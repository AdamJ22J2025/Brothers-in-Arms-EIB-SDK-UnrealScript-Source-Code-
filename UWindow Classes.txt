class UWindowBase extends Interaction
	poolable( 20, 0 );



// Fonts array constants
const F_Normal = 0;			// Normal font
const F_Bold = 1;			// Bold font

struct Region
{
	var() int X;
	var() int Y;
	var() int W;
	var() int H;
};

struct TexRegion
{
	var() int X;
	var() int Y;
	var() int W;
	var() int H;
	var() Texture T;
};

enum TextAlign
{
	TA_Left,
	TA_Right,
	TA_Center
};

enum FrameHitTest
{
	HT_NW,
	HT_N,
	HT_NE,
	HT_W,
	HT_E,
	HT_SW,
	HT_S,
	HT_SE,
	HT_TitleBar,
	HT_DragHandle,
	HT_None
};

enum MenuSound
{
	MS_MenuPullDown,
	MS_MenuCloseUp,
	MS_MenuItem,
	MS_WindowOpen,
	MS_WindowClose,
	MS_ChangeTab
};

enum MessageBoxButtons
{
	MB_YesNo,
	MB_OKCancel,
	MB_OK,
	MB_YesNoCancel
};

enum MessageBoxResult
{
	MR_None,
	MR_Yes,
	MR_No,
	MR_OK,
	MR_Cancel	// also if you press the Close box.
};

enum PropertyCondition
{
	PC_None,
	PC_LessThan,
	PC_Equal,
	PC_GreaterThan,
	PC_NotEqual,
	PC_Contains,
	PC_NotContains
};

struct HTMLStyle
{
	var int BulletLevel;			// 0 = no bullet depth
	var string LinkDestination;
	var Color TextColor;
	var Color BGColor;
	var bool bCenter;
	var bool bLink;
	var bool bUnderline;
	var bool bNoBR;
	var bool bHeading;
	var bool bBold;
	var bool bBlink;
};

function Region NewRegion(float X, float Y, float W, float H)
{
	local Region R;
	R.X = X;
	R.Y = Y;
	R.W = W;
	R.H = H;
	return R;
}

function TexRegion NewTexRegion(float X, float Y, float W, float H, Texture T)
{
	local TexRegion R;
	R.X = X;
	R.Y = Y;
	R.W = W;
	R.H = H;
	R.T = T;
	return R;
}

function Region GetRegion(TexRegion T)
{
	local Region R;

	R.X = T.X;
	R.Y = T.Y;
	R.W = T.W;
	R.H = T.H;

	return R;
}

static function int InStrAfter(string Text, string Match, int Pos)
{
	local int i;

	i = InStr(Mid(Text, Pos), Match);
	if(i != -1)
		return i + Pos;
	return -1;
}

static function Object BuildObjectWithProperties(string Text)
{
	local int i;
	local string ObjectClass, PropertyName, PropertyValue, Temp;
	local class<Object> C;
	local Object O;

	i = InStr(Text, ",");
	if(i == -1)
	{
		ObjectClass=Text;
		Text="";
	}
	else
	{
		ObjectClass=Left(Text, i);
		Text=Mid(Text, i+1);
	}

	//Log("Class: "$ObjectClass);

	C = class<Object>(DynamicLoadObject(ObjectClass, class'Class'));
	O = new( None ) C;

	while(Text != "")
	{
		i = InStr(Text, "=");
		if(i == -1)
		{
			Log("Missing value for property "$ObjectClass$"."$Text);
			PropertyName=Text;
			PropertyValue="";
		}
		else
		{
			PropertyName=Left(Text, i);
			Text=Mid(Text, i+1);
		}

		if(Left(Text, 1) == "\"")
		{
			i = InStrAfter(Text, "\"", 1);
			if(i == -1)
			{
				Log("Missing quote for "$ObjectClass$"."$PropertyName);
				return O;
			}
			PropertyValue = Mid(Text, 1, i-1);

			Temp = Mid(Text, i+1, 1);
			if(Temp != "" && Temp != ",")
				Log("Missing comma after close quote for "$ObjectClass$"."$PropertyName);
			Text = Mid(Text, i+2);
		}
		else
		{
			i = InStr(Text, ",");
			if(i == -1)
			{
				PropertyValue=Text;
				Text="";
			}
			else
			{
				PropertyValue=Left(Text, i);
				Text=Mid(Text, i+1);
			}
		}

		//Log("Property: "$PropertyName$" => "$PropertyValue);
		O.SetPropertyText(PropertyName, PropertyValue);
	}

	return O;
}
class UWindowBitmap extends UWindowWindow;



var Texture T;
var Region	R;
var bool	bStretch;
var bool	bCenter;


function Paint(Canvas C, float X, float Y)
{
	if(bStretch)
	{
		DrawStretchedTextureSegment(C, 0, 0, WinWidth, WinHeight, R.X, R.Y, R.W, R.H, T);
	}
	else
	{
		if(bCenter)
		{
			DrawStretchedTextureSegment(C, (WinWidth - R.W)/2, (WinHeight - R.H)/2, R.W, R.H, R.X, R.Y, R.W, R.H, T);
		}
		else
		{
			DrawStretchedTextureSegment(C, 0, 0, R.W, R.H, R.X, R.Y, R.W, R.H, T);
		}
	}
}
//=============================================================================
// UWindowButton - A button
//=============================================================================
class UWindowButton extends UWindowDialogControl;



var bool		bDisabled;
var bool		bStretched;
var texture		UpTexture, DownTexture, DisabledTexture, OverTexture;
var Region		UpRegion,  DownRegion,  DisabledRegion,  OverRegion;
var bool		bUseRegion;
var float		RegionScale;
var string		ToolTipString;
var float		ImageX, ImageY;
var sound		OverSound, DownSound;

function Created()
{
	Super.Created();

	ImageX = 0;
	ImageY = 0;
	TextX = 0;
	TextY = 0;
	RegionScale = 1;
}

function BeforePaint(Canvas C, float X, float Y)
{
	C.Font = Root.Fonts[Font];
}

function Paint(Canvas C, float X, float Y)
{
	C.Font = Root.Fonts[Font];

	if(bDisabled) {
		if(DisabledTexture != None)
		{
			if(bUseRegion)
				DrawStretchedTextureSegment( C, ImageX, ImageY, DisabledRegion.W*RegionScale, DisabledRegion.H*RegionScale,
											DisabledRegion.X, DisabledRegion.Y,
											DisabledRegion.W, DisabledRegion.H, DisabledTexture );
			else if(bStretched)
				DrawStretchedTexture( C, ImageX, ImageY, WinWidth, WinHeight, DisabledTexture );
			else
				DrawClippedTexture( C, ImageX, ImageY, DisabledTexture);
		}
	} else {
		if(bMouseDown)
		{
			if(DownTexture != None)
			{
				if(bUseRegion)
					DrawStretchedTextureSegment( C, ImageX, ImageY, DownRegion.W*RegionScale, DownRegion.H*RegionScale,
												DownRegion.X, DownRegion.Y,
												DownRegion.W, DownRegion.H, DownTexture );
				else if(bStretched)
					DrawStretchedTexture( C, ImageX, ImageY, WinWidth, WinHeight, DownTexture );
				else
					DrawClippedTexture( C, ImageX, ImageY, DownTexture);
			}
		} else {
			if(MouseIsOver()) {
				if(OverTexture != None)
				{
					if(bUseRegion)
						DrawStretchedTextureSegment( C, ImageX, ImageY, OverRegion.W*RegionScale, OverRegion.H*RegionScale,
													OverRegion.X, OverRegion.Y,
													OverRegion.W, OverRegion.H, OverTexture );
					else if(bStretched)
						DrawStretchedTexture( C, ImageX, ImageY, WinWidth, WinHeight, OverTexture );
					else
						DrawClippedTexture( C, ImageX, ImageY, OverTexture);
				}
			} else {
				if(UpTexture != None)
				{
					if(bUseRegion)
						DrawStretchedTextureSegment( C, ImageX, ImageY, UpRegion.W*RegionScale, UpRegion.H*RegionScale,
													UpRegion.X, UpRegion.Y,
													UpRegion.W, UpRegion.H, UpTexture );
					else if(bStretched)
						DrawStretchedTexture( C, ImageX, ImageY, WinWidth, WinHeight, UpTexture );
					else
						DrawClippedTexture( C, ImageX, ImageY, UpTexture);
				}
			}
		}
	}

	if(Text != "")
	{
		C.DrawColor=TextColor;
		ClipText(C, TextX, TextY, Text, True);
		C.SetDrawColor(255,255,255);
	}
}

function MouseLeave()
{
	Super.MouseLeave();
	if(ToolTipString != "") ToolTip("");
}

simulated function MouseEnter()
{
	Super.MouseEnter();
	if(ToolTipString != "") ToolTip(ToolTipString);
	if (!bDisabled && (OverSound != None))
		GetPlayerOwner().PlaySound(OverSound, SLOT_Interface);
}

simulated function Click(float X, float Y)
{
	Notify(DE_Click);
	if (!bDisabled && (DownSound != None))
		GetPlayerOwner().PlaySound(DownSound, SLOT_Interact);
}

function DoubleClick(float X, float Y)
{
	Notify(DE_DoubleClick);
}

function RClick(float X, float Y)
{
	Notify(DE_RClick);
}

function MClick(float X, float Y)
{
	Notify(DE_MClick);
}

function KeyDown(int Key, float X, float Y)
{
	local PlayerController P;

	P = Root.GetPlayerOwner();

	switch (Key)
	{
	case P.Player.Console.EInputKey.IK_Space:
		LMouseDown(X, Y);
		LMouseUp(X, Y);
		break;
	default:
		Super.KeyDown(Key, X, Y);
		break;
	}
}

defaultproperties
{
	bIgnoreLDoubleClick=True
	bIgnoreMDoubleClick=True
	bIgnoreRDoubleClick=True
}
//=============================================================================
// UWindowCheckbox - a checkbox
//=============================================================================
class UWindowCheckbox extends UWindowButton;



var bool		bChecked;

function BeforePaint(Canvas C, float X, float Y)
{
	LookAndFeel.Checkbox_SetupSizes(Self, C);
	Super.BeforePaint(C, X, Y);
}

function Paint(Canvas C, float X, float Y)
{
	LookAndFeel.Checkbox_Draw(Self, C);
	Super.Paint(C, X, Y);
}


function LMouseUp(float X, float Y)
{
	if(!bDisabled)
	{
		bChecked = !bChecked;
		Notify(DE_Change);
	}

	Super.LMouseUp(X, Y);
}
//=============================================================================
// UWindowClientWindow - a blanked client-area window.
//=============================================================================
class UWindowClientWindow extends UWindowWindow;



#exec TEXTURE IMPORT FILE=Textures\Background.tga GROUP="Icons" MIPS=OFF COMPRESS=DXT1


function Close(optional bool bByParent)
{
	if(!bByParent)
		ParentWindow.Close(bByParent);

	Super.Close(bByParent);
}
class UWindowComboButton extends UWindowButton;



var UWindowComboControl Owner;

function BeforePaint(Canvas C, float X, float Y)
{
	LookAndFeel.Combo_GetButtonBitmaps(Self);

	bMouseDown = Owner.bListVisible;
}

function LMouseDown(float X, float Y)
{
	if(!bDisabled)
	{
		if(Owner.bListVisible)
			Owner.CloseUp();
		else
		{
			Owner.DropDown();
			Root.CaptureMouse(Owner.List);
		}
	}
}

function Click(float X, float Y)
{
}

function FocusOtherWindow(UWindowWindow W)
{
	Super.FocusOtherWindow(W);

	if(Owner.bListVisible && W.ParentWindow != Owner && W.ParentWindow != Owner.List && W.ParentWindow.ParentWindow != Owner.List)
		Owner.CloseUp();
}

defaultproperties
{
	bNoKeyboard=True
}
class UWindowComboControl extends UWindowDialogControl;



var	float				EditBoxWidth;
var float				EditAreaDrawX, EditAreaDrawY;

var UWindowEditBox		EditBox;
var UWindowComboButton	Button;
var UWindowComboLeftButton LeftButton;
var UWindowComboRightButton RightButton;

var class<UWindowComboList>	ListClass;
var UWindowComboList	List;

var bool				bListVisible;
var bool				bCanEdit;
var bool				bButtons;

function Created()
{
	Super.Created();

	EditBox = UWindowEditBox(CreateWindow(class'UWindowEditBox', 0, 0, WinWidth-12, WinHeight));
	EditBox.NotifyOwner = Self;
	EditBoxWidth = WinWidth / 2;
	EditBox.bTransient = True;

	Button = UWindowComboButton(CreateWindow(class'UWindowComboButton', WinWidth-12, 0, 12, 10));
	Button.Owner = Self;

	List = UWindowComboList(Root.CreateWindow(ListClass, 0, 0, 100, 100));
	List.LookAndFeel = LookAndFeel;
	List.Owner = Self;
	List.Setup();

	List.HideWindow();
	bListVisible = False;

	SetEditTextColor(LookAndFeel.EditBoxTextColor);
}

function SetButtons(bool bInButtons)
{
	bButtons = bInButtons;
	if(bInButtons)
	{
		LeftButton = UWindowComboLeftButton(CreateWindow(class'UWindowComboLeftButton', WinWidth-12, 0, 12, 10));
		RightButton = UWindowComboRightButton(CreateWindow(class'UWindowComboRightButton', WinWidth-12, 0, 12, 10));
	}
	else
	{
		LeftButton = None;
		RightButton = None;
	}
}

function Notify(byte E)
{
	Super.Notify(E);

	if(E == DE_LMouseDown)
	{
		if(!bListVisible)
		{
			if(!bCanEdit)
			{
				DropDown();
				Root.CaptureMouse(List);
			}
		}
		else
			CloseUp();
	}
}

function int FindItemIndex(string V, optional bool bIgnoreCase)
{
	return List.FindItemIndex(V, bIgnoreCase);
}

function RemoveItem(int Index)
{
	List.RemoveItem(Index);
}

function int FindItemIndex2(string V2, optional bool bIgnoreCase)
{
	return List.FindItemIndex2(V2, bIgnoreCase);
}

function Close(optional bool bByParent)
{
	if(bByParent && bListVisible)
		CloseUp();

	Super.Close(bByParent);
}

function SetNumericOnly(bool bNumericOnly)
{
	EditBox.bNumericOnly = bNumericOnly;
}

function SetNumericFloat(bool bNumericFloat)
{
	EditBox.bNumericFloat = bNumericFloat;
}

function SetFont(int NewFont)
{
	Super.SetFont(NewFont);
	EditBox.SetFont(NewFont);
}

function SetEditTextColor(Color NewColor)
{
	EditBox.SetTextColor(NewColor);
}

function SetEditable(bool bNewCanEdit)
{
	bCanEdit = bNewCanEdit;
	EditBox.SetEditable(bCanEdit);
}

function int GetSelectedIndex()
{
	return List.FindItemIndex(GetValue());
}

function SetSelectedIndex(int Index)
{
	SetValue(List.GetItemValue(Index), List.GetItemValue2(Index));
}

function string GetValue()
{
	return EditBox.GetValue();
}

function string GetValue2()
{
	return EditBox.GetValue2();
}

function SetValue(string NewValue, optional string NewValue2)
{
	EditBox.SetValue(NewValue, NewValue2);
	UWindowDialogClientWindow(OwnerWindow).Notify(self, DE_Change);
}

function SetMaxLength(int MaxLength)
{
	EditBox.MaxLength = MaxLength;
}

function Paint(Canvas C, float X, float Y)
{
	LookAndFeel.Combo_Draw(Self, C);
	Super.Paint(C, X, Y);
}

function AddItem(string S, optional string S2, optional int SortWeight)
{
	List.AddItem(S, S2, SortWeight);
}

function InsertItem(string S, optional string S2, optional int SortWeight)
{
	List.InsertItem(S, S2, SortWeight);
}

function BeforePaint(Canvas C, float X, float Y)
{
	Super.BeforePaint(C, X, Y);
	LookAndFeel.Combo_SetupSizes(Self, C);
	List.bLeaveOnscreen = bListVisible && bLeaveOnscreen;
}

function CloseUp()
{
	bListVisible = False;
	EditBox.SetEditable(bCanEdit);
	EditBox.SelectAll();
	List.HideWindow();
}

function DropDown()
{
	bListVisible = True;
	EditBox.SetEditable(False);
	List.ShowWindow();
}

function Sort()
{
	List.Sort();
}

function ClearValue()
{
	EditBox.Clear();
}

function Clear()
{
	List.Clear();
	EditBox.Clear();
}

function FocusOtherWindow(UWindowWindow W)
{
	Super.FocusOtherWindow(W);

	if(bListVisible && W.ParentWindow != Self && W != List && W.ParentWindow != List)
		CloseUp();
}

defaultproperties
{
	ListClass=class'UWindowComboList'
	bNoKeyboard=True
}
class UWindowComboLeftButton extends UWindowButton;



function BeforePaint(Canvas C, float X, float Y)
{
	LookAndFeel.Combo_SetupLeftButton(Self);
}

function LMouseDown(float X, float Y)
{
	local int i;

	Super.LMouseDown(X, Y);
	if(!bDisabled)
	{
		i = UWindowComboControl(OwnerWindow).GetSelectedIndex();
		i--;
		if(i < 0)
			i = UWindowComboControl(OwnerWindow).List.Items.Count() - 1;
		UWindowComboControl(OwnerWindow).SetSelectedIndex(i);
	}
}

defaultproperties
{
	bNoKeyboard=True
}
class UWindowComboList extends UWindowListControl;



var UWindowComboControl		Owner;
var UWindowVScrollBar		VertSB;
var UWindowComboListItem	Selected;
var int ItemHeight;
var int VBorder;
var int HBorder;
var int TextBorder;
var int MaxVisible;

function Sort()
{
	Items.Sort();
}

function WindowShown()
{
	Super.WindowShown();
	FocusWindow();
}

function Clear()
{
	Items.Clear();
}

function Texture GetLookAndFeelTexture()
{
	return LookAndFeel.Active;
}

function Setup()
{
	VertSB = UWindowVScrollBar(CreateWindow(class'UWindowVScrollBar', 0, WinWidth - 16, 16, WinHeight));
}

function Created()
{
	ListClass = class'UWindowComboListItem';
	bAlwaysOnTop = True;
	bTransient = True;
	Super.Created();
	ItemHeight = 15;
	VBorder = 3;
	HBorder = 3;
	TextBorder = 9;

	Super.Created();
}

function int FindItemIndex(string Value, optional bool bIgnoreCase)
{
	local UWindowComboListItem I;
	local int Count;

	I = UWindowComboListItem(Items.Next);
	Count = 0;

	while(I != None)
	{
		if(bIgnoreCase && I.Value ~= Value) return Count;
		if(I.Value == Value) return Count;

		Count++;
		I = UWindowComboListItem(I.Next);
	}

	return -1;
}

function int FindItemIndex2(string Value2, optional bool bIgnoreCase)
{
	local UWindowComboListItem I;
	local int Count;

	I = UWindowComboListItem(Items.Next);
	Count = 0;

	while(I != None)
	{
		if(bIgnoreCase && I.Value2 ~= Value2) return Count;
		if(I.Value2 == Value2) return Count;

		Count++;
		I = UWindowComboListItem(I.Next);
	}

	return -1;
}

function string GetItemValue(int Index)
{
	local UWindowComboListItem I;
	local int Count;

	I = UWindowComboListItem(Items.Next);
	Count = 0;

	while(I != None)
	{
		if(Count == Index) return I.Value;

		Count++;
		I = UWindowComboListItem(I.Next);
	}

	return "";
}

function RemoveItem(int Index)
{
	local UWindowComboListItem I;
	local int Count;

	if(Index == -1)
		return;

	I = UWindowComboListItem(Items.Next);
	Count = 0;

	while(I != None)
	{
		if(Count == Index)
		{
			I.Remove();
			return;
		}

		Count++;
		I = UWindowComboListItem(I.Next);
	}
}

function string GetItemValue2(int Index)
{
	local UWindowComboListItem I;
	local int Count;

	I = UWindowComboListItem(Items.Next);
	Count = 0;

	while(I != None)
	{
		if(Count == Index) return I.Value2;

		Count++;
		I = UWindowComboListItem(I.Next);
	}

	return "";
}

function AddItem(string Value, optional string Value2, optional int SortWeight)
{
	local UWindowComboListItem I;
	I = UWindowComboListItem(Items.Append(class'UWindowComboListItem'));
	I.Value = Value;
	I.Value2 = Value2;
	I.SortWeight = SortWeight;
}

function InsertItem(string Value, optional string Value2, optional int SortWeight)
{
	local UWindowComboListItem I;
	I = UWindowComboListItem(Items.Insert(class'UWindowComboListItem'));
	I.Value = Value;
	I.Value2 = Value2;
	I.SortWeight = SortWeight;
}

function SetSelected(float X, float Y)
{
	local UWindowComboListItem NewSelected, Item;
	local int i, Count;

	Count = 0;
	for( Item = UWindowComboListItem(Items.Next);Item != None; Item = UWindowComboListItem(Item.Next) )
		Count++;

	i = (Y - VBorder) / ItemHeight + VertSB.Pos;

	if(i < 0)
		i = 0;

	if(i >= VertSB.Pos + Min(Count, MaxVisible))
		i = VertSB.Pos + Min(Count, MaxVisible) - 1;

	NewSelected = UWindowComboListItem(Items.FindEntry(i));

	if(NewSelected != Selected)
	{
		if(NewSelected == None)
			Selected = None;
		else
			Selected = NewSelected;
	}
}

function MouseMove(float X, float Y)
{
	Super.MouseMove(X, Y);
	if(Y > WinHeight) VertSB.Scroll(1);
	if(Y < 0) VertSB.Scroll(-1);

	SetSelected(X, Y);

	FocusWindow();
}

function LMouseUp(float X, float Y)
{
	If(Y >= 0 && Y <= WinHeight && Selected != None)
	{
		ExecuteItem(Selected);
	}
	Super.LMouseUp(X, Y);
}

function LMouseDown(float X, float Y)
{
	Root.CaptureMouse();
}

function BeforePaint(Canvas C, float X, float Y)
{
	local float W, H, MaxWidth;
	local int Count;
	local UWindowComboListItem I;
	local float ListX, ListY;
	local float ExtraWidth;

	C.Font = Root.Fonts[F_Normal];
	C.SetPos(0, 0);

	MaxWidth = Owner.EditBoxWidth;
	ExtraWidth = ((HBorder + TextBorder) * 2);

	Count = Items.Count();
	if(Count > MaxVisible)
	{
		ExtraWidth += LookAndFeel.Size_ScrollbarWidth;
		WinHeight = (ItemHeight * MaxVisible) + (VBorder * 2);
	}
	else
	{
		VertSB.Pos = 0;
		WinHeight = (ItemHeight * Count) + (VBorder * 2);
	}

	for( I = UWindowComboListItem(Items.Next);I != None; I = UWindowComboListItem(I.Next) )
	{
		TextSize(C, RemoveAmpersand(I.Value), W, H);
		if(W + ExtraWidth > MaxWidth)
			MaxWidth = W + ExtraWidth;
	}

	WinWidth = MaxWidth;

	ListX = Owner.EditAreaDrawX + Owner.EditBoxWidth - WinWidth;
	ListY = Owner.Button.WinTop + Owner.Button.WinHeight;

	if(Count > MaxVisible)
	{
		VertSB.ShowWindow();
		VertSB.SetRange(0, Count, MaxVisible);
		VertSB.WinLeft = WinWidth - LookAndFeel.Size_ScrollbarWidth - HBorder;
		VertSB.WinTop = HBorder;
		VertSB.WinWidth = LookAndFeel.Size_ScrollbarWidth;
		VertSB.WinHeight = WinHeight - 2*VBorder;
	}
	else
	{
		VertSB.HideWindow();
	}

	Owner.WindowToGlobal(ListX, ListY, WinLeft, WinTop);
}

function Paint(Canvas C, float X, float Y)
{
	local int Count;
	local UWindowComboListItem I;

	DrawMenuBackground(C);

	Count = 0;

	for( I = UWindowComboListItem(Items.Next);I != None; I = UWindowComboListItem(I.Next) )
	{
		if(VertSB.bWindowVisible)
		{
			if(Count >= VertSB.Pos)
				DrawItem(C, I, HBorder, VBorder + (ItemHeight * (Count - VertSB.Pos)), WinWidth - (2 * HBorder) - VertSB.WinWidth, ItemHeight);
		}
		else
			DrawItem(C, I, HBorder, VBorder + (ItemHeight * Count), WinWidth - (2 * HBorder), ItemHeight);
		Count++;
	}
}

function DrawMenuBackground(Canvas C)
{
	LookAndFeel.ComboList_DrawBackground(Self, C);
}

function DrawItem(Canvas C, UWindowList Item, float X, float Y, float W, float H)
{
	LookAndFeel.ComboList_DrawItem(Self, C, X, Y, W, H, UWindowComboListItem(Item).Value, Selected == Item);
}

function ExecuteItem(UWindowComboListItem I)
{
	Owner.SetValue(I.Value, I.Value2);
	CloseUp();
}

function CloseUp()
{
	Owner.CloseUp();
}

function FocusOtherWindow(UWindowWindow W)
{
	Super.FocusOtherWindow(W);

	if(bWindowVisible && W.ParentWindow.ParentWindow != Self && W.ParentWindow != Self && W.ParentWindow != Owner)
		CloseUp();
}

defaultproperties
{
	MaxVisible=10
}
class UWindowComboListItem extends UWindowList;



var string					Value;
var string					Value2;		// A second, non-displayed value
var int						SortWeight;

var float					ItemTop;

function int Compare(UWindowList T, UWindowList B)
{
	local UWindowComboListItem TI, BI;
	local string TS, BS;

	TI = UWindowComboListItem(T);
	BI = UWindowComboListItem(B);

	if(TI.SortWeight == BI.SortWeight)
	{
		TS = caps(TI.Value);
		BS = caps(BI.Value);

		if(TS == BS)
			return 0;

		if(TS < BS)
			return -1;

		return 1;

	}
	else
		return TI.SortWeight - BI.SortWeight;
}
class UWindowComboRightButton extends UWindowButton;



function BeforePaint(Canvas C, float X, float Y)
{
	LookAndFeel.Combo_SetupRightButton(Self);
}

function LMouseDown(float X, float Y)
{
	local int i;

	Super.LMouseDown(X, Y);
	if(!bDisabled)
	{
		i = UWindowComboControl(OwnerWindow).GetSelectedIndex();
		i++;
		if(i >= UWindowComboControl(OwnerWindow).List.Items.Count())
			i = 0;
		UWindowComboControl(OwnerWindow).SetSelectedIndex(i);
	}
}

defaultproperties
{
	bNoKeyboard=True
}
class UWindowConsoleClientWindow extends UWindowDialogClientWindow;



var UWindowConsoleTextAreaControl TextArea;
var UWindowEditControl	EditControl;

function Created()
{
	TextArea = UWindowConsoleTextAreaControl(CreateWindow(class'UWindowConsoleTextAreaControl', 0, 0, WinWidth, WinHeight));

	EditControl = UWindowEditControl(CreateControl(class'UWindowEditControl', 0, WinHeight-16, WinWidth, 16));
	EditControl.SetValue("Test");
	EditControl.SetNumericOnly(False);
	EditControl.SetMaxLength(400);
	EditControl.SetHistory(True);
	Cursor = Root.NormalCursor;
}

function Notify(UWindowDialogControl C, byte E)
{
	local string s;
	Super.Notify(C, E);

	switch(E)
	{
	case DE_EnterPressed:
		switch(C)
		{
		case EditControl:
			if(EditControl.GetValue() != "")
			{
				s = EditControl.GetValue();

				Message( "> "$s, 6.0 );
				EditControl.Clear();
				if( !Root.ConsoleCommand( s ) )
					Message( Localize("Errors","Exec","Core"), 6.0 );
			}
			break;
		}
		break;
	case DE_WheelUpPressed:
		switch(C)
		{
		case EditControl:
			TextArea.VertSB.Scroll(-1);
			break;
		}
		break;
	case DE_WheelDownPressed:
		switch(C)
		{
		case EditControl:
			TextArea.VertSB.Scroll(1);
			break;
		}
		break;
	}
}

function BeforePaint(Canvas C, float X, float Y)
{
	Super.BeforePaint(C, X, Y);

	EditControl.SetSize(WinWidth, 17);
	EditControl.WinLeft = 0;
	EditControl.WinTop = WinHeight - EditControl.WinHeight;
	EditControl.EditBoxWidth = WinWidth;

	TextArea.SetSize(WinWidth, WinHeight - EditControl.WinHeight);
}

function Paint(Canvas C, float X, float Y)
{
	DrawStretchedTexture(C, 0, 0, WinWidth, WinHeight, Texture'BlackTexture');
}

function Message( coerce string Msg, float MsgLife )
{
	Super.Message( Msg, MsgLife );

	if ( Msg!="" )
		TextArea.AddText(Msg);
}

class UWindowConsoleTextAreaControl extends UWindowDynamicTextArea;



defaultproperties
{
	bScrollOnResize=True
	bVariableRowHeight=False
	bTopCentric=False
	MaxLines=500
}
class UWindowConsoleWindow extends UWindowFramedWindow;



var float OldParentWidth, OldParentHeight;
var bool bIsResizing;

function Created()
{
	Super.Created();
	bSizable = True;
	bStatusBar = True;
	bLeaveOnScreen = True;

	OldParentWidth = ParentWindow.WinWidth;
	OldParentHeight = ParentWindow.WinHeight;

	SetDimensions();

	SetAcceptsFocus();
}

function ShowWindow()
{
	Super.ShowWindow();

	if(ParentWindow.WinWidth != OldParentWidth || ParentWindow.WinHeight != OldParentHeight)
	{
		SetDimensions();
		OldParentWidth = ParentWindow.WinWidth;
		OldParentHeight = ParentWindow.WinHeight;
	}
}

function ResolutionChanged(float W, float H)
{
	SetDimensions();
}

function SetDimensions()
{
	if (bIsResizing)
		return;

	bIsResizing = true;  // prevent recursion crashing problem

	if (Root.bIsConsole)
	{
		SetSize(250, 180);

		// switch to smaller fonts if in split screen mode
//		if ((Root.RealWidth < 640) || (Root.RealHeight < 480))
//			Root.SetScale(1);
	}
	else
		SetSize(410, 310);

	WinLeft = ParentWindow.WinWidth/2 - WinWidth/2;
	WinTop = ParentWindow.WinHeight/2 - WinHeight/2;

	bIsResizing = false;
}

function Close(optional bool bByParent)
{
	ClientArea.Close(True);
	Root.GotoState('');
}

defaultproperties
{
	WindowTitle="Game Console";
	ClientClass=class'UWindowConsoleClientWindow'
}
class UWindowControlFrame extends UWindowWindow;



var UWindowWindow Framed;

function SetFrame(UWindowWindow W)
{
	Framed = W;
	W.SetParent(Self);
}

function BeforePaint(Canvas C, float X, float Y)
{
	if(Framed != None)
		LookAndFeel.ControlFrame_SetupSizes(Self, C);
}

function Paint(Canvas C, float X, float Y)
{
	LookAndFeel.ControlFrame_Draw(Self, C);
}
class UWindowDialogClientWindow extends UWindowClientWindow;




// Used for scrolling
var float DesiredWidth;
var float DesiredHeight;

var UWindowDialogControl	TabLast;

function OKPressed()
{
}

function Notify(UWindowDialogControl C, byte E)
{
	// Handle this notification in a subclass.
}

function UWindowDialogControl CreateControl(class<UWindowDialogControl> ControlClass, float X, float Y, float W, float H, optional UWindowWindow OwnerWindow)
{
	local UWindowDialogControl C;

	C = UWindowDialogControl(CreateWindow(ControlClass, X, Y, W, H, OwnerWindow));
	C.Register(Self);
	C.Notify(C.DE_Created);

	if(TabLast == None)
	{
		TabLast = C;
		C.TabNext = C;
		C.TabPrev = C;
	}
	else
	{
		C.TabNext = TabLast.TabNext;
		C.TabPrev = TabLast;
		TabLast.TabNext.TabPrev = C;
		TabLast.TabNext = C;

		TabLast = C;
	}

	return C;
}

function Paint(Canvas C, float X, float Y)
{
	Super.Paint(C, X, Y);
	LookAndFeel.DrawClientArea(Self, C);
}


function GetDesiredDimensions(out float W, out float H)
{
	W = DesiredWidth;
	H = DesiredHeight;
}
//=============================================================================
// UWindowDialogControl - a control which notifies a dialog control group
//=============================================================================
class UWindowDialogControl extends UWindowWindow;



var UWindowDialogClientWindow	NotifyWindow;
var string Text;
var int Font;
var color TextColor;
var TextAlign Align;
var float TextX, TextY;		// changed by BeforePaint functions
var bool bHasKeyboardFocus;
var bool bNoKeyboard;
var bool bAcceptExternalDragDrop;
var string HelpText;
var float MinWidth, MinHeight;	// minimum heights for layout control

var UWindowDialogControl	TabNext;
var UWindowDialogControl	TabPrev;


function Created()
{
	if(!bNoKeyboard)
		SetAcceptsFocus();
}

function KeyFocusEnter()
{
	Super.KeyFocusEnter();
	bHasKeyboardFocus = True;
}

function KeyFocusExit()
{
	Super.KeyFocusExit();
	bHasKeyboardFocus = False;
}

function SetHelpText(string NewHelpText)
{
	HelpText = NewHelpText;
}

function SetText(string NewText)
{
	Text = NewText;
}

function BeforePaint(Canvas C, float X, float Y)
{
	Super.BeforePaint(C, X, Y);

	C.Font = Root.Fonts[Font];
}

function SetFont(int NewFont)
{
	Font = NewFont;
}

function SetTextColor(color NewColor)
{
	TextColor = NewColor;
}


function Register(UWindowDialogClientWindow	W)
{
	NotifyWindow = W;
	Notify(DE_Created);
}

function Notify(byte E)
{
	if(NotifyWindow != None)
	{
		NotifyWindow.Notify(Self, E);
	}
}

function bool ExternalDragOver(UWindowDialogControl ExternalControl, float X, float Y)
{
	return False;
}

function UWindowDialogControl CheckExternalDrag(float X, float Y)
{
	local float RootX, RootY;
	local float ExtX, ExtY;
	local UWindowWindow W;
	local UWindowDialogControl C;

	WindowToGlobal(X, Y, RootX, RootY);
	W = Root.FindWindowUnder(RootX, RootY);
	C = UWindowDialogControl(W);

	if(W != Self && C != None && C.bAcceptExternalDragDrop)
	{
		W.GlobalToWindow(RootX, RootY, ExtX, ExtY);
		if(C.ExternalDragOver(Self, ExtX, ExtY))
			return C;
	}

	return None;
}

function KeyDown(int Key, float X, float Y)
{
	local PlayerController P;
	local UWindowDialogControl N;

	P = Root.GetPlayerOwner();

	switch (Key)
	{
	case P.Player.Console.EInputKey.IK_Tab:

		if(TabNext != None)
		{
			N = TabNext;
			while(N != Self && !N.bWindowVisible)
				N = N.TabNext;

			N.ActivateWindow(0, False);
		}
		break;
	default:
		Super.KeyDown(Key, X, Y);
		break;
	}

}

function MouseMove(float X, float Y)
{
	Super.MouseMove(X, Y);
	Notify(DE_MouseMove);
}

function MouseEnter()
{
	Super.MouseEnter();
	Notify(DE_MouseEnter);
}

function MouseLeave()
{
	Super.MouseLeave();
	Notify(DE_MouseLeave);
}

defaultproperties
{
	TextColor=(R=0,G=0,B=0,A=255)
}
class UWindowDynamicTextArea extends UWindowDialogControl;



var config int MaxLines;

var bool bTopCentric;
var float DefaultTextHeight;
var bool bScrollOnResize;
var bool bVCenter;
var bool bHCenter;
var bool bAutoScrollbar;
var bool bVariableRowHeight;	// Assumes !bTopCentric, !bScrollOnResize
var float WrapWidth;

// private
var UWindowDynamicTextRow List;
var UWindowVScrollBar VertSB;
var float OldW, OldH;
var bool bDirty;
var int Count;
var int VisibleRows;
var Font AbsoluteFont;
var class<UWindowDynamicTextRow> RowClass;

function Created()
{
	Super.Created();

	VertSB = UWindowVScrollbar(CreateWindow(class'UWindowVScrollbar', WinWidth-12, 0, 12, WinHeight));
	VertSB.bAlwaysOnTop = True;
	Cursor = Root.NormalCursor;

	Clear();
}

function Clear()
{
	bDirty = True;

	if(List != None)
	{
		if(List.Next == None)
			return;
		List.DestroyList();
	}

	List = new( None ) RowClass;
	List.SetupSentinel();
}

function SetAbsoluteFont(Font F)
{
	AbsoluteFont = F;
}

function SetFont(int F)
{
	Font = F;
}

function SetTextColor(Color C)
{
	TextColor = C;
}

function TextAreaClipText(Canvas C, float DrawX, float DrawY, coerce string S, optional bool bCheckHotkey)
{
	ClipText(C, DrawX, DrawY, S, bCheckHotkey);
}

function TextAreaTextSize(Canvas C, string Text, out float W, out float H)
{
	TextSize(C, Text, W, H);
}

function BeforePaint( Canvas C, float X, float Y )
{
	Super.BeforePaint(C, X, Y);

	VertSB.WinTop = 0;
	VertSB.WinHeight = WinHeight;
	VertSB.WinWidth = LookAndFeel.Size_ScrollbarWidth;
	VertSB.WinLeft = WinWidth - LookAndFeel.Size_ScrollbarWidth;
}

function Paint( Canvas C, float MouseX, float MouseY )
{
	local UWindowDynamicTextRow L;
	local int SkipCount, DrawCount;
	local int i;
	local float Y, Junk;
	local bool bWrapped;

	C.DrawColor = TextColor;

	if(AbsoluteFont != None)
		C.Font = AbsoluteFont;
	else
		C.Font = Root.Fonts[Font];

	if(OldW != WinWidth || OldH != WinHeight)
	{
		WordWrap(C, True);
		OldW = WinWidth;
		OldH = WinHeight;
		bWrapped = True;
	}
	else
	if(bDirty)
	{
		WordWrap(C, False);
		bWrapped = True;
	}

	if(bWrapped)
	{
		TextAreaTextSize(C, "A", Junk, DefaultTextHeight);
		VisibleRows = WinHeight / DefaultTextHeight;
		Count = List.Count();
		VertSB.SetRange(0, Count, VisibleRows);

		if(bScrollOnResize)
		{
			if(bTopCentric)
				VertSB.Pos = 0;
			else
				VertSB.Pos = VertSB.MaxPos;
		}

		if(bAutoScrollbar && !bVariableRowHeight)
		{
			if(Count <= VisibleRows)
				VertSB.HideWindow();
			else
				VertSB.ShowWindow();
		}
	}

	if(bTopCentric)
	{
		SkipCount = VertSB.Pos;
		L = UWindowDynamicTextRow(List.Next);
		for(i=0; i < SkipCount && (L != None) ; i++)
			L = UWindowDynamicTextRow(L.Next);

		if(bVCenter && Count <= VisibleRows)
			Y = int((WinHeight - (Count * DefaultTextHeight)) / 2);
		else
			Y = 1;

		DrawCount = 0;
		while(Y < WinHeight)
		{
			DrawCount++;
			if(L != None)
			{
				Y += DrawTextLine(C, L, Y);
				L = UWindowDynamicTextRow(L.Next);
			}
			else
				Y += DefaultTextHeight;
		}

		if(bVariableRowHeight)
		{
			VisibleRows = DrawCount - 1;

			while(VertSB.Pos + VisibleRows > Count)
				VisibleRows--;

			VertSB.SetRange(0, Count, VisibleRows);

			if(bAutoScrollbar)
			{
				if(Count <= VisibleRows)
					VertSB.HideWindow();
				else
					VertSB.ShowWindow();
			}
		}
	}
	else
	{
		SkipCount = Max(0, Count - (VisibleRows + VertSB.Pos));
		L = UWindowDynamicTextRow(List.Last);
		for(i=0; i < SkipCount && (L != List) ; i++)
			L = UWindowDynamicTextRow(L.Prev);

		Y = WinHeight - DefaultTextHeight;
		while(L != List && L != None && Y > -DefaultTextHeight)
		{
			DrawTextLine(C, L, Y);
			Y = Y - DefaultTextHeight;
			L = UWindowDynamicTextRow(L.Prev);
		}
	}
}

function UWindowDynamicTextRow AddText(string NewLine)
{
	local UWindowDynamicTextRow L;
	local string Temp;
	local int i;

	bDirty = True;

	i = InStr(NewLine, "\\n");
	if(i != -1)
	{
		Temp = Mid(NewLine, i+2);
		NewLine = Left(NewLine, i);
	}
	else
		Temp = "";


	// reuse a row if possible
	L = CheckMaxRows();

	if(L != None)
		List.AppendItem(L);
	else
		L = UWindowDynamicTextRow(List.Append(RowClass));

	L.Text = NewLine;
	L.WrapParent = None;
	L.bRowDirty = True;

	if(Temp != "")
		AddText(Temp);

	return L;
}

function UWindowDynamicTextRow CheckMaxRows()
{
	local UWindowDynamicTextRow L;
	L = None;
	while(MaxLines > 0 && List.Count() > MaxLines - 1 && List.Next != None)
	{
		L = UWindowDynamicTextRow(List.Next);
		RemoveWrap(L);
		L.Remove();
	}
	return L;
}

function WordWrap(Canvas C, bool bForce)
{
	local UWindowDynamicTextRow L;

	for(L = UWindowDynamicTextRow(List.Next); L != None; L = UWindowDynamicTextRow(L.Next))
		if(L.WrapParent == None && (L.bRowDirty || bForce))
			WrapRow(C, L);

	bDirty = False;
}

function WrapRow(Canvas C, UWindowDynamicTextRow L)
{
	local UWindowDynamicTextRow CurrentRow, N;
	local float MaxWidth;
	local int WrapPos;

	if(WrapWidth == 0)
	{
		if(VertSB.bWindowVisible || bAutoScrollbar)
			MaxWidth = WinWidth - VertSB.WinWidth;
		else
			MaxWidth = WinWidth;
	}
	else
		MaxWidth = WrapWidth;

	L.bRowDirty = False;

	// fast check - single line?
	N = UWindowDynamicTextRow(L.Next);
	if(N == None || N.WrapParent != L)
	{
		if(GetWrapPos(C, L, MaxWidth) == -1)
			return;
	}

	RemoveWrap(L);
	CurrentRow = L;

	while(True)
	{
		WrapPos = GetWrapPos(C, CurrentRow, MaxWidth);
		if(WrapPos == -1)
			break;

		CurrentRow = SplitRowAt(CurrentRow, WrapPos);
	}
}

///////////////////////////////////////////////////////
// Functions to override to change format/layout
///////////////////////////////////////////////////////

function float DrawTextLine(Canvas C, UWindowDynamicTextRow L, float Y)
{
	local float X, W, H;

	if(bHCenter)
	{
		TextAreaTextSize(C, L.Text, W, H);
		if(VertSB.bWindowVisible)
			X = int(((WinWidth - VertSB.WinWidth) - W) / 2);
		else
			X = int((WinWidth - W) / 2);
	}
	else
		X = 2;
	TextAreaClipText(C, X, Y, L.Text);

	return DefaultTextHeight;
}


// find where to break the line
function int GetWrapPos(Canvas C, UWindowDynamicTextRow L, float MaxWidth)
{
	local float W, H, LineWidth, NextWordWidth;
	local string Input, NextWord;
	local int WordsThisRow, WrapPos;

	// quick check
	TextAreaTextSize(C, L.Text, W, H);
	if(W <= MaxWidth)
		return -1;

	Input = L.Text;
	WordsThisRow = 0;
	LineWidth = 0;
	WrapPos = 0;
	NextWord = "";

	while(Input != "" || NextWord != "")
	{
		if(NextWord == "")
		{
			RemoveNextWord(Input, NextWord);
			TextAreaTextSize(C, NextWord, NextWordWidth, H);
		}
		if(WordsThisRow > 0 && LineWidth + NextWordWidth > MaxWidth)
		{
			return WrapPos;
		}
		else
		{
			WrapPos += Len(NextWord);
			LineWidth += NextWordWidth;
			NextWord = "";
			WordsThisRow++;
		}
	}
	return -1;
}

function UWindowDynamicTextRow SplitRowAt(UWindowDynamicTextRow L, int SplitPos)
{
	local UWindowDynamicTextRow N;

	N = UWindowDynamicTextRow(L.InsertAfter(RowClass));

	if(L.WrapParent == None)
		N.WrapParent = L;
	else
		N.WrapParent = L.WrapParent;

	N.Text = Mid(L.Text, SplitPos);
	L.Text = Left(L.Text, SplitPos);

	return N;
}

function RemoveNextWord(out string Text, out string NextWord)
{
	local int i;

	i = InStr(Text, " ");
	if(i == -1)
	{
		NextWord = Text;
		Text = "";
	}
	else
	{
		while(Mid(Text, i, 1) == " ")
			i++;

		NextWord = Left(Text, i);
		Text = Mid(Text, i);
	}
}

function RemoveWrap(UWindowDynamicTextRow L)
{
	local UWindowDynamicTextRow N;

	// Remove previous word-wrapping
	N = UWindowDynamicTextRow(L.Next);
	while(N != None && N.WrapParent == L)
	{
		L.Text = L.Text $ N.Text;
		N.Remove();
		N = UWindowDynamicTextRow(L.Next);
	}
}

defaultproperties
{
	Font=0
	WrapWidth=0
	bNoKeyboard=True
	bScrollOnResize=True
	MaxLines=0
	TextColor=(R=255,G=255,B=255,A=255);
	bVCenter=False
	bHCenter=False
	bAutoScrollbar=False
	bVariableRowHeight=False
	RowClass=class'UWindowDynamicTextRow'
}
class UWindowDynamicTextRow extends UWindowList;



var string Text;
var UWindowDynamicTextRow WrapParent;
var bool bRowDirty;
// UWindowEditBox - simple edit box, for use in other controls such as
// UWindowComboxBoxControl, UWindowEditBoxControl etc.

class UWindowEditBox extends UWindowDialogControl;



var string		Value;
var string		Value2;
var int			CaretOffset;
var int			MaxLength;
var float		LastDrawTime;
var bool		bShowCaret;
var float		Offset;
var UWindowDialogControl	NotifyOwner;
var bool		bNumericOnly;
var bool		bNumericFloat;
var bool		bCanEdit;
var bool		bAllSelected;
var bool		bSelectOnFocus;
var bool		bDelayedNotify;
var bool		bChangePending;
var bool		bControlDown;
var bool		bShiftDown;
var bool		bHistory;
var bool		bKeyDown;
var UWindowEditBoxHistory	HistoryList;
var UWindowEditBoxHistory	CurrentHistory;

function Created()
{
	Super.Created();
	bCanEdit = True;
	bControlDown = False;
	bShiftDown = False;

	MaxLength = 255;
	CaretOffset = 0;
	Offset = 0;
	LastDrawTime = 0.0;
}

function SetHistory(bool bInHistory)
{
	bHistory = bInHistory;

	if(bHistory && HistoryList==None)
	{
		HistoryList = new(None) class'UWindowEditBoxHistory';
		HistoryList.SetupSentinel();
		CurrentHistory = None;
	}
	else
	if(!bHistory && HistoryList!=None)
	{
		HistoryList = None;
		CurrentHistory = None;
	}
}

function SetEditable(bool bEditable)
{
	bCanEdit = bEditable;
}

function SetValue(string NewValue, optional string NewValue2)
{
	Value = NewValue;
	Value2 = NewValue2;

	if(CaretOffset > Len(Value))
		CaretOffset = Len(Value);
	Notify(DE_Change);
}

function Clear()
{
	CaretOffset = 0;
	Value="";
	Value2="";
	bAllSelected = False;
	if(bDelayedNotify)
		bChangePending = True;
	else
		Notify(DE_Change);
}

function SelectAll()
{
	if(bCanEdit && Value != "")
	{
		CaretOffset = Len(Value);
		bAllSelected = True;
	}
}

function string GetValue()
{
	return Value;
}

function string GetValue2()
{
	return Value2;
}

function Notify(byte E)
{
	if(NotifyOwner != None)
	{
		NotifyOwner.Notify(E);
	} else {
		Super.Notify(E);
	}
}

function InsertText(string Text)
{
	local int i;

	for(i=0;i<Len(Text);i++)
		Insert(Asc(Mid(Text,i,1)));
}

// Inserts a character at the current caret position
function bool Insert(byte C)
{
	local string	NewValue;

	NewValue = Left(Value, CaretOffset) $ Chr(C) $ Mid(Value, CaretOffset);

	if(Len(NewValue) > MaxLength)
		return False;

	CaretOffset++;

	Value = NewValue;
	if(bDelayedNotify)
		bChangePending = True;
	else
		Notify(DE_Change);
	return True;
}

function bool Backspace()
{
	local string	NewValue;

	if(CaretOffset == 0) return False;

	NewValue = Left(Value, CaretOffset - 1) $ Mid(Value, CaretOffset);
	CaretOffset--;

	Value = NewValue;
	if(bDelayedNotify)
		bChangePending = True;
	else
		Notify(DE_Change);
	return True;
}

function bool DeleteSelf()
{
	local string	NewValue;

	if(CaretOffset == Len(Value)) return False;

	NewValue = Left(Value, CaretOffset) $ Mid(Value, CaretOffset + 1);

	Value = NewValue;
	Notify(DE_Change);
	return True;
}

function bool WordLeft()
{
	while(CaretOffset > 0 && Mid(Value, CaretOffset - 1, 1) == " ")
		CaretOffset--;
	while(CaretOffset > 0 && Mid(Value, CaretOffset - 1, 1) != " ")
		CaretOffset--;

	LastDrawTime = GetLevel().TimeSeconds;
	bShowCaret = True;

	return True;
}

function bool MoveLeft()
{
	if(CaretOffset == 0) return False;
	CaretOffset--;

	LastDrawTime = GetLevel().TimeSeconds;
	bShowCaret = True;

	return True;
}

function bool MoveRight()
{
	if(CaretOffset == Len(Value)) return False;
	CaretOffset++;

	LastDrawTime = GetLevel().TimeSeconds;
	bShowCaret = True;

	return True;
}

function bool WordRight()
{
	while(CaretOffset < Len(Value) && Mid(Value, CaretOffset, 1) != " ")
		CaretOffset++;
	while(CaretOffset < Len(Value) && Mid(Value, CaretOffset, 1) == " ")
		CaretOffset++;

	LastDrawTime = GetLevel().TimeSeconds;
	bShowCaret = True;

	return True;
}

function bool MoveHome()
{
	CaretOffset = 0;

	LastDrawTime = GetLevel().TimeSeconds;
	bShowCaret = True;

	return True;
}

function bool MoveEnd()
{
	CaretOffset = Len(Value);

	LastDrawTime = GetLevel().TimeSeconds;
	bShowCaret = True;

	return True;
}

function EditCopy()
{
	if(bAllSelected || !bCanEdit)
		GetPlayerOwner().CopyToClipboard(Value);
}

function EditPaste()
{
	if(bCanEdit)
	{
		if(bAllSelected)
			Clear();
		InsertText(GetPlayerOwner().PasteFromClipboard());
	}
}

function EditCut()
{
	if(bCanEdit)
	{
		if(bAllSelected)
		{
			GetPlayerOwner().CopyToClipboard(Value);
			bAllSelected = False;
			Clear();
		}
	}
	else
		EditCopy();
}

function KeyPressed( int Key, float MouseX, float MouseY )
{
	if(bCanEdit && bKeyDown)
	{
		if( !bControlDown )
		{
			if(bAllSelected)
				Clear();

			bAllSelected = False;

			if(bNumericOnly)
			{
				if( Key>=0x30 && Key<=0x39 )
				{
					Insert(Key);
				}
			}
			else
			{
				if( Key>=0x20 && Key<0x80 )
				{
					Insert(Key);
				}
			}
		}
	}
}

function KeyUp(int Key, float X, float Y)
{
	local PlayerController P;
	bKeyDown = False;
	P = GetPlayerOwner();
	switch (Key)
	{
	case P.Player.Console.EInputKey.IK_Ctrl:
		bControlDown = False;
		break;
	case P.Player.Console.EInputKey.IK_Shift:
		bShiftDown = False;
		break;
	}
}

function KeyDown(int Key, float X, float Y)
{
	bKeyDown = True;

	switch (Key)
	{
	case 0x11:
		bControlDown = True;
		break;
	case 0x10:
		bShiftDown = True;
		break;
	case 0x1B:
		break;
	case 0x0D:
		if(bCanEdit)
		{
			if(bHistory)
			{
				if(Value != "")
				{
					CurrentHistory = UWindowEditBoxHistory(HistoryList.Insert(class'UWindowEditBoxHistory'));
					CurrentHistory.HistoryText = Value;
				}
				CurrentHistory = HistoryList;
			}
			Notify(DE_EnterPressed);
		}
		break;
	case 0xEC:
		if(bCanEdit)
			Notify(DE_WheelUpPressed);
		break;
	case 0xED:
		if(bCanEdit)
			Notify(DE_WheelDownPressed);
		break;

	case 0x27:
		if(bCanEdit)
		{
			if(bControlDown)
				WordRight();
			else
				MoveRight();
		}
		bAllSelected = False;
		break;
	case 0x25:
		if(bCanEdit)
		{
			if(bControlDown)
				WordLeft();
			else
				MoveLeft();
		}
		bAllSelected = False;
		break;
	case 0x26:
		if(bCanEdit && bHistory)
		{
			bAllSelected = False;
			if(CurrentHistory != None && CurrentHistory.Next != None)
			{
				CurrentHistory = UWindowEditBoxHistory(CurrentHistory.Next);
				SetValue(CurrentHistory.HistoryText);
				MoveEnd();
			}
		}
		break;
	case 0x28:
		if(bCanEdit && bHistory)
		{
			bAllSelected = False;
			if(CurrentHistory != None && CurrentHistory.Prev != None)
			{
				CurrentHistory = UWindowEditBoxHistory(CurrentHistory.Prev);
				SetValue(CurrentHistory.HistoryText);
				MoveEnd();
			}
		}
		break;
	case 0x24:
		if(bCanEdit)
			MoveHome();
		bAllSelected = False;
		break;
	case 0x23:
		if(bCanEdit)
			MoveEnd();
		bAllSelected = False;
		break;
	case 0x08:
		if(bCanEdit)
		{
			if(bAllSelected)
				Clear();
			else
				Backspace();
		}
		bAllSelected = False;
		break;
	case 0x2E:
		if(bCanEdit)
		{
			if(bAllSelected)
				Clear();
			else
				DeleteSelf();
		}
		bAllSelected = False;
		break;
	case 0xBE:
	case 0x6E:
		if (bNumericFloat)
			Insert(Asc("."));
		break;
	default:
		if( bControlDown )
		{
			if( Key == Asc("c") || Key == Asc("C"))
				EditCopy();

			if( Key == Asc("v") || Key == Asc("V"))
				EditPaste();

			if( Key == Asc("x") || Key == Asc("X"))
				EditCut();
		}
		else
		{
			if(NotifyOwner != None)
				NotifyOwner.KeyDown(Key, X, Y);
			else
				Super.KeyDown(Key, X, Y);
		}

		break;
	}
}

function Click(float X, float Y)
{
	Notify(DE_Click);
}

function LMouseDown(float X, float Y)
{
	Super.LMouseDown(X, Y);
	Notify(DE_LMouseDown);
}

function Paint(Canvas C, float X, float Y)
{
	local float W, H;
	local float TextY;

	C.Font = Root.Fonts[Font];

	TextSize(C, "A", W, H);
	TextY = (WinHeight - H) / 2;

	TextSize(C, Left(Value, CaretOffset), W, H);

	C.SetDrawColor(255,255,255);

	if(W + Offset < 0)
		Offset = -W;

	if(W + Offset > (WinWidth - 2))
	{
		Offset = (WinWidth - 2) - W;
		if(Offset > 0) Offset = 0;
	}

	C.DrawColor = TextColor;

	if(bAllSelected)
	{
		DrawStretchedTexture(C, Offset + 1, TextY, W, H, Texture'UWindow.WhiteTexture');

		// Invert Colors
		C.SetDrawColor(255 ^ C.DrawColor.R, 255 ^ C.DrawColor.G, 255 ^ C.DrawColor.B);
	}

	ClipText(C, Offset + 1, TextY,  Value);

	if((!bHasKeyboardFocus) || (!bCanEdit))
		bShowCaret = False;
	else
	{
		if((GetLevel().TimeSeconds > LastDrawTime + 0.3) || (GetLevel().TimeSeconds < LastDrawTime))
		{
			LastDrawTime = GetLevel().TimeSeconds;
			bShowCaret = !bShowCaret;
		}
	}

	if(bShowCaret)
		ClipText(C, Offset + W - 1, TextY, "|");
}

function Close(optional bool bByParent)
{
	if(bChangePending)
	{
		bChangePending = False;
		Notify(DE_Change);
	}
	bKeyDown = False;
	Super.Close(bByParent);
}

function FocusOtherWindow(UWindowWindow W)
{
	if(bChangePending)
	{
		bChangePending = False;
		Notify(DE_Change);
	}

	if(NotifyOwner != None)
		NotifyOwner.FocusOtherWindow(W);
	else
		Super.FocusOtherWindow(W);
}

function KeyFocusEnter()
{
	if(bSelectOnFocus && !bHasKeyboardFocus)
		SelectAll();

	Super.KeyFocusEnter();
}

function DoubleClick(float X, float Y)
{
	Super.DoubleClick(X, Y);
	SelectAll();
}

function KeyFocusExit()
{
	bAllSelected = False;
	Super.KeyFocusExit();
}

class UWindowEditBoxHistory extends UWindowList;



var string HistoryText;
class UWindowEditControl extends UWindowDialogControl;



var	float			EditBoxWidth;
var float			EditAreaDrawX, EditAreaDrawY;
var UWindowEditBox	EditBox;

function Created()
{
	Super.Created();

	EditBox = UWindowEditBox(CreateWindow(class'UWindowEditBox', 0, 0, WinWidth, WinHeight));
	EditBox.NotifyOwner = Self;
	EditBox.bSelectOnFocus = True;

	EditBoxWidth = WinWidth / 2;

	SetEditTextColor(LookAndFeel.EditBoxTextColor);
}

function SetNumericOnly(bool bNumericOnly)
{
	EditBox.bNumericOnly = bNumericOnly;
}

function SetNumericFloat(bool bNumericFloat)
{
	EditBox.bNumericFloat = bNumericFloat;
}

function SetFont(int NewFont)
{
	Super.SetFont(NewFont);
	EditBox.SetFont(NewFont);
}

function SetHistory(bool bInHistory)
{
	EditBox.SetHistory(bInHistory);
}

function SetEditTextColor(Color NewColor)
{
	EditBox.SetTextColor(NewColor);
}

function Clear()
{
	EditBox.Clear();
}

function string GetValue()
{
	return EditBox.GetValue();
}

function SetValue(string NewValue)
{
	EditBox.SetValue(NewValue);
}

function SetMaxLength(int MaxLength)
{
	EditBox.MaxLength = MaxLength;
}

function Paint(Canvas C, float X, float Y)
{
	LookAndFeel.Editbox_Draw(Self, C);
	Super.Paint(C, X, Y);
}


function BeforePaint(Canvas C, float X, float Y)
{
	Super.BeforePaint(C, X, Y);
	LookAndFeel.Editbox_SetupSizes(Self, C);
}

function SetDelayedNotify(bool bDelayedNotify)
{
	Editbox.bDelayedNotify = bDelayedNotify;
}
class UWindowFrameCloseBox extends UWindowButton;



function Created()
{
	bNoKeyboard = True;
	Super.Created();
}

function Click(float X, float Y)
{
	ParentWindow.Close();
}

// No keyboard support
function KeyDown(int Key, float X, float Y)
{
}
//=============================================================================
// UWindowFramedWindow - a Windows95 style framed window
//=============================================================================
class UWindowFramedWindow extends UWindowWindow;




var class<UWindowWindow>	ClientClass;
var UWindowWindow			ClientArea;
var localized string		WindowTitle;
var string					StatusBarText;
var float					MoveX, MoveY;	// co-ordinates where the move was requested
var float					MinWinWidth, MinWinHeight;

var bool					bTLSizing;
var bool					bTSizing;
var bool					bTRSizing;
var bool					bLSizing;
var bool					bRSizing;
var bool					bBLSizing;
var bool					bBSizing;
var bool					bBRSizing;

var bool					bMoving;
var bool					bSizable;
var bool					bStatusBar;
var UWindowFrameCloseBox	CloseBox;


function Created()
{
	Super.Created();

	MinWinWidth = 50;
	MinWinHeight = 50;
	ClientArea = CreateWindow(ClientClass, 4, 16, WinWidth - 8, WinHeight - 20, OwnerWindow);
	CloseBox = UWindowFrameCloseBox(CreateWindow(Class'UWindowFrameCloseBox', WinWidth-20, WinHeight-20, 11, 10));
}

function Texture GetLookAndFeelTexture()
{
	return LookAndFeel.GetTexture(Self);
}

function bool IsActive()
{
	return ParentWindow.ActiveWindow == Self;
}

function BeforePaint(Canvas C, float X, float Y)
{
	Super.BeforePaint(C, X, Y);
	Resized();
	LookAndFeel.FW_SetupFrameButtons(Self, C);
}

function Paint(Canvas C, float X, float Y)
{
	LookAndFeel.FW_DrawWindowFrame(Self, C);
}

function LMouseDown(float X, float Y)
{
	local FrameHitTest H;
	H = LookAndFeel.FW_HitTest(Self, X, Y);

	Super.LMouseDown(X, Y);


	if(H == HT_TitleBar)
	{
		MoveX = X;
		MoveY = Y;
		bMoving = True;
		Root.CaptureMouse();

		return;
	}

	if(bSizable)
	{
		switch(H)
		{
		case HT_NW:
			bTLSizing = True;
			Root.CaptureMouse();
			return;
		case HT_NE:
			bTRSizing = True;
			Root.CaptureMouse();
			return;
		case HT_SW:
			bBLSizing = True;
			Root.CaptureMouse();
			return;
		case HT_SE:
			bBRSizing = True;
			Root.CaptureMouse();
			return;
		case HT_N:
			bTSizing = True;
			Root.CaptureMouse();
			return;
		case HT_S:
			bBSizing = True;
			Root.CaptureMouse();
			return;
		case HT_W:
			bLSizing = True;
			Root.CaptureMouse();
			return;
		case HT_E:
			bRSizing = True;
			Root.CaptureMouse();
			return;
		}
	}
}

function Resized()
{
	local Region R;

	if(ClientArea == None)
	{
		Log("Client Area is None for "$Self);
		return;
	}

	R = LookAndFeel.FW_GetClientArea(Self);

	ClientArea.WinLeft = R.X;
	ClientArea.WinTop = R.Y;

	if((R.W != ClientArea.WinWidth) || (R.H != ClientArea.WinHeight))
	{
		ClientArea.SetSize(R.W, R.H);
	}

}

function MouseMove(float X, float Y)
{
	local float OldW, OldH;
	local FrameHitTest H;
	H = LookAndFeel.FW_HitTest(Self, X, Y);


	if(bMoving && bMouseDown)
	{
		WinLeft = Int(WinLeft + X - MoveX);
		WinTop = Int(WinTop + Y - MoveY);
	}
	else
		bMoving = False;


	Cursor = Root.NormalCursor;

	if(bSizable && !bMoving)
	{
		switch(H)
		{
		case HT_NW:
		case HT_SE:
			Cursor = Root.DiagCursor1;
			break;
		case HT_NE:
		case HT_SW:
			Cursor = Root.DiagCursor2;
			break;
		case HT_W:
		case HT_E:
			Cursor = Root.WECursor;
			break;
		case HT_N:
		case HT_S:
			Cursor = Root.NSCursor;
			break;
		}
	}

	// Top Left
	if(bTLSizing && bMouseDown)
	{
		Cursor = Root.DiagCursor1;
		OldW = WinWidth;
		OldH = WinHeight;
		SetSize(Max(MinWinWidth, WinWidth - X), Max(MinWinHeight, WinHeight - Y));
		WinLeft = Int(WinLeft + OldW - WinWidth);
		WinTop = Int(WinTop + OldH - WinHeight);
	}
	else
		bTLSizing = False;


	// Top
	if(bTSizing && bMouseDown)
	{
		Cursor = Root.NSCursor;
		OldH = WinHeight;
		SetSize(WinWidth, Max(MinWinHeight, WinHeight - Y));
		WinTop = Int(WinTop + OldH - WinHeight);
	}
	else
		bTSizing = False;

	// Top Right
	if(bTRSizing && bMouseDown)
	{
		Cursor = Root.DiagCursor2;
		OldH = WinHeight;
		SetSize(Max(MinWinWidth, X), Max(MinWinHeight, WinHeight - Y));
		WinTop = Int(WinTop + OldH - WinHeight);
	}
	else
		bTRSizing = False;


	// Left
	if(bLSizing && bMouseDown)
	{
		Cursor = Root.WECursor;
		OldW = WinWidth;
		SetSize(Max(MinWinWidth, WinWidth - X), WinHeight);
		WinLeft = Int(WinLeft + OldW - WinWidth);
	}
	else
		bLSizing = False;

	// Right
	if(bRSizing && bMouseDown)
	{
		Cursor = Root.WECursor;
		SetSize(Max(MinWinWidth, X), WinHeight);
	}
	else
		bRSizing = False;

	// Bottom Left
	if(bBLSizing && bMouseDown)
	{
		Cursor = Root.DiagCursor2;
		OldW = WinWidth;
		SetSize(Max(MinWinWidth, WinWidth - X), Max(MinWinHeight, Y));
		WinLeft = Int(WinLeft + OldW - WinWidth);
	}
	else
		bBLSizing = False;

	// Bottom
	if(bBSizing && bMouseDown)
	{
		Cursor = Root.NSCursor;
		SetSize(WinWidth, Max(MinWinHeight, Y));
	}
	else
		bBSizing = False;

	// Bottom Right
	if(bBRSizing && bMouseDown)
	{
		Cursor = Root.DiagCursor1;
		SetSize(Max(MinWinWidth, X), Max(MinWinHeight, Y));
	}
	else
		bBRSizing = False;

}

function ToolTip(string strTip)
{
	StatusBarText = strTip;
}

function WindowEvent(WinMessage Msg, Canvas C, float X, float Y, int Key)
{
	if(Msg == WM_Paint || !WaitModal())
		Super.WindowEvent(Msg, C, X, Y, Key);
}

function WindowHidden()
{
	Super.WindowHidden();
	LookAndFeel.PlayMenuSound(Self, MS_WindowClose);
}

defaultproperties
{
	ClientClass=class'UWindowClientWindow';
}
//=============================================================================
// UWindowGrid - a grid with sizable columns and clickable column headings.
//=============================================================================
class UWindowGrid extends UWindowWindow;



var UWindowGridColumn FirstColumn;
var UWindowGridColumn LastColumn;
var UWindowGridClient ClientArea;

var int					TopRow;
var float				RowHeight;
var UWindowVScrollbar	VertSB;
var UWindowHScrollbar	HorizSB;
var bool				bShowHorizSB;
var bool				bSizingColumn;
var bool				bNoKeyboard;

function Created()
{
	ClientArea = UWindowGridClient(CreateWindow(class'UWindowGridClient', 0, 0, WinWidth - 12, WinHeight));
	VertSB = UWindowVScrollbar(CreateWindow(class'UWindowVScrollbar', WinWidth-12, 0, 12, WinHeight));
	VertSB.bAlwaysOnTop = True;

	HorizSB = UWindowHScrollbar(CreateWindow(class'UWindowHScrollbar', 0, WinHeight-12, WinWidth, 12));
	HorizSB.bAlwaysOnTop = True;
	HorizSB.HideWindow();
	bShowHorizSB = False;

	if(!bNoKeyboard)
		SetAcceptsFocus();

	Super.Created();
}


function BeforePaint(Canvas C, float X, float Y)
{
	Super.BeforePaint(C, X, Y);
	Resized();
}

function Resized()
{
	local float Offset;
	local UWindowGridColumn colColumn;
	local float TotalWidth;


	TotalWidth = 0;
	colColumn = FirstColumn;
	while(colColumn != None)
	{
		TotalWidth = TotalWidth + colColumn.WinWidth;
		colColumn = colColumn.NextColumn;
	}

	if(!bSizingColumn)
		HorizSB.SetRange(0, TotalWidth, WinWidth - LookAndFeel.Size_ScrollbarWidth, 10);

	if(!HorizSB.bDisabled)
	{
		// Need a horizontal scrollbar
		HorizSB.ShowWindow();
		bShowHorizSB = True;
	}
	else
	{
		HorizSB.HideWindow();
		bShowHorizSB = False;
		HorizSB.Pos = 0;
	}


	ClientArea.WinTop = 0;
	ClientArea.WinLeft = 0;
	ClientArea.WinWidth = WinWidth - LookAndFeel.Size_ScrollbarWidth;
	if(bShowHorizSB)
		ClientArea.WinHeight = WinHeight - LookAndFeel.Size_ScrollbarWidth;
	else
		ClientArea.WinHeight = WinHeight;


	if(bShowHorizSB)
	{
		HorizSB.WinTop = WinHeight-LookAndFeel.Size_ScrollbarWidth;
		HorizSB.WinLeft = 0;
		HorizSB.WinWidth = WinWidth - LookAndFeel.Size_ScrollbarWidth;
		HorizSB.WinHeight = LookAndFeel.Size_ScrollbarWidth;
	}

	VertSB.WinTop = 0;
	VertSB.WinLeft = WinWidth-LookAndFeel.Size_ScrollbarWidth;
	VertSB.WinWidth = LookAndFeel.Size_ScrollbarWidth;
	if(bShowHorizSB)
		VertSB.WinHeight = WinHeight - LookAndFeel.Size_ScrollbarWidth;
	else
		VertSB.WinHeight = WinHeight;


	if(bShowHorizSB)
		Offset = 1 - HorizSB.Pos;
	else
		Offset = 1;

	colColumn = FirstColumn;
	while(colColumn != None)
	{
		colColumn.WinLeft = Offset ;
		colColumn.WinTop = 0;
		colColumn.WinHeight = WinHeight;
		Offset = Offset + colColumn.WinWidth;
		colColumn = colColumn.NextColumn;
	}
}


function UWindowGridColumn AddColumn(string ColumnHeading, float DefaultWidth)
{
	local UWindowGridColumn NewColumn;
	local UWindowGridColumn OldLastColumn;

	OldLastColumn = LastColumn;

	if(LastColumn == None)
	{
		NewColumn = UWindowGridColumn(ClientArea.CreateWindow(class'UWindowGridColumn', 0, 0, DefaultWidth, WinHeight));
		FirstColumn = NewColumn;
		NewColumn.ColumnNum = 0;
	}
	else
	{
		NewColumn = UWindowGridColumn(ClientArea.CreateWindow(class'UWindowGridColumn', LastColumn.WinLeft + LastColumn.WinWidth, 0, DefaultWidth, WinHeight));
		LastColumn.NextColumn = NewColumn;
		NewColumn.ColumnNum = LastColumn.ColumnNum + 1;
	}

	LastColumn = NewColumn;
	NewColumn.NextColumn = None;
	NewColumn.PrevColumn = OldLastColumn;

	NewColumn.ColumnHeading = ColumnHeading;
	return NewColumn;
}

function Paint(Canvas C, float MouseX, float MouseY)
{
	local float X;
	local Texture T;
	local Region R;

	X = LastColumn.WinWidth + LastColumn.WinLeft;

	T = GetLookAndFeelTexture();
	DrawUpBevel( C, X, 0, WinWidth-X, LookAndFeel.ColumnHeadingHeight, T);

	if(bShowHorizSB)
	{
		// R = LookAndFeel.SBBackground;
		DrawStretchedTextureSegment( C, WinWidth-LookAndFeel.Size_ScrollbarWidth,
										WinHeight-LookAndFeel.Size_ScrollbarWidth,
										LookAndFeel.Size_ScrollbarWidth,
										LookAndFeel.Size_ScrollbarWidth,
										R.X, R.Y, R.W, R.H, T);
	}
}


function PaintColumn(Canvas C, UWindowGridColumn Column, float MouseX, float MouseY)
{
	// defined in subclass
}

function SortColumn(UWindowGridColumn Column)
{
	// defined in subclass
}

function SelectRow(int Row)
{
	// defined in subclass
}

function RightClickRow(int Row, float X, float Y)
{
	// defined in subclass
}

function RightClickRowDown(int Row, float X, float Y)
{
	// defined in subclass
}

function DoubleClickRow(int Row)
{
	// defined in subclass
}

function MouseLeaveColumn(UWindowGridColumn Column)
{
	// defined in subclass
}

function KeyDown(int Key, float X, float Y)
{
	switch(Key) {
	case 0x26: // IK_Up
	case 0xEC: // IK_MouseWheelUp
		VertSB.Scroll(-1);
		break;
	case 0x28: // IK_Down
	case 0xED: // IK_MouseWheelDown
		VertSB.Scroll(1);
		break;
	case 0x21: // IK_PageUp
		VertSB.Scroll(-(VertSB.MaxVisible-1));
		break;
	case 0x22: // IK_PageDown
		VertSB.Scroll(VertSB.MaxVisible-1);
		break;
	}
}

defaultproperties
{
	RowHeight=10
}
//=============================================================================
// UWindowGridClient - The client area on a grid.
//=============================================================================
class UWindowGridClient extends UWindowWindow;



function Created() {
}
//=============================================================================
// UWindowGridColumn - a grid column
//=============================================================================
class UWindowGridColumn extends UWindowWindow;



var UWindowGridColumn NextColumn;
var UWindowGridColumn PrevColumn;
var bool				bSizing;
var string				ColumnHeading;
var int					ColumnNum;

function Created() {
	Super.Created();
}

function BeforePaint(Canvas C, float X, float Y)
{
	Super.BeforePaint(C, X, Y);
	if(WinWidth < 1) WinWidth = 1;
}

function LMouseDown(float X, float Y)
{
	Super.LMouseDown(X, Y);

	if(X > Min(WinWidth - 5, ParentWindow.WinWidth - WinLeft - 5) && Y < 12)
	{
		bSizing = True;
		UWindowGrid(ParentWindow.ParentWindow).bSizingColumn = True;
		Root.CaptureMouse();
	}

}

function LMouseUp(float X, float Y)
{
	Super.LMouseUp(X, Y);

	UWindowGrid(ParentWindow.ParentWindow).bSizingColumn = False;
}

function MouseMove(float X, float Y)
{
	if(X > Min(WinWidth - 5, ParentWindow.WinWidth - WinLeft - 5) && Y < 12)
	{
		Cursor = Root.HSplitCursor;
	}
	else
	{
		Cursor = Root.NormalCursor;
	}

	if(bSizing && bMouseDown)
	{
		WinWidth = X;
		if(WinWidth < 1) WinWidth = 1;
		if(WinWidth > ParentWindow.WinWidth - WinLeft - 1) WinWidth = ParentWindow.WinWidth - WinLeft - 1;
	}
	else
	{
		bSizing = False;
		UWindowGrid(ParentWindow.ParentWindow).bSizingColumn = False;
	}
}

function Paint(Canvas C, float X, float Y)
{
	local Texture T;
	local Color FC;

	UWindowGrid(ParentWindow.ParentWindow).PaintColumn(C, Self, X, Y);

	if(IsActive())
	{
		T = LookAndFeel.Active;
		FC = LookAndFeel.HeadingActiveTitleColor;
	}
	else
	{
		T = LookAndFeel.InActive;
		FC = LookAndFeel.HeadingInactiveTitleColor;
	}

	C.SetDrawColor(255,255,255);

	DrawUpBevel( C, 0, 0, WinWidth, LookAndFeel.ColumnHeadingHeight, T);

	C.DrawColor = FC;

	ClipText( C, 2, 1, ColumnHeading);

	C.SetDrawColor(255,255,255);
}

function Click(float X, float Y)
{
	local int Row;

	if(Y < 12)
	{
		if(X <= Min(WinWidth - 5, ParentWindow.WinWidth - WinLeft - 5))
		{
			UWindowGrid(ParentWindow.ParentWindow).SortColumn(Self);
		}
	}
	else
	{
		Row = ((Y - 12) / UWindowGrid(ParentWindow.ParentWindow).RowHeight) + UWindowGrid(ParentWindow.ParentWindow).TopRow;
		UWindowGrid(ParentWindow.ParentWindow).SelectRow(Row);
	}
}

function RMouseDown(float X, float Y)
{
	local int Row;
	Super.RMouseDown(X, Y);

	if(Y > 12)
	{
		Row = ((Y - 12) / UWindowGrid(ParentWindow.ParentWindow).RowHeight) + UWindowGrid(ParentWindow.ParentWindow).TopRow;
		UWindowGrid(ParentWindow.ParentWindow).SelectRow(Row);
		UWindowGrid(ParentWindow.ParentWindow).RightClickRowDown(Row, X+WinLeft, Y+WinTop);
	}
}

function RMouseUp(float X, float Y)
{
	local int Row;
	Super.RMouseUp(X, Y);

	if(Y > 12)
	{
		Row = ((Y - 12) / UWindowGrid(ParentWindow.ParentWindow).RowHeight) + UWindowGrid(ParentWindow.ParentWindow).TopRow;
		UWindowGrid(ParentWindow.ParentWindow).SelectRow(Row);
		UWindowGrid(ParentWindow.ParentWindow).RightClickRow(Row, X+WinLeft, Y+WinTop);
	}
}

function DoubleClick(float X, float Y)
{
	local int Row;

	if(Y < 12)
	{
		Click(X, Y);
	}
	else
	{
		Row = ((Y - 12) / UWindowGrid(ParentWindow.ParentWindow).RowHeight) + UWindowGrid(ParentWindow.ParentWindow).TopRow;
		UWindowGrid(ParentWindow.ParentWindow).DoubleClickRow(Row);
	}
}

function MouseLeave()
{
	Super.MouseLeave();
	UWindowGrid(ParentWindow.ParentWindow).MouseLeaveColumn(Self);
}

class UWindowHotkeyWindowList extends UWindowList;




var UWindowWindow		Window;


function UWindowHotkeyWindowList FindWindow(UWindowWindow W)
{
	local UWindowHotkeyWindowList l;

	l = UWindowHotkeyWindowList(Next);
	while(l != None)
	{
		if(l.Window == W) return l;
		l = UWindowHotkeyWindowList(l.Next);
	}
	return None;
}



//=============================================================================
// UWindowHScrollBar - A horizontal scrollbar
//=============================================================================
class UWindowHScrollBar extends UWindowWindow;



var UWindowSBLeftButton		LeftButton;
var UWindowSBRightButton	RightButton;
var bool					bDisabled;
var float					MinPos;
var float					MaxPos;
var float					MaxVisible;
var float					Pos;				// offset to WinTop
var float					ThumbStart, ThumbWidth;
var float					NextClickTime;
var float					DragX;
var bool					bDragging;
var float					ScrollAmount;

function Show(float P)
{
	if(P < 0) return;
	if(P > MaxPos + MaxVisible) return;

	while(P < Pos)
		if(!Scroll(-1))
			break;
	while(P - Pos > MaxVisible - 1)
		if(!Scroll(1))
			break;
}

function bool Scroll(float Delta)
{
	local float OldPos;

	OldPos = Pos;
	Pos = Pos + Delta;
	CheckRange();
	return Pos == OldPos + Delta;
}

function SetRange(float NewMinPos, float NewMaxPos, float NewMaxVisible, optional float NewScrollAmount)
{
	if(NewScrollAmount == 0)
		NewScrollAmount = 1;

	ScrollAmount = NewScrollAmount;
	MinPos = NewMinPos;
	MaxPos = NewMaxPos - NewMaxVisible;
	MaxVisible = NewMaxVisible;

	CheckRange();
}

function CheckRange()
{
	if(Pos < MinPos)
	{
		Pos = MinPos;
	}
	else
	{
		if(Pos > MaxPos) Pos = MaxPos;
	}

	bDisabled = (MaxPos <= MinPos);
	LeftButton.bDisabled = bDisabled;
	RightButton.bDisabled = bDisabled;

	if(bDisabled)
	{
		Pos = 0;
	}
	else
	{
		ThumbStart = ((Pos - MinPos) * (WinWidth - (2*LookAndFeel.Size_ScrollbarButtonHeight))) / (MaxPos + MaxVisible - MinPos);
		ThumbWidth = (MaxVisible * (WinWidth - (2*LookAndFeel.Size_ScrollbarButtonHeight))) / (MaxPos + MaxVisible - MinPos);

		if(ThumbWidth < LookAndFeel.Size_MinScrollbarHeight)
			ThumbWidth = LookAndFeel.Size_MinScrollbarHeight;

		if(ThumbWidth + ThumbStart > WinWidth - 2*LookAndFeel.Size_ScrollbarButtonHeight)
		{
			ThumbStart = WinWidth - 2*LookAndFeel.Size_ScrollbarButtonHeight - ThumbWidth;
		}

		ThumbStart = ThumbStart + LookAndFeel.Size_ScrollbarButtonHeight;
	}
}

function Created()
{
	Super.Created();
	LeftButton = UWindowSBLeftButton(CreateWindow(class'UWindowSBLeftButton', 0, 0, 10, 12));
	RightButton = UWindowSBRightButton(CreateWindow(class'UWindowSBRightButton', WinWidth-10, 0, 10, 12));
}


function BeforePaint(Canvas C, float X, float Y)
{
	LeftButton.WinTop = 0;
	LeftButton.WinLeft = 0;
	LeftButton.WinWidth = LookAndFeel.Size_ScrollbarButtonHeight;
	LeftButton.WinHeight = LookAndFeel.Size_ScrollbarWidth;

	RightButton.WinTop = 0;
	RightButton.WinLeft = WinWidth - LookAndFeel.Size_ScrollbarButtonHeight;
	RightButton.WinWidth = LookAndFeel.Size_ScrollbarButtonHeight;
	RightButton.WinHeight = LookAndFeel.Size_ScrollbarWidth;

	CheckRange();
}

function Paint(Canvas C, float X, float Y)
{
	LookAndFeel.SB_HDraw(Self, C);
}

function LMouseDown(float X, float Y)
{
	Super.LMouseDown(X, Y);

	if(bDisabled) return;

	if(X < ThumbStart)
	{
		Scroll(-(MaxVisible-1));
		NextClickTime = GetLevel().TimeSeconds + 0.5;
		return;
	}
	if(X > ThumbStart + ThumbWidth)
	{
		Scroll(MaxVisible-1);
		NextClickTime = GetLevel().TimeSeconds + 0.5;
		return;
	}

	if((X >= ThumbStart) && (X <= ThumbStart + ThumbWidth))
	{
		DragX = X - ThumbStart;
		bDragging = True;
		Root.CaptureMouse();
		return;
	}
}


function Tick(float Delta)
{
	local bool bLeft, bRight;
	local float X, Y;

	if(bDragging) return;

	bLeft = False;
	bRight = False;

	if(bMouseDown)
	{
		GetMouseXY(X, Y);
		bLeft = (X < ThumbStart);
		bRight = (X > ThumbStart + ThumbWidth);
	}

	if(bMouseDown && (NextClickTime > 0) && (NextClickTime < GetLevel().TimeSeconds)  && bLeft)
	{
		Scroll(-(MaxVisible-1));
		NextClickTime = GetLevel().TimeSeconds + 0.1;
	}

	if(bMouseDown && (NextClickTime > 0) && (NextClickTime < GetLevel().TimeSeconds)  && bRight)
	{
		Scroll(MaxVisible-1);
		NextClickTime = GetLevel().TimeSeconds + 0.1;
	}

	if(!bMouseDown || (!bLeft && !bRight))
	{
		NextClickTime = 0;
	}
}

function MouseMove(float X, float Y)
{
	if(bDragging && bMouseDown && !bDisabled)
	{
		while(X < (ThumbStart+DragX) && Pos > MinPos)
		{
			Scroll(-1);
		}

		while(X > (ThumbStart+DragX) && Pos < MaxPos)
		{
			Scroll(1);
		}
	}
	else
		bDragging = False;
}
class UWindowHSliderControl extends UWindowDialogControl;




var	float	MinValue;
var	float	MaxValue;
var	float	Value;
var	int		Step;		// 0 = continuous

var	float	SliderWidth;
var	float	SliderDrawX, SliderDrawY;
var float	TrackStart;
var float	TrackWidth;
var bool	bSliding;
var bool	bNoSlidingNotify;


function Created()
{
	Super.Created();
	SliderWidth = WinWidth / 2;
	TrackWidth = 4;
}

function SetRange(float Min, float Max, int NewStep)
{
	MinValue = Min;
	MaxValue = Max;
	Step = NewStep;
	Value = CheckValue(Value);
}

function float GetValue()
{
	return Value;
}

function SetValue(float NewValue, optional bool bNoNotify)
{
	local float OldValue;

	OldValue = Value;

	Value = CheckValue(NewValue);

	if(Value != OldValue && !bNoNotify)
	{
		// Notify
		Notify(DE_Change);
	}
}


function float CheckValue(float Test)
{
	local float TempF;
	local float NewValue;

	NewValue = Test;

	if(Step != 0)
	{
		TempF = NewValue / Step;
		NewValue = Int(TempF + 0.5) * Step;
	}

	if(NewValue < MinValue) NewValue = MinValue;
	if(NewValue > MaxValue) NewValue = MaxValue;

	return NewValue;
}





function BeforePaint(Canvas C, float X, float Y)
{
	local float W, H;

	Super.BeforePaint(C, X, Y);

	TextSize(C, Text, W, H);
	WinHeight = H+1;

	switch(Align)
	{
	case TA_Left:
		SliderDrawX = WinWidth - SliderWidth;
		TextX = 0;
		break;
	case TA_Right:
		SliderDrawX = 0;
		TextX = WinWidth - W;
		break;
	case TA_Center:
		SliderDrawX = (WinWidth - SliderWidth) / 2;
		TextX = (WinWidth - W) / 2;
		break;
	}

	SliderDrawY = (WinHeight - 2) / 2;
	TextY = (WinHeight - H) / 2;

	TrackStart = SliderDrawX + (SliderWidth - TrackWidth) * ((Value - MinValue)/(MaxValue - MinValue));
}


function Paint(Canvas C, float X, float Y)
{
	local Texture T;
	local Region R;

	T = GetLookAndFeelTexture();


	if(Text != "")
	{
		C.DrawColor = TextColor;
		ClipText(C, TextX, TextY, Text);
		C.SetDrawColor(255,255,255);
	}

	R = LookAndFeel.HLine;
	DrawStretchedTextureSegment( C, SliderDrawX, SliderDrawY, SliderWidth, R.H, R.X, R.Y, R.W, R.H, T);

	DrawUpBevel(C, TrackStart, SliderDrawY-4, TrackWidth, 10, T);
}

function LMouseUp(float X, float Y)
{
	Super.LMouseUp(X, Y);

	if(bNoSlidingNotify)
		Notify(DE_Change);
}

function LMouseDown(float X, float Y)
{
	Super.LMouseDown(X, Y);
	if((X >= TrackStart) && (X <= TrackStart + TrackWidth)) {
		bSliding = True;
		Root.CaptureMouse();
	}

	if(X < TrackStart && X > SliderDrawX)
	{
		if(Step != 0)
			SetValue(Value - Step);
		else
			SetValue(Value - 1);
	}

	if(X > TrackStart + TrackWidth && X < SliderDrawX + SliderWidth)
	{
		if(Step != 0)
			SetValue(Value + Step);
		else
			SetValue(Value + 1);
	}

}

function MouseMove(float X, float Y)
{
	Super.MouseMove(X, Y);
	if(bSliding && bMouseDown)
	{
		SetValue((((X - SliderDrawX) / (SliderWidth - TrackWidth)) * (MaxValue - MinValue)) + MinValue, bNoSlidingNotify);
	}
	else
		bSliding = False;
}


function KeyDown(int Key, float X, float Y)
{
	local Interaction C;

	C = GetPlayerOwner().Player.Console;

	switch (Key)
	{
	case C.EInputKey.IK_Left:
		if(Step != 0)
			SetValue(Value - Step);
		else
			SetValue(Value - 1);

		break;
	case C.EInputKey.IK_Right:
		if(Step != 0)
			SetValue(Value + Step);
		else
			SetValue(Value + 1);

		break;
	case C.EInputKey.IK_Home:
		SetValue(MinValue);
		break;
	case C.EInputKey.IK_End:
		SetValue(MaxValue);
		break;
	default:
		Super.KeyDown(Key, X, Y);
		break;
	}
}
//=============================================================================
// UWindowHSplitter - a horizontal splitter component
//=============================================================================
class UWindowHSplitter extends UWindowWindow;



var UWindowWindow			LeftClientWindow;
var UWindowWindow			RightClientWindow;
var bool					bSizing;
var float					SplitPos;
var float					MinWinWidth;
var float					OldWinWidth;
var float					MaxSplitPos;
var bool					bRightGrow;
var bool					bSizable;

function Created()
{
	Super.Created();
	bAlwaysBehind = True;
	SplitPos = WinWidth / 2;
	MinWinWidth = 24;

	OldWinWidth = WinWidth;
}

function Paint(Canvas C, float X, float Y)
{
	local Texture T;

	T = GetLookAndFeelTexture();
	DrawUpBevel(C, SplitPos, 0, 7, WinHeight, T);
}

function BeforePaint(Canvas C, float X, float Y)
{
	local float NewW, NewH;

	// Make Left panel resize
	if(OldWinWidth != WinWidth && !bRightGrow)
	{
		SplitPos = SplitPos + WinWidth - OldWinWidth;
	}

	SplitPos = FClamp(SplitPos, MinWinWidth, WinWidth - 7 - MinWinWidth);
	if(MaxSplitPos != 0)
		SplitPos = FClamp(SplitPos, 0, MaxSplitPos);

	NewW = SplitPos;
	NewH = WinHeight;

	if(NewH != LeftClientWindow.WinHeight || NewW != LeftClientWindow.WinWidth)
	{
		LeftClientWindow.SetSize(NewW, NewH);
	}

	LeftClientWindow.WinTop = 0;
	LeftClientWindow.WinLeft = 0;

	NewW = WinWidth - SplitPos - 7;

	if(NewH != RightClientWindow.WinHeight || NewW != RightClientWindow.WinWidth)
	{
		RightClientWindow.SetSize(NewW, NewH);
	}
	RightClientWindow.WinTop = 0;
	RightClientWindow.WinLeft = SplitPos + 7;


	OldWinWidth = WinWidth;
}

function LMouseDown(float X, float Y)
{
	Super.LMouseDown(X, Y);

	if(bSizable && (X >= SplitPos) && (X <= SplitPos + 7))
	{
		bSizing = True;
		Root.CaptureMouse();
	}
}

function MouseMove(float X, float Y)
{

	if(bSizable && (X >= SplitPos) && (X <= SplitPos + 7))
		Cursor = Root.HSplitCursor;
	else
		Cursor = Root.NormalCursor;

	if(bSizing && bMouseDown)
	{
		SplitPos = X;
	} else bSizing = False;
}

defaultproperties
{
	bSizable=True
	MaxSplitPos=0
}
class UWindowHTMLTextArea extends UWindowDynamicTextArea;



/*

HTML Currently Supported
========================

Parsed on add
-------------
<body bgcolor=#ffffff link=#ffffff alink=#ffffff>...</body>
<font color=#ffffff bgcolor=#ffffff>...</font>
<br>
<center>....</center>
<p>
<h1>...</h1>

Parsed on add and display
-------------------------
<nobr>...</nobr>
<a href="...">...</a>
<b>...</b>
<u>...</u>
<blink>...</blink>

Parsed only on display
----------------------
&gt;
&lt;
&amp;
&nbsp;

Planned improvements
--------------------
<ul><li>item 1<li>item 2...</ul>
<table>...</table>

Bugs
----
The parsing is pretty slack!

*/

// default styles
var Color BGColor;
var Color LinkColor;
var Color ALinkColor;
var float LastBlinkTime;
var bool bShowBlink;
var bool bReleased;

function SetHTML(string HTML)
{
	Clear();
	ReplaceText(HTML, Chr(13)$Chr(10), " ");
	ReplaceText(HTML, Chr(13), " ");
	ReplaceText(HTML, Chr(10), " ");
	AddText(HTML);
}

function BeforePaint(Canvas C, float X, float Y)
{
	Super.BeforePaint(C, X, Y);
	Cursor = Root.NormalCursor;
}

function Paint(Canvas C, float X, float Y)
{
	C.DrawColor = BGColor;
	DrawStretchedTexture(C, 0, 0, WinWidth, WinHeight, Texture'WhiteTexture');
	Super.Paint(C, X, Y);
	bReleased = False;
}

function Click(float X, float Y)
{
	Super.Click(X, Y);
	bReleased = True;
}

function ProcessURL(string URL)
{
	Log("Clicked Link: >>"$URL$"<<");

	if( Left(URL, 7) ~= "mailto:" )
		GetPlayerOwner().ConsoleCommand("start "$URL);
	if( Left(URL, 7) ~= "http://" )
		GetPlayerOwner().ConsoleCommand("start "$URL);
	if( Left(URL, 6) ~= "ftp://" )
		GetPlayerOwner().ConsoleCommand("start "$URL);
	if( Left(URL, 9) ~= "telnet://" )
		GetPlayerOwner().ConsoleCommand("start "$URL);
	if( Left(URL, 9) ~= "gopher://" )
		GetPlayerOwner().ConsoleCommand("start "$URL);
	if( Left(URL, 4) ~= "www." )
		GetPlayerOwner().ConsoleCommand("start http://"$URL);
	if( Left(URL, 4) ~= "ftp." )
		GetPlayerOwner().ConsoleCommand("start ftp://"$URL);
	else
	if( Left(URL, 9) ~= "unreal://" )
		LaunchUnrealURL(URL);
}

function OverURL(string URL)
{
}

function LaunchUnrealURL(string URL)
{
	GetPlayerOwner().ClientTravel(URL, TRAVEL_Absolute, false);
}

function TextAreaTextSize(Canvas C, string Text, out float W, out float H)
{
	ReplaceText(Text, "&nbsp;", " ");
	ReplaceText(Text, "&gt;", ">");
	ReplaceText(Text, "&lt;", "<");
	ReplaceText(Text, "&amp;", "&");

	TextSize(C, Text, W, H);
}

function TextAreaClipText(Canvas C, float DrawX, float DrawY, coerce string Text, optional bool bCheckHotkey)
{
	ReplaceText(Text, "&nbsp;", " ");
	ReplaceText(Text, "&gt;", ">");
	ReplaceText(Text, "&lt;", "<");
	ReplaceText(Text, "&amp;", "&");

	ClipText(C, DrawX, DrawY, Text, bCheckHotKey);
}

///////////////////////////////////////////////////////
// Overloaded functions from UWindowDynamicTextArea
///////////////////////////////////////////////////////

function WrapRow(Canvas C, UWindowDynamicTextRow L)
{
	local HTMLStyle CurrentStyle;
	local UWindowHTMLTextRow R;
	local string Input, LeftText, HTML, RightText;

	Super.WrapRow(C, L);

	// Generate the DisplayString and StyleString lines for each row
	R = UWindowHTMLTextRow(L);
	while(R != None && (R == L || R.WrapParent == L))
	{
		R.DisplayString = "";
		R.StyleString = "";

		CurrentStyle = R.StartStyle;

		Input = R.Text;
		while(Input != "")
		{
			ParseHTML(Input, LeftText, HTML, RightText);

			if(LeftText != "" || R.DisplayString == "")
			{
				R.DisplayString = R.DisplayString $ LeftText;
				R.StyleString = R.StyleString $ WriteStyleText(CurrentStyle, Len(LeftText));
			}

			ProcessInlineHTML(HTML, CurrentStyle);
			SetCanvasStyle(C, CurrentStyle);

			Input = RightText;
		}

		R = UWindowHTMLTextRow(R.Next);
	}
}

function float DrawTextLine(Canvas C, UWindowDynamicTextRow L, float Y)
{
	local float X, W, H, MouseX, MouseY;
	local HTMLStyle CurrentStyle;
	local float RowHeight;
	local Color OldColor;
	local int StylePos, DisplayPos, i;
	local string S;

	RowHeight = 0;

	CurrentStyle = UWindowHTMLTextRow(L).StartStyle;
	if(CurrentStyle.bCenter)
	{
		W = CalcHTMLTextWidth(C, L.Text, CurrentStyle);
		if(VertSB.bWindowVisible)
			X = int(((WinWidth - VertSB.WinWidth) - W) / 2);
		else
			X = int((WinWidth - W) / 2);
	}
	else
		X = 2;

	if(GetEntryLevel().TimeSeconds > LastBlinkTime + 0.5)
	{
		bShowBlink = !bShowBlink;
		LastBlinkTime = GetEntryLevel().TimeSeconds;
	}

	if(UWindowHTMLTextRow(L).DisplayString == "")
		SetCanvasStyle(C, CurrentStyle);
	else
	{
		while(DisplayPos < Len(UWindowHTMLTextRow(L).DisplayString))
		{
			i = ReadStyleText(UWindowHTMLTextRow(L).StyleString, StylePos, CurrentStyle);
			S = Mid(UWindowHTMLTextRow(L).DisplayString, DisplayPos, i);
			DisplayPos += i;
			SetCanvasStyle(C, CurrentStyle);

			TextAreaTextSize(C, S, W, H);
			if(H > RowHeight)
				RowHeight = H;

			if(CurrentStyle.bLink)
			{
				GetMouseXY(MouseX, MouseY);
				if(X < MouseX && X + W > MouseX && Y < MouseY && Y + H > MouseY)
				{
					Cursor = Root.HandCursor;
					OverURL(CurrentStyle.LinkDestination);

					if(bMouseDown || bReleased)
					{
						if(bReleased)
						{
							ProcessURL(CurrentStyle.LinkDestination);
							bReleased = False;
						}
						else
							C.DrawColor = ALinkColor;
					}
				}
			}

			if(CurrentStyle.BGColor != BGColor)
			{
				OldColor = C.DrawColor;
				C.DrawColor = CurrentStyle.BGColor;
				DrawStretchedTexture(C, X, Y, W, H, Texture'WhiteTexture');
				C.DrawColor = OldColor;
			}
			if(!CurrentStyle.bBlink || bShowBlink)
				TextAreaClipText(C, X, Y, S);
			if(CurrentStyle.bLink || CurrentStyle.bUnderline)
				DrawStretchedTexture(C, X, Y+H-1, W, 1, Texture'WhiteTexture');

			X += W;
		}
	}
	if(RowHeight == 0)
		TextAreaTextSize(C, "A", W, RowHeight);

	return RowHeight;
}

function UWindowDynamicTextRow SplitRowAt(UWindowDynamicTextRow L, int SplitPos)
{
	local UWindowDynamicTextRow N;
	local HTMLStyle CurrentStyle;

	N = Super.SplitRowAt(L, SplitPos);

	// update the style by processing from the start of L to the split position.
	UWindowHTMLTextRow(N).EndStyle = UWindowHTMLTextRow(L).EndStyle;
	CurrentStyle = UWindowHTMLTextRow(L).StartStyle;
	HTMLUpdateStyle(L.Text, CurrentStyle);
	UWindowHTMLTextRow(L).EndStyle = CurrentStyle;
	UWindowHTMLTextRow(N).StartStyle = CurrentStyle;

	return N;
}

function RemoveWrap(UWindowDynamicTextRow L)
{
	local UWindowDynamicTextRow N;

	// copy final endstyle to current row
	N = UWindowDynamicTextRow(L.Next);
	while(N != None && N.WrapParent == L)
	{
		UWindowHTMLTextRow(L).EndStyle = UWindowHTMLTextRow(N).EndStyle;
		N = UWindowDynamicTextRow(N.Next);
	}

	Super.RemoveWrap(L);
}

function int GetWrapPos(Canvas C, UWindowDynamicTextRow L, float MaxWidth)
{
	local float LineWidth, NextWordWidth;
	local string Input, NextWord;
	local int WordsThisRow, WrapPos;
	local HTMLStyle CurrentStyle;

	CurrentStyle = UWindowHTMLTextRow(L).StartStyle;

	// quick check
	if(CalcHTMLTextWidth(C, L.Text, CurrentStyle) <= MaxWidth)
		return -1;

	Input = L.Text;
	WordsThisRow = 0;
	LineWidth = 0;
	WrapPos = 0;
	NextWord = "";
	CurrentStyle = UWindowHTMLTextRow(L).StartStyle;

	while(Input != "" || NextWord != "")
	{
		if(NextWord == "")
		{
			RemoveNextWord(Input, NextWord);
			NextWordWidth = CalcHTMLTextWidth(C, NextWord, CurrentStyle);
		}
		if(WordsThisRow > 0 && LineWidth + NextWordWidth > MaxWidth)
		{
			return WrapPos;
		}
		else
		{
			WrapPos += Len(NextWord);
			LineWidth += NextWordWidth;
			NextWord = "";
			WordsThisRow++;
		}
	}
	return -1;
}

// Find the next word - but don't split up HTML tags.
function RemoveNextWord(out string Text, out string NextWord)
{
	local int i;
	local bool bInsideTag;
	local string Ch;

	bInsideTag = False;

	for(i=0;i<Len(Text);i++)
	{
		Ch = Mid(Text, i, 1);
		if(Ch == ">")
			bInsideTag = False;
		if(Ch == "<")
			bInsideTag = True;
		if(Ch == " " && !bInsideTag)
			break;
	}
	while(Mid(Text, i, 1) == " ")
		i++;
	NextWord = Left(Text, i);
	Text = Mid(Text, i);
}

function UWindowDynamicTextRow AddText(string NewLine)
{
	local string Input, Output, LeftText, RightText, HTML, Temp;
	local int i;
	local UWindowDynamicTextRow L;
	local HTMLStyle CurrentStyle, StartStyle;

	if(List.Last == List)
	{
		CurrentStyle.BulletLevel = 0;
		CurrentStyle.LinkDestination = "";
		CurrentStyle.TextColor = TextColor;
		CurrentStyle.BGColor = BGColor;
		CurrentStyle.bCenter = bHCenter;
		CurrentStyle.bLink = False;
		CurrentStyle.bUnderline = False;
		CurrentStyle.bNoBR = False;
		CurrentStyle.bHeading = False;
		CurrentStyle.bBold = False;
		CurrentStyle.bBlink = False;
	}
	else
		CurrentStyle = UWindowHTMLTextRow(List.Last).EndStyle;
	StartStyle = CurrentStyle;

	// convert \\n's -> <br>'s
	i = InStr(NewLine, "\\n");
	while(i != -1)
	{
		NewLine = Left(NewLine, i) $ "<br>" $ Mid(NewLine, i + 2);
		i = InStr(NewLine, "\\n");
	}

	Input = NewLine;
	Output = "";
	while(Input != "")
	{
		ParseHTML(Input, LeftText, HTML, RightText);

		switch(GetTag(HTML))
		{
		// multiline HTML tags
		case "P":
			if((Output $ LeftText) != "")
			{
				L = Super.AddText(Output $ LeftText);
				Output = "";
				UWindowHTMLTextRow(L).StartStyle = StartStyle;
				UWindowHTMLTextRow(L).EndStyle = CurrentStyle;
			}
			StartStyle = CurrentStyle;
			L = Super.AddText("");
			UWindowHTMLTextRow(L).StartStyle = StartStyle;
			UWindowHTMLTextRow(L).EndStyle = CurrentStyle;
			break;
		case "BR":
			L = Super.AddText(Output $ LeftText);
			Output = "";
			UWindowHTMLTextRow(L).StartStyle = StartStyle;
			UWindowHTMLTextRow(L).EndStyle = CurrentStyle;
			StartStyle = CurrentStyle;
			break;
		case "BODY":
			Temp = GetOption(HTML, "BGCOLOR=");
			if(Temp != "")
			{
				BGColor = ParseColor(Temp);
				CurrentStyle.BGColor = BGColor;
				StartStyle.BGColor = BGColor;
			}

			Temp = GetOption(HTML, "LINK=");
			if(Temp != "")
				LinkColor = ParseColor(Temp);

			Temp = GetOption(HTML, "ALINK=");
			if(Temp != "")
				ALinkColor = ParseColor(Temp);

			Temp = GetOption(HTML, "TEXT=");
			if(Temp != "")
			{
				TextColor = ParseColor(Temp);
				CurrentStyle.TextColor = TextColor;
			}
			Output = Output $ LeftText;
			break;
		case "CENTER":
			if((Output $ LeftText) != "")
			{
				L = Super.AddText(Output $ LeftText);
				Output = "";
				UWindowHTMLTextRow(L).StartStyle = StartStyle;
				UWindowHTMLTextRow(L).EndStyle = CurrentStyle;
			}
			CurrentStyle.bCenter = True;
			StartStyle = CurrentStyle;
			break;
		case "/CENTER":
			L = Super.AddText(Output $ LeftText);
			Output = "";
			UWindowHTMLTextRow(L).StartStyle = StartStyle;
			UWindowHTMLTextRow(L).EndStyle = CurrentStyle;
			CurrentStyle.bCenter = False;
			StartStyle = CurrentStyle;
			break;
		// Inline HTML tags
		case "H1":
			if((Output $ LeftText) != "")
			{
				L = Super.AddText(Output $ LeftText);
				Output = "";
				UWindowHTMLTextRow(L).StartStyle = StartStyle;
				UWindowHTMLTextRow(L).EndStyle = CurrentStyle;
			}
			CurrentStyle.bHeading = True;
			StartStyle = CurrentStyle;
			break;
		case "/H1":
			L = Super.AddText(Output $ LeftText);
			Output = "";
			UWindowHTMLTextRow(L).StartStyle = StartStyle;
			UWindowHTMLTextRow(L).EndStyle = CurrentStyle;
			CurrentStyle.bHeading = False;
			StartStyle = CurrentStyle;
			break;
		case "FONT":
			Output = Output $ LeftText $ HTML;
			Temp = GetOption(HTML, "COLOR=");
			if(Temp != "")
				CurrentStyle.TextColor = ParseColor(Temp);
			Temp = GetOption(HTML, "BGCOLOR=");
			if(Temp != "")
				CurrentStyle.BGColor = ParseColor(Temp);
			break;
		case "/FONT":
			Output = Output $ LeftText $ HTML;
			CurrentStyle.TextColor = TextColor;
			CurrentStyle.BGColor = BGColor;
			break;
		case "B":
			Output = Output $ LeftText $ HTML;
			CurrentStyle.bBold = True;
			break;
		case "/B":
			Output = Output $ LeftText $ HTML;
			CurrentStyle.bBold = False;
			break;
		case "U":
			Output = Output $ LeftText $ HTML;
			CurrentStyle.bUnderline = True;
			break;
		case "/U":
			Output = Output $ LeftText $ HTML;
			CurrentStyle.bUnderline = False;
			break;
		case "A":
			Output = Output $ LeftText $ HTML;
			CurrentStyle.bLink = True;
			CurrentStyle.LinkDestination = GetOption(HTML, "HREF=");
			break;
		case "/A":
			Output = Output $ LeftText $ HTML;
			CurrentStyle.bLink = False;
			CurrentStyle.LinkDestination = "";
			break;
		case "NOBR":
			Output = Output $ LeftText $ HTML;
			CurrentStyle.bNoBR = True;
			break;
		case "/NOBR":
			Output = Output $ LeftText $ HTML;
			CurrentStyle.bNoBR = False;
			break;
		case "BLINK":
			Output = Output $ LeftText $ HTML;
			CurrentStyle.bBlink = True;
			break;
		case "/BLINK":
			Output = Output $ LeftText $ HTML;
			CurrentStyle.bBlink = False;
			break;
		default:
			Output = Output $ LeftText;
			break;
		}
		Input = RightText;
	}

	L = Super.AddText(Output);
	UWindowHTMLTextRow(L).StartStyle = StartStyle;
	UWindowHTMLTextRow(L).EndStyle = CurrentStyle;

	return L;
}

///////////////////////////////////////////////////
// HTML Text Processing
///////////////////////////////////////////////////

// Get the next HTML tag, the text before it and everthing after it.
function ParseHTML(string Input, out string LeftText, out string HTML, out string RightText)
{
	local int i;

	i = InStr(Input, "<");
	if(i == -1)
	{
		LeftText = Input;
		HTML = "";
		RightText = "";
		return;
	}

	LeftText = Left(Input, i);
	HTML = Mid(Input, i);

	i = InStr(HTML, ">");
	if(i == -1)
	{
		RightText = "";
		return;
	}

	RightText = Mid(HTML, i+1);
	HTML = Left(HTML, i+1);
}

function float CalcHTMLTextWidth(Canvas C, string Text, out HTMLStyle CurrentStyle)
{
	local string Input, LeftText, HTML, RightText;
	local float W, H, Width;

	Width = 0;
	Input = Text;
	while(Input != "")
	{
		ParseHTML(Input, LeftText, HTML, RightText);

		SetCanvasStyle(C, CurrentStyle);
		TextAreaTextSize(C, LeftText, W, H);
		Width += W;

		ProcessInlineHTML(HTML, CurrentStyle);

		Input = RightText;
	}

	return Width;
}

// Update CurrentStyle based on the contents of the HTML tag provided
function ProcessInlineHTML(string HTML, out HTMLStyle CurrentStyle)
{
	local string Temp;

	if(HTML == "")
		return;

	switch(GetTag(HTML))
	{
	case "H1":
		CurrentStyle.bHeading = True;
		break;
	case "/H1":
		CurrentStyle.bHeading = False;
		break;
	case "FONT":
		Temp = GetOption(HTML, "COLOR=");
		if(Temp != "")
			CurrentStyle.TextColor = ParseColor(Temp);
		Temp = GetOption(HTML, "BGCOLOR=");
		if(Temp != "")
			CurrentStyle.BGColor = ParseColor(Temp);
		break;
	case "/FONT":
		CurrentStyle.TextColor = TextColor;
		CurrentStyle.BGColor = BGColor;
		break;
	case "B":
		CurrentStyle.bBold = True;
		break;
	case "/B":
		CurrentStyle.bBold = False;
		break;
	case "U":
		CurrentStyle.bUnderline = True;
		break;
	case "/U":
		CurrentStyle.bUnderline = False;
		break;
	case "A":
		CurrentStyle.bLink = True;
		CurrentStyle.LinkDestination = GetOption(HTML, "HREF=");
		break;
	case "/A":
		CurrentStyle.bLink = False;
		CurrentStyle.LinkDestination = "";
		break;
	case "NOBR":
		CurrentStyle.bNoBR = True;
		break;
	case "/NOBR":
		CurrentStyle.bNoBR = False;
		break;
	case "BLINK":
		CurrentStyle.bBlink = True;
		break;
	case "/BLINK":
		CurrentStyle.bBlink = False;
		break;
	}
}

// update the current style based on some text input
function HTMLUpdateStyle(string Input, out HTMLStyle CurrentStyle)
{
	local string LeftText, HTML, RightText;

	while(Input != "")
	{
		ParseHTML(Input, LeftText, HTML, RightText);
		ProcessInlineHTML(HTML, CurrentStyle);
		Input = RightText;
	}
}

function string GetOption(string HTML, string Option)
{
	local int i, j;
	local string s;

	i = InStr(Caps(HTML), Caps(Option));

	if(i == 1 || Mid(HTML, i-1, 1) == " ")
	{
		s = Mid(HTML, i+Len(Option));
		j = FirstMatching(InStr(s, ">"), InStr(s, " "));
		s = Left(s, j);

		if(Left(s, 1) == "\"")
			s = Mid(s, 1);

		if(Right(s, 1) == "\"")
			s = Left(s, Len(s) - 1);

		return s;
	}
	return "";
}

function string GetTag(string HTML)
{
	local int i;

	if(HTML == "")
		return "";

	HTML = Mid(HTML, 1); // lose <

	i = FirstMatching(InStr(HTML, ">"), InStr(HTML, " "));
	if(i == -1)
		return Caps(HTML);
	else
		return Caps(Left(HTML, i));
}

function Color ParseColor(string S)
{
	local Color C;

	if(Left(S, 1) == "#")
		S = Mid(S, 1);

	C.R = 16 * GetHexDigit(Mid(S, 0, 1)) + GetHexDigit(Mid(S, 1, 1));
	C.G = 16 * GetHexDigit(Mid(S, 2, 1)) + GetHexDigit(Mid(S, 3, 1));
	C.B = 16 * GetHexDigit(Mid(S, 4, 1)) + GetHexDigit(Mid(S, 5, 1));

	return C;
}

function int GetHexDigit(string D)
{
	switch(caps(D))
	{
	case "0": return 0;
	case "1": return 1;
	case "2": return 2;
	case "3": return 3;
	case "4": return 4;
	case "5": return 5;
	case "6": return 6;
	case "7": return 7;
	case "8": return 8;
	case "9": return 9;
	case "A": return 10;
	case "B": return 11;
	case "C": return 12;
	case "D": return 13;
	case "E": return 14;
	case "F": return 15;
	}

	return 0;
}

function int FirstMatching(int i, int j)
{
	if(i == -1)
		return j;

	if(j == -1)
		return i;
	else
		return Min(i, j);
}

function SetCanvasStyle(Canvas C, HTMLStyle CurrentStyle)
{
	if(CurrentStyle.bLink)
		C.DrawColor = LinkColor;
	else
		C.DrawColor = CurrentStyle.TextColor;

	if(CurrentStyle.bHeading)
		C.Font = Root.Fonts[F_Normal];
	else
	if(CurrentStyle.bBold)
		C.Font = Root.Fonts[F_Bold];
	else
		C.Font = Root.Fonts[F_Normal];
}

function string WriteStyleText(HTMLStyle CurrentStyle, int CharCount)
{
	local string Pad;
	local string Temp;
	local string Output;

	Pad = "0000";

	Temp = string(CharCount);
	Output = Left(Pad, 4 - Len(Temp)) $ Temp;

	Temp = string(Len(CurrentStyle.LinkDestination));
	Output = Output $ Left(Pad, 4 - Len(Temp)) $ Temp $ CurrentStyle.LinkDestination;

	Temp = string(CurrentStyle.TextColor.R);
	Output = Output $ Left(Pad, 3 - Len(Temp)) $ Temp;
	Temp = string(CurrentStyle.TextColor.G);
	Output = Output $ Left(Pad, 3 - Len(Temp)) $ Temp;
	Temp = string(CurrentStyle.TextColor.B);
	Output = Output $ Left(Pad, 3 - Len(Temp)) $ Temp;

	Temp = string(CurrentStyle.BGColor.R);
	Output = Output $ Left(Pad, 3 - Len(Temp)) $ Temp;
	Temp = string(CurrentStyle.BGColor.G);
	Output = Output $ Left(Pad, 3 - Len(Temp)) $ Temp;
	Temp = string(CurrentStyle.BGColor.B);
	Output = Output $ Left(Pad, 3 - Len(Temp)) $ Temp;

	if(CurrentStyle.bCenter)
		Output = Output $ "T";
	else
		Output = Output $ "F";

	if(CurrentStyle.bLink)
		Output = Output $ "T";
	else
		Output = Output $ "F";

	if(CurrentStyle.bUnderline)
		Output = Output $ "T";
	else
		Output = Output $ "F";

	if(CurrentStyle.bNoBR)
		Output = Output $ "T";
	else
		Output = Output $ "F";

	if(CurrentStyle.bHeading)
		Output = Output $ "T";
	else
		Output = Output $ "F";

	if(CurrentStyle.bBold)
		Output = Output $ "T";
	else
		Output = Output $ "F";

	if(CurrentStyle.bBlink)
		Output = Output $ "T";
	else
		Output = Output $ "F";

	return Output;
}

function int ReadStyleText(string StyleString, out int StylePos, out HTMLStyle CurrentStyle)
{
	local int CharCount;
	local int i;

	CharCount = Int(Mid(StyleString, StylePos, 4));
	StylePos += 4;

	i = Int(Mid(StyleString, StylePos, 4));
	StylePos += 4;

	CurrentStyle.LinkDestination = Mid(StyleString, StylePos, i);
	StylePos += i;

	CurrentStyle.TextColor.R = Int(Mid(StyleString, StylePos, 3));
	StylePos += 3;
	CurrentStyle.TextColor.G = Int(Mid(StyleString, StylePos, 3));
	StylePos += 3;
	CurrentStyle.TextColor.B = Int(Mid(StyleString, StylePos, 3));
	StylePos += 3;

	CurrentStyle.BGColor.R = Int(Mid(StyleString, StylePos, 3));
	StylePos += 3;
	CurrentStyle.BGColor.G = Int(Mid(StyleString, StylePos, 3));
	StylePos += 3;
	CurrentStyle.BGColor.B = Int(Mid(StyleString, StylePos, 3));
	StylePos += 3;

	CurrentStyle.bCenter = Mid(StyleString, StylePos++, 1) == "T";
	CurrentStyle.bLink = Mid(StyleString, StylePos++, 1) == "T";
	CurrentStyle.bUnderline = Mid(StyleString, StylePos++, 1) == "T";
	CurrentStyle.bNoBR = Mid(StyleString, StylePos++, 1) == "T";
	CurrentStyle.bHeading = Mid(StyleString, StylePos++, 1) == "T";
	CurrentStyle.bBold = Mid(StyleString, StylePos++, 1) == "T";
	CurrentStyle.bBlink = Mid(StyleString, StylePos++, 1) == "T";

	return CharCount;
}

defaultproperties
{
	RowClass=class'UWindowHTMLTextRow'
	TextColor=(R=255,G=255,B=255,A=255)
	BGColor=(R=0,G=0,B=0,A=255)
	LinkColor=(R=0,G=0,B=255,A=255)
	ALinkColor=(R=255,G=0,B=0,A=255)
	bIgnoreLDoubleClick=True
	bAutoScrollbar=True
	bTopCentric=True
	bVariableRowHeight=True
}
class UWindowHTMLTextRow extends UWindowDynamicTextRow;



var HTMLStyle StartStyle; // style at start of line
var HTMLStyle EndStyle;	  // style at end of line

var string DisplayString;
var string StyleString;
class UWindowLabelControl extends UWindowDialogControl;



function Created()
{
	TextX = 0;
	TextY = 0;
}

function BeforePaint(Canvas C, float X, float Y)
{
	local float W, H;

	// Implemented in a child class

	Super.BeforePaint(C, X, Y);

	TextSize(C, Text, W, H);
	WinHeight = H+1;
	//WinWidth = W+1;
	TextY = (WinHeight - H) / 2;
	switch (Align)
	{
		case TA_Left:
			break;
		case TA_Center:
			TextX = (WinWidth - W)/2;
			break;
		case TA_Right:
			TextX = WinWidth - W;
			break;
	}
}

function Paint(Canvas C, float X, float Y)
{
	if(Text != "")
	{
		C.SetDrawColor(TextColor.R,TextColor.G,TextColor.B);
		C.Font = Root.Fonts[Font];
		ClipText(C, TextX, TextY, Text);
		C.SetDrawColor(255,255,255);
	}
}
class UWindowLayoutBase extends UWindowList;



enum EVerticalAlign
{
	VA_Middle,
	VA_Top,
	VA_Bottom,
};

enum EHorizAlign
{
	HA_Center,
	HA_Left,
	HA_Right,
};

class UWindowLayoutCell extends UWindowLayoutBase;




// Cell Layout Parameters
var int					RowSpan;
var int					ColSpan;
var EHorizAlign			HAlign;
var EVerticalAlign		VAlign;

var UWindowDialogControl C;


defaultproperties
{
	RowSpan=0
	ColSpan=0
	HAlign=HA_Center
	VAlign=VA_Middle
}

class UWindowLayoutControl extends UWindowLayoutBase;



var UWindowDialogClientWindow	OwnerWindow;

var float				WinTop;
var float				WinLeft;
var float				WinWidth;
var float				WinHeight;

var float				MinimumWidth;
var float				MinimumHeight;


var UWindowLayoutRow	RowList;


// Methods
static function UWindowLayoutControl Create()
{
	local UWindowLayoutControl C;

	C = new( None ) class'UWindowLayoutControl';
	C.RowList = new( None ) class'UWindowLayoutRow';
	C.RowList.SetupSentinel();

	return C;
}


/*
Layout procedure

1.  Calculate minimum (desired) row height by asking
    controls
2.  For each column, work out the minimum (desired) width for this column.
    Then add these up and

	.
2.	If this is less than WinHeight, space cells to fit.
3.	If this is more than WinHeight, adjust parent
    window's DesiredWidth/DesiredHeight variables to cause scrolling.


*/

function PerformLayout()
{
	local UWindowLayoutRow R;
	local float TotalWidth;
	local float TotalHeight;

	for(R = UWindowLayoutRow(RowList.Next); R != None; R = UWindowLayoutRow(R.Next))
		TotalHeight += R.CalcMinHeight();


		TotalWidth += R.CalcMinHeight();


}

function UWindowLayoutRow AddRow()
{
	return UWindowLayoutRow(RowList.Append(class'UWindowLayoutRow'));
}

function UWindowLayoutCell AddCell(optional int ColSpan, optional int RowSpan)
{
	return RowList.AddCell(ColSpan, RowSpan);
}


class UWindowLayoutRow extends UWindowLayoutBase;



var UWindowLayoutCell	CellList;

function SetupSentinel(optional bool bInTreeSort)
{
	Super.SetupSentinel(bInTreeSort);
	CellList = new( None ) class'UWindowLayoutCell';
	CellList.SetupSentinel();
}


function UWindowLayoutCell AddCell(optional int ColSpan, optional int RowSpan)
{
	local UWindowLayoutCell C;

	C = UWindowLayoutCell(CellList.Append(class'UWindowLayoutCell'));
	C.ColSpan = ColSpan;
	C.RowSpan = RowSpan;

	return C;
}

function float CalcMinHeight()
{
	return 0;
}
//=============================================================================
// UWindowList - a generic linked list class
//=============================================================================
class UWindowList extends UWindowBase;



var UWindowList	Next;
var UWindowList	Last;		// Only valid for sentinel
var UWindowList	Prev;
var UWindowList	Sentinel;
var int			InternalCount;
var bool		bItemOrderChanged;

var bool		bSuspendableSort;

var int			CompareCount;
var bool		bSortSuspended;
var UWindowList CurrentSortItem;

// Binary tree variables for sentinel
var bool		bTreeSort;

// Binary tree variables for each element
var UWindowList BranchLeft;
var UWindowList BranchRight;
var UWindowList ParentNode;

var int Tag;

/* Tree Sorting:

- Items must be added with AppendItem()
- Items which require resorting must call MoveItemSorted()
- Should call Tick and set bSuspendableSort - for large sorts!

*/

/********** These things can be called on any element **********/

function UWindowList CreateItem(Class<UWindowList> C)
{
	local UWindowList NewElement;

	NewElement = new( None ) C;
	return NewElement;
}

function GraftLeft(UWindowList NewLeft)
{
	assert(Sentinel.bTreeSort);

	BranchLeft = NewLeft;
	if(NewLeft != None)
		NewLeft.ParentNode = Self;
}

function GraftRight(UWindowList NewRight)
{
	assert(Sentinel.bTreeSort);

	BranchRight = NewRight;
	if(NewRight != None)
		NewRight.ParentNode = Self;
}

// Return rightmost child of subtree
function UWindowList RightMost()
{
	local UWindowList L;

	assert(Sentinel.bTreeSort);

	if(BranchRight == None)
		return None;

	L = Self;
	while(L.BranchRight != None)
		L = L.BranchRight;

	return L;
}

// Return leftmost child of subtree
function UWindowList LeftMost()
{
	local UWindowList L;

	assert(Sentinel.bTreeSort);

	if(BranchLeft == None)
		return None;

	L = Self;
	while(L.BranchLeft != None)
		L = L.BranchLeft;

	return L;
}

function Remove()
{
	local UWindowList T;

	if(Next != None)
		Next.Prev = Prev;

	if(Prev != None)
		Prev.Next = Next;

	if(Sentinel != None)
	{
		if(Sentinel.bTreeSort && ParentNode!=None)
		{
			if(BranchLeft != None)
			{
				if(ParentNode.BranchLeft == Self)
					ParentNode.GraftLeft(BranchLeft);
				if(ParentNode.BranchRight == Self)
					ParentNode.GraftRight(BranchLeft);

				// If we had a right branch we better move it
				// into the far right of the left branch.

				T = BranchLeft.Rightmost();
				if(T != None)
					T.GraftRight(BranchRight);
			}
			else
			{
				if(ParentNode.BranchLeft == Self)
					ParentNode.GraftLeft(BranchRight);
				if(ParentNode.BranchRight == Self)
					ParentNode.GraftRight(BranchRight);

				// no left branch to worry about.
			}

			ParentNode = None;
			BranchLeft = None;
			BranchRight = None;
		}

		Sentinel.InternalCount--;
		Sentinel.bItemOrderChanged = True;

		if(Sentinel.Last == Self)
			Sentinel.Last = Prev;

		Prev=None;
		Next=None;

	/*	Sentinel.Validate();  */
		Sentinel = None;
	}
}

function int Compare(UWindowList T, UWindowList B)
{
	// declare actual sort method in subclass
	return 0;
}

// Inserts a new element before us.  DO NOT CALL on the sentinel.
function UWindowList InsertBefore(Class<UWindowList> C)
{
	local UWindowList NewElement;

	NewElement = CreateItem(C);
	InsertItemBefore(NewElement);

	return NewElement;
}

function UWindowList InsertAfter(Class<UWindowList> C)
{
	local UWindowList NewElement;

	NewElement = CreateItem(C);
	InsertItemAfter(NewElement);

	return NewElement;
}


// Inserts an element before us.  DO NOT CALL on the sentinel.
function InsertItemBefore(UWindowList NewElement)
{
	assert(Sentinel != Self);

	NewElement.BranchLeft = None;
	NewElement.BranchRight = None;
	NewElement.ParentNode = None;
	NewElement.Sentinel = Sentinel;
	NewElement.BranchLeft = None;
	NewElement.BranchRight = None;
	NewElement.ParentNode = None;
	NewElement.Prev = Prev;
	Prev.Next = NewElement;
	Prev = NewElement;
	NewElement.Next = Self;

	if(Sentinel.Next == Self)
		Sentinel.Next = NewElement;

	Sentinel.InternalCount++;
	Sentinel.bItemOrderChanged = True;
}

function InsertItemAfter(UWindowList NewElement, optional bool bCheckShowItem)
{
	local UWindowList N;

	N = Next;
	if(bCheckShowItem)
		while(N != None && !N.ShowThisItem())
			N = N.Next;

	if(N != None)
		N.InsertItemBefore(NewElement);
	else
		Sentinel.DoAppendItem(NewElement);
	Sentinel.bItemOrderChanged = True;
}

function ContinueSort()
{
	local UWindowList N;

	CompareCount = 0;
	bSortSuspended = False;

	while(CurrentSortItem != None)
	{
		N = CurrentSortItem.Next;
		AppendItem(CurrentSortItem);
		CurrentSortItem = N;

		// split sort over multiple frames, if it's BIG
		if(CompareCount >= 10000 && bSuspendableSort)
		{
			bSortSuspended = True;
			return;
		}
	}
}

function Tick(float Delta)
{
	if(bSortSuspended)
		ContinueSort();
}

function UWindowList Sort()
{
	local UWindowList S;
	local UWindowList CurrentItem;
	local UWindowList Previous;
	local UWindowList Best;
	local UWindowList BestPrev;

	if(bTreeSort)
	{
		if(bSortSuspended)
		{
			ContinueSort();
			return Self;
		}

		CurrentSortItem = Next;
		DisconnectList();
		ContinueSort();
		return Self;
	}

	CurrentItem = Self;

	while(CurrentItem != None)
	{
		S = CurrentItem.Next;	Best = CurrentItem.Next;
		Previous = CurrentItem;	BestPrev = CurrentItem;

		// Find the best server
		while(S != None)
		{
			if(CurrentItem.Compare(S, Best) <= 0)
			{
				Best = S;
				BestPrev = Previous;
			}

			Previous = S;
			S = S.Next;
		}

		// If we're not already in the right order, move the best one next.
		if(Best != CurrentItem.Next)
		{
			// Delete Best's old position
			BestPrev.Next = Best.Next;
			if(BestPrev.Next != None)
				BestPrev.Next.Prev = BestPrev;

			// Fix Self and Best
			Best.Prev = CurrentItem;
			Best.Next = CurrentItem.Next;
			CurrentItem.Next.Prev = Best;
			CurrentItem.Next = Best;

			// Fix up Sentinel if Best was also Last
			if(Sentinel.Last == Best)
			{
				Sentinel.Last = BestPrev;
				if(Sentinel.Last == None)
					Sentinel.Last = Sentinel;
			}
		}

		CurrentItem = CurrentItem.Next;
	}

	//Validate();
	return Self;
}

function DisconnectList()
{
	Next=None;
	Last=Self;
	Prev=None;
	BranchLeft = None;
	BranchRight = None;
	ParentNode = None;
	InternalCount = 0;
	Sentinel.bItemOrderChanged = True;
}

function DestroyList()
{
	local UWindowList L, Temp;
	L = Next;

	InternalCount = 0;
	if(Sentinel != None)
		Sentinel.bItemOrderChanged = True;

	while(L != None)
	{
		Temp = L.Next;
		L.DestroyListItem();
		L = Temp;
	}
	DestroyListItem();
}

function DestroyListItem()
{
	Next=None;
	Last=Self;
	Sentinel=None;
	Prev=None;
	BranchLeft=None;
	BranchRight=None;
	ParentNode=None;
}

function int CountShown()
{
	local int C;
	local UWindowList I;

	for(I = Next;I != None; I = I.Next)
		if(I.ShowThisItem())
			C++;

	return C;
}

function int CountTotal()
{
	local int C;
	local UWindowList I;

	for(I = Next;I != None; I = I.Next)
		C++;

	return C;
}

function UWindowList CopyExistingListItem(Class<UWindowList> ItemClass, UWindowList SourceItem)
{
	local UWindowList I;

	I = Append(ItemClass);
	Sentinel.bItemOrderChanged = True;

	return I;
}

// for Listboxes only (so far)
function bool ShowThisItem()
{
	return True;
}

/********** These things can only be called on the sentinel **********/
function int Count()
{
	return InternalCount;
}

function MoveItemSorted(UWindowList Item)
{
	local UWindowList L;

	if(bTreeSort)
	{
		Item.Remove();
		AppendItem(Item);
	}
	else
	{
		for(L=Next;L != None; L = L.Next)
			if(Compare(Item, L) <= 0) break;

		if(L != Item)
		{
			Item.Remove();
			if(L == None)
				AppendItem(Item);
			else
				L.InsertItemBefore(Item);
		}
	}
}

function SetupSentinel(optional bool bInTreeSort)
{
	Last = Self;
	Next = None;
	Prev = None;
	BranchLeft = None;
	BranchRight = None;
	ParentNode = None;
	Sentinel = Self;
	InternalCount = 0;
	bItemOrderChanged = True;
	bTreeSort = bInTreeSort;
}

function Validate()
{
	local UWindowList I, Previous;
	local int Count;

	if(Sentinel != Self)
	{
		Log("Calling Sentinel.Validate() from "$Self);
		Sentinel.Validate();
		return;
	}

	Log("BEGIN Validate(): "$Class);

	Count = 0;
	Previous = Self;

	for(I = Next; I != None; I = I.Next)
	{
		Log("Checking item: "$Count);

		if(I.Sentinel != Self)
			Log("   I.Sentinel reference is broken");

		if(I.Prev != Previous)
			Log("   I.Prev reference is broken");

		if(Last == I && I.Next != None)
			Log("   Item is Sentinel.Last but Item has valid Next");

		if(I.Next == None && Last != I)
			Log("   Item is Item.Next is none, but Item is not Sentinel.Last");

		Previous = I;
		Count++;
	}

	Log("END Validate(): "$Class);
}

// For sentinel only
function UWindowList Append(Class<UWindowList> C)
{
	local UWindowList NewElement;

	NewElement = CreateItem(C);
	AppendItem(NewElement);

	return NewElement;
}

function AppendItem(UWindowList NewElement)
{
	local UWindowList Node, OldNode, Temp;
	local int Test;

	if(bTreeSort)
	{
		// Check for worst cases!
		if(Next != None && Last != Self)
		{
			if(Compare(NewElement, Last) >= 0)
			{
				// put at end of list
				Node = Last;
				Node.InsertItemAfter(NewElement, False);
				Node.GraftRight(NewElement);
				return;
			}

			if(Compare(NewElement, Next) <= 0)
			{
				// put at front of list
				Node = Next;
				Node.InsertItemBefore(NewElement);
				Node.GraftLeft(NewElement);
				return;
			}
		}

		Node = Self;
		while(True)
		{
			if(Node == Self)
				Test = 1;
			else
				Test = Compare(NewElement, Node);

			// special case for equality
			if(Test == 0)
			{
				Node.InsertItemAfter(NewElement, False);
				return;
			}
			else
			if(Test > 0)
			{
				// Traverse right
				OldNode = Node;
				Node = Node.BranchRight;
				if(Node == None)
				{
					// Move past equal values
					Temp = OldNode;
					while(Temp.Next != None && Temp.Next.ParentNode == None)
						Temp = Temp.Next;

					Temp.InsertItemAfter(NewElement, False);
					OldNode.GraftRight(NewElement);
					return;
				}
			}
			else
			{
				// Traverse left
				OldNode = Node;
				Node = Node.BranchLeft;
				if(Node == None)
				{
					OldNode.InsertItemBefore(NewElement);
					OldNode.GraftLeft(NewElement);
					return;
				}
			}
		}
	}
	else
		DoAppendItem(NewElement);
}

function DoAppendItem(UWindowList NewElement)
{
	NewElement.Next = None;
	Last.Next = NewElement;
	NewElement.Prev = Last;
	NewElement.Sentinel = Self;
	NewElement.BranchLeft = None;
	NewElement.BranchRight = None;
	NewElement.ParentNode = None;
	Last = NewElement;
	Sentinel.InternalCount++;
	Sentinel.bItemOrderChanged = True;
}


// For sentinel only
function UWindowList Insert(Class<UWindowList> C)
{
	local UWindowList NewElement;

	NewElement = CreateItem(C);
	InsertItem(NewElement);

	return NewElement;
}

function InsertItem(UWindowList NewElement)
{
	NewElement.Next = Next;
	if(Next != None)
		Next.Prev = NewElement;
	Next = NewElement;
	if(Last == Self)
		Last = Next;
	NewElement.Prev = Self;
	NewElement.Sentinel = Self;
	NewElement.BranchLeft = None;
	NewElement.BranchRight = None;
	NewElement.ParentNode = None;
	Sentinel.InternalCount++;
	Sentinel.bItemOrderChanged = True;
}

// For sentinel only
function UWindowList FindEntry(int Index)
{
	local UWindowList l;
	local int i;

	l = Next;
	for(i=0;i<Index;i++)
	{
		l = l.Next;
		if(l==None) return None;
	}
	return l;
}

function AppendListCopy(UWindowList L)
{
	if(L == None)
		return;

	for(L = L.Next;L != None; L = L.Next)
		CopyExistingListItem(L.Class, L);
}

function Clear()
{
	InternalCount = 0;
	ParentNode = None;
	BranchLeft = None;
	BranchRight = None;
	bItemOrderChanged = True;
	Next = None;
	Last = Self;
}
//=============================================================================
// UWindowListBox - a listbox
//=============================================================================
class UWindowListBox extends UWindowListControl;



var float				ItemHeight;
var UWindowVScrollbar	VertSB;
var UWindowListBoxItem	SelectedItem;

var bool				bCanDrag;
var bool				bCanDragExternal;
var string				DefaultHelpText;
var bool				bDragging;
var float				DragY;
var UWindowListBox		DoubleClickList;	// list to send items to on double-click

var bool				bHotTrack;	// Auto select when the mouse is over.

function Created()
{
	Super.Created();
	VertSB = UWindowVScrollbar(CreateWindow(class'UWindowVScrollbar', WinWidth-12, 0, 12, WinHeight));
}

function ClearList()
{
	Items.DestroyList();
}

function int Count()
{
	return Items.CountTotal();
}

function UWindowListBoxItem GetItemAtIdx( int nIdx )
{
	return UWindowListBoxItem(Items.FindEntry( nIdx ));
}

function UWindowListBoxItem AddItem(string C)
{
	local UWindowListBoxItem I;

	I = UWindowListBoxItem(Items.Append(ListClass));
	I.Caption = c;

	return I;
}


function BeforePaint(Canvas C, float MouseX, float MouseY)
{
	local UWindowListBoxItem OverItem;
	local string NewHelpText;

	VertSB.SetRange(0, Items.CountShown(), int(WinHeight/ItemHeight));

	NewHelpText = DefaultHelpText;
	if(SelectedItem != None)
	{
		OverItem = GetItemAt(MouseX, MouseY);
		if(OverItem == SelectedItem && OverItem.HelpText != "")
			NewHelpText = OverItem.HelpText;
	}

	if(NewHelpText != HelpText)
	{
		HelpText = NewHelpText;
		Notify(DE_HelpChanged);
	}
}

function SetHelpText(string T)
{
	Super.SetHelpText(T);
	DefaultHelpText = T;
}

function Sort()
{
	Items.Sort();
}

function Paint(Canvas C, float MouseX, float MouseY)
{
	local float y;
	local UWindowList CurItem;
	local int i;
	local Color OldColor;
	CurItem = Items.Next;
	i = 0;

	while((CurItem != None) && (i < VertSB.Pos))
	{
		if(CurItem.ShowThisItem())
			i++;
		CurItem = CurItem.Next;
	}

	for(y=3;(y < WinHeight) && (CurItem != None);CurItem = CurItem.Next)
	{
		if(CurItem.ShowThisItem())
		{
			OldColor = TextColor;
			if (bHotTrack)
			{
				if ( (GetItemAt(MouseX, MouseY) == CurItem) && (CurItem != SelectedItem) )
				{
					TextColor = SelectionColor;
					TextColor.R = max(0,TextColor.R-96);
					TextColor.G = max(0,TextColor.G-96);
					TextColor.B = max(0,TextColor.B-96);
				}
			}

			if (VertSB.bWindowVisible)
				DrawItem(C, CurItem, 5, y, WinWidth - 12, ItemHeight);
			else
			    DrawItem(C, CurItem, 5, y, WinWidth, ItemHeight);
			y = y + ItemHeight;

			TextColor = OldColor;

		}
	}


}

function Resized()
{
	Super.Resized();

	VertSB.WinLeft = WinWidth-12;
	VertSB.WinTop = 0;
	VertSB.SetSize(12, WinHeight);
}

function UWindowListBoxItem GetItemAt(float MouseX, float MouseY)
{
	local float y;
	local UWindowList CurItem;
	local int i;

	if(MouseX < 0 || MouseX > WinWidth)
		return None;

	CurItem = Items.Next;
	i = 0;

	while((CurItem != None) && (i < VertSB.Pos))
	{
		if(CurItem.ShowThisItem())
			i++;
		CurItem = CurItem.Next;
	}

	for(y=0;(y < WinHeight) && (CurItem != None);CurItem = CurItem.Next)
	{
		if(CurItem.ShowThisItem())
		{
			if(MouseY >= y && MouseY <= y+ItemHeight)
				return UWindowListBoxItem(CurItem);
			y = y + ItemHeight;
		}
	}

	return None;
}

function MakeSelectedVisible()
{
	local UWindowList CurItem;
	local int i;

	VertSB.SetRange(0, Items.CountShown(), int(WinHeight/ItemHeight));

	if(SelectedItem == None)
		return;

	i = 0;
	for(CurItem=Items.Next; CurItem != None; CurItem = CurItem.Next)
	{
		if(CurItem == SelectedItem)
			break;
		if(CurItem.ShowThisItem())
			i++;
	}

	VertSB.Show(i);
}

function SetSelectedItem(UWindowListBoxItem NewSelected)
{
	if(NewSelected != None && SelectedItem != NewSelected)
	{
		if(SelectedItem != None)
			SelectedItem.bSelected = False;

		SelectedItem = NewSelected;

		if(SelectedItem != None)
			SelectedItem.bSelected = True;

		Notify(DE_Click);
	}
}

function SetSelected(float X, float Y)
{
	local UWindowListBoxItem NewSelected;

	NewSelected = GetItemAt(X, Y);
	SetSelectedItem(NewSelected);
}

function LMouseDown(float X, float Y)
{
	Super.LMouseDown(X, Y);

	SetSelected(X, Y);

	if(bCanDrag || bCanDragExternal)
	{
		bDragging = True;
		Root.CaptureMouse();
		DragY = Y;
	}
}

function DoubleClick(float X, float Y)
{
	Super.DoubleClick(X, Y);

	if(GetItemAt(X, Y) == SelectedItem)
	{
		DoubleClickItem(SelectedItem);
	}
}

function ReceiveDoubleClickItem(UWindowListBox L, UWindowListBoxItem I)
{
	I.Remove();
	Items.AppendItem(I);
	SetSelectedItem(I);
	L.SelectedItem = None;
	L.Notify(DE_Change);
	Notify(DE_Change);
}

function DoubleClickItem(UWindowListBoxItem I)
{
	if(DoubleClickList != None && I != None)
		DoubleClickList.ReceiveDoubleClickItem(Self, I);
}

function MouseMove(float X, float Y)
{
	local UWindowListBoxItem OverItem;


	Super.MouseMove(X, Y);

	if(bDragging && bMouseDown)
	{
		OverItem = GetItemAt(X, Y);
		if(bCanDrag && OverItem != SelectedItem && OverItem != None && SelectedItem != None)
		{
			SelectedItem.Remove();
			if(Y < DragY)
				OverItem.InsertItemBefore(SelectedItem);
			else
				OverItem.InsertItemAfter(SelectedItem, True);

			Notify(DE_Change);

			DragY = Y;
		}
		else
		{
			if(bCanDragExternal && CheckExternalDrag(X, Y) != None)
				bDragging = False;
		}
	}
	else
		bDragging = False;

//	if (bHotTrack)
//	{
//		OverItem = GetItemAt(X, Y);
//		SetSelectedItem(OverItem);
//	}

}

function bool ExternalDragOver(UWindowDialogControl ExternalControl, float X, float Y)
{
	local UWindowListBox B;
	local UWindowListBoxItem OverItem;

	// Subclass should return false and not call this version if this external
	// drag should be denied.

	B = UWindowListBox(ExternalControl);
	if(B != None && B.SelectedItem != None)
	{
		OverItem = GetItemAt(X, Y);

		B.SelectedItem.Remove();
		if(OverItem != None)
			OverItem.InsertItemBefore(B.SelectedItem);
		else
			Items.AppendItem(B.SelectedItem);

		SetSelectedItem(B.SelectedItem);
		B.SelectedItem = None;
		B.Notify(DE_Change);
		Notify(DE_Change);

		if(bCanDrag || bCanDragExternal)
		{
			Root.CancelCapture();
			bDragging = True;
			bMouseDown = True;
			Root.CaptureMouse(Self);
			DragY = Y;
		}

		return True;
	}

	return False;
}


function DrawItem(Canvas C, UWindowList Item, float X, float Y, float W, float H)
{

	local float TX,XL,YL;

// @@Joe - Fixed this to use the TextColor and fonts.  Much nicer :)
//   FIXME: Update to auto-set the item height


	if(UWindowListBoxItem(Item).bSelected)
	{
		if (!bNoSelectionBox)
		{
			C.DrawColor = SelectionBkgColor;
			DrawStretchedTexture(C, X, Y, W, H-1, Texture'WhiteTexture');
		}
		C.DrawColor = SelectionColor;
	}
	else
		C.DrawColor = TextColor;


	C.Font = Root.Fonts[Font];
	C.StrLen(UWindowListBoxItem(Item).Caption,XL,YL);

	switch (Align)
	{
		case TA_Left:
			TX = X+2;
		case TA_Center:
			TX = (W-4 - XL)/2;
			break;
		case TA_Right:
			TX = W-XL - W-2;
			break;
	}

	ClipText(C, TX, Y, UWindowListBoxItem(Item).Caption);

}

function KeyUp(int Key, float X, float Y)
{
	if ( (key==0xC8) || (key==78) )
	{
		If (SelectedItem.Prev.Prev!=None)
			SetSelectedItem(UWindowListBoxItem(SelectedItem.Prev));
	}
	else if ( (key==0xC9) || (key==80) )
	{
		If (SelectedItem.Next!=None)
			SetSelectedItem(UWindowListBoxItem(SelectedItem.Next));
	}
	else if ( (key==0xCD) || (key==0x0d) )
	{
		if ( (OwnerWindow!=None) && (OwnerWindow.IsA('UWindowDialogClientWindow')) )
		{
			UWindowDialogClientWindow(OwnerWindow).Notify(self,DE_Change);
		}
	}

	Super.KeyUp(key,x,y);

}


defaultproperties
{
	Align=TA_Left
	TextColor=(R=255,G=255,B=255,A=255)
	ItemHeight=10
	ListClass=class'UWindowListBoxItem'
}
class UWindowListBoxItem extends UWindowList;



var string Caption;
var bool bSelected;
var string HelpText;
//=============================================================================
// UWindowListControl - Abstract class for list controls
//	- List boxes
//	- Dropdown Menus
//	- Combo Boxes, etc
//=============================================================================
class UWindowListControl extends UWindowDialogControl;



var class<UWindowList>	ListClass;
var UWindowList			Items;
var Color				SelectionBkgColor;
var Color				SelectionColor;
var bool				bNoSelectionBox;

function DrawItem(Canvas C, UWindowList Item, float X, float Y, float W, float H)
{
	// Declared in Subclass
}

function Created()
{
	Super.Created();

	Items = new( None ) ListClass;
	Items.Last = Items;
	Items.Next = None;
	Items.Prev = None;
	Items.Sentinel = Items;
}

defaultproperties
{
	SelectionBkgColor=(R=0,G=0,B=192,A=255)
	SelectionColor=(R=255,G=255,B=255,A=255)
}

class UWindowLookAndFeel extends UWindowBase;



var() Texture	Active;			// Active widgets, window frames, etc.
var() Texture	Inactive;		// Inactive Widgets, window frames, etc.
var() Texture	ActiveS;
var() Texture	InactiveS;

var() Texture	Misc;			// Miscellaneous: backgrounds, bevels, etc.

var() Region	FrameTL;
var() Region	FrameT;
var() Region	FrameTR;

var() Region	FrameL;
var() Region	FrameR;

var() Region	FrameBL;
var() Region	FrameB;
var() Region	FrameBR;

var() Color		FrameActiveTitleColor;
var() Color		FrameInactiveTitleColor;
var() Color		HeadingActiveTitleColor;
var() Color		HeadingInActiveTitleColor;

var() int		FrameTitleX;
var() int		FrameTitleY;

var() Region	BevelUpTL;
var() Region	BevelUpT;
var() Region	BevelUpTR;

var() Region	BevelUpL;
var() Region	BevelUpR;

var() Region	BevelUpBL;
var() Region	BevelUpB;
var() Region	BevelUpBR;
var() Region	BevelUpArea;


var() Region	MiscBevelTL[4];
var() Region	MiscBevelT[4];
var() Region	MiscBevelTR[4];
var() Region	MiscBevelL[4];
var() Region	MiscBevelR[4];
var() Region	MiscBevelBL[4];
var() Region	MiscBevelB[4];
var() Region	MiscBevelBR[4];
var() Region	MiscBevelArea[4];

var() Region	ComboBtnUp;
var() Region	ComboBtnDown;
var() Region	ComboBtnDisabled;

var() int		ColumnHeadingHeight;
var() Region	HLine;

var() Color		EditBoxTextColor;
var() int		EditBoxBevel;

var() Region	TabSelectedL;
var() Region	TabSelectedM;
var() Region	TabSelectedR;

var() Region	TabUnselectedL;
var() Region	TabUnselectedM;
var() Region	TabUnselectedR;

var() Region	TabBackground;


var() float		Size_ScrollbarWidth;
var() float		Size_ScrollbarButtonHeight;		// Interchange W and H for horizontal SB's
var() float		Size_MinScrollbarHeight;

var() float		Size_TabAreaHeight;				// The height of the clickable tab area
var() float		Size_TabAreaOverhangHeight;		// The height of the tab area overhang
var() float		Size_TabSpacing;
var() float		Size_TabXOffset;

var() float		Pulldown_ItemHeight;
var() float		Pulldown_VBorder;
var() float		Pulldown_HBorder;
var() float		Pulldown_TextBorder;

function Texture GetTexture(UWindowFramedWindow W)
{
	if(W.bStatusBar)
	{
		if(W.IsActive())
			return ActiveS;
		else
			return InactiveS;
	}
	else
	{
		if(W.IsActive())
			return Active;
		else
			return Inactive;
	}
}

/* Setup Functions */
function Setup();
function FW_DrawWindowFrame(UWindowFramedWindow W, Canvas C);
function Region FW_GetClientArea(UWindowFramedWindow W);
function FrameHitTest FW_HitTest(UWindowFramedWindow W, float X, float Y);
function FW_SetupFrameButtons(UWindowFramedWindow W, Canvas C);
function DrawClientArea(UWindowClientWindow W, Canvas C);
function Combo_SetupSizes(UWindowComboControl W, Canvas C);
function Combo_Draw(UWindowComboControl W, Canvas C);
function Combo_GetButtonBitmaps(UWindowComboButton W);
function Combo_SetupLeftButton(UWindowComboLeftButton W);
function Combo_SetupRightButton(UWindowComboRightButton W);
function Checkbox_SetupSizes(UWindowCheckbox W, Canvas C);
function Checkbox_Draw(UWindowCheckbox W, Canvas C);
function ComboList_DrawBackground(UWindowComboList W, Canvas C);
function ComboList_DrawItem(UWindowComboList Combo, Canvas C, float X, float Y, float W, float H, string Text, bool bSelected);
function Editbox_SetupSizes(UWindowEditControl W, Canvas C);
function Editbox_Draw(UWindowEditControl W, Canvas C);
function SB_SetupUpButton(UWindowSBUpButton W);
function SB_SetupDownButton(UWindowSBDownButton W);
function SB_SetupLeftButton(UWindowSBLeftButton W);
function SB_SetupRightButton(UWindowSBRightButton W);
function SB_VDraw(UWindowVScrollbar W, Canvas C);
function SB_HDraw(UWindowHScrollbar W, Canvas C);
function Tab_DrawTab(UWindowTabControlTabArea Tab, Canvas C, bool bActiveTab, bool bLeftmostTab, float X, float Y, float W, float H, string Text, bool bShowText);
function Tab_GetTabSize(UWindowTabControlTabArea Tab, Canvas C, string Text, out float W, out float H);
function Tab_SetupLeftButton(UWindowTabControlLeftButton W);
function Tab_SetupRightButton(UWindowTabControlRightButton W);
function Tab_SetTabPageSize(UWindowPageControl W, UWindowPageWindow P);
function Tab_DrawTabPageArea(UWindowPageControl W, Canvas C, UWindowPageWindow P);
function Menu_DrawMenuBar(UWindowMenuBar W, Canvas C);
function Menu_DrawMenuBarItem(UWindowMenuBar B, UWindowMenuBarItem I, float X, float Y, float W, float H, Canvas C);
function Menu_DrawPulldownMenuBackground(UWindowPulldownMenu W, Canvas C);
function Menu_DrawPulldownMenuItem(UWindowPulldownMenu M, UWindowPulldownMenuItem Item, Canvas C, float X, float Y, float W, float H, bool bSelected);
function Button_DrawSmallButton(UWindowSmallButton B, Canvas C);
function PlayMenuSound(UWindowWindow W, MenuSound S);
function ControlFrame_SetupSizes(UWindowControlFrame W, Canvas C);
function ControlFrame_Draw(UWindowControlFrame W, Canvas C);
//=============================================================================
// UWindowMenuBar - A menu bar
//=============================================================================
class UWindowMenuBar extends UWindowListControl;



var UWindowMenuBarItem		Selected;
var UWindowMenuBarItem		Over;
var bool					bAltDown;
var int						Spacing;

function Created()
{
	ListClass = class'UWindowMenuBarItem';
	SetAcceptsHotKeys(True);
	Super.Created();
	Spacing = 10;
}

function UWindowMenuBarItem AddHelpItem(string Caption)
{
	Local UWindowMenuBarItem I;

	I = AddItem(Caption);
	I.SetHelp(True);

	return I;
}

function UWindowMenuBarItem AddItem(string Caption)
{
	local UWindowMenuBarItem I;
	I = UWindowMenuBarItem(Items.Append(class'UWindowMenuBarItem'));
	I.Owner = Self;
	I.SetCaption(Caption);

	return I;
}

function ResolutionChanged(float W, float H)
{
	local UWindowMenuBarItem I;

	if (Items != none)
	{
		for( I = UWindowMenuBarItem(Items.Next);I != None; I = UWindowMenuBarItem(I.Next) )
			if(I.Menu != None)
				I.Menu.ResolutionChanged(W, H);
	}

	Super.ResolutionChanged(W, H);
}

function Paint(Canvas C, float MouseX, float MouseY)
{
	local float X;
	local float W, H;
	local UWindowMenuBarItem I;

	DrawMenuBar(C);

	for( I = UWindowMenuBarItem(Items.Next);I != None; I = UWindowMenuBarItem(I.Next) )
	{
		C.Font = Root.Fonts[F_Normal];
		TextSize( C, RemoveAmpersand(I.Caption), W, H );

		if(I.bHelp)
		{
			DrawItem(C, I, (WinWidth - (W + Spacing)), 1, W + Spacing, 14);
		}
		else
		{
			DrawItem(C, I, X, 1, W + Spacing, 14);
			X = X + W + Spacing;
		}
	}
}

function MouseMove(float X, float Y)
{
	local UWindowMenuBarItem I;
	Super.MouseMove(X, Y);

	Over = None;

	for( I = UWindowMenuBarItem(Items.Next);I != None; I = UWindowMenuBarItem(I.Next) )
	{
		if(X >= I.ItemLeft && X <= I.ItemLeft + I.ItemWidth)
		{
			if(Selected != None) {
				if(Selected != I)
				{
					Selected.DeSelect();
					Selected = I;
					Selected.Select();
					Select(Selected);
				}
			} else {
				Over = I;
			}
		}
	}
}

function MouseLeave()
{
	Super.MouseLeave();
	Over=None;
}

function Select(UWindowMenuBarItem I)
{
}

function LMouseDown(float X, float Y)
{
	local UWindowMenuBarItem I;

	for( I = UWindowMenuBarItem(Items.Next);I != None; I = UWindowMenuBarItem(I.Next) )
	{
		if(X >= I.ItemLeft && X <= I.ItemLeft + I.ItemWidth)
		{
			//Log("Click "$I.Caption);

			if(Selected != None) {
				Selected.DeSelect();
			}

			if(Selected == I)
			{
				Selected = None;
				Over = I;
			}
			else
			{
				Selected = I;
				Selected.Select();
			}

			Select(Selected);
			return;
		}
	}

	if(Selected != None)
	{
		Selected.DeSelect();
	}

	Selected = None;
	Select(Selected);
}

function DrawItem(Canvas C, UWindowList Item, float X, float Y, float W, float H)
{
	C.SetDrawColor(255,255,255);

	UWindowMenuBarItem(Item).ItemLeft = X;
	UWindowMenuBarItem(Item).ItemWidth = W;

	LookAndFeel.Menu_DrawMenuBarItem(Self, UWindowMenuBarItem(Item), X, Y, W, H, C);
}

function DrawMenuBar(Canvas C)
{
	DrawStretchedTexture( C, 0, 0, WinWidth, 16, Texture'MenuBar' );
}

function CloseUp()
{
	if(Selected != None)
	{
		Selected.DeSelect();
		Selected = None;
	}
}

function Close(optional bool bByParent)
{
//	Root.Console.CloseUWindow();
}

function UWindowMenuBar GetMenuBar()
{
	return Self;
}


function bool HotKeyDown(int Key, float X, float Y)
{
	local UWindowMenuBarItem I;

	if(Key == 0x12)
		bAltDown = True;

	if(bAltDown)
	{
		// Check for hotkeys in each menu item
		for( I = UWindowMenuBarItem(Items.Next);I != None; I = UWindowMenuBarItem(I.Next) )
		{
			if(Key == I.HotKey)
			{
				if(Selected != None)
					Selected.DeSelect();
				Selected = I;
				Selected.Select();
				Select(Selected);
				bAltDown = False;
				return True;
			}
		}
	}
	return False;
}

function bool HotKeyUp(int Key, float X, float Y)
{
	if(Key == 0x12)
		bAltDown = False;

	return False;
}

function KeyDown(int Key, float X, float Y)
{
	local UWindowMenuBarItem I;

	switch(Key)
	{
	case 0x25: // Left
		I = UWindowMenuBarItem(Selected.Prev);
		if(I==None || I==Items)
			I = UWindowMenuBarItem(Items.Last);

		if(Selected != None)
			Selected.DeSelect();

		Selected = I;
		Selected.Select();

		Select(Selected);

		break;
	case 0x27: // Right
		I = UWindowMenuBarItem(Selected.Next);
		if(I==None)
			I = UWindowMenuBarItem(Items.Next);

		if(Selected != None)
			Selected.DeSelect();


		Selected = I;
		Selected.Select();

		Select(Selected);

		break;
	}
}

function MenuCmd(int Menu, int Item)
{
	local UWindowMenuBarItem I;
	local int j;

	j=0;
	for(I = UWindowMenuBarItem(Items.Next); I != None; I = UWindowMenuBarItem(I.Next))
	{
		if(j == Menu && I.Menu != None)
		{
			if(Selected != None)
				Selected.DeSelect();
			Selected = I;
			Selected.Select();
			Select(Selected);
			I.Menu.MenuCmd(Item);
			return;
		}
		j++;
	}
}

function MenuItemSelected(UWindowBase Sender, UWindowBase Item)
{
	// Should be handled in a child

}

defaultproperties
{
	bAltDown=False
}
//=============================================================================
// UWindowMenuBarItem - An Unreal menu bar item
//=============================================================================

class UWindowMenuBarItem extends UWindowList
	config;



var	string					Caption;
var UWindowMenuBar			Owner;
var UWindowPulldownMenu		Menu;
var float					ItemLeft;
var float					ItemWidth;
var bool					bHelp;
var byte					HotKey;

function SetHelp(bool b)
{
	bHelp = b;
}

function SetCaption(string C)
{
	local string Junk, Junk2;

	Caption = C;
	HotKey = Owner.ParseAmpersand(C, Junk, Junk2, False);
}

function UWindowPulldownMenu CreateMenu(Class<UWindowPulldownMenu> MenuClass)
{
	Menu = UWindowPulldownMenu(Owner.ParentWindow.CreateWindow(MenuClass, 0, 0, 100, 100));
	Menu.HideWindow();
	Menu.Owner = Self;
	return Menu;
}

function DeSelect()
{
	Owner.LookAndFeel.PlayMenuSound(Owner, MS_MenuCloseUp);
	Menu.DeSelect();
	Menu.HideWindow();
}

function Select()
{
	Owner.LookAndFeel.PlayMenuSound(Owner, MS_MenuPullDown);
	Menu.ShowWindow();
	Menu.WinLeft = ItemLeft + Owner.WinLeft;
	Menu.WinTop = 14;
	Menu.WinWidth = 100;
	Menu.WinHeight = 100;
}


function CloseUp() {
	Owner.CloseUp();
}

function UWindowMenuBar GetMenuBar()
{
	return Owner.GetMenuBar();
}
class UWindowMessageBox extends UWindowFramedWindow;



var MessageBoxResult Result;
var float TimeOutTime;
var int TimeOut;
var bool bSetupSize;
var int FrameCount;

function SetupMessageBox(string Title, string Message, MessageBoxButtons Buttons, MessageBoxResult InESCResult, optional MessageBoxResult InEnterResult, optional int InTimeOut)
{
	WindowTitle = Title;
	UWindowMessageBoxCW(ClientArea).SetupMessageBoxClient(Message, Buttons, InEnterResult);
	Result = InESCResult;
	TimeOutTime = 0;
	TimeOut = InTimeOut;
	FrameCount = 0;
}

function BeforePaint(Canvas C, float X, float Y)
{
	local Region R;

	if(!bSetupSize)
	{
		SetSize(200, WinHeight);
		R = LookAndFeel.FW_GetClientArea(Self);
		SetSize(200, (WinHeight - R.H) + UWindowMessageBoxCW(ClientArea).GetHeight(C));
		WinLeft = int((Root.WinWidth - WinWidth) / 2);
		WinTop = int((Root.WinHeight - WinHeight) / 2);
		bSetupSize = True;
	}

	Super.BeforePaint(C, X, Y);
}

function AfterPaint(Canvas C, float X, float Y)
{
	Super.AfterPaint(C, X, Y);

	if(TimeOut != 0)
	{
		FrameCount++;

		if(FrameCount >= 5)
		{
			TimeOutTime = GetEntryLevel().TimeSeconds + TimeOut;
			TimeOut = 0;
		}
	}

	if(TimeOutTime != 0 && GetEntryLevel().TimeSeconds > TimeOutTime)
	{
		TimeOutTime = 0;
		Close();
	}
}

function Close(optional bool bByParent)
{
	Super.Close(bByParent);
	OwnerWindow.MessageBoxDone(Self, Result);
}

defaultproperties
{
	ClientClass=class'UWindowMessageBoxCW'
}
class UWindowMessageBoxArea extends UWindowWindow;



var string Message;

function float GetHeight(Canvas C)
{
	local float TW, TH, H;
	local int L;
	local float OldWinHeight;

	OldWinHeight = WinHeight;
	WinHeight = 1000;
	C.Font = Root.Fonts[F_Normal];
	TextSize(C, "A", TW, TH);
	L = WrapClipText(C, 0, 0, Message,,,, True);
	H = TH * L;
	WinHeight = OldWinHeight;
	return H;
}

function Paint(Canvas C, float X, float Y)
{
	C.Font = Root.Fonts[F_Normal];
	C.SetDrawColor(0,0,0);
	WrapClipText(C, 0, 0, Message);
	C.SetDrawColor(255,255,255);
}
class UWindowMessageBoxCW extends UWindowDialogClientWindow;



var MessageBoxButtons Buttons;

var MessageBoxResult EnterResult;
var UWindowSmallButton YesButton, NoButton, OKButton, CancelButton;
var localized string YesText, NoText, OKText, CancelText;
var UWindowMessageBoxArea MessageArea;

function Created()
{
	Super.Created();
	SetAcceptsFocus();

	MessageArea = UWindowMessageBoxArea(CreateWindow(class'UWindowMessageBoxArea', 10, 10, WinWidth-20, WinHeight-44));
}

function KeyDown(int Key, float X, float Y)
{
	local UWindowMessageBox P;

	P = UWindowMessageBox(ParentWindow);

	if(Key == GetPlayerOwner().Player.Console.EInputKey.IK_Enter && EnterResult != MR_None)
	{
		P = UWindowMessageBox(ParentWindow);
		P.Result = EnterResult;
		P.Close();
	}
}

function BeforePaint(Canvas C, float X, float Y)
{
	Super.BeforePaint(C, X, Y);

	MessageArea.SetSize(WinWidth-20, WinHeight-44);

	switch(Buttons)
	{
	case MB_YesNoCancel:
		CancelButton.WinLeft = WinWidth - 52;
		CancelButton.WinTop = WinHeight - 20;
		NoButton.WinLeft = WinWidth - 104;
		NoButton.WinTop = WinHeight - 20;
		YesButton.WinLeft = WinWidth - 156;
		YesButton.WinTop = WinHeight - 20;
		break;
	case MB_YesNo:
		NoButton.WinLeft = WinWidth - 52;
		NoButton.WinTop = WinHeight - 20;
		YesButton.WinLeft = WinWidth - 104;
		YesButton.WinTop = WinHeight - 20;
		break;
	case MB_OKCancel:
		CancelButton.WinLeft = WinWidth - 52;
		CancelButton.WinTop = WinHeight - 20;
		OKButton.WinLeft = WinWidth - 104;
		OKButton.WinTop = WinHeight - 20;
		break;
	case MB_OK:
		OKButton.WinLeft = WinWidth - 52;
		OKButton.WinTop = WinHeight - 20;
		break;
	}
}

function Resized()
{
	Super.Resized();
	MessageArea.SetSize(WinWidth-20, WinHeight-44);
}

function float GetHeight(Canvas C)
{
	return 44 + MessageArea.GetHeight(C);
}

function Paint(Canvas C, float X, float Y)
{
	local Texture T;
	Super.Paint(C, X, Y);
	T = GetLookAndFeelTexture();
	DrawUpBevel( C, 0, WinHeight-24, WinWidth, 24, T);
}

function SetupMessageBoxClient(string InMessage, MessageBoxButtons InButtons, MessageBoxResult InEnterResult)
{
	MessageArea.Message = InMessage;
	Buttons = InButtons;
	EnterResult = InEnterResult;

	// Create buttons
	switch(Buttons)
	{
	case MB_YesNoCancel:
		CancelButton = UWindowSmallButton(CreateControl(class'UWindowSmallButton', WinWidth - 52, WinHeight - 20, 48, 16));
		CancelButton.SetText(CancelText);
		if(EnterResult == MR_Cancel)
			CancelButton.SetFont(F_Bold);
		else
			CancelButton.SetFont(F_Normal);
		NoButton = UWindowSmallButton(CreateControl(class'UWindowSmallButton', WinWidth - 104, WinHeight - 20, 48, 16));
		NoButton.SetText(NoText);
		if(EnterResult == MR_No)
			NoButton.SetFont(F_Bold);
		else
			NoButton.SetFont(F_Normal);
		YesButton = UWindowSmallButton(CreateControl(class'UWindowSmallButton', WinWidth - 156, WinHeight - 20, 48, 16));
		YesButton.SetText(YesText);
		if(EnterResult == MR_Yes)
			YesButton.SetFont(F_Bold);
		else
			YesButton.SetFont(F_Normal);
		break;
	case MB_YesNo:
		NoButton = UWindowSmallButton(CreateControl(class'UWindowSmallButton', WinWidth - 52, WinHeight - 20, 48, 16));
		NoButton.SetText(NoText);
		if(EnterResult == MR_No)
			NoButton.SetFont(F_Bold);
		else
			NoButton.SetFont(F_Normal);
		YesButton = UWindowSmallButton(CreateControl(class'UWindowSmallButton', WinWidth - 104, WinHeight - 20, 48, 16));
		YesButton.SetText(YesText);
		if(EnterResult == MR_Yes)
			YesButton.SetFont(F_Bold);
		else
			YesButton.SetFont(F_Normal);
		break;
	case MB_OKCancel:
		CancelButton = UWindowSmallButton(CreateControl(class'UWindowSmallButton', WinWidth - 52, WinHeight - 20, 48, 16));
		CancelButton.SetText(CancelText);
		if(EnterResult == MR_Cancel)
			CancelButton.SetFont(F_Bold);
		else
			CancelButton.SetFont(F_Normal);
		OKButton = UWindowSmallButton(CreateControl(class'UWindowSmallButton', WinWidth - 104, WinHeight - 20, 48, 16));
		OKButton.SetText(OKText);
		if(EnterResult == MR_OK)
			OKButton.SetFont(F_Bold);
		else
			OKButton.SetFont(F_Normal);
		break;
	case MB_OK:
		OKButton = UWindowSmallButton(CreateControl(class'UWindowSmallButton', WinWidth - 52, WinHeight - 20, 48, 16));
		OKButton.SetText(OKText);
		if(EnterResult == MR_OK)
			OKButton.SetFont(F_Bold);
		else
			OKButton.SetFont(F_Normal);
		break;
	}
}

function Notify(UWindowDialogControl C, byte E)
{
	local UWindowMessageBox P;

	P = UWindowMessageBox(ParentWindow);

	if(E == DE_Click)
	{
		switch(C)
		{
		case YesButton:
			P.Result = MR_Yes;
			P.Close();
			break;
		case NoButton:
			P.Result = MR_No;
			P.Close();
			break;
		case OKButton:
			P.Result = MR_OK;
			P.Close();
			break;
		case CancelButton:
			P.Result = MR_Cancel;
			P.Close();
			break;
		}
	}
}

defaultproperties
{
	YesText="Yes"
	NoText="No"
	OKText="OK"
	CancelText="Cancel"
}
class UWindowPageControl extends UWindowTabControl;



function ResolutionChanged(float W, float H)
{
	local UWindowPageControlPage I;

	for(I = UWindowPageControlPage(Items.Next); I != None; I = UWindowPageControlPage(I.Next))
		if(I.Page != None && I != SelectedTab )
			I.Page.ResolutionChanged(W, H);

	if(SelectedTab != None)
		UWindowPageControlPage(SelectedTab).Page.ResolutionChanged(W, H);
}

function NotifyQuitUnreal()
{
	local UWindowPageControlPage I;

	for(I = UWindowPageControlPage(Items.Next); I != None; I = UWindowPageControlPage(I.Next))
		if(I.Page != None)
			I.Page.NotifyQuitUnreal();
}

function NotifyBeforeLevelChange()
{
	local UWindowPageControlPage I;

	for(I = UWindowPageControlPage(Items.Next); I != None; I = UWindowPageControlPage(I.Next))
		if(I.Page != None)
			I.Page.NotifyBeforeLevelChange();
}

function NotifyAfterLevelChange()
{
	local UWindowPageControlPage I;

	for(I = UWindowPageControlPage(Items.Next); I != None; I = UWindowPageControlPage(I.Next))
		if(I.Page != None)
			I.Page.NotifyAfterLevelChange();
}

function GetDesiredDimensions(out float W, out float H)
{
	local float MaxW, MaxH, TW, TH;
	local UWindowPageControlPage I;

	MaxW = 0;
	MaxH = 0;

	for(I = UWindowPageControlPage(Items.Next); I != None; I = UWindowPageControlPage(I.Next))
	{
		if(I.Page != None)
			I.Page.GetDesiredDimensions(TW, TH);

		if(TW > MaxW) MaxW = TW;
		if(TH > MaxH) MaxH = TH;
	}
	W = MaxW;
	H = MaxH + TabArea.WinHeight;
}


function BeforePaint(Canvas C, float X, float Y)
{
	local float OldWinHeight;
	local UWindowPageControlPage I;

	OldWinHeight = WinHeight;
	Super.BeforePaint(C, X, Y);
	WinHeight = OldWinHeight;

	for(I = UWindowPageControlPage(Items.Next); I != None; I = UWindowPageControlPage(I.Next))
		LookAndFeel.Tab_SetTabPageSize(Self, I.Page);
}

function Paint(Canvas C, float X, float Y)
{
	Super.Paint(C, X, Y);
	LookAndFeel.Tab_DrawTabPageArea(Self, C, UWindowPageControlPage(SelectedTab).Page);
}

function UWindowPageControlPage AddPage(string Caption, class<UWindowPageWindow> PageClass, optional name ObjectName)
{
	local UWindowPageControlPage P;
	P = UWindowPageControlPage(AddTab(Caption));
	P.Page = UWindowPageWindow(CreateWindow(PageClass, 0,
				TabArea.WinHeight-(LookAndFeel.TabSelectedM.H-LookAndFeel.TabUnselectedM.H),
				WinWidth, WinHeight-(TabArea.WinHeight-(LookAndFeel.TabSelectedM.H-LookAndFeel.TabUnselectedM.H)),,,ObjectName));
	P.Page.OwnerTab = P;

	if(P != SelectedTab)
		P.Page.HideWindow();
	else
	if(UWindowPageControlPage(SelectedTab) != None && WindowIsVisible())
	{
		UWindowPageControlPage(SelectedTab).Page.ShowWindow();
		UWindowPageControlPage(SelectedTab).Page.BringToFront();
	}

	return P;
}

function UWindowPageControlPage InsertPage(UWindowPageControlPage BeforePage, string Caption, class<UWindowPageWindow> PageClass, optional name ObjectName)
{
	local UWindowPageControlPage P;

	if(BeforePage == None)
		return AddPage(Caption, PageClass);

	P = UWindowPageControlPage(InsertTab(BeforePage, Caption));
	P.Page = UWindowPageWindow(CreateWindow(PageClass, 0,
				TabArea.WinHeight-(LookAndFeel.TabSelectedM.H-LookAndFeel.TabUnselectedM.H),
				WinWidth, WinHeight-(TabArea.WinHeight-(LookAndFeel.TabSelectedM.H-LookAndFeel.TabUnselectedM.H)),,,ObjectName));
	P.Page.OwnerTab = P;

	if(P != SelectedTab)
		P.Page.HideWindow();
	else
	if(UWindowPageControlPage(SelectedTab) != None && WindowIsVisible())
	{
		UWindowPageControlPage(SelectedTab).Page.ShowWindow();
		UWindowPageControlPage(SelectedTab).Page.BringToFront();
	}

	return P;
}

function UWindowPageControlPage GetPage(string Caption)
{
	return UWindowPageControlPage(GetTab(Caption));
}

function DeletePage(UWindowPageControlPage P)
{
	P.Page.Close(True);
	P.Page.HideWindow();
	DeleteTab(P);
}

function Close(optional bool bByParent)
{
	local UWindowPageControlPage I;

	for(I = UWindowPageControlPage(Items.Next); I != None; I = UWindowPageControlPage(I.Next))
		if(I.Page != None)
			I.Page.Close(True);

	Super.Close(bByParent);
}

function GotoTab(UWindowTabControlItem NewSelected, optional bool bByUser)
{
	local UWindowPageControlPage I;

	Super.GotoTab(NewSelected, bByUser);

	for(I = UWindowPageControlPage(Items.Next);I != None;I = UWindowPageControlPage(I.Next))
	{
		if(I != NewSelected)
			I.Page.HideWindow();
	}

	if(UWindowPageControlPage(NewSelected) != None)
		UWindowPageControlPage(NewSelected).Page.ShowWindow();
}

function UWindowPageControlPage FirstPage()
{
	return UWindowPageControlPage(Items.Next);
}

defaultproperties
{
	ListClass=class'UWindowPageControlPage'
}
class UWindowPageControlPage extends UWindowTabControlItem;



var UWindowPageWindow	Page;

function RightClickTab()
{
	Page.RightClickTab();
}

function UWindowPageControlPage NextPage()
{
	return UWindowPageControlPage(Next);
}
class UWindowPageWindow extends UWindowDialogClientWindow;



var UWindowPageControlPage OwnerTab;

function RightClickTab()
{
}
class UWindowProgressBar extends UWindowWindow;



var float Percent;
const BlockWidth=7;

function SetPercent(float NewPercent)
{
	Percent = NewPercent;
}

function Paint(Canvas C, float X, float Y)
{
	local float BlockX, BlockW;

	DrawMiscBevel( C, 0, 0, WinWidth, WinHeight, LookAndFeel.Misc, 2 );

	C.SetDrawColor(192,192,192);

	DrawStretchedTextureSegment(
							C,
							LookAndFeel.MiscBevelL[2].W,
							LookAndFeel.MiscBevelT[2].H,
							WinWidth - LookAndFeel.MiscBevelL[2].W - LookAndFeel.MiscBevelR[2].W,
							WinHeight - LookAndFeel.MiscBevelT[2].H - LookAndFeel.MiscBevelB[2].H,
							0,
							0,
							1,
							1,
							Texture'WhiteTexture'
						);

	C.SetDrawColor(0,0,255);

	BlockX = LookAndFeel.MiscBevelL[2].W + 1;
	while( BlockX < 1 + LookAndFeel.MiscBevelL[2].W + Percent * (WinWidth - LookAndFeel.MiscBevelL[2].W - LookAndFeel.MiscBevelR[2].W - 2) / 100)
	{
		BlockW = Min(BlockWidth, WinWidth - LookAndFeel.MiscBevelR[2].W - BlockX - 1);



		DrawStretchedTextureSegment(
								C,
								BlockX,
								LookAndFeel.MiscBevelT[2].H + 1,
								BlockW,
								WinHeight - LookAndFeel.MiscBevelT[2].H - LookAndFeel.MiscBevelB[2].H - 1,
								0,
								0,
								1,
								1,
								Texture'WhiteTexture'
							);

		BlockX += BlockWidth + 1;
	}

	C.SetDrawColor(255,255,255);
}
//=============================================================================
// UWindowPulldownMenu
//=============================================================================


class UWindowPulldownMenu extends UWindowListControl;



#exec TEXTURE IMPORT FILE=Textures\MenuTick.tga GROUP="Icons"       MIPS=OFF MASKED=1 COMPRESS=DXT1A
#exec TEXTURE IMPORT FILE=Textures\MenuDivider.tga GROUP="Icons"    MIPS=OFF COMPRESS=DXT1
#exec TEXTURE IMPORT FILE=Textures\MenuSubArrow.tga GROUP="Icons"   MIPS=OFF MASKED=1 COMPRESS=DXT1A

var UWindowPulldownMenuItem		Selected;

// Owner is either a UWindowMenuBarItem or UWindowPulldownMenuItem
var UWindowList					Owner;

var int ItemHeight;
var int VBorder;
var int HBorder;
var int TextBorder;

var UWindowMenuBar MyMenuBar;

// External functions
function UWindowPulldownMenuItem AddMenuItem(string C, Texture G)
{
	local UWindowPulldownMenuItem I;

	I = UWindowPulldownMenuItem(Items.Append(class'UWindowPulldownMenuItem'));

	I.Owner = Self;
	I.SetCaption(C);
	I.Graphic = G;
	I.Tag = Items.Count();

	return I;
}

// Mostly-private funcitons

function Created()
{
	ListClass = class'UWindowPulldownMenuItem';
	SetAcceptsFocus();
	Super.Created();
	ItemHeight = LookAndFeel.Pulldown_ItemHeight;
	VBorder = LookAndFeel.Pulldown_VBorder;
	HBorder = LookAndFeel.Pulldown_HBorder;
	TextBorder = LookAndFeel.Pulldown_TextBorder;
}

function Clear()
{
	Items.Clear();
	Selected = None;
}

function DeSelect()
{
	if(Selected != None)
	{
		Selected.DeSelect();
		Selected = None;
	}
}

function Select(UWindowPulldownMenuItem I)
{
}

function PerformSelect(UWindowPulldownMenuItem NewSelected)
{
	if(Selected != None && NewSelected != Selected) Selected.DeSelect();

	if(NewSelected == None)
	{
		Selected = None;
	}
	else
	{
		if(Selected != NewSelected && NewSelected.Caption != "-" && !NewSelected.bDisabled)
			LookAndFeel.PlayMenuSound(Self, MS_MenuItem);

		Selected = NewSelected;
		if(Selected != None)
		{
			Selected.Select();
			Select(Selected);
		}
	}
}

function SetSelected(float X, float Y)
{
	local UWindowPulldownMenuItem NewSelected;

	NewSelected = UWindowPulldownMenuItem(Items.FindEntry((Y - VBorder) / ItemHeight));

	PerformSelect(NewSelected);
}

function ShowWindow()
{
	Super.ShowWindow();
	PerformSelect(None);
	FocusWindow();
}

function MouseMove(float X, float Y)
{
	Super.MouseMove(X, Y);
	SetSelected(X, Y);
	FocusWindow();
}

function LMouseUp(float X, float Y)
{
	If(Selected != None && Selected.Caption != "-" && !Selected.bDisabled)
	{
		BeforeExecuteItem(Selected);
		ExecuteItem(Selected);
	}
	Super.LMouseUp(X, Y);
}

function LMouseDown(float X, float Y)
{
}

function BeforePaint(Canvas C, float X, float Y)
{
	local float W, H, MaxWidth;
	local int Count;
	local UWindowPulldownMenuItem I;


	MaxWidth = 100;
	Count = 0;

	C.Font = Root.Fonts[F_Normal];
	C.SetPos(0, 0);

	for( I = UWindowPulldownMenuItem(Items.Next);I != None; I = UWindowPulldownMenuItem(I.Next) )
	{
		Count++;
		TextSize(C, RemoveAmpersand(I.Caption), W, H);
		if(W > MaxWidth) MaxWidth = W;
	}

	WinWidth = MaxWidth + ((HBorder + TextBorder) * 2);
	WinHeight = (ItemHeight * Count) + (VBorder * 2);

	// Take care of bHelp items
	if(	((UWindowMenuBarItem(Owner) != None) && (UWindowMenuBarItem(Owner).bHelp)) ||
		WinLeft+WinWidth > ParentWindow.WinWidth )
	{
		WinLeft = ParentWindow.WinWidth - WinWidth;
	}

	if(UWindowPulldownMenuItem(Owner) != None)
	{
		I = UWindowPulldownMenuItem(Owner);

		if(WinWidth + WinLeft > ParentWindow.WinWidth)
			WinLeft = I.Owner.WinLeft + I.Owner.HBORDER - WinWidth;
	}
}

function Paint(Canvas C, float X, float Y)
{
	local int Count;
	local UWindowPulldownMenuItem I;

	DrawMenuBackground(C);

	Count = 0;

	for( I = UWindowPulldownMenuItem(Items.Next);I != None; I = UWindowPulldownMenuItem(I.Next) )
	{
		DrawItem(C, I, HBorder, VBorder + (ItemHeight * Count), WinWidth - (2 * HBorder), ItemHeight);
		Count++;
	}
}

function DrawMenuBackground(Canvas C)
{
	LookAndFeel.Menu_DrawPulldownMenuBackground(Self, C);
}

function DrawItem(Canvas C, UWindowList Item, float X, float Y, float W, float H)
{
	LookAndFeel.Menu_DrawPulldownMenuItem(Self, UWindowPulldownMenuItem(Item), C, X, Y, W, H, Selected == Item);
}

function BeforeExecuteItem(UWindowPulldownMenuItem I)
{
	LookAndFeel.PlayMenuSound(Self, MS_WindowOpen);
}

function ExecuteItem(UWindowPulldownMenuItem I)
{
	MyMenuBar.MenuItemSelected(Self,I);
	CloseUp();
}

function CloseUp(optional bool bByOwner)
{
	local UWindowPulldownMenuItem I;

	// tell our owners to close up
	if(!bByOwner)
	{
		if(UWindowPulldownMenuItem(Owner) != None)  UWindowPulldownMenuItem(Owner).CloseUp();
		if(UWindowMenuBarItem(Owner) != None)  UWindowMenuBarItem(Owner).CloseUp();
	}

	// tell our children to close up
	for( I = UWindowPulldownMenuItem(Items.Next);I != None; I = UWindowPulldownMenuItem(I.Next) )
		if(I.SubMenu != None)
			I.SubMenu.CloseUp(True);
}

function UWindowMenuBar GetMenuBar()
{
	if(UWindowPulldownMenuItem(Owner) != None) return UWindowPulldownMenuItem(Owner).GetMenuBar();
	if(UWindowMenuBarItem(Owner) != None) return UWindowMenuBarItem(Owner).GetMenuBar();
}

function FocusOtherWindow(UWindowWindow W)
{
	Super.FocusOtherWindow(W);

	if(Selected != None)
		if(W == Selected.SubMenu) return;

	if(UWindowPulldownMenuItem(Owner) != None)
		if(UWindowPulldownMenuItem(Owner).Owner == W) return;

	if(bWindowVisible)
		CloseUp();
}

function KeyDown(int Key, float X, float Y)
{
	local UWindowPulldownMenuItem I;

	I = Selected;

	switch(Key)
	{
	case 27: // ESC
		CloseUp();
		break;
	case 0x26: // Up
		if(I == None || I == Items.Next)
			I = UWindowPulldownMenuItem(Items.Last);
		else
			I = UWindowPulldownMenuItem(I.Prev);

		if(I == None)
			I = UWindowPulldownMenuItem(Items.Last);
		else
			if(I.Caption == "-")
				I = UWindowPulldownMenuItem(I.Prev);

		if(I == None)
			I = UWindowPulldownMenuItem(Items.Last);

		if(I.SubMenu == None)
			PerformSelect(I);
		else
			Selected = I;

		break;
	case 0x28: // Down
		if(I == None)
			I = UWindowPulldownMenuItem(Items.Next);
		else
			I = UWindowPulldownMenuItem(I.Next);

		if(I == None)
			I = UWindowPulldownMenuItem(Items.Next);
		else
			if(I.Caption == "-")
				I = UWindowPulldownMenuItem(I.Next);

		if(I == None)
			I = UWindowPulldownMenuItem(Items.Next);

		if(I.SubMenu == None)
			PerformSelect(I);
		else
			Selected = I;

		break;
	case 0x25: // Left
		if(UWindowPulldownMenuItem(Owner) != None)
		{
			 UWindowPulldownMenuItem(Owner).Owner.PerformSelect(None);
			 UWindowPulldownMenuItem(Owner).Owner.Selected = UWindowPulldownMenuItem(Owner);
		}
		if(UWindowMenuBarItem(Owner) != None)
			UWindowMenuBarItem(Owner).Owner.KeyDown(Key, X, Y);
		break;
	case 0x27: // Right
		if(I != None && I.SubMenu != None)
		{
			Selected = None;
			PerformSelect(I);
			I.SubMenu.Selected = UWindowPulldownMenuItem(I.SubMenu.Items.Next);
		}
		else
		{
			if(UWindowPulldownMenuItem(Owner) != None)
			{
				UWindowPulldownMenuItem(Owner).Owner.PerformSelect(None);
				UWindowPulldownMenuItem(Owner).Owner.KeyDown(Key, X, Y);
			}
			if(UWindowMenuBarItem(Owner) != None)
				UWindowMenuBarItem(Owner).Owner.KeyDown(Key, X, Y);
		}
		break;
	case 0x0D: // Enter
		if(I.SubMenu != None)
		{
			Selected = None;
			PerformSelect(I);
		}
		else
			if(Selected != None && Selected.Caption != "-" && !Selected.bDisabled)
			{
				BeforeExecuteItem(Selected);
				ExecuteItem(Selected);
			}
		break;
	default:
	}
}

function KeyUp(int Key, float X, float Y)
{
	local UWindowPulldownMenuItem I;

	if(Key >= 0x41 && Key <= 0x60)
	{
		// Check for hotkeys in each menu item
		for( I = UWindowPulldownMenuItem(Items.Next);I != None; I = UWindowPulldownMenuItem(I.Next) )
		{
			if(Key == I.HotKey)
			{
				PerformSelect(I);
				if(I != None && I.Caption != "-" && !I.bDisabled)
				{
					BeforeExecuteItem(I);
					ExecuteItem(I);
				}
			}
		}
	}
}

function MenuCmd(int Item)
{
	local int j;
	local UWindowPulldownMenuItem I;

	for( I = UWindowPulldownMenuItem(Items.Next);I != None; I = UWindowPulldownMenuItem(I.Next) )
	{
		if(j == Item)
		{
			PerformSelect(I);
			if( I.Caption != "-" && !I.bDisabled )
			{
				BeforeExecuteItem(I);
				ExecuteItem(I);
			}
			return;
		}
		j++;
	}
}

defaultproperties
{
	bAlwaysOnTop=True
}
//=============================================================================
// UWindowPulldownMenuItem
//=============================================================================

class UWindowPulldownMenuItem extends UWindowList;



var string					Caption;
var Texture					Graphic;
var byte					HotKey;

var UWindowPulldownMenu		SubMenu;
var	bool					bChecked;
var	bool					bDisabled;

var UWindowPulldownMenu		Owner;
var float					ItemTop;

function UWindowPulldownMenu CreateSubMenu(class<UWindowPulldownMenu> MenuClass, optional UWindowWindow InOwnerWindow)
{
	SubMenu = UWindowPulldownMenu(Owner.ParentWindow.CreateWindow(MenuClass, 0, 0, 100, 100, InOwnerWindow));
	SubMenu.HideWindow();
	SubMenu.Owner = Self;
	return SubMenu;
}

function Select()
{
	if(SubMenu != None)
	{
		SubMenu.WinLeft = Owner.WinLeft + Owner.WinWidth - Owner.HBORDER;
		SubMenu.WinTop = ItemTop - Owner.VBORDER;

		SubMenu.ShowWindow();
	}
}

function SetCaption(string C)
{
	local string Junk, Junk2;

	Caption = C;
	HotKey = Owner.ParseAmpersand(C, Junk, Junk2, False);
}

function DeSelect()
{
	if(SubMenu != None)
	{
		SubMenu.DeSelect();
		SubMenu.HideWindow();
	}
}

function CloseUp()
{
	Owner.CloseUp();
}

function UWindowMenuBar GetMenuBar()
{
	return Owner.GetMenuBar();
}
class UWindowRightClickMenu extends UWindowPulldownMenu;



function Created()
{
	bTransient = True;
	Super.Created();
}

function RMouseDown(float X, float Y)
{
	LMouseDown(X, Y);
}

function RMouseUp(float X, float Y)
{
	LMouseUp(X, Y);
}

function CloseUp(optional bool bByOwner)
{
	Super.CloseUp(bByOwner);
	HideWindow();
}
//=============================================================================
// UWindowRootWindow - the root window.
//
// This Window should be subclassed for each different type of menuing system.
// In many cases, there should be at least 1 UWindowRootWindow that contains
// at the very least the console.
//=============================================================================
class UWindowRootWindow extends UWindowWindow;



#exec TEXTURE IMPORT FILE=Textures\MouseCursor.tga GROUP="Icons"    MIPS=OFF MASKED=1 COMPRESS=DXT1A
#exec TEXTURE IMPORT FILE=Textures\MouseMove.tga GROUP="Icons"      MIPS=OFF MASKED=1 COMPRESS=DXT1A
#exec TEXTURE IMPORT FILE=Textures\MouseDiag1.tga GROUP="Icons"     MIPS=OFF MASKED=1 COMPRESS=DXT1A
#exec TEXTURE IMPORT FILE=Textures\MouseDiag2.tga GROUP="Icons"     MIPS=OFF MASKED=1 COMPRESS=DXT1A
#exec TEXTURE IMPORT FILE=Textures\MouseNS.tga GROUP="Icons"        MIPS=OFF MASKED=1 COMPRESS=DXT1A
#exec TEXTURE IMPORT FILE=Textures\MouseWE.tga GROUP="Icons"        MIPS=OFF MASKED=1 COMPRESS=DXT1A
#exec TEXTURE IMPORT FILE=Textures\MouseHand.tga GROUP="Icons"      MIPS=OFF MASKED=1 COMPRESS=DXT1A
#exec TEXTURE IMPORT FILE=Textures\MouseHSplit.tga GROUP="Icons"    MIPS=OFF MASKED=1 COMPRESS=DXT1A
#exec TEXTURE IMPORT FILE=Textures\MouseVSplit.tga GROUP="Icons"    MIPS=OFF MASKED=1 COMPRESS=DXT1A
#exec TEXTURE IMPORT FILE=Textures\MouseWait.tga GROUP="Icons"      MIPS=OFF MASKED=1 COMPRESS=DXT1A

var UWindowWindow		MouseWindow;		// The window the mouse is over
var bool				bMouseCapture;
var float				OldMouseX, OldMouseY;
var UWindowWindow		FocusedWindow;
var UWindowWindow		KeyFocusWindow;		// window with keyboard focus
var MouseCursor			NormalCursor, MoveCursor, DiagCursor1, HandCursor, HSplitCursor, VSplitCursor, DiagCursor2, NSCursor, WECursor, WaitCursor;
var bool				bQuickKeyEnable;
var UWindowHotkeyWindowList	HotkeyWindows;
var config float		GUIScale;
var float				RealWidth, RealHeight;
var Font				Fonts[4];
var UWindowLookAndFeel	LooksAndFeels[20];
var config string		LookAndFeelClass;
var bool				bRequestQuit;
var float				QuitTime;
var bool				bAllowConsole;

var config float		MouseScale;
var float				MouseX;
var float				MouseY;

var float				OldClipX;
var float				OldClipY;

var float fDelayTime;
var bool bAutoRepeat;
var float fAutoRepeatTime;
var int iAutoRepeatCount;
var bool bFastAutoRepeat;
var EInputKey AutoRepeat_Key;
var EInputAction AutoRepeat_Action;

// Define the console that will be given to each local player

var class<UWindowConsoleWindow> ConsoleClass;
var UWindowConsoleWindow ConsoleWindow;

// Define the Menubar that will be given to each local player

function BeginPlay()
{
	Root = Self;
	MouseWindow = Self;
	KeyFocusWindow = Self;
}

function UWindowLookAndFeel GetLookAndFeel(String LFClassName)
{
	local int i;
	local class<UWindowLookAndFeel> LFClass;

	LFClass = class<UWindowLookAndFeel>(DynamicLoadObject(LFClassName, class'Class'));

	for(i=0;i<20;i++)
	{
		if(LooksAndFeels[i] == None)
		{
			LooksAndFeels[i] = new( None ) LFClass;
			LooksAndFeels[i].Setup();
			return LooksAndFeels[i];
		}

		if(LooksAndFeels[i].Class == LFClass)
			return LooksAndFeels[i];
	}
	Log("Out of LookAndFeel array space!!");
	return None;
}


function Created()
{
	LookAndFeel = GetLookAndFeel(LookAndFeelClass);
	SetupFonts();

	NormalCursor.tex = Texture'MouseCursor';
	NormalCursor.HotX = 0;
	NormalCursor.HotY = 0;
	NormalCursor.WindowsCursor = ViewportOwner.IDC_ARROW;

	MoveCursor.tex = Texture'MouseMove';
	MoveCursor.HotX = 8;
	MoveCursor.HotY = 8;
	MoveCursor.WindowsCursor = ViewportOwner.IDC_SIZEALL;

	DiagCursor1.tex = Texture'MouseDiag1';
	DiagCursor1.HotX = 8;
	DiagCursor1.HotY = 8;
	DiagCursor1.WindowsCursor = ViewportOwner.IDC_SIZENWSE;

	HandCursor.tex = Texture'MouseHand';
	HandCursor.HotX = 11;
	HandCursor.HotY = 1;
	HandCursor.WindowsCursor = ViewportOwner.IDC_ARROW;

	HSplitCursor.tex = Texture'MouseHSplit';
	HSplitCursor.HotX = 9;
	HSplitCursor.HotY = 9;
	HSplitCursor.WindowsCursor = ViewportOwner.IDC_SIZEWE;

	VSplitCursor.tex = Texture'MouseVSplit';
	VSplitCursor.HotX = 9;
	VSplitCursor.HotY = 9;
	VSplitCursor.WindowsCursor = ViewportOwner.IDC_SIZENS;

	DiagCursor2.tex = Texture'MouseDiag2';
	DiagCursor2.HotX = 7;
	DiagCursor2.HotY = 7;
	DiagCursor2.WindowsCursor = ViewportOwner.IDC_SIZENESW;

	NSCursor.tex = Texture'MouseNS';
	NSCursor.HotX = 3;
	NSCursor.HotY = 7;
	NSCursor.WindowsCursor = ViewportOwner.IDC_SIZENS;

	WECursor.tex = Texture'MouseWE';
	WECursor.HotX = 7;
	WECursor.HotY = 3;
	WECursor.WindowsCursor = ViewportOwner.IDC_SIZEWE;

	WaitCursor.tex = Texture'MouseWait';
	WECursor.HotX = 6;
	WECursor.HotY = 9;
	WECursor.WindowsCursor = ViewportOwner.IDC_WAIT;


	HotkeyWindows = new( None ) class'UWindowHotkeyWindowList';
	HotkeyWindows.Last = HotkeyWindows;
	HotkeyWindows.Next = None;
	HotkeyWindows.Sentinel = HotkeyWindows;

	Cursor = NormalCursor;

	if (ConsoleClass != None)
	{
		ConsoleWindow = UWindowConsoleWindow(CreateWindow(ConsoleClass, 100, 100, 200, 200));
		ConsoleWindow.HideWindow();
	}

}

function MoveMouse(float X, float Y)
{
	local UWindowWindow NewMouseWindow;
	local float tx, ty;

	MouseX = X;
	MouseY = Y;

	if(!bMouseCapture)
		NewMouseWindow = FindWindowUnder(X, Y);
	else
		NewMouseWindow = MouseWindow;

	if(NewMouseWindow != MouseWindow)
	{
		MouseWindow.MouseLeave();
		NewMouseWindow.MouseEnter();
		MouseWindow = NewMouseWindow;
	}

	if(MouseX != OldMouseX || MouseY != OldMouseY)
	{
		OldMouseX = MouseX;
		OldMouseY = MouseY;

		MouseWindow.GetMouseXY(tx, ty);
		MouseWindow.MouseMove(tx, ty);
	}
}

function DrawMouse(Canvas C)
{
	if(ViewportOwner.bWindowsMouseAvailable)
	{
		// Set the windows cursor...
		ViewportOwner.SelectedCursor = MouseWindow.Cursor.WindowsCursor;
	}
	else
	{
		C.DrawColor.R = 255;
		C.DrawColor.G = 255;
		C.DrawColor.B = 255;
		C.bNoSmooth = True;
		C.Style=2;
		C.SetPos(MouseX * GUIScale - MouseWindow.Cursor.HotX, MouseY * GUIScale - MouseWindow.Cursor.HotY);
		C.DrawIcon(MouseWindow.Cursor.tex, 1.0);
		C.Style=1;
	}

	/* DEBUG - show which window mouse is over

	MouseWindow.GetMouseXY(X, Y);
	C.Font = Fonts[F_Normal];

	C.DrawColor.R = 0;
	C.DrawColor.G = 0;
	C.DrawColor.B = 0;
	C.SetPos(MouseX * GUIScale - MouseWindow.Cursor.HotX, MouseY * GUIScale - MouseWindow.Cursor.HotY);
	C.DrawText( GetPlayerOwner().GetItemName(string(MouseWindow))$" "$int(MouseX * GUIScale)$", "$int(MouseY * GUIScale)$" ("$int(X)$", "$int(Y)$")");

	C.DrawColor.R = 255;
	C.DrawColor.G = 255;
	C.DrawColor.B = 0;
	C.SetPos(-1 + MouseX * GUIScale - MouseWindow.Cursor.HotX, -1 + MouseY * GUIScale - MouseWindow.Cursor.HotY);
	C.DrawText( GetPlayerOwner().GetItemName(string(MouseWindow))$" "$int(MouseX * GUIScale)$", "$int(MouseY * GUIScale)$" ("$int(X)$", "$int(Y)$")");

	*/
}

function bool CheckCaptureMouseUp()
{
	local float X, Y;

	if(bMouseCapture) {
		MouseWindow.GetMouseXY(X, Y);
		MouseWindow.LMouseUp(X, Y);
		bMouseCapture = False;
		return True;
	}
	return False;
}

function bool CheckCaptureMouseDown()
{
	local float X, Y;

	if(bMouseCapture) {
		MouseWindow.GetMouseXY(X, Y);
		MouseWindow.LMouseDown(X, Y);
		bMouseCapture = False;
		return True;
	}
	return False;
}


function CancelCapture()
{
	bMouseCapture = False;
}


function CaptureMouse(optional UWindowWindow W)
{
	bMouseCapture = True;
	if(W != None)
		MouseWindow = W;
	//Log(MouseWindow.Class$": Captured Mouse");
}

function Texture GetLookAndFeelTexture()
{
	Return LookAndFeel.Active;
}

function bool IsActive()
{
	Return True;
}

function AddHotkeyWindow(UWindowWindow W)
{
//	Log("Adding hotkeys for "$W);
	UWindowHotkeyWindowList(HotkeyWindows.Insert(class'UWindowHotkeyWindowList')).Window = W;
}

function RemoveHotkeyWindow(UWindowWindow W)
{
	local UWindowHotkeyWindowList L;

//	Log("Removing hotkeys for "$W);

	L = HotkeyWindows.FindWindow(W);
	if(L != None)
		L.Remove();
}


function WindowEvent(WinMessage Msg, Canvas C, float X, float Y, int Key)
{
	switch(Msg) {
	case WM_KeyDown:
		if(HotKeyDown(Key, X, Y))
			return;
		break;
	case WM_KeyUp:
		if(HotKeyUp(Key, X, Y))
			return;
		break;
	}

	Super.WindowEvent(Msg, C, X, Y, Key);
}


function bool HotKeyDown(int Key, float X, float Y)
{
	local UWindowHotkeyWindowList l;

	l = UWindowHotkeyWindowList(HotkeyWindows.Next);
	while(l != None)
	{
		if(l.Window != Self && l.Window.HotKeyDown(Key, X, Y)) return True;
		l = UWindowHotkeyWindowList(l.Next);
	}

	return False;
}

function bool HotKeyUp(int Key, float X, float Y)
{
	local UWindowHotkeyWindowList l;

	l = UWindowHotkeyWindowList(HotkeyWindows.Next);
	while(l != None)
	{
		if(l.Window != Self && l.Window.HotKeyUp(Key, X, Y)) return True;
		l = UWindowHotkeyWindowList(l.Next);
	}

	return False;
}

function CloseActiveWindow()
{
	if(ActiveWindow != None)
		ActiveWindow.EscClose();
}

function Resized()
{
	ResolutionChanged(WinWidth, WinHeight);
}

function SetScale(float NewScale)
{
	WinWidth = RealWidth / NewScale;
	WinHeight = RealHeight / NewScale;

	GUIScale = NewScale;

	ClippingRegion.X = 0;
	ClippingRegion.Y = 0;
	ClippingRegion.W = WinWidth;
	ClippingRegion.H = WinHeight;

	SetupFonts();

	Resized();
}

function SetupFonts()
{
	Fonts[F_Normal] = Font(DynamicLoadObject("t_gbxfonts.TahomaNormal", class'Font'));
	Fonts[F_Bold] = Font(DynamicLoadObject("t_gbxfonts.TahomaNormalBold", class'Font'));
}

function ChangeLookAndFeel(string NewLookAndFeel)
{
	LookAndFeelClass = NewLookAndFeel;
	SaveConfig();

//	// Completely restart UWindow system on the next paint
//	Console.ResetUWindow();
}

function HideWindow()
{
}

function SetMousePos(float X, float Y)
{
	MouseX = X;
	MouseY = Y;
}

function QuitGame()
{
	bRequestQuit = True;
	QuitTime = 0;
	NotifyQuitUnreal();
}

function DoQuitGame()
{
	SaveConfig();
//	Console.SaveConfig();
//	Console.ViewPort.Actor.SaveConfig();
//	Close();
	ViewportOwner.Actor.ConsoleCommand("exit");
}

function Tick(float Delta)
{
	if(bRequestQuit)
	{
		// Give everything time to close itself down (ie sockets).
		if(QuitTime > 0.25)
			DoQuitGame();
		QuitTime += Delta;
	}

	Super.Tick(Delta);
}

// ====================================================================
// Glue Code to hold the UWindows together
// ====================================================================

event Initialized()		// Replaces the BeginPlay
{
	Root = Self;
	MouseWindow = Self;
	KeyFocusWindow = Self;

	Created();		// Glue Logic Replace it later
}


function bool KeyEvent( out EInputKey Key, out EInputAction Action, FLOAT Delta )
{

	if ( (Action == IST_Press) && (Key == IK_Tilde) )
	{
		bAllowConsole = true;
		GotoState('UWindows');
		return true;
	}

	return Super.KeyEvent(Key,Action,Delta);
}


state UWindows
{
	function BeginState()
	{
		// Add code to initialize the uwindows system

		bVisible 		= true;
		bRequiresTick 	= true;

		bWindowVisible = True;
		bUWindowActive = true;

		ViewportOwner.bShowWindowsMouse = True;
		ViewportOwner.bSuspendPrecaching = True;

		if (ViewportOwner.Actor.Level.NetMode == NM_Standalone)
			ViewportOwner.Actor.SetPause( True );

		if (bAllowConsole)
			ConsoleWindow.ShowWindow();

	}

	function EndState()
	{
		// Add code to hide the window

		bVisible		 = false;
		bRequiresTick	 = false;

		bUWindowActive = False;
		bWindowVisible = False;

		ViewportOwner.bShowWindowsMouse = False;
		ViewportOwner.bSuspendPrecaching = False;

		if (ViewportOwner.Actor.Level.NetMode == NM_Standalone)
			ViewportOwner.Actor.SetPause( False );

		ConsoleWindow.HideWindow();

	}

	function bool KeyType(out EInputKey Key, optional string Unicode )
	{
		WindowEvent(WM_KeyType, None, MouseX, MouseY, Key);
		return true;
	}

	function bool KeyEvent( EInputKey Key, EInputAction Action, FLOAT Delta )
	{
		local byte k;
		k = Key;

		switch (Action)
		{
			case IST_Release:
				switch (k)
				{

					case EInputKey.IK_Escape:
						CloseActiveWindow();
						break;
					case EInputKey.IK_LeftMouse:
						WindowEvent(WM_LMouseUp, None, MouseX, MouseY, k);
						break;
					case EInputKey.IK_RightMouse:
						WindowEvent(WM_RMouseUp, None, MouseX, MouseY, k);
						break;
					case EInputKey.IK_MiddleMouse:
						WindowEvent(WM_MMouseUp, None, MouseX, MouseY, k);
						break;
					default:
						WindowEvent(WM_KeyUp, None, MouseX, MouseY, k);
						break;
				}
				break;

			case IST_Press:

				switch (k)
				{
					case EInputKey.IK_LeftMouse:
						WindowEvent(WM_LMouseDown, None, MouseX, MouseY, k);
						break;
					case EInputKey.IK_RightMouse:
						WindowEvent(WM_RMouseDown, None, MouseX, MouseY, k);
						break;
					case EInputKey.IK_MiddleMouse:
						WindowEvent(WM_MMouseDown, None, MouseX, MouseY, k);
						break;
					default:
						WindowEvent(WM_KeyDown, None, MouseX, MouseY, k);
						break;
				}
				break;
			case IST_Axis:
				switch (Key)
				{
					case IK_MouseX:
						MouseX = MouseX + (MouseScale * Delta);
						break;
					case IK_MouseY:
						MouseY = MouseY - (MouseScale * Delta);
						break;
				}
			default:
				break;
		}
		return true;
	}

}

function PostRender(canvas Canvas)
{
	local UWindowWindow NewFocusWindow;

	Canvas.bNoSmooth = True;
	Canvas.Z = 1;
	Canvas.Style = 1;
	Canvas.DrawColor.r = 255;
	Canvas.DrawColor.g = 255;
	Canvas.DrawColor.b = 255;

	if(ViewportOwner.bWindowsMouseAvailable && Root != None)
	{
		MouseX = ViewportOwner.WindowsMouseX/Root.GUIScale;
		MouseY = ViewportOwner.WindowsMouseY/Root.GUIScale;
	}

	if(Canvas.ClipX != OldClipX || Canvas.ClipY != OldClipY)
	{
		OldClipX = Canvas.ClipX;
		OldClipY = Canvas.ClipY;

		WinTop = 0;
		WinLeft = 0;
		WinWidth = Canvas.ClipX / Root.GUIScale;
		WinHeight = Canvas.ClipY / Root.GUIScale;

		RealWidth = Canvas.ClipX;
		RealHeight = Canvas.ClipY;

		ClippingRegion.X = 0;
		ClippingRegion.Y = 0;
		ClippingRegion.W = Root.WinWidth;
		ClippingRegion.H = Root.WinHeight;
		Resized();
	}

	if(MouseX > WinWidth) MouseX = WinWidth;
	if(MouseY > WinHeight) MouseY = WinHeight;
	if(MouseX < 0) MouseX = 0;
	if(MouseY < 0) MouseY = 0;


	// Check for keyboard focus
	NewFocusWindow = CheckKeyFocusWindow();

	if(NewFocusWindow != KeyFocusWindow)
	{
		KeyFocusWindow.KeyFocusExit();
		KeyFocusWindow = NewFocusWindow;
		KeyFocusWindow.KeyFocusEnter();
	}

	MoveMouse(MouseX, MouseY);

	WindowEvent(WM_Paint, Canvas, MouseX, MouseY, 0);

	DrawMouse(Canvas);

}

function Message( coerce string Msg, float MsgLife)
{
	PropagateMessage(Msg,MsgLife);

	// @@Hack - Pass along to the console

	if (ConsoleWindow!=None)
  		ConsoleWindow.PropagateMessage(Msg,MsgLife);
}


defaultproperties
{
	GUIScale=1
	LookAndFeelClass=""
	bAllowConsole=True
	ConsoleClass=class'UWindowConsoleWindow'
	MouseScale=0.60
}
//=============================================================================
// UWindowSBDownButton - Scrollbar up button
//=============================================================================
class UWindowSBDownButton extends UWindowButton;



var float NextClickTime;

function Created()
{
	bNoKeyboard = True;
	Super.Created();
}

function BeforePaint(Canvas C, float X, float Y)
{
	LookAndFeel.SB_SetupDownButton(Self);
}

function LMouseDown(float X, float Y)
{
	Super.LMouseDown(X, Y);
	if(bDisabled)
		return;
	UWindowVScrollBar(ParentWindow).Scroll(UWindowVScrollBar(ParentWindow).ScrollAmount);
	NextClickTime = Root.GetPlayerOwner().Level.TimeSeconds + 0.5;
}

function Tick(float Delta)
{
	if(bMouseDown && (NextClickTime > 0) && (NextClickTime < Root.GetPlayerOwner().Level.TimeSeconds))
	{
		UWindowVScrollBar(ParentWindow).Scroll(UWindowVScrollBar(ParentWindow).ScrollAmount);
		NextClickTime = Root.GetPlayerOwner().Level.TimeSeconds + 0.1;
	}

	if(!bMouseDown)
	{
		NextClickTime = 0;
	}
}
//=============================================================================
// UWindowSBLeftButton - Scrollbar left button
//=============================================================================
class UWindowSBLeftButton extends UWindowButton;



var float NextClickTime;

function Created()
{
	bNoKeyboard = True;
	Super.Created();
}

function BeforePaint(Canvas C, float X, float Y)
{
	LookAndFeel.SB_SetupLeftButton(Self);
}

function LMouseDown(float X, float Y)
{
	Super.LMouseDown(X, Y);
	if(bDisabled)
		return;
	UWindowHScrollBar(ParentWindow).Scroll(-UWindowHScrollBar(ParentWindow).ScrollAmount);
	NextClickTime = GetLevel().TimeSeconds + 0.5;
}

function Tick(float Delta)
{
	if(bMouseDown && (NextClickTime > 0) && (NextClickTime < GetLevel().TimeSeconds))
	{
		UWindowHScrollBar(ParentWindow).Scroll(-UWindowHScrollBar(ParentWindow).ScrollAmount);
		NextClickTime = GetLevel().TimeSeconds + 0.1;
	}

	if(!bMouseDown)
	{
		NextClickTime = 0;
	}
}
//=============================================================================
// UWindowSBRightButton - Scrollbar right button
//=============================================================================
class UWindowSBRightButton extends UWindowButton;



var float NextClickTime;

function Created()
{
	bNoKeyboard = True;
	Super.Created();
}

function BeforePaint(Canvas C, float X, float Y)
{
	LookAndFeel.SB_SetupRightButton(Self);
}

function LMouseDown(float X, float Y)
{
	Super.LMouseDown(X, Y);
	if(bDisabled)
		return;
	UWindowHScrollBar(ParentWindow).Scroll(UWindowHScrollBar(ParentWindow).ScrollAmount);
	NextClickTime = GetLevel().TimeSeconds + 0.5;
}

function Tick(float Delta)
{
	if(bMouseDown && (NextClickTime > 0) && (NextClickTime < GetLevel().TimeSeconds))
	{
		UWindowHScrollBar(ParentWindow).Scroll(UWindowHScrollBar(ParentWindow).ScrollAmount);
		NextClickTime = GetLevel().TimeSeconds + 0.1;
	}

	if(!bMouseDown)
	{
		NextClickTime = 0;
	}
}
//=============================================================================
// UWindowSBUpButton - Scrollbar up button
//=============================================================================
class UWindowSBUpButton extends UWindowButton;



var float NextClickTime;

function Created()
{
	bNoKeyboard = True;
	Super.Created();
}

function BeforePaint(Canvas C, float X, float Y)
{
	LookAndFeel.SB_SetupUpButton(Self);
}

function LMouseDown(float X, float Y)
{
	Super.LMouseDown(X, Y);
	if(bDisabled)
		return;
	UWindowVScrollBar(ParentWindow).Scroll(-UWindowVScrollBar(ParentWindow).ScrollAmount);
	NextClickTime = GetLevel().TimeSeconds + 0.5;
}

function Tick(float Delta)
{
	if(bMouseDown && (NextClickTime > 0) && (NextClickTime < GetLevel().TimeSeconds))
	{
		UWindowVScrollBar(ParentWindow).Scroll(-UWindowVScrollBar(ParentWindow).ScrollAmount);
		NextClickTime = GetLevel().TimeSeconds + 0.1;
	}

	if(!bMouseDown)
	{
		NextClickTime = 0;
	}
}

class UWindowScrollingDialogClient extends UWindowPageWindow;



var bool bShowHorizSB;
var bool bShowVertSB;

var UWindowDialogClientWindow	ClientArea;
var UWindowDialogClientWindow	FixedArea;
var class<UWindowDialogClientWindow> ClientClass;
var class<UWindowDialogClientWindow> FixedAreaClass;

var UWindowVScrollBar VertSB;
var UWindowHScrollBar HorizSB;
var UWindowBitmap	  BRBitmap;

function Created()
{
	Super.Created();

	if(FixedAreaClass != None)
	{
		FixedArea = UWindowDialogClientWindow(CreateWindow(FixedAreaClass, 0, 0, 100, 100, OwnerWindow));
		FixedArea.bAlwaysOnTop = True;
	}
	else
		FixedArea = None;

	ClientArea = UWindowDialogClientWindow(CreateWindow(ClientClass, 0, 0, WinWidth, WinHeight, OwnerWindow));

	VertSB = UWindowVScrollbar(CreateWindow(class'UWindowVScrollbar', WinWidth-12, 0, 12, WinHeight));
	VertSB.bAlwaysOnTop = True;
	VertSB.HideWindow();

	HorizSB = UWindowHScrollbar(CreateWindow(class'UWindowHScrollbar', 0, WinHeight-12, WinWidth, 12));
	HorizSB.bAlwaysOnTop = True;
	HorizSB.HideWindow();

	BRBitmap = UWindowBitmap(CreateWindow(class'UWindowBitmap', WinWidth-12, WinHeight-12, 12, 12));
	BRBitmap.bAlwaysOnTop = True;
	BRBitmap.HideWindow();
	BRBitmap.bStretch = True;
}

function BeforePaint(Canvas C, float X, float Y)
{
	local float ClientWidth, ClientHeight;
	local float FixedHeight;


	if(FixedArea != None)
		FixedHeight = FixedArea.WinHeight;
	else
		FixedHeight = 0;

	ClientWidth = ClientArea.DesiredWidth;
	ClientHeight = ClientArea.DesiredHeight;

	if(ClientWidth <= WinWidth)
		ClientWidth = WinWidth;

	if(ClientHeight <= WinHeight - FixedHeight)
		ClientHeight = WinHeight - FixedHeight;

	ClientArea.SetSize(ClientWidth, ClientHeight);

	bShowVertSB = (ClientHeight > WinHeight - FixedHeight);
	bShowHorizSB = (ClientWidth > WinWidth);

	if(bShowHorizSB)
	{
		// re-examine need for vertical SB now we've got smaller client area.

		ClientHeight = ClientArea.DesiredHeight;

		if(ClientHeight <= WinHeight - LookAndFeel.Size_ScrollbarWidth - FixedHeight)
			ClientHeight = WinHeight - LookAndFeel.Size_ScrollbarWidth - FixedHeight;

		bShowVertSB = (ClientHeight > WinHeight - LookAndFeel.Size_ScrollbarWidth - FixedHeight);
	}

	if(bShowVertSB)
	{
		VertSB.ShowWindow();
		VertSB.WinTop = 0;
		VertSB.WinLeft = WinWidth - LookAndFeel.Size_ScrollbarWidth;
		VertSB.WinWidth = LookAndFeel.Size_ScrollbarWidth;
		if(bShowHorizSB)
		{
			BRBitmap.ShowWindow();
			BRBitmap.WinWidth = LookAndFeel.Size_ScrollbarWidth;
			BRBitmap.WinHeight = LookAndFeel.Size_ScrollbarWidth;
			BRBitmap.WinTop = WinHeight - LookAndFeel.Size_ScrollbarWidth - FixedHeight;
			BRBitmap.WinLeft = WinWidth - LookAndFeel.Size_ScrollbarWidth;

			BRBitmap.T = GetLookAndFeelTexture();
			//BRBitmap.R = LookAndFeel.SBBackground;

			VertSB.WinHeight = WinHeight - LookAndFeel.Size_ScrollbarWidth - FixedHeight;
		}
		else
		{
			BRBitmap.HideWindow();
			VertSB.WinHeight = WinHeight - FixedHeight;
		}

		VertSB.SetRange(0, ClientHeight, VertSB.WinHeight, 10);
	}
	else
	{
		BRBitmap.HideWindow();
		VertSB.HideWindow();
		VertSB.Pos = 0;
	}

	if(bShowHorizSB)
	{
		HorizSB.ShowWindow();
		HorizSB.WinLeft = 0;
		HorizSB.WinTop = WinHeight - LookAndFeel.Size_ScrollbarWidth - FixedHeight;
		HorizSB.WinHeight = LookAndFeel.Size_ScrollbarWidth;
		if(bShowVertSB)
			HorizSB.WinWidth = WinWidth - LookAndFeel.Size_ScrollbarWidth;
		else
			HorizSB.WinWidth = WinWidth;

		HorizSB.SetRange(0, ClientWidth, HorizSB.WinWidth, 10);
	}
	else
	{
		HorizSB.HideWindow();
		HorizSB.Pos = 0;
	}

	ClientArea.WinLeft = -HorizSB.Pos;
	ClientArea.WinTop = -VertSB.Pos;

	if(FixedArea != None)
	{
		FixedArea.WinLeft = 0;
		FixedArea.WinTop = WinHeight - FixedHeight;
		if(FixedArea.WinWidth != WinWidth)
			FixedArea.SetSize(WinWidth, FixedArea.WinHeight);
	}

	Super.BeforePaint(C, X, Y);
}

function GetDesiredDimensions(out float W, out float H)
{
	Super(UWindowWindow).GetDesiredDimensions(W, H);
}

function Paint(Canvas C, float X, float Y)
{
}

defaultproperties
{
	ClientClass=class'UWindowDialogClientWindow'
	FixedAreaClass=None
}
class UWindowSmallButton extends UWindowButton;



function Created()
{
	bNoKeyboard = True;

	Super.Created();

	ToolTipString = "";
	SetText("");
	SetFont(F_Normal);

	WinHeight = 16;
}

function AutoWidth(Canvas C)
{
	local float W, H;
	C.Font = Root.Fonts[Font];

	TextSize(C, RemoveAmpersand(Text), W, H);

	if(WinWidth < W + 10)
		WinWidth = W + 10;
}

function BeforePaint(Canvas C, float X, float Y)
{
	local float W, H;
	C.Font = Root.Fonts[Font];

	TextSize(C, RemoveAmpersand(Text), W, H);

	TextX = (WinWidth-W)/2;
	TextY = (WinHeight-H)/2;

	if(bMouseDown)
	{
		TextX += 1;
		TextY += 1;
	}
}

function Paint(Canvas C, float X, float Y)
{
	LookAndFeel.Button_DrawSmallButton(Self, C);
	Super.Paint(C, X, Y);
}
class UWindowSmallCancelButton extends UWindowButton;



var localized string CancelText;

function Created()
{
	Super.Created();
	SetText(CancelText);
}

defaultproperties
{
	CancelText="Cancel"
}
class UWindowSmallCloseButton extends UWindowSmallButton;



var localized string CloseText;

function Created()
{
	Super.Created();
	SetText(CloseText);
}

function Click(float X, float Y)
{
	UWindowFramedWindow(GetParent(class'UWindowFramedWindow')).Close();
}

defaultproperties
{
	CloseText="Close"
}
class UWindowSmallOKButton extends UWindowSmallCloseButton;



var localized string OKText;

function Created()
{
	Super.Created();
	SetText(OKText);
}

defaultproperties
{
	OKText="OK"
}
class UWindowTabControl extends UWindowListControl;



var UWindowTabControlLeftButton		LeftButton;
var UWindowTabControlRightButton	RightButton;
var UWindowTabControlTabArea		TabArea;
var UWindowTabControlItem			SelectedTab;

var bool							bMultiLine;
var bool							bSelectNearestTabOnRemove;

function Created()
{
	Super.Created();

	SelectedTab = None;

	TabArea = UWindowTabControlTabArea(CreateWindow(class'UWindowTabControlTabArea',
					0, 0, WinWidth - LookAndFeel.Size_ScrollbarWidth
						- LookAndFeel.Size_ScrollbarWidth - 10,
					 LookAndFeel.Size_TabAreaHeight+LookAndFeel.Size_TabAreaOverhangHeight));

	TabArea.bAlwaysOnTop = True;

	LeftButton = UWindowTabControlLeftButton(CreateWindow(class'UWindowTabControlLeftButton', WinWidth-20, 0, 10, 12));
	RightButton = UWindowTabControlRightButton(CreateWindow(class'UWindowTabControlRightButton', WinWidth-10, 0, 10, 12));
}

function BeforePaint(Canvas C, float X, float Y)
{
	TabArea.WinTop = 0;
	TabArea.WinLeft = 0;

	if(bMultiLine)
		TabArea.WinWidth = WinWidth;
	else
		TabArea.WinWidth = WinWidth - LookAndFeel.Size_ScrollbarWidth - LookAndFeel.Size_ScrollbarWidth - 10;

	TabArea.LayoutTabs(C);
	WinHeight = (LookAndFeel.Size_TabAreaHeight * TabArea.TabRows) + LookAndFeel.Size_TabAreaOverhangHeight;
	TabArea.WinHeight = WinHeight;

	Super.BeforePaint(C, X, Y);
}

function SetMultiLine(bool InMultiLine)
{
	bMultiLine = InMultiLine;

	if(bMultiLine)
	{
		LeftButton.HideWindow();
		RightButton.HideWindow();
	}
	else
	{
		LeftButton.ShowWindow();
		RightButton.ShowWindow();
	}
}

function Paint(Canvas C, float X, float Y)
{
	local Region R;
	local Texture T;

	T = GetLookAndFeelTexture();
	R = LookAndFeel.TabBackground;
	DrawStretchedTextureSegment( C, 0, 0, WinWidth, LookAndFeel.Size_TabAreaHeight * TabArea.TabRows, R.X, R.Y, R.W, R.H, T );
}

function UWindowTabControlItem AddTab(string Caption)
{
	local UWindowTabControlItem I;

	I = UWindowTabControlItem(Items.Append(ListClass));

	I.Owner = Self;
	I.SetCaption(Caption);

	if(SelectedTab == None)
		SelectedTab = I;

	return I;
}

function UWindowTabControlItem InsertTab(UWindowTabControlItem BeforeTab, string Caption)
{
	local UWindowTabControlItem I;

	I = UWindowTabControlItem(BeforeTab.InsertBefore(ListClass));

	I.Owner = Self;
	I.SetCaption(Caption);

	if(SelectedTab == None)
		SelectedTab = I;

	return I;
}

function GotoTab( UWindowTabControlItem NewSelected, optional bool bByUser )
{
	if(SelectedTab != NewSelected && bByUser)
		LookAndFeel.PlayMenuSound(Self, MS_ChangeTab);
	SelectedTab = NewSelected;
	TabArea.bShowSelected = True;
}

function UWindowTabControlItem GetTab( string Caption )
{
	local UWindowTabControlItem I;
	for(I = UWindowTabControlItem(Items.Next); I != None; I = UWindowTabControlItem(I.Next))
	{
		if(I.Caption == Caption) return I;
	}

	return None;
}

function DeleteTab( UWindowTabControlItem Tab )
{
	local UWindowTabControlItem NextTab;
	local UWindowTabControlItem PrevTab;

	NextTab = UWindowTabControlItem(Tab.Next);
	PrevTab = UWindowTabControlItem(Tab.Prev);
	Tab.Remove();

	if(SelectedTab == Tab)
	{
		if(bSelectNearestTabOnRemove)
		{
			Tab = NextTab;
			if(Tab == None)
				Tab = PrevTab;

			GotoTab(Tab);
		}
		else
			GotoTab(UWindowTabControlItem(Items.Next));
	}
}

defaultproperties
{
	ListClass=class'UWindowTabControlItem'
	bMultiLine=False
}
class UWindowTabControlItem extends UWindowList;



var string					Caption;
var string					HelpText;

var UWindowTabControl		Owner;
var float					TabTop;
var float					TabLeft;
var float					TabWidth;
var float					TabHeight;

var int						RowNumber;
var bool					bFlash;

function SetCaption(string NewCaption)
{
	Caption=NewCaption;
}

function RightClickTab()
{
}
class UWindowTabControlLeftButton extends UWindowButton;



function BeforePaint(Canvas C, float X, float Y)
{
	LookAndFeel.Tab_SetupLeftButton(Self);
}

function LMouseDown(float X, float Y)
{
	Super.LMouseDown(X, Y);
	if(!bDisabled)
		UWindowTabControl(ParentWindow).TabArea.TabOffset--;
}

defaultproperties
{
	bNoKeyboard=True
}
class UWindowTabControlRightButton extends UWindowButton;



function BeforePaint(Canvas C, float X, float Y)
{
	LookAndFeel.Tab_SetupRightButton(Self);
}

function LMouseDown(float X, float Y)
{
	Super.LMouseDown(X, Y);
	if(!bDisabled)
		UWindowTabControl(ParentWindow).TabArea.TabOffset++;
}

defaultproperties
{
	bNoKeyboard=True
}
class UWindowTabControlTabArea extends UWindowWindow;



var int TabOffset;
var bool bShowSelected;
var UWindowTabControlItem FirstShown;
var bool bDragging;
var UWindowTabControlItem DragTab;
var int TabRows;
var globalconfig bool bArrangeRowsLikeTimHates;
var float UnFlashTime;
var bool bFlashShown;

function Created()
{
	TabOffset = 0;
	Super.Created();
}

function SizeTabsSingleLine(Canvas C)
{
	local UWindowTabControlItem I, Selected, LastHidden;
	local int Count, TabCount;
	local float ItemX, W, H;
	local bool bHaveMore;

	ItemX = LookAndFeel.Size_TabXOffset;
	TabCount=0;
	for(
			I = UWindowTabControlItem(UWindowTabControl(ParentWindow).Items.Next);
			I != None;
			I = UWindowTabControlItem(I.Next)
		)
	{
		LookAndFeel.Tab_GetTabSize(Self, C, RemoveAmpersand(I.Caption), W, H);
		I.TabWidth = W;
		I.TabHeight = H + 1;
		I.TabTop = 0;
		I.RowNumber = 0;
		TabCount++;
	}

	Selected = UWindowTabControl(ParentWindow).SelectedTab;

	while(True)
	{
		ItemX = LookAndFeel.Size_TabXOffset;
		Count = 0;
		LastHidden = None;
		FirstShown = None;
		for(
				I = UWindowTabControlItem(UWindowTabControl(ParentWindow).Items.Next);
				I != None;
				I = UWindowTabControlItem(I.Next)
			)
		{
			if( Count < TabOffset)
			{
				I.TabLeft = -1;
				LastHidden = I;
			}
			else
			{
				if(FirstShown == None) FirstShown = I;
				I.TabLeft = ItemX;
				if(I.TabLeft + I.TabWidth >= WinWidth + 5) bHaveMore = True;
				ItemX += I.TabWidth;
			}
			Count++;

		}

		if( TabOffset > 0 && LastHidden != None && LastHidden.TabWidth + 5 < WinWidth - ItemX)
			TabOffset--;
		else
		if(	bShowSelected && TabOffset < TabCount - 1
			&&	Selected != None &&	Selected != FirstShown
			&& Selected.TabLeft + Selected.TabWidth > WinWidth - 5
		  )
			TabOffset++;
		else
			break;
	}
	bShowSelected = False;

	UWindowTabControl(ParentWindow).LeftButton.bDisabled = TabOffset <= 0;
	UWindowTabControl(ParentWindow).RightButton.bDisabled = !bHaveMore;
	TabRows = 1;
}

function SizeTabsMultiLine(Canvas C)
{
	local UWindowTabControlItem I, Selected;
	local float W, H;
	local int MinRow;
	local float RowWidths[10];
	local int TabCounts[10];
	local int j;
	local bool bTryAnotherRow;

	TabOffset = 0;
	FirstShown = None;

	TabRows = 1;
	bTryAnotherRow = True;

	while(bTryAnotherRow && TabRows <= 10)
	{
		bTryAnotherRow = False;
		for(j=0;j<TabRows;j++)
		{
			RowWidths[j] = 0;
			TabCounts[j] = 0;
		}

		for(
				I = UWindowTabControlItem(UWindowTabControl(ParentWindow).Items.Next);
				I != None;
				I = UWindowTabControlItem(I.Next)
			)
		{
			LookAndFeel.Tab_GetTabSize(Self, C, RemoveAmpersand(I.Caption), W, H);
			I.TabWidth = W;
			I.TabHeight = H;

			// find the best row for this tab
			MinRow = 0;
			for(j=1;j<TabRows;j++)
				if(RowWidths[j] < RowWidths[MinRow])
					MinRow = j;

			if(RowWidths[MinRow] + W > WinWidth)
			{
				TabRows ++;
				bTryAnotherRow = True;
				break;
			}
			else
			{
				RowWidths[MinRow] += W;
				TabCounts[MinRow]++;
				I.RowNumber = MinRow;
			}
		}
	}

	Selected = UWindowTabControl(ParentWindow).SelectedTab;

	if(TabRows > 1)
	{
		for(
				I = UWindowTabControlItem(UWindowTabControl(ParentWindow).Items.Next);
				I != None;
				I = UWindowTabControlItem(I.Next)
			)
		{
			I.TabWidth += (WinWidth - RowWidths[I.RowNumber]) / TabCounts[I.RowNumber];
		}
	}

	for(j=0;j<TabRows;j++)
		RowWidths[j] = 0;

	for(
			I = UWindowTabControlItem(UWindowTabControl(ParentWindow).Items.Next);
			I != None;
			I = UWindowTabControlItem(I.Next)
		)
	{
		I.TabLeft = RowWidths[I.RowNumber];

		if(bArrangeRowsLikeTimHates)
			I.TabTop = ((I.RowNumber + ((TabRows - 1) - Selected.RowNumber)) % TabRows) * I.TabHeight;
		else
			I.TabTop = I.RowNumber * I.TabHeight;

		RowWidths[I.RowNumber] += I.TabWidth;
	}
}

function LayoutTabs(Canvas C)
{
	if(UWindowTabControl(ParentWindow).bMultiLine)
		SizeTabsMultiLine(C);
	else
		SizeTabsSingleLine(C);
}

function Paint(Canvas C, float X, float Y)
{
	local UWindowTabControlItem I;
	local int Count;
	local int Row;
	local float T;

	T = GetEntryLevel().TimeSeconds;

	if(UnFlashTime < T)
	{
		bFlashShown = !bFlashShown;

		if(bFlashShown)
			UnFlashTime = T + 0.5;
		else
			UnFlashTime = T + 0.3;
	}

	for(Row=0;Row<TabRows;Row++)
	{
		Count = 0;
		for(
				I = UWindowTabControlItem(UWindowTabControl(ParentWindow).Items.Next);
				I != None;
				I = UWindowTabControlItem(I.Next)
			)
		{
			if( Count < TabOffset)
			{
				Count++;
				continue;
			}
			if(I.RowNumber == Row)
				DrawItem(C, I, I.TabLeft, I.TabTop, I.TabWidth, I.TabHeight, (!I.bFlash) || bFlashShown);
		}
	}
}

function LMouseDown(float X, float Y)
{
	local UWindowTabControlItem I;
	local int Count;

	Super.LMouseDown(X, Y);

	Count = 0;
	for(
			I = UWindowTabControlItem(UWindowTabControl(ParentWindow).Items.Next);
			I != None;
			I = UWindowTabControlItem(I.Next)
		)
	{
		if( Count < TabOffset)
		{
			Count++;
			continue;
		}
		if( X >= I.TabLeft && X <= I.TabLeft + I.TabWidth && (TabRows==1 || (Y >= I.TabTop && Y <= I.TabTop + I.TabHeight)) )
		{
			if(!UWindowTabControl(ParentWindow).bMultiLine)
			{
				bDragging = True;
				DragTab = I;
				Root.CaptureMouse();
			}
			UWindowTabControl(ParentWindow).GotoTab(I, True);
		}
	}
}

function MouseMove(float X, float Y)
{
	if(bDragging && bMouseDown)
	{
		if(X < DragTab.TabLeft)
			TabOffset++;

		if(X > DragTab.TabLeft + DragTab.TabWidth && TabOffset > 0)
			TabOffset--;
	}
	else
		bDragging = False;
}

function RMouseDown(float X, float Y)
{
	local UWindowTabControlItem I;
	local int Count;

	Super.LMouseDown(X, Y);

	Count = 0;
	for(
			I = UWindowTabControlItem(UWindowTabControl(ParentWindow).Items.Next);
			I != None;
			I = UWindowTabControlItem(I.Next)
		)
	{
		if( Count < TabOffset)
		{
			Count++;
			continue;
		}
		if( X >= I.TabLeft && X <= I.TabLeft + I.TabWidth )
		{
			I.RightClickTab();
		}
	}
}

function DrawItem(Canvas C, UWindowList Item, float X, float Y, float W, float H, bool bShowText)
{
	if(Item == UWindowTabControl(ParentWindow).SelectedTab)
		LookAndFeel.Tab_DrawTab(Self, C, True, FirstShown==Item, X, Y, W, H, UWindowTabControlItem(Item).Caption, bShowText);
	else
		LookAndFeel.Tab_DrawTab(Self, C, False, FirstShown==Item, X, Y, W, H, UWindowTabControlItem(Item).Caption, bShowText);
}

function bool CheckMousePassThrough(float X, float Y)
{
	return Y >= LookAndFeel.Size_TabAreaHeight*TabRows;
}

defaultproperties
{
	bArrangeRowsLikeTimHates=False
}
class UWindowTextAreaControl extends UWindowDialogControl;



var string TextArea[750];
var string Prompt;
var Font AbsoluteFont;
var int BufSize;
var int Head, Tail, Lines, VisibleRows;

var bool bCursor;
var bool bScrollable;
var bool bShowCaret;
var bool bScrollOnResize;

var UWindowVScrollBar VertSB;
var float LastDrawTime;

function Created()
{
	Super.Created();
	if (GetLevel() != None)
		LastDrawTime = GetLevel().TimeSeconds;
}

function SetScrollable(bool newScrollable)
{
	bScrollable = newScrollable;
	if(newScrollable)
	{
		VertSB = UWindowVScrollbar(CreateWindow(class'UWindowVScrollbar', WinWidth-12, 0, 12, WinHeight));
		VertSB.bAlwaysOnTop = True;
	}
	else
	{
		if (VertSB != None)
		{
			VertSB.Close();
			VertSB = None;
		}
	}
}

function BeforePaint( Canvas C, float X, float Y )
{
	Super.BeforePaint(C, X, Y);

	if(VertSB != None)
	{
		VertSB.WinTop = 0;
		VertSB.WinHeight = WinHeight;
		VertSB.WinWidth = LookAndFeel.Size_ScrollbarWidth;
		VertSB.WinLeft = WinWidth - LookAndFeel.Size_ScrollbarWidth;
	}
}

function SetAbsoluteFont(Font F)
{
	AbsoluteFont = F;
}

function Paint( Canvas C, float X, float Y )
{
	local int i, Line;
	local int TempHead, TempTail;
	local float XL, YL;
	local float W, H;

	if(AbsoluteFont != None)
		C.Font = AbsoluteFont;
	else
		C.Font = Root.Fonts[Font];

	C.SetDrawColor(255,255,255);

	TextSize(C, "TEST", XL, YL);
	VisibleRows = WinHeight / YL;

	TempHead = Head;
	TempTail = Tail;
	Line = TempHead;
	TextArea[Line] = Prompt;

	if(Prompt == "")
	{
		Line--;
		if(Line < 0)
			Line += BufSize;
	}

	if(bScrollable)
	{
		if (VertSB.MaxPos - VertSB.Pos >= 0)
		{
			Line -= VertSB.MaxPos - VertSB.Pos;
			TempTail -= VertSB.MaxPos - VertSB.Pos;

			if(Line < 0)
				Line += BufSize;
			if(TempTail < 0)
				TempTail += BufSize;
		}
	}

	if(!bCursor)
	{
		bShowCaret = False;
	}
	else
	{
		if((GetLevel().TimeSeconds > LastDrawTime + 0.3) || (GetLevel().TimeSeconds < LastDrawTime))
		{
			LastDrawTime = GetLevel().TimeSeconds;
			bShowCaret = !bShowCaret;
		}
	}

	for(i=0; i<VisibleRows+1; i++)
	{
		ClipText(C, 2, WinHeight-YL*(i+1), TextArea[Line]);
		if(Line == Head && bShowCaret)
		{
			// Draw cursor..
			TextSize(C, TextArea[Line], W, H);
			ClipText(C, W, WinHeight-YL*(i+1), "|");
		}

		if(TempTail == Line)
			break;

		Line--;
		if(Line < 0)
			Line += BufSize;
	}
}

function AddText(string NewLine)
{
	TextArea[Head] = NewLine;
	Head = (Head + 1)%BufSize;

	if(Head == Tail)
		Tail = (Tail + 1)%BufSize;

	// Calculate lines for scrollbar.
	Lines = Head - Tail;
	if(Lines < 0)
		Lines += BufSize;

	if(bScrollable)
	{
		VertSB.SetRange(0, Lines, VisibleRows);
		VertSB.Pos = VertSB.MaxPos;
	}
}

function Resized()
{
	if(bScrollable)
	{
		VertSB.SetRange(0, Lines, VisibleRows);
		if(bScrollOnResize)
			VertSB.Pos = VertSB.MaxPos;
	}
}

function SetPrompt(string NewPrompt)
{
	Prompt = NewPrompt;
}

function Clear()
{
	TextArea[0] = "";
	Head = 0;
	Tail = 0;
}

defaultproperties
{
	BufSize=750
	bScrollOnResize=True
}
class UWindowURLTextArea extends UWindowDynamicTextArea;



var bool bReleased;

function BeforePaint(Canvas C, float X, float Y)
{
	Super.BeforePaint(C, X, Y);
	Cursor = Root.NormalCursor;
}

function Paint(Canvas C, float X, float Y)
{
	Super.Paint(C, X, Y);
	bReleased = False;
}

function TextAreaClipText(Canvas C, float DrawX, float DrawY, coerce string S, optional bool bCheckHotkey)
{
	local float X, Y, W, H;
	local float ClickX, ClickY;
	local string Text, NextBlock;
	local byte bLink;
	local bool bOverLink;

	Text = S;
	X = DrawX;
	Y = DrawY;
	while(Text != "")
	{
		ProcessText(C, Text, NextBlock, W, H, bLink);
		if(bLink != 0)
		{
			C.SetDrawColor(0,0,255);
		}
		else
		{
			C.SetDrawColor(255,255,255);
		}

		GetMouseXY(ClickX, ClickY);
		bOverLink = bLink != 0 && DrawX < ClickX && DrawX + W > ClickX && DrawY < ClickY && DrawY + H > ClickY;

		if(bOverLink)
			Cursor = Root.HandCursor;

		if(bOverLink && (bMouseDown || bReleased))
		{
			if(bReleased)
			{
				Log("Clicked URL: >>"$NextBlock$"<<");
				if( Left(NextBlock, 7) ~= "http://" )
					GetPlayerOwner().ConsoleCommand("start "$NextBlock);
				if( Left(NextBlock, 6) ~= "ftp://" )
					GetPlayerOwner().ConsoleCommand("start "$NextBlock);
				if( Left(NextBlock, 9) ~= "telnet://" )
					GetPlayerOwner().ConsoleCommand("start "$NextBlock);
				if( Left(NextBlock, 9) ~= "gopher://" )
					GetPlayerOwner().ConsoleCommand("start "$NextBlock);
				if( Left(NextBlock, 4) ~= "www." )
					GetPlayerOwner().ConsoleCommand("start http://"$NextBlock);
				if( Left(NextBlock, 4) ~= "ftp." )
					GetPlayerOwner().ConsoleCommand("start ftp://"$NextBlock);
				else
				if( Left(NextBlock, 9) ~= "unreal://" )
					LaunchUnrealURL(NextBlock);
			}
			else
			{
				C.SetDrawColor(255,0,0);
			}
			if(bReleased)
				bReleased = False;
		}

		if(bLink != 0)
			DrawStretchedTexture(C, DrawX, DrawY+H-1, W, 1, Texture'WhiteTexture');
		ClipText(C, DrawX, DrawY, NextBlock);
		DrawX += W;
	}
}

function LaunchUnrealURL(string URL)
{
	GetPlayerOwner().ClientTravel(URL, TRAVEL_Absolute, false);
}

function Click(float X, float Y)
{
	Super.Click(X, Y);
	bReleased = True;
}

function ProcessText(Canvas C, out string Text, out string NextBlock, out float W, out float H, out byte bLink)
{
	local int i, j;

	i = InStr(Text, "http://");

	j = InStr(Text, "www.");
	if(i == -1 || j == -1)
		i = Max(i, j);
	else
		i = Min(i, j);

	j = InStr(Text, "unreal://");
	if(i == -1 || j == -1)
		i = Max(i, j);
	else
		i = Min(i, j);

	j = InStr(Text, "ftp://");
	if(i == -1 || j == -1)
		i = Max(i, j);
	else
		i = Min(i, j);

	j = InStr(Text, "ftp.");
	if(i == -1 || j == -1)
		i = Max(i, j);
	else
		i = Min(i, j);

	j = InStr(Text, "telnet://");
	if(i == -1 || j == -1)
		i = Max(i, j);
	else
		i = Min(i, j);

	j = InStr(Text, "gopher://");
	if(i == -1 || j == -1)
		i = Max(i, j);
	else
		i = Min(i, j);

	bLink = 0;

	if(i == -1)
	{
		NextBlock = Text;
		Text = "";
	}
	else
	if(i == 0)
	{
		bLink = 1;

		i = InStr(Text, " ");
		if(i == -1)
		{
			NextBlock = Text;
			Text = "";
		}
		else
		{
			NextBlock = Left(Text, i);
			Text = Mid(Text, i);
		}
	}
	else
	{
		NextBlock = Left(Text, i);
		Text = Mid(Text, i);
	}

	TextAreaTextSize(C, NextBlock, W, H);
}

defaultproperties
{
	Font=0
	bNoKeyboard=True
	bIgnoreLDoubleClick=True
}
//=============================================================================
// UWindowVScrollBar - A vertical scrollbar
//=============================================================================
class UWindowVScrollBar extends UWindowWindow;



var UWindowSBUpButton		UpButton;
var UWindowSBDownButton		DownButton;
var bool					bDisabled;
var float					MinPos;
var float					MaxPos;
var float					MaxVisible;
var float					Pos;				// offset to WinTop
var float					ThumbStart, ThumbHeight;
var float					NextClickTime;
var float					DragY;
var bool					bDragging;
var float					ScrollAmount;

function Show(float P)
{
	if(P < 0) return;
	if(P > MaxPos + MaxVisible) return;

	while(P < Pos)
		if(!Scroll(-1))
			break;
	while(P - Pos > MaxVisible - 1)
		if(!Scroll(1))
			break;
}

function bool Scroll(float Delta)
{
	local float OldPos;

	OldPos = Pos;
	Pos = Pos + Delta;
	CheckRange();
	return Pos == OldPos + Delta;
}

function SetRange(float NewMinPos, float NewMaxPos, float NewMaxVisible, optional float NewScrollAmount)
{
	if(NewScrollAmount == 0)
		NewScrollAmount = 1;

	ScrollAmount = NewScrollAmount;
	MaxPos = NewMaxPos - NewMaxVisible;
	MaxVisible = NewMaxVisible;

	CheckRange();
}

function CheckRange()
{
	if(Pos < MinPos)
	{
		Pos = MinPos;
	}
	else
	{
		if(Pos > MaxPos) Pos = MaxPos;
	}

	bDisabled = (MaxPos <= MinPos);
	DownButton.bDisabled = bDisabled;
	UpButton.bDisabled = bDisabled;

	if(bDisabled)
	{
		Pos = 0;
	}
	else
	{
		ThumbStart = ((Pos - MinPos) * (WinHeight - (2*LookAndFeel.Size_ScrollbarButtonHeight))) / (MaxPos + MaxVisible - MinPos);
		ThumbHeight = (MaxVisible * (WinHeight - (2*LookAndFeel.Size_ScrollbarButtonHeight))) / (MaxPos + MaxVisible - MinPos);

		if(ThumbHeight < LookAndFeel.Size_MinScrollbarHeight)
			ThumbHeight = LookAndFeel.Size_MinScrollbarHeight;

		if(ThumbHeight + ThumbStart > WinHeight - (2*LookAndFeel.Size_ScrollbarButtonHeight))
		{
			ThumbStart = WinHeight - (2*LookAndFeel.Size_ScrollbarButtonHeight) - ThumbHeight;
		}
		ThumbStart = ThumbStart + LookAndFeel.Size_ScrollbarButtonHeight;
	}
}

function Created()
{
	Super.Created();
	UpButton = UWindowSBUpButton(CreateWindow(class'UWindowSBUpButton', 0, 0, 12, 10));
	DownButton = UWindowSBDownButton(CreateWindow(class'UWindowSBDownButton', 0, WinHeight-10, 12, 10));
}

function BeforePaint(Canvas C, float X, float Y)
{
	UpButton.WinTop = 0;
	UpButton.WinLeft = 0;
	UpButton.WinWidth = LookAndFeel.Size_ScrollbarWidth;
	UpButton.WinHeight = LookAndFeel.Size_ScrollbarButtonHeight;

	DownButton.WinTop = WinHeight - LookAndFeel.Size_ScrollbarButtonHeight;
	DownButton.WinLeft = 0;
	DownButton.WinWidth = LookAndFeel.Size_ScrollbarWidth;
	DownButton.WinHeight = LookAndFeel.Size_ScrollbarButtonHeight;

	CheckRange();
}

function Paint(Canvas C, float X, float Y)
{
	LookAndFeel.SB_VDraw(Self, C);
}

function LMouseDown(float X, float Y)
{
	Super.LMouseDown(X, Y);

	if(bDisabled) return;

	if(Y < ThumbStart)
	{
		Scroll(-(MaxVisible-1));
		NextClickTime = GetLevel().TimeSeconds + 0.5;
		return;
	}
	if(Y > ThumbStart + ThumbHeight)
	{
		Scroll(MaxVisible-1);
		NextClickTime = GetLevel().TimeSeconds + 0.5;
		return;
	}

	if((Y >= ThumbStart) && (Y <= ThumbStart + ThumbHeight))
	{
		DragY = Y - ThumbStart;
		bDragging = True;
		Root.CaptureMouse();
		return;
	}
}

function Tick(float Delta)
{
	local bool bUp, bDown;
	local float X, Y;

	if(bDragging) return;

	bUp = False;
	bDown = False;

	if(bMouseDown)
	{
		GetMouseXY(X, Y);
		bUp = (Y < ThumbStart);
		bDown = (Y > ThumbStart + ThumbHeight);
	}

	if(bMouseDown && (NextClickTime > 0) && (NextClickTime < GetLevel().TimeSeconds)  && bUp)
	{
		Scroll(-(MaxVisible-1));
		NextClickTime = GetLevel().TimeSeconds + 0.1;
	}

	if(bMouseDown && (NextClickTime > 0) && (NextClickTime < GetLevel().TimeSeconds)  && bDown)
	{
		Scroll(MaxVisible-1);
		NextClickTime = GetLevel().TimeSeconds + 0.1;
	}

	if(!bMouseDown || (!bUp && !bDown))
	{
		NextClickTime = 0;
	}
}

function MouseMove(float X, float Y)
{
	if(bDragging && bMouseDown && !bDisabled)
	{
		while(Y < (ThumbStart+DragY) && Pos > MinPos)
		{
			Scroll(-1);
		}

		while(Y > (ThumbStart+DragY) && Pos < MaxPos)
		{
			Scroll(1);
		}
	}
	else
		bDragging = False;
}
//=============================================================================
// UWindowVSplitter - a vertical splitter component
//=============================================================================
class UWindowVSplitter extends UWindowWindow;



var UWindowWindow			TopClientWindow;
var UWindowWindow			BottomClientWindow;
var bool					bSizing;
var float					SplitPos;
var float					MinWinHeight;
var float					MaxSplitPos;
var float					OldWinHeight;
var bool					bBottomGrow;
var bool					bSizable;

function Created()
{
	Super.Created();
	bAlwaysBehind = True;
	SplitPos = WinHeight / 2;
	MinWinHeight = 24;

	OldWinHeight = WinHeight;
}

function Paint(Canvas C, float X, float Y)
{
	local Texture T;

	T = GetLookAndFeelTexture();
	DrawUpBevel(C, 0, SplitPos, WinWidth, 7, T);
}

function BeforePaint(Canvas C, float X, float Y)
{
	local float NewW, NewH;

	// Make Top panel resize
	if(OldWinHeight != WinHeight && !bBottomGrow)
	{
		SplitPos = SplitPos + WinHeight - OldWinHeight;
	}

	SplitPos = FClamp(SplitPos, MinWinHeight, WinHeight - 7 - MinWinHeight);
	if(MaxSplitPos != 0)
		SplitPos = FClamp(SplitPos, 0, MaxSplitPos);

	NewW = WinWidth;
	NewH = SplitPos;

	if(NewW != TopClientWindow.WinWidth || NewH != TopClientWindow.WinHeight)
	{
		TopClientWindow.SetSize(NewW, NewH);
	}

	NewH = WinHeight - SplitPos - 7;

	if(NewW != BottomClientWindow.WinWidth || NewH != BottomClientWindow.WinHeight)
	{
		BottomClientWindow.SetSize(NewW, NewH);
	}
	BottomClientWindow.WinTop = SplitPos + 7;
	BottomClientWindow.WinLeft = 0;

	OldWinHeight = WinHeight;
}

function LMouseDown(float X, float Y)
{
	Super.LMouseDown(X, Y);

	if(bSizable && (Y >= SplitPos) && (Y <= SplitPos + 7))
	{
		bSizing = True;
		Root.CaptureMouse();
	}
}

function MouseMove(float X, float Y)
{

	if(bSizable && (Y >= SplitPos) && (Y <= SplitPos + 7))
		Cursor = Root.VSplitCursor;
	else
		Cursor = Root.NormalCursor;

	if(bSizing && bMouseDown)
	{
		SplitPos = Y;
	} else bSizing = False;
}

defaultproperties
{
	bSizable=True
	MaxSplitPos=0
}
class UWindowWin95LookAndFeel extends UWindowLookAndFeel;



#exec TEXTURE IMPORT FILE=Textures\ActiveFrame.tga GROUP="Icons"            MIPS=OFF COMPRESS=DXT1
#exec TEXTURE IMPORT FILE=Textures\InactiveFrame.tga GROUP="Icons"          MIPS=OFF COMPRESS=DXT1
#exec TEXTURE IMPORT FILE=Textures\ActiveFrameS.tga GROUP="Icons"           MIPS=OFF COMPRESS=DXT1
#exec TEXTURE IMPORT FILE=Textures\InactiveFrameS.tga GROUP="Icons"         MIPS=OFF COMPRESS=DXT1

#exec TEXTURE IMPORT FILE=Textures\Misc.tga GROUP="Icons"                   MIPS=OFF COMPRESS=DXT1

#exec TEXTURE IMPORT FILE=Textures\ChkChecked.tga GROUP="Icons"             MIPS=OFF MASKED=1 COMPRESS=DXT1A
#exec TEXTURE IMPORT FILE=Textures\ChkUnchecked.tga GROUP="Icons"           MIPS=OFF MASKED=1 COMPRESS=DXT1A
#exec TEXTURE IMPORT FILE=Textures\ChkCheckedDisabled.tga GROUP="Icons"     MIPS=OFF MASKED=1 COMPRESS=DXT1A
#exec TEXTURE IMPORT FILE=Textures\ChkUncheckedDisabled.tga GROUP="Icons"   MIPS=OFF MASKED=1 COMPRESS=DXT1A

#exec TEXTURE IMPORT FILE=Textures\MenuBar.tga GROUP="Icons"                MIPS=OFF COMPRESS=DXT1
#exec TEXTURE IMPORT FILE=Textures\MenuHighlightL.tga GROUP="Icons"         MIPS=OFF MASKED=1 COMPRESS=DXT1A
#exec TEXTURE IMPORT FILE=Textures\MenuHighlightM.tga GROUP="Icons"         MIPS=OFF MASKED=1 COMPRESS=DXT1A
#exec TEXTURE IMPORT FILE=Textures\MenuHighlightR.tga GROUP="Icons"         MIPS=OFF MASKED=1 COMPRESS=DXT1A

#exec TEXTURE IMPORT FILE=Textures\MenuArea.tga GROUP="Icons"               MIPS=OFF COMPRESS=DXT1
#exec TEXTURE IMPORT FILE=Textures\MenuTL.tga GROUP="Icons"                 MIPS=OFF COMPRESS=DXT1
#exec TEXTURE IMPORT FILE=Textures\MenuT.tga GROUP="Icons"                  MIPS=OFF COMPRESS=DXT1
#exec TEXTURE IMPORT FILE=Textures\MenuTR.tga GROUP="Icons"                 MIPS=OFF COMPRESS=DXT1
#exec TEXTURE IMPORT FILE=Textures\MenuL.tga GROUP="Icons"                  MIPS=OFF COMPRESS=DXT1
#exec TEXTURE IMPORT FILE=Textures\MenuR.tga GROUP="Icons"                  MIPS=OFF COMPRESS=DXT1
#exec TEXTURE IMPORT FILE=Textures\MenuBL.tga GROUP="Icons"                 MIPS=OFF COMPRESS=DXT1
#exec TEXTURE IMPORT FILE=Textures\MenuB.tga GROUP="Icons"                  MIPS=OFF COMPRESS=DXT1
#exec TEXTURE IMPORT FILE=Textures\MenuBR.tga GROUP="Icons"                 MIPS=OFF COMPRESS=DXT1
#exec TEXTURE IMPORT FILE=Textures\MenuHighlight.tga GROUP="Icons"          MIPS=OFF COMPRESS=DXT1

var() Region	SBUpUp;
var() Region	SBUpDown;
var() Region	SBUpDisabled;

var() Region	SBDownUp;
var() Region	SBDownDown;
var() Region	SBDownDisabled;

var() Region	SBLeftUp;
var() Region	SBLeftDown;
var() Region	SBLeftDisabled;

var() Region	SBRightUp;
var() Region	SBRightDown;
var() Region	SBRightDisabled;

var() Region	SBBackground;

var() Region	FrameSBL;
var() Region	FrameSB;
var() Region	FrameSBR;

var() Region	CloseBoxUp;
var() Region	CloseBoxDown;
var() int		CloseBoxOffsetX;
var() int		CloseBoxOffsetY;


const SIZEBORDER = 3;
const BRSIZEBORDER = 15;

/* Framed Window Drawing Functions */
function FW_DrawWindowFrame(UWindowFramedWindow W, Canvas C)
{
	local Texture T;
	local Region R, Temp;

	C.DrawColor.r = 255;
	C.DrawColor.g = 255;
	C.DrawColor.b = 255;

	T = W.GetLookAndFeelTexture();

	R = FrameTL;
	W.DrawStretchedTextureSegment( C, 0, 0, R.W, R.H, R.X, R.Y, R.W, R.H, T );

	R = FrameT;
	W.DrawStretchedTextureSegment( C, FrameTL.W, 0,
									W.WinWidth - FrameTL.W
									- FrameTR.W,
									R.H, R.X, R.Y, R.W, R.H, T );

	R = FrameTR;
	W.DrawStretchedTextureSegment( C, W.WinWidth - R.W, 0, R.W, R.H, R.X, R.Y, R.W, R.H, T );


	if(W.bStatusBar)
		Temp = FrameSBL;
	else
		Temp = FrameBL;

	R = FrameL;
	W.DrawStretchedTextureSegment( C, 0, FrameTL.H,
									R.W,
									W.WinHeight - FrameTL.H
									- Temp.H,
									R.X, R.Y, R.W, R.H, T );

	R = FrameR;
	W.DrawStretchedTextureSegment( C, W.WinWidth - R.W, FrameTL.H,
									R.W,
									W.WinHeight - FrameTL.H
									- Temp.H,
									R.X, R.Y, R.W, R.H, T );

	if(W.bStatusBar)
		R = FrameSBL;
	else
		R = FrameBL;
	W.DrawStretchedTextureSegment( C, 0, W.WinHeight - R.H, R.W, R.H, R.X, R.Y, R.W, R.H, T );

	if(W.bStatusBar)
	{
		R = FrameSB;
		W.DrawStretchedTextureSegment( C, FrameBL.W, W.WinHeight - R.H,
										W.WinWidth - FrameSBL.W
										- FrameSBR.W,
										R.H, R.X, R.Y, R.W, R.H, T );
	}
	else
	{
		R = FrameB;
		W.DrawStretchedTextureSegment( C, FrameBL.W, W.WinHeight - R.H,
										W.WinWidth - FrameBL.W
										- FrameBR.W,
										R.H, R.X, R.Y, R.W, R.H, T );
	}

	if(W.bStatusBar)
		R = FrameSBR;
	else
		R = FrameBR;
	W.DrawStretchedTextureSegment( C, W.WinWidth - R.W, W.WinHeight - R.H, R.W, R.H, R.X, R.Y,
									R.W, R.H, T );


	C.Font = W.Root.Fonts[W.F_Normal];
	if(W.ParentWindow.ActiveWindow == W)
		C.DrawColor = FrameActiveTitleColor;
	else
		C.DrawColor = FrameInactiveTitleColor;


	W.ClipTextWidth(C, FrameTitleX, FrameTitleY,
					W.WindowTitle, W.WinWidth - 22);

	if(W.bStatusBar)
	{
		C.DrawColor.r = 0;
		C.DrawColor.g = 0;
		C.DrawColor.b = 0;

		W.ClipTextWidth(C, 6, W.WinHeight - 13, W.StatusBarText, W.WinWidth - 22);

		C.DrawColor.r = 255;
		C.DrawColor.g = 255;
		C.DrawColor.b = 255;
	}
}

function FW_SetupFrameButtons(UWindowFramedWindow W, Canvas C)
{
	local Texture T;

	T = W.GetLookAndFeelTexture();

	W.CloseBox.WinLeft = W.WinWidth - CloseBoxOffsetX - CloseBoxUp.W;
	W.CloseBox.WinTop = CloseBoxOffsetY;

	W.CloseBox.SetSize(CloseBoxUp.W, CloseBoxUp.H);
	W.CloseBox.bUseRegion = True;

	W.CloseBox.UpTexture = T;
	W.CloseBox.DownTexture = T;
	W.CloseBox.OverTexture = T;
	W.CloseBox.DisabledTexture = T;

	W.CloseBox.UpRegion = CloseBoxUp;
	W.CloseBox.DownRegion = CloseBoxDown;
	W.CloseBox.OverRegion = CloseBoxUp;
	W.CloseBox.DisabledRegion = CloseBoxUp;
}

function Region FW_GetClientArea(UWindowFramedWindow W)
{
	local Region R;

	R.X = FrameL.W;
	R.Y	= FrameT.H;
	R.W = W.WinWidth - (FrameL.W + FrameR.W);
	if(W.bStatusBar)
		R.H = W.WinHeight - (FrameT.H + FrameSB.H);
	else
		R.H = W.WinHeight - (FrameT.H + FrameB.H);

	return R;
}


function FrameHitTest FW_HitTest(UWindowFramedWindow W, float X, float Y)
{
	if((X >= 3) && (X <= W.WinWidth-3) && (Y >= 3) && (Y <= 14))
		return HT_TitleBar;
	if((X < BRSIZEBORDER && Y < SIZEBORDER) || (X < SIZEBORDER && Y < BRSIZEBORDER))
		return HT_NW;
	if((X > W.WinWidth - SIZEBORDER && Y < BRSIZEBORDER) || (X > W.WinWidth - BRSIZEBORDER && Y < SIZEBORDER))
		return HT_NE;
	if((X < BRSIZEBORDER && Y > W.WinHeight - SIZEBORDER)|| (X < SIZEBORDER && Y > W.WinHeight - BRSIZEBORDER))
		return HT_SW;
	if((X > W.WinWidth - BRSIZEBORDER) && (Y > W.WinHeight - BRSIZEBORDER))
		return HT_SE;
	if(Y < SIZEBORDER)
		return HT_N;
	if(Y > W.WinHeight - SIZEBORDER)
		return HT_S;
	if(X < SIZEBORDER)
		return HT_W;
	if(X > W.WinWidth - SIZEBORDER)
		return HT_E;

	return HT_None;
}

/* Client Area Drawing Functions */
function DrawClientArea(UWindowClientWindow W, Canvas C)
{
	W.DrawStretchedTexture(C, 0, 0, W.WinWidth, W.WinHeight, Texture'BlackTexture');
}


/* Combo Drawing Functions */
function Combo_SetupSizes(UWindowComboControl W, Canvas C)
{
	local float TW, TH;

	C.Font = W.Root.Fonts[W.Font];
	W.TextSize(C, W.Text, TW, TH);

	W.WinHeight = 12 + MiscBevelT[2].H + MiscBevelB[2].H;

	switch(W.Align)
	{
	case TA_Left:
		W.EditAreaDrawX = W.WinWidth - W.EditBoxWidth;
		W.TextX = 0;
		break;
	case TA_Right:
		W.EditAreaDrawX = 0;
		W.TextX = W.WinWidth - TW;
		break;
	case TA_Center:
		W.EditAreaDrawX = (W.WinWidth - W.EditBoxWidth) / 2;
		W.TextX = (W.WinWidth - TW) / 2;
		break;
	}

	W.EditAreaDrawY = (W.WinHeight - 2) / 2;
	W.TextY = (W.WinHeight - TH) / 2;

	W.EditBox.WinLeft = W.EditAreaDrawX + MiscBevelL[2].W;
	W.EditBox.WinTop = MiscBevelT[2].H;
	W.Button.WinWidth = ComboBtnUp.W;

	if(W.bButtons)
	{
		W.EditBox.WinWidth = W.EditBoxWidth - MiscBevelL[2].W - MiscBevelR[2].W - ComboBtnUp.W - SBLeftUp.W - SBRightUp.W;
		W.EditBox.WinHeight = W.WinHeight - MiscBevelT[2].H - MiscBevelB[2].H;
		W.Button.WinLeft = W.WinWidth - ComboBtnUp.W - MiscBevelR[2].W - SBLeftUp.W - SBRightUp.W;
		W.Button.WinTop = W.EditBox.WinTop;

		W.LeftButton.WinLeft = W.WinWidth - MiscBevelR[2].W - SBLeftUp.W - SBRightUp.W;
		W.LeftButton.WinTop = W.EditBox.WinTop;
		W.RightButton.WinLeft = W.WinWidth - MiscBevelR[2].W - SBRightUp.W;
		W.RightButton.WinTop = W.EditBox.WinTop;

		W.LeftButton.WinWidth = SBLeftUp.W;
		W.LeftButton.WinHeight = SBLeftUp.H;
		W.RightButton.WinWidth = SBRightUp.W;
		W.RightButton.WinHeight = SBRightUp.H;
	}
	else
	{
		W.EditBox.WinWidth = W.EditBoxWidth - MiscBevelL[2].W - MiscBevelR[2].W - ComboBtnUp.W;
		W.EditBox.WinHeight = W.WinHeight - MiscBevelT[2].H - MiscBevelB[2].H;
		W.Button.WinLeft = W.WinWidth - ComboBtnUp.W - MiscBevelR[2].W;
		W.Button.WinTop = W.EditBox.WinTop;
	}
	W.Button.WinHeight = W.EditBox.WinHeight;
}

function Combo_Draw(UWindowComboControl W, Canvas C)
{
	W.DrawMiscBevel(C, W.EditAreaDrawX, 0, W.EditBoxWidth, W.WinHeight, Misc, 2);

	if(W.Text != "")
	{
		C.DrawColor = W.TextColor;
		W.ClipText(C, W.TextX, W.TextY, W.Text);
		C.DrawColor.R = 255;
		C.DrawColor.G = 255;
		C.DrawColor.B = 255;
	}
}

function ComboList_DrawBackground(UWindowComboList W, Canvas C)
{
	W.DrawClippedTexture(C, 0, 0, Texture'UWindow.MenuTL');
	W.DrawStretchedTexture(C, 4, 0, W.WinWidth-8, 4, Texture'UWindow.MenuT');
	W.DrawClippedTexture(C, W.WinWidth-4, 0, Texture'UWindow.MenuTR');

	W.DrawClippedTexture(C, 0, W.WinHeight-4, Texture'UWindow.MenuBL');
	W.DrawStretchedTexture(C, 4, W.WinHeight-4, W.WinWidth-8, 4, Texture'UWindow.MenuB');
	W.DrawClippedTexture(C, W.WinWidth-4, W.WinHeight-4, Texture'UWindow.MenuBR');

	W.DrawStretchedTexture(C, 0, 4, 4, W.WinHeight-8, Texture'UWindow.MenuL');
	W.DrawStretchedTexture(C, W.WinWidth-4, 4, 4, W.WinHeight-8, Texture'UWindow.MenuR');

	W.DrawStretchedTexture(C, 4, 4, W.WinWidth-8, W.WinHeight-8, Texture'UWindow.MenuArea');
}

function ComboList_DrawItem(UWindowComboList Combo, Canvas C, float X, float Y, float W, float H, string Text, bool bSelected)
{
	C.DrawColor.R = 255;
	C.DrawColor.G = 255;
	C.DrawColor.B = 255;

	if(bSelected)
	{
		Combo.DrawStretchedTexture(C, X, Y, W, H, Texture'UWindow.MenuHighlight');
		C.DrawColor.R = 0;
		C.DrawColor.G = 0;
		C.DrawColor.B = 0;
	}
	else
	{
		C.DrawColor.R = 0;
		C.DrawColor.G = 0;
		C.DrawColor.B = 0;
	}

	Combo.ClipText(C, X + Combo.TextBorder + 2, Y + 3, Text);
}

function Checkbox_SetupSizes(UWindowCheckbox W, Canvas C)
{
	local float TW, TH;

	W.TextSize(C, W.Text, TW, TH);
	W.WinHeight = Max(TH+1, 16);

	switch(W.Align)
	{
	case TA_Left:
		W.ImageX = W.WinWidth - 16;
		W.TextX = 0;
		break;
	case TA_Right:
		W.ImageX = 0;
		W.TextX = W.WinWidth - TW;
		break;
	case TA_Center:
		W.ImageX = (W.WinWidth - 16) / 2;
		W.TextX = (W.WinWidth - TW) / 2;
		break;
	}

	W.ImageY = (W.WinHeight - 16) / 2;
	W.TextY = (W.WinHeight - TH) / 2;

	if(W.bChecked)
	{
		W.UpTexture = Texture'ChkChecked';
		W.DownTexture = Texture'ChkChecked';
		W.OverTexture = Texture'ChkChecked';
		W.DisabledTexture = Texture'ChkCheckedDisabled';
	}
	else
	{
		W.UpTexture = Texture'ChkUnchecked';
		W.DownTexture = Texture'ChkUnchecked';
		W.OverTexture = Texture'ChkUnchecked';
		W.DisabledTexture = Texture'ChkUncheckedDisabled';
	}
}

function Combo_GetButtonBitmaps(UWindowComboButton W)
{
	local Texture T;

	T = W.GetLookAndFeelTexture();

	W.bUseRegion = True;

	W.UpTexture = T;
	W.DownTexture = T;
	W.OverTexture = T;
	W.DisabledTexture = T;

	W.UpRegion = ComboBtnUp;
	W.DownRegion = ComboBtnDown;
	W.OverRegion = ComboBtnUp;
	W.DisabledRegion = ComboBtnDisabled;
}

function Editbox_SetupSizes(UWindowEditControl W, Canvas C)
{
	local float TW, TH;
	local int B;

	B = EditBoxBevel;

	C.Font = W.Root.Fonts[W.Font];
	W.TextSize(C, W.Text, TW, TH);

	W.WinHeight = 12 + MiscBevelT[B].H + MiscBevelB[B].H;

	switch(W.Align)
	{
	case TA_Left:
		W.EditAreaDrawX = W.WinWidth - W.EditBoxWidth;
		W.TextX = 0;
		break;
	case TA_Right:
		W.EditAreaDrawX = 0;
		W.TextX = W.WinWidth - TW;
		break;
	case TA_Center:
		W.EditAreaDrawX = (W.WinWidth - W.EditBoxWidth) / 2;
		W.TextX = (W.WinWidth - TW) / 2;
		break;
	}

	W.EditAreaDrawY = (W.WinHeight - 2) / 2;
	W.TextY = (W.WinHeight - TH) / 2;

	W.EditBox.WinLeft = W.EditAreaDrawX + MiscBevelL[B].W;
	W.EditBox.WinTop = MiscBevelT[B].H;
	W.EditBox.WinWidth = W.EditBoxWidth - MiscBevelL[B].W - MiscBevelR[B].W;
	W.EditBox.WinHeight = W.WinHeight - MiscBevelT[B].H - MiscBevelB[B].H;
}

function Editbox_Draw(UWindowEditControl W, Canvas C)
{
	W.DrawMiscBevel(C, W.EditAreaDrawX, 0, W.EditBoxWidth, W.WinHeight, Misc, EditBoxBevel);

	if(W.Text != "")
	{
		C.DrawColor = W.TextColor;
		W.ClipText(C, W.TextX, W.TextY, W.Text);
		C.DrawColor.R = 255;
		C.DrawColor.G = 255;
		C.DrawColor.B = 255;
	}
}

function Tab_DrawTab(UWindowTabControlTabArea Tab, Canvas C, bool bActiveTab, bool bLeftmostTab, float X, float Y, float W, float H, string Text, bool bShowText)
{
	local Region R;
	local Texture T;
	local float TW, TH;

	C.DrawColor.R = 255;
	C.DrawColor.G = 255;
	C.DrawColor.B = 255;

	T = Tab.GetLookAndFeelTexture();

	if(bActiveTab)
	{
		R = TabSelectedL;
		Tab.DrawStretchedTextureSegment( C, X, Y, R.W, R.H, R.X, R.Y, R.W, R.H, T );

		R = TabSelectedM;
		Tab.DrawStretchedTextureSegment( C, X+TabSelectedL.W, Y,
										W - TabSelectedL.W
										- TabSelectedR.W,
										R.H, R.X, R.Y, R.W, R.H, T );

		R = TabSelectedR;
		Tab.DrawStretchedTextureSegment( C, X + W - R.W, Y, R.W, R.H, R.X, R.Y, R.W, R.H, T );

		C.Font = Tab.Root.Fonts[Tab.F_Bold];
		C.DrawColor.R = 0;
		C.DrawColor.G = 0;
		C.DrawColor.B = 0;

		if(bShowText)
		{
			Tab.TextSize(C, Text, TW, TH);
			Tab.ClipText(C, X + (W-TW)/2, Y + 3, Text, True);
		}
	}
	else
	{
		R = TabUnselectedL;
		Tab.DrawStretchedTextureSegment( C, X, Y, R.W, R.H, R.X, R.Y, R.W, R.H, T );

		R = TabUnselectedM;
		Tab.DrawStretchedTextureSegment( C, X+TabUnselectedL.W, Y,
										W - TabUnselectedL.W
										- TabUnselectedR.W,
										R.H, R.X, R.Y, R.W, R.H, T );

		R = TabUnselectedR;
		Tab.DrawStretchedTextureSegment( C, X + W - R.W, Y, R.W, R.H, R.X, R.Y, R.W, R.H, T );

		C.Font = Tab.Root.Fonts[Tab.F_Normal];
		C.DrawColor.R = 0;
		C.DrawColor.G = 0;
		C.DrawColor.B = 0;

		if(bShowText)
		{
			Tab.TextSize(C, Text, TW, TH);
			Tab.ClipText(C, X + (W-TW)/2, Y + 4, Text, True);
		}
	}
}

function SB_SetupUpButton(UWindowSBUpButton W)
{
	local Texture T;

	T = W.GetLookAndFeelTexture();

	W.bUseRegion = True;

	W.UpTexture = T;
	W.DownTexture = T;
	W.OverTexture = T;
	W.DisabledTexture = T;

	W.UpRegion = SBUpUp;
	W.DownRegion = SBUpDown;
	W.OverRegion = SBUpUp;
	W.DisabledRegion = SBUpDisabled;
}

function SB_SetupDownButton(UWindowSBDownButton W)
{
	local Texture T;

	T = W.GetLookAndFeelTexture();

	W.bUseRegion = True;

	W.UpTexture = T;
	W.DownTexture = T;
	W.OverTexture = T;
	W.DisabledTexture = T;

	W.UpRegion = SBDownUp;
	W.DownRegion = SBDownDown;
	W.OverRegion = SBDownUp;
	W.DisabledRegion = SBDownDisabled;
}



function SB_SetupLeftButton(UWindowSBLeftButton W)
{
	local Texture T;

	T = W.GetLookAndFeelTexture();

	W.bUseRegion = True;

	W.UpTexture = T;
	W.DownTexture = T;
	W.OverTexture = T;
	W.DisabledTexture = T;

	W.UpRegion = SBLeftUp;
	W.DownRegion = SBLeftDown;
	W.OverRegion = SBLeftUp;
	W.DisabledRegion = SBLeftDisabled;
}

function SB_SetupRightButton(UWindowSBRightButton W)
{
	local Texture T;

	T = W.GetLookAndFeelTexture();

	W.bUseRegion = True;

	W.UpTexture = T;
	W.DownTexture = T;
	W.OverTexture = T;
	W.DisabledTexture = T;

	W.UpRegion = SBRightUp;
	W.DownRegion = SBRightDown;
	W.OverRegion = SBRightUp;
	W.DisabledRegion = SBRightDisabled;
}

function SB_VDraw(UWindowVScrollbar W, Canvas C)
{
	local Region R;
	local Texture T;

	T = W.GetLookAndFeelTexture();

	R = SBBackground;
	W.DrawStretchedTextureSegment( C, 0, 0, W.WinWidth, W.WinHeight, R.X, R.Y, R.W, R.H, T);

	if(!W.bDisabled)
	{
		W.DrawUpBevel( C, 0, W.ThumbStart, Size_ScrollbarWidth,	W.ThumbHeight, T);
	}
}

function SB_HDraw(UWindowHScrollbar W, Canvas C)
{
	local Region R;
	local Texture T;

	T = W.GetLookAndFeelTexture();

	R = SBBackground;
	W.DrawStretchedTextureSegment( C, 0, 0, W.WinWidth, W.WinHeight, R.X, R.Y, R.W, R.H, T);

	if(!W.bDisabled)
	{
		W.DrawUpBevel( C, W.ThumbStart, 0, W.ThumbWidth, Size_ScrollbarWidth, T);
	}
}

function Tab_SetupLeftButton(UWindowTabControlLeftButton W)
{
	local Texture T;

	T = W.GetLookAndFeelTexture();


	W.WinWidth = Size_ScrollbarButtonHeight;
	W.WinHeight = Size_ScrollbarWidth;
	W.WinTop = Size_TabAreaHeight - W.WinHeight;
	W.WinLeft = W.ParentWindow.WinWidth - 2*W.WinWidth;

	W.bUseRegion = True;

	W.UpTexture = T;
	W.DownTexture = T;
	W.OverTexture = T;
	W.DisabledTexture = T;

	W.UpRegion = SBLeftUp;
	W.DownRegion = SBLeftDown;
	W.OverRegion = SBLeftUp;
	W.DisabledRegion = SBLeftDisabled;
}

function Tab_SetupRightButton(UWindowTabControlRightButton W)
{
	local Texture T;

	T = W.GetLookAndFeelTexture();

	W.WinWidth = Size_ScrollbarButtonHeight;
	W.WinHeight = Size_ScrollbarWidth;
	W.WinTop = Size_TabAreaHeight - W.WinHeight;
	W.WinLeft = W.ParentWindow.WinWidth - W.WinWidth;

	W.bUseRegion = True;

	W.UpTexture = T;
	W.DownTexture = T;
	W.OverTexture = T;
	W.DisabledTexture = T;

	W.UpRegion = SBRightUp;
	W.DownRegion = SBRightDown;
	W.OverRegion = SBRightUp;
	W.DisabledRegion = SBRightDisabled;
}

function Tab_SetTabPageSize(UWindowPageControl W, UWindowPageWindow P)
{
	P.WinLeft = 2;
	P.WinTop = W.TabArea.WinHeight-(TabSelectedM.H-TabUnselectedM.H) + 3;
	P.SetSize(W.WinWidth - 4, W.WinHeight-(W.TabArea.WinHeight-(TabSelectedM.H-TabUnselectedM.H)) - 6);
}

function Tab_DrawTabPageArea(UWindowPageControl W, Canvas C, UWindowPageWindow P)
{
	W.DrawUpBevel( C, 0, Size_TabAreaHeight, W.WinWidth, W.WinHeight-Size_TabAreaHeight, W.GetLookAndFeelTexture());
}

function Tab_GetTabSize(UWindowTabControlTabArea Tab, Canvas C, string Text, out float W, out float H)
{
	local float TW, TH;

	C.Font = Tab.Root.Fonts[Tab.F_Normal];

	Tab.TextSize( C, Text, TW, TH );
	W = TW + Size_TabSpacing;
	H = TH;
}

function Menu_DrawMenuBar(UWindowMenuBar W, Canvas C)
{
	W.DrawStretchedTexture( C, 16, 0, W.WinWidth - 32, 16, Texture'UWindow.MenuBar');
}

function Menu_DrawMenuBarItem(UWindowMenuBar B, UWindowMenuBarItem I, float X, float Y, float W, float H, Canvas C)
{
	if(B.Selected == I)
	{
		B.DrawClippedTexture(C, X, 1, Texture'MenuHighlightL');
		B.DrawClippedTexture(C, X+W-1, 1, Texture'MenuHighlightR');
		B.DrawStretchedTexture(C, X+1, 1, W-2, 16, Texture'MenuHighlightM');
	}

	C.Font = B.Root.Fonts[F_Normal];
	C.DrawColor.R = 0;
	C.DrawColor.G = 0;
	C.DrawColor.B = 0;

	B.ClipText(C, X + B.Spacing / 2, 2, I.Caption, True);
}

function Menu_DrawPulldownMenuBackground(UWindowPulldownMenu W, Canvas C)
{
	W.DrawClippedTexture(C, 0, 0, Texture'UWindow.MenuTL');
	W.DrawStretchedTexture(C, 2, 0, W.WinWidth-4, 2, Texture'UWindow.MenuT');
	W.DrawClippedTexture(C, W.WinWidth-2, 0, Texture'UWindow.MenuTR');

	W.DrawClippedTexture(C, 0, W.WinHeight-2, Texture'UWindow.MenuBL');
	W.DrawStretchedTexture(C, 2, W.WinHeight-2, W.WinWidth-4, 2, Texture'UWindow.MenuB');
	W.DrawClippedTexture(C, W.WinWidth-2, W.WinHeight-2, Texture'UWindow.MenuBR');

	W.DrawStretchedTexture(C, 0, 2, 2, W.WinHeight-4, Texture'UWindow.MenuL');
	W.DrawStretchedTexture(C, W.WinWidth-2, 2, 2, W.WinHeight-4, Texture'UWindow.MenuR');
	W.DrawStretchedTexture(C, 2, 2, W.WinWidth-4, W.WinHeight-4, Texture'UWindow.MenuArea');
}

function Menu_DrawPulldownMenuItem(UWindowPulldownMenu M, UWindowPulldownMenuItem Item, Canvas C, float X, float Y, float W, float H, bool bSelected)
{
	C.DrawColor.R = 255;
	C.DrawColor.G = 255;
	C.DrawColor.B = 255;

	Item.ItemTop = Y + M.WinTop;

	if(Item.Caption == "-")
	{
		C.DrawColor.R = 255;
		C.DrawColor.G = 255;
		C.DrawColor.B = 255;
		M.DrawStretchedTexture(C, X, Y+5, W, 2, Texture'UWindow.MenuDivider');
		return;
	}

	C.Font = M.Root.Fonts[F_Normal];

	if(bSelected)
		M.DrawStretchedTexture(C, X, Y, W, H, Texture'UWindow.MenuHighlight');

	if(Item.bDisabled)
	{
		// Black Shadow
		C.DrawColor.R = 96;
		C.DrawColor.G = 96;
		C.DrawColor.B = 96;
	}
	else
	{
		C.DrawColor.R = 0;
		C.DrawColor.G = 0;
		C.DrawColor.B = 0;
	}

	// DrawColor will render the tick black white or gray.
	if(Item.bChecked)
		M.DrawClippedTexture(C, X + 1, Y + 3, Texture'MenuTick');

	if(Item.SubMenu != None)
		M.DrawClippedTexture(C, X + W - 9, Y + 3, Texture'MenuSubArrow');

	M.ClipText(C, X + M.TextBorder + 2, Y + 3, Item.Caption, True);
}

defaultproperties
{
	Active=Texture'UWindow.ActiveFrame'
	Inactive=Texture'UWindow.InactiveFrame'
	ActiveS=Texture'UWindow.ActiveFrameS'
	InactiveS=Texture'UWindow.InactiveFrameS'
	Misc=Texture'UWindow.Misc';


	FrameTL=(X=0,Y=0,W=2,H=16)
	FrameT=(X=32,Y=0,W=1,H=16)
	FrameTR=(X=126,Y=0,W=2,H=16)
	FrameL=(X=0,Y=32,W=2,H=1)
	FrameR=(X=126,Y=32,W=2,H=1)
	FrameBL=(X=0,Y=125,W=2,H=3)
	FrameB=(X=32,Y=125,W=1,H=3)
	FrameBR=(X=126,Y=125,W=2,H=3)

	FrameSBL=(X=0,Y=112,W=2,H=16)
	FrameSB=(X=32,Y=112,W=1,H=16)
	FrameSBR=(X=112,Y=112,W=16,H=16)


	FrameActiveTitleColor=(R=255,G=255,B=255,A=255)
	FrameInactiveTitleColor=(R=255,G=255,B=255,A=255)

	HeadingActiveTitleColor=(R=0,G=0,B=0,A=0)
	HeadingInActiveTitleColor=(R=0,G=0,B=0,A=0)

	FrameTitleX=6
	FrameTitleY=4

	CloseBoxOffsetX=3;
	CloseBoxOffsetY=5;
	CloseBoxUp=(X=4,Y=32,W=11,H=11)
	CloseBoxDown=(X=4,Y=43,W=11,H=11)

	MiscBevelTL(0)=(X=0,Y=17,W=3,H=3)
	MiscBevelT(0)=(X=3,Y=17,W=116,H=3)
	MiscBevelTR(0)=(X=119,Y=17,W=3,H=3)
	MiscBevelL(0)=(X=0,Y=20,W=3,H=10)
	MiscBevelR(0)=(X=119,Y=20,W=3,H=10)
	MiscBevelBL(0)=(X=0,Y=30,W=3,H=3)
	MiscBevelB(0)=(X=3,Y=30,W=116,H=3)
	MiscBevelBR(0)=(X=119,Y=30,W=3,H=3)
	MiscBevelArea(0)=(X=3,Y=20,W=116,H=10)


	MiscBevelTL(1)=(X=0,Y=0,W=3,H=3)
	MiscBevelT(1)=(X=3,Y=0,W=116,H=3)
	MiscBevelTR(1)=(X=119,Y=0,W=3,H=3)
	MiscBevelL(1)=(X=0,Y=3,W=3,H=10)
	MiscBevelR(1)=(X=119,Y=3,W=3,H=10)
	MiscBevelBL(1)=(X=0,Y=14,W=3,H=3)
	MiscBevelB(1)=(X=3,Y=14,W=116,H=3)
	MiscBevelBR(1)=(X=119,Y=14,W=3,H=3)
	MiscBevelArea(1)=(X=3,Y=3,W=116,H=10)


	MiscBevelTL(2)=(X=0,Y=33,W=2,H=2)
	MiscBevelT(2)=(X=2,Y=33,W=1,H=2)
	MiscBevelTR(2)=(X=11,Y=33,W=2,H=2)
	MiscBevelL(2)=(X=0,Y=36,W=2,H=1)
	MiscBevelR(2)=(X=11,Y=36,W=2,H=1)
	MiscBevelBL(2)=(X=0,Y=44,W=2,H=2)
	MiscBevelB(2)=(X=2,Y=44,W=1,H=2)
	MiscBevelBR(2)=(X=11,Y=44,W=2,H=2)
	MiscBevelArea(2)=(X=2,Y=35,W=9,H=9)

	ComboBtnUp=(X=20,Y=60,W=12,H=12)
	ComboBtnDown=(X=32,Y=60,W=12,H=12)
	ComboBtnDisabled=(X=44,Y=60,W=12,H=12)

	EditBoxBevel=2
	EditBoxTextColor=(R=0,G=0,B=0,A=0)

	TabSelectedL=(X=4,Y=80,W=3,H=17)
	TabSelectedM=(X=7,Y=80,W=1,H=17)
	TabSelectedR=(X=55,Y=80,W=2,H=17)

	TabBackground=(X=4,Y=79,W=1,H=1)

	SBUpUp=(X=20,Y=16,W=12,H=10)
	SBUpDown=(X=32,Y=16,W=12,H=10)
	SBUpDisabled=(X=44,Y=16,W=12,H=10)

	SBDownUp=(X=20,Y=26,W=12,H=10)
	SBDownDown=(X=32,Y=26,W=12,H=10)
	SBDownDisabled=(X=44,Y=26,W=12,H=10)

	SBLeftUp=(X=20,Y=48,W=10,H=12)
	SBLeftDown=(X=30,Y=48,W=10,H=12)
	SBLeftDisabled=(X=40,Y=48,W=10,H=12)

	SBRightUp=(X=20,Y=36,W=10,H=12)
	SBRightDown=(X=30,Y=36,W=10,H=12)
	SBRightDisabled=(X=40,Y=36,W=10,H=12)

	SBBackground=(X=4,Y=79,W=1,H=1)

	BevelUpTL=(X=4,Y=16,W=2,H=2)
	BevelUpT=(X=10,Y=16,W=1,H=2)
	BevelUpTR=(X=18,Y=16,W=2,H=2)

	BevelUpL=(X=4,Y=20,W=2,H=1)
	BevelUpR=(X=18,Y=20,W=2,H=1)

	BevelUpBL=(X=4,Y=30,W=2,H=2)
	BevelUpB=(X=10,Y=30,W=1,H=2)
	BevelUpBR=(X=18,Y=30,W=2,H=2)

	BevelUpArea=(X=8,Y=20,W=1,H=1)

	HLine=(X=5,Y=78,W=1,H=2)

	TabUnselectedL=(X=57,Y=80,W=3,H=15)
	TabUnselectedM=(X=60,Y=80,W=1,H=15)
	TabUnselectedR=(X=109,Y=80,W=2,H=15)

	Size_ScrollbarWidth=12
	Size_ScrollbarButtonHeight=10
	Size_MinScrollbarHeight=6

	Size_TabAreaHeight=15
	Size_TabAreaOverhangHeight=2
	Size_TabSpacing=20
	Size_TabXOffset=1

	Pulldown_ItemHeight=15
	Pulldown_VBorder=3
	Pulldown_HBorder=3
	Pulldown_TextBorder=9

	ColumnHeadingHeight=13
}
//=============================================================================
// UWindowWindow - the parent class for all Window objects
//=============================================================================
class UWindowWindow extends UWindowBase;



#exec TEXTURE IMPORT NAME=BlackTexture FILE=..\Engine\Textures\Black.tga MIPS=OFF COMPRESS=DXT1
#exec TEXTURE IMPORT NAME=WhiteTexture FILE=..\Engine\Textures\White.tga MIPS=OFF COMPRESS=DXT1

// Dimensions, offset relative to parent.
var float				WinLeft;
var float				WinTop;
var float				WinWidth;
var float				WinHeight;

// Relationships to other windows
var UWindowWindow		ParentWindow;			// Parent window
var UWindowWindow		FirstChildWindow;		// First child window - bottom window first
var UWindowWindow		LastChildWindow;		// Last child window - WinTop window first
var UWindowWindow		NextSiblingWindow;		// sibling window - next window above us
var UWindowWindow		PrevSiblingWindow;		// previous sibling window - next window below us
var UWindowWindow		ActiveWindow;			// The child of ours which is currently active
var UWindowRootWindow	Root;					// The root window
var UWindowWindow		OwnerWindow;			// Some arbitary owner window
var UWindowWindow		ModalWindow;			// Some window we've opened modally.

var bool				bWindowVisible;
var bool				bNoClip;				// Clipping disabled for this window?
var bool				bMouseDown;				// Pressed down in this window?
var bool				bRMouseDown;			// Pressed down in this window?
var bool				bMMouseDown;			// Pressed down in this window?
var bool				bAlwaysBehind;			// Window doesn't bring to front on click.
var bool				bAcceptsFocus;			// Accepts key messages
var bool				bAlwaysOnTop;			// Always on top
var bool				bLeaveOnscreen;			// Window is left onscreen when UWindow isn't active.
var bool				bUWindowActive;			// Is UWindow active?
var bool				bTransient;				// Never the active window. Used for combo dropdowns7
var bool				bAcceptsHotKeys;		// Does this window accept hotkeys?
var bool				bIgnoreLDoubleClick;
var bool				bIgnoreMDoubleClick;
var bool				bIgnoreRDoubleClick;

var float				ClickTime;
var float				MClickTime;
var float				RClickTime;
var float				ClickX;
var float				ClickY;
var float				MClickX;
var float				MClickY;
var float				RClickX;
var float				RClickY;

var UWindowLookAndFeel	LookAndFeel;

var Region	ClippingRegion;

struct MouseCursor
{
	var Texture tex;
	var int HotX;
	var int HotY;
	var byte WindowsCursor;
};

var MouseCursor Cursor;

enum WinMessage
{
	WM_LMouseDown,
	WM_LMouseUp,
	WM_MMouseDown,
	WM_MMouseUp,
	WM_RMouseDown,
	WM_RMouseUp,
	WM_KeyUp,
	WM_KeyDown,
	WM_KeyType,
	WM_Paint	// Window needs painting
};

// Dialog messages
const DE_Created = 0;
const DE_Change	 = 1;
const DE_Click	 = 2;
const DE_Enter	 = 3;
const DE_Exit	 = 4;
const DE_MClick	 = 5;
const DE_RClick	 = 6;
const DE_EnterPressed = 7;
const DE_MouseMove = 8;
const DE_MouseLeave = 9;
const DE_LMouseDown = 10;
const DE_DoubleClick = 11;
const DE_MouseEnter = 12;
const DE_HelpChanged = 13;
const DE_WheelUpPressed = 14;
const DE_WheelDownPressed = 15;

// Ideally Key would be a EInputKey but I can't see that class here.
function WindowEvent(WinMessage Msg, Canvas C, float X, float Y, int Key)
{
	switch(Msg)
	{
	case WM_Paint:
		Paint(C, X, Y);
		PaintClients(C, X, Y);
		break;
	case WM_LMouseDown:
		if(!Root.CheckCaptureMouseDown())
		{
			if(!MessageClients(Msg, C, X, Y, Key))
				LMouseDown(X, Y);
		}
		break;
	case WM_LMouseUp:
		if(!Root.CheckCaptureMouseUp())
		{
			if(!MessageClients(Msg, C, X, Y, Key))
				LMouseUp(X, Y);
		}
		break;
	case WM_RMouseDown:
		if(!MessageClients(Msg, C, X, Y, Key)) RMouseDown(X, Y);
		break;
	case WM_RMouseUp:
		if(!MessageClients(Msg, C, X, Y, Key)) RMouseUp(X, Y);
		break;
	case WM_MMouseDown:
		if(!MessageClients(Msg, C, X, Y, Key)) MMouseDown(X, Y);
		break;
	case WM_MMouseUp:
		if(!MessageClients(Msg, C, X, Y, Key)) MMouseUp(X, Y);
		break;
	case WM_KeyDown:
		if(!PropagateKey(Msg, C, X, Y, Key))
		{
			KeyDown(Key, X, Y);
		}
		break;
	case WM_KeyUp:
		if(!PropagateKey(Msg, C, X, Y, Key))
		{
			KeyUp(Key, X, Y);
		}
		break;
	case WM_KeyType:
		if(!PropagateKey(Msg, C, X, Y, Key))
			KeyPressed(Key, X, Y);
		break;
	default:
		break;
	}
}

function SaveConfigs()
{

	// Implemented in a child class
}

final function PlayerController GetPlayerOwner()
{
	return Root.ViewportOwner.Actor;
}

final function LevelInfo GetLevel()
{
	if (Root != None)
	{
		if (Root.ViewportOwner != None)
		{
			if (Root.ViewportOwner.Actor != None)
				return Root.ViewportOwner.Actor.Level;
		}
	}

	return None;
}

final function LevelInfo GetEntryLevel()
{
	return Root.ViewportOwner.Actor.GetEntryLevel();
}

function Resized()
{
	// Implemented in a child class
}

function BeforePaint(Canvas C, float X, float Y)
{
	// Implemented in a child class
}

function AfterPaint(Canvas C, float X, float Y)
{
	// Implemented in a child class
}

function Paint(Canvas C, float X, float Y)
{
	// Implemented in a child class
}

function Click(float X, float Y)
{
	// Implemented in a child class
}


function MClick(float X, float Y)
{
	// Implemented in a child class
}

function RClick(float X, float Y)
{
	// Implemented in a child class
}

function DoubleClick(float X, float Y)
{
	// Implemented in a child class
}

function MDoubleClick(float X, float Y)
{
	// Implemented in a child class
}

function RDoubleClick(float X, float Y)
{
	// Implemented in a child class
}

function BeginPlay()
{
	// Implemented in a child class
}

function BeforeCreate()
{
	// Implemented in a child class
}

function Created()
{
	// Implemented in a child class
}

function AfterCreate()
{
	// Implemented in a child class
}

function MouseEnter()
{
	// Implemented in a child class
}

function Activated()
{
	// Implemented in a child class
}

function Deactivated()
{
	// Implemented in a child class
}

function MouseLeave()
{
	bMouseDown = False;
	bMMouseDown = False;
	bRMouseDown = False;
}

function MouseMove(float X, float Y)
{
}

function KeyUp(int Key, float X, float Y)
{
	// Implemented in child class
}

function KeyDown(int Key, float X, float Y)
{
	// Implemented in child class
}

function bool HotKeyDown(int Key, float X, float Y)
{
	// Implemented in child class
	//Log("UWindowWindow: Checking HotKeyDown for "$Self);
	return False;
}

function bool HotKeyUp(int Key, float X, float Y)
{
	// Implemented in child class
	//Log("UWindowWindow: Checking HotKeyUp for "$Self);
	return False;
}

function KeyPressed(int Key, float X, float Y)
{
	// Implemented in child class
}

function ProcessMenuKey(int Key, string KeyName)
{
	// Implemented in child class
}

function KeyFocusEnter()
{
	// Implemented in child class
}

function KeyFocusExit()
{
	// Implemented in child class
}


function RMouseDown(float X, float Y)
{
	ActivateWindow(0, False);
	bRMouseDown = True;
}

function RMouseUp(float X, float Y)
{
	if(bRMouseDown)
	{
		if(!bIgnoreRDoubleClick && Abs(X-RClickX) <= 1 && Abs(Y-RClickY) <= 1 && GetLevel().TimeSeconds < RClickTime + 0.600)
		{
			RDoubleClick(X, Y);
			RClickTime = 0;
		}
		else
		{
			RClickTime = GetLevel().TimeSeconds;
			RClickX = X;
			RClickY = Y;
			RClick(X, Y);
		}
	}
	bRMouseDown = False;

}

function MMouseDown(float X, float Y)
{
	ActivateWindow(0, False);
	/* DEBUG
	HideWindow();
	*/
	bMMouseDown = True;
}

function MMouseUp(float X, float Y)
{
	if(bMMouseDown)
	{
		if(!bIgnoreMDoubleClick && Abs(X-MClickX) <= 1 && (Y-MClickY)<=1 && GetLevel().TimeSeconds < MClickTime + 0.600)
		{
			MDoubleClick(X, Y);
			MClickTime = 0;
		}
		else
		{
			MClickTime = GetLevel().TimeSeconds;
			MClickX = X;
			MClickY = Y;
			MClick(X, Y);
		}
	}
	bMMouseDown = False;
}


function LMouseDown(float X, float Y)
{
	ActivateWindow(0, False);
	bMouseDown = True;
}

function LMouseUp(float X, float Y)
{
	if(bMouseDown)
	{
		if(!bIgnoreLDoubleClick && Abs(X-ClickX) <= 1 && (Y-ClickY) <= 1 && GetLevel().TimeSeconds < ClickTime + 0.600)
		{
			DoubleClick(X, Y);
			ClickTime = 0;
		}
		else
		{
			ClickTime = GetLevel().TimeSeconds;
			ClickX = X;
			ClickY = Y;
			Click(X, Y);
		}
	}
	bMouseDown = False;
}

function FocusWindow()
{
	if(Root.FocusedWindow != None && Root.FocusedWindow != Self)
		Root.FocusedWindow.FocusOtherWindow(Self);

	Root.FocusedWindow = Self;
}

function FocusOtherWindow(UWindowWindow W)
{
}

function EscClose()
{
	Close();
}

function Close(optional bool bByParent)
{
	local UWindowWindow Prev, Child;

	for(Child = LastChildWindow;Child != None;Child = Prev)
	{
		Prev = Child.PrevSiblingWindow;
		Child.Close(True);
	}
	SaveConfigs();
	if(!bByParent)
		HideWindow();
}

final function SetSize(float W, float H)
{
	if(WinWidth != W || WinHeight != H)
	{
		WinWidth = W;
		WinHeight = H;
		Resized();
	}
}

function Tick(float Delta)
{
}

final function DoTick(float Delta)
{
	local UWindowWindow Child;

	Tick(Delta);

	Child = FirstChildWindow;

	while(Child != None)
	{
		Child.bUWindowActive = bUWindowActive;

		if(bLeaveOnScreen)
			Child.bLeaveOnscreen = True;

		if(bUWindowActive || Child.bLeaveOnscreen)
		{
			Child.DoTick(Delta);
		}

		Child = Child.NextSiblingWindow;
	}
}

final function PaintClients(Canvas C, float X, float Y)
{
	local float   OrgX, OrgY;
	local float   ClipX, ClipY;
	local UWindowWindow Child;

	OrgX = C.OrgX;
	OrgY = C.OrgY;
	ClipX = C.ClipX;
	ClipY = C.ClipY;

	Child = FirstChildWindow;

	while(Child != None)
	{
		Child.bUWindowActive = bUWindowActive;

		C.SetPos(0,0);
		C.Style = GetPlayerOwner().ERenderStyle.STY_Normal;
		C.SetDrawColor(255,255,255);
		C.SpaceX = 0;
		C.SpaceY = 0;

		Child.BeforePaint(C, X - Child.WinLeft, Y - Child.WinTop);

		if(bLeaveOnScreen)
			Child.bLeaveOnscreen = True;

		if(bUWindowActive || Child.bLeaveOnscreen)
		{

			C.OrgX = C.OrgX + Child.WinLeft*Root.GUIScale;
			C.OrgY = C.OrgY + Child.WinTop*Root.GUIScale;

			if(!Child.bNoClip)
			{
				C.ClipX = FMin(WinWidth - Child.WinLeft, Child.WinWidth)*Root.GUIScale;
				C.ClipY = FMin(WinHeight - Child.WinTop, Child.WinHeight)*Root.GUIScale;


				// Translate to child's co-ordinate system
				Child.ClippingRegion.X = ClippingRegion.X - Child.WinLeft;
				Child.ClippingRegion.Y = ClippingRegion.Y - Child.WinTop;
				Child.ClippingRegion.W = ClippingRegion.W;
				Child.ClippingRegion.H = ClippingRegion.H;

				if(Child.ClippingRegion.X < 0)
				{
					Child.ClippingRegion.W += Child.ClippingRegion.X;
					Child.ClippingRegion.X = 0;
				}

				if(Child.ClippingRegion.Y < 0)
				{
					Child.ClippingRegion.H += Child.ClippingRegion.Y;
					Child.ClippingRegion.Y = 0;
				}

				if(Child.ClippingRegion.W > Child.WinWidth - Child.ClippingRegion.X)
				{
					Child.ClippingRegion.W = Child.WinWidth - Child.ClippingRegion.X;
				}

				if(Child.ClippingRegion.H > Child.WinHeight - Child.ClippingRegion.Y)
				{
					Child.ClippingRegion.H = Child.WinHeight - Child.ClippingRegion.Y;
				}
			}

			if(Child.ClippingRegion.W > 0 && Child.ClippingRegion.H > 0)
			{
				Child.WindowEvent(WM_Paint, C, X - Child.WinLeft, Y - Child.WinTop, 0);
				Child.AfterPaint(C, X - Child.WinLeft, Y - Child.WinTop);
			}

			C.OrgX = OrgX;
			C.OrgY = OrgY;
		}

		Child = Child.NextSiblingWindow;
	}

	C.ClipX = ClipX;
	C.ClipY = ClipY;
}

final function UWindowWindow FindWindowUnder(float X, float Y)
{
	local UWindowWindow Child;

	// go from Topmost downwards
	Child = LastChildWindow;

	while(Child != None)
	{
		Child.bUWindowActive = bUWindowActive;

		if(bLeaveOnScreen)
			Child.bLeaveOnscreen = True;

		if(bUWindowActive || Child.bLeaveOnscreen)
		{
			if((X >= Child.WinLeft) && (X <= Child.WinLeft+Child.WinWidth) &&
			   (Y >= Child.WinTop) && (Y <= Child.WinTop+Child.WinHeight) &&
			   (!Child.CheckMousePassThrough(X-Child.WinLeft, Y-Child.WinTop)))
			{
				return Child.FindWindowUnder(X - Child.WinLeft, Y - Child.WinTop);
			}
		}

		Child = Child.PrevSiblingWindow;
	}

	// Doesn't correspond to any children - it's us.
	return Self;
}

final function bool PropagateKey(WinMessage Msg, Canvas C, float X, float Y, int Key)
{
	local UWindowWindow Child;

	// Check from WinTopmost for windows which accept focus
	Child = LastChildWindow;

	// HACK for always on top windows...need a better solution
	if(ActiveWindow != None && Child != ActiveWindow && !Child.bTransient)
		Child = ActiveWindow;

	while(Child != None)
	{
		Child.bUWindowActive = bUWindowActive;

		if(bLeaveOnScreen)
			Child.bLeaveOnscreen = True;

		if((bUWindowActive || Child.bLeaveOnscreen) && Child.bAcceptsFocus)
		{
//			Log("Sending keystrokes from: "$self$" to:  "$Child$" in state "$Child.GetStateName()$" from state "$GetStateName());
			Child.WindowEvent(Msg, C, X - Child.WinLeft, Y - Child.WinTop, Key);
//			log("Returned from "$Child);
			return True;
		}
		//else
			//Log("Ignoring child:  "$Child);
		Child = Child.PrevSiblingWindow;
	}
	return False;
}

final function bool PropagateMessage( coerce string Msg, float MsgLife)
{
	local UWindowWindow Child;

	Child = LastChildWindow;

	if(ActiveWindow != None && Child != ActiveWindow && !Child.bTransient)
		Child = ActiveWindow;

	while(Child != None)
	{
		Child.bUWindowActive = bUWindowActive;

		if(bLeaveOnScreen)
			Child.bLeaveOnscreen = True;

		if((bUWindowActive || Child.bLeaveOnscreen) && Child.bAcceptsFocus)
		{
			Child.Message(Msg,MsgLife);
			Child.PropagateMessage(Msg, MsgLife);
			return True;
		}
		Child = Child.PrevSiblingWindow;
	}

	return False;
}


final function UWindowWindow CheckKeyFocusWindow()
{
	local UWindowWindow Child;

	// Check from WinTopmost for windows which accept key focus
	Child = LastChildWindow;

	if(ActiveWindow != None && Child != ActiveWindow && !Child.bTransient)
		Child = ActiveWindow;

	while(Child != None)
	{
		Child.bUWindowActive = bUWindowActive;

		if(bLeaveOnScreen)
			Child.bLeaveOnscreen = True;

		if(bUWindowActive || Child.bLeaveOnscreen)
		{
			if(Child.bAcceptsFocus)
			{
				return Child.CheckKeyFocusWindow();
			}
		}
		Child = Child.PrevSiblingWindow;
	}

	return Self;
}

final function bool MessageClients(WinMessage Msg, Canvas C, float X, float Y, int Key)
{
	local UWindowWindow Child;

	// go from topmost downwards
	Child = LastChildWindow;

	while(Child != None)
	{
		Child.bUWindowActive = bUWindowActive;

		if(bLeaveOnScreen)
			Child.bLeaveOnscreen = True;

		if(bUWindowActive || Child.bLeaveOnscreen)
		{
			if((X >= Child.WinLeft) && (X <= Child.WinLeft+Child.WinWidth) &&
			   (Y >= Child.WinTop) && (Y <= Child.WinTop+Child.WinHeight)  &&
			   (!Child.CheckMousePassThrough(X-Child.WinLeft, Y-Child.WinTop)))
			{
				Child.WindowEvent(Msg, C, X - Child.WinLeft, Y - Child.WinTop, Key);
				return True;
			}
		}

		Child = Child.PrevSiblingWindow;
	}

	return False;
}

final function ActivateWindow(int Depth, bool bTransientNoDeactivate)
{
	if(Self == Root)
	{
		if(Depth == 0)
			FocusWindow();
		return;
	}

	if(WaitModal()) return;

	if(!bAlwaysBehind)
	{
		ParentWindow.HideChildWindow(Self);
		ParentWindow.ShowChildWindow(Self);
	}

	//Log("Activating Window "$Self);

	if(!(bTransient || bTransientNoDeactivate))
	{
		if(ParentWindow.ActiveWindow != None && ParentWindow.ActiveWindow != Self)
		{
			ParentWindow.ActiveWindow.Deactivated();
		}

		ParentWindow.ActiveWindow = Self;
		ParentWindow.ActivateWindow(Depth + 1, False);

		Activated();
	}
	else
	{
		ParentWindow.ActivateWindow(Depth + 1, True);
	}

	if(Depth == 0)
		FocusWindow();
}

final function BringToFront()
{
	if(Self == Root)
		return;

	if(!bAlwaysBehind && !WaitModal())
	{
		ParentWindow.HideChildWindow(Self);
		ParentWindow.ShowChildWindow(Self);
	}
	ParentWindow.BringToFront();
}

final function SendToBack()
{
	ParentWindow.HideChildWindow(Self);
	ParentWindow.ShowChildWindow(Self, True);
}

final function HideChildWindow(UWindowWindow Child)
{
	local UWindowWindow Window;

	if(!Child.bWindowVisible) return;
	Child.bWindowVisible = False;

	if(Child.bAcceptsHotKeys)
		Root.RemoveHotkeyWindow(Child);

	// Check WinTopmost
	if(LastChildWindow == Child)
	{
		LastChildWindow = Child.PrevSiblingWindow;
		if(LastChildWindow != None)
		{
			LastChildWindow.NextSiblingWindow = None;
		}
		else
		{
			FirstChildWindow = None;
		}
	}
	else if(FirstChildWindow == Child) // Check bottommost
	{
		FirstChildWindow = Child.NextSiblingWindow;
		if(FirstChildWindow != None)
		{
			FirstChildWindow.PrevSiblingWindow = None;
		}
		else
		{
			LastChildWindow = None;
		}
	}
	else
	{
		// you mean I have to go looking for it???
		Window = FirstChildWindow;
		while(Window != None)
		{
			if(Window.NextSiblingWindow == Child)
			{
				Window.NextSiblingWindow = Child.NextSiblingWindow;
				Window.NextSiblingWindow.PrevSiblingWindow = Window;
				break;
			}
			Window = Window.NextSiblingWindow;
		}
	}

	// Set the active window
	ActiveWindow = None;
	Window = LastChildWindow;
	while(Window != None)
	{
		if(!Window.bAlwaysOnTop)
		{
			ActiveWindow = Window;
			break;
		}
		Window = Window.PrevSiblingWindow;
	}
	if(ActiveWindow == None) ActiveWindow = LastChildWindow;
}

final function SetAcceptsFocus()
{
	if(bAcceptsFocus) return;
	bAcceptsFocus = True;

	if(Self != Root)
		ParentWindow.SetAcceptsFocus();
}

final function CancelAcceptsFocus()
{
	local UWindowWindow Child;

	for(Child = LastChildWindow; Child != None; Child = Child.PrevSiblingWindow)
		Child.CancelAcceptsFocus();

	bAcceptsFocus = False;
}

final function GetMouseXY(out float X, out float Y)
{
	local UWindowWindow P;

	X = Int(Root.MouseX);
	Y = Int(Root.MouseY);

	P = Self;
	while(P != Root)
	{
		X = X - P.WinLeft;
		Y = Y - P.WinTop;
		P = P.ParentWindow;
	}
}

final function GlobalToWindow(float GlobalX, float GlobalY, out float WinX, out float WinY)
{
	local UWindowWindow P;

	WinX = GlobalX;
	WinY = GlobalY;

	P = Self;
	while(P != Root)
	{
		WinX -= P.WinLeft;
		WinY -= P.WinTop;
		P = P.ParentWindow;
	}
}

final function WindowToGlobal(float WinX, float WinY, out float GlobalX, out float GlobalY)
{
	local UWindowWindow P;

	GlobalX = WinX;
	GlobalY = WinY;

	P = Self;
	while(P != Root)
	{
		GlobalX += P.WinLeft;
		GlobalY += P.WinTop;
		P = P.ParentWindow;
	}
}

final function ShowChildWindow(UWindowWindow Child, optional bool bAtBack)
{
	local UWindowWindow W;

	if(!Child.bTransient) ActiveWindow = Child;

	if(Child.bWindowVisible) return;
	Child.bWindowVisible = True;

	if(Child.bAcceptsHotKeys)
		Root.AddHotkeyWindow(Child);

	if(bAtBack)
	{
		if(FirstChildWindow == None)
		{
			Child.NextSiblingWindow = None;
			Child.PrevSiblingWindow = None;
			LastChildWindow = Child;
			FirstChildWindow = Child;
		}
		else
		{
			FirstChildWindow.PrevSiblingWindow = Child;
			Child.NextSiblingWindow = FirstChildWindow;
			Child.PrevSiblingWindow = None;
			FirstChildWindow = Child;
		}
	}
	else
	{
		W = LastChildWindow;
		while(True)
		{
			if((Child.bAlwaysOnTop) || (W == None) || (!W.bAlwaysOnTop))
			{
				if(W == None)
				{
					if(LastChildWindow == None)
					{
						// We're the only window
						Child.NextSiblingWindow = None;
						Child.PrevSiblingWindow = None;
						LastChildWindow = Child;
						FirstChildWindow = Child;
					}
					else
					{
						// We feel off the end of the list, we're the bottom (first) child window.
						Child.NextSiblingWindow = FirstChildWindow;
						Child.PrevSiblingWindow = None;
						FirstChildWindow.PrevSiblingWindow = Child;
						FirstChildWindow = Child;
					}
				}
				else
				{
					// We're either the new topmost (last) or we need to be inserted in the list.

					Child.NextSiblingWindow = W.NextSiblingWindow;
					Child.PrevSiblingWindow = W;
					if(W.NextSiblingWindow != None)
					{
						W.NextSiblingWindow.PrevSiblingWindow = Child;
					}
					else
					{
						LastChildWindow = Child;
					}
					W.NextSiblingWindow = Child;
				}

				// We're done.
				break;
			}

			W = W.PrevSiblingWindow;
		}
	}
}

function ShowWindow()
{
	ParentWindow.ShowChildWindow(Self);
	WindowShown();
}

function HideWindow()
{
	WindowHidden();
	ParentWindow.HideChildWindow(Self);
}

final function UWindowWindow CreateWindow(class<UWindowWindow> WndClass, float X, float Y, float W, float H, optional UWindowWindow OwnerW, optional bool bUnique, optional name ObjectName)
{
	local UWindowWindow Child;

	if(bUnique)
	{
		Child = Root.FindChildWindow(WndClass, True);

		if(Child != None)
		{
			Child.ShowWindow();
			Child.BringToFront();
			return Child;
		}
	}

	if(ObjectName != '')
		Child = New(None, string(ObjectName)) WndClass;
	else
		Child = New(None) WndClass;


	Child.BeginPlay();
	Child.WinTop = Y;
	Child.WinLeft = X;
	Child.WinWidth = W;
	Child.WinHeight = H;
	Child.Root = Root;
	Child.ParentWindow = Self;
	Child.OwnerWindow = OwnerW;
	if(Child.OwnerWindow == None)
		Child.OwnerWindow = Self;

	Child.Cursor = Cursor;
	Child.bAlwaysBehind = False;
	Child.LookAndFeel = LookAndFeel;
	Child.BeforeCreate();
	Child.Created();



	// Now add it at the WinTop of the Z-Order and then adjust child list.
	ShowChildWindow(Child);

	Child.AfterCreate();

	return Child;
}

final function Tile(Canvas C, Texture T)
{
	local int X, Y;

	X = 0;
	Y = 0;

	While(X < WinWidth)
	{
		While(Y < WinHeight)
		{
			DrawClippedTexture( C, X, Y, T );
			Y += T.VSize;
		}
		X += T.USize;
		Y = 0;
	}
}

final function DrawHorizTiledPieces( Canvas C, float DestX, float DestY, float DestW, float DestH, TexRegion T1, TexRegion T2, TexRegion T3, TexRegion T4, TexRegion T5, float Scale )
{
	local TexRegion Pieces[5], R;
	local int PieceCount;
	local int j;
	local float X, L;

	Pieces[0] = T1; if(T1.T != None) PieceCount = 1;
	Pieces[1] = T2; if(T2.T != None) PieceCount = 2;
	Pieces[2] = T3; if(T3.T != None) PieceCount = 3;
	Pieces[3] = T4; if(T4.T != None) PieceCount = 4;
	Pieces[4] = T5; if(T5.T != None) PieceCount = 5;

	j = 0;
	X = DestX;
	while( X < DestX + DestW )
	{
		L = DestW - (X - DestX);
		R = Pieces[j];
		DrawStretchedTextureSegment( C, X, DestY, FMin(R.W*Scale, L), R.H*Scale, R.X, R.Y, FMin(R.W, L/Scale), R.H, R.T );
		X += FMin(R.W*Scale, L);
		j = (j+1)%PieceCount;
	}
}

final function DrawVertTiledPieces( Canvas C, float DestX, float DestY, float DestW, float DestH, TexRegion T1, TexRegion T2, TexRegion T3, TexRegion T4, TexRegion T5, float Scale )
{
	local TexRegion Pieces[5], R;
	local int PieceCount;
	local int j;
	local float Y, L;

	Pieces[0] = T1; if(T1.T != None) PieceCount = 1;
	Pieces[1] = T2; if(T2.T != None) PieceCount = 2;
	Pieces[2] = T3; if(T3.T != None) PieceCount = 3;
	Pieces[3] = T4; if(T4.T != None) PieceCount = 4;
	Pieces[4] = T5; if(T5.T != None) PieceCount = 5;

	j = 0;
	Y = DestY;
	while( Y < DestY + DestH )
	{
		L = DestH - (Y - DestY);
		R = Pieces[j];
		DrawStretchedTextureSegment( C, DestX, Y, R.W*Scale, FMin(R.H*Scale, L), R.X, R.Y, R.W, FMin(R.H, L/Scale), R.T );
		Y += FMin(R.H*Scale, L);
		j = (j+1)%PieceCount;
	}
}


final function DrawClippedTexture( Canvas C, float X, float Y, texture Tex )
{
	DrawStretchedTextureSegment( C, X, Y, Tex.USize, Tex.VSize, 0, 0, Tex.USize, Tex.VSize, Tex);
}

final function DrawStretchedTexture( Canvas C, float X, float Y, float W, float H, texture Tex )
{
	DrawStretchedTextureSegment( C, X, Y, W, H, 0, 0, Tex.USize, Tex.VSize, Tex);
}

final function DrawStretchedTextureSegment( Canvas C, float X, float Y, float W, float H,
									  float tX, float tY, float tW, float tH, texture Tex )
{
	local float OrgX, OrgY, ClipX, ClipY;

	OrgX = C.OrgX;
	OrgY = C.OrgY;
	ClipX = C.ClipX;
	ClipY = C.ClipY;

	C.SetOrigin(OrgX + ClippingRegion.X*Root.GUIScale, OrgY + ClippingRegion.Y*Root.GUIScale);
	C.SetClip(ClippingRegion.W*Root.GUIScale, ClippingRegion.H*Root.GUIScale);

	C.SetPos((X - ClippingRegion.X)*Root.GUIScale, (Y - ClippingRegion.Y)*Root.GUIScale);
	C.DrawTileClipped( Tex, W*Root.GUIScale, H*Root.GUIScale, tX, tY, tW, tH);

	C.SetClip(ClipX, ClipY);
	C.SetOrigin(OrgX, OrgY);
}

final function ClipText(Canvas C, float X, float Y, coerce string S, optional bool bCheckHotkey)
{
	local float OrgX, OrgY, ClipX, ClipY;

	OrgX = C.OrgX;
	OrgY = C.OrgY;
	ClipX = C.ClipX;
	ClipY = C.ClipY;

	C.SetOrigin(OrgX + ClippingRegion.X*Root.GUIScale, OrgY + ClippingRegion.Y*Root.GUIScale);
	C.SetClip(ClippingRegion.W*Root.GUIScale, ClippingRegion.H*Root.GUIScale);

	C.SetPos((X - ClippingRegion.X)*Root.GUIScale, (Y - ClippingRegion.Y)*Root.GUIScale);
	C.DrawTextClipped(S, bCheckHotKey, Root.GUIScale, Root.GUIScale);

	C.SetClip(ClipX, ClipY);
	C.SetOrigin(OrgX, OrgY);
}

final function int WrapClipText(Canvas C, float X, float Y, coerce string S, optional bool bCheckHotkey, optional int Length, optional int PaddingLength, optional bool bNoDraw)
{
	local float W, H;
	local int SpacePos, CRPos, WordPos, TotalPos;
	local string Out, Temp, Padding;
	local bool bCR, bSentry;
	local int i;
	local int NumLines;
	local float pW, pH;

	// replace \\n's with Chr(13)'s
	i = InStr(S, "\\n");
	while(i != -1)
	{
		S = Left(S, i) $ Chr(13) $ Mid(S, i + 2);
		i = InStr(S, "\\n");
	}

	i = 0;
	bSentry = True;
	Out = "";
	NumLines = 1;
	while( bSentry && Y < WinHeight )
	{
		// Get the line to be drawn.
		if(Out == "")
		{
			i++;
			if (Length > 0)
				Out = Left(S, Length);
			else
				Out = S;
		}

		// Find the word boundary.
		SpacePos = InStr(Out, " ");
		CRPos = InStr(Out, Chr(13));

		bCR = False;
		if(CRPos != -1 && (CRPos < SpacePos || SpacePos == -1))
		{
			WordPos = CRPos;
			bCR = True;
		}
		else
		{
			WordPos = SpacePos;
		}

		// Get the current word.
		C.SetPos(0, 0);
		if(WordPos == -1)
			Temp = Out;
		else
			Temp = Left(Out, WordPos)$" ";
		TotalPos += WordPos;

		TextSize(C, Temp, W, H);

		// Calculate draw offset.
		if ( (Mid(Out, Len(Temp)) == "") && (PaddingLength > 0) )
		{
			Padding = Mid(S, Length, PaddingLength);
			TextSize(C, Padding, pW, pH);
			if(W + X + pW > WinWidth && X > 0)
			{
				X = 0;
				Y += H;
				NumLines++;
			}
		}
		else
		{
			if(W + X > WinWidth && X > 0)
			{
				X = 0;
				Y += H;
				NumLines++;
			}
		}

		// Draw the line.
		if(!bNoDraw)
			ClipText(C, X, Y, Temp, bCheckHotKey);

		// Increment the draw offset.
		X += W;
		if(bCR)
		{
			X =0;
			Y += H;
			NumLines++;
		}
		Out = Mid(Out, Len(Temp));
		if ((Out == "") && (i > 0))
			bSentry = False;
	}
	return NumLines;
}

final function ClipTextWidth(Canvas C, float X, float Y, coerce string S, float W)
{
	ClipText(C, X, Y, S);
}

final function DrawClippedActor( Canvas C, float X, float Y, Actor A, bool WireFrame, rotator RotOffset, vector LocOffset )
{
	local vector MeshLoc;
	local float FOV;

	FOV = GetPlayerOwner().FOVAngle * Pi / 180;

	MeshLoc.X = 4 / tan(FOV/2);
	MeshLoc.Y = 0;
	MeshLoc.Z = 0;

	A.SetRotation(RotOffset);
	A.SetLocation(MeshLoc + LocOffset);

	// C.DrawClippedActor(A, WireFrame, ClippingRegion.W * Root.GUIScale, ClippingRegion.H * Root.GUIScale, C.OrgX + ClippingRegion.X * Root.GUIScale, C.OrgY + ClippingRegion.Y * Root.GUIScale, True);
}

final function DrawUpBevel( Canvas C, float X, float Y, float W, float H, Texture T)
{
	local Region R;

	R = LookAndFeel.BevelUpTL;
	DrawStretchedTextureSegment( C, X, Y, R.W, R.H, R.X, R.Y, R.W, R.H, T );

	R = LookAndFeel.BevelUpT;
	DrawStretchedTextureSegment( C, X+LookAndFeel.BevelUpTL.W, Y,
									W - LookAndFeel.BevelUpTL.W
									- LookAndFeel.BevelUpTR.W,
									R.H, R.X, R.Y, R.W, R.H, T );

	R = LookAndFeel.BevelUpTR;
	DrawStretchedTextureSegment( C, X + W - R.W, Y, R.W, R.H, R.X, R.Y, R.W, R.H, T );

	R = LookAndFeel.BevelUpL;
	DrawStretchedTextureSegment( C, X, Y + LookAndFeel.BevelUpTL.H,
									R.W,
									H - LookAndFeel.BevelUpTL.H
									- LookAndFeel.BevelUpBL.H,
									R.X, R.Y, R.W, R.H, T );

	R = LookAndFeel.BevelUpR;
	DrawStretchedTextureSegment( C, X + W - R.W, Y + LookAndFeel.BevelUpTL.H,
									R.W,
									H - LookAndFeel.BevelUpTL.H
									- LookAndFeel.BevelUpBL.H,
									R.X, R.Y, R.W, R.H, T );


	R = LookAndFeel.BevelUpBL;
	DrawStretchedTextureSegment( C, X, Y + H - R.H, R.W, R.H, R.X, R.Y, R.W, R.H, T );

	R = LookAndFeel.BevelUpB;
	DrawStretchedTextureSegment( C, X + LookAndFeel.BevelUpBL.W, Y + H - R.H,
									W - LookAndFeel.BevelUpBL.W
									- LookAndFeel.BevelUpBR.W,
									R.H, R.X, R.Y, R.W, R.H, T );

	R = LookAndFeel.BevelUpBR;
	DrawStretchedTextureSegment( C, X + W - R.W, Y + H - R.H, R.W, R.H, R.X, R.Y,
									R.W, R.H, T );

	R = LookAndFeel.BevelUpArea;
	DrawStretchedTextureSegment( C, X + LookAndFeel.BevelUpTL.W,
	                                Y + LookAndFeel.BevelUpTL.H,
									W - LookAndFeel.BevelUpBL.W
									- LookAndFeel.BevelUpBR.W,
									H - LookAndFeel.BevelUpTL.H
									- LookAndFeel.BevelUpBL.H,
									R.X, R.Y, R.W, R.H, T );

}

final function DrawMiscBevel( Canvas C, float X, float Y, float W, float H, Texture T, int BevelType)
{
	local Region R;

	R = LookAndFeel.MiscBevelTL[BevelType];
	DrawStretchedTextureSegment( C, X, Y, R.W, R.H, R.X, R.Y, R.W, R.H, T );

	R = LookAndFeel.MiscBevelT[BevelType];
	DrawStretchedTextureSegment( C, X+LookAndFeel.MiscBevelTL[BevelType].W, Y,
									W - LookAndFeel.MiscBevelTL[BevelType].W
									- LookAndFeel.MiscBevelTR[BevelType].W,
									R.H, R.X, R.Y, R.W, R.H, T );

	R = LookAndFeel.MiscBevelTR[BevelType];
	DrawStretchedTextureSegment( C, X + W - R.W, Y, R.W, R.H, R.X, R.Y, R.W, R.H, T );

	R = LookAndFeel.MiscBevelL[BevelType];
	DrawStretchedTextureSegment( C, X, Y + LookAndFeel.MiscBevelTL[BevelType].H,
									R.W,
									H - LookAndFeel.MiscBevelTL[BevelType].H
									- LookAndFeel.MiscBevelBL[BevelType].H,
									R.X, R.Y, R.W, R.H, T );

	R = LookAndFeel.MiscBevelR[BevelType];
	DrawStretchedTextureSegment( C, X + W - R.W, Y + LookAndFeel.MiscBevelTL[BevelType].H,
									R.W,
									H - LookAndFeel.MiscBevelTL[BevelType].H
									- LookAndFeel.MiscBevelBL[BevelType].H,
									R.X, R.Y, R.W, R.H, T );


	R = LookAndFeel.MiscBevelBL[BevelType];
	DrawStretchedTextureSegment( C, X, Y + H - R.H, R.W, R.H, R.X, R.Y, R.W, R.H, T );

	R = LookAndFeel.MiscBevelB[BevelType];
	DrawStretchedTextureSegment( C, X + LookAndFeel.MiscBevelBL[BevelType].W, Y + H - R.H,
									W - LookAndFeel.MiscBevelBL[BevelType].W
									- LookAndFeel.MiscBevelBR[BevelType].W,
									R.H, R.X, R.Y, R.W, R.H, T );

	R = LookAndFeel.MiscBevelBR[BevelType];
	DrawStretchedTextureSegment( C, X + W - R.W, Y + H - R.H, R.W, R.H, R.X, R.Y,
									R.W, R.H, T );

	R = LookAndFeel.MiscBevelArea[BevelType];
	DrawStretchedTextureSegment( C, X + LookAndFeel.MiscBevelTL[BevelType].W,
	                                Y + LookAndFeel.MiscBevelTL[BevelType].H,
									W - LookAndFeel.MiscBevelBL[BevelType].W
									- LookAndFeel.MiscBevelBR[BevelType].W,
									H - LookAndFeel.MiscBevelTL[BevelType].H
									- LookAndFeel.MiscBevelBL[BevelType].H,
									R.X, R.Y, R.W, R.H, T );
}

final function string RemoveAmpersand(string S)
{
	local string Result;
	local string Underline;

	ParseAmpersand(S, Result, Underline, False);

	return Result;
}

final function byte ParseAmpersand(string S, out string Result, out string Underline, bool bCalcUnderline)
{
	local string Temp;
	local int Pos, NewPos;
	local int i;
	local byte HotKey;

	HotKey = 0;
	Pos = 0;
	Result = "";
	Underline = "";

	while(True)
	{
		Temp = Mid(S, Pos);

		NewPos = InStr(Temp, "&");

		if(NewPos == -1) break;
		Pos += NewPos;

		if(Mid(Temp, NewPos + 1, 1) == "&")
		{
			// It's a double &, lets add one to the output.
			Result = Result $ Left(Temp, NewPos) $ "&";

			if(bCalcUnderline)
				Underline = Underline $ " ";

			Pos++;
		}
		else
		{
			if(HotKey == 0)
				HotKey = Asc(Caps(Mid(Temp, NewPos + 1, 1)));

			Result = Result $ Left(Temp, NewPos);

			if(bCalcUnderline)
			{
				for(i=0;i<NewPos - 1;i++)
					Underline = Underline $ " ";
				Underline = Underline $ "_";
			}
		}

		Pos++;
	}
	Result = Result $ Temp;

	return HotKey;
}

final function bool MouseIsOver()
{
	return (Root.MouseWindow == Self);
}

function ToolTip(string strTip)
{
	if(ParentWindow != Root) ParentWindow.ToolTip(strTip);
}

// Sets mouse window for mouse capture.
final function SetMouseWindow()
{
	Root.MouseWindow = Self;
}

function Texture GetLookAndFeelTexture()
{
	return ParentWindow.GetLookAndFeelTexture();
}

function bool IsActive()
{
	return ParentWindow.IsActive();
}

function SetAcceptsHotKeys(bool bNewAccpetsHotKeys)
{
	if(bNewAccpetsHotKeys && !bAcceptsHotKeys && bWindowVisible)
		Root.AddHotkeyWindow(Self);

	if(!bNewAccpetsHotKeys && bAcceptsHotKeys && bWindowVisible)
		Root.RemoveHotkeyWindow(Self);

	bAcceptsHotKeys = bNewAccpetsHotKeys;
}

final function UWindowWindow GetParent(class<UWindowWindow> ParentClass, optional bool bExactClass)
{
	local UWindowWindow P;

	P = ParentWindow;
	while(P != Root)
	{
		if(bExactClass)
		{
			if(P.Class == ParentClass)
				return P;
		}
		else
		{
			if(ClassIsChildOf(P.Class, ParentClass))
				return P;
		}
		P = P.ParentWindow;
	}

	return None;
}

final function UWindowWindow FindChildWindow(class<UWindowWindow> ChildClass, optional bool bExactClass)
{
	local UWindowWindow Child, Found;

	for(Child = LastChildWindow;Child != None;Child = Child.PrevSiblingWindow)
	{
		if(bExactClass)
		{
			if(Child.Class == ChildClass) return Child;
		}
		else
		{
			if(ClassIsChildOf(Child.Class, ChildClass)) return Child;
		}

		Found = Child.FindChildWindow(ChildClass);
		if(Found != None) return Found;
	}

	return None;
}

function GetDesiredDimensions(out float W, out float H)
{
	local float MaxW, MaxH, TW, TH;
	local UWindowWindow Child;

	MaxW = 0;
	MaxH = 0;

	for(Child = LastChildWindow;Child != None;Child = Child.PrevSiblingWindow)
	{
		Child.GetDesiredDimensions(TW, TH);
		//Log("Calling: "$GetPlayerOwner().GetItemName(string(Child)));


		if(TW > MaxW) MaxW = TW;
		if(TH > MaxH) MaxH = TH;
	}
	W = MaxW;
	H = MaxH;
	//Log(GetPlayerOwner().GetItemName(string(Self))$": DesiredHeight: "$H);
}

final function TextSize(Canvas C, string Text, out float W, out float H)
{
	C.SetPos(0, 0);
	C.TextSize(Text, W, H);
//	W = W / Root.GUIScale;  // don't change font width since it's scaled based on GUIScale
//	H = H / Root.GUIScale;  // don't change font height since it's scaled based on GUIScale
}

function ResolutionChanged(float W, float H)
{
	local UWindowWindow Child;

	for(Child = LastChildWindow;Child != None;Child = Child.PrevSiblingWindow)
	{
		Child.ResolutionChanged(W, H);
	}
}

function ShowModal(UWindowWindow W)
{
	ModalWindow = W;
	W.ShowWindow();
	W.BringToFront();
}

function bool WaitModal()
{
	if(ModalWindow != None && ModalWindow.bWindowVisible)
		return True;

	ModalWindow = None;

	return False;
}

function WindowHidden()
{
	local UWindowWindow Child;

	for(Child = LastChildWindow;Child != None;Child = Child.PrevSiblingWindow)
		Child.WindowHidden();
}

function WindowShown()
{
	local UWindowWindow Child;

	for(Child = LastChildWindow;Child != None;Child = Child.PrevSiblingWindow)
		Child.WindowShown();
}

// Should mouse events at these co-ordinates be passed through to underlying windows?
function bool CheckMousePassThrough(float X, float Y)
{
	return False;
}

final function bool WindowIsVisible()
{
	if(Self == Root)
		return True;

	if(!bWindowVisible)
		return False;
	return ParentWindow.WindowIsVisible();
}

function SetParent(UWindowWindow NewParent)
{
	HideWindow();
	ParentWindow = NewParent;
	ShowWindow();
}

function UWindowMessageBox MessageBox(string Title, string Message, MessageBoxButtons Buttons, MessageBoxResult ESCResult, optional MessageBoxResult EnterResult, optional int TimeOut)
{
	local UWindowMessageBox W;
	local UWindowFramedWindow F;

	W = UWindowMessageBox(Root.CreateWindow(class'UWindowMessageBox', 100, 100, 100, 100, Self));
	W.SetupMessageBox(Title, Message, Buttons, ESCResult, EnterResult, TimeOut);
	F = UWindowFramedWindow(GetParent(class'UWindowFramedWindow'));

	if(F!= None)
		F.ShowModal(W);
	else
		Root.ShowModal(W);

	return W;
}

function MessageBoxDone(UWindowMessageBox W, MessageBoxResult Result)
{
}

function NotifyQuitUnreal()
{
	local UWindowWindow Child;

	for(Child = LastChildWindow;Child != None;Child = Child.PrevSiblingWindow)
		Child.NotifyQuitUnreal();
}

function NotifyBeforeLevelChange()
{
	local UWindowWindow Child;

	for(Child = LastChildWindow;Child != None;Child = Child.PrevSiblingWindow)
		Child.NotifyBeforeLevelChange();
}

function SetCursor(MouseCursor C)
{
	local UWindowWindow Child;

	Cursor = C;

	for(Child = LastChildWindow;Child != None;Child = Child.PrevSiblingWindow)
		Child.SetCursor(C);
}

function NotifyAfterLevelChange()
{
	local UWindowWindow Child;

	for(Child = LastChildWindow;Child != None;Child = Child.PrevSiblingWindow)
		Child.NotifyAfterLevelChange();
}

final function ReplaceText(out string Text, string Replace, string With)
{
	local int i;
	local string Input;

	Input = Text;
	Text = "";
	i = InStr(Input, Replace);
	while(i != -1)
	{
		Text = Text $ Left(Input, i) $ With;
		Input = Mid(Input, i + Len(Replace));
		i = InStr(Input, Replace);
	}
	Text = Text $ Input;
}

function StripCRLF(out string Text)
{
	ReplaceText(Text, Chr(13)$Chr(10), "");
	ReplaceText(Text, Chr(13), "");
	ReplaceText(Text, Chr(10), "");
}
class UWindowWrappedTextArea extends UWindowTextAreaControl;



function Paint( Canvas C, float X, float Y )
{
	local int i, Line;
	local int TempHead, TempTail;
	local float XL, YL;

	C.Font = Root.Fonts[Font];
	C.SetDrawColor(255,255,255);

	TextSize(C, "TEST", XL, YL);
	VisibleRows = WinHeight / YL;

	if (bScrollable)
	{
		VertSB.SetRange(0, Lines, VisibleRows);
	}

	TempHead = Head;
	TempTail = Tail;
	Line = TempHead;
	TextArea[Line] = Prompt;
	if (bScrollable)
	{
		if (VertSB.MaxPos - VertSB.Pos > 0)
		{
			Line -= VertSB.MaxPos - VertSB.Pos;
			TempTail -= VertSB.MaxPos - VertSB.Pos;
		}
	}
	for (i=0; i<VisibleRows; i++)
	{
		WrapClipText(C, 2, YL*(VisibleRows-i-1), TextArea[Line-1]);
		Line--;
		if (TempTail == Line)
			break;
		if (Line < 0)
			Line = BufSize-1;
	}
}

	//=============================================================================
// WindowConsole - console replacer to implement UWindow UI System
//=============================================================================
class WindowConsole extends Console;



// Constants.
const MaxLines=64;
const TextMsgSize=128;

// Variables.
var viewport Viewport;
var int Scrollback, NumLines, TopLine, TextLines;
var float MsgTime, MsgTickTime;
var string MsgText[64];
var float MsgTick[64];
var int ConsoleLines;
var float ConsolePos, ConsoleDest;
var bool bNoStuff;
var bool bNoDrawWorld;

// ---------


var UWindowRootWindow	Root;
var() config string		RootWindow;

var float				OldClipX;
var float				OldClipY;
var bool				bCreatedRoot;
var float				MouseX;
var float				MouseY;

var class<UWindowConsoleWindow> ConsoleClass;
var config float		MouseScale;
var config bool			ShowDesktop;
var config bool			bShowConsole;
var bool				bBlackout;
var bool				bUWindowType;

var bool				bUWindowActive;
var bool				bQuickKeyEnable;
var bool				bLocked;
var bool				bLevelChange;
var string				OldLevel;

var config EInputKey	UWindowKey;

var UWindowConsoleWindow ConsoleWindow;

function ResetUWindow()
{
	if(Root != None)
		Root.Close();
	Root = None;
	bCreatedRoot = False;
	ConsoleWindow = None;
	bShowConsole = False;
	CloseUWindow();
}

function bool KeyEvent( EInputKey Key, EInputAction Action, FLOAT Delta )
{
	local byte k;
	k = Key;
	switch(Action)
	{
	case IST_Press:
		switch(k)
		{
		case EInputKey.IK_Escape:
			if (bLocked)
				return true;

			bQuickKeyEnable = False;
			LaunchUWindow();
			return true;
		case ConsoleKey:
			if (bLocked)
				return true;

			bQuickKeyEnable = True;
			LaunchUWindow();
			if(!bShowConsole)
				ShowConsole();
			return true;
		}
		break;
	}

	return False;
	//!! because of ConsoleKey
	//!! return Super.KeyEvent(Key, Action, Delta);
}

function ShowConsole()
{
	bShowConsole = true;
	if(bCreatedRoot)
		ConsoleWindow.ShowWindow();
}

function HideConsole()
{
	ConsoleLines = 0;
	bShowConsole = false;
	if (ConsoleWindow != None)
		ConsoleWindow.HideWindow();
}

event Tick( float Delta )
{
	Super.Tick(Delta);

	if(bLevelChange && Root != None && string(Viewport.Actor.Level) != OldLevel)
	{
		OldLevel = string(Viewport.Actor.Level);
		// if this is Entry, we could be falling through to another level...
		if(Viewport.Actor.Level != Viewport.Actor.GetEntryLevel())
			bLevelChange = False;
		Root.NotifyAfterLevelChange();
	}
}

state UWindow
{
	event Tick( float Delta )
	{
		Global.Tick(Delta);
		if(Root != None)
			Root.DoTick(Delta);
	}

	function PostRender( canvas Canvas )
	{
		if(Root != None)
			Root.bUWindowActive = True;
		RenderUWindow( Canvas );
	}

	function bool KeyType( EInputKey Key, optional string Unicode )
	{
		if (Root != None)
			Root.WindowEvent(WM_KeyType, None, MouseX, MouseY, Key );
		return True;
	}

	function bool KeyEvent( EInputKey Key, EInputAction Action, FLOAT Delta )
	{
		local byte k;
		k = Key;

		switch (Action)
		{
		case IST_Release:
			switch (k)
			{
			case EInputKey.IK_LeftMouse:
				if(Root != None)
					Root.WindowEvent(WM_LMouseUp, None, MouseX, MouseY, k);
				break;
			case EInputKey.IK_RightMouse:
				if(Root != None)
					Root.WindowEvent(WM_RMouseUp, None, MouseX, MouseY, k);
				break;
			case EInputKey.IK_MiddleMouse:
				if(Root != None)
					Root.WindowEvent(WM_MMouseUp, None, MouseX, MouseY, k);
				break;
			default:
				if(Root != None)
					Root.WindowEvent(WM_KeyUp, None, MouseX, MouseY, k);
				break;
			}
			break;

		case IST_Press:
			switch (k)
			{
			case EInputKey.IK_F9:	// Screenshot
				return Global.KeyEvent(Key, Action, Delta);
				break;
			case ConsoleKey:
				if (bShowConsole)
				{
					HideConsole();
					if(bQuickKeyEnable)
						CloseUWindow();
				}
				else
				{
					if(Root.bAllowConsole)
						ShowConsole();
					else
						Root.WindowEvent(WM_KeyDown, None, MouseX, MouseY, k);
				}
				break;
			case EInputKey.IK_Escape:
				if(Root != None)
					Root.CloseActiveWindow();
				break;
			case EInputKey.IK_LeftMouse:
				if(Root != None)
					Root.WindowEvent(WM_LMouseDown, None, MouseX, MouseY, k);
				break;
			case EInputKey.IK_RightMouse:
				if(Root != None)
					Root.WindowEvent(WM_RMouseDown, None, MouseX, MouseY, k);
				break;
			case EInputKey.IK_MiddleMouse:
				if(Root != None)
					Root.WindowEvent(WM_MMouseDown, None, MouseX, MouseY, k);
				break;
			default:
				if(Root != None)
					Root.WindowEvent(WM_KeyDown, None, MouseX, MouseY, k);
				break;
			}
			break;
		case IST_Axis:
			switch (Key)
			{
			case IK_MouseX:
				MouseX = MouseX + (MouseScale * Delta);
				break;
			case IK_MouseY:
				MouseY = MouseY - (MouseScale * Delta);
				break;
			}
		default:
			break;
		}

		return true;
	}

Begin:
}

function ToggleUWindow()
{
}

function LaunchUWindow()
{
	Viewport.bSuspendPrecaching = True;
	bUWindowActive = !bQuickKeyEnable;
	Viewport.bShowWindowsMouse = True;

	if(bQuickKeyEnable)
		bNoDrawWorld = False;
	else
	{
		if(Viewport.Actor.Level.NetMode == NM_Standalone)
			Viewport.Actor.SetPause( True );
		bNoDrawWorld = ShowDesktop;
	}
	if(Root != None)
		Root.bWindowVisible = True;

	GotoState('UWindow');
}

function CloseUWindow()
{
	if(!bQuickKeyEnable)
		Viewport.Actor.SetPause( False );

	bNoDrawWorld = False;
	bQuickKeyEnable = False;
	bUWindowActive = False;
	Viewport.bShowWindowsMouse = False;

	if(Root != None)
		Root.bWindowVisible = False;
	GotoState('');
	Viewport.bSuspendPrecaching = False;
}

function CreateRootWindow(Canvas Canvas)
{
	local int i;

	if(Canvas != None)
	{
		OldClipX = Canvas.ClipX;
		OldClipY = Canvas.ClipY;
	}
	else
	{
		OldClipX = 0;
		OldClipY = 0;
	}

	Log("Creating root window: "$RootWindow);

	Root = New(None) class<UWindowRootWindow>(DynamicLoadObject(RootWindow, class'Class'));

	Root.BeginPlay();
	Root.WinTop = 0;
	Root.WinLeft = 0;

	if(Canvas != None)
	{
		Root.WinWidth = Canvas.ClipX / Root.GUIScale;
		Root.WinHeight = Canvas.ClipY / Root.GUIScale;
		Root.RealWidth = Canvas.ClipX;
		Root.RealHeight = Canvas.ClipY;
	}
	else
	{
		Root.WinWidth = 0;
		Root.WinHeight = 0;
		Root.RealWidth = 0;
		Root.RealHeight = 0;
	}

	Root.ClippingRegion.X = 0;
	Root.ClippingRegion.Y = 0;
	Root.ClippingRegion.W = Root.WinWidth;
	Root.ClippingRegion.H = Root.WinHeight;

//	Root.Console = Self;

	Root.bUWindowActive = bUWindowActive;

	Root.Created();
	bCreatedRoot = True;

	// Create the console window.
	ConsoleWindow = UWindowConsoleWindow(Root.CreateWindow(ConsoleClass, 100, 100, 200, 200));
	if(!bShowConsole)
		HideConsole();

	UWindowConsoleClientWindow(ConsoleWindow.ClientArea).TextArea.AddText(" ");
	for (I=0; I<4; I++)
		UWindowConsoleClientWindow(ConsoleWindow.ClientArea).TextArea.AddText(MsgText[I]);
}

function RenderUWindow( canvas Canvas )
{
	local UWindowWindow NewFocusWindow;

	Canvas.bNoSmooth = True;
	Canvas.Z = 1;
	Canvas.Style = 1;
	Canvas.DrawColor.r = 255;
	Canvas.DrawColor.g = 255;
	Canvas.DrawColor.b = 255;

	if(Viewport.bWindowsMouseAvailable && Root != None)
	{
		MouseX = Viewport.WindowsMouseX/Root.GUIScale;
		MouseY = Viewport.WindowsMouseY/Root.GUIScale;
	}

	if(!bCreatedRoot)
		CreateRootWindow(Canvas);

	Root.bWindowVisible = True;
	Root.bUWindowActive = bUWindowActive;
	Root.bQuickKeyEnable = bQuickKeyEnable;

	if(Canvas.ClipX != OldClipX || Canvas.ClipY != OldClipY)
	{
		OldClipX = Canvas.ClipX;
		OldClipY = Canvas.ClipY;

		Root.WinTop = 0;
		Root.WinLeft = 0;
		Root.WinWidth = Canvas.ClipX / Root.GUIScale;
		Root.WinHeight = Canvas.ClipY / Root.GUIScale;

		Root.RealWidth = Canvas.ClipX;
		Root.RealHeight = Canvas.ClipY;

		Root.ClippingRegion.X = 0;
		Root.ClippingRegion.Y = 0;
		Root.ClippingRegion.W = Root.WinWidth;
		Root.ClippingRegion.H = Root.WinHeight;

		Root.Resized();
	}

	if(MouseX > Root.WinWidth) MouseX = Root.WinWidth;
	if(MouseY > Root.WinHeight) MouseY = Root.WinHeight;
	if(MouseX < 0) MouseX = 0;
	if(MouseY < 0) MouseY = 0;


	// Check for keyboard focus
	NewFocusWindow = Root.CheckKeyFocusWindow();

	if(NewFocusWindow != Root.KeyFocusWindow)
	{
		Root.KeyFocusWindow.KeyFocusExit();
		Root.KeyFocusWindow = NewFocusWindow;
		Root.KeyFocusWindow.KeyFocusEnter();
	}


	Root.MoveMouse(MouseX, MouseY);
	Root.WindowEvent(WM_Paint, Canvas, MouseX, MouseY, 0);
	if(bUWindowActive || bQuickKeyEnable)
		Root.DrawMouse(Canvas);
}

event Message( coerce string Msg, float MsgLife )
{
	Super.Message( Msg, MsgLife );

	if ( Viewport.Actor == None )
		return;

	if( (Msg!="") && (ConsoleWindow != None) )
		UWindowConsoleClientWindow(ConsoleWindow.ClientArea).TextArea.AddText(MsgText[TopLine]);
}

function UpdateHistory()
{
	// Update history buffer.
	History[HistoryCur++ % MaxHistory] = TypedStr;
	if( HistoryCur > HistoryBot )
		HistoryBot++;
	if( HistoryCur - HistoryTop >= MaxHistory )
		HistoryTop = HistoryCur - MaxHistory + 1;
}

function HistoryUp()
{
	if( HistoryCur > HistoryTop )
	{
		History[HistoryCur % MaxHistory] = TypedStr;
		TypedStr = History[--HistoryCur % MaxHistory];
		TypedStrPos = 0;
	}
}

function HistoryDown()
{
	History[HistoryCur % MaxHistory] = TypedStr;
	if( HistoryCur < HistoryBot )
		TypedStr = History[++HistoryCur % MaxHistory];
	else
		TypedStr="";
	
	TypedStrPos = 0;
}

function NotifyLevelChange()
{
//	Super.NotifyLevelChange();
	bLevelChange = True;
	if(Root != None)
		Root.NotifyBeforeLevelChange();
}

defaultproperties
{
	MouseScale=0.6
	RootWindow="UWindow.UWindowRootWindow"
	UWindowKey=IK_Esc
	ConsoleKey=192
	ConsoleClass=class'UWindowConsoleWindow'
	bShowConsole=False
	bLevelChange=False
}
