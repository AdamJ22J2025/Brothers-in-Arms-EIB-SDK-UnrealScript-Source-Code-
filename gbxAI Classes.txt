class AIDebugCamera extends IAIDebugCamera
	native
	transient;


var protected gbxPlayerController	MyPlayerController;				// gbxPlayerController this camera is associated with
var protected gbxPawn				CurPawn, LastPawnOnOtherSide;
var protected int					ndxCurEnemy;
var protected int					ndxCurNode;
var protected ETeamIdentifier		CurTeam;
var protected Unit					CurUnit, LastUnitOnOtherSide;
var protected bool					bIsActive;
var protected bool					bIsPawnLevelView;
var protected bool					bIsTargetMode;
var protected bool					bIsPaused;
var protected bool					bZoomingUpwards;
var protected Texture				IconsTex;
var protected Vector				LastCameraLoc;
var protected Vector				DesiredCameraLoc;
var protected Rotator				LastCameraRot;
var protected float					CameraHeight;
var protected float					CameraMoveTime;
var protected float					TimeSeconds, MoveStartTime;
var protected float					XDistMiddleText, YDistMiddleText, XDistMiddleIcons, YDistMiddleIcons, 
									XDistLeftText1, YDistLeftText1, XDistLeftText2, YDistLeftText2, XDistLeftText3, YDistLeftText3,
									XDistLeftIcons1, YDistLeftIcons1, XDistLeftIcons2, YDistLeftIcons2,
									XDistLeftIcons3, YDistLeftIcons3, XDistNodeScore, YDistNodeScore,
									XDistEnemyDist, YDistEnemyDist, XDistExposure, YDistExposure;
var protected int					IconSizeBig, IconSizeMed, IconSizeSmall, TextScaleBig, TextScaleMed, TextScaleSmall;


cpptext
{
#ifndef SHIP
	virtual UBOOL IsActive();
#endif
}

simulated function LoadResources()
{
	IconsTex = Texture( DynamicLoadObject("t_interface_mb.debug.AIDebug_Icons", class'Texture') );
}

simulated function SetOwnerPlayerController( gbxPlayerController PC )
{
	MyPlayerController = PC;	
}

simulated function SetActive( bool bActive )
{
	if ( !bIsActive && bActive )
	{
		InitializeTeamUnitAndPawn();
		
		if ( CurUnit == None || CurPawn == None )
			return;	// Can't do anything; no units or pawns to show!

		bIsPawnLevelView = false;
		MyPlayerController.SetOraclePause( true );
		bIsPaused = true;

		LastCameraLoc = MyPlayerController.Pawn.Location;
		LastCameraRot = MyPlayerController.Pawn.Rotation;
	}

	bIsActive = bActive;

	if ( !bIsActive )
	{
		LastUnitOnOtherSide = None;
		LastPawnOnOtherSide = None;
		MyPlayerController.SetOraclePause( false );
		bIsPaused = false;
		bIsTargetMode = false;
		bIsPawnLevelView = false;
		CurUnit = None;
		CurPawn = None;
		CameraHeight = Default.CameraHeight;
		MyPlayerController.ConsoleCommand( "viewself" );
	}

	MoveStartTime = TimeSeconds;
}

simulated function TogglePause()
{
	MyPlayerController.SetOraclePause( !bIsPaused );
	bIsPaused = !bIsPaused;
}

simulated function bool IsActive()
{
	return bIsActive;
}

simulated function InitializeTeamUnitAndPawn()
{
	local int Attempt;
	local Unit aUnit;	

	if ( MyPlayerController != None && MyPlayerController.Pawn != None )
	{
		if ( MyPlayerController.Pawn.IsA( 'gbxPawn' ) )
			CurTeam = gbxPawn( MyPlayerController.Pawn ).PawnTeam;
		else
			CurTeam = TEAM_US;

		for( Attempt = 0; Attempt < 2; ++Attempt )
		{
			foreach MyPlayerController.DynamicActors( class'Unit', aUnit )
			{
				if ( aUnit.Leader != None && aUnit.Leader.PawnTeam == CurTeam && !aUnit.Leader.IsHumanControlled())
				{
					CurUnit = aUnit;
					CurPawn = CurUnit.Leader;								
					ndxCurEnemy = -1;
					ndxCurNode = -1;
					
					MyPlayerController.SetViewTarget( CurPawn );
					MyPlayerController.bBehindView = true;
					MyPlayerController.FixFOV();

					MoveStartTime = TimeSeconds;
				}			
			}		
			
			if ( CurUnit != None )
				break;
			else
			{
				// Switch team type and try again.
				if ( CurTeam == TEAM_US )
					CurTeam = TEAM_German;
				else
					CurTeam = TEAM_US;
			}
		}
	}
	else
	{
		log("NAJ**** "$Self.Name$" ; InitializeTeamUnitAndPawn: Warning: PC or PC's pawn are None. PC="$MyPlayerController$" ; Pawn="$MyPlayerController.Pawn, 'naj' );
	}
}

simulated function ToggleActive()
{
	SetActive( !bIsActive );
}

simulated function ToggleTeam() 
{
	local Unit aUnit, TempUnit;	
	local gbxPawn TempPawn;
	local Mind aMind;

	if ( !bIsActive )
	{
		SetActive( true );
		return;
	}	

	TempUnit = CurUnit;
	TempPawn = CurPawn;

	if ( CurTeam == TEAM_US )
		CurTeam = TEAM_German;
	else
		CurTeam = TEAM_US;

	// If in Targetting mode and an enemy is in view, toggle straight to that enemy.
	if ( bIsTargetMode && ndxCurEnemy != -1 )
	{
		// TBD: find the enemy and his unit.
		aMind = Mind( CurPawn.Controller );
		if ( aMind != None && aMind.AITracker != None && !aMind.AITracker.Enemies[ ndxCurEnemy ].Target.IsHumanControlled() )
		{
			CurPawn = aMind.AITracker.Enemies[ ndxCurEnemy ].Target;
			CurUnit = CurPawn.MyUnit;

			ndxCurEnemy = -1;
			LastPawnOnOtherSide = TempPawn;	

			MoveStartTime = TimeSeconds;

			MyPlayerController.SetViewTarget( CurPawn );
			MyPlayerController.bBehindView = true;
			MyPlayerController.FixFOV();
			return;
		}
	}	
	
	bIsPawnLevelView = false;

	if ( LastUnitOnOtherSide != None )
	{		
		CurUnit = LastUnitOnOtherSide;
		LastUnitOnOtherSide = TempUnit;		
	}
	else
	{
		foreach MyPlayerController.DynamicActors( class'Unit', aUnit )
		{
			if ( aUnit.Leader != None && aUnit.Leader.PawnTeam == CurTeam && !aUnit.Leader.IsHumanControlled() )
			{				
				CurUnit = aUnit;
				LastUnitOnOtherSide = TempUnit;
			}
		}
	}

	if ( LastPawnOnOtherSide == None )
		CurPawn = CurUnit.Leader;
	else
		CurPawn = LastPawnOnOtherSide;
	
	ndxCurEnemy = -1;
	ndxCurNode = -1;
	LastPawnOnOtherSide = TempPawn;	

	MoveStartTime = TimeSeconds;

	MyPlayerController.SetViewTarget( CurPawn );
	MyPlayerController.bBehindView = true;
	MyPlayerController.FixFOV();
}

simulated function ToggleUnit() 
{
	local Unit aUnit, FirstUnit;
	local bool bFound;

	if ( !bIsActive )
	{
		SetActive( true );
		return;
	}

	bIsPawnLevelView = false;

	// Find the next unit in the level that is of the same team as the currently-selected one.
	foreach MyPlayerController.DynamicActors( class'Unit', aUnit )
	{
		if ( FirstUnit == None && aUnit.SameTeamAsUnitIgnoreNeutrals( CurUnit ) && aUnit.Leader != None && !aUnit.Leader.IsHumanControlled())
		{
			FirstUnit = aUnit;			
		}

		if ( bFound )
		{
			if ( aUnit.SameTeamAsUnitIgnoreNeutrals( CurUnit ) && aUnit.Leader != None && !aUnit.Leader.IsHumanControlled() )
			{
				CurUnit = aUnit;
				CurPawn = CurUnit.Leader;
				ndxCurEnemy = -1;
				ndxCurNode = -1;

				MoveStartTime = TimeSeconds;

				MyPlayerController.SetViewTarget( CurPawn );
				MyPlayerController.bBehindView = true;
				MyPlayerController.FixFOV();
				return;
			}			
		}
		else if ( aUnit == CurUnit )
		{
			bFound = true;
		}
	}

	CurUnit = FirstUnit;
	CurPawn = CurUnit.Leader;
	ndxCurEnemy = -1;
	ndxCurNode = -1;

	MoveStartTime = TimeSeconds;

	MyPlayerController.SetViewTarget( CurPawn );
	MyPlayerController.bBehindView = true;
	MyPlayerController.FixFOV();
}

simulated function TogglePawn() 
{
	local gbxPawn aPawn, FirstPawn;
	local bool bFound;

	if ( !bIsActive )
	{
		SetActive( true );
		return;
	}

	if ( !bIsPawnLevelView )
	{
		bIsPawnLevelView = true;
		MoveStartTime = TimeSeconds;
		return;
	}
	
	foreach MyPlayerController.DynamicActors( class'gbxPawn', aPawn )
	{
		if ( FirstPawn == None && aPawn.MyUnit == CurPawn.MyUnit )
		{
			FirstPawn = aPawn;
		}

		if ( bFound )
		{
			if ( aPawn.MyUnit == CurPawn.MyUnit )
			{
				CurPawn = aPawn;
				ndxCurEnemy = -1;
				ndxCurNode = -1;
				MoveStartTime = TimeSeconds;

				MyPlayerController.SetViewTarget( CurPawn );
				MyPlayerController.bBehindView = true;
				MyPlayerController.FixFOV();
				return;
			}
		}
		else if ( aPawn == CurPawn )
		{
			bFound = true;
		}
	}

	CurPawn = FirstPawn;
	ndxCurEnemy = -1;
	ndxCurNode = -1;

	MyPlayerController.SetViewTarget( CurPawn );
	MyPlayerController.bBehindView = true;
	MyPlayerController.FixFOV();

	MoveStartTime = TimeSeconds;
}

simulated function ToggleEnemy()
{
	local Mind aMind;

	if ( bIsPawnLevelView && bIsTargetMode )
	{
		aMind = Mind( CurPawn.Controller );
		if ( aMind != None && aMind.TargetQueue.Length > 0 )
		{
			if ( ndxCurEnemy == -1 )
			{
				ndxCurEnemy = 0;
			}
			else
			{
				ndxCurEnemy = ( ndxCurEnemy + 1 ) % aMind.TargetQueue.Length;
				if ( ndxCurEnemy == 0 )
					ndxCurEnemy = -1;	// Cycle back to the CurPawn first before wrapping back around.
			}
		}		
	}

	MoveStartTime = TimeSeconds;
}

simulated function PrevNodeOrEnemy()
{	
	local Mind aMind;
	
	if ( bIsPawnLevelView )
	{
		aMind = Mind( CurPawn.Controller );
		if ( aMind != None )
		{
			if ( bIsTargetMode )
			{
				if ( aMind.TargetQueue.Length > 0 )
				{
					// Target mode: view the previous enemy.							
					if ( ndxCurEnemy > -1 )
						ndxCurEnemy--;						
					else			
						ndxCurEnemy = aMind.TargetQueue.Length-1;
				}
				else
				{
					ndxCurEnemy = -1;
				}
			}
			else
			{
				if ( aMind.AITracker != None && aMind.AITracker.MyPathNodes.Length > 0 )
				{
					// Node selection mode: View the previous pathnode.
					if ( ndxCurNode > -1 )
						ndxCurNode--;						
					else			
						ndxCurNode = aMind.AITracker.MyPathNodes.Length-1;
				}
				else
				{
					ndxCurNode = -1;
				}
			}
		}
	}

	MoveStartTime = TimeSeconds;
}

simulated function NextNodeOrEnemy()
{
	local Mind aMind;
	
	if ( bIsPawnLevelView )
	{
		aMind = Mind( CurPawn.Controller );
		if ( aMind != None )
		{
			if ( bIsTargetMode )
			{
				if ( aMind.TargetQueue.Length > 0 )
				{
					// Target mode: view the next enemy.			
					if ( ndxCurEnemy == -1 )
					{
						ndxCurEnemy = 0;
					}
					else
					{
						ndxCurEnemy = ( ndxCurEnemy + 1 ) % aMind.TargetQueue.Length;
						if ( ndxCurEnemy == 0 )
							ndxCurEnemy = -1;	// Cycle back to the CurPawn first before wrapping back around.
					}
				}
				else
				{
					ndxCurEnemy = -1;
				}
			}
			else
			{
				if ( aMind.AITracker != None && aMind.AITracker.MyPathNodes.Length > 0 )
				{
					// Node selection mode: View the next pathnode.
					if ( ndxCurNode == -1 )
					{
						ndxCurNode = 0;
					}
					else
					{
						ndxCurNode = ( ndxCurNode + 1 ) % aMind.AITracker.MyPathNodes.Length;
						if ( ndxCurNode == 0 )
							ndxCurNode = -1;	// Cycle back to the CurPawn first before wrapping back around.
					}
				}
				else
				{
					ndxCurNode = -1;
				}
			}
		}
	}

	MoveStartTime = TimeSeconds;
}

simulated function ToggleMode()
{
	bIsTargetMode = !bIsTargetMode;
	if ( !bIsTargetMode )
		ndxCurEnemy = -1;
	else
		ndxCurNode = -1;
}

simulated function ResetCamera() 
{
	local Mind aMind;

	if ( bIsPawnLevelView )
	{
		if ( bIsTargetMode && ndxCurEnemy > -1 )
		{
			aMind = Mind( CurPawn.Controller );
			if ( aMind != None && aMind.AITracker != None )
				DesiredCameraLoc = aMind.AITracker.Enemies[ndxCurEnemy].Target.Location;
			else
				DesiredCameraLoc = CurPawn.Location;
		}
		else if ( !bIsTargetMode && ndxCurNode > -1 )
		{
			aMind = Mind( CurPawn.Controller );
			if ( aMind != None && aMind.AITracker != None )
				DesiredCameraLoc = aMind.AITracker.MyPathNodes[ndxCurNode].Location;
			else
				DesiredCameraLoc = CurPawn.Location;
		}
		else
		{
			DesiredCameraLoc = CurPawn.Location;
		}
	}
	else
	{
		if ( CurUnit != None && CurUnit.FormationCenter != None )
			DesiredCameraLoc = GetLocation( CurUnit.FormationCenter );
		else
			DesiredCameraLoc = CurPawn.Location;
	}

	DesiredCameraLoc.Z += CameraHeight;
}

simulated function bool SpecialCalcView( out actor ViewActor, out vector CameraLocation, out rotator CameraRotation )
{
	local float T;
	
	ViewActor = MyPlayerController;

	ResetCamera();

	T = FClamp( ( TimeSeconds - MoveStartTime ) / CameraMoveTime, 0.0, 1.0 );
	CameraLocation = LastCameraLoc + T * ( DesiredCameraLoc - LastCameraLoc );

	CameraRotation.Pitch = -16384;
	
	LastCameraLoc = CameraLocation;
	LastCameraRot = CameraRotation;

	return true;
}

simulated function ToggleZoom()
{
	if ( CameraHeight >= 6000.0f )
		CameraHeight = 3000.0f;
	else if ( CameraHeight < 6000.0f && CameraHeight >= 3000.0f )
		CameraHeight = 2000.0f;
	else if ( CameraHeight < 3000.0f && CameraHeight >= 2000.0f )
		CameraHeight = 1000.0f;
	else
		CameraHeight = 6000.0f;

	MoveStartTime = TimeSeconds;
}

simulated function DrawGBXHud( canvas Canvas, gbxHud Hud, FontInfo Fonts, int nPass )
{
	local Mind aMind;
	local AIDebugTracker AITracker;

	aMind = Mind( CurPawn.Controller );
	if ( aMind != None && aMind.AITracker != None )
	{
		AITracker = aMind.AITracker;

		Canvas.Font = Hud.WargameFont;

		if ( bIsTargetMode )
		{
			DrawTargetModeHud( Canvas, nPass, bIsPawnLevelView, AITracker );
		}
		else
		{
			DrawMoveModeHud( Canvas, nPass, bIsPawnLevelView, AITracker );
		}
	}
}

simulated native function DrawMoveModeHud( canvas Canvas, int nPass, bool bIsPawnLevelView, AIDebugTracker AITracker );
simulated native function DrawTargetModeHud( canvas Canvas, int nPass, bool bIsPawnLevelView, AIDebugTracker AITracker );

//---------------------------------------------------------
//	GetLocation
//---------------------------------------------------------
function Vector GetLocation( ActorLite NavPoint )
{
	if ( NavPoint.bIsNavigationPoint )
		return NavigationPoint( NavPoint ).Location;
	else if ( NavPoint.bIsNavigationPointLite )
		return NavigationPointLite( NavPoint ).Location;
}

simulated event Tick( float DeltaTime )
{
	TimeSeconds += DeltaTime;	
}

defaultproperties
{
	XDistMiddleText=250.0
	YDistMiddleText=175.0
	XDistMiddleIcons=250.0
	YDistMiddleIcons=110
	XDistLeftText1=15.0
	YDistLeftText1=440.0
	XDistLeftText2=15.0
	YDistLeftText2=350.0
	XDistLeftText3=15
	YDistLeftText3=460.0
	XDistLeftIcons1=15
	YDistLeftIcons1=380
	XDistLeftIcons2=15
	YDistLeftIcons2=290
	XDistLeftIcons3=15
	YDistLeftIcons3=316
	IconSizeBig=64
	IconSizeMed=45
	IconSizeSmall=28
	TextScaleBig=1.0
	TextScaleMed=1.0
	TextScaleSmall=1.0
	CameraHeight=3000.0
	XDistNodeScore=-10
	YDistNodeScore=-25
	XDistEnemyDist=-10
	YDistEnemyDist=-100
	XDistExposure=-10
	YDistExposure=-45
	CameraMoveTime=4.0
}class AIDebugTracker extends Object
	native
	transient;

cpptext
{
	void AddFiringFactor( BYTE aReason );
#ifndef SHIP
	void StartNewMove();
	void PrepareForNewPathNodes();
	void StartNewFiringCycle( UBOOL bAvoidDuplicates );
	void AddMoveReason( BYTE aReason );
	void SetMoveSuccess( UBOOL bWasSuccess );
	FSNodeInfo& CreateNewNodeRecord( int ndx, UActorLite* pNode, FVector& NodeLocation );
	void AddCachedPathNode( UActorLite* pNode );
	void AddCandidatePathNode( UActorLite* pNode );
	void AddExcludedPathNode( UActorLite* pNode );	
	void AddCoverPathNode( UActorLite* pNode );	
	void AddVantagePathNode( UActorLite* pNode );	
	void AddFearedNode( UActorLite* pNode );
	void RemoveVantagePathNode( UActorLite* pNode );
	void FinalizePathNodes();
	void TranslateMoveReasonCode( BYTE ReasonCode, FLOAT& U, FLOAT& V );
	bool GetTargetPriorityUVOffset( int ndx, int Order, FLOAT& U, FLOAT& V );
	void AddEnemy( AgbxPawn* NewEnemy );
	void UpdateLastKnownLoc( int ndx, const FVector& NewLoc );
	void UpdateTargetExposure( int ndx, float Exposure );
	void RemoveEnemy( int ndx );
	void RemoveAllEnemies();
	void AnalyzeTarget( int TargetNdx );
	void AnalyzeReject( int TargetNdx, int RejectNdx );	
	void GetMoveHistoryUVOffset( int HistoryNdx, int ndx, FLOAT& U, FLOAT& V );
	void GetNodeReasonUVOffset( BYTE ReasonCode, FLOAT& U, FLOAT& V );
	bool ConsiderNodeScore( UActorLite* pNode, FLOAT NewScore );
	void AddNodeRejectionFactor( UActorLite* pNode, BYTE aFactor );
	void AddNodeScoreFactor( int ndx, BYTE aFactor, float FactorScore );
	void AddNodeScoreFactor( UActorLite* pNode, BYTE aFactor, float FactorScore=-1.0f );
	void AddNodeScoreFactors( UActorLite* pNode, FLOAT ScoreCover, bool bTotalCover, bool bPartialCover, FLOAT ScoreAwayFromThreats, FLOAT ScoreDistPawn, FLOAT ScoreDistFORMC, FLOAT ScoreDistIdeal, FLOAT ScoreDistVantage, bool bCoverIsVantage, FLOAT ScoreCorner, FLOAT ScoreFear, FLOAT ScoreParallel, FLOAT ScoreNoCross );
	void SortNodesByScore();
	void PushFiringHistory();	
	void RenderMoveReasons( UCanvas* Canvas, UTexture* IconsTex, FLOAT LeftX, FLOAT TopY, int IconSize );
	void RenderMoveHistory( UCanvas* Canvas, UTexture* IconsTex, FLOAT LeftX, FLOAT StartY, int IconSize );	
	void RenderTargetPriorities( int ndx, UCanvas* Canvas, UTexture* IconsTex, FLOAT StartX, FLOAT StartY, int IconSize );
	void RenderNodeReasons( int ndx, UCanvas* Canvas, UTexture* IconsTex, FLOAT LeftX, FLOAT LeftY, int IconSize, FLOAT TextScale );
	void RenderFiringFactors( UCanvas* Canvas, UTexture* IconsTex, FLOAT StartX, FLOAT StartY, int IconSize );
	void RenderFiringHistory( UCanvas* Canvas, UTexture* IconsTex, FLOAT StartX, FLOAT StartY, int IconSize );
	UBOOL RenderCSSData( UCanvas* Canvas, UTexture* IconsTex, FVector& FailLoc );
	void TranslateFiringReasonCode( BYTE ReasonCode, FLOAT& U, FLOAT& V );
	void UpdateCSSData( const FVector& SeeLoc, const FVector& SuppressLoc, const FVector& FailLoc );
#endif	// ifndef SHIP
}

struct native SHistoryInfo
{
	var int Reasons[10];
};

struct native SNodeInfo
{
	var ActorLite pNode;
	var Vector Location;
	var byte bIsExcluded;
	var byte bIsCandidate;
	var byte bIsCover;
	var byte bIsVantage;
	var byte bIsFeared;
	var int Reasons[10];
	var float Scores[10];
	var float TotalScore;
};

struct native STargetInfo
{
	var gbxPawn Target;
	var byte bIsTarget;
	var byte bIgnored;
	var byte bRelegated;
	var float Importances[9];
	var SHistoryInfo TargetHistory[6];
	var int HistoryHead, HistoryTail;
	var Vector LastKnownLoc;
	var float TargetExposure;
};

enum ENodeScoreFactor
{
	NodeScore_Excluded,
	NodeScore_AlreadyClaimed,	
	NodeScore_TotalCover,
	NodeScore_PartialCover,
	NodeScore_SomeCover,
	NodeScore_Corner,
	NodeScore_CloseToFORMC,
	NodeScore_CloseToIdeal,
	NodeScore_CloseToPawn,
	NodeScore_CloseToVantage,
	NodeScore_CoverIsVantage,
	NodeScore_AwayFromThreats,
	NodeScore_Restricted,
	NodeScore_NoCover,
	NodeScore_NoVantage,
	NodeScore_Feared,
	NodeScore_CloseToThreats,
	NodeScore_OutsideSearchRadius,
	NodeScore_ParallelToMove,
	NodeScore_NoCrossPaths,
};

enum EFiringFactor
{
	Firing_ShotOK,
	Firing_FriendlyInWay,
	Firing_TargetDead,
	Firing_NoVantage,
	Firing_ShotBlocked,
	Firing_CantSeeOrSuppress,
	Firing_CantAim,
	Firing_OpBurst,
	Firing_Terrified,
};

var Mind	MyMind;
var Vector MyThreatDir_Temp;
var Vector MyThreatDir;
var Vector SeeLoc, SuppressLoc, FailLoc;
var array<SNodeInfo> MyPathNodes_Temp;	// Temporary repository for pathnode scores that is moved over to MyPathNodes when the transaction is "finalized."
var array<SNodeInfo> MyPathNodes;
var int  LastSuccessfulMove[10];
var int LastFailedMove[10];
var int PendingMove[10];
var int LastFiringCycle[10];
var int FiringFactors_Temp[10];
var array<STargetInfo> Enemies;
var SHistoryInfo MoveHistory[6];
var SHistoryInfo FiringHistory[6];
var float LeftHistoryY;	// temp
var int			MoveHistoryHead, MoveHistoryTail;
var int			FiringHistoryHead, FiringHistoryTail;
//var bool		bStartedNewFiringCycle;
var bool		bFiringHistoryPushed;
var bool		bIgnoreDupeFiringCycles;

var const int  TARGETFACTOR_DISTANCE;
var const int  TARGETFACTOR_ATTACKLEVEL;
var const int  TARGETFACTOR_ASSIGNED;
var const int  TARGETFACTOR_ALREADYTARGETTED;
var const int  TARGETFACTOR_HUMAN;
var const int  TARGETFACTOR_TARGETEXPOSURE;
var const int  TARGETFACTOR_MYEXPOSURE;
var const int  TARGETFACTOR_IMPERVIOUS;

native function InitializeTracker();
native function StartNewMove();
native function StartNewFiringCycle( optional bool bAvoidDuplicates );
native function SetMoveSuccess( bool bWasSuccess );
native function AddCachedPathNode( ActorLite aNode );
native function AddCandidatePathNode( ActorLite aNode );
native function AddExcludedPathNode( ActorLite aNode );
native function AddCoverPathNode( ActorLite aNode );
native function AddVantagePathNode( ActorLite aNode );
native function RemoveVantagePathNode( ActorLite aNode );
native function AddMoveReason( EMoveReason aReason );
native function AddEnemy( gbxPawn NewEnemy );
native function UpdateLastKnownLoc( int ndx, Vector NewLoc );
native function RemoveEnemy( int ndx );
native function RemoveAllEnemies();
native function AnalyzeEnemies();
native function AddFiringFactor( EFiringFactor aReason );
native function UpdateCSSData( Vector SeeLoc, Vector SuppressLoc, Vector FailLoc );

function SetMind( Mind NewMind )
{
	MyMind = NewMind;
	InitializeTracker();
}

defaultproperties
{
	TARGETFACTOR_DISTANCE=0
	TARGETFACTOR_ATTACKLEVEL=1
	TARGETFACTOR_ASSIGNED=2
	TARGETFACTOR_ALREADYTARGETTED=3
	TARGETFACTOR_HUMAN=4
	TARGETFACTOR_TARGETEXPOSURE=5
	TARGETFACTOR_MYEXPOSURE=6
	TARGETFACTOR_IMPERVIOUS=7

	MoveHistoryHead=-1
	MoveHistoryTail=-1
	LeftHistoryY=106.0
}class CombatReadyCallback extends MountCallbackClass;

static function MountFinished( gbxPawn gbxP, bool bSuccess, EMountAction MountAction )
{
	if ( gbxP.Controller.IsA( 'Mind' ) )
	{
		Mind( gbxP.Controller ).NotifyCombatReady();
	}
}//=============================================================================
// High-level manager of game difficulty.  This actor acts as an abstraction 
// layer for all of the little variables and settings throughout the system
// that must be tuned to affect the game's difficulty level.
//
// Author: Neil Johnson, Gearbox Software.
//=============================================================================
class DifficultyManager extends IDifficultyManager
	notplaceable;


//---------------------------------------------------------
//	Variables / Constants
//---------------------------------------------------------
var EDifficulty Difficulty;
var int DifficultyAsInt;

// Protection Timer
var float InitialProtectionHumanSP[4];
var float SecondProtectionHumanSP[4];
var float VulnerableWindowHumanSP[4];
var Range InitialProtectionHumanMP;
var Range SecondProtectionHumanMP;
var Range VulnerableWindowHumanMP;
var Range InitialProtectionUS;
var Range SecondProtectionUS;
var Range VulnerableWindowUS;
var Range InitialProtectionGerman;
var Range SecondProtectionGerman;
var Range VulnerableWindowGerman;
var float ProtectionTimerTotalDur;

// Damage modifiers
var float BulletDamageModifierPlayerSP[4];
var float BulletDamageModifierUS[4];
var float BulletDamageModifierGerman[4];

var float ExplosiveDamageModifierPlayerSP[4];
var float ExplosiveDamageModifierUS[4];
var float ExplosiveDamageModifierGerman[4];

var float DamageModifierPlayerSP[4];
var float DamageModifierUS[4];
var float DamageModifierGerman[4];

// Suppression recovery rates
var float SuppressionDecayGray_Novice[4];
var float SuppressionDecayGray_Interm[4];
var float SuppressionDecayGray_Advanced[4];
var float SuppressionDecayGray_Veteran[4];
var float SuppressionDecayRed_Novice[4];
var float SuppressionDecayRed_Interm[4];
var float SuppressionDecayRed_Advanced[4];
var float SuppressionDecayRed_Veteran[4];

// Skill-based suppression 'magnifiers'
var float SuppressionMag_Novice[4];
var float SuppressionMag_Interm[4];
var float SuppressionMag_Advanced[4];
var float SuppressionMag_Veteran[4];

// Skill-based weapon accuracy modifiers
var float WeaponAccuracySkillMultiplier_Novice[4];
var float WeaponAccuracySkillMultiplier_Interm[4];
var float WeaponAccuracySkillMultiplier_Advanced[4];
var float WeaponAccuracySkillMultiplier_Veteran[4];

// Warning-shot viewkick and fatigue jog
var float WarningShotViewKickIntensity[4];
var float WarningShotFatigueJog[4];

// Fatigue recovery rates
var Range	FatigueRecovery_Novice, FatigueRecovery_Interm, FatigueRecovery_Advanced, FatigueRecovery_Veteran;

// Range multipliers
enum EMultiplierType
{
	MULT_ASCENDING, 
	MULT_DESCENDING
};

var const int DIFF_EASY, DIFF_NORMAL, DIFF_HARD, DIFF_AUTHENTIC;

//---------------------------------------------------------
//	SetDifficulty
//---------------------------------------------------------
function SetDifficulty( EDifficulty NewDifficulty )
{
	Difficulty = NewDifficulty;
	DifficultyAsInt = GetDifficultyAsInt();

	// Make sure the LevelInfo var matches ours.
	if ( Level.DifficultyLevel != NewDifficulty )
	{
		Level.DifficultyLevel = NewDifficulty;
	}

	DifficultyChanged();
}

//---------------------------------------------------------
//	GetDifficulty
//---------------------------------------------------------
function EDifficulty GetDifficulty()
{
	return Difficulty;
}

//---------------------------------------------------------
//	DifficultyChanged - INTERNAL USE ONLY
//---------------------------------------------------------
function DifficultyChanged()
{
	local Actor AnActor;

	// Change all the default values for each class type.
	UpdateMindDefault();
	UpdateWargamePawnDefault();
	UpdateFiringControllerDefault();
	UpdateUnitControllerAIDefault();
	UpdateGbxWeaponDefault();

	// Iterate over all Minds, UnitControllerAIs, FiringControllers, and gbxWeapons.
	// Change their various values based on the difficulty level.
	foreach DynamicActors( class'Actor', AnActor )
	{
		if ( AnActor.IsA( 'Mind' ) )
		{
			UpdateMind( Mind( AnActor ) );
		}
		if ( AnActor.IsA( 'WargamePawn' ) )
		{
			UpdateWargamePawn( WargamePawn( AnActor ) );
		}
		else if ( AnActor.IsA( 'gbxWeapon' ) )
		{
			UpdateGbxWeapon( gbxWeapon( AnActor ) );
		}
		else if ( AnActor.IsA( 'FiringControllerInfantry' ) )
		{
			UpdateFiringController( FiringControllerInfantry( AnActor ) );
		}
		else if ( AnActor.IsA( 'UnitControllerAI' ) )
		{
			UpdateUnitControllerAI( UnitControllerAI( AnActor ) );			
		}
	}
}

//---------------------------------------------------------
//	UpdateMindDefault - INTERNAL USE ONLY
//---------------------------------------------------------
function UpdateMindDefault()
{
	class'Mind'.Default.WeaponAccuracyModifierSP_Novice = WeaponAccuracySkillMultiplier_Novice[ DifficultyAsInt ];
	class'Mind'.Default.WeaponAccuracyModifierSP_Interm = WeaponAccuracySkillMultiplier_Interm[ DifficultyAsInt ];
	class'Mind'.Default.WeaponAccuracyModifierSP_Advanced = WeaponAccuracySkillMultiplier_Advanced[ DifficultyAsInt ];
	class'Mind'.Default.WeaponAccuracyModifierSP_Veteran = WeaponAccuracySkillMultiplier_Veteran[ DifficultyAsInt ];

	// These accuracy modifiers don't really need to apply to MG42 gunners, but here's the goods if necessary.
	//class'MindMG42Gunner'.Default.WeaponAccuracyModifierSP_Novice = WeaponAccuracySkillMultiplier_Novice[ DifficultyAsInt ];
	//class'MindMG42Gunner'.Default.WeaponAccuracyModifierSP_Interm = WeaponAccuracySkillMultiplier_Interm[ DifficultyAsInt ];
	//class'MindMG42Gunner'.Default.WeaponAccuracyModifierSP_Advanced = WeaponAccuracySkillMultiplier_Advanced[ DifficultyAsInt ];
	//class'MindMG42Gunner'.Default.WeaponAccuracyModifierSP_Veteran = WeaponAccuracySkillMultiplier_Veteran[ DifficultyAsInt ];

	// These accuracy modifiers don't really need to apply to Panzerfaust gunners, but here's the goods if necessary.
	//class'MindPanzerfaust'.Default.WeaponAccuracyModifierSP_Novice = WeaponAccuracySkillMultiplier_Novice[ DifficultyAsInt ];
	//class'MindPanzerfaust'.Default.WeaponAccuracyModifierSP_Interm = WeaponAccuracySkillMultiplier_Interm[ DifficultyAsInt ];
	//class'MindPanzerfaust'.Default.WeaponAccuracyModifierSP_Advanced = WeaponAccuracySkillMultiplier_Advanced[ DifficultyAsInt ];
	//class'MindPanzerfaust'.Default.WeaponAccuracyModifierSP_Veteran = WeaponAccuracySkillMultiplier_Veteran[ DifficultyAsInt ];
}

//---------------------------------------------------------
//	UpdateMind - INTERNAL USE ONLY
//---------------------------------------------------------
function UpdateMind( Mind aMind )
{
	aMind.WeaponAccuracyModifierSP_Novice = WeaponAccuracySkillMultiplier_Novice[ DifficultyAsInt ];
	aMind.WeaponAccuracyModifierSP_Interm = WeaponAccuracySkillMultiplier_Interm[ DifficultyAsInt ];
	aMind.WeaponAccuracyModifierSP_Advanced = WeaponAccuracySkillMultiplier_Advanced[ DifficultyAsInt ];
	aMind.WeaponAccuracyModifierSP_Veteran = WeaponAccuracySkillMultiplier_Veteran[ DifficultyAsInt ];
}

//---------------------------------------------------------
//	UpdateWargamePawnDefault - INTERNAL USE ONLY
//---------------------------------------------------------
function UpdateWargamePawnDefault()
{
	// Protection Timer settings
	class'gbxPlayerPawn'.Default.LongTimerDur = InitialProtectionHumanSP[ DifficultyAsInt ];
	class'InfantryUSA'.Default.LongTimerDur = GetAdjustedFloat( InitialProtectionUS, MULT_DESCENDING );
	class'InfantryGermany'.Default.LongTimerDur = GetAdjustedFloat( InitialProtectionGerman, MULT_ASCENDING );

	class'gbxPlayerPawn'.Default.ShortTimerDur = SecondProtectionHumanSP[ DifficultyAsInt ];
	class'InfantryUSA'.Default.ShortTimerDur = GetAdjustedFloat( SecondProtectionUS, MULT_DESCENDING );
	class'InfantryGermany'.Default.ShortTimerDur = GetAdjustedFloat( SecondProtectionGerman, MULT_ASCENDING );

	class'gbxPlayerPawn'.Default.VulnerableDur = VulnerableWindowHumanSP[ DifficultyAsInt ];
	class'InfantryUSA'.Default.VulnerableDur = GetAdjustedFloat( VulnerableWindowUS, MULT_ASCENDING );
	class'InfantryGermany'.Default.VulnerableDur = GetAdjustedFloat( VulnerableWindowGerman, MULT_ASCENDING );

	class'gbxPlayerPawn'.Default.TimerTotalDur = ProtectionTimerTotalDur;
	class'InfantryUSA'.Default.TimerTotalDur = ProtectionTimerTotalDur;
	class'InfantryGermany'.Default.TimerTotalDur = ProtectionTimerTotalDur;
	
	// Turn on protection for players.
	class'gbxPlayerPawn'.Default.bEnableProtectionTimers = true;
		
	// Turn off protection timers for USA/German AI pawns.	
	class'InfantryUSA'.Default.bEnableProtectionTimers = false;
	class'InfantryGermany'.Default.bEnableProtectionTimers = false;

	// Fatigue recovery rates.
	class'WargamePawn'.Default.FatigueRecovery_Novice		= GetAdjustedFloat( FatigueRecovery_Novice, MULT_ASCENDING );
	class'WargamePawn'.Default.FatigueRecovery_Interm		= GetAdjustedFloat( FatigueRecovery_Interm, MULT_ASCENDING );
	class'WargamePawn'.Default.FatigueRecovery_Advanced	= GetAdjustedFloat( FatigueRecovery_Advanced, MULT_ASCENDING );
	class'WargamePawn'.Default.FatigueRecovery_Veteran	= GetAdjustedFloat( FatigueRecovery_Veteran, MULT_ASCENDING );
}

//---------------------------------------------------------
//	UpdateWargamePawn - INTERNAL USE ONLY
//---------------------------------------------------------
function UpdateWargamePawn( WargamePawn WGPawn )
{
	// Protection Timer Settings.
	if ( WGPawn.IsA( 'gbxPlayerPawn' ) )
	{
		WGPawn.bEnableProtectionTimers = true;	// Turn on protection for players.
		WGPawn.LongTimerDur = InitialProtectionHumanSP[ DifficultyAsInt ];
		WGPawn.ShortTimerDur = SecondProtectionHumanSP[ DifficultyAsInt ];
		WGPawn.VulnerableDur = VulnerableWindowHumanSP[ DifficultyAsInt ];
	}
	else if ( WGPawn.IsA( 'InfantryUSA' ) ) 
	{
		WGPawn.bEnableProtectionTimers = false;	// Turn off protection for US AI pawns.
		WGPawn.LongTimerDur = GetAdjustedFloat( InitialProtectionUS, MULT_DESCENDING );
		WGPawn.ShortTimerDur = GetAdjustedFloat( SecondProtectionUS, MULT_DESCENDING );
		WGPawn.VulnerableDur = GetAdjustedFloat( VulnerableWindowUS, MULT_ASCENDING );
	}
	else if ( WGPawn.IsA( 'InfantryGermany' ) )
	{
		WGPawn.bEnableProtectionTimers = false;	// Turn off protection for German AI pawns.
		WGPawn.Default.LongTimerDur = GetAdjustedFloat( InitialProtectionGerman, MULT_ASCENDING );
		WGPawn.Default.ShortTimerDur = GetAdjustedFloat( SecondProtectionGerman, MULT_ASCENDING );
		WGPawn.VulnerableDur = GetAdjustedFloat( VulnerableWindowGerman, MULT_ASCENDING );
	}
	
	WGPawn.TimerTotalDur = ProtectionTimerTotalDur;
	WGPawn.ClearProtectionTimer();

	// Fatigue recovery rates.
	WGPawn.FatigueRecovery_Novice	= GetAdjustedFloat( FatigueRecovery_Novice, MULT_ASCENDING );
	WGPawn.FatigueRecovery_Interm	= GetAdjustedFloat( FatigueRecovery_Interm, MULT_ASCENDING );
	WGPawn.FatigueRecovery_Advanced	= GetAdjustedFloat( FatigueRecovery_Advanced, MULT_ASCENDING );
	WGPawn.FatigueRecovery_Veteran	= GetAdjustedFloat( FatigueRecovery_Veteran, MULT_ASCENDING );
}

//---------------------------------------------------------
//	UpdateUnitControllerAIDefault - INTERNAL USE ONLY
//---------------------------------------------------------
function UpdateUnitControllerAIDefault()
{
	// Suppression recovery rates.
	class'UnitControllerAI'.Default.SuppressionDecayGray_Novice		= SuppressionDecayGray_Novice[ DifficultyAsInt ];
	class'UnitControllerAI'.Default.SuppressionDecayGray_Interm		= SuppressionDecayGray_Interm[ DifficultyAsInt ];
	class'UnitControllerAI'.Default.SuppressionDecayGray_Advanced	= SuppressionDecayGray_Advanced[ DifficultyAsInt ];
	class'UnitControllerAI'.Default.SuppressionDecayGray_Veteran	= SuppressionDecayGray_Veteran[ DifficultyAsInt ];

	class'UnitControllerAI'.Default.SuppressionDecayRed_Novice		= SuppressionDecayRed_Novice[ DifficultyAsInt ];
	class'UnitControllerAI'.Default.SuppressionDecayRed_Interm		= SuppressionDecayRed_Interm[ DifficultyAsInt ];
	class'UnitControllerAI'.Default.SuppressionDecayRed_Advanced	= SuppressionDecayRed_Advanced[ DifficultyAsInt ];
	class'UnitControllerAI'.Default.SuppressionDecayRed_Veteran		= SuppressionDecayRed_Veteran[ DifficultyAsInt ];

	// Skill-based suppression 'magnifiers'.
	class'UnitControllerAI'.Default.SuppressionMag_Novice			= SuppressionMag_Novice[ DifficultyAsInt ];
	class'UnitControllerAI'.Default.SuppressionMag_Interm			= SuppressionMag_Interm[ DifficultyAsInt ];
	class'UnitControllerAI'.Default.SuppressionMag_Advanced			= SuppressionMag_Advanced[ DifficultyAsInt ];
	class'UnitControllerAI'.Default.SuppressionMag_Veteran			= SuppressionMag_Veteran[ DifficultyAsInt ];

	// Suppression recovery rates.
	class'UnitControllerAIInfantry'.Default.SuppressionDecayGray_Novice		= SuppressionDecayGray_Novice[ DifficultyAsInt ];
	class'UnitControllerAIInfantry'.Default.SuppressionDecayGray_Interm		= SuppressionDecayGray_Interm[ DifficultyAsInt ];
	class'UnitControllerAIInfantry'.Default.SuppressionDecayGray_Advanced	= SuppressionDecayGray_Advanced[ DifficultyAsInt ];
	class'UnitControllerAIInfantry'.Default.SuppressionDecayGray_Veteran	= SuppressionDecayGray_Veteran[ DifficultyAsInt ];

	class'UnitControllerAIInfantry'.Default.SuppressionDecayRed_Novice		= SuppressionDecayRed_Novice[ DifficultyAsInt ];
	class'UnitControllerAIInfantry'.Default.SuppressionDecayRed_Interm		= SuppressionDecayRed_Interm[ DifficultyAsInt ];
	class'UnitControllerAIInfantry'.Default.SuppressionDecayRed_Advanced	= SuppressionDecayRed_Advanced[ DifficultyAsInt ];
	class'UnitControllerAIInfantry'.Default.SuppressionDecayRed_Veteran		= SuppressionDecayRed_Veteran[ DifficultyAsInt ];

	// Skill-based suppression 'magnifiers'.
	class'UnitControllerAIInfantry'.Default.SuppressionMag_Novice			= SuppressionMag_Novice[ DifficultyAsInt ];
	class'UnitControllerAIInfantry'.Default.SuppressionMag_Interm			= SuppressionMag_Interm[ DifficultyAsInt ];
	class'UnitControllerAIInfantry'.Default.SuppressionMag_Advanced			= SuppressionMag_Advanced[ DifficultyAsInt ];
	class'UnitControllerAIInfantry'.Default.SuppressionMag_Veteran			= SuppressionMag_Veteran[ DifficultyAsInt ];
}

//---------------------------------------------------------
//	UpdateUnitControllerAI - INTERNAL USE ONLY
//---------------------------------------------------------
function UpdateUnitControllerAI( UnitControllerAI UnitConAI )
{
	// Suppression recovery rates.
	UnitConAI.SuppressionDecayGray_Novice		= SuppressionDecayGray_Novice[ DifficultyAsInt ];
	UnitConAI.SuppressionDecayGray_Interm		= SuppressionDecayGray_Interm[ DifficultyAsInt ];
	UnitConAI.SuppressionDecayGray_Advanced		= SuppressionDecayGray_Advanced[ DifficultyAsInt ];
	UnitConAI.SuppressionDecayGray_Veteran		= SuppressionDecayGray_Veteran[ DifficultyAsInt ];

	UnitConAI.SuppressionDecayRed_Novice		= SuppressionDecayRed_Novice[ DifficultyAsInt ];
	UnitConAI.SuppressionDecayRed_Interm		= SuppressionDecayRed_Interm[ DifficultyAsInt ];
	UnitConAI.SuppressionDecayRed_Advanced		= SuppressionDecayRed_Advanced[ DifficultyAsInt ];
	UnitConAI.SuppressionDecayRed_Veteran		= SuppressionDecayRed_Veteran[ DifficultyAsInt ];

	// Skill-based suppression 'magnifiers'.
	UnitConAI.SuppressionMag_Novice				= SuppressionMag_Novice[ DifficultyAsInt ];
	UnitConAI.SuppressionMag_Interm				= SuppressionMag_Interm[ DifficultyAsInt ];
	UnitConAI.SuppressionMag_Advanced			= SuppressionMag_Advanced[ DifficultyAsInt ];
	UnitConAI.SuppressionMag_Veteran			= SuppressionMag_Veteran[ DifficultyAsInt ];
}

//---------------------------------------------------------
//	UpdateFiringControllerDefault - INTERNAL USE ONLY
//---------------------------------------------------------
function UpdateFiringControllerDefault()
{
	// Unit skill modifiers.
	//class'FiringControllerInfantry'.Default.UnitSkillMod_Novice   = GetAdjustedInt( UnitSkillMod_Novice, MULT_ASCENDING );
	//class'FiringControllerInfantry'.Default.UnitSkillMod_Interm   = GetAdjustedInt( UnitSkillMod_Interm, MULT_ASCENDING );
	//class'FiringControllerInfantry'.Default.UnitSkillMod_Advanced = GetAdjustedInt( UnitSkillMod_Advanced, MULT_ASCENDING );
	//class'FiringControllerInfantry'.Default.UnitSkillMod_Veteran   = GetAdjustedInt( UnitSkillMod_Veteran, MULT_ASCENDING );
}

//---------------------------------------------------------
//	UpdateFiringController - INTERNAL USE ONLY
//---------------------------------------------------------
function UpdateFiringController( FiringControllerInfantry FC )
{
	// Unit skill modifiers.
	//FC.UnitSkillMod_Novice   = GetAdjustedInt( UnitSkillMod_Novice, MULT_ASCENDING );
	//FC.UnitSkillMod_Interm   = GetAdjustedInt( UnitSkillMod_Interm, MULT_ASCENDING );
	//FC.UnitSkillMod_Advanced = GetAdjustedInt( UnitSkillMod_Advanced, MULT_ASCENDING );
	//FC.UnitSkillMod_Veteran   = GetAdjustedInt( UnitSkillMod_Veteran, MULT_ASCENDING );
}

//---------------------------------------------------------
//	UpdateGbxWeaponDefault - INTERNAL USE ONLY
//---------------------------------------------------------
function UpdateGbxWeaponDefault()
{
	local int GameType;

	if ( Level.Game.IsA('WargameMultiplayer') )
	{
		GameType = 1;
	}
	else
	{
		GameType = 0;
	}
}

//---------------------------------------------------------
//	UpdateGbxWeapon - INTERNAL USE ONLY
//---------------------------------------------------------
function UpdateGbxWeapon( gbxWeapon Weapon )
{		
	if ( Level.Game.IsA('WargameMultiplayer') )
	{
	}
	else
	{
	}
}

//---------------------------------------------------------
//	GetMultiplier - INTERNAL USE ONLY
//---------------------------------------------------------
function float GetMultiplier( EMultiplierType MType )
{
	if ( MType == MULT_Ascending )
	{
		switch( Difficulty )
		{
			case DIFF_Easy:
				return 0.0;
			case DIFF_Normal:
				return 0.33;
			case DIFF_Hard:
				return 0.66;
			case DIFF_Authentic:
				return 1.0;
		}
	}
	else
	{
		switch( Difficulty )
		{
			case DIFF_Easy:
				return 1.0;
			case DIFF_Normal:
				return 0.66;
			case DIFF_Hard:
				return 0.33;
			case DIFF_Authentic:
				return 0.0;
		}
	}
}

//---------------------------------------------------------
//	GetAdjustedInt - INTERNAL USE ONLY
//---------------------------------------------------------
function int GetAdjustedInt( Range TheRange, EMultiplierType MType )
{
	return TheRange.Min + GetMultiplier( MType ) * ( TheRange.Max - TheRange.Min );
}

//---------------------------------------------------------
//	GetMultipliedInt - INTERNAL USE ONLY
//---------------------------------------------------------
function int GetMultipliedInt( Range TheRange, float Multiplier )
{
	return TheRange.Min + Multiplier * ( TheRange.Max - TheRange.Min );
}

//---------------------------------------------------------
//	GetAdjustedFloat - INTERNAL USE ONLY
//---------------------------------------------------------
function float GetAdjustedFloat( Range TheRange, EMultiplierType MType )
{
	return TheRange.Min + GetMultiplier( MType ) * ( TheRange.Max - TheRange.Min );
}

//---------------------------------------------------------
//	GetMultipliedFloat - INTERNAL USE ONLY
//---------------------------------------------------------
function float GetMultipliedFloat( Range TheRange, float Multiplier )
{
	return TheRange.Min + Multiplier * ( TheRange.Max - TheRange.Min );
}

//---------------------------------------------------------
//	GetDifficultyAsInt - INTERNAL USE ONLY
//---------------------------------------------------------
function int GetDifficultyAsInt()
{
	switch ( Difficulty )
	{
	case Diff_Easy: 
		return DIFF_EASY;
	case Diff_Normal:
		return DIFF_NORMAL;
	case Diff_Hard:
		return DIFF_HARD;
	case DIFF_Authentic:
		return DIFF_AUTHENTIC;
	}
}

//---------------------------------------------------------
//	AdjustDamage
//---------------------------------------------------------
// This function is called through the Pawn.TakeDamage() chain.  It adjusts the actual damage done by 
// shots based on what type of pawn the victim is.
function float AdjustDamage( int Damage, Pawn DamagedPawn, class<DamageType> DamageType )
{
	local float AdjDamage;
	//Log( " DifficultyManager::AdjustDamage() Damage="$Damage$" DamagedPawn="$DamagedPawn$" DamageType="$DamageType, 'MP' );
	
	if (Level.NetMode == NM_StandAlone)
	{
		if (DamageType.Default.m_bBulletDamage)
		{
			if ( DamagedPawn.IsA( 'gbxPlayerPawn' ) )
			{
				AdjDamage = BulletDamageModifierPlayerSP[ DifficultyAsInt ] * Damage;
			}
			else if ( DamagedPawn.IsA( 'InfantryUSA' ) )
			{
				AdjDamage = BulletDamageModifierUS[ DifficultyAsInt ] * Damage;
			}
			else if ( DamagedPawn.IsA( 'InfantryGermany' ) )
			{
				AdjDamage = BulletDamageModifierGerman[ DifficultyAsInt ] * Damage;
			}
			else
			{
				AdjDamage = Damage;
			}
		}
		else if (DamageType.Default.m_bExplosiveDamage)
		{
			if ( DamagedPawn.IsA( 'gbxPlayerPawn' ) )
			{
				AdjDamage = ExplosiveDamageModifierPlayerSP[ DifficultyAsInt ] * Damage;
			}
			else if ( DamagedPawn.IsA( 'InfantryUSA' ) )
			{
				AdjDamage = ExplosiveDamageModifierUS[ DifficultyAsInt ] * Damage;
			}
			else if ( DamagedPawn.IsA( 'InfantryGermany' ) )
			{
				AdjDamage = ExplosiveDamageModifierGerman[ DifficultyAsInt ] * Damage;
			}
			else
			{
				AdjDamage = Damage;
			}
		}
		else
		{
			if ( DamagedPawn.IsA( 'gbxPlayerPawn' ) )
			{
				AdjDamage = DamageModifierPlayerSP[ DifficultyAsInt ] * Damage;
			}
			else if ( DamagedPawn.IsA( 'InfantryUSA' ) )
			{
				AdjDamage = DamageModifierUS[ DifficultyAsInt ] * Damage;
			}
			else if ( DamagedPawn.IsA( 'InfantryGermany' ) )
			{
				AdjDamage = DamageModifierGerman[ DifficultyAsInt ] * Damage;
			}
			else
			{
				AdjDamage = Damage;
			}
		}
	}
	else
	{
		if ( DamagedPawn.IsA( 'gbxPlayerPawn' ) )
		{
			AdjDamage = DamageModifierPlayerSP[ DifficultyAsInt ] * Damage;
		}
		else if ( DamagedPawn.IsA( 'InfantryUSA' ) )
		{
			AdjDamage = DamageModifierUS[ DifficultyAsInt ] * Damage;
		}
		else if ( DamagedPawn.IsA( 'InfantryGermany' ) )
		{
			AdjDamage = DamageModifierGerman[ DifficultyAsInt ] * Damage;
		}
		else
		{
			AdjDamage = Damage;
		}
	}
	
	//Log( " DifficultyManager::AdjustDamage() AdjDamage="$AdjDamage, 'MP' );
	
	return AdjDamage;
}

//=========================================================
//	Polled functions
//=========================================================

//---------------------------------------------------------
//	CanDoOpBursts
//---------------------------------------------------------
function bool CanDoOpBursts( ESkillLevel SkillLevel )
{
	return true;
/*
	if ( Difficulty == DIFF_Easy )
	{
		// On EASY, only Advanced and Veteran Germans can do op-bursts.
		return ( SkillLevel > SKILL_Intermediate );
	}
	else
	{
		// On any other difficulty level, everyone except the most novice German units can do op-bursts.
		return ( SkillLevel > SKILL_Novice );
	}
*/
}

//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
	//---------------------------------------------
	// Protection Timer (all values in seconds)
	//
	InitialProtectionHumanSP[0]=8.4
	InitialProtectionHumanSP[1]=6.0
	InitialProtectionHumanSP[2]=3.6
	InitialProtectionHumanSP[3]=3.6
	//----
	SecondProtectionHumanSP[0]=7.2
	SecondProtectionHumanSP[1]=4.8
	SecondProtectionHumanSP[2]=2.4
	SecondProtectionHumanSP[3]=2.4
	//----
	VulnerableWindowHumanSP[0]=4.0
	VulnerableWindowHumanSP[1]=4.0
	VulnerableWindowHumanSP[2]=4.0
	VulnerableWindowHumanSP[3]=4.0

	InitialProtectionHumanMP=(Min=1.5,Max=4.0)
	SecondProtectionHumanMP=(Min=0.5,Max=1.5)
	VulnerableWindowHumanMP=(Min=0.0,Max=0.0)
	InitialProtectionUS=(Min=0.0,Max=0.0)
	SecondProtectionUS=(Min=0.0,Max=0.0)
	VulnerableWindowUS=(Min=0.0,Max=0.0)
	InitialProtectionGerman=(Min=0.0,Max=0.0)
	SecondProtectionGerman=(Min=0.0,Max=0.0)
	VulnerableWindowGerman=(Min=0.0,Max=0.0)
	ProtectionTimerTotalDur=40.0

	//---------------------------------------------
	// Suppression recovery rates
	//
	// G R A Y
	SuppressionDecayGray_Novice[0]=0.067	// 15 seconds
	SuppressionDecayGray_Novice[1]=0.077	// 13 seconds
	SuppressionDecayGray_Novice[2]=0.091	// 11 seconds
	SuppressionDecayGray_Novice[3]=0.091	// 11 seconds
	//----
	SuppressionDecayGray_Interm[0]=0.077	// 13 seconds
	SuppressionDecayGray_Interm[1]=0.091	// 11 seconds
	SuppressionDecayGray_Interm[2]=0.111	// 9 seconds
	SuppressionDecayGray_Interm[3]=0.111	// 9 seconds
	//----
	SuppressionDecayGray_Advanced[0]=0.091	// 11 seconds
	SuppressionDecayGray_Advanced[1]=0.111	// 9 seconds
	SuppressionDecayGray_Advanced[2]=0.143	// 7 seconds
	SuppressionDecayGray_Advanced[3]=0.143	// 7 seconds
	//----
	SuppressionDecayGray_Veteran[0]=0.111	// 9 seconds
	SuppressionDecayGray_Veteran[1]=0.143	// 7 seconds
	SuppressionDecayGray_Veteran[2]=0.200	// 5 seconds
	SuppressionDecayGray_Veteran[3]=0.200	// 5 seconds
	// R E D
	SuppressionDecayRed_Novice[0]=0.037
	SuppressionDecayRed_Novice[1]=0.037
	SuppressionDecayRed_Novice[2]=0.037
	SuppressionDecayRed_Novice[3]=0.037
	//----
	SuppressionDecayRed_Interm[0]=0.037
	SuppressionDecayRed_Interm[1]=0.037
	SuppressionDecayRed_Interm[2]=0.037
	SuppressionDecayRed_Interm[3]=0.037
	//----
	SuppressionDecayRed_Advanced[0]=0.037
	SuppressionDecayRed_Advanced[1]=0.037
	SuppressionDecayRed_Advanced[2]=0.037
	SuppressionDecayRed_Advanced[3]=0.037
	//----
	SuppressionDecayRed_Veteran[0]=0.037
	SuppressionDecayRed_Veteran[1]=0.037
	SuppressionDecayRed_Veteran[2]=0.037
	SuppressionDecayRed_Veteran[3]=0.037

	//---------------------------------------------
	// Skill-based suppression scalars: the amount of suppression "damage" applied per impulse based on the recipient's skill.
	//
	SuppressionMag_Novice[0]=1.6
	SuppressionMag_Novice[1]=0.83
	SuppressionMag_Novice[2]=0.7
	SuppressionMag_Novice[3]=0.625
	//----
	SuppressionMag_Interm[0]=0.7
	SuppressionMag_Interm[1]=0.625
	SuppressionMag_Interm[2]=0.55
	SuppressionMag_Interm[3]=0.5
	//----
	SuppressionMag_Advanced[0]=0.55
	SuppressionMag_Advanced[1]=0.5
	SuppressionMag_Advanced[2]=0.43
	SuppressionMag_Advanced[3]=0.4
	//----
	SuppressionMag_Veteran[0]=0.43
	SuppressionMag_Veteran[1]=0.4
	SuppressionMag_Veteran[2]=0.37
	SuppressionMag_Veteran[3]=0.34

	//---------------------------------------------
	// Skill-based weapon accuracy modifiers; when modifying the protection timer just isn't enough
	//
	WeaponAccuracySkillMultiplier_Novice[0]=1.4
	WeaponAccuracySkillMultiplier_Novice[1]=1.3
	WeaponAccuracySkillMultiplier_Novice[2]=1.0
	WeaponAccuracySkillMultiplier_Novice[3]=1.0
	//----
	WeaponAccuracySkillMultiplier_Interm[0]=1.3
	WeaponAccuracySkillMultiplier_Interm[1]=1.1
	WeaponAccuracySkillMultiplier_Interm[2]=0.9
	WeaponAccuracySkillMultiplier_Interm[3]=0.9
	//----
	WeaponAccuracySkillMultiplier_Advanced[0]=1.2
	WeaponAccuracySkillMultiplier_Advanced[1]=1.0
	WeaponAccuracySkillMultiplier_Advanced[2]=0.8
	WeaponAccuracySkillMultiplier_Advanced[3]=0.8
	//----
	WeaponAccuracySkillMultiplier_Veteran[0]=1.1
	WeaponAccuracySkillMultiplier_Veteran[1]=0.9
	WeaponAccuracySkillMultiplier_Veteran[2]=0.7
	WeaponAccuracySkillMultiplier_Veteran[3]=0.7

	//---------------------------------------------
	// Fatigue recovery rates
	//
//	FatigueRecovery_Novice=(Min=0.125,Max=0.125)
//	FatigueRecovery_Interm=(Min=0.154,Max=0.154)
//	FatigueRecovery_Advanced=(Min=0.182,Max=0.182)
//	FatigueRecovery_Veteran=(Min=0.25,Max=0.25)
	FatigueRecovery_Novice=(Min=0.063,Max=0.063)
	FatigueRecovery_Interm=(Min=0.077,Max=0.077)
	FatigueRecovery_Advanced=(Min=0.091,Max=0.091)
	FatigueRecovery_Veteran=(Min=0.125,Max=0.125)

	//---------------------------------------------
	// Damage modifiers
	//
	// GBX:PAD: Modifying the player damage modifier to make the easy game a little easier.
	BulletDamageModifierPlayerSP[0]=0.16	// Easy: ~4 shots
	BulletDamageModifierPlayerSP[1]=0.32	// Normal: ~4 shots
	BulletDamageModifierPlayerSP[2]=0.48	// Hard: ~4 shots
	BulletDamageModifierPlayerSP[3]=0.48	// Authentic: 1-2 shots
	BulletDamageModifierUS[0]=0.16
	BulletDamageModifierUS[1]=0.32
	BulletDamageModifierUS[2]=0.48
	BulletDamageModifierUS[3]=0.48
	BulletDamageModifierGerman[0]=1.0
	BulletDamageModifierGerman[1]=1.0
	BulletDamageModifierGerman[2]=1.0
	BulletDamageModifierGerman[3]=1.0

	ExplosiveDamageModifierPlayerSP[0]=0.36	// Easy: ~4 shots
	ExplosiveDamageModifierPlayerSP[1]=0.36	// Normal: ~4 shots
	ExplosiveDamageModifierPlayerSP[2]=0.36	// Hard: ~4 shots
	ExplosiveDamageModifierPlayerSP[3]=0.8	// Authentic: 1-2 shots
	ExplosiveDamageModifierUS[0]=0.5
	ExplosiveDamageModifierUS[1]=1.0
	ExplosiveDamageModifierUS[2]=1.0
	ExplosiveDamageModifierUS[3]=1.0
	ExplosiveDamageModifierGerman[0]=1.0
	ExplosiveDamageModifierGerman[1]=1.0
	ExplosiveDamageModifierGerman[2]=1.0
	ExplosiveDamageModifierGerman[3]=1.0

	DamageModifierPlayerSP[0]=0.36	// Easy: ~4 shots
	DamageModifierPlayerSP[1]=0.36	// Normal: ~4 shots
	DamageModifierPlayerSP[2]=0.36	// Hard: ~4 shots
	DamageModifierPlayerSP[3]=0.8	// Authentic: 1-2 shots
	DamageModifierUS[0]=1.0
	DamageModifierUS[1]=1.0
	DamageModifierUS[2]=1.0
	DamageModifierUS[3]=1.0
	DamageModifierGerman[0]=1.0
	DamageModifierGerman[1]=1.0
	DamageModifierGerman[2]=1.0
	DamageModifierGerman[3]=1.0

	//---------------------------------------------
	// Warning shot view-kick intensity and fatigue jog
	//
	WarningShotViewKickIntensity[0]=512.0
	WarningShotViewKickIntensity[1]=512.0
	WarningShotViewKickIntensity[2]=512.0
	WarningShotViewKickIntensity[3]=512.0

	WarningShotFatigueJog[0]=1.0
	WarningShotFatigueJog[1]=1.0
	WarningShotFatigueJog[2]=1.0
	WarningShotFatigueJog[3]=1.0

	DIFF_EASY=0
	DIFF_NORMAL=1
	DIFF_HARD=2
	DIFF_AUTHENTIC=3
}
// This MP specific version has its own settings 2004-04-27 JWS

class DifficultyManagerMP extends DifficultyManager
	notplaceable;

// UnitControllerAI suppression parameters
var Range PlayerShotSuppressionScalar;
var Range AIShotSuppressionScalar;
var Range OverallSuppressionScalarPlayer;
var Range OverallSuppressionScalarAI;

// FiringController parameters
var Range PauseTime_High_Novice;
var Range PauseTime_High_Interm;
var Range PauseTime_High_Advanced;
var Range PauseTime_High_Veteran;
var Range PauseTime_Low;

// Weapon parameters
var Range AIFireRateMultiplier;

// WargamePawn parameters
var float PlayerFootSpeed;

// More damage modifiers
var float DamageModifierPlayerMP[4];

// Op-burst maximum radius
var float MaxOpBurstDist;

function UpdateUnitControllerAIDefault()
{
	Super.UpdateUnitControllerAIDefault();

	class'UnitControllerAI'.Default.OverallSuppressionScalarPlayer = GetAdjustedFloat(OverallSuppressionScalarPlayer, MULT_DESCENDING);
	class'UnitControllerAI'.Default.OverallSuppressionScalarAI	   = GetAdjustedFloat(OverallSuppressionScalarAI,	  MULT_DESCENDING);
	class'UnitControllerAI'.Default.PlayerShotSuppressionScalar	   = GetAdjustedFloat(PlayerShotSuppressionScalar,	  MULT_DESCENDING);
	class'UnitControllerAI'.Default.AIShotSuppressionScalar		   = GetAdjustedFloat(AIShotSuppressionScalar,		  MULT_DESCENDING);
}

function UpdateUnitControllerAI( UnitControllerAI UnitConAI )
{
	Super.UpdateUnitControllerAI(UnitConAI);

	UnitConAI.OverallSuppressionScalarPlayer = GetAdjustedFloat(OverallSuppressionScalarPlayer, MULT_DESCENDING);
	UnitConAI.OverallSuppressionScalarAI	 = GetAdjustedFloat(OverallSuppressionScalarAI,		MULT_DESCENDING);
	UnitConAI.PlayerShotSuppressionScalar	 = GetAdjustedFloat(PlayerShotSuppressionScalar,	MULT_DESCENDING);
	UnitConAI.AIShotSuppressionScalar		 = GetAdjustedFloat(AIShotSuppressionScalar,		MULT_DESCENDING);
}

function UpdateFiringControllerDefault()
{
	Super.UpdateFiringControllerDefault();

	class'FiringControllerInfantry'.Default.PauseTime_Low			= PauseTime_Low;
	class'FiringControllerInfantry'.Default.PauseTime_High_Novice   = PauseTime_High_Novice;
	class'FiringControllerInfantry'.Default.PauseTime_High_Interm	= PauseTime_High_Interm;
	class'FiringControllerInfantry'.Default.PauseTime_High_Advanced	= PauseTime_High_Advanced;
	class'FiringControllerInfantry'.Default.PauseTime_High_Veteran	= PauseTime_High_Veteran;
}

function UpdateFiringController( FiringControllerInfantry FC )
{
	Super.UpdateFiringController(FC);

	FC.PauseTime_Low		   = PauseTime_Low;
	FC.PauseTime_High_Novice   = PauseTime_High_Novice;
	FC.PauseTime_High_Interm   = PauseTime_High_Interm;
	FC.PauseTime_High_Advanced = PauseTime_High_Advanced;
	FC.PauseTime_High_Veteran  = PauseTime_High_Veteran;
}

function UpdateGbxWeaponDefault()
{
	Super.UpdateGbxWeaponDefault();

	class'FireUSM1_'.Default.AIFireRateMP			*= GetAdjustedFloat(AIFireRateMultiplier, MULT_ASCENDING);
	class'FireUSM1Carbine'.Default.AIFireRateMP	*= GetAdjustedFloat(AIFireRateMultiplier, MULT_ASCENDING);
	class'FireUSBAR'.Default.AIFireRateMP			*= GetAdjustedFloat(AIFireRateMultiplier, MULT_ASCENDING);
	class'FireUSThompson'.Default.AIFireRateMP	*= GetAdjustedFloat(AIFireRateMultiplier, MULT_ASCENDING);
	class'FireUSColt1911_'.Default.AIFireRateMP	*= GetAdjustedFloat(AIFireRateMultiplier, MULT_ASCENDING);
	class'FireUSBazooka'.Default.AIFireRateMP		*= GetAdjustedFloat(AIFireRateMultiplier, MULT_ASCENDING);
	class'FireUSSpringfield'.Default.AIFireRateMP *= GetAdjustedFloat(AIFireRateMultiplier, MULT_ASCENDING);

	class'FireDEK98_'.Default.AIFireRateMP		*= GetAdjustedFloat(AIFireRateMultiplier, MULT_ASCENDING);
	class'FireDEK98Sniper'.Default.AIFireRateMP	*= GetAdjustedFloat(AIFireRateMultiplier, MULT_ASCENDING);
	class'FireDEMP40_'.Default.AIFireRateMP		*= GetAdjustedFloat(AIFireRateMultiplier, MULT_ASCENDING);
	class'FireDEMG42_'.Default.AIFireRateMP		*= GetAdjustedFloat(AIFireRateMultiplier, MULT_ASCENDING);
	class'FireDEHalftrackMG42_'.Default.AIFireRateMP		*= GetAdjustedFloat(AIFireRateMultiplier, MULT_ASCENDING);
	class'FireDEP38_'.Default.AIFireRateMP		*= GetAdjustedFloat(AIFireRateMultiplier, MULT_ASCENDING);
	class'FireDESTG44_'.Default.AIFireRateMP		*= GetAdjustedFloat(AIFireRateMultiplier, MULT_ASCENDING);
}

function UpdateGbxWeapon( gbxWeapon Weapon )
{
	Super.UpdateGbxWeapon(Weapon);

	Weapon.FireMode[0].AIFireRateMP *= GetAdjustedFloat(AIFireRateMultiplier, MULT_ASCENDING);
}

function UpdateMindDefault()
{
	Super.UpdateMindDefault();

	class'Mind'.Default.CombatRadius_NoOpBurst = MaxOpBurstDist;
}

function UpdateMind( Mind aMind )
{
	aMind.CombatRadius_NoOpBurst = MaxOpBurstDist;
}

function UpdateWargamePawnDefault()
{
	Super.UpdateWargamePawnDefault();

	// GBX:naj - Overwrite settings from the Super with multiplayer-specific settings.
	class'gbxPlayerPawn'.Default.LongTimerDur = GetAdjustedFloat( InitialProtectionHumanMP, MULT_DESCENDING );
	class'gbxPlayerPawn'.Default.ShortTimerDur = GetAdjustedFloat( SecondProtectionHumanMP, MULT_DESCENDING );
	class'gbxPlayerPawn'.Default.VulnerableDur = GetAdjustedFloat( VulnerableWindowHumanMP, MULT_ASCENDING );

	class'gbxPlayerPawn'.Default.GroundSpeed = PlayerFootSpeed;

	class'gbxPlayerPawn'.Default.bEnableProtectionTimers = false;
	class'InfantryUSA'.Default.bEnableProtectionTimers = false;
	class'InfantryGermany'.Default.bEnableProtectionTimers = false;
}

function UpdateWargamePawn( WargamePawn WGPawn )
{
	Super.UpdateWargamePawn(WGPawn);

	if ( WGPawn.IsA( 'gbxPlayerPawn' ) )
	{
		WGPawn.GroundSpeed = PlayerFootSpeed;
	}

	WGPawn.bEnableProtectionTimers = false;
}

function float AdjustDamage( int Damage, Pawn DamagedPawn, class<DamageType> DamageType )
{
	// GBX:naj - assuming here that only human-controlled pawns get their damage adjusted in MP games.
	if ( DamagedPawn.IsA( 'gbxPlayerPawn' ) )
	{
		return DamageModifierPlayerMP[ DifficultyAsInt ] * Damage;
	}
	else
	{
		return Damage;
	}
}

//---------------------------------------------------------
//	CanDoOpBursts
//---------------------------------------------------------
function bool CanDoOpBursts( ESkillLevel SkillLevel )
{
	if ( Difficulty == DIFF_Easy )
	{
		// On EASY, only Advanced and Veteran Germans can do op-bursts.
		return ( SkillLevel > SKILL_Intermediate );
	}
	else
	{
		// On any other difficulty level, everyone except the most novice German units can do op-bursts.
		return ( SkillLevel > SKILL_Novice );
	}
}

defaultproperties
{
	// UnitControllerAI Suppression parameters
	// Not sure how these should be affected by overall difficulty...what does that even mean for us??? 2004-06-02 JWS

	PlayerShotSuppressionScalar=(Min=1.0,Max=1.0) // Reversing the player and AI suppression bonuses as of 2004-06-02 JWS
	AIShotSuppressionScalar=(Min=1.6,Max=1.6)	

	OverallSuppressionScalarPlayer=(Min=2.6,Max=2.6) // further increases 2004-06-03 JWS
	OverallSuppressionScalarAI=(Min=3.0,Max=3.0) // further increases 2004-06-03 JWS

	// FiringController parameters
	PauseTime_Low=(Min=0.5,Max=1.0) // making these 50% of values as of 2004-06-02 JWS
	PauseTime_High_Novice=(Min=5.0,Max=7.5)
	PauseTime_High_Interm=(Min=3.0,Max=6.0)
	PauseTime_High_Advanced=(Min=2.5,Max=5.0)
	PauseTime_High_Veteran=(Min=2.0,Max=4.0)

	// Weapon parameters
	AIFireRateMultiplier=(Min=1.0,Max=1.0) // we want AI guys to fire twice as often as before 2004-06-02 JWS

	// WargamePawn parameters
	PlayerFootSpeed=450.0

	// Damage modifiers
	DamageModifierPlayerMP[0]=0.36	// Easy: ~4 shots
	DamageModifierPlayerMP[1]=0.36	// Normal: ~4 shots
	DamageModifierPlayerMP[2]=0.36	// Hard: ~4 shots
	DamageModifierPlayerMP[3]=1.0	// Authentic: 1-2 shots

	//---------------------------------------------
	// Suppression recovery rates
	//
	// G R A Y
	SuppressionDecayGray_Novice[0]=0.04
	SuppressionDecayGray_Novice[1]=0.0532
	SuppressionDecayGray_Novice[2]=0.0664
	SuppressionDecayGray_Novice[3]=0.08
	//----
	SuppressionDecayGray_Interm[0]=0.07
	SuppressionDecayGray_Interm[1]=0.0832
	SuppressionDecayGray_Interm[2]=0.0964
	SuppressionDecayGray_Interm[3]=0.11
	//----
	SuppressionDecayGray_Advanced[0]=0.09
	SuppressionDecayGray_Advanced[1]=0.1032
	SuppressionDecayGray_Advanced[2]=0.1164
	SuppressionDecayGray_Advanced[3]=0.13
	//----
	SuppressionDecayGray_Veteran[0]=0.13
	SuppressionDecayGray_Veteran[1]=0.14
	SuppressionDecayGray_Veteran[2]=0.1498
	SuppressionDecayGray_Veteran[3]=0.16
	// R E D
	SuppressionDecayRed_Novice[0]=0.07
	SuppressionDecayRed_Novice[1]=0.0799
	SuppressionDecayRed_Novice[2]=0.0898
	SuppressionDecayRed_Novice[3]=0.1
	//----
	SuppressionDecayRed_Interm[0]=0.1
	SuppressionDecayRed_Interm[1]=0.1165
	SuppressionDecayRed_Interm[2]=0.1330
	SuppressionDecayRed_Interm[3]=0.15
	//----
	SuppressionDecayRed_Advanced[0]=0.125
	SuppressionDecayRed_Advanced[1]=0.1415
	SuppressionDecayRed_Advanced[2]=0.1580
	SuppressionDecayRed_Advanced[3]=0.175
	//----
	SuppressionDecayRed_Veteran[0]=0.15
	SuppressionDecayRed_Veteran[1]=0.1665
	SuppressionDecayRed_Veteran[2]=0.1830
	SuppressionDecayRed_Veteran[3]=0.2

	//---------------------------------------------
	// Skill-based suppression scalars: the amount of suppression "damage" applied per impulse based on the recipient's skill.
	//
	SuppressionMag_Novice[0]=1.6
	SuppressionMag_Novice[1]=1.6
	SuppressionMag_Novice[2]=1.6
	SuppressionMag_Novice[3]=1.6
	//----
	SuppressionMag_Interm[0]=1.5
	SuppressionMag_Interm[1]=1.5
	SuppressionMag_Interm[2]=1.5
	SuppressionMag_Interm[3]=1.5
	//----
	SuppressionMag_Advanced[0]=1.3
	SuppressionMag_Advanced[1]=1.3
	SuppressionMag_Advanced[2]=1.3
	SuppressionMag_Advanced[3]=1.3
	//----
	SuppressionMag_Veteran[0]=1.0
	SuppressionMag_Veteran[1]=1.0
	SuppressionMag_Veteran[2]=1.0
	SuppressionMag_Veteran[3]=1.0

	MaxOpBurstDist=4500.0f
}// PSV: 4/7/2005 Skirmish specific version 

class DifficultyManagerSkirmish extends DifficultyManager
	notplaceable;

var int					iSkillSets[3];		// These skill set values are only up to date since the last call to DifficutlyChanged()

// ACCURACY
var float				fAccuracyMultiplierMin;
var float				fAccuracyMultiplierMax;
var float				fInitialProtectionHumanMultiplierMin;
var float				fInitialProtectionHumanMultiplierMax;
var float				fSecondProtectionHumanMultiplierMin;
var float				fSecondProtectionHumanMultiplierMax;
var float				fVulnerableWindowHumanMultiplierMin;
var float				fVulnerableWindowHumanMultiplierMax;
var float				fFatigueRecoveryMultiplierMin;
var float				fFatigueRecoveryMultiplierMax;

// SUPPRESSION
var float				fSuppressionDecayGrayMultiplierMin;
var float				fSuppressionDecayGrayMultiplierMax;
var float				fSuppressionMagMultiplierMin;
var float				fSuppressionMagMultiplierMax;

// Override SP settings as necessary
// Eventually there will be support here for the difficutly sliders that are planned for the game: Supression, Accuracy, and Tactics
// Each one of these sliders will affect one or more of the rules defined in the base Difficulty Manager.

//---------------------------------------------------------
//	DifficultyChanged - INTERNAL USE ONLY
//---------------------------------------------------------
function DifficultyChanged()
{
	local Actor AnActor;

	Log( " DifficultyManagerSkirmish::DifficultyChanged()", 'MP' );
	
	// Get the latest skill set values from WargameSkirmish
	WargameSkirmish(Level.Game).GetSkillValues(iSkillSets);

	// Change all the default values for each class type.
	UpdateMindDefault();
	UpdateWargamePawnDefault();
	UpdateFiringControllerDefault();
	UpdateUnitControllerAIDefault();
	UpdateGbxWeaponDefault();

	// Iterate over all Minds, UnitControllerAIs, FiringControllers, and gbxWeapons.
	// Change their various values based on the difficulty level.
	foreach DynamicActors( class'Actor', AnActor )
	{
		if ( AnActor.IsA( 'Mind' ) )
		{
			UpdateMind( Mind( AnActor ) );
		}
		if ( AnActor.IsA( 'WargamePawn' ) )
		{
			UpdateWargamePawn( WargamePawn( AnActor ) );
		}
		else if ( AnActor.IsA( 'gbxWeapon' ) )
		{
			UpdateGbxWeapon( gbxWeapon( AnActor ) );
		}
		else if ( AnActor.IsA( 'FiringControllerInfantry' ) )
		{
			UpdateFiringController( FiringControllerInfantry( AnActor ) );
		}
		else if ( AnActor.IsA( 'UnitControllerAI' ) )
		{
			UpdateUnitControllerAI( UnitControllerAI( AnActor ) );			
		}
	}
}

//---------------------------------------------------------
//	UpdateMindDefault - INTERNAL USE ONLY
//---------------------------------------------------------
function UpdateMindDefault()
{
	local int accuracySlider;
	local float accuracy, range;

	// This is the value from WargameSkirmish (set in the lobby) or during a defend game.
	accuracySlider = iSkillSets[0];
	
	range = fAccuracyMultiplierMax - fAccuracyMultiplierMin;
	accuracy = fAccuracyMultiplierMax - ((float(accuracySlider)/9) * range);

	Log( " DifficultyManagerSkirmish::UpdateMindDefault() accuracySlider="$accuracySlider$ " accuracy="$accuracy$" range="$range, 'MP' );

	class'Mind'.Default.WeaponAccuracyModifierSP_Novice = accuracy;
	class'Mind'.Default.WeaponAccuracyModifierSP_Interm = accuracy;
	class'Mind'.Default.WeaponAccuracyModifierSP_Advanced = accuracy;
	class'Mind'.Default.WeaponAccuracyModifierSP_Veteran = accuracy;
}

//---------------------------------------------------------
//	UpdateMind - INTERNAL USE ONLY
//---------------------------------------------------------
function UpdateMind( Mind aMind )
{
	local int accuracySlider;
	local float accuracy, range;

	Log( " DifficultyManagerSkirmish::UpdateMind()", 'MP' );

	// This is the value from WargameSkirmish (set in the lobby) or during a defend game.
	accuracySlider = iSkillSets[0];
	
	range = fAccuracyMultiplierMax - fAccuracyMultiplierMin;
	accuracy = fAccuracyMultiplierMax - ((float(accuracySlider)/9) * range);

	Log( " DifficultyManagerSkirmish::UpdateMind() accuracySlider="$accuracySlider$ " accuracy="$accuracy$" range="$range, 'MP' );

	aMind.WeaponAccuracyModifierSP_Novice = accuracy;
	aMind.WeaponAccuracyModifierSP_Interm = accuracy;
	aMind.WeaponAccuracyModifierSP_Advanced = accuracy;
	aMind.WeaponAccuracyModifierSP_Veteran = accuracy;
}

//---------------------------------------------------------
//	UpdateWargamePawnDefault - INTERNAL USE ONLY
//---------------------------------------------------------
function UpdateWargamePawnDefault()
{
	local int accuracySlider;
	local float Initialprotection, SecondProtection, FatigueRecoveryRate, range;

	Log( " DifficultyManager::UpdateWargamePawnDefault()", 'MP' );

	// This is the value from WargameSkirmish (set in the lobby) or during a defend game.
	accuracySlider = iSkillSets[0];
	
	range = fInitialProtectionHumanMultiplierMax - fInitialProtectionHumanMultiplierMin;
	Initialprotection = fInitialProtectionHumanMultiplierMax - ((float(accuracySlider)/9) * range);

	range = fSecondProtectionHumanMultiplierMax - fSecondProtectionHumanMultiplierMin;
	SecondProtection = fSecondProtectionHumanMultiplierMax - ((float(accuracySlider)/9) * range);

	Log( " DifficultyManagerSkirmish::UpdateWargamePawnDefault() accuracySlider="$accuracySlider$ " InitialProtection="$Initialprotection$" SecondProtection="$SecondProtection$" range="$range, 'MP' );

	// Protection Timer settings
	class'gbxPlayerPawn'.Default.LongTimerDur = InitialProtection;
	// These values are the same across the board
	class'InfantryUSA'.Default.LongTimerDur = GetAdjustedFloat( InitialProtectionUS, MULT_DESCENDING );
	class'InfantryGermany'.Default.LongTimerDur = GetAdjustedFloat( InitialProtectionGerman, MULT_ASCENDING );

	class'gbxPlayerPawn'.Default.ShortTimerDur = SecondProtection;
	// These values are the same across the board
	class'InfantryUSA'.Default.ShortTimerDur = GetAdjustedFloat( SecondProtectionUS, MULT_DESCENDING );
	class'InfantryGermany'.Default.ShortTimerDur = GetAdjustedFloat( SecondProtectionGerman, MULT_ASCENDING );

	// These values are the same across the board
	class'gbxPlayerPawn'.Default.VulnerableDur = VulnerableWindowHumanSP[ DifficultyAsInt ];
	class'InfantryUSA'.Default.VulnerableDur = GetAdjustedFloat( VulnerableWindowUS, MULT_ASCENDING );
	class'InfantryGermany'.Default.VulnerableDur = GetAdjustedFloat( VulnerableWindowGerman, MULT_ASCENDING );

	// These values are the same across the board
	class'gbxPlayerPawn'.Default.TimerTotalDur = ProtectionTimerTotalDur;
	class'InfantryUSA'.Default.TimerTotalDur = ProtectionTimerTotalDur;
	class'InfantryGermany'.Default.TimerTotalDur = ProtectionTimerTotalDur;
	
	// Turn on protection for players.
	class'gbxPlayerPawn'.Default.bEnableProtectionTimers = true;
	// Turn off protection timers for USA/German AI pawns.
	class'InfantryUSA'.Default.bEnableProtectionTimers = false;
	class'InfantryGermany'.Default.bEnableProtectionTimers = false;

	range = fFatigueRecoveryMultiplierMax - fFatigueRecoveryMultiplierMin;
	FatigueRecoveryRate = fFatigueRecoveryMultiplierMin + ((float(accuracySlider)/9) * range);

	Log( " DifficultyManagerSkirmish::UpdateWargamePawnDefault() accuracySlider="$accuracySlider$ " FatigueRecoveryRate="$FatigueRecoveryRate$" range="$range, 'MP' );

	// Fatigue recovery rates.
	class'WargamePawn'.Default.FatigueRecovery_Novice		= FatigueRecoveryRate;
	class'WargamePawn'.Default.FatigueRecovery_Interm		= FatigueRecoveryRate;
	class'WargamePawn'.Default.FatigueRecovery_Advanced	= FatigueRecoveryRate;
	class'WargamePawn'.Default.FatigueRecovery_Veteran	= FatigueRecoveryRate;
}

//---------------------------------------------------------
//	UpdateWargamePawn - INTERNAL USE ONLY
//---------------------------------------------------------
function UpdateWargamePawn( WargamePawn WGPawn )
{
	local int accuracySlider;
	local float Initialprotection, SecondProtection, FatigueRecoveryRate, range;

	Log( " DifficultyManager::UpdateWargamePawn() WGPawn="$WGPawn, 'MP' );

	// This is the value from WargameSkirmish (set in the lobby) or during a defend game.
	accuracySlider = iSkillSets[0];
	
	range = fInitialProtectionHumanMultiplierMax - fInitialProtectionHumanMultiplierMin;
	Initialprotection = fInitialProtectionHumanMultiplierMax - ((float(accuracySlider)/9) * range);

	range = fSecondProtectionHumanMultiplierMax - fSecondProtectionHumanMultiplierMin;
	SecondProtection = fSecondProtectionHumanMultiplierMax - ((float(accuracySlider)/9) * range);

	Log( " DifficultyManagerSkirmish::UpdateWargamePawn() accuracySlider="$accuracySlider$ " InitialProtection="$Initialprotection$" SecondProtection="$SecondProtection$" range="$range, 'MP' );

	// Protection Timer Settings.
	if ( WGPawn.IsA( 'gbxPlayerPawn' ) )
	{
		WGPawn.bEnableProtectionTimers = true;	// Turn on protection for players.
		WGPawn.LongTimerDur = InitialProtection;
		WGPawn.ShortTimerDur = SecondProtection;
		WGPawn.VulnerableDur = VulnerableWindowHumanSP[ DifficultyAsInt ];		// This value is the same across the board
	}
	else if ( Level.Game.IsPawnOnSameTeamAsPlayer( WGPawn ) )
	{
		WGPawn.bEnableProtectionTimers = false;	// Turn off protection for US AI pawns.
		WGPawn.LongTimerDur = GetAdjustedFloat( InitialProtectionUS, MULT_DESCENDING );
		WGPawn.ShortTimerDur = GetAdjustedFloat( SecondProtectionUS, MULT_DESCENDING );
		WGPawn.VulnerableDur = GetAdjustedFloat( VulnerableWindowUS, MULT_ASCENDING );
	}
	else if ( !Level.Game.IsPawnOnSameTeamAsPlayer( WGPawn ) )
	{
		WGPawn.bEnableProtectionTimers = false;	// Turn off protection for German AI pawns.
		WGPawn.Default.LongTimerDur = GetAdjustedFloat( InitialProtectionGerman, MULT_ASCENDING );
		WGPawn.Default.ShortTimerDur = GetAdjustedFloat( SecondProtectionGerman, MULT_ASCENDING );
		WGPawn.VulnerableDur = GetAdjustedFloat( VulnerableWindowGerman, MULT_ASCENDING );
	}
	
	WGPawn.TimerTotalDur = ProtectionTimerTotalDur;
	WGPawn.ClearProtectionTimer();

	range = fFatigueRecoveryMultiplierMax - fFatigueRecoveryMultiplierMin;
	FatigueRecoveryRate = fFatigueRecoveryMultiplierMin + ((float(accuracySlider)/9) * range);

	Log( " DifficultyManagerSkirmish::UpdateWargamePawn() accuracySlider="$accuracySlider$ " FatigueRecoveryRate="$FatigueRecoveryRate$" range="$range, 'MP' );

	// Fatigue recovery rates.
	WGPawn.FatigueRecovery_Novice	= FatigueRecoveryRate;
	WGPawn.FatigueRecovery_Interm	= FatigueRecoveryRate;
	WGPawn.FatigueRecovery_Advanced	= FatigueRecoveryRate;
	WGPawn.FatigueRecovery_Veteran	= FatigueRecoveryRate;
}

//---------------------------------------------------------
//	UpdateUnitControllerAIDefault - INTERNAL USE ONLY
//---------------------------------------------------------
function UpdateUnitControllerAIDefault()
{
	local int suppressionSlider;
	local float suppression, range;

	Log( " DifficultyManagerSkirmish::UpdateUnitControllerAIDefault()", 'MP' );

	// This is the value from WargameSkirmish (set in the lobby) or during a defend game.
	suppressionSlider = iSkillSets[2];
	
	range = fSuppressionDecayGrayMultiplierMax - fSuppressionDecayGrayMultiplierMin;
	suppression = fSuppressionDecayGrayMultiplierMin + ((float(suppressionSlider)/9) * range);

	Log( " DifficultyManagerSkirmish::UpdateUnitControllerAIDefault() suppressionSlider="$suppressionSlider$ " suppressionGrey="$suppression$" range="$range, 'MP' );
	
	// Suppression recovery rates.
	class'UnitControllerAI'.Default.SuppressionDecayGray_Novice		= suppression;
	class'UnitControllerAI'.Default.SuppressionDecayGray_Interm		= suppression;
	class'UnitControllerAI'.Default.SuppressionDecayGray_Advanced	= suppression;
	class'UnitControllerAI'.Default.SuppressionDecayGray_Veteran	= suppression;

	// Suppression recovery rates.
	class'UnitControllerAIInfantry'.Default.SuppressionDecayGray_Novice		= suppression;
	class'UnitControllerAIInfantry'.Default.SuppressionDecayGray_Interm		= suppression;
	class'UnitControllerAIInfantry'.Default.SuppressionDecayGray_Advanced	= suppression;
	class'UnitControllerAIInfantry'.Default.SuppressionDecayGray_Veteran	= suppression;

	range = fSuppressionMagMultiplierMax - fSuppressionMagMultiplierMin;
	suppression = fSuppressionMagMultiplierMax - ((float(suppressionSlider)/9) * range);

	Log( " DifficultyManagerSkirmish::UpdateUnitControllerAIDefault() suppressionSlider="$suppressionSlider$ " suppressionMag="$suppression$" range="$range, 'MP' );

	// Skill-based suppression 'magnifiers'.
	class'UnitControllerAI'.Default.SuppressionMag_Novice			= suppression;
	class'UnitControllerAI'.Default.SuppressionMag_Interm			= suppression;
	class'UnitControllerAI'.Default.SuppressionMag_Advanced			= suppression;
	class'UnitControllerAI'.Default.SuppressionMag_Veteran			= suppression;
	
	// Skill-based suppression 'magnifiers'.
	class'UnitControllerAIInfantry'.Default.SuppressionMag_Novice			= suppression;
	class'UnitControllerAIInfantry'.Default.SuppressionMag_Interm			= suppression;
	class'UnitControllerAIInfantry'.Default.SuppressionMag_Advanced			= suppression;
	class'UnitControllerAIInfantry'.Default.SuppressionMag_Veteran			= suppression;

	// These values are the same across the board
	class'UnitControllerAI'.Default.SuppressionDecayRed_Novice		= SuppressionDecayRed_Novice[ DifficultyAsInt ];
	class'UnitControllerAI'.Default.SuppressionDecayRed_Interm		= SuppressionDecayRed_Interm[ DifficultyAsInt ];
	class'UnitControllerAI'.Default.SuppressionDecayRed_Advanced	= SuppressionDecayRed_Advanced[ DifficultyAsInt ];
	class'UnitControllerAI'.Default.SuppressionDecayRed_Veteran		= SuppressionDecayRed_Veteran[ DifficultyAsInt ];

	// These values are the same across the board
	class'UnitControllerAIInfantry'.Default.SuppressionDecayRed_Novice		= SuppressionDecayRed_Novice[ DifficultyAsInt ];
	class'UnitControllerAIInfantry'.Default.SuppressionDecayRed_Interm		= SuppressionDecayRed_Interm[ DifficultyAsInt ];
	class'UnitControllerAIInfantry'.Default.SuppressionDecayRed_Advanced	= SuppressionDecayRed_Advanced[ DifficultyAsInt ];
	class'UnitControllerAIInfantry'.Default.SuppressionDecayRed_Veteran		= SuppressionDecayRed_Veteran[ DifficultyAsInt ];
}


//---------------------------------------------------------
//	UpdateUnitControllerAI - INTERNAL USE ONLY
//---------------------------------------------------------
function UpdateUnitControllerAI( UnitControllerAI UnitConAI )
{
	local int suppressionSlider;
	local float suppression, range;

	Log( " DifficultyManagerSkirmish::UpdateUnitControllerAI()", 'MP' );

	// This is the value from WargameSkirmish (set in the lobby) or during a defend game.
	suppressionSlider = iSkillSets[2];
	
	range = fSuppressionDecayGrayMultiplierMax - fSuppressionDecayGrayMultiplierMin;
	suppression = fSuppressionDecayGrayMultiplierMin + ((float(suppressionSlider)/9) * range);

	Log( " DifficultyManagerSkirmish::UpdateUnitControllerAI() suppressionSlider="$suppressionSlider$ " suppressionGrey="$suppression$" range="$range, 'MP' );
	
	// Suppression recovery rates.
	UnitConAI.SuppressionDecayGray_Novice		= suppression;
	UnitConAI.SuppressionDecayGray_Interm		= suppression;
	UnitConAI.SuppressionDecayGray_Advanced		= suppression;
	UnitConAI.SuppressionDecayGray_Veteran		= suppression;

	range = fSuppressionMagMultiplierMax - fSuppressionMagMultiplierMin;
	suppression = fSuppressionMagMultiplierMax - ((float(suppressionSlider)/9) * range);

	Log( " DifficultyManagerSkirmish::UpdateUnitControllerAIDefault() suppressionSlider="$suppressionSlider$ " suppressionMag="$suppression$" range="$range, 'MP' );

	// Skill-based suppression 'magnifiers'.
	UnitConAI.SuppressionMag_Novice				= suppression;
	UnitConAI.SuppressionMag_Interm				= suppression;
	UnitConAI.SuppressionMag_Advanced			= suppression;
	UnitConAI.SuppressionMag_Veteran			= suppression;

	// These values are the same across the board
	UnitConAI.SuppressionDecayRed_Novice		= SuppressionDecayRed_Novice[ DifficultyAsInt ];
	UnitConAI.SuppressionDecayRed_Interm		= SuppressionDecayRed_Interm[ DifficultyAsInt ];
	UnitConAI.SuppressionDecayRed_Advanced		= SuppressionDecayRed_Advanced[ DifficultyAsInt ];
	UnitConAI.SuppressionDecayRed_Veteran		= SuppressionDecayRed_Veteran[ DifficultyAsInt ];
}

//---------------------------------------------------------
//	AdjustDamage
//---------------------------------------------------------
// This function is called through the Pawn.TakeDamage() chain.  It adjusts the actual damage done by 
// shots based on what type of pawn the victim is.
function float AdjustDamage( int Damage, Pawn DamagedPawn, class<DamageType> DamageType )
{
	local float AdjDamage;
	Log( " DifficultyManagerSkirmish::AdjustDamage() Damage="$Damage$" DamagedPawn="$DamagedPawn$" DamageType="$DamageType, 'MP' );
	
	// 5/31/2005 MikeW wants the damage modifier always to be set to what the normal difficulty uses

	if (DamageType.Default.m_bBulletDamage)
	{
		if ( DamagedPawn.IsA( 'gbxPlayerPawn' ) )
		{
			AdjDamage = BulletDamageModifierPlayerSP[ DIFF_NORMAL ] * Damage;
		}
		else if ( Level.Game.IsPawnOnSameTeamAsPlayer( DamagedPawn ) )
		{
			AdjDamage = BulletDamageModifierUS[ DIFF_NORMAL ] * Damage;
		}
		else if ( !Level.Game.IsPawnOnSameTeamAsPlayer( DamagedPawn ) )
		{
			AdjDamage = BulletDamageModifierGerman[ DIFF_NORMAL ] * Damage;
		}
		else
		{
			AdjDamage = Damage;
		}
	}
	else if (DamageType.Default.m_bExplosiveDamage)
	{
		if ( DamagedPawn.IsA( 'gbxPlayerPawn' ) )
		{
			AdjDamage = ExplosiveDamageModifierPlayerSP[ DIFF_NORMAL ] * Damage;
		}
		else if ( Level.Game.IsPawnOnSameTeamAsPlayer( DamagedPawn ) )
		{
			AdjDamage = ExplosiveDamageModifierUS[ DIFF_NORMAL ] * Damage;
		}
		else if ( !Level.Game.IsPawnOnSameTeamAsPlayer( DamagedPawn ) )
		{
			AdjDamage = ExplosiveDamageModifierGerman[ DIFF_NORMAL ] * Damage;
		}
		else
		{
			AdjDamage = Damage;
		}
	}
	else
	{
		if ( DamagedPawn.IsA( 'gbxPlayerPawn' ) )
		{
			AdjDamage = DamageModifierPlayerSP[ DIFF_NORMAL ] * Damage;
		}
		else if ( Level.Game.IsPawnOnSameTeamAsPlayer( DamagedPawn ) )
		{
			AdjDamage = DamageModifierUS[ DIFF_NORMAL ] * Damage;
		}
		else if ( !Level.Game.IsPawnOnSameTeamAsPlayer( DamagedPawn ) )
		{
			AdjDamage = DamageModifierGerman[ DIFF_NORMAL ] * Damage;
		}
		else
		{
			AdjDamage = Damage;
		}
	}
	
	Log( " DifficultyManagerSkirmish::AdjustDamage() AdjDamage="$AdjDamage, 'MP' );

	return AdjDamage;
}

//=========================================================
//	Polled functions
//=========================================================

//---------------------------------------------------------
//	CanDoOpBursts
//---------------------------------------------------------
function bool CanDoOpBursts( ESkillLevel SkillLevel )
{
	//Log( " DifficultyManagerSkirmish::CanDoOpBursts() Difficulty="$Difficulty$" SkillLevel="$SkillLevel, 'MP' );

	// 5/31/2005 MikeW wants this to always be true.
	return true;
}

defaultproperties
{
	// ACCURACY
	fAccuracyMultiplierMin = 0.01			// veteran authentic ++
	fAccuracyMultiplierMax = 1.0			// easy novice
	fInitialProtectionHumanMultiplierMin = 1.0	// authentic
	fInitialProtectionHumanMultiplierMax = 5.0	// novice
	fSecondProtectionHumanMultiplierMin = 0.0	// authentic
	fSecondProtectionHumanMultiplierMax = 4.0	// novice
	fFatigueRecoveryMultiplierMin = 0.125		// novice
	fFatigueRecoveryMultiplierMax = 0.25		// veteran
	
	// SUPPRESSION
	fSuppressionDecayGrayMultiplierMin = 0.067	// easy novice
	fSuppressionDecayGrayMultiplierMax = 0.4	// veteran authentic 2.5 seconds
	fSuppressionMagMultiplierMin = 0.34	// veteran authentic ++
	fSuppressionMagMultiplierMax = 1.6		// easy novice
}class DumbMind extends Mind;



//
// DumbMind is an AIController with NO AI at all, it just spawns FiringController and NavigationController
//

function PostNetBeginPlay()
{
	Super(gbxAIController).PostNetBeginPlay();

	NavigationController = Spawn( NavigationControllerClass );
	NavigationController.SetMind(Self);

	FiringController = Spawn( FiringControllerClass );
	FiringController.SetMind(Self);
	FiringController.SetNavController(NavigationController);
}

function Possess(Pawn aPawn)
{
	Super(gbxAIController).Possess(aPawn);

	Pawn.SetMovementPhysics();
	if (Pawn.Physics == PHYS_Walking)
		Pawn.SetPhysics(PHYS_Falling);

	ClientSwitchToBestWeapon();

	WGPawn = WargamePawn( aPawn );

	if (FiringController != None)
	{
		FiringController.Possess(aPawn);
	}

	if (NavigationController != None)
	{
		NavigationController.Possess(WGPawn);
	}

	SetFacingPolicy(FACE_Destination);
}

function DisplayDebug(Canvas Canvas, out float YL, out float YPos)
{
}

function DisplayDebugSpecial( HUD H )
{
}

function PawnDied(Pawn P)
{
	Super(gbxAIController).PawnDied( P );

	if( P != WGPawn )
	{
		Log( "WARNING: " $ Name $ "(" $ Pawn.Name $ ").PawnDied( " $ P $ " ) called for P != WGPawn.", 'Mind' );
		return;
	}

	// Pawn should leave unit.
	WGPawn.MyUnit.RemoveMember( WGPawn );

	Destroy();
}

function Destroyed()
{
	// Destroy assistants too.

	FiringController.Destroy();
	NavigationController.Destroy();

	Super(gbxAIController).Destroyed();
}

auto state Maneuvering
{
}

function ManeuverComplete()
{
}

function ManeuverFailed()
{
}

function CoverFound(ECoverType CoverTypeFound, ActorLite NavPoint, int NumThreatsCovered)
{
}

function NoCoverFound()
{
}

/// POSTURE RELATED /////////////////////////////////////////////////////

function RequestPawnToStand()
{
	// stand up (unless there's a reason not to)...
	WGPawn.StartGoingToStand();
}

function RequestPawnToCrouch()
{
	// change to crouching (unless there's a reason not to)...
	WGPawn.StartGoingToCrouch();
}

function RequestPawnToGoProne()
{
	// go prone (unless there's a reason not to)...
//DISABLED	WGPawn.StartGoingToProne();
}

defaultproperties
{
	bHidden=true

	bIsPlayer=true
	TimerInterval=0.5

	FiringControllerClass=class'FiringControllerInfantry'
	NavigationControllerClass=class'NavigationController'
}
//=============================================================================
// Interface class for all firing controllers.  These classes are responsible 
// for managing weapon firing.  Instances of FiringControllerBase-derived classes
// are owned by Mind.
//
// Author: Neil Johnson, Gearbox Software.
//=============================================================================
class FiringControllerBase extends Actor
	native
	abstract
	notplaceable;

cpptext
{
	UBOOL DoWarningShot( float DistToTarget ) { return ( DistToTarget > MyMind->CombatRadius_NoWarningShots ) && Target->DoWarningShot(); }
	UBOOL DoDeadlock( AgbxPawn* pTarget, float DistToTarget );

#ifndef SHIP
protected:
	void LogSelective( const TCHAR* msg );
#endif
}

//---------------------------------------------------------
//	Variables / Constants
//---------------------------------------------------------
var gbxPawn					Pawn;						// The Pawn controlled by this firing controller.
var gbxPawn					Target;						// The controller's current target.
var gbxPawn					BlockingFriendly;			// A friendly Pawn who is in the way of this Pawn's shot.
var gbxWeapon				TheWeapon;					// The weapon currently being used by this FiringController.
var Mind					MyMind;						// Mind that possesses the Pawn.
var NavigationController	NavController;				// The aMind's navigation controller.
var bool					bWaitForTimer;				// Flag for use with the Timer() function.
var bool					bWaitForCallback;			// Whether to keep waiting for a callback from the nav. controller.
var bool					bLogSelect;					// DEBUG VAR
var bool					bDontInterruptMe;			// Prevents outsiders from yanking us out of the current state.
var bool					bNoAccuracyAdjust;
var bool					bBurstInterrupted;
var bool					bGoingToAssault;
var config bool				NoShow;
var int						BurstCount;					// Number of bullets to fire (non-turret weapons only)
var int						IsHeadShot;					// Whether SeeLoc refers to a headshot ( 0 == torso shot ).
var float					BurstLength;				// Length (in seconds) of a turret-weapon burst.
var float					PauseTime;					// Time to wait behind cover before shooting again
var float					LastSuccessfulShotTime;
var float					SecondsBeforeKillingBurst;
var float					FFBufferDist;
var float					FFConeThresh;
var float					FFSuperCloseRadius;
var float					FFSuperCloseConeThresh;
var Name					StateInfoLabel;	// Used with DisplayDebug to show the current state subsection.
var Name					PendingStateChange;
var Name					PawnToWatch;		// DEBUG VAR
var String					MyLogSelectName;
var Vector					SeeLoc;				// Location on the target's body at which to shoot.
var Vector					SuppressLoc;		// Location at which to lay down suppressing fire.
var Vector					FailLoc;
var Vector					TargetLastKnownLoc;
var ETargetFailure			TargetFailureCode;
var Range					PauseTime_High_Novice;
var Range					PauseTime_High_Interm;
var Range					PauseTime_High_Advanced;
var Range					PauseTime_High_Veteran;
var Range					PauseTime_Low;							// Pause time in seconds for low suppression when firing from cover.
var Range					PauseTime_HumanControlledSP;			// Pause time in seconds for human-controlled pawns 
var Range					PauseTime_HumanControlledSP_Targeting;	// Pause time in seconds for human-controlled pawns when a Target order is issued (but after the initial op-burst)
var Range					PauseTime_HumanControlledMP;
var Range					PauseTime_HumanControlledMP_Targeting;


//---------------------------------------------------------
//	LogSelective
//---------------------------------------------------------
// Selective logging function.  Use this in place of Log() wherever possible.
// Using the "logselect" console command at runtime causes only those log messages
// that pertain to an individual pawn to be printed out.
//
function LogSelective( String msg )
{
	if ( bLogSelect )
	{ 
		if ( PawnToWatch == '' || PawnToWatch == Pawn.Name )
			log( MyLogSelectName$": NAJ**** "$Pawn.Name$" ["$GetStateName()$"]: "$msg, 'naj');
		else
		if ( PawnToWatch == 'InfantryUSA' && Pawn.IsA( 'InfantryUSA' ) )
			log( MyLogSelectName$": NAJ**** "$Pawn.Name$" ["$GetStateName()$"]: "$msg, 'naj' );
		else
		if ( PawnToWatch == 'InfantryGermany' && Pawn.IsA( 'InfantryGermany' ) )
			log( MyLogSelectName$": NAJ**** "$Pawn.Name$" ["$GetStateName()$"]: "$msg, 'naj' );
	}
}

function Destroyed()
{
	Pawn = None;  // prevent references to/in destroyed objects
	Target = None;
	BlockingFriendly = None;
	TheWeapon = None;
	MyMind = None;
	NavController = None;

    super.Destroyed();
}

//---------------------------------------------------------
//	SetPawnToWatch
//---------------------------------------------------------
function SetPawnToWatch( Name APawnToWatch )
{
	if ( APawnToWatch != '' )
	{
		bLogSelect = true;
		Default.bLogSelect = true;
		PawnToWatch = APawnToWatch;
		Default.PawnToWatch = APawnToWatch;		
	}
	else
	{
		bLogSelect = false;
		Default.bLogSelect = false;
	}	
}

//---------------------------------------------------------
//	EnsureWeaponIsCurrent
//---------------------------------------------------------
// Place code in this function to make sure that TheWeapon is always
// set to the weapon that you want this FiringController to work with.
//
function EnsureWeaponIsCurrent() {}	// Implement me.

function UpdateTargetKnownLocation( optional out float TargetDistance )
{
	if ( Target != None && MyMind != None )
	{
		TargetLastKnownLoc = MyMind.GetLastKnownLocation( Target, TargetDistance );
	}
}

//---------------------------------------------------------
//	Tick
//---------------------------------------------------------
function Tick( float DeltaTime )
{
	Super.Tick( DeltaTime );

	EnsureWeaponIsCurrent();
}

//---------------------------------------------------------
//	SetMind
//---------------------------------------------------------
function SetMind(Mind NewMind)
{
	MyMind = NewMind;
}

//---------------------------------------------------------
//	SetNavController
//---------------------------------------------------------
function SetNavController(NavigationController NewNavController)
{
	NavController = NewNavController;
}

//---------------------------------------------------------
//	Possess
//---------------------------------------------------------
function Possess(Pawn aPawn)
{
	if (aPawn.IsA('gbxPawn'))
	{
		Pawn = gbxPawn(aPawn);
	}
}

//---------------------------------------------------------
//	DontInterruptMe
//---------------------------------------------------------
function DontInterruptMe() {}

//---------------------------------------------------------
//	OKToInterruptMe
//---------------------------------------------------------
function OKToInterruptMe() {}

//---------------------------------------------------------
//	NotifyTargetFailureMind
//---------------------------------------------------------
function NotifyTargetFailureMind( ETargetFailure FailureCode, optional gbxPawn Blocker )
{
	LogSelective( "NotifyTargetFailureMind(): "$FailureCode$" ; bGoingToAssault: "$bGoingToAssault );
	if ( !bGoingToAssault )
	{
		MyMind.NotifyTargetFailure( Target, FailureCode, Blocker );
	}
}

//---------------------------------------------------------
//	ApproveShot
//---------------------------------------------------------
function bool ApproveShot( Rotator AimRotator )
{
	return true;
}

//---------------------------------------------------------
//	ReactToAllyBlocking
//---------------------------------------------------------
function ReactToAllyBlocking( gbxPawn BlockingActor )
{
	// Override/expand in state code.
}

//---------------------------------------------------------
//	CalculateDistToTarget
//---------------------------------------------------------
function float CalculateDistToTarget()
{
	return VSize( TargetLastKnownLoc - Pawn.Location );
}

//---------------------------------------------------------
//	SnapAimRotator
//---------------------------------------------------------
function SnapAimRotator( out Rotator AimRotator, Vector ToTarget )
{
	AimRotator = Rotator( ToTarget );
}

//---------------------------------------------------------
//	DoWarningShot
//---------------------------------------------------------
function bool DoWarningShot( float DistToTarget )
{
	return ( DistToTarget > MyMind.CombatRadius_NoWarningShots ) && Target.DoWarningShot();
}

//---------------------------------------------------------
//	AdjustAimNew
//---------------------------------------------------------
native function Rotator AdjustAimNew( Ammunition Ammo, Vector ProjStart, Rotator AimRotator, optional out int bSkipDoTrace );

//---------------------------------------------------------
//	DoDeadlock
//---------------------------------------------------------
function bool DoDeadlock( float DistToTarget )
{
	// Conditions for doing deadlock:
	// 1) Target is not a player pawn;
	// 2) Target is at a cover point;
	// 3) That cover point provides crouched protection from the shooter.
	// 4) Target is further away than a distance threshold;
	//
	// Results:
	// The shooter misses the target (but not by much!)

	local ActorLite TargetCoverPoint;

	if ( Target.IsHumanControlled() )
	{
		return false;
	}

	if ( Target.IsCoveredFrom( Pawn.Location, TargetCoverPoint ) && DistToTarget >= MyMind.CombatRadius_Deadlock ) 
	{
		return true;
	}

	return false;
}

//---------------------------------------------------------
//	DoPurposefulMiss
//---------------------------------------------------------
event Rotator DoPurposefulMiss( Vector ProjStart, Vector TargetLoc, gbxPawn MissTarget, optional out int bSkipDoTrace )
{
	local Vector ToTarget, TargetFacing, PerpVector, BestMissLoc, NextBestMissLoc;
	local bool bTargetFacingAway, bTargetFacingRight;
	local Rotator TempRot;

	ToTarget = Normal( TargetLoc - ProjStart );

	// Do a purposeful miss.  Here's the logic:
	// If we can only see the target's head, shoot to the right or left of the head.
	// If we can see the target's center-of-mass,
	// shoot at the ground in front of the target's feet.

	// Before we get started, mark this bullet as a "purposeful miss" bullet,
	// which prevents it from causing any damage, should something go wrong and this bullet actually hit someone.
	TheWeapon.SetNoDamageThisBullet();

	// First, find what direction the target is facing.
	if (Target.IsHumanControlled())
	{
		TempRot = Target.Rotation;
		TempRot.Pitch = 0;
		TargetFacing = Vector( TempRot );
		PerpVector = ToTarget cross Vect(0,0,1);

		if ( TargetFacing dot Normal( ToTarget ) > 0 )
			bTargetFacingAway = true;
		if ( TargetFacing dot PerpVector > 0 )
			bTargetFacingRight = true;
	}
	else
	{
		// if Target is not a human player, just pick a random side of Target to fire towards...
		if (Rand(2) == 0)
			bTargetFacingRight = true;
		else
			bTargetFacingRight = false;
	}

	// Get the "fall back" miss location, in case the ideal miss location is unusable.
	NextBestMissLoc = Target.Location;
	NextBestMissLoc.Z += (Target.BaseEyeHeight + 25.0);

	if ( bTargetFacingRight )
		BestMissLoc = TargetLoc + 100.0 * PerpVector;
	else
		BestMissLoc = TargetLoc - 100.0 * PerpVector;

	// Adjust the miss-location upward/downward randomly.
	if ( Rand(2) == 0 )
		BestMissLoc.Z -= Rand(100);
	else
		BestMissLoc.Z += Rand(100);

	// Adjust the miss-location X and Y offset...
	BestMissLoc.X += (FRand() * 100.0) - 50.0;  // offset +/- 50.0 units
	BestMissLoc.Y += (FRand() * 100.0) - 50.0;  // offset +/- 50.0 units

	// Do a last-minute muzzle check on the ideal miss location.
	if ( !ShotHitsPawn( BestMissLoc ) )
	{
		return Rotator( BestMissLoc - ProjStart );
	}
	else
	if ( !ShotHitsPawn( NextBestMissLoc ) )
	{
		return Rotator( NextBestMissLoc - ProjStart );
	}
	else
	{
		// TBD: indicate to caller NOT to do damage.
		bSkipDoTrace = 1;
		return Rotator( NextBestMissLoc - ProjStart );
	}
}

//---------------------------------------------------------
//	ShotHitsPawn
//---------------------------------------------------------
function bool ShotHitsPawn( Vector TargetPos )
{
	local Vector MuzzleLoc, HitLoc, HitNormal, ShotDir;
	local Actor HitActor;

	MuzzleLoc = TheWeapon.GetMuzzleLocationWorld();

	ShotDir = Normal( TargetPos - MuzzleLoc );

	HitActor = Trace( HitLoc, HitNormal, MuzzleLoc + TheWeapon.FireMode[0].MaxRange()*ShotDir, MuzzleLoc, true );

	if ( HitActor != None && HitActor.IsA( 'Infantry' ) )
	{
		return true;
	}
	else
		return false;
}

//---------------------------------------------------------
//	TargetIsOutInOpen
//---------------------------------------------------------
function bool TargetIsOutInOpen( gbxPawn aTarget )
{
	//local bool bTargetIsCovered;
	//local Actor HitActor;
	//local Vector HitLoc, HitNorm;
	//local NavigationPoint NavPoint;
	//local NavigationPointLite NavPointLite;

	// GBX:PAD: I put the following two checks in since either aTarget was null, or the nav point was, which was causing
	// a bunch of accessed none messages in the log files.
	if ( aTarget == None)
	{
		return false;
	}
	
	// An experiment in simplicity:
	return ( MyMind.IsTargetExposed( aTarget ) );
}

//---------------------------------------------------------
//	CheckForOpBurst
//---------------------------------------------------------
function bool CheckForOpBurst() 
{
	return false;
}

//---------------------------------------------------------
//	NotifyDoingOpBurst
//---------------------------------------------------------
function NotifyDoingOpBurst();	// Implement me.

//---------------------------------------------------------
//	SetTarget
//---------------------------------------------------------
function SetTarget( Pawn NewTarget );	// Implement me.

//---------------------------------------------------------
//	SetFrenzied
//---------------------------------------------------------
function SetFrenzied( bool bFrenzied );	// Implement me.

//---------------------------------------------------------
//	FriendlyInTheWay
//---------------------------------------------------------
function bool FriendlyInTheWay( optional out gbxPawn BlockingFriendly )
{
	local bool bResult;
	bResult = FriendlyInTheWayFromLocation( Pawn.Location, BlockingFriendly );

	if ( bResult )
	{
		LogSelective( "FriendlyInTheWay(): "$bResult$" ; Blocker="$BlockingFriendly );
	}
	return bResult;
}

//---------------------------------------------------------
//	FriendlyInTheWayFromLocation
//---------------------------------------------------------
function bool FriendlyInTheWayFromLocation( Vector FromLocation, optional out gbxPawn BlockingFriendly )
{
	local Vector EndTrace, GunVector, ToFriendly;
	local gbxPawn OneFriendly;
	local int index;
	local float Dist, DistToTarget, DotVal;
	local bool bSkipPawn;

	EndTrace = TargetLastKnownLoc;

	GunVector = EndTrace - FromLocation;
	DistToTarget = VSize( GunVector );
	GunVector = Normal( GunVector );

	if ( Pawn == None )
	{
		log("NAJ**** WARNING; "$Self.Name$".FriendlyInTheWayFromLocation called, but FC has no pawn!", 'naj' );
		return false;
	}

	// Compare the dot-product of the gun's aim direction with a vector to each
	// friendly in the map.  If the dot-product is sufficiently large ( near 1.0 ),
	// this means a friendly is in our cone of fire.
	if ((Pawn.MyUnit != None) && (Pawn.MyUnit.IsA('MultiplayerUnit')))
	{
		index = Pawn.GetNextTeammateByTeam( MultiplayerUnit(Pawn.MyUnit).Team, 0, OneFriendly );
	}
	else
	{
		index = Pawn.GetNextTeammateByTeam( Pawn.PawnTeam, 0, OneFriendly );
	}

	//LogSelective( "FriendlyInTheWayFromLocation: OneFriendly: "$OneFriendly );
	while( index != -1 )
	{
		bSkipPawn = false;

		if ( OneFriendly == Pawn || OneFriendly.IsDead() )  // skip check for ourselves and skip check on dead pawns...
			bSkipPawn = true;
		else if ( gbxVehicle(OneFriendly) != None )  // skip check on friendly vehicles (tanks, halftracks, trucks, etc)
			bSkipPawn = true;
		else if ( TankCommanderPawn(OneFriendly) != None )  // skip check on friendly tank commanders
			bSkipPawn = true;

		if ( !bSkipPawn )
		{
			Dist = VSize( OneFriendly.Location - FromLocation );

			// JMW tweaking this for situations I'm coming across in testing:
			if ( Dist < DistToTarget || 		// Friendly in between me and target.
				 Dist - DistToTarget < FFBufferDist	)	// Friendly beyond target; make sure he's *far* beyond the target.
			{
				ToFriendly = OneFriendly.Location - FromLocation;
				ToFriendly = Normal( ToFriendly );

				DotVal = ToFriendly dot GunVector;
				if ( DotVal >= FFConeThresh )
				{
					BlockingFriendly = OneFriendly;
					return true;
				}
				else
				// For pawns that are especially close to the shooter, don't even allow it if
				// the angle to the friendly is less than 60 degrees.
				if ( (DotVal >= FFSuperCloseConeThresh) && (Dist <= FFSuperCloseRadius) )
				{
					BlockingFriendly = OneFriendly;
					return true;
				}
			}
		}

		if ((Pawn.MyUnit != None) && (Pawn.MyUnit.IsA('MultiplayerUnit')))
		{
			index = Pawn.GetNextTeammateByTeam( MultiplayerUnit(Pawn.MyUnit).Team, index, OneFriendly );
		}
		else
		{
			index = Pawn.GetNextTeammateByTeam( Pawn.PawnTeam, index, OneFriendly );
		}
	}

	BlockingFriendly = None;
	return false;
}

//---------------------------------------------------------
//	VantagePointStolen
//---------------------------------------------------------
event VantagePointStolen(ActorLite NavPoint);	// Implement me.

//---------------------------------------------------------
//	SetOneOffTimer
//---------------------------------------------------------
function SetOneOffTimer( float Duration )
{
	if ( Duration <= 0.001f )
	{
		bWaitForTimer = false;
		return;
	}
	else
	{
		bWaitForTimer = true;
		SetTimer( Duration, false );
	}
}

//---------------------------------------------------------
//	TurnOffTimer
//---------------------------------------------------------
function TurnOffTimer()
{
	SetTimer( 0.0, false );
	bWaitForTimer = false;
}

//---------------------------------------------------------
//	DetermineBurstCount
//---------------------------------------------------------
function int DetermineBurstCount()
{
	// TBD: Add logic for Opportunistic Burst that returns the maximum possible 
	// burst size for this weapon.
	local int Min, Max;

	if ( TheWeapon == None )
		return 0;

	TheWeapon.GetBestBurstCount( MyMind.GetSuppressionLevel(), Min, Max );

	return Rand( Max - Min + 1 ) + Min;
}

//---------------------------------------------------------
//	MuzzleHasClearShot
//---------------------------------------------------------
// DO NOT call this function from outside the FiringController.  Call IsMuzzleBlocked() instead.
function bool MuzzleHasClearShot()
{
	local Vector MuzzleLoc, EndLoc, HitLoc, HitNormal;
	local Actor HitActor;
	local bool bSuppressing, bResult;

	// Sanity checks.
	if ( Pawn == None || Pawn.Weapon == None )
	{	
		return false;
	}

	MuzzleLoc = Pawn.Weapon.GetMuzzleLocationWorld();

	if ( SuppressLoc != Vect(0,0,0) )
	{
		bSuppressing = true;
		EndLoc = SuppressLoc;
	}
	else
	{
		bSuppressing = false;
		
		// Always check against the target's head instead of using the SeeLoc.
		// This avoids situations where the rifle is propped up on a wall and the
		// target is relatively close to the shooter, in which case a line check to the
		// target's torso would clip into the wall.
		EndLoc = TargetLastKnownLoc + Target.EyePosition();
	}

	HitActor = Trace( HitLoc, HitNormal, EndLoc, MuzzleLoc, true );

	if ( HitActor == None || HitActor == Target )
		bResult = true;
	else
		bResult = ( VSize( HitLoc - MuzzleLoc ) >= 500 );

	if ( !bResult )
	{
		if ( MyMind.bUseAIDebugging && MyMind.AITracker != None )
		{
			MyMind.AITracker.UpdateCSSData( Vect(0,0,0), Vect(0,0,0), HitLoc );
		}

		LogSelective( "MuzzleHasClearShot(): "$bResult );
	}

	return bResult;
}

//---------------------------------------------------------
//	Think
//---------------------------------------------------------
function Think();		// Implement me.

//---------------------------------------------------------
//	GetPauseTime
//---------------------------------------------------------
function float GetPauseTime()
{
	// Pause ONLY if the pawn is firing an automatic weapon (such as a Thompson)
	if ( TheWeapon == None )
		return 0.0;

	return TheWeapon.GetPauseTimeExposed();
}

//---------------------------------------------------------
//	FireBurstWithTimer
//---------------------------------------------------------
function FireBurstWithTimer()
{
	SetOneOffTimer( 7.0 );		// Wait no longer than 7 seconds for the burst to finish.
	LastSuccessfulShotTime = Level.TimeSeconds;
	
	bBurstInterrupted = false;
	Pawn.FireWeaponBurst( BurstCount );
}

//---------------------------------------------------------
//	IsWeaponFiring
//---------------------------------------------------------
function bool IsWeaponFiring()
{
	return	Pawn.IsWeaponFiring() && 
			bWaitForTimer && 
			(Level.TimeSeconds - LastSuccessfulShotTime) < SecondsBeforeKillingBurst;
}

//---------------------------------------------------------
//	NotifyTakeHit
//---------------------------------------------------------
function NotifyTakeHit( Pawn InstigatedBy, Vector HitLocation );	// Implement me.

//---------------------------------------------------------
//	NotifyTargeting
//---------------------------------------------------------
function NotifyTargeting()
{
	LogSelective( "NotifyTargeting." );
}

//---------------------------------------------------------
//	NotifyStopTargeting
//---------------------------------------------------------
function NotifyStopTargeting()
{
	LogSelective( "NotifyStopTargeting." );
}

//---------------------------------------------------------
//	NotifyPrepareAssault
//---------------------------------------------------------
function NotifyPrepareAssault()
{
	TheWeapon.FireMode[0].StartBerserk();
	bGoingToAssault = true;
}

//---------------------------------------------------------
//	NotifyStopAssaulting
//---------------------------------------------------------
function NotifyStopAssaulting()
{
	if ( TheWeapon != None && TheWeapon.FireMode[0] != None )
		TheWeapon.FireMode[0].StopBerserk();

	bGoingToAssault = false;
}

//---------------------------------------------------------
//	NotifySuppressed
//---------------------------------------------------------
function NotifySuppressed();	// Implement me.

//---------------------------------------------------------
//	NotifyRally
//---------------------------------------------------------
function NotifyRally();		// Implement me.

//---------------------------------------------------------
//	MountFinished
//---------------------------------------------------------
function MountFinished( bool bSuccess, EMountAction MountAction ) {}

//---------------------------------------------------------
//	MissShotAgainstAssaulter
//---------------------------------------------------------
event bool MissShotAgainstAssaulter()
{
	return false;	// Override in subclass.
}

//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
	DrawType=DT_None
	bHidden=true

	SecondsBeforeKillingBurst=2.0
	FFConeThresh=0.974
	FFSuperCloseRadius=100.0
	FFSuperCloseConeThresh=0.5
	FFBufferDist=250.0	//1500.0

	bLogSelect=false;
	MyLogSelectName="FCBASE"

	noshow=true
}class FiringControllerCallback extends MountCallbackClass;



static function MountFinished( gbxPawn gbxP, bool bSuccess, EMountAction MountAction )
{
	local FiringControllerBase FireCtrl;

	if ( gbxP.Controller.IsA( 'Mind' ) )
	{
		FireCtrl = Mind( gbxP.Controller ).GetFiringController();
		FireCtrl.MountFinished( bSuccess, MountAction );
	}
}
//=============================================================================
// Infantry firing controller that specifically handles behavior when manning 
// Flakvierling anti-aircraft guns.
//
// Author: Neil Johnson, Gearbox Software.
//=============================================================================
class FiringControllerFlakV extends FiringControllerInfantry;

//---------------------------------------------------------
//	Variables / Constants
//---------------------------------------------------------
var		float		TIMER_DURATION;

//---------------------------------------------------------
//	StartGunningTurret
//---------------------------------------------------------
function StartGunningTurret()
{
	LogSelective( "StartGunningTurret." );
	GotoState( 'GunningTurret' );
}

//---------------------------------------------------------
//	StartLoadingTurret
//---------------------------------------------------------
function StartLoadingTurret()
{
	LogSelective( "StartLoadingTurret." );
	GotoState( 'LoadingTurret' );
}

//---------------------------------------------------------
//	SetTargetPoint
//---------------------------------------------------------
function SetTargetPoint( Vector NewTargetPoint )
{
	MyMind.FacingVector = NewTargetPoint;
}

//---------------------------------------------------------
//	EnsureWeaponIsCurrent
//---------------------------------------------------------
function EnsureWeaponIsCurrent()
{
	if ( TheWeapon == None && WGPawn.Turret != None && WGPawn.Turret.IsA( 'WeapDEFlakvierling' ) )
	{		
		TheWeapon = WGPawn.Turret;
	}
}

//=========================================================
//	State GunningTurret
//=========================================================
state GunningTurret
{	
	//---------------------------------------------------------
	//	BeginState (GunningTurret)
	//---------------------------------------------------------
	function BeginState()
	{
		Super.BeginState();
		MyMind.SetFacingPolicy( FACE_Vector );
		SetTimer(TIMER_DURATION, true);
	}	

	//---------------------------------------------------------
	//	ApproveShot (GunningTurret)
	//---------------------------------------------------------
	function bool ApproveShot( Rotator AimRotator )
	{
		return true;
	}

	//---------------------------------------------------------
	//	CloseEnoughToFire (GunningTurret)
	//---------------------------------------------------------
	function bool CloseEnoughToFire()
	{
		local Rotator TempRot;
		local Vector ToTargetNorm, FacingVectNorm;
		local float TheDot;

		ToTargetNorm = Normal( MyMind.FacingVector - WGPawn.Location );
		TempRot = WeapDEFlakVierling( TheWeapon ).GetFireRotation();

		FacingVectNorm = Vector( TempRot );
		TheDot = FacingVectNorm dot ToTargetNorm;

		//log( "TheDot: "$TheDot, 'naj' );
		return ( TheDot >= 0.85 );
	}	

//-----------------------------------------
Begin:		// state GunningTurret
//-----------------------------------------
	
	if ( CloseEnoughToFire() )
	{
		WGPawn.StartFiringWeapon();		
	}
	else
	{
		WGPawn.StopFiringWeapon();
	}	

	Sleep( 1.0 );
	Goto( 'Begin' );
}

//=========================================================
//	State LoadingTurret
//=========================================================
state LoadingTurret
{
	// This state essentially does nothing, because the loader
	// never actually has to fire the gun.
}


//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
	MyLogSelectName="FCFLAKV"
	TIMER_DURATION=0.75
}class FiringControllerHalftrack extends FiringControllerInfantry;


//---------------------------------------------------------
//	EnsureWeaponIsCurrent
//---------------------------------------------------------
function EnsureWeaponIsCurrent()
{
	if ( MyMind == None )
		return;

	if ( Pawn != None && Pawn.Weapon != None && TheWeapon != Pawn.Weapon )
	{
		TheWeapon = gbxWeapon( Pawn.Weapon );
	}
}

function StartFiringFromCover( Pawn NewTarget )
{
	GotoState( 'FiringFromCover' );
}


state Exposed
{
}

state FFCBase
{
	function bool IsAtLowCover()
	{
		LogSelective( "IsAtLowCover(): returning true" );
		return true;
	}
}

state FiringFromCover
{
	function bool DoMountAction()
	{
		MyMind.RequestPawnToCrouch();
		bMountSuccessful = true;
		return true;
	}
}

state HunkeredDown
{
	function BeginState()
	{
		Super.BeginState();
		MyMind.RequestPawnToCrouch();
	}

	function bool IsAtLowCover()
	{
		LogSelective( "IsAtLowCover(): returning true" );
		return true;
	}

	function bool IsNearCoverPoint() 
	{
		LogSelective( "IsNearCoverPoint(): returning true" );
		return true; 
	}

	function bool ShouldPeekThisRound()
	{
		LogSelective( "ShouldPeekThisRound(): returning true" );
		return false;
	}

	function bool TargetingFailed()
	{
		if( TargetNotViable( GetCurrentPosture(), TargetFailureCode, BlockingFriendly ) )
		{
			// Was the shot blocked from a crouched posture?  If so, try it from the standing posture?
			if ( GetCurrentPosture() == 1 && ( TargetFailureCode == FAIL_MuzzleBlocked || TargetFailureCode == FAIL_NoVantage ) )
			{
				if ( TargetNotViable( 2, TargetFailureCode, BlockingFriendly ) )
				{
					// Blocked even from a standing posture.
					return true;
				}
				else
				{
					// We DO have a shot if we stand up.  Do it.
					MyMind.RequestPawnToStand();
					return false;
				}
			}
			else
			{
				// Either we're standing or targeting failed for some reason other than the shot was blocked.
				return true;
			}
		}
	}


Begin:
	StateInfoLabel='Begin_Exposed';

	if ( MyMind.bUseAIDebugging && MyMind.AITracker != None )
	{
		MyMind.AITracker.StartNewFiringCycle( true );
	}
	
	if ( TheWeapon == None )
	{
		Sleep( 0.1 );
		Goto( 'Begin' );
	}

	// Do we need to reload?
	if ( TheWeapon.NeedsToReload() )
	{		
		// Crouch down first if not moving.
		if ( !MyMind.IsNavigating() && !WGPawn.bIsCrouched )
		{
			MyMind.RequestPawnToCrouch();
			while( WGPawn.IsTransitioning() )
				Sleep( 0.1 );		
		}

		TheWeapon.EnableReload();

		while( TheWeapon.IsReloading() )
			Sleep( 0.1 );
	}

	if ( !CanFireWeapon() )
	{
		Sleep( 0.1 );
		Goto( 'Begin' );
	}

	StateInfoLabel='Exposed_2';

    // Verify that a target exists.
	if ( Target == None || Target.IsDead() )
	{
		if ( MyMind.bUseAIDebugging && MyMind.AITracker != None )
		{
			MyMind.AITracker.AddFiringFactor( Firing_TargetDead );
		}
						
		Goto( 'BackToBegin' );
	}

	// Update our knowledge about the target's location.
	UpdateTargetKnownLocation();

	WGPawn.SetWeaponAimedState( WAS_Sighted );
		
	LogSelective( "Checking for opburst..." );
	if ( CheckForOpBurst() && !MyMind.HasFreeOpBurst() )	// Don't send a message if the Unit already knows about it.
	{
		if ( MyMind.bUseAIDebugging && MyMind.AITracker != None )
		{
			MyMind.AITracker.AddFiringFactor( Firing_OpBurst );
		}
		// TBD: Notify teammates that I'm firing an op-burst.
		SendOpBurstMessage();
	}

	LogSelective( "Determing target viability of "$Target.Name$"..." );
	if ( TargetingFailed() )
	{
		LogSelective( "Targeting failed for "$Target.Name$"." );
		NotifyTargetFailureMind( TargetFailureCode, BlockingFriendly );

		if ( WGPawn.IsWeaponFiring() )
			WGPawn.StopFiringWeapon();
		StateInfoLabel='Target_Not_Viable';
		
		Goto( 'BackToBegin' );
	}

	bLockFacingPolicy = true;	// Don't allow the Mind to change the facing policy while FC is trying to shoot.
	MyMind.RequestFacingPolicy( FACE_Enemy );

	MyMind.SetAimingAtTarget( Target );
	
	StateInfoLabel='Trying_To_Aim';
	LogSelective( "Trying to aim..." );

	StateInfoLabel='Trying_To_Aim_2';

	// Determine the burst length based on the current suppression level of this pawn's unit.
	BurstCount = DetermineBurstCount();

	if ( true/*bIsFrenzied*/ || WGPawn.IsAimingAtTarget() )
	{
		StateInfoLabel='WaitingForBurst';
		LogSelective( "Targeting succeeded, firing at "$Target.Name$"..." );

		if ( BurstCount > 0 )
		{
			MyMind.NotifyPreparingToFire( true, Target );

			TheWeapon.DisableReload();	// Disable reload because when the clip runs out, we want the pawn to crouch first before reloading.
			FireBurstWithTimer();
			while ( IsWeaponFiring() )
				Sleep( 0.1 );

			WGPawn.StopFiringWeapon();

			MyMind.NotifyPreparingToFire( false );
		}

		StateInfoLabel='BurstFinished';
	}
	else
	{
		//log("NAJ**** Pawn is not aiming at target.", 'naj');
		if ( MyMind.bUseAIDebugging && MyMind.AITracker != None )
		{
			MyMind.AITracker.AddFiringFactor( Firing_CantAim );
		}
	}	

//-----------------------------------------
BackToBegin:
//-----------------------------------------
	PauseTime = GetPauseTime();
	SetOneOffTimer( PauseTime );
	while( bWaitForTimer && !bSuspendForWallClimb )
		Sleep(0.2);

	Sleep( 0.1 );

	Goto( 'Begin' );
}

state ConsiderFiringOptions
{
	function bool HasShotAroundCorner()
	{
		return false;
	}
}

state FireOverWall
{
	function PositionSelf()
	{
		MyMind.RequestPawnToCrouch();
		MyMind.RequestFacingPolicy( FACE_Enemy );
	}

	function bool CanThrowGrenade( float DistToTarget )
	{
		return false;
	}

	function bool CanShootAtTarget() 
	{
		return true;
	}
}

state GoBackToCover
{
	function bool ReturnToCover() 
	{
		return true;
	}

	function bool ReturningToCover() 
	{
		return false;
	}
}


//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
//	bLogSelect=true
	FFConeThresh=0.974  // 13 degrees
	FFSuperCloseRadius=100.0
	FFSuperCloseConeThresh=0.866  // 30 degrees
	FFBufferDist=250.0

}//=============================================================================
// Infantry firing controller that specifically handles behavior when manning 
// the MG42 machine gun on the Halftrack
//=============================================================================
class FiringControllerHalftrackMG extends FiringControllerInfantry
	native;

//---------------------------------------------------------
//	Variables / Constants
//---------------------------------------------------------

var enum E_HT_KillZone
{
	HTMG_KZ_None,
	HTMG_KZ_ZoneOne,
	HTMG_KZ_ZoneTwo,
	HTMG_KZ_ZoneThree,
	HTMG_KZ_Suppress,
}
KillZone;					// When on turret weapons, the current kill zone.

var bool			bIsTargetingEnemy;
var bool			bIsSweeping;
var Vector			SweepPath;					// Vector from turret weapon to target.
var Vector			SweepStart;					// Turret sweep starting point.
var float			T;							// Parametric t-value used in sweeping the weapon.

var vector			FacingVector;

var float			SWEEP_END_OFFSET;
var float			SWEEP_START_OFFSET;

var const float		SWEEPSTART_OFFSET;			// Offset from the path-start from which to start a sweep.
var const float		OVERSHOOT_OFFSET;			// Offset past the target to go when sweeping.
var const float		SWEEP_ERROR_ZONE3;			// Error-offset when the target is in kill-zone 3.
var int				ShotCount;

var bool bGunFiring;      //DLEVY
var Pawn DesiredNewTarget; //DLEVY

var Halftrack MyHalftrack;
var WeapDEHalftrackMG42_ MyMG42;

native function StopWaiting();


//---------------------------------------------------------
//	StartManningTurret
//---------------------------------------------------------
function StartManningTurret()
{
	LogSelective( "StartManningTurret." );

	MyMind.SetFacingPolicy( FACE_NoChange );
	FacingVector = Pawn.Location + 1000.0f * vector(Pawn.Rotation);

	bIsTargetingEnemy = false;
	bIsSweeping = false;

	GotoState( 'ManningTurret' );
}

//---------------------------------------------------------
//	EnsureWeaponIsCurrent
//---------------------------------------------------------
function EnsureWeaponIsCurrent()
{
	if ( MyMind == None )
		return;

	if ( Pawn != None && Pawn.Weapon != None && TheWeapon != Pawn.Weapon )
	{		
		TheWeapon = gbxWeapon( Pawn.Weapon );		
	}
}

function int GetRotDiff(int A, int B)
{
	local int comp;

	comp = (A - B) & 65535;
	if (comp > 32768)
		comp -= 65536;

	return comp;
}

function Tick(float DeltaTime)
{
	local rotator FacingRot;
	local int YawDiff, PitchDiff;
	local int ndx;
	local vector EnemyLoc;

	super.Tick(DeltaTime);

	if (MyMind == None)
		return;

	if (MyHalftrack == None)
	{
		MyHalftrack = MindHalftrackMG42Gunner(MyMind).MyHalftrack;
	}

	if (MyMG42 == None)
	{
		MyMG42 = MindHalftrackMG42Gunner(MyMind).MyHalftrack.MyMG;
	}

	if (bIsTargetingEnemy)
	{
		// Face the Enemy himself if he is visible.  Otherwise, face his last known location.			
		ndx = MyMind.FindTargetInQueue( MyMind.Enemy );

		if ( ndx > -1 )
		{
			if ( MyMind.TargetQueue[ ndx ].TargetExposureToMe > 0.25 )
			{
				EnemyLoc = MyMind.Enemy.Location;
			}
			else
			{
				EnemyLoc = MyMind.TargetQueue[ ndx ].LastKnownLocation;
			}
		}
		else
		{
			EnemyLoc = MyMind.Enemy.Location;
		}

		FacingVector = EnemyLoc;
	}
	else if (bIsSweeping)
	{
		FacingVector = SweepStart + T * SweepPath;

		// Update the t-value.
		T += DeltaTime;

		if ( T > 1.0)
		{
			T = 0.0;
			bIsSweeping = false;
		}
	}

	// convert FacingVector to a rotator...
	FacingRot = rotator(FacingVector - Pawn.Location);

	// Restrict the yaw to the cone of fire.
	//RotDelta = PreviousHalftrackRotation - FacingRot;  // delta is negative change since previous frame

	//FacingRot.Pitch = (FacingRot.Pitch + RotDelta.Pitch) & 65535;
	//FacingRot.Yaw = (FacingRot.Yaw + RotDelta.Yaw) & 65535;
	//FacingRot.Roll = 0;  // always reset the roll to 0 to make the iron sights view "level"

	//PreviousHalftrackRotation = MyHalftrack.Rotation;

	// Yaw.
	YawDiff = GetRotDiff(FacingRot.Yaw, MyHalftrack.Rotation.Yaw);
	if (YawDiff > MyMG42.HorizFieldUU)
		FacingRot.Yaw = (MyHalftrack.Rotation.Yaw + MyMG42.HorizFieldUU) & 65535;
	else if (YawDiff < -MyMG42.HorizFieldUU)
		FacingRot.Yaw = (MyHalftrack.Rotation.Yaw - MyMG42.HorizFieldUU) & 65535;

	// Pitch.
	PitchDiff = GetRotDiff(FacingRot.Pitch, MyHalftrack.Rotation.Pitch);
	if (PitchDiff > MyMG42.VertFieldUU)
		FacingRot.Pitch = (MyHalftrack.Rotation.Pitch + MyMG42.VertFieldUU) & 65535;
	else if (PitchDiff < -MyMG42.VertFieldUU)
		FacingRot.Pitch = (MyHalftrack.Rotation.Pitch - MyMG42.VertFieldUU) & 65535;

	FacingVector = Pawn.Location + 1000.0f * vector(FacingRot);

	MyMind.SetRotation(FacingRot);
	MyMG42.FaceRotation(FacingRot);
}

//---------------------------------------------------------
//	CalcKillZone
//---------------------------------------------------------
function E_HT_KillZone CalcKillZone( float DistToTarget )
{
	//local float DistToTarget;
	local bool bCSSResult;

	// First things first.  Is the target even in our visibility cone?
	if ( !Pawn.Turret.PointIsInMyConeOfFire( Target.Location ) )
		return HTMG_KZ_None;

	// Don't calculate a sweep path if the target is under cover.
	// Check for suppression.
	bCSSResult = MyMind.CanSeeOrSuppressFromPoint( Target, TheWeapon.GetMuzzleLocationWorld(), SeeLoc, IsHeadShot, SuppressLoc, FailLoc ); 

	if ( SuppressLoc != Vect(0,0,0 ) )
	{
		return HTMG_KZ_Suppress;
	}
	
	if ( DistToTarget < 0 )
	{
		// Error: target wasn't found in the Mind's TargetQueue, but we need to keep moving here.  Calculate the distance directly.
		DistToTarget = VSizeIgnoreZ( Target.Location - Pawn.Location );
	}

	if ( DistToTarget < Pawn.Turret.Zone1OuterRadius )
	{
		LogSelective( "Zone 1..." );
		return HTMG_KZ_ZoneOne;
	}
	else if ( DistToTarget < Pawn.Turret.Zone2OuterRadius )
	{
		LogSelective( "Zone 2..." );
		return HTMG_KZ_ZoneTwo;
	}
	else if ( DistToTarget < Pawn.Turret.Zone3OuterRadius )
	{
		LogSelective( "Zone 3..." );
		return HTMG_KZ_ZoneThree;
	}
	else
	{
		LogSelective( "Zone NoZone..." );
		return HTMG_KZ_None;
	}
}

//=========================================================
//	State ManningTurret
//=========================================================
state ManningTurret
{			
	function BeginState()
	{
		Pawn.bPhysicsAnimUpdate = false;
	}

	function EndState()
	{
		Pawn.bPhysicsAnimUpdate = true;
	}

	//---------------------------------------------------------
	//	Think
	//---------------------------------------------------------
	function Think()
	{
		// GBX:naj - Now calculating the killzone every think-cycle instead at the beginning of every burst.
		// This makes MG gunners more responsive to enemies crossing from one killzone into another.
		// If the target has crossed into a new kill zone, reset the state code.
		local E_HT_KillZone NewKillZone;
		local float TargetDistance;

		UpdateTargetKnownLocation( TargetDistance );
		NewKillZone = CalcKillZone( TargetDistance );

		if ( NewKillZone != KillZone )
		{
			KillZone = NewKillZone;
			GotoState('ManningTurret', 'ChangingTarget');
		}	
		else
		{
			KillZone = NewKillZone;
		}
	}

	//---------------------------------------------------------
	//	SetTarget
	//---------------------------------------------------------
	function SetTarget( Pawn NewTarget )
	{ 
	//start DLEVY 1/7/05

	// fix for bug #7254. 
	// Problem was that when player went behind MG
	// while it was firing a teammates in front of it,
	// it could retarget the player in the middle of the burst due to Mind.SetEnemy 
	// and circumvent the check which prevents shooting at targets outside of cone
	// for a a very very short time, but since the MG bullets are instakill only one hit is needed
	// To resolve this I have added a check to this FiringControllerMG.SetTarget()
	// where if it is called while the gun is actively firing in Zone1
	// we stop the gun from firing before changing the Target

		DesiredNewTarget = NewTarget;
		if (bGunFiring )
		{
			GotoState('ManningTurret', 'ChangingTarget');
			return;
		}
	//end DLEVY 1/7/05

		if ( NewTarget == Target )
			return;

		Target = gbxPawn( NewTarget );
		Threat = Target;

		FrustrationLevel = 0.0;
		NewTargetTimeStamp = Level.TimeSeconds;	
		GotoState('ManningTurret', 'Begin');  //DLEVY 1/6/05
	}

	//---------------------------------------------------------
	//	GetTraceExtents (ManningTurret)
	//---------------------------------------------------------
	function GetTraceExtents( out Vector StartTrace, out Vector EndTrace )
	{
		StartTrace = Pawn.Weapon.GetMuzzleLocationWorld();
		EndTrace = Pawn.Weapon.GetMuzzleLocationWorld() + (Vect(10000,0,0) >> Pawn.Weapon.Rotation);
	}

	//---------------------------------------------------------
	//	FriendlyInTheWayFromLocation (ManningTurret)
	//---------------------------------------------------------
	function bool FriendlyInTheWayFromLocation( Vector FromLocation, optional out gbxPawn BlockingFriendly )
	{
		return false;		
	}

	//---------------------------------------------------------
	//	CalculateDistToTarget (ManningTurret)
	//---------------------------------------------------------
	function float CalculateDistToTarget()
	{
		return VSizeIgnoreZ( TargetLastKnownLoc - Pawn.Location );
	}	

	//---------------------------------------------------------
	//	CalculateSweepPath (ManningTurret)
	//---------------------------------------------------------
	function CalculateSweepPath( E_HT_KillZone KillZone )
	{
		local Vector SkyPoint, SkyPointTemp, FireDir, EndPos, HitNorm, X,Y,Z;
		local int RandomDir;

		SkyPoint = TargetLastKnownLoc + Vect(0,0,1000.0);	// Wayyy up in the sky above the target.

		FireDir = TargetLastKnownLoc - Pawn.Turret.Location;
		FireDir.Z = 0;
		FireDir = Normal( FireDir );

		// If the target is higher in elevation, use the target's
		// head as the end point.
		if ( TargetLastKnownLoc.Z > ( Pawn.Location.Z + 100.0 ) )
		{
			// Gunner is below the target in elevation.
			EndPos = TargetLastKnownLoc + Target.EyePosition();
			SweepStart = Pawn.Turret.Location;
		}
		else
		{
			// Gunner is up in the air above target.
			SkyPointTemp = SkyPoint + SWEEP_END_OFFSET * FireDir;
			Trace( EndPos, HitNorm, SkyPointTemp + Vect(0,0,-2000), SkyPointTemp );

			SkyPointTemp = SkyPoint - SWEEP_START_OFFSET * FireDir;
			Trace( SweepStart, HitNorm, SkyPointTemp + Vect(0,0,-2000), SkyPointTemp );
		}

		if ( KillZone == HTMG_KZ_Suppress )
		{
			EndPos = SuppressLoc;
		}
		

		SweepPath = EndPos - SweepStart;

		// If in the third (outermost) killzone,
		// adjust the root path by an over-correction offset.
		if ( KillZone == HTMG_KZ_ZoneThree )
		{
			if (Rand(2) == 0)
				RandomDir = 1;
			else
				RandomDir = -1;

			GetAxes(Pawn.Turret.Rotation, X,Y,Z);
			SweepPath += SWEEP_ERROR_ZONE3 * RandomDir * Y;
		}
	}

	//---------------------------------------------------------
	//	GetPauseTime (ManningTurret)
	//---------------------------------------------------------
	function float GetPauseTime()
	{
		local float Min, Max;

		if ( Pawn.Turret == None )
			return 0.0;

		if ( Pawn.Turret.bIgnoreSuppression )
		{
			Pawn.Turret.GetBestPauseTime( SL_UNSUPPRESSED, Min, Max );
		}
		else
		{
			Pawn.Turret.GetBestPauseTime( MyMind.GetSuppressionLevel(), Min, Max );
		}

		return RandRange( Min, Max );
	}

	//---------------------------------------------------------
	//	ApproveShot
	//---------------------------------------------------------
	function bool ApproveShot( Rotator AimRotator )
	{
		return true;
	}

	//---------------------------------------------------------
	//	AdjustAimNew (ManningTurret)
	//---------------------------------------------------------
	function Rotator AdjustAimNew( Ammunition Ammo, Vector ProjStart, Rotator AimRotator, optional out int bSkipDoTrace )
	{		
		local Actor HitActor;
		local float DistToTarget, RepelBulletsCutoffDist;
		local bool bDoWarningShot, bShotWouldCollide, bMissOnPurpose;
		local Vector HitLoc, HitNormal, MuzzleLoc;

		MuzzleLoc = TheWeapon.GetMuzzleLocationWorld();

		if ( KillZone == HTMG_KZ_ZoneOne )
		{
			// Shoot right at the target's head half of the time.
			if ( ShotCount++ % 2 == 0 )
				AimRotator = Rotator( ( Target.Location + Target.EyePosition() ) - MuzzleLoc );
			else
				AimRotator = Rotator( Target.Location - MuzzleLoc );
		}
		else
		{
			MyMind.ApplyAccuracy( AimRotator, 50 );

			if ( KillZone == HTMG_KZ_ZoneThree || KillZone == HTMG_KZ_Suppress )
			{
				TheWeapon.SetNoDamageThisBullet();	// Suppression shots should not damage anyone.
			}
			else
			{
				//DistToTarget = CalculateDistToTarget();	

				HitActor = Trace( HitLoc, HitNormal, ProjStart + TheWeapon.FireMode[0].MaxRange() * Vector(AimRotator), ProjStart, true );
				if ( HitActor != None && HitActor.IsA( 'Infantry' ) )
				{		
					if ( HitActor == Target )
					{
						LogSelective( "Shot would normally hit the target." );
						bShotWouldCollide = true;
					}
					else
					{
						LogSelective( "Shot wouldn't hit target, but it would hit "$HitActor.Name$" instead." );
						bMissOnPurpose = true;		// The shot would hit somebody else; miss him on purpose.
					}
				}

				// Does our target repel bullets magically?
				if ( Target.RepelsBullets( RepelBulletsCutoffDist ) )
				{
					if ( RepelBulletsCutoffDist < 0.00001f || DistToTarget > RepelBulletsCutoffDist )
					{
						LogSelective( "Target magically repels bullets!" );
						TheWeapon.SetNoDamageThisBullet();
						bMissOnPurpose = true;
					}
				}

				// Should our target get the "deadlock" bonus?
				if ( !bMissOnPurpose && DoDeadlock( DistToTarget ) )
				{
					LogSelective( "Giving target deadlock bonus." );
					TheWeapon.SetNoDamageThisBullet();
					bMissOnPurpose = bShotWouldCollide;
				}

				// Determine whether or not to the "warning shot" screen effect.  The shot must otherwise have hit the target.
				bDoWarningShot = bShotWouldCollide && DoWarningShot( DistToTarget );

				if ( bDoWarningShot )
				{
					bMissOnPurpose = true;
					LogSelective( "Doing warning shot." );
				}

				// If we must miss the target on purpose, calculate a trajectory that will not hit him.
				if ( bMissOnPurpose )
				{
					LogSelective( "Doing purposeful miss." );
					AimRotator = DoPurposefulMiss( ProjStart, Target.Location, Target, bSkipDoTrace );
				}
			}

		}

		MyMind.NotifyPawnIsShooting();
		Target.IShotAtYou( Pawn, false );
		return AimRotator;
	}

	//---------------------------------------------------------
	//	SetFrenzied (ManningTurret)
	//---------------------------------------------------------
	function SetFrenzied( bool bFrenzied )
	{
		log("NAJ**** ERROR: SetFrenzied() called in the ManningTurret state.", 'naj');
	}

	//---------------------------------------------------------
	//	NotifyRally (ManningTurret)
	//---------------------------------------------------------
	function NotifyRally()
	{
		StopWaiting();
	}

	//---------------------------------------------------------
	//	DetermineBurstLength (ManningTurret)
	//---------------------------------------------------------
	function float DetermineBurstLength()
	{
		local float Min, Max;

		if ( Pawn.Turret.bIgnoreSuppression )
		{
			Pawn.Turret.GetBestBurstLength( SL_UNSUPPRESSED, Min, Max );
		}
		else
		{
			Pawn.Turret.GetBestBurstLength( MyMind.GetSuppressionLevel(), Min, Max );
		}

		return RandRange( Min, Max );
	}

	//---------------------------------------------------------
	//	SetRandomFacingVector (ManningTurret)
	//---------------------------------------------------------
	function SetRandomFacingVector()
	{
		local Rotator ForwardRot;
		
		// Only do this once in a while.
		if ( Rand( 100 ) > 50 )
			return;

		ForwardRot = Rotator( Pawn.Turret.GetBaseVector() );
		
		if ( Rand( 2 ) == 0 )
		{
			ForwardRot.Yaw += Rand( 6000 );
		}
		else
		{
			ForwardRot.Yaw -= Rand( 6000 );
		}

		if ( Rand( 2 ) == 0 )
		{
			ForwardRot.Pitch += Rand( 500 );
		}
		else
		{
			ForwardRot.Pitch -= Rand( 500 );
		}

		FacingVector = Pawn.Location + 1000.0 * Vector( ForwardRot );
	}


//-----------------------------------------
Begin:		// state ManningTurret
//-----------------------------------------
	bGunFiring = false; //DLEVY

	if ( MyMind.bUseAIDebugging && MyMind.AITracker != None )
	{
		MyMind.AITracker.StartNewFiringCycle( true );
	}

	// Verify that a target exists.
	if ( Target == None || Target.IsDead() )
	{
		if ( MyMind.bUseAIDebugging && MyMind.AITracker != None )
		{
			MyMind.AITracker.AddFiringFactor( Firing_TargetDead );
		}
		Sleep( 1.0 );
		Goto( 'Begin' );
	}

	if ( !Pawn.Turret.IsEnabled() )
	{
		Sleep( 1.0 );
		Goto( 'Begin' );
	}

	//T = 0.0;	// Uncomment this line to make each burst to start a new sweep.

	//UpdateTargetKnownLocation();
	//KillZone = CalcKillZone();

	if (KillZone != HTMG_KZ_ZoneOne )
	{
		CalculateSweepPath( KillZone );
	}
	
	switch ( KillZone )
	{
	case HTMG_KZ_None:
		Goto( 'NoZone' );
		break;
	case HTMG_KZ_ZoneOne:
		Goto( 'Zone1' );
		break;
	case HTMG_KZ_ZoneTwo:
		Goto( 'Zone2' );
		break;
	case HTMG_KZ_ZoneThree:
		Goto( 'Zone3' );
		break;
	case HTMG_KZ_Suppress:
		Goto( 'SuppressingFire' );
		break;
	}	

//-----------------------------------------
NoZone:	// Too far away to hit!
//-----------------------------------------
	StateInfoLabel = 'NoZone';

	TargetFailureCode = FAIL_NoVantage;
	NotifyTargetFailureMind( TargetFailureCode );

	SetRandomFacingVector();

	Pawn.StopFiringWeapon();
	Sleep( 0.5 );
	Goto( 'Begin' );

//-----------------------------------------
SuppressingFire:
//-----------------------------------------
	StateInfoLabel = 'SuppressingFire';

	bIsSweeping = false;

	FacingVector = SuppressLoc;

	BurstLength = DetermineBurstLength();

	Pawn.StartFiringWeapon();
	Sleep( BurstLength );
	Pawn.StopFiringWeapon();

	PauseTime = GetPauseTime();
	Sleep( PauseTime );


	Goto('Begin');

//-----------------------------------------
Zone1:	// Draw a direct bead on the target
//-----------------------------------------
	StateInfoLabel = 'Zone1';
	TheWeapon.SetInstaKill( true );
	
	bIsSweeping = false;
	bIsTargetingEnemy = true;

	BurstLength = DetermineBurstLength();

	if ( TargetNotViableFromLocation( TheWeapon.GetMuzzleLocationWorld(), -1, TargetFailureCode, BlockingFriendly ) )
	{
		NotifyTargetFailureMind( TargetFailureCode, BlockingFriendly );
		Pawn.StopFiringWeapon();
		Sleep( 0.5 );
		Goto( 'Begin' );
	}
	
	Pawn.StartFiringWeapon();
	bGunFiring = true;   //DLEVY flag so dont allow target changes in Zone1 while gun firing

	Sleep( BurstLength );
	Pawn.StopFiringWeapon();

	//PauseTime = GetPauseTime();
	//Sleep( PauseTime );
	Sleep( 0.1 );

	TheWeapon.SetInstaKill( false );

	bGunFiring = false;   //DLEVY allow target changes again
	Goto('Begin');

//-----------------------------------------
Zone2:	// Sweep the ground in front of target,
		// eventually hitting him.
//-----------------------------------------
//-----------------------------------------
Zone3:	// Sweep the ground in front of target,
		// but don't hit him.
//-----------------------------------------
	StateInfoLabel = 'Zone2_or_3';

	bIsTargetingEnemy = false;
	bIsSweeping = true;

	BurstLength = DetermineBurstLength();

	if ( TargetNotViableFromLocation( TheWeapon.GetMuzzleLocationWorld(), -1, TargetFailureCode, BlockingFriendly ) )
	{
		NotifyTargetFailureMind( TargetFailureCode, BlockingFriendly );
		Pawn.StopFiringWeapon();
		Sleep( 0.5 );
		Goto( 'Begin' );
	}

	Pawn.StartFiringWeapon();
	Sleep( BurstLength );
	Pawn.StopFiringWeapon();

	bIsSweeping = false;

	PauseTime = GetPauseTime();
	Sleep( PauseTime );
	Goto('Begin');

ChangingTarget:					//DLEVY new state for handling  changing targets while firing
	StateInfoLabel = 'ChangingTarget';
	Pawn.StopFiringWeapon();
	Sleep(0.1);
	bGunFiring = false;
	
	if ( DesiredNewTarget != None )
		SetTarget(DesiredNewTarget);

	Goto('Begin');
}

simulated function DisplayDebug(Canvas Canvas, out float YL, out float YPos)
{
	Super.DisplayDebug( Canvas, YL, YPos );
}

//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
	MyLogSelectName="FCHTMG42"

	SWEEPSTART_OFFSET=0.5
	OVERSHOOT_OFFSET=0.4
	SWEEP_ERROR_ZONE3=100.0
	SWEEP_END_OFFSET=10.0
	SWEEP_START_OFFSET=1000.0
}//=============================================================================
// Subcontroller responsible for infantry firing behavior.  Includes aiming and
// firing at targets, melee attacks, and firing-from-cover logic.
//
// Author: Neil Johnson, Gearbox Software.
//=============================================================================
class FiringControllerInfantry extends FiringControllerBase
	native;

//---------------------------------------------------------
//	Variables / Constants
//---------------------------------------------------------
var WargamePawn				WGPawn;						// Pawn, cast to WargamePawn.
var Actor					Threat;						// Actor (usually a Pawn) that is attacking this Pawn.
var byte					bMeleeTraceBlocked;
var bool					bMountSuccessful;			// Whether the Mount Controller was successful at mounting a cover point.
var bool					bIsFrenzied;				// Flags whether the pawn should fire shots like there's no tomorrow.
var bool					bHasShotAroundCorner;
var bool					bHasShotOverCorner;
var bool					bPermittedToOpBurst;
var bool					bDontStayUp;
var bool					bLockFacingPolicy;
var bool					bLerpLocation;
var bool					bSuspendForWallClimb;		// GBX:naj - last-minute hack to prevent the bWaitForTimer from being left set to true when a wall-climb occurs.
var Name					PendingGesture;
var Name					SkipToStateName;
var int						GrenadeIndex;				// Index of a grenade to lob.
var int						FinalErrorDebug;			// DEBUG
var float					DestinationRadius;			// Distance threshold when maneuvering to a destination.
var float					NewTargetTimeStamp;			// Time stamp when our target was updated
var float					FrustrationLevel;			// 0-1 measure of 'frustration' at target.  Used only in the GrenadeFiringController for now
var float					FrustrationBegin;			// Number of seconds we must shoot at the current target before frustration level rises
var float					FrustrationRate;			// Rate at which frustration level rises (pct/second)
var float					NextCheckVantageShotTime;
var float					NextCheckLeaveFFCTime;
var float					LerpMultiplier;
var float					ApproveShotCutoffDot;
var ECornerDir				PeekDirection;
var MountController			MountCtrl;			// Mount Controller for precision maneuvering and mount actions.
var Vector					MeleeEyesOffset;
var Vector					MeleeTraceExtent;
var Vector					PawnMeleeLocation;
var const float				CheckVantageShotInterval;
var const float				CheckLeaveFFCInterval;	// How often to check if we should leave firing-from-cover.
var const float				MeleeStrikeDist;			// The distance at which a melee attack can occur.
var const float				MeleeRootMotionDist;
var const float				MeleeChargeSpeed;
var const float				MeleeTooCloseToHuman;
var const float				MeleeFriendlyFireDot;
var const float				MeleeFacingDot;
var GrenadeFiringController	GrenadeFireCtrl;		// Contains all logic related to grenade lobbing.
var class<GrenadeFiringController> GrenadeFCClass;
var Flag					RecentTroubleShootingOverCorner;


//---------------------------------------------------------
//	SetPawnToWatch
//---------------------------------------------------------
function SetPawnToWatch( Name APawnToWatch )
{
	Super.SetPawnToWatch( APawnToWatch );
	
	if ( GrenadeFireCtrl != None )
	{
		if ( APawnToWatch != '' )
		{
			GrenadeFireCtrl.bLogSelect = true;
			GrenadeFireCtrl.Default.bLogSelect = true;
			GrenadeFireCtrl.PawnToWatch = APawnToWatch;
			GrenadeFireCtrl.Default.PawnToWatch = APawnToWatch;
		}
		else
		{
			GrenadeFireCtrl.bLogSelect = false;
			GrenadeFireCtrl.Default.bLogSelect = false;
		}
	}
}

//---------------------------------------------------------
//	PostBeginPlay
//---------------------------------------------------------
function PostBeginPlay()
{
	Super.PostBeginPlay();
}

//---------------------------------------------------------
//	PostBeginPlay
//---------------------------------------------------------
function Initialize()
{
	if ( GrenadeFireCtrl == None )
	{
		GrenadeFireCtrl = Spawn( GrenadeFCClass, self );	
		GrenadeFireCtrl.SetFiringController( Self );
	}
}

//---------------------------------------------------------
//	PrepareForDestroy
//---------------------------------------------------------
function PrepareForDestroy()
{
	if ( MountCtrl != None )
	{
		MountCtrl.PrepareForDestroy();
	}

	WGPawn = None;
	GotoState( 'WaitingForDestruction' );
}

//---------------------------------------------------------
//	Destroyed
//---------------------------------------------------------
function Destroyed()
{
	MyMind = None;
	WGPawn = None;
	Threat = None;
	Target = None;
	MountCtrl = None;	// Mind is responsible for deleting it.
	Disable( 'Tick' );
	Disable( 'Timer' );

	Super.Destroyed();
}

//---------------------------------------------------------
//	SetMountController
//---------------------------------------------------------
function SetMountController( MountController NewMountCtrl )
{
	MountCtrl = NewMountCtrl;
}

//---------------------------------------------------------
//	SetGrenadeFC
//---------------------------------------------------------
function SetGrenadeFiringController( GrenadeFiringController NewGFC )
{
	if ( NewGFC != None )
	{
		GrenadeFireCtrl = NewGFC;
		GrenadeFireCtrl.SetFiringController( Self );
	}
}

//---------------------------------------------------------
//	GetGrenadeFC
//---------------------------------------------------------
function GrenadeFiringController GetGrenadeFC()
{
	return GrenadeFireCtrl;
}

//---------------------------------------------------------
//	Possess
//---------------------------------------------------------
function Possess(Pawn aPawn)
{
	Super.Possess( aPawn );
	WGPawn = WargamePawn( aPawn );
	
	if (aPawn.IsA('gbxPawn') && GrenadeFireCtrl != None )
	{
		GrenadeFireCtrl.Possess( gbxPawn(aPawn) );		
	}
}

//---------------------------------------------------------
//	EnsureWeaponIsCurrent
//---------------------------------------------------------
function EnsureWeaponIsCurrent()
{
	local class<gbxAIController> NewMindClass;

	if ( MyMind == None )
		return;

	if ( Pawn != None && Pawn.Weapon != None && TheWeapon != Pawn.Weapon )
	{
		TheWeapon = gbxWeapon( Pawn.Weapon );
		if ( TheWeapon.RequiresSpecialMind( NewMindClass ) )
		{
			if ( NewMindClass.Name != MyMind.Class.Name )
				MyMind.ChangeMind( NewMindClass );			
		}
		else if ( MyMind.Class.Name != 'Mind' )
		{
			MyMind.ChangeMind( class'Mind' );
		}
	}
}

//---------------------------------------------------------
//	TranslateFailureCode
//---------------------------------------------------------
function String TranslateFailureCode( ETargetFailure FailureCode )
{
	switch ( FailureCode )
	{
		case FAIL_None :
			return "FAIL_None";
		case FAIL_FriendlyInWay :
			return "FAIL_FriendlyInWay";
		case FAIL_MuzzleBlocked :
			return "FAIL_MuzzleBlocked";
		case FAIL_TargetDead :
			return "FAIL_TargetDead";
		case FAIL_OutOfAmmo :
			return "FAIL_OutOfAmmo";
		case FAIL_NoVantage :
			return "FAIL_NoVantage";

		default:
			return "<unknown code>";
	}
}

//---------------------------------------------------------
//	NotifyTargetFailureMind
//---------------------------------------------------------
function NotifyTargetFailureMind( ETargetFailure FailureCode, optional gbxPawn Blocker )
{
	LogSelective( "NotifyTargetFailureMind(): "$TranslateFailureCode( FailureCode )$" ; bGoingToAssault: "$bGoingToAssault );
	if ( bGoingToAssault )
	{
		// Can't hit his target, so obviously he won't be throwing a grenade.
		MyMind.ReportThrowingGrenade( false );
	}
	else
	{
		MyMind.NotifyTargetFailure( Target, FailureCode, Blocker );
	}
}

//---------------------------------------------------------
//	IsOKToChangePawnPosture
//---------------------------------------------------------
// This function is used in special circumstances (namely when
// throwing grenades) when the Mind should not interfere with 
// the FiringController's control of the Pawn's posture.
function bool IsOKToChangePawnPosture()
{
	// Overridden in other states.
	return true;
}

//---------------------------------------------------------
//	ApproveShot
//---------------------------------------------------------
function bool ApproveShot( Rotator AimRotator )
{
	local Vector Vect1, Vect2, VectView;
	local bool bResult;

	// Sanity check.
	if ( TheWeapon == None || WGPawn == None || Target == None )
	{
		return false;
	}	

	if ((Level.NetMode == NM_StandAlone) && (WGPawn.PawnTeam == TEAM_US))
	{
		// is this game configured to hold fire and is it not time to fire yet?
		if (Level.Game.bHoldFire && ((Level.TimeSeconds - Level.Game.fHoldFireTime) > 30.0))
		{
			return false;
		}
	}

	// Don't approve the shot unless the shooter is pointing at least marginally close to the target.
	if ( !bIsFrenzied && !bGoingToAssault )
	{
		Vect1 = Vector( AimRotator );
		Vect1.Z = 0;
		Vect2 = TargetLastKnownLoc - WGPawn.Location;
		Vect2.Z = 0;

		if ( Normal( Vect1 ) dot Normal( Vect2 ) < ApproveShotCutoffDot )
		{
			LogSelective( "ApproveShot: dot-product check failed." );
			return false;
		}
	}

	// If friendly was in the way, tell the system somehow
	// so it can say "Watch out!" and lift fire.
	if ( FriendlyInTheWay( BlockingFriendly ) )
	{
		ReactToAllyBlocking( BlockingFriendly );
		bResult = false;		
	}
	else if ( !MuzzleHasClearShot() )
	{
		TargetFailureCode = FAIL_MuzzleBlocked;
		NotifyTargetFailureMind( TargetFailureCode );
		bResult = false;		
	}
	else
	{
		// Do CSS() here as opposed to in AdjustAimNew() so that it doesn't get called too often for
		// automatic weapons like the Thompson and MP40.
		if (Level.bUrbanCover && WGPawn.m_bCornerFiring && !WGPawn.bIsCrouched)
		{
			VectView = WGPawn.WhereWillIBeWhenCornerFiring( NavigationPoint(WGPawn.MyClaimedNavPoint).Rotation, true );
			bResult = MyMind.CanSeeOrSuppressFromPoint( Target, VectView, SeeLoc, IsHeadShot, SuppressLoc, FailLoc, GetCurrentPosture() );
		}
		else
		{
			bResult = MyMind.CanSeeOrSuppress( Target, SeeLoc, IsHeadShot, SuppressLoc, FailLoc, GetCurrentPosture() );
		}

		if ( !bResult && MyMind.bUseAIDebugging && MyMind.AITracker != None )
		{			
			MyMind.AITracker.AddFiringFactor( Firing_CantSeeOrSuppress );
		}
	}

	if ( bResult )
	{
		LastSuccessfulShotTime = Level.TimeSeconds;
	}
	else
	{
		bBurstInterrupted = true;
	}

	return bResult;
}

//---------------------------------------------------------
//	IsFiringFromCover
//---------------------------------------------------------
function bool IsFiringFromCover() 
{ 
	return false; 
}

//---------------------------------------------------------
//	VantageNoLongerValid
//---------------------------------------------------------
// Called by outsiders (Mind, namely)
function bool VantageNoLongerValid()
{
	return false;
}

// Override me.
function CheckPendingState() {}
// Override me.
function CheckShouldLeaveFFC() {}

//---------------------------------------------------------
//	HasTargetOrder
//---------------------------------------------------------
function bool HasTargetOrder()
{
	return MyMind != None && MyMind.HasTargetOrder();
}

//---------------------------------------------------------
//	GetWeaponReloadRate
//---------------------------------------------------------
function float GetWeaponReloadRate()
{
	if ( bGoingToAssault || bPermittedToOpBurst || bIsFrenzied )
	{
		return 1.5;
	}
	else
	{
		return 1.0;
	}
}

//---------------------------------------------------------
//	CheckForOpBurst
//---------------------------------------------------------
function bool CheckForOpBurst() 
{
	local float Dist;
	local Unit TargetUnit;
	local gbxPawn OneTeammate;
	local int ndx;

	// Sanity checks.
	if ( MyMind == None || WGPawn == None || Target == None )
	{
		bPermittedToOpBurst = false;
		return false;
	}

	// If the pawn has been issued a Target command, op-burst for the next several seconds.
	if ( MyMind.HasFreeOpBurst() )
	{
		LogSelective( "CheckForOpBurst: I was given a Target order, so I can op-burst for a while." );
		bPermittedToOpBurst = true;
		return true;
	}

	// If the pawn has been issued an Assault command, definitely do an op-burst.  Ditto if he's frenzied.
	if ( bGoingToAssault || bIsFrenzied )
	{
		bPermittedToOpBurst = true;
		return true;
	}

	// If the pawn's unit is suppressed, no op-bursts are allowed.
	// (Except in multiplayer, where op-bursts are really important for preventing frontal assaults.
	if ( ( !Level.UseMPStyleFatigue() ) && MyMind.GetSuppressionLevel() == SL_SUPPRESSED )
	{
		bPermittedToOpBurst = false;
		return false;
	}

	// SP USA pawns: This pawn may be firing at a unit which is an Assault target of another friendly unit--op-burst to help 'em out!
	if ( !Level.UseMPStyleFatigue() && Level.Game.IsPawnOnSameTeamAsPlayer(WGPawn) )
	{
		TargetUnit = Target.MyUnit;
		if ( TargetUnit != None )
		{
			ndx = WGPawn.GetNextTeammate( 0, OneTeammate );
			while( ndx != -1 )
			{			
				if ( OneTeammate.MyUnit != None && 
					OneTeammate.MyUnit != WGPawn.MyUnit &&
					OneTeammate.MyUnit.bAssaultingTargetUnit && 
					WGPawn.MyUnit.AssignedTargetUnit == TargetUnit )
				{
					bPermittedToOpBurst = true;
					return true;
				}

				ndx = WGPawn.GetNextTeammate( ndx, OneTeammate );
			}
		}
	}

	// This pawn's skill level may not permit him to do op-bursts.  Or, this pawn may not have a unit,
	// in which case, he can't do op-bursts either.
	if ( WGPawn.MyUnit == None || !Level.DifficultyManager.CanDoOpBursts( WGPawn.MyUnit.BaseSkillLevel ) )
	{
		bPermittedToOpBurst = false;
		return false;
	}

	Dist = VSize( TargetLastKnownLoc - WGPawn.Location );

	if ( Dist > MyMind.CombatRadius_NoOpBurst )
	{
		bPermittedToOpBurst = false;
	}
	else
	if ( TargetIsOutInOpen( Target ) )
	{
		bPermittedToOpBurst = true;
	}
	else
	{
		bPermittedToOpBurst = false;
	}

	LogSelective( "CheckForOpBurst(): "$bPermittedToOpBurst );
	return bPermittedToOpBurst;
}

//---------------------------------------------------------
//	NotifyDoingOpBurst
//---------------------------------------------------------
function NotifyDoingOpBurst()
{
	bPermittedToOpBurst = true;
}

//---------------------------------------------------------
//	SetTarget
//---------------------------------------------------------
function SetTarget( Pawn NewTarget )
{
	if ( NewTarget == Target )
		return;

	Target = gbxPawn( NewTarget );
	Threat = Target;
	UpdateTargetKnownLocation();

	FrustrationLevel = 0.0;
	NewTargetTimeStamp = Level.TimeSeconds;

	CheckForOpBurst();

	if ( IsInState( '' ) || IsInState( 'FiringControllerInfantry' ) )
		GotoState( 'Exposed' );
}

//---------------------------------------------------------
//	StartFiringFromCover
//---------------------------------------------------------
function StartFiringFromCover( Pawn NewTarget )
{
	Target = gbxPawn( NewTarget );
	Threat = Target;

	if ( !IsInState( 'FFCBase' ) )	// Assumes that IsInState() reports true if in the state OR ONE OF ITS SUBSTATES.
	{
		GotoState( 'FiringFromCover' );
	}
}

//---------------------------------------------------------
//	StartManningTurret
//---------------------------------------------------------
function StartManningTurret()
{
	//GotoState( 'ManningTurret' );
	LogSelective( "ERROR: StartManningTurret called in FiringControllerInfantry." );
}

//---------------------------------------------------------
//	RequestStopFiringFromCover
//---------------------------------------------------------
function RequestStopFiringFromCover( optional bool bForGesture )  
{
	LogSelective( "RequestStopFiringFromCover(). " );
}

//---------------------------------------------------------
//	RequestPlayGesture
//---------------------------------------------------------
function RequestPlayGesture( Name Gesture )
{
	// Overridden in FFCBase.
}

//---------------------------------------------------------
//	SetFrenzied
//---------------------------------------------------------
function SetFrenzied( bool bFrenzied )
{
	bIsFrenzied = bFrenzied;
	if ( bIsFrenzied )
		FFBufferDist = 0.0;
	else
		FFBufferDist = Default.FFBufferDist;
}

//---------------------------------------------------------
//	MountFinished
//---------------------------------------------------------
function MountFinished( bool bSuccess, EMountAction MountAction )
{
	bWaitForCallback = false;
	bMountSuccessful = bSuccess;
}

//---------------------------------------------------------
//	FriendlyInTheWay
//---------------------------------------------------------
function bool FriendlyInTheWay( optional out gbxPawn BlockingFriendly )
{
	if ( WGPawn.bIgnoreFriendlyFire )
		return false;
	else if ( MyMind.IsFrenzied() )
		return false;
	else
		return Super.FriendlyInTheWay( BlockingFriendly );
}

//---------------------------------------------------------
//	TargetNotViable
//---------------------------------------------------------
function bool TargetNotViable( int Posture, out ETargetFailure FailCode, optional out gbxPawn BlockingFriendly )
{
	if ( TheWeapon != None && !TheWeapon.HasAmmo() )
	{
		LogSelective( "Target not viable (out of ammo)." );
		FailCode = FAIL_OutOfAmmo;
		return true;
	}
	else if ( Target == None || Target.IsDead() )
	{
		LogSelective( "Target "$Target$" not viable (target is None or dead)." );
		FailCode = FAIL_TargetDead;
		return true;
	}
	else if ( FriendlyInTheWay( BlockingFriendly ) )
	{
		LogSelective( "Target "$Target.Name$" not viable (friendly in the way)." );
		FailCode = FAIL_FriendlyInWay;
		return true;
	}
	else if ( !MyMind.CanSeeOrSuppress( Target, SeeLoc, IsHeadShot, SuppressLoc, FailLoc, Posture ) )
	{
		LogSelective( "Target "$Target.Name$" not viable (can't see or suppress from posture "$Posture$")." );
		FailCode = FAIL_NoVantage;
		
		if ( MyMind.bUseAIDebugging && MyMind.AITracker != None )
		{
			if ( VSize( FailLoc - WGPawn.Location ) < MyMind.MaxImpactDistance )
				MyMind.AITracker.AddFiringFactor( Firing_ShotBlocked );
			else
				MyMind.AITracker.AddFiringFactor( Firing_CantSeeOrSuppress );
		}
		return true;
	}	
	else
	{
		FailCode = FAIL_None;
		return false;
	}
}

//-----------------------------------------------------
//	TargetNotViableFromLocation
//-----------------------------------------------------
function bool TargetNotViableFromLocation( Vector FromLocation, int Posture, out ETargetFailure FailCode, optional out gbxPawn BlockingFriendly )
{
	//log( self$ " FiringCInfantry::TargetNotViableFromLocation() FromLocation="$FromLocation$" Target "$Target.Name, 'MP' );
	
	if ( TheWeapon != None && !TheWeapon.HasAmmo() )
	{			
		LogSelective( "Target "$Target.Name$" not viable [from location] (out of ammo)." );
		FailCode = FAIL_OutOfAmmo;
		return true;
	}
	else if ( Target == None || Target.IsDead() )
	{
		LogSelective( "Target "$Target.Name$" not viable [from location] (target is None or dead)." );
		FailCode = FAIL_TargetDead;
		return true;
	}
	else if ( FriendlyInTheWayFromLocation( FromLocation, BlockingFriendly ) )
	{
		LogSelective( "Target "$Target.Name$" not viable [from location] (friendly in the way)." );
		FailCode = FAIL_FriendlyInWay;
		return true;
	}
	else if ( !MyMind.CanSeeOrSuppressFromPoint( Target, FromLocation, SeeLoc, IsHeadShot, SuppressLoc, FailLoc, Posture ) )
	{
		LogSelective( "Target "$Target.Name$" not viable [from location] (can't see or suppress)." );
		FailCode = FAIL_NoVantage;
	
		if ( MyMind.bUseAIDebugging && MyMind.AITracker != None )
		{
			if ( VSize( FailLoc - WGPawn.Location ) >= MyMind.MaxImpactDistance )
				MyMind.AITracker.AddFiringFactor( Firing_ShotBlocked );
			else
				MyMind.AITracker.AddFiringFactor( Firing_CantSeeOrSuppress );
		}
		
		//log( self$ " FiringCInfantry::TargetNotViableFromLocation() FailCode = FAIL_NoVantage", 'MP' );

		return true;
	}		
	else
	{
		//log( self$ " FiringCInfantry::TargetNotViableFromLocation() Target "$Target.Name$" is viable.", 'MP' );
		FailCode = FAIL_None;
		return false;
	}
}

//---------------------------------------------------------
//	VantagePointStolen
//---------------------------------------------------------
event VantagePointStolen(ActorLite NavPoint)
{
}

//-----------------------------------------------------
//	GrenadesOKAtThisRange - called internally
//-----------------------------------------------------
function bool GrenadesOKAtThisRange( float DistToTarget )
{
	return MyMind.GrenadesOKAtThisRange( DistToTarget );
}

//-----------------------------------------------------
//	GrenadesAllowedAgainstTarget - called by GrenadeFiringController
//-----------------------------------------------------
function bool GrenadesAllowedAgainstTarget( gbxPawn aTarget )
{
	local bool bResult;

	// US grenade-throwers only: Only throw grenades at targeted units' members.
	if ( Level.Game.IsPawnOnSameTeamAsPlayer(WGPawn) )
	{
		bResult = WGPawn.MyUnit != None && WGPawn.MyUnit.AssignedTargetUnit != None && WGPawn.MyUnit.AssignedTargetUnit == aTarget.MyUnit;
		LogSelective( "GrenadesAllowedAgainstTarget(): "$bResult$" ; MyUnit: "$WGPawn.MyUnit$" ; AssignedTargetUnit: "$WGPawn.MyUnit.AssignedTargetUnit$" ; aTarget: "$aTarget.Name$" ; aTarget.MyUnit: "$aTarget.MyUnit);
		
		return bResult;
	}
	else
	{
		return true;
	}
}

//-----------------------------------------------------
//	CanThrowGrenade - called internally
//-----------------------------------------------------
function bool CanThrowGrenade( float DistToTarget )
{
	local bool bGrenadeRangeOK, bWantsToThrow;

	// Don't throw grenades while actually rushing the enemy.
	if ( GrenadeFireCtrl == None || MyMind.IsAssaulting() )
	{
		return false;
	}

	bGrenadeRangeOK = GrenadesOKAtThisRange( DistToTarget );
	bWantsToThrow = GrenadeFireCtrl.WantsToThrowGrenade( GrenadeIndex );
	
	LogSelective( "CanThrowGrenade() [global]: GrenadesOKAtThisRange("$DistToTarget$") : "$bGrenadeRangeOK$" ; WantsToThrow: "$bWantsToThrow );
	return bGrenadeRangeOK && bWantsToThrow;
}

//---------------------------------------------------------
//	NotifyTakeHit
//---------------------------------------------------------
function SpeakThrowingGrenade()
{
	local Pawn PlayerPawn;
	PlayerPawn = WGPawn.MyUnit.GetControllingPlayerController().Pawn;
	Level.TheAISpeechManager.PlaySpeech( 
		WGPawn, 
		PlayerPawn,
		'ThrowingGrenade',
		'ThrowingGrenade',
		,
		0.0, 
		WGPawn.MyUnit, 
		1.0, 
		1.0 
	);
}

//---------------------------------------------------------
//	NotifyTakeHit
//---------------------------------------------------------
function NotifyTakeHit( Pawn InstigatedBy, Vector HitLocation )
{
	// Don't do anything special in this state.
}

//---------------------------------------------------------
//	NotifyTargeting
//---------------------------------------------------------
function NotifyTargeting()
{
	Super.NotifyTargeting();
	
	if ( GrenadeFireCtrl != None )
	{
		GrenadeFireCtrl.NotifyTargeting();
	}
}

//-----------------------------------------------------
//	CanFireWeapon
//-----------------------------------------------------
function bool CanFireWeapon()
{
	return WGPawn.CanFireWeapon();
}

//---------------------------------------------------------
//	DetermineBurstCount
//---------------------------------------------------------
function int DetermineBurstCount()
{
	// TBD: Add logic for Opportunistic Burst that returns the maximum possible 
	// burst size for this weapon.
	local int Min, Max;

	if ( TheWeapon == None )
		return 0;

	// When being assaulted, don't shoot much at all.
	if( MyMind.IsTerrified() )
	{
		TheWeapon.GetBestBurstCount( SL_SUPPRESSED, Min, Max );
	}
	else
	{
		if ( bPermittedToOpBurst )
			TheWeapon.GetOpBurstCount( Min, Max );
		else
		if ( bIsFrenzied )
			TheWeapon.GetBestBurstCount( SL_UNSUPPRESSED, Min, Max );
		else
			TheWeapon.GetBestBurstCount( MyMind.GetSuppressionLevel(), Min, Max );
	}

	return Rand( Max - Min + 1 ) + Min;
}

//---------------------------------------------------------
//	GetCurrentPosture
//---------------------------------------------------------
function int GetCurrentPosture()
{
	if ( WGPawn.bIsProne )
		return 0;
	else if ( WGPawn.bIsCrouched )
		return 1;
	else
		return 2;
}

//---------------------------------------------------------
//	GrenadeTossCallBack
//---------------------------------------------------------
function GrenadeTossCallBack()
{
	if ( GrenadeFireCtrl != None )
	{
		GrenadeFireCtrl.GrenadeTossCallBack();
	}
}

//---------------------------------------------------------
//	GrenadeTossFromGroundCallBack
//---------------------------------------------------------
function GrenadeTossFromGroundCallBack()
{
	if ( GrenadeFireCtrl != None )
	{
		GrenadeFireCtrl.GrenadeTossFromGroundCallBack();
	}
}

//---------------------------------------------------------
//	RefreshTarget
//---------------------------------------------------------
function RefreshTarget( Pawn tPawn, float tPriority )
{
	if ( GrenadeFireCtrl != None )
	{
		GrenadeFireCtrl.RefreshTarget( gbxPawn(tPawn), tPriority );
	}
}

//---------------------------------------------------------
//	NotifySuppressed
//---------------------------------------------------------
function NotifySuppressed() 
{
	// Overridden versions in state code should do additional actions.
	//CurSuppression = SL_SUPPRESSED;
}

//---------------------------------------------------------
//	NotifyRally
//---------------------------------------------------------
function NotifyRally()
{
	// Overridden versions in state code should do additional actions.
	//CurSuppression = SL_UNSUPPRESSED;
}

//---------------------------------------------------------
//	Think
//---------------------------------------------------------
function Think()
{
	// Update the frustration level, if it's time
	if( Target != None && Level.TimeSeconds - NewTargetTimeStamp > FrustrationBegin )
	{
		FrustrationLevel = FMin( 1.0, FrustrationLevel + FrustrationRate * MyMind.TimerInterval );
	}

	if ( GrenadeFireCtrl != None )
	{
		GrenadeFireCtrl.Think();
	}
}

function bool IsNearCoverPoint() { return false; }
function bool IsAtVantagePoint() { return false; }

//---------------------------------------------------------
//	SendOpBurstMessage
//---------------------------------------------------------
function SendOpBurstMessage()
{
	MyMind.NotifyUnitOfOpBurst();
}

//---------------------------------------------------------
//	StartMelee
//---------------------------------------------------------
function StartMelee()
{
	GotoState( 'Melee' );
}

//---------------------------------------------------------
//	StopMelee
//---------------------------------------------------------
function StopMelee() 
{
	GotoState( 'Exposed' );
}

function bool OKToControlFacingPolicy() { return true; }

//=========================================================
//	State Exposed
//=========================================================
// The pawn is in this state whenever he is not firing from cover.  The logic is simple:
// face your enemy, aim at him, and fire a burst.  Do not pause at all between bursts unless you're
// firing automatic weapons.
//
state Exposed
{
	//---------------------------------------------------------
	//	BeginState (Exposed)
	//---------------------------------------------------------
	function BeginState()
	{
		LogSelective( "BeginState." );

		if ( TheWeapon != None && TheWeapon.FireMode[0] != None )
		{
			if ( bGoingToAssault || bIsFrenzied )
			{
				TheWeapon.StartBerserk();
			}
			else
			{
				TheWeapon.StartOpBurst();
			}
		}

		WGPawn.BreakOutOfHunker();
		WGPawn.StopFiringWeapon();
		WGPawn.SetUsingCrouchedCover( false );	// Unset in case firing-from-cover logic left on.
	}

	//---------------------------------------------------------
	//	EndState (Exposed)
	//---------------------------------------------------------
	function EndState()
	{
		LogSelective( "EndState." );
		if ( !bGoingToAssault && TheWeapon != None && TheWeapon.FireMode[0] != None )
			TheWeapon.StopBerserk();

		bLockFacingPolicy = false;
	}

	//---------------------------------------------------------
	//	Timer (Exposed)
	//---------------------------------------------------------
	function Timer()
	{
		TurnOffTimer();
	}

	//---------------------------------------------------------
	//	NotifySuppressed (Exposed)
	//---------------------------------------------------------
	function NotifySuppressed()
	{
		Global.NotifySuppressed();
		TurnOffTimer();
		WGPawn.StopFiringWeapon();
	}

	//---------------------------------------------------------
	//	NotifyRally (Exposed)
	//---------------------------------------------------------
	function NotifyRally()
	{
		Global.NotifyRally();
		TurnOffTimer();
	}	

	//---------------------------------------------------------
	//	TargetingFailed (Exposed)
	//---------------------------------------------------------
	function bool TargetingFailed()
	{
		if( TargetNotViable( GetCurrentPosture(), TargetFailureCode, BlockingFriendly ) )
		{
			// Was the shot blocked from a crouched posture?  If so, try it from the standing posture?
			if ( GetCurrentPosture() == 1 && ( TargetFailureCode == FAIL_MuzzleBlocked || TargetFailureCode == FAIL_NoVantage ) )
			{
				if ( TargetNotViable( 2, TargetFailureCode, BlockingFriendly ) )
				{
					// Blocked even from a standing posture.
					return true;
				}
				else
				{
					// We DO have a shot if we stand up.  Do it.
					MyMind.RequestPawnToStand();
					return false;
				}
			}
			else
			{
				// Either we're standing or targeting failed for some reason other than the shot was blocked.
				return true;
			}
		}
	}

	//---------------------------------------------------------
	//	OKToControlFacingPolicy (Exposed)
	//---------------------------------------------------------
	function bool OKToControlFacingPolicy() 
	{ 
		// The Mind can do whatever he wants as long as the FC hasn't locked the facing policy.
		return !bLockFacingPolicy;
	}

//-----------------------------------------
Begin:		// ( state Exposed )
//-----------------------------------------
	StateInfoLabel='Begin_Exposed';

	/////////// GBX:naj - This hack fixes problem where wall-climbing (initiated from NavigationController) interferes with FC's one-off timers.
	/////////// (See bug 11614.)
	if ( bSuspendForWallClimb )
	{
		Sleep( 0.25 );		
		TurnOffTimer();
		Goto( 'Begin' );
	}
	//////////

	// First, test if this is an emergency that doesn't allow for the luxury of reloading.
	if ( MyMind.ShouldMelee() )
	{
		Sleep( 0.25 );
		Goto( 'Begin' );	// Spin your wheels until the Mind switches states for us.
	}
	
	bLockFacingPolicy = false;	// Allow the Mind to set the facing policy as he wills--for now.

	if ( MyMind.bUseAIDebugging && MyMind.AITracker != None )
	{
		MyMind.AITracker.StartNewFiringCycle( true );
	}
	
	if ( TheWeapon == None )
	{
		Sleep( 0.1 );
		Goto( 'Begin' );
	}

	// Do we need to reload?
	if ( TheWeapon.NeedsToReload() )
	{		
		// Crouch down first if not moving.
		if ( !MyMind.IsNavigating() && !WGPawn.bIsCrouched )
		{
			MyMind.RequestPawnToCrouch();
			while( WGPawn.IsTransitioning() )
				Sleep( 0.1 );		
		}

		TheWeapon.EnableReload();

		while( TheWeapon.IsReloading() )
			Sleep( 0.1 );
	}

	if ( !CanFireWeapon() )
	{
		Sleep( 0.1 );
		Goto( 'Begin' );
	}

	StateInfoLabel='Exposed_2';

    // Verify that a target exists.
	if ( Target == None || Target.IsDead() )
	{
		if ( MyMind.bUseAIDebugging && MyMind.AITracker != None )
		{
			MyMind.AITracker.AddFiringFactor( Firing_TargetDead );
		}
						
		Goto( 'BackToBegin' );
	}

	// Update our knowledge about the target's location.
	UpdateTargetKnownLocation();

	// Before going further, check if the Grenade Firing Controller wants us to
	// lob a grenade.
	if ( CanThrowGrenade( VSize( TargetLastKnownLoc - WGPawn.Location ) ) )
	{		
		// Stop moving if you're going to throw a grenade.
		NavController.StopManeuvering();
		GotoState( 'ThrowingGrenade' );		
	}
	else if ( bGoingToAssault )
	{
		MyMind.ReportThrowingGrenade( false );
	}

	// No firing allowed while sprinting.
	if ( WGPawn.bIsSprinting )
	{
		Sleep( 0.1 );
		Goto( 'Begin' );
	}

	WGPawn.SetWeaponAimedState( WAS_Sighted );
		
	LogSelective( "Checking for opburst..." );
	if ( CheckForOpBurst() && !MyMind.HasFreeOpBurst() )	// Don't send a message if the Unit already knows about it.
	{
		if ( MyMind.bUseAIDebugging && MyMind.AITracker != None )
		{
			MyMind.AITracker.AddFiringFactor( Firing_OpBurst );
		}
		// TBD: Notify teammates that I'm firing an op-burst.
		SendOpBurstMessage();
	}

	LogSelective( "Determing target viability of "$Target.Name$"..." );
	if ( TargetingFailed() )
	{
		LogSelective( "Targeting failed for "$Target.Name$"." );
		NotifyTargetFailureMind( TargetFailureCode, BlockingFriendly );

		if ( WGPawn.IsWeaponFiring() )
			WGPawn.StopFiringWeapon();
		StateInfoLabel='Target_Not_Viable';
		
		Goto( 'BackToBegin' );
	}

	bLockFacingPolicy = true;	// Don't allow the Mind to change the facing policy while FC is trying to shoot.
	MyMind.RequestFacingPolicy( FACE_Enemy );

	MyMind.SetAimingAtTarget( Target );
	
	StateInfoLabel='Trying_To_Aim';
	LogSelective( "Trying to aim..." );

	// Don't spend more than 4 seconds aiming at the target.
	/*
	SetOneOffTimer( 4.0 );
	while( !WGPawn.IsAimingAtTarget() && bWaitForTimer )
	{
		Sleep(0.3);
	}
	*/

	StateInfoLabel='Trying_To_Aim_2';

	// Determine the burst length based on the current suppression level of this pawn's unit.
	BurstCount = DetermineBurstCount();

	if ( true/*bIsFrenzied*/ || WGPawn.IsAimingAtTarget() )
	{
		StateInfoLabel='WaitingForBurst';
		LogSelective( "Targeting succeeded, firing at "$Target.Name$"..." );

		if ( BurstCount > 0 )
		{
			MyMind.NotifyPreparingToFire( true, Target );

			TheWeapon.DisableReload();	// Disable reload because when the clip runs out, we want the pawn to crouch first before reloading.
			FireBurstWithTimer();
			while ( IsWeaponFiring() )
				Sleep( 0.1 );

			WGPawn.StopFiringWeapon();

			MyMind.NotifyPreparingToFire( false );
		}

		StateInfoLabel='BurstFinished';
	}
	else
	{
		//log("NAJ**** Pawn is not aiming at target.", 'naj');
		if ( MyMind.bUseAIDebugging && MyMind.AITracker != None )
		{
			MyMind.AITracker.AddFiringFactor( Firing_CantAim );
		}
	}	


//-----------------------------------------
BackToBegin:
//-----------------------------------------
	PauseTime = GetPauseTime();
	SetOneOffTimer( PauseTime );
	while( bWaitForTimer && !bSuspendForWallClimb )
		Sleep(0.2);

	Sleep( 0.1 );

	Goto( 'Begin' );
}

//=========================================================
//	State ThrowingGrenade
//=========================================================
state ThrowingGrenade
{
	//---------------------------------------------------------
	//	BeginState
	//---------------------------------------------------------
	function BeginState()
	{
		WGPawn.StopFiringWeapon();
		WGPawn.StartGoingToStand();
	}
	
	//---------------------------------------------------------
	//	IsOKToChangePawnPosture
	//---------------------------------------------------------
	function bool IsOKToChangePawnPosture()
	{
		return false;	// Hey Mind, don't make me crouch when I'm trying to stand!
	}

//-----------------------------------------
Begin:	// State ThrowingGrenade
//-----------------------------------------
	
	StateInfoLabel='Standing_Up';

	DontInterruptMe();

	while( WGPawn.IsTransitioning() )
		Sleep( 0.1 );

	StateInfoLabel='Throwing_Grenade';

	if ( GrenadeFireCtrl.AttackTargetIndex( GrenadeIndex ) )
	{
		if ( bGoingToAssault )
		{
			MyMind.ReportThrowingGrenade( true );
		}

		// Announce to the world that you're lobbing a grenade.
		SpeakThrowingGrenade();

		// Stand still until the grenade has been thrown.
		while( GrenadeFireCtrl.bAttackPending )
			Sleep( 0.1 );		
	}	

	OKToInterruptMe();
	GotoState( 'Exposed' );
}

function NotifyMeleeAnimFinished() {}
function DoMeleeLunge() {}

//=========================================================
//	State Melee
//=========================================================
state Melee
{
	//---------------------------------------------------------
	//	BeginState (Melee)
	//---------------------------------------------------------
	function BeginState()
	{	
		LogSelective( "BeginState." );
		SetFrenzied( true );
		MyMind.SetAimingAtTarget( None );
		TheWeapon.DisableReload();
		PawnMeleeLocation = Vect(0,0,0);
	}

	//---------------------------------------------------------
	//	EndState (Melee)
	//---------------------------------------------------------
	function EndState()
	{
		LogSelective( "EndState." );
		
		TheWeapon.EnableReload();

		// GBX:PAD: Make sure the pawn isn't dying while in melee.  If so, we don't want to zero out the velocity
		// since it causes issues with Karma.
		if (!WGPawn.IsDead())
		{
			WGPawn.Velocity = vect(0,0,0);
		}

		if ( WGPawn.MyUnit != None )
		{
			WGPawn.MyUnit.StopMeleeTarget( WGPawn );
		}
	}

	//---------------------------------------------------------
	//	CanChargeEnemy (Melee)
	//---------------------------------------------------------
	// Logic: Pawn must be within a certain distance and facing the target
	// to do a melee charge.
	function bool CanChargeEnemy( out byte bTraceBlocked ) 
	{
		local float DistToTarget;
		local Vector Vect1, Vect2, HitLoc, HitNorm;
		local Actor HitActor;
		local bool bResult;

		DistToTarget = VSize( Target.Location - WGPawn.Location );
		
		Vect1 = Vector( WGPawn.Rotation );
		Vect1.Z = 0;
		Vect1 = Normal( Vect1 );
		Vect2 = Target.Location - WGPawn.Location;
		Vect2.Z = 0;
		Vect2 = Normal( Vect2 );
		
		// Do a last-minute linetrace to make sure there's no geometry between me and him.
		bTraceBlocked = 0;
		HitActor = Trace( HitLoc, HitNorm, Target.Location, WGPawn.Location,, MeleeTraceExtent );

		if ( HitActor == None || HitActor == Target || HitActor == WGPawn )
		{
			bResult = ( DistToTarget <= MeleeStrikeDist && ( Vect1 dot Vect2 >= MeleeFacingDot ) );
		}
		else
		{
			bTraceBlocked = 1;
		}

		LogSelective( "CanChargeEnemy: "$bResult$" ; trace blocked: "$bTraceBlocked );

		return bResult;
	}

	//---------------------------------------------------------
	//	DoMeleeLunge (Melee)
	//---------------------------------------------------------
	function DoMeleeLunge() 
	{
		local float DistToTarget;
		local Vector NewVelo;

		DistToTarget = VSize( Target.Location - WGPawn.Location );
		if ( DistToTarget >= MeleeRootMotionDist )
		{
			NewVelo = MeleeChargeSpeed * Normal( Target.Location - WGPawn.Location );
			NewVelo.Z = 200.0;
			WGPawn.AddVelocity( NewVelo );
		}
	}

	//---------------------------------------------------------
	//	ChargeEnemy (Melee)
	//---------------------------------------------------------
	function ChargeEnemy() 
	{
		local Pawn PlayerPawn;
		LogSelective( "ChargeEnemy." );

		NavController.StopManeuvering();
		WGPawn.ResetLookAtImmediate( true, true, true );
		WGPawn.SetRotation( Rotator( Target.Location - WGPawn.Location ) );						

		bWaitForCallback = true;

		PlayerPawn = WGPawn.MyUnit.GetControllingPlayerController().Pawn;
		Level.TheAISpeechManager.PlaySpeech(
			WGPawn,
			PlayerPawn,
			'Melee',
			,
			,
			0.0,
			Target,
			8.0,
			5.0
		);

		WGPawn.PlayMelee( 0 );
	}
	
	//---------------------------------------------------------
	//	CanShootEnemy (Melee)
	//---------------------------------------------------------
	function bool CanShootEnemy()
	{
		local bool bResult;

		// Certain weapons (e.g. K98) are way too slow to shoot at all when this close to the enemy.
		bResult = ( TheWeapon.HasAmmo() && TheWeapon.CanShootDuringMelee() );

		LogSelective( "CanShootEnemy: "$bResult );
		return bResult;
	}

	//---------------------------------------------------------
	//	NotifyMeleeAnimFinished (Melee)
	//---------------------------------------------------------
	function NotifyMeleeAnimFinished() 
	{
		local WargamePawn aPawn;
		
		bWaitForCallback = false;

		// GBX:PAD: Make sure this guy is still alive since otherwise it resets the velocity down to 0 and will kill
		// the ragdoll physics.
		if (!WGPawn.IsDead())
		{
			WGPawn.SetRotation( Rotator( Target.Location - WGPawn.Location ) );

			foreach WGPawn.TouchingActors( class'WargamePawn', aPawn )
			{
				if ( aPawn == Target )
				{
					NavController.ManeuverToVector( WGPawn.Location + 100.0 * Normal( WGPawn.Location - Target.Location ) );
					return;
				}
			}

			NavController.StopManeuvering();
			WGPawn.Velocity = Vect( 0,0,0 );
		}
	}

	//---------------------------------------------------------
	//	FriendlyBlockingMelee (Melee)
	//---------------------------------------------------------
	function bool FriendlyBlockingMelee( out gbxPawn BlockingFriendly )
	{
		local Vector EndTrace, ChargeVector, ToFriendly;
		local gbxPawn OneFriendly;
		local int index;
		local float Dist, DistToTarget, DotVal;

		EndTrace = Target.Location;

		ChargeVector = EndTrace - WGPawn.Location;
		DistToTarget = VSizeIgnoreZ( ChargeVector );
		ChargeVector.Z = 0;
		ChargeVector = Normal( ChargeVector );

		// Compare the dot-product of the melee charge direction with a vector to each
		// friendly in the map.  If the dot-product is sufficiently large ( near 1.0 ),
		// and the friendly is closer to us than the target is, this means a 
		// friendly is blocking our charge path.
		if ((WGPawn.MyUnit != None) && (WGPawn.MyUnit.IsA('MultiplayerUnit')))
		{
			index = WGPawn.GetNextTeammateByTeam( MultiplayerUnit(WGPawn.MyUnit).Team, 0, OneFriendly );
		}
		else
		{
			index = WGPawn.GetNextTeammate( 0, OneFriendly );
		}

		while( index != -1 )
		{
			if ( OneFriendly != WGPawn && !OneFriendly.IsDead() )
			{
				Dist = VSizeIgnoreZ( OneFriendly.Location - WGPawn.Location );

				//if ( Dist < ( DistToTarget + 75.0 ) )
				if ( Dist < DistToTarget + 75.0 )
				{
					ToFriendly = OneFriendly.Location - WGPawn.Location;
					ToFriendly.Z = 0;
					ToFriendly = Normal( ToFriendly );

					DotVal = ToFriendly dot ChargeVector;
					if ( DotVal >= MeleeFriendlyFireDot )
					{
						BlockingFriendly = WargamePawn( OneFriendly );
						LogSelective( "FriendlyBlockingMelee: true; "$BlockingFriendly.Name );
						return true;
					}					
				}
			}

			if ((WGPawn.MyUnit != None) && (WGPawn.MyUnit.IsA('MultiplayerUnit')))
			{
				index = WGPawn.GetNextTeammateByTeam( MultiplayerUnit(WGPawn.MyUnit).Team, index, OneFriendly );
			}
			else
			{
				index = WGPawn.GetNextTeammate( index, OneFriendly );
			}
		}

		BlockingFriendly = None;

		LogSelective( "FriendlyBlockingMelee: false." );
		return false;
	}	


//-----------------------------------------
Begin:	// State Melee
//-----------------------------------------

	// Look your enemy right in the eyes.
	WGPawn.SetLookAtPoint( Target.Location + Target.EyePosition() + MeleeEyesOffset, true, true );

	LogSelective( "Checking for friendlies blocking melee..." );

	if ( FriendlyBlockingMelee( BlockingFriendly ) )
	{
		TargetFailureCode = FAIL_FriendlyInWay;
		NotifyTargetFailureMind( TargetFailureCode, BlockingFriendly );
		Sleep( 0.1 );
		Goto( 'Begin' );
	}	

	// Check if we can claim this enemy as a melee target.
	if ( WGPawn.MyUnit != None && WGPawn.MyUnit.RequestMeleeTarget( WGPawn, Target ) )
	{
		if ( CanChargeEnemy( bMeleeTraceBlocked ) )
		{
			ChargeEnemy();
			
			while( bWaitForCallback )
				Sleep( 0.1 );		
		}	
		else if ( bMeleeTraceBlocked == 0 && VSize( WGPawn.Location - PawnMeleeLocation ) > 0.000001f )
		{
			// Not close enough to charge yet.  Move straight for your target.
			LogSelective( "Maneuvering directly toward target..." );
			NavController.ManeuverToVector( Target.Location + 100.0 * Normal( WGPawn.Location - Target.Location ) );
			
			PawnMeleeLocation = WGPawn.Location;
			Sleep( 0.2 );
			Goto( 'Begin' );
		}
		else
		{
			TargetFailureCode = FAIL_CantMelee;
			NotifyTargetFailureMind( TargetFailureCode );
			Sleep( 0.1 );
			// Mind should have yanked us out of this state by now.
		}
	}	
	else
	{
		TargetFailureCode = FAIL_CantClaimMelee;
		NotifyTargetFailureMind( TargetFailureCode );
		Sleep( 0.1 );
		// Mind should have yanked us out of this state by now.
	}
	
	Sleep( 0.1 );
	Goto( 'Begin' );
}

function SetFacingDirection( optional bool bAboutToFire ) {}

//=========================================================
//	State FFCBase
//=========================================================
// This state is a container for functions common to the family
// of FiringFromCover(tm) states, otherwise known as FFC.
//
state FFCBase
{
	//---------------------------------------------------------
	//	BeginState (FFCBase)
	//---------------------------------------------------------
	function BeginState()
	{
		LogSelective( "BeginState()" );
		bWaitForCallback = false;
		TurnOffTimer();
	}

	//---------------------------------------------------------
	//	EndState (FFCBase)
	//---------------------------------------------------------
	function EndState()
	{
		LogSelective( "EndState()" );
		bWaitForCallback = false;
		TurnOffTimer();
		WGPawn.StopFiringWeapon();
	}	

	//---------------------------------------------------------
	//	IsFiringFromCover (FFCBase)
	//---------------------------------------------------------
	function bool IsFiringFromCover() 
	{ 
		return true; 
	}

	//---------------------------------------------------------
	//	CheckPendingState (FFCBase)
	//---------------------------------------------------------
	// Check to see if a pending-state was set while we were locked.
	// If that state is one of the FFC family of states, just go directly
	// to it.  If that state is outside of the FFC family, it will
	// be handled by CheckShouldLeaveFFC().
	//
	function CheckPendingState() 
	{
		local Name TempState;

		if ( PendingStateChange != '' && PendingStateChange != 'Exposed' )
		{
			LogSelective( "CheckPendingState: Going to pending state "$PendingStateChange );
			TempState = PendingStateChange;
			PendingStateChange = '';
			GotoState( TempState );		// Warning: don't put any code after this GotoState().
		}
	}

	//---------------------------------------------------------
	//	CheckShouldLeaveFFC (FFCBase)
	//---------------------------------------------------------
	function CheckShouldLeaveFFC()
	{
		// ASSUMPTION: bDontInterruptMe is false.

		if ( PendingStateChange != '' )
		{
			LogSelective( "CheckShouldLeaveFFC(): A Pending State awaits us: "$PendingStateChange );
			GotoState( 'LeavingFFC' );
		}		
	}

	//-----------------------------------------------------
	//	IsAtLowCover (FFCBase)
	//-----------------------------------------------------
	function bool IsAtLowCover()
	{
		local bool bResult;		

		if ( Threat == None )
		{
			bResult =	MyMind.HasAnyLowCover( WGPawn.MyClaimedNavPoint ) &&
						!MyMind.HasAnyCrouchedCover( WGPawn.MyClaimedNavPoint );
		}
		else if ( WGPawn.MyClaimedNavPoint.bIsNavigationPoint )
		{
			bResult =	( NavigationPoint( WGPawn.MyClaimedNavPoint ).ProvidesCoverFrom( Threat.Location, 0 ) && 
						 !NavigationPoint( WGPawn.MyClaimedNavPoint ).ProvidesCoverFrom( Threat.Location, 1 ) );
		}
		else if ( WGPawn.MyClaimedNavPoint.bIsNavigationPointLite )
		{
			bResult =	( NavigationPointLite( WGPawn.MyClaimedNavPoint ).ProvidesCoverFrom( Threat.Location, 0 ) && 
						 !NavigationPointLite( WGPawn.MyClaimedNavPoint ).ProvidesCoverFrom( Threat.Location, 1 ) );
		}

		LogSelective( "IsAtLowCover(): "$bResult );
		return bResult;
	}

	//---------------------------------------------------------
	//	VantageNoLongerValid (FFCBase)
	//---------------------------------------------------------
	// Called by outsiders (Mind, namely).
	function bool VantageNoLongerValid()
	{		
		// This point is bad for vantage if the target is behind you.
		// (unless you are standing with your back to a full-height wall.
		local bool bResult;
		local Vector ToTargetVect, WallFacingVect;
		
		if ( WGPawn.m_bStandingBackToWall )
		{
			LogSelective( "VantageNoLongerValid: Pawn is standing with back to a wall, so he really *has* no vantage, does he?" );
			return false;	// Standing with back to full-height wall.
		}

		if ( WGPawn == None || Target == None )
		{
			return false;
		}
		
		// Target must be visible for us to comment on whether vantage is valid.
		if ( MyMind.GetTargetExposure( Target ) < 0.0001f )
		{
			return false;
		}
		
		UpdateTargetKnownLocation();

		ToTargetVect = Normal( TargetLastKnownLoc - WGPawn.Location );
		if ( !MyMind.GetWallFacingVector( false, true, WallFacingVect ) )
			WallFacingVect = Vector( WGPawn.Rotation );

		bResult = ( ToTargetVect dot WallFacingVect <= 0 );

		if ( bResult )
		{
			LogSelective( "VantageNoLongerValid: true for Target "$Target.Name );
		}

		return bResult;
	}

	//---------------------------------------------------------
	//	Tick (FFCBase)
	//---------------------------------------------------------
	function Tick( float DeltaTime )
	{
		Super.Tick( DeltaTime );

		LerpLocation( DeltaTime );

		if ( Level.TimeSeconds >= NextCheckLeaveFFCTime )
		{			
			NextCheckLeaveFFCTime = Level.TimeSeconds + CheckLeaveFFCInterval;
			if ( !bDontInterruptMe )
				CheckShouldLeaveFFC();
		}		
	}

	//---------------------------------------------------------
	//	Timer (FFCBase)
	//---------------------------------------------------------
	function Timer()
	{
		TurnOffTimer();
	}

	//---------------------------------------------------------
	//	DontInterruptMe (FFCBase)
	//---------------------------------------------------------
	function DontInterruptMe()
	{
		bDontInterruptMe = true;
	}

	//---------------------------------------------------------
	//	OKToInterruptMe (FFCBase)
	//---------------------------------------------------------
	function OKToInterruptMe()
	{
		LogSelective( "OKToInterruptMe()." );
		bDontInterruptMe = false;
		CheckPendingState();
		CheckShouldLeaveFFC();
	}

	//---------------------------------------------------------
	//	NotifySuppressed (FFCBase)
	//---------------------------------------------------------
	function NotifySuppressed()
	{
		Global.NotifySuppressed();
		WGPawn.StopFiringWeapon();
		TurnOffTimer();
	}

	//---------------------------------------------------------
	//	NotifyRally (FFCBase)
	//---------------------------------------------------------
	function NotifyRally()
	{
		Global.NotifyRally();
		TurnOffTimer();		
	}

	//---------------------------------------------------------
	//	CanCornerLook (FFCBase)
	//---------------------------------------------------------
	function bool CanCornerLook( out ECornerDir Direction )
	{
		// Don't peek unless your back is to the target.
		if ( !WGPawn.MyClaimedNavPoint.IsA( 'CornerPoint' ) || !WGPawn.m_bCornerHunkered )
			return false;

		return true;
	}	

	//---------------------------------------------------------
	//	FaceTowardWalls (FFCBase)
	//---------------------------------------------------------
	function FaceTowardWalls()
	{
		local Rotator NavPointRot;
		local Vector HitNormal, NavPointLoc;
		local NavigationPoint NavPoint;
		local NavigationPointLite NavPointLite;
		local bool bIsDirectional;

		bIsDirectional = false;
		if (WGPawn.MyClaimedNavPoint.bIsNavigationPoint)
		{
			NavPoint = NavigationPoint( WGPawn.MyClaimedNavPoint );
			bIsDirectional = NavPoint.bDirectional;
			NavPointLoc = NavPoint.Location;
			NavPointRot = NavPoint.Rotation;
		}
		else if ( WGPawn.MyClaimedNavPoint.bIsNavigationPointLite )
		{
			NavPointLite = NavigationPointLite( WGPawn.MyClaimedNavPoint );
			NavPointLoc = NavPointLite.Location;
			NavPointRot = NavPointLite.Rotation;
		}

		if ( bIsDirectional )
		{
			HitNormal = Vector( NavPointRot );
			HitNormal.Z = 0;
			HitNormal = Normal( HitNormal );

			MyMind.RequestFacingPolicy( FACE_Vector );
			MyMind.FacingVector = WGPawn.Location + 1000 * -HitNormal;
		}
		else
			MyMind.FaceTowardWalls();
	}

	//---------------------------------------------------------
	//	SetFacingDirection (FFCBase)
	//---------------------------------------------------------
	function SetFacingDirection( optional bool bAboutToFire )
	{
		if ( IsAtLowCover() && Target != None && MyMind.Enemy != None )
		{
			MyMind.RequestFacingPolicy( FACE_Enemy );
		}
		else if ( WGPawn.m_bCornerHunkered || WGPawn.m_bUsingCrouchedCover /*|| IsAtLowCover()*/ )
		{
			if ( bAboutToFire && Target != None && MyMind.Enemy != None )
			{
				MyMind.RequestFacingPolicy( FACE_Enemy );
			}
			else
			{
				FaceTowardWalls();
				if ( (WGPawn != None) && (MyMind.Enemy != None) )
					WGPawn.ResetLookAt( true,true,true );
			}
		}
		else
		if ( !WGPawn.bIsCrouched && !IsAtLowCover() )
		{
			MyMind.FaceAwayFromWalls();
			if ( (WGPawn != None) && (MyMind.Enemy != None) )
			{
				WGPawn.ResetLookAt( true,true,true );
				WGPawn.bDoTorsoTwist = false;
			}
		}
	}

	//---------------------------------------------------------
	//	IsNearCoverPoint (FFCBase)
	//---------------------------------------------------------
	function bool IsNearCoverPoint()
	{
		local Vector CoverLoc;

		if (WGPawn.MyClaimedNavPoint.bIsNavigationPoint)
			CoverLoc = NavigationPoint(WGPawn.MyClaimedNavPoint).Location;
		else if (WGPawn.MyClaimedNavPoint.bIsNavigationPointLite)
			CoverLoc = NavigationPointLite(WGPawn.MyClaimedNavPoint).Location;

		return VSizeIgnoreZ( CoverLoc - WGPawn.Location ) <= DestinationRadius;
	}

	//---------------------------------------------------------
	//	CanPeekAboveWall (FFCBase)
	//---------------------------------------------------------
	function bool CanPeekAboveWall()
	{
		local bool bProvidesStandingCover, bProvidesCrouchedCover;

		bProvidesStandingCover = false;
		bProvidesCrouchedCover = false;

		if ( Threat == None )
		{
			bProvidesStandingCover = MyMind.HasAnyStandingCover( WGPawn.MyClaimedNavPoint );
			bProvidesCrouchedCover = MyMind.HasAnyCrouchedCover( WGPawn.MyClaimedNavPoint );
		}
		else if (WGPawn.MyClaimedNavPoint.bIsNavigationPoint)
		{
			bProvidesStandingCover = NavigationPoint(WGPawn.MyClaimedNavPoint).ProvidesCoverFrom( Threat.Location, 2 );
			bProvidesCrouchedCover = NavigationPoint(WGPawn.MyClaimedNavPoint).ProvidesCoverFrom( Threat.Location, 1 );
		}
		else if (WGPawn.MyClaimedNavPoint.bIsNavigationPointLite)
		{
			bProvidesStandingCover = NavigationPointLite(WGPawn.MyClaimedNavPoint).ProvidesCoverFrom( Threat.Location, 2 );
			bProvidesCrouchedCover = NavigationPointLite(WGPawn.MyClaimedNavPoint).ProvidesCoverFrom( Threat.Location, 1 );
		}

		if ( bProvidesCrouchedCover && !bProvidesStandingCover && !WGPawn.m_bCornerHunkered && WGPawn.bIsCrouched )
			return true;
		else
			return false;
	}

	//---------------------------------------------------------
	//	RequestStopFiringFromCover (FFCBase)
	//---------------------------------------------------------
	function RequestStopFiringFromCover( optional bool bForGesture ) 
	{
		PendingStateChange = 'Exposed';
		LogSelective( "RequestStopFiringFromCover(). PendingState="$PendingStateChange$" ; bDontInterrupt="$bDontInterruptMe$" ; IsTransitioning()="$WGPawn.IsTransitioning() );
		if ( !bDontInterruptMe && !WGPawn.IsTransitioning() )
		{
			GotoState( 'LeavingFFC' );
		}
	}

	//---------------------------------------------------------
	//	RequestPlayGesture
	//---------------------------------------------------------
	function RequestPlayGesture( Name Gesture )
	{
		if ( Gesture == '' )
		{
			LogSelective( "RequestPlayGesture: Canceled." );
		}
		else
		{
			LogSelective( "RequestPlayGesture: Gesture=="$Gesture );
		}
		PendingGesture = Gesture;
	}
}

//---------------------------------------------------------
//	LerpLocation
//---------------------------------------------------------
function LerpLocation( float DeltaTime )
{
	local Vector TravelVect;	
	local float DistToNode;

	if ( !bLerpLocation || WGPawn.MyClaimedNavPoint == None )
		return;

	TravelVect = GetLocation( WGPawn.MyClaimedNavPoint ) - WGPawn.Location;
	DistToNode = VSize( TravelVect );

	if ( DistToNode <= MyMind.DestinationRadius && !MyMind.IsNavigating() )
	{
		TravelVect.Z = 0;
		WGPawn.SetLocation( WGPawn.Location + DeltaTime * LerpMultiplier * TravelVect );
	}	
}

//=========================================================
//	State FiringFromCover
//=========================================================
state FiringFromCover extends FFCBase
{
	//-----------------------------------------------------
	//	BeginState (FiringFromCover)
	//-----------------------------------------------------
	function BeginState()
	{
		Super.BeginState();

		if ( WGPawn.MyClaimedNavPoint != None && WGPawn.MyClaimedNavPoint.IsA( 'TankCornerPoint' ) )
		{
			bLerpLocation = true;
		}

		bMountSuccessful = false;

		// Turn off head-tracking (ONLY if you currently have an Enemy!!!)
		if ( (WGPawn != None) && (MyMind.Enemy != None) )
			WGPawn.bDoHeadTurn = false;

		if ( MyMind != None )
			MyMind.RequestFacingPolicy( FACE_NoChange );

		// Stop firing any lingering weapon burst, and don't allow reloading until we're ready for it.
		if ( WGPawn != None )
			WGPawn.StopFiringWeapon();
		if ( TheWeapon != None )
			TheWeapon.DisableReload();
	}

	//-----------------------------------------------------
	//	EndState (FiringFromCover)
	//-----------------------------------------------------
	function EndState()
	{
		Super.EndState();
		
		if ( MountCtrl != None )
		{
			MountCtrl.StopMountAction();
		}	
	}	

	//---------------------------------------------------------
	//	DoMountAction (FiringFromCover)
	//---------------------------------------------------------
	function bool DoMountAction()
	{
		// Use the Mount Controller to maneuver the pawn precisely to the cover point,
		// and to play the appropriate mounting animation.			
		local bool bProvidesStandingCover, bProvidesCrouchedCover, bProvidesLowCover;
		local Vector NavPointLoc, WallFacingVect;		
		local CornerPoint Corner;
		local NavigationPoint NavPoint;
		local NavigationPointLite NavPointLite;				
		local Rotator NavRot, WallFacingRot;

		//LogSelective( "DoMountAction: Threat=="$Threat$" ; ClaimedNav=="$WGPawn.MyClaimedNavPoint );

		// The pawn may be standing at a corner point but not actually in combat.  Mount the corner anyway.
		if ( Threat == None )
		{
			if ( WGPawn.MyClaimedNavPoint.IsA( 'CornerPoint' ) )
			{							
				Corner = CornerPoint( WGPawn.MyClaimedNavPoint );
				NavRot = Corner.Rotation;
				NavRot.Pitch = 0;
				if ( Corner.ProvidesCoverFrom( Corner.Location - 500.0*Vector( Corner.Rotation ), 2 ) )
				{
					bWaitForCallback = true;
					MountCtrl.DoMountAction( Mount_MountCornerStanding, WGPawn.MyClaimedNavPoint, true, true, class'FiringControllerCallback', Rotator( Vect(-1,0,0)>>NavRot) );
				}
				else
				{
					bWaitForCallback = true;
					MountCtrl.DoMountAction( Mount_MountCornerCrouched, WGPawn.MyClaimedNavPoint, true, true, class'FiringControllerCallback', Rotator( Vect(-1,0,0)>>NavRot) );
				}
				return true;
			}
			else
			{
				// No threats around, but use cover points anyway.
				bProvidesStandingCover = MyMind.HasAnyStandingCover( WGPawn.MyClaimedNavPoint );
				bProvidesCrouchedCover = MyMind.HasAnyCrouchedCover( WGPawn.MyClaimedNavPoint );
				bProvidesLowCover = MyMind.HasAnyLowCover( WGPawn.MyClaimedNavPoint );
			}
		}
		else
		{
			// Otherwise, the pawn is in combat and is assumed to have a threat.
			if ( WGPawn.MyClaimedNavPoint.bIsNavigationPoint )
			{
				NavPoint = NavigationPoint( WGPawn.MyClaimedNavPoint );
				NavPointLoc = NavPoint.Location;	
				bProvidesStandingCover = NavPoint.ProvidesDoubleCoverFrom( Threat.Location, 2 );
				bProvidesCrouchedCover = NavPoint.ProvidesCoverFrom( Threat.Location, 1 );
				bProvidesLowCover = NavPoint.ProvidesCoverFrom( Threat.Location, 0 );
			}
			else if ( WGPawn.MyClaimedNavPoint.bIsNavigationPointLite )
			{
				NavPointLite = NavigationPointLite( WGPawn.MyClaimedNavPoint );
				NavPointLoc = NavPointLite.Location;
				bProvidesStandingCover = NavPointLite.ProvidesDoubleCoverFrom( Threat.Location, 2 );
				bProvidesCrouchedCover = NavPointLite.ProvidesCoverFrom( Threat.Location, 1 );
				bProvidesLowCover = NavPointLite.ProvidesCoverFrom( Threat.Location, 0 );
			}
		}

		//LogSelective( "DoMountAction: bProvidesStandingCover=="$bProvidesStandingCover$" ; bProvidesCrouchedCover=="$bProvidesCrouchedCover$" ; bProvidesLowCover "$bProvidesLowCover );
		if ( !WGPawn.m_bStandingBackToWall || !IsNearCoverPoint() )
		{			
			// Test 1: Is this a corner point?
			if ( WGPawn.MyClaimedNavPoint.IsA( 'CornerPoint' ) && bProvidesCrouchedCover )
			{
				Corner = CornerPoint( WGPawn.MyClaimedNavPoint );
				NavRot = Corner.Rotation;
				NavRot.Pitch = 0;
				if ( bProvidesStandingCover )
				{
					bWaitForCallback = true;
					MountCtrl.DoMountAction( Mount_MountCornerStanding, WGPawn.MyClaimedNavPoint, true, true, class'FiringControllerCallback', Rotator( Vect(-1,0,0)>>NavRot) );
				}
				else
				{
					bWaitForCallback = true;
					MountCtrl.DoMountAction( Mount_MountCornerCrouched, WGPawn.MyClaimedNavPoint, true, true, class'FiringControllerCallback', Rotator( Vect(-1,0,0)>>NavRot) );
				}
			}
			else
			{
				if ( bProvidesStandingCover )
				{
					//LogSelective( "DoMountAction: Mounting cover standing up." );
					if ( MyMind.GetWallFacingVector( true, false, WallFacingVect ) )
						WallFacingRot = Rotator( WallFacingVect );
					else
						WallFacingRot = WGPawn.Rotation;

					bWaitForCallback = true;										
					MountCtrl.DoMountAction( Mount_MountCoverStanding, WGPawn.MyClaimedNavPoint, true, true, class'FiringControllerCallback', WallFacingRot );
				}
				else if ( bProvidesCrouchedCover )
				{
					//LogSelective( "DoMountAction: Mounting cover crouched." );
					if ( MyMind.GetWallFacingVector( false, true, WallFacingVect ) )
						WallFacingRot = Rotator( WallFacingVect );
					else
						WallFacingRot = WGPawn.Rotation;

					bWaitForCallback = true;
					MountCtrl.DoMountAction( Mount_MountCoverCrouched, WGPawn.MyClaimedNavPoint, true, true, class'FiringControllerCallback', WallFacingRot );
				}
				else	// Low cover
				{
					//LogSelective( "DoMountAction: Mounting low cover." );
					if ( MyMind.GetWallFacingVector( false, true, WallFacingVect ) )
						WallFacingRot = Rotator( WallFacingVect );
					else
						WallFacingRot = WGPawn.Rotation;

					bWaitForCallback = true;
					MountCtrl.DoMountAction( Mount_MountCoverLow, WGPawn.MyClaimedNavPoint, true, false, class'FiringControllerCallback', WallFacingRot );
				}
			}

			return true;
		}
		else
		{
			// Already mounted.
			return false;
		}
	}

	//---------------------------------------------------------
	//	SkipMountAction (FiringFromCover)
	//---------------------------------------------------------
	// Where DoMountAction() gets a pawn into his "hunkered" position, 
	// this function goes straight to the shootin'.
	//
	function bool SkipMountAction( out name NextStateName )
	{
		local ECornerDir LeanDirection;
		local NavigationPoint NavPoint;
		local NavigationPointLite NavPointLite;
		local bool bProvidesStandingCover, bProvidesCrouchedCover, bProvidesLowCover;

		if ( Threat == None )
		{
			bProvidesStandingCover = MyMind.HasAnyStandingCover( WGPawn.MyClaimedNavPoint );
			bProvidesCrouchedCover = MyMind.HasAnyCrouchedCover( WGPawn.MyClaimedNavPoint );
			bProvidesLowCover = MyMind.HasAnyLowCover( WGPawn.MyClaimedNavPoint );
		}
		else if ( WGPawn.MyClaimedNavPoint.bIsNavigationPoint )
		{
			NavPoint = NavigationPoint( WGPawn.MyClaimedNavPoint );
			bProvidesStandingCover = NavPoint.ProvidesCoverFrom( Threat.Location, 2 );
			bProvidesCrouchedCover = NavPoint.ProvidesCoverFrom( Threat.Location, 1 );
			bProvidesLowCover = NavPoint.ProvidesCoverFrom( Threat.Location, 0 );
		}
		else if ( WGPawn.MyClaimedNavPoint.bIsNavigationPointLite )
		{
			NavPointLite = NavigationPointLite( WGPawn.MyClaimedNavPoint );
			bProvidesStandingCover = NavPointLite.ProvidesCoverFrom( Threat.Location, 2 );
			bProvidesCrouchedCover = NavPointLite.ProvidesCoverFrom( Threat.Location, 1 );
			bProvidesLowCover = NavPointLite.ProvidesCoverFrom( Threat.Location, 0 );
		}

		// Test 1: Is this a corner point?
		if ( WGPawn.MyClaimedNavPoint.IsA( 'CornerPoint' ) && bProvidesCrouchedCover )
		{
			if ( CornerPoint( WGPawn.MyClaimedNavPoint ).IsLeftCorner )
				LeanDirection = CDIR_Right;
			else
				LeanDirection = CDIR_Left;		

			if ( bProvidesStandingCover )
			{
				return false;	// Can't skip the mount sequence.
			}
			else
			{
				WGPawn.CompleteCornerMount( LeanDirection, true );
				WGPawn.m_bStandingOverCorner = true;				
				NextStateName = 'FireOverCorner';
			}
		}
		else
		{
			if ( bProvidesStandingCover )
			{
				return false;	// Can't skip the mount sequence.
			}
			else if ( bProvidesCrouchedCover )
			{
				WGPawn.SetUsingCrouchedCover( true, true );
				NextStateName = 'FireOverWall';
			}
			else
			{
				// The low cover mount sequence is so quick, why bother?
				return false;
			}
		}

		// Additional setup code that would've been executed had we traveled through the normal entry sequence.
		if ( MyMind.bUseAIDebugging && MyMind.AITracker != None )
		{
			MyMind.AITracker.StartNewFiringCycle();
		}
		MyMind.NotifyPreparingToFire( false );

		if ( WGPawn.bIsCrouched )
			WGPawn.StartGoingToStand();

		SetFacingDirection( true );

		if ( WGPawn.MyClaimedNavPoint != None && WGPawn.MyClaimedNavPoint.IsA( 'TankCornerPoint' ) )
		{
			bLerpLocation = true;
		}

		LogSelective( "SkipMountAction: true." );
		return true;
	}
	
//-----------------------------------------
Begin:		// ( state FiringFromCover )
//-----------------------------------------
		
	if ( bPermittedToOpBurst && SkipMountAction( SkipToStateName ) )
	{		
		GotoState( SkipToStateName, 'ConsiderGesturing' );
	}

	DontInterruptMe();

	if ( DoMountAction() )
	{		
		LogSelective( "Doing mount action..." );
		while( bWaitForCallback )
				Sleep( 0.1 );
		
		OKToInterruptMe();
		if ( bMountSuccessful )
		{
			GotoState( 'HunkeredDown' );
		}
		else
		{
			Sleep( 0.1 );
			Goto( 'Begin' );
		}
	}
	else	
	{
		// Already mounted.
		OKToInterruptMe();
		GotoState( 'HunkeredDown' );
	}
}

//=========================================================
//	State HunkeredDown
//=========================================================
state HunkeredDown extends FFCBase
{	
	//-----------------------------------------------------
	//	BeginState (HunkeredDown)
	//-----------------------------------------------------
	function BeginState()
	{
		Super.BeginState();
		if ( MyMind.bUseAIDebugging && MyMind.AITracker != None )
		{
			MyMind.AITracker.StartNewFiringCycle();
		}

		MyMind.NotifyPreparingToFire( false );
	}

	//-----------------------------------------------------
	//	EndState (HunkeredDown)
	//-----------------------------------------------------
	function EndState()
	{
		Super.EndState();
		WGPawn.SetBackToWall( false );
	}

	//-----------------------------------------------------
	//	GetPauseTime (HunkeredDown)
	//-----------------------------------------------------
	function float GetPauseTime()
	{
		local Range PauseRange;

		if ( TheWeapon == None )
		{
			return 0.0;
		}

		if ( Threat == None )
		{
			return RandRange( PauseTime_High_Veteran.Min, PauseTime_High_Veteran.Max );
		}

		if ( bPermittedToOpBurst || IsAtLowCover() )
		{
			return TheWeapon.GetPauseTimeExposed();
		}

		// In single player, the player's teams don't care about suppression but they
		// determine their pause time mainly based on boldness.
		if ( Level.UseMPStyleFatigue() )
		{
			// Multiplayer pawns (U.S. and German)			
			if ( HasTargetOrder() )
				return RandRange( 
					PauseTime_HumanControlledMP_Targeting.Min, 
					PauseTime_HumanControlledMP_Targeting.Max );
			else
				return RandRange( 
					PauseTime_HumanControlledMP.Min, 
					PauseTime_HumanControlledMP.Max );

		}
		else if( !Level.UseMPStyleFatigue() && Level.Game.IsPawnOnSameTeamAsPlayer(WGPawn) )
		{
			// Singleplayer U.S. pawns
			if ( HasTargetOrder() )
				return RandRange( 
					PauseTime_HumanControlledSP_Targeting.Min, 
					PauseTime_HumanControlledSP_Targeting.Max );
			else
				return RandRange( 
					PauseTime_HumanControlledSP.Min, 
					PauseTime_HumanControlledSP.Max );
		}		
		else
		{
			if ( MyMind.GetSuppressionLevel() == SL_UNSUPPRESSED )
			{
				return RandRange( PauseTime_Low.Min, PauseTime_Low.Max );
			}
			else if ( MyMind.GetSuppressionLevel() == SL_SUPPRESSED )
			{
				switch( WGPawn.MyUnit.BaseSkillLevel )
				{
					case SKILL_Novice: 
						PauseRange = PauseTime_High_Novice;
						break;
					case SKILL_Intermediate: 
						PauseRange = PauseTime_High_Interm;
						break;
					case SKILL_Advanced: 
						PauseRange = PauseTime_High_Advanced;
						break;
					case SKILL_Veteran: 
					case SKILL_Invincible:
						PauseRange = PauseTime_High_Veteran;
						break;
				}

				return RandRange( PauseRange.Min, PauseRange.Max );
			}
		}
	}

	//---------------------------------------------------------
	//	ShouldPeekThisRound (HunkeredDown)
	//---------------------------------------------------------
	function bool ShouldPeekThisRound()
	{
		if ((Level.NetMode == NM_StandAlone) && (WGPawn.PawnTeam == TEAM_US))
		{
			// is this game configured to hold fire and is it not time to fire yet?
			if (Level.Game.bHoldFire && ((Level.TimeSeconds - Level.Game.fHoldFireTime) > 30.0))
			{
				return true;
			}
		}

		if ( Threat == None )
			return true;
		else
		// No need to peek if we must fire an op-burst now.
		if ( bPermittedToOpBurst || bGoingToAssault || HasTargetOrder() || IsAtLowCover() )		
			return false;

		// When being assaulted, remain hunkered down for a while, to act "terrified".
		if( MyMind.IsTerrified() )
		{
			return false;
		}

		return ( MyMind.GetSuppressionLevel() == SL_SUPPRESSED );
	}

	//---------------------------------------------------------
	//	ShouldFireThisRound (HunkeredDown)
	//---------------------------------------------------------
	function bool ShouldFireThisRound()
	{
		if ((Level.NetMode == NM_StandAlone) && (WGPawn.PawnTeam == TEAM_US))
		{
			// is this game configured to hold fire and is it not time to fire yet?
			if (Level.Game.bHoldFire && ((Level.TimeSeconds - Level.Game.fHoldFireTime) > 30.0))
			{
				return false;
			}
		}

		if ( Threat == None )
			return false;		
		else if ( bPermittedToOpBurst || bGoingToAssault || HasTargetOrder() || IsAtLowCover() )
			return true;

		// MP games: never stop shooting.
		if ( Level.UseMPStyleFatigue() )
		{
			return true;
		}

		// When being assaulted, remain hunkered down for a while, to act "terrified".
		if( MyMind.IsTerrified() )
		{
			return false;
		}

		return ( MyMind.GetSuppressionLevel() == SL_UNSUPPRESSED );
	}

	//---------------------------------------------------------
	//	NotifyPrepareAssault (HunkeredDown)
	//---------------------------------------------------------
	function NotifyPrepareAssault()
	{
		Super.NotifyPrepareAssault();
		if ( bDontInterruptMe )
		{
			PendingStateChange = 'ConsiderFiringOptions';
		}
		else
		{
			GotoState( 'ConsiderFiringOptions' );
		}
	}	

//-----------------------------------------
Begin:	// (state HunkeredDown)
//-----------------------------------------
	
	LogSelective( "Beginning hunker..." );		

	SetFacingDirection();

	// At tank corner points, give the pawn an extra nudging to put him right on top of the node.
	if ( WGPawn.MyClaimedNavPoint != None && WGPawn.MyClaimedNavPoint.IsA( 'TankCornerPoint' ) && !IsNearCoverPoint() )
	{		
		bLerpLocation = true;	// Should be true anyway, but...
		Sleep( 0.25 );
		Goto( 'Begin' );
	}

	// The lerp code has by this point pushed us close enough.
	bLerpLocation = false;

	if ( TheWeapon == None )
	{
		LogSelective( "Pawn doesn't have a weapon yet!" );
		Sleep( 1.0 );
		Goto( 'Begin' );
	}

	//LogSelective( "Giving pawn opportunity to reload..." );
	DontInterruptMe();
	TheWeapon.EnableReload();

	// Our boy might be reloading.  Hang back until finished.
	while( TheWeapon.IsReloading() )
		Sleep( 0.1 );

	OKToInterruptMe();
	
	PauseTime = GetPauseTime();
		
	LogSelective( "Hunker-pausing...PauseTime: "$PauseTime );
	Sleep( 0.1 );
	SetOneOffTimer( PauseTime );

	while( bWaitForTimer && !bPermittedToOpBurst && !bGoingToAssault && PendingStateChange == '' )		
	{
		Sleep( 0.1 );
	}
	
	if ( WGPawn.m_bStandingBackToWall )
	{
		LogSelective( "Standing w/ back to wall, no firing options available." );
		TargetFailureCode = FAIL_NoVantage;
		NotifyTargetFailureMind( TargetFailureCode );
		Sleep( 0.1 );
		Goto( 'Begin' );
	}

	LogSelective( "Checking if should peek/fire this round..." );
	if ( ShouldPeekThisRound() )
		GotoState( 'Peeking' );
	else
	if ( ShouldFireThisRound() )
		GotoState( 'ConsiderFiringOptions' );
	else
	{
		Sleep( 0.1 );
		Goto( 'Begin' );
	}
}

//=========================================================
//	State Peeking
//=========================================================
state Peeking extends FFCBase
{
	//---------------------------------------------------------
	//	NotifyAssaulting (Peeking)
	//---------------------------------------------------------
	/* DEPRECATED.
	function NotifyAssaulting() 
	{
		bGoingToAssault = true;
		GotoState( 'ConsiderFiringOptions' );
	}
	*/

	//---------------------------------------------------------
	//	NotifyPrepareAssault (Peeking)
	//---------------------------------------------------------
	function NotifyPrepareAssault()
	{
		Super.NotifyPrepareAssault();
		GotoState( 'ConsiderFiringOptions' );
	}
	
	//---------------------------------------------------------
	//	LerpLocation (Peeking)
	//---------------------------------------------------------
	function LerpLocation( float DeltaTime ) {}

	//---------------------------------------------------------
	//	ShouldFireThisRound (Peeking)
	//---------------------------------------------------------
	function bool ShouldFireThisRound()
	{
		if ((Level.NetMode == NM_StandAlone) && (WGPawn.PawnTeam == TEAM_US))
		{
			// is this game configured to hold fire and is it not time to fire yet?
			if (Level.Game.bHoldFire && ((Level.TimeSeconds - Level.Game.fHoldFireTime) > 30.0))
			{
				return false;
			}
		}

		if ( bPermittedToOpBurst || bGoingToAssault || HasTargetOrder() )		
			return true;

		// MP games: never stop shooting.
		if ( Level.UseMPStyleFatigue() )
		{
			return true;
		}

		// When being assaulted, remain hunkered down for a while, to act "terrified".
		if( MyMind.IsTerrified() )
		{
			return false;
		}

		return ( MyMind.GetSuppressionLevel() == SL_UNSUPPRESSED );
	}


//-----------------------------------------
Begin:	// (state Peeking)
//-----------------------------------------

	// Peek.
	if ( CanCornerLook( PeekDirection ) )
	{
		LogSelective( "Peeking around corner..." );

		// Peek around the corner.
		DontInterruptMe();

		WGPawn.LeanAroundCornerToPeek();

		while ( WGPawn.IsTransitioning() )
			Sleep( 0.2 );

		// While peeking, check if an opportunistic burst is available.
		CheckForOpBurst();

		WGPawn.ReturnToCorner();

		while ( WGPawn.IsTransitioning() )
			Sleep( 0.2 );

		OKToInterruptMe();		
	}
	else if ( CanPeekAboveWall() )
	{
		LogSelective( "Peeking over wall..." );

		// Peek over the wall.
		DontInterruptMe();

		WGPawn.StandFromCoverToPeek();

		while( WGPawn.IsTransitioning() )
			Sleep( 0.2 );

		// While peeking, check if an opportunistic burst is available.
		CheckForOpBurst();

		WGPawn.StartGoingToCrouch();

		while( WGPawn.IsTransitioning() )
			Sleep( 0.2 );

		OKToInterruptMe();
	}	

	// Consider whether we're going to fire this round.
	if ( ShouldFireThisRound() )
		GotoState( 'ConsiderFiringOptions' );
	else
		GotoState( 'HunkeredDown' );
}

//=========================================================
//	State ConsiderFiringOptions
//=========================================================
state ConsiderFiringOptions extends FFCBase
{
	//-----------------------------------------------------
	//	PositionIsClear (ConsiderFiringOptions)
	//-----------------------------------------------------
	function bool PositionIsClear( Vector TestLoc )
	{
		local Actor EncroachedActor;
		return !WGPawn.CheckEncroachment( TestLoc, WGPawn.Rotation, EncroachedActor );
	}		

	//-----------------------------------------------------
	//	HasShotAroundCorner (ConsiderFiringOptions)
	//-----------------------------------------------------
	function bool HasShotAroundCorner()
	{
		local bool bResult;
		local Vector FutureLocation;

		if (WGPawn.MyClaimedNavPoint.bIsNavigationPoint)
			FutureLocation = WGPawn.WhereWillIBeWhenCornerFiring( NavigationPoint(WGPawn.MyClaimedNavPoint).Rotation, true );
		else if (WGPawn.MyClaimedNavPoint.bIsNavigationPointLite)
			FutureLocation = WGPawn.WhereWillIBeWhenCornerFiring( NavigationPointLite(WGPawn.MyClaimedNavPoint).Rotation, true );

		log(WGPawn$".HasShotAroundCorner()");
		bResult = ( 
			PositionIsClear( FutureLocation ) && 
			!TargetNotViableFromLocation(	FutureLocation, 
											GetCurrentPosture(), 
											TargetFailureCode, 
											BlockingFriendly ) );

		LogSelective( "HasShotAroundCorner() at "$Target.Name$": "$bResult );
		return bResult;
	}

	//-----------------------------------------------------
	//	HasShotOverCorner (ConsiderFiringOptions)
	//-----------------------------------------------------
	function bool HasShotOverCorner()
	{
		local bool bResult;
		bResult = ( WGPawn.bIsCrouched && HasShotOverWall() );	

		LogSelective( "HasShotOverCorner() at "$Target.Name$": "$bResult );
		return bResult;
	}

	//-----------------------------------------------------
	//	HasShotOverWall (ConsiderFiringOptions)
	//-----------------------------------------------------
	function bool HasShotOverWall()
	{
		local bool bResult;
		bResult = !TargetNotViable( 2, TargetFailureCode, BlockingFriendly );

		LogSelective( "HasShotOverWall() at "$Target.Name$": "$bResult$" ; with SeeLoc=="$SeeLoc$" ; SuppressLoc="$SuppressLoc );
		return bResult;
	}	

	//-----------------------------------------------------
	//	HasShotFromVantagePoint (ConsiderFiringOptions)
	//-----------------------------------------------------
	function bool HasShotFromVantagePoint()
	{
		local bool bResult;

		bResult = false;

		LogSelective( "HasShotFromVantagePoint(): Friendly in the way: "$!bResult );

		return bResult;
	}

	//---------------------------------------------------------
	//	LerpLocation (ConsiderFiringOptions)
	//---------------------------------------------------------
	function LerpLocation( float DeltaTime ) {}

//-----------------------------------------
Begin:	// (state ConsiderFiringOptions)
//-----------------------------------------
	
	LogSelective( "Considering firing options..." );	

	TargetFailureCode = FAIL_None;		// In preparation for changing it below...

	// Can the weapon even fire right now?
	if ( !CanFireWeapon() )
	{
		GotoState( 'HunkeredDown' );
	}

	if ( Target == None || Target.IsDead() )
	{
		TargetFailureCode = FAIL_TargetDead;
		NotifyTargetFailureMind( TargetFailureCode );
		GotoState( 'HunkeredDown' );
	}
		
	if ( CanCornerLook( PeekDirection ) )
	{
		LogSelective( "Testing corner-firing options." );

		// Test 1: Does this pawn have a pending gesture to do?  If so, make sure he will be standing when he does it.
		if ( PendingGesture != '' )
		{
			if ( WGPawn.bIsCrouched )
				GotoState( 'FireOverCorner' );
		}

		// Don't even think about it if your target is behind you!
		if ( Normal( Target.Location - WGPawn.Location ) dot Vector( WGPawn.Rotation ) > 0 )
		{
			bHasShotAroundCorner = HasShotAroundCorner();	// Includes check for encroachment
			bHasShotOverCorner = HasShotOverCorner();
		}	
		else
		{
			bHasShotAroundCorner = false;
			bHasShotOverCorner = false;
		}

		if ( bHasShotAroundCorner && bHasShotOverCorner )
		{
			// When op-bursting, always choose to fire over the corner.  It's just more dang dramatic.
			// Otherwise, it's a coin toss between the two.
			if ( IsTrue( RecentTroubleShootingOverCorner ) )
			{
				LogSelective( "Technically has a shot over corner but skipping it because I've had trouble with that lately..." );
				GotoState( 'FireAroundCorner' );
			}
			else if ( bPermittedToOpBurst )
				GotoState( 'FireOverCorner' );			
			else if ( Rand(2) == 0 )
				GotoState( 'FireAroundCorner' );
			else
				GotoState( 'FireOverCorner' );
		}
		else if ( bHasShotAroundCorner )
			GotoState( 'FireAroundCorner' );
		else if ( bHasShotOverCorner )
			GotoState( 'FireOverCorner' );
		else
		{
			LogSelective( "Pawn has NO shot around or over corner." );
			if ( TargetFailureCode == FAIL_None )
				TargetFailureCode = FAIL_NoVantage;
			NotifyTargetFailureMind( TargetFailureCode, BlockingFriendly );
			GotoState( 'HunkeredDown' );
		}
	}
	else if ( WGPawn.bIsCrouched && IsAtLowCover() )
	{
		GotoState( 'FireFromLowCover' );
	}
	else if ( HasShotOverWall() )
	{
		GotoState( 'FireOverWall' );
	}
	else
	{
		if ( TargetFailureCode == FAIL_None )
			TargetFailureCode = FAIL_NoVantage;
		NotifyTargetFailureMind( TargetFailureCode, BlockingFriendly );
		GotoState( 'HunkeredDown' );
	}
}

//=========================================================
//	State FireUponTarget
//=========================================================
state FireUponTarget extends FFCBase
{
	//-----------------------------------------------------
	//	BeginState (FireUponTarget)
	//-----------------------------------------------------
	function BeginState()
	{
		Super.BeginState();
		TheWeapon.DisableReload();	// When in FFC, don't allow reloads while exposed to enemy fire.
		WGPawn.bDoTorsoTwist = true;
		
		MyMind.NotifyPreparingToFire( true, Target );
	}

	//-----------------------------------------------------
	//	EndState (FireUponTarget)
	//-----------------------------------------------------
	function EndState() 
	{
		LogSelective( "EndState()." );
		WGPawn.StopFiringWeapon();
	}

	//---------------------------------------------------------
	//	NotifyTakeHit (FireUponTarget)
	//---------------------------------------------------------
	function NotifyTakeHit( Pawn InstigatedBy, Vector HitLocation )
	{
		if ( !bDontInterruptMe )
		{
			GotoState( GetNextStateName() );
		}
		else
		{
			PendingStateChange = GetNextStateName();
		}
	}

	//-----------------------------------------------------
	//	PositionSelf (FireUponTarget)
	//-----------------------------------------------------
	function PositionSelf() {}
	
	//-----------------------------------------------------
	//	IsReadyToFire (FireUponTarget)
	//-----------------------------------------------------
	function bool IsReadyToFire() 
	{
		return true; 
	}

	//-----------------------------------------------------
	//	AimAtTargetWithTimer (FireUponTarget)
	//-----------------------------------------------------
	function AimAtTargetWithTimer() 
	{
		// Check for opportunistic burst.
		if ( CheckForOpBurst() && !MyMind.HasFreeOpBurst() )
			SendOpBurstMessage();

		// Don't spend more than 3 seconds aiming at the target.
		SetOneOffTimer( 3.0 );		
		WGPawn.SetWeaponAimedState( WAS_Sighted );
		MyMind.SetAimingAtTarget(Target);
	}

	//-----------------------------------------------------
	//	FireBurstWithTimer (FireUponTarget)
	//-----------------------------------------------------
	function FireBurstWithTimer() 
	{
		LogSelective( "FireBurstWithTimer()" );

		if ( bGoingToAssault || bIsFrenzied )
		{
			if ( MyMind.bUseAIDebugging && MyMind.AITracker != None )
			{
				MyMind.AITracker.AddFiringFactor( Firing_OpBurst );
			}
			TheWeapon.StartBerserk();
		}
		else if ( bPermittedToOpBurst )
		{
			if ( MyMind.bUseAIDebugging && MyMind.AITracker != None )
			{
				MyMind.AITracker.AddFiringFactor( Firing_OpBurst );
			}
			TheWeapon.StartOpBurst();
		}
		else
		{
			TheWeapon.StopBerserk();
		}

		// Don't spend more than 7 seconds firing burst.
		SetOneOffTimer( 7.0 );
		BurstCount = DetermineBurstCount();
		LastSuccessfulShotTime = Level.TimeSeconds;
		
		bBurstInterrupted = false;
		WGPawn.FireWeaponBurst( BurstCount );
	}	

	//-----------------------------------------------------
	//	CanShootAtTarget (FireUponTarget)
	//-----------------------------------------------------
	function bool CanShootAtTarget() 
	{ 
		local bool bResult;
		local Vector	VectView;
		
		if ( Target == None )
			return false;
		
		if (Level.bUrbanCover && WGPawn.m_bCornerFiring && !WGPawn.bIsCrouched)
		{
			VectView = WGPawn.WhereWillIBeWhenCornerFiring( NavigationPoint(WGPawn.MyClaimedNavPoint).Rotation, true );
			bResult = !TargetNotViableFromLocation( VectView, GetCurrentPosture(), TargetFailureCode, BlockingFriendly );
		}
		else
		{
			bResult = !TargetNotViable( GetCurrentPosture(), TargetFailureCode, BlockingFriendly );
		}

		LogSelective( "CanShootAtTarget() "$Target.Name$": "$bResult );
		return bResult;
	}

	//-----------------------------------------------------
	//	IsAimingAtTarget (FireUponTarget)
	//-----------------------------------------------------
	function bool IsAimingAtTarget() 
	{ 
		local bool bResult;
		bResult = WGPawn.IsAimingAtTarget();

		LogSelective( "IsAimingAtTarget() "$Target.Name$": "$bResult );
		return bResult;
	}

	//-----------------------------------------------------
	//	IsFiringBurst (FireUponTarget)
	//-----------------------------------------------------
	function bool IsFiringBurst() 
	{ 
		return	WGPawn.IsWeaponFiring() && 
				bWaitForTimer && 
				(Level.TimeSeconds - LastSuccessfulShotTime) < SecondsBeforeKillingBurst; 
	}	

	//---------------------------------------------------------
	//	ReactToAllyBlocking (FireUponTarget)
	//---------------------------------------------------------
	function ReactToAllyBlocking( gbxPawn BlockingActor )
	{
		LogSelective( "ReactToAllyBlocking()." );

		// Kill currently firing burst.
		WGPawn.StopFiringWeapon();
		TurnOffTimer();
		TargetFailureCode = FAIL_FriendlyInWay;
		NotifyTargetFailureMind( TargetFailureCode, BlockingActor );

		bDontStayUp = true;
	}

	//-----------------------------------------------------
	//	CanThrowGrenade (FireUponTarget)
	//-----------------------------------------------------
	function bool CanThrowGrenade( float DistToTarget )
	{
		LogSelective( "CanThrowGrenade(): false." );
		// Override this in other states.
		return false;
	}

	//-----------------------------------------------------
	//	CanReloadOutInOpen (FireUponTarget)
	//-----------------------------------------------------
	function bool CanReloadOutInOpen()
	{
		LogSelective( "CanReloadOutInOpen: "$bPermittedToOpBurst );
		return bPermittedToOpBurst;
	}

	//-----------------------------------------------------
	//	ReportCouldntAim (FireUponTarget)
	//-----------------------------------------------------
	function ReportCouldntAim()
	{
		if ( MyMind.bUseAIDebugging && MyMind.AITracker != None )
		{
			// GBX:naj - This seems redundant, doesn't it?
			MyMind.AITracker.AddFiringFactor( Firing_CantAim );
		}

		TargetFailureCode = FAIL_NoVantage;
		NotifyTargetFailureMind( TargetFailureCode );
	}

	//-----------------------------------------------------
	//	ShouldStayUp (FireUponTarget)
	//-----------------------------------------------------
	function bool ShouldStayUp()
	{
		local bool bResult;

		// Stay up if:
		// 1) I'm not suppressed and I don't need to reload;
		// OR
		// 2) I am permitted to do an op-burst and my target is still alive.
		//
		if ( bDontStayUp || bBurstInterrupted )		
		{
			bDontStayUp = false;
			bResult = false;
		}
		else
		{
			// Uncomment the following text to make unsuppressed pawns fire until their clips are empty.
			bResult =	( 	//( MyMind.GetSuppressionLevel() == SL_UNSUPPRESSED && !TheWeapon.NeedsToReload() ) || 
							( bGoingToAssault ) ||
							( bPermittedToOpBurst && !Target.IsDead() ) );
		}

		LogSelective( "ShouldStayUp(): "$bResult );
		return bResult;
	}

	//-----------------------------------------------------
	//	LerpLocation (FireUponTarget)
	//-----------------------------------------------------
	function LerpLocation( float DeltaTime ) {}

	//-----------------------------------------------------
	//	GetNextState (FireUponTarget)
	//-----------------------------------------------------
	function Name GetNextStateName() { return 'GoBackToCover'; }

//-----------------------------------------
Begin:		// state FireUponTarget
//-----------------------------------------	

	StateInfoLabel='Positioning_Self';
	DontInterruptMe();	

	LogSelective( "Positioning self..." );
	PositionSelf();	

	LogSelective( "Getting ready to fire..." );
	while ( !IsReadyToFire() )
		Sleep( 0.1 );

	OKToInterruptMe();		
	
//-----------------------------------------
ConsiderGesturing:
//-----------------------------------------
	LogSelective( "Checking if should do a gesture." );
	if ( PendingGesture != '' )
	{
		LogSelective( "Gesturing.  PendingGesture=="$PendingGesture );
		WGPawn.PlayGestureAnim( PendingGesture, true );
		PendingGesture = '';

		Sleep( 1.5 );	// Replace this with a wait-for-callback.
	}

//-----------------------------------------
ConsiderGrenade:
//-----------------------------------------

	// Update our knowledge about the target's location.
	UpdateTargetKnownLocation();

	LogSelective( "Checking if should throw grenade..." );
	if ( Target != None && CanThrowGrenade( VSize( TargetLastKnownLoc - WGPawn.Location ) ) )
	{
		NavController.StopManeuvering();
		if ( GrenadeFireCtrl.AttackTargetIndex( GrenadeIndex ) )
		{			
			DontInterruptMe();
			if ( bGoingToAssault )
			{
				MyMind.ReportThrowingGrenade( true );
			}
			Goto( 'ThrowingGrenadeFFC' );	// Label, not state!
		}
	}
	else if ( bGoingToAssault )
	{
		MyMind.ReportThrowingGrenade( false );
	}

	StateInfoLabel='Evaluating_Target';

	LogSelective( "Checking if can shoot at target..." );
	if( !CanShootAtTarget() )
	{
		LogSelective( "CANNOT shoot at target." );
		NotifyTargetFailureMind( TargetFailureCode );
		GotoState( GetNextStateName() );
	}

//-----------------------------------------
AimAndFire:
//-----------------------------------------
	StateInfoLabel='Aiming';

	// If we're firing op-bursts, it's ok to reload out in the open.
	if ( CanReloadOutInOpen() )
	{
		TheWeapon.EnableReload();
		while( TheWeapon.IsReloading() )
			Sleep( 0.1 );
	}	

	LogSelective( "Aiming at target..." );
	AimAtTargetWithTimer();

	//while ( !IsAimingAtTarget() && bWaitForTimer )
		//Sleep( 0.1 );

	TurnOffTimer();

	if ( true/*IsAimingAtTarget()*/ )
	{
		StateInfoLabel='Firing';
		LogSelective( "Firing burst." );
		FireBurstWithTimer();
		while ( IsFiringBurst() )
			Sleep( 0.1 );
			
		TurnOffTimer();
		WGPawn.StopFiringWeapon();	

		// Comment on the status of our target: if suppressed, let the player know!
		MyMind.ReportSuppressionStatus();		
	}
	else
	{
		ReportCouldntAim();
		GotoState( GetNextStateName() );
	}

	StateInfoLabel='Done_Firing';
	// If we are firing op-bursts, don't hunker down.
	if ( ShouldStayUp() )
	{
		// Pause for the very briefest of spells and shoot again.
		Sleep( 0.3 );
		Goto( 'ConsiderGesturing' );
	}
	else
		GotoState( GetNextStateName() );

//-----------------------------------------
ThrowingGrenadeFFC:
//-----------------------------------------
	StateInfoLabel='Throwing_Grenade';
	LogSelective( "[ThrowingGrenadeFFC]" );

	// Announce to the world that you're lobbing a grenade.
	SpeakThrowingGrenade();

	while( GrenadeFireCtrl.bAttackPending )
			Sleep( 0.1 );

	OKToInterruptMe();

	if ( ShouldStayUp() )
	{
		Sleep( 0.1 );
		//Goto( 'ConsiderGrenade' );
		Goto( 'ConsiderGesturing' );
	}
	else
		GotoState( GetNextStateName() );
}

//=========================================================
//	State FireFromLowCover
//=========================================================
state FireFromLowCover extends FireUponTarget
{	
	function BeginState()
	{
		Super.BeginState();
		MyMind.RequestFacingPolicy( FACE_Enemy );
	}

	//-----------------------------------------------------
	//	ShouldStayUp (FireFromLowCover)
	//-----------------------------------------------------
	function bool ShouldStayUp()
	{
		return false;
	}	

	//-----------------------------------------------------
	//	GetNextState (FireFromLowCover)
	//-----------------------------------------------------
	function Name GetNextStateName() 
	{ 
		return 'GoBackToLowCover'; 
	}
}

//=========================================================
//	State FireOverWall
//=========================================================
state FireOverWall extends FireUponTarget
{
	//-----------------------------------------------------
	//	PositionSelf (FireOverWall)
	//-----------------------------------------------------
	function PositionSelf()
	{
		WGPawn.StartGoingToStand();
		MyMind.RequestFacingPolicy( FACE_Enemy );
	}

	//-----------------------------------------------------
	//	IsReadyToFire (FireOverWall)
	//-----------------------------------------------------
	function bool IsReadyToFire() 
	{ 
		return !WGPawn.IsTransitioning(); 
	}

	//-----------------------------------------------------
	//	CanThrowGrenade (FireOverWall)
	//-----------------------------------------------------
	function bool CanThrowGrenade( float DistToTarget )
	{
		return Global.CanThrowGrenade( DistToTarget );
	}	
}


//=========================================================
//	State FireAroundCorner
//=========================================================
state FireAroundCorner extends FireUponTarget
{
	//-----------------------------------------------------
	//	BeginState (FireAroundCorner)
	//-----------------------------------------------------
	function BeginState()
	{
		Super.BeginState();
	}

	//-----------------------------------------------------
	//	EndState (FireAroundCorner)
	//-----------------------------------------------------
	function EndState()
	{
		Super.EndState();
		// This is here in case the pawn leaned out to fire, and then got pulled out of FFC, 
		// and thus wasn't able to play the corner-fire dismount animation.
		WGPawn.bNoTurnBody = false;
	}

	//-----------------------------------------------------
	//	CanThrowGrenade (FireAroundCorner)
	//-----------------------------------------------------
	function bool CanThrowGrenade( float DistToTarget )
	{
		return Global.CanThrowGrenade( DistToTarget );
	}

	//-----------------------------------------------------
	//	CanReloadOutInOpen (FireAroundCorner)
	//-----------------------------------------------------
	function bool CanReloadOutInOpen()
	{
		return bPermittedToOpBurst && !WGPawn.bIsCrouched && !Level.bUrbanCover;
	}

	//-----------------------------------------------------
	//	ShouldStayUp (FireAroundCorner)
	//-----------------------------------------------------
	function bool ShouldStayUp()
	{
		// Allow corner-firing pawns to stay out if they are standing.
		// (We don't have reload anims for the crouch case).
		if ( WGPawn.bIsCrouched )
		{
			return bPermittedToOpBurst && !TheWeapon.NeedsToReload();
		}
		else
		{
			return bPermittedToOpBurst && !TheWeapon.NeedsToReload();  //NAC: added the check for the weapon reload here as well.  It was happening that guys bPermittedToOpBurst would be true, but they couldnt fire the weapon because they needed to reload...so they just stood there and did nothing. 
		}
	}

	//-----------------------------------------------------
	//	PositionSelf (FireAroundCorner)
	//-----------------------------------------------------
	function PositionSelf()
	{
		local Rotator CornerPointRot;

		MyMind.RequestFacingPolicy( FACE_NoChange );

		MyMind.SetAimingAtTarget(Target);
		
		CornerPointRot = GetRotation( WGPawn.MyClaimedNavPoint );
		CornerPointRot.Pitch = 0;
		WGPawn.LeanAroundCornerToFire( CornerPointRot );

	}

	//-----------------------------------------------------
	//	IsReadyToFire (FireAroundCorner)
	//-----------------------------------------------------
	function bool IsReadyToFire() 
	{ 
		return !WGPawn.IsTransitioning(); 
	}

	//-----------------------------------------------------
	//	GetNextStateName (FireAroundCorner)
	//-----------------------------------------------------
	function Name GetNextStateName() { return 'GoBackToCorner';	}
}

//=========================================================
//	State FireOverCorner
//=========================================================
state FireOverCorner extends FireUponTarget
{
	//-----------------------------------------------------
	//	PositionSelf (FireOverCorner)
	//-----------------------------------------------------
	function PositionSelf()
	{
		MyMind.RequestFacingPolicy( FACE_Enemy );
		MyMind.SetAimingAtTarget(Target);
		WGPawn.StandUpToFireOverCorner();
	}
	
	//-----------------------------------------------------
	//	IsReadyToFire (FireOverCorner)
	//-----------------------------------------------------
	function bool IsReadyToFire() 
	{ 
		return !WGPawn.IsTransitioning(); 
	}	

	//-----------------------------------------------------
	//	GetNextStateName (FireOverCorner)
	//-----------------------------------------------------
	function Name GetNextStateName() { return 'GoBackToCorner';	}

	//-----------------------------------------------------
	//	CanThrowGrenade (FireOverCorner)
	//-----------------------------------------------------
	function bool CanThrowGrenade( float DistToTarget )
	{
		return Global.CanThrowGrenade( DistToTarget );
	}

	//-----------------------------------------------------
	//	NotifyTargetFailureMind (FireOverCorner)
	//-----------------------------------------------------
	function NotifyTargetFailureMind( ETargetFailure FailureCode, optional gbxPawn Blocker )
	{
		Global.NotifyTargetFailureMind( FailureCode, Blocker );
		SetFlagTrueTimed( RecentTroubleShootingOverCorner, 10.0f );
	}
}

//=========================================================
//	State GoBackToCover
//=========================================================
state GoBackToCover extends FFCBase
{
	//---------------------------------------------------------
	//	ReturnToCover (GoBackToCover)
	//---------------------------------------------------------	
	function bool ReturnToCover() 
	{
		WGPawn.BreakOutOfHunker();
		MyMind.RequestFacingPolicy( FACE_Destination );
		NavController.ManeuverToActor( WGPawn.MyClaimedNavPoint, false );
		
		// Don't take more than 10 seconds to get back to the cover point.
		SetOneOffTimer( 10.0 );
		
		return true; 
	}
	
	//---------------------------------------------------------
	//	ReturningToCover (GoBackToCover)
	//---------------------------------------------------------
	function bool ReturningToCover() 
	{ 
		return ( MyMind.IsNavigating() && !IsNearCoverPoint() && bWaitForTimer );
		//return ( !IsNearCoverPoint() && bWaitForTimer );
	}

	//---------------------------------------------------------
	//	LerpLocation (GoBackToCover)
	//---------------------------------------------------------
	//function LerpLocation( float DeltaTime ) {}

	//---------------------------------------------------------
	//	GetNextStateName (GoBackToCover)
	//---------------------------------------------------------
	function Name GetNextStateName() { return 'FiringFromCover'; }

//-----------------------------------------
Begin:		// state GoBackToCover
//-----------------------------------------	

	DontInterruptMe();

	if ( !ReturnToCover() )
	{
		MyMind.RequestStopFiringFromCover();
	}

	while ( ReturningToCover() )
		Sleep( 0.1 );

	OKToInterruptMe();

	GotoState( GetNextStateName() );
}

//=========================================================
//	State GoBackToCorner
//=========================================================
state GoBackToCorner extends GoBackToCover
{
	//---------------------------------------------------------
	//	PositionIsClear (GoBackToCorner)
	//---------------------------------------------------------
	function bool PositionIsClear( Vector TestLoc )
	{
		local Actor EncroachedActor;
		return !WGPawn.CheckEncroachment( TestLoc, WGPawn.Rotation, EncroachedActor );
	}

	//---------------------------------------------------------
	//	ReturnToCover (GoBackToCorner)
	//---------------------------------------------------------
	function bool ReturnToCover() 
	{
		// Don't lean back if someone else is occupying our corner position.
		if ( !PositionIsClear( WGPawn.LastCornerPosition ) )
		{
			LogSelective( "ReturnToCover() failed because someone is occupying our spot." );
			return false;
		}
		
		WGPawn.ReturnToCorner();

		return true;
	}
	
	//---------------------------------------------------------
	//	ReturningToCover (GoBackToCorner)
	//---------------------------------------------------------
	function bool ReturningToCover() 
	{ 	
		return WGPawn.IsTransitioning();
	}

	//---------------------------------------------------------
	//	GetNextStateName (GoBackToCorner)
	//---------------------------------------------------------
	function Name GetNextStateName() 
	{ 
		return 'HunkeredDown'; 
	}
}

//=========================================================
//	State GoBackToLowCover
//=========================================================
state GoBackToLowCover extends GoBackToCover
{
	//---------------------------------------------------------
	//	ReturnToCover (GoBackToLowCover)
	//---------------------------------------------------------	
	function bool ReturnToCover() 
	{
		return true; 
	}

	//---------------------------------------------------------
	//	ReturningToCover (GoBackToLowCover)
	//---------------------------------------------------------
	function bool ReturningToCover() 
	{ 	
		return false;
	}

	//---------------------------------------------------------
	//	GetNextStateName (GoBackToLowCover)
	//---------------------------------------------------------
	function Name GetNextStateName() 
	{ 
		if ( Target != None && !Target.IsDead() )
			return 'FireFromLowCover'; 
		else
			return 'HunkeredDown';
	}
}

//=========================================================
//	State LeavingFFC
//=========================================================
state LeavingFFC
{
	//------------------------------------------------------
	//	BeginState (LeavingFFC)
	//------------------------------------------------------
	function BeginState()
	{
		WGPawn.StopFiringWeapon();
		LogSelective( "BeginState()." );
	}

	//------------------------------------------------------
	//	EndState (LeavingFFC)
	//------------------------------------------------------
	function EndState()
	{
		LogSelective( "EndState()." );
		bWaitForCallback = false;
		TurnOffTimer();
		
		WGPawn.bDoHeadTurn = true;		
		WGPawn.SetBackToWall( false );
		WGPawn.BreakOutOfHunker();

		SetFlagValue( RecentTroubleShootingOverCorner, false );

		WGPawn.StopFiringWeapon();

		MyMind.NotifyFiringFromCoverDone();
		
		if ( MountCtrl != None )
		{
			MountCtrl.StopMountAction();
		}

		PendingStateChange = '';
	}

	//------------------------------------------------------
	//	LerpLocation (LeavingFFC)
	//------------------------------------------------------
	function LerpLocation( float DeltaTime ) {}

	//------------------------------------------------------
	//	IsHunkeredAtCorner (LeavingFFC)
	//------------------------------------------------------
	function bool IsHunkeredAtCorner( out ECornerDir Direction )
	{
		// Don't peek unless your back is to the target.
		if ( !WGPawn.MyClaimedNavPoint.IsA( 'CornerPoint' ) || !WGPawn.m_bCornerHunkered )
			return false;

		return true;
	}


//-----------------------------------------
Begin:		// state LeavingFFC
//-----------------------------------------

	if ( WGPawn.m_bCornerHunkered && !WGPawn.m_bCornerFiring && !WGPawn.m_bStandingOverCorner )
	{
		bWaitForCallback = true;		
		
		if ( MountCtrl != None )
		{
			MountCtrl.DoMountAction( Mount_DismountCornerNoRootMotion, None, false, false, class'FiringControllerCallback', WGPawn.Rotation );

			while( bWaitForCallback )
				Sleep( 0.1 );
		}
	}

	if ( PendingStateChange != '' && PendingStateChange != 'LeavingFFC' )
	{
		GotoState( PendingStateChange );
	}
	else
	{
		GotoState( 'Exposed' );
	}
}

//=========================================================
//	State WaitingForDestruction
//=========================================================
state WaitingForDestruction
{
	function Possess(Pawn aPawn) {}
	function Timer() {}
	function Tick( float DeltaTime ) {}
	function Think() {}
	function bool ApproveShot( Rotator AimRotator ) { return false; }
	function SetTarget( Pawn NewTarget ) {}
	function StartFiringFromCover( Pawn NewTarget ) {}
	function SetFrenzied( bool bFrenzied ) {}
	function NotifyTargeting() {}
	function RefreshTarget( Pawn tPawn, float tPriority ) {}
	function StartMelee() {}
	function StopMelee() {}
}

//---------------------------------------------------------
//	DisplayDebug
//---------------------------------------------------------
simulated function DisplayDebug(Canvas Canvas, out float YL, out float YPos)
{
	local String WeapPosture;

	Canvas.DrawColor.R = 0;
	Canvas.DrawColor.G = 255;
	Canvas.DrawColor.B = 255;
	YPos += YL;
	Canvas.SetPos(4,YPos);
	Canvas.DrawText("FIRINGCONTROLLER: "$Self.name$"  PAWN: "$Pawn.Name, false);	

	Canvas.DrawColor.R = 255;
	Canvas.DrawColor.G = 255;
	Canvas.DrawColor.B = 255;

	YPos += YL;
	Canvas.SetPos(4,YPos);
	Canvas.DrawText("STATE: "$GetStateName(), false, 0.9, 0.9);

	if ( !NoShow )
	{		
		Canvas.DrawColor.R = 0;
		Canvas.DrawColor.G = 255;
		Canvas.DrawColor.B = 255;

	YPos += YL;
	Canvas.SetPos(4,YPos);
	Canvas.DrawText("TARGET: "$Target, false, 0.9, 0.9);

	YPos += YL;
	Canvas.SetPos(4,YPos);
		if ( MyMind.GetSuppressionLevel() == SL_UNSUPPRESSED )
		Canvas.DrawText("SUPPRESSION LEVEL: NOT suppressed", false, 0.9, 0.9);
		else if ( MyMind.GetSuppressionLevel() == SL_SUPPRESSED )
		Canvas.DrawText("SUPPRESSION LEVEL: SUPPRESSED", false, 0.9, 0.9);

	YPos += YL;
	Canvas.SetPos(4,YPos);
	Canvas.DrawText("COVER POINT: "$Pawn.MyClaimedNavPoint, false, 0.9, 0.9);

	YPos += YL;
	Canvas.SetPos(4,YPos);
	Canvas.DrawText("SEE LOCATION: "$SeeLoc, false, 0.9, 0.9);

	YPos += YL;
	Canvas.SetPos(4,YPos);
	Canvas.DrawText("SUPPRESSION LOCATION: "$SuppressLoc, false, 0.9, 0.9);

	switch( Pawn.eWeaponAimedState )
	{
		case WAS_Relaxed:
			WeapPosture = "RELAXED";
			break;
		case WAS_AimedHip:
			WeapPosture = "AIMED-HIP";
			break;
		case WAS_Sighted:
			WeapPosture = "SIGHTED";
			break;
	}
	YPos += YL;
	Canvas.SetPos(4,YPos);
	Canvas.DrawText("WEAPON POSTURE: "$WeapPosture, false, 0.9, 0.9 );

	YPos += YL;
	Canvas.SetPos(4,YPos);
	Canvas.DrawText("IS AIMING AT TARGET: "$Pawn.IsAimingAtTarget(), false, 0.9, 0.9 );

	Canvas.SetDrawColor(255,255,255);

	YPos += YL;
	Canvas.SetPos(4,YPos);
	Canvas.DrawText("STATE LABEL: "$StateInfoLabel, false, 0.9, 0.9 );

	//if ( IsInState('FiringFromCover') )
	if ( IsFiringFromCover() )
	{
		// GBX:PAD: WG_HUD does not exist any more, so we need to change these over to something valid
//		Canvas.DrawTile3D(Texture't_interface_mb.debug.FC_RedLight', Pawn.Location + Vect(0,0,50), 64, 64, 0, 0, 64, 64);
	}
	else if ( IsInState('Exposed') )
	{
		// GBX:PAD: WG_HUD does not exist any more, so we need to change these over to something valid
//		Canvas.DrawTile3D(Texture't_interface_mb.debug.FC_GreenLight', Pawn.Location + Vect(0,0,50), 64, 64, 0, 0, 64, 64);
	}
	
	YPos += YL;
	Canvas.SetPos(4,YPos);
	}

	if ( GrenadeFireCtrl != None )
	{
		GrenadeFireCtrl.DisplayDebug( Canvas, YL, YPos );
	}
}

//---------------------------------------------------------
//	MissShotAgainstAssaulter
//---------------------------------------------------------
event bool MissShotAgainstAssaulter()
{
	local float ProbDivertShot;

	// MP games: Never give shot protection to assaulters.	
	if ( Level.UseMPStyleFatigue() )
		return false;

	if ( Target.MyUnit != None && WGPawn.MyUnit != None )
	{
		if ( Target.MyUnit.NumMembers >= ( WGPawn.MyUnit.NumMembers - 1 ) )
		{
			return true;
		}
		else 
		{
			ProbDivertShot = Target.MyUnit.NumMembers / WGPawn.MyUnit.NumMembers;
			if ( FRand() <= ProbDivertShot )
			{
				return true;
			}
		}
	}

	return false;
}

//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
	//DestinationRadius=50.0
	DestinationRadius=10.0

	MeleeStrikeDist=200.0
	MeleeRootMotionDist=250.0
	MeleeChargeSpeed=500.0
	MeleeEyesOffset=Vect(0,0,50.0)
	MeleeTooCloseToHuman=350.0
	MeleeFriendlyFireDot=0.9
	MeleeFacingDot=0.9

	FrustrationRate=0.0166666 // Takes about 60 seconds to become fully frustrated
	FrustrationBegin=12.0 // Frustration doesn't begin for 12 seconds
	CheckVantageShotInterval=0.5
	CheckLeaveFFCInterval=0.5

	PauseTime_Low=(Min=1.0,Max=2.0)
	PauseTime_High_Novice=(Min=10.0,Max=15.0)
	PauseTime_High_Interm=(Min=6.0,Max=12.0)
	PauseTime_High_Advanced=(Min=5.0,Max=10.0)
	PauseTime_High_Veteran=(Min=4.0,Max=8.0)
	PauseTime_HumanControlledSP=(Min=6.0,Max=10.0)
	PauseTime_HumanControlledSP_Targeting=(Min=0.5,Max=1.2)
	PauseTime_HumanControlledMP=(Min=1.0,Max=4.0)
	PauseTime_HumanControlledMP_Targeting=(Min=0.4,Max=1.2)

	GrenadeFCClass=class'GrenadeFiringController'
	MyLogSelectName="FCINFANTRY"

	LerpMultiplier=0.96

	ApproveShotCutoffDot=0.7071

	MeleeTraceExtent=(X=40,Y=40,Z=40 )
	RemoteRole=ROLE_None
}//=============================================================================
// Infantry firing controller that specifically handles behavior when manning 
// machine guns such as the MG42 and the M1919.
//
// Author: Neil Johnson, Gearbox Software.
//=============================================================================
class FiringControllerMG extends FiringControllerInfantry
	native;

//---------------------------------------------------------
//	Variables / Constants
//---------------------------------------------------------

var enum EKillZone
{
	KZ_None,
	KZ_ZoneOne,
	KZ_ZoneTwo,
	KZ_ZoneThree,
	KZ_Suppress,
}
KillZone;					// When on turret weapons, the current kill zone.

var Vector					SweepPath;					// Vector from turret weapon to target.
var Vector					SweepStart;					// Turret sweep starting point.
var float					T;							// Parametric t-value used in sweeping the weapon.
var float					SWEEP_END_OFFSET;
var float					SWEEP_START_OFFSET;
var const float				TIMER_DURATION;				// Used with SetTimer().
var const float				SWEEPSTART_OFFSET;			// Offset from the path-start from which to start a sweep.
var const float				OVERSHOOT_OFFSET;			// Offset past the target to go when sweeping.
var const float				SWEEP_ERROR_ZONE3;			// Error-offset when the target is in kill-zone 3.
var int						ShotCount;
var float					OutOfFiringConeNextFireTime;
var	float					OutOfFiringConeVisibleFiringDuration;
var	float					OutOfFiringConeHiddenFiringDuration;

var bool bGunFiring;      //DLEVY
var Pawn DesiredNewTarget; //DLEVY

native function StopWaiting();

//---------------------------------------------------------
//	StartManningTurret
//---------------------------------------------------------
function StartManningTurret()
{
	LogSelective( "StartManningTurret." );
	GotoState( 'ManningTurret' );
}

//---------------------------------------------------------
//	EnsureWeaponIsCurrent
//---------------------------------------------------------
function EnsureWeaponIsCurrent()
{
	if ( MyMind == None )
		return;

	if ( Pawn != None && Pawn.Weapon != None && TheWeapon != Pawn.Weapon )
	{		
		TheWeapon = gbxWeapon( Pawn.Weapon );		
	}
}

//---------------------------------------------------------
//	CalcKillZone
//---------------------------------------------------------
function EKillZone CalcKillZone( float DistToTarget )
{
	//local float DistToTarget;
	local bool bCSSResult;

	// First things first.  Is the target even in our visibility cone?
        // PSV: 6/20/2005 Prevent accessed None spammage
	if ( Target == None || !Pawn.Turret.PointIsInMyConeOfFire( Target.Location ) )
	{
		return KZ_None;
	}

	// Don't calculate a sweep path if the target is under cover.
	// Check for suppression.
	bCSSResult = MyMind.CanSeeOrSuppressFromPoint( Target, TheWeapon.GetMuzzleLocationWorld(), SeeLoc, IsHeadShot, SuppressLoc, FailLoc ); 

	if ( SuppressLoc != Vect(0,0,0 ) && DistToTarget < Pawn.Turret.Zone3OuterRadius)  //NAC: added distance check so that gun doesn't fire suppression at rediculous distances.
	{
		return KZ_Suppress;
	}
	
	if ( DistToTarget < 0 )
	{
		// Error: target wasn't found in the Mind's TargetQueue, but we need to keep moving here.  Calculate the distance directly.
		DistToTarget = VSizeIgnoreZ( Target.Location - Pawn.Location );
	}

	if ( DistToTarget < Pawn.Turret.Zone1OuterRadius )
	{
		LogSelective( "Zone 1..." );
		return KZ_ZoneOne;
	}
	else if ( DistToTarget < Pawn.Turret.Zone2OuterRadius )
	{
		LogSelective( "Zone 2..." );
		return KZ_ZoneTwo;
	}
	else if ( DistToTarget < Pawn.Turret.Zone3OuterRadius )
	{
		LogSelective( "Zone 3..." );
		return KZ_ZoneThree;
	}
	else
	{
		LogSelective( "Zone NoZone..." );
		return KZ_None;
	}
}

//=========================================================
//	State ManningTurret
//=========================================================
state ManningTurret
{			
	//---------------------------------------------------------
	//	Think
	//---------------------------------------------------------
	function Think()
	{
		// GBX:naj - Now calculating the killzone every think-cycle instead at the beginning of every burst.
		// This makes MG gunners more responsive to enemies crossing from one killzone into another.
		// If the target has crossed into a new kill zone, reset the state code.
		local EKillZone NewKillZone;
		local float TargetDistance;

		UpdateTargetKnownLocation( TargetDistance );
		NewKillZone = CalcKillZone( TargetDistance );

		if ( NewKillZone != KillZone )
		{
			KillZone = NewKillZone;
			GotoState('ManningTurret', 'ChangingTarget');
		}	
		else
		{
			KillZone = NewKillZone;
		}
	}

	//---------------------------------------------------------
	//	SetTarget
	//---------------------------------------------------------
	function SetTarget( Pawn NewTarget )
	{ 
	//start DLEVY 1/7/05

	// fix for bug #7254. 
	// Problem was that when player went behind MG
	// while it was firing a teammates in front of it,
	// it could retarget the player in the middle of the burst due to Mind.SetEnemy 
	// and circumvent the check which prevents shooting at targets outside of cone
	// for a a very very short time, but since the MG bullets are instakill only one hit is needed
	// To resolve this I have added a check to this FiringControllerMG.SetTarget()
	// where if it is called while the gun is actively firing in Zone1
	// we stop the gun from firing before changing the Target

		DesiredNewTarget = NewTarget;
		if (bGunFiring )
		{
			log("DLEVY************ SetTarget()Requested While Weapon is Firing. Stopping Firing ***************",'dlevy');
			GotoState('ManningTurret', 'ChangingTarget');
			return;
		}
	//end DLEVY 1/7/05

		if ( NewTarget == Target )
			return;

		Target = gbxPawn( NewTarget );
		Threat = Target;

		FrustrationLevel = 0.0;
		NewTargetTimeStamp = Level.TimeSeconds;	
		GotoState('ManningTurret', 'Begin');  //DLEVY 1/6/05
	}

	//---------------------------------------------------------
	//	GetTraceExtents (ManningTurret)
	//---------------------------------------------------------
	function GetTraceExtents( out Vector StartTrace, out Vector EndTrace )
	{
		StartTrace = Pawn.Weapon.GetMuzzleLocationWorld();
		EndTrace = Pawn.Weapon.GetMuzzleLocationWorld() + (Vect(10000,0,0) >> Pawn.Weapon.Rotation);
	}

	//---------------------------------------------------------
	//	FriendlyInTheWayFromLocation (ManningTurret)
	//---------------------------------------------------------
	function bool FriendlyInTheWayFromLocation( Vector FromLocation, optional out gbxPawn BlockingFriendly )
	{
		return false;		
	}

	//---------------------------------------------------------
	//	CalculateDistToTarget (ManningTurret)
	//---------------------------------------------------------
	function float CalculateDistToTarget()
	{
		return VSizeIgnoreZ( TargetLastKnownLoc - Pawn.Location );
	}	

	//---------------------------------------------------------
	//	CalculateSweepPath (ManningTurret)
	//---------------------------------------------------------
	function CalculateSweepPath( EKillZone KillZone )
	{
		local Vector  EndPos, X,Y,Z; //SkyPoint, SkyPointTemp, FireDir, HitNorm,
		local int RandomDir;

		//log( self$ " FiringControllerMG::CalculateSweepPath()", 'MP' );

		//SkyPoint = TargetLastKnownLoc + Vect(0,0,1000.0);	// Wayyy up in the sky above the target.

		//FireDir = TargetLastKnownLoc - Pawn.Turret.Location;
		//FireDir.Z = 0;
		//FireDir = Normal( FireDir );

		// If the target is higher in elevation, use the target's
		// head as the end point.
		if ( TargetLastKnownLoc.Z > ( Pawn.Location.Z + 100.0 ) )
		{
			// Gunner is below the target in elevation.
			EndPos = TargetLastKnownLoc + Target.EyePosition();
			SweepStart = Pawn.Turret.Location;
		}
		else
		{
			// Gunner is up in the air above target.
			//SkyPointTemp = SkyPoint + SWEEP_END_OFFSET * FireDir;
			//Trace( EndPos, HitNorm, SkyPointTemp + Vect(0,0,-2000), SkyPointTemp );

			//SkyPointTemp = SkyPoint - SWEEP_START_OFFSET * FireDir;
			//Trace( SweepStart, HitNorm, SkyPointTemp + Vect(0,0,-2000), SkyPointTemp );


			EndPos = TargetLastKnownLoc;// + Target.EyePosition()  *  Vect(1,1,0.0005);
			EndPos.Z *= 0.25;
			SweepStart = Pawn.Turret.Location;
		}

		if ( KillZone == KZ_Suppress )
		{
			EndPos = SuppressLoc;
		}
		

		SweepPath = EndPos - SweepStart;

		// If in the third (outermost) killzone,
		// adjust the root path by an over-correction offset.
		if ( KillZone == KZ_ZoneThree )
		{
			if (Rand(2) == 0)
				RandomDir = 1;
			else
				RandomDir = -1;

			GetAxes(Pawn.Turret.Rotation, X,Y,Z);
			SweepPath += SWEEP_ERROR_ZONE3 * RandomDir * Y;
		}
	}

	//---------------------------------------------------------
	//	GetPauseTime (ManningTurret)
	//---------------------------------------------------------
	function float GetPauseTime()
	{
		local float Min, Max;

		if ( Pawn.Turret == None )
			return 0.0;

		if ( Pawn.Turret.bIgnoreSuppression )
		{
			Pawn.Turret.GetBestPauseTime( SL_UNSUPPRESSED, Min, Max );
		}
		else
		{
			Pawn.Turret.GetBestPauseTime( MyMind.GetSuppressionLevel(), Min, Max );
		}

		return RandRange( Min, Max );
	}

	//---------------------------------------------------------
	//	Timer (ManningTurret)
	//---------------------------------------------------------
	function Timer()
	{
		MyMind.FacingVector = SweepStart + T * SweepPath;

		// Update the t-value.
		T += TIMER_DURATION;

		if ( T > 1.0)
		{
			T = 0.0;
			SetTimer(0.0, false);
		}
	}

	//---------------------------------------------------------
	//	ApproveShot
	//---------------------------------------------------------
	function bool ApproveShot( Rotator AimRotator )
	{
		local bool bResult;
		local int ndx;
		local bool bVisible;
		local float blindFiringDuration, timeRemaining;
		//log( self$" FiringControllerMG::ApproveShot() TargetLastKnownLoc="$TargetLastKnownLoc$ " AimRotator="$AimRotator, 'MP' );

		bResult = false;

		// Sanity check.
		if ( TheWeapon == None || WGPawn == None || Target == None )
		{
			return false;
		}	

		// Are we done firing out of our fire cone?
			//log( self$" FiringControllerMG::ApproveShot() Level.TimeSeconds="$Level.TimeSeconds$" < OutOfFiringConeNextFireTime="$OutOfFiringConeNextFireTime$" so returning!", 'MP' );

			// Don't approve the shot unless the shooter is pointing at least marginally close to the target.
			if ( !bIsFrenzied && !bGoingToAssault )
			{
				//log( self$" FiringControllerMG::ApproveShot() !bIsFrenzied && !bGoingToAssault", 'MP' );
				if ( !IsTargetInMyFireCone(TargetLastKnownLoc) )
				{
					//log( self$" FiringControllerInfantry::ApproveShot() ApproveShotCutoffDot failed for target's last know location!", 'MP' );
					LogSelective( "ApproveShot: dot-product check failed." );
					return false;
				}
				else
				{
					// Now make sure that we didn't pass because we haven't been updating TargetLastKnownLoc
					if ( !IsTargetInMyFireCone(Target.Location) )
					{
						//log( self$" FiringControllerInfantry::ApproveShot() ApproveShotCutoffDot failed for target's real location!", 'MP' );
						LogSelective( "ApproveShot: dot-product check failed." );
						
						ndx = MyMind.FindTargetInQueue( Target );
						bVisible = (MyMind.TargetQueue[ ndx ].TargetExposureToMe >= 0.5 && MyMind.TargetQueue[ ndx ].TargetOutOfViewRating <= 0.5);

						if ( bVisible )
							blindFiringDuration = OutOfFiringConeVisibleFiringDuration;
						else
							blindFiringDuration = OutOfFiringConeHiddenFiringDuration;
	
						//log( self$" FiringControllerInfantry::ApproveShot() bVisible="$bVisible$" blindFiringDuration="$blindFiringDuration, 'MP' );

						// Is it ok to keep firing at the target's last known location?
						if ( (OutOfFiringConeNextFireTime + blindFiringDuration) <= Level.TimeSeconds )
						{
							//log( self$" FiringControllerInfantry::ApproveShot() We've fired enough at the target's last known location, giving up now.", 'MP' );
							return false;
						}
						else
						{
							// It's ok to fire at the target's last known location for now
							timeRemaining = (OutOfFiringConeNextFireTime + blindFiringDuration) - Level.TimeSeconds;
							//log( self$" FiringControllerInfantry::ApproveShot() Failed cone of fire check, but keep firing at the target's last known location.  timeRemaining="$timeRemaining, 'MP' );
						}
					}
					else
					{
						OutOfFiringConeNextFireTime = Level.TimeSeconds;
					}
				}
			}

			// If friendly was in the way, tell the system somehow
			// so it can say "Watch out!" and lift fire.
			if ( FriendlyInTheWay( BlockingFriendly ) )
			{
				ReactToAllyBlocking( BlockingFriendly );
				bResult = false;		
			}
			else if ( !MuzzleHasClearShot() )
			{
				TargetFailureCode = FAIL_MuzzleBlocked;
				NotifyTargetFailureMind( TargetFailureCode );
				bResult = false;		
			}
			else
			{
				//log( self$" FiringControllerMG::ApproveShot() Else case!", 'MP' );
				
				// Do CSS() here as opposed to in AdjustAimNew() so that it doesn't get called too often for
				// automatic weapons like the Thompson and MP40.
				ndx = MyMind.FindTargetInQueue( Target );
				bVisible = (MyMind.TargetQueue[ ndx ].TargetExposureToMe >= 0.5 && MyMind.TargetQueue[ ndx ].TargetOutOfViewRating <= 0.5);

				if ( bVisible )
					blindFiringDuration = OutOfFiringConeVisibleFiringDuration;
				else
					blindFiringDuration = OutOfFiringConeHiddenFiringDuration;

				if ( (OutOfFiringConeNextFireTime + blindFiringDuration) > Level.TimeSeconds )
				{
					//log( self$" FiringControllerMG::ApproveShot() (OutOfFiringConeNextFireTime + blindFiringDuration) > Level.TimeSeconds, calling CanSeeOrSuppress()", 'MP' );
					bResult = MyMind.CanSeeOrSuppressFromPoint( Target, TheWeapon.GetMuzzleLocationWorld(), SeeLoc, IsHeadShot, SuppressLoc, FailLoc ); 
				}

				//log( self$" FiringControllerMG::ApproveShot() 2: bResult="$bResult, 'MP' );
				
				if ( !bResult && MyMind.bUseAIDebugging && MyMind.AITracker != None )
				{			
					MyMind.AITracker.AddFiringFactor( Firing_CantSeeOrSuppress );
				}
			}

			if ( bResult )
			{
				LastSuccessfulShotTime = Level.TimeSeconds;
			}
			else
			{
				bBurstInterrupted = true;
			}

		return bResult;
	}

	function bool IsTargetInMyFireCone(Vector TargetLoc)
	{
		local bool bResult;
		local Vector Vect1, Vect2;

		bResult = false;
		
		if ( Target != None )
		{
			Vect1 = Vector( WGPawn.TorsoViewRotation() );
			Vect1.Z = 0;
			Vect2 = TargetLoc - WGPawn.Location;
			Vect2.Z = 0;

			if ( Normal( Vect1 ) dot Normal( Vect2 ) >= ApproveShotCutoffDot )
				bResult = true;
		}

		//Log( self$" FiringControllerMG::InMyFireConeUsingRealLocation() bResult="$bResult, 'MP' );

		return bResult;
	}

	//---------------------------------------------------------
	//	AdjustAimNew (ManningTurret)
	//---------------------------------------------------------
	function Rotator AdjustAimNew( Ammunition Ammo, Vector ProjStart, Rotator AimRotator, optional out int bSkipDoTrace )
	{		
		local Actor HitActor;
		local float DistToTarget, RepelBulletsCutoffDist;
		local bool bDoWarningShot, bShotWouldCollide, bMissOnPurpose;
		local Vector HitLoc, HitNormal, MuzzleLoc;

		//Log( self$" FiringControllerMG::AdjustAimNew() KillZone="$KillZone, 'MP' );

		MuzzleLoc = TheWeapon.GetMuzzleLocationWorld();

		if ( KillZone == KZ_ZoneOne )
		{
			//Log( self$" FiringControllerMG::AdjustAimNew() KZ_ZoneOne", 'MP' );
			
			// PSV: 6/20/2005	Fixing bug where player runs past MG, which prevents any updates to TargetLastKnownLoc.
			//			If the player is not exposed to the shooter, shoot at TargetLastKnownLoc, otherwise, shoot at his real location.
			if ( IsTargetInMyFireCone(Target.Location) )
			{
				//Log( self$" FiringControllerMG::AdjustAimNew() Target is in my cone of fire so using real location!", 'MP' );
				// Shoot right at the target's head half of the time.
				if ( ShotCount++ % 2 == 0 )
					AimRotator = Rotator( ( Target.Location + Target.EyePosition() ) - MuzzleLoc );
				else
					AimRotator = Rotator( Target.Location - MuzzleLoc );
			}
			else
			{
				//Log( self$" FiringControllerMG::AdjustAimNew() Target is NOT in my cone of fire so using last known location!", 'MP' );
				// Shoot right at the target's head half of the time.
				if ( ShotCount++ % 2 == 0 )
					AimRotator = Rotator( ( TargetLastKnownLoc + Target.EyePosition() ) - MuzzleLoc );
				else
					AimRotator = Rotator( TargetLastKnownLoc - MuzzleLoc );
			}
		}
		else
		{
			//Log( self$" FiringControllerMG::AdjustAimNew() NOT KZ_ZoneOne", 'MP' );
			
			MyMind.ApplyAccuracy( AimRotator, 50 );

			if ( KillZone == KZ_ZoneThree || KillZone == KZ_Suppress )
			{
				//Log( self$" FiringControllerMG::AdjustAimNew() KZ_ZoneThree or KZ_Suppress", 'MP' );

				TheWeapon.SetNoDamageThisBullet();	// Suppression shots should not damage anyone.
			}
			else
			{
				//Log( self$" FiringControllerMG::AdjustAimNew() Else case!", 'MP' );
				//DistToTarget = CalculateDistToTarget();	

				HitActor = Trace( HitLoc, HitNormal, ProjStart + TheWeapon.FireMode[0].MaxRange() * Vector(AimRotator), ProjStart, true );

				//Log( " FiringControllerMG::AdjustAimNew() HitActor="$HitActor, 'MP' );
				if ( HitActor != None && HitActor.IsA( 'Infantry' ) )
				{		
					if ( HitActor == Target )
					{
						LogSelective( "Shot would normally hit the target." );
						bShotWouldCollide = true;
					}
					else
					{
						LogSelective( "Shot wouldn't hit target, but it would hit "$HitActor.Name$" instead." );
						bMissOnPurpose = true;		// The shot would hit somebody else; miss him on purpose.
					}
				}

				// Does our target repel bullets magically?
				if ( Target.RepelsBullets( RepelBulletsCutoffDist ) )
				{
					if ( RepelBulletsCutoffDist < 0.00001f || DistToTarget > RepelBulletsCutoffDist )
					{
						LogSelective( "Target magically repels bullets!" );
						TheWeapon.SetNoDamageThisBullet();
						bMissOnPurpose = true;
					}
				}

				// Should our target get the "deadlock" bonus?
				if ( !bMissOnPurpose && DoDeadlock( DistToTarget ) )
				{
					LogSelective( "Giving target deadlock bonus." );
					TheWeapon.SetNoDamageThisBullet();
					bMissOnPurpose = bShotWouldCollide;
				}

				// Determine whether or not to the "warning shot" screen effect.  The shot must otherwise have hit the target.
				bDoWarningShot = bShotWouldCollide && DoWarningShot( DistToTarget );

				if ( bDoWarningShot )
				{
					bMissOnPurpose = true;
					LogSelective( "Doing warning shot." );
				}

				// If we must miss the target on purpose, calculate a trajectory that will not hit him.
				if ( bMissOnPurpose )
				{
					LogSelective( "Doing purposeful miss." );
					AimRotator = DoPurposefulMiss( ProjStart, Target.Location, Target, bSkipDoTrace );
				}
			}

		}
		
		MyMind.NotifyPawnIsShooting();
		Target.IShotAtYou( Pawn, false );
		return AimRotator;
	}

	//---------------------------------------------------------
	//	SetFrenzied (ManningTurret)
	//---------------------------------------------------------
	function SetFrenzied( bool bFrenzied )
	{
		log("NAJ**** ERROR: SetFrenzied() called in the ManningTurret state.", 'naj');
	}

	//---------------------------------------------------------
	//	NotifyRally (ManningTurret)
	//---------------------------------------------------------
	function NotifyRally()
	{
		StopWaiting();
	}

	//---------------------------------------------------------
	//	DetermineBurstLength (ManningTurret)
	//---------------------------------------------------------
	function float DetermineBurstLength()
	{
		local float Min, Max;

		//log( self$ " FiringControllerMG::DeteremineBurstLength() Pawn.Turret.bIgnoreSuppression="$Pawn.Turret.bIgnoreSuppression, 'MP' );

		if ( Pawn.Turret.bIgnoreSuppression )
		{
			Pawn.Turret.GetBestBurstLength( SL_UNSUPPRESSED, Min, Max );
		}
		else
		{
			Pawn.Turret.GetBestBurstLength( MyMind.GetSuppressionLevel(), Min, Max );
		}

		//log( self$ " FiringControllerMG::DeteremineBurstLength() Min="$Min$" Max="$Max, 'MP' );

		return RandRange( Min, Max );
	}

	//---------------------------------------------------------
	//	SetRandomFacingVector (ManningTurret)
	//---------------------------------------------------------
	function SetRandomFacingVector()
	{
		local Rotator ForwardRot;
		
		// Only do this once in a while.
		if ( Rand( 100 ) > 50 )
			return;

		ForwardRot = Rotator( Pawn.Turret.GetBaseVector() );
		
		if ( Rand( 2 ) == 0 )
		{
			ForwardRot.Yaw += Rand( 6000 );
		}
		else
		{
			ForwardRot.Yaw -= Rand( 6000 );
		}

		if ( Rand( 2 ) == 0 )
		{
			ForwardRot.Pitch += Rand( 500 );
		}
		else
		{
			ForwardRot.Pitch -= Rand( 500 );
		}

		MyMind.FacingVector = Pawn.Location + 1000.0 * Vector( ForwardRot );
	}


//-----------------------------------------
Begin:		// state ManningTurret
//-----------------------------------------
	bGunFiring = false; //DLEVY

	if ( MyMind.bUseAIDebugging && MyMind.AITracker != None )
	{
		MyMind.AITracker.StartNewFiringCycle( true );
	}

	// Verify that a target exists.
	if ( Target == None || Target.IsDead() )
	{
		if ( MyMind.bUseAIDebugging && MyMind.AITracker != None )
		{
			MyMind.AITracker.AddFiringFactor( Firing_TargetDead );
		}
		Sleep( 1.0 );
		Goto( 'Begin' );
	}

	if ( !Pawn.Turret.IsEnabled() )
	{
		Sleep( 1.0 );
		Goto( 'Begin' );
	}

	//T = 0.0;	// Uncomment this line to make each burst to start a new sweep.

	//UpdateTargetKnownLocation();
	//KillZone = CalcKillZone();

	if (KillZone != KZ_ZoneOne )
	{
		CalculateSweepPath( KillZone );
	}
	
	switch ( KillZone )
	{
	case KZ_None:
		Goto( 'NoZone' );
		break;
	case KZ_ZoneOne:
		Goto( 'Zone1' );
		break;
	case KZ_ZoneTwo:
		Goto( 'Zone2' );
		break;
	case KZ_ZoneThree:
		Goto( 'Zone3' );
		break;
	case KZ_Suppress:
		Goto( 'SuppressingFire' );
		break;
	}	

//-----------------------------------------
NoZone:	// Too far away to hit!
//-----------------------------------------
	StateInfoLabel = 'NoZone';

	TargetFailureCode = FAIL_NoVantage;
	NotifyTargetFailureMind( TargetFailureCode );

	SetRandomFacingVector();

	Pawn.StopFiringWeapon();
	Sleep( 0.5 );
	Goto( 'Begin' );

//-----------------------------------------
SuppressingFire:
//-----------------------------------------
	StateInfoLabel = 'SuppressingFire';

	SetTimer(0.0, false);

	MyMind.FacingVector = SuppressLoc;

	BurstLength = DetermineBurstLength();

	//log( self$ " FiringControllerMG::ManningTurret::SuppressingFire goto, about to call pawn.startfiringweapon() BurstLength="$BurstLength, 'MP' );

	Pawn.StartFiringWeapon();
	Sleep( BurstLength );
	Pawn.StopFiringWeapon();

	PauseTime = GetPauseTime();
	Sleep( PauseTime );


	Goto('Begin');

//-----------------------------------------
Zone1:	// Draw a direct bead on the target
//-----------------------------------------
	StateInfoLabel = 'Zone1';
	TheWeapon.SetInstaKill( true );
	
	SetTimer(0.0, false);

	MyMind.SetFacingPolicy( FACE_Enemy );

	BurstLength = DetermineBurstLength();

	if ( TargetNotViableFromLocation( TheWeapon.GetMuzzleLocationWorld(), -1, TargetFailureCode, BlockingFriendly )
		|| !ApproveShot(Pawn.TorsoViewRotation() ) )
	{
		NotifyTargetFailureMind( TargetFailureCode, BlockingFriendly );
		Pawn.StopFiringWeapon();
		Sleep( 0.5 );
		Goto( 'Begin' );
	}
	
	//log( self$ " FiringControllerMG::ManningTurret::Zone1 goto, about to call pawn.startfiringweapon()", 'MP' );
	Pawn.StartFiringWeapon();
	bGunFiring = true;   //DLEVY flag so dont allow target changes in Zone1 while gun firing

	Sleep( BurstLength );
	Pawn.StopFiringWeapon();

	//PauseTime = GetPauseTime();
	//Sleep( PauseTime );
	Sleep( 0.1 );

	TheWeapon.SetInstaKill( false );

	bGunFiring = false;   //DLEVY allow target changes again
	Goto('Begin');

//-----------------------------------------
Zone2:	// Sweep the ground in front of target,
		// eventually hitting him.
//-----------------------------------------
//-----------------------------------------
Zone3:	// Sweep the ground in front of target,
		// but don't hit him.
//-----------------------------------------
	StateInfoLabel = 'Zone2_or_3';

	MyMind.SetFacingPolicy( FACE_Vector );

	SetTimer(TIMER_DURATION, true);

	BurstLength = DetermineBurstLength();

	if ( TargetNotViableFromLocation( TheWeapon.GetMuzzleLocationWorld(), -1, TargetFailureCode, BlockingFriendly ) 
              || !ApproveShot(Pawn.TorsoViewRotation() ) )
	{
		NotifyTargetFailureMind( TargetFailureCode, BlockingFriendly );
		Pawn.StopFiringWeapon();
		Sleep( 0.5 );
		Goto( 'Begin' );
	}
	//log( self$ " FiringControllerMG::ManningTurret::Zone3 goto, about to call pawn.startfiringweapon() BurstLength="$BurstLength, 'MP' );
	Pawn.StartFiringWeapon();
	Sleep( BurstLength );
	//log( self$ " FiringControllerMG::ManningTurret::Zone3 goto, about to call pawn.stopfiringweapon() BurstLength="$BurstLength, 'MP' );
	Pawn.StopFiringWeapon();

	SetTimer(0.0, false);

	PauseTime = GetPauseTime();
	Sleep( PauseTime );
	Goto('Begin');

ChangingTarget:					//DLEVY new state for handling  changing targets while firing
	StateInfoLabel = 'ChangingTarget';
	Pawn.StopFiringWeapon();
	Sleep(0.1);
	bGunFiring = false;
	
	if ( DesiredNewTarget != None )
		SetTarget(DesiredNewTarget);

	Goto('Begin');
}

simulated function DisplayDebug(Canvas Canvas, out float YL, out float YPos)
{
	Super.DisplayDebug( Canvas, YL, YPos );
}

//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
	MyLogSelectName="FCMG42"

	TIMER_DURATION=0.05
	SWEEPSTART_OFFSET=0.5
	OVERSHOOT_OFFSET=0.4
	SWEEP_ERROR_ZONE3=100.0
	SWEEP_END_OFFSET=10.0
	SWEEP_START_OFFSET=1000.0
        
        OutOfFiringConeHiddenFiringDuration = 20.0f
	OutOfFiringConeVisibleFiringDuration = 5.0f
}class FiringControllerMortar extends FiringControllerInfantry;

var WeapDEMortar	TheMortar;
var int				ShotsRemaining;

const QUEUE_ADJUST_PRIORITY	= 95;
const QUEUE_IDLE_PRIORITY = 90;

//---------------------------------------------------------
//	StartGunningTurret
//---------------------------------------------------------
function StartGunningTurret()
{
	LogSelective( "StartGunningTurret." );
	GotoState( 'Idling' );
}

//---------------------------------------------------------
//	StartLoadingTurret
//---------------------------------------------------------
function StartLoadingTurret()
{
	LogSelective( "StartLoadingTurret." );
	GotoState( 'LoadingTurret' );
}

//---------------------------------------------------------
//	EnsureWeaponIsCurrent
//---------------------------------------------------------
function EnsureWeaponIsCurrent()
{
	if ( TheWeapon == None && WGPawn.Turret != None && WGPawn.Turret.IsA( 'WeapDEMortar' ) )
	{		
		TheWeapon = WGPawn.Turret;
		TheMortar = WeapDEMortar( TheWeapon );
	}
}

//---------------------------------------------------------
//	SetTarget
//---------------------------------------------------------
// The Target var is irrelevant in this FC subclass.
function SetTarget( Pawn NewTarget ) {}

//=========================================================
//	State Idling
//=========================================================
state Idling
{	
	function BeginState()
	{
		WGPawn.PlayWaiting();		
	}

Begin:
	if ( TheMortar != None && TheMortar.Target != None && TheMortar.ReadyToShoot() )
	{
		GotoState( 'Aiming' );
	}
	else
	{
		Sleep( 1.0 );
		Goto( 'Begin' );
	}
	
}

//=========================================================
//	State WaitingBetweenShots
//=========================================================
state WaitingBetweenShots
{
	function BeginState()
	{
		WGPawn.AddAnimToQueue( 'de_mortar_gunner_idle_3', QUEUE_IDLE_PRIORITY, false, true, false, 1.0, 6.0, class'PawnAnimRandomIdleCallback' );
		
		if ( TheMortar != None )
			SetTimer( TheMortar.TimeBetweenShots, false );
		else
			SetTimer( 1.0, false );
	}

	function Timer()
	{
		if ( TheMortar != None && TheMortar.Target != None && TheMortar.ClipAmt > 0 )
		{
			if ( TheMortar.ReadyToShoot() )
				GotoState( 'Aiming' );
			else
				SetTimer( 1.0, false );
		}
		else
		{
			GotoState( 'Idling' );
		}
	}
}

//=========================================================
//	State Aiming
//=========================================================
state Aiming
{
	function BeginState()	
	{	
		if ( !WGPawn.bHidden && !TheMortar.IndependentFireMode() )
		{
			WGPawn.FlushAnimQueueChannel( 0 );
			WGPawn.AddAnimToQueue( 'de_mortar_gunner_idle_3', QUEUE_ADJUST_PRIORITY, false, false,,, 0.15 );		
			SetTimer( 2.0, false );
		}
		else
		{
			WGPawn.FireWeaponBurst( 1 );
			GotoState( 'WaitingBetweenShots' );
		}
	}

	function Timer()
	{
		WGPawn.FireWeaponBurst( 1 );
		GotoState( 'WaitingBetweenShots' );
	}
}

//=========================================================
//	State LoadingTurret
//=========================================================
state LoadingTurret
{
	// This state essentially does nothing, because the loader
	// never actually has to fire the gun.
}

//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
	MyLogSelectName="FCMORTAR"
}
//=============================================================================
// Infantry firing controller that specifically handles behavior when manning 
// Pak 36 Anti-Tank guns.
//
// Author: Neil Johnson, Gearbox Software.
//=============================================================================
class FiringControllerPak36_ extends FiringControllerInfantry;

//---------------------------------------------------------
//	Variables / Constants
//---------------------------------------------------------
var		float		TIMER_DURATION;
var		float		OutOfViewDot, CloseEnoughToFireDot;
var		float		InfantryZOffset;
var const float		AfterShotDelayTime;
var		Vector		TankZAdjust;

//---------------------------------------------------------
//	StartGunningTurret
//---------------------------------------------------------
function StartGunningTurret()
{
	LogSelective( "StartGunningTurret." );
	GotoState( 'GunningTurret' );
}

//---------------------------------------------------------
//	StartLoadingTurret
//---------------------------------------------------------
function StartLoadingTurret()
{
	LogSelective( "StartLoadingTurret." );
	GotoState( 'LoadingTurret' );
}

//---------------------------------------------------------
//	SetTargetPoint
//---------------------------------------------------------
function SetTargetPoint( Vector NewTargetPoint )
{
	if ( MyMind != None )
	{
		MyMind.FacingVector = NewTargetPoint;
	}
}

//---------------------------------------------------------
//	EnsureWeaponIsCurrent
//---------------------------------------------------------
function EnsureWeaponIsCurrent()
{
	if ( TheWeapon == None && WGPawn.Turret != None && WGPawn.Turret.IsA( 'WeapDEPak36_' ) )
	{		
		TheWeapon = WGPawn.Turret;
	}
}
//---------------------------------------------------------
//	AdjustAimNew
//---------------------------------------------------------
function Rotator AdjustAimNew( Ammunition Ammo, Vector ProjStart, Rotator AimRotator, optional out int bSkipDoTrace )
{
	// Sanity checks.
	if ( bNoAccuracyAdjust || Pawn == None || Target == None || TheWeapon == None || MyMind == None )
	{
		MyMind.NotifyPawnIsShooting();
		Target.IShotAtYou( Pawn, false );
		return AimRotator;
	}

	LogSelective( "AdjustAimNew: Target=="$Target.Name );

	// This is a projectile weapon, so the do-trace call is irrelevant.
	bSkipDoTrace = 1;

	if ( Target.IsA( 'gbxSVehicle' ) )
	{
		// Target is a tank/vehicle.
		LogSelective( "Target is a tank or vehicle." );
		if ( !gbxSVehicle( Target ).HasBeenFiredAtByAT( Pawn, TheWeapon ) && !WeapDEPak36_( TheWeapon ).TargetIsInKillZone( Target ) )
		{
			LogSelective( "First AT shot at target; doing purposeful miss." );
			AimRotator = ATPurposefulMiss( ProjStart, Target.Location, Target );
			
			gbxSVehicle( Target ).SetFiredAtByAT( Pawn, TheWeapon );
			Target.IShotAtYou( Pawn, false );
			return AimRotator;
		}
		else
		{
			// Direct shot at a tank.
			LogSelective( "Lobbing direct shot." );
			Target.IShotAtYou( Pawn, false );

			// Slight adjustment upwards to account for the fact that tanks have no collision box near their treads.
			AimRotator = Rotator( (Target.Location + TankZAdjust) - ProjStart );
			return AimRotator;
		}		
	}
	else
	{
		LogSelective( "Target is infantry; doing purposeful miss." );
		AimRotator = ATPurposefulMiss( ProjStart, Target.Location, Target );
		
		Target.IShotAtYou( Pawn, false );
		return AimRotator;
	}	
}


//---------------------------------------------------------
//	ATPurposefulMiss
//---------------------------------------------------------
function Rotator ATPurposefulMiss( Vector ProjStart, Vector TargetLoc, gbxPawn MissTarget, optional out int bSkipDoTrace )
{
	local Vector VectToTarget;

	LogSelective( "ATPurposefulMiss()." );

	// Shoot way over the target's head.
	VectToTarget = ( TargetLoc + Vect(0,0,200.0) ) - WGPawn.Location;

	return Rotator( VectToTarget );
}


//=========================================================
//	State GunningTurret
//=========================================================
state GunningTurret
{
	//---------------------------------------------------------
	//	ApproveShot (GunningTurret)
	//---------------------------------------------------------
	function bool ApproveShot( Rotator AimRotator )
	{
		return true;
	}

	//---------------------------------------------------------
	//	TargetOutOfView (GunningTurret)
	//---------------------------------------------------------
	function bool TargetOutOfView()
	{
		local float TheDot;
		local Vector SeeLoc, SuppressLoc, FailLoc;
		local int IsHeadShot;

		if ( Target == None )
			return false;

		TheDot = Normal( MyMind.FacingVector - TheWeapon.Location ) dot Vector( TheWeapon.Rotation );

		LogSelective( "TargetOutOfView: TheDot: "$TheDot );

		if ( TheDot < OutOfViewDot )
			return true;
		
		if ( MyMind.CanSeeOrSuppressFromPoint( Target, TheWeapon.GetMuzzleLocationWorld(), SeeLoc, IsHeadShot, SuppressLoc, FailLoc, 1 ) &&
			SeeLoc != Vect(0,0,0) )
			return false;
		else
			return true;
	}

	//---------------------------------------------------------
	//	CloseEnoughToFire (GunningTurret)
	//---------------------------------------------------------
	function bool CloseEnoughToFire()
	{
		local Rotator TempRot;
		local Vector ToTargetNorm, FacingVectNorm;
		local float TheDot, DistToTarget;

		if ( Target == None )
			return false;

		ToTargetNorm = Normal( MyMind.FacingVector - TheWeapon.Location );
		TempRot = WeapDEPak36_( TheWeapon ).GetFireRotation();

		FacingVectNorm = Vector( TempRot );
		TheDot = FacingVectNorm dot ToTargetNorm;

		DistToTarget = VSize( Target.Location - TheWeapon.Location );

		LogSelective( "CloseEnoughToFire: TheDot: "$TheDot );
		return ( TheDot >= CloseEnoughToFireDot && DistToTarget <= WeapDEPak36_( TheWeapon ).MaxFiringDist );
	}

	
	//---------------------------------------------------------
	//	Tick (GunningTurret)
	//---------------------------------------------------------
	function Tick( float DeltaTime )
	{
		Super.Tick( DeltaTime );

		if ( Target != None )
		{
			SetTargetPoint( Target.Location );
		}
	}

//-----------------------------------------
Begin:		// state GunningTurret
//-----------------------------------------
	
	if ( TargetOutOfView() )
	{
		WGPawn.StopFiringWeapon();
		NotifyTargetFailureMind( FAIL_NoVantage, None );		
	}
	else
	if ( CloseEnoughToFire() )
	{
		WGPawn.FireWeaponBurst( 1 );
		Sleep( AfterShotDelayTime );
	}
	else
	{
		WGPawn.StopFiringWeapon();
	}

	Sleep( 0.5 );
	Goto( 'Begin' );
}


//=========================================================
//	State LoadingTurret
//=========================================================
state LoadingTurret
{
	// This state essentially does nothing, because the loader
	// never actually has to fire the gun.
}


//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
	MyLogSelectName="FCPAK36"
	TIMER_DURATION=0.75
	OutOfViewDot=0.9659
	//OutOfViewDot=0.9239
	CloseEnoughToFireDot=0.99
	InfantryZOffset=20.0

	AfterShotDelayTime=7.0
	TankZAdjust=Vect(0,0,40)
}//=============================================================================
// Infantry firing controller that specifically handles behavior when manning 
// Flakvierling anti-aircraft guns.
//
// Author: Neil Johnson, Nick Chinnici, Gearbox Software.
//=============================================================================
class FiringControllerPAK88_ extends FiringControllerInfantry;

//---------------------------------------------------------
//	Variables / Constants
//---------------------------------------------------------
var		float		TIMER_DURATION;
var		Vector		TankZAdjust, LastTargetLoc;
var		bool		bDirectShot;
var		bool		bTargetPointSet, bOKToFire;
var		Actor		PrevTarget;
var		int			TimesShotAt;


var enum EKillZone
{
	KZ_None,
	KZ_ZoneOne,
	KZ_ZoneTwo,
	KZ_ZoneThree,
	KZ_Suppress,
}KillZone;


//---------------------------------------------------------
//	StartGunningTurret
//---------------------------------------------------------
function StartGunningTurret()
{
	LogSelective( "StartGunningTurret." );
	bTargetPointSet = false;
	GotoState( 'GunningTurret' );
}

//---------------------------------------------------------
//	StartLoadingTurret
//---------------------------------------------------------
function StartLoadingTurret()
{
	LogSelective( "StartLoadingTurret." );
	GotoState( 'LoadingTurret' );
}

//---------------------------------------------------------
//	SetTargetPoint
//---------------------------------------------------------
function SetTargetPoint( Vector NewTargetPoint )
{
	MyMind.FacingVector = NewTargetPoint;
	bTargetPointSet = true;
}

//---------------------------------------------------------
//	SetOKToFire
//---------------------------------------------------------
function SetOKToFire( bool ok )
{
	bOKToFire = ok;
}

//---------------------------------------------------------
//	EnsureWeaponIsCurrent
//---------------------------------------------------------
function EnsureWeaponIsCurrent()
{
	if ( TheWeapon == None && WGPawn.Turret != None && WGPawn.Turret.IsA( 'WeapDEPAK88_' ) )
	{		
		TheWeapon = WGPawn.Turret;
	}
}

//---------------------------------------------------------
//	AdjustAimNew
//---------------------------------------------------------
function Rotator AdjustAimNew( Ammunition Ammo, Vector ProjStart, Rotator AimRotator, optional out int bSkipDoTrace )
{
	// Sanity checks.
	if ( bNoAccuracyAdjust || Pawn == None || Target == None || TheWeapon == None || MyMind == None )
	{
		MyMind.NotifyPawnIsShooting();
		Target.IShotAtYou( Pawn, false );
		return AimRotator;
	}

	// This is a projectile weapon, so the do-trace call is irrelevant.
	bSkipDoTrace = 1;

	if ( Target.IsA( 'gbxSVehicle' ) )
	{
		// Target is a tank/vehicle.
		LogSelective( "Target is a tank or vehicle." );
		if ( !gbxSVehicle( Target ).HasBeenFiredAtByAT( Pawn, TheWeapon ) && !bDirectShot)
		{
			LogSelective( "First AT shot at target; doing purposeful miss." );
			AimRotator = ATPurposefulMiss( ProjStart, Target.Location, Target );
			
			gbxSVehicle( Target ).SetFiredAtByAT( Pawn, TheWeapon );
			Target.IShotAtYou( Pawn, false );
			return AimRotator;
		}
		else
		{
			// Direct shot at a tank.
			LogSelective( "Lobbing direct shot." );
			Target.IShotAtYou( Pawn, false );

			// Slight adjustment upwards to account for the fact that tanks have no collision box near their treads.
			AimRotator = Rotator( (Target.Location + TankZAdjust) - ProjStart );
			return AimRotator;
		}		
	}
	else
	{
		if(bDirectShot)
		{
			// Direct shot at infantry...this is gonna hurt!
			LogSelective( "Lobbing direct shot." );
			Target.IShotAtYou( Pawn, false );

			// Slight adjustment upwards
			AimRotator = Rotator( (Target.Location + Vect(0.0,0.0,5.0)) - ProjStart );
			return AimRotator;

		}
		//Log( "****Target is infantry; doing purposeful miss.****",'NAC' );
		AimRotator = ATPurposefulMiss( ProjStart, Target.Location, Target );
		
		Target.IShotAtYou( Pawn, false );
		return AimRotator;
	}	
}


//---------------------------------------------------------
//	CalcKillZone
//---------------------------------------------------------

function EKillZone CalcKillZone( float DistToTarget ){
	if ( DistToTarget < 0 )
	{
		// Error: target wasn't found in the Mind's TargetQueue, but we need to keep moving here.  Calculate the distance directly.
		DistToTarget = VSizeIgnoreZ( Target.Location - WGPawn.Location );
	}

	if ( DistToTarget < WGPawn.Turret.Zone1OuterRadius )
	{
	//	Log( "****Zone 1..."$DistToTarget,'NAC' );
		return KZ_ZoneOne;
	}
	else if ( DistToTarget <  WGPawn.Turret.Zone2OuterRadius )
	{
	//	Log( "****Zone 2..."$DistToTarget,'NAC' );
		return KZ_ZoneTwo;
	}
	else //  DistToTarget >=  WGPawn.Turret.Zone3OuterRadius 
	{
	//	Log( "****Zone 3..."$DistToTarget,'NAC' );
		return KZ_ZoneThree;
	}

}

//---------------------------------------------------------
//	ATPurposefulMiss
//---------------------------------------------------------
function Rotator ATPurposefulMiss( Vector ProjStart, Vector TargetLoc, gbxPawn MissTarget, optional out int bSkipDoTrace )
{
	local Vector VectToTarget, VectOffset, SuppressionVector;
	local float	 DistToTarget, TargetMovedOffset;
	local Rotator AdjustedAim;
	local EKillZone NewKillZone;
	local float SuppressionLevelAccuracyAdjustment;

	LogSelective( "ATPurposefulMiss()." );

	//if this guy is in a unit of guys, aim for the unit's centroid
	if (!MissTarget.Controller.bIsHumanPlayer)
	{
		TargetLoc = MissTarget.MyUnit.GetUnitCentroid();
	}
	
	SuppressionLevelAccuracyAdjustment = WeapDEPak88_( TheWeapon ).Spotter.MyUnit.MyUnitController.GetSuppressionLevelAnalog()* 20;  //get the suppression level of the Spotter to effect the accuracy of the gun

	// Target is the same one we shot at last time..
	if (MissTarget == PrevTarget)
	{
		TargetMovedOffset = VSizeIgnoreZ(TargetLoc - LastTargetLoc);
		++TimesShotAt;	
	}
	else
	{
		TimesShotAt = 1;
		WeapDEPAK88_(WGPawn.Turret).NumShotsSoFar = -1;
		PrevTarget = MissTarget;
		TargetMovedOffset = 0.0;
	}


	LastTargetLoc = TargetLoc;
	VectToTarget = TargetLoc - WGPawn.Location;
	AdjustedAim = Rotator(VectToTarget);
	DistToTarget = VSizeIgnoreZ( VectToTarget );

	NewKillZone = CalcKillZone(DistToTarget);
	
	if (TargetMovedOffset != 0.0)
	{
		if (NewKillZone == KZ_ZoneThree)
			TargetMovedOffset = TargetMovedOffset/10;
		else if (NewKillZone == KZ_ZoneTwo)
			TargetMovedOffset = TargetMovedOffset/30;
		else if (NewKillZone == KZ_ZoneOne)
			TargetMovedOffset = TargetMovedOffset/1000;  //it will almost always hit you if you are in zone 1

	}
	if (NewKillZone == KZ_ZoneThree)		//if a target has been spotted and is in KZ_ZoneThree he is killed on the 3rd shot
	{
		switch (TimesShotAt) 
		{
			case 1:
				//	log("****SHOT AT 1 TIME!!!! KZ3",'NAC');
					MyMind.ApplyAccuracy(AdjustedAim , 250+SuppressionLevelAccuracyAdjustment + TargetMovedOffset);
					return AdjustedAim;
			case 2:
		//		log("****SHOT AT 2 TIMES!!!! KZ3",'NAC');
					MyMind.ApplyAccuracy(AdjustedAim , 220+SuppressionLevelAccuracyAdjustment + TargetMovedOffset);
					return AdjustedAim;
			case 3:
			//	log("****SHOT AT 3 TIMES!!!! KZ3",'NAC');
					MyMind.ApplyAccuracy(AdjustedAim , 220+SuppressionLevelAccuracyAdjustment + TargetMovedOffset);
					return AdjustedAim;
			case 4:
			//	log("****SHOT AT 4 TIMES, DIE!!!! KZ3",'NAC');
				SuppressionVector.Z = SuppressionLevelAccuracyAdjustment - 160.0 + TargetMovedOffset;
				AdjustedAim = Rotator( (TargetLoc + SuppressionVector) - WGPawn.Location );
				return AdjustedAim;

			default:
				SuppressionVector.Z = SuppressionLevelAccuracyAdjustment - 160.0 + TargetMovedOffset;
			//	log("****SHOT AT 4+ TIMES, DIE !!!! KZ3",'NAC');
				AdjustedAim = Rotator( (TargetLoc + SuppressionVector) - WGPawn.Location );
				return AdjustedAim;
		}
	} //end KZ_ZoneThree

	else if (NewKillZone == KZ_ZoneTwo)	//if a target has been spotted and is in KZ_ZoneTwo he is killed on the 2nd shot
	{
		switch (TimesShotAt)
		{
			case 1:
	//				log("****SHOT AT 1 TIMES!!!! KZ2",'NAC');
					MyMind.ApplyAccuracy(AdjustedAim , 220+SuppressionLevelAccuracyAdjustment + TargetMovedOffset);
					return AdjustedAim;
			case 2:
			//	log("****SHOT AT 2 TIMES!!!! KZ2",'NAC');
					MyMind.ApplyAccuracy(AdjustedAim , 220+SuppressionLevelAccuracyAdjustment + TargetMovedOffset);
					return AdjustedAim;

			case 3:
				SuppressionVector.Z = SuppressionLevelAccuracyAdjustment - 175.0;
			//	log("****SHOT AT 3 TIMES, DIE!!!! KZ2",'NAC');
				AdjustedAim = Rotator( (TargetLoc + SuppressionVector) - WGPawn.Location );
				return AdjustedAim;
			default:
				SuppressionVector.Z = SuppressionLevelAccuracyAdjustment - 175.0;
			//	log("****SHOT AT 3+ TIMES, DIE!!!! KZ2",'NAC');
				AdjustedAim = Rotator( (TargetLoc + SuppressionVector) - WGPawn.Location );
				return AdjustedAim;
		}

	}

	else if (NewKillZone == KZ_ZoneOne)	//if a target has been spotted and is in KZ_ZoneOne he is killed on the 1st shot
	{
		if (TimesShotAt <= 1)
		{
			//	log("****SHOT AT 1 TIMES!!!! KZ1",'NAC');
			MyMind.ApplyAccuracy(AdjustedAim , 220+SuppressionLevelAccuracyAdjustment + TargetMovedOffset);
			return AdjustedAim;
		}
		else
		{
			SuppressionVector.Z = SuppressionLevelAccuracyAdjustment - 200.0;
		//	log("****SHOT AT 1+ TIMES, DIE!!!! KZ2",'NAC');
		        AdjustedAim = Rotator( (TargetLoc + SuppressionVector) - WGPawn.Location );
		        return AdjustedAim;
		}

	}
	//VectOffset.X = RandRange(-100,100);
	//VectOffset.Y = RandRange(-100,100);
	//VectOffset.Z = RandRange(-400,200);
	
	VectToTarget = ( TargetLoc + VectOffset ) - WGPawn.Location;

	return Rotator( VectToTarget );
}

//---------------------------------------------------------
//	CloseEnoughToFire
//---------------------------------------------------------
function bool CloseEnoughToFire()
{
	local Rotator TempRot;
	local Vector ToTargetNorm, FacingVectNorm;
	local float TheDot, DistToTarget;
	if ( Target == None )
	{	
		return false;
	}
	
	if (!bTargetPointSet)
		return false;

	bTargetPointSet = false;   //Clear out this flag...
	ToTargetNorm = Normal( MyMind.FacingVector - TheWeapon.Location );
	TempRot = WeapDEPak88_( TheWeapon ).GetFireRotation();
	FacingVectNorm = Vector( TempRot );
	TheDot = FacingVectNorm dot ToTargetNorm;
	DistToTarget = VSize( Target.Location - TheWeapon.Location );
	//Log( "CloseEnoughToFire: TheDot: "$TheDot,'NAC' );

	return ( TheDot >= 0.99 );//&& DistToTarget <= WeapDEPak36_( TheWeapon ).MaxFiringDist );
}


//=========================================================
//	State GunningTurret
//=========================================================
state GunningTurret
{	
	//---------------------------------------------------------
	//	BeginState (GunningTurret)
	//---------------------------------------------------------
	function BeginState()
	{
		Super.BeginState();
		MyMind.SetFacingPolicy( FACE_Vector );
		SetTimer(TIMER_DURATION, true);
	}	


	//---------------------------------------------------------
	//	TargetOutOfView (GunningTurret)
	//---------------------------------------------------------
	function bool TargetOutOfView()
	{
		local float TheDot;
		local Vector SeeLoc, SuppressLoc, FailLoc, StartPos;
		local int IsHeadShot;

		if ( Target == None )
		{
			PrevTarget = None;
			TimesShotAt = 1;
			return false;
		}

		TheDot = Normal( MyMind.FacingVector - TheWeapon.Location ) dot Vector( TheWeapon.Rotation );

	//	Log( "**TargetOutOfView: TheDot: "$TheDot $" MyMind:" $MyMind $" BARREL_01:"$ TheWeapon.GetBoneCoords('Barrel_01').origin  $ " TARGET:" $Target $" TARGETLOCATION:"$Target.Location,'NAC');

		StartPos = TheWeapon.GetBoneCoords('Barrel_01').origin;
		if (MyMind.CanSeeOrSuppressFromPoint( Target, TheWeapon.GetMuzzleLocationWorld() , SeeLoc, IsHeadShot, SuppressLoc, FailLoc, 1 ) && SeeLoc != Vect(0,0,0))
		//if ( MyMind.CanSeeOrSuppressFromPoint( Target, StartPos , SeeLoc, IsHeadShot, SuppressLoc, FailLoc, 1 ) && SeeLoc != Vect(0,0,0))
			return false;
		else
			return true;
	}
	//---------------------------------------------------------
	//	CloseEnoughToFire (GunningTurret)
	//---------------------------------------------------------
	function bool CloseEnoughToFire()
	{
		local Rotator TempRot;
		local Vector ToTargetNorm, FacingVectNorm;
		local float TheDot;

		if ( Target == None )
		{	
			return false;
		}

		//if (!bTargetPointSet){
		//	return false;
		//}
		if (!bOKToFire)
			return false;
		
		//bTargetPointSet = false;   //Clear out this flag...

		ToTargetNorm = Normal( MyMind.FacingVector - TheWeapon.Location );
		TempRot = WeapDEPak88_( TheWeapon ).GetFireRotation();

		FacingVectNorm = Vector( TempRot );
		TheDot = FacingVectNorm dot ToTargetNorm;
		
		//log("*****************THE DOT:" $TheDot,'NAC');
		
		if(WeapDEPAK88_(WGPawn.Turret).NumShotsSoFar < 0)
		{
			++WeapDEPAK88_(WGPawn.Turret).NumShotsSoFar;
			return false;
		}
		++WeapDEPAK88_(WGPawn.Turret).NumShotsSoFar;

		return ( TheDot >= 0.99 );
	}

	//---------------------------------------------------------
	//	ApproveShot (GunningTurret)
	//---------------------------------------------------------
	function bool ApproveShot( Rotator AimRotator )
	{
		if (CloseEnoughToFire())
		{
			return true;
		}
		return false;
	}


//-----------------------------------------
Begin:		// state GunningTurret
//-----------------------------------------
	
		
	if ( TargetOutOfView() )
	{
		WGPawn.StopFiringWeapon();
		NotifyTargetFailureMind( FAIL_NoVantage, None );		
	}

	else if(Target == Level.GetLocalPlayerController().Pawn )  //if we are shooting at the player, he is close enough to fire at, and we've given him time to get up if shot at before, ok the shot
	{
		//log("**************PLAYER SHOT AT TIME DIFF:"$(Level.TimeSeconds - WeapDEPAK88_( TheWeapon ).PlayerHitTimer),'NAC');
		//if( CloseEnoughToFire() && ((Level.TimeSeconds - WeapDEPAK88_( TheWeapon ).PlayerHitTimer) > 20.0))//&& WeapDEPAK88_( TheWeapon ).bGunIsLoaded )
		//{
		if(WeapDEPAK88_( TheWeapon ).OKToFire() && CloseEnoughToFire())
		{
			WeapDEPAK88_( TheWeapon ).SetTargetActor(MyMind.TargetQueue[ MyMind.ndxEnemyInQueue ].Target);
			Target =MyMind.TargetQueue[ MyMind.ndxEnemyInQueue ].Target;
			WGPawn.StartFiringWeapon();		
			WeapDEPAK88_( TheWeapon ).bGunIsLoaded = false;
		}	
	}
	else if (CloseEnoughToFire())
	{
		WeapDEPAK88_( TheWeapon ).SetTargetActor(MyMind.TargetQueue[ MyMind.ndxEnemyInQueue ].Target);
		Target =MyMind.TargetQueue[ MyMind.ndxEnemyInQueue ].Target;
		WGPawn.StartFiringWeapon();		
		WeapDEPAK88_( TheWeapon ).bGunIsLoaded = false;
	}
	else if (Target != None && !bTargetPointSet)  //we have a target and want to makes sure that actor is set, but we have not set a target point yet.
	{
		WeapDEPAK88_( TheWeapon ).SetTargetActor(MyMind.TargetQueue[ MyMind.ndxEnemyInQueue ].Target);
	}
	else
	{
		WGPawn.StopFiringWeapon();
	}	
	
	Sleep( 1.0 );
	Goto( 'Begin' );
}

//=========================================================
//	State LoadingTurret
//=========================================================
state LoadingTurret
{
	// This state essentially does nothing, because the loader
	// never actually has to fire the gun.
}

state Exposed
{
Begin:
		//do nothing
}

//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
	MyLogSelectName="FCPAK88"
	TIMER_DURATION=0.75
	TankZAdjust=Vect(0,0,40)
	bDirectShot = false
	bTargetPointSet = false;
	TimesShotAt = 0;


}class FiringControllerPanzerfaust extends FiringControllerInfantry;

var float	NextCanFireTime;
var float	FiringInterval;
var bool	bIgnoreSuppression;

//---------------------------------------------------------
// StartUsingPanzerfaust
//---------------------------------------------------------
function StartUsingPanzerfaust()
{
	// TBD: Any panzerfaust-specific logic here?
}

//---------------------------------------------------------
//	TargetNotViable
//---------------------------------------------------------
function bool TargetNotViable( int Posture, out ETargetFailure FailCode, optional out gbxPawn BlockingFriendly )
{
	local bool bResult;

	bResult = Super.TargetNotViable( Posture, FailCode, BlockingFriendly );

	if ( !bResult )
	{
		if ( SeeLoc != Vect( 0,0,0 ) )
		{
			if( TargetOutOfRange() )
			{
				return true;
			}
			else
			{
				return false;		// Direct shot available; ok to use Panzerfaust
			}
		}
		else
		{
			if ( Target.IsA( 'gbxSVehicle' ) )
				return true;	// No direct shot, and target is a tank; save your shot.					
			else
				return false;	// No direct shot available, but ok to do suppression shots on humans.
		}	
	}
	else
		return true;
}

//-----------------------------------------------------
// TargetOutOfRange
//-----------------------------------------------------
function bool TargetOutOfRange()
{
	return VSize( Target.Location - Pawn.Location ) > MyMind.MaxTargetRange;
}

//-----------------------------------------------------
//	CanFireWeapon
//-----------------------------------------------------
function bool CanFireWeapon()
{
	local bool bResult;
	bResult = Super.CanFireWeapon();
	
	bResult = bResult && ( NextCanFireTime <= 0.00001f || Level.TimeSeconds > NextCanFireTime );

	LogSelective( "CanFireWeapon: "$bResult$" ; Level.TimeSeconds=="$Level.TimeSeconds$" ; NextCanFireTime=="$NextCanFireTime );
	return bResult;
}

//---------------------------------------------------------
//	AdjustAimNew
//---------------------------------------------------------
function Rotator AdjustAimNew( Ammunition Ammo, Vector ProjStart, Rotator AimRotator, optional out int bSkipDoTrace )
{
	// Sanity checks.
	if ( bNoAccuracyAdjust || Pawn == None || Target == None || TheWeapon == None || MyMind == None )
	{
		MyMind.NotifyPawnIsShooting();
		Target.IShotAtYou( Pawn, false );
		return AimRotator;
	}

	LogSelective( "AdjustAimNew: Target=="$Target.Name );

	// Panzerfaust is a projectile weapon, so the do-trace call is irrelevant.
	bSkipDoTrace = 1;

	if ( Target.IsA( 'gbxSVehicle' ) )
	{
		// Target is a tank/vehicle.
		LogSelective( "Target is a tank or vehicle." );
		if ( !gbxSVehicle( Target ).HasBeenFiredAtByAT( Pawn, TheWeapon ) )
		{
			LogSelective( "First panzerfaust shot at target; doing purposeful miss." );
			AimRotator = PanzerfaustPurposefulMiss( ProjStart, Target.Location, Target );
			
			gbxSVehicle( Target ).SetFiredAtByAT( Pawn, TheWeapon );
			Target.IShotAtYou( Pawn, false );
			return AimRotator;
		}
		else
		{
			// Direct shot at a tank.
			LogSelective( "Lobbing direct shot." );
			Target.IShotAtYou( Pawn, false );
			return AimRotator;
		}		
	}
	else
	{
		AimRotator = PanzerfaustPurposefulMiss( ProjStart, Target.Location, Target );

		// If we're alone in our unit, do one purposeful miss and then prefer to switch to the next best weapon.
		if( Pawn.MyUnit == None || ( Pawn.MyUnit != None && Pawn.MyUnit.GetNumLivingMembers() == 1 ) )
		{
			if( MindPanzerfaust(MyMind) != None )
			{
				MindPanzerfaust(MyMind).SwitchToRifleDist = Pawn.SightRadius;
				MindPanzerfaust(MyMind).SwitchToRifleDistVehiclePriority = Pawn.SightRadius;
			}
		}

		Target.IShotAtYou( Pawn, false );
		return AimRotator;
	}	
}

//---------------------------------------------------------
//	PanzerfaustPurposefulMiss
//---------------------------------------------------------
function Rotator PanzerfaustPurposefulMiss( Vector ProjStart, Vector TargetLoc, gbxPawn MissTarget, optional out int bSkipDoTrace )
{
	local Vector VectToTarget;

	LogSelective( "PanzerfaustPurposefulMiss()." );

	// Shoot way over the target's head.
	VectToTarget = ( TargetLoc + Vect(0,0,200.0) ) - WGPawn.Location;

	return Rotator( VectToTarget );
}

//=========================================================
//	State ConsiderFiringOptions
//=========================================================
state ConsiderFiringOptions
{
	function BeginState()
	{
		LogSelective( "BeginState [FCPanzerFaust]." );
		Super.BeginState();		
	}	

	//-----------------------------------------------------
	//	TargetNotViableFromLocation (ConsiderFiringOptions)
	//-----------------------------------------------------
	function bool TargetNotViableFromLocation( Vector FromLocation, int Posture, out ETargetFailure FailCode, optional out gbxPawn BlockingFriendly )
	{
		local bool bResult;

		bResult = Super.TargetNotViableFromLocation( FromLocation, Posture, FailCode, BlockingFriendly );
		if ( !bResult )
		{
			if ( SeeLoc != Vect( 0,0,0 ) )
			{
				if( TargetOutOfRange() )
					return true;
				else
					return false;		// Direct shot available; ok to use Panzerfaust
			}
			else
			{
				if ( Target.IsA( 'gbxSVehicle' ) )
					return true;	// No direct shot, and target is a tank; save your shot.					
				else
					return false;	// No direct shot available, but ok to do suppression shots on humans.
					
			}			
		}
		else
			return true;
	}
}

function SetNextFireTime()
{
	NextCanFireTime = Level.TimeSeconds + FiringInterval;
}

// Must override global so that state Exposed gets this logic.
function FireBurstWithTimer() 
{
	SetNextFireTime();
	Super.FireBurstWithTimer();
}

state Peeking
{
	function bool ShouldFireThisRound()
	{
		if ( bPermittedToOpBurst || bGoingToAssault || HasTargetOrder() )		
			return true;

		return ( bIgnoreSuppression || MyMind.IsTerrified() || MyMind.GetSuppressionLevel() == SL_UNSUPPRESSED );		 
	}
}

state HunkeredDown
{
	function bool ShouldFireThisRound()
	{
		if ( Threat == None )
			return false;		
		else if ( bPermittedToOpBurst || bGoingToAssault || HasTargetOrder() || IsAtLowCover() )
			return true;

		return ( bIgnoreSuppression || MyMind.IsTerrified() || MyMind.GetSuppressionLevel() == SL_UNSUPPRESSED );	
	}
}

// Must apparently override FireBurstWithTimer for *every* substate of FireUponTarget.
// I don't know why I can't simply override FireUponTarget's version; Unreal ignores my override in such a case...
//
state FireOverWall
{
	function FireBurstWithTimer() 
	{
		SetNextFireTime();
		Super.FireBurstWithTimer();
	}

	function bool ShouldStayUp()
	{
		return false;
	}	
}

state FireOverCorner
{
	function FireBurstWithTimer() 
	{
		SetNextFireTime();
		Super.FireBurstWithTimer();
	}

	function bool ShouldStayUp()
	{
		return false;
	}
}

state FireAroundCorner
{
	function FireBurstWithTimer() 
	{
		SetNextFireTime();
		Super.FireBurstWithTimer();
	}

	function bool ShouldStayUp()
	{
		return false;
	}
}

defaultproperties
{
	MyLogSelectName="FCPANZERFAUST"
	GrenadeFCClass=None
	FiringInterval=10.0
	bHidden=true
	bIgnoreSuppression=true
}class FiringControllerScarecrow extends FiringControllerInfantry;

function StartFiringFromCover( Pawn NewTarget )
{
	GotoState( 'FiringFromCover' );
}

function EnsureWeaponIsCurrent()
{
	if ( MyMind == None )
		return;

	if ( Pawn != None && Pawn.Weapon != None && TheWeapon != Pawn.Weapon )
	{
		TheWeapon = gbxWeapon( Pawn.Weapon );
	}
}

state Exposed
{
}

state FiringFromCover
{
	function bool DoMountAction()
	{
		WGPawn.StartGoingToCrouch( true );
		bMountSuccessful = true;
		return true;
	}
}

state HunkeredDown
{
	function BeginState()
	{
		Super.BeginState();
		WGPawn.StartGoingToCrouch( true );
	}

	function bool IsNearCoverPoint() 
	{ 
		return true; 
	}

	function bool ShouldPeekThisRound()
	{
		return false;
	}
}

state ConsiderFiringOptions
{
	function bool HasShotAroundCorner()
	{
		return false;
	}
}

state FireOverWall
{
	function PositionSelf()
	{
		WGPawn.StartGoingToStand( true );
		MyMind.RequestFacingPolicy( FACE_Enemy );
	}

	function bool CanThrowGrenade( float DistToTarget )
	{
		return false;
	}

	function bool CanShootAtTarget() 
	{
		return true;
	}
}

state GoBackToCover
{
	function bool ReturnToCover() 
	{
		return true;
	}

	function bool ReturningToCover() 
	{
		return false;
	}
}


simulated function DisplayDebug(Canvas Canvas, out float YL, out float YPos)
{
	Canvas.DrawColor.R = 0;
	Canvas.DrawColor.G = 255;
	Canvas.DrawColor.B = 255;
	YPos += YL;
	Canvas.SetPos(4,YPos);
	Canvas.DrawText("FIRINGCONTROLLER: "$Self.name$"  PAWN: "$Pawn.Name, false);	

	Canvas.DrawColor.R = 255;
	Canvas.DrawColor.G = 255;
	Canvas.DrawColor.B = 255;

	YPos += YL;
	Canvas.SetPos(4,YPos);
	Canvas.DrawText("STATE: "$GetStateName(), false, 0.9, 0.9);

	if ( !NoShow )
	{		
		Canvas.DrawColor.R = 0;
		Canvas.DrawColor.G = 255;
		Canvas.DrawColor.B = 255;

		YPos += YL;
		Canvas.SetPos(4,YPos);
		Canvas.DrawText("TARGET: "$Target, false, 0.9, 0.9);

		YPos += YL;
		Canvas.SetPos(4,YPos);
			if ( MyMind.GetSuppressionLevel() == SL_UNSUPPRESSED )
			Canvas.DrawText("SUPPRESSION LEVEL: NOT suppressed", false, 0.9, 0.9);
			else if ( MyMind.GetSuppressionLevel() == SL_SUPPRESSED )
			Canvas.DrawText("SUPPRESSION LEVEL: SUPPRESSED", false, 0.9, 0.9);

		YPos += YL;
		Canvas.SetPos(4,YPos);
		Canvas.DrawText("COVER POINT: "$Pawn.MyClaimedNavPoint, false, 0.9, 0.9);

		YPos += YL;
		Canvas.SetPos(4,YPos);
		Canvas.DrawText("STATE LABEL: "$StateInfoLabel, false, 0.9, 0.9 );

		YPos += YL;
		Canvas.SetPos(4,YPos);
	}
}


defaultproperties
{
	MyLogSelectName="FCSCARECROW"
}class FiringControllerScarecrowLethal extends FiringControllerScarecrow;

var array<gbxPawn> HitList;

//---------------------------------------------------------
//	AdjustAimNew
//---------------------------------------------------------
function Rotator AdjustAimNew( Ammunition Ammo, Vector ProjStart, Rotator AimRotator, optional out int bSkipDoTrace )
{
	if ( TargetIsOnHitList() )
		return AimRotator;
	else
		return Super.AdjustAimNew( Ammo, ProjStart, AimRotator, bSkipDoTrace );
}

//---------------------------------------------------------
//	TargetIsOnHitList
//---------------------------------------------------------
function bool TargetIsOnHitList()
{
	local int x;

	if ( Target == None )
		return false;

	for( x=0; x < HitList.Length; ++x )
		if ( HitList[x] == Target )
			return true;

	return false;
}

//---------------------------------------------------------
//	NotifyEnteredVolume
//---------------------------------------------------------
function NotifyEnteredVolume( gbxPawn Other )
{
	local int x;

	for( x=0; x < HitList.Length; ++x )
		if ( HitList[x] == Other )
			return;

	HitList.Length = HitList.Length + 1;
	HitList[ HitList.Length - 1 ] = Other;
}

//---------------------------------------------------------
//	NotifyExitedVolume
//---------------------------------------------------------
function NotifyExitedVolume( gbxPawn Other )
{
	local int x;

	for( x=0; x < HitList.Length; ++x )
		if ( HitList[x] == Other )
		{
			HitList.Remove( x, 1 );
		}
}

//---------------------------------------------------------
//	Destroyed
//---------------------------------------------------------
function Destroyed()
{
	Super.Destroyed();
	HitList.Remove( 0, HitList.Length );
}

//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
	MyLogSelectName="FCSCARECROWLETHAL"
}class FlakvierlingCallback extends MountCallbackClass;

static function MountFinished( gbxPawn gbxP, bool bSuccess, EMountAction MountAction )
{
	if ( gbxP.Controller.IsA( 'Mind' ) )
	{
		Mind( gbxP.Controller ).ChangeMind();
	}	
}
class gbxUnitMessageTrigger extends gbxMessageTrigger;


//
// See whether the other actor is relevant to this trigger.
//
function bool IsRelevant( actor Other )
{
	local gbxPawn	aPawn;
	
	if( !bInitiallyActive )
		return false;

	if( MatchTag != '' )
	{
		if (Other.Tag != MatchTag)
		{
			aPawn = gbxPawn(Other);
			if (aPawn != None)
			{
				if (aPawn.MyUnit.Tag != MatchTag)
					return false;
			}
			else
				return false;
		}
	}

	switch( TriggerType )
	{
	case TT_HumanPlayerProximity:
			return (Pawn(Other) != None) && Pawn(Other).IsHumanControlled();
		case TT_PlayerProximity:
			return (Pawn(Other) != None) && (Pawn(Other).IsPlayerPawn() || Pawn(Other).WasPlayerPawn());
		case TT_PawnProximity:
			return (Pawn(Other) != None) && Pawn(Other).CanTrigger(self);
		case TT_ClassProximity:
			return ClassIsChildOf(Other.Class, ClassProximityType);
		case TT_AnyProximity:
			return true;
		case TT_Shoot:
			return ( (Projectile(Other) != None) && (Projectile(Other).Damage >= DamageThreshold) );
	}
}
//=============================================================================
// Basically just the Unreal trigger, with an extra field for the mask test.
//=============================================================================
class gbxUnitTrigger extends gbxTrigger;



//
// See whether the other actor is relevant to this trigger.
//
function bool IsRelevant( actor Other )
{
	local gbxPawn	aPawn;
	
	if( !bInitiallyActive )
		return false;

	if( MatchTag != '' )
	{
		if (Other.Tag != MatchTag)
		{
			aPawn = gbxPawn(Other);
			if (aPawn != None)
			{
				if (aPawn.MyUnit.Tag != MatchTag)
					return false;
			}
			else
				return false;
		}
	}

	switch( TriggerType )
	{
	case TT_HumanPlayerProximity:
			return (Pawn(Other) != None) && Pawn(Other).IsHumanControlled();
		case TT_PlayerProximity:
			return (Pawn(Other) != None) && (Pawn(Other).IsPlayerPawn() || Pawn(Other).WasPlayerPawn());
		case TT_PawnProximity:
			return (Pawn(Other) != None) && Pawn(Other).CanTrigger(self);
		case TT_ClassProximity:
			return ClassIsChildOf(Other.Class, ClassProximityType);
		case TT_AnyProximity:
			return true;
		case TT_Shoot:
			return ( (Projectile(Other) != None) && (Projectile(Other).Damage >= DamageThreshold) );
	}
}
//=============================================================================
// AI subcontroller responsible for managing grenade lobbing.  This class is
// owned by the FiringController.
//
// Author: Stephen Palmer, Gearbox Software.
//=============================================================================
class GrenadeFiringController extends Actor;



//---------------------------------------------------------
//	Variables / Constants
//---------------------------------------------------------
struct native SGrenadeLobInfo
{
	var gbxPawn	Target;
	var float	TargetPriority; // Priority as reported by the aMind
	var Vector	LobVector;		// Velocity vector to hit target
	var Vector  LobTarget;		// Location where grenade will land, if thrown with LobVector
	var float	LobTime;		// Time it will take to hit the target with the current lob vector
	var float	Effect;			// Measure of the potential effect of throwing a grenade at this target
	var float	Score;			// Aggregate measure to determine if we want to throw a grenade at this target
	var float	LastUpdateTime;	// Last time this target was refreshed
	var float	LastAttackTime; // Last time this target was attacked
	var float	LastLobCalcTime;// Last time the lob vector was calculated for this target

	var Vector	CachedPawnLoc;		// The pawn's location when the last trajectory calculation was made
	var Vector	CachedTargetLoc;	// The target's location when the last trajectory calculation was made
};

////////// API Variables ///////////////////
var float					MaxTargetDeltaZ;		// Target is too high above this value
var float					LobBehindRange;			// Range at which lob error will tend toward overthrowing the target
var float					CeilingAdjust;			// Number of units (positive) to adjust down from ceiling when calculating lob apex
var float					GravityFactor;			// Adjust gravity used in calculating lob vector
var float					LocRecalcDeltaSquared;	// The pawn or the pawn's target must move this far (squared) from their location when the last calculation was done to cause the lob vector to be recalculated
var float					BaseMinScore;			// Minimum score required to be considered a best target (Base)
var float					MinCalcInterval;		// Minimum amount of time that must pass between each Effect/LobVector calculation
var float					LobInfoExpire;			// LobInfo's are considered stale if not refreshed this fast
var float					TimerInterval;			// Interval at which LobInfo array is cleaned
var float					AfterThrowPauseTime;	// Amt of time to pause after actually throwing the grenade.
var float					CookTimeThresh;			// An attack must require this much cookoff time to actually use that state
var int						FacingCheckRotThresh;	// A pawn must be rotated within this number of rot units toward his target for the target to be valid
var bool					bUseLobVectorCache;		// For debugging; turns off caching of lob vector calculations.
var config bool				NoShow;

////////// Lob limits/adjustments (defined by pawn) //////////
var float					MaxTargetRange;		// Maximum distance grenade can be thrown
var range					RangeAccuracyMod;	// Minimum and maximum modifiers applied to accuracy based on target range
var range					LobAccuracyMod;		// Accuracy range, attenuated by suppression level
var float					MaxLobHeight;		// Maximum height allowed to apply to grenade toss
var float					FrustrationFactor;	// Multiple applied to frustration adjustment to target score
var float					MinLobYaw;			// Minimum rotation applied to normal vector from target to pawn where grenade may land
var float					OverthrowFactor;	// Given a perfect throw, offset the destination away from the thrower by this much

////////// Internal variables //////////////
var float					CookTime;			// Time to cook off current grenade
var float					BestTargetMinScore;	// Minimum score required to be considered a best target
var bool					bAttackPending;		// LobInfo array will not be purged while this is true
var bool					bLogSelect;			// DEBUG VAR
var array<SGrenadeLobInfo>	TargetLobInfos;		// Contains necessary data to hit any of our current targets
var gbxPawn					Pawn;				// Pawn that controlls me.
var Name					PawnToWatch;		// DEBUG VAR

var FiringControllerInfantry	MyFiringController;	// Firing controller that owns me


//---------------------------------------------------------
//	LogSelective
//---------------------------------------------------------
// Selective logging function.  Use this in place of Log() wherever possible.
// Using the "logselect" console command at runtime causes only those log messages
// that pertain to an individual pawn to be printed out.
//
function LogSelective( String msg )
{
	if ( bLogSelect )
	{ 
		if ( PawnToWatch == '' || PawnToWatch == Pawn.Name )
			log( "GFC: NAJ**** "$Pawn.Name$" ["$GetStateName()$"]: "$msg, 'naj');
		else
		if ( PawnToWatch == 'InfantryUSA' && Pawn.IsA( 'InfantryUSA' ) )
			log( "GFC: NAJ**** "$Pawn.Name$" ["$GetStateName()$"]: "$msg, 'naj' );
		else
		if ( PawnToWatch == 'InfantryGermany' && Pawn.IsA( 'InfantryGermany' ) )
			log( "GFC: NAJ**** "$Pawn.Name$" ["$GetStateName()$"]: "$msg, 'naj' );
	}
}

//---------------------------------------------------------
//	PostBeginPlay
//---------------------------------------------------------
function PostBeginPlay()
{
	Super.PostBeginPlay();
	ResetMinScore();
}

//---------------------------------------------------------
//	SetFiringController
//---------------------------------------------------------
function SetFiringController( FiringControllerInfantry NewFC )
{
	MyFiringController = NewFC;
}

//---------------------------------------------------------
//	Possess
//---------------------------------------------------------
function Possess( gbxPawn aPawn )
{
	Pawn = aPawn;

	// Load lob adjustment variables from pawn
	RangeAccuracyMod	= Pawn.G_RangeAccuracyMod;
	LobAccuracyMod		= Pawn.G_LobAccuracyMod;
	MaxTargetRange		= Pawn.G_MaxTargetRange;
	MaxLobHeight		= Pawn.G_MaxLobHeight;
	FrustrationFactor	= Pawn.G_FrustrationFactor;
	MinLobYaw			= Pawn.G_MinLobYaw;
	OverthrowFactor		= Pawn.G_OverthrowFactor;
}

//---------------------------------------------------------
//	PrepareForDestroy
//---------------------------------------------------------
function PrepareForDestroy()
{
	GotoState( 'WaitingForDestruction' );
}

//---------------------------------------------------------
//	MinScore functions
//---------------------------------------------------------
function ResetMinScore()
{
	BestTargetMinScore = BaseMinScore;
}

function AdjustMinScore( float adjAmount )
{
	BestTargetMinScore = FMax( 0.0, BestTargetMinScore + adjAmount );
}

function SetBaseMinScore( float newBase )
{
	BaseMinScore = FMax( 0.0, newBase );
}

function float GetMinScore()
{
	return BestTargetMinScore;
}

//---------------------------------------------------------
//	NotifyTargeting
//---------------------------------------------------------
function NotifyTargeting()
{
	LogSelective( "NotifyTargeting." );
	/* TBD
	local int i;

	// Set all your attack times to 0 in order to make them attractive.

	for( i = 0; i < TargetLobInfos.Length; ++i )
	{
		TargetLobInfos[ i ].LastAttackTime = 0.0;
	}
	*/
}

//---------------------------------------------------------
//	LobVectorIsStale
//---------------------------------------------------------
function bool LobVectorIsStale( int idx )
{
	return (
			VSizeSquared( Pawn.Location - TargetLobInfos[ idx ].CachedPawnLoc ) > LocRecalcDeltaSquared ||
			VSizeSquared( TargetLobInfos[ idx ].Target.Location - TargetLobInfos[ idx ].CachedTargetLoc ) > LocRecalcDeltaSquared ||
			TargetLobInfos[ idx ].LastAttackTime > TargetLobInfos[ idx ].LastLobCalcTime ||
			TargetLobInfos[ idx ].LastLobCalcTime == 0.0
			);
}

//---------------------------------------------------------
//	CalculateLobVector
//---------------------------------------------------------
function bool CalculateLobVector( vector vDest, out vector LobVector, out float LobTime )
{
	local Vector vMidPoint, vApex, OutVector;
	local Vector HitLocation, HitNormal;
	local Actor HitActor;
	local float Gravity, distance1, distance2, time1, time2;

	//log( "*****SJP: "$Pawn$" CalculateLobVector to "$vDest$" from "$Pawn.Location, 'SJP' );
	
	// Mid point between ourselves and the target
	vMidPoint = Pawn.Location + ( vDest - Pawn.Location ) * 0.5;

	// Find the ceiling at the midpoint (if any)
	Trace( HitLocation, HitNormal, vMidPoint + ( Vect(0,0,1) * MaxLobHeight ), Pawn.Location, false );

	if( HitLocation != Vect(0,0,0) )
	{
		vMidPoint = HitLocation - ( Vect(0,0,1) * CeilingAdjust );
	}
	else
	{
		// We're probably outside.  Attenuate the lob height by the target distance.
		vMidPoint.Z += FMax(2.0 * Pawn.BaseEyeHeight, ( VSize(Pawn.Location - vDest) / MaxTargetRange ) * MaxLobHeight);
	}

	if( vMidPoint.Z < Pawn.Location.Z || vMidPoint.Z < vDest.Z )
	{
		//log( "****SJP: "$Pawn$" CalculateLobVector failed because the lob arc height was below myself or the target." );
		return false;
	}

	// How high should the grenade travel to reach the apex?
	distance1 = vMidPoint.Z - Pawn.Location.Z;
	distance2 = vMidPoint.Z - vDest.Z;

	// Gravity is defined by the physics volume, and multiplied by our internal factor
	Gravity = Abs(PhysicsVolume.Gravity.Z) * GravityFactor;

	// How long will it take for the grenade to travel this distance?
	time1 = sqrt( (2.0 * distance1) / Gravity );
	time2 = sqrt( (2.0 * distance2) / Gravity );

	if( time1 < 0.25 )
	{
		//log( "****SJP: "$Pawn$" CalculateLobVector failed because the target is too close to me", 'SJP' );
		// too close
		return false;
	}

	// Lateral velocity needed to get there in time
	OutVector = ( vDest - Pawn.Location ) / ( time1 + time2 );

	// Vertical velocity needed to get there in time
	OutVector.Z = Gravity * time1;

	// Time for sanity check.  Trace to the apex from start and end position to make sure we won't hit anything along the way
	vApex = Pawn.Location + OutVector * time1;
	vApex.Z = vMidPoint.Z;

	// Trace from pawn to apex
	HitActor = Trace( HitLocation, HitNormal, vApex, Pawn.Location, true );
	if( HitActor != None )
	{
		//log( "****SJP: "$Pawn$" CalculateLobVector failed because something is blocking the lob.", 'SJP' );
		// We hit something in the way, fail.
		return false;
	}

	// Trace from target to apex
	HitActor = Trace( HitLocation, HitNormal, vApex, vDest + (Vect(0,0,1) * 128.0), true );
	if( HitActor != None && !HitActor.IsA('Pawn') )
	{
		//log( "****SJP: "$Pawn$" CalculateLobVector failed because something is blocking the lob.", 'SJP' );
		// We hit something other than a pawn in the way, fail.
		return false;
	}

	LobVector = OutVector;
	LobTime = time1 + time2;

	log( "****SJP: "$Pawn$" CalculateLobVector success!", 'SJP' );
	return true;
}

//---------------------------------------------------------
//	CalculateTarget
//---------------------------------------------------------
function bool CalculateTarget( int idx )
{
	local Vector LobSideVector, vDest,HitLocation,HitNormal, LobNormal;
	local float LobError, TargetRange, RangeError, SupError, ClampedSupLevel;
	local Rotator LobRotator;
	local Actor HitActor;

//	if(idx<0 || idx > TargetLobInfos.Length || TargetLobInfos.Length == 0)
//		return false;

	// We might not have to recalculate this lob vector
	if( bUseLobVectorCache && !LobVectorIsStale( idx ) )
	{
		if( TargetLobInfos[ idx ].LobVector != vect(0,0,0) )
			return true;
		else
			return false;
	}

	// Save the pawn and target's absolute location
	TargetLobInfos[ idx ].CachedPawnLoc = Pawn.Location;
	TargetLobInfos[ idx ].CachedTargetLoc = TargetLobInfos[ idx ].Target.Location;

	// Ensure target is not too high
	if( TargetLobInfos[ idx ].Target.Location.Z - Pawn.Location.Z > MaxTargetDeltaZ )
	{
		TargetLobInfos[ idx ].LobVector = vect(0,0,0);
		return false;
	}

	// Make sure target is within range
    TargetRange = VSize( Pawn.Location - TargetLobInfos[ idx ].Target.Location );

	if( TargetRange > MaxTargetRange )
		return false;

	RangeError = Lerp( TargetRange / MaxTargetRange, RangeAccuracyMod.Min, RangeAccuracyMod.Max );	

	// GBX:naj - modified 3/2/04 - Suppression now goes from 0 to 2 instead of 0 to 1.
	//SupError = Lerp( Pawn.MyUnit.MyUnitController.GetSuppressionLevelAnalog(), LobAccuracyMod.Min, LobAccuracyMod.Max );
	ClampedSupLevel = FClamp( Pawn.MyUnit.MyUnitController.GetSuppressionLevelAnalog(), 0.0, 1.0 );
	SupError = Lerp( ClampedSupLevel, LobAccuracyMod.Min, LobAccuracyMod.Max );

	// Distance from the target the grenade will land
	LobError = ( RangeError * SupError );

	//log("NAJ**** CalculateLobVector(): "$Pawn.Name$" TargetRange: "$TargetRange$" Min: "$LobAccuracyMod.Min$" ; Max: "$LobAccuracyMod.Max$" SupError: "$SupError$" ; LobError: "$LobError, 'naj' );
	// Direction from the target the grenade will land
	
	LobRotator = Rot(0,1,0) * RandRange( MinLobYaw, 65535 - MinLobYaw );

	// LobSideVector determines which "side" of the target the grenade will land on ... toward the front if far away, behind if very close
	if( TargetRange - LobError  < LobBehindRange )
	{
		LobSideVector = Normal( Pawn.Location - TargetLobInfos[ idx ].Target.Location  );
	}
	else
	{
		LobSideVector = Normal( TargetLobInfos[ idx ].Target.Location - Pawn.Location  );
	}

	// Final landing spot is the target's location plus the LobSideVector rotated around LobRotator, LobError units away from the target
	vDest = TargetLobInfos[ idx ].Target.Location + (LobSideVector >> LobRotator) * LobError;
	vDest = VDest + OverthrowFactor * Normal( TargetLobInfos[ idx ].Target.Location - Pawn.Location  );

	log("***SJP: "$Pawn$" RangeError: "$RangeError$"  SupError: "$SupError$" Vector: "$vDest - TargetLobInfos[ idx ].Target.Location, 'SJP');

	if( CalculateLobVector( vDest, TargetLobInfos[ idx ].LobVector, TargetLobInfos[ idx ].LobTime ) )
	{
		// Save the lob destination
		TargetLobInfos[ idx ].LobTarget = vDest;

		// Save calc time
		TargetLobInfos[ idx ].LastLobCalcTime = Level.TimeSeconds;

		//NAC: do a quick trace to see if we throw it in the direction of lob vector, will it hit an object and bounce back at us. 
		LobNormal =Normal( TargetLobInfos[ idx ].LobVector);
		vDest = (Pawn.Location + Pawn.EyeHeight * vect(0,0,1));
		HitActor = Trace(HitLocation,HitNormal,vDest+(LobNormal * 250),vDest,true);
		if (HitActor != None)
		{
			TargetLobInfos[ idx ].LobVector = vect(0,0,0);
			return false;
		}
		//NAC-

		log( "*****SJP: "$Pawn$" Calculation successful. LobVector: "$TargetLobInfos[ idx ].LobVector$" LobTime:"$TargetLobInfos[ idx ].LobTime, 'SJP' );
		return true;
	}

	return false;
}

//---------------------------------------------------------
//	CalculateEffect
//---------------------------------------------------------
function float CalculateEffect( vector TargetLocation, float DamageRadius )
{
	local gbxPawn Victim;
	local float vDamage, tDist, Effect;

	// reset the effect level
	Effect = 0.0;

	// For now we'll judge effectiveness by the relative potential damage. + for enemies, - for friendlies
	foreach RadiusActors( class'gbxPawn', Victim, DamageRadius, TargetLocation )
	{
		//LogSelective( "CalculateEffect(): Victim="$Victim );
		// Line check to see if the target will be hurt
		if( FastTrace( Victim.Location, TargetLocation ) )
		{
			tDist = VSize(Victim.Location - TargetLocation);
			vDamage = ( 1 - FMax( 0,(tDist - Victim.CollisionRadius)/DamageRadius ) ) * Victim.Health;

			//LogSelective( "CalculateEffect(): vDamage="$vDamage );

			//log("***SJP: "$Pawn$" might hit "$Victim$" with grenade (tdist is "$tDist$").  Damage modifier is "$vDamage, 'SJP');

			if( Victim.SameTeamAs( Pawn ) )
			{
				// Big penalty for hurting teammates
				//LogSelective( "CalculateEffect(): Choosing "$TargetLobInfos[ idx ].Target.Name$" will hurt teammates." );
				vDamage = -10000;
			}

			Effect += vDamage;
		}
	}

	return Effect;
}

//---------------------------------------------------------
//	ScoreTarget
//---------------------------------------------------------
function ScoreTarget( int idx )
{
	// TODO: get the damage radius from the grenade in my inventory
	TargetLobInfos[ idx ].Effect = CalculateEffect( TargetLobInfos[ idx ].Target.Location + (Vect(0,0,1) * 64.0), 600.0 );
	
	// Update score
	if( TargetLobInfos[ idx ].Effect > 0.0 )
	{
		//LogSelective( "CalculateEffect(): TargetPriority="$TargetLobInfos[ idx ].TargetPriority$" ; Effect: "$TargetLobInfos[ idx ].Effect );
		TargetLobInfos[ idx ].Score = TargetLobInfos[ idx ].TargetPriority * TargetLobInfos[ idx ].Effect;

		// If this is the target my firing controller is shooting at, include the frustration level in the calculations
		if( MyFiringController.Target == TargetLobInfos[ idx ].Target )
		{
			TargetLobInfos[ idx ].Score *= (1.0 + MyFiringController.FrustrationLevel) * FrustrationFactor;
		}
	}
	else
	{
		TargetLobInfos[ idx ].Score = 0.0;
	}
}

//---------------------------------------------------------
//	RefreshTarget
//---------------------------------------------------------
function RefreshTarget( gbxPawn rTarget, float TargetPriority )
{
	local int i;
	local bool bNewTarget;
	local SGrenadeLobInfo NewLobInfo;

	bNewTarget = true;

	for( i = 0; i < TargetLobInfos.Length; ++i )
	{
		if( TargetLobInfos[i].Target == rTarget && !TargetIsStale(i) )
		{
			TargetLobInfos[i].TargetPriority = TargetPriority;

			if( Level.TimeSeconds - TargetLobInfos[i].LastUpdateTime > MinCalcInterval )
			{
				TargetLobInfos[i].LastUpdateTime = Level.TimeSeconds;
				ScoreTarget( i );
			}

			bNewTarget = false;
			break;
		}
	}

	if( bNewTarget && VSizeSquared(rTarget.Location - Pawn.Location) < MaxTargetRange * MaxTargetRange )
	{
		NewLobInfo.Target = rTarget;
		NewLobInfo.TargetPriority = TargetPriority;
		NewLobInfo.LastUpdateTime = Level.TimeSeconds;

		TargetLobInfos.Length = TargetLobInfos.Length + 1;
		TargetLobInfos[ TargetLobInfos.Length - 1 ] = NewLobInfo;

		ScoreTarget( TargetLobInfos.Length - 1 );
	}
}

//---------------------------------------------------------
//	CleanTargetList
//---------------------------------------------------------
function CleanTargetList()
{
	local int i;
	local bool bQuit;

	do
	{
		bQuit = true;

		for( i = 0; i < TargetLobInfos.Length; ++i )
		{
			if( TargetIsStale(i) )
			{
				TargetLobInfos.Remove( i, 1 );
				bQuit = false;
				break;
			}
		}
	} until(bQuit);
}

//---------------------------------------------------------
//	TargetIsStale
//---------------------------------------------------------
function bool TargetIsStale( int idx )
{
	return	TargetLobInfos[ idx ].Target == None ||
			TargetLobInfos[ idx ].Target.IsDead() ||
			Level.TimeSeconds - TargetLobInfos[ idx ].LastUpdateTime > LobInfoExpire ||
			VSizeSquared(TargetLobInfos[ idx ].Target.Location - Pawn.Location) > MaxTargetRange * MaxTargetRange;
}

//---------------------------------------------------------
//	WantsToThrowGrenade
//---------------------------------------------------------
// GBX:naj - added 3/12/04
function bool WantsToThrowGrenade( out int BestIndex )
{
	if ( CanThrowGrenade() )
	{
		return GetAttackTargetIndex( BestIndex );
	}
	else
	{
		LogSelective( "WantsToThrowGrenade(): can't (false)." );
		return false;
	}
}

//---------------------------------------------------------
//	CanThrowGrenade
//---------------------------------------------------------
// GBX:naj - added 3/12/04
function bool CanThrowGrenade()
{
	if ( Pawn == None || Pawn.MyUnit == None || Pawn.MyUnit.MyUnitController == None )
	{
		LogSelective( "CanThrowGrenade(): can't because pawn, unit, or unitcontroller is None (false)." );
		return false;
	}
	else
	{
		return ( !bAttackPending && Pawn.MyUnit.MyUnitController.IsAnyGrenadeAttackAllowed() );
	}
}

//---------------------------------------------------------
//	GetAttackTargetIndex
//---------------------------------------------------------
function bool GetAttackTargetIndex( out int BestIndex )
{
	LogSelective( "GetAttackTargetIndex()." );

	// Make sure the fire mode says we can fire
	if( Pawn == None || Pawn.Weapon == None || Pawn.Weapon.FireMode[0] == None || !Pawn.Weapon.FireMode[1].AllowFire() )
	{
		//!ABORT!
		LogSelective( "GetAttackTargetIndex(): aborting (false)." );
		bAttackPending = false;
		return false;
	}

	BestIndex = GetBestTargetIndex( true );

	if( BestIndex < 0 )
	{
		LogSelective( "GetAttackTargetIndex(): BestIndex < 0." );
		return false;
	}

	bAttackPending = true;

	LogSelective( "GetAttackTargetIndex(): returning true for BestIndex "$BestIndex );
	return true;
}
//---------------------------------------------------------
//	GetBestTargetIndex
//---------------------------------------------------------
function int GetBestTargetIndex( bool StrictRules )
{
	local int i, BestIndex;

	BestIndex = -1;

	// For now, just return the entry with the highest score that is above the minimum
	for( i = 0; i < TargetLobInfos.Length; ++i )
	{
		if( TargetLobInfos[i].Target.IsDead() )
			continue;

		// Loose rules first: things only we care about internally to GrenadeFiringController

		if( !(TargetLobInfos[i].Score > BestTargetMinScore && 
			(BestIndex < 0 || TargetLobInfos[i].Score > TargetLobInfos[BestIndex].Score) &&
			Pawn.IsFacingRotator( Rotator(TargetLobInfos[ i ].Target.Location - Pawn.Location), FacingCheckRotThresh ))
		)
			continue;

		if( StrictRules )
		{
			if(	!(MyFiringController.GrenadesAllowedAgainstTarget( TargetLobInfos[ i ].Target ) &&
				Pawn.MyUnit.MyUnitController.IsGrenadeAttackAllowed( TargetLobInfos[ i ].Target.Location ))
			)
				continue;
		}

		BestIndex = i;

	}

	return BestIndex;
}

//---------------------------------------------------------
//	AttackTargetIndex
//---------------------------------------------------------
function bool AttackTargetIndex( int i )
{
	local bool LobVectorCalculated;

//	Perf_Begin("+++SJP: CalculateLobVector");
	LobVectorCalculated = CalculateTarget(i);
//	Perf_End();

	//if( LobVectorCalculated && Pawn.MyUnit.MyUnitController.IsGrenadeAttackAllowed( TargetLobInfos[ i ].Target.Location ) )	
	if( LobVectorCalculated )	
	{
		// Make sure the fire mode says we can fire
		if( !Pawn.Weapon.FireMode[1].AllowFire() )
		{
			//!ABORT!
			bAttackPending = false;
			return false;
		}

		// Set the throw vector on the grenade
		UsableHandGrenade( Pawn.SecondaryWeapon ).ThrowVector = TargetLobInfos[ i ].LobVector;

		// Set the cook off time
		CookTime = FMax(0.0, UsableHandGrenade( Pawn.SecondaryWeapon ).GrenadeClass.default.FuseTimeMin + UsableHandGrenade( Pawn.SecondaryWeapon ).default.FuseStartDelay - TargetLobInfos[ i ].LobTime);

		if( CookTime > CookTimeThresh )
			Pawn.m_bCookingGrenade = true;

		// Begin the fire sequence, after setting m_bCookingGrenade, so the animations will play correctly
		Pawn.Weapon.FireMode[1].ModeDoFire();

		// Now go to the cooking off state if we need to, otherwise return as usual
		if( Pawn.m_bCookingGrenade )
		{
			GotoState('CookingGrenade');
		}
		else
		{
			GotoState('HasThrownGrenade');
		}

		// Save the last attack time for the lob calculation cache
		TargetLobInfos[ i ].LastAttackTime = Level.TimeSeconds;

		return true;
	}

	bAttackPending = false;

	return false;
}

//---------------------------------------------------------
//	GrenadeTossCallback
//---------------------------------------------------------
function GrenadeTossCallBack()
{
	Pawn.Weapon.FireMode[1].FireProjectile();
}

//---------------------------------------------------------
//	GrenadeTossFromGroundCallBack
//---------------------------------------------------------
function GrenadeTossFromGroundCallBack()
{
	local int i;
	local gbxGrenade Gren;

	for( i = 0; i < Pawn.Attached.Length; i++ )
	{
		if( Pawn.Attached[ i ].IsA('gbxGrenade') )
		{
			Gren = gbxGrenade( Pawn.Attached[ i ] );

			Gren.ThrowGrenade();
			break;
		}
	}
}

//---------------------------------------------------------
//	Think
//---------------------------------------------------------
function Think()
{
	if( !bAttackPending )
	{
		// Clean up the target list
		CleanTargetList();
	}

	//SetTimer( TimerInterval, false );
}

//---------------------------------------------------------
//	State CookingGrenade

state CookingGrenade
{
	ignores AttackTargetIndex;

	function BeginState()
	{
		SetTimer( CookTime, false );
	}

	function Timer()
	{
		WargamePawn( Pawn ).PlayThrow(1);
		GotoState( 'HasThrownGrenade' );
	}
}

//---------------------------------------------------------
//	State HasThrownGrenade

state HasThrownGrenade
{
	function BeginState()
	{
		SetTimer( AfterThrowPauseTime, false );
	}

	function EndState()
	{
		SetTimer( TimerInterval, false );
		bAttackPending = false;
	}

	function Timer()
	{
		GotoState('');
	}
}

//---------------------------------------------------------
//	DisplayDebug
//---------------------------------------------------------
simulated function DisplayDebug(Canvas Canvas, out float YL, out float YPos)
{
	local int i;

	Canvas.DrawColor.R = 255;
	Canvas.DrawColor.G = 0;
	Canvas.DrawColor.B = 255;
	YPos += YL;
	Canvas.SetPos(4,YPos);
	Canvas.DrawText("GRENADEFIRINGCONTROLLER: "$Self.name, false);

	if ( !NoShow )
	{
		YPos += YL;
		Canvas.SetPos(4,YPos);
		Canvas.DrawText("STATE: "$GetStateName(), false, 0.9, 0.9);

		YPos += YL;
		Canvas.SetPos(4,YPos);
		Canvas.DrawText("ATTACK PENDING: "$bAttackPending, false, 0.9, 0.9);		
		
		YPos += YL;
		Canvas.SetPos(4,YPos);
		Canvas.DrawText("TARGET LOB SCORES:  BaseMin="$BestTargetMinScore);

		for( i = 0; i < TargetLobInfos.Length; ++i )
		{
			YPos += YL;
			Canvas.SetPos(4,YPos);
			Canvas.DrawText( TargetLobInfos[i].Target.Name$" : "$TargetLobInfos[i].Score );
		}
	}
}

//=========================================================
//	State WaitingForDestruction
//=========================================================
state WaitingForDestruction
{
	function bool CalculateLobVector( vector vDest, out vector LobVector, out float LobTime ) { return false; }
	function bool CalculateTarget( int idx ) { return false; }
	function float CalculateEffect( vector TargetLocation, float DamageRadius ) { return 0.0; }
	function ScoreTarget( int idx ) {}
	function RefreshTarget( gbxPawn rTarget, float TargetPriority ) {}
	function bool WantsToThrowGrenade( out int BestIndex ) { return false; }
	function bool CanThrowGrenade() { return false; }
	function bool GetAttackTargetIndex( out int BestIndex ) { return false; }
	function int GetBestTargetIndex( bool StrictRules ) { return -1; }
	function bool AttackTargetIndex( int i ) { return false; }
	function Think() {}
}

//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
	MinCalcInterval=2.0
	TimerInterval=5.0
	LobInfoExpire=120.0
	BaseMinScore=25.0
	LocRecalcDeltaSquared=16384.0 // 128 units
	CookTimeThresh=999.0 /// Disable cooking off for now.  It's there and it works, though!
	bUseLobVectorCache=true
	FacingCheckRotThresh=4000
	MaxTargetDeltaZ=1024.0
	CeilingAdjust=32.0
	GravityFactor=0.45
	LobBehindRange=368.0
	AfterThrowPauseTime=2.0
	bHidden=true
	NoShow=true
	bLogSelect=false;

	RemoteRole=ROLE_None
}
class LethalScarecrowVolume extends Volume;

var bool bDisabled;

event touch( Actor Other )
{
	local FiringControllerScarecrowLethal FC;

	if ( bDisabled || !Other.IsA( 'gbxPawn' ) )
		return;
	
	foreach DynamicActors( class'FiringControllerScarecrowLethal', FC )
	{
		log("NAJ**** touch FC=="$FC.Name$" ; other="$Other, 'naj' );
		FC.NotifyEnteredVolume( gbxPawn( Other ) );
	}
}

event untouch( Actor Other )
{
	local FiringControllerScarecrowLethal FC;

	if ( !Other.IsA( 'gbxPawn' ) )
		return;
	
	foreach DynamicActors( class'FiringControllerScarecrowLethal', FC )
	{
		log("NAJ**** untouch FC=="$FC.Name$" ; other="$Other, 'naj' );
		FC.NotifyExitedVolume( gbxPawn( Other ) );
	}
}

function Trigger( actor Other, Pawn EventInstigator )
{
	local FiringControllerScarecrowLethal FC;
	local gbxPawn gbxP;
	local array<FiringControllerScarecrowLethal> FCs;
	local int x;

	bDisabled = !bDisabled;

	foreach DynamicActors( class'FiringControllerScarecrowLethal', FC )
	{
		FCs.Length = FCs.Length + 1;
		FCs[ FCs.Length - 1 ] = FC;
	}

	if ( bDisabled )
	{		
		ForEach TouchingActors( class'gbxPawn', gbxP )
		{
			for( x = 0; x < FCs.Length; ++x )
			{
				FCs[ x ].NotifyExitedVolume( gbxP );
			}
		}		
	}
	else
	{
		ForEach TouchingActors( class'gbxPawn', gbxP )
		{
			for( x = 0; x < FCs.Length; ++x )
			{
				FCs[ x ].NotifyEnteredVolume( gbxP );
			}
		}
	}

	FCs.Remove( 0, FCs.Length );
}

defaultproperties
{
	bStatic=false
}class MG42Callback extends MountCallbackClass;



static function MountFinished( gbxPawn gbxP, bool bSuccess, EMountAction MountAction )
{
	if ( gbxP.Controller.IsA( 'MindMG42Gunner' ) )
	{
		MindMG42Gunner( gbxP.Controller ).MountOrDismountFinished( bSuccess, MountAction );
	}
}
//=============================================================================
// Main AI controller responsible for all infantry pawns in the game.
//
// Authors: Jeff Wofford, Neil Johnson, Jeff Broome, Patrick Deupree, Stephen Palmer,
// Gearbox Software.
//=============================================================================
class Mind extends gbxAIController
	native;


var WargamePawn WGPawn;
var name	PawnName;			// GBX:naj - I use this to keep track of the last pawn possessed by this mind for debug purposes.

var() float TimerInterval;
var		float StateStartTime;	// When did we enter the current state?
var()	float StateStickTime;	// How long should we stay in a state before allowing a shift to a new one? (Can be overridden)
var		float PostureStartTime;	// When did we begin the current posture?
var()	float PostureStickTime;	// How long should we stay in the current posture before allowing a shift to a new one?

// Assistants.
var class<FiringControllerInfantry> FiringControllerClass;
var FiringControllerInfantry FiringController;
var class<NavigationController> NavigationControllerClass;
var NavigationController NavigationController;
var MountController	MountController;
var GrenadeFiringController	GrenadeFiringController;	// Stored only temporarily while 'changing minds'.
var SalutationsController SalutationsController;

// Perception ////////////////////////////////////////////////////////

var float	NearbyBulletAnimDelay;	// How long do I have to wait to be allowed to play the nearby bullet animation?
var float	NextNearbyBulletAnimTime;
var float	SurpriseCosThetaMin,
			SurpriseCosThetaMax;	// The minimum and maximum dot-products used with view-cone surprise calculations.
var float	SurpriseCosThetaMin_Firing,
			SurpriseCosThetaMax_Firing;
var float	MinNoticeSneakerDist;	// Within this distance, it is impossible to not notice a surprise-attacker.
var float	MaxNoticeSneakerDist;	// Outside this distance, a surprise-attacker will not be noticed unless the victim is facing him or the surprise-attacker shoots at him.
var float	NoticeSneakerShrinkFactor;
var float	TargetForgetDist;		// Under certain conditions, forget about a target if he's traveled this far since last we saw him.
var float	SurpriseDecayTime;		// The time it takes the shock of being surprise-attacked to wear off.
var float	TargetForgetTimeMP_Long,
			TargetForgetTimeMP_Short;		// Two timer variables representing the time that it takes to for
var float	TargetForgetTimeSP;
var float	DistractionForgetfulnessMP;	// The amount per think-tick to subtract a target's LastContactTime if I'm distracted by other enemies.

const GRENADE_COWER_TIME = 3.0;

// Grenades
var (Perception) float		GrenadeTossBackMaxDist;	// Maximum distance from a landed grenade where we will try to return the grenade to sender
var (Perception) float		GrenadeFusePanicTime;	// Number of seconds remaining on the grenade's fuse where pawn's will take drastic evasive action
var (Perception) float		GrenadeReactionDelay;	// Number of seconds before pawn will react to a perceived grenade
var array<gbxExplosive>		PerceivedGrenades;		// Array of live grenades that I have noticed
var float					GrenadeCowerStopTime;	// Time to stop cowering.
var int						iReturnGrenadeIndex;	// Index of the grenade we are going to return
var float					GrenadeReactionStartTime; // Time when we went into FleeGrenade state
var int						iTNTindex;				//NAC:when TNT is planted, this is the index into the PerceivedGrenades Array

// Targetting ////////////////////////////////////////////////////////

var(MindTarget) float MaxTargetRange;						// TODO probably should come from weapon.
var(MindTarget) float TargetPriorityScalarDistance;
var(MindTarget) float TargetPriorityScalarReallyClose;
var(MindTarget) float TargetPriorityScalarAttackLevel;
var(MindTarget) float TargetPriorityScalarAlreadyTargetted;
var(MindTarget) float TargetPriorityScalarTargetExposureToMe;
var(MindTarget) float TargetPriorityScalarMyExposureToTarget;
var(MindTarget) float TargetPriorityScalarInAssignedUnit;
var(MindTarget) float TargetPriorityScalarHumanPlayer;
var(MindTarget) float TargetPriorityScalarTargetImpervious;
var(MindTarget) float TargetPriorityScalarSurprisedBy;

var(MindTarget)	float	StealNodePatience;
var				float	TimeLastNoHadVantage;
var				float	TimeLastBlockedByFriendly;
var				float	TimeLastShotAtAssignedUnit;

var				gbxPawn	BlockingFriendly;

// This struct is similar to a bool, but also tracks when the state of the bool has changed.
struct native export TargetInfo
{
	var gbxPawn		Target;
	var int			bIgnored;
	var float		TargetPriority;
	var float		ActualAttackLevel;		// How much is this target actually shooting at me?
	var float		DistractionLevel;		// How much is this target distracting me?
	var float		RelegationTime;
	var float		LastCSSTime;			// The last time this target was checked for CSS exposure.
	var float		LastEvaluationTime;		// The last time this target was evaluated at all.
	var float		LastContactTime;		// The last time I had contact with this target, either seeing it or being shot at by it.
	var float		LastSurprisedTime;		// The last time I was surprised by this target.

	var float		TargetDistance;
	var float		TargetExposureToMe;
	var float		MyExposureToTarget;
	var float		TargetOutOfViewRating;

	var float		TargetPriorityDistance;
	var float		TargetPriorityReallyClose;
	var float		TargetPriorityAttackLevel;
	var float		TargetPriorityInAssignedUnit;
	var float		TargetPriorityAlreadyTargetted;
	var float		TargetPriorityHumanPlayer;
	var float		TargetPriorityTargetExposureToMe;
	var float		TargetPriorityMyExposureToTarget;
	var float		TargetPriorityTargetImpervious;
	var float		TargetPrioritySurprisedBy;
	var float		TargetTotalWeight;	
	var Vector		LastKnownLocation;
	var ActorLite	RelegatedNavPoint;
};

var array<TargetInfo> TargetQueue;
var Flag		TargetSuppressed;
var Flag		SpokeAboutSuppression;
var Flag		VantageLost;
var Flag		FriendlyDead;
var Flag		MultipleFriendliesDead;
var Flag		BeingBlockedByPlayer;
var Flag		IveBeenFlanked;
var Flag		MeleeAttemptFailed;
var Flag		StoppedAndIdle;
var Flag		PlayerIsTalkingToMe;
var Flag		NotifyTargetFailureCalled;
var Flag		TargetOrderRulesInEffect;
var Flag		HasExtendedDeadlockProtection;
var Flag		PawnShoutedCoveringFire;
var Flag		PawnShoutedCantHitTarget;
var Unit		LastEnemyUnit;
var Unit		LastAssignedTargetUnit;
var int			ndxEnemyInQueue;		// The index of Enemy in TargetQueue, as of the last PrioritizeTargets call.
var float		LastTimeNearbyTrace;
var int			NumTracesPerSpeech;
var float		TimeBetweenSpeeches;

var float TargetOrderRulesDuration;
var float TimeLastTargetSort;
var float MaxSecondsPerNTF;
var(MindTarget) float ForceTargetSortInterval;

var(MindTarget) float TargetEvaluationIntervalFar;
var(MindTarget) float TargetCSSIntervalMedium;
var(MindTarget) float TargetRangeMedium;
var(MindTarget) float TargetRangeFar;

var ECoverType DesiredCoverType;

var float RelegationDuration;

var float AttackLevelDecay;
var float DistractionLevelDecay;

var Pawn MyKiller;	// keep track of who killed me so it can be reported in PerceptionPawnDied message.

// Threat ////////////////////////////////////////////////////////////

var array< TargetInfo > WorstThreats;
var array< Vector > ThreatLocations;
const MAX_WORST_THREATS = 3;

// Maneuver ///////////////////////////////////////////////////////////

var(MindManeuver) float  DestinationRadius;				// How far from the desired destination is "close enough"?

var float			fApproachingTime;

// Facing //////////////////////////////////////////////////////////////////////

var(MindFacing) EFacingPolicy	FacingPolicy;
var(MindFacing) Vector			FacingVector;
var(MindFacing) Actor			FacingActor;
var				Vector			BaseAlertDirection;
var				float			NextShiftFacingTime;

// Combat Radii ////////////////////////////////////////////////////
var float CombatRadius_Melee;
var float CombatRadius_NoGrenades;
var float CombatRadius_Deadlock;
var float CombatRadius_Grenade;
var float CombatRadius_NoOpBurst;
var float CombatRadius_NoWarningShots;
var float CombatRadius_MaxMeleePursuit;
var float CombatRadius_AlwaysMiss;
var float CombatRadius_NoFFC;
var float CombatRadius_CommentaryEnemies;
var float CombatRadius_CommentaryPlayer;
var float CombatRadius_NoRelegation;
var float CombatRadius_NoTurretUsage;

var Name		PendingState;
var Name		PendingGestureAnim;
var ActorLite	PendingDestination;

// Cover and Vantage ///////////////////////////////////////////////
var PathExclusionTracker ExclusionTracker;
var float	LastSwitchedCoverTime;
var Range	ForceSwitchCoverInterval_Low;
var Range	ForceSwitchCoverInterval_High;
var float	LastLookedForCoverTime;
var float	ForceLookForCover;
var float	NoVantageDueToFriendlyCosTheta;
var float	FlankAlarmDuration;

// Static Targets ///////////////////////////////////////////////
enum ETargetModes
{
	TargetMode_Normal,
	TargetMode_SingleTarget,
	TargetMode_Sweep
};

var float			m_flLastTargetTime;
var float			m_flTotalTargetTime;
var Actor			m_aTarget1;
var Actor			m_aTarget2;
var gbxPawn			m_aTargetPawn;
var ETargetModes	m_nTargetMode;

var Rotator RotationRateInCombat;
var Rotator RotationRateRelaxed;

const TARGET_UNITS_PER_SEC = 300.0f;

var int				m_nTargetDir;

enum ENodeSearch
{
	NodeSearch_None,
	NodeSearch_Elsewhere,
	NodeSearch_ElsewhereNew,
	NodeSearch_Anywhere,
	NodeSearch_AnywhereHasCover,
	NodeSearch_AnywhereForgetCover,
	NodeSearch_Approaching,
	NodeSearch_BetterCover,
	NodeSearch_BetterVantageWithCover,
};

struct native SLastNodeSearch
{
	var ENodeSearch SearchType;
	var EMoveReason MoveReason;
	var bool bMustLeaveCover;
	var bool bMustHaveVantage;
	var Actor Other;
	var Vector MovementDirection;
};
var SLastNodeSearch LastNodeSearch;

// NavigationPoint/CoverPoint/VantagePoint selection scoring tuneables...
var(MindNavScoring) float ScoringNavPointFORMCDistance;  // clamped maximum distance between navpoint and formation center
var(MindNavScoring) float ScoringNavPointFORMCDistanceScale;  // scale factor to divide navpoint-FORMC distance by
var(MindNavScoring) float ScoringCoverPawnDistance;  // clamped maximum distance between cover point and pawn's current location
var(MindNavScoring) float ScoringCoverPawnDistanceScale;  // scale factor to divide cover-pawn distance by
var(MindNavScoring) float ScoringCoverAdjacentDirection;  // amount to add to total score if cover point provides cover in a sector next to the threat direction sector
var(MindNavScoring) float ScoringCornerCoverHasVantage;  // amount to add to total score if the cover point is a corner point that has vantage
var(MindNavScoring) float ScoringHasVantage;	// amount to add to total score if the cover point has vantage

// AI soldiers want to keep the same relative locations when a formation moves (relative to the center of the formation).  We keep track
// of where the "ideal" location would be based on where the soldier was before the move order was given (relative to the formation center)
// and taking into account if the unit formation has rotated based on the "facing direction" of the unit at the new formation center...
var(MindNavScoring) float ScoringCoverNearFormationIdealDistance;  // clamped maximum distance between cover point and ideal formation location
var(MindNavScoring) float ScoringCoverNearFormationIdealDistanceScale;  // scale factor to divide cover-ideal distance by
var(MindNavScoring) float FearCostScale;  // scale factor to multiply NavigationPoint.FearCost by

// DEBUGGING ////////////////////////////////////////////////////////////

var Name PawnToWatch;
var String MyLogSelectName;

var transient AIDebugTracker	AITracker;

//////////////////////////////// Packed bools
var bool	bPreparingFire;
var bool	bBestTargetRelegated;
var bool	bFleeGrenades;				// Toggle fleeing grenades at all
var bool	bGrenadePanic;				// I'm in panic mode.
var bool	bFleeingGrenade;			// Used to know if we're already navigating toward a safe spot
var bool	bReturningGrenade;			// Used to know if we are currently returning grenade to sender
var bool	bDontInterruptMe;			// I'm in the middle of something important, so don't change states!
var bool	bEnemiesTooCloseForFFC;
var bool	bTargetQueueNeedsSort;
var bool	bMatchAttackLevels;
var bool	bRetainSubcontrollers;
var bool	bShouldAssault;
var bool	bLastCoverCheckFailed;
var bool	bDontLetMindTick;
var bool	bShiftFacingLeft;
var bool	bAtLeastOnePerfectCover;	// Used in FindBestDestination().
var bool	bAtLeastOnePartialCover;	// Used in FindBestDestination().
var bool	bAtLeastOneFurtherAway;		// Used in FindBestDestination().
var bool	bAntsyGermans;
var bool	bCanReportSuppressionStatus;
var bool	bUseScriptedTargets;
var bool	m_fTargetVisible;
var bool	m_fDisableAI;
var bool	m_fChangeTarget;
var bool	bLogSelect;
var bool	bUseAIDebugging;
var bool	bPendingFormationChange;
var config	bool NoShow;
//////////////////////////////// end Packed bools

/////////////////////////////////////////////////////////////////////////
// Basic Functions
/////////////////////////////////////////////////////////////////////////

native function InitializeAIDebugTracker();
native function FindBestDestination( out ActorLite CoverPoint, bool bIgnoreCover, bool bMustHaveVantage, bool bIveBeenFlanked, Array<vector> Threats, bool bEvalAssignedTargetUnit, Pawn Enemy, bool bUseFormationCache, vector SearchCenter, float SearchRadius, Array<ActorLite> ExcludeNavPoints, out byte bHasPerfectCover, out byte bHasPartialCover, optional out Vector DummyThreatLocation );
native function PrioritizeTargets();
native function int FindTargetInQueue( Pawn potentialTarget );
native function bool CoverNoLongerValid();
native function SetContactedTarget( int ndx );
native function bool CanSeeOrSuppress( Pawn Other, out Vector SeeLocation, out int bIsHeadShot, out Vector SuppressLocation, out Vector FailLoc, optional int Posture );
native function bool CanSeeOrSuppressFromPoint( Pawn Other, Vector FromLocation, out Vector SeeLocation, out int bIsHeadShot, out Vector SuppressLocation, out Vector FailLoc, optional int Posture );
native function ActorLite FindFarthestDestinationFromVector( vector loc, float radius, optional bool bRequireLOS, optional float cosFrustumCull );
native function BuildGrenadeExcludeList(array<ActorLite> ExcludeList, vector GrenadeLocation, float DamageRadius);
native function UpdateFatigue(Float DeltaTime);
native function InitTargetInfo( out TargetInfo targetInfo );

function PostBeginPlay()
{
	Super.PostBeginPlay();

	InitializeAIDebugTracker();
}

//---------------------------------------------------------
//	LogSelective
//---------------------------------------------------------
// Selective logging function.  Use this in place of Log() wherever possible.
// Using the "logselect" console command at runtime causes only those log messages
// that pertain to an individual pawn to be printed out.
//
function LogSelective( String msg )
{
	if ( bLogSelect )
	{ 
		if ( PawnToWatch == '' || PawnToWatch == Pawn.Name )
		{
			log( MyLogSelectName$": NAJ**** "$WGPawn.Name$" ["$GetStateName()$"]: "$msg, 'naj');
		}
		else if ( PawnToWatch == 'InfantryUSA' && Pawn.IsA( 'InfantryUSA' ) )
		{
			log( MyLogSelectName$": NAJ**** "$WGPawn.Name$" ["$GetStateName()$"]: "$msg, 'naj' );
		}
		else if ( PawnToWatch == 'InfantryGermany' && Pawn.IsA( 'InfantryGermany' ) )
		{
			log( MyLogSelectName$": NAJ**** "$WGPawn.Name$" ["$GetStateName()$"]: "$msg, 'naj' );
		}
	}
}

//---------------------------------------------------------
//	SetPawnToWatch
//---------------------------------------------------------
function SetPawnToWatch( Name APawnToWatch )
{
	if ( APawnToWatch != '' )
	{
		bLogSelect = true;
		Default.bLogSelect = true;
		PawnToWatch = APawnToWatch;
		Default.PawnToWatch = APawnToWatch;
	}
	else
	{
		bLogSelect = false;
		Default.bLogSelect = false;
	}

	FiringController.SetPawnToWatch( APawnToWatch );		
}

//---------------------------------------------------------
//	PrePossessTransfer
//---------------------------------------------------------
function PrePossessTransfer( Mind OldMind, MountController NewMC, FiringControllerInfantry NewFC, GrenadeFiringController NewGFC, NavigationController NewNC, AIDebugTracker NewAITracker, PathExclusionTracker NewExclusionTracker )
{
	local int i;

	MountController = NewMC;
	MountController.ResetController();

	FiringController = NewFC;
	GrenadeFiringController = NewGFC;
	NavigationController = NewNC;

	if ( NewAITracker != None )
	{
		AITracker = NewAITracker;
		AITracker.SetMind( self );  // this also calls InitializeTracker()
	}

	ExclusionTracker = NewExclusionTracker;
	ExclusionTracker.ClearList();

	///////////////////////////	
	// Copy this Mind's TargetQueue into the new Mind.
	TargetQueue.Length = OldMind.TargetQueue.Length;

	for( i=0; i < OldMind.TargetQueue.Length; ++i )
	{
		TargetQueue[i] = OldMind.TargetQueue[i];
	}

	Enemy = OldMind.Enemy;
	ndxEnemyInQueue = OldMind.ndxEnemyInQueue;
	FiringController.SetTarget( OldMind.Enemy );

	bUseAIDebugging = OldMind.bUseAIDebugging;
	///////////////////////////
}

//---------------------------------------------------------
//	Possess
//---------------------------------------------------------
function Possess(Pawn aPawn)
{
	Super.Possess(aPawn);

	Pawn.bNoTurnBody = false;

	Pawn.SetMovementPhysics();
	if (Pawn.Physics != PHYS_Walking)
		Pawn.SetPhysics(PHYS_Falling);

	ClientSwitchToBestWeapon();

	PawnName = aPawn.Name;
	WGPawn = WargamePawn( aPawn );

	if ( bUseAIDebugging && AITracker == None )
	{
		AITracker = new( None ) class'AIDebugTracker';		
	}		
	if ( MountController == None )
	{
		MountController = Spawn( class'MountController' );		
	}
	if ( NavigationController == None )
	{
		NavigationController = Spawn( NavigationControllerClass );		
	}
	if ( FiringController == None )
	{
		FiringController = Spawn( FiringControllerClass );		
	}
	if ( ExclusionTracker == None )
	{
		ExclusionTracker = Spawn( class'PathExclusionTracker' );
	}
	if ( SalutationsController == None && Level.NetMode == NM_Standalone && WGPawn.IsA( 'InfantryUSA' ) )
	{
		SalutationsController = Spawn( class'SalutationsController' );
		SalutationsController.Initialize( Self, WGPawn );
	}

	if ( GrenadeFiringController != None )
	{
		FiringController.SetGrenadeFiringController( GrenadeFiringController );
		GrenadeFiringController = None;	// Don't need it around anymore.
	}

	NavigationController.SetMind(Self);
	NavigationController.SetMountController( MountController );		
	MountController.SetNavigationController( NavigationController );
	FiringController.SetMind( Self );
	FiringController.SetNavController( NavigationController );
	FiringController.SetMountController( MountController );		
	FiringController.Initialize();

	AITracker.SetMind( Self );
	MountController.Possess(WGPawn);
	NavigationController.Possess(WGPawn);
	FiringController.Possess(aPawn);

	// Lock position to the pawn's position
	SetLocation( aPawn.Location );
	SetBase( aPawn );

	fApproachingTime = 0.0;

	TransitionToCombatReady();
}

//---------------------------------------------------------
//	UnPossess
//---------------------------------------------------------
function UnPossess()
{
	// if ( !bRetainSubcontrollers )  ???
	if ( FiringController != None )
	{
		FiringController.PrepareForDestroy();		
	}
	if ( NavigationController != None )
	{
		NavigationController.PrepareForDestroy();
	}

	Super.UnPossess();
}

//---------------------------------------------------------
//	StartJob
//---------------------------------------------------------
function StartJob( optional EJobType NewJob )
{
	// Override this in Mind subclasses.
	WGPawn.Job = NewJob;
	WGPawn.PlayWaiting();
}

//---------------------------------------------------------
//	NotifyFormationCenterChange
//---------------------------------------------------------
function NotifyFormationCenterChange()
{
	LogSelective( "NotifyFormationCenterChange GLOBAL. Queueing up the request for later." );
	bPendingFormationChange = true;
}

//---------------------------------------------------------
//	PrepareForFormationCenterChange
//---------------------------------------------------------
// Called for all FORMC changes.
function PrepareForFormationCenterChange()
{
	// Any time a new move order is given, clear the list of excluded nodes.
	ExclusionTracker.ClearList();

	LastAssignedTargetUnit = None;
	SetFlagValue( TargetOrderRulesInEffect, false );
}

//---------------------------------------------------------
//	RespondToPlayerUse
//---------------------------------------------------------
function RespondToPlayerUse() 
{
	if ( SalutationsController != None )
		SalutationsController.RespondToPlayerUse();
}

//---------------------------------------------------------
//	SetPlayerAddressingMe
//---------------------------------------------------------
function SetPlayerAddressingMe( bool bAddressing )
{
	if ( !bAddressing )
		return;

	SetFlagValue( PlayerIsTalkingToMe, bAddressing );
	WGPawn.LookAtPlayerOverShoulder( bAddressing );
	
	if ( IsTrue( PlayerIsTalkingToMe ) && IsTrue( StoppedAndIdle ) )
	{
		GotoState( 'RelaxedTalkingToPlayer' );
	}
}

//---------------------------------------------------------
//	IsNavigating
//---------------------------------------------------------
function bool IsNavigating()
{
	if ( NavigationController == None )
		return false;
	else
		return NavigationController.bIsNavigating;
}

//---------------------------------------------------------
//	ClaimNavPoint
//---------------------------------------------------------
function bool ClaimNavPoint( ActorLite NavPoint )
{
	local ActorLite LastNavPoint;

	LastNavPoint = WGPawn.MyClaimedNavPoint;

	if ( WGPawn.ClaimNavPoint( NavPoint ) )
	{
		TimeLastNoHadVantage = 0.0;
		TimeLastBlockedByFriendly = 0.0;
		BlockingFriendly = None;

		if ( bUseAIDebugging && AITracker != None )
		{
			AITracker.AddCoverPathNode( NavPoint );
			AITracker.SetMoveSuccess( true );
		}

		if ( LastNavPoint != WGPawn.MyClaimedNavPoint )
			ClearRelegations();

		return true;
	}
	else
		return false;
}


//---------------------------------------------------------
//	DisplayDebug
//---------------------------------------------------------
simulated function DisplayDebug(Canvas Canvas, out float YL, out float YPos)
{
	local int i;

	Canvas.DrawColor.R = 255;
	Canvas.DrawColor.B = 0;
	Canvas.DrawColor.G = 0;
	//Super.DisplayDebug(Canvas,YL, YPos);

	Canvas.DrawText("MIND: "$Self.name$"  PAWN: "$WGPawn.Name, false);
	YPos += YL;
	Canvas.SetPos(4,YPos);

	Canvas.DrawColor.R = 255;
	Canvas.DrawColor.B = 255;
	Canvas.DrawColor.G = 255;
	Canvas.DrawText("STATE: "$GetStateName(), false, 0.9, 0.9);
	YPos += YL;
	Canvas.SetPos(4,YPos);
	

	//if ( !NoShow )
	//{
		Canvas.DrawColor.R = 255;
		Canvas.DrawColor.B = 0;
		Canvas.DrawColor.G = 0;
	
		Canvas.DrawText("     Unit: " $ WGPawn.MyUnit $ " Unit.Tag: " $ WGPawn.MyUnit.Tag, false, 0.9, 0.9);
		YPos += YL;
		Canvas.SetPos(4,YPos);

		for( i = 0; i < WorstThreats.Length; ++i )
		{
			Canvas.DrawText("     WorstThreat[" $ i $ "]: " $ WorstThreats[ i ].Target, false, 0.9, 0.9 );
			YPos += YL;
			Canvas.SetPos(4,YPos);
		}

		Canvas.DrawText("     ---- TargetQueue ----", false, 0.9, 0.9);
		YPos += YL;
		Canvas.SetPos(4,YPos);
		Canvas.DrawText("     Best Target Relegated: "$bBestTargetRelegated, false, 0.9, 0.9);
		YPos += YL;
		Canvas.SetPos(4,YPos);

		for( i = 0; i < TargetQueue.Length; ++i )
		{
			Canvas.DrawText("          Target: " $ TargetQueue[ i ].Target
				$ "    Priority: " $ TargetQueue[ i ].TargetPriority
				//$ "    DistP: " $ TargetQueue[ i ].TargetPriorityDistance
				//$ "    AttackLvl: " $ TargetQueue[ i ].ActualAttackLevel
				//$ " DistrctLvl: " $ TargetQueue[ i ].DistractionLevel
				//$ " ExposureToMe: " $ TargetQueue[ i ].TargetExposureToMe
				//$ " MyExposure: " $ TargetQueue[ i ].MyExposureToTarget
				$ " LstContact: "$TargetQueue[ i ].LastContactTime
				//$ " OutOfView: "$TargetQueue[ i ].TargetOutOfViewRating
				//$ " Surp: "$TargetQueue[ i ].TargetPrioritySurprisedBy
				//$ " Ignore: "$TargetQueue[ i ].bIgnored
				//$ " Releg: "$( Level.TimeSeconds < TargetQueue[ i ].RelegationTime )
				, false, 0.9, 0.9);
			YPos += YL;
			Canvas.SetPos(4,YPos);
		}

		Canvas.DrawText("     ---------------------", false, 0.9, 0.9);
		YPos += YL;
		Canvas.SetPos(4,YPos);
//	}

	if ( MountController != None )
		MountController.DisplayDebug( Canvas, YL, YPos );
	if ( FiringController != None )
		FiringController.DisplayDebug( Canvas, YL, YPos );
	if ( NavigationController != None )
		NavigationController.DisplayDebug( Canvas, YL, YPos );
}

//---------------------------------------------------------
//	DisplayDebugSpecial
//---------------------------------------------------------
simulated function DisplayDebugSpecial( HUD H )
{
	
	local int i;
	local vector LobNormal, vDest;

	//if( WGPawn.MyClaimedNavPoint != None )
	//{
	//	if (WGPawn.MyClaimedNavPoint.bIsNavigationPoint)
	//		H.Draw3DLine( Pawn.Location, NavigationPoint(WGPawn.MyClaimedNavPoint).Location, class'Canvas'.Static.MakeColor(64,64,0));
	//	else if (WGPawn.MyClaimedNavPoint.bIsNavigationPointLite)
	//		H.Draw3DLine( Pawn.Location, NavigationPointLite(WGPawn.MyClaimedNavPoint).Location, class'Canvas'.Static.MakeColor(64,64,0));
	//}

	for( i = 0; i < FiringController.GrenadeFireCtrl.TargetLobInfos.Length; ++i )
	{
		if (FiringController.GrenadeFireCtrl.TargetLobInfos[i].LobVector != vect(0,0,0))
		{
			LobNormal = Normal(FiringController.GrenadeFireCtrl.TargetLobInfos[ i ].LobVector);
			vDest = (WGPawn.Location + WGPawn.EyeHeight* vect(0,0,1));// * LobNormal;
			H.Draw3DLine( vDest, vDest+(LobNormal * 250), class'Canvas'.Static.MakeColor(0, 255, i * 32 ));
		}
	}

}

//---------------------------------------------------------
//	DontInterruptMe
//---------------------------------------------------------
event DontInterruptMe()
{
	bDontInterruptMe = true;
}

//---------------------------------------------------------
//	OKToInterruptMe
//---------------------------------------------------------
event OKToInterruptMe()
{
	local Name StateToGoto;

	bDontInterruptMe = false;

	if ( PendingState != '' )
	{				
		if ( GetStateName() != PendingState ) 
		{						
			StateToGoto = PendingState;			
		}
		else
		{
			LogSelective( "OKToInterruptMe(): Already in state "$PendingState );
		}

		PendingState = '';

		if ( StateToGoto != '' )
		{
			LogSelective( "OKToInterruptMe(): Going to "$StateToGoto );
			GotoState( StateToGoto );
			return;		// Warning: Don't put any code after GotoState().
		}
	}
}

//---------------------------------------------------------
//	IsUnitLeader
//---------------------------------------------------------
function bool IsUnitLeader()
{
	return WGPawn.MyUnit != None && WGPawn.MyUnit.Leader == WGPawn;
}

//---------------------------------------------------------
//	SetEnemy
//---------------------------------------------------------
function bool SetEnemy( Pawn newEnemy )
{
	//Log( " Mind::SetEnemy() newEnemy="$newEnemy, 'MP' );
	
	if ( WGPawn == None )
		return false;

	// Sanity check: Check that the 'enemy' is not actually on your own team!
	if ( newEnemy != None && WGPawn.PawnTeam == newEnemy.PawnTeam )
	{
		//log( "Mind::SetEnemy() Pawn "$WGPawn$" cannot set teammate "$newEnemy$" as his enemy!", 'MP' );
		return false;
	}

	// Last check: If the "notarget" console command has been entered, don't set human players as enemies.
	if ( newEnemy != None && newEnemy.IsHumanControlled() )
	{
		if ( gbxPlayerController( newEnemy.Controller ).bNeverEnemy )
			return false;
	}

	// If the battle is just starting, set the pawn to fully fatigued.
	if ( Enemy == None && newEnemy != None )
	{
		LogSelective( "Setting enemy "$newEnemy$" for the first time, jogging fatigue." );
		JogFatigue( WGPawn.FatigueJog_Rotation );
	}	

	if( newEnemy != Enemy )
	{
		Enemy = newEnemy;

		FiringController.SetTarget( newEnemy );

		// Reset the flag that we use for tracking the suppression status of our enemy.
		if ( Enemy == None )
		{
			LastEnemyUnit = None;
			SetInitialFlagValue( TargetSuppressed, false );
		}
		else if ( gbxPawn(newEnemy).MyUnit != None && gbxPawn(newEnemy).MyUnit != LastEnemyUnit )
		{
			LastEnemyUnit = gbxPawn(newEnemy).MyUnit;

			if (  gbxPawn(newEnemy).MyUnit.MyUnitController != None )
				SetInitialFlagValue( TargetSuppressed, (gbxPawn(newEnemy).MyUnit.MyUnitController.GetSuppressionLevel() == SL_SUPPRESSED ) );
			else
				SetInitialFlagValue( TargetSuppressed, false );
		}

		// GBX:PAD: Make sure to update the ground speed if these guys change their enemy.  If they have an enemy, we
		// don't want them to limp, but if they don't, they should go back to limping.
		WGPawn.UpdateGroundSpeed();

		if ( bUseAIDebugging && AITracker != None )
		{
			AITracker.AnalyzeEnemies();
		}
		return true;
	}

	if ( bUseAIDebugging && AITracker != None )
	{
		AITracker.AnalyzeEnemies();
	}
	return false;
}

//---------------------------------------------------------
//	ChangeMind
//---------------------------------------------------------
function gbxAIController ChangeMind( optional class<gbxAIController> NewMindClass ) 
{
	local Mind NewMind;
	local WargamePawn Temp;

	Self.Disable( 'Tick' );
	Self.Disable( 'Timer' );

	NavigationController.StopManeuvering();

	if ( NewMindClass == None )
		NewMindClass = class'Mind';
	
	WGPawn.bNoTurnBody = false;

	NewMind = Mind( Spawn( NewMindClass, Self.Owner ) );
	
	Self.bRetainSubcontrollers = true;

	// Always be in the "sighted" pose when changing from one Mind to another (unlike when changing from a ScriptedController to a Mind).
	WGPawn.SetWeaponAimedState( WAS_Sighted );

	// Transfer over all subcontrollers except the FiringController.
	NewMind.PrePossessTransfer( Self, MountController, None, FiringController.GetGrenadeFC(), NavigationController, AITracker, ExclusionTracker );	
	NewMind.Possess( WGPawn );
	
	// Destroy the FiringController.
	FiringController.Destroy();
	FiringController = None;

	if ( SalutationsController != None )
	{
		SalutationsController.Destroy();
		SalutationsController = None;
	}

	PostMindChangeTasks( NewMind );
	
	Temp = WGPawn;
	Self.Pawn = None;
	Self.WGPawn = None;
	
	Self.Destroy();

	NewMind.Timer();
	return NewMind;
}

// Extended by subclasses.
function PostMindChangeTasks( Mind NewMind ) 
{
}

//---------------------------------------------------------
//	SetDesiredDestination
//---------------------------------------------------------
function SetDesiredDestination( ActorLite CoverPoint, optional bool bMustLeaveCover )
{	
	LogSelective( "SetDesiredDestination() [global]: CoverPoint="$CoverPoint );
	if ( CoverPoint != None )
	{
		ClaimNavPoint( CoverPoint );  // claim the destination point
		LogSelective( "SetDesiredDestination(): Maneuvering to actor "$CoverPoint$" without cover, claimednavpoint="$WGPawn.MyClaimedNavPoint );
		NavigationController.ManeuverToActor( CoverPoint, true );
	}
}

//---------------------------------------------------------
//	NavigationPointStolen
//---------------------------------------------------------
event NavigationPointStolen(ActorLite NavPoint)
{
	LogSelective( "ERROR: NavigationPointStolen() [global]." );	
	
	if ( NavPoint != None )
	{
		if ( bUseAIDebugging && AITracker != None )
		{
			AITracker.StartNewMove();
			AITracker.AddMoveReason( ReasonMove_CoverPointStolen );
			LastNodeSearch.MoveReason = ReasonMove_CoverPointStolen;
		}
		DecideDestAnywhere();
	}
}

//---------------------------------------------------------
//	RequestPlayGesture
//---------------------------------------------------------
// Make sure to override this in states where animation synch is important (i.e. FiringFromCover).
function bool RequestPlayGesture( Name GestureAnimName, bool bNoInterrupt )
{
	if ( GestureAnimName != '' )
		return WGPawn.PlayGestureAnim( GestureAnimName, bNoInterrupt );
}

//---------------------------------------------------------
//	DecideDestCore
//---------------------------------------------------------
function bool DecideDestCore( bool bRequireVantage, ActorLite NavPoint, Vector DummyThreatLoc, optional bool bMustLeaveCover )
{
	LogSelective( "DecideDestCore(): CoverPoint="$NavPoint$" ; DummyThreatLoc="$DummyThreatLoc );

	if ( bUseAIDebugging && AITracker != None )
	{
		if ( bRequireVantage )
		{
			AITracker.AddMoveReason( ReasonMove_DesireVantage );
			LastNodeSearch.MoveReason = ReasonMove_DesireVantage;
		}

		if ( IsTrue( IveBeenFlanked ) )
		{
			AITracker.AddMoveReason( ReasonMove_Flanked );
			LastNodeSearch.MoveReason = ReasonMove_Flanked;
		}
	}	
	
	if ( NavPoint == None )
	{
		LogSelective( "DecideDestCore(): No nav point found.  Failure." );
		if ( bUseAIDebugging && AITracker != None )
		{
			AITracker.SetMoveSuccess( false );
		}			
		return false;
	}
		
	LogSelective( "DecideDestCore(): Claiming Nav point "$NavPoint.Name );
	SetDesiredDestination( NavPoint, bMustLeaveCover );
	return true;		
}

//---------------------------------------------------------
//	DecideDestElsewhereNew
//---------------------------------------------------------
function bool DecideDestElsewhereNew( bool bMustHaveVantage, optional bool bIsRepeat )
{
	local ActorLite NavPoint;
	local array<ActorLite> ExclusionList;
	local Vector DummyThreatLoc;
	local byte bPerfectCover, bPartialCover;

	LogSelective( "DecideDestElsewhereNew()." );

	if ( !bIsRepeat )
	{
		ExclusionTracker.AddToList( WGPawn.MyClaimedNavPoint );
	}
	ExclusionTracker.GetList( ExclusionList );
	FindBestDestination( NavPoint, false, bMustHaveVantage, IsTrue( IveBeenFlanked ), ThreatLocations, false, Enemy, true, vect(0,0,0), 0.0, ExclusionList, bPerfectCover, bPartialCover, DummyThreatLoc );

	LastNodeSearch.SearchType = NodeSearch_ElsewhereNew;
	LastNodeSearch.bMustLeaveCover = false;
	LastNodeSearch.bMustHaveVantage = bMustHaveVantage;
	LastNodeSearch.Other = None;

	return DecideDestCore( bMustHaveVantage, NavPoint, DummyThreatLoc );
}

//---------------------------------------------------------
//	DecideDestElsewhere
//---------------------------------------------------------
function bool DecideDestElsewhere( optional bool bIsRepeat )
{
	local ActorLite NavPoint;
	local array<ActorLite> ExclusionList;
	local Vector DummyThreatLoc;
	local byte bPerfectCover, bPartialCover;

	LogSelective( "DecideDestElsewhere()." );	
	
	ExclusionTracker.ClearList();
	
	if ( !bIsRepeat )
	{
		ExclusionTracker.AddToList( WGPawn.MyClaimedNavPoint );
	}
	ExclusionTracker.GetList( ExclusionList );
	FindBestDestination( NavPoint, false, false, IsTrue( IveBeenFlanked ), ThreatLocations, false, Enemy, true, vect(0,0,0), 0.0, ExclusionList, bPerfectCover, bPartialCover, DummyThreatLoc );

	LastNodeSearch.SearchType = NodeSearch_Elsewhere;
	LastNodeSearch.bMustLeaveCover = false;
	LastNodeSearch.Other = None;

	return DecideDestCore( false, NavPoint, DummyThreatLoc );
}

//---------------------------------------------------------
//	DecideDestAnywhere
//---------------------------------------------------------
function bool DecideDestAnywhere( optional bool bMustLeaveCover )
{
	local ActorLite NavPoint;
	local array<ActorLite> ExclusionList;
	local Vector DummyThreatLoc;
	local byte bPerfectCover, bPartialCover;

	LogSelective( "DecideDestAnywhere()." );	
	
	ExclusionTracker.ClearList();
	ExclusionTracker.GetList( ExclusionList );
	FindBestDestination( NavPoint, false, false, IsTrue( IveBeenFlanked ), ThreatLocations, false, Enemy, true, vect(0,0,0), 0.0, ExclusionList, bPerfectCover, bPartialCover, DummyThreatLoc );

	// This function is called for OrderMoves, so returning empty-handed is not an option.
	// If the search failed, do it again with a radius check instead of using the formation cache.
	if ( NavPoint == None && WGPawn.MyUnit != None && WGPawn.MyUnit.FormationCenter != None )
	{
		LogSelective( "DecideDestAnywhere(): WARNING!! Node search failed using formation cache, so doing radius-based search!" );
		FindBestDestination( NavPoint, false, false, IsTrue( IveBeenFlanked ), ThreatLocations, false, Enemy, false, GetLocation( WGPawn.MyUnit.FormationCenter ), 1500.0f, ExclusionList, bPerfectCover, bPartialCover, DummyThreatLoc );
	}

	LastNodeSearch.SearchType = NodeSearch_Anywhere;
	LastNodeSearch.bMustLeaveCover = bMustLeaveCover;
	LastNodeSearch.Other = None;

	return DecideDestCore( false, NavPoint, DummyThreatLoc, bMustLeaveCover );
}

//---------------------------------------------------------
//	DecideDestAnywhereHasPerfectCover
//---------------------------------------------------------
function bool DecideDestAnywhereHasPerfectCover()
{
	local ActorLite NavPoint;
	local array<ActorLite> ExclusionList;
	local Vector DummyThreatLoc;
	local byte bPerfectCover, bPartialCover;

	LogSelective( "DecideDestAnywhereHasPerfectCover()." );	
	
	ExclusionTracker.ClearList();
	ExclusionTracker.GetList( ExclusionList );
	FindBestDestination( NavPoint, false, false, IsTrue( IveBeenFlanked ), ThreatLocations, false, Enemy, true, vect(0,0,0), 0.0, ExclusionList, bPerfectCover, bPartialCover, DummyThreatLoc );

	// TBD: Decide whether to accept this node based on its cover potential.	
	if ( bPerfectCover != 1 )
	{
		LogSelective( "DecideDestAnywhereHasPerfectCover: NavPoint "$NavPoint$" does not provide perfect cover.  Doing nothing." );
		if ( bUseAIDebugging && AITracker != None )
		{
			AITracker.AddMoveReason( ReasonMove_InsufficientCover );
			AITracker.SetMoveSuccess( false );
		}
		return false;
	}
	
	LastNodeSearch.SearchType = NodeSearch_AnywhereHasCover;
	LastNodeSearch.Other = None;

	return DecideDestCore( false, NavPoint, DummyThreatLoc );
}

//---------------------------------------------------------
//	DecideDestAnywhereForgetCover
//---------------------------------------------------------
function bool DecideDestAnywhereForgetCover( optional bool bMustHaveVantage )
{
	local ActorLite NavPoint;
	local array<ActorLite> ExclusionList;
	local Vector DummyThreatLoc;
	local byte bPerfectCover, bPartialCover;

	LogSelective( "DecideDestAnywhereForgetCover()." );

	ExclusionTracker.ClearList();
	ExclusionTracker.GetList( ExclusionList );
	
	FindBestDestination( NavPoint, true, false, false, ThreatLocations, false, Enemy, true, vect(0,0,0), 0.0, ExclusionList, bPerfectCover, bPartialCover, DummyThreatLoc );

	// It's REALLY important that this function not return empty-handed; if FBD() failed, try it again without using the node cache.
	if ( NavPoint == None && WGPawn.MyUnit.FormationCenter != None )
		FindBestDestination( NavPoint, true, bMustHaveVantage, false, ThreatLocations, false, Enemy, false, GetLocation( WGPawn.MyUnit.FormationCenter ), 2.0f*WGPawn.MyUnit.FormationRadius, ExclusionList, bPerfectCover, bPartialCover, DummyThreatLoc );

	LastNodeSearch.SearchType = NodeSearch_AnywhereForgetCover;
	LastNodeSearch.bMustLeaveCover = false;
	LastNodeSearch.bMustHaveVantage = bMustHaveVantage;
	LastNodeSearch.Other = None;

	return DecideDestCore( false, NavPoint, DummyThreatLoc );
}

//---------------------------------------------------------
//	DecideDestElsewhereForgetCover
//---------------------------------------------------------
function bool DecideDestElsewhereForgetCover( optional bool bMustHaveVantage )
{
	local ActorLite NavPoint;
	local array<ActorLite> ExclusionList;
	local Vector DummyThreatLoc;
	local byte bPerfectCover, bPartialCover;

	LogSelective( "DecideDestElsewhereForgetCover()." );

	ExclusionTracker.AddToList( WGPawn.MyClaimedNavPoint );
	ExclusionTracker.GetList( ExclusionList );
	
	FindBestDestination( NavPoint, true, false, false, ThreatLocations, false, Enemy, true, vect(0,0,0), 0.0, ExclusionList, bPerfectCover, bPartialCover, DummyThreatLoc );

	LastNodeSearch.SearchType = NodeSearch_AnywhereForgetCover;
	LastNodeSearch.bMustLeaveCover = false;
	LastNodeSearch.bMustHaveVantage = bMustHaveVantage;
	LastNodeSearch.Other = None;

	return DecideDestCore( false, NavPoint, DummyThreatLoc );

}

//---------------------------------------------------------
//	DecideDestApproaching
//---------------------------------------------------------
function bool DecideDestApproaching( Actor OtherActor, Vector OtherMovementDirection )
{
	local ActorLite NavPoint;
	local array<ActorLite> ExclusionList;
	local Vector DummyThreatLoc;
	local Vector NewCenter;
	local ActorLite OnePoint;
	local float SqDistance;
	local Vector v_dir, v_temp;
	local Vector NavLoc;
	local int index;
	local vector vPawnDir, vOtherActorDir, vCross;
	local rotator rTemp;
	local bool bIsOnLeftSide;
	local byte bPerfectCover, bPartialCover;

	LogSelective( "DecideDestApproaching()." );

	// determine if the Pawn is to the left or right of the approaching actor...
	vPawnDir = Normal(WGPawn.Location - OtherActor.Location);  // direction from other actor to pawn
	vOtherActorDir = Normal(Vector(OtherActor.Rotation));  // direction other actor is facing

	vCross = vPawnDir cross vOtherActorDir;
	if (vCross.Z >= 0)
		bIsOnLeftSide = true;
	else
		bIsOnLeftSide = false;

	if (bIsOnLeftSide)
	{
		// pick a point to the left of the approaching actor...
		rTemp = OtherActor.Rotation;
		rTemp.Yaw = (rTemp.Yaw - 16384) & 65535;
		vOtherActorDir = Normal(Vector(rTemp));
	}
	else
	{
		// pick a point to the right of the approaching actor...
		rTemp = OtherActor.Rotation;
		rTemp.Yaw = (rTemp.Yaw + 16384) & 65535;
		vOtherActorDir = Normal(Vector(rTemp));
	}

	// determine the center point for the FindBestDestination() call...
	NewCenter = OtherActor.Location + (vOtherActorDir * (OtherActor.CollisionRadius + (4 * WGPawn.CollisionRadius)));

	ExclusionTracker.ClearList();

	// temporarily block nodes between the Pawn and the approaching actor...
	if (NavigationController != None)
	{
		SqDistance = VSizeSquared(OtherActor.Location - WGPawn.Location);
		v_dir = Normal(OtherActor.Location - WGPawn.Location);

		if (NavigationController.OneTimeBlockedNodes.Length > 0)
			NavigationController.OneTimeBlockedNodes.Remove(0, NavigationController.OneTimeBlockedNodes.Length);

		for (OnePoint=Level.NavigationPointList; OnePoint!=None; OnePoint=OnePoint.nextNavigationPoint)
		{
			NavLoc = GetLocation( OnePoint );

			if (VSizeSquared(NavLoc - WGPawn.Location) < SqDistance)
			{
				v_temp = Normal(NavLoc - WGPawn.Location);

				if ((v_dir dot v_temp) > 0.866)  // 30 degrees
				{
					index = NavigationController.OneTimeBlockedNodes.Length;
					NavigationController.OneTimeBlockedNodes.Length = index + 1;
					NavigationController.OneTimeBlockedNodes[index] = OnePoint;

				}

				if ((v_dir dot v_temp) > 0)  // 180 degrees
				{
					ExclusionTracker.AddToList( OnePoint );  // exclude navigation points in front of the tank
				}
			}
		}
	}

	ExclusionTracker.GetList( ExclusionList );

	FindBestDestination( NavPoint, false, false, false, ThreatLocations, false, Enemy, false, NewCenter, WGPawn.MyUnit.FormationRadius * 2.0f, ExclusionList, bPerfectCover, bPartialCover, DummyThreatLoc );

	if (NavPoint == None)  // search failed, try the other side of the approaching vehicle...
	{
		if (!bIsOnLeftSide)  // if first attempt was on right, try the left side now...
		{
			// pick a point to the left of the approaching actor...
			rTemp = OtherActor.Rotation;
			rTemp.Yaw = (rTemp.Yaw - 16384) & 65535;
			vOtherActorDir = Normal(Vector(rTemp));
		}
		else  // else, first attempt was on the left, try the right side now...
		{
			// pick a point to the right of the approaching actor...
			rTemp = OtherActor.Rotation;
			rTemp.Yaw = (rTemp.Yaw + 16384) & 65535;
			vOtherActorDir = Normal(Vector(rTemp));
		}

		// determine the center point for the FindBestDestination() call...
		NewCenter = OtherActor.Location + (vOtherActorDir * (OtherActor.CollisionRadius + (4 * WGPawn.CollisionRadius)));

		// try again with the new NewCenter...
		FindBestDestination( NavPoint, false, false, false, ThreatLocations, false, Enemy, false, NewCenter, WGPawn.MyUnit.FormationRadius * 2.0f, ExclusionList, bPerfectCover, bPartialCover, DummyThreatLoc );

		if (NavPoint == None)  // search failed, try to the rear of the approaching vehicle...
		{
			rTemp = OtherActor.Rotation;
			rTemp.Yaw = (rTemp.Yaw + 32768) & 65535;
			vOtherActorDir = Normal(Vector(rTemp));

			// determine the center point for the FindBestDestination() call...
			NewCenter = OtherActor.Location + (vOtherActorDir * (OtherActor.CollisionRadius + (4 * WGPawn.CollisionRadius)));

			// try again with the new NewCenter...
			FindBestDestination( NavPoint, false, false, false, ThreatLocations, false, Enemy, false, NewCenter, WGPawn.MyUnit.FormationRadius * 2.0f, ExclusionList, bPerfectCover, bPartialCover, DummyThreatLoc );
		}
	}

	ExclusionTracker.ClearList();

	if (NavPoint != None)
	{
		LastNodeSearch.SearchType = NodeSearch_Approaching;
		LastNodeSearch.bMustLeaveCover = false;
		LastNodeSearch.Other = OtherActor;
		LastNodeSearch.MovementDirection = OtherMovementDirection;

		return DecideDestCore( false, NavPoint, DummyThreatLoc );
	}

	return false;
}

//---------------------------------------------------------
//	DecideDestBetterCover
//---------------------------------------------------------
function bool DecideDestBetterCover( bool bMustHaveVantage, optional bool bIsRepeat )
{
	local ActorLite NavPoint;
	local array<ActorLite> ExclusionList;
	local Vector DummyThreatLoc;//, FORMC;
	local byte bPerfectCover, bPartialCover;
	
	LogSelective( "DecideDestBetterCover()." );

	ExclusionTracker.ClearList();
	
	if ( WGPawn.MyUnit == None || WGPawn.MyUnit.FormationCenter == None )
	{
		LogSelective( "DecideDestBetterCover: ERROR: Null Unit or FORMC" );
		if ( bUseAIDebugging && AITracker != None )
		{
			AITracker.SetMoveSuccess( false );
		}
		return false;
	}

	if ( !bIsRepeat )
	{
		ExclusionTracker.AddToList( WGPawn.MyClaimedNavPoint );
	}
	ExclusionTracker.GetList( ExclusionList );
	FindBestDestination( NavPoint, false, bMustHaveVantage, IsTrue( IveBeenFlanked ), ThreatLocations, false, Enemy, true, vect(0,0,0), 0.0, ExclusionList, bPerfectCover, bPartialCover, DummyThreatLoc );

	LogSelective( "DecideDestBetterCover: CP: "$NavPoint );
	if ( NavPoint == None )
	{
		if ( bUseAIDebugging && AITracker != None )
		{
			AITracker.SetMoveSuccess( false );
		}
		return false;
	}
	
	//FORMC = GetLocation( WGPawn.MyUnit.FormationCenter );
	
	// If I haven't been flanked, I can afford to be choosy; 
	// don't actually accept this point unless it provides at least partial cover.
	// GBX:naj - No, require *perfect* cover, otherwise, you'll see pawns abandon good cover spots to go out into the open.
	//if ( !bIveBeenFlanked && bPerfectCover == 0 && bPartialCover == 0 )
	if ( IsFalse( IveBeenFlanked ) && bPerfectCover == 0 )
	{
		if ( bUseAIDebugging && AITracker != None )
		{
			AITracker.AddMoveReason( ReasonMove_InsufficientCover );
			AITracker.SetMoveSuccess( false );
		}
		LogSelective( "DecideDestBetterCover: CP does not provide perfect cover, so why go there?" );
		return false;
	}
	
	LastNodeSearch.SearchType = NodeSearch_BetterCover;
	LastNodeSearch.bMustLeaveCover = false;
	LastNodeSearch.bMustHaveVantage = bMustHaveVantage;
	LastNodeSearch.Other = None;

	return DecideDestCore( false, NavPoint, DummyThreatLoc );				
}

//---------------------------------------------------------
//	DecideDestBetterVantageWithCover
//---------------------------------------------------------
function bool DecideDestBetterVantageWithCover()
{
	local ActorLite NavPoint;
	local array<ActorLite> ExclusionList;
	local Vector DummyThreatLoc;
	local Pawn FindDestEnemy;
	//local float ExpandedRadius;
	local byte bPerfectCover, bPartialCover;
	local bool bEvaluateAssignedTargetUnit;
	
	LogSelective( "DecideDestBetterVantageWithCover()." );

	if ( WGPawn.MyUnit == None || WGPawn.MyUnit.FormationCenter == None )
	{
		LogSelective( "DecideDestBetterVantageWithCover: ERROR: Null Unit or FORMC" );
		if ( bUseAIDebugging && AITracker != None )
		{
			AITracker.SetMoveSuccess( false );
		}
		return false;
	}

	if ( IsTrue( TargetOrderRulesInEffect ))
	{
		bEvaluateAssignedTargetUnit = true;
		FindDestEnemy = None;
	}
	else
	{
		bEvaluateAssignedTargetUnit = false;
		FindDestEnemy = Enemy;
	}

	ExclusionTracker.AddToList( WGPawn.MyClaimedNavPoint );
	ExclusionTracker.GetList( ExclusionList );
	FindBestDestination( NavPoint, false, true, IsTrue( IveBeenFlanked ), ThreatLocations, bEvaluateAssignedTargetUnit, FindDestEnemy, true, vect(0,0,0), 0.0, ExclusionList, bPerfectCover, bPartialCover, DummyThreatLoc );

	LogSelective( "DecideDestBetterVantageWithCover: CP: "$NavPoint );
	// We really should try harder if the node search came back empty-handed.  Expand the radius and try again.
	/*
	if ( NavPoint == None && WGPawn.MyUnit.FormationCenter != None && IsTrue( TargetOrderRulesInEffect ) )		
	{
		LogSelective( "DecideDestBetterVantageWithCover: Trying again with an expanded radius." );
		ExpandedRadius = Min( 2.0f*WGPawn.MyUnit.FormationRadius, MaxRadiusForBetterVantageSearch );
		ExpandedRadius = Max( ExpandedRadius, WGPawn.MyUnit.FormationRadius );
		FindBestDestination( NavPoint, false, true, IsTrue( IveBeenFlanked ), ThreatLocations, bEvaluateAssignedTargetUnit, FindDestEnemy, false, GetLocation( WGPawn.MyUnit.FormationCenter ), ExpandedRadius, ExclusionList, bPerfectCover, bPartialCover, 0.3f, DummyThreatLoc );

		if ( NavPoint == None )
		{
			LogSelective( "DecideDestBetterVantageWithCover: No nav point found the second time, either." );
		}
	}
	else
	{
		LogSelective( "DecideDestBetterVantageWithCover: Couldn't do an expanded radius re-try.  FormationCenter=="$WGPawn.MyUnit.FormationCenter$" ; TargetOrderRulesInEffect=="$IsTrue( TargetOrderRulesInEffect ) );
	}
	*/
	
	if ( NavPoint == None )
	{
		LogSelective( "DecideDestBetterVantageWithCover: NULL nav point.  Failure." );		

		if ( bUseAIDebugging && AITracker != None )
		{
			AITracker.SetMoveSuccess( false );
		}
		return false;
	}
	// If I haven't been flanked, I can afford to be choosy; 
	// don't actually accept this point unless it provides at least partial cover.
	// GBX:naj - No, require *perfect* cover, otherwise, you'll see pawns abandon good cover spots to go out into the open.
	else if ( IsFalse( IveBeenFlanked ) && bPerfectCover == 0 )
	{
		if ( bUseAIDebugging && AITracker != None )
		{
			AITracker.AddMoveReason( ReasonMove_InsufficientCover );
			AITracker.SetMoveSuccess( false );
		}
		LogSelective( "DecideDestBetterVantageWithCover: CP does not provide perfect cover, so why go there?" );
		ExclusionTracker.AddToList( NavPoint );
		return false;
	}
	
	LastNodeSearch.SearchType = NodeSearch_BetterVantageWithCover;
	LastNodeSearch.bMustLeaveCover = false;
	LastNodeSearch.bMustHaveVantage = true;
	LastNodeSearch.Other = None;

	if ( Level.Game.GameReplicationInfo.GameType != GT_MULTIPLAYER && Level.Game.IsPawnOnSameTeamAsPlayer(WGPawn) && !IsFrenzied() )
	{
		SetFlagTrueTimed( HasExtendedDeadlockProtection, 10.0f );
	}

	return DecideDestCore( false, NavPoint, DummyThreatLoc );
}

//---------------------------------------------------------
//	RepeatLastNodeSearch
//---------------------------------------------------------
function RepeatLastNodeSearch()
{
	LogSelective( "RepeatLastNodeSearch()." );

	// Do NOT repeat node searches when these pawns are firing at scripted targets.
	if ( bUseScriptedTargets )
		return;

	if (	LastNodeSearch.SearchType == NodeSearch_Anywhere /*|| 
			LastNodeSearch.SearchType == NodeSearch_AnywhereHasCover || 
			LastNodeSearch.SearchType == NodeSearch_BetterCover*/ )
	{
		if ( bUseAIDebugging && AITracker != None )
		{
			AITracker.StartNewMove();
			AITracker.AddMoveReason( LastNodeSearch.MoveReason );
		}

		switch( LastNodeSearch.SearchType )
		{
			case NodeSearch_Anywhere:
				DecideDestAnywhere( LastNodeSearch.bMustLeaveCover );
				break;
			/*
			case NodeSearch_AnywhereHasCover:
				DecideDestAnywhereHasPerfectCover();
				break;	
			case NodeSearch_BetterCover:
				DecideDestBetterCover( LastNodeSearch.bMustHaveVantage, true );
				break;
			*/
		}
	}
}

/////////////// UTILITY FUNCTIONS FOR DETERMINING COVER /////////////////////////////////////////////////////////////////

//---------------------------------------------------------
//	HasAnyStandingCover
//---------------------------------------------------------
function bool HasAnyStandingCover( ActorLite NavPoint )
{
	local byte CoverBits;

	if ( NavPoint.bIsNavigationPoint )
	{
		CoverBits = NavigationPoint( NavPoint ).CoverBits[2];
	}
	else
	if ( NavPoint.bIsNavigationPointLite )
	{
		CoverBits = NavigationPointLite( NavPoint ).CoverBits[2];
	}

	return ( CoverBits != 0x0 );
}

//---------------------------------------------------------
//	HasAnyCrouchedCover
//---------------------------------------------------------
function bool HasAnyCrouchedCover( ActorLite NavPoint )
{
	local byte CoverBits;

	if ( NavPoint.bIsNavigationPoint )
	{
		CoverBits = NavigationPoint( NavPoint ).CoverBits[1];
	}
	else
	if ( NavPoint.bIsNavigationPointLite )
	{
		CoverBits = NavigationPointLite( NavPoint ).CoverBits[1];
	}

	return ( CoverBits != 0x0 );
}

//---------------------------------------------------------
//	HasAnyLowCover
//---------------------------------------------------------
function bool HasAnyLowCover( ActorLite NavPoint )
{
	local byte CoverBits;

	if ( NavPoint == None )
	{
		return false;
	}
	if ( NavPoint.bIsNavigationPoint )
	{
		CoverBits = NavigationPoint( NavPoint ).CoverBits[0];
	}
	else
	if ( NavPoint.bIsNavigationPointLite )
	{
		CoverBits = NavigationPointLite( NavPoint ).CoverBits[0];
	}

	return ( CoverBits != 0x0 );
}

//---------------------------------------------------------
//	ProvidesCoverFrom
//---------------------------------------------------------
function bool ProvidesCoverFrom( Vector ThreatDir, ActorLite NavPoint, int Posture )
{
	if ( NavPoint == None )
	{
		return false;
	}

	else if ( NavPoint.bIsNavigationPoint )
	{
		return ( NavigationPoint( NavPoint ).ProvidesCoverFrom( ThreatDir, Posture ) );
	}
	else if ( NavPoint.bIsNavigationPointLite )
	{
		return ( NavigationPointLite( NavPoint ).ProvidesCoverFrom( ThreatDir, Posture ) );
	}
	else
		return false;
}

//---------------------------------------------------------
//	ProvidesStandingCoverFrom
//---------------------------------------------------------
function bool ProvidesStandingCoverFrom( Vector ThreatDir, ActorLite NavPoint )
{
	return ProvidesCoverFrom( ThreatDir, NavPoint, 2 );
}

//---------------------------------------------------------
//	ProvidesCrouchedCoverFrom
//---------------------------------------------------------
function bool ProvidesCrouchedCoverFrom( Vector ThreatDir, ActorLite NavPoint )
{
	local bool bResult;
	bResult = ProvidesCoverFrom( ThreatDir, NavPoint, 1 );

	//LogSelective( "ProvidesCrouchedCoverFrom: "$bResult$", ThreatDir="$ThreatDir$" ; NavPoint="$NavPoint );
	return bResult;
}

//---------------------------------------------------------
//	ProvidesLowCoverFrom
//---------------------------------------------------------
function bool ProvidesLowCoverFrom( Vector ThreatDir, ActorLite NavPoint )
{
	local bool bResult;
	bResult = ProvidesCoverFrom( ThreatDir, NavPoint, 0 );

	//LogSelective( "ProvidesLowCoverFrom: "$bResult$", ThreatDir="$ThreatDir$" ; NavPoint="$NavPoint );
	return bResult;
}

//---------------------------------------------------------
//	ProvidesLowOrCrouchedCoverFrom
//---------------------------------------------------------
function bool ProvidesLowOrCrouchedCoverFrom( Vector ThreatDir, ActorLite NavPoint )
{
	local bool bResult;
	bResult = ( ProvidesLowCoverFrom( ThreatDir, NavPoint ) || ProvidesCrouchedCoverFrom( ThreatDir, NavPoint ) );

	//LogSelective( "ProvidesLowOrCrouchedCoverFrom: "$bResult$", ThreatDir="$ThreatDir$" ; NavPoint="$NavPoint );
	return bResult;
}

//---------------------------------------------------------
//	IsCoveredAtThisNode - CALLED BY OUTSIDERS
//---------------------------------------------------------
event bool IsCoveredAtThisNode( ActorLite aNode )
{
	// Conditions:
	// 1) aNode is the Pawn's claimed nav point;
	// 2) The Pawn is not moving or is within 25 units of the node;
	// 3) The FiringController is in FiringFromCover.

	if ( WGPawn.MyClaimedNavPoint != aNode )
	{
		return false;
	}
	else if ( /*!IsInState( 'RelaxedAtCorner' ) &&*/ !IsInState( 'FiringFromCover' ) )
	{
		return false;
	}
	else if ( !NavigationController.bIsNavigating )
	{
		return true;
	}
	else if ( VSizeIgnoreZ( WGPawn.Location - GetLocation( aNode ) ) <= 25.0 )
	{
		return true;
	}
	else
	{
		return false;
	}
}

//---------------------------------------------------------
//	NotifyTeammateShootingAtTarget
//---------------------------------------------------------
function NotifyTeammateShootingAtTarget( gbxPawn Teammate, gbxPawn theTarget )
{
	// TODO: Make sure we don't ignore this target.
	AddTarget( theTarget, true );
}

//---------------------------------------------------------
//	NotifyPreparingToFire
//---------------------------------------------------------
// Reduce the pawn's chances of noticing sneaking enemies when firing shots.
function NotifyPreparingToFire( bool bPreparing, optional gbxPawn IntendedTarget )
{
	bPreparingFire = bPreparing;

	if ( bPreparingFire )
	{
		SurpriseCosThetaMax = SurpriseCosThetaMax_Firing;
		SurpriseCosThetaMin = SurpriseCosThetaMin_Firing;

		if ( IntendedTarget != None )
		{
			WGPawn.MyUnit.NotifyTeammatesOfTarget( WGPawn, IntendedTarget );
		}
	}	
}

//---------------------------------------------------------
//	NotifyPawnIsShooting
//---------------------------------------------------------
event NotifyPawnIsShooting()
{
	// Clear the exclusion list only if we're stopped at a nav point.
	if ( !NavigationController.bIsNavigating )
		ExclusionTracker.ClearList();

	// Clear the target-failure information, because clearly nothing is hindering our shot.
	TimeLastBlockedByFriendly = 0.0;
	TimeLastNoHadVantage = 0.0;
	BlockingFriendly = None;

	if ( bUseAIDebugging && AITracker != None )
	{
		AITracker.AddFiringFactor( Firing_ShotOK );
	}

	SetInitialFlagValue( VantageLost, false );
	SetInitialFlagValue( BeingBlockedByPlayer, false );
	
	if ( WGPawn.MyUnit != None )
	{
		if ( HasTargetOrder() && WGPawn.MyUnit.IsInTargetUnit( gbxPawn( Enemy ) ) )
		{
			TimeLastShotAtAssignedUnit = Level.TimeSeconds;
		}
	}
}

//---------------------------------------------------------
//	HasBeenShootingWell
//---------------------------------------------------------
function bool HasBeenShootingWell()
{
	return ( IsFalse( VantageLost ) );
}

//---------------------------------------------------------
//	HasHadVantageProblems
//---------------------------------------------------------
function bool HasHadVantageProblems()
{
	return ( IsTrue( VantageLost ) && TimeSinceRaised( VantageLost ) > 5.0 );
}

//---------------------------------------------------------
//	TimeLastShotAtAssignedUnit
//---------------------------------------------------------
function float GetTimeLastShotAtAssignedUnit()
{
	return TimeLastShotAtAssignedUnit;
}

//---------------------------------------------------------
//	HasVantageOnUnit
//---------------------------------------------------------
function bool HasVantageOnUnit( Unit aUnit )
{
	local int iEnemyUnitMember, iTarget;

	if( aUnit == None || aUnit.bDeleteMe )
	{
		return false;
	}

	// I have vantage on a unit if at least one of the unit's members is in my target queue and I have exposure on that member.

	// TODO argh painful O(N^2) algorithm. Maybe identify vantaged units during CalculateTargetPriorities() and store for later access here.

	for( iEnemyUnitMember = 0; iEnemyUnitMember < aUnit.NumMembers; ++iEnemyUnitMember )
	{
		for( iTarget = 0; iTarget < TargetQueue.Length; ++iTarget )
		{
			if( TargetQueue[ iTarget ].Target == aUnit.Members[ iEnemyUnitMember ] &&
				TargetQueue[ iTarget ].TargetExposureToMe > 0 )
			{
/*				Log( name $ "<" $ GetStateName() $ ">.HasVantageOnUnit( " $ aUnit $ " ) found known target " $ TargetQueue[ iTarget ].Target $
					" with exposure " $ TargetQueue[ iTarget ].TargetExposureToMe, 'unit' );
*/
				return true;
			}
		}
	}

	return false;
}

//---------------------------------------------------------
//	GetTargetExposure
//---------------------------------------------------------
native function float GetTargetExposure( Pawn aTarget );

//---------------------------------------------------------
//	PostNetBeginPlay
//---------------------------------------------------------
function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();

	Level.MessageManager.AddListener( Self );
}

//---------------------------------------------------------
//	GetFiringController
//---------------------------------------------------------
function FiringControllerBase GetFiringController()
{
	return FiringController;
}

//---------------------------------------------------------
//	ReplaceFiringController
//---------------------------------------------------------
function ReplaceFiringController( FiringControllerInfantry NewFC )
{
	FiringController = NewFC;
	FiringController.SetMind( Self );
	FiringController.Possess( WGPawn );
}

//---------------------------------------------------------
//	GetMountController
//---------------------------------------------------------
function MountController GetMountController()
{
	return MountController;	// May be None
}

//---------------------------------------------------------
//	PawnDied
//---------------------------------------------------------
function PawnDied(Pawn P)
{
	local PerceptionPawnDied percep;

//	Log( Name $ "(" $ Pawn.Name $ ").PawnDied( " $ P $ " )", 'Mind' );

	Super.PawnDied( P );

	if( P != WGPawn )
	{
		Log( "WARNING: " $ Name $ "(" $ Pawn.Name $ ").PawnDied( " $ P $ " ) called for P != WGPawn.", 'Mind' );
		return;
	}

	percep = new( None ) class'PerceptionPawnDied'; // GBX:naj - modified 3/11/04
	percep.PawnDied = P;
	percep.Killer = MyKiller;

	P.PostGBXMessage( percep );

	// Pawn should leave unit.
	if ( WGPawn != None && WGPawn.MyUnit != None )
	{
		WGPawn.MyUnit.RemoveMember( WGPawn );
	}

	Destroy();
}

function WasKilledBy(Controller Other)
{
	if (Other.Pawn != None)
		MyKiller = Other.Pawn;
	else
		MyKiller = None;
}


//---------------------------------------------------------
//	Destroyed
//---------------------------------------------------------
function Destroyed()
{
	Level.MessageManager.RemoveListener( Self );

	Disable( 'Tick' );
	Disable( 'Timer' );

	if (TargetQueue.Length > 0)
		TargetQueue.Remove(0, TargetQueue.Length);

	WGPawn = None;  // prevent references to/in destroyed objects

	if ( !bRetainSubcontrollers )
	{
		if ( FiringController != None )
		{
			FiringController.Destroy();
			FiringController = None;  // prevent references to/in destroyed objects
		}
		
		if ( NavigationController != None )
		{
			NavigationController.Destroy();
			NavigationController = None;  // prevent references to/in destroyed objects
		}

		if ( MountController != None )
		{
			MountController.Destroy();
			MountController = None;    // prevent references to/in destroyed objects
		}

		if ( ExclusionTracker != None )
		{
			ExclusionTracker.Destroy();
			ExclusionTracker = None;    // prevent references to/in destroyed objects
		}

		if ( SalutationsController != None )
		{
			SalutationsController.Destroy();
			SalutationsController = None;  // prevent references to/in destroyed objects
		}
		// delete AITracker?  How?
	}

	Super.Destroyed();
}

//---------------------------------------------------------
//	Timer
//---------------------------------------------------------
function Timer()
{
	if(TimerRate != TimerInterval)
		SetTimer( TimerInterval, true );

	if( Pawn == None || Pawn.bDeleteMe || WGPawn == None || WGPawn.MyUnit == None || WGPawn.MyUnit.bDeleteMe )
	{
		return;
	}

	UpdateActualAttackLevels();
	UpdateForgetfulness();	

	// Deal with finished goals and empty queues.
	if( IsTargetDead() || IsTargetNoTarget() )
	{
		RemoveTargetFromQueue( Enemy );
		SetEnemy( None );
		FiringController.SetTarget( None );
	}

	// Check if a prior Assault command is still valid.
	if ( bShouldAssault && !IsInState( 'Assaulting' ) )
	{
		if ( WGPawn.MyUnit.AssignedTargetUnit == None || WGPawn.MyUnit.AssignedTargetUnit.GetNumLivingMembers() == 0 )
		{
			StopAssault();
		}
	}

	// Occasionally force a re-sort of the target and destination queues by setting their "needs sort" flags.
	if( Level.TimeSeconds > TimeLastTargetSort + ForceTargetSortInterval )
	{
		bTargetQueueNeedsSort = true;
	}

	// Sort queues as necessary.
	if ( bUseScriptedTargets )
	{
		SetEnemy( m_aTargetPawn );
	}
	else if( bTargetQueueNeedsSort )
	{
		PrioritizeTargets();
		
		// Assign best Target.
		if( ndxEnemyInQueue >= 0 && ndxEnemyInQueue < TargetQueue.Length )
		{
			SetEnemy( TargetQueue[ ndxEnemyInQueue ].Target );
		}
		else
		{
			SetEnemy( None );
		}

		// Assign worst threat.
		if( TargetQueue.Length > 0 )
		{
			FindWorstThreats();
		}
		else if ( WorstThreats.Length > 0 )
		{
			WorstThreats.Remove( 0, WorstThreats.Length );
			ThreatLocations.Remove( 0, ThreatLocations.Length );
		}

		UpdateFlankAlarm();
		AnnounceTargetPriorities();
		UpdateEnemySuppressionKnowledge();
		CheckDeadTeammateStatus();
	}

	///////// Update miscellaneous flags.
	if ( IsInCombat() || Enemy != None || IsNavigating() )
		SetFlagValue( StoppedAndIdle, false );			
	else
		SetFlagValue( StoppedAndIdle, true );

	if ( IsTrue( HasExtendedDeadlockProtection ) )
	{
		// No extended deadlock protection if not in the middle of movement, if frenzied, or if the pawn has been flanked.
		if ( !IsNavigating() || IsTrue( IveBeenFlanked ) || IsFrenzied() )
			SetFlagValue( HasExtendedDeadlockProtection, false );	
	}
	///////// End update miscellaneous flags.

	if ( !bDontInterruptMe )
	{
		DecideState();
		DecideWeaponAim();

		if( !IsInState('FiringFromCover') )
		{
			DecidePosture();
			DecideMaxSpeed();
		}
		
		DecideFacingPolicy();

		FiringController.Think(); // SJP: This just passes through to the grenade firing controller right now.
	}
}


//---------------------------------------------------------
//	UpdateFlankAlarm
//---------------------------------------------------------
function UpdateFlankAlarm()
{
	// Has the flank alarm been activated?  See if it's time to shut it off.
	if ( IsTrue( IveBeenFlanked ) )
	{
		if ( TimeSinceRaised( IveBeenFlanked ) > FlankAlarmDuration )
		{
			if ( !CoverNoLongerValid() && !FiringController.VantageNoLongerValid() )	// if cover is valid		
				SetFlagValue( IveBeenFlanked, false );
		}
	}
	else
	{
		// See if we should activate the flank alarm.
		if ( Enemy != None && WGPawn.MyUnit != None )
		{
			if ( WGPawn.MyUnit.MyUnitController.PawnIsOnUnitFlank( gbxPawn( Enemy ) ) )
			{
				SetFlagValue( IveBeenFlanked, true );
				SpeakWeveBeenFlanked();
			}
		}
	}
}

//---------------------------------------------------------
//	AnnounceTargetPriorities
//---------------------------------------------------------
function AnnounceTargetPriorities()
{
	local int i;
	local UnitControllerAI UnitConAI;

	if( WGPawn.MyUnit != None )
	{
		UnitConAI = UnitControllerAI(WGPawn.MyUnit.MyUnitController);
	}

	for( i = 0; i < TargetQueue.Length; ++i )
	{
		if( UnitConAI != None )
		{
			UnitConAI.UnitMemberUpdatedTarget( TargetQueue[ i ].Target );
		}

		FiringController.RefreshTarget( TargetQueue[ i ].Target, TargetQueue[ i ].TargetPriority );
	}
}

//---------------------------------------------------------
//	UpdateEnemySuppressionKnowledge
//---------------------------------------------------------
function UpdateEnemySuppressionKnowledge()
{
	local Pawn PlayerPawn;

        // PSV: 6/20/2005 Prevent script warning accessing None
	if ( WGPawn.MyUnit.GetControllingPlayerController() != None )
	PlayerPawn = WGPawn.MyUnit.GetControllingPlayerController().Pawn;
	else
		PlayerPawn = None;

	if (	Enemy == None || !Enemy.IsA( 'gbxPawn' ) || 
			gbxPawn(Enemy).MyUnit.MyUnitController == None )
		return;

	// Update the state of the flag we use to track our enemy's suppression status.
	if ( gbxPawn(Enemy).MyUnit.MyUnitController.GetSuppressionLevel() == SL_SUPPRESSED )
		SetFlagValue( TargetSuppressed, true );
	else
		SetFlagValue( TargetSuppressed, false );

	// If the enemy becomes unsuppressed, this is urgent to report.
	if ( IsLowered( TargetSuppressed ) )
	{
		Level.TheAISpeechManager.PlaySpeech(
			WGPawn,
			PlayerPawn,
			'EnemyUnsuppressed',
			,
			,
			0.0,
			WGPawn.MyUnit,
			5.0,
			2.0
		);
	}
	// Report on the enemy's suppression status, but only try to speak once every 10 seconds or so.
	else if ( IsFalse( SpokeAboutSuppression ) )
	{
		if ( IsTrue( TargetSuppressed ) )
		{
			if ( bCanReportSuppressionStatus )
			{
				Level.TheAISpeechManager.PlaySpeech(
					WGPawn,
					PlayerPawn,
					'EnemySuppressed',
					,
					,
					0.0,
					WGPawn.MyUnit,
					5.0,
					5.0
				);
				SetFlagTrueTimed( SpokeAboutSuppression, 20.0f );
			}
			else if ( TimeSinceRaised( TargetSuppressed ) > 20.0f )
			{
				Level.TheAISpeechManager.PlaySpeech(
					WGPawn,
					PlayerPawn,
					'FlankTheEnemy',
					,
					,
					0.0,
					WGPawn.MyUnit,
					4.0,
					5.0
				);
				SetFlagTrueTimed( SpokeAboutSuppression, 20.0f );
			}
		}
	}		
	
	bCanReportSuppressionStatus = false;
}

//---------------------------------------------------------
//	CheckDeadTeammateStatus
//---------------------------------------------------------
function CheckDeadTeammateStatus()
{
	local Pawn PlayerPawn;
	
	if ( IsRaised( MultipleFriendliesDead ) )
	{
		PlayerPawn = WGPawn.MyUnit.GetControllingPlayerController().Pawn;
		Level.TheAISpeechManager.PlaySpeech(
			WGPawn,
			PlayerPawn,
			'AlliesDying',
			,
			,
			3.0,
			WGPawn.MyUnit,
			5.0,
			6.0
		);
		SetFlagValue( MultipleFriendliesDead, false );	// Clear out the "multiple dead" flag so it can be triggered again for the next death.
		
		SetInitialFlagValue( FriendlyDead, false );		// Refresh the "at least one dead" flag so that it has a fresh timestamp.
		SetFlagValue( FriendlyDead, true );
	}

	// Decay flags after about 2 minutes.
	if ( IsTrue( FriendlyDead ) && TimeSinceRaised( FriendlyDead ) > 120.0 )
	{
		SetFlagValue( FriendlyDead, false );
	}

}

//---------------------------------------------------------
//	ReportSuppressionStatus
//---------------------------------------------------------
function ReportSuppressionStatus() 
{
	bCanReportSuppressionStatus = true;	
}

//---------------------------------------------------------
//	UpdateActualAttackLevels
//---------------------------------------------------------
function UpdateActualAttackLevels()
{
	local int i;

	for( i = 0; i < TargetQueue.Length; ++i )
	{
		TargetQueue[ i ].ActualAttackLevel = FClamp( TargetQueue[ i ].ActualAttackLevel - AttackLevelDecay, 0, 1 );
		TargetQueue[ i ].DistractionLevel = FClamp( TargetQueue[ i ].DistractionLevel - DistractionLevelDecay, 0, 1 );
	}
}

//---------------------------------------------------------
//	UpdateForgetfulness
//---------------------------------------------------------
function UpdateForgetfulness()
{
	// Singleplayer only.
	local float CurSuppressionNormalized;

	// GBX:naj - bug 8368.
	if ( Level.Game.GameReplicationInfo.GameType != GT_MULTIPLAYER )
	{
		CurSuppressionNormalized = FClamp( 1.0f - WGPawn.MyUnit.MyUnitController.GetSuppressionLevelAnalog() / 2.0f, 0.0, 1.0f );
		TargetForgetTimeSP = FClamp( CurSuppressionNormalized * Default.TargetForgetTimeSP, 3.0, Default.TargetForgetTimeSP );	
	}
}

//---------------------------------------------------------
//	NotifyUnitOfOpBurst
//---------------------------------------------------------
function NotifyUnitOfOpBurst()
{
	if ( WGPawn != None && WGPawn.MyUnit != None )
	{
		WGPawn.MyUnit.NotifyMemberDoingOpBurst( WGPawn );
	}
}

//---------------------------------------------------------
//	NotifyDoingOpBurst
//---------------------------------------------------------
function NotifyDoingOpBurst()
{
	FiringController.NotifyDoingOpBurst();
}

//---------------------------------------------------------
//	CanDoOpBurst
//---------------------------------------------------------
function bool CanDoOpBurst() 
{
	// TBD: Keep a variable here that is set by either PrioritizeTargets()
	// or by a NotifyOpportunisticBurst() call from a teammate.
	//
	// return bCanDoOpportunisticBurst;

	return false;
}

//---------------------------------------------------------
//	AdjustAimNew
//---------------------------------------------------------
function Rotator AdjustAimNew(Ammunition Ammo, Vector ProjStart, Rotator AimRotator, optional out int bSkipDoTrace )
{
	return FiringController.AdjustAimNew( Ammo, ProjStart, AimRotator, bSkipDoTrace );
}

//---------------------------------------------------------
//	ReceiveGBXMessage
//---------------------------------------------------------
// True == Message has been stored away for later use; caller should not delete it after calling this function.
// False == Message has *not* been stored away; caller may delete msg if necessary after calling this function.
function bool ReceiveGBXMessage( gbxMessage msg )
{
	local bool bKeep;

	if ( Pawn == None )
	{
		return false;
	}

	bKeep = false;  // not storing the message away by default

//	Log( Name $ "(" $ Pawn.Name $ ").ReceiveGBXMessage()", 'Mind' );
	if( msg.IsA( 'Perception' ))
	{
		Perception( msg ).AffectMind( Self );
		
		// GBX:PAD: Ensure that WGPawn.MyUnit exists since otherwise it dumps a bunch of accessed none messages in the log files.
		if ((WGPawn.MyUnit != None) && (UnitControllerAI(WGPawn.MyUnit.MyUnitController) != None))
		{
			bKeep = UnitControllerAI( WGPawn.MyUnit.MyUnitController ).ReceiveMemberMessage( msg, VSize( Pawn.Location - msg.GetLocation() ) );
		}
	}

	return bKeep;
}

//---------------------------------------------------------
//	RequestFacingPolicy
//---------------------------------------------------------
function bool RequestFacingPolicy( EFacingPolicy policy )
{
	// If this function returns true, your request has been accepted and you can set FacingActor or FacingVector, if needed, as desired.
	// If the function returns false, your request has been denied and you should not set FacingActor or FacingVector.

	SetFacingPolicy( policy );
	return true;
}

//---------------------------------------------------------
//	SetFacingPolicy
//---------------------------------------------------------
event bool SetFacingPolicy( EFacingPolicy policy )
{
	// NOTE: This check MUST occur BEFORE the 'if (bDontInterruptMe)' check below, since the NavigationController
	// mounting and climing over walls REQUIRES this function to return 'true' in the MountController
	if (policy == FacingPolicy)
		return true;  // already set to this policy, do nothing, just return 'true';

	if ( bDontInterruptMe )
		return false;  // don't allow changes right now

	// External classes shouldn't call this directly unless you're really confident you want to override. Use RequestFacingPolicy() instead.
	FacingPolicy = policy;

	// make sure the NavigationController knows what facing policy to use
	if (NavigationController != None)
		NavigationController.SetFacingPolicy( policy );

	return true;
}

//---------------------------------------------------------
//	GetLastKnownLocation
//---------------------------------------------------------
// Warning!  Check the sign of the TargetDistance value returned from this function.
function Vector GetLastKnownLocation( gbxPawn theTarget, out float TargetDistance )
{
	local int ndx;

	ndx = FindTargetInQueue( theTarget );

	if ( ndx > -1 )
	{
		TargetDistance = TargetQueue[ ndx ].TargetDistance;
		return TargetQueue[ ndx ].LastKnownLocation;
	}
	else
	{
		TargetDistance = -1.0f;
		return Vect(0,0,0);
	}
}

//---------------------------------------------------------
//	SetAimingAtTarget
//---------------------------------------------------------
function SetAimingAtTarget( gbxPawn theTarget )
{
	local int ndx;

	if ( theTarget == None )
		WGPawn.SetAimingAtTarget( None );
	else
	{
		ndx = FindTargetInQueue( theTarget );

		if ( TargetQueue[ ndx ].TargetExposureToMe > 0 )
		{
			WGPawn.SetAimingAtTarget( theTarget );
		}
		else
		{
			WGPawn.SetAimingAtTarget( None );
			WGPawn.SetAimAtPoint( TargetQueue[ ndx ].LastKnownLocation, true );
		}
	}
}

//---------------------------------------------------------
//	ImplementFacingPolicy
//---------------------------------------------------------
event ImplementFacingPolicy()
{
	local int ndx;

	switch( FacingPolicy )
	{
		case FACE_NoChange:
			bRotateToDesired=false;
			break;

		case FACE_Destination:
			bRotateToDesired = true;
//			FocalPoint = Destination;	// Do nothing. Low-level navigation code handles this policy.
			Focus = None;
			WGPawn.ResetLookAt( false, false, true );
			break;

		case FACE_Vector:
			bRotateToDesired = true;
			FocalPoint = FacingVector;
			Focus = None;
			break;

		case FACE_Actor:
			bRotateToDesired = true;
			Focus = FacingActor;
			break;

		case FACE_Enemy:
			// Face the Enemy himself if he is visible.  Otherwise, face his last known location.			
			bRotateToDesired = true;

			ndx = FindTargetInQueue( Enemy );

			if ( ndx > -1 )
			{
				if ( TargetQueue[ ndx ].TargetExposureToMe > 0.25 )
				{
					Focus = Enemy;
				}
				else
				{
					Focus = None;
					FocalPoint = TargetQueue[ ndx ].LastKnownLocation;
				}
			}
			else
			{
				Focus = Enemy;
			}

			break;

		default:
			Warn( class $ ".ImplementFacingPolicy(): Unknown facing policy." );
			break;
	}
}

//---------------------------------------------------------
//	Tick
//---------------------------------------------------------
function Tick( float DeltaTime )
{
	local float	flTime, flPct;
	local Vector vecTarget;

	if( Pawn == None )
	{
		WGPawn = None;
		return;
	}

	// Update our pawn.
	if( Pawn != WGPawn )
	{
		WGPawn = WargamePawn( Pawn );
	}

	if( WGPawn == None )
	{
		return;
	}

	// Update the location of the scripted target pawn, if one is being used by this pawn.
	if ( bUseScriptedTargets )
	{
		if (m_nTargetMode == TargetMode_Sweep)
		{
			flTime = Level.TimeSeconds - m_flLastTargetTime;
			if (flTime > m_flTotalTargetTime)
			{
				m_nTargetDir *= -1;
				m_flLastTargetTime = Level.TimeSeconds;
				flTime = 0.0f;
			}
			
			if (m_nTargetDir > 0)
			{
				flPct = flTime / m_flTotalTargetTime;
			}
			else
			{
				flPct = (m_flTotalTargetTime - flTime) / m_flTotalTargetTime;
			}
			
			if ( m_aTargetPawn != None && m_aTarget1 != None && m_aTarget2 != None )
			{
				vecTarget.X = Lerp( flPct, m_aTarget1.Location.X, m_aTarget2.Location.X );
				vecTarget.Y = Lerp( flPct, m_aTarget1.Location.Y, m_aTarget2.Location.Y );
				vecTarget.Z = Lerp( flPct, m_aTarget1.Location.Z, m_aTarget2.Location.Z );
				
				m_aTargetPawn.SetLocation( vecTarget );
			}
		}
	}

	// is wall climbing animation in progress?  don't let normal Mind process this Tick, but MUST call Super.Tick() otherwise won't rotate
	if (bDontLetMindTick)
	{
		Super.Tick( DeltaTime );
		return;
	}

	if( FacingPolicy == FACE_Enemy && Enemy == None )
	{
		if ( IsNavigating() )
		{
			SetFacingPolicy( FACE_Destination );
		}
		else
		{
			SetFacingPolicy( FACE_NoChange );
		}
	}
	
	ImplementFacingPolicy();

	UpdateFatigue(DeltaTime);

	AdjustSurpriseability( DeltaTime );

	Super.Tick( DeltaTime );
}

//---------------------------------------------------------
//	GetFatigueRecoveryRate
//---------------------------------------------------------
event float GetFatigueRecoveryRate()
{
	// GBX:PAD: This prevents a ton of accessed none messages in maps where a unit is not defined.
	if (WGPawn.MyUnit == None)
		return WGPawn.FatigueRecovery_Novice;
		
	// Recovery rate is based on this pawn's unit's skill level.
	switch ( WGPawn.MyUnit.BaseSkillLevel )
	{
		case SKILL_Novice:
			return WGPawn.FatigueRecovery_Novice;
		case SKILL_Intermediate:
			return WGPawn.FatigueRecovery_Interm;
		case SKILL_Advanced:
			return WGPawn.FatigueRecovery_Advanced;
		case SKILL_Veteran:
		case SKILL_Invincible:
			return WGPawn.FatigueRecovery_Veteran;
	}

	return WGPawn.FatigueRecovery_Novice;
}

//---------------------------------------------------------
//	AdjustSurpriseability
//---------------------------------------------------------
function AdjustSurpriseability( float DeltaTime )
{
	local float CurSuppressionNormalized;
	
	if ( !bPreparingFire )
	{
		// GBX:naj - bug 8368.
		if ( Level.Game.GameReplicationInfo.GameType != GT_MULTIPLAYER )
		{
			// Singleplayer surprise model: Surpriseability viewcone is tied directly to suppression level.
			if ( WGPawn.MyUnit != None && WGPawn.MyUnit.MyUnitController != None )
			{
				CurSuppressionNormalized = FClamp( WGPawn.MyUnit.MyUnitController.GetSuppressionLevelAnalog() / 2.0f, 0.0, 1.0f );
				SurpriseCosThetaMax = Default.SurpriseCosThetaMax + CurSuppressionNormalized * (SurpriseCosThetaMax_Firing - Default.SurpriseCosThetaMax);
				SurpriseCosThetaMin = Default.SurpriseCosThetaMin + CurSuppressionNormalized * (SurpriseCosThetaMin_Firing - Default.SurpriseCosThetaMin);
			}
		}
		else
		{
			// Multiplayer surprise model.  Surpriseability only goes down when firing weapon and decays by a fixed rate.
			if ( SurpriseCosThetaMax > Default.SurpriseCosThetaMax )
			{
				SurpriseCosThetaMax -= 0.25 * DeltaTime;
				SurpriseCosThetaMax = FClamp( SurpriseCosThetaMax, Default.SurpriseCosThetaMax, SurpriseCosThetaMax_Firing );
			}
			if ( SurpriseCosThetaMin > Default.SurpriseCosThetaMin )
			{
				SurpriseCosThetaMin -= 0.25 * DeltaTime;
				SurpriseCosThetaMin = FClamp( SurpriseCosThetaMin, Default.SurpriseCosThetaMin, SurpriseCosThetaMin_Firing );
			}
		}
	}
}

//---------------------------------------------------------
//	ClampFatigueSpecial
//---------------------------------------------------------
function ClampFatigueSpecial()
{
	// If the pawn is suppressed, don't let his fatigue value go below 1.0.
	// If the pawn is not suppressed, don't let his fatigue value go above 1.0.
	if ( GetSuppressionLevel() == SL_UNSUPPRESSED )
	{
		//Super.ClampFatigueSpecial();
		if( IsBerserk() )
		{
			m_flFatigue = 0.0;
		}
		else
		{
			m_flFatigue = FClamp( m_flFatigue, 0.0, 1.0 );
		}
	}
	else
	{
		m_flFatigue = 1.0;
	}
}

//---------------------------------------------------------
//	IsTargetExposed
//---------------------------------------------------------
function bool IsTargetExposed( gbxPawn theTarget )
{
	local int ndx;

	ndx = FindTargetInQueue( theTarget );
	if( ndx > -1 )
		return ( TargetQueue[ ndx ].TargetExposureToMe >= 1.0 );
	else
		return false;
}

//---------------------------------------------------------
//	AmIExposedToTarget
//---------------------------------------------------------
function bool AmIExposedToTarget( gbxPawn theTarget )
{
	local int ndx;

	ndx = FindTargetInQueue( theTarget );	
	if( ndx >= 0 )
		return ( TargetQueue[ ndx ].MyExposureToTarget >= 1.0 );
	else
		return false;
}

//---------------------------------------------------------
//	IsPointExposedToTarget
//---------------------------------------------------------
// Expensive line trace within.  Use with caution.
function bool IsPointExposedToTarget( Vector TestPoint, gbxPawn theTarget )
{
	return FastTrace( TestPoint, TheTarget.Location );
}

/////////////////////////////////////////////////////////////////////////
// Queue Management
/////////////////////////////////////////////////////////////////////////

// Target Queue /////////////////////////////////////////////////////////

//---------------------------------------------------------
//	RelegateEnemy
//---------------------------------------------------------
function RelegateEnemy()
{
	local int ndx;	

	// Enemy looks good but no way to kill it. Send it back in the queue.
	
	// But no relegating human targets.
	if ( Enemy == None /*|| Enemy.IsHumanControlled()*/ )
		return;	

	ndx = FindTargetInQueue( Enemy );
	
	if( ndx >= 0 )
	{
		if ( TargetQueue[ ndx ].TargetDistance >= CombatRadius_NoRelegation )
		{
			TimeLastNoHadVantage = 0.0;
			TargetQueue[ ndx ].RelegationTime = Level.TimeSeconds + RelegationDuration;
			TargetQueue[ ndx ].RelegatedNavPoint = TargetQueue[ ndx ].Target.MyClaimedNavPoint;
		}
	}
}

//---------------------------------------------------------
//	ClearRelegations
//---------------------------------------------------------
function ClearRelegations()
{
	local int ndx;

	for( ndx=0; ndx < TargetQueue.Length; ++ndx )
	{
		TargetQueue[ ndx ].RelegationTime = 0.0f;
		TargetQueue[ ndx ].RelegatedNavPoint = None;
	}

	bBestTargetRelegated = false;
}

//---------------------------------------------------------
//	AddTarget
//---------------------------------------------------------
function AddTarget( gbxPawn newTarget, optional bool bDefinitelySeeTarget )
{
	local TargetInfo newTargetInfo;
	local int ndxTarget;
	local PerceptionPawnAddedTarget percep;	
	local Object Regarding;

	// Sanity checks.
	if( newTarget == None || newTarget.SameTeamAs( WGPawn ) )
	{
		return;
	}

	if ( TargetQueue.Length == 0 )
	{
		SetFlagValue( StoppedAndIdle, false );
	}

	newTargetInfo.Target = newTarget;

	// Is this target already in the queue?
	ndxTarget = FindTargetInQueue( newTarget );

	if( ndxTarget < 0 )
	{
		// Add the new target to the end of the list.
		TargetQueue.Length = TargetQueue.Length + 1;
		TargetQueue[ TargetQueue.Length - 1 ] = newTargetInfo;
		InitTargetInfo( TargetQueue[ TargetQueue.Length - 1 ] );
		
		if ( bUseAIDebugging && AITracker != None )
		{
			AITracker.AddEnemy( newTarget );
		}

		// Alert my friends about this target.
		percep = new( None ) class'PerceptionPawnAddedTarget';
		percep.Target = newTarget;

		WGPawn.PostGBXMessage( percep );
		
		if ( bDefinitelySeeTarget ||
			(	TargetQueue[ TargetQueue.Length - 1 ].TargetExposureToMe >= 0.5 && 
				TargetQueue[ TargetQueue.Length - 1 ].TargetOutOfViewRating <= 0.5 ) )
		{
			if ( WGPawn.MyUnit != None && WGPawn.MyUnit.MyUnitController != None )
			{
				WGPawn.MyUnit.MyUnitController.MemberSurprisedByAttacker( newTarget, WGPawn );	// Calls NotifySurpriseAttack on all unit members.
			}

			if ( newTarget.MyUnit != None )
				Regarding = newTarget.MyUnit;
			else
				Regarding = newTarget;

			SpeakEnemySighted( newTarget, Regarding );
			//WGPawn.NotifyCombatStarted();
			if ( SalutationsController != None )
				SalutationsController.StopTrackingPlayer();
		}
	}
	else
	{		
		// We already know about this target, but update our contact time for him in case he has been ignored.
		// Don't set the contacted time unless target is visible.
		if (	bDefinitelySeeTarget || 
				( TargetQueue[ndxTarget].TargetExposureToMe >= 0.5 && TargetQueue[ndxTarget].TargetOutOfViewRating <= 0.5 ) )
		{
			SetContactedTarget( ndxTarget );
		}
	}
}

//---------------------------------------------------------
//	NotifyTargetRemovedFromQueue
//---------------------------------------------------------
event NotifyTargetRemovedFromQueue()
{
	local gbxPawn OneEnemy;
	local bool bMultiplayer, bAllEnemiesDead;
	local int ndx;

	if( WGPawn != None && TargetQueue.Length == 0 )
	{
		bMultiplayer = WGPawn.MyUnit != None && WGPawn.MyUnit.IsA('MultiplayerUnit');

		// Loop through the pawn cache, examining all enemies.  
		// If none are left alive, say, "I think we got 'em all!"
		bAllEnemiesDead = true;

		if ( bMultiplayer)
			ndx = WGPawn.GetNextEnemyByTeam( MultiplayerUnit(WGPawn.MyUnit).Team, 0, OneEnemy );
		else
			ndx = WGPawn.GetNextEnemyByTeam( WGPawn.PawnTeam, 0, OneEnemy );

		while( ndx != -1 )
		{
			if ( !OneEnemy.IsDead() )
			{
				bAllEnemiesDead = false;
				break;
			}
			if ( bMultiplayer)
				ndx = WGPawn.GetNextEnemyByTeam( MultiplayerUnit(WGPawn.MyUnit).Team, ndx, OneEnemy );
			else
				ndx = WGPawn.GetNextEnemyByTeam( WGPawn.PawnTeam, ndx, OneEnemy );
		}

		if ( bAllEnemiesDead )
		{
			SpeakAllEnemiesDead();

			// are we configured to hold fire in this game?, if so, reset the HoldFireTime...
			if (Level.Game.bHoldFire && (Level.Game.fHoldFireTime > 0.0f))
				Level.Game.fHoldFireTime = 0.0f;
		}
	}
}

//---------------------------------------------------------
//	RemoveTargetFromQueue
//---------------------------------------------------------
function RemoveTargetFromQueue( Pawn aTarget )
{
	local int ndxTarget;

	if ( aTarget == None )
		return;

	ndxTarget = FindTargetInQueue( aTarget );

	if( ndxTarget >= 0 )
	{
		TargetQueue.Remove( ndxTarget, 1 );
		if ( bUseAIDebugging && AITracker != None )
		{
			AITracker.RemoveEnemy( ndxTarget );
		}

		NotifyTargetRemovedFromQueue();
	}
}


//---------------------------------------------------------
//	EnemyCanSeeMe
//---------------------------------------------------------
function bool EnemyCanSeeMe()
{
	local int ndx;

	ndx = FindTargetInQueue( Enemy );
	
	if( ndx >= 0 )
	{
		return TargetQueue[ ndx ].MyExposureToTarget > 0.0f;
	}
	return false;
}

//---------------------------------------------------------
//	CanSeeEnemy
//---------------------------------------------------------
function bool CanSeeEnemy()
{
	local int ndx;

	ndx = FindTargetInQueue( Enemy );

	if( ndx >= 0 )
	{
		return	( TargetQueue[ndx].bIgnored == 0 ) && 
				TargetQueue[ndx].TargetExposureToMe > 0.0;
	}
	return false;
}

//---------------------------------------------------------
//	DistanceToEnemy
//---------------------------------------------------------
function float DistanceToEnemy()
{
	if( Enemy != None )
	{
		return VSize( Enemy.Location - Pawn.Location );
	}
	else
	{
		Log( name $ "<" $ GetStateName() $ ">.DistanceToEnemy() ERROR: called with Enemy == None.", 'mind' );
		return -1.0;
	}
}

//---------------------------------------------------------
//	ShouldMelee
//---------------------------------------------------------
function bool ShouldMelee()
{
	local Vector FORMC;

	if ( WGPawn.MyUnit != None )
	{
		if ( WGPawn.MyUnit.FormationCenter != None )
		{
			if ( WGPawn.MyUnit.FormationCenter.bIsNavigationPoint )
				FORMC = NavigationPoint( WGPawn.MyUnit.FormationCenter ).Location;
			else if ( WGPawn.MyUnit.FormationCenter.bIsNavigationPointLite )
				FORMC = NavigationPointLite( WGPawn.MyUnit.FormationCenter ).Location;
		}

		return
				Enemy != None &&
				Enemy.IsA( 'gbxPawn' ) && gbxPawn( Enemy ).CanBeMeleed() &&
				//EnemyCanSeeMe() &&
				CanSeeEnemy() &&
				DistanceToEnemy() < CombatRadius_Melee &&
				( WGPawn.MyUnit.FormationCenter == None || VSize( Enemy.Location - FORMC ) <= CombatRadius_MaxMeleePursuit ) &&
				!EnemyIsOnADifferentLevel() &&
				( IsFalse( MeleeAttemptFailed ) || TimeSinceRaised( MeleeAttemptFailed ) > 3.0 );	
	}
	else
	{
		return false;
	}
}

//---------------------------------------------------------
//	ShouldFrenzy
//---------------------------------------------------------
function bool ShouldFrenzy()
{
	return
		Enemy != None &&
		EnemyCanSeeMe() &&
		CanSeeEnemy() &&
		DistanceToEnemy() < CombatRadius_NoFFC
		&& !EnemyIsOnADifferentLevel();
}

//---------------------------------------------------------
//	IsFrenzied
//---------------------------------------------------------
function bool IsFrenzied()
{
	return IsInState( 'Frenzied' );
}

//---------------------------------------------------------
//	ShouldAssault
//---------------------------------------------------------
function bool ShouldAssault()
{
	return bShouldAssault;	
}

//---------------------------------------------------------
//	EnemyIsOnADifferentLevel
//---------------------------------------------------------
function bool EnemyIsOnADifferentLevel()
{
	if ( Enemy == None || WGPawn == None )
		return false;

	return ( Abs( Enemy.Location.Z - WGPawn.Location.Z ) > 200.0 );
}

//---------------------------------------------------------
//	NotifyTargetOrder
//---------------------------------------------------------
function NotifyTargetOrder(Unit targetUnit)
{
	local int i;

	if (targetUnit == None)
		return;

	LogSelective( "NotifyTargeting." );

	// When a target order is issued, always clear out relegations and start fresh.
	ClearRelegations();

	// Is this a new target?  If so, clear the excluded pathnodes list.
	if ( targetUnit != LastAssignedTargetUnit )
	{
		ExclusionTracker.ClearList();
		LastAssignedTargetUnit = targetUnit;
	}

	SetFlagValue( TargetOrderRulesInEffect, false );	// To ensure that the "raised" time gets reset...
	SetFlagTrueTimed( TargetOrderRulesInEffect, TargetOrderRulesDuration );

	// notify this member about all Targets in the targetUnit...
	for (i = 0; i < targetUnit.NumMembers; i++)
	{
		AddTarget( targetUnit.Members[i], true );
	}

	// Think now, possibly ahead of schedule.
	Timer();
	
	FiringController.NotifyTargeting();
	
	TimeLastShotAtAssignedUnit = 0.0f;
}

//---------------------------------------------------------
//	NotifyTargetOrderRemoved
//---------------------------------------------------------
function NotifyTargetOrderRemoved()
{
	SetFlagValue( TargetOrderRulesInEffect, false );
}

//---------------------------------------------------------
//	NotifyAssaultOrder
//---------------------------------------------------------
function NotifyAssaultOrder(Unit targetUnit)
{
	local int i;

	if (targetUnit == None)
		return;

	LogSelective( "NotifyAssaulting." );

	// notify this member about all Targets in the targetUnit...
	for (i = 0; i < targetUnit.NumMembers; i++)
	{
		AddTarget( targetUnit.Members[i], true );
	}

	// Think now, possibly ahead of schedule.
	Timer();
}

//---------------------------------------------------------
//	HasTargetOrder
//---------------------------------------------------------
function bool HasTargetOrder()
{
	return WGPawn.MyUnit.HasTargetOrder();
}

//---------------------------------------------------------
//	TimeSinceTargetOrderGiven
//---------------------------------------------------------
function float TimeSinceTargetOrderGiven()
{
	return WGPawn.MyUnit.TimeSinceTargetOrderGiven();
}

//---------------------------------------------------------
//	EnemyIsInTargetUnit
//---------------------------------------------------------
function bool EnemyIsInTargetUnit()
{
	return WGPawn.MyUnit.IsInTargetUnit( gbxPawn( Enemy ) );
}

//---------------------------------------------------------
//	NotifyPrepareAssault
//---------------------------------------------------------
function bool HasFreeOpBurst()
{
	return WGPawn.MyUnit.HasFreeOpBurst();
}

//---------------------------------------------------------
//	NotifyAssaultCommand
//---------------------------------------------------------
function NotifyAssaultCommand()
{
	bShouldAssault = true;

	LogSelective( "NotifyAssaultCommand." );
	if ( FiringController != None )
	{		
		FiringController.NotifyPrepareAssault();
	}	

	NotifyFormationCenterChange();
}

//---------------------------------------------------------
//	StopAssault
//---------------------------------------------------------
function StopAssault()
{
	bShouldAssault = false;
	FiringController.NotifyStopAssaulting();
}

//---------------------------------------------------------
//	IsAssaulting
//---------------------------------------------------------
function bool IsAssaulting()
{
	return IsInState( 'Assaulting' );
}

//---------------------------------------------------------
//	NotifyFiringFromCoverDone
//---------------------------------------------------------
function NotifyFiringFromCoverDone()
{
	Log( name $ "<" $ GetStateName() $ ">.NotifyFiringFromCoverDone(): ERROR Called outside of FiringFromCover state.", 'Mind' );
}

//---------------------------------------------------------
//	FindWorstThreats
//---------------------------------------------------------
function FindWorstThreats()
{
	local int i, j, ndx;
	local bool bAlreadyKnown;
	local array< gbxPawn > LastThreats;

	for( i = 0; i < WorstThreats.Length; ++i )
		LastThreats[i] = WorstThreats[i].Target;

	// Scan the queue for the targets with the highest priority.

	WorstThreats.Remove( 0, WorstThreats.Length );

	for( i = 0; i < TargetQueue.Length; ++i )
	{
		// Try to add this as a worst threat.
		AddWorstThreat( i );
	}

	// TBD: Check if this cycle added any new threats that were unknown before.
	for( ndx = 0; ndx < WorstThreats.Length; ++ndx )
	{
		bAlreadyKnown = false;

		for( j = 0; j < LastThreats.Length; ++j )
		{
			if ( LastThreats[ j ] == WorstThreats[ ndx ].Target )
			{
				bAlreadyKnown = true;
				break;
			}
		}

		if ( !bAlreadyKnown )
			break;
	}

	// Copy the threats' locations into the ThreatLocations array, which will be used in FindBestDestination calls.
	ThreatLocations.Length = WorstThreats.Length;
	for( i = 0; i < WorstThreats.Length; ++i )
	{
		ThreatLocations[ i ] = WorstThreats[ i ].Target.Location;
	}

	// If maneuvering toward a destination node, repeat the last node search if any new threats have been determined.
	if ( !bAlreadyKnown && IsNavigating() )
	{
		RepeatLastNodeSearch();
	}
}

//---------------------------------------------------------
//	IsInWorstThreats
//---------------------------------------------------------
function bool IsInWorstThreats( Pawn aPawn )
{
	local int i;

	for( i = 0; i < WorstThreats.Length; ++i )
	{
		if( WorstThreats[ i ].Target == aPawn )
		{
			return true;
		}
	}

	return false;
}

//---------------------------------------------------------
//	AddWorstThreat
//---------------------------------------------------------
function AddWorstThreat( int ndxTarget )
{
	local int i;

	// GBX:naj - Don't add targets that are marked "ignore me."
	if ( TargetQueue[ ndxTarget ].bIgnored == 1 )
		return;

	// Find which worst threat this target is even worser than. (sic)
	for( i = WorstThreats.Length - 1; i >= 0; --i )
	{
		if( WorstThreats[ i ].TargetPriority > TargetQueue[ ndxTarget ].TargetPriority )
		{
			// This worst threat is worse than the target. If the target is to be added, it will
			// have to be added after this.
			break;
		}
	}

	++i;

	// Don't add this threat off the back end of the array's limit, but do add it if it's in the middle or if the array isn't too long yet.
	if( WorstThreats.Length < MAX_WORST_THREATS || i < ( WorstThreats.Length - 1 ))
	{
		WorstThreats.Insert( i, 1 );
		WorstThreats[ i ] = TargetQueue[ ndxTarget ];
	}

	// Truncate any extra threats so the array doesn't get too long.
	if( WorstThreats.Length > MAX_WORST_THREATS )
	{
		WorstThreats.Remove( MAX_WORST_THREATS, WorstThreats.Length - MAX_WORST_THREATS );
	}
}

//---------------------------------------------------------
//	GetSuppressionLevel
//---------------------------------------------------------
function ESuppressionLevel GetSuppressionLevel()
{
	if( WGPawn.MyUnit == None || UnitControllerAI( WGPawn.MyUnit.MyUnitController ) == None )
	{
		return SL_UNSUPPRESSED;
	}
	else
	{
		return UnitControllerAI( WGPawn.MyUnit.MyUnitController ).GetSuppressionLevel();
	}
}

//---------------------------------------------------------
//	IsTerrified
//---------------------------------------------------------
event bool IsTerrified()
{
	local Pawn PlayerPawn;

	// Must have been flanked and the unit-controller must think we're terrified.
	if ( WGPawn.MyUnit != None && WGPawn.MyUnit.MyUnitController != None )
	{
		if(  WGPawn.MyUnit.MyUnitController.IsTerrified() )
		{
			PlayerPawn = WGPawn.MyUnit.GetControllingPlayerController().Pawn;
			Level.TheAISpeechManager.PlaySpeech(
				WGPawn,
				PlayerPawn,
				'Horror',
				,
				,
				0.3,
				WGPawn.MyUnit,
				0.5,
				8.0
			);
			return true;
		}
		else
		{
			return false;
		}
	}
	else
	{
		return false;
	}
}

event bool IsBeingFlankedByAssaulter( gbxPawn Assaulter )
{
	return IsTerrified() && WGPawn.MyUnit.MyUnitController.PawnIsOnUnitFlank( Assaulter );
}

//---------------------------------------------------------
//	IsBerserk
//---------------------------------------------------------
function bool IsBerserk()
{
	if( WGPawn.MyUnit == None || UnitControllerAIInfantry( WGPawn.MyUnit.MyUnitController ) == None )
	{
		return false;
	}
	else
	{
		return UnitControllerAIInfantry( WGPawn.MyUnit.MyUnitController ).IsBerserk();
	}
}

//---------------------------------------------------------
//	NotifySuppressed
//---------------------------------------------------------
function NotifySuppressed() 
{
	// GBX:naj - bug 8368.
	if ( Level.Game.GameReplicationInfo.GameType != GT_MULTIPLAYER )
	{
		MinNoticeSneakerDist *= NoticeSneakerShrinkFactor;
		MaxNoticeSneakerDist *= NoticeSneakerShrinkFactor;
	}

	FiringController.NotifySuppressed();
	LastSwitchedCoverTime = Level.TimeSeconds;	// Reset the timer for German "antsy-ness."
}

//---------------------------------------------------------
//	NotifyRally
//---------------------------------------------------------
function NotifyRally()
{
	// GBX:naj - bug 8368.
	if ( Level.Game.GameReplicationInfo.GameType != GT_MULTIPLAYER )
	{
		MinNoticeSneakerDist = Default.MinNoticeSneakerDist;
		MaxNoticeSneakerDist = Default.MaxNoticeSneakerDist;
	}

	FiringController.NotifyRally();
}

//---------------------------------------------------------
//	GetWorstThreatLocation
//---------------------------------------------------------
function Vector GetWorstThreatLocation()
{
	if( WorstThreats.Length > 0 )
	{
		return WorstThreats[ 0 ].Target.Location;
	}
	else
	{
		return vect( 0, 0, 0 );
	}
}

//---------------------------------------------------------
//	IsInCombat
//---------------------------------------------------------
function bool IsInCombat()
{
	return TargetQueue.Length > 0 && Enemy != None;
}

/////////////////////////////////////////////////////////////////////////
// Perception
/////////////////////////////////////////////////////////////////////////


// Push perceptions

//---------------------------------------------------------
//	SeeGrenade
//---------------------------------------------------------
function SeeGrenade( gbxExplosive Grenade, bool msgFromGrenade )
{
	local int i;
	local bool bRememberGrenade;
	local PerceptionGrenadeNotify GrenadeNotification;
	local Pawn PlayerPawn;

	if ( Grenade == None || Grenade.bDeleteMe )
		return;

	// See if we already know about this grenade
	for(i = 0; i < PerceivedGrenades.Length; i++ )
	{
		if( PerceivedGrenades[i] == Grenade )
		{
			return;
		}
	}

	if (Level.Game.bHoldFire && (WGPawn.PawnTeam == TEAM_US))  // is this game configured to hold fire?...
	{
		Level.Game.fHoldFireTime = Level.TimeSeconds;  // let 'em have it!
	}

	if( VSize(Grenade.Velocity) > 0.0f )
		WGPawn.SetLookingAtTarget( Grenade );

	// If the message came from the grenade, tell everyone around us about it
	if( msgFromGrenade )
	{
		// Create the message if I haven't already.  The message will be sent in the global timer.
		GrenadeNotification = new( None ) class'PerceptionGrenadeNotify';
		GrenadeNotification.vLocation = Grenade.Location;
		GrenadeNotification.bUseSenderLocation = false;
		GrenadeNotification.bHasLocation = true;
		GrenadeNotification.BroadcastRadius = Grenade.DamageRadius;
		GrenadeNotification.Grenade = Grenade;

		SendGBXMessage( GrenadeNotification );

		// Talk about this grenade
		// TBD: Say something about TNT as well.
		if ( Grenade.IsA( 'gbxGrenade' ) )
		{
			PlayerPawn = WGPawn.MyUnit.GetControllingPlayerController().Pawn;
			Level.TheAISpeechManager.PlaySpeech(
				WGPawn,
				PlayerPawn,
				'IncomingGrenade',
				,
				,
				0.0,
				WGPawn.MyUnit,
				0.5,
				8.0
			);
		}

		// I know grenades will continuously notify, so let's only take action if the grenade is currently dangerous.
		// I will be sending out a notification though, even if I'm not in danger from the grenade
		if( IsGrenadeDangerous(Grenade) )
		{
			//log("****SJP: "$Pawn$" NOTICED GRENADE! GLocation: "$Grenade.Location$" Velocity: "$Grenade.Velocity  $"    STATE:"$GetStateName(), 'naj');
			bRememberGrenade = true;
		}
	}
	else
	{
		// It's possible that I was told about this grenade, but it won't actually hurt me.
		if( IsGrenadeDangerous(Grenade) )
		{
			//log("****SJP: "$Pawn$" **NOTIFIED** of GRENADE!", 'naj');
			bRememberGrenade = true;
		}
	}

	if( bRememberGrenade )
	{
		PerceivedGrenades.Length = PerceivedGrenades.Length + 1;
		PerceivedGrenades[ PerceivedGrenades.Length - 1 ] = Grenade;

		//log("****SJP: "$Pawn$" **REMEMBERING**  GRENADE!"$bFleeGrenades $" "$bDontLetMindTick $"    STATE:"$GetStateName(), 'naj');
		if( bFleeGrenades && !IsInState( 'FleeGrenade' ) && !bDontLetMindTick)  //make sure not to do any of this if we are climbing a wall
		{
			//NAC: if we are in a frenzied state get the distance between me and the owner of the grenade...if we are greater than the melee distance flee grenade, else continue with the melee beat down!
			if (IsInState('Frenzied'))
			{
				if (VSizeSquared(gbxGrenade(Grenade).PreviousAttachedToPawn.Location-WGPawn.Location) > (CombatRadius_Melee * CombatRadius_Melee))
				{
					RequestPawnToStand();  //NAC: A grenade has been thrown, stand up and MOVE!
					GotoState( 'FleeGrenade' ); //force pawn into flee grenade state
				}
				else 
				{
					FleeGrenadeAction(); //this function does nothing while in frenzied state...this is what we want if we within melee range.
			}
			}
			else
			{
			FleeGrenadeAction();
		}
		}
		else
		{
			log( "*****SJP: "$Pawn$" already in FleeGrenade state.", 'naj' );
		}
	}
}




//---------------------------------------------------------
//	SeeTNT
//---------------------------------------------------------
function SeeTNT( gbxExplosive TNT)
{
	local int i;

	if ( TNT == None || TNT.bDeleteMe )
		return;

	// See if we already know about this TNT
	for(i = 0; i < PerceivedGrenades.Length; i++ )
	{
		if( PerceivedGrenades[i] == TNT )
		{
			return;
		}
	}

	if (Level.Game.bHoldFire && (WGPawn.PawnTeam == TEAM_US))  // is this game configured to hold fire?...
	{
		Level.Game.fHoldFireTime = Level.TimeSeconds;  // let 'em have it!
	}

	iTNTindex = PerceivedGrenades.Length;
	PerceivedGrenades.Length = PerceivedGrenades.Length + 1;
	PerceivedGrenades[ iTNTindex ] = TNT;

	if( bFleeGrenades && !IsInState( 'FleeTNT' ) && TNT.flFuseTime < 5.0)
	{
			GotoState( 'FleeTNT' );//FleeGrenadeAction();
	}
	else
	{
		log( "*****SJP: "$Pawn$" already in FleeGrenade state.", 'SJP' );
	}
}




//---------------------------------------------------------
//	FleeGrenadeAction
//---------------------------------------------------------
function FleeGrenadeAction()
{
	GotoState( 'FleeGrenade' );
}

//---------------------------------------------------------
//	SeeImpact
//---------------------------------------------------------
function SeeImpact( Pawn instigator, float impactSeverity, float distance )
{
	local int ndx;

	if( !Pawn.SameTeamAs( Instigator ) )
	{		
		ConsiderPossibleEnemy( instigator );

		// Note that this guy actually attacked me.
		ndx = FindTargetInQueue( Instigator );
		if( ndx >= 0 )
		{
			TargetQueue[ ndx ].ActualAttackLevel += 0.2;
			TargetQueue[ ndx ].DistractionLevel = 1.0;
			SetContactedTarget( ndx );
			TellFriendsAboutAttackLevel( Instigator, TargetQueue[ ndx ].ActualAttackLevel );
		}

		if (Level.Game.bHoldFire && (WGPawn.PawnTeam == TEAM_US))  // is this game configured to hold fire?...
		{
			Level.Game.fHoldFireTime = Level.TimeSeconds;  // let 'em have it!
		}
	}

	MaybePlayReactToBulletsAnim( FClamp( distance / 200.0, 0, 1 ));
}

//---------------------------------------------------------
//	TellFriendsAboutAttackLevel
//---------------------------------------------------------
function TellFriendsAboutAttackLevel( Pawn anAttacker, float anAttackLevel )
{
	local PerceptionIncreasedAttackLevel percep;

	if ( !bMatchAttackLevels )
		return;

	percep = new( None ) class'PerceptionIncreasedAttackLevel';
	percep.Attacker = anAttacker;
	percep.AttackLevel = anAttackLevel;
	WGPawn.PostGBXMessage( percep );
}

//---------------------------------------------------------
//	MatchFriendsAttackLevel
//---------------------------------------------------------
function MatchFriendsAttackLevel( Mind FriendMind, Pawn anAttacker, float anAttackLevel )
{
	// Someone else near me just updated their attack level for aTarget.  Make sure yours is at least that high.
	// If yours is higher, tell the sender to match yours.
	local int ndx;

	if ( !bMatchAttackLevels || FriendMind == Self )
		return;

	ndx = FindTargetInQueue( anAttacker );
	if( ndx >= 0 )
	{
		if ( anAttackLevel > TargetQueue[ndx].ActualAttackLevel )
		{
			TargetQueue[ ndx ].ActualAttackLevel = anAttackLevel;			
		}
		else if ( anAttackLevel < TargetQueue[ndx].ActualAttackLevel )
		{
			FriendMind.MatchFriendsAttackLevel( Self, anAttacker, TargetQueue[ ndx ].ActualAttackLevel );
		}

		//TargetQueue[ ndx ].LastContactTime = Level.TimeSeconds;
		SetContactedTarget( ndx );
	}
	else if ( anAttacker != None && anAttacker.IsA( 'gbxPawn' ) )
	{
		// New target!
		AddTarget( gbxPawn( anAttacker ) );
		MatchFriendsAttackLevel( FriendMind, anAttacker, anAttackLevel );
	}
}

//---------------------------------------------------------
//	SeePawn
//---------------------------------------------------------
function SeePawn( Pawn Seen )
{
	// Log( Name $ "(" $ Pawn.name $ ").SeePawn( " $ Seen.name $ " )", 'Mind' );
	ConsiderPossibleEnemy( Seen );
}


//---------------------------------------------------------
//	HearNoise
//---------------------------------------------------------
function HearNoise( float Loudness, Actor NoiseMaker )
{
	local Pawn PlayerPawn;

	// Log( Name $ "(" $ Pawn.name $ ").HearNoise( " $ Loudness $ ", " $ NoiseMaker $ " )", 'Mind' );
	if( NoiseMaker.IsA( 'Pawn' ))
	{
		// TODO do uncertainty.
		if( Loudness > 0.15 )
		{
			PlayerPawn = WGPawn.MyUnit.GetControllingPlayerController().Pawn;
			Level.TheAISpeechManager.PlaySpeech(
				WGPawn,
				PlayerPawn,
				'HeardNoise',
				,
				,
				0.0,
				Self,
				0.5,
				3.0
			);
			SeePawn( Pawn( NoiseMaker ));
		}
	}
}

//---------------------------------------------------------
//	SeePlayer
//---------------------------------------------------------
function SeePlayer( Pawn Seen )
{
	// Log( Name $ "(" $ Pawn.name $ ").SeePlayer( " $ Seen.name $ " )", 'Mind' );
	SeePawn( Seen );
}

//---------------------------------------------------------
//	SeeMonster
//---------------------------------------------------------
function SeeMonster( Pawn Seen )
{
	// Log( Name $ "(" $ Pawn.name $ ").SeeMonster( " $ Seen.name $ " )", 'Mind' );
	SeePawn( Seen );
}

//---------------------------------------------------------
//	NotifyKilled
//---------------------------------------------------------
function NotifyKilled(Controller Killer, Controller Killed, Pawn Other)
{	
	local int ndx;
	local Pawn PlayerPawn;

	if ( Killed == Self )
	{
		PlayerPawn = WGPawn.MyUnit.GetControllingPlayerController().Pawn;
		Level.TheAISpeechManager.PlaySpeech(
			WGPawn,
			None,
			'Death',
			,
			,
			0.0,
			Self,
			0.5,
			3.0
		);
	}
	else if ( Killer == Self )
	{
		SpeakMyTargetDied( Other );
	}
	else if ( Other != None && Killer != None && Other != WGPawn )
	{
		if ( Other.SameTeamAs( WGPawn ) )
		{
			if ( IsTrue( FriendlyDead ) )
				SetFlagValue( MultipleFriendliesDead, true );
			else
				SetFlagValue( FriendlyDead, true );
			SpeakAllyDied( Other );
		}
		else
		{
			// Is this a tank commander?  We're not interested in him--just in his tank.
			if ( Other.IsA( 'gbxPawn' ) && gbxPawn( Other ).IsTankCommander() )
			{
				Other = gbxPawn( Other ).GetMyTank();
			}

			// This is an enemy.  If he is in my targeted unit, reset the flag that determines 
			// when to start suggesting that we should flank.
			if ( IsTrue( TargetSuppressed ) && LastEnemyUnit != None && Other.IsA( 'gbxPawn' ) && gbxPawn( Other ).MyUnit == LastEnemyUnit )
			{
				SetInitialFlagValue( TargetSuppressed, false );
				SetFlagValue( TargetSuppressed, true );
			}

			// Get this target from the TargetQueue and check its exposure rating to determine if we should even say anything.
			ndx = FindTargetInQueue( Other );

			if ( ndx >= 0 && TargetQueue[ ndx ].TargetExposureToMe > 0 )
			{
				SpeakEnemyDied( Other );
			}
		}
	}

	Super.NotifyKilled( Killer, Killed, Other );
}

//---------------------------------------------------------
//	SeePawnDied
//---------------------------------------------------------
function SeePawnDied( Pawn Seen )
{
	// Seeing your friends get killed.
	if ( Seen != WGPawn && Seen.Controller != None && !Seen.Controller.IsA( 'ScriptedController' ) )
	{
		if( Pawn.SameTeamAs( Seen ) )
		{
			if ( IsTrue( FriendlyDead ) )
				SetFlagValue( MultipleFriendliesDead, true );
			else
				SetFlagValue( FriendlyDead, true );

			SpeakAllyDied( Seen );

			if (Level.Game.bHoldFire && (WGPawn.PawnTeam == TEAM_US))  // is this game configured to hold fire?...
			{
				Level.Game.fHoldFireTime = Level.TimeSeconds;  // let 'em have it!
			}
		}
		else
		{
			SpeakEnemyDied( Seen );
		}
	}
}

//---------------------------------------------------------
//	SpeakEnemySighted
//---------------------------------------------------------
function SpeakEnemySighted( gbxPawn newTarget, Object Regarding )
{
	local name SpeechName;
	local Pawn PlayerPawn;

	// Is this target a tank?
	if ( newTarget.IsTank() )
	{
		SpeechName = 'SeeEnemyTank';
	}
	else
	{
		// Is this target manning an emplaced weapon, like an MG42 or an AT gun? - or the new Pak88
		if ( ( newTarget.bIsManningTurret || newTarget.bIsManning88 ) && newTarget.Turret != None )
		{
			if ( newTarget.Turret.IsMortar() )
			{
				SpeechName = 'MortarTeam';
			}
			else if ( newTarget.Turret.IsAntiTank() )
			{
				SpeechName = 'SeeAT';
			}
			else if ( newTarget.Turret.IsPak88() )
			{
				SpeechName = 'SeePak88';
			}
			else if ( newTarget.Turret.IsMachineGun() )
			{
				SpeechName = 'SeeMG42';
			}
			else
			{
				SpeechName = 'EnemySighted';
			}
		}
		else
		{
			// Is this enemy carrying a Panzerfaust or Bazooka?
			if ( newTarget.Weapon != None && newTarget.Weapon.IsA( 'gbxWeapon' ) && gbxWeapon( newTarget.Weapon ).IsRocketLauncher() )
			{
				SpeechName = 'RocketLauncherSighted';
			}
			else 
			{
				if( TargetQueue.Length == 1 )	// Is this the first enemy we've seen?  Say so!
				{				
					SpeechName = 'EnemySighted';
				}			
				else	// It may not be the first enemy, but report anyway.
				{
					SpeechName = 'EnemyFireTeam';
				}
			}
		}
	}

	PlayerPawn = WGPawn.MyUnit.GetControllingPlayerController().Pawn;
	Level.TheAISpeechManager.PlaySpeech(
		WGPawn,
		PlayerPawn,
		SpeechName,
		,
		,
		0.2,
		Regarding,
		3.0,
		5.0
	);
	//log( "Mind::SpeakEnemySighted() - PlaySpeech( " $ WGPawn $ ", " $ PlayerPawn $ ", " $ SpeechName, 'RSC' );
}

//---------------------------------------------------------
//	SpeakOuttaTheWayBuddy
//---------------------------------------------------------
function SpeakOuttaTheWayBuddy( gbxPawn BlockingPlayer )
{
	Level.TheAISpeechManager.PlaySpeech(
		WGPawn,
		BlockingPlayer,
		'OuttaTheWay',
		,
		,
		0.0,
		BlockingPlayer,
		3.0,
		5.0
	);
}

//---------------------------------------------------------
//	SpeakCoveringFire
//---------------------------------------------------------
function SpeakCoveringFire()
{	
	local Pawn PlayerPawn;
	PlayerPawn = WGPawn.MyUnit.GetControllingPlayerController().Pawn;
	Level.TheAISpeechManager.PlaySpeech(
		WGPawn,
		PlayerPawn,
		'CoveringFire',
		,
		,
		0.0,
		WGPawn.MyUnit,
		3.0,
		3.0
	);
}

//---------------------------------------------------------
//	SpeakCantHitAssignedTarget
//---------------------------------------------------------
function SpeakCantHitAssignedTarget()
{
	local Pawn PlayerPawn;
	PlayerPawn = WGPawn.MyUnit.GetControllingPlayerController().Pawn;
	Level.TheAISpeechManager.PlaySpeech( 
		WGPawn,
		PlayerPawn,
		'CantHitTarget',
		,
		, 
		0.0, 
		WGPawn, 
		3.0, 
		2.0 );
}

//---------------------------------------------------------
//	SpeakAllEnemiesDead
//---------------------------------------------------------
function SpeakAllEnemiesDead()
{
	local Name speechName;
	local Pawn PlayerPawn;

	if ( WGPawn.MyUnit != None && WGPawn.MyUnit.GetNumLivingMembers() > 1 )
		speechName = 'SquadKilled';
	else
		speechName = 'AllEnemiesDead';

	PlayerPawn = WGPawn.MyUnit.GetControllingPlayerController().Pawn;

	Level.TheAISpeechManager.PlaySpeech(
		WGPawn,
		PlayerPawn,
		speechName,
		, //'AffirmativeResponse',
		,
		3.0,
		WGPawn.MyUnit,
		10.0,
		5.0
	);

	// Make some wise-ass remark after a few seconds.
	if ( IsFalse( FriendlyDead ) )
	{
		Level.TheAISpeechManager.PlaySpeech( 
			WGPawn, 
			PlayerPawn,
			'CommentaryUpperHand',
			,
			, 
			5.0, 
			WGPawn.MyUnit, 
			10.0, 
			20.0 
		);
	}
	else
	{
		Level.TheAISpeechManager.PlaySpeech( 
			WGPawn, 
			PlayerPawn,
			'CommentaryLowerHand',
			,
			, 
			5.0, 
			WGPawn.MyUnit, 
			10.0, 
			20.0 
		);
	}
}

//---------------------------------------------------------
//	SpeakWarnPlayerGetDown
//---------------------------------------------------------
function SpeakWarnPlayerGetDown( Pawn PlayerPawn )
{
	if ( PlayerPawn != None && PlayerPawn.IsHumanControlled() )
	{
		Level.TheAISpeechManager.PlaySpeech(
			WGPawn,
			PlayerPawn,
			'NearMiss',
			,
			,
			1.0,
			PlayerPawn,
			3.0,
			10.0
		);
	}
}

//---------------------------------------------------------
//	SpeakAllyHurt
//---------------------------------------------------------
function SpeakAllyHurt( Pawn Ally )
{
	local Pawn PlayerPawn;
	if ( Ally != None )
	{
		if ( Ally.IsHumanControlled() )
		{
			PlayerPawn = WGPawn.MyUnit.GetControllingPlayerController().Pawn;
			Level.TheAISpeechManager.PlaySpeech(
				WGPawn,
				PlayerPawn,
				'PlayerWounded',
				'BuddyWounded',
				,
				1.0,
				Ally,
				3.0,
				4.0
			);
		}
		else
		{
			Level.TheAISpeechManager.ShoutNameOf( WGPawn, PlayerPawn, Ally, 'BuddyWounded', 1.0, 3.0, 4.0 );
		}
	}
}

//---------------------------------------------------------
//	SpeakAllyDied
//---------------------------------------------------------
function SpeakAllyDied( Pawn Ally )
{
	local Pawn PlayerPawn;
	if ( Ally != None )
	{
		PlayerPawn = WGPawn.MyUnit.GetControllingPlayerController().Pawn;
		if( Ally.IsA('Tank') )
		{
			Level.TheAISpeechManager.PlaySpeech(
				WGPawn,
				PlayerPawn,
				'AlliedTankKilled',
				,
				,
				1.0,
				WGPawn.MyUnit,
				2.0,
				15.0
			);
		}
		else
		{
			Level.TheAISpeechManager.ShoutNameOf( 
				WGPawn, 
				PlayerPawn, 
				Ally, 
				'BuddyDown', 
				1.0, 
				3.0, 
				4.0 
			);
		}
	}
}

//---------------------------------------------------------
//	SpeakEnemyDied
//---------------------------------------------------------
function SpeakEnemyDied( Pawn aTarget )
{
	local name SpeechName;
	local gbxPawn gbxPTarget;
	local Pawn PlayerPawn;

	if ( aTarget != None )
	{
		if ( aTarget.IsA( 'gbxPawn' ) )
		{
			gbxPTarget = gbxPawn( aTarget );
		}

		// Is this target a tank?
		if ( gbxPTarget != None  )
		{
			if( gbxPTarget.IsTank() )
			{
				SpeechName = 'TankKilled';
			}
			else if( gbxPTarget.Turret != None )
			{
				if( gbxPTarget.Turret.IsMachineGun() )
					SpeechName = 'MG42Killed';
				else
					SpeechName = 'EnemyKilled';
			}
			else
			{
				SpeechName = 'EnemyKilled';
			}
		}
		else
		{		
			SpeechName = 'EnemyKilled';
		}

		// Enemy was killed.
		PlayerPawn = WGPawn.MyUnit.GetControllingPlayerController().Pawn;
		Level.TheAISpeechManager.PlaySpeech(
			WGPawn,
			PlayerPawn,
			SpeechName,
			,
			,
			1.0,
			WGPawn.MyUnit,
			2.0,
			15.0
		);
	}
}

//---------------------------------------------------------
//	SpeakMyTargetDied
//---------------------------------------------------------
function SpeakMyTargetDied( Pawn aTarget )
{
	local Pawn PlayerPawn;
	if ( aTarget != None )
	{
		// Enemy was killed.
		PlayerPawn = WGPawn.MyUnit.GetControllingPlayerController().Pawn;
		Level.TheAISpeechManager.PlaySpeech(
			WGPawn,
			PlayerPawn,
			'ConfirmedKill',
			,
			,
			0.8,
			aTarget,
			2.0,
			7.0
		);
	}
}

//---------------------------------------------------------
//	SpeakWeveBeenFlanked
//---------------------------------------------------------
function SpeakWeveBeenFlanked()
{
	local Pawn PlayerPawn;
	if ( !Level.Game.IsPawnOnSameTeamAsPlayer(WGPawn) )
	{
		PlayerPawn = WGPawn.MyUnit.GetControllingPlayerController().Pawn;
		Level.TheAISpeechManager.PlaySpeech(
			WGPawn,
			PlayerPawn,
			'Flanked',
			,
			,
			0.5,
			WGPawn.MyUnit,
			2.0,
			5.0
		);
	}
}

//---------------------------------------------------------
//	SeePawnHit
//---------------------------------------------------------
// NOTE: This function does not really get called all that often...
function SeePawnHit( Pawn Seen )
{
	if ( Seen != WGPawn )
	{
		if( Pawn.SameTeamAs( Seen ))
		{
			SpeakAllyHurt( Seen );

			if (Level.Game.bHoldFire && (WGPawn.PawnTeam == TEAM_US))  // is this game configured to hold fire?...
			{
				Level.Game.fHoldFireTime = Level.TimeSeconds;  // let 'em have it!
			}
		}
		else
		{
			// This is an enemy.  If he is in my targeted unit, reset the flag that determines 
			// when to start suggesting that we should flank.
			if ( IsTrue( TargetSuppressed ) && LastEnemyUnit != None && Seen.IsA( 'gbxPawn' ) && gbxPawn( Seen ).MyUnit == LastEnemyUnit )
			{
				SetInitialFlagValue( TargetSuppressed, false );
				SetFlagValue( TargetSuppressed, true );
			}
		}
	}
}

//---------------------------------------------------------
//	SeePlayerWarningShot
//---------------------------------------------------------
function SeePlayerWarningShot( Pawn PlayerPawn )
{
	if( PlayerPawn != None && Pawn.SameTeamAs( PlayerPawn ))
	{
		SpeakWarnPlayerGetDown( PlayerPawn );

		if (Level.Game.bHoldFire && (WGPawn.PawnTeam == TEAM_US))  // is this game configured to hold fire?...
		{
			Level.Game.fHoldFireTime = Level.TimeSeconds;  // let 'em have it!
		}
	}
}

//---------------------------------------------------------
//	NotifyTakeHit
//---------------------------------------------------------
function NotifyTakeHit(pawn InstigatedBy, vector HitLocation, int Damage, class<DamageType> damageType, vector Momentum)
{
	local PerceptionPawnHit percep;
	local int ndx;
	local Pawn PlayerPawn;

	// Might need to resort targets to prioritize the guy who just shot me.
	bTargetQueueNeedsSort = true;

	Super.NotifyTakeHit( InstigatedBy, HitLocation, Damage, damageType, Momentum );

	FiringController.NotifyTakeHit( InstigatedBy, HitLocation );

	ConsiderPossibleEnemy( InstigatedBy );

	percep = new( None ) class'PerceptionPawnHit';
	percep.PawnHit = Pawn;
	Pawn.PostGBXMessage( percep );


	// Note that this guy actually attacked me.
	PlayerPawn = WGPawn.MyUnit.GetControllingPlayerController().Pawn;
	ndx = FindTargetInQueue( InstigatedBy );
	if( ndx >= 0 )
	{
		TargetQueue[ ndx ].ActualAttackLevel += 1.0;
		TargetQueue[ ndx ].DistractionLevel = 1.0;
		SetContactedTarget( ndx );
		TellFriendsAboutAttackLevel( Instigator, TargetQueue[ ndx ].ActualAttackLevel );
	}

	//if( Damage <= 25 )
	//{
	//	log( "Mind::NotifyTakeHit() - PlaySpeech( 'LowImpactWound' )", 'RSC' );
	//	Level.TheAISpeechManager.PlaySpeech(
	//		WGPawn,
	//		PlayerPawn,
	//		'LowImpactWound',
	//		,
	//		,
	//		0.0,
	//		Self,
	//		1.0,
	//		2.0
	//	);
	//}
	//else
	//{
			log( "Mind::NotifyTakeHit() - PlaySpeech( 'Wounded' )", 'RSC' );
			Level.TheAISpeechManager.PlaySpeech(
				WGPawn,
				PlayerPawn,
				'Wounded',
				,
				,
				0.0,
				Self,
				1.0,
				2.0
			);
	//}
}

//---------------------------------------------------------
//	NotifyNearbyTrace
//---------------------------------------------------------
function NotifyNearbyTrace( Actor Other, vector TouchLocation, vector TouchNormal, vector End, vector Start, vector Extent, int TraceFlags )
{
	local int ndx;
	local vector NearestPoint;		// The nearest point to the pawn that this trace passed through.
	local float MissDistance;		// How far away from me the bullet passed.
	local float MissDistanceRelative;		// How far away from me the bullet passed, scaled and clamped to (0,1)
	local vector TraceNormal;
	local Pawn PlayerPawn;

//	Log( Name $ "(" $ Pawn.Name $ ").NotifyNearbyTrace( " $ Other $ ", ... )", 'Mind' );

	// Ensure the shot came from an enemy.
	if( Pawn.SameTeamAs( Other.Instigator ))
	{
		return;
	}

	TraceNormal = Normal( Start - End );

	NearestPoint = End + TraceNormal * (( Pawn.Location - End ) dot TraceNormal );

	MissDistance = VSize( NearestPoint - Pawn.Location ) - Pawn.CollisionRadius;
	MissDistanceRelative =
		FClamp(
			MissDistance / ( gbxPawn( Pawn ).MyBulletListener.CollisionRadius - Pawn.CollisionRadius ),
			0.0, 1.0 
	);

	ConsiderPossibleEnemy( Other.Instigator );

	// Note that this guy actually attacked me.
	ndx = FindTargetInQueue( Other.Instigator );
	if( ndx >= 0 )
	{
		TargetQueue[ ndx ].ActualAttackLevel += 0.2;
		TargetQueue[ ndx ].DistractionLevel = 1.0;
		SetContactedTarget( ndx );
		TellFriendsAboutAttackLevel( Other.Instigator, TargetQueue[ ndx ].ActualAttackLevel );
	}

	// Notify the unit that a bullet nearly missed me!
	if( WGPawn.MyUnit != None && UnitControllerAI( WGPawn.MyUnit.MyUnitController ) != None )
	{
		UnitControllerAI( WGPawn.MyUnit.MyUnitController ).MemberSawNearbyBullet( Other.Instigator, MissDistanceRelative );
	}

	//log( "Mind::NotifyNearbyTrace() - " $ Level.TimeSeconds $ "-" $ LastTimeNearbyTrace $ ">" $ TimeBetweenSpeeches, 'RSC' );
	//log( "Mind::NotifyNearbyTrace() - Other=" $ Other $ ",MissDistanceRelative" $ MissDistanceRelative, 'RSC' );
	NumTracesPerSpeech++;
	if( Level.TimeSeconds - LastTimeNearbyTrace > TimeBetweenSpeeches )
	{
		PlayerPawn = WGPawn.MyUnit.GetControllingPlayerController().Pawn;

		log( "Mind::NotifyNearbyTrace() - " $ Level.TimeSeconds $ "-" $ LastTimeNearbyTrace $ ">" $ TimeBetweenSpeeches, 'RSC' );
		log( "Mind::NotifyNearbyTrace() - NumTraces=" $ NumTracesPerSpeech, 'RSC' );
		if( NumTracesPerSpeech > 50 )
		{
			// if this is from a gun, just speak about taking fire
			Level.TheAISpeechManager.PlaySpeech(
				WGPawn,
				PlayerPawn,
				'HeavyFire',
				,
				,
				0.0,
				Self,
				1.0,
				2.0
			);
		}
		else
		{
			// if this is from a gun, just speak about taking fire
			Level.TheAISpeechManager.PlaySpeech(
				WGPawn,
				PlayerPawn,
				'ExposedToFire',
				,
				,
				0.0,
				Self,
				1.0,
				2.0
			);
		}

		// save off the time so we dont speak too often
		LastTimeNearbyTrace = Level.TimeSeconds;
		NumTracesPerSpeech=0;
	}

	// Play animations of noticing nearby bullets, depending on how close they are and our suppression level
	MaybePlayReactToBulletsAnim( MissDistanceRelative );
}

function MaybePlayReactToBulletsAnim( float MissDistanceRelative )
{
	local float NearbyBulletAnimChance;
	
	NearbyBulletAnimChance = FClamp(( 1.0 - MissDistanceRelative ) * WGPawn.MyUnit.MyUnitController.GetSuppressionLevelAnalog(), 0.1, 0.75 );

	if( FRand() < NearbyBulletAnimChance && NextNearbyBulletAnimTime < Level.TimeSeconds )
	{
		//log("****** SJP: NearbyBulletAnimChance:"$NearbyBulletAnimChance$" MissDistanceRelative:"$MissDistanceRelative$" Playing anim on "$WGPawn, 'SJP');

		WGPawn.PlayReactToBulletsAnim();

		NextNearbyBulletAnimTime = Level.TimeSeconds + NearbyBulletAnimDelay;
	}
}

//---------------------------------------------------------
//	IsValidEnemy
//---------------------------------------------------------
function bool IsValidEnemy( Pawn aPawn )
{
	if( WGPawn == None )
	{
		Log( "WARNING: " $ name $ ".IsValidEnemy( " $ aPawn $ " ) found WGPawn == None.", 'Mind' );
		return false;
	}

	return (
		aPawn != None &&
		aPawn.Health > 0 &&
		!Pawn.SameTeamAs( aPawn ) &&
		!( aPawn.Controller.IsA( 'WargamePlayerController') && WargamePlayerController( aPawn.Controller ).bNeverEnemy )
	);
}

//---------------------------------------------------------
//	ConsiderPossibleEnemy
//---------------------------------------------------------
function ConsiderPossibleEnemy( Pawn possibleEnemy )
{
	// Log(name $ "(" $ Pawn.name $ ").ConsiderPossibleEnemy(" $ possibleEnemy.name $")", 'Mind');

	if( gbxPawn( possibleEnemy ) != None && IsValidEnemy( possibleEnemy ))
	{
		AddTarget( gbxPawn( possibleEnemy ));
	}
}

//---------------------------------------------------------
//	RejectNTFCall
//---------------------------------------------------------
function bool RejectNTFCall()
{
	if ( IsFalse( NotifyTargetFailureCalled ) )
	{
		// Don't reject; hasn't been called lately.
		SetFlagValue( NotifyTargetFailureCalled, true );
		return false;
	}
	if ( TimeSinceRaised( NotifyTargetFailureCalled ) < MaxSecondsPerNTF )
	{
		LogSelective( "RejectNTFCall: Rejecting because NTF was called really recently..." );
		return true;
	}
	else
	{
		SetFlagValue( NotifyTargetFailureCalled, false );
		return false;
	}
}

//---------------------------------------------------------
//	NotifyTargetFailure
//---------------------------------------------------------
function NotifyTargetFailure( Pawn Target, optional ETargetFailure FailCode, optional gbxPawn TheBlocker )
{	
	if ( Target == None )
	{
		if ( bUseAIDebugging && AITracker != None )
			AITracker.AddFiringFactor( Firing_TargetDead );
		return;
	}

	if ( Target != Enemy )
	{
		FiringController.SetTarget( Enemy );
		return;
	}

	if ( FailCode == FAIL_TargetDead )
	{			
		RemoveTargetFromQueue( Enemy );
		Enemy = None;
		FiringController.SetTarget( None );
	}

	if ( bUseAIDebugging && AITracker != None )
	{
		switch( FailCode )
		{
		case FAIL_None:
			break;
		case FAIL_FriendlyInWay:
			AITracker.AddFiringFactor( Firing_FriendlyInWay );
			break;
		case FAIL_MuzzleBlocked:
			AITracker.AddFiringFactor( Firing_ShotBlocked );
			break;
		case FAIL_TargetDead:
			AITracker.AddFiringFactor( Firing_TargetDead );
			break;
		case FAIL_NoVantage:
			AITracker.AddFiringFactor( Firing_NoVantage );
			break;
		}
	}

	SetFlagValue( VantageLost, true );
}

//---------------------------------------------------------
//	NotifySurpriseAttack
//---------------------------------------------------------
function NotifySurpriseAttack( gbxPawn Attacker, optional gbxPawn Notifier )
{
	local int ndxAttacker;

	// Set the last-contact-time for this attacker to be now, so that
	// we no longer ignore him when he's outside of our field of view.
	ndxAttacker = FindTargetInQueue( Attacker );
	if ( ndxAttacker < 0 )
	{
		AddTarget( Attacker );
		ndxAttacker = FindTargetInQueue( Attacker );
	}
	
	if( ndxAttacker >= 0 )
	{
		SetContactedTarget( ndxAttacker );
	}
}

//---------------------------------------------------------
//	GetCoverCheckCenter
//---------------------------------------------------------
function ActorLite GetCoverCheckCenter()
{
	if( WGPawn.MyUnit != None && WGPawn.MyUnit.FormationCenter != None )
	{
		return WGPawn.MyUnit.FormationCenter;
	}
	else if ( WGPawn != None )
	{
		return WGPawn.MyClaimedNavPoint;
	}
}

//---------------------------------------------------------
//	GrenadeTossCallBack
//---------------------------------------------------------
function GrenadeTossCallBack()
{
	FiringController.GrenadeTossCallBack();
}

/////////////////////////////////////////////////////////////////////////
// Low-level setting determinations
/////////////////////////////////////////////////////////////////////////

//---------------------------------------------------------
//	IsStateSticky
//---------------------------------------------------------
function bool IsStateSticky()
{
	return (Level.TimeSeconds - StateStartTime ) < StateStickTime;
}

//---------------------------------------------------------
//	DecideState
//---------------------------------------------------------
function DecideState()
{
	// Intentionally blank in global.
}

//---------------------------------------------------------
//	DecideWeaponAim
//---------------------------------------------------------
function DecideWeaponAim()
{
	// Intentionally blank in global.
}

//---------------------------------------------------------
//	DecideMaxSpeed
//---------------------------------------------------------
function DecideMaxSpeed()
{
	// Intentionally blank in global.
}

//---------------------------------------------------------
//	DecidePosture
//---------------------------------------------------------
function DecidePosture()
{
	// Intentionally blank in global.
}

//---------------------------------------------------------
//	DecideFacingPolicy
//---------------------------------------------------------
function DecideFacingPolicy()
{
	// Intentionally blank in global.
}

//---------------------------------------------------------
//	BeginState
//---------------------------------------------------------
function BeginState()
{
	StateStartTime = Level.TimeSeconds;

	if ( Pawn != None && WGPawn != None )
	{
		DecidePosture();
		DecideWeaponAim();
		DecideMaxSpeed();
		DecideFacingPolicy();
	}
}

//---------------------------------------------------------
//	LeaveFiringFromCover
//---------------------------------------------------------
function LeaveFiringFromCover( name newState, optional ActorLite NewDestination )
{
	log("NAJ**** ERROR: Mind::LeaveFiringFromCover() global function called.", 'naj');
}

//---------------------------------------------------------
//	FaceAwayFromWalls
//---------------------------------------------------------
function FaceAwayFromWalls()
{
	local int x, i, min, finalMin, size, largestSize;
	local Rotator Temp;
	local byte CoverBits;

	min = -1;
	finalMin = -1;
	size = 0;
	largestSize = 0;

	// GBX:PAD: Ensure that WGPawn and MyClaimedNavPoint exist since otherwise it dumps a bunch of accessed none messages in the log files.
	if ( (WGPawn == None) || (WGPawn.MyRecentlyTouchedNavPoint == None) )
		return;

	//LogSelective( "FaceAwayFromWalls." );

	// Find the largest group of contiguous cover-bits having no cover.  
	// Find the midpoint of this group, and face in that direction.
	// Algorithm: Loop around twice, counting contiguous groups.  After you've
	// gone around a full lap, quit at the first covered bit.
	for ( x = 0; x < 16; ++x )
	{
		//LogSelective( "FaceAwayFromWalls: x="$x );

		// Get the cover bits.  First try the standing bits, and if there is no standing cover try the crouched bits.
		for ( i = 2; i > 0; --i )
		{
			CoverBits = 0;
			if (WGPawn.MyRecentlyTouchedNavPoint.bIsNavigationPoint)
				CoverBits = NavigationPoint(WGPawn.MyRecentlyTouchedNavPoint).CoverBits[i];
			else if (WGPawn.MyRecentlyTouchedNavPoint.bIsNavigationPointLite)
				CoverBits = NavigationPointLite(WGPawn.MyRecentlyTouchedNavPoint).CoverBits[i];
			
			if ( CoverBits != 0x0 )
			{
				break;
			}
		}

		// If there is no cover in the standing and crouched postures, don't do anything.
		if ( CoverBits == 0x0 )
		{
			//LogSelective( "FaceAwayFromWalls: Cover bits iz zero in direction x="$x );
			return;
		}

		if ( ( CoverBits & (1 << (x%8))) == 0 )
		{
			// No cover in this direction.
			//LogSelective( "FaceAwayFromWalls: NO cover in direction x="$x );
			if ( min == -1 )
			{
				min = x;
				size = 1;
			}
			else
			{
				size++;
			}
			
			if ( size > largestSize )
			{
				largestSize = size;
			}
		}
		else
		{			
			// Cover in this direction.
			//LogSelective( "FaceAwayFromWalls: cover in direction x="$x );
			if ( size == largestSize )
			{
				finalMin = min;
				min = -1;
				size = 0;
			}

			if ( x > 7 )
			{
				break;
			}
		}
	}

	if ( largestSize > 0 )
	{
		x = ( ( finalMin + (finalMin+largestSize) ) / 2 ) % 8;
		// DEBUG
		//x = 0;
		//LogSelective( "FaceAwayFromWalls: Best direction x="$x );
		Temp.Yaw = (x * 8192) & 65535;
		
		SetFacingPolicy( FACE_Vector );
		FacingVector = WGPawn.Location + 500.0 * Vector( Temp );

		//LogSelective( "FaceAwayFromWalls: Offset="$( FacingVector - WGPawn.Location ) );
	}
}

function bool GetWallFacingVector( bool bCheckStanding, bool bCheckCrouched, out Vector WallFacingVect )
{
	local int x, i, min, finalMin, size, largestSize;
	local Rotator Temp;
	local byte CoverBits;

	min = -1;
	finalMin = -1;
	size = 0;
	largestSize = 0;

	// GBX:PAD: Ensure that WGPawn and MyClaimedNavPoint exist since otherwise it dumps a bunch of accessed none messages in the log files.
	if ( (WGPawn == None) || (WGPawn.MyRecentlyTouchedNavPoint == None) )
		return false;

	// Corner-point cases are easy.  Use the directional arrow.
	if ( WGPawn.MyRecentlyTouchedNavPoint.IsA( 'CornerPoint' ) )
	{
		Temp = CornerPoint( WGPawn.MyRecentlyTouchedNavPoint ).Rotation;
		Temp.Pitch = 0;
		WallFacingVect = -1 * Vector( Temp );
		return true;
	}

	// Find the largest group of contiguous cover-bits having cover.  
	// Find the midpoint of this group, and face in that direction.
	// Algorithm: Loop around twice, counting contiguous groups.  After you've
	// gone around a full lap, quit at the first uncovered bit.
	for ( x = 0; x < 16; ++x )
	{
		// Get the cover bits.  First try the standing bits, and if there is no standing cover try the crouched bits.
		for ( i = 2; i > 0; --i )
		{			
			CoverBits = 0;

			if ( !bCheckStanding && i == 2 )
				continue;
			else if ( !bCheckCrouched && i == 1 )
				continue;

			if (WGPawn.MyRecentlyTouchedNavPoint.bIsNavigationPoint)
				CoverBits = NavigationPoint(WGPawn.MyRecentlyTouchedNavPoint).CoverBits[i];
			else if (WGPawn.MyRecentlyTouchedNavPoint.bIsNavigationPointLite)
				CoverBits = NavigationPointLite(WGPawn.MyRecentlyTouchedNavPoint).CoverBits[i];

			if ( CoverBits != 0x0 )
			{
				break;
			}
		}

		// If there is no cover in the standing and crouched postures, don't do anything.
		if ( CoverBits == 0x0 )
		{
			return false;
		}

		if ( ( CoverBits & (1 << (x%8))) != 0 )
		{
			// Cover in this direction.
			if ( min == -1 )
			{
				min = x;
				size = 1;
			}
			else
			{
				size++;
			}
			
			if ( size > largestSize )
			{
				largestSize = size;
			}
		}
		else
		{
			// No Cover in this direction.
			if ( size == largestSize )
			{
				finalMin = min;
				min = -1;
				size = 0;
			}

			if ( x > 7 )
			{
				break;
			}
		}
	}

	if ( largestSize > 0 )
	{
		x = ( ( finalMin + (finalMin+largestSize) ) / 2 ) % 8;
		Temp.Yaw = (x * 8192) & 65535;
		
		WallFacingVect = Vector( Temp );
		return true;
	}

	return false;
}

//---------------------------------------------------------
//	FaceTowardWalls
//---------------------------------------------------------
function FaceTowardWalls()
{
	local Vector WallFacingVect;

	if ( GetWallFacingVector( false, true, WallFacingVect ) )
	{
		SetFacingPolicy( FACE_Vector );
		FacingVector = WGPawn.Location + 500.0 * WallFacingVect;
	}
}

//---------------------------------------------------------
//	GrenadesOKAtThisRange
//---------------------------------------------------------
function bool GrenadesOKAtThisRange( float Dist )
{
	local bool bResult;
	
	if ( bShouldAssault )
	{
		return false;
	}
	else
	{
		bResult = ( Dist > CombatRadius_NoGrenades && Dist <= CombatRadius_Grenade );
	}
	LogSelective( "GrenadesOKAtThisRange(): "$bResult );
	
	return bResult;
}

//---------------------------------------------------------
//	ReportThrowingGrenade
//---------------------------------------------------------
// This function reports back to the UnitController that a member is 
// or is not throwing a grenade.  This allows the UC to decide whether
// to make the squad wait to rush the enemy until all grenades have exploded.
function ReportThrowingGrenade( bool bIsThrowing )
{
	LogSelective( "ReportThrowingGrenade: "$bIsThrowing );
	WGPawn.MyUnit.MyUnitController.MemberThrowingGrenade( WGPawn, bIsThrowing );
}

//---------------------------------------------------------
//	FarEnoughFromEnemiesToBlabber
//---------------------------------------------------------
function bool FarEnoughFromEnemiesToBlabber()
{
	local int ndx;
	local float ClosestDistance;
	local bool bAtLeastOne;

	ClosestDistance = 99999;
	for( ndx=0; ndx < TargetQueue.Length; ++ndx )
	{
		if ( TargetQueue[ ndx ].bIgnored == 0 && TargetQueue[ ndx ].TargetDistance < ClosestDistance )
		{
			bAtLeastOne = true;
			ClosestDistance = TargetQueue[ ndx ].TargetDistance;
		}
	}

	if( bAtLeastOne )
		return ClosestDistance > CombatRadius_CommentaryEnemies;
	else
		return true;
}

//---------------------------------------------------------
//	CloseEnoughToPlayerToBlabber
//---------------------------------------------------------
// Traverse up the tree of units and their superunits, looking for a player-pawn.
// When you find one, check his distance from the speaker.
function bool CloseEnoughToPlayerToBlabber()
{
	local gbxPawn PlayerPawn;
	local float DistToPlayer;
	local Unit CurUnit;

	// Find the player first.
	if ( WGPawn.MyUnit == None )
		return false;
	else
	{
		CurUnit = WGPawn.MyUnit;

		while ( PlayerPawn == None )
		{
			if ( CurUnit.Leader != None && CurUnit.Leader.IsHumanControlled() )
				PlayerPawn = CurUnit.Leader;
			else
			{
				if ( CurUnit.SuperUnit != None && CurUnit.SuperUnit != CurUnit )
					CurUnit = CurUnit.SuperUnit;
				else
					return false;
			}
		}

		if ( PlayerPawn != None )
		{
			DistToPlayer = VSize( PlayerPawn.Location - WGPawn.Location );
			if ( DistToPlayer <= CombatRadius_CommentaryPlayer )
			{
				return true;
			}
		}

		return false;
	}	
}

//---------------------------------------------------------
//	Approaching
//---------------------------------------------------------
// This function is called by tanks and other heavy vehicles that
// can potentially squash the Pawn if he doesn't move out the way.
function Approaching(Actor Other, Vector OtherMovementDirection)
{
	// ASSUMPTION: The caller has done all the work of claiming nav points
	// that will be "off-limits" for the next few seconds.  In the case of
	// tanks, these are nodes that are directly in front of the tank for a
	// few feet.

	if ((fApproachingTime + 3.0) > Level.TimeSeconds)
		return;  // ignore approaching messages if one received very recently

	fApproachingTime = Level.TimeSeconds;
	
	if ( bUseAIDebugging && AITracker != None )
	{
		AITracker.StartNewMove();
		AITracker.AddMoveReason( ReasonMove_VehicleApproaching );
		LastNodeSearch.MoveReason = ReasonMove_VehicleApproaching;
	}

	DecideDestApproaching( Other, OtherMovementDirection );
}

function TransitionToRelaxed()
{
	if ( Level.Game.IsPawnOnSameTeamAsPlayer(WGPawn) && WGPawn.eWeaponAimedState == WAS_CombatRelaxed && !WGPawn.IsTransitioning() && MountController != None )
	{
		MountController.DoMountAction( Mount_ChangeToRelaxed, None, false, false, class'RelaxedCallback', WGPawn.Rotation );
	}
}

function TransitionToCombatReady()
{
	if ( Level.Game.IsPawnOnSameTeamAsPlayer(WGPawn) && WGPawn.eWeaponAimedState == WAS_Relaxed && !WGPawn.IsTransitioning() && !WGPawn.m_fDispositionAnimPlaying && MountController != None && !WGPawn.bDontTransitionToCombat )
	{
		MountController.DoMountAction( Mount_ChangeToCombatReady, None, false, false, class'CombatReadyCallback', WGPawn.Rotation );
	}
	else
	{		
		WGPawn.bDontTransitionToCombat = false;
		NotifyCombatReady();
	}
}

function NotifyCombatReady()
{
	local float ThinkStart;

	TimerInterval = Level.AIMaxThinkInterval;
	ThinkStart = 1 + Level.AIGetNextThinkStart();
	SetTimer( ThinkStart, true );

	if ( !IsInCombat() && !bPendingFormationChange)
		SetFlagValue( StoppedAndIdle, true );	// Initial value plus "raised" timestamp.

	GotoState( 'InCombat' );
}

function NotifyRelaxed() {}

/////////////////////////////////////////////////////////////////////////
// States
/////////////////////////////////////////////////////////////////////////

//=========================================================
//	State RelaxedTalkingToPlayer
//=========================================================
state RelaxedTalkingToPlayer
{
	//---------------------------------------------------------
	//	BeginState (RelaxedTalkingToPlayer)
	//---------------------------------------------------------
	function BeginState()
	{
		TransitionToRelaxed();
	}

	//---------------------------------------------------------
	//	NotifyRelaxed (RelaxedTalkingToPlayer)
	//---------------------------------------------------------
	function NotifyRelaxed() {}

	//---------------------------------------------------------
	//	NotifyFormationCenterChange (RelaxedTalkingToPlayer)
	//---------------------------------------------------------
	function NotifyFormationCenterChange()
	{
		Global.NotifyFormationCenterChange();
		
		SetFlagValue( PlayerIsTalkingToMe, false );

		Pawn.RotationRate = Pawn.Default.RotationRate;
		RotationRate = Default.RotationRate;
		AcquisitionYawRate = Default.AcquisitionYawRate;
		
		//TransitionToCombatReady();
		if ( SalutationsController != None )
			SalutationsController.StopTrackingPlayer();
		GotoState( 'InCombat' );
	}

	//---------------------------------------------------------
	//	SetPlayerAddressingMe (RelaxedTalkingToPlayer)
	//---------------------------------------------------------
	function SetPlayerAddressingMe( bool bAddressing )
	{
		if ( bAddressing )
			return;		// No use doing anything unless the player has walked away.

		SetFlagValue( PlayerIsTalkingToMe, bAddressing );
		WGPawn.LookAtPlayerOverShoulder( bAddressing );
	}

	//---------------------------------------------------------
	//	DecideState (RelaxedTalkingToPlayer)
	//---------------------------------------------------------
	function DecideState() 
	{
		if ( IsFalse( PlayerIsTalkingToMe ) && TimeSinceLowered( PlayerIsTalkingToMe ) > 2.0f )
		{
			TransitionToCombatReady();
		}
	}

	//---------------------------------------------------------
	//	DecideMaxSpeed (RelaxedTalkingToPlayer)
	//---------------------------------------------------------
	function DecideMaxSpeed() 
	{
	}

	//---------------------------------------------------------
	//	DecideWeaponAim (RelaxedTalkingToPlayer)
	//---------------------------------------------------------
	function DecideWeaponAim()
	{
		WGPawn.SetWeaponAimedState( WAS_Relaxed );
	}

	//---------------------------------------------------------
	//	DecidePosture (RelaxedTalkingToPlayer)
	//---------------------------------------------------------
	function DecidePosture() 
	{
		WGPawn.StartGoingToStand();
	}

	//---------------------------------------------------------
	//	DecideFacingPolicy (RelaxedTalkingToPlayer)
	//---------------------------------------------------------
	function DecideFacingPolicy() 
	{
		local Vector VectToPlayer;

		WGPawn.bDoHeadTurn = true;

		if ( IsTrue( PlayerIsTalkingToMe ) )
		{
			Pawn.RotationRate = RotationRateRelaxed;
			RotationRate = RotationRateRelaxed;
			AcquisitionYawRate = RotationRateRelaxed.Yaw;

			VectToPlayer = Level.GetLocalPlayerController().Pawn.Location - WGPawn.Location;
			VectToPlayer.Z = 0;

			if ( Vector( WGPawn.Rotation ) dot Normal( VectToPlayer ) < 0.95 ) 
				FacingVector = Level.GetLocalPlayerController().Pawn.Location;

			SetFacingPolicy( FACE_Vector );
		}
	}
}

function bool ShouldMoveDueToTargetFailure() { return false; }

//=========================================================
//	State InCombat
//=========================================================
state InCombat
{
	// In this state, we're trying to get under cover as quickly as possible.
	// Later, if we have a target we'll try to attack the target from cover.

	//---------------------------------------------------------
	//	BeginState (InCombat)
	//---------------------------------------------------------
	function BeginState()
	{
		if ( WGPawn.MyUnit == None )
		{
			//log( "******** ERROR: ("$Self.Name$") Pawn "$WGPawn.Name$" has not been assigned a unit!" );
		}

		Global.BeginState();
		LastLookedForCoverTime = Level.TimeSeconds + ForceLookForCover;

		WGPawn.bDoTorsoTwist = true;
		DecideFacingPolicy();	// GBX:naj - added 2/9/04

		// Did a move order get sneaked in before this Mind got initialized?
		if ( bPendingFormationChange )
		{
			LogSelective( "BeginState: There was a FORMC change while in the default state.  Re-executing it now." );
			NotifyFormationCenterChange();
			bPendingFormationChange = false;
		}
	}

	//---------------------------------------------------------
	//	EndState (InCombat)
	//---------------------------------------------------------
	function EndState()
	{
		Global.EndState();
	}

	//---------------------------------------------------------
	//	DecideWeaponAim (InCombat)
	//---------------------------------------------------------
	function DecideWeaponAim()
	{
		if ( WGPawn.eWeaponAimedState == WAS_Relaxed || 
			( IsTrue( StoppedAndIdle ) && TimeSinceRaised( StoppedAndIdle ) > 3.0 ) )
		{
			WGPawn.SetWeaponAimedState( WAS_CombatRelaxed );
		}
	}

	//---------------------------------------------------------
	//	DecideMaxSpeed (InCombat)
	//---------------------------------------------------------
	function DecideMaxSpeed()
	{
		if ( WGPawn == None )
			return;
		else if ( WGPawn.MyUnit == None )
		{
			WGPawn.SetMaxAllowedSpeed( SL_Running );
			return;
		}

		// If I have been ordered to fall in,
		// check if I am so far away from the super unit that I should sprint
		// to keep up.
		if ( WGPawn.MyUnit.bAttachedToSuperUnit )
		{
			if ( WGPawn.MyUnit.IsTooFarFromSuperUnit( WGPawn.Location ) )
			{
				LogSelective( "DecideMaxSpeed: Too far from super-unit." );
				WGPawn.SetMaxAllowedSpeed( SL_Sprinting );
			}
		}
		else
		{
			WGPawn.SetMaxAllowedSpeed( SL_Running );
		}
	}

	//---------------------------------------------------------
	//	NotifyFormationCenterChange (InCombat)
	//---------------------------------------------------------
	function NotifyFormationCenterChange()
	{
		LogSelective( "NotifyFormationCenterChange." );
		
		PrepareForFormationCenterChange();

		if ( bShouldAssault )
		{
			if ( bUseAIDebugging && AITracker != None )
			{
				AITracker.StartNewMove();
				AITracker.AddMoveReason( ReasonMove_Assaulting );
				LastNodeSearch.MoveReason = ReasonMove_Assaulting;
			}
			DecideDestAnywhereForgetCover( true );
		}
		else
		{
			if ( bUseAIDebugging && AITracker != None )
			{
				AITracker.StartNewMove();
				AITracker.AddMoveReason( ReasonMove_MoveOrder );
				LastNodeSearch.MoveReason = ReasonMove_MoveOrder;
			}
			DecideDestAnywhere();
		}
	}

	//---------------------------------------------------------
	//	NotifyTargetFailure (InCombat)
	//---------------------------------------------------------
	function NotifyTargetFailure( Pawn Target, optional ETargetFailure FailCode, optional gbxPawn TheBlocker )
	{
		if ( RejectNTFCall() )
			return;

		Global.NotifyTargetFailure( Target, FailCode, TheBlocker );		

		// Don't do anything until the pawn has stopped maneuvering to his destination.
		if ( NavigationController.bIsNavigating )
			return;

		// If blocked by a friendly who happens to be a human-controlled player, tell him to "get outta da way!"
		if ( FailCode == FAIL_FriendlyInWay )
		{
			if ( TheBlocker != None && TheBlocker.IsHumanControlled() )
			{
				SetFlagValue( BeingBlockedByPlayer, true );

				if ( TimeSinceRaised( BeingBlockedByPlayer ) > 4.0 && CloseEnoughToPlayerToBlabber() )
				{
					SpeakOuttaTheWayBuddy( TheBlocker );
				}
			}
		}

		if ( FailCode == FAIL_NoVantage || FailCode == FAIL_MuzzleBlocked || FailCode == FAIL_FriendlyInWay )
		{
			RelegateEnemy();

			//if ( bBestTargetRelegated )
			if ( ShouldMoveDueToTargetFailure() )
			{
				MoveDueToTargetFailure( FailCode );
			}
		}
	}	
	
	//---------------------------------------------------------
	//	ShouldMoveDueToTargetFailure (InCombat)
	//---------------------------------------------------------
	function bool ShouldMoveDueToTargetFailure()
	{
		local int ndx;

		if ( Enemy == None )
		{
			return false;
		}

		ndx = FindTargetInQueue( Enemy );		

		// You should try moving for vantage if:
		// 1) You've relegated all of your targets;
		// 2) You've been flanked;
		// 3) Your enemy is a human player;
		// 4) Your enemy is within the no-relegation distance.
		//
		return	bBestTargetRelegated || 
				IsTrue( IveBeenFlanked ) || 
				Enemy.IsHumanControlled() || 
				( ndx > -1 && ( TargetQueue[ndx].TargetDistance <= CombatRadius_NoRelegation ) );
	}

	//---------------------------------------------------------
	//	MoveDueToTargetFailure (InCombat)
	//---------------------------------------------------------
	// Substates override this as needed.
	function MoveDueToTargetFailure( ETargetFailure FailCode )
	{
		if ( !bUseScriptedTargets )
		{			
			StartNewMoveAIDebugCam( FailCode );
			DecideDestElsewhereNew( true );
		}
	}

	//---------------------------------------------------------
	//	StartNewMoveAIDebugCam (InCombat)
	//---------------------------------------------------------
	function StartNewMoveAIDebugCam( ETargetFailure FailCode )
	{
		if ( bUseAIDebugging && AITracker != None )
		{
			AITracker.StartNewMove();
			if ( FailCode == FAIL_FriendlyInWay )
			{								
				AITracker.AddMoveReason( ReasonMove_FriendlyFire );					
				LastNodeSearch.MoveReason = ReasonMove_FriendlyFire;
			}
			else if ( FailCode == FAIL_NoVantage )
			{
				AITracker.AddMoveReason( ReasonMove_NoVantage );
				LastNodeSearch.MoveReason = ReasonMove_NoVantage;
			}
			else if ( FailCode == FAIL_MuzzleBlocked )
			{
				AITracker.AddMoveReason( ReasonMove_MuzzleBlocked );
				LastNodeSearch.MoveReason = ReasonMove_MuzzleBlocked;
			}
		}
	}

	//---------------------------------------------------------
	//	DecidePosture (InCombat)
	//---------------------------------------------------------
	function DecidePosture()
	{
		if ( NavigationController.bIsNavigating )
		{
			RequestPawnToStand();
		}
		// Otherwise, let the FiringController decide facing policy in this state.		

	}

	//---------------------------------------------------------
	//	DecideFacingPolicy (InCombat)
	//---------------------------------------------------------
	function DecideFacingPolicy()
	{
		local Rotator YawOffset;
		local bool bIsInCombat, bHasEnemy, bIsNavigating;
		local name AnimName;
		local float AnimFrame, AnimRate;

		bIsInCombat = IsInCombat();
		bHasEnemy = ( Enemy != None );
		bIsNavigating = IsNavigating();

		////////////////////////////////////////////////////
		// Next: update the rotation speed.
		if	( bIsInCombat || 
				( bIsNavigating && 
				( IsFalse( StoppedAndIdle ) && TimeSinceLowered( StoppedAndIdle ) <= 2.0 ) )
			)
		{
			WGPawn.RotationRate = RotationRateInCombat;
			RotationRate = RotationRateInCombat;
			AcquisitionYawRate = RotationRateInCombat.Yaw;
		}
		else if ( IsTrue( StoppedAndIdle ) && IsFalse( PlayerIsTalkingToMe ) && Level.Game.IsPawnOnSameTeamAsPlayer(WGPawn) )
		{
			Pawn.RotationRate = RotationRateRelaxed;
			RotationRate = RotationRateRelaxed;
			AcquisitionYawRate = RotationRateRelaxed.Yaw;
		}
		else
		{
			Pawn.RotationRate = Pawn.Default.RotationRate;
			RotationRate = Default.RotationRate;
			AcquisitionYawRate = Default.AcquisitionYawRate;
		}

		////////////////////////////////////////////////////
		// Finally, decide where to face.
		if ( !bIsNavigating && bHasEnemy )
		{
			// Always face your enemy when stationary.
			RequestFacingPolicy( FACE_Enemy );
		}
		else if ( FiringController.OKToControlFacingPolicy() )
		{
			// If the pawn has just stopped and is idle (not in combat), make him face away from his formation center.
			if ( IsRaised( StoppedAndIdle) && TimeSinceRaised( StoppedAndIdle ) > 3.0f )
			{
				if ( WGPawn.MyUnit.FormationCenter != None )
					BaseAlertDirection = Normal( WGPawn.Location - GetLocation( WGPawn.MyUnit.FormationCenter ) );
				else
					BaseAlertDirection = Vector( WGPawn.Rotation );

				FacingVector = Pawn.Location + 1000.0 * BaseAlertDirection;
				SetFacingPolicy( FACE_Vector );
				NextShiftFacingTime = Level.TimeSeconds + 10.0f + Rand( 8 );
			}
			// Maybe he has been stopped and idle for a while.  Make him shift his facing direction around to look more lifelike.
			else if ( IsTrue( StoppedAndIdle ) && TimeSinceRaised( StoppedAndIdle ) > 3.0f )
			{	
				if ( NextShiftFacingTime < 0.000001f || Level.TimeSeconds > NextShiftFacingTime )
				{
					// Horrible hack alert:  The pawn combat-ready idle animations look cool but most of them pop badly 
					// when blended with turn anims. Only one of them blends perfectly.  So, don't do any turning 
					// unless that idle is the current playing animation.
					WGPawn.GetAnimParams( 0, AnimName, AnimFrame, AnimRate );
					if ( AnimName == 'standing_idle_combat_1' )
					{
						YawOffset.Yaw = 5460 + FRand()*3642;		// Min 15 deg, max 45 deg.
						if ( bShiftFacingLeft )
							YawOffset.Yaw = Rotator( BaseAlertDirection ).Yaw - YawOffset.Yaw;
						else
							YawOffset.Yaw = Rotator( BaseAlertDirection ).Yaw + YawOffset.Yaw;

						bShiftFacingLeft = !bShiftFacingLeft;
						SetFacingPolicy( FACE_Vector );
						FacingVector = Pawn.Location + 1000.0 * Vector( YawOffset );
						NextShiftFacingTime = Level.TimeSeconds + 10.0f + Rand( 8 );
					}
				}
				
				RequestFacingPolicy( FACE_Vector );
			}
			// Otherwise, face the destination because we're not sure what else to do.
			else
			{				
				RequestFacingPolicy( FACE_Destination );
			}
		}
	}

	//---------------------------------------------------------
	//	CoverPointStolen (InCombat)
	//---------------------------------------------------------
	event CoverPointStolen(ActorLite NavPoint)
	{
		LogSelective( "CoverPointStolen." );

		// another Pawn stole my cover point, check for other available cover points...
		if ( bUseAIDebugging && AITracker != None )
		{
			AITracker.StartNewMove();
			AITracker.AddMoveReason( ReasonMove_CoverPointStolen );
			LastNodeSearch.MoveReason = ReasonMove_CoverPointStolen;
		}
		DecideDestAnywhere();		// "here" will no longer include the stolen point, since it's been claimed.
	}
	
	//---------------------------------------------------------
	//	NotifyTakeHit (InCombat)
	//---------------------------------------------------------
	// When shot and not currently moving to a destination, by god, get a new destination.
	function NotifyTakeHit(pawn InstigatedBy, vector HitLocation, int Damage, class<DamageType> damageType, vector Momentum)
	{
		Global.NotifyTakeHit( InstigatedBy, HitLocation, Damage, damageType, Momentum );
		if ( !NavigationController.bIsNavigating )
		{
			if ( bUseAIDebugging && AITracker != None )
			{
				AITracker.StartNewMove();
				AITracker.AddMoveReason( ReasonMove_TakingFire );
				LastNodeSearch.MoveReason = ReasonMove_TakingFire;
			}
			DecideDestElsewhere();
		}
	}

	//---------------------------------------------------------
	//	SetDesiredDestination (InCombat)
	//---------------------------------------------------------
	function SetDesiredDestination( ActorLite CoverPoint, optional bool bMustLeaveCover )
	{
		LogSelective( "SetDesiredDestination().  CoverPoint=="$CoverPoint );

		if( CoverPoint != None )
		{
			ClaimNavPoint( CoverPoint );  // claim the destination point

			if( WorstThreats.Length > 0 )
			{
				LogSelective( "SetDesiredDestination(): Maneuvering to actor "$CoverPoint.Name$" with cover." );
				NavigationController.ManeuverToActorWithCover( CoverPoint, WorstThreats[ 0 ].Target.Location, true, 0.5 );
				
				if ( bShouldAssault && !IsInState( 'Assaulting' ) )
				{					
					GotoState( 'Assaulting' );
				}
			}
			else
			{
				LogSelective( "SetDesiredDestination(): Maneuvering to actor without cover." );
				NavigationController.ManeuverToActor( CoverPoint, true );
			}
		}
	}

	//---------------------------------------------------------
	//	RequestFacingPolicy (InCombat)
	//---------------------------------------------------------
	function bool RequestFacingPolicy( EFacingPolicy policy )
	{
		// TEST: ALLOW THE FC TO DETERMINE FACING POLICY.
		return Global.RequestFacingPolicy( policy );
		// Deny FP requests in this state.
		//return false;
	}

	//---------------------------------------------------------
	//	SetEnemy (InCombat)
	//---------------------------------------------------------
	function bool SetEnemy( Pawn newEnemy )
	{
		// GBX:naj - WARNING! This function is a ticking time bomb.  It returns a bool but contains a GotoState().
		local bool bChanged;
		bChanged = Global.SetEnemy( newEnemy );

		// Consider going into firing from cover state.
		if( bChanged && WGPawn.MyClaimedNavPoint != None && ShouldGoIntoFFC() && !bLastCoverCheckFailed )
		{
			GotoState( 'FiringFromCover' );
		}

		return bChanged;
	}

	//---------------------------------------------------------
	//	ManeuverComplete (InCombat)
	//---------------------------------------------------------
	function ManeuverComplete()
	{
		Global.ManeuverComplete();

		LogSelective( "ManeuverComplete().  Considering going into FFC." );

		// Consider going into firing from cover state.
		if( WGPawn.MyClaimedNavPoint != None && ShouldGoIntoFFC())
		{
			GotoState( 'FiringFromCover' );
			return;		// Warning: Don't put any code after this GotoState()!
		}
	}

	//---------------------------------------------------------
	//	DecideState (InCombat)
	//---------------------------------------------------------
	function DecideState()
	{
		if( IsStateSticky() )
		{
			return;
		}

		if ( ShouldMelee() )
		{
			GotoState( 'Melee' );
		}
		else if( ShouldAssault() )
		{
			GotoState( 'Assaulting' );
		}
		else if( ShouldFrenzy() )
		{
			GotoState( 'Frenzied' );
		}
		// Consider going into firing from cover mode.
		else if( WGPawn.MyClaimedNavPoint != None && ShouldGoIntoFFC())
		{
			GotoState( 'FiringFromCover' );
		}
	}

	//---------------------------------------------------------
	//	Timer (InCombat)
	//---------------------------------------------------------
	function Timer()
	{
		Global.Timer();

		// Don't linger in the open very long; try to find a better spot.
		if( IsInCombat() &&
			!bDontInterruptMe &&
			!NavigationController.bIsNavigating &&
			GetStateName() == 'InCombat' &&
			Level.TimeSeconds > LastLookedForCoverTime + ForceLookForCover )
		{
			LogSelective( "Timer(): Looking for a better spot because the pawn has lingered out in the open for too long." );
			LastLookedForCoverTime = Level.TimeSeconds;

			if ( !bUseScriptedTargets && bUseAIDebugging && AITracker != None )
			{
				AITracker.StartNewMove();
				AITracker.AddMoveReason( ReasonMove_Exposed );
				LastNodeSearch.MoveReason = ReasonMove_Exposed;
			}
			
			DecideDestAnywhereHasPerfectCover();
		}
	}	
}

function RequestStopFiringFromCover();
function bool IsAllowedToUseVantage() { return false; }
function DoMeleeLunge() {}
function MoveDueToTargetFailure( ETargetFailure FailCode ) {}

//=========================================================
//	State FiringFromCover
//=========================================================
state FiringFromCover extends InCombat
{
	// In this state, the firing controller manages the pawn in order to keep
	// the pawn in cover

	//---------------------------------------------------------
	//	BeginState (FiringFromCover)
	//---------------------------------------------------------
	function BeginState()
	{
		LogSelective( "BeginState()." );		
		Global.BeginState();

		WGPawn.SetMyRecentlyTouchedNavPoint( WGPawn.MyClaimedNavPoint );
		SetFlagValue( HasExtendedDeadlockProtection, false );

		FiringController.StartFiringFromCover( Enemy );

		LastSwitchedCoverTime = Level.TimeSeconds;
		TimeLastNoHadVantage = 0.0;

		SetFlagValue( StoppedAndIdle, false );		
		SetFlagValue( IveBeenFlanked, false );
	}

	//---------------------------------------------------------
	//	EndState (FiringFromCover)
	//---------------------------------------------------------
	function EndState()
	{
		PendingGestureAnim = '';		// Safeguard.		
	}

	//---------------------------------------------------------
	//	UnPossess (FiringFromCover)
	//---------------------------------------------------------
	// Probably called via an ACTION_ChangeController TriggeredScript call.  Clean up the pawn's cover-logic variables 
	// before handing it over to the new controller.
	function UnPossess()
	{		
		WGPawn.BreakOutOfHunker();
		LogSelective( "Mind.UnPossess." );
		Super.UnPossess();
	}

	//---------------------------------------------------------
	//	IsFiringFromCover (FiringFromCover)
	//---------------------------------------------------------
	function bool IsFiringFromCover()
	{
		return true;
	}

	//---------------------------------------------------------
	//	DecideWeaponAim (FiringFromCover)
	//---------------------------------------------------------
	function DecideWeaponAim()
	{
		if ( WGPawn.m_bStandingBackToWall )
		{
			if ( IsFalse( PlayerIsTalkingToMe ) || IsInCombat() || WGPawn.eWeaponAimedState != WAS_Relaxed )
				Super.DecideWeaponAim();
		}
	}

	//---------------------------------------------------------
	//	DecideMaxSpeed (FiringFromCover)
	//---------------------------------------------------------
	function DecideMaxSpeed()
	{
		// Do nothing in this state.
	}

	//---------------------------------------------------------
	//	DecidePosture (FiringFromCover)
	//---------------------------------------------------------
	function DecidePosture()
	{
		// Do nothing in this state.
	}

	//---------------------------------------------------------
	//	DecideFacingPolicy (FiringFromCover)
	//---------------------------------------------------------
	function DecideFacingPolicy()
	{
		// Turn on head-tracking if the player is talking with the pawn during a non-combat situation.
		if ( WGPawn.m_bStandingBackToWall && IsTrue( PlayerIsTalkingToMe ) && !IsInCombat() )
			WGPawn.bDoHeadTurn = true;
		else
			WGPawn.bDoHeadTurn = false;
	}

	//---------------------------------------------------------
	//	NotifyLosingCoverPoint (FiringFromCover)
	//---------------------------------------------------------
	function NotifyLosingCoverPoint()
	{			
		// Oops. Can't do firing from cover if the cover point is lost. Go back to InCombat.
		LogSelective( "NotifyLosingCoverPoint()." );
		if ( bUseAIDebugging && AITracker != None )
		{
			AITracker.StartNewMove();
			AITracker.AddMoveReason( ReasonMove_CoverPointStolen );
			LastNodeSearch.MoveReason = ReasonMove_CoverPointStolen;
		}
		DecideDestAnywhere();
	}

	//---------------------------------------------------------
	//	NotifyTakeHit (FiringFromCover)
	//---------------------------------------------------------
	// Experiment: Half of the time, make FFC German pawns switch their cover spot when shot.
	function NotifyTakeHit(pawn InstigatedBy, vector HitLocation, int Damage, class<DamageType> damageType, vector Momentum)
	{		
		Super.NotifyTakeHit( InstigatedBy, HitLocation, Damage, damageType, Momentum );

		if ( !Level.Game.IsPawnOnSameTeamAsPlayer(WGPawn) && Rand(2) == 0 )
		{
			LogSelective( "NotifyTakeHit: I am a German and I just got shot.  Looking for a more protected spot." );
			LastSwitchedCoverTime = Level.TimeSeconds;				
			if ( bUseAIDebugging && AITracker != None )
			{
				AITracker.StartNewMove();
				AITracker.AddMoveReason( ReasonMove_TakingFire );
				LastNodeSearch.MoveReason = ReasonMove_TakingFire;
			}
			
			//DecideDestElsewhere();
			DecideDestBetterCover( false );
		}
	}

	//---------------------------------------------------------
	//	NotifyTargetOrder (FiringFromCover)
	//---------------------------------------------------------
	function NotifyTargetOrder(Unit targetUnit)
	{
		Global.NotifyTargetOrder( targetUnit );

		// Think now, possibly ahead of schedule.
		Timer();
		FiringController.NotifyTargeting();
	}

	//---------------------------------------------------------
	//	MoveDueToTargetFailure (FiringFromCover)
	//---------------------------------------------------------
	// Substates override this as needed.
	function MoveDueToTargetFailure( ETargetFailure FailCode )
	{
		local ActorLite BetterNavPoint;
		local gbxPawn Teammate;

		if ( bUseScriptedTargets )
			return;

		StartNewMoveAIDebugCam( FailCode );

		if( WGPawn.MyUnit != None &&
			WGPawn.MyUnit.TryToStealTeammatesNavPoint( WGPawn, Teammate, BetterNavPoint ) )
		{
			LogSelective( "MoveDueToTargetFailure: Stole new nav point "$BetterNavPoint$" from teammate "$Teammate.Name );						
			ClaimNavPoint( BetterNavPoint );	// It's already been claimed, so this is just a safeguard.			
			SetFlagTrueTimed( HasExtendedDeadlockProtection, 10.0f );		// Extend deadlock protection for this pawn while he moves.
			LeaveFiringFromCover( 'InCombat', BetterNavPoint );
		}
		else
		{
			if ( !DecideDestBetterVantageWithCover() )
			{
				if ( IsTrue( TargetOrderRulesInEffect ) )
				{
					SetFlagValue( TargetOrderRulesInEffect, false );
					SpeakCantHitAssignedTarget();			
					SetFlagTrueTimed( PawnShoutedCantHitTarget, 10.0f );
				}
			}
		}
	}

	//---------------------------------------------------------
	//	IsPostureSticky (FiringFromCover)
	//---------------------------------------------------------
	function bool IsPostureSticky()
	{
		return false;
	}

	//---------------------------------------------------------
	//	RequestFacingPolicy (FiringFromCover)
	//---------------------------------------------------------
	function bool RequestFacingPolicy( EFacingPolicy policy )
	{
		return global.RequestFacingPolicy( policy );
	}

	//---------------------------------------------------------
	//	SetDesiredDestination (FiringFromCover)
	//---------------------------------------------------------
	// This function overrides the normal behavior of claiming nodes and maneuvering to them.
	// Instead, it claims the nodes but doesn't maneuver; it tells the FiringController to break out of
	// firing-from-cover, which requires time and perhaps special animations.
	// The FiringController will call us back at NotifyFiringFromCoverDone() 
	// or NotifyFCReadyToAssault() when it's ready.
	//	
	function SetDesiredDestination( ActorLite CoverPoint, optional bool bMustLeaveCover )
	{
		if ( CoverPoint == WGPawn.MyClaimedNavPoint )
		{
			if ( bMustLeaveCover )
			{
				LogSelective( "SetDesiredDestination(): Requested CoverPoint is the same as my current claimed navpoint.  Leaving FFC but not moving." );			
				CoverPoint = None;
			}
			else
			{
				LogSelective( "SetDesiredDestination(): Requested CoverPoint is the same as my current claimed navpoint.  Doing nothing." );
				return;
			}						
		}
		else
		{
			ClaimNavPoint( CoverPoint );
		}
		
		if ( bShouldAssault )
		{
			LeaveFiringFromCover( 'Assaulting', CoverPoint );
		}
		else
		{
			LeaveFiringFromCover( 'InCombat', CoverPoint );
		}
	}

	//---------------------------------------------------------
	//	RequestStopFiringFromCover (FiringFromCover)
	//---------------------------------------------------------
	function RequestStopFiringFromCover()
	{
		LogSelective( "RequestStopFiringFromCover()." );
		DecideDestAnywhere( true );
	}

	//---------------------------------------------------------
	//	NotifyFiringFromCoverDone (FiringFromCover)
	//---------------------------------------------------------
	function NotifyFiringFromCoverDone()
	{
		OKToInterruptMe();

		if ( PendingGestureAnim != '' )
		{
			WGPawn.PlayGestureAnim( PendingGestureAnim, true );
			PendingGestureAnim = '';
		}

		if ( PendingDestination != None )
		{
			Super.SetDesiredDestination( PendingDestination );
		}

		PendingDestination = None;
	}

	//---------------------------------------------------------
	//	LeaveFiringFromCover (FiringFromCover)
	//---------------------------------------------------------
	function LeaveFiringFromCover( name newState, optional ActorLite NewDestination )
	{
		DontInterruptMe();	// While waiting for the FiringController to finish leaving FFC, don't execute any dangerous code.

		if( PendingState != '' )
		{
			Log( name $ "<" $ GetStateName() $ ">.LeaveFiringFromCover( " $ newState $ " ): WARNING PendingState previously set to "$PendingState, 'Mind' );
		}

		LogSelective( "LeaveFiringFromCover().  Going to "$newState );
		PendingState = newState;
		PendingDestination = NewDestination;
		FiringController.RequestStopFiringFromCover();
	}

	//---------------------------------------------------------
	//	DecideState (FiringFromCover)
	//---------------------------------------------------------
	function DecideState()
	{
		if( IsStateSticky() )
		{
			return;
		}

		if ( ShouldMelee() )
		{
			LogSelective( "FFC.DecideState(); Should melee." );
			LeaveFiringFromCover( 'Melee' );
		}		
		else if( ShouldFrenzy() )
		{
			LogSelective( "FFC.DecideState(); Should frenzy." );
			LeaveFiringFromCover( 'Frenzied' );
		}
		else if ( CoverNoLongerValid() || FiringController.VantageNoLongerValid() )
		{
			//SetFlagValue( IveBeenFlanked, true );
			SpeakWeveBeenFlanked();
			LogSelective( "DecideState().  Cover or Vantage no longer valid." );
			LeaveFiringFromCover( 'InCombat' );
		}
	}

	function RequestPawnToStand() {}
	function RequestPawnToCrouch() {}

	//---------------------------------------------------------
	//	FleeGrenadeAction (FiringFromCover)
	//---------------------------------------------------------
	function FleeGrenadeAction()
	{
		LogSelective( "FleeGrenadeAction()." );
		LeaveFiringFromCover( 'FleeGrenade' );
	}

	//---------------------------------------------------------
	//	SetEnemy (FiringFromCover)
	//---------------------------------------------------------
	function bool SetEnemy( Pawn newEnemy )
	{
		local bool bChanged;
		bChanged = Super.SetEnemy( newEnemy );

		if ( bChanged )
		{
			if ( bShouldAssault )
			{
				if ( bUseAIDebugging && AITracker != None )
				{
					AITracker.StartNewMove();
					AITracker.AddMoveReason( ReasonMove_Assaulting );
					LastNodeSearch.MoveReason = ReasonMove_Assaulting;
				}				
				DecideDestAnywhereForgetCover( true );
			}
			/*
			else if ( CoverNoLongerValid() || FiringController.VantageNoLongerValid() )
			{
				//SetFlagValue( IveBeenFlanked, true );

				LogSelective( "SetEnemy(); Cover no longer valid." );
				if ( bUseAIDebugging && AITracker != None )
				{
					AITracker.StartNewMove();
					AITracker.AddMoveReason( ReasonMove_Exposed );
					LastNodeSearch.MoveReason = ReasonMove_Exposed;
				}
				DecideDestAnywhere();
			}
			*/
		}
		return bChanged;
	}

	//---------------------------------------------------------
	//	Timer (FiringFromCover)
	//---------------------------------------------------------
	function Timer()
	{
		local ESuppressionLevel supLevel;		

		Global.Timer();		

		// Sanity check.
		if ( WGPawn == None || WGPawn.IsDead() || !bAntsyGermans )
			return;

		// Shout 'Covering fire!'
		if ( HasTargetOrder() && TimeSinceTargetOrderGiven() > 3.0f )
		{
			if ( HasBeenShootingWell() && IsFalse( PawnShoutedCoveringFire ) )
			{
				SpeakCoveringFire();
				SetFlagTrueTimed( PawnShoutedCoveringFire, 3.0f );
			}
			else if ( HasHadVantageProblems() && IsFalse( PawnShoutedCantHitTarget ) )
			{
				SpeakCantHitAssignedTarget();
				SetFlagTrueTimed( PawnShoutedCantHitTarget, 10.0f );
			}
		}

		// BEGIN GERMANS ANTSY-NESS
		//
		// GBX:naj - Germans only: every once in a while, switch your cover spot.
		if( !Level.Game.IsPawnOnSameTeamAsPlayer(WGPawn) && !FiringController.bPermittedToOpBurst )
		{
			supLevel = GetSuppressionLevel();

			if ( supLevel == SL_UNSUPPRESSED && Level.TimeSeconds > LastSwitchedCoverTime + RandRange(ForceSwitchCoverInterval_Low.Min, ForceSwitchCoverInterval_Low.Max ) )
			{
				LogSelective( "Timer: I am a German, and I have been stationary for a while.  Changing position." );
				LastSwitchedCoverTime = Level.TimeSeconds;				
				if ( bUseAIDebugging && AITracker != None )
				{
					AITracker.StartNewMove();
					AITracker.AddMoveReason( ReasonMove_Antsy );
					LastNodeSearch.MoveReason = ReasonMove_Antsy;
				}
				
				// Require perfect cover and vantage from your new nav point if you're going to go to the bother of 
				// moving from your current position.
				DecideDestBetterCover( true );
			}
			else
			if ( supLevel == SL_SUPPRESSED && Level.TimeSeconds > LastSwitchedCoverTime + RandRange(ForceSwitchCoverInterval_High.Min, ForceSwitchCoverInterval_High.Max ) )
			{

				LastSwitchedCoverTime = Level.TimeSeconds;
				
				/* Replace the above line with these if you want antsy-ness to happen when suppressed.
				LogSelective( "Timer: I am a German, and I have been stationary for a while.  Changing position." );
				LastSwitchedCoverTime = Level.TimeSeconds;				
				if ( bUseAIDebugging && AITracker != None )
				{
					AITracker.StartNewMove();
					AITracker.AddMoveReason( ReasonMove_Antsy );
				}				
				DecideDestElsewhere( false );
				*/
			}
		}
		// END GERMANS ANTSY-NESS
	}

	//---------------------------------------------------------
	//	NotifyFormationCenterChange (FiringFromCover)
	//---------------------------------------------------------
	function NotifyFormationCenterChange()
	{
		LogSelective( "NotifyFormationCenterChange()." );

		PrepareForFormationCenterChange();

		if ( bShouldAssault )
		{
			if ( bUseAIDebugging && AITracker != None )
			{
				AITracker.StartNewMove();
				AITracker.AddMoveReason( ReasonMove_Assaulting );
				LastNodeSearch.MoveReason = ReasonMove_Assaulting;
			}				
			DecideDestAnywhereForgetCover( true );
		}
		else
		{
			if ( bUseAIDebugging && AITracker != None )
			{
				AITracker.StartNewMove();
				AITracker.AddMoveReason( ReasonMove_MoveOrder );
				LastNodeSearch.MoveReason = ReasonMove_MoveOrder;
			}				
			DecideDestAnywhere();
		}
	}
	
	//---------------------------------------------------------
	//	NavigationPointStolen (FiringFromCover)
	//---------------------------------------------------------
	event NavigationPointStolen(ActorLite NavPoint)
	{		
		LogSelective( "NavigationPointStolen." );

		if ( WGPawn != None && NavPoint != None )
		{
			if ( bUseAIDebugging && AITracker != None )
			{
				AITracker.StartNewMove();
				AITracker.AddMoveReason( ReasonMove_CoverPointStolen );
				LastNodeSearch.MoveReason = ReasonMove_CoverPointStolen;
			}

			SetFlagTrueTimed( HasExtendedDeadlockProtection, 10.0f );		// Extend deadlock protection for this pawn while he finds a new place to go.
			DecideDestAnywhere();
		}
	}

	//---------------------------------------------------------
	//	RequestPlayGesture (FiringFromCover)
	//---------------------------------------------------------
	function bool RequestPlayGesture( Name GestureAnimName, bool bNoInterrupt )
	{
		LogSelective( "RequestPlayGesture: anim: "$GestureAnimName );
		PendingGestureAnim = GestureAnimName;

		FiringController.RequestPlayGesture( PendingGestureAnim );

		return true;	// We're making a leap of faith here that the gesture anim will always play.
	}

	//---------------------------------------------------------
	//	SetPlayerAddressingMe (FiringFromCover)
	//---------------------------------------------------------
	// Overridden from base logic to prevent changing states.
	function SetPlayerAddressingMe( bool bAddressing )
	{
		if ( WGPawn.m_bStandingBackToWall )
		{
			SetFlagValue( PlayerIsTalkingToMe, bAddressing );
			WGPawn.LookAtPlayerOverShoulder( bAddressing );

			if ( IsTrue( PlayerIsTalkingToMe ) && IsTrue( StoppedAndIdle ) )
			{
				TransitionToRelaxed();
			}
			else
			{
				TransitionToCombatReady();
			}
		}
	}

	// Overridden from base logic to prevent changing states.
	function NotifyRelaxed() {}
	function NotifyCombatReady() {}

	simulated function bool GoToDeadGuy( gbxPawn aPawn ) { return false; }	
}

//=========================================================
//	State FleeGrenade
//=========================================================
// In this state, there's one or more grenades incoming and we need to decide what to do
state FleeGrenade
{
	//---------------------------------------------------------
	//	BeginState (FleeGrenade)
	//---------------------------------------------------------
	function BeginState()
	{
		GrenadeReactionStartTime = Level.TimeSeconds;
		WGPawn.Weapon.DisableReload();  //NAC:While fleeing grenades, never stop to reload the weapon...A full health meter is better than a fully loaded gun at this point!
	}

	//---------------------------------------------------------
	//	EndState (FleeGrenade)
	//---------------------------------------------------------
	function EndState()
	{
		bReturningGrenade = false;
		bFleeingGrenade = false;
		bLastCoverCheckFailed = false;
		bGrenadePanic = false;
		WGPawn.bWantsToCrouch = false;
		WGPawn.SetCowering( false );
		WGPawn.Weapon.EnableReload();  //NAC: Ok, now feel free to reload and pop a cap!
	}

	//---------------------------------------------------------
	//	DecideWeaponAim (FleeGrenade)
	//---------------------------------------------------------
	function DecideWeaponAim()
	{
		// Do nothing in this state.
	}

	//---------------------------------------------------------
	//	DecideMaxSpeed (FleeGrenade)
	//---------------------------------------------------------
	function DecideMaxSpeed()
	{
		// GBX:PAD: Ensure that WGPawn exists since otherwise it dumps a bunch of accessed none messages in the log files.
		if (WGPawn == None)
		{
			return;
		}

		WGPawn.SetMaxAllowedSpeed( SL_Running );
	}

	//---------------------------------------------------------
	//	DecidePosture (FleeGrenade)
	//---------------------------------------------------------
	function DecidePosture()
	{
		//RequestPawnToStand();
	}

	//---------------------------------------------------------
	//	DecideFacingPolicy (FleeGrenade)
	//---------------------------------------------------------
	function DecideFacingPolicy()
	{
		SetFacingPolicy( FACE_Destination );
	}

	//---------------------------------------------------------
	//	RequestFacingPolicy (FleeGrenade)
	//---------------------------------------------------------
	function bool RequestFacingPolicy( EFacingPolicy policy )
	{
		return global.RequestFacingPolicy( policy );
	}

	//---------------------------------------------------------
	//	CanCrewTurret (FleeGrenade)
	//---------------------------------------------------------
	function bool CanCrewTurret( TurretWeapon TheTurret )
	{
		// No time to crew a turret, I've got a grenade to escape from!
		return false;
	}

	//---------------------------------------------------------
	//	Timer (FleeGrenade)
	//---------------------------------------------------------
	function Timer()
	{
		local int i, ndx, ndx2, TargetOfOpIndex;
		local float DistToGrenade, TimeToDetonation, ThrowAwayLobTime;
		local ActorLite CoverPoint;
		local PlayerController PC;
		local array<ActorLite> ExcludeList;
		local array<Vector> MyLocationArray;
		local vector ThrowAwayLobVector, CoverPointLocation;
		local byte bPerfectCover, bPartialCover;
		local bool bGermanThrowback;

		Global.Timer();

		if (WGPawn.m_bIsCowering)
		{
			if (WGPawn.bWantsToCrouch && (GrenadeCowerStopTime < Level.TimeSeconds))
			{
				WGPawn.bWantsToCrouch = false;
				WGPawn.SetCowering( false );
			}
			
			log( "*****SJP: "$Pawn$" is cowering; exiting FleeGrenade tick", 'SJP' );
			return;
		}

		// Clean up the grenade list
		CleanGrenadeList();

		// If there are no more grenades in the list, go to InCombat
		if( PerceivedGrenades.Length == 0 )
		{
			GotoState( 'InCombat' );
			return;
		}

		i = MostDangerousGrenadeIndex();

		if( i >= 0 && !bReturningGrenade )
		{
			DistToGrenade = VSize(PerceivedGrenades[i].Location - Pawn.Location);
			TimeToDetonation = PerceivedGrenades[i].RealFuseTime - PerceivedGrenades[i].ElapsedFuseTime;

			//NAC: dampening down the frequency at which enemies throw back grenades in SP & SKR 
			bGermanThrowback = true;
			PC = Level.GetLocalPlayerController();
			if (Level.Game.GameReplicationInfo.GameType != GT_MULTIPLAYER && !WGPawn.SameTeamAs(PC.Pawn))
			{
				TargetOfOpIndex = int(RandRange(0,5));  //Hijack this variable
				if (TargetOfOpIndex < 4)
				{
					bGermanThrowback = false;
				}
			}

			if(	TimeToDetonation > GrenadeFusePanicTime && 
				!bFleeingGrenade && !bGrenadePanic && !gbxGrenade( PerceivedGrenades[i] ).IsClaimed() && 
				gbxGrenade( PerceivedGrenades[i] ).bHitGround && 
				DistToGrenade < GrenadeTossBackMaxDist && bGermanThrowback)
			{
				// Find a target of opportunity for this rogue grenade.  We'll query our GrenadeFiringController to see if there is an acceptable target.
				// Sending falst to GetBestTargetIndex tells it to use lax rules about what a good target is; the restrictions placed on grenade targeting
				// by the unit (such as how often the location has been grenaded) are ignored.
				TargetOfOpIndex = FiringController.GrenadeFireCtrl.GetBestTargetIndex( false );

				//log( "*****SJP: "$Pawn$" Searched for TargetofOp; found index "$TargetOfOpIndex, 'NAC' );

				// If we found one, calculate the lobvector to the target
				if(	TargetOfOpIndex >= 0 &&	FiringController.GrenadeFireCtrl.CalculateTarget(TargetOfOpIndex) )
				{
					//log( "*****SJP: "$Pawn$" TargetOfOp lob calculation was successful! Throwing to my enemy.", 'NAC' );
					// If the calculation was successful, throw the grenade
					TossBackGrenade( i, FiringController.GrenadeFireCtrl.TargetLobInfos[TargetOfOpIndex].LobVector );	// Throw back grenade if I first see it on the ground near me
				}
				else
				{
					// No target of oppurtunity exists, so we'll use the navigation code to find cover from the grenade.  Instead of navigating to cover,
					// however, we'll try to throw grenade there.  Therefore, we'll consider all of our unit members as 'threats' so that
					// the grenade will not damage them when it explodes at the returned location.

					ndx2 = 0;

					for( ndx = 0; ndx < WGPawn.MyUnit.MAX_MEMBERS; ++ndx )
					{
						if( WGPawn.MyUnit.Members[ndx] != None )
						{
							MyLocationArray.Length = MyLocationArray.Length + 1;
							MyLocationArray[ndx2] = WGPawn.MyUnit.Members[ndx].Location;
							ndx2++;
						}
					}

					// If no target was found or the vector calculation failed, we'll find a cover point and try to lob the grenade to it
					//log( "*****SJP: "$Pawn$" No TargetOfOp! Looking for a coverpoint to throw the grenade to, away from "$MyLocationArray[0], 'NAC' );
											
					FindBestDestination( CoverPoint, false, false, false, MyLocationArray, false, Enemy, false, Pawn.Location, PerceivedGrenades[i].DamageRadius * 4, ExcludeList, bPerfectCover, bPartialCover );

					if( CoverPoint != None )
					{
						CoverPointLocation = GetLocation(CoverPoint);
					//	Log( "*****SJP: "$Pawn$" FBD returned CoverPt="$CoverPoint$", Location="$CoverPointLocation, 'NAC' );
					}

					if( CoverPoint != None && // Did we find a cover point?
						FiringController.GrenadeFireCtrl.CalculateEffect( CoverPointLocation, PerceivedGrenades[i].DamageRadius ) >= 0.0 && // Is this a safe place to throw the grenade? 
						FiringController.GrenadeFireCtrl.CalculateLobVector( CoverPointLocation, ThrowAwayLobVector, ThrowAwayLobTime ) // Can a lob vector be calculated?
						)
					{
					//	Log( "*****SJP: "$Pawn$" Throwing away grenade to cover node.", 'NAC' );
						TossBackGrenade( i, ThrowAwayLobVector, CoverPointLocation );
					}
					else
					{
					
					//	Log( "*****SJP: "$Pawn$" Running away from grenade; could not find anywhere to throw it!", 'NAC' );
						// Fuggedaboudit, run away
						RequestPawnToStand();
						FindCoverFromGrenade( i, true );
					}
				}
			}
			else if( !bFleeingGrenade )
			{
				RequestPawnToStand();
				// Delay a bit before running away
				if( Level.TimeSeconds - GrenadeReactionStartTime < GrenadeReactionDelay )
					return;

				//log( "*****SJP: "$Pawn$" Starting destination search. bGrenadePanic = "$bGrenadePanic, 'NAC' );
				
				if( bGrenadePanic )
				{
					FindCoverFromGrenade( i, true );	// Find any destination away from the grenade if finding cover is taking too long
				}
				else
				{
					FindCoverFromGrenade( i );	// Try to find cover first
				}
			}
		}
		else
		{
			bFleeingGrenade = false;
		}
		
		if( (bGrenadePanic || i < 0) && !bFleeingGrenade && !bReturningGrenade && !WGPawn.m_bIsCowering )
		{
			NavigationController.StopManeuvering();
			WGPawn.SetCowering( true );
			GrenadeCowerStopTime = Level.TimeSeconds + GRENADE_COWER_TIME;
		}
	}

	//---------------------------------------------------------
	//	CoverPointStolen (FleeGrenade)
	//---------------------------------------------------------
	event CoverPointStolen(ActorLite NavPoint)
	{
		// Do nothing in this state.
	}

	//---------------------------------------------------------
	//	SetDesiredDestination (FleeGrenade)
	//---------------------------------------------------------
	function SetDesiredDestination( ActorLite CoverPoint, bool bMustLeaveCover ) // FleeGrenade
	{
		// Nothing
	}

	//---------------------------------------------------------
	//	IsStateSticky (FleeGrenade)
	//---------------------------------------------------------
	function bool IsStateSticky()
	{
		return true;
	}

	simulated function bool GoToDeadGuy( gbxPawn aPawn ) { return false; }
}

//=========================================================
//	State FleeTNT
//=========================================================
state FleeTNT extends FleeGrenade
{



	//---------------------------------------------------------
	//	DecidePosture (FleeTNT)
	//---------------------------------------------------------
	function DecidePosture()
	{
		//RequestPawnToStand();
	}

	//---------------------------------------------------------
	//	BeginState (FleeTNT)
	//---------------------------------------------------------
	function BeginState()
	{
		GrenadeReactionStartTime = Level.TimeSeconds;
	}

	//---------------------------------------------------------
	//	Timer (FleeTNT)
	//---------------------------------------------------------
	function Timer()
	{
		local Vector MeToTNT;

		Global.Timer();

		if (WGPawn.m_bIsCowering)
		{
			if (WGPawn.bWantsToCrouch && (GrenadeCowerStopTime < Level.TimeSeconds))
			{
				WGPawn.bWantsToCrouch = false;
				WGPawn.SetCowering( false );
			}
			
			log( "*****SJP: "$Pawn$" is cowering; exiting FleeGrenade tick", 'SJP' );
			return;
		}



		// If there are no more grenades in the list, go to InCombat
		if( PerceivedGrenades.Length == 0 )
		{
			GotoState( 'InCombat' );
			return;
		}
	
	
		RequestPawnToStand();
		if( !bFleeingGrenade )
			{
		// Delay a bit before running away
			if( Level.TimeSeconds - GrenadeReactionStartTime < GrenadeReactionDelay )
				return;
			log( "*****SJP: "$Pawn$" Starting destination search. bGrenadePanic = "$bGrenadePanic, 'SJP' );
		
			if( bGrenadePanic )
			{
				FindCoverFromTNT( iTNTIndex, true );	// Find any destination away from the grenade if finding cover is taking too long
			}
			else
			{
				FindCoverFromTNT( iTNTIndex );	// Try to find cover first
			}
		}
	
		else
		{
			bFleeingGrenade = false;
		}
		
		
		MeToTNT = (PerceivedGrenades[iTNTIndex].Location - WGPawn.Location);
		//// If we are far enough away from the TNT, cower down
		if(( VSize(MeToTNT) > PerceivedGrenades[iTNTIndex].DamageRadius*4) && ( VSize(MeToTNT) < PerceivedGrenades[iTNTIndex].DamageRadius*5) && !WGPawn.m_bIsCowering)
		{
			NavigationController.StopManeuvering();
			WGPawn.SetCowering( true );
			GrenadeCowerStopTime = Level.TimeSeconds + GRENADE_COWER_TIME;
		}
	}





}



//=========================================================
//	State Frenzied
//=========================================================
state Frenzied extends InCombat
{
	//---------------------------------------------------------
	//	BeginState (Frenzied)
	//---------------------------------------------------------
	function BeginState()
	{
		Super.BeginState();

		ClearRelegations();

		SetFlagValue( HasExtendedDeadlockProtection, false );
		FiringController.SetFrenzied( true );

		SetFacingPolicy( FACE_Enemy );

		DecideState();

		TimerInterval = 0.2;
		SetTimer( TimerInterval, true );
	}

	//---------------------------------------------------------
	//	EndState (Frenzied)
	//---------------------------------------------------------
	function EndState()
	{
		Super.EndState();

		FiringController.SetFrenzied( false );

		TimerInterval = 0.5;
		SetTimer( TimerInterval, true );
	}

	//---------------------------------------------------------
	//	SetEnemy (Frenzied)
	//---------------------------------------------------------
	function bool SetEnemy( Pawn newEnemy )
	{
		// GBX:naj - WARNING! This function is a ticking time bomb.  It returns a bool but contains a GotoState().
		local bool bChanged, bStayInFrenzied;
		bChanged = Global.SetEnemy( newEnemy );

		bStayInFrenzied = ShouldFrenzy();

		// Bail out of this state if enemy changes.
		if( bChanged && !bStayInFrenzied )
		{
			GotoState( 'InCombat' );
		}

		return bChanged;
	}

	//---------------------------------------------------------
	//	DecideState (Frenzied)
	//---------------------------------------------------------
	function DecideState()
	{
		if( IsStateSticky() )
			return;

		if ( ShouldMelee() )
		{
			GotoState( 'Melee' );
		}		
		else if ( ShouldAssault() )
		{			
			GotoState( 'Assaulting' );
		}
		else if ( !ShouldFrenzy() )
		{
			GotoState( 'InCombat' );
		}
	}

	//---------------------------------------------------------
	//	ManeuverComplete (Frenzied)
	//---------------------------------------------------------
	function ManeuverComplete()
	{
		// Overridden to prevent going into FFC from the Frenzied state.
		LogSelective( "ManeuverComplete().  Doing nothing." );
	}

	//---------------------------------------------------------
	//	DecidePosture (InCombat)
	//---------------------------------------------------------
	function DecidePosture()
	{
		RequestPawnToStand();
	}

	//---------------------------------------------------------
	//	DecideFacingPolicy (Frenzied)
	//---------------------------------------------------------
	// This function was once in Melee, but I decided it needed to be available for all of the Frenzied states.
	function DecideFacingPolicy()
	{
		RequestFacingPolicy( FACE_Enemy );
	}

	//---------------------------------------------------------
	//	RequestPawnToCrouch (Frenzied)
	//---------------------------------------------------------
	function RequestPawnToCrouch() {}

	//---------------------------------------------------------
	//	GrenadesOKAtThisRange (Frenzied)
	//---------------------------------------------------------
	function bool GrenadesOKAtThisRange( float Dist )
	{
		return false;	// Don't throw grenades when frenzied.
	}

	//---------------------------------------------------------
	//	FleeGrenadeAction (Frenzied)
	//---------------------------------------------------------
	// Don't flee grenades when frenzied/assaulting/meleeing.
	function FleeGrenadeAction() {
        }

	//---------------------------------------------------------
	//	DecideMaxSpeed (Frenzied)
	//---------------------------------------------------------
	function DecideMaxSpeed()
	{
		// GBX:PAD: Ensure that WGPawn exists since otherwise it dumps a bunch of accessed none messages in the log files.
		if (WGPawn == None)
		{
			return;
		}		

		WGPawn.SetMaxAllowedSpeed( SL_Running );
	}	

	//---------------------------------------------------------
	//	NotifyTakeHit (Frenzied)
	//---------------------------------------------------------
	// When shot and not currently moving to a destination, by god, get a new destination.
	function NotifyTakeHit(pawn InstigatedBy, vector HitLocation, int Damage, class<DamageType> damageType, vector Momentum)
	{
		Global.NotifyTakeHit( InstigatedBy, HitLocation, Damage, damageType, Momentum );
		if ( !NavigationController.bIsNavigating && !IsFrenzied() )
		{
			LogSelective( "NotifyTakeHit: Looking for a more protected spot." );
			if ( bUseAIDebugging && AITracker != None )
			{
				AITracker.StartNewMove();
				AITracker.AddMoveReason( ReasonMove_TakingFire );
				LastNodeSearch.MoveReason = ReasonMove_TakingFire;
			}							
			DecideDestElsewhere();
		}
	}

	//---------------------------------------------------------
	//	ShouldMoveDueToTargetFailure (Frenzied)
	//---------------------------------------------------------
	function bool ShouldMoveDueToTargetFailure()
	{
		return true;
	}

	//---------------------------------------------------------
	//	MoveDueToTargetFailure (Frenzied)
	//---------------------------------------------------------
	function MoveDueToTargetFailure( ETargetFailure FailCode )
	{
		if ( !bUseScriptedTargets )
		{
			StartNewMoveAIDebugCam( FailCode );
			//DecideDestElsewhereNew( true, true );

			//////////// TEST: Make frenzied pawns more likely to give up on cover.
			DecideDestAnywhereForgetCover( true );
		}
	}	

	//---------------------------------------------------------
	//	ApproveFlinchRequest (Frenzied)
	//---------------------------------------------------------
	function bool ApproveFlinchRequest()
	{
		return false;
	}

	function MaybePlayReactToBulletsAnim( float MissDistanceRelative ) {}	
	simulated function bool GoToDeadGuy( gbxPawn aPawn ) { return false; }
}

//---------------------------------------------------------
//	SendNotifyOfAssault
//---------------------------------------------------------
function SendNotifyOfAssault()
{
	UnitControllerAI( WGPawn.MyUnit.MyUnitController ).OrderAssault( gbxPawn( Enemy ).MyUnit );
}

//=========================================================
//	State Assaulting
//=========================================================
state Assaulting extends Frenzied
{
	//---------------------------------------------------------
	//	BeginState (Assaulting)
	//---------------------------------------------------------
	function BeginState()
	{
		Super.BeginState();

		ExclusionTracker.ClearList();

		if ( WGPawn.Weapon != None )
		{
			WGPawn.Weapon.StopBerserk();
		}
	}

	//---------------------------------------------------------
	//	EndState (Assaulting)
	//---------------------------------------------------------
	function EndState()
	{
		//log("NAJ**** "$Self.Name$" Assaulting.EndState() called.", 'naj');
		Super.EndState();

		StopAssault();


		// TODO speech
	}

	//---------------------------------------------------------
	//	MoveDueToTargetFailure (Assaulting)
	//---------------------------------------------------------
	function MoveDueToTargetFailure( ETargetFailure FailCode )
	{
		if ( !bUseScriptedTargets )
		{
			StartNewMoveAIDebugCam( FailCode );
			DecideDestElsewhereForgetCover( true );
		}
	}

	//---------------------------------------------------------
	//	SetDesiredDestination (Assaulting)
	//---------------------------------------------------------
	function SetDesiredDestination( ActorLite CoverPoint, optional bool bMustLeaveCover )
	{
		if( CoverPoint != None )
		{
			ClaimNavPoint( CoverPoint );  // claim the destination point

			LogSelective( "SetDesiredDestination(): Maneuvering to actor "$CoverPoint.Name$" without cover." );
			NavigationController.ManeuverToActor( CoverPoint, true );
		}
	}

	//---------------------------------------------------------
	//	ManeuverComplete (Assaulting)
	//---------------------------------------------------------
	function ManeuverComplete()	// Overridden to prevent going into cover.
	{
		Global.ManeuverComplete();		
		LogSelective( "ManeuverComplete().  Doing nothing." );
	}

	//---------------------------------------------------------
	//	ManeuverFailed (Assaulting)
	//---------------------------------------------------------
	function ManeuverFailed()
	{		
		if ( WGPawn.MyUnit.Leader == WGPawn )
			WGPawn.MyUnit.SetFormationCenterNearCurrentCentroid( true );

		LogSelective( "ManeuverFailed().  Going to frenzied." );
		GotoState( 'Frenzied' );
	}

	//---------------------------------------------------------
	//	SetEnemy (Assaulting)
	//---------------------------------------------------------
	function bool SetEnemy( Pawn newEnemy )
	{
		local bool bChanged;
		bChanged = Global.SetEnemy( newEnemy );

		// TBD: Do something with bChanged?

		return bChanged;
	}

	//---------------------------------------------------------
	//	TestShouldKeepAssaulting (Assaulting)
	//---------------------------------------------------------
	function TestShouldKeepAssaulting()
	{
		if ( bShouldAssault && WGPawn.MyUnit != None )
		{
			if ( WGPawn.MyUnit.AssignedTargetUnit == None )
			{
				StopAssault();
			}
			else if ( WGPawn.MyUnit.AssignedTargetUnit.GetNumLivingMembers() == 0 )
			{
				StopAssault();
			}
		}
	}
	
	//---------------------------------------------------------
	//	DecideState (Assaulting)
	//---------------------------------------------------------
	function DecideState()
	{
		if( IsStateSticky() )
			return;

		TestShouldKeepAssaulting();

		if ( ShouldMelee() )
		{
			GotoState( 'Melee' );
		}		
		else if( !bShouldAssault )
		{
			GotoState( 'InCombat' );
		}
	}

	//---------------------------------------------------------
	//	DecideMaxSpeed (Assaulting)
	//---------------------------------------------------------
	function DecideMaxSpeed()
	{
		// Sanity checks.
		if ( WGPawn == None || Enemy == None || !Enemy.IsA( 'gbxPawn' ) || gbxPawn( Enemy ).MyUnit == None )
		{
			return;
		}

		// No sprinting if within assault range of our enemy.
		/*
		if ( FacingPolicy == FACE_Destination && VSize( gbxPawn( Enemy ).WGPawn.MyUnit.UnitCentroid - WGPawn.Location ) > CombatRadius_Deadlock )
		{
			WGPawn.SetMaxAllowedSpeed( SL_Sprinting );
		}
		else
		{
		*/
		WGPawn.SetMaxAllowedSpeed( SL_Running );
		//}
	}

	function Timer()
	{
		Global.Timer();
	}

	simulated function bool GoToDeadGuy( gbxPawn aPawn ) { return false; }
}

//=========================================================
//	State Melee
//=========================================================
state Melee extends Frenzied
{
	//---------------------------------------------------------
	//	BeginState (Melee)
	//---------------------------------------------------------
	function BeginState()
	{
		WGPawn.bDoTorsoTwist = false;
		Pawn.Weapon.DisableReload();
		SetFacingPolicy( FACE_Enemy );
		WGPawn.SetLookingAtTarget( Enemy );
		FiringController.StartMelee();
		
		TimerInterval = 0.2;
		SetTimer( TimerInterval, true );
		SetInitialFlagValue( MeleeAttemptFailed, false );
	}

	//---------------------------------------------------------
	//	EndState (Melee)
	//---------------------------------------------------------
	function EndState()
	{
		if ( WGPawn != None )
		{
			if ( WGPawn.Weapon != None )
				WGPawn.Weapon.EnableReload();
			
			FiringController.StopMelee();			
			WGPawn.ResetLookAt( true, true, true );
		}

		SetDesiredDestination( WGPawn.MyClaimedNavPoint );

		TimerInterval = 0.5;
		SetTimer( TimerInterval, true );
	}

	//---------------------------------------------------------
	//	ShouldMelee (Melee)
	//---------------------------------------------------------
	function bool ShouldMelee()
	{
		local Vector FORMC;

		// Sanity check.
		if ( WGPawn.MyUnit == None || WGPawn.MyUnit.FormationCenter == None || WGPawn == None )
		{
			return false;
		}

		// Pawn may not actually have a unit.
		if ( WGPawn.MyUnit == None || WGPawn.MyUnit.FormationCenter == None )
		{
			return Global.ShouldMelee();
		}
		else
		{
			if ( WGPawn.MyUnit.FormationCenter.bIsNavigationPoint )
				FORMC = NavigationPoint( WGPawn.MyUnit.FormationCenter ).Location;
			else if ( WGPawn.MyUnit.FormationCenter.bIsNavigationPointLite )
				FORMC = NavigationPointLite( WGPawn.MyUnit.FormationCenter ).Location;

			//if ( VSize( WGPawn.Location - FORMC ) > CombatRadius_MaxMeleePursuit )
			if ( VSize( Enemy.Location - FORMC ) > CombatRadius_MaxMeleePursuit )
			{
				LogSelective( "ShouldMelee: too far away from FORMC." );
				return false;
			}
			else
			{
				return
					Enemy != None &&
					//EnemyCanSeeMe() &&
					CanSeeEnemy() &&
					!EnemyIsOnADifferentLevel();
			}
		}
	}

	//---------------------------------------------------------
	//	DoMeleeLunge (Melee)
	//---------------------------------------------------------
	function DoMeleeLunge() 
	{
		if ( FiringController != None )
			FiringController.DoMeleeLunge();
	}

	//---------------------------------------------------------
	//	RepeatLastNodeSearch (Melee)
	//---------------------------------------------------------
	function RepeatLastNodeSearch() {}

	//---------------------------------------------------------
	//	NotifyTargetFailure (Melee)
	//---------------------------------------------------------
	function NotifyTargetFailure( Pawn Target, optional ETargetFailure FailCode, optional gbxPawn TheBlocker )
	{
		if ( RejectNTFCall() )
			return;

		// The FiringController couldn't melee attack for some reason.  Go back to being frenzied instead.
		SetFlagValue( MeleeAttemptFailed, true );

		// If someone else is meleeing my target, look for someone else to kill.
		if ( FailCode == FAIL_CantClaimMelee )
		{
			RelegateEnemy();
		}

		GotoState( 'Frenzied' );
	}

	//---------------------------------------------------------
	//	MoveDueToTargetFailure (Melee)
	//---------------------------------------------------------
	function MoveDueToTargetFailure( ETargetFailure FailCode )
	{
		if ( bUseScriptedTargets )
			return;

		LogSelective( "MoveDueToTargetFailure." );

		StartNewMoveAIDebugCam( FailCode );		
		if ( DecideDestElsewhereNew( true ) )
			return;

		// OK, that didn't work...
		NavigationController.StopManeuvering();

		if ( ShouldFrenzy() )
		{			
			GotoState( 'Frenzied' );
		}
		else if ( ShouldAssault() )
		{			
			GotoState( 'Assaulting' );
		}
		else
		{
			GotoState( 'InCombat' );
		}
	}

	//---------------------------------------------------------
	//	NotifyMeleeAnimFinished (Melee)
	//---------------------------------------------------------
	function NotifyMeleeAnimFinished()
	{
		FiringController.NotifyMeleeAnimFinished();
	}

	//---------------------------------------------------------
	//	DecideState (Melee)
	//---------------------------------------------------------
	function DecideState()
	{
		if( IsStateSticky() )
		{
			return;
		}

		if ( ShouldMelee() )
		{
			// Do nothing?
		}
		else if ( ShouldFrenzy() )
		{			
			GotoState( 'Frenzied' );
		}
		else if ( ShouldAssault() )
		{			
			GotoState( 'Assaulting' );
		}
		else
		{
			GotoState( 'InCombat' );
		}
	}

	//---------------------------------------------------------
	//	DecideWeaponAim (Melee)
	//---------------------------------------------------------
	function DecideWeaponAim()
	{
		WGPawn.SetWeaponAimedState( WAS_Sighted );
	}

	//---------------------------------------------------------
	//	DecidePosture (Melee)
	//---------------------------------------------------------
	function DecidePosture()
	{
		RequestPawnToStand();
	}

	//---------------------------------------------------------
	//	GrenadesOKAtThisRange (Melee)
	//---------------------------------------------------------
	function bool GrenadesOKAtThisRange( float Dist )
	{
		return false;
	}

	//---------------------------------------------------------
	//	DecideMaxSpeed (Melee)
	//---------------------------------------------------------
	function DecideMaxSpeed()
	{
		RequestPawnToStand();
		WGPawn.SetMaxAllowedSpeed( SL_Running );
	}

	simulated function bool GoToDeadGuy( gbxPawn aPawn ) { return false; }
}

/// FIRING RELATED //////////////////////////////////////////////////////

//---------------------------------------------------------
//	IsTargetDead
//---------------------------------------------------------
function bool IsTargetDead()
{
	return Enemy == None || Enemy.IsDead();
}

//---------------------------------------------------------
//	IsTargetNoTarget
//---------------------------------------------------------
function bool IsTargetNoTarget()
{
	local gbxPlayerController gbxPC;

	if ( Enemy == None || !Enemy.IsHumanControlled() )
		return false;

	gbxPC = gbxPlayerController( Enemy.Controller );
	
	return ( gbxPC != None && gbxPC.bNeverEnemy );
}

//---------------------------------------------------------
//	ApproveShot
//---------------------------------------------------------
function bool ApproveShot( Rotator AimRotator )
{
	return FiringController.ApproveShot( AimRotator );
}

/// MANEUVER RELATED ///////////////////////////////////////////////////

//---------------------------------------------------------
//	IsAtDesiredDestination
//---------------------------------------------------------
/*
function bool IsAtDesiredDestination()
{
	if( WGPawn.MyClaimedNavPoint == None )
	{
		// We have no destination, so we're done.
		return true;
	}

	if (WGPawn.MyClaimedNavPoint.bIsNavigationPoint)
	{
		if ( VSize( NavigationPoint(WGPawn.MyClaimedNavPoint).Location - Pawn.Location ) <= DestinationRadius )
			return true;
	}
	else if (WGPawn.MyClaimedNavPoint.bIsNavigationPointLite)
	{
		if ( VSize( NavigationPointLite(WGPawn.MyClaimedNavPoint).Location - Pawn.Location ) <= DestinationRadius )
			return true;
	}

	return false;
}
*/

//---------------------------------------------------------
//	ShouldGoIntoFFC
//---------------------------------------------------------
function bool ShouldGoIntoFFC()
{
	local vector ClaimedNavPointLoc;
	
	if ( WGPawn == None || WGPawn.MyClaimedNavPoint == None )
		return false;

	// Don't go into FFC until the pawn has stopped navigating.
	if ( IsNavigating() )
		return false;

	ClaimedNavPointLoc = GetLocation( WGPawn.MyClaimedNavPoint );

	if ( !IsInCombat() )
	{
		if ( VSizeSquared( ClaimedNavPointLoc - WGPawn.Location ) > DestinationRadius * DestinationRadius )
			return false;
		else
		{
			// OK, we're close enough to the point, but does it actually have any cover bits?
			if ( HasAnyStandingCover( WGPawn.MyClaimedNavPoint ) || HasAnyCrouchedCover( WGPawn.MyClaimedNavPoint ) )
				return true;
			else
				return false;
		}
	}

	if ( Enemy == None )
	{
		LogSelective( "ShouldGoIntoFFC(): false; no enemy." );
		return false;
	}

	// Test 1: Don't do it if enemies are too close to me.
	if ( bEnemiesTooCloseForFFC )
	{
		LogSelective( "ShouldGoIntoFFC(): false; enemies are too close for FFC." );
		return false;
	}

	// Test 3: Don't do it if your chosen enemy is behind your chosen node.	
	if ( Enemy != None && WGPawn.MyClaimedNavPoint.bIsNavigationPoint )
	{
		if ( NavigationPoint( WGPawn.MyClaimedNavPoint ).bDirectional && 
			( Vector( GetRotation( WGPawn.MyClaimedNavPoint ) ) dot Normal( Enemy.Location - WGPawn.Location ) ) >= 0 )
		{
			LogSelective( "ShouldGoIntoFFC(): false; chosen enemy is behind me." );
			return false;
		}
	}

	// Test 4: Does the point provide low or crouched cover?
	if ( !ProvidesLowCoverFrom( Enemy.Location, WGPawn.MyClaimedNavPoint ) && 
		 !ProvidesCrouchedCoverFrom( Enemy.Location, WGPawn.MyClaimedNavPoint ) )
	{
		// No, it doesn't.
		LogSelective( "ShouldGoIntoFFC(): false; Claimed nav point "$WGPawn.MyClaimedNavPoint$" doesn't provide either low or crouched cover." );
		return false;
	}	

	// Test 5: Is the pawn close enough to the point to be considered "on" it?
	if ( VSizeSquared( ClaimedNavPointLoc - WGPawn.Location ) > DestinationRadius * DestinationRadius )
	{
		// Nope.
		LogSelective( "ShouldGoIntoFFC(): false; Pawn is too far away from nav point loc." );
		return false;
	}
	
	// Test 6: Is the cover still valid?
	if ( CoverNoLongerValid() )
	{
		LogSelective( "ShouldGoIntoFFC(): false; Cover is no longer valid." );
		return false;
	}

	LogSelective( "ShouldGoIntoFFC(): true." );
	return true;
}

//---------------------------------------------------------
//	ManeuverComplete
//---------------------------------------------------------
function ManeuverComplete()
{
	//local Pawn PlayerPawn;

	LogSelective( "ManeuverComplete() [global].  Doing nothing." );

	//PlayerPawn = WGPawn.MyUnit.GetControllingPlayerController().Pawn;
	//Level.TheAISpeechManager.PlaySpeech(
	//	WGPawn,
	//	PlayerPawn,
	//	'MoveComplete',
	//	,
	//	,
	//	0.0,
	//	WGPawn.MyUnit,
	//	8.0,
	//	5.0
	//);
}

//---------------------------------------------------------
//	ManeuverFailed
//---------------------------------------------------------
function ManeuverFailed()
{
	local Pawn PlayerPawn;

	LogSelective( "ManeuverFailed() [global]." );

	PlayerPawn = WGPawn.MyUnit.GetControllingPlayerController().Pawn;
	Level.TheAISpeechManager.PlaySpeech(
		WGPawn,
		PlayerPawn,
		'CantReachPosition',
		,
		,
		0.0,
		Self,
		1.0,
		2.0
	);
}

/// COVER RELATED ///////////////////////////////////////////////////////

function CoverFound(ECoverType CoverTypeFound, ActorLite NavPoint, int NumThreatsCovered) {/*GBX:naj - deprecated.*/}
function NoCoverFound() {/*GBX:naj - deprecated.*/}
event CoverPointStolen(ActorLite NavPoint) {}

//---------------------------------------------------------
//	VantagePointStolen
//---------------------------------------------------------
event VantagePointStolen(ActorLite NavPoint)
{
	FiringController.VantagePointStolen(NavPoint);
}


/// POSTURE RELATED /////////////////////////////////////////////////////

//---------------------------------------------------------
//	IsPostureSticky
//---------------------------------------------------------
function bool IsPostureSticky()
{
	return Level.TimeSeconds - PostureStartTime < PostureStickTime;
}

//---------------------------------------------------------
//	RequestPawnToStand
//---------------------------------------------------------
function RequestPawnToStand()
{
	if( IsPostureSticky() )
	{
		return;
	}

	// stand up (unless there's a reason not to)...
	if (WGPawn != None)
		WGPawn.StartGoingToStand();

	PostureStartTime = Level.TimeSeconds;
}

//---------------------------------------------------------
//	RequestPawnToCrouch
//---------------------------------------------------------
function RequestPawnToCrouch()
{
	if( IsPostureSticky() || !(WGPawn.bCanCrouch))
	{
		return;
	}

	// change to crouching (unless there's a reason not to)...
	WGPawn.StartGoingToCrouch();

	PostureStartTime = Level.TimeSeconds;
}

//---------------------------------------------------------
//	RequestPawnToGoProne
//---------------------------------------------------------
function RequestPawnToGoProne()
{
	// Removed.
}

/// GRENADE RELATED /////////////////////////////////////////////////////

//---------------------------------------------------------
//	CleanGrenadeList
//---------------------------------------------------------
function CleanGrenadeList()
{
	local bool bRemove;
	local int i;

	do
	{
		bRemove = false;

		for( i = 0; i < PerceivedGrenades.Length; i++ )
		{
			if( PerceivedGrenades[i] != None )
			{
				// Why on earth do gbxGrenades use their own fuse timer system when gbxExplosion already has one???
				if( PerceivedGrenades[i].IsA( 'gbxGrenade' ) )
				{
					if ( PerceivedGrenades[i].ElapsedFuseTime >= PerceivedGrenades[i].RealFuseTime )
						bRemove = true;
				}
				else if ( PerceivedGrenades[i].flFuseTime <= 0 )
				{
					bRemove = true;
				}
			}
			else
			{
				bRemove = true;
			}

			if ( bRemove )
			{
				PerceivedGrenades.Remove( i, 1 );
			}
		}
	} until (!bRemove)
}

//---------------------------------------------------------
//	CleanTNT
//---------------------------------------------------------
function CleanTNT()  //NAC added function to clean out TNT explosives from perceivedgrenades list
{

	if (iTNTIndex >=0)
	{
		PerceivedGrenades.Remove( iTNTIndex, 1 );
		iTNTIndex = -1;
	}
	
}

//---------------------------------------------------------
//	FindCoverFromGrenade
//---------------------------------------------------------
function FindCoverFromGrenade( int iGrenade, optional bool bForcePanic )
{
	local ActorLite CoverPoint;
	local array<ActorLite> ExcludeList;
	local ActorLite EscapePoint;
	local float cosFrustrum;
	local vector DummyThreatLoc;
	local int i;
	local byte bPerfectCover, bPartialCover;

	LogSelective( "FindCoverFromGrenade()." );

	if( PerceivedGrenades[iGrenade] != None )
	{
		//RequestPawnToStand();

		if( !bForcePanic )
		{
			log("****SJP: "$Pawn$" FINDING COVER FROM GRENADE(S)!!", 'SJP');

			bLastCoverCheckFailed = false;

			// 1. Exclude nodes within the damage radius of all grenades
			// 2. Use FindBestDestination as normal, passing my enemies as threat locations
			for( i = 0; i < PerceivedGrenades.Length; i++ )
			{
				BuildGrenadeExcludeList(ExcludeList, PerceivedGrenades[i].Location, PerceivedGrenades[i].DamageRadius);
			}

			if ( bUseAIDebugging && AITracker != None )
			{
				AITracker.StartNewMove();
				AITracker.AddMoveReason( ReasonMove_FleeGrenade );					
			}
			
			FindBestDestination( CoverPoint, false, false, false, ThreatLocations, false, Enemy, true, vect(0,0,0), 0.0, ExcludeList, bPerfectCover, bPartialCover, DummyThreatLoc );

			Log( "*****SJP: "$Pawn$" FindCoverFromGrenade():  FBD returned CoverPt="$CoverPoint, 'SJP' );

			// Handle the results of the cover search.
			if ( CoverPoint != None )
			{
				bLastCoverCheckFailed = false;

				if ( ClaimNavPoint( CoverPoint ) )
				{
					LogSelective( "FindCoverFromGrenade(): Maneuvering to actor without cover." );
					if( NavigationController.ManeuverToActor( CoverPoint, false ) )
					{
						bFleeingGrenade = true;
					}
				}
			}
			else
			{
				bLastCoverCheckFailed = true;
			}
		}

		if( bLastCoverCheckFailed || bForcePanic )
		{
			// If we're not that far away from the grenade, just run as far as possible.  Otherwise, run AWAY from the grenade
			if( VSize( Pawn.Location - PerceivedGrenades[iGrenade].Location ) < 128.0 )
				cosFrustrum = 0.0;
			else
				cosFrustrum = 0.45;

			// Find a nav point away from the grenade.  TODO: factor in all of the grenades
			EscapePoint = FindFarthestDestinationFromVector( PerceivedGrenades[iGrenade].Location,
															 PerceivedGrenades[iGrenade].DamageRadius * 1.50,
															 true,
															 cosFrustrum );

			if( EscapePoint != None )
			{
				log("****SJP: "$Pawn$" No cover found from grenade, moving to "$EscapePoint, 'SJP');
				if ( ClaimNavPoint( EscapePoint ) )
				{
					LogSelective( "FindCoverFromGrenade(): Maneuvering to actor without cover." );
					NavigationController.ManeuverToActor( EscapePoint, false );
					bFleeingGrenade = true;
				}
				else
				{
					log("****SJP: "$Pawn$" WARNING[1]: Destination point was already claimed, cannot find any destination away from grenade! Help!", 'SJP');
				}

			}
			else
			{
				log("****SJP: "$Pawn$" WARNING[2] Cannot find destination to flee from grenade! Help!", 'SJP');
			}
		}
	}
}




//---------------------------------------------------------
//	FindCoverFromTNT
//---------------------------------------------------------
function FindCoverFromTNT( int iTNT, optional bool bForcePanic )
{
	local ActorLite CoverPoint;
	local array<ActorLite> ExcludeList;
	local ActorLite EscapePoint;
	local float cosFrustrum;
	local vector DummyThreatLoc;
	local int i;
	local byte bPerfectCover, bPartialCover;

	LogSelective( "FindCoverFromTNT()." );

	if( PerceivedGrenades[iTNT] != None )
	{
		//RequestPawnToStand();

		if( !bForcePanic )
		{
			//log("****NAC: "$Pawn$" FINDING COVER FROM GRENADE(S)!!", 'NAC');

			bLastCoverCheckFailed = false;

			// 1. Exclude nodes within the damage radius of all grenades
			// 2. Use FindBestDestination as normal, passing my enemies as threat locations
			for( i = 0; i < PerceivedGrenades.Length; i++ )
			{
				BuildGrenadeExcludeList(ExcludeList, PerceivedGrenades[i].Location, PerceivedGrenades[i].DamageRadius*4);
			}

			if ( bUseAIDebugging && AITracker != None )
			{
				AITracker.StartNewMove();
				AITracker.AddMoveReason( ReasonMove_FleeGrenade );					
			}
			
			FindBestDestination( CoverPoint, false, false, false, ThreatLocations, false, Enemy, true, vect(0,0,0), 0.0, ExcludeList, bPerfectCover, bPartialCover, DummyThreatLoc );

			//Log( "*****NAC: "$Pawn$" FindCoverFromTNT():  FBD returned CoverPt="$CoverPoint, 'NAC' );

			// Handle the results of the cover search.
			if ( CoverPoint != None )
			{
				bLastCoverCheckFailed = false;

				if ( ClaimNavPoint( CoverPoint ) )
				{
					LogSelective( "FindCoverFromGrenade(): Maneuvering to actor without cover." );
					if( NavigationController.ManeuverToActor( CoverPoint, false ) )
					{
						bFleeingGrenade = true;
					}
				}
			}
			else
			{
				bLastCoverCheckFailed = true;
			}
		}

		if( bLastCoverCheckFailed || bForcePanic )
		{
			// If we're not that far away from the TNT, just run as far as possible.  Otherwise, run AWAY from the TNT
			if( VSize( Pawn.Location - PerceivedGrenades[iTNTIndex].Location ) < PerceivedGrenades[iTNTIndex].DamageRadius * 4 )
				cosFrustrum = 0.0;
			else
				cosFrustrum = 0.45;

			// Find a nav point away from the grenade.  TODO: factor in all of the grenades
			EscapePoint = FindFarthestDestinationFromVector( PerceivedGrenades[iTNTIndex].Location,
															 PerceivedGrenades[iTNTIndex].DamageRadius * 4,
															 true,
															 cosFrustrum );

			if( EscapePoint != None )
			{
				//log("****NAC: "$Pawn$" No cover found from grenade, moving to "$EscapePoint, 'NAC');
				if ( ClaimNavPoint( EscapePoint ) )
				{
					LogSelective( "FindCoverFromGrenade(): Maneuvering to actor without cover." );
					NavigationController.ManeuverToActor( EscapePoint, false );
					bFleeingGrenade = true;
				}
				else
				{
					log("****NAC: "$Pawn$" WARNING[1]: Destination point was already claimed, cannot find any destination away from TNT! Help!", 'NAC');
				}

			}
			else
			{
				log("****NAC: "$Pawn$" WARNING[2] Cannot find destination to flee from grenade! TNT!", 'NAC');
			}
		}
	}
}




//---------------------------------------------------------
//	TossBackGrenade
//---------------------------------------------------------
function TossBackGrenade( int iGrenade, vector returnVector, optional vector faceVector )
{
	local float TimeToDetonation;
	local gbxGrenade TheGrenade;

	TheGrenade = gbxGrenade( PerceivedGrenades[iGrenade] );
	
	if( TheGrenade != None && TheGrenade.Claim( Pawn ) )
	{
		bReturningGrenade = true;
		iReturnGrenadeIndex = iGrenade; // Save the index of this grenade so we'll toss back the correct one!

		TheGrenade.ThrowVector = returnVector;
		Log( "*****SJP: Tossing away grenade with ThrowVector set at "$TheGrenade.ThrowVector, 'SJP' );

		// If there's over 20% fuse time remaining, ensure there is adequate fuse time to throw the grenade again.  Otherwise, let it detonate soon, possibly in my hand!
		TimeToDetonation = TheGrenade.RealFuseTime - TheGrenade.ElapsedFuseTime;

		if( TimeToDetonation > TheGrenade.RealFuseTime / 5 )
			TheGrenade.RealFuseTime += TheGrenade.RealFuseTime / 2;

		WGPawn.PlayReturnGrenadeThrow();

		if( faceVector != Vect(0,0,0) )
		{
			if( RequestFacingPolicy( FACE_Vector ) )
				FacingVector = faceVector;
		}
	}
}

//---------------------------------------------------------
//	GrenadeTossFromGroundCallBack
//---------------------------------------------------------
function GrenadeTossFromGroundCallBack()
{
	FiringController.GrenadeTossFromGroundCallBack();
}

//---------------------------------------------------------
//	PickupGrenadeFromGroundCallBack
//---------------------------------------------------------
function PickupGrenadeFromGroundCallBack()
{
	gbxGrenade( PerceivedGrenades[iReturnGrenadeIndex] ).AttachToClaimedByPawn();
}

//---------------------------------------------------------
//	IsGrenadeDangerous
//---------------------------------------------------------
function bool IsGrenadeDangerous( gbxExplosive Grenade )
{
	local Vector MeToGrenade;
	local float MeToGrenadeDot;

	if( Grenade == None )
		return false;

	MeToGrenade = (Grenade.Location - Pawn.Location);

	// Is the grenade close enough?
	if( VSize(MeToGrenade) < Grenade.DamageRadius )
	{
		// Is the grenade still moving and above my head?
		if( Grenade.IsA( 'gbxGrenade' ) && !gbxGrenade( Grenade ).bHitGround && Grenade.Location.Z > Pawn.Location.Z + Pawn.CollisionHeight )
		{
			MeToGrenadeDot = Normal(MeToGrenade * vect(1,1,0)) dot Normal(Grenade.Velocity * vect(1,1,0));

			// Is the grenade moving toward me?
			if( MeToGrenadeDot < 0.0 && Grenade.Velocity.Z < 0.0f )
			{
				return true;
			}
		}
		else
		{
			// The grenade has stopped (or is below my head), is there geometry between it and myself?
			if( FastTrace( Pawn.Location, Grenade.Location + vect(0,0,25) ) )
			{
				return true;
			}
		}
	}

	return false;
}

//---------------------------------------------------------
//	MostDangerousGrenadeIndex
//---------------------------------------------------------
function int MostDangerousGrenadeIndex()
{
	local int i, iDanger;


	iDanger = -1;

	// See if we already know about this grenade
	for(i = 0; i < PerceivedGrenades.Length; i++ )
	{
		if( PerceivedGrenades[i] != None )
		{
			if( IsGrenadeDangerous( PerceivedGrenades[i] ) )
			{
				if( iDanger < 0 || (VSize(PerceivedGrenades[i].Location - Pawn.Location) < VSize(PerceivedGrenades[iDanger].Location - Pawn.Location)) )
				{
					iDanger = i;
				}
			}
		}
	}

	return iDanger;
}

//---------------------------------------------------------
//	CleanUpGrenade
//---------------------------------------------------------
function CleanUpGrenade( gbxExplosive aGrenade )
{
	local int i;

//	log(self$".CleanUpGrenade( "$aGrenade$" )");

	if (WGPawn.LookAtTarget == aGrenade)
		WGPawn.SetLookingAtTarget( None );
		
	for( i = 0; i < PerceivedGrenades.Length; i++ )
	{
		if( PerceivedGrenades[i] == aGrenade )
		{
			PerceivedGrenades.Remove( i, 1 );
			break;
		}
	}
}

/// TURRET WEAPON RELATED ///////////////////////////////////////////////

//---------------------------------------------------------
//	CanCrewTurret
//---------------------------------------------------------
function bool CanCrewTurret( TurretWeapon TheTurret )
{
	local int i;
	
	if ( IsAssaulting() )
		return false;

	for( i=0; i < TargetQueue.Length; ++i )
	{
		if ( TargetQueue[i].bIgnored == 0 )
		{
			if ( TargetQueue[i].TargetDistance <= CombatRadius_NoTurretUsage || TargetQueue[i].TargetDistance <= TheTurret.EnemyTooCloseDist )
			{
				return false;
			}
			else
			if ( TargetQueue[i].MyExposureToTarget > 0 && !TheTurret.TargetIsInMyConeOfFire( TargetQueue[i].Target, true ) )	// Use narrow hysteresis to avoid dithering.
			{
				return false;
			}
		}
	}

	return true;
}

simulated function Unit GetUnit()
{
	return WGPawn.MyUnit;
}

//---------------------------------------------------------
//	GetWeaponReloadRate
//---------------------------------------------------------
function float GetWeaponReloadRate()
{
	return FiringController.GetWeaponReloadRate();
}

//---------------------------------------------------------
//	EnableGrenades
//---------------------------------------------------------
function EnableGrenades( bool bEnabled )
{
	if ( bEnabled )
	{
		CombatRadius_NoGrenades = Default.CombatRadius_NoGrenades;
	}
	else
	{
		CombatRadius_NoGrenades = 8000.0f;
	}
}

//---------------------------------------------------------
//	SetScriptedTargets
//---------------------------------------------------------
function SetScriptedTargets( Actor aTarget1, Actor aTarget2 )
{
	bUseScriptedTargets = true;

	if ((m_aTarget1 != aTarget1) || (m_aTarget2 != aTarget2))
		m_fChangeTarget = true;

	m_aTarget1 = aTarget1;
	m_aTarget2 = aTarget2;

	if ( m_aTarget1 != None && m_aTarget2 != None )
	{
		m_flTotalTargetTime = abs(VSize( m_aTarget1.Location - m_aTarget2.Location )) / TARGET_UNITS_PER_SEC;
		if (Rand( 1 ) == 1)
		{
			m_nTargetDir = 1;
		}
		else
		{
			m_nTargetDir = -1;
		}
	}
	else if ( m_aTarget1 == None && m_aTarget2 == None )
	{
		bUseScriptedTargets = false;
		return;
	}

	if (m_aTargetPawn == None)
	{
		m_aTargetPawn = Spawn( class'gbxTargetPawn', self,, m_aTarget1.Location, m_aTarget1.Rotation );
		
		if ( m_fTargetVisible )
		{
			m_aTargetPawn.Texture=Texture'Engine.S_PathNode';
			m_aTargetPawn.SetDrawType(DT_Sprite);
		}

		AddTarget( m_aTargetPawn );
	}
	
	log(self$".SetScriptedTargets( "$aTarget1$", "$aTarget2$" ) - "$m_aTargetPawn);
}

//---------------------------------------------------------
//	SetTargetMode
//---------------------------------------------------------
function SetTargetMode( ETargetModes nTargetMode )
{
	if (m_nTargetMode != nTargetMode)
		m_fChangeTarget = true;
	m_nTargetMode = nTargetMode;
	log(self$".SetTargetMode( "$nTargetMode$" )");
	if ((m_nTargetMode != TargetMode_Normal) && (m_aTargetPawn != None))
	{
		AddTarget( m_aTargetPawn );
	}
	m_flLastTargetTime = Level.TimeSeconds;
}

//---------------------------------------------------------
//	RemoveAllTargetsFromQueue
//---------------------------------------------------------
function RemoveAllTargetsFromQueue()
{
	TargetQueue.Remove( 0, TargetQueue.Length );

	if ( bUseAIDebugging && AITracker != None )
	{
		AITracker.RemoveAllEnemies();
	}

	m_fChangeTarget = false;
}

//=========================================================
// Default Properties
//=========================================================
defaultproperties
{
	bHidden=true

	bIsPlayer=true
	TimerInterval=0.5

	FacingPolicy=FACE_Destination

	FiringControllerClass=class'FiringControllerInfantry'
	NavigationControllerClass=class'NavigationController'

	StateStickTime=1.0
	PostureStickTime=1

	bLastCoverCheckFailed=false

	ForceTargetSortInterval=0.75

	ForceSwitchCoverInterval_Low=(min=10.00,max=15.0)
	ForceSwitchCoverInterval_High=(min=30.00,max=50.0)

	ForceLookForCover=3.0

	DestinationRadius=150.0

	MaxTargetRange=10000.0

	MinNoticeSneakerDist=1300.0
	MaxNoticeSneakerDist=2500.0
	NoticeSneakerShrinkFactor=0.5

	TargetPriorityScalarDistance			=1.0
	TargetPriorityScalarReallyClose			=5.0
	TargetPriorityScalarAttackLevel			=0.12	// was 0.4
	TargetPriorityScalarAlreadyTargetted	=0.1
	TargetPriorityScalarTargetExposureToMe	=0.75
	TargetPriorityScalarMyExposureToTarget	=0.75
	TargetPriorityScalarInAssignedUnit		=2.0
	TargetPriorityScalarHumanPlayer			=0.01
	TargetPriorityScalarTargetImpervious	= -3.0
	TargetPriorityScalarSurprisedBy			= 5.0

	AcquisitionYawRate=30000

	RelegationDuration=10.0

	AttackLevelDecay=0.03
	DistractionLevelDecay=0.1667	

	NearbyBulletAnimDelay=8.0

	GrenadeTossBackMaxDist=128.0
	GrenadeFusePanicTime=1.0
	bFleeGrenades=true
	GrenadeReactionDelay=0.25	
	
	StealNodePatience=2.0

	CombatRadius_Melee=600.0
	CombatRadius_NoGrenades=1000.0	// was 500.0
	CombatRadius_Deadlock=900.0		// was 750.0
	CombatRadius_Grenade=2000.0
	CombatRadius_NoOpBurst=2000.0
	CombatRadius_NoWarningShots=975.0 //was 1800.0// was 1000.0
	CombatRadius_MaxMeleePursuit=1200.0
	CombatRadius_AlwaysMiss=5000.0
	CombatRadius_NoFFC=1200.0
	CombatRadius_CommentaryEnemies=800.0
	CombatRadius_CommentaryPlayer=2000.0
	CombatRadius_NoRelegation=1200.0		// Synchronize with CombatRadius_NoFFC
	CombatRadius_NoTurretUsage=1500.0
	
	TargetCSSIntervalMedium=3.0
	TargetEvaluationIntervalFar=6.0
	TargetRangeMedium=2.0
	TargetRangeFar=4.0

	bAntsyGermans=true

	TargetForgetDist=1000.0f
	TargetForgetTimeSP=30.0f
	TargetForgetTimeMP_Long=30.0f
	TargetForgetTimeMP_Short=15.0f
	DistractionForgetfulnessMP=1.5f
	SurpriseDecayTime=15.0f

	SurpriseCosThetaMax=0.2589			// ~75 degrees on each side of center
	SurpriseCosThetaMin=-0.1736			// ~100 degrees on each side of center
	SurpriseCosThetaMax_Firing=0.7071	// ~45 degrees on each side of center
	SurpriseCosThetaMin_Firing=0.5		// 60 degrees on each side of center
	
	NoVantageDueToFriendlyCosTheta=0.97

	FlankAlarmDuration=15.0f	// When flanked, stay alert for 15 seconds.

	MyLogSelectName="MIND"

	noshow=true
	bLogSelect=false;

	ScoringNavPointFORMCDistance=1000.0
	ScoringNavPointFORMCDistanceScale=50.0
	ScoringCoverPawnDistance=4000.0
	ScoringCoverPawnDistanceScale=40.0
	ScoringCoverAdjacentDirection=25.0
	ScoringCornerCoverHasVantage=100.0
	ScoringHasVantage=100.0
	ScoringCoverNearFormationIdealDistance=1000.0
	ScoringCoverNearFormationIdealDistanceScale=10.0
	FearCostScale=2.0

	RotationRateRelaxed=(Pitch=3072,Yaw=10000,Roll=2048)
	RotationRateInCombat=(Pitch=3072,Yaw=70000,Roll=2048)

	bMatchAttackLevels=false
	bDontLetMindTick=false

	MaxSecondsPerNTF=1.0
	TargetOrderRulesDuration=12.0f
	
	LastTimeNearbyTrace=0
	NumTracesPerSpeech=0
	TimeBetweenSpeeches=7.5
}
class MindFlakvierlingGunner extends Mind;

var Actor TargetActor;
var Pawn MyAttacker;
var bool bFleeGrenade;
var bool bIsFiring;
var bool bWaitForTimer;
var float TimerEndTime;
var float EnemyTooCloseDist;

//---------------------------------------------------------
// Possess
//---------------------------------------------------------
function Possess(Pawn aPawn)
{
	Super.Possess( aPawn );

	WGPawn.m_bUsingCrouchedCover = false;
	WGPawn.m_bCornerFiring = false;
	WGPawn.m_bCornerHunkered = false;
	WGPawn.m_bCornerPeeking = false;
	WGPawn.m_bStandingOverCorner = false;
	WGPawn.m_bStandPeeking = false;

	FiringControllerFlakv( FiringController ).StartGunningTurret();
}

//---------------------------------------------------------
//	StartJob
//---------------------------------------------------------
function StartJob( optional EJobType NewJob )
{
	local float ThinkStart;

	Super.StartJob( NewJob );
	WGPawn.CompleteTurretMount( false );
	EnemyTooCloseDist = WGPawn.Turret.EnemyTooCloseDist;

	TimerInterval = Level.AIMaxThinkInterval;
	ThinkStart = 1 + Level.AIGetNextThinkStart();
	SetTimer( ThinkStart, true );

	EnemyTooCloseDist = WGPawn.Turret.EnemyTooCloseDist;

	GotoState( 'ManningFlakvierling' );
}

function TransitionToCombatReady() {}
function NotifyCombatReady() {}

//=========================================================
//	State ManningFlakvierling
//=========================================================
state ManningFlakvierling
{
	//---------------------------------------------------------
	//	BeginState (ManningFlakvierling)
	//---------------------------------------------------------
	function BeginState()
	{
		if ( !bIsFiring )
		{
			WGPawn.FlushAnimQueueChannel( 0 );
			WGPawn.PlayWaiting();
		}
	}

	//---------------------------------------------------------
	//	DecideFacingPolicy (ManningFlakvierling)
	//---------------------------------------------------------
	function DecideFacingPolicy()
	{
		logSelective( "DecideFacingPolicy." );
		RequestFacingPolicy( FACE_Vector );
	}

	//---------------------------------------------------------
	//	RequestFacingPolicy (ManningFlakvierling)
	//---------------------------------------------------------
	function bool RequestFacingPolicy( EFacingPolicy policy )
	{
		logSelective( "RequestFacingPolicy: policy=="$policy );
		if ( policy == FACE_Vector )
		{
			SetFacingPolicy( policy );
			return true;
		}
		else
		{
			return false;
		}
	}

	//---------------------------------------------------------
	// NotifyBeginFiring (ManningFlakvierling)
	//---------------------------------------------------------
	function NotifyBeginFiring()
	{
		bIsFiring = true;
		WGPawn.FlushAnimQueueChannel( 0 );
		WGPawn.AddAnimToQueue( 'Flakv_gunner_fire', 95.0, true, false,,, 0.1 );
	}
	
	//---------------------------------------------------------
	// NotifyStopFiring (ManningFlakvierling)
	//---------------------------------------------------------
	function NotifyStopFiring()
	{
		bIsFiring = false;
		WGPawn.PlayWaiting();
	}

	//---------------------------------------------------------
	// NotifyIdleFinished (ManningFlakvierling)
	//---------------------------------------------------------
	function NotifyIdleFinished() 
	{
		if ( !bIsFiring )
		{
			WGPawn.FlushAnimQueueChannel( 0 );
			WGPawn.PlayWaiting();
		}
	}	

	//---------------------------------------------------------
	//	SetRandomTargetPoint (ManningFlakvierling)
	//---------------------------------------------------------
	function SetRandomTargetPoint()
	{
		local Vector TargetPoint;

		TargetPoint = WGPawn.Location;
		TargetPoint.Z += Rand(10000);

		TargetPoint.X += Rand(10000) - 5000;
		TargetPoint.Y += Rand(10000) - 5000;
		
		FiringControllerFlakv( FiringController ).SetTargetPoint( TargetPoint );
	}

	//---------------------------------------------------------
	//	SeeImpact (ManningFlakvierling)
	//---------------------------------------------------------
	function SeeImpact( Pawn instigator, float impactSeverity, float distance )
	{
		Super.SeeImpact( instigator, impactSeverity, distance );
		WGPawn.Turret.ForceCrewDismount( instigator );
	}

	//---------------------------------------------------------
	//	NotifyNearbyTrace (ManningFlakvierling)
	//---------------------------------------------------------
	function NotifyNearbyTrace( Actor Other, vector TouchLocation, vector TouchNormal, vector End, vector Start, vector Extent, int TraceFlags )
	{
		Super.NotifyNearbyTrace( Other, TouchLocation, TouchNormal, End, Start, Extent, TraceFlags );
		WGPawn.Turret.ForceCrewDismount( Pawn( Other ) );
	}

	//---------------------------------------------------------
	//	NotifyTakeHit (ManningFlakvierling)
	//---------------------------------------------------------
	function NotifyTakeHit(pawn InstigatedBy, vector HitLocation, int Damage, class<DamageType> damageType, vector Momentum)
	{
		MyAttacker = gbxPawn( instigatedBy );
		Super.NotifyTakeHit( InstigatedBy, HitLocation, Damage, damageType, Momentum );
		WGPawn.Turret.ForceCrewDismount( InstigatedBy );
	}

	//---------------------------------------------------------
	//	FleeGrenadeAction (ManningFlakvierling)
	//---------------------------------------------------------
	function FleeGrenadeAction()
	{
		bFleeGrenade = true;
		WGPawn.Turret.ForceCrewDismount();
	}	

	//---------------------------------------------------------
	// BreakOutJustMe (ManningFlakvierling)
	//---------------------------------------------------------
	function BreakOutJustMe( optional Pawn InstigatedBy )
	{		
		MyAttacker = InstigatedBy;
		GotoState( 'Dismounting' );
	}	

	//---------------------------------------------------------
	// SetOneOffTimer (ManningFlakvierling)
	//---------------------------------------------------------
	function SetOneOffTimer( float Duration )
	{
		bWaitForTimer = true;
		TimerEndTime = Level.TimeSeconds + Duration;
	}

	//---------------------------------------------------------
	// Tick (ManningFlakvierling)
	//---------------------------------------------------------
	function Tick( float DeltaTime )
	{
		Super.Tick( DeltaTime );
		
		if ( bWaitForTimer )
		{
			if ( Level.TimeSeconds > TimerEndTime )
			{
				bWaitForTimer = false;
				TimerEndTime = 0.0;
			}
		}
	}

	//---------------------------------------------------------
	// Timer (ManningFlakvierling)
	//---------------------------------------------------------
	function Timer()
	{
		local int i;
		local gbxPawn LeftLoader, RightLoader;

		Super.Timer();		// Do all of the thinking a normal Mind does...

		// Then, check if we need to leave the weapon.
		LeftLoader = WeapDEFlakvierling( WGPawn.Turret ).LeftLoader;		
		RightLoader = WeapDEFlakvierling( WGPawn.Turret ).RightLoader;		

		if ( LeftLoader == None || LeftLoader.IsDead() || RightLoader == None || RightLoader.IsDead() )
		{
			WGPawn.Turret.ForceCrewDismount();
		}

		for ( i=0; i < TargetQueue.Length; ++i )
		{
			if ( TargetQueue[i].bIgnored == 0 )
			{
				if ( TargetQueue[i].TargetDistance <= EnemyTooCloseDist )
				{
					WGPawn.Turret.ForceCrewDismount();
				}
			}
		}
	}

//-----------------------------------------
Begin:		// state ManningFlakvierling
//-----------------------------------------
	if ( WGPawn.Turret != None )
	{
		if ( WeapDEFlakvierling( WGPawn.Turret ).GetTargetActor() != None )
		{
			TargetActor = WeapDEFlakvierling( WGPawn.Turret ).GetTargetActor();
			FiringControllerFlakv( FiringController ).SetTargetPoint( TargetActor.Location );
			Sleep( 0.2 );
		}
		else
		{
			SetRandomTargetPoint();			
			SetOneOffTimer( 10.0 );
			while ( bWaitForTimer && WeapDEFlakvierling( WGPawn.Turret ).GetTargetActor() == None )
				Sleep( 0.2 );
		}
	}
	else
	{	
		Sleep( 1.0 );
	}


	Goto( 'Begin' );
}

//=========================================================
//	State Dismounting
//=========================================================
state Dismounting extends ManningFlakvierling
{	
	//---------------------------------------------------------
	//	BeginState (Dismounting)
	//---------------------------------------------------------
	function BeginState()
	{		
		MountController.DoMountAction( Mount_DismountFlakVGunner, None, false, false, class'FlakvierlingCallback', WGPawn.Rotation );
	}

	//---------------------------------------------------------
	//	PostMindChangeTasks
	//---------------------------------------------------------
	function PostMindChangeTasks( Mind NewMind ) 
	{
		Super.PostMindChangeTasks( NewMind );

		NewMind.StartJob();
		
		/*
		if ( bFleeGrenade )
			NewMind.MindSwitchedFleeGrenade( MyAttacker, PerceivedGrenades );		
		else
			NewMind.MindSwitched( MyAttacker );		
		*/

		MyAttacker = None;
	}
}

simulated function bool GoToDeadGuy( gbxPawn aPawn ) { return false; }

//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
	FiringControllerClass=class'FiringControllerFlakV'
	MyLogSelectName="MINDFLAKVGUNNER"
}class MindFlakvierlingLoader extends Mind;

var	Name	BracingAnim;
var Pawn	MyAttacker;
var bool	bBracing, bFleeGrenade;

//---------------------------------------------------------
// Possess
//---------------------------------------------------------
function Possess(Pawn aPawn)
{
	Super.Possess( aPawn );

	WGPawn.m_bUsingCrouchedCover = false;
	WGPawn.m_bCornerFiring = false;
	WGPawn.m_bCornerHunkered = false;
	WGPawn.m_bCornerPeeking = false;
	WGPawn.m_bStandingOverCorner = false;
	WGPawn.m_bStandPeeking = false;	

	BracingAnim = WeapDEFlakvierling( WGPawn.Turret ).GetBracingAnim( WGPawn );

	FiringControllerFlakv( FiringController ).StartLoadingTurret();	
}

//---------------------------------------------------------
//	StartJob
//---------------------------------------------------------
function StartJob( optional EJobType NewJob )
{
	local float ThinkStart;

	Super.StartJob( NewJob );
	WGPawn.CompleteTurretMount( false );

	TimerInterval = Level.AIMaxThinkInterval;
	ThinkStart = 1 + Level.AIGetNextThinkStart();
	SetTimer( ThinkStart, true );

	GotoState( 'ManningFlakvierling' );
}

function TransitionToCombatReady() {}
function NotifyCombatReady() {}

//=========================================================
//	State ManningFlakvierling
//=========================================================
state ManningFlakvierling
{	
	//---------------------------------------------------------
	//	BeginState (ManningFlakvierling)
	//---------------------------------------------------------
	function BeginState()
	{
		bBracing = false;
		WGPawn.FlushAnimQueueChannel( 0 );
		WGPawn.PlayWaiting();
	}

	//---------------------------------------------------------
	// NotifyBeginFiring (ManningFlakvierling)
	//---------------------------------------------------------
	function NotifyBeginFiring() 
	{
		GotoState( 'BracingSelf' );
	}

	//---------------------------------------------------------
	// Reload (ManningFlakvierling)
	//---------------------------------------------------------
	function ReloadTurret()
	{
		GotoState( 'Reloading' );
	}	

	//---------------------------------------------------------
	//	SeeImpact (ManningFlakvierling)
	//---------------------------------------------------------
	function SeeImpact( Pawn instigator, float impactSeverity, float distance )
	{
		Super.SeeImpact( instigator, impactSeverity, distance );
		WGPawn.Turret.ForceCrewDismount( instigator );
	}

	//---------------------------------------------------------
	//	NotifyNearbyTrace (ManningFlakvierling)
	//---------------------------------------------------------
	function NotifyNearbyTrace( Actor Other, vector TouchLocation, vector TouchNormal, vector End, vector Start, vector Extent, int TraceFlags )
	{
		Super.NotifyNearbyTrace( Other, TouchLocation, TouchNormal, End, Start, Extent, TraceFlags );
		WGPawn.Turret.ForceCrewDismount( Pawn( Other ) );
	}

	//---------------------------------------------------------
	//	NotifyTakeHit (ManningFlakvierling)
	//---------------------------------------------------------
	function NotifyTakeHit(pawn InstigatedBy, vector HitLocation, int Damage, class<DamageType> damageType, vector Momentum)
	{
		MyAttacker = gbxPawn( instigatedBy );
		Super.NotifyTakeHit( InstigatedBy, HitLocation, Damage, damageType, Momentum );
		WGPawn.Turret.ForceCrewDismount( InstigatedBy );
	}

	//---------------------------------------------------------
	//	FleeGrenadeAction (ManningFlakvierling)
	//---------------------------------------------------------
	function FleeGrenadeAction()
	{
		bFleeGrenade = true;
		WGPawn.Turret.ForceCrewDismount();

	}
	//---------------------------------------------------------
	// BreakOutJustMe (ManningFlakvierling)
	//---------------------------------------------------------
	function BreakOutJustMe( optional Pawn InstigatedBy )
	{		
		MyAttacker = InstigatedBy;
		GotoState( 'Dismounting' );
	}	

	//---------------------------------------------------------
	// NotifyIdleFinished (ManningFlakvierling)
	//---------------------------------------------------------
	function NotifyIdleFinished() 
	{
		WGPawn.PlayWaiting();
	}

	//---------------------------------------------------------
	// Timer (ManningFlakvierling)
	//---------------------------------------------------------
	function Timer()
	{
		local gbxPawn Gunner;

		Super.Timer();		// Do all of the thinking a normal Mind does...

		// Then, check if we need to leave the weapon.		
		Gunner = WeapDEFlakvierling( WGPawn.Turret ).Gunner;		
		if ( Gunner == None || Gunner.IsDead() )
		{
			WeapDEFlakvierling( WGPawn.Turret ).ForceCrewDismount();
		}		
	}
}

//=========================================================
//	State BracingSelf
//=========================================================
state BracingSelf extends ManningFlakvierling	
{
	//---------------------------------------------------------
	//	BeginState (BracingSelf)
	//---------------------------------------------------------
	function BeginState()
	{
		bBracing = true;
	}
	
	function EndState() {}

	function NotifyBeginFiring() {}

	//---------------------------------------------------------
	//	NotifyStopFiring (BracingSelf)
	//---------------------------------------------------------
	function NotifyStopFiring() 
	{
		GotoState( 'TransitionBackToNormal' );
	}

Begin:
	WGPawn.AddAnimToQueue( BracingAnim, WGPawn.QUEUE_COWER_IDLE_PRIORITY, false, true,,, 0.2 );

	Sleep( 0.5 );
	Goto( 'Begin' );
}

//=========================================================
//	State TransitionBackToNormal
//=========================================================
state TransitionBackToNormal extends ManningFlakvierling
{
	function BeginState() {}
	function EndState() {}

Begin:
	WGPawn.AddAnimToQueue( WGPawn.PawnAnimInfoClass.Static.PawnIdleAnim( WGPawn ), WGPawn.QUEUE_COWER_IDLE_PRIORITY+1, true, false,,, 0.5 );
	//WGPawn.PlayAnim( WGPawn.PawnAnimInfoClass.Static.PawnIdleAnim( WGPawn ), 1.0, 0.5 );
	
	Sleep( 1.0 );
	
	GotoState( 'ManningFlakvierling' );
}

//=========================================================
//	State Reloading
//=========================================================
state Reloading extends ManningFlakvierling
{
	function BeginState() {}
	function EndState() {}

	//---------------------------------------------------------
	// NotifyReloadFinished (Reloading)
	//---------------------------------------------------------
	function NotifyReloadFinished()
	{
		if ( bBracing )
			GotoState( 'BracingSelf' );
		else
			GotoState( 'ManningFlakvierling' );
	}

Begin:
	WGPawn.AddAnimToQueue( WGPawn.PawnAnimInfoClass.Static.PawnReloadAnim( WGPawn ), WGPawn.QUEUE_COWER_IDLE_PRIORITY+2, true, false, true, 1.0, 0.15, class'FlakVReloadCallback' );
}

//=========================================================
//	State Dismounting
//=========================================================
state Dismounting extends ManningFlakvierling
{
	//---------------------------------------------------------
	//	BeginState (Dismounting)
	//---------------------------------------------------------
	function BeginState()
	{
		Super.BeginState();
		MountController.DoMountAction( Mount_DismountFlakVLoader, None, false, false, class'FlakvierlingCallback', WGPawn.Rotation );
	}

	//---------------------------------------------------------
	//	PostMindChangeTasks
	//---------------------------------------------------------
	function PostMindChangeTasks( Mind NewMind ) 
	{
		Super.PostMindChangeTasks( NewMind );

		NewMind.StartJob();
		
		/*
		if ( bFleeGrenade )
			NewMind.MindSwitchedFleeGrenade( MyAttacker, PerceivedGrenades );		
		else
			NewMind.MindSwitched( MyAttacker );			
		*/

		MyAttacker = None;
	}
}

simulated function bool GoToDeadGuy( gbxPawn aPawn ) { return false; }

//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
	FiringControllerClass=class'FiringControllerFlakV'
	//MyLogSelectName="MINDFLAKVLOADER"
}class MindHalftrackMG42Gunner extends Mind
	native;

cpptext
{
	virtual float CalculateTargetPriority( FTargetInfo& targetInfo, int ndx, float closestDistance );
}

//---------------------------------------------------------
//	Variables / Constants
//---------------------------------------------------------
var gbxPawn	MyAttacker;
var float	CheckTime;
var float	EnemyTooCloseDist;
var float	BreakOutNoMatterWhatDist;

var bool bGunnerDismountsWhenFlanked;

var Halftrack MyHalftrack;


//---------------------------------------------------------
// Possess
//---------------------------------------------------------
function Possess(Pawn aPawn)
{
	local gbxPawn gbxP;

	Super.Possess( aPawn );

	gbxP = gbxPawn( aPawn );
	gbxP.m_bUsingCrouchedCover = false;
	gbxP.m_bCornerFiring = false;
	gbxP.m_bCornerHunkered = false;
	gbxP.m_bCornerPeeking = false;
	gbxP.m_bStandingOverCorner = false;
	gbxP.m_bStandPeeking = false;
}

function SetVehicle( gbxSVehicle MyVehicle )
{
	MyHalfTrack = Halftrack(MyVehicle);
}

//---------------------------------------------------------
//	ChangeMind
//---------------------------------------------------------
function gbxAIController ChangeMind( optional class<gbxAIController> NewMindClass )
{
	if ( NewMindClass == None || NewMindClass != Self.Class )
	{
		return Super.ChangeMind( NewMindClass );
	}
	else
	{
		return Self;
	}
}

//---------------------------------------------------------
//	StartJob
//---------------------------------------------------------
function StartJob( optional EJobType NewJob )
{
	local float ThinkStart;

	Super.StartJob( NewJob );

	EnemyTooCloseDist = WGPawn.Turret.EnemyTooCloseDist;

	TimerInterval = Level.AIMaxThinkInterval;
	ThinkStart = 1 + Level.AIGetNextThinkStart();
	SetTimer( ThinkStart, true );

	FiringController.StartManningTurret();

	GotoState( 'ManningMG' );
}

function TransitionToCombatReady() {}
function NotifyCombatReady() {}


// Overridden to prevent movement.
function SetDesiredDestination( ActorLite CoverPoint, optional bool bMustLeaveCover ) {}
function bool DecideDestCore( bool bPreferVantage, ActorLite NavPoint, Vector DummyThreatLoc, optional bool bMustLeaveCover ) 
{
	return false;
}

//---------------------------------------------------------
// NotifyTakeHit
//---------------------------------------------------------
function NotifyTakeHit(pawn InstigatedBy, vector HitLocation, int Damage, class<DamageType> damageType, vector Momentum)
{
	MyAttacker = gbxPawn( InstigatedBy );
	Super.NotifyTakeHit( InstigatedBy, HitLocation, Damage, damageType, Momentum );
	if (bGunnerDismountsWhenFlanked)
		BreakOutJustMe( InstigatedBy );
}

//---------------------------------------------------------
// DecideState
//---------------------------------------------------------
function DecideState()
{
}

//---------------------------------------------------------
//	FleeGrenadeAction (FiringFromCover)
//---------------------------------------------------------
function FleeGrenadeAction()
{
	LogSelective( "FleeGrenadeAction()." );
	if (bGunnerDismountsWhenFlanked)
		BreakOutJustMe();
}

//---------------------------------------------------------
//	PostMindChangeTasks
//---------------------------------------------------------
function PostMindChangeTasks( Mind NewMind ) 
{
	Super.PostMindChangeTasks( NewMind );

	NewMind.StartJob();

	MyAttacker = None;
}

//---------------------------------------------------------
//	ShouldMelee
//---------------------------------------------------------
function bool ShouldMelee()
{
	return false;
}

//---------------------------------------------------------
//	RequestPawnToCrouch
//---------------------------------------------------------
function RequestPawnToCrouch()
{
}

//---------------------------------------------------------
// Stub functions - implemented in states
//
function MountOrDismountFinished( bool bSuccess, EMountAction MountAction ) 
{
	log("NAJ**** "$Self.Name$" WARNING!!!!!!! Function MountOrDismountFinished called outside of DismountingMG state.", 'naj' );
}
	
function BreakOutJustMe( optional Pawn InstigatedBy )
{
}
	
function PrioritizeTargets()
{
}

function Trigger( actor Other, Pawn EventInstigator )
{
	BreakOutJustMe();  // dismount from the MG42 (only valid while in the ManningMG state)
}


//=========================================================
//	State ManningMG
//=========================================================
state ManningMG
{
	//---------------------------------------------------------
	// BeginState
	//---------------------------------------------------------
	function BeginState()
	{
		Super.BeginState();

		WGPawn.bDoTorsoTwist = false;
	}

	//---------------------------------------------------------
	// BreakOutJustMe
	//---------------------------------------------------------
	function BreakOutJustMe( optional Pawn InstigatedBy )
	{
		WGPawn.bUseCustomDeathAnim = false;
		WGPawn.bDontDropWeapon = false;

		WGPawn.bHardAttach = false;
		SetBase(None);

		WGPawn.Controller.bGodMode = true;  // dismounting Pawns can't be killed until dismount is finished

		if (FiringController != None)
		{
			FiringController.Destroy();
			FiringController = None;
		}

		MountController.DoMountAction( Mount_DismountHalftrackMG42Gunner, None, false, true, class'MountHalftrackMG42Callback', WGPawn.Rotation );

		GotoState( 'DismountingMG' );
	}

	//---------------------------------------------------------
	//	ShouldIDismount
	//---------------------------------------------------------
	function bool ShouldIDismount( Pawn Instigator )
	{
		return !Instigator.SameTeamAs( WGPawn ) && !WGPawn.Turret.PointIsInMyConeOfFire( Instigator.Location );
	}

	//---------------------------------------------------------
	//	SeeImpact
	//---------------------------------------------------------
	function SeeImpact( Pawn instigator, float impactSeverity, float distance )
	{
		Super.SeeImpact( instigator, impactSeverity, distance );

		if (bGunnerDismountsWhenFlanked)
		{
			if ( ShouldIDismount( instigator ) )
			{
				BreakOutJustMe( instigator );
			}
		}
	}

	//---------------------------------------------------------
	//	NotifyNearbyTrace
	//---------------------------------------------------------
	function NotifyNearbyTrace( Actor Other, vector TouchLocation, vector TouchNormal, vector End, vector Start, vector Extent, int TraceFlags )
	{
		Super.NotifyNearbyTrace( Other, TouchLocation, TouchNormal, End, Start, Extent, TraceFlags );

		if (bGunnerDismountsWhenFlanked)
		{
			if ( Other.IsA( 'Weapon' ) || Other.IsA( 'WeaponFire' ) )
			{
				if ( Other.Instigator != None && ShouldIDismount( Other.Instigator ) )
				{
					BreakOutJustMe( Other.Instigator );
				}
			}
		}
	}

	//---------------------------------------------------------
	// NotifyTargetFailure
	//---------------------------------------------------------
	function NotifyTargetFailure( Pawn Target, optional ETargetFailure FailCode, optional gbxPawn TheBlocker )
	{
		Super.NotifyTargetFailure( Target, FailCode, TheBlocker );

		if ((bGunnerDismountsWhenFlanked) && ( FailCode == FAIL_NoVantage ))
		{
			if ( !WGPawn.Turret.TargetIsInMyConeOfFire( gbxPawn( Target ) ) )
			{
				if ( VSizeIgnoreZ( Target.Location - WGPawn.Turret.Location ) <= EnemyTooCloseDist )
				{
					BreakOutJustMe( Target );
				}
			}
		}
	}

	//---------------------------------------------------------
	// PrioritizeTargets
	//---------------------------------------------------------
	function PrioritizeTargets()
	{
		Super.PrioritizeTargets();
	}

	//---------------------------------------------------------
	// Timer
	//---------------------------------------------------------
	function Timer()
	{
		local int i, iLastEnemy;
		local bool bAtLeastOneEnemyInForwardCone, bAtLeastOneEnemyCanShootMe;

		for ( i=0; i < TargetQueue.Length; ++i )
		{
			if ( TargetQueue[i].bIgnored == 0 )
			{
				if ( !bAtLeastOneEnemyInForwardCone )
				{
					bAtLeastOneEnemyInForwardCone = WGPawn.Turret.TargetIsInMyConeOfFire( TargetQueue[i].Target );
				}

				if ( !bAtLeastOneEnemyCanShootMe )
				{
					bAtLeastOneEnemyCanShootMe = ( TargetQueue[i].MyExposureToTarget > 0 );

					if( bAtLeastOneEnemyCanShootMe )
						iLastEnemy = i;
				}

				if (bGunnerDismountsWhenFlanked)
				{
					if ( TargetQueue[i].TargetDistance <= BreakOutNoMatterWhatDist ||
						( TargetQueue[i].TargetDistance <= EnemyTooCloseDist && !WGPawn.Turret.TargetIsInMyConeOfFire( TargetQueue[i].Target ) ) )
					{
						BreakOutJustMe( TargetQueue[i].Target );
					}
				}
			}
		}

		if ( bGunnerDismountsWhenFlanked && !bAtLeastOneEnemyInForwardCone && bAtLeastOneEnemyCanShootMe )
		{
			BreakOutJustMe( TargetQueue[ iLastEnemy ].Target );
		}

		Super.Timer();		
	}

Begin:
	while (WGPawn.Turret == None)
		sleep(0.1);

	if (WGPawn.Turret.Owner.IsA('Halftrack'))
		bGunnerDismountsWhenFlanked = Halftrack(WGPawn.Turret.Owner).bGunnerDismountsWhenFlanked;
}

//=========================================================
//	State DismountingMG
//=========================================================
state DismountingMG
{
	//---------------------------------------------------------
	//	MountOrDismountFinished
	//---------------------------------------------------------
	function MountOrDismountFinished( bool bSuccess, EMountAction MountAction ) 
	{
		local vector PlayerLoc;
		local vector vPlayer;  // vector from vehicle toward player
		local vector vRotation;  // vector in the direction vehicle is facing
		local vector vCross;
		local rotator NewRot;

		// determine whether to dismount on the Left or Right side of the vehicle (on the opposite side from the player)...

		PlayerLoc = Level.GetLocalPlayerController().Pawn.Location;
		vPlayer = PlayerLoc - Location;
		vRotation = vector(MyHalfTrack.Rotation);
		vCross = vRotation cross vPlayer;
		if (vCross.Z > 0)
		{
			NewRot = MyHalfTrack.Rotation;
			NewRot.Yaw = (NewRot.Yaw + 49152) & 65535;  // dismount to the Left side
		}
		else
		{
			NewRot = MyHalfTrack.Rotation;
			NewRot.Yaw = (NewRot.Yaw + 16384) & 65535;  // dismount to the Right side
		}

		MountController.DoMountAction( Mount_DismountHalftrackPassenger, None, false, true, class'MountHalftrackMG42Callback', NewRot );

		GotoState( 'DismountingHalftrack' );
	}
}

//=========================================================
//	State DismountingMG
//=========================================================
state DismountingHalftrack
{
	//---------------------------------------------------------
	//	MountOrDismountFinished
	//---------------------------------------------------------
	function MountOrDismountFinished( bool bSuccess, EMountAction MountAction ) 
	{
		WGPawn.Controller.bGodMode = false;

		ChangeMind();
	}
}
	
simulated function DisplayDebug(Canvas Canvas, out float YL, out float YPos)
{
	Super.DisplayDebug( Canvas, YL, YPos );

	if ( FiringController != None )
	{
		FiringController.DisplayDebug( Canvas, YL, YPos );
	}

	// TEST
	//Canvas.DrawTile3D(Texture't_interface_mb.debug.FC_Bullseye', WeapDEMG42_( WGPawn.Turret ).GetMuzzleLocationWorld(), 32, 32, 0, 0, 32, 32);
}

simulated function bool GoToDeadGuy( gbxPawn aPawn ) { return false; }

//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
	FiringControllerClass=class'FiringControllerHalftrackMG'
	CheckTime=0.0

	TargetPriorityScalarDistance=5.0
	TargetPriorityScalarSurprisedBy=1.0			// Surprise is not as important as distance.
	TargetPriorityScalarAlreadyTargetted=0.0	// MG42 gunners cover a lots of targets and shouldn't linger on any one.

	MyLogSelectName="MINDHTMG42GUNNER"
	
	BreakOutNoMatterWhatDist=250.0

	bGunnerDismountsWhenFlanked=true
}class MindHalftrackPassenger extends Mind;

var Halftrack MyHalftrack;


//---------------------------------------------------------
//	PostNetBeginPlay
//---------------------------------------------------------
function PostNetBeginPlay()
{
	local float ThinkStart;

	Super.PostNetBeginPlay();

	Level.MessageManager.AddListener( Self );

	FiringController = Spawn( FiringControllerClass );
	FiringController.SetMind( Self );

	TimerInterval = Level.AIMaxThinkInterval;
	ThinkStart = 1 + Level.AIGetNextThinkStart();

	log( Name $ ".PostNetBeginPlay() - Thinking will be delayed " $ ThinkStart $ " sec.", 'Mind' );

	SetTimer( ThinkStart, true );
}

function SetVehicle( gbxSVehicle MyVehicle )
{
	MyHalfTrack = Halftrack(MyVehicle);
}

//---------------------------------------------------------
//	ChangeMind
//---------------------------------------------------------
function gbxAIController ChangeMind( optional class<gbxAIController> NewMindClass )
{
	if ( NewMindClass == None || NewMindClass != Self.Class )
	{
		return Super.ChangeMind( NewMindClass );
	}
	else
	{
		return Self;
	}
}

function Possess(Pawn aPawn)
{
	super.Possess(aPawn);

	Pawn.SetMovementPhysics();
	if (Pawn.Physics != PHYS_Walking)
		Pawn.SetPhysics(PHYS_Falling);

	WGPawn = WargamePawn( aPawn );

	if (FiringController != None)
	{
		FiringController.Possess(aPawn);
	}

	if (NavigationController != None)
	{
		NavigationController.Destroy();
		NavigationController = None;
	}

	// Lock position to the pawn's position
	SetLocation( aPawn.Location );
	SetBase( aPawn );

	fApproachingTime = 0.0;

	GotoState('FiringFromCover');
}

function bool DecideDestElsewhereNew( bool bMustHaveVantage, optional bool bIsRepeat ) { return false; }
function bool DecideDestElsewhere(  optional bool bIsRepeat ) { return false; }
function bool DecideDestAnywhere( optional bool bMustLeaveCover ) { return false; }
function bool DecideDestAnywhereHasVantage() { return false; }
function bool DecideDestApproaching( Actor OtherActor, Vector OtherMovementDirection ) { return false; }
function bool DecideDestAnywhereHasPerfectCover() { return false; }
function bool DecideDestBetterCover( bool bMustHaveVantage, optional bool bIsRepeat ) { return false; }

//---------------------------------------------------------
//	BreakRelaxation
//---------------------------------------------------------
/*
function BreakRelaxation()
{
	bRelaxationBroken = true;
}
*/

//---------------------------------------------------------
//	MindSwitchedFleeGrenade
//---------------------------------------------------------
function MindSwitchedFleeGrenade( Pawn newEnemy, array<gbxExplosive> NewPerceivedGrenades )  
{
}

//---------------------------------------------------------
//	SetEnemy
//---------------------------------------------------------
function bool SetEnemy( Pawn newEnemy )
{
	if ( WGPawn == None )
		return false;

	// Sanity check: Check that the 'enemy' is not actually on your own team!
	if ( newEnemy != None && WGPawn.PawnTeam == newEnemy.PawnTeam )
	{
		log( "ERROR: Pawn "$WGPawn$" cannot set teammate "$newEnemy$" as his enemy!", 'ScriptWarning' );
		return false;
	}

	// Last check: If the "notarget" console command has been entered, don't set human players as enemies.
	if ( newEnemy != None && newEnemy.IsHumanControlled() )
	{
		if ( gbxPlayerController( newEnemy.Controller ).bNeverEnemy )
			return false;
	}

	// If the battle is just starting, set the pawn to fully fatigued.
	if ( Enemy == None && newEnemy != None )
	{
		LogSelective( "Setting enemy "$newEnemy$" for the first time, jogging fatigue." );
		JogFatigue( WGPawn.FatigueJog_Rotation );
	}

	if( newEnemy != Enemy )
	{
		Enemy = newEnemy;
		FiringController.SetTarget( newEnemy );
		// GBX:PAD: Make sure to update the ground speed if these guys change their enemy.  If they have an enemy, we
		// don't want them to limp, but if they don't, they should go back to limping.
		WGPawn.UpdateGroundSpeed();

		return true;
	}
	return false;
}

//---------------------------------------------------------
//	IsNavigating
//---------------------------------------------------------
function bool IsNavigating()
{
	return false;
}

//---------------------------------------------------------
//	SetDesiredDestination
//---------------------------------------------------------
function SetDesiredDestination( ActorLite CoverPoint, optional bool bMustLeaveCover )
{
}

//---------------------------------------------------------
//	FindFarthestDestinationFromVector
//---------------------------------------------------------
function ActorLite FindFarthestDestinationFromVector( vector loc, float radius, optional bool bRequireLOS, optional float cosFrustrumCull )
{
	return None;
}

//---------------------------------------------------------
//	NavigationPointStolen
//---------------------------------------------------------
event NavigationPointStolen(ActorLite NavPoint)
{
}

//---------------------------------------------------------
//	Timer
//---------------------------------------------------------
function Timer()
{
//	Log( Name $ "(" $ Pawn.Name $ ").Timer() ->"$ Level.TimeSeconds, 'Mind' );

	if(TimerRate != TimerInterval)
		SetTimer( TimerInterval, true );
	//SetTimer( TimerInterval, false );

	if (m_fDisableAI)
	{
		return;
	}
	
	if( Pawn == None )
	{
		return;
	}

	UpdateActualAttackLevels();

	// Deal with finished goals and empty queues.
	if( IsTargetDead() )
	{
		RemoveTargetFromQueue( Enemy );
		SetEnemy( None );
	}

	// Occasionally force a re-sort of the target and destination queues by setting their "needs sort" flags.
	if( Level.TimeSeconds > TimeLastTargetSort + ForceTargetSortInterval )
	{
		bTargetQueueNeedsSort = true;
	}

	if ((m_nTargetMode != TargetMode_Normal) && m_fChangeTarget)
	{
		if (m_aTargetPawn == None)
		{
			m_aTargetPawn = Spawn( class'gbxTargetPawn', self,, m_aTarget1.Location, m_aTarget1.Rotation );
			if (m_fTargetVisible)
			{
				m_aTargetPawn.Texture=Texture'Engine.S_PathNode';
				m_aTargetPawn.SetDrawType(DT_Sprite);
			}
		}

		if (m_aTargetPawn != None)
		{
			AddTarget( m_aTargetPawn );
//			SetEnemy( m_aTargetPawn );		
//			m_fChangeTarget = false;
		}
	}

	// Sort queues as necessary.
	if( bTargetQueueNeedsSort )
	{
		PrioritizeTargets();

		// Assign best Target.
		if( ndxEnemyInQueue >= 0 && ndxEnemyInQueue < TargetQueue.Length )
		{
			SetEnemy( TargetQueue[ ndxEnemyInQueue ].Target );
		}
		else
		{
			SetEnemy( None );
		}

		// Assign worst threat.
		if( TargetQueue.Length > 0 )
		{
			FindWorstThreats();
		}
		else
		{
			WorstThreats.Remove( 0, WorstThreats.Length );
		}

		AnnounceTargetPriorities();
	}
	
	if ( !bDontInterruptMe )
	{
		DecideState();

		if( !IsInState('FiringFromCover') )
		{
			DecidePosture();
			DecideWeaponAim();
			DecideMaxSpeed();
			DecideFacingPolicy();
		}

		FiringController.Think(); // SJP: This just passes through to the grenade firing controller right now.
	}
}

//---------------------------------------------------------
//	SetFacingPolicy
//---------------------------------------------------------
function bool SetFacingPolicy( EFacingPolicy policy )
{
	if ( bDontInterruptMe )
		return false;

	// External classes shouldn't call this directly unless you're really confident you want to override. Use RequestFacingPolicy() instead.
	FacingPolicy = policy;

	return true;
}

//---------------------------------------------------------
//	ImplementFacingPolicy
//---------------------------------------------------------
function ImplementFacingPolicy()
{
	switch( FacingPolicy )
	{
		case FACE_NoChange:
			bRotateToDesired=false;
			break;

		case FACE_Destination:
			bRotateToDesired = true;
			Focus = None;
			break;

		case FACE_Vector:
			bRotateToDesired = true;
			FocalPoint = FacingVector;
			Focus = None;
			break;

		case FACE_Actor:
			bRotateToDesired = true;
			Focus = FacingActor;
			break;

		case FACE_Enemy:
			bRotateToDesired = true;
			Focus = Enemy;
			break;

		default:
			Warn( class $ ".ImplementFacingPolicy(): Unknown facing policy." );
			break;
	}
}

//---------------------------------------------------------
//	Tick
//---------------------------------------------------------
function Tick( float DeltaTime )
{
	local float RecoveryRate;
	local float	flTime, flPct;
	local Vector vecTarget;

	if (m_fDisableAI)
	{
		return;
	}
	
	if( Pawn == None )
	{
		return;
	}

	// Update our pawn.
	if( Pawn != WGPawn )
	{
		WGPawn = WargamePawn( Pawn );
	}
	if( WGPawn == None )
	{
		return;
	}

	if (m_nTargetMode == TargetMode_Sweep)
	{
		flTime = Level.TimeSeconds - m_flLastTargetTime;
		if (flTime > m_flTotalTargetTime)
		{
			m_nTargetDir *= -1;
			m_flLastTargetTime = Level.TimeSeconds;
			flTime = 0.0f;
		}
		
		if (m_nTargetDir > 0)
		{
			flPct = flTime / m_flTotalTargetTime;
		}
		else
		{
			flPct = (m_flTotalTargetTime - flTime) / m_flTotalTargetTime;
		}
		
		if ( m_aTargetPawn != None && m_aTarget1 != None && m_aTarget2 != None )
		{
			vecTarget.X = Lerp( flPct, m_aTarget1.Location.X, m_aTarget2.Location.X );
			vecTarget.Y = Lerp( flPct, m_aTarget1.Location.Y, m_aTarget2.Location.Y );
			vecTarget.Z = Lerp( flPct, m_aTarget1.Location.Z, m_aTarget2.Location.Z );
			
			m_aTargetPawn.SetLocation( vecTarget );
		}
	}
	
	// GBX:naj - TBD: Can I remove this code??
	if( FacingPolicy == FACE_Enemy && Enemy == None )
	{
		SetFacingPolicy( FACE_Destination );
	}
	
	ImplementFacingPolicy();

	RecoveryRate = GetFatigueRecoveryRate();
	DoFatigueRecovery( RecoveryRate, deltaTime );

	Super.Tick( deltaTime );
}

//---------------------------------------------------------
//	AddTarget
//---------------------------------------------------------
function AddTarget( gbxPawn newTarget, optional bool bDefinitelySeeTarget )
{
	local TargetInfo newTargetInfo;
	local int ndxTarget;
	local PerceptionPawnAddedTarget percep;

//	Log(name $ "(" $ Pawn.name $ ").AddTarget(" $ newTarget.name $")");

	if( newTarget == None || newTarget.SameTeamAs( WGPawn ) )
	{
		return;
	}

	if (m_nTargetMode != TargetMode_Normal)
	{
		if (m_fChangeTarget)
		{
			TargetQueue.Remove( 0, TargetQueue.Length );
			m_fChangeTarget = false;
		}
		else
		{
			return;
		}
	}

	newTargetInfo.Target = newTarget;

	// Is this target already in the queue?
	ndxTarget = FindTargetInQueue( newTarget );

	if( ndxTarget < 0 )
	{
		//Log( Name $ "(" $ Pawn.Name $ ").AddTarget( " $ newTarget $ " ) adding target.", 'Mind' );

		// Add the new target to the end of the list.
		TargetQueue.Length = TargetQueue.Length + 1;
		TargetQueue[ TargetQueue.Length - 1 ] = newTargetInfo;

		// TODO remove or reinstate.
//		bTargetQueueNeedsSort = true;

		// Alert my friends about this target.
		percep = new( None ) class'PerceptionPawnAddedTarget'; // GBX:naj - modified 3/11/04
		percep.Target = newTarget;

		WGPawn.PostGBXMessage( percep );
	}
}

//---------------------------------------------------------
//	RemoveTargetFromQueue
//---------------------------------------------------------
function RemoveTargetFromQueue( Pawn aTarget )
{
	local int ndxTarget;

	ndxTarget = FindTargetInQueue( aTarget );

	if( ndxTarget >= 0 )
	{
		TargetQueue.Remove( ndxTarget, 1 );
	}
}

//---------------------------------------------------------
//	ShouldMelee
//---------------------------------------------------------
function bool ShouldMelee()
{
	return false;
}

//---------------------------------------------------------
//	ShouldFrenzy
//---------------------------------------------------------
function bool ShouldFrenzy()
{
	return false;
}

//---------------------------------------------------------
//	ShouldAssault
//---------------------------------------------------------
function bool ShouldAssault()
{
	return false;
}

//---------------------------------------------------------
//	NotifyTargetOrder
//---------------------------------------------------------
function NotifyTargetOrder(Unit targetUnit)
{
	LogSelective( "NotifyTargeting." );

	// Think now, possibly ahead of schedule.
	Timer();
	
	FiringController.NotifyTargeting();
}

//---------------------------------------------------------
//	NotifyPrepareAssault
//---------------------------------------------------------
function NotifyPrepareAssault( bool bWaitToRush )
{
}

//---------------------------------------------------------
//	SeeGrenade
//---------------------------------------------------------
function SeeGrenade( gbxExplosive Grenade, bool msgFromGrenade )
{
}

//---------------------------------------------------------
//	FleeGrenadeAction
//---------------------------------------------------------
function FleeGrenadeAction()
{
}

//---------------------------------------------------------
//	SeeImpact
//---------------------------------------------------------
function SeeImpact( Pawn instigator, float impactSeverity, float distance )
{
	local int ndx;

	if(!Pawn.SameTeamAs( Instigator ))
	{
		ConsiderPossibleEnemy( instigator );

		// Note that this guy actually attacked me.
		ndx = FindTargetInQueue( Instigator );
		if( ndx >= 0 )
		{
			TargetQueue[ ndx ].ActualAttackLevel += 0.2;
			TargetQueue[ ndx ].LastContactTime = Level.TimeSeconds;
		}
	}
}

//---------------------------------------------------------
//	SeePawnDied
//---------------------------------------------------------
function SeePawnDied( Pawn Seen )
{
}

//---------------------------------------------------------
//	SeePawnHit
//---------------------------------------------------------
function SeePawnHit( Pawn Seen )
{
}

//---------------------------------------------------------
//	NotifyNearbyTrace
//---------------------------------------------------------
function NotifyNearbyTrace( Actor Other, vector TouchLocation, vector TouchNormal, vector End, vector Start, vector Extent, int TraceFlags )
{
	local int ndx;
	local vector NearestPoint;		// The nearest point to the pawn that this trace passed through.
	local float MissDistance;		// How far away from me the bullet passed.
	local float MissDistanceRelative;		// How far away from me the bullet passed, scaled and clamped to (0,1)
	local vector TraceNormal;

//	Log( Name $ "(" $ Pawn.Name $ ").NotifyNearbyTrace( " $ Other $ ", ... )", 'Mind' );

	// Ensure the shot came from an enemy.
	if( Pawn.SameTeamAs( Other.Instigator ))
	{
		return;
	}

	TraceNormal = Normal( Start - End );

	NearestPoint = End + TraceNormal * (( Pawn.Location - End ) dot TraceNormal );

	MissDistance = VSize( NearestPoint - Pawn.Location ) - Pawn.CollisionRadius;
	MissDistanceRelative =
		FClamp(
			MissDistance / ( gbxPawn( Pawn ).MyBulletListener.CollisionRadius - Pawn.CollisionRadius ),
			0.0, 1.0 );

	ConsiderPossibleEnemy( Other.Instigator );

	// Note that this guy actually attacked me.
	ndx = FindTargetInQueue( Other.Instigator );
	if( ndx >= 0 )
	{
		TargetQueue[ ndx ].ActualAttackLevel += 0.2;
		TargetQueue[ ndx ].LastContactTime = Level.TimeSeconds;
	}

	// Notify the unit that a bullet nearly missed me!
	if( WGPawn.MyUnit != None && UnitControllerAI( WGPawn.MyUnit.MyUnitController ) != None )
	{
		UnitControllerAI( WGPawn.MyUnit.MyUnitController ).MemberSawNearbyBullet( Other.Instigator, MissDistanceRelative );
	}
}

function MaybePlayReactToBulletsAnim( float MissDistanceRelative )
{
}

//---------------------------------------------------------
//	FaceAwayFromWalls
//---------------------------------------------------------
function FaceAwayFromWalls()
{
}

//---------------------------------------------------------
//	FaceTowardWalls
//---------------------------------------------------------
function FaceTowardWalls()
{
}

//---------------------------------------------------------
//	GrenadesOKAtThisRange
//---------------------------------------------------------
function bool GrenadesOKAtThisRange( float Dist )
{
	return false;
}

//---------------------------------------------------------
//	Approaching
//---------------------------------------------------------
// This function is called by tanks and other heavy vehicles that
// can potentially squash the Pawn if he doesn't move out the way.
function Approaching(Actor Other, Vector OtherMovementDirection)
{
}

function MountOrDismountFinished( bool bSuccess, EMountAction MountAction ) 
{
	log("**** "$Self.Name$" WARNING!!!!!!! Function MountOrDismountFinished called outside of state code." );
}

function Trigger( actor Other, Pawn EventInstigator )
{
	local vector PlayerLoc;
	local vector vPlayer;  // vector from vehicle toward player
	local vector vRotation;  // vector in the direction vehicle is facing
	local vector vCross;
	local rotator NewRot;

	WGPawn.bUseCustomDeathAnim = false;
	WGPawn.bDontDropWeapon = false;

	WGPawn.bHardAttach = false;
	SetBase(None);

	WGPawn.Controller.bGodMode = true;  // dismounting Pawns can't be killed until dismount is finished

	WGPawn.StartGoingToStand( true );

	if (FiringController != None)
	{
		FiringController.Destroy();
		FiringController = None;
	}

	// determine whether to dismount on the Left or Right side of the vehicle (on the opposite side from the player)...

	PlayerLoc = Level.GetLocalPlayerController().Pawn.Location;
	vPlayer = PlayerLoc - Location;
	vRotation = vector(MyHalfTrack.Rotation);
	vCross = vRotation cross vPlayer;
	if (vCross.Z > 0)
	{
		NewRot = MyHalfTrack.Rotation;
		NewRot.Yaw = (NewRot.Yaw + 49152) & 65535;  // dismount to the Left side
	}
	else
	{
		NewRot = MyHalfTrack.Rotation;
		NewRot.Yaw = (NewRot.Yaw + 16384) & 65535;  // dismount to the Right side
	}

	MountController.DoMountAction( Mount_DismountHalftrackPassenger, None, false, true, class'MountHalftrackPassengerCallback', NewRot );

	GotoState( 'DismountingHalftrack' );
}


/////////////////////////////////////////////////////////////////////////
// States
/////////////////////////////////////////////////////////////////////////

auto state Relaxed
{
	//---------------------------------------------------------
	//	BeginState (Relaxed)
	//---------------------------------------------------------
	function BeginState()
	{
		if ( Pawn != None )
		{
			Super.BeginState();
		}
		
		SetFlagValue( IveBeenFlanked, false );
	}

	//---------------------------------------------------------
	//	DecideWeaponAim (Relaxed)
	//---------------------------------------------------------
	function DecideWeaponAim()
	{
		// GBX:PAD: Ensure that WGPawn exists since otherwise it dumps a bunch of accessed none messages in the log files.
		if (WGPawn == None)
		{
			return;
		}
		
		// When transitioning from combat to relaxed mode, look nervous for the first 15 seconds or so.
		WGPawn.SetWeaponAimedState( WAS_CombatRelaxed );		
	}

	//---------------------------------------------------------
	//	DecideMaxSpeed (Relaxed)
	//---------------------------------------------------------
	function DecideMaxSpeed()
	{
		// GBX:PAD: Ensure that WGPawn exists since otherwise it dumps a bunch of accessed none messages in the log files.
		if (WGPawn == None)
		{
			return;
		}
		WGPawn.SetMaxAllowedSpeed( SL_Running );
	}

	//---------------------------------------------------------
	//	DecidePosture (Relaxed)
	//---------------------------------------------------------
	function DecidePosture()
	{
	}

	//---------------------------------------------------------
	//	DecideFacingPolicy (Relaxed)
	//---------------------------------------------------------
	function DecideFacingPolicy()
	{
	}

	//---------------------------------------------------------
	//	RequestFacingPolicy (Relaxed)
	//---------------------------------------------------------
	function bool RequestFacingPolicy( EFacingPolicy policy )
	{
		// Deny FP requests in this state.
		return false;
	}

	//---------------------------------------------------------
	//	IsStateSticky (Relaxed)
	//---------------------------------------------------------
	function bool IsStateSticky()
	{
		return false;
	}

	//---------------------------------------------------------
	//	ManeuverComplete (Relaxed)
	//---------------------------------------------------------
	function ManeuverComplete()
	{
	}

	//---------------------------------------------------------
	//	DecideState (Relaxed)
	//---------------------------------------------------------
	function DecideState()
	{
		if( IsStateSticky() )
		{
			return;
		}

		if( IsInCombat() )
		{
			GotoState( 'InCombat' );			// Warning: Do not put any new code after this GotoState().
		}
	}
	
	//---------------------------------------------------------
	//	NotifyFormationCenterChange (Relaxed)
	//---------------------------------------------------------
	function NotifyFormationCenterChange()
	{
	}
}

//=========================================================
//	State InCombat
//=========================================================
state InCombat
{
	// In this state, we're trying to get under cover as quickly as possible.
	// Later, if we have a target we'll try to attack the target from cover.

	//---------------------------------------------------------
	//	BeginState (InCombat)
	//---------------------------------------------------------
	function BeginState()
	{
		if ( WGPawn.MyUnit == None )
		{
			log( "******** ERROR: ("$Self.Name$") Pawn "$WGPawn.Name$" has not been assigned a unit!" );
		}

		Global.BeginState();
		LastLookedForCoverTime = Level.TimeSeconds + ForceLookForCover;

		DecideFacingPolicy();	// GBX:naj - added 2/9/04
	}

	//---------------------------------------------------------
	//	EndState (InCombat)
	//---------------------------------------------------------
	function EndState()
	{
		Global.EndState();
	}

	//---------------------------------------------------------
	//	DecideWeaponAim (InCombat)
	//---------------------------------------------------------
	function DecideWeaponAim()
	{
		// GBX:naj - let the FiringController decide this.		
	}

	//---------------------------------------------------------
	//	DecideMaxSpeed (InCombat)
	//---------------------------------------------------------
	function DecideMaxSpeed()
	{
		// TBD: If I have been ordered to fall in,
		// check if I am so far away from the super unit that I should sprint
		// to keep up.
		if ( WGPawn.MyUnit.bAttachedToSuperUnit )
		{
			if ( WGPawn.MyUnit.IsTooFarFromSuperUnit( WGPawn.Location ) )
			{
				LogSelective( "DecideMaxSpeed: Too far from super-unit." );
				WGPawn.SetMaxAllowedSpeed( SL_Sprinting );
			}
		}
		else
		{
			WGPawn.SetMaxAllowedSpeed( SL_Running );
		}
	}

	//---------------------------------------------------------
	//	NotifyFormationCenterChange (InCombat)
	//---------------------------------------------------------
	function NotifyFormationCenterChange()
	{
	}

	//---------------------------------------------------------
	//	NotifyTargetFailure (InCombat)
	//---------------------------------------------------------
	function NotifyTargetFailure( Pawn Target, optional ETargetFailure FailCode, optional gbxPawn TheBlocker )
	{
	}

	//---------------------------------------------------------
	//	DecidePosture (InCombat)
	//---------------------------------------------------------
	function DecidePosture()
	{		
	}

	//---------------------------------------------------------
	//	DecideFacingPolicy (InCombat)
	//---------------------------------------------------------
	function DecideFacingPolicy()
	{
		// Let the FiringController decide facing policy in this state.
	}

	//---------------------------------------------------------
	//	CoverPointStolen (InCombat)
	//---------------------------------------------------------
	event CoverPointStolen(ActorLite NavPoint)
	{
	}
	
	//---------------------------------------------------------
	//	NotifyTakeHit (InCombat)
	//---------------------------------------------------------
	// When shot and not currently moving to a destination, by god, get a new destination.
	function NotifyTakeHit(pawn InstigatedBy, vector HitLocation, int Damage, class<DamageType> damageType, vector Momentum)
	{
		Global.NotifyTakeHit( InstigatedBy, HitLocation, Damage, damageType, Momentum );
	}

	//---------------------------------------------------------
	//	TestForReverseCornerMount (InCombat)
	//---------------------------------------------------------
	function bool TestForReverseCornerMount( out Vector FiringLocation )
	{
		return false;
	}

	//---------------------------------------------------------
	//	SetDesiredDestination (InCombat)
	//---------------------------------------------------------
	function SetDesiredDestination( ActorLite CoverPoint, optional bool bMustLeaveCover )
	{
	}

	//---------------------------------------------------------
	//	RequestFacingPolicy (InCombat)
	//---------------------------------------------------------
	function bool RequestFacingPolicy( EFacingPolicy policy )
	{
		// TEST: ALLOW THE FC TO DETERMINE FACING POLICY.
		return Global.RequestFacingPolicy( policy );
		// Deny FP requests in this state.
		//return false;
	}

	//---------------------------------------------------------
	//	SetEnemy (InCombat)
	//---------------------------------------------------------
	function bool SetEnemy( Pawn newEnemy )
	{
		// GBX:naj - WARNING! This function is a ticking time bomb.  It returns a bool but contains a GotoState().
		local bool bChanged;
		bChanged = Global.SetEnemy( newEnemy );

		return bChanged;
	}

	//---------------------------------------------------------
	//	ManeuverComplete (InCombat)
	//---------------------------------------------------------
	function ManeuverComplete()
	{
		Global.ManeuverComplete();

		LogSelective( "ManeuverComplete().  Considering going into FFC." );
	}

	//---------------------------------------------------------
	//	DecideState (InCombat)
	//---------------------------------------------------------
	function DecideState()
	{
		if( IsStateSticky() )
		{
			return;
		}

		if( !IsInCombat() )
		{
			//LastSawCombatTime = Level.TimeSeconds;
			GotoState( 'Relaxed' );
		}
	}

	//---------------------------------------------------------
	//	Timer (InCombat)
	//---------------------------------------------------------
	function Timer()
	{
		Global.Timer();
	}	
}

state FiringFromCover
{
	function DecideState() {}
	function RequestStopFiringFromCover() {}
	function LeaveFiringFromCover( name newState, optional ActorLite NewDestination ) {}
	function NotifyTargetFailure( Pawn Target, optional ETargetFailure FailCode, optional gbxPawn TheBlocker ) {}
	function bool CoverNoLongerValid() { return false; }

	//---------------------------------------------------------
	//	SetEnemy (FiringFromCover)
	//---------------------------------------------------------
	function bool SetEnemy( Pawn newEnemy )
	{
		// GBX:naj - WARNING! This function is a ticking time bomb.  It returns a bool but contains a GotoState().
		local bool bChanged;
		bChanged = Global.SetEnemy( newEnemy );

		return bChanged;
	}

	//---------------------------------------------------------
	//	NotifyTakeHit (FiringFromCover)
	//---------------------------------------------------------
	function NotifyTakeHit(pawn InstigatedBy, vector HitLocation, int Damage, class<DamageType> damageType, vector Momentum)
	{		
		Super.NotifyTakeHit( InstigatedBy, HitLocation, Damage, damageType, Momentum );
	}

	function Timer()
	{
		Global.Timer();
	}
}

state DismountingHalftrack
{
	//---------------------------------------------------------
	//	MountOrDismountFinished
	//---------------------------------------------------------
	function MountOrDismountFinished( bool bSuccess, EMountAction MountAction ) 
	{
		WGPawn.Controller.bGodMode = false;

		WGPawn.SetCollisionSize(WGPawn.default.CollisionRadius, WGPawn.default.CollisionHeight);

		ChangeMind();
	}
}


/// MANEUVER RELATED ///////////////////////////////////////////////////

//---------------------------------------------------------
//	IsAtDesiredDestination
//---------------------------------------------------------
/*
function bool IsAtDesiredDestination()
{
	return true;
}
*/

//---------------------------------------------------------
//	IsCloseToCoverPoint
//---------------------------------------------------------
function bool IsCloseToCoverPoint()
{
	return true;
}

//---------------------------------------------------------
//	VantagePointStolen
//---------------------------------------------------------
event VantagePointStolen(ActorLite NavPoint)
{
}
/*
//---------------------------------------------------------
//	RequestPawnToStand
//---------------------------------------------------------
function RequestPawnToStand()
{
}

//---------------------------------------------------------
//	RequestPawnToCrouch
//---------------------------------------------------------
function RequestPawnToCrouch()
{
}
*/
//---------------------------------------------------------
//	FindCoverFromGrenade
//---------------------------------------------------------
function FindCoverFromGrenade( int iGrenade, optional bool bForcePanic )
{
}

//---------------------------------------------------------
//	TossBackGrenade
//---------------------------------------------------------
function TossBackGrenade( int iGrenade, vector returnVector, optional vector faceVector )
{
}

//---------------------------------------------------------
//	GrenadeTossFromGroundCallBack
//---------------------------------------------------------
function GrenadeTossFromGroundCallBack()
{
}

//---------------------------------------------------------
//	PickupGrenadeFromGroundCallBack
//---------------------------------------------------------
function PickupGrenadeFromGroundCallBack()
{
}

//---------------------------------------------------------
//	IsGrenadeDangerous
//---------------------------------------------------------
function bool IsGrenadeDangerous( gbxExplosive Grenade )
{
	return false;
}

//---------------------------------------------------------
//	MostDangerousGrenadeIndex
//---------------------------------------------------------
function int MostDangerousGrenadeIndex()
{
	return -1;
}

//---------------------------------------------------------
//	CanCrewTurret
//---------------------------------------------------------
function bool CanCrewTurret( TurretWeapon TheTurret )
{
	return false;
}

//---------------------------------------------------------
//	NotifyPawnIsShooting
//---------------------------------------------------------
function NotifyPawnIsShooting()
{
	// Clear the target-failure information, because clearly nothing is hindering our shot.
	TimeLastBlockedByFriendly = 0.0;
	TimeLastNoHadVantage = 0.0;
	BlockingFriendly = None;
}

//=========================================================
// Default Properties
//=========================================================
defaultproperties
{
	MyLogSelectName="MINDHALFTRACKPASSENGER"
	bHidden=true

	bIsPlayer=true
	TimerInterval=0.5

	NavigationControllerClass=None
	FiringControllerClass=class'FiringControllerHalftrack'

//	bLogSelect=true
}
class MindMG42Gunner extends Mind
	native;

cpptext
{
	virtual float CalculateTargetPriority( FTargetInfo& targetInfo, int ndx, float closestDistance );
	virtual float CalculateExposure( APawn* pFrom, APawn* pTarget );
	virtual DWORD LineOfSightTo(UActorLite *Other, INT bUseLOSFlag=0);
}

//---------------------------------------------------------
//	Variables / Constants
//---------------------------------------------------------
var gbxPawn	MyAttacker;
var float	CheckTime;
var float	EnemyTooCloseDist;
var float	BreakOutNoMatterWhatDist;
var bool	bFleeGrenade;
var bool	bMountInProgress;
var bool	bMountFailed;

//---------------------------------------------------------
// Possess
//---------------------------------------------------------
function Possess(Pawn aPawn)
{
	local gbxPawn gbxP;

	Super.Possess( aPawn );

	gbxP = gbxPawn( aPawn );
	gbxP.m_bUsingCrouchedCover = false;
	gbxP.m_bCornerFiring = false;
	gbxP.m_bCornerHunkered = false;
	gbxP.m_bCornerPeeking = false;
	gbxP.m_bStandingOverCorner = false;
	gbxP.m_bStandPeeking = false;	
}

//---------------------------------------------------------
//	ChangeMind
//---------------------------------------------------------
function gbxAIController ChangeMind( optional class<gbxAIController> NewMindClass )
{
	if ( NewMindClass == None || NewMindClass != Self.Class )
	{
		return Super.ChangeMind( NewMindClass );
	}
	else
	{
		return Self;
	}
}

//---------------------------------------------------------
//	NotifyKilled
//---------------------------------------------------------
function NotifyKilled(Controller Killer, Controller Killed, Pawn Other)
{	
	if ( Killed == Self )
		BreakOutJustMe();
	
	Super.NotifyKilled(Killer, Killed, Other);
}
	
	
//---------------------------------------------------------
//	StartJob
//---------------------------------------------------------
function StartJob( optional EJobType NewJob )
{
	local float ThinkStart;

	Super.StartJob( NewJob );
	
	bMountFailed = false;
	bMountInProgress = true;
	MountController.DoMountAction( Mount_MountMG42Gunner, GetMountNode(), true, false, class'MG42Callback', WGPawn.Turret.Rotation );	
	
	EnemyTooCloseDist = WGPawn.Turret.EnemyTooCloseDist;

	TimerInterval = Level.AIMaxThinkInterval;
	ThinkStart = 1 + Level.AIGetNextThinkStart();
	SetTimer( ThinkStart, true );

	GotoState( 'AcquiringMG' );
}

function TransitionToCombatReady() {}
function NotifyCombatReady() {}

//---------------------------------------------------------
//	GetMountNode
//---------------------------------------------------------
function ActorLite GetMountNode()
{
	return WGPawn.Turret.GetMountPoint();
}

// Overridden to prevent movement.
function SetDesiredDestination( ActorLite CoverPoint, optional bool bMustLeaveCover ) {}
function bool DecideDestCore( bool bPreferVantage, ActorLite NavPoint, Vector DummyThreatLoc, optional bool bMustLeaveCover ) 
{
	return false;
}

//---------------------------------------------------------
// NotifyTakeHit
//---------------------------------------------------------
function NotifyTakeHit(pawn InstigatedBy, vector HitLocation, int Damage, class<DamageType> damageType, vector Momentum)
{
	MyAttacker = gbxPawn( InstigatedBy );
	Super.NotifyTakeHit( InstigatedBy, HitLocation, Damage, damageType, Momentum );

	if (WeapDEMG42_(WGPawn.Turret).bDontDismountUnlessFlanked)
		return;

	BreakOutJustMe( InstigatedBy );
}

//---------------------------------------------------------
// DecideState
//---------------------------------------------------------
function DecideState()
{
}

//---------------------------------------------------------
//	FleeGrenadeAction (FiringFromCover)
//---------------------------------------------------------
function FleeGrenadeAction()
{
	LogSelective( "FleeGrenadeAction()." );
	
	if (WeapDEMG42_(WGPawn.Turret).bDontFleeFromGrenades)
		return;
	
	bFleeGrenade = true;
	BreakOutJustMe();
}

//---------------------------------------------------------
//	PostMindChangeTasks
//---------------------------------------------------------
function PostMindChangeTasks( Mind NewMind ) 
{
	Super.PostMindChangeTasks( NewMind );

	NewMind.StartJob();

	MyAttacker = None;
}

//---------------------------------------------------------
//	ShouldMelee
//---------------------------------------------------------
function bool ShouldMelee()
{
	return false;
}

//---------------------------------------------------------
//	RequestPawnToCrouch
//---------------------------------------------------------
function RequestPawnToCrouch() {}

//---------------------------------------------------------
// Stub functions - implemented in states
//
function MountOrDismountFinished( bool bSuccess, EMountAction MountAction ) 
{
	log("NAJ**** "$Self.Name$" WARNING!!!!!!! Function MountOrDismountFinished called outside of DismountingMG state.", 'naj' );
	
	bMountInProgress = false;
	
	if ( !bSuccess )
	{
		bMountFailed = true;
	}
}
function BreakOutJustMe( optional Pawn InstigatedBy )		{}
function PrioritizeTargets()	{}	// Inherited from Mind.

//=========================================================
//	State AcquiringMG
//=========================================================
state AcquiringMG
{
	//---------------------------------------------------------
	//	StartJob
	//---------------------------------------------------------
	function StartJob( optional EJobType NewJob )
	{
		if ( !bMountInProgress && bMountFailed )
		{
			bMountFailed = false;
			bMountInProgress = true;
			MountController.DoMountAction( Mount_MountMG42Gunner, GetMountNode(), true, false, class'MG42Callback', WGPawn.Turret.Rotation );
		}
	}

	//---------------------------------------------------------
	//	MountOrDismountFinished
	//---------------------------------------------------------
	function MountOrDismountFinished( bool bSuccess, EMountAction MountAction ) 
	{
		bMountInProgress = false;

		if ( bSuccess )
		{
			FiringController.StartManningTurret();
			GotoState( 'ManningMG' );
		}
		else
		{
			bMountFailed = true;
		}
	}
}

//=========================================================
//	State ManningMG
//=========================================================
state ManningMG
{
	//---------------------------------------------------------
	// BeginState
	//---------------------------------------------------------
	function BeginState()
	{
		Super.BeginState();
		WGPawn.bDoTorsoTwist = false;
	}

	//---------------------------------------------------------
	// BreakOutJustMe
	//---------------------------------------------------------
	function BreakOutJustMe( optional Pawn InstigatedBy )
	{
		// Use 180-degree dismount if the attacker is behind me.  Otherwise, face forward when dismounting.
		if ( InstigatedBy != None && 
			( Normal( InstigatedBy.Location - WGPawn.Turret.Location ) dot Vector( WGPawn.Turret.Rotation ) <= 0.0 ) )
		{
			MountController.DoMountAction( Mount_DismountMG42GunnerTurn, GetMountNode(), false, false, class'MG42Callback', WGPawn.Rotation );			
		}
		else
		{
			MountController.DoMountAction( Mount_DismountMG42Gunner, GetMountNode(), false, false, class'MG42Callback', WGPawn.Rotation );
		}

		SetFlagValue( IveBeenFlanked, true );
		SpeakWeveBeenFlanked();

		GotoState( 'DismountingMG' );
	}

	//---------------------------------------------------------
	//	ShouldIDismount
	//---------------------------------------------------------
	function bool ShouldIDismount( Pawn Instigator )
	{
		return !Instigator.SameTeamAs( WGPawn ) && !WGPawn.Turret.PointIsInMyConeOfFire( Instigator.Location );
	}

	//---------------------------------------------------------
	//	SeeImpact
	//---------------------------------------------------------
	function SeeImpact( Pawn instigator, float impactSeverity, float distance )
	{
		Super.SeeImpact( instigator, impactSeverity, distance );
		
		if ( ShouldIDismount( instigator ) )
		{
			if (WeapDEMG42_(WGPawn.Turret).bDontDismountUnlessFlanked)
				return;

			BreakOutJustMe( instigator );
		}
	}

	//---------------------------------------------------------
	//	NotifyNearbyTrace
	//---------------------------------------------------------
	function NotifyNearbyTrace( Actor Other, vector TouchLocation, vector TouchNormal, vector End, vector Start, vector Extent, int TraceFlags )
	{
		Super.NotifyNearbyTrace( Other, TouchLocation, TouchNormal, End, Start, Extent, TraceFlags );
		
		if ( Other.IsA( 'Weapon' ) || Other.IsA( 'WeaponFire' ) )
		{
			if (WeapDEMG42_(WGPawn.Turret).bDontDismountUnlessFlanked)
				return;

			if ( Other.Instigator != None && ShouldIDismount( Other.Instigator ) )
			{
				BreakOutJustMe( Other.Instigator );
			}
		}
	}

	//---------------------------------------------------------
	// NotifyTargetFailure
	//---------------------------------------------------------
	function NotifyTargetFailure( Pawn Target, optional ETargetFailure FailCode, optional gbxPawn TheBlocker )
	{
		Super.NotifyTargetFailure( Target, FailCode, TheBlocker );

		if (WeapDEMG42_(WGPawn.Turret).bDontDismountUnlessFlanked)
			return;

		if ( FailCode == FAIL_NoVantage )
		{
			if ( !WGPawn.Turret.TargetIsInMyConeOfFire( gbxPawn( Target ) ) )
			{
				if ( VSizeIgnoreZ( Target.Location - WGPawn.Turret.Location ) <= EnemyTooCloseDist )
				{
					BreakOutJustMe( Target );
				}
			}
		}
	}

	//---------------------------------------------------------
	// PrioritizeTargets
	//---------------------------------------------------------
	function PrioritizeTargets()
	{
		Super.PrioritizeTargets();
	}

	//---------------------------------------------------------
	// Timer
	//---------------------------------------------------------
	function Timer()
	{
		local int i, iLastEnemy;
		local bool bAtLeastOneEnemyInForwardCone, bAtLeastOneEnemyCanShootMe;

		for ( i=0; i < TargetQueue.Length; ++i )
		{
			if ( TargetQueue[i].bIgnored == 0 )
			{
				if ( !bAtLeastOneEnemyInForwardCone )
				{
					bAtLeastOneEnemyInForwardCone = WGPawn.Turret.TargetIsInMyConeOfFire( TargetQueue[i].Target );
				}

				if ( !bAtLeastOneEnemyCanShootMe )
				{
					bAtLeastOneEnemyCanShootMe = ( TargetQueue[i].MyExposureToTarget > 0 );

					if( bAtLeastOneEnemyCanShootMe )
						iLastEnemy = i;
				}

				if ( TargetQueue[i].TargetDistance <= BreakOutNoMatterWhatDist ||
					( TargetQueue[i].TargetDistance <= EnemyTooCloseDist && !WGPawn.Turret.TargetIsInMyConeOfFire( TargetQueue[i].Target ) ) )
				{
					BreakOutJustMe( TargetQueue[i].Target );
				}
			}
		}

		if ( !bAtLeastOneEnemyInForwardCone && bAtLeastOneEnemyCanShootMe )
		{
			if ( !WeapDEMG42_(WGPawn.Turret).bDontDismountUnlessFlanked )
			{
				BreakOutJustMe( TargetQueue[ iLastEnemy ].Target );
			}
		}

		Super.Timer();		
	}
}

//=========================================================
//	State DismountingMG
//=========================================================
state DismountingMG
{
	//---------------------------------------------------------
	//	MountOrDismountFinished
	//---------------------------------------------------------
	function MountOrDismountFinished( bool bSuccess, EMountAction MountAction ) 
	{
		ChangeMind();
	}
}
	
simulated function DisplayDebug(Canvas Canvas, out float YL, out float YPos)
{
	Super.DisplayDebug( Canvas, YL, YPos );

	if ( FiringController != None )
	{
		FiringController.DisplayDebug( Canvas, YL, YPos );
	}

	// TEST
	//Canvas.DrawTile3D(Texture't_interface_mb.debug.FC_Bullseye', WeapDEMG42_( WGPawn.Turret ).GetMuzzleLocationWorld(), 32, 32, 0, 0, 32, 32);
}

simulated function bool GoToDeadGuy( gbxPawn aPawn ) { return false; }

//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
	FiringControllerClass=class'FiringControllerMG'
	CheckTime=0.0

	TargetPriorityScalarDistance=5.0
	TargetPriorityScalarSurprisedBy=1.0			// Surprise is not as important as distance.
	TargetPriorityScalarAlreadyTargetted=0.0	// MG42 gunners cover a lots of targets and shouldn't linger on any one.

	MyLogSelectName="MINDMG42GUNNER"
	
	BreakOutNoMatterWhatDist=250.0;
}class MindMortarGunner extends Mind;


//---------------------------------------------------------
// Variables
//---------------------------------------------------------
var Pawn	MyAttacker;
var float	EnemyTooCloseDist;

//---------------------------------------------------------
// Possess
//---------------------------------------------------------
function Possess(Pawn aPawn)
{
	Super.Possess( aPawn );

	WGPawn.m_bUsingCrouchedCover = false;
	WGPawn.m_bCornerFiring = false;
	WGPawn.m_bCornerHunkered = false;
	WGPawn.m_bCornerPeeking = false;
	WGPawn.m_bStandingOverCorner = false;
	WGPawn.m_bStandPeeking = false;

	FiringControllerMortar( FiringController ).StartGunningTurret();
}

//---------------------------------------------------------
//	StartJob
//---------------------------------------------------------
function StartJob( optional EJobType NewJob )
{	
	local float ThinkStart;

	Super.StartJob( NewJob );
	WGPawn.LastWeapon = WGPawn.Weapon;
	WGPawn.CompleteTurretMount( false );
	EnemyTooCloseDist = WGPawn.Turret.EnemyTooCloseDist;

	TimerInterval = Level.AIMaxThinkInterval;
	ThinkStart = 1 + Level.AIGetNextThinkStart();
	SetTimer( ThinkStart, true );

	EnemyTooCloseDist = WGPawn.Turret.EnemyTooCloseDist;

	GotoState( 'ManningMortar' );
}

function TransitionToCombatReady() {}
function NotifyCombatReady() {}

//=========================================================
//	State ManningMortar
//=========================================================
state ManningMortar
{
	//---------------------------------------------------------
	//	DecideFacingPolicy (ManningMortar)
	//---------------------------------------------------------
	function DecideFacingPolicy()
	{
		RequestFacingPolicy( FACE_Vector );
	}

	//---------------------------------------------------------
	//	RequestFacingPolicy (ManningMortar)
	//---------------------------------------------------------
	function bool RequestFacingPolicy( EFacingPolicy policy )
	{
		if ( policy == FACE_Vector )
		{
			SetFacingPolicy( policy );
			return true;
		}
		else
		{
			return false;
		}
	}

	//---------------------------------------------------------
	//	SeeImpact (ManningMortar)
	//---------------------------------------------------------
	function SeeImpact( Pawn instigator, float impactSeverity, float distance )
	{		
		Super.SeeImpact( instigator, impactSeverity, distance );
		
		if ( WeapDEMortar( WGPawn.Turret ).bDismountWhenNearbyImpacts && distance <= WeapDEMortar( WGPawn.Turret ).NoticeBulletImpactsDist )
		{			
			WGPawn.Turret.ForceCrewDismount( instigator );
		}
	}

	//---------------------------------------------------------
	//	NotifyNearbyTrace (ManningMortar)
	//---------------------------------------------------------
	function NotifyNearbyTrace( Actor Other, vector TouchLocation, vector TouchNormal, vector End, vector Start, vector Extent, int TraceFlags )
	{		
		Super.NotifyNearbyTrace( Other, TouchLocation, TouchNormal, End, Start, Extent, TraceFlags );
		
		if ( WeapDEMortar( WGPawn.Turret ).bDismountWhenNearbyWhizzes )
		{	
			if ( Other.IsA( 'Weapon' ) )
			{
				WGPawn.Turret.ForceCrewDismount( Pawn( Other ) );
			}
		}
	}

	//---------------------------------------------------------
	//	NotifyTakeHit (ManningMortar)
	//---------------------------------------------------------
	function NotifyTakeHit(pawn InstigatedBy, vector HitLocation, int Damage, class<DamageType> damageType, vector Momentum)
	{
		MyAttacker = gbxPawn( instigatedBy );
		Super.NotifyTakeHit( InstigatedBy, HitLocation, Damage, damageType, Momentum );
		
		WGPawn.Turret.ForceCrewDismount( InstigatedBy );
	}

	//---------------------------------------------------------
	//	FleeGrenadeAction (ManningMortar)
	//---------------------------------------------------------
	function FleeGrenadeAction()
	{
		WGPawn.Turret.ForceCrewDismount();
	}

	//---------------------------------------------------------
	// BreakOutJustMe (ManningMortar)
	//---------------------------------------------------------
	function BreakOutJustMe( optional Pawn InstigatedBy )
	{		
		MyAttacker = InstigatedBy;
		GotoState( 'Dismounting' );
	}

	//---------------------------------------------------------
	// Timer (ManningMortar)
	//---------------------------------------------------------
	function Timer()
	{		
		local int i;
		local gbxPawn LeftLoader, RightLoader;
		local WeapDEMortar TheMortar;

		Super.Timer();		// Do all of the thinking a normal Mind does...

		// Then, check if we need to leave the weapon.		
		TheMortar = WeapDEMortar( WGPawn.Turret );
		if ( TheMortar.CurCrewSize > 1 )
		{
			LeftLoader = TheMortar.LeftLoader;
			RightLoader = TheMortar.RightLoader;
			
			if ( TheMortar.CurCrewSize >= 2 && ( LeftLoader == None || LeftLoader.IsDead() ) )
			{
				WGPawn.Turret.ForceCrewDismount();
			}
			else
			if ( TheMortar.CurCrewSize == 3 && ( RightLoader == None || RightLoader.IsDead() ) )
			{
				WGPawn.Turret.ForceCrewDismount();
			}
			
		}

		for ( i=0; i < TargetQueue.Length; ++i )
		{
			if ( TargetQueue[i].bIgnored == 0 )
			{
				if ( TargetQueue[i].TargetDistance <= EnemyTooCloseDist )
				{
					WGPawn.Turret.ForceCrewDismount();
				}
			}
		}
	}
}

//=========================================================
//	State Dismounting
//=========================================================
state Dismounting
{
	//---------------------------------------------------------
	//	BeginState (Dismounting)
	//---------------------------------------------------------
	function BeginState()
	{
		WGPawn.FlushAnimQueueChannel( 0 );
		MountController.DoMountAction( Mount_DismountMortarGunner, None, false, false, class'FlakvierlingCallback', WGPawn.Rotation );
	}	
}

//---------------------------------------------------------
//	PostMindChangeTasks
//---------------------------------------------------------
function PostMindChangeTasks( Mind NewMind ) 
{
	Super.PostMindChangeTasks( NewMind );
	NewMind.StartJob();
	
	//NewMind.MindSwitched( MyAttacker );		
	MyAttacker = None;
}

//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
	FiringControllerClass=class'FiringControllerMortar'
	MyLogSelectName="MINDMORTARGUNNER"
}class MindMortarLoader extends Mind;

//---------------------------------------------------------
// Variables
//---------------------------------------------------------
var Pawn	MyAttacker;

//---------------------------------------------------------
// Possess
//---------------------------------------------------------
function Possess(Pawn aPawn)
{
	Super.Possess( aPawn );

	WGPawn.m_bUsingCrouchedCover = false;
	WGPawn.m_bCornerFiring = false;
	WGPawn.m_bCornerHunkered = false;
	WGPawn.m_bCornerPeeking = false;
	WGPawn.m_bStandingOverCorner = false;
	WGPawn.m_bStandPeeking = false;	

	FiringControllerMortar( FiringController ).StartLoadingTurret();	
}

//---------------------------------------------------------
//	StartJob
//---------------------------------------------------------
function StartJob( optional EJobType NewJob )
{
	local float ThinkStart;

	Super.StartJob( NewJob );
	WGPawn.LastWeapon = WGPawn.Weapon;
	WGPawn.CompleteTurretMount( false );

	TimerInterval = Level.AIMaxThinkInterval;
	ThinkStart = 1 + Level.AIGetNextThinkStart();
	SetTimer( ThinkStart, true );

	GotoState( 'ManningMortar' );
}

function TransitionToCombatReady() {}
function NotifyCombatReady() {}

//=========================================================
//	State ManningMortar
//=========================================================
state ManningMortar
{
	//---------------------------------------------------------
	// BreakOutJustMe (ManningMortar)
	//---------------------------------------------------------
	function BreakOutJustMe( optional Pawn InstigatedBy )
	{		
		MyAttacker = InstigatedBy;
		GotoState( 'Dismounting' );
	}

	//---------------------------------------------------------
	//	SeeImpact (ManningMortar)
	//---------------------------------------------------------
	function SeeImpact( Pawn instigator, float impactSeverity, float distance )
	{
		Super.SeeImpact( instigator, impactSeverity, distance );
		
		if ( WeapDEMortar( WGPawn.Turret ).bDismountWhenNearbyImpacts && distance <= WeapDEMortar( WGPawn.Turret ).NoticeBulletImpactsDist )
		{
			WGPawn.Turret.ForceCrewDismount( instigator );
		}
	}

	//---------------------------------------------------------
	//	NotifyNearbyTrace (ManningMortar)
	//---------------------------------------------------------
	function NotifyNearbyTrace( Actor Other, vector TouchLocation, vector TouchNormal, vector End, vector Start, vector Extent, int TraceFlags )
	{
		Super.NotifyNearbyTrace( Other, TouchLocation, TouchNormal, End, Start, Extent, TraceFlags );
		
		if ( WeapDEMortar( WGPawn.Turret ).bDismountWhenNearbyWhizzes )
		{
			if ( Other.IsA( 'Weapon' ) )
			{
				WGPawn.Turret.ForceCrewDismount( Pawn( Other ) );
			}
		}
	}

	//---------------------------------------------------------
	//	NotifyTakeHit (ManningMortar)
	//---------------------------------------------------------
	function NotifyTakeHit(pawn InstigatedBy, vector HitLocation, int Damage, class<DamageType> damageType, vector Momentum)
	{
		MyAttacker = gbxPawn( instigatedBy );
		Super.NotifyTakeHit( InstigatedBy, HitLocation, Damage, damageType, Momentum );
		
		// Is the shot from behind this weapon, or is it within the NoShotProtectionDist?  If so, break out.
		WGPawn.Turret.ForceCrewDismount( InstigatedBy );
	}

	//---------------------------------------------------------
	//	FleeGrenadeAction (ManningMortar)
	//---------------------------------------------------------
	function FleeGrenadeAction()
	{
		WGPawn.Turret.ForceCrewDismount();
	}

	//---------------------------------------------------------
	// Timer (ManningMortar)
	//---------------------------------------------------------
	function Timer()
	{
		local gbxPawn Gunner;

		Super.Timer();		// Do all of the thinking a normal Mind does...

		// Then, check if we need to leave the weapon.		
		Gunner = WeapDEMortar( WGPawn.Turret ).Gunner;		
		if ( Gunner == None || Gunner.IsDead() )
		{
			WGPawn.Turret.ForceCrewDismount();
		}		
	}

Begin:

	WGPawn.PlayWaiting();

	Sleep( 1.0 );
	Goto( 'Begin' );
}

//=========================================================
//	State Dismounting
//=========================================================
state Dismounting
{
	//---------------------------------------------------------
	//	BeginState (Dismounting)
	//---------------------------------------------------------
	function BeginState()
	{
		WGPawn.FlushAnimQueueChannel( 0 );
		MountController.DoMountAction( Mount_DismountMortarLoader, None, false, false, class'FlakvierlingCallback', WGPawn.Rotation );
	}	
}

//---------------------------------------------------------
//	PostMindChangeTasks
//---------------------------------------------------------
function PostMindChangeTasks( Mind NewMind ) 
{
	Super.PostMindChangeTasks( NewMind );

	NewMind.StartJob();
	
	//NewMind.MindSwitched( MyAttacker );		
	MyAttacker = None;
}

//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
	FiringControllerClass=class'FiringControllerMortar'
	MyLogSelectName="MINDMORTARLOADER"
}class MindPak36Gunner extends Mind
	native;

//---------------------------------------------------------
// Variables
//---------------------------------------------------------
var Pawn	MyAttacker;
var bool	bFleeGrenade;
var float	PriorityCutoffDot;
var float	EnemyTooCloseDist;

cpptext
{
	virtual float CalculateTargetPriority( FTargetInfo& targetInfo, int ndx, float closestDistance );
}

//---------------------------------------------------------
// Possess
//---------------------------------------------------------
function Possess(Pawn aPawn)
{
	Super.Possess( aPawn );

	WGPawn.m_bUsingCrouchedCover = false;
	WGPawn.m_bCornerFiring = false;
	WGPawn.m_bCornerHunkered = false;
	WGPawn.m_bCornerPeeking = false;
	WGPawn.m_bStandingOverCorner = false;
	WGPawn.m_bStandPeeking = false;

	FiringControllerPak36_( FiringController ).StartGunningTurret();
}

//---------------------------------------------------------
//	StartJob
//---------------------------------------------------------
function StartJob( optional EJobType NewJob )
{	
	local float ThinkStart;

	Super.StartJob( NewJob );
	WGPawn.LastWeapon = WGPawn.Weapon;
	WGPawn.CompleteTurretMount( false );
	EnemyTooCloseDist = WGPawn.Turret.EnemyTooCloseDist;

	TimerInterval = Level.AIMaxThinkInterval;
	ThinkStart = 1 + Level.AIGetNextThinkStart();
	SetTimer( ThinkStart, true );

	EnemyTooCloseDist = WGPawn.Turret.EnemyTooCloseDist;

	GotoState( 'ManningPak' );
}

function TransitionToCombatReady() {}
function NotifyCombatReady() {}

//---------------------------------------------------------
//	PostMindChangeTasks
//---------------------------------------------------------
function PostMindChangeTasks( Mind NewMind ) 
{
	Super.PostMindChangeTasks( NewMind );
	NewMind.StartJob();
	
	//NewMind.MindSwitched( MyAttacker );		
	MyAttacker = None;
}

//=========================================================
//	State ManningPak
//=========================================================
state ManningPak
{
	//---------------------------------------------------------
	//	DecideFacingPolicy (ManningPak)
	//---------------------------------------------------------
	function DecideFacingPolicy()
	{
		RequestFacingPolicy( FACE_Vector );
	}

	//---------------------------------------------------------
	//	RequestFacingPolicy (ManningPak)
	//---------------------------------------------------------
	function bool RequestFacingPolicy( EFacingPolicy policy )
	{
		if ( policy == FACE_Vector )
		{
			SetFacingPolicy( policy );
			return true;
		}
		else
		{
			return false;
		}
	}

	//---------------------------------------------------------
	//	SeeImpact (ManningPak)
	//---------------------------------------------------------
	function SeeImpact( Pawn instigator, float impactSeverity, float distance )
	{
		Super.SeeImpact( instigator, impactSeverity, distance );
		
		// Is the shot from behind this weapon, or is it within the NoShotProtectionDist?  If so, break out.
		if ( ShouldIDismount( instigator.Location ) )
		{
			WGPawn.Turret.ForceCrewDismount( instigator );
		}
	}

	//---------------------------------------------------------
	//	NotifyNearbyTrace (ManningPak)
	//---------------------------------------------------------
	function NotifyNearbyTrace( Actor Other, vector TouchLocation, vector TouchNormal, vector End, vector Start, vector Extent, int TraceFlags )
	{
		Super.NotifyNearbyTrace( Other, TouchLocation, TouchNormal, End, Start, Extent, TraceFlags );
		
		// Is the shot from behind this weapon, or is it within the NoShotProtectionDist?  If so, break out.
		if ( Other.IsA( 'Weapon' ) )
		{
			if ( Other.Instigator != None && ShouldIDismount( Other.Instigator.Location ) )
			{
				WGPawn.Turret.ForceCrewDismount( Pawn( Other ) );
			}
		}
	}

	//---------------------------------------------------------
	//	NotifyTakeHit (ManningPak)
	//---------------------------------------------------------
	function NotifyTakeHit(pawn InstigatedBy, vector HitLocation, int Damage, class<DamageType> damageType, vector Momentum)
	{
		MyAttacker = gbxPawn( instigatedBy );
		Super.NotifyTakeHit( InstigatedBy, HitLocation, Damage, damageType, Momentum );
		
		// Is the shot from behind this weapon, or is it within the NoShotProtectionDist?  If so, break out.
		WGPawn.Turret.ForceCrewDismount( InstigatedBy );
	}

	//---------------------------------------------------------
	//	NotifyTargetFailure (ManningPak)
	//---------------------------------------------------------
	function NotifyTargetFailure( Pawn Target, optional ETargetFailure FailCode, optional gbxPawn TheBlocker )
	{
		RelegateEnemy();
	}

	//---------------------------------------------------------
	//	ShouldIDismount (ManningPak)
	//---------------------------------------------------------
	function bool ShouldIDismount( Vector InstigatorLoc )
	{
		local float DotVal;

		DotVal = Vector( WGPawn.Turret.Rotation ) Dot Normal( InstigatorLoc - WGPawn.Turret.Location );
		if ( DotVal < 0.7071 )
		{		
			return true;
		}
		else if ( VSize( InstigatorLoc - WGPawn.Location ) < WGPawn.Turret.NoShotProtectionDist )
		{
			return true;
		}
		else
		{
			return false;
		}
	}

	//---------------------------------------------------------
	//	FleeGrenadeAction (ManningPak)
	//---------------------------------------------------------
	function FleeGrenadeAction()
	{
		bFleeGrenade = true;
		WGPawn.Turret.ForceCrewDismount( PerceivedGrenades[ PerceivedGrenades.Length - 1 ].Instigator );
	}


	//---------------------------------------------------------
	// BreakOutJustMe (ManningPak)
	//---------------------------------------------------------
	function BreakOutJustMe( optional Pawn InstigatedBy )
	{		
		MyAttacker = InstigatedBy;
		GotoState( 'Dismounting' );
	}

	//---------------------------------------------------------
	// Timer (ManningPak)
	//---------------------------------------------------------
	function Timer()
	{
		local int i;
		local gbxPawn Loader;

		Super.Timer();		// Do all of the thinking a normal Mind does...

		// Then, check if we need to leave the weapon.
		Loader = WeapDEPak36_( WGPawn.Turret ).Loader;		
		if ( Loader == None || Loader.IsDead() )
		{
			WeapDEPak36_( WGPawn.Turret ).ForceCrewDismount();
		}	

		for ( i=0; i < TargetQueue.Length; ++i )
		{
			if ( TargetQueue[i].bIgnored == 0 )
			{
				if ( TargetQueue[i].TargetDistance <= EnemyTooCloseDist )
				{
					WeapDEPak36_( WGPawn.Turret ).ForceCrewDismount();
				}
			}
		}
	}
}


//=========================================================
//	State PickingUpAndMovingPak
//=========================================================
state PickingUpAndMovingPak
{
}

//=========================================================
//	State Dismounting
//=========================================================
state Dismounting
{
	//---------------------------------------------------------
	//	BeginState (Dismounting)
	//---------------------------------------------------------
	function BeginState()
	{
		WGPawn.FlushAnimQueueChannel( 0 );
		MountController.DoMountAction( Mount_DismountPak36Gunner, None, false, false, class'FlakvierlingCallback', WGPawn.Rotation );
	}	
}

simulated function bool GoToDeadGuy( gbxPawn aPawn ) { return false; }

//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
	FiringControllerClass=class'FiringControllerPak36_'
	MyLogSelectName="MINDPAK36GUNNER"
	//PriorityCutoffDot=0.9659
	PriorityCutoffDot=0.9239
}class MindPak36Loader extends Mind;

//---------------------------------------------------------
//	Variables
//---------------------------------------------------------
var Pawn MyAttacker;
var bool bFleeGrenade;
var float LastReloadedTime;

//---------------------------------------------------------
// Possess
//---------------------------------------------------------
function Possess(Pawn aPawn)
{
	Super.Possess( aPawn );

	WGPawn.m_bUsingCrouchedCover = false;
	WGPawn.m_bCornerFiring = false;
	WGPawn.m_bCornerHunkered = false;
	WGPawn.m_bCornerPeeking = false;
	WGPawn.m_bStandingOverCorner = false;
	WGPawn.m_bStandPeeking = false;	

	FiringControllerPak36_( FiringController ).StartLoadingTurret();	
}

//---------------------------------------------------------
//	StartJob
//---------------------------------------------------------
function StartJob( optional EJobType NewJob )
{
	local float ThinkStart;

	Super.StartJob( NewJob );
	WGPawn.LastWeapon = WGPawn.Weapon;
	WGPawn.CompleteTurretMount( false );
	
	TimerInterval = Level.AIMaxThinkInterval;
	ThinkStart = 1 + Level.AIGetNextThinkStart();
	SetTimer( ThinkStart, true );
	
	GotoState( 'ManningPak' );
}

function TransitionToCombatReady() {}
function NotifyCombatReady() {}

//---------------------------------------------------------
//	StartJob
//---------------------------------------------------------
function PostMindChangeTasks( Mind NewMind ) 
{
	Super.PostMindChangeTasks( NewMind );
	NewMind.StartJob();
	
	//NewMind.MindSwitched( MyAttacker );		
	MyAttacker = None;
}

//=========================================================
//	State ManningPak
//=========================================================
state ManningPak
{
	//---------------------------------------------------------
	// ReloadTurret (ManningPak)
	//---------------------------------------------------------
	function ReloadTurret()
	{
		GotoState( 'Reloading' );
	}

	//---------------------------------------------------------
	// BreakOutJustMe (ManningPak)
	//---------------------------------------------------------
	function BreakOutJustMe( optional Pawn InstigatedBy )
	{		
		MyAttacker = InstigatedBy;
		GotoState( 'Dismounting' );
	}

	//---------------------------------------------------------
	//	SeeImpact (ManningPak)
	//---------------------------------------------------------
	function SeeImpact( Pawn instigator, float impactSeverity, float distance )
	{
		Super.SeeImpact( instigator, impactSeverity, distance );
		
		// Is the shot from behind this weapon, or is it within the NoShotProtectionDist?  If so, break out.
		if ( ShouldIDismount( instigator.Location ) )
		{
			WGPawn.Turret.ForceCrewDismount( instigator );
		}
	}

	//---------------------------------------------------------
	//	NotifyNearbyTrace (ManningPak)
	//---------------------------------------------------------
	function NotifyNearbyTrace( Actor Other, vector TouchLocation, vector TouchNormal, vector End, vector Start, vector Extent, int TraceFlags )
	{
		Super.NotifyNearbyTrace( Other, TouchLocation, TouchNormal, End, Start, Extent, TraceFlags );
		
		// Is the shot from behind this weapon, or is it within the NoShotProtectionDist?  If so, break out.
		if ( Other.IsA( 'Weapon' ) )
		{
			if ( Other.Instigator != None && ShouldIDismount( Other.Instigator.Location ) )
			{
				WGPawn.Turret.ForceCrewDismount( Pawn( Other ) );
			}
		}
	}

	//---------------------------------------------------------
	//	NotifyTakeHit (ManningPak)
	//---------------------------------------------------------
	function NotifyTakeHit(pawn InstigatedBy, vector HitLocation, int Damage, class<DamageType> damageType, vector Momentum)
	{
		MyAttacker = gbxPawn( instigatedBy );
		Super.NotifyTakeHit( InstigatedBy, HitLocation, Damage, damageType, Momentum );
		
		// Is the shot from behind this weapon, or is it within the NoShotProtectionDist?  If so, break out.
		WGPawn.Turret.ForceCrewDismount( InstigatedBy );
	}
	
	//---------------------------------------------------------
	//	ShouldIDismount (ManningPak)
	//---------------------------------------------------------
	function bool ShouldIDismount( Vector InstigatorLoc )
	{
		local float DotVal;

		DotVal = Vector( WGPawn.Turret.Rotation ) Dot Normal( InstigatorLoc - WGPawn.Turret.Location );
		if ( DotVal < 0.7071 )
		{
			return true;
		}
		else if ( VSize( InstigatorLoc - WGPawn.Location ) < WGPawn.Turret.NoShotProtectionDist )
		{
			return true;
		}
		else
		{			
			return false;
		}
	}

	//---------------------------------------------------------
	//	FleeGrenadeAction (ManningPak)
	//---------------------------------------------------------
	function FleeGrenadeAction()
	{
		bFleeGrenade = true;
		WGPawn.Turret.ForceCrewDismount( PerceivedGrenades[ PerceivedGrenades.Length - 1 ].Instigator );

	}

	//---------------------------------------------------------
	// Timer (ManningPak)
	//---------------------------------------------------------
	function Timer()
	{
		local gbxPawn Gunner;

		Super.Timer();		// Do all of the thinking a normal Mind does...

		// Then, check if we need to leave the weapon.		
		Gunner = WeapDEPak36_( WGPawn.Turret ).Gunner;		
		if ( Gunner == None || Gunner.IsDead() )
		{
			WeapDEPak36_( WGPawn.Turret ).ForceCrewDismount();
		}		
	}


Begin:

	WGPawn.PlayWaiting();

	Sleep( 1.0 );
	Goto( 'Begin' );
}

//=========================================================
//	State DelayBetweenShots
//=========================================================
/*
state DelayBetweenShots extends ManningPak
{
	//---------------------------------------------------------
	// BeginState (DelayBetweenShots)
	//---------------------------------------------------------
	function BeginState() 
	{		
		LastReloadedTime = Level.TimeSeconds;
		LogSelective( "DelayBetweenShots.BeginState(): LastReloadedTime=="$LastReloadedTime );
	}
	
	//---------------------------------------------------------
	// EndState (DelayBetweenShots)
	//---------------------------------------------------------
	function EndState() 
	{
		LogSelective( "DelayBetweenShots.EndState()." );
		LastReloadedTime = 0.0;
	}

	//---------------------------------------------------------
	// Tick (DelayBetweenShots)
	//---------------------------------------------------------
	function Tick( float DeltaTime )
	{
		Super.Tick( DeltaTime );
		
		if ( LastReloadedTime > 0.0 && Level.TimeSeconds > ( LastReloadedTime + AfterShotDelayTime ) )
			GotoState( 'ManningPak' );
	}

	function ReloadTurret() {}
}
*/

//=========================================================
//	State Reloading
//=========================================================
state Reloading extends ManningPak
{
	function BeginState() {}
	function EndState() {}

	//---------------------------------------------------------
	// NotifyReloadFinished (Reloading)
	//---------------------------------------------------------
	function NotifyReloadFinished()
	{
		GotoState( 'ManningPak' );
	}

Begin:
	WGPawn.PlayReloadTurret();
}

//=========================================================
//	State Dismounting
//=========================================================
state Dismounting
{
	//---------------------------------------------------------
	//	BeginState (Dismounting)
	//---------------------------------------------------------
	function BeginState()
	{		
		WGPawn.FlushAnimQueueChannel( 0 );
		MountController.DoMountAction( Mount_DismountPak36Loader, None, false, false, class'FlakvierlingCallback', WGPawn.Rotation );
	}	
}

simulated function bool GoToDeadGuy( gbxPawn aPawn ) { return false; }

//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
	FiringControllerClass=class'FiringControllerPak36_'
	MyLogSelectName="MINDPAK36LOADER"	
}//=============================================================================
// Main AI controller for the Pak 88 FuseSetter.
//
// Author: Nick Chinnici 
// Gearbox Software.
//=============================================================================

class MindPAK88FuseSetter extends Mind;

var	Name	BracingAnim;
var Pawn	MyAttacker;
var bool	bBracing, bFleeGrenade;

//---------------------------------------------------------
// Possess
//---------------------------------------------------------
function Possess(Pawn aPawn)
{
	Super.Possess( aPawn );

	WGPawn.m_bUsingCrouchedCover = false;
	WGPawn.m_bCornerFiring = false;
	WGPawn.m_bCornerHunkered = false;
	WGPawn.m_bCornerPeeking = false;
	WGPawn.m_bStandingOverCorner = false;
	WGPawn.m_bStandPeeking = false;	
	WGPawn.bIsManning88 = true;

	BracingAnim = WeapDEPAK88_( WGPawn.Turret ).GetBracingAnim( WGPawn );

	FiringControllerPAK88_( FiringController ).StartLoadingTurret();	
}

//---------------------------------------------------------
//	StartJob
//---------------------------------------------------------
function StartJob( optional EJobType NewJob )
{
	local float ThinkStart;

	Super.StartJob( NewJob );
	WGPawn.CompleteTurretMount( false );

	TimerInterval = Level.AIMaxThinkInterval;
	ThinkStart = 1 + Level.AIGetNextThinkStart();
	SetTimer( ThinkStart, true );

	GotoState( 'ManningPak88' );
}

function TransitionToCombatReady() {}
function NotifyCombatReady() {}

//=========================================================
//	State ManningPak88
//=========================================================
state ManningPak88
{	
	//---------------------------------------------------------
	//	BeginState (ManningPak88)
	//---------------------------------------------------------
	function BeginState()
	{
		bBracing = false;
		WGPawn.FlushAnimQueueChannel( 0 );
		WGPawn.PlayWaiting();
	}

	//---------------------------------------------------------
	// NotifyBeginFiring (ManningPak88)
	//---------------------------------------------------------
	function NotifyBeginFiring() 
	{
		GotoState( 'BracingSelf' );
	}

	//---------------------------------------------------------
	// Reload (ManningPak88)
	//---------------------------------------------------------
	function ReloadTurret()
	{
		GotoState( 'Reloading' );
	}	

	//---------------------------------------------------------
	//	SeeImpact (ManningPak88)
	//---------------------------------------------------------
	function SeeImpact( Pawn instigator, float impactSeverity, float distance )
	{
		//Super.SeeImpact( instigator, impactSeverity, distance );
		//WGPawn.Turret.ForceCrewDismount( instigator );
	}

	//---------------------------------------------------------
	//	NotifyNearbyTrace (ManningPak88)
	//---------------------------------------------------------
	function NotifyNearbyTrace( Actor Other, vector TouchLocation, vector TouchNormal, vector End, vector Start, vector Extent, int TraceFlags )
	{
		//Super.NotifyNearbyTrace( Other, TouchLocation, TouchNormal, End, Start, Extent, TraceFlags );
		//WGPawn.Turret.ForceCrewDismount( Pawn( Other ) );
	}

	//---------------------------------------------------------
	//	NotifyTakeHit (ManningPak88)
	//---------------------------------------------------------
	function NotifyTakeHit(pawn InstigatedBy, vector HitLocation, int Damage, class<DamageType> damageType, vector Momentum)
	{
		MyAttacker = gbxPawn( instigatedBy );
		//Super.NotifyTakeHit( InstigatedBy, HitLocation, Damage, damageType, Momentum );
		//WGPawn.Turret.ForceCrewDismount( InstigatedBy );
	}

	//---------------------------------------------------------
	//	FleeGrenadeAction (ManningPak88)
	//---------------------------------------------------------
	function FleeGrenadeAction()
	{
		bFleeGrenade = true;
		WGPawn.Turret.ForceCrewDismount();

	}
	//---------------------------------------------------------
	// BreakOutJustMe (ManningPak88)
	//---------------------------------------------------------
	function BreakOutJustMe( optional Pawn InstigatedBy )
	{		
		MyAttacker = InstigatedBy;
		GotoState( 'Dismounting' );
	}	

	//---------------------------------------------------------
	// NotifyIdleFinished (ManningPak88)
	//---------------------------------------------------------
	function NotifyIdleFinished() 
	{
		WGPawn.PlayWaiting();
	}

	//---------------------------------------------------------
	// Timer (ManningPak88)
	//---------------------------------------------------------
	function Timer()
	{
		local gbxPawn Gunner;

		// Then, check if we need to leave the weapon.		
		Gunner = WeapDEPAK88_( WGPawn.Turret ).Gunner;		
		if ( Gunner == None || Gunner.IsDead() )
		{
			WeapDEPAK88_( WGPawn.Turret ).ForceCrewDismount();
		}		
	}
}

//=========================================================
//	State BracingSelf
//=========================================================
state BracingSelf extends ManningPak88	
{
	//---------------------------------------------------------
	//	BeginState (BracingSelf)
	//---------------------------------------------------------
	function BeginState()
	{
		bBracing = true;
	}
	
	function EndState() {}

	function NotifyBeginFiring() {}

	//---------------------------------------------------------
	//	NotifyStopFiring (BracingSelf)
	//---------------------------------------------------------
	function NotifyStopFiring() 
	{
		GotoState( 'TransitionBackToNormal' );
	}

Begin:
	WGPawn.AddAnimToQueue( BracingAnim, WGPawn.QUEUE_COWER_IDLE_PRIORITY, false, true,,, 0.2 );

	Sleep( 0.5 );
	Goto( 'Begin' );
}

//=========================================================
//	State TransitionBackToNormal
//=========================================================
state TransitionBackToNormal extends ManningPak88
{
	function BeginState() {}
	function EndState() {}

Begin:
	WGPawn.AddAnimToQueue( WGPawn.PawnAnimInfoClass.Static.PawnIdleAnim( WGPawn ), WGPawn.QUEUE_COWER_IDLE_PRIORITY+1, true, false,,, 0.5 );
	//WGPawn.PlayAnim( WGPawn.PawnAnimInfoClass.Static.PawnIdleAnim( WGPawn ), 1.0, 0.5 );
	
	Sleep( 1.0 );
	
	GotoState( 'ManningPak88' );
}

//=========================================================
//	State Reloading
//=========================================================
state Reloading extends ManningPak88
{
	function BeginState() {}
	function EndState() {}

	//---------------------------------------------------------
	// NotifyReloadFinished (Reloading)
	//---------------------------------------------------------
	function NotifyReloadFinished()
	{
		if ( bBracing )
			GotoState( 'BracingSelf' );
		else
			GotoState( 'ManningPak88' );
	}

Begin:
	WGPawn.AddAnimToQueue( WGPawn.PawnAnimInfoClass.Static.PawnReloadAnim( WGPawn ), WGPawn.QUEUE_COWER_IDLE_PRIORITY+2, true, false, true, 1.0, 0.15, class'FlakVReloadCallback' );
}


//=========================================================
//	State Scripted
//=========================================================
state Scripted
{
	//---------------------------------------------------------
	//	BeginState (Scripted)
	//---------------------------------------------------------
	function BeginState()
	{
		bBracing = true;
	}
	
	function EndState() {}

	function NotifyBeginFiring() {
		WGPawn.FlushAnimQueueChannel( 0,,true );
		WGPawn.AddAnimToQueue( 'de_88_fuse_setter_sets_fuse', WGPawn.QUEUE_COWER_IDLE_PRIORITY, false, true,,, 0.2 );
	}

	//---------------------------------------------------------
	//	NotifyStopFiring (Scripted)
	//---------------------------------------------------------
	function NotifyStopFiring() 
	{
		GotoState( 'TransitionBackToNormal' );
	}

Begin:
	WGPawn.AddAnimToQueue( WGPawn.PawnAnimInfoClass.Static.PawnIdleAnim( WGPawn ), WGPawn.QUEUE_COWER_IDLE_PRIORITY, false, true,,, 1.0 );
	Sleep( 10.0 );
	Goto( 'Begin' );
}



//=========================================================
//	State Dismounting
//=========================================================
state Dismounting extends ManningPak88
{
	//---------------------------------------------------------
	//	BeginState (Dismounting)
	//---------------------------------------------------------
	function BeginState()
	{
		Super.BeginState();
		MountController.DoMountAction( Mount_DismountPak88FuseSetter, None, false, false, class'FlakvierlingCallback', WGPawn.Rotation );
	}

	//---------------------------------------------------------
	//	PostMindChangeTasks
	//---------------------------------------------------------
	function PostMindChangeTasks( Mind NewMind ) 
	{
		Super.PostMindChangeTasks( NewMind );

		NewMind.StartJob();

		MyAttacker = None;
	}
}

simulated function bool GoToDeadGuy( gbxPawn aPawn ) { return false; }

//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
	FiringControllerClass=class'FiringControllerPAK88_'
}//=============================================================================
// Main AI controller for the Pak 88 Gunner.
//
// Author: Nick Chinnici 
// Gearbox Software.
//=============================================================================
class MindPAK88Gunner extends Mind
	native;

var Actor TargetActor;
var Pawn MyAttacker;
var bool bFleeGrenade;
var bool bIsFiring;
var bool bWaitForTimer;
var float TimerEndTime;
var float EnemyTooCloseDist;
var bool bIsInScriptedMode;


cpptext
{
	virtual float CalculateTargetPriority( FTargetInfo& targetInfo, int ndx, float closestDistance );
}

//---------------------------------------------------------
// Possess
//---------------------------------------------------------
function Possess(Pawn aPawn)
{
	Super.Possess( aPawn );

	WGPawn.m_bUsingCrouchedCover = false;
	WGPawn.m_bCornerFiring = false;
	WGPawn.m_bCornerHunkered = false;
	WGPawn.m_bCornerPeeking = false;
	WGPawn.m_bStandingOverCorner = false;
	WGPawn.m_bStandPeeking = false;
	WGPawn.bIsManning88 = true;
	WGPawn.bUsesHoldRifleAnim = false;
	WGPawn.SightRadius = 18000;
	FiringControllerPAK88_( FiringController ).StartGunningTurret();
}

//---------------------------------------------------------
//	StartJob
//---------------------------------------------------------
function StartJob( optional EJobType NewJob )
{
	local float ThinkStart;

	Super.StartJob( NewJob );
	WGPawn.CompleteTurretMount( false );
	EnemyTooCloseDist = WGPawn.Turret.EnemyTooCloseDist;

	TimerInterval = Level.AIMaxThinkInterval;
	ThinkStart = 1 + Level.AIGetNextThinkStart();
	SetTimer( ThinkStart, true );

	EnemyTooCloseDist = WGPawn.Turret.EnemyTooCloseDist;

	GotoState( 'ManningPak88' );
}

function TransitionToCombatReady() {}
function NotifyCombatReady() {}
function SetFireParameters(Actor NewTarget, bool directShot){}
function FireAtTarget(Actor Target){}
function bool CheckOnTarget(Actor Target){return false;}
function ClearTargets(){}

//---------------------------------------------------------
//	ApplyAccuracy
//---------------------------------------------------------

// Apply our final error value to the aim-rotator to determine
// where the shot will actually travel.
function ApplyAccuracy( out Rotator AimRotator, int FinalError )
{
	local Vector NewAimVect;
	local Rotator NewAimRot, NewAimRot2;
	local float ZDiff;

	// Use "polar coordinates" to determine the new aim rotator:
	// Pitch the input rotator upwards by the FinalError,
	// then roll the resulting rotator around some random amount (~90 to ~270 degrees).
	// The resulting vector will fall somewhere within a circle centered around the
	// starting rotator and having a radius of FinalError.
	//
	ZDiff = WGPawn.Location.Z - TargetActor.Location.Z;
	if (ZDiff < -100)
		NewAimRot.Pitch = FinalError + (abs(ZDiff)/10);
	else if (ZDiff > 100)
		NewAimRot.Pitch = FinalError + (ZDiff/20);
	else
		NewAimRot.Pitch = FinalError;

	NewAimRot2.Roll = RandRange(26000,27500);
	NewAimRot2.Yaw = RandRange(-800,800);
	NewAimVect = Vector( NewAimRot ) >> NewAimRot2;
	AimRotator = Rotator( NewAimVect >> AimRotator );	
	
}


//=========================================================
//	State ManningPak88
//=========================================================
state ManningPak88
{
	//---------------------------------------------------------
	//	BeginState (ManningPak88)
	//---------------------------------------------------------
	function BeginState()
	{
		if ( !bIsFiring )
		{
			WGPawn.FlushAnimQueueChannel( 0 );
			WGPawn.PlayWaiting();
		}
	}

	//---------------------------------------------------------
	//	DecideFacingPolicy (ManningPak88)
	//---------------------------------------------------------
	function DecideFacingPolicy()
	{
		logSelective( "DecideFacingPolicy." );
		RequestFacingPolicy( FACE_Vector );
	}

	//---------------------------------------------------------
	//	RequestFacingPolicy (ManningPak88)
	//---------------------------------------------------------
	function bool RequestFacingPolicy( EFacingPolicy policy )
	{
		logSelective( "RequestFacingPolicy: policy=="$policy );
		if ( policy == FACE_Vector )
		{
			SetFacingPolicy( policy );
			return true;
		}
		else
		{
			return false;
		}
	}

	//---------------------------------------------------------
	// NotifyBeginFiring (ManningPak88)
	//---------------------------------------------------------
	function NotifyBeginFiring()
	{
		bIsFiring = true;
		WGPawn.FlushAnimQueueChannel( 0 );
		WGPawn.AddAnimToQueue( 'de_88_gunner_idle', 95.0, true, false,,, 0.1 );  //88 gunner has no firing animation, stay idle.
	}
	
	//---------------------------------------------------------
	// NotifyStopFiring (ManningPak88)
	//---------------------------------------------------------
	function NotifyStopFiring()
	{
		bIsFiring = false;
		WGPawn.PlayWaiting();
	}

	//---------------------------------------------------------
	// NotifyIdleFinished (ManningPak88)
	//---------------------------------------------------------
	function NotifyIdleFinished() 
	{
		if ( !bIsFiring )
		{
			WGPawn.FlushAnimQueueChannel( 0 );
			WGPawn.PlayWaiting();
		}
	}	

	//---------------------------------------------------------
	//	SetRandomTargetPoint (ManningPak88)
	//---------------------------------------------------------
	function SetRandomTargetPoint()
	{
		local Vector TargetPoint;

		TargetPoint = WGPawn.Location;
		TargetPoint.Z += Rand(10000);

		TargetPoint.X += Rand(10000) - 5000;
		TargetPoint.Y += Rand(10000) - 5000;
		
		FiringControllerPAK88_( FiringController ).SetTargetPoint( TargetPoint );
	}

	//---------------------------------------------------------
	//	SeeImpact (ManningPak88)
	//---------------------------------------------------------
	function SeeImpact( Pawn instigator, float impactSeverity, float distance )
	{
		//Super.SeeImpact( instigator, impactSeverity, distance );
		//WGPawn.Turret.ForceCrewDismount( instigator );
	}

	//---------------------------------------------------------
	//	NotifyNearbyTrace (ManningPak88)
	//---------------------------------------------------------
	function NotifyNearbyTrace( Actor Other, vector TouchLocation, vector TouchNormal, vector End, vector Start, vector Extent, int TraceFlags )
	{
		//Super.NotifyNearbyTrace( Other, TouchLocation, TouchNormal, End, Start, Extent, TraceFlags );
		//WGPawn.Turret.ForceCrewDismount( Pawn( Other ) );
	}

	//---------------------------------------------------------
	//	NotifyTakeHit (ManningPak88)
	//---------------------------------------------------------
	function NotifyTakeHit(pawn InstigatedBy, vector HitLocation, int Damage, class<DamageType> damageType, vector Momentum)
	{
		MyAttacker = gbxPawn( instigatedBy );
		///Super.NotifyTakeHit( InstigatedBy, HitLocation, Damage, damageType, Momentum );
		//WGPawn.Turret.ForceCrewDismount( InstigatedBy );
	}

	//---------------------------------------------------------
	//	FleeGrenadeAction (ManningPak88)
	//---------------------------------------------------------
	function FleeGrenadeAction()
	{
		bFleeGrenade = true;
		WGPawn.Turret.ForceCrewDismount();
	}	

	//---------------------------------------------------------
	// BreakOutJustMe (ManningPak88)
	//---------------------------------------------------------
	function BreakOutJustMe( optional Pawn InstigatedBy )
	{		
		MyAttacker = InstigatedBy;
		GotoState( 'Dismounting' );
	}	

	//---------------------------------------------------------
	// SetOneOffTimer (ManningPak88)
	//---------------------------------------------------------
	function SetOneOffTimer( float Duration )
	{
		bWaitForTimer = true;
		TimerEndTime = Level.TimeSeconds + Duration;
	}

	//---------------------------------------------------------
	// Tick (ManningPak88)
	//---------------------------------------------------------
	function Tick( float DeltaTime )
	{
		Super.Tick( DeltaTime );
		
		////if we have no target, make our focus the end of the gun
		if (TargetActor == None)
		{
			FacingVector = WeapDEPAK88_( WGPawn.Turret ).GetBoneCoords('Barrel_01').origin;//WeapDEPAK88_( WGPawn.Turret ).GetMuzzleLocationWorld();
			FocalPoint = FacingVector;
		}
		if ( bWaitForTimer )
		{
			if ( Level.TimeSeconds > TimerEndTime )
			{
				bWaitForTimer = false;
				TimerEndTime = 0.0;
			}
		}
	}

	//---------------------------------------------------------
	// Timer (ManningPak88)
	//---------------------------------------------------------
	function Timer()
	{
		local int i;
		local gbxPawn My88CrewMember;
		local bool bNewtarget;

		Super.Timer();		// Do all of the thinking a normal Mind does...


	//****************************** TARGET SELECTION***************************
	UpdateActualAttackLevels();

	bNewTarget = false;
	// Deal with finished goals and empty queues.
	if( IsTargetDead() )
	{
		RemoveTargetFromQueue( Enemy );
		SetEnemy( None );
	}

		bTargetQueueNeedsSort = true;

	// Sort queues as necessary.
	if( bTargetQueueNeedsSort )
	{
		PrioritizeTargets();

		// Assign best Target.
		if( ndxEnemyInQueue >= 0 && ndxEnemyInQueue < TargetQueue.Length )
		{
			//log("****SETTING ENEMY****** " $TargetQueue[ ndxEnemyInQueue ].Target,'NAC');
				//if the target is now behind cover, set the gun to look at the last known location of the target
				if (TargetQueue[ ndxEnemyInQueue ].TargetExposureToMe == 0)
				{
					WeapDEPAK88_(WGPawn.Turret).FaceRotation(Rotator(TargetQueue[ndxEnemyInQueue].LastKnownLocation));
					SetEnemy(None);
				}
			else
		        {
			SetEnemy( TargetQueue[ ndxEnemyInQueue ].Target );
			
			if (FiringControllerPAK88_( FiringController ).Target == WeapDEPAK88_( WGPawn.Turret ).GetTargetActor())
			{
				bNewTarget = false;
				FiringControllerPAK88_( FiringController ).SetOKToFire(true);
			}
			else
			{
				bNewTarget = true;
			        FiringControllerPAK88_( FiringController ).SetOKToFire(false);
			}
			WeapDEPAK88_(WGPawn.Turret).SetTargetActor(TargetQueue[ ndxEnemyInQueue ].Target);
			TargetActor =TargetQueue[ ndxEnemyInQueue ].Target;// WeapDEPAK88_( WGPawn.Turret ).GetTargetActor();
			FiringControllerPAK88_( FiringController ).SetTargetPoint( TargetActor.Location );
			
					//the gunner actually locates the target and tells the spotter and loader about it...
			if (WeapDEPAK88_( WGPawn.Turret ).Spotter != None)  //there might not always be a spotter to tell
			{
			        My88CrewMember = WeapDEPAK88_( WGPawn.Turret ).Spotter;
			        MindPAK88Spotter(My88CrewMember.Controller).SetEnemy(TargetQueue[ ndxEnemyInQueue ].Target );
	                        MindPAK88Spotter(My88CrewMember.Controller).TargetActor = TargetActor;
        			MindPAK88Spotter(My88CrewMember.Controller).NotifyNewTarget(bNewTarget);
			}
			
                        //there should always be a loader to tell
			My88CrewMember = WeapDEPAK88_( WGPawn.Turret ).Loader;
			MindPAK88Loader(My88CrewMember.Controller).SetEnemy(TargetQueue[ ndxEnemyInQueue ].Target );
			MindPAK88Loader(My88CrewMember.Controller).TargetActor = TargetActor;

		    }
				
		}
		else
		{
			SetEnemy( None );
		}

		// Assign worst threat.
		if( TargetQueue.Length > 0 )
		{
			FindWorstThreats();
		}
		else
		{
			WorstThreats.Remove( 0, WorstThreats.Length );
		}

		AnnounceTargetPriorities();
	}
	//****************************** TARGET SELECTION***************************


		// Then, check if we need to leave the weapon.  The gunner will check to see if the loader is alive or not...if not, exit the useless weapon
		My88CrewMember = WeapDEPAK88_( WGPawn.Turret ).Loader;		

		if ( My88CrewMember == None || My88CrewMember.IsDead() )
		{
			WGPawn.Turret.ForceCrewDismount();
		}

		for ( i=0; i < TargetQueue.Length; ++i )
		{
			if ( TargetQueue[i].bIgnored == 0 )
			{
				if ( TargetQueue[i].TargetDistance <= EnemyTooCloseDist )
				{
					WGPawn.Turret.ForceCrewDismount();
				}
			}
		}
	}
}

//=========================================================
//	State Dismounting
//=========================================================
state Dismounting extends ManningPak88
{	
	//---------------------------------------------------------
	//	BeginState (Dismounting)
	//---------------------------------------------------------
	function BeginState()
	{		
		WGPawn.Turret.StopSound( WeapDEPAK88_(WGPawn.Turret).TurretRotatingSoundHandle );
		MountController.DoMountAction( Mount_DismountPak88Gunner, None, false, false, class'FlakvierlingCallback', WGPawn.Rotation );
	}

	//---------------------------------------------------------
	//	PostMindChangeTasks
	//---------------------------------------------------------
	function PostMindChangeTasks( Mind NewMind ) 
	{
		Super.PostMindChangeTasks( NewMind );

		NewMind.StartJob();
		

		MyAttacker = None;
	}
}

//=========================================================
//	State Scripted
//=========================================================

state Scripted
{
	function BeginState()
	{
		FiringControllerPAK88_( FiringController ).GotoState('LoadingTurret');
	}
	function SetFireParameters(Actor NewTarget, bool directShot)
	{

			//log(name $ ".state Scripted - SetFireParameters!!", 'PAK88');
			
			FiringControllerPAK88_( FiringController ).SetTargetPoint( NewTarget.Location );
			TargetActor = NewTarget;
			WeapDEPAK88_( WGPawn.Turret ).SetTargetActor(TargetActor);
			FiringControllerPAK88_( FiringController ).Target = gbxPawn(TargetActor);
			FiringControllerPAK88_( FiringController ).EnsureWeaponIsCurrent();
			if (directShot)
			{
				FiringControllerPAK88_(FiringController).bDirectShot = true;
			}
	}

	function bool CheckOnTarget(Actor Target)
	{
		TargetActor = Target;
		FiringControllerPAK88_( FiringController ).Target = gbxPawn(TargetActor);
		return  FiringControllerPAK88_( FiringController ).CloseEnoughToFire();	
	}

	function FireAtTarget(Actor Target)
	{
		local ProjectileDEPAK88_ aShell;
		local Rotator Aim;
		local Vector StartTrace;
			TargetActor = Target;
			FiringControllerPAK88_( FiringController ).Target = gbxPawn(TargetActor);
		
			WeapDEPAK88_( WGPawn.Turret).PlayAnim('Fire', 1.0, 0.0);
			
			StartTrace = WeapDEPAK88_( WGPawn.Turret).GetBoneCoords('Barrel_01').origin;
			if (gbxPawn(Instigator) != None)
				gbxPawn(Instigator).LastAimRotator = Aim;
				
			Spawn( class'MuzzleFlashPak88_',,, StartTrace,  WeapDEPAK88_( WGPawn.Turret).GetFireRotation() );
			spawn(class'Pak88SmokeAndDust', None,, StartTrace, WeapDEPAK88_( WGPawn.Turret).GetFireRotation());
			WeapDEPAK88_( WGPawn.Turret).PlaySound( WeapDEPAK88_( WGPawn.Turret).GunFireSound, SLOT_NONE, TransientSoundVolume,,,,false);
			aShell = Spawn( class'ProjectileDEPAK88_',,, StartTrace, WeapDEPak88_( WGPawn.Turret ).GetFireRotation() );
			aShell.LaunchingWeapon = WeapDEPAK88_(WGPawn.Turret);


	}

	function ClearTargets()
	{
			WeapDEPAK88_( WGPawn.Turret ).SetTargetActor(None);
			FiringControllerPAK88_( FiringController ).Target = None;
			ClearRelegations();		//clear the relegations on any targets
			RemoveAllTargetsFromQueue();  //remove all the targets from the target queue
	}

Begin:
	//Log(name $ ".state Scripted - Entering Scripted state", 'PAK88');
	
	if  (bIsInScriptedMode)
	{
		Sleep(0.1);
		GoTo('Begin');
	}

	
	//Log(name $ ".state Scripted - Leaving Scripted state", 'PAK88');
	//restore the states...
	FiringControllerPAK88_(FiringController).StartGunningTurret();
	FiringControllerPAK88_(FiringController).bDirectShot = false;
	//StartJob();
	GotoState('ManningPak88');



}

simulated function bool GoToDeadGuy( gbxPawn aPawn ) { return false; }

//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
	FiringControllerClass=class'FiringControllerPAK88_'
	MyLogSelectName="MINDFLAKVGUNNER"
	bIsInScriptedMode = false;
	MaxTargetRange=18000.0
}//=============================================================================
// Main AI controller for the Pak 88 Loader.
//
// Author: Nick Chinnici 
// Gearbox Software.
//=============================================================================
class MindPAK88Loader extends Mind;

var	Name	BracingAnim;
var Pawn	MyAttacker;
var Actor TargetActor;
var float	BarrelLength;
var ActorLite	AmmoBox1, AmmoBox2;
var bool	bBracing, bHasShell,bFleeGrenade;
var array<ActorLite> AmmoBoxes;
var vector	PrevLoc;
var int StuckCount;
var float ReloadTimer;
//---------------------------------------------------------
// Possess
//---------------------------------------------------------
function Possess(Pawn aPawn)
{
	local Actor tmpNode;
	local int i;
	Super.Possess( aPawn );

	WGPawn.m_bUsingCrouchedCover = false;
	WGPawn.m_bCornerFiring = false;
	WGPawn.m_bCornerHunkered = false;
	WGPawn.m_bCornerPeeking = false;
	WGPawn.m_bStandingOverCorner = false;
	WGPawn.m_bStandPeeking = false;	
	WGPawn.bIsManning88 = true;
	WGPawn.bUsesHoldRifleAnim = false;
	if (WeapDEPAK88_(WGPawn.Turret).LoaderNoShotProtectionDist > 0.0 )
		WGPawn.Controller.bDemigod = true;  //this is cheap, but makes it harder to pick off the loader and ruin the 88
	i = 0;
	ForEach RadiusActors(class'Actor', tmpNode, 1000.0)
	{
	//ForEach AllActors(class'Actor',tmpNode)
		if(tmpNode.tag == 'AmmoBox')
		{
			AmmoBoxes[i] = tmpNode;
			++i;	
		}
	}
	WGPawn.PawnAnimInfoClass=class'PawnAnimInfoFinal88Loader';
	BracingAnim = WeapDEPAK88_( WGPawn.Turret ).GetBracingAnim( WGPawn );
	FiringControllerPAK88_( FiringController ).StartLoadingTurret();	
}

//---------------------------------------------------------
//	StartJob
//---------------------------------------------------------
function StartJob( optional EJobType NewJob )
{
	local float ThinkStart;

	Super.StartJob( NewJob );

	TimerInterval = Level.AIMaxThinkInterval;
	ThinkStart = 1 + Level.AIGetNextThinkStart();
	SetTimer( ThinkStart, true );

	//lets make him pick up a shell to start with
	WGPawn.FlushAnimQueueChannel( 0,,true );
	WGPawn.AddAnimToQueue( 'de_88_loader_ammo_pickup', 9999, true, false, true, 1.0, 0.15, class'FlakVReloadCallback' );

	GotoState( 'ManningPak88' );
}

function TransitionToCombatReady() {}
function NotifyCombatReady() {}

//---------------------------------------------------------
//	DecideFacingPolicy 
//---------------------------------------------------------
function DecideFacingPolicy()
{
	RemoveAllTargetsFromQueue();
	RequestFacingPolicy( FACE_Destination );
}

//---------------------------------------------------------
//	RequestFacingPolicy
//---------------------------------------------------------
function bool RequestFacingPolicy( EFacingPolicy policy )
{
	logSelective( "RequestFacingPolicy: policy=="$policy );
	if ( policy == FACE_Destination )
	{
		SetFacingPolicy( policy );
		return true;
	}
	else
	{
		return false;
	}
}

//---------------------------------------------------------
//	IsGunnerManningGun
//---------------------------------------------------------
function bool  IsGunnerManningGun()
{
	//NAC: if there is not a gunner, but the crew has been drafted for the weapon, make sure that this guy leaves the weapon!
	//first check to make sure that the gun has drafted the gunner
	if (WeapDEPAK88_(WGPawn.Turret).bCrewHasBeenDrafted)
	{
		if(WeapDEPAK88_(WGPawn.Turret).Gunner == None) 
		{ //we need to get off the gun!
			return false;
		}
		else
		{
			return true;
		}
	}

	return true;  //return true by default because we might have been drafted before our gunner
}


//---------------------------------------------------------
// Timer
//---------------------------------------------------------
function Timer()
{
	if (!IsGunnerManningGun())
			GotoState('Dismounting');  ///get off of there if there is no gunner!
}

//---------------------------------------------------------
//	DetermineClosestAmmoBox
//---------------------------------------------------------
function int DetermineClosestAmmoBox()
{
	local int i, ClosestBox;
	local float ClosestDistance, TempDistance;

	ClosestDistance = 20000.0;
	ClosestBox = 0;
	for (i = 0; i<AmmoBoxes.Length; i++)
	{
		TempDistance =  VSizeIgnoreZ(WGPawn.Location - Actor(AmmoBoxes[i]).Location);
		if (ClosestDistance > TempDistance)
		{
			ClosestDistance = TempDistance;
			ClosestBox = i;
		}
	}
	return ClosestBox;
}
//=========================================================
//	State ManningPak88
//=========================================================
state ManningPak88
{	
	//---------------------------------------------------------
	//	BeginState (ManningPak88)
	//---------------------------------------------------------
	function BeginState()
	{
		bBracing = false;
		if (!IsGunnerManningGun())
			GotoState('Dismounting');  ///get off of there if there is no gunner!
	}

	//---------------------------------------------------------
	// NotifyBeginFiring (ManningPak88)
	//---------------------------------------------------------
	function NotifyBeginFiring() 
	{
		GotoState( 'BracingSelf' );
	}

	//---------------------------------------------------------
	// Reload (ManningPak88)
	//---------------------------------------------------------
	function ReloadTurret()
	{
		GotoState( 'Reloading' );
	}	

	//---------------------------------------------------------
	//	SeeImpact (ManningPak88)
	//---------------------------------------------------------
	function SeeImpact( Pawn instigator, float impactSeverity, float distance )
	{
		//Super.SeeImpact( instigator, impactSeverity, distance );
		//WGPawn.Turret.ForceCrewDismount( instigator );
	}

	//---------------------------------------------------------
	//	NotifyNearbyTrace (ManningPak88)
	//---------------------------------------------------------
	function NotifyNearbyTrace( Actor Other, vector TouchLocation, vector TouchNormal, vector End, vector Start, vector Extent, int TraceFlags )
	{
		//Super.NotifyNearbyTrace( Other, TouchLocation, TouchNormal, End, Start, Extent, TraceFlags );
		//WGPawn.Turret.ForceCrewDismount( Pawn( Other ) );
	}

	//---------------------------------------------------------
	//	NotifyTakeHit (ManningPak88)
	//---------------------------------------------------------
	function NotifyTakeHit(pawn InstigatedBy, vector HitLocation, int Damage, class<DamageType> damageType, vector Momentum)
	{
		local float ShotProtectionDist;
		MyAttacker = gbxPawn( instigatedBy );
		ShotProtectionDist = WeapDEPAK88_(WGPawn.Turret).LoaderNoShotProtectionDist;
		if (ShotProtectionDist > 0.0)
		{
			if (VSizeSquared(WGPawn.Location-MyAttacker.Location)<(ShotProtectionDist*ShotProtectionDist))
			{
				WGPawn.Controller.bDemigod = false;
			}
			else
			{
				WGPawn.Controller.bDemigod = true;
			}
		}
	}

	//---------------------------------------------------------
	//	FleeGrenadeAction (ManningPak88)
	//---------------------------------------------------------
	function FleeGrenadeAction()
	{
		bFleeGrenade = true;
		WGPawn.Turret.ForceCrewDismount();

	}
	//---------------------------------------------------------
	// BreakOutJustMe (ManningPak88)
	//---------------------------------------------------------
	function BreakOutJustMe( optional Pawn InstigatedBy )
	{		
		MyAttacker = InstigatedBy;
		GotoState( 'Dismounting' );
	}	

	//---------------------------------------------------------
	// NotifyIdleFinished (ManningPak88)
	//---------------------------------------------------------
	function NotifyIdleFinished() 
	{
		WGPawn.PlayWaiting();
	}


	//---------------------------------------------------------
	// Timer (ManningPak88)
	//---------------------------------------------------------
	//function Timer()
	//{
	//	if (!IsGunnerManningGun())
	//		GotoState('Dismounting');  ///get off of there if there is no gunner!
	//}
}

//=========================================================
//	State BracingSelf
//=========================================================
state BracingSelf extends ManningPak88	
{
	//---------------------------------------------------------
	//	BeginState (BracingSelf)
	//---------------------------------------------------------
	function BeginState()
	{
		bBracing = true;
	}
	
	function EndState() {}

	function NotifyBeginFiring() {}

	//---------------------------------------------------------
	//	NotifyStopFiring (BracingSelf)
	//---------------------------------------------------------
	function NotifyStopFiring() 
	{
		GotoState( 'TransitionBackToNormal' );
	}

Begin:
	WGPawn.AddAnimToQueue( BracingAnim, WGPawn.QUEUE_COWER_IDLE_PRIORITY, false, true,,, 0.2 );

	Sleep( 0.5 );
	Goto( 'Begin' );
}



//=========================================================
//	State TransitionBackToNormal
//=========================================================
state TransitionBackToNormal extends ManningPak88
{
	function BeginState() 
	{
		if (!IsGunnerManningGun())
			GotoState('Dismounting');  ///get off of there if there is no gunner!
	}
	function EndState() {}

Begin:
	WGPawn.ForceCrouch();
	WGPawn.AddAnimToQueue( WGPawn.PawnAnimInfoClass.Static.PawnIdleAnim( WGPawn ), WGPawn.QUEUE_COWER_IDLE_PRIORITY+1, false, true,,, 0.5 );
	
	Sleep( 1.0 );
	
	GotoState( 'ManningPak88' );
}

//=========================================================
//	State Reloading
//=========================================================
state Reloading 
{
	function BeginState() 
	{ 
		local vector LoadingPos;
		WGPawn.ForceUnCrouch();
		PrevLoc = WGPawn.Location;
		StuckCount = 0;
		ReloadTimer = Level.TimeSeconds;

		if (!IsGunnerManningGun())
			GotoState('Dismounting');  ///get off of there if there is no gunner!
			
			WGPawn.FlushAnimQueueChannel( 0,,true );
			LoadingPos = WeapDEPAK88_( WGPawn.Turret ).LoaderRef.Location;
			LoadingPos.Z = WGPawn.Location.Z;  //set the Z location down to the pawns level so he can get to it
			Mind(WGPawn.Controller).FocalPoint = Destination;
			//log("****MOVING TO :"$LoadingPos $" ****WGPawn.bRotateToDesired: " $WGPawn.bRotateToDesired $" ***WGPawn.bDontInterruptMe: " $Mind(WGPawn.Controller).bDontInterruptMe ,'NAC');
			WGPawn.SetFacingTarget( WeapDEPAK88_( WGPawn.Turret ).LoaderRef, true, true );
			NavigationController.ManeuverToVector(LoadingPos);

	}
	function EndState() {}

	//---------------------------------------------------------
	// NotifyReloadFinished (Reloading)
	//---------------------------------------------------------
	function NotifyReloadFinished()
	{

		if ( bBracing )
			GotoState( 'BracingSelf' );
		else
			GotoState( 'ManningPak88' );
		
	}

	//---------------------------------------------------------
	// BreakOutOfReloading (Reloading)
	//---------------------------------------------------------
	function BreakOutOfReloading()
	{
		//NAC:a call to this function means the loader is stuck!  Try to get him unstuck by sending him back to his shell pile
		WGPawn.FlushAnimQueueChannel( 0,,true );
		//Turn to face the gun to reload
		Mind(WGPawn.Controller).FocalPoint = WeapDEPAK88_( WGPawn.Turret ).GetMuzzleLocationWorld();//TargetActor.Location;
		Mind(WGPawn.Controller).FacingActor = WGPawn.Turret;
		SetFacingPolicy( FACE_Actor );
		
		bHasShell = false;
		WeapDEPAK88_( WGPawn.Turret ).bGunIsLoaded = true;
		GotoState('GetShell');

	}

	//---------------------------------------------------------
	//	NotifyTakeHit (Reloading)
	//---------------------------------------------------------
	function NotifyTakeHit(pawn InstigatedBy, vector HitLocation, int Damage, class<DamageType> damageType, vector Momentum)
	{
		local float ShotProtectionDist;
		MyAttacker = gbxPawn( instigatedBy );
		ShotProtectionDist = WeapDEPAK88_(WGPawn.Turret).LoaderNoShotProtectionDist;
		if (ShotProtectionDist > 0.0)
		{
			if (VSizeSquared(WGPawn.Location-MyAttacker.Location)<(ShotProtectionDist*ShotProtectionDist))
			{
				WGPawn.Controller.bDemigod = false;
			}
			else
			{
				WGPawn.Controller.bDemigod = true;
			}
		}
	}

	//---------------------------------------------------------
	// BreakOutJustMe (Reloading)
	//---------------------------------------------------------
	function BreakOutJustMe( optional Pawn InstigatedBy )
	{		
		MyAttacker = InstigatedBy;
		GotoState( 'Dismounting' );
	}	

Begin:

	if (!IsGunnerManningGun())
			GotoState('Dismounting');  ///get off of there if there is no gunner!
	if (NavigationController.bIsNavigating  )
	{ 
		if (PrevLoc == WGPawn.Location )
		{
			if (StuckCount > 3)
			{
				//he must be stuck on geometry.  
				BreakOutOfReloading();
			}
			else 
				StuckCount++;
		}
		else
			PrevLoc = WGPawn.Location;
		Sleep(1.0);
		GoTo('Begin');
	}
	//else we have arrived at our destination...load the gun
	else
	{
		WGPawn.FlushAnimQueueChannel( 0,,true );
		// we need to turn and face the gun
		Mind(WGPawn.Controller).FocalPoint = WeapDEPAK88_( WGPawn.Turret ).GetMuzzleLocationWorld();//TargetActor.Location;
		Mind(WGPawn.Controller).FacingActor = WGPawn.Turret;
		SetFacingPolicy( FACE_Actor );

		WGPawn.AddAnimToQueue( 'de_88_loader_reloads_standing', 9999, true, false, true, 1.0, 0.15, class'FlakVReloadCallback' );
		Sleep(2.0);
		bHasShell = false;
		WeapDEPAK88_( WGPawn.Turret ).bGunIsLoaded = true;
		GotoState('GetShell');
	}
}

//=========================================================
//	State GetShell
//=========================================================

state GetShell
{

	function BeginState()
	{
		if (!IsGunnerManningGun())
			GotoState('Dismounting');  ///get off of there if there is no gunner!
		//move to the ammobox
		NavigationController.ManeuverToActor(AmmoBoxes[DetermineClosestAmmoBox()],false);

		//if we couldnt get to the first box, try the second...
		if (!NavigationController.bIsNavigating)
		{
			NavigationController.ManeuverToActor(AmmoBox2,false);	
			//log("******Navi Adest:" $ NavigationController.adestination,'NAC');
		}
	}
	
	//---------------------------------------------------------
	// BreakOutJustMe (GetShell)
	//---------------------------------------------------------
	function BreakOutJustMe( optional Pawn InstigatedBy )
	{		
		MyAttacker = InstigatedBy;
		GotoState( 'Dismounting' );
	}	

	//---------------------------------------------------------
	//	NotifyTakeHit (GetShell)
	//---------------------------------------------------------
	function NotifyTakeHit(pawn InstigatedBy, vector HitLocation, int Damage, class<DamageType> damageType, vector Momentum)
	{
		local float ShotProtectionDist;
		MyAttacker = gbxPawn( instigatedBy );
		ShotProtectionDist = WeapDEPAK88_(WGPawn.Turret).LoaderNoShotProtectionDist;
		if (ShotProtectionDist > 0.0)
		{
			if (VSizeSquared(WGPawn.Location-MyAttacker.Location)<(ShotProtectionDist*ShotProtectionDist))
			{
				WGPawn.Controller.bDemigod = false;
			}
			else
			{
				WGPawn.Controller.bDemigod = true;
			}
		}
	}

Begin:

	if(NavigationController.bIsNavigating)
	{
		if (!IsGunnerManningGun())
			GotoState('Dismounting');  ///get off of there if there is no gunner!
		Sleep(1.0);
		GoTo('Begin');
	}
	else 
	{
		WGPawn.FlushAnimQueueChannel( 0,,true );
		WGPawn.AddAnimToQueue( 'de_88_loader_ammo_pickup', 9999, true, false, true, 1.0, 0.15, class'FlakVReloadCallback' );
		Sleep(2.0);
		bHasShell = true;
		GotoState('TransitionBackToNormal');
	}

}

//=========================================================
//	State Scripted
//=========================================================
state Scripted
{
	//---------------------------------------------------------
	//	BeginState (Scripted)
	//---------------------------------------------------------
	function BeginState()
	{
		bBracing = true;
	}
	
	function EndState() {}

	function NotifyBeginFiring() {
		WGPawn.FlushAnimQueueChannel( 0,,true );
		WGPawn.AddAnimToQueue( 'de_88_loader_reloads', WGPawn.QUEUE_COWER_IDLE_PRIORITY, true, false,,, 0.2 );
	}

	//---------------------------------------------------------
	//	NotifyStopFiring (Scripted)
	//---------------------------------------------------------
	function NotifyStopFiring() 
	{
		GotoState( 'TransitionBackToNormal' );
	}

Begin:
	WGPawn.AddAnimToQueue( WGPawn.PawnAnimInfoClass.Static.PawnIdleAnim( WGPawn ), WGPawn.QUEUE_COWER_IDLE_PRIORITY, false, true,,, 1.0 );
	Sleep( 0.1 );
	Goto( 'Begin' );
}



//=========================================================
//	State Frenzied 
//=========================================================
state Frenzied
{
	//---------------------------------------------------------
	//	BeginState (Frenzied)
	//---------------------------------------------------------
	function BeginState()
	{
		Gotostate( 'Dismounting' ); //NAC:  If this guy ever gets in a frenzied state, immediately dismount!
	}
	
}


//=========================================================
//	State FleeGrenade
//=========================================================
state FleeGrenade
{
	//---------------------------------------------------------
	//	BeginState (FleeGrenade)
	//---------------------------------------------------------
	function BeginState()
	{
		Gotostate( 'Dismounting' ); //NAC:  If this guy ever gets in a FleeGrenade state, immediately dismount!
	}
	
}


//=========================================================
//	State Dismounting
//=========================================================
state Dismounting extends ManningPak88
{
	//---------------------------------------------------------
	//	BeginState (Dismounting)
	//---------------------------------------------------------
	function BeginState()
	{
		local StaticMesh shell;
		Super.BeginState();
		WGPawn.Controller.bDemigod = false;
			shell = StaticMesh(DynamicLoadObject("s_military_de.Weapon.88mm_shell", class 'StaticMesh'));
			WGPawn.DetachScriptedAttachment(shell,'88_Shell');

		WGPawn.Turret.StopSound( WeapDEPAK88_(WGPawn.Turret).TurretRotatingSoundHandle );
		MountController.DoMountAction( Mount_DismountPak88Loader, None, false, false, class'FlakvierlingCallback', WGPawn.Rotation );
	}

	//---------------------------------------------------------
	//	PostMindChangeTasks
	//---------------------------------------------------------
	function PostMindChangeTasks( Mind NewMind ) 
	{
		Super.PostMindChangeTasks( NewMind );

		NewMind.StartJob();
		

		MyAttacker = None;
	}
}

simulated function bool GoToDeadGuy( gbxPawn aPawn ) { return false; }

//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
	FiringControllerClass=class'FiringControllerPAK88_'
	BarrelLength = 10000.0
	bHasShell = true;
}//=============================================================================
// Main AI controller for the Pak 88 Spotter.
//
// Author: Nick Chinnici 
// Gearbox Software.
//=============================================================================
class MindPAK88Spotter extends Mind;

var	Name	BracingAnim;
var Pawn	MyAttacker;
var Actor TargetActor;
var bool	bBracing, bFleeGrenade;

//---------------------------------------------------------
// Possess
//---------------------------------------------------------
function Possess(Pawn aPawn)
{
	Super.Possess( aPawn );

	WGPawn.m_bUsingCrouchedCover = false;
	WGPawn.m_bCornerFiring = false;
	WGPawn.m_bCornerHunkered = false;
	WGPawn.m_bCornerPeeking = false;
	WGPawn.m_bStandingOverCorner = false;
	WGPawn.m_bStandPeeking = false;
	WGPawn.bUsesHoldRifleAnim = false;
	WGPawn.bIsManning88 = true;

	WGPawn.PawnAnimInfoClass=class'PawnAnimInfoFinal88Spotter';
	BracingAnim = WeapDEPAK88_( WGPawn.Turret ).GetBracingAnim( WGPawn );

	FiringControllerPAK88_( FiringController ).StartLoadingTurret();	
}

//---------------------------------------------------------
//	StartJob
//---------------------------------------------------------
function StartJob( optional EJobType NewJob )
{
	local float ThinkStart;

	Super.StartJob( NewJob );
	WGPawn.bIsManningTurret = false;
	TimerInterval = Level.AIMaxThinkInterval;
	ThinkStart = 1 + Level.AIGetNextThinkStart();
	SetTimer( ThinkStart, true );

	//pick up the range finder to begin with
	WGPawn.FlushAnimQueueChannel( 0,,true );
	WGPawn.AddAnimToQueue( 'de_88_spotter_standing_mount', 9999, true, false, true, 1.0, 0.15, class'FlakVReloadCallback' );
	
	GotoState( 'ManningPak88' );
}

function NotifyNewTarget(bool bNewTarget)
{
	if (bNewTarget)		//if it is a new target play the pointing animation
	{
		WGPawn.Controller.Focus = TargetActor;
		WGPawn.FlushAnimQueueChannel( 0 );
		WGPawn.AddAnimToQueue( 'de_88_spotter_standing_point', WGPawn.QUEUE_COWER_IDLE_PRIORITY+2, true, false, true, 1.0, 0.15, class'FlakVReloadCallback' );
		GoToState( 'TransitionBackToNormal');
		WGPawn.SetLookAtTarget(TargetActor, true, true);
		WGPawn.Controller.bRotateToDesired = true;
		WGPawn.Controller.Enemy = Pawn(TargetActor);
		SetFacingPolicy( FACE_Enemy );
	}
}

function TransitionToCombatReady() {}
function NotifyCombatReady() {}

//=========================================================
//	State ManningPak88
//=========================================================
state ManningPak88
{	
	//---------------------------------------------------------
	//	BeginState (ManningPak88)
	//---------------------------------------------------------
	function BeginState()
	{
		bBracing = false;
		WGPawn.FlushAnimQueueChannel( 0 );
		WGPawn.PlayWaiting();
	}

	//---------------------------------------------------------
	// NotifyBeginFiring (ManningPak88)
	//---------------------------------------------------------
	function NotifyBeginFiring() 
	{
		GotoState( 'BracingSelf' );
	}

	//---------------------------------------------------------
	// Reload (ManningPak88)
	//---------------------------------------------------------
	function ReloadTurret()
	{
		GotoState( 'Reloading' );
	}	

	//---------------------------------------------------------
	//	SeeImpact (ManningPak88)
	//---------------------------------------------------------
	function SeeImpact( Pawn instigator, float impactSeverity, float distance )
	{
		//Super.SeeImpact( instigator, impactSeverity, distance );
		//WGPawn.Turret.ForceCrewDismount( instigator );
	}

	//---------------------------------------------------------
	//	NotifyNearbyTrace (ManningPak88)
	//---------------------------------------------------------
	function NotifyNearbyTrace( Actor Other, vector TouchLocation, vector TouchNormal, vector End, vector Start, vector Extent, int TraceFlags )
	{
		//Super.NotifyNearbyTrace( Other, TouchLocation, TouchNormal, End, Start, Extent, TraceFlags );
		//WGPawn.Turret.ForceCrewDismount( Pawn( Other ) );
	}

	//---------------------------------------------------------
	//	NotifyTakeHit (ManningPak88)
	//---------------------------------------------------------
	function NotifyTakeHit(pawn InstigatedBy, vector HitLocation, int Damage, class<DamageType> damageType, vector Momentum)
	{
		MyAttacker = gbxPawn( instigatedBy );
	}

	//---------------------------------------------------------
	//	FleeGrenadeAction (ManningPak88)
	//---------------------------------------------------------
	function FleeGrenadeAction()
	{
		bFleeGrenade = true;
		WGPawn.Turret.ForceCrewDismount();

	}
	//---------------------------------------------------------
	// BreakOutJustMe (ManningPak88)
	//---------------------------------------------------------
	function BreakOutJustMe( optional Pawn InstigatedBy )
	{		
		MyAttacker = InstigatedBy;
		GotoState( 'Dismounting' );
	}	

	//---------------------------------------------------------
	// NotifyIdleFinished (ManningPak88)
	//---------------------------------------------------------
	function NotifyIdleFinished() 
	{
		WGPawn.PlayWaiting();
	}

	//---------------------------------------------------------
	// Timer (ManningPak88)
	//---------------------------------------------------------
	function Timer()
	{
		//Do Nothing	
	}
}

//=========================================================
//	State BracingSelf
//=========================================================
state BracingSelf extends ManningPak88	
{
	//---------------------------------------------------------
	//	BeginState (BracingSelf)
	//---------------------------------------------------------
	function BeginState()
	{
		bBracing = false;
	}
	
	function EndState() {}

	function NotifyBeginFiring() {}

	//---------------------------------------------------------
	//	NotifyStopFiring (BracingSelf)
	//---------------------------------------------------------
	function NotifyStopFiring() 
	{
		GotoState( 'TransitionBackToNormal' );
	}

Begin:
	WGPawn.AddAnimToQueue( BracingAnim, WGPawn.QUEUE_COWER_IDLE_PRIORITY, false, true,,, 0.2 );

	Sleep( 0.5 );
	Goto( 'Begin' );
}



//=========================================================
//	State TransitionBackToNormal
//=========================================================
state TransitionBackToNormal extends ManningPak88
{
	function BeginState() {}
	function EndState() {}

Begin:
	WGPawn.AddAnimToQueue( WGPawn.PawnAnimInfoClass.Static.PawnIdleAnim( WGPawn ), WGPawn.QUEUE_COWER_IDLE_PRIORITY+1, true, false,,1.0);
	
	Sleep( 1.0 );
	
	GotoState( 'ManningPak88' );
}

//=========================================================
//	State Reloading
//=========================================================
state Reloading extends ManningPak88
{
	function BeginState() {}
	function EndState() {}

	//---------------------------------------------------------
	// NotifyReloadFinished (Reloading)
	//---------------------------------------------------------
	function NotifyReloadFinished()
	{
		if ( bBracing )
			GotoState( 'BracingSelf' );
		else
			GotoState( 'ManningPak88' );
	}

Begin:
	WGPawn.FlushAnimQueueChannel( 0 );
	WGPawn.AddAnimToQueue( 'de_88_fuse_setter_sets_fuse', WGPawn.QUEUE_COWER_IDLE_PRIORITY+2, true, false, true, 1.0, 0.15, class'FlakVReloadCallback' );
}

//=========================================================
//	State Scripted
//=========================================================
state Scripted
{
	//---------------------------------------------------------
	//	BeginState (Scripted)
	//---------------------------------------------------------
	function BeginState()
	{
		bBracing = true;
	}
	
	function EndState() {}

	function NotifyBeginFiring() {
		WGPawn.FlushAnimQueueChannel( 0,,true );
		WGPawn.AddAnimToQueue( 'de_88_fuse_setter_sets_fuse', WGPawn.QUEUE_COWER_IDLE_PRIORITY, false, true,,, 0.2 );
	}

	//---------------------------------------------------------
	//	NotifyStopFiring (Scripted)
	//---------------------------------------------------------
	function NotifyStopFiring() 
	{
		GotoState( 'TransitionBackToNormal' );
	}

Begin:
	WGPawn.AddAnimToQueue( WGPawn.PawnAnimInfoClass.Static.PawnIdleAnim( WGPawn ), WGPawn.QUEUE_COWER_IDLE_PRIORITY, false, true,,, 1.0 );
	Sleep( 10.0 );
	Goto( 'Begin' );
}




//=========================================================
//	State Dismounting
//=========================================================
state Dismounting extends ManningPak88
{
	//---------------------------------------------------------
	//	BeginState (Dismounting)
	//---------------------------------------------------------
	function BeginState()
	{
		Super.BeginState();
		MountController.DoMountAction( Mount_DismountPak88Spotter, None, false, false, class'FlakvierlingCallback', WGPawn.Rotation );
	}

	//---------------------------------------------------------
	//	PostMindChangeTasks
	//---------------------------------------------------------
	function PostMindChangeTasks( Mind NewMind ) 
	{
		Super.PostMindChangeTasks( NewMind );
		WGPawn.GoBackToOldWeapon();
		NewMind.StartJob();
		
		/*
		if ( bFleeGrenade )
			NewMind.MindSwitchedFleeGrenade( MyAttacker, PerceivedGrenades );		
		else
			NewMind.MindSwitched( MyAttacker );			
		*/

		MyAttacker = None;
	}
}

simulated function bool GoToDeadGuy( gbxPawn aPawn ) { return false; }

//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
	FiringControllerClass=class'FiringControllerPAK88_'
}class MindPanzerfaust extends Mind
	native;

var float	SwitchToRifleDist;
var float	SwitchToRifleDistVehiclePriority;
var gbxPawn	MyAttacker;

cpptext
{
	virtual float CalculateTargetPriority( FTargetInfo& targetInfo, int ndx, float closestDistance );
}

function TransitionToCombatReady() {}
function NotifyCombatReady() {}

function Timer()
{
	local int ndx;
	local Vector TossVel;

	if ( WGPawn.Weapon.IsA( 'WeapDEPanzerfaust' ) )
	{
		for( ndx = 0; ndx < TargetQueue.Length; ++ndx )
		{
			if ( TargetQueue[ ndx ].bIgnored == 0 && 
				!TargetQueue[ ndx ].Target.IsA( 'gbxSVehicle' ) )
			{
				if( TargetQueue[ ndx ].TargetDistance < CombatRadius_NoFFC || 
					(WGPawn.bPrioritizeVehicles && TargetQueue[ ndx ].TargetDistance < SwitchToRifleDistVehiclePriority) ||
					(!WGPawn.bPrioritizeVehicles && TargetQueue[ ndx ].TargetDistance < SwitchToRifleDist) )
				{
					MyAttacker = TargetQueue[ ndx ].Target;
					
					TossVel = Vector(GetViewRotation());
					TossVel = TossVel * ((Pawn.Velocity Dot TossVel) + 500) + Vect(0,0,200);
					Pawn.TossWeapon(TossVel);
					ClientSwitchToBestWeapon();

					break;
				}
			}
		}
	}

	Super.Timer();
}

//---------------------------------------------------------
// Possess
//---------------------------------------------------------
function Possess(Pawn aPawn)
{
	local float ThinkStart;

	Super.Possess( aPawn );

	WGPawn.m_bUsingCrouchedCover = false;
	WGPawn.m_bCornerFiring = false;
	WGPawn.m_bCornerHunkered = false;
	WGPawn.m_bCornerPeeking = false;
	WGPawn.m_bStandingOverCorner = false;
	WGPawn.m_bStandPeeking = false;

	FiringControllerPanzerfaust( FiringController ).StartUsingPanzerfaust();

	TimerInterval = Level.AIMaxThinkInterval;
	ThinkStart = 1 + Level.AIGetNextThinkStart();
	SetTimer( ThinkStart, true );

	GotoState( 'InCombat' );
}

//---------------------------------------------------------
//	PostMindChangeTasks
//---------------------------------------------------------
function PostMindChangeTasks( Mind NewMind ) 
{
	Super.PostMindChangeTasks( NewMind );
	//NewMind.MindSwitched( MyAttacker );		
	MyAttacker = None;
}


//=========================================================
// Default Properties
//=========================================================
defaultproperties
{
	FiringControllerClass=class'FiringControllerPanzerfaust'
	MyLogSelectName="MINDPANZERFAUST"
	bHidden=true
	//bAntsyGermans=false
	SwitchToRifleDist=2250.0
	SwitchToRifleDistVehiclePriority=500.0
	MaxTargetRange=4500.0
}//=============================================================================
// MountCallbackClass.uc
//
//	This is an interface for callback classes used by the MountController.
//	The MountController calls MountFinished() when a mount action has
//	completed.
//
//=============================================================================
class MountCallbackClass extends Object;



static function MountFinished( gbxPawn gbxP, bool bSuccess, EMountAction MountAction );
//static function ManeuverFinished( WargamePawn WGPawn, bool bSuccess );
//=============================================================================
// MountController.uc
//
//	This class is responsible for maneuvering pawns to a mount point (with
//	precision movement) and then playing the appropriate mount animation
//	for the action requested.
//
//=============================================================================
class MountController extends Actor
	notplaceable
	native;

var WargamePawn					WGPawn;
var EMountAction				CurrentAction;
var ECornerDir					LeanDirection;
var NavigationController		NavCtrl;
var ActorLite					MountPoint;
var class<MountCallbackClass>	CallbackClass;
var	class<ItemPawnAnimInfo>		PawnAnimInfoClass;
var Rotator						ReferenceRotator;
var Vector						LocalX, LocalY, LocalZ;
var Rotator						RotOffset;
var float						XOffset, YOffset;
var bool						bWaitForCallback, bWaitForTimer;
var bool						bStartOutCrouched;
var bool						bPostTasksCalled;
var bool						bLerpRotation;		// Debug
var config bool					NoShow;
var bool						bRotationComplete;  // indicates when Pawn is fully rotated to ReferenceRotator


//---------------------------------------------------------
//	SetNavigationController
//---------------------------------------------------------
function SetNavigationController( NavigationController NewNavCtrl )
{
	NavCtrl = NewNavCtrl;
}

//---------------------------------------------------------
//	Possess
//---------------------------------------------------------
function Possess( WargamePawn NewWGPawn )
{
	WGPawn = NewWGPawn;
}

//---------------------------------------------------------
//	Reset
//---------------------------------------------------------
function ResetController()
{
	ResetVars();	
	CurrentAction = Mount_None;
	CallbackClass = None;
	MountPoint = None;
	GotoState( '' );
}

//---------------------------------------------------------
//	PrepareForDestroy
//---------------------------------------------------------
function PrepareForDestroy()
{
	WGPawn = None;
	CurrentAction = Mount_None;
	ResetVars();
	GotoState( 'WaitingForDestruction' );
}

//---------------------------------------------------------
//	Destroyed
//---------------------------------------------------------
function Destroyed()
{
	WGPawn = None;  // prevent references to/in destroyed objects
	NavCtrl = None;	// Mind is responsible for deleting it.
	MountPoint = None;

	Disable( 'Tick' );
	Disable( 'Timer' );

	Super.Destroyed();
}

//---------------------------------------------------------
//	ResetVars
//---------------------------------------------------------
function ResetVars()
{
	bWaitForCallback = false;
	bWaitForTimer = false;
	bPostTasksCalled = false;
	MountPoint = None;
	CallbackClass = None;

	////////// new
	bPostTasksCalled = false;
	bLerpRotation = false;
	NoShow = false;
	bRotationComplete = false;
	//////////
}

//---------------------------------------------------------
//	DoMountAction
//---------------------------------------------------------
event DoMountAction( EMountAction Action, ActorLite NewMountPoint, bool bUseManeuver, bool bDoLerpRotation, class<MountCallbackClass> NewCallbackClass, Rotator NewReferenceRot )
{
	local bool bQuitEarly;

	ResetVars();
	ReferenceRotator = NewReferenceRot;
	bLerpRotation = bDoLerpRotation;
	bRotationComplete = false;  // not done rotating yet

	// Check that the action is unnecessary.
	switch ( Action )
	{
		case Mount_MountCoverStanding:
			if ( WGPawn.m_bStandingBackToWall )
			{
				bQuitEarly = true;
			}
			break;
		case Mount_MountCoverLow:
			if ( WGPawn.bIsCrouched )
			{
				bQuitEarly = true;
			}
			break;
		case Mount_ChangeToRelaxed:
			if ( WGPawn.eWeaponAimedState != WAS_CombatRelaxed )
			{
				bQuitEarly = true;
			}
			break;
		case Mount_ChangeToCombatReady:
			if ( WGPawn.eWeaponAimedState != WAS_Relaxed )
			{
				bQuitEarly = true;
			}
			break;
	}

	if ( bQuitEarly )
	{
		NewCallbackClass.static.MountFinished( WGPawn, true, Action );
		return;
	}

	// Set up vars for a new mount action.
	CurrentAction = Action;
	CallbackClass = NewCallbackClass;
	MountPoint = NewMountPoint;

	if ( bUseManeuver && MountPoint != None )
	{
		if ( MountPoint != WGPawn.MyClaimedNavPoint )
		{
			if ( !Mind( WGPawn.Controller ).ClaimNavPoint( MountPoint ) )
			{
				CallbackClass.static.MountFinished( WGPawn, false, Action );	// failed
				return;
			}
		}

		NavCtrl.ManeuverToActor( MountPoint, false, true );
		GotoState( 'WaitingForManeuver' );
	}
	else
		GotoState( 'RotateToFace' );
}

//---------------------------------------------------------
//	StopMountAction
//---------------------------------------------------------
function StopMountAction() {}	// Implemented in state WaitingForManeuver.

//---------------------------------------------------------
//	ManeuverFinished
//---------------------------------------------------------
function ManeuverFinished( bool bSuccess ) {}	// Implemented in state WaitingForManeuver.

//---------------------------------------------------------
//	AnimationFinished
//---------------------------------------------------------
function AnimationFinished() {}		// Implemented in state PlayAnimation.

//=========================================================
//	State WaitingForManeuver
//=========================================================
state WaitingForManeuver
{
	//---------------------------------------------------------
	//	ManeuverFinished
	//---------------------------------------------------------
	function ManeuverFinished( bool bSuccess )
	{
		NavCtrl.StopManeuvering();

		if ( bSuccess )
			GotoState( 'RotateToFace' );
		else
		{
			//log("NAJ**** MountController::ManeuverFinished(): failure.", 'naj');
			CallbackClass.static.MountFinished( WGPawn, false, CurrentAction );	// failed
			WGPawn.StopTransitioning();
			GotoState( '' );
		}
	}

	//---------------------------------------------------------
	//	StopMountAction
	//---------------------------------------------------------
	function StopMountAction()
	{
		//log("NAJ**** MountController::StopMountAction() called.", 'naj');
		ResetVars();
		GotoState( '' );
	}
}

//=========================================================
//	State RotateToFace
//=========================================================
state RotateToFace
{
	//---------------------------------------------------------
	//	GetFocalPoint
	//---------------------------------------------------------
	function Vector GetFocalPoint()
	{
		switch ( CurrentAction )
		{
			case Mount_MountMG42Gunner:
			case Mount_Mount30CalGunner:
				if ( WGPawn.Turret != None )
					return WGPawn.Location + 1000.0 * Vector( WGPawn.Turret.Rotation );
				else
					return WGPawn.Location + 1000.0 * Vector( WGPawn.Rotation );

			case Mount_NavigationWallClimb:
			case Mount_NavigationClimbThroughWindow:
				return NavCtrl.FocalPointDuringAnim;

			default:
				return WGPawn.Location + 1000.0 * Vector( ReferenceRotator );
		}
	}

	//---------------------------------------------------------
	//	IsFacingProperly
	//---------------------------------------------------------
	function bool IsFacingProperly()
	{
		local Rotator RotTo;
		local int YawDiff;
		local bool bResult;

		RotTo = Rotator( Mind( WGPawn.Controller ).FacingVector - WGPawn.Location );

		RotTo.Yaw = RotTo.Yaw & 65535;

		YawDiff = abs(RotTo.Yaw - (WGPawn.Rotation.Yaw & 65535) );

		if (YawDiff >= 32767)
		{
			YawDiff = (65535 - YawDiff);
		}

		bResult = (YawDiff < 100);

		return bResult;
	}

	//---------------------------------------------------------
	//	Timer
	//---------------------------------------------------------
	function Timer()
	{
		bWaitForTimer = false;
		SetTimer( 0.0, false );
	}

//--------
Begin:
	if ( WGPawn.Controller.IsA( 'Mind' ) )
	{
		if ( !Mind( WGPawn.Controller ).SetFacingPolicy( FACE_Vector ) )
		{
			Log(name $ ".(" $ WGPawn.name $ ").MountController.state RotateToFace - FAILED TO SET FACING POLICY!!!");
			Goto( 'OnwardToNextState' );
		}

		Mind( WGPawn.Controller ).FacingVector = GetFocalPoint();
		Mind( WGPawn.Controller ).ImplementFacingPolicy();
	}

	WGPawn.m_fDispositionAnimPlaying = true;

	if ( bLerpRotation )
	{
		bWaitForTimer = true;
		SetTimer( 5.0, false );

		while ( !IsFacingProperly() && bWaitForTimer )
		{
			Sleep( 0.1 );
		}		
		// TEST
		//GotoState( 'PlayAnimation' );
	}
	
OnwardToNextState:
	if ( !IsFacingProperly() )
	{
		Log(name $ ".(" $ WGPawn.name $ ").MountController.state RotateToFace - FAILED TO ROTATE, popping rotation YAW to ..." $ ReferenceRotator.Yaw);

		WGPawn.SetRotation( ReferenceRotator );
		WGPawn.Controller.SetRotation( ReferenceRotator );
	}
	bRotationComplete = true;  // now pawn is facing properly

	GotoState( 'PlayAnimation' );
}

function bool PreTasks() { return true; }
function PlayMountAnimation() {}
function PostTasks() {}

//=========================================================
//	State PlayAnimation
//=========================================================
state PlayAnimation
{
	//---------------------------------------------------------
	//	Timer
	//---------------------------------------------------------
	function Timer()
	{
		bWaitForTimer = false;
		SetTimer( 0.0, false );
	}

	//---------------------------------------------------------
	//	PreTasks
	//---------------------------------------------------------
	function bool PreTasks()
	{
		// If this is a corner, determine which direction it "faces."
		if ( MountPoint != None && MountPoint.IsA( 'CornerPoint' ) )
		{
			if ( CornerPoint( MountPoint ).IsLeftCorner )
				LeanDirection = CDIR_Right;
			else
				LeanDirection = CDIR_Left;			
		}

		bStartOutCrouched = WGPawn.bIsCrouched;

		// Save the pawn's local coordinate axes for later, if necessary.
		GetAxes( WGPawn.Rotation, LocalX, LocalY, LocalZ );

		switch( CurrentAction )
		{
			case Mount_MountCornerCrouched:
				if ( !WGPawn.bIsCrouched )
				{
					WGPawn.StartGoingToCrouch( true );
					//bStandToCrouchMount = true;					
				}
				break;

			case Mount_MountCornerStanding:
				if ( WGPawn.bIsCrouched )
				{
					WGPawn.StartGoingToStand( true );
				}
				break;

			case Mount_DismountCorner:
				WGPawn.bNoTurnBody = true;
				WGPawn.SetLocation( WGPawn.WhereWillIBeWhenDismounting( bStartOutCrouched, WGPawn.bIsCrouched ) );
			case Mount_DismountCornerNoRootMotion:
				if ( WGPawn.bIsCrouched )
				{
					if ( !WGPawn.bWantsToCrouch )
					{
						WGPawn.StartGoingToStand( true );
						//bCrouchToStandMount = true;						
					}
				}
				else
				{
					if ( WGPawn.bWantsToCrouch )
					{
						WGPawn.StartGoingToCrouch( true );
						//bStandToCrouchMount = true;
					}
				}
				break;

			case Mount_MountCoverLow:
				WGPawn.StartGoingToCrouch( true );
				break;

			case Mount_MountCoverCrouched:
				WGPawn.StartGoingToCrouch( true );
				break;

			case Mount_MountCoverStanding:
				WGPawn.StartGoingToStand();
				break;

			case Mount_MountMG42Gunner:
			case Mount_Mount30CalGunner:
				if ( WGPawn.Turret != None )
					WGPawn.Turret.TryToPlaceGunner( WGPawn );
				WGPawn.SetWeapon( None );
				WGPawn.StartGoingToCrouch( true );
				break;

			case Mount_DismountMG42GunnerTurn:
			case Mount_DismountMG42Gunner:
			case Mount_DismountHalftrackMG42Gunner:
				WGPawn.PrepareTurretDismount();
				WGPawn.StartGoingToStand( true );
				break;

			case Mount_DismountPak36Gunner:
			case Mount_DismountPak36Loader:
			case Mount_DismountMortarGunner:
			case Mount_DismountMortarLoader:
				WGPawn.bNoTurnBody = true;
				WGPawn.StartGoingToStand( true );
			case Mount_DismountFlakVGunner:
			case Mount_DismountFlakVLoader:		
			case Mount_DismountPak88Gunner:
			//case Mount_DismountPak88Loader:
			case Mount_DismountPak88FuseSetter:
				WGPawn.bNoTurnBody = true;
				WGPawn.PrepareTurretDismount();
				break;

			
			case Mount_NavigationWallClimb:
			case Mount_NavigationClimbThroughWindow:
				WGPawn.bDoTorsoTwist = false;
				WGPawn.bNoTurnBody = true;
				WGPawn.bPawnLooksAtTargets = false;
				break;

			case Mount_ChangeToRelaxed:
				WGPawn.FlushAnimQueueChannel( 0 );
				WGPawn.SetWeaponAimedState( WAS_Relaxed );
				break;

			case Mount_ChangeToCombatReady:
				WGPawn.FlushAnimQueueChannel( 0 );
				WGPawn.SetWeaponAimedState( WAS_CombatRelaxed );
				break;

		}

		return true;
	}

	//---------------------------------------------------------
	//	PlayMountAnimation
	//---------------------------------------------------------
	function PlayMountAnimation()
	{
		local Name Animation;
		local bool bSuppressRootMotion;
		local float Rate, TweenTime;
		local byte bTeleportRootType;
		local Pawn tmpPawn;
		Rate = 1.0;
		TweenTime = 0.1;
		bSuppressRootMotion = true;
		bTeleportRootType = 0;

		//log("NAJ**** MountController::PlayMountAnimation() called.", 'naj');

		WGPawn.StartTransitioning();

		switch( CurrentAction )
		{
			case Mount_MountCornerCrouched:

				if ( LeanDirection == CDIR_Left )
					Animation = PawnAnimInfoClass.Static.PawnCoverMountAnim( WGPawn, 0, bStartOutCrouched, true );
				else
					Animation = PawnAnimInfoClass.Static.PawnCoverMountAnim( WGPawn, 1, bStartOutCrouched, true );				
				break;

			case Mount_MountCornerStanding:

				if ( LeanDirection == CDIR_Left )
					Animation = PawnAnimInfoClass.Static.PawnCoverMountAnim( WGPawn, 0, bStartOutCrouched, false );
				else
					Animation = PawnAnimInfoClass.Static.PawnCoverMountAnim( WGPawn, 1, bStartOutCrouched, false );				
				break;

			case Mount_MountCoverLow:
				Animation = PawnAnimInfoClass.Static.PawnStandToCrouchAnim( WGPawn );
				break;

			case Mount_MountCoverCrouched:
				if ( WGPawn.bIsCrouched )
					break;
				Animation = PawnAnimInfoClass.Static.PawnStandToCrouchAnim( WGPawn, true );
				break;

			case Mount_MountCoverStanding:
				break;

			case Mount_MountMG42Gunner:
			case Mount_Mount30CalGunner:
				WGPawn.LoadMountAnimations( CurrentAction );
				Animation = PawnAnimInfoClass.Static.MG42GunnerAnim( true );
				break;

			case Mount_DismountCorner:
				bSuppressRootMotion = false;
				TweenTime = 0.0;
			case Mount_DismountCornerNoRootMotion:
				if ( LeanDirection == CDIR_Left )
					Animation = PawnAnimInfoClass.Static.PawnCoverDismountAnim( 0, bStartOutCrouched, WGPawn.bWantsToCrouch );
				else
					Animation = PawnAnimInfoClass.Static.PawnCoverDismountAnim( 1, bStartOutCrouched, WGPawn.bWantsToCrouch );
				break;

			case Mount_DismountMG42GunnerTurn:
				WGPawn.GoBackToOldWeapon();
				Animation = PawnAnimInfoClass.Static.MG42GunnerAnim( false, true );
				bTeleportRootType = 1;
				break;

			case Mount_DismountMG42Gunner:
				WGPawn.GoBackToOldWeapon();
				Animation = PawnAnimInfoClass.Static.MG42GunnerAnim( false );
				break;

			case Mount_DismountHalftrackMG42Gunner:
				WGPawn.GoBackToOldWeapon();
				Animation = 'de_halftrack_dismount_mg42';  // from a_hold_misc.Halftrack
				break;

			case Mount_DismountHalftrackPassenger:
				Animation = 'de_halftrack_dismount';  // from a_hold_misc.Halftrack
				bSuppressRootMotion = false;
				bTeleportRootType = WGPawn.TR_AnimEnd;
				break;

			case Mount_DismountFlakVGunner:
				WGPawn.GoBackToOldWeapon();
				Animation = PawnAnimInfoClass.Static.FlakVGunnerDismountAnim( XOffset, YOffset, RotOffset );
				bSuppressRootMotion = false;
				//bTeleportRootType = WGPawn.TR_AnimEnd;
				break;

			case Mount_DismountFlakVLoader:
				WGPawn.GoBackToOldWeapon();
				if ( WGPawn.Job == Job_FlakV_LeftLoader )
					Animation = PawnAnimInfoClass.Static.FlakVLoaderDismountAnim( true, XOffset, YOffset, RotOffset );
				else
					Animation = PawnAnimInfoClass.Static.FlakVLoaderDismountAnim( false, XOffset, YOffset, RotOffset );
				bSuppressRootMotion = false;
				//bTeleportRootType = WGPawn.TR_AnimEnd;
				break;

			case Mount_DismountPak88Loader:
				WGPawn.GoBackToOldWeapon();
				//Animation = PawnAnimInfoClass.Static.Pak88LoaderDismountAnim( XOffset, YOffset, RotOffset );
				bSuppressRootMotion = false;
				bTeleportRootType = 1;  // TR_AnimStart
				break;

			case Mount_DismountPak88FuseSetter:
				WGPawn.GoBackToOldWeapon();
				Animation = PawnAnimInfoClass.Static.Pak88FuseSetterDismountAnim( XOffset, YOffset, RotOffset );
				bSuppressRootMotion = false;
				bTeleportRootType = 1;  // TR_AnimStart
				break;

			case Mount_DismountPak88Gunner:
				WGPawn.GoBackToOldWeapon();
				Animation = PawnAnimInfoClass.Static.Pak88GunnerDismountAnim( XOffset, YOffset, RotOffset );
				bSuppressRootMotion = false;
				bTeleportRootType = 1;  // TR_AnimStar
				break;

			case Mount_DismountPak88Spotter:
				//WGPawn.GoBackToOldWeapon();
				Animation = 'de_88_spotter_standing_dismount';
				bSuppressRootMotion = false;
				bTeleportRootType = 1;  // TR_AnimStart
				break;

			case Mount_DismountPak36Gunner:
				WGPawn.GoBackToOldWeapon();
				Animation = PawnAnimInfoClass.Static.Pak36GunnerDismountAnim( XOffset, YOffset );
				bSuppressRootMotion = false;
				break;

			case Mount_DismountPak36Loader:
				WGPawn.GoBackToOldWeapon();
				Animation = PawnAnimInfoClass.Static.Pak36LoaderDismountAnim( XOffset, YOffset );
				bSuppressRootMotion = false;
				break;

			case Mount_DismountMortarGunner:
				WGPawn.GoBackToOldWeapon();
				Animation = PawnAnimInfoClass.Static.MortarGunnerDismountAnim( XOffset, YOffset );
				bSuppressRootMotion = false;
				break;

			case Mount_DismountMortarLoader:
				WGPawn.GoBackToOldWeapon();
				if ( WGPawn.Job == Job_Mortar_LeftLoader )
					Animation = PawnAnimInfoClass.Static.MortarLoaderDismountAnim( true, XOffset, YOffset, RotOffset );
				else
					Animation = PawnAnimInfoClass.Static.MortarLoaderDismountAnim( false, XOffset, YOffset, RotOffset );
				bSuppressRootMotion = false;
				break;

			case Mount_NavigationWallClimb:
				Animation = 'standing_climb_over_128_wall';
				bSuppressRootMotion = false;
				bTeleportRootType = 1;  // TR_AnimStart
				break;

			case Mount_NavigationClimbThroughWindow:
//				Animation = 'standing_climb_through_window';
				Animation = 'standing_hop_over_wall_96';
				bSuppressRootMotion = false;
				bTeleportRootType = 1;  // TR_AnimStart
				break;

			case Mount_ChangeToRelaxed:
				Animation = PawnAnimInfoClass.Static.RelaxedTransitionAnim();
				bSuppressRootMotion = false;
				TweenTime = 0.25;
				break;

			case Mount_ChangeToCombatReady:
				Animation = PawnAnimInfoClass.Static.CombatReadyTransitionAnim();
				bSuppressRootMotion = false;
				break;

		}

		if ( Animation != '' )
		{
			WGPawn.AddAnimToQueue( Animation, 9999, true, false, bSuppressRootMotion, Rate, TweenTime, class'MountControllerAnimCallback', 0,,,,,, bTeleportRootType );

			// since wall climbing clears out all animation channels, AND requires teleport to root, we MUST queue up some animation
			// to play when the wall climbing animation ends otherwise the teleport to root value won't be passed into the native PlayAnim() code
			if ((CurrentAction == Mount_NavigationWallClimb) || (CurrentAction == Mount_NavigationClimbThroughWindow))
				WGPawn.AddAnimToQueue( WGPawn.PawnAnimInfoClass.Static.PawnIdleAnim( WGPawn ), 90, false, true, false, 1.0, 0.15, class'PawnAnimRandomIdleCallback' );

			//NAC: refer to above comment. In addition to that we must specify a generic pawn's idle animation, not the current pawn's because it will place the 88 gunner/loader's idle (i.e. he'll be sitting and it just looks bad!)
			if ((CurrentAction == Mount_DismountPak88Loader) ||(CurrentAction == Mount_DismountPak88Gunner ) || (CurrentAction == Mount_DismountPak88FuseSetter))
			{
				WGPawn.AddAnimToQueue( WGPawn.PawnAnimInfoClass.Static.PawnIdleAnim( tmpPawn ), 90, false, true, false, 1.0, 0.15, class'PawnAnimRandomIdleCallback' );
			}

			bWaitForTimer = true;
			SetTimer( 5.0, false );
		}
		else
		{
			// No animation to play, so skip to the punch line.
			AnimationFinished();
		}
	}

	//---------------------------------------------------------
	//	AnimationFinished
	//---------------------------------------------------------
	function AnimationFinished()
	{
		PostTasks();
		bWaitForCallback = false;
	}

	//---------------------------------------------------------
	//	PostTasks
	//---------------------------------------------------------
	function PostTasks()
	{
		local Rotator NewRot;

		WGPawn.m_fDispositionAnimPlaying = false;
		WGPawn.StopTransitioning();

		switch( CurrentAction )
		{
			case Mount_MountCornerCrouched:
				WGPawn.CompleteCornerMount( LeanDirection );
				break;
			case Mount_MountCornerStanding:
				WGPawn.CompleteCornerMount( LeanDirection );
				break;
			case Mount_MountCoverCrouched:
				WGPawn.SetUsingCrouchedCover( true );
				break;
			case Mount_MountCoverStanding:
				WGPawn.SetBackToWall( true );
				break;
			case Mount_DismountCorner:				
			case Mount_DismountCornerNoRootMotion:
				WGPawn.CompleteCornerDismount();
				WGPawn.bNoTurnBody = false;
				// Make sure the pawn is no longer trying to face into the wall.
				Mind( WGPawn.Controller ).SetFacingPolicy( FACE_Vector );
				Mind( WGPawn.Controller ).FacingVector = WGPawn.Location + 1000.0f * Vector( WGPawn.Rotation );
				break;
			case Mount_MountMG42Gunner:
			case Mount_Mount30CalGunner:
				WGPawn.CompleteTurretMount( false );
				break;

			case Mount_DismountMG42GunnerTurn:
			case Mount_DismountMG42Gunner:
			case Mount_DismountHalftrackMG42Gunner:
				WGPawn.CompleteTurretDismount();
				break;

			case Mount_DismountFlakVGunner:
			case Mount_DismountFlakVLoader:
				WGPawn.DetachFromBone( WGPawn );
				WGPawn.bNoTurnBody = false;
				WGPawn.SetLocation( WGPawn.Location + XOffset*LocalX + YOffset*LocalY );
				NewRot = WGPawn.Rotation + RotOffset;
				WGPawn.SetRotation( NewRot );
				WGPawn.Controller.SetRotation( NewRot );				
				WGPawn.CompleteTurretDismount();
				break;

			case Mount_DismountPak88Gunner:
			//case Mount_DismountPak88Loader:
			case Mount_DismountPak88FuseSetter:
				WGPawn.DetachFromBone( WGPawn );
				WGPawn.bNoTurnBody = false;
				WGPawn.CompleteTurretDismount();
				break;

			case Mount_DismountPak36Gunner:
			case Mount_DismountPak36Loader:
				WGPawn.bNoTurnBody = false;
				WGPawn.SetLocation( WGPawn.Location + XOffset*LocalX + YOffset*LocalY );
				WGPawn.CompleteTurretDismount();
				break;

			case Mount_DismountMortarGunner:
			case Mount_DismountMortarLoader:
				WGPawn.bNoTurnBody = false;
				WGPawn.SetLocation( WGPawn.Location + XOffset*LocalX + YOffset*LocalY );
				WGPawn.CompleteTurretDismount();
				break;

			case Mount_NavigationWallClimb:
			case Mount_NavigationClimbThroughWindow:
				WGPawn.bDoTorsoTwist = true;
				WGPawn.bNoTurnBody = false;
				WGPawn.bPawnLooksAtTargets = true;
				break;

			case Mount_ChangeToRelaxed:
				WGPawn.PlayWaiting();
				WGPawn.PlayMoving();
				break;

			case Mount_ChangeToCombatReady:
				WGPawn.PlayWaiting();
				WGPawn.PlayMoving();
				break;

		default:
			break;
		}

		bWaitForCallback = false;	// Just in case the animation never played.
		bPostTasksCalled = true;
	}

//--------
Begin:
	if ( PreTasks() )
	{
		bWaitForCallback = true;
		PlayMountAnimation();

		while( bWaitForCallback && bWaitForTimer )
			Sleep( 0.2 );

		if ( !bPostTasksCalled )
		{
			//log("NAJ**** MountController: timer expired.", 'naj');
			PostTasks();
		}
	}

	CallbackClass.static.MountFinished( WGPawn, true, CurrentAction );	// success

	//WGPawn.StopTransitioning();

	GotoState( '' );
}

//---------------------------------------------------------
//	DisplayDebug
//---------------------------------------------------------
simulated function DisplayDebug(Canvas Canvas, out float YL, out float YPos)
{
	Canvas.DrawColor.R = 255;
	Canvas.DrawColor.G = 255;
	Canvas.DrawColor.B = 0;
	Canvas.DrawText("MOUNTCONTROLLER: "$Self.name, false);

	if ( !NoShow )
	{
		YPos += YL;
		Canvas.SetPos(4,YPos);
		Canvas.DrawText("STATE: "$GetStateName(), false, 0.9, 0.9);		
	}
}

//=========================================================
//	State WaitingForDestruction
//=========================================================
state WaitingForDestruction
{
	function DoMountAction( EMountAction Action, ActorLite NewMountPoint, bool bUseManeuver, bool bDoLerpRotation, class<MountCallbackClass> NewCallbackClass, Rotator NewReferenceRot ) {}
}

defaultproperties
{
	PawnAnimInfoClass=class'PawnAnimInfoFinalTwoHand'
	bHidden=true
	NoShow=true

	RemoteRole=ROLE_None
}
//=============================================================================
// MountControllerAnimCallback.uc
//
//	This callback class is used for mount animations fired off by the
//	MountController.
//
//=============================================================================
class MountControllerAnimCallback extends PawnAnimExtra;



static function bool EndAnim( AnimPawn aPawn, bool bNoStart, bool fInterrupt )
{
	local MountController MountCtrl;
	if ( aPawn.Controller.IsA( 'Mind' ) )
	{
		MountCtrl = Mind( aPawn.Controller ).GetMountController();
		MountCtrl.AnimationFinished();
	}

	return true;
}
class MountHalftrackMG42Callback extends MountCallbackClass;


static function MountFinished( gbxPawn gbxP, bool bSuccess, EMountAction MountAction )
{
	MindHalftrackMG42Gunner( gbxP.Controller ).MountOrDismountFinished( bSuccess, MountAction );
}
class MountHalftrackPassengerCallback extends MountCallbackClass;


static function MountFinished( gbxPawn gbxP, bool bSuccess, EMountAction MountAction )
{
	MindHalftrackPassenger( gbxP.Controller ).MountOrDismountFinished( bSuccess, MountAction );
}
class NavigationController extends Actor
	notplaceable
	native;

var Mind 			MyMind;				// Mind that possesses the Pawn.
var AIController 	MyController;  		// AI Controller that possesses this Pawn
var MountController	MountCtrl;			// Reference to a MountController.
var gbxPawn			gbxPawn;			// Pawn that is being controlled
var float			TickTime;			// the next time the NavigationController should perform movement checks
var float			StartMoveTime;		// for checking if Pawn get stuck
var vector			StartMoveLoc;

var EFacingPolicy 	FacingPolicy;
var EFacingPolicy	SavedFacingPolicy;

const NUM_MAX_THREATS=16;

// Navigation variables...
var float CoverWeight;			// weight to use when navigating with cover
var	ECoverType CurrentCoverPosture;  // desired posture for Pawn when navigating with cover
var ECoverType PreviousCoverPostureRequest;
var Vector	vDestination;
var ActorLite aDestination;
var ActorLite NavPathNode;		// current PathNode actor in the navigation path
var ActorLite PrevNavPathNode;			// previous node returned from SetNextNavPoint (for checking if Pawn is in infinite navigation loop)
var float	JumpTime;
var float	fCheckBlockingPawnTime;
var Actor	PreviousActorHit;
var float	fCheckBlockingWorldTime;
var int		BlockingWorldCount;
var float	UseShortestPathDistance;	// use the shortest path instead of covered path if direct path distance is less than this amount
var array<ActorLite> MyBlockedNodes;	// a list of NavigationPoints that I tried to get to but was blocked by something
var float	OriginalPathDistance;		// keep track of the original path distance when re-pathfinding due to blocked nodes
var array<ActorLite> OneTimeBlockedNodes;	// allow external code to temporarily block some nodes from pathfinding (this is a one-off thing)
var Vector vThreatLocations[NUM_MAX_THREATS];
var int numThreatLocations;
var ReachSpec	WallClimbReachSpec;
var ActorLite	WallClimbNode1;			// first node in the Wall Climb animation sequence
var ActorLite	WallClimbNode2;			// second node in the Wall Climb animation sequence
var vector		WallClimbNode1Loc;
var vector		WallClimbNode2Loc;
var Pawn	WallClimbToucher;			// Pawn who is blocking one of the Wall Climb Nodes
var float	fWallClimbMoveTimer;		// save the MoveTimer value while waiting for other Pawns climbing a wall
var float	fWaitForWallClimbTimeout;	// timeout for waiting for a Pawn to move away from a wall climb path node

// Playing special animations while maneuvering stuff (climbing over walls, climbing through windows, etc)...
var vector	FocalPointDuringAnim;		// where to look at while special animation is playing (i.e. direction to face)
var vector	LocationDuringAnim;			// location where the Pawn should always be while playing this animation (others aren't allowed to change this)
var rotator	RotationDuringAnim;			// desired rotation during the animation

// boolean variables (keep together for better packing)...
var bool    bIsNavigating;				// are we currently navigating toward some location?
var bool    bIsNavPointSet;				// have we determined the navitation destination and/or navigation path yet?
var bool	bNeedsToJump;
var bool	bNeedsToWallClimb;
var bool	bFollowUnitPath;
var bool	bIsWallClimbing;			// is this Pawn currently climbing over a wall?
var bool	bIsApproachingWallClimbNode;	// is the next node in the navigation path a wall climb node?
var bool 	bWaitingForWallClimbPathNode;	// are we currently waiting for someone who's blocking a wall climb node?
var bool	bDoCallbackMountCtrl;		// Flag whether this maneuver action will need to call MountController back.
var bool	bWaitingOnAnimDone;			// are we waiting for special animation to finish playing?
var	bool	bPreciseNavBeforeAnim;		// set to true when we must navigate with precision to the nav point where animation starts
var bool	bIsMindDisabled;			// used to turn on/off Mind and FiringController during wall climb animations
var bool	bIsCollisionDisabled;		// used only in Wall Climbing when can't place (FarMoveActor) Pawn on top of start PathNode
var bool	bDrawMoveDirection;
var bool	bDrawPath;


enum ENavMountAnims
{
	NavMount_WallClimb,
	NavMount_ClimbThroughWindow
};


// PostBeginPlay is called when the actor spawns...
event PostBeginPlay()
{
	TickTime = 0.0f;
	fCheckBlockingPawnTime = 0.0f;
	fCheckBlockingWorldTime = 0.0f;
	BlockingWorldCount = 0;

	bIsMindDisabled = false;
	bIsNavigating = false;  // not initially navigating towards a point or actor
	bWaitingOnAnimDone = false;
	bIsApproachingWallClimbNode = false;
	bWaitingForWallClimbPathNode = false;
	CurrentCoverPosture = Cover_Standing;  // pawns spawn standing up
	PreviousCoverPostureRequest = CurrentCoverPosture;
	bIsCollisionDisabled = false;
}

function PrepareForDestroy()
{
	StopManeuvering();
	gbxPawn = None;
	GotoState( 'WaitingForDestruction' );
}

function Destroyed()
{
	UnBlockAllNodes();

	bWaitingOnAnimDone = false;
	bIsWallClimbing = false;

	MyMind = None;  // prevent references to/in destroyed objects
	MyController = None;
	MountCtrl = None;		// Mind is responsible for deleting it.
	gbxPawn = None;
	
	Disable( 'Tick' );
	Disable( 'Timer' );

	Super.Destroyed();
}

// Navigation Controller setup stuff after Pawn is possessed by AIController...

function SetMind(Mind NewMind)
{
	MyMind = NewMind;
	MyController = NewMind;
}

function SetMountController( MountController NewMountCtrl )
{
	MountCtrl = NewMountCtrl;
}

function Possess(gbxPawn aPawn)
{
	gbxPawn = aPawn;

	gbxPawn.bNavigateUsingCover = false;

	// AI Pawns have difficulty stopping at PathNodes if the DecelRate isn't increased from the default...
	gbxPawn.DecelRate=192.0;
}

function SetFacingPolicy( EFacingPolicy policy )
{
	FacingPolicy = policy;
}

function UnBlockAllNodes()
{
	local int index;

	if (MyBlockedNodes.Length > 0)
	{
		for (index = 0; index < MyBlockedNodes.Length; index++)
		{
			if (MyBlockedNodes[index].bIsNavigationPoint)
				NavigationPoint(MyBlockedNodes[index]).bCodeBlocked = false;
			else if (MyBlockedNodes[index].bIsNavigationPointLite)
				NavigationPointLite(MyBlockedNodes[index]).bCodeBlocked = false;
		}

		MyBlockedNodes.Remove(0, MyBlockedNodes.Length);  // empty the list of blocked nodes
	}
}


// Maneuvering functions (with and without cover)...

function ManeuverToVector( Vector dest )
{
	vDestination = dest;
	aDestination = None;

	StartMoveTime = Level.TimeSeconds;
	StartMoveLoc = gbxPawn.Location;

	bIsNavigating = true;
	gbxPawn.bNavigateUsingCover = false;  // no cover pathfinding required

	gbxPawn.Anchor = None;
	MyController.RouteGoal = None;

	UnBlockAllNodes();

	WallClimbNode1 = None;
	WallClimbNode2 = None;
	bIsWallClimbing = false;
	bIsApproachingWallClimbNode = false;
	bWaitingForWallClimbPathNode = false;
	fWaitForWallClimbTimeout = -1.0f;

	OriginalPathDistance = 0.0f;

	bIsNavPointSet = false;  // haven't set up navigation point and/or navigation path yet
	PreviousActorHit = None;  // haven't steered around anyone yet

	bNeedsToJump = false;
	bNeedsToWallClimb = false;
}

function bool ManeuverToActor( ActorLite dest, bool bStayCloseToUnitPath, optional bool bCallbackMountCtrl )
{
	local Pawn destClaimant;	

	destClaimant = None;
	if (dest.bIsNavigationPoint)
		destClaimant = NavigationPoint(dest).Claimant;
	else if (dest.bIsNavigationPointLite)
		destClaimant = NavigationPointLite(dest).Claimant;

	// is the desired destination already claimed by someone (other than me)?
	if ( destClaimant != None && destClaimant != gbxPawn )
	{
		Log(name $ " - ManeuverToActor: Trying to move to " $ dest.name $ " claimed by someone else (" $ destClaimant.name $ ")");
		return false;  // return error if already claimed
	}

	aDestination = dest;

	StartMoveTime = Level.TimeSeconds;
	StartMoveLoc = gbxPawn.Location;

	bIsNavigating = true;
	gbxPawn.bNavigateUsingCover = false;  // no cover pathfinding required

	gbxPawn.Anchor = None;
	MyController.RouteGoal = None;

	UnBlockAllNodes();

	WallClimbNode1 = None;
	WallClimbNode2 = None;
	bIsWallClimbing = false;
	bIsApproachingWallClimbNode = false;
	bWaitingForWallClimbPathNode = false;
	fWaitForWallClimbTimeout = -1.0f;

	OriginalPathDistance = 0.0f;

	bFollowUnitPath = bStayCloseToUnitPath;  // generate path that is close to the Unit's path (to keep guys together)
	bIsNavPointSet = false;  // haven't set up navigation point and/or navigation path yet
	PreviousActorHit = None;  // haven't steered around anyone yet

	bNeedsToJump = false;
	bNeedsToWallClimb = false;

	bDoCallbackMountCtrl = bCallbackMountCtrl;

	return true;
}

function ManeuverToVectorWithCover( Vector dest, Vector ThreatLocation, optional float fCoverWeight )
{
	vDestination = dest;
	aDestination = None;

	StartMoveTime = Level.TimeSeconds;
	StartMoveLoc = gbxPawn.Location;

	bIsNavigating = true;
	gbxPawn.bNavigateUsingCover = true;  // use cover points and cover paths when pathfinding

	gbxPawn.Anchor = None;
	MyController.RouteGoal = None;

	UnBlockAllNodes();

	WallClimbNode1 = None;
	WallClimbNode2 = None;
	bIsWallClimbing = false;
	bIsApproachingWallClimbNode = false;
	bWaitingForWallClimbPathNode = false;
	fWaitForWallClimbTimeout = -1.0f;

	OriginalPathDistance = 0.0f;

	vThreatLocations[0] = ThreatLocation;
	numThreatLocations = 1;

  	// cover weight range is 0.0 - 1.0 (0.0 = don't care about cover, 1.0 = strongly want cover)
	CoverWeight = fCoverWeight;

	bIsNavPointSet = false;  // haven't set up navigation point and/or navigation path yet
	PreviousActorHit = None;  // haven't steered around anyone yet

	bNeedsToJump = false;
	bNeedsToWallClimb = false;
}

function bool ManeuverToActorWithCover( ActorLite dest, Vector ThreatLocation, bool bStayCloseToUnitPath, optional float fCoverWeight )
{
	local Pawn destClaimant;

	destClaimant = None;
	if (dest.bIsNavigationPoint)
		destClaimant = NavigationPoint(dest).Claimant;
	else if (dest.bIsNavigationPointLite)
		destClaimant = NavigationPointLite(dest).Claimant;

	// is the desired destination already claimed by someone (other than me)?
	if ( destClaimant != None && destClaimant != gbxPawn )
	{
		Log(name $ " - ManeuverToActorWithCover: Trying to move to " $ dest.name $ " claimed by someone else (" $ destClaimant.name $ ")");
		return false;  // return error if already claimed
	}

	aDestination = dest;

	StartMoveTime = Level.TimeSeconds;
	StartMoveLoc = gbxPawn.Location;

	bIsNavigating = true;
	gbxPawn.bNavigateUsingCover = true;  // use cover points and cover paths when pathfinding

	gbxPawn.Anchor = None;
	MyController.RouteGoal = None;

	UnBlockAllNodes();

	WallClimbNode1 = None;
	WallClimbNode2 = None;
	bIsWallClimbing = false;
	bIsApproachingWallClimbNode = false;
	bWaitingForWallClimbPathNode = false;
	fWaitForWallClimbTimeout = -1.0f;

	OriginalPathDistance = 0.0f;

	vThreatLocations[0] = ThreatLocation;
	numThreatLocations = 1;

  	// cover weight range is 0.0 - 1.0 (0.0 = don't care about cover, 1.0 = strongly want cover)
	CoverWeight = fCoverWeight;

	bFollowUnitPath = bStayCloseToUnitPath;  // generate path that is close to the Unit's path (to keep guys together)
	bIsNavPointSet = false;  // haven't set up navigation point and/or navigation path yet
	PreviousActorHit = None;  // haven't steered around anyone yet

	bNeedsToJump = false;
	bNeedsToWallClimb = false;

	return true;
}

function StopManeuvering()
{
	if (!bIsNavigating)  // ignore if not currently maneuvering
		return;

	UnBlockAllNodes();

	if (gbxPawn != None)
		gbxPawn.Acceleration = vect(0,0,0);

	bIsNavigating = false;
}

// callback from NavigationController.cpp when maneuver is complete
event ManeuverComplete()
{
	UnBlockAllNodes();

	if ( bDoCallbackMountCtrl )
	{
		MountCtrl.ManeuverFinished( true );	// successful
		bDoCallbackMountCtrl = false;
	}
	else
		MyMind.ManeuverComplete();
}

// callback from NavigationController.cpp when maneuver failed
event ManeuverFailed()
{
	UnBlockAllNodes();

	if ( bDoCallbackMountCtrl )
	{
		MountCtrl.ManeuverFinished( false );	// failed
		bDoCallbackMountCtrl = false;
	}
	else
		MyMind.ManeuverFailed();
}

event StartMountAnimation(ENavMountAnims MountAnim)
{
	local int index;

	gbxPawn.StopAnimating(true);

	gbxPawn.FlushAnimQueueChannel( 0 );

	for (index=1; index <= 16; index++)
		gbxPawn.FlushAnimQueueChannel( index, false, true );

	RotationDuringAnim = gbxPawn.Rotation;
	RotationDuringAnim.Yaw = rotator(FocalPointDuringAnim - LocationDuringAnim).Yaw;

	RotationDuringAnim.Pitch = RotationDuringAnim.Pitch & 65535;
	RotationDuringAnim.Yaw = RotationDuringAnim.Yaw & 65535;
	RotationDuringAnim.Roll = RotationDuringAnim.Roll & 65535;

	if (MountAnim == NavMount_WallClimb)
	{
		MountCtrl.DoMountAction( Mount_NavigationWallClimb, None, false, true, class'NavigationControllerCallback', RotationDuringAnim );
	}
	else if (MountAnim == NavMount_ClimbThroughWindow)
	{
		MountCtrl.DoMountAction( Mount_NavigationClimbThroughWindow, None, false, true, class'NavigationControllerCallback', RotationDuringAnim );
	}
}

function MountFinished( bool bSuccess, EMountAction MountAction )
{
	// wall climbover/windowthru animation is done, okay to interrupt me now...
	MyMind.OKToInterruptMe();

	MyMind.SetFacingPolicy(SavedFacingPolicy);  // restore the saved facing policy (from native code)

//jlb - this is WRONG because the Pawn HASN'T teleported yet until the NEXT animation plays!!!...
//	NavPoint = GetNearestNavpoint(gbxPawn.Location, -1.0f, false, true, false, false, gbxPawn);
//
//	if (gbxPawn.ReachedDestination(NavPoint))
//	{
//		gbxPawn.SetMyRecentlyTouchedNavPoint(NavPoint);
//	}

	gbxPawn.SetMyRecentlyTouchedNavPoint(WallClimbNode2);  // HACKHACK!!! - fix for WRONG above!!!

	bWaitingOnAnimDone = false;
	bIsWallClimbing = false;
	bIsApproachingWallClimbNode = false;
	bWaitingForWallClimbPathNode = false;

	bPreciseNavBeforeAnim = false;
}

event RequestPawnToStand()
{
	MyMind.RequestPawnToStand();
	PreviousCoverPostureRequest = Cover_Standing;
}

event RequestPawnToCrouch()
{
	MyMind.RequestPawnToCrouch();
	PreviousCoverPostureRequest = Cover_Crouched;
}

event RequestPawnToGoProne()
{
//DISABLED	MyMind.RequestPawnToGoProne();
	MyMind.RequestPawnToCrouch();
	PreviousCoverPostureRequest = Cover_Low;
}


function DisplayDebug(Canvas Canvas, out float YL, out float YPos)
{
	//local string str;
	Canvas.SetDrawColor(0,255,0);
	YPos += YL;
	Canvas.SetPos(4,YPos);
	Canvas.DrawText("NAVCONTROLLER: "$Self.name, false);
	YPos += YL;
	Canvas.SetPos(4,YPos);
}

//=========================================================
//	State WaitingForDestruction
//=========================================================
state WaitingForDestruction
{
	function Possess(gbxPawn aPawn) {}
	function ManeuverToVector( Vector dest ) {}
	function bool ManeuverToActor( ActorLite dest, bool bStayCloseToUnitPath, optional bool bCallbackMountCtrl ) { return false; }
	function ManeuverToVectorWithCover( Vector dest, Vector ThreatLocation, optional float fCoverWeight ) {}
	function bool ManeuverToActorWithCover( ActorLite dest, Vector ThreatLocation, bool bStayCloseToUnitPath, optional float fCoverWeight ) { return false; }
	function ManeuverComplete() {}
	function ManeuverFailed() {}
	function StartMountAnimation(ENavMountAnims MountAnim) {}
	function MountFinished( bool bSuccess, EMountAction MountAction ) {}
}

defaultproperties
{
	bHidden=true

	FacingPolicy=FACE_Destination
	UseShortestPathDistance=1500.0

	RemoteRole=ROLE_None
}
class NavigationControllerCallback extends MountCallbackClass;


static function MountFinished( gbxPawn gbxP, bool bSuccess, EMountAction MountAction )
{
	local NavigationController NavCtrl;

	if ( gbxP.Controller.IsA( 'Mind' ) )
	{
		NavCtrl = Mind( gbxP.Controller ).NavigationController;
		if (NavCtrl != None)
			NavCtrl.MountFinished( bSuccess, MountAction );
	}
}
class PathExclusionTracker extends Actor;



var array<ActorLite>	TheList;
var array<FLOAT>		TimeStamps;
var float				ShelfLife;

//---------------------------------------------------------
//	PostBeginPlay
//---------------------------------------------------------
function PostBeginPlay()
{
	SetTimer( 1.0, true );
}

//---------------------------------------------------------
//	AddToList
//---------------------------------------------------------
function AddToList( ActorLite NewPoint )
{
	local int x;

	if ( NewPoint == None )
		return;

	// TBD: Iterate over list, check that there is not a dupe.
	for( x=0; x < TheList.Length; ++x)
	{
		if ( TheList[x] == NewPoint )
			return;
	}

	// Ensure that there are no more than 2 items in the list at any one time. 
	//if ( TheList.Length >= 2 )
		//Deque();

	TheList[ TheList.Length ] = NewPoint;
	TimeStamps[ TimeStamps.Length ] = Level.TimeSeconds;
}

//---------------------------------------------------------
//	GetList
//---------------------------------------------------------
function GetList( out array<ActorLite> OutList )
{
	local int x;

	OutList.Length = TheList.Length;

	for(x=0; x<TheList.Length; ++x)
	{
		OutList[x] = TheList[x];
	}
}

//---------------------------------------------------------
//	ClearList
//---------------------------------------------------------
function ClearList()
{
	if ( TheList.Length > 0 )
	{
		TheList.Remove( 0, TheList.Length );
		TimeStamps.Remove( 0, TimeStamps.Length );
	}
}

//---------------------------------------------------------
//	Timer
//---------------------------------------------------------
function Timer()
{
	local int x;

	// Once per seconds, check for stale records.
	for( x=0; x < TheList.Length; ++x) 
	{
		if ( Level.TimeSeconds > ( TimeStamps[ x ] + ShelfLife ) )
		Deque();
		else
			return;
	}
}

//---------------------------------------------------------
//	Deque
//---------------------------------------------------------
function Deque()
{
	TheList.Remove( 0, 1 );
	TimeStamps.Remove( 0, 1 );
}

//---------------------------------------------------------
//	RemoveFromList
//---------------------------------------------------------
function RemoveFromList( ActorLite PointToRemove )
{
	local int x;

	if ( PointToRemove == None )
		return;

	for( x=0; x < TheList.Length; ++x) 
	{
		if ( TheList[x] == PointToRemove )
		{
			TheList.Remove( x, 1 );
			TimeStamps.Remove( x, 1 );
			return;
		}
	}
}

//---------------------------------------------------------
//	PrintList
//---------------------------------------------------------
function String PrintList()
{
	local int x;
	local String ListContents;

	ListContents = "";

	for( x = 0; x < TheList.Length; ++x )
	{
		ListContents = ListContents$GetItemName( String( TheList[x] ) );
		if ( x < TheList.Length )
			ListContents = ListContents$" ; ";
	}

	return ListContents;
}

defaultproperties
{
	bHidden=true
	ShelfLife=30.0

	RemoteRole=ROLE_None
}
class Perception extends gbxMessage
	abstract
	transient;


function AffectMind( Mind aMind )
{
	// Override Me.
}

function AffectUnit( Unit aUnit, float assumedDistanceFromUnit )
{
	// Override Me.
}

function AffectTank( TankController TC )
{
	// Override Me.
}


defaultproperties
{
	bUseSenderLocation=true
	bBroadcastRadially=true
	BroadcastRadius=1024
	bDupable=true
	DupeRadius=512
	DupeTime=3
}
/////////////////////////////////////////////////////////////////////////
/// PerceptionGrenade
///
/// Used by grenades to notify observant pawns about the grenade
/////////////////////////////////////////////////////////////////////////
class PerceptionGrenade extends Perception;



function AffectMind( Mind aMind )
{
	local gbxExplosive gExplosive;

	local float DistToGrenade;
	gExplosive = gbxExplosive(Sender);

	DistToGrenade = VSize( aMind.WGPawn.Location - gExplosive.Location );
	//NAC:our own teammates are always aware of when I throw a grenade, get them the heck out of the way
	if (gExplosive.Instigator.SameTeamAs(aMind.WGPawn) && DistToGrenade < gExplosive.DamageRadius)
	{
		aMind.SeeGrenade( gExplosive, true );
	}

	// Only notify this mind if I'm mostly in front of it's owner, or if it's really close
	else if( IsExplosiveInView( aMind.WGPawn, gExplosive ) || DistToGrenade < 128.0 )
	{
		aMind.SeeGrenade( gExplosive, true );
	}
}

function AffectUnit( Unit aUnit, float assumedDistanceFromUnit )
{
	aUnit.DoSuppressionGrenade();
}

function bool IsExplosiveInView( AnimPawn aPawn, gbxExplosive gExplosive )
{
	return Vector( aPawn.GetBoneRotation( aPawn.ScriptedViewBoneName ) ) dot Normal( gExplosive.Location - aPawn.Location ) > 0.31; // ~ 72 deg.
}

defaultproperties
{
	bBroadcastLOSBlocked = true;
}
/////////////////////////////////////////////////////////////////////////
/// PerceptionGrenadeExplosion
///
/// Used by grenades to notify all pawns in the area about the explosion
/////////////////////////////////////////////////////////////////////////
class PerceptionGrenadeExplosion extends Perception;


function AffectMind( Mind aMind ) {}

function AffectUnit( Unit aUnit, float assumedDistanceFromUnit )
{
	local float Normalized, Temp;

	// Scale the suppression based on the distance of the explosion from the target.
	// At 600 units or closer, do full suppression.  From 600 to 1000 units, scale gradually down.
	Temp = ( assumedDistanceFromUnit - 600.0 ) / ( 1000.0 - 600.0 );
	Normalized = 1.0 - FClamp( Temp, 0.0, 1.0 );
	aUnit.DoGradedSuppressionGrenade( Normalized * 1.5f );
}

function AffectTank( TankController TC )
{
	if ( TC.Pawn != Sender )
	{
		TC.SeeExplosion( Instigator );
	}
}


defaultproperties
{
	bBroadcastLOSBlocked = false;
}
/////////////////////////////////////////////////////////////////////////
/// PerceptionGrenadeNotify
///
/// Used by pawns to notify nearby pawns about a grenade they discovered
/////////////////////////////////////////////////////////////////////////
class PerceptionGrenadeNotify extends Perception;



var gbxExplosive Grenade;				/// The grenade to tell everyone around us about

function AffectMind( Mind aMind )
{
	if( Grenade != None )
	{
		aMind.SeeGrenade( Grenade, false );
	}
}

function AffectUnit( Unit aUnit, float assumedDistanceFromUnit )
{
	aUnit.DoSuppressionGrenade();
}

event bool ActorWasDeleted( Actor anActor )
{
	Super.ActorWasDeleted( anActor );
	if (Grenade == anActor)
	{
		Grenade = None;
	}
	return false;
}

defaultproperties
{
	bDupable=false
}
class PerceptionImpact extends Perception;



var() float ImpactSeverity;

function AffectMind( Mind aMind )
{
	if( aMind.Pawn != Sender )	// If I didn't shoot the bullet...
	{
		aMind.SeeImpact( Pawn( Sender ), ImpactSeverity * ( NumDupes + 1 ), VSize( aMind.Pawn.Location - GetLocation() ));
	}
}

function AffectUnit( Unit aUnit, float assumedDistanceFromUnit )
{
	if( aUnit != None )
	{
		UnitControllerAI( aUnit.MyUnitController ).MemberSawImpact( Pawn( Sender ), assumedDistanceFromUnit, ImpactSeverity );
	}
}

defaultproperties
{
	bHasLocation=true
	bUseSenderLocation=false
	BroadcastRadius=1000	// was 1400 for a long time
	DupeRadius=700
	DupeTime=2

	ImpactSeverity=1.0
}
class PerceptionIncreasedAttackLevel extends Perception;



var() Pawn Attacker;
var float AttackLevel;

function SetAttackLevel( float newAttackLevel )
{
	AttackLevel = newAttackLevel;
}

function AffectMind( Mind aMind )
{
	local Mind mindSender;

	if (aMind == None)
		return;

	if ( Sender.IsA( 'Pawn' ) )
		mindSender = Mind( Pawn( Sender ).Controller );
	else if ( Sender.IsA( 'Mind' ) )
		mindSender = Mind( Sender );

	if (mindSender == None)
		return;

	if( Attacker != None && aMind.Pawn != None && aMind != Sender && aMind.Pawn.SameTeamAs( mindSender.Pawn ))
	{
		aMind.MatchFriendsAttackLevel( mindSender, Attacker, AttackLevel );
	}
}

event bool ActorWasDeleted( Actor anActor )
{
	Super.ActorWasDeleted( anActor );
	if (Attacker == anActor)
	{
		Attacker = None;
	}
	return false;
}

defaultproperties
{
	bUseSenderLocation=true

	bBroadcastLOSBlocked=false
	bBroadcastRadially=true
	BroadcastRadius=2048

	DupeRadius=1024
	DupeTime=1
}
class PerceptionOpBurst extends Perception;


function AffectMind( Mind aMind )
{
	if( aMind.Pawn != Sender )	// If I didn't send the message...
	{
		aMind.NotifyDoingOpBurst();
	}
}

function AffectUnit( Unit aUnit, float assumedDistanceFromUnit )
{	
}

defaultproperties
{
	bBroadcastLOSBlocked=false
	bBroadcastRadially=true

	BroadcastRadius=2048
	DupeRadius=2048

	bDupable=true
	DupeTime=2
}
class PerceptionOrderMove extends Perception;



var() edfindable Actor aDestination;
var() Vector vDestination;		// This is used if aDestination == None.

function AffectMind( Mind aMind )
{
	local vector dest;

	if( aDestination != None )
	{
		dest = aDestination.Location;
	}
	else
	{
		dest = vDestination;
	}
	aMind.SetAssignedDestination( dest );
}

event bool ActorWasDeleted( Actor anActor )
{
	Super.ActorWasDeleted( anActor );
	if (aDestination == anActor)
	{
		aDestination = None;
	}
	return false;
}

defaultproperties
{
	bBroadcastLOSBlocked=false
	bBroadcastRadially=false

	bDupable=false
}
class PerceptionPawnAddedTarget extends Perception;



var() gbxPawn Target;

function AffectMind( Mind aMind )
{
	local Mind mindSender;

	if (aMind == None)
		return;

	if ( Sender.IsA( 'Pawn' ) )
		mindSender = Mind( Pawn( Sender ).Controller );
	else if ( Sender.IsA( 'Mind' ) )
		mindSender = Mind( Sender );

	if (mindSender == None)
		return;

	if( Target != None && aMind.Pawn != None && aMind != mindSender && aMind.Pawn.SameTeamAs( mindSender.Pawn ))
	{
		// Minds add their friends' targets.
		aMind.AddTarget( Target );
	}
}

event bool ActorWasDeleted( Actor anActor )
{
	Super.ActorWasDeleted( anActor );
	if (Target == anActor)
	{
		Target = None;
	}
	return false;
}

defaultproperties
{
	bUseSenderLocation=true

	bBroadcastLOSBlocked=false
	bBroadcastRadially=true
	BroadcastRadius=2000	// was 6000 for a long time.

	DupeRadius=1024
	DupeTime=2
}
class PerceptionPawnDied extends Perception;


var() Pawn PawnDied;
var() Pawn Killer;  // Pawn who killed me


function AffectMind( Mind aMind )
{
	if( aMind.Pawn != PawnDied && aMind.Pawn != Sender )
	{
		aMind.SeePawnDied( PawnDied );
	}
}

function AffectUnit( Unit aUnit, float assumedDistanceFromUnit )
{
	if( aUnit != None )
	{
		UnitControllerAI( aUnit.MyUnitController ).MemberSawPawnDie( PawnDied );
	}
}

function AffectTank( TankController TC )
{
	if( TC.Pawn != PawnDied && TC.Pawn != Sender )
	{
		TC.SeePawnKilled( PawnDied, Killer );
	}
}

event bool ActorWasDeleted( Actor anActor )
{
	Super.ActorWasDeleted( anActor );
	
	if (PawnDied == anActor)
	{
		PawnDied = None;
	}
	if (Killer == anActor)
	{
		Killer = None;
	}
	return false;
}

defaultproperties
{
	bBroadcastLOSBlocked=false
	bBroadcastRadially=true

	BroadcastRadius=2048
	DupeRadius=400
	DupeTime=2
}
class PerceptionPawnHit extends Perception;



var() Pawn PawnHit;
var bool bWarningShot;

function AffectMind( Mind aMind )
{
	if( aMind.Pawn != PawnHit && aMind.Pawn != Sender )
	{
		if ( bWarningShot && PawnHit.IsHumanControlled() )
		{
			aMind.SeePlayerWarningShot( PawnHit );
		}
		else
		{
		aMind.SeePawnHit( PawnHit );
	}
}
}

function AffectUnit( Unit aUnit, float assumedDistanceFromUnit )
{
	if( !bWarningShot && aUnit != None )
	{
		UnitControllerAI( aUnit.MyUnitController ).MemberSawPawnHit( PawnHit );
	}
}

event bool ActorWasDeleted( Actor anActor )
{
	Super.ActorWasDeleted( anActor );
	
	if (PawnHit == anActor)
	{
		PawnHit = None;
	}
	return false;
}

defaultproperties
{
	bBroadcastLOSBlocked=false
	bBroadcastRadially=true
	BroadcastRadius=2048

	DupeRadius=400
	DupeTime=2
}
class PerceptionTankShellExplosion extends Perception;


function AffectMind( Mind aMind ) {}

function AffectUnit( Unit aUnit, float assumedDistanceFromUnit )
{
	local float Normalized, Temp;

	// Scale the suppression based on the distance of the explosion from the target.
	// At 1024 units or closer, do full (1.0) suppression.  From 1024 to 2000 units, scale gradually down from 1.0 to 0.0.
	Temp = ( assumedDistanceFromUnit - 1024.0 ) / ( 2000.0 - 1024.0 );
	Normalized = 1.0 - FClamp( Temp, 0.0, 1.0 );
	aUnit.DoGradedSuppressionGrenade( Normalized * 5.0 );
}

function AffectTank( TankController TC )
{
	if ( TC.Pawn != Sender )
	{
		TC.SeeExplosion( Instigator );
	}
}


defaultproperties
{
	bBroadcastLOSBlocked = false;
	BroadcastRadius=2000
}class RelaxedCallback extends MountCallbackClass;

static function MountFinished( gbxPawn gbxP, bool bSuccess, EMountAction MountAction )
{
	if ( gbxP.Controller.IsA( 'Mind' ) )
	{
		Mind( gbxP.Controller ).NotifyRelaxed();
	}
}class SalutationsController extends Actor;

var int		NumGoodbyes;
var int		MaxGoodbyes;
var float	EngagePlayerDist;
var float	EngagedPlayerTime;
var float	DisengagePlayerDist;
var float	LastSpokenTime;
var float	CommentaryInterval;
var Pawn	TheHumanPlayer;
var Mind	MyMind;
var WargamePawn	WGPawn;
var bool	bSpokenAtLeastOnce;
var bool	bEngagedPlayer;
var bool	bTrackingPlayer;
var bool	bActivated;
var bool	bSpokenLowAmmo;

function Initialize( Mind NewMind, WargamePawn NewPawn )
{
	MyMind = NewMind;
	WGPawn = NewPawn;
	StartTrackingPlayer();

	bEngagedPlayer = false;
	bTrackingPlayer = true;
	bActivated = false;
	bSpokenLowAmmo = false;
	NumGoodbyes = 0;
	
	LastSpokenTime = 0.0f;
}

function RespondToPlayerUse()
{
	if( MyMind.IsInCombat() )
	{
		SpeakUsedDuringCombat();
	}
	else if( bTrackingPlayer )
	{		
		MyMind.SetPlayerAddressingMe( true );
		bEngagedPlayer = true;

		SpeakCommentary();
	}
	else
	{
		SpeakCommentary();
	}
}

function SpeakUsedDuringCombat()
{
	local Name nameSpeech;

	// dont speak too often
	if( Level.TimeSeconds - LastSpokenTime < CommentaryInterval )
	{
		return;
	}

	if( WGPawn.numTimesSpokenTo > 2 )
	{
		nameSpeech = 'Annoyed';

		WGPawn.numTimesSpokenTo = 0;
	}
	else 
	{
		nameSpeech = 'CombatUse';
		
		WGPawn.numTimesSpokenTo++;
	}

	Level.TheAISpeechManager.PlaySpeech(
		WGPawn,
		TheHumanPlayer,
		nameSpeech,
		,
		,
		0.0,
		WGPawn.MyUnit,
		0.0,
		1.0
	);

	bSpokenAtLeastOnce = true;
	bSpokenLowAmmo=false;
	LastSpokenTime = Level.TimeSeconds;
}

function SpeakCommentary()
{
	local String strLevel;
	local Name nameSpeech;

	// dont speak too often
	if( Level.TimeSeconds - LastSpokenTime < CommentaryInterval )
	{
		return;
	}

	if( MyMind.IsInCombat() )
	{
		return;
	}

	if( !bSpokenAtLeastOnce )
	{
		strLevel = Left( Level.GetLevelFileName(), 8 );	// get the first 8 characters, hopefully this never changes
		nameSpeech = FindNameFromString( strLevel );

		if( nameSpeech == '' )
		{
			nameSpeech = 'NonCombatGreeting';
		}
		
		WGPawn.numTimesSpokenTo++;
	}
	else if( WGPawn.numTimesSpokenTo > 2 )
	{
		nameSpeech = 'HangAround';

		WGPawn.numTimesSpokenTo = 0;
	}
	else 
	{
		nameSpeech = 'NonCombatGreeting';
		
		WGPawn.numTimesSpokenTo++;
	}

	Level.TheAISpeechManager.PlaySpeech(
		WGPawn,
		TheHumanPlayer,
		nameSpeech,
		,
		,
		0.0,
		WGPawn.MyUnit,
		0.0,
		1.0
	);

	bSpokenAtLeastOnce = true;
	bSpokenLowAmmo=false;
	LastSpokenTime = Level.TimeSeconds;
}

function SpeakLowAmmo()
{
	if( MyMind.IsInCombat() )
	{
		return;
	}

	Level.TheAISpeechManager.PlaySpeech(
		WGPawn,
		TheHumanPlayer,
		'NeedAmmo',
		,
		,
		0.0,
		None,
		0.0,
		1.0
	);

	LastSpokenTime = Level.TimeSeconds;
	bSpokenLowAmmo=true;
}

function SpeakGoodbye()
{
	if( MyMind.IsInCombat() )
	{
		return;
	}

	Level.TheAISpeechManager.PlaySpeech(
		WGPawn,
		TheHumanPlayer,
		'NonCombatDismissal',
		,
		,
		0.0,
		None,
		0.0,
		1.0
	);

	LastSpokenTime = Level.TimeSeconds;
	bSpokenLowAmmo=false;
}

function StartTrackingPlayer()
{
	// This check is not absolutely necessary, but it helps me sleep at night.
	if ( Level.NetMode == NM_Standalone && TimerRate <= 0.000001f )
		SetTimer( 1.0, true );

	bTrackingPlayer = true;
}

function StopTrackingPlayer()
{
	SetTimer( 0.0, false );
	bTrackingPlayer = false;
	NumGoodbyes = 0;
}

function Timer()
{
	local PlayerController	PC;
	local float DistToPlayer;
	local bool bPlayerIsFacingMe, bIAmFacingPlayer;

	if ( MyMind == None || WGPawn == None )
	{
		return;
	}

	if( TheHumanPlayer == None )
	{		
		if( TheHumanPlayer == None )
		{
			PC = Level.GetLocalPlayerController();
			if ( PC != None )
				TheHumanPlayer = PC.Pawn;
		}
	}

	DistToPlayer = VSize( TheHumanPlayer.Location - WGPawn.Location );
	bIAmFacingPlayer = WGPawn.IsPawnFacingActor( TheHumanPlayer, 0.4 );
	bPlayerIsFacingMe = TheHumanPlayer.IsPawnFacingActor( WGPawn, 0.5 );

	// Require the player to first be outside our range before we consider engaging him.
	// This removes the problem of pawns talking right after the map starts just because they are spawned right in front of his face.
	if ( !bActivated )
	{
		if ( DistToPlayer >= DisengagePlayerDist )
		{
			bActivated = true;
		}
	}
	else if ( bEngagedPlayer )
	{
		bPlayerIsFacingMe = TheHumanPlayer.IsPawnFacingActor( WGPawn, 0.3 );

		if ( DistToPlayer >= DisengagePlayerDist /*|| !bPlayerIsFacingMe*/ )		// Uncomment if you want the pawn to disengage when the player turns away from him.
		{
			MyMind.SetPlayerAddressingMe( false );
			bEngagedPlayer = false;
			EngagedPlayerTime = 0.0f;			

			// Say goodbye.
			if ( NumGoodbyes < MaxGoodbyes && bSpokenAtLeastOnce )
			{
				SpeakGoodbye();
				NumGoodbyes++;
			}

			WGPawn.numTimesSpokenTo = 0;
			bSpokenAtLeastOnce = false;
		}
		else
		{
			// Still engaging player; should I say something?
			if ( Level.TimeSeconds > ( EngagedPlayerTime + 2.5 ) && Level.TimeSeconds > ( LastSpokenTime + CommentaryInterval ) && bIAmFacingPlayer && bPlayerIsFacingMe )
			{
				// Should I speak about ammo or other stuff
				if( !TheHumanPlayer.Weapon.IsAmmoFull() /*&& TheHumanPlayer.Weapon.AmmoMatches( WGPawn.Weapon )*/ && !bSpokenLowAmmo )
				{
					SpeakLowAmmo();
				}
				else
				{
					SpeakCommentary();
				}
			}
		}
	}
	else
	{
		// Not yet engaging the player.
		if ( DistToPlayer <= EngagePlayerDist && bPlayerIsFacingMe && bIAmFacingPlayer )
		{
			MyMind.SetPlayerAddressingMe( true );
			bEngagedPlayer = true;
			EngagedPlayerTime = Level.TimeSeconds;
			
			// Always say something the first time I engage the player.
			if( !TheHumanPlayer.Weapon.IsAmmoFull() /*&& TheHumanPlayer.Weapon.AmmoMatches( WGPawn.Weapon )*/ && !bSpokenLowAmmo )
			{
				SpeakLowAmmo();
			}
			else
			{
				SpeakCommentary();
			}
			//LastSpokenTime = Level.TimeSeconds;
		}
	}	
}

defaultproperties
{
	DrawType=DT_None
	EngagePlayerDist=185.0f
	DisengagePlayerDist=200.0f
	CommentaryInterval=3.0f
	MaxGoodbyes=2
	bHidden=true

	bSpokenLowAmmo=false
}
class StaticMind extends Mind;



//---------------------------------------------------------
//	PostNetBeginPlay
//---------------------------------------------------------
function PostNetBeginPlay()
{
	local float ThinkStart;

	Super.PostNetBeginPlay();

	Level.MessageManager.AddListener( Self );

	FiringController = Spawn( FiringControllerClass );
	FiringController.SetMind( Self );

	TimerInterval = Level.AIMaxThinkInterval;
	ThinkStart = 1 + Level.AIGetNextThinkStart();

	log( Name $ ".PostNetBeginPlay() - Thinking will be delayed " $ ThinkStart $ " sec.", 'Mind' );

	SetTimer( ThinkStart, true );
}

function Possess(Pawn aPawn)
{
	Super( gbxAIController ).Possess(aPawn);

	Pawn.SetMovementPhysics();
	if (Pawn.Physics != PHYS_Walking)
		Pawn.SetPhysics(PHYS_Falling);

	WGPawn = WargamePawn( aPawn );

	if (FiringController != None)
	{
		FiringController.Possess(aPawn);
	}

	// Lock position to the pawn's position
	SetLocation( aPawn.Location );
	SetBase( aPawn );

	fApproachingTime = 0.0;

	GotoState('FiringFromCover');
}

function bool DecideDestElsewhereNew( bool bMustHaveVantage, optional bool bIsRepeat ) { return false; }
function bool DecideDestElsewhere(  optional bool bIsRepeat ) { return false; }
function bool DecideDestAnywhere( optional bool bMustLeaveCover ) { return false; }
function bool DecideDestAnywhereHasVantage() { return false; }
function bool DecideDestApproaching( Actor OtherActor, Vector OtherMovementDirection ) { return false; }
function bool DecideDestAnywhereHasPerfectCover() { return false; }
function bool DecideDestBetterCover( bool bMustHaveVantage, optional bool bIsRepeat ) { return false; }

//---------------------------------------------------------
//	BreakRelaxation
//---------------------------------------------------------
/*
function BreakRelaxation()
{
	bRelaxationBroken = true;
}
*/

//---------------------------------------------------------
//	MindSwitchedFleeGrenade
//---------------------------------------------------------
function MindSwitchedFleeGrenade( Pawn newEnemy, array<gbxExplosive> NewPerceivedGrenades )  
{
}

//---------------------------------------------------------
//	SetEnemy
//---------------------------------------------------------
function bool SetEnemy( Pawn newEnemy )
{
	if ( WGPawn == None )
		return false;

	// Sanity check: Check that the 'enemy' is not actually on your own team!
	if ( newEnemy != None && WGPawn.PawnTeam == newEnemy.PawnTeam )
	{
		log( "ERROR: Pawn "$WGPawn$" cannot set teammate "$newEnemy$" as his enemy!", 'ScriptWarning' );
		return false;
	}

	// Last check: If the "notarget" console command has been entered, don't set human players as enemies.
	if ( newEnemy != None && newEnemy.IsHumanControlled() )
	{
		if ( gbxPlayerController( newEnemy.Controller ).bNeverEnemy )
			return false;
	}

	// If the battle is just starting, set the pawn to fully fatigued.
	if ( Enemy == None && newEnemy != None )
	{
		LogSelective( "Setting enemy "$newEnemy$" for the first time, jogging fatigue." );
		JogFatigue( WGPawn.FatigueJog_Rotation );
	}

	if( newEnemy != Enemy )
	{
		Enemy = newEnemy;
		FiringController.SetTarget( newEnemy );
		// GBX:PAD: Make sure to update the ground speed if these guys change their enemy.  If they have an enemy, we
		// don't want them to limp, but if they don't, they should go back to limping.
		WGPawn.UpdateGroundSpeed();

		return true;
	}
	return false;
}

//---------------------------------------------------------
//	IsNavigating
//---------------------------------------------------------
function bool IsNavigating()
{
	return false;
}

//---------------------------------------------------------
//	SetDesiredDestination
//---------------------------------------------------------
function SetDesiredDestination( ActorLite CoverPoint, optional bool bMustLeaveCover )
{
}

//---------------------------------------------------------
//	FindFarthestDestinationFromVector
//---------------------------------------------------------
function ActorLite FindFarthestDestinationFromVector( vector loc, float radius, optional bool bRequireLOS, optional float cosFrustrumCull )
{
	return None;
}

//---------------------------------------------------------
//	NavigationPointStolen
//---------------------------------------------------------
event NavigationPointStolen(ActorLite NavPoint)
{
}

//---------------------------------------------------------
//	Timer
//---------------------------------------------------------
function Timer()
{
//	Log( Name $ "(" $ Pawn.Name $ ").Timer() ->"$ Level.TimeSeconds, 'Mind' );

	if(TimerRate != TimerInterval)
		SetTimer( TimerInterval, true );
	//SetTimer( TimerInterval, false );

	if (m_fDisableAI)
	{
		return;
	}
	
	if( Pawn == None )
	{
		return;
	}

	UpdateActualAttackLevels();

	// Deal with finished goals and empty queues.
	if( IsTargetDead() )
	{
		RemoveTargetFromQueue( Enemy );
		SetEnemy( None );
	}

	// Occasionally force a re-sort of the target and destination queues by setting their "needs sort" flags.
	if( Level.TimeSeconds > TimeLastTargetSort + ForceTargetSortInterval )
	{
		bTargetQueueNeedsSort = true;
	}

	if ((m_nTargetMode != TargetMode_Normal) && m_fChangeTarget)
	{
		if (m_aTargetPawn == None)
		{
			m_aTargetPawn = Spawn( class'gbxTargetPawn', self,, m_aTarget1.Location, m_aTarget1.Rotation );
			if (m_fTargetVisible)
			{
				m_aTargetPawn.Texture=Texture'Engine.S_PathNode';
				m_aTargetPawn.SetDrawType(DT_Sprite);
			}
		}

		if (m_aTargetPawn != None)
		{
			AddTarget( m_aTargetPawn );
//			SetEnemy( m_aTargetPawn );		
//			m_fChangeTarget = false;
		}
	}

	// Sort queues as necessary.
	if( bTargetQueueNeedsSort )
	{
		PrioritizeTargets();

		// Assign best Target.
		if( ndxEnemyInQueue >= 0 && ndxEnemyInQueue < TargetQueue.Length )
		{
			SetEnemy( TargetQueue[ ndxEnemyInQueue ].Target );
		}
		else
		{
			SetEnemy( None );
		}

		// Assign worst threat.
		if( TargetQueue.Length > 0 )
		{
			FindWorstThreats();
		}
		else
		{
			WorstThreats.Remove( 0, WorstThreats.Length );
		}

		AnnounceTargetPriorities();
	}
	
	if ( !bDontInterruptMe )
	{
		DecideState();

		if( !IsInState('FiringFromCover') )
		{
			DecidePosture();
			DecideWeaponAim();
			DecideMaxSpeed();
			DecideFacingPolicy();
		}

		FiringController.Think(); // SJP: This just passes through to the grenade firing controller right now.
	}
}

//---------------------------------------------------------
//	SetFacingPolicy
//---------------------------------------------------------
function bool SetFacingPolicy( EFacingPolicy policy )
{		
	if ( bDontInterruptMe )
		return false;

	// External classes shouldn't call this directly unless you're really confident you want to override. Use RequestFacingPolicy() instead.
	FacingPolicy = policy;

	return true;
}

//---------------------------------------------------------
//	ImplementFacingPolicy
//---------------------------------------------------------
function ImplementFacingPolicy()
{
	switch( FacingPolicy )
	{
		case FACE_NoChange:
			bRotateToDesired=false;
			break;

		case FACE_Destination:
			bRotateToDesired = true;
			Focus = None;
			break;

		case FACE_Vector:
			bRotateToDesired = true;
			FocalPoint = FacingVector;
			Focus = None;
			break;

		case FACE_Actor:
			bRotateToDesired = true;
			Focus = FacingActor;
			break;

		case FACE_Enemy:
			bRotateToDesired = true;
			Focus = Enemy;
			break;

		default:
			Warn( class $ ".ImplementFacingPolicy(): Unknown facing policy." );
			break;
	}
}

//---------------------------------------------------------
//	Tick
//---------------------------------------------------------
function Tick( float DeltaTime )
{
	local float RecoveryRate;
	local float	flTime, flPct;
	local Vector vecTarget;

	if (m_fDisableAI)
	{
		return;
	}
	
	if( Pawn == None )
	{
		return;
	}

	// Update our pawn.
	if( Pawn != WGPawn )
	{
		WGPawn = WargamePawn( Pawn );
	}
	if( WGPawn == None )
	{
		return;
	}

	if (m_nTargetMode == TargetMode_Sweep)
	{
		flTime = Level.TimeSeconds - m_flLastTargetTime;
		if (flTime > m_flTotalTargetTime)
		{
			m_nTargetDir *= -1;
			m_flLastTargetTime = Level.TimeSeconds;
			flTime = 0.0f;
		}
		
		if (m_nTargetDir > 0)
		{
			flPct = flTime / m_flTotalTargetTime;
		}
		else
		{
			flPct = (m_flTotalTargetTime - flTime) / m_flTotalTargetTime;
		}
		
		if ( m_aTargetPawn != None && m_aTarget1 != None && m_aTarget2 != None )
		{
			vecTarget.X = Lerp( flPct, m_aTarget1.Location.X, m_aTarget2.Location.X );
			vecTarget.Y = Lerp( flPct, m_aTarget1.Location.Y, m_aTarget2.Location.Y );
			vecTarget.Z = Lerp( flPct, m_aTarget1.Location.Z, m_aTarget2.Location.Z );
			
			m_aTargetPawn.SetLocation( vecTarget );
		}
	}
	
	// GBX:naj - TBD: Can I remove this code??
	if( FacingPolicy == FACE_Enemy && Enemy == None )
	{
		SetFacingPolicy( FACE_Destination );
	}
	
	ImplementFacingPolicy();

	RecoveryRate = GetFatigueRecoveryRate();
	DoFatigueRecovery( RecoveryRate, deltaTime );

	Super.Tick( deltaTime );
}

//---------------------------------------------------------
//	AddTarget
//---------------------------------------------------------
function AddTarget( gbxPawn newTarget, optional bool bDefinitelySeeTarget )
{
	local TargetInfo newTargetInfo;
	local int ndxTarget;
	local PerceptionPawnAddedTarget percep;

//	Log(name $ "(" $ Pawn.name $ ").AddTarget(" $ newTarget.name $")");

	if( newTarget == None || newTarget.SameTeamAs( WGPawn ) )
	{
		return;
	}

	if (m_nTargetMode != TargetMode_Normal)
	{
		if (m_fChangeTarget)
		{
			TargetQueue.Remove( 0, TargetQueue.Length );
			m_fChangeTarget = false;
		}
		else
		{
			return;
		}
	}

	newTargetInfo.Target = newTarget;

	// Is this target already in the queue?
	ndxTarget = FindTargetInQueue( newTarget );

	if( ndxTarget < 0 )
	{
		//Log( Name $ "(" $ Pawn.Name $ ").AddTarget( " $ newTarget $ " ) adding target.", 'Mind' );

		// Add the new target to the end of the list.
		TargetQueue.Length = TargetQueue.Length + 1;
		TargetQueue[ TargetQueue.Length - 1 ] = newTargetInfo;

		// TODO remove or reinstate.
//		bTargetQueueNeedsSort = true;

		// Alert my friends about this target.
		percep = new( None ) class'PerceptionPawnAddedTarget'; // GBX:naj - modified 3/11/04
		percep.Target = newTarget;

		WGPawn.PostGBXMessage( percep );
	}
}

//---------------------------------------------------------
//	RemoveTargetFromQueue
//---------------------------------------------------------
function RemoveTargetFromQueue( Pawn aTarget )
{
	local int ndxTarget;

	ndxTarget = FindTargetInQueue( aTarget );

	if( ndxTarget >= 0 )
	{
		TargetQueue.Remove( ndxTarget, 1 );
	}
}

//---------------------------------------------------------
//	ShouldMelee
//---------------------------------------------------------
function bool ShouldMelee()
{
	return false;
}

//---------------------------------------------------------
//	ShouldFrenzy
//---------------------------------------------------------
function bool ShouldFrenzy()
{
	return false;
}

//---------------------------------------------------------
//	ShouldAssault
//---------------------------------------------------------
function bool ShouldAssault()
{
	return false;
}

//---------------------------------------------------------
//	NotifyTargetOrder
//---------------------------------------------------------
function NotifyTargetOrder(Unit targetUnit)
{
	LogSelective( "NotifyTargeting." );

	// Think now, possibly ahead of schedule.
	Timer();
	
	FiringController.NotifyTargeting();
}

//---------------------------------------------------------
//	NotifyPrepareAssault
//---------------------------------------------------------
function NotifyPrepareAssault( bool bWaitToRush )
{
}

//---------------------------------------------------------
//	SeeGrenade
//---------------------------------------------------------
function SeeGrenade( gbxExplosive Grenade, bool msgFromGrenade )
{
}

//---------------------------------------------------------
//	FleeGrenadeAction
//---------------------------------------------------------
function FleeGrenadeAction()
{
}

//---------------------------------------------------------
//	SeeImpact
//---------------------------------------------------------
function SeeImpact( Pawn instigator, float impactSeverity, float distance )
{
	local int ndx;

	if(!Pawn.SameTeamAs( Instigator ))
	{
		ConsiderPossibleEnemy( instigator );

		// Note that this guy actually attacked me.
		ndx = FindTargetInQueue( Instigator );
		if( ndx >= 0 )
		{
			TargetQueue[ ndx ].ActualAttackLevel += 0.2;
			TargetQueue[ ndx ].LastContactTime = Level.TimeSeconds;
		}
	}
}

//---------------------------------------------------------
//	SeePawnDied
//---------------------------------------------------------
function SeePawnDied( Pawn Seen )
{
}

//---------------------------------------------------------
//	SeePawnHit
//---------------------------------------------------------
function SeePawnHit( Pawn Seen )
{
}

//---------------------------------------------------------
//	NotifyNearbyTrace
//---------------------------------------------------------
function NotifyNearbyTrace( Actor Other, vector TouchLocation, vector TouchNormal, vector End, vector Start, vector Extent, int TraceFlags )
{
	local int ndx;
	local vector NearestPoint;		// The nearest point to the pawn that this trace passed through.
	local float MissDistance;		// How far away from me the bullet passed.
	local float MissDistanceRelative;		// How far away from me the bullet passed, scaled and clamped to (0,1)
	local vector TraceNormal;

//	Log( Name $ "(" $ Pawn.Name $ ").NotifyNearbyTrace( " $ Other $ ", ... )", 'Mind' );

	// Ensure the shot came from an enemy.
	if( Pawn.SameTeamAs( Other.Instigator ))
	{
		return;
	}

	TraceNormal = Normal( Start - End );

	NearestPoint = End + TraceNormal * (( Pawn.Location - End ) dot TraceNormal );

	MissDistance = VSize( NearestPoint - Pawn.Location ) - Pawn.CollisionRadius;
	MissDistanceRelative =
		FClamp(
			MissDistance / ( gbxPawn( Pawn ).MyBulletListener.CollisionRadius - Pawn.CollisionRadius ),
			0.0, 1.0 );

	ConsiderPossibleEnemy( Other.Instigator );

	// Note that this guy actually attacked me.
	ndx = FindTargetInQueue( Other.Instigator );
	if( ndx >= 0 )
	{
		TargetQueue[ ndx ].ActualAttackLevel += 0.2;
		TargetQueue[ ndx ].LastContactTime = Level.TimeSeconds;
	}

	// Notify the unit that a bullet nearly missed me!
	if( WGPawn.MyUnit != None && UnitControllerAI( WGPawn.MyUnit.MyUnitController ) != None )
	{
		UnitControllerAI( WGPawn.MyUnit.MyUnitController ).MemberSawNearbyBullet( Other.Instigator, MissDistanceRelative );
	}
}

function MaybePlayReactToBulletsAnim( float MissDistanceRelative )
{
}

//---------------------------------------------------------
//	FaceAwayFromWalls
//---------------------------------------------------------
function FaceAwayFromWalls()
{
}

//---------------------------------------------------------
//	FaceTowardWalls
//---------------------------------------------------------
function FaceTowardWalls()
{
}

//---------------------------------------------------------
//	GrenadesOKAtThisRange
//---------------------------------------------------------
function bool GrenadesOKAtThisRange( float Dist )
{
	return false;
}

//---------------------------------------------------------
//	Approaching
//---------------------------------------------------------
// This function is called by tanks and other heavy vehicles that
// can potentially squash the Pawn if he doesn't move out the way.
function Approaching(Actor Other, Vector OtherMovementDirection)
{
}

/////////////////////////////////////////////////////////////////////////
// States
/////////////////////////////////////////////////////////////////////////

auto state Relaxed
{
	//---------------------------------------------------------
	//	BeginState (Relaxed)
	//---------------------------------------------------------
	function BeginState()
	{
		if ( Pawn != None )
		{
			Super.BeginState();
		}
		
		SetFlagValue( IveBeenFlanked, false );
	}

	//---------------------------------------------------------
	//	DecideWeaponAim (Relaxed)
	//---------------------------------------------------------
	function DecideWeaponAim()
	{
		// GBX:PAD: Ensure that WGPawn exists since otherwise it dumps a bunch of accessed none messages in the log files.
		if (WGPawn == None)
		{
			return;
		}
		
		// When transitioning from combat to relaxed mode, look nervous for the first 15 seconds or so.
		WGPawn.SetWeaponAimedState( WAS_CombatRelaxed );		
	}

	//---------------------------------------------------------
	//	DecideMaxSpeed (Relaxed)
	//---------------------------------------------------------
	function DecideMaxSpeed()
	{
		// GBX:PAD: Ensure that WGPawn exists since otherwise it dumps a bunch of accessed none messages in the log files.
		if (WGPawn == None)
		{
			return;
		}
		WGPawn.SetMaxAllowedSpeed( SL_Running );
	}

	//---------------------------------------------------------
	//	DecidePosture (Relaxed)
	//---------------------------------------------------------
	function DecidePosture()
	{
	}

	//---------------------------------------------------------
	//	DecideFacingPolicy (Relaxed)
	//---------------------------------------------------------
	function DecideFacingPolicy()
	{
	}

	//---------------------------------------------------------
	//	RequestFacingPolicy (Relaxed)
	//---------------------------------------------------------
	function bool RequestFacingPolicy( EFacingPolicy policy )
	{
		// Deny FP requests in this state.
		return false;
	}

	//---------------------------------------------------------
	//	IsStateSticky (Relaxed)
	//---------------------------------------------------------
	function bool IsStateSticky()
	{
		return false;
	}

	//---------------------------------------------------------
	//	ManeuverComplete (Relaxed)
	//---------------------------------------------------------
	function ManeuverComplete()
	{
	}

	//---------------------------------------------------------
	//	DecideState (Relaxed)
	//---------------------------------------------------------
	function DecideState()
	{
		if( IsStateSticky() )
		{
			return;
		}

		if( IsInCombat() )
		{
			GotoState( 'InCombat' );			// Warning: Do not put any new code after this GotoState().
		}
	}
	
	//---------------------------------------------------------
	//	NotifyFormationCenterChange (Relaxed)
	//---------------------------------------------------------
	function NotifyFormationCenterChange()
	{
	}
}

//=========================================================
//	State InCombat
//=========================================================
state InCombat
{
	// In this state, we're trying to get under cover as quickly as possible.
	// Later, if we have a target we'll try to attack the target from cover.

	//---------------------------------------------------------
	//	BeginState (InCombat)
	//---------------------------------------------------------
	function BeginState()
	{
		if ( WGPawn.MyUnit == None )
		{
			log( "******** ERROR: ("$Self.Name$") Pawn "$WGPawn.Name$" has not been assigned a unit!" );
		}

		Global.BeginState();
		LastLookedForCoverTime = Level.TimeSeconds + ForceLookForCover;

		DecideFacingPolicy();	// GBX:naj - added 2/9/04
	}

	//---------------------------------------------------------
	//	EndState (InCombat)
	//---------------------------------------------------------
	function EndState()
	{
		Global.EndState();
	}

	//---------------------------------------------------------
	//	DecideWeaponAim (InCombat)
	//---------------------------------------------------------
	function DecideWeaponAim()
	{
		// GBX:naj - let the FiringController decide this.		
	}

	//---------------------------------------------------------
	//	DecideMaxSpeed (InCombat)
	//---------------------------------------------------------
	function DecideMaxSpeed()
	{
		// TBD: If I have been ordered to fall in,
		// check if I am so far away from the super unit that I should sprint
		// to keep up.
		if ( WGPawn.MyUnit.bAttachedToSuperUnit )
		{
			if ( WGPawn.MyUnit.IsTooFarFromSuperUnit( WGPawn.Location ) )
			{
				LogSelective( "DecideMaxSpeed: Too far from super-unit." );
				WGPawn.SetMaxAllowedSpeed( SL_Sprinting );
			}
		}
		else
		{
			WGPawn.SetMaxAllowedSpeed( SL_Running );
		}
	}

	//---------------------------------------------------------
	//	NotifyFormationCenterChange (InCombat)
	//---------------------------------------------------------
	function NotifyFormationCenterChange()
	{
	}

	//---------------------------------------------------------
	//	NotifyTargetFailure (InCombat)
	//---------------------------------------------------------
	function NotifyTargetFailure( Pawn Target, optional ETargetFailure FailCode, optional gbxPawn TheBlocker )
	{
	}

	//---------------------------------------------------------
	//	DecidePosture (InCombat)
	//---------------------------------------------------------
	function DecidePosture()
	{		
	}

	//---------------------------------------------------------
	//	DecideFacingPolicy (InCombat)
	//---------------------------------------------------------
	function DecideFacingPolicy()
	{
		// Let the FiringController decide facing policy in this state.
	}

	//---------------------------------------------------------
	//	CoverPointStolen (InCombat)
	//---------------------------------------------------------
	event CoverPointStolen(ActorLite NavPoint)
	{
	}
	
	//---------------------------------------------------------
	//	NotifyTakeHit (InCombat)
	//---------------------------------------------------------
	// When shot and not currently moving to a destination, by god, get a new destination.
	function NotifyTakeHit(pawn InstigatedBy, vector HitLocation, int Damage, class<DamageType> damageType, vector Momentum)
	{
		Global.NotifyTakeHit( InstigatedBy, HitLocation, Damage, damageType, Momentum );
	}

	//---------------------------------------------------------
	//	TestForReverseCornerMount (InCombat)
	//---------------------------------------------------------
	function bool TestForReverseCornerMount( out Vector FiringLocation )
	{
		return false;
	}

	//---------------------------------------------------------
	//	SetDesiredDestination (InCombat)
	//---------------------------------------------------------
	function SetDesiredDestination( ActorLite CoverPoint, optional bool bMustLeaveCover )
	{
	}

	//---------------------------------------------------------
	//	RequestFacingPolicy (InCombat)
	//---------------------------------------------------------
	function bool RequestFacingPolicy( EFacingPolicy policy )
	{
		// TEST: ALLOW THE FC TO DETERMINE FACING POLICY.
		return Global.RequestFacingPolicy( policy );
		// Deny FP requests in this state.
		//return false;
	}

	//---------------------------------------------------------
	//	SetEnemy (InCombat)
	//---------------------------------------------------------
	function bool SetEnemy( Pawn newEnemy )
	{
		// GBX:naj - WARNING! This function is a ticking time bomb.  It returns a bool but contains a GotoState().
		local bool bChanged;
		bChanged = Global.SetEnemy( newEnemy );

		return bChanged;
	}

	//---------------------------------------------------------
	//	ManeuverComplete (InCombat)
	//---------------------------------------------------------
	function ManeuverComplete()
	{
		Global.ManeuverComplete();

		LogSelective( "ManeuverComplete().  Considering going into FFC." );
	}

	//---------------------------------------------------------
	//	DecideState (InCombat)
	//---------------------------------------------------------
	function DecideState()
	{
		if( IsStateSticky() )
		{
			return;
		}

		if( !IsInCombat() )
		{
			//LastSawCombatTime = Level.TimeSeconds;
			GotoState( 'Relaxed' );
		}
	}

	//---------------------------------------------------------
	//	Timer (InCombat)
	//---------------------------------------------------------
	function Timer()
	{
		Global.Timer();
	}	
}

state FiringFromCover
{
	function DecideState() {}
	function RequestStopFiringFromCover() {}
	function LeaveFiringFromCover( name newState, optional ActorLite NewDestination ) {}
	function NotifyTargetFailure( Pawn Target, optional ETargetFailure FailCode, optional gbxPawn TheBlocker ) {}
	function bool CoverNoLongerValid() { return false; }

	function Timer()
	{
		Global.Timer();
	}
}

/// MANEUVER RELATED ///////////////////////////////////////////////////

//---------------------------------------------------------
//	IsAtDesiredDestination
//---------------------------------------------------------
/*
function bool IsAtDesiredDestination()
{
	return true;
}
*/

//---------------------------------------------------------
//	IsCloseToCoverPoint
//---------------------------------------------------------
function bool IsCloseToCoverPoint()
{
	return true;
}

//---------------------------------------------------------
//	VantagePointStolen
//---------------------------------------------------------
event VantagePointStolen(ActorLite NavPoint)
{
}
/*
//---------------------------------------------------------
//	RequestPawnToStand
//---------------------------------------------------------
function RequestPawnToStand()
{
}

//---------------------------------------------------------
//	RequestPawnToCrouch
//---------------------------------------------------------
function RequestPawnToCrouch()
{
}
*/
//---------------------------------------------------------
//	FindCoverFromGrenade
//---------------------------------------------------------
function FindCoverFromGrenade( int iGrenade, optional bool bForcePanic )
{
}

//---------------------------------------------------------
//	TossBackGrenade
//---------------------------------------------------------
function TossBackGrenade( int iGrenade, vector returnVector, optional vector faceVector )
{
}

//---------------------------------------------------------
//	GrenadeTossFromGroundCallBack
//---------------------------------------------------------
function GrenadeTossFromGroundCallBack()
{
}

//---------------------------------------------------------
//	PickupGrenadeFromGroundCallBack
//---------------------------------------------------------
function PickupGrenadeFromGroundCallBack()
{
}

//---------------------------------------------------------
//	IsGrenadeDangerous
//---------------------------------------------------------
function bool IsGrenadeDangerous( gbxExplosive Grenade )
{
	return false;
}

//---------------------------------------------------------
//	MostDangerousGrenadeIndex
//---------------------------------------------------------
function int MostDangerousGrenadeIndex()
{
	return -1;
}

//---------------------------------------------------------
//	CanCrewTurret
//---------------------------------------------------------
function bool CanCrewTurret( TurretWeapon TheTurret )
{
	return false;
}

//---------------------------------------------------------
//	NotifyPawnIsShooting
//---------------------------------------------------------
function NotifyPawnIsShooting()
{
	// Clear the target-failure information, because clearly nothing is hindering our shot.
	TimeLastBlockedByFriendly = 0.0;
	TimeLastNoHadVantage = 0.0;
	BlockingFriendly = None;
}

//=========================================================
// Default Properties
//=========================================================
defaultproperties
{
	MyLogSelectName="STATICMIND"
	bHidden=true

	bIsPlayer=true
	TimerInterval=0.5

	NavigationControllerClass=None
	FiringControllerClass=class'FiringControllerScarecrow'
}
class StaticMindLethal extends StaticMind;

//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
	MyLogSelectName="STATICMINDLETHAL"
	FiringControllerClass=class'FiringControllerScarecrowLethal'
}class TankController extends gbxAIController
	abstract
	native;

var()	Tank		MyTank;

// navigation stuff...
var		float		TickTime;
var()	bool		bIsNavigating;
var()	ActorLite	aDestination;		// goal destination while navigating
var()	bool    	bIsNavPointSet;		// have we determined the navitation destination and/or navigation path yet?
var()	ActorLite	NavPathNode;		// current PathNode actor in the navigation path
var()	ActorLite	MyGoalNavPoint;		// where the tank is heading towards when navigating (so other tanks will know about it)
var()	bool		bCheckForPawnsInTheWay;
var		float		fCheckPawnsInTheWayTime;  // the next time we should check to see if we are about to run over Pawns
var()	bool		bIsRotating;
var()	bool		bRotateToFaceEnemy;	// set to true when the tank should constantly rotate to keep front towards enemy
var()	Actor		EnemyRotateToFace;
var()	bool		bIsPlayerMounting;
var()	float		RotateToFaceDistance;	// target must be closer than this distance to keep rotating front towards enemy
var()	float		fLastRotateToFaceTraceTime;
var()	float		fRotateToFaceHaltTime;	// keep setting the Throttle to zero until this time has passed
var()	float		fRotateToFaceCheckTime;	// time when we should check if we need to stop and rotate to face enemy

var()	bool		bNoEnemies;			// set to true if you don't want the tank shooting at enemies
var()	bool		bNoTargetPlayer;	// set to true to target anything but the player
var()	bool		bPauseMovement;			// set to true if the tank has an enemy and it should pause to fire at enemy
var()	float		fPauseMovementCheckTime;	// the next time when we should check if we should pause
var()	bool		bDontPause;				// if set, don't stop moving while on the way to a destination (i.e. to face an enemy)

// stuff from Mind...
var()	float		TimerInterval;
var()	float		CombatRadius_Deadlock;

// automatic corner point generation stuff...
var()	bool		bNeedsToDropCornerPoints;
var()	float		CornerPointDropTime;

// state stuff...
var()	float	SightRadiusWithCommander;
var()	float	SightRadiusWithoutCommander;
var()	float	HearingThresholdWithCommander;  // this gets squared in UnController::CanHear()
var()	float	HearingThresholdWithoutCommander;  // this gets squared in UnController::CanHear()
var()	float	AlertnessWithCommander;  // applies to hearing (range -1.0 to 1.0)
var()	float	AlertnessWithoutCommander;  // applies to hearing (range -1.0 to 1.0)

var()	float	BestDestClampedMaxDistance;  	// clamped maximum distance for scoring NavPoints when assaulting unit
var()	float	BestDestScoreDistanceScalar;  	// how much to scale Distance score
var()	float	BestDestScoreVantageScalar;		// how much to scale Vantage on Assaulted Unit score
var()	float	BestDestScoreSuppressionScalar;	// how much to scale Suppression of Assaulted Unit score (if no vantage, can we at least suppress them?)
var()	float	BestDestScoreNearbyScalar;		// how much to scale Distance from tank's current location score

var()	bool	bIsInScriptedMode;
var()	bool	bKeepRotatingTowardsTarget;

// allow level designers to override the tank gun controller values for these...
var() bool		bTargetForgetTimeOverride;
var() float		TargetForgetTime;


native function ActorLite TankFindPathToward(ActorLite anActor, optional bool bWeightDetours);
native latent function TankMoveToward(ActorLite NewTarget, optional float DestinationOffset );
native latent function TankFinishRotation();
native function ActorLite GetNearestTankFriendlyNavpoint( ActorLite FormC );
native function ActorLite GetBestTankDestination(vector Location, float IdealDistance, optional float MaxDistance);


function PostNetBeginPlay()
{
	local float ThinkStart;

	Super.PostNetBeginPlay();

	Level.MessageManager.AddListener( Self );

	TimerInterval = Level.AIMaxThinkInterval;
	ThinkStart = 1 + Level.AIGetNextThinkStart();

	log( Name $ ".PostNetBeginPlay() - Thinking will be delayed " $ ThinkStart $ " sec.", 'Tank' );

	SetTimer( ThinkStart, true );
}

function Possess(Pawn aPawn)
{
	local int index;
	local vector Offset;
	local rotator CP_Rot;
	local vector RotX, RotY, RotZ;

	Super.Possess(aPawn);

	MyTank = Tank( aPawn );

	if (MyTank == None)
	{
		Log(name $ ".Possess() - WARNING! TankController's Pawn is NOT a Tank!!!");
	}

	// Lock position to the pawn's position
	SetLocation( aPawn.Location );
	SetBase( aPawn );

	// the tank is its own driver (needed because some code checks if there's no driver)
	MyTank.Driver = MyTank;

	// Tanks need 360 degrees of peripheral vision since gun "controllers" aren't
	// derived from the Controller class (and thus if the turret is rotated to face
	// the rear of the tank, the tank won't be able to "see" something at its rear)
	MyTank.PeripheralVision = -1.0;

	// always use the "With Commander" settings since some tanks are spawned without commanders due to memory contraints
	MyTank.SightRadius = SightRadiusWithCommander;
	MyTank.HearingThreshold = HearingThresholdWithCommander;
	MyTank.Alertness = AlertnessWithCommander;

	TickTime = 0.0f;
	bIsNavigating = false;
	bIsRotating = false;
	bIsPlayerMounting = false;
	bCheckForPawnsInTheWay = true;
	MyGoalNavPoint = None;
	fLastRotateToFaceTraceTime = 0.0f;
	fRotateToFaceHaltTime = 0.0f;
	fPauseMovementCheckTime = Level.TimeSeconds;
	bDontPause = false;

	GetAxes(MyTank.Rotation,RotX,RotY,RotZ);

	for (index = 0; index < 8; index++)
	{
		Offset = MyTank.CornerPointOffset[index].X * RotX + MyTank.CornerPointOffset[index].Y * RotY + MyTank.CornerPointOffset[index].Z * RotZ;

		CP_Rot = MyTank.Rotation;
		CP_Rot.Yaw = (CP_Rot.Yaw + MyTank.CornerPointYawRotation[index]) & 65535;

		MyTank.MyCornerPoints[index] = Spawn(class'TankCornerPoint',,, MyTank.Location + Offset, CP_Rot);

		if (MyTank.CornerPointIsLeftCorner[index] != 0)
			MyTank.MyCornerPoints[index].IsLeftCorner = true;
		else
			MyTank.MyCornerPoints[index].IsLeftCorner = false;

		MyTank.MyCornerPoints[index].bHardAttach = true;
		MyTank.MyCornerPoints[index].SetBase(MyTank);

		MyTank.MyCornerPoints[index].bVehicleBlocked = false;
	}

	bNeedsToDropCornerPoints = true;
}

function UnPossess()
{
	local int index;

	MyTank.Driver = None;  // no one is driving this tank now

	MyGoalNavPoint = None;

	// remove any corner points...
	for (index = 0; index < 8; index++)
	{
		if (MyTank.MyCornerPoints[index] != None)
		{
			MyTank.MyCornerPoints[index].Destroy();
		}
	}

	Super.UnPossess();
}

function Timer()
{
	local int index;

	if (TimerRate != TimerInterval)
		SetTimer( TimerInterval, true );

	if (bIsInScriptedMode)
		return;  // don't do anything if under scripted control

	// update SightRadius, HearingThreshold and Alertness based on health of commander...
	if ((MyTank != None) && (MyTank.CommanderPawn != None) &&
		(MyTank.CommanderPawn.Health > 0) && (!MyTank.CommanderPawn.bHatchClosing))
	{
		MyTank.SightRadius = SightRadiusWithCommander;
		MyTank.HearingThreshold = HearingThresholdWithCommander;
		MyTank.Alertness = AlertnessWithCommander;
	}
	else if (MyTank.bSpawnCommander)  // if tank has a commander, but he's dead, or closed up inside the hatch, visibility is reduced
	{
		MyTank.SightRadius = SightRadiusWithoutCommander;
		MyTank.HearingThreshold = HearingThresholdWithoutCommander;
		MyTank.Alertness = AlertnessWithoutCommander;
	}

	if (bNeedsToDropCornerPoints)
	{
		if (bIsNavigating || bIsRotating)
		{
			CornerPointDropTime = Level.TimeSeconds + 2.0;
		}
		else if (CornerPointDropTime < Level.TimeSeconds)
		{
			bNeedsToDropCornerPoints = false;

			// enable any previously dropped corner points...
			for (index = 0; index < 8; index++)
			{
				if (MyTank.MyCornerPoints[index] != None)
				{
					SetCornerPointsCoverBits();

					MyTank.MyCornerPoints[index].bVehicleBlocked = false;
				}
			}

			AddCornerPointsToNavPointCaches();
		}
	}
}

function AddCornerPointsToNavPointCaches()
{
	local UnitController UC;
	local int index, my_index;
	local vector FC_Loc;  // formation center location
	local float distance;
	local bool bVisible;

	// loop through all UnitController actors and add this tanks TankCornerPoints to the cache...
	ForEach DynamicActors(class'UnitController', UC)
	{
		if ((UC.MyUnit != None) && (UC.MyUnit.FormationCenter != None))
		{
			for (my_index = 0; my_index < 8; my_index++)
			{
				FC_Loc = GetLocation(UC.MyUnit.FormationCenter);

				if (MyTank.MyCornerPoints[my_index] != None)
				{
					distance = VSize(FC_Loc - MyTank.MyCornerPoints[my_index].Location);

					if (distance < UC.MyUnit.FormationRadius)
					{
						index = UC.FormationNavPointCache.Length;
						UC.FormationNavPointCache.Length = index + 1;

						bVisible = FastTrace(FC_Loc, MyTank.MyCornerPoints[my_index].Location);

						UC.FormationNavPointCache[index].NavPoint = MyTank.MyCornerPoints[my_index];
						UC.FormationNavPointCache[index].DistanceLinear = distance;
						UC.FormationNavPointCache[index].bCanSeeFormationCenter = bVisible;
					}
				}
			}
		}
	}
}

function SetCornerPointsCoverBits()
{
	local int index;
	local int Yaw;
	local int bits;

	for (index = 0; index < 8; index++)
	{
		if (MyTank.MyCornerPoints[index] != None)
		{
			// add the tank's current Yaw to the CornerPointYawRotation and add 180 degrees
			// (since CornerPoints point away from the wall that provides cover)...

			Yaw = MyTank.Rotation.Yaw & 65535;
			Yaw = (Yaw + MyTank.CornerPointYawRotation[index] + 32768) & 65535;

			if ((Yaw > 61440) || (Yaw <= 4096))
				bits = 128 + 1 + 2;  // sector 7, 0, and 1
			else if ((Yaw > 4096) && (Yaw <= 12288))
				bits = 1 + 2 + 4;  // sector 0, 1, and 2
			else if ((Yaw > 12288) && (Yaw <= 20480))
				bits = 2 + 4 + 8;  // sector 1, 2, and 3
			else if ((Yaw > 20480) && (Yaw <= 28672))
				bits = 4 + 8 + 16;  // sector 2, 3, and 4
			else if ((Yaw > 28672) && (Yaw <= 36864))
				bits = 8 + 16 + 32;  // sector 3, 4, and 5
			else if ((Yaw > 36864) && (Yaw <= 45056))
				bits = 16 + 32 + 64;  // sector 4, 5, and 6
			else if ((Yaw > 45056) && (Yaw <= 53248))
				bits = 32 + 64 + 128;  // sector 5, 6, and 7
			else
				bits = 64 + 128 + 1;  // sector 6, 7, and 0

			if (MyTank.CornerPointIsStandingCorner[index] != 0)
				MyTank.MyCornerPoints[index].SetCoverBits(0, bits, bits);
			else
				MyTank.MyCornerPoints[index].SetCoverBits(0, bits, 0);
		}
	}
}

function PawnDied(Pawn P)
{
	local PerceptionPawnDied percep;

	Log( name $ "(" $ Pawn.name $ ").PawnDied( " $ P.name $ " )", 'Tank' );

	// stop any tank movement...
	MyTank.Steering = 0.0f;
	MyTank.Throttle = 0.0f;
	MyTank.Rise = 0.0f;

	percep = new( None ) class'PerceptionPawnDied';
	percep.PawnDied = P;
	P.PostGBXMessage( percep );

/* TODO: QUESTION??? SHOULD AI SOLDIERS USE DEAD TANK CORNERPOINTS?  IF NOT, UNCOMMENT OUT THE FOLLOWING CODE...
	MyTank.RemoveCornerPointsFromNavPointCaches();

	// remove any corner points...
	for (i = 0; i < 8; i++)
	{
		if (MyTank.MyCornerPoints[i] != None)
		{
			MyTank.MyCornerPoints[i].Destroy();
		}
	}
*/

	// Pawn should leave unit.
	if (MyTank.MyUnit != None)
	{
		MyTank.MyUnit.RemoveMember( MyTank );
		MyTank.MyUnit = None;
	}

	Super.PawnDied( P );
}

function Destroyed()
{
	Log( name $ ".(TankController).Destroyed()", 'Tank' );

	// Pawn should leave unit.
	if (MyTank.MyUnit != None)
	{
		MyTank.MyUnit.RemoveMember( MyTank );
		MyTank.MyUnit = None;
	}

	Level.MessageManager.RemoveListener( Self );

	super.Destroyed();
}

//---------------------------------------------------------
//	ReceiveGBXMessage
//---------------------------------------------------------
// True == Message has been stored away for later use; caller should not delete it after calling this function.
// False == Message has *not* been stored away; caller may delete msg if necessary after calling this function.
function bool ReceiveGBXMessage( gbxMessage msg )
{
	if ( Pawn == None )
	{
		return false;
	}

//	Log( name $ "(" $ Pawn.name $ ").ReceiveGBXMessage( " $ msg.name $ " )", 'Tank' );

	if( msg.IsA( 'Perception' ))
	{
		Perception( msg ).AffectTank( Self );
	}

	return false;
}

function NotifyTakeHit(pawn InstigatedBy, vector HitLocation, int Damage, class<DamageType> damageType, vector Momentum)
{
	local PerceptionPawnHit percep;

	Super.NotifyTakeHit( InstigatedBy, HitLocation, Damage, damageType, Momentum );

	if (bIsInScriptedMode)
		return;  // don't do anything if under scripted control

	percep = new( None ) class'PerceptionPawnHit';
	percep.PawnHit = Pawn;
	Pawn.PostGBXMessage( percep );
}

function SeePawn( Pawn Seen )
{
	// override this in the derived classes
//	Log( name $ "(" $ Pawn.name $ ").SeePawn( " $ Seen.name $ " )", 'Tank' );
}

function SeePawnKilled( Pawn Seen, Pawn Killer )
{
	// override this in the derived classes
//	Log( name $ "(" $ Pawn.name $ ").SeePawnKilled( " $ Seen.name $ " )", 'Tank' );

	// Seeing your friends get killed.
}

function SeePawnHit( Pawn Seen )
{
	// override this in the derived classes
//	Log( name $ "(" $ Pawn.name $ ").SeePawnHit( " $ Seen.name $ " )", 'Tank' );
}

function HearNoise( float Loudness, Actor NoiseMaker )
{
	// override this in the derived classes
//	Log( name $ "(" $ Pawn.name $ ").HearNoise( " $ Loudness $ ", " $ NoiseMaker.name $ " )", 'Tank' );
}

function SeePlayer( Pawn Seen )
{
	// override this in the derived classes
//	Log( name $ "(" $ Pawn.name $ ").SeePlayer( " $ Seen.name $ " )", 'Tank' );
}

function SeeExplosion( Pawn Instigator )
{
	// override this in the derived classes
//	Log( name $ "(" $ Pawn.name $ ").SeeExplosion( " $ Seen.name $ " )", 'Tank' );

	// Seeing shit get blown up.
}


function ConsiderPossibleEnemy( Pawn possibleEnemy )
{
	// override this in the derived classes
//	Log( name $ "(" $ Pawn.name $ ").ConsiderPossibleEnemy( " $ possibleEnemy.name $ " )", 'Tank' );
}

function SetContactedTarget()
{
	// override this in the derived classes
//	Log( name $ ".SetContactedTarget() - an enemy was seen", 'Tank' );
}

event float GetTargetExposureToMe( Pawn aThreat )
{
	// override this in the derived classes
	return 0.0f;
}

function SeeEnemy()
{
	if (bIsInScriptedMode)
		return;  // don't do anything if under scripted control

	// we have a valid enemy
	if ((MyTank != None) && (MyTank.CommanderPawn != None))
		MyTank.CommanderPawn.SeeEnemy();
}

function ActorLite DecideDesiredDestination()
{
	local bool bIsFORMCTankFriendly;
	local bool bNavTeamCanUse;
	local ActorLite TankFriendlyFORMC;

	Log(name $ ".DecideDesiredDestination() - original FORMC = " $ MyTank.MyUnit.FormationCenter, 'Tank');

	bIsFORMCTankFriendly = false;
	bNavTeamCanUse = true;

	if (MyTank.MyUnit.FormationCenter.bIsNavigationPoint)
	{
		bIsFORMCTankFriendly = NavigationPoint(MyTank.MyUnit.FormationCenter).bTanksCanUse;
		if (NavigationPoint(MyTank.MyUnit.FormationCenter).TeamNavPoint != NAV_TeamAny)
		{
			if ((MyTank.PawnTeam == TEAM_US) &&
				(NavigationPoint(MyTank.MyUnit.FormationCenter).TeamNavPoint != NAV_TeamUS))
				bNavTeamCanUse = false;
			else if ((MyTank.PawnTeam == TEAM_German) &&
					(NavigationPoint(MyTank.MyUnit.FormationCenter).TeamNavPoint != NAV_TeamGerman))
				bNavTeamCanUse = false;
		}
	}
	else if (MyTank.MyUnit.FormationCenter.bIsNavigationPointLite)
	{
		bIsFORMCTankFriendly = NavigationPointLite(MyTank.MyUnit.FormationCenter).bTanksCanUse;
		if (NavigationPointLite(MyTank.MyUnit.FormationCenter).TeamNavPoint != NAVL_TeamAnyLite)
		{
			if ((MyTank.PawnTeam == TEAM_US) &&
				(NavigationPointLite(MyTank.MyUnit.FormationCenter).TeamNavPoint != NAVL_TeamUSLite))
				bNavTeamCanUse = false;
			else if ((MyTank.PawnTeam == TEAM_German) &&
					(NavigationPointLite(MyTank.MyUnit.FormationCenter).TeamNavPoint != NAVL_TeamGermanLite))
				bNavTeamCanUse = false;
		}
	}

	if (!bIsFORMCTankFriendly || !bNavTeamCanUse)
		TankFriendlyFORMC = GetNearestTankFriendlyNavpoint(MyTank.MyUnit.FormationCenter);
	else
		TankFriendlyFORMC = MyTank.MyUnit.FormationCenter;

	Log(name $ ".DecideDesiredDestination() - tank friendly FORMC = " $ TankFriendlyFORMC, 'Tank');

	return TankFriendlyFORMC;
}

function MoveToDestination(ActorLite NewDestination)
{
	local int index;

	if (NewDestination == None)
		return;

	aDestination = NewDestination;
	MyGoalNavPoint = aDestination;  // let other tanks know where this tank is headed

	bRotateToFaceEnemy = false;		// don't keep facing an enemy (since tank was ordered to move somewhere else)

	fCheckPawnsInTheWayTime = 0.0f;  // start checking if Pawns are in the way of the tank

	bIsNavPointSet = false;
	bIsNavigating = true;  // start moving towards desired destination

	// disable any previously dropped corner points...
	for (index = 0; index < 8; index++)
	{
		if (MyTank.MyCornerPoints[index] != None)
		{
			MyTank.MyCornerPoints[index].bVehicleBlocked = true;
			MyTank.MyCornerPoints[index].SetCoverBits(0, 0, 0);  // clear the cover bits
		}
	}

	MyTank.RemoveCornerPointsFromNavPointCaches();

	NotifyInfantryClaimingCornerPoints();

	bNeedsToDropCornerPoints = true;
}

function StopRotating()
{
	Log(name $ ".StopRotating() - called at Level.TimeSeconds = " $ Level.TimeSeconds, 'Tank');

	bIsRotating = false;	// stop rotating
	MyTank.Steering = 0.0f;
}

function StopNavigating()
{
	Log(name $ ".StopNavigating() - called at Level.TimeSeconds = " $ Level.TimeSeconds, 'Tank');

	bIsNavigating = false;

	MyTank.Steering = 0.0f;  // stop turning and moving
	MyTank.Throttle = 0.0f;

	MyTank.ClaimUnClaimNavPoints();  // claim any nearby navigation points
}

function NotifyFormationCenterChange()
{
	local ActorLite MyDest;

	MyDest = DecideDesiredDestination();

	Log(name $ ".NotifyFormationCenterChange() - MyDest = " $ MyDest, 'Tank');

	fRotateToFaceCheckTime = -1.0;  // don't keep rotating to face enemies when given a move order

	if (MyDest != None)
		MoveToDestination(MyDest);
}

function NotifyInfantryClaimingCornerPoints()
{
	local int index;
	local Pawn Claimant;

	for (index = 0; index < 8; index++)
	{
		if (MyTank.MyCornerPoints[index] != None)
		{
			Claimant = MyTank.MyCornerPoints[index].Claimant;

			if ((gbxPawn(Claimant) != None) && (Mind(Claimant.Controller) != None))
			{
				// formation center didn't really change, but this is an easy way to
				// cause them to pick a new destination from the (now modified) nav cache...
				Log(name $ ".NotifyInfantryClaimingCornerPoint() - telling " $ Mind(Claimant.Controller) $ " to move!...", 'Tank');
				Mind(Claimant.Controller).NotifyFormationCenterChange();
			}
		}
	}
}

function NotifyTargetOrder(Unit targetUnit)
{
	Log(name $ ".NotifyTargetOrder() - YOU FORGOT TO OVERRIDE THIS FUNCTION!!!");
}

function NotifyAssaultOrder(Unit targetUnit)
{
	Log(name $ ".NotifyAssaultOrder() - YOU FORGOT TO OVERRIDE THIS FUNCTION!!!");
}

function bool RotateTowardTarget(Actor Target, optional bool bOverrideNavCheck)
{
	local int index;

	// request that the tank rotate it's body towards a target...
//	Log(name $ "(" $ Pawn.name $ ").RotateTowardTarget(" $ Target.name $ ")", 'Tank');

	if (bIsNavigating && !bOverrideNavCheck)  // is the tank currently navigating towards a destination?
		return false;  // request denied

	if (Target == None)
		return false;  // just return if no target specified

	Focus = Target;

	if (!bIsRotating)
	{
		bIsRotating = true;

		// disable any previously dropped corner points...
		for (index = 0; index < 8; index++)
		{
			if (MyTank.MyCornerPoints[index] != None)
			{
				MyTank.MyCornerPoints[index].bVehicleBlocked = true;
				MyTank.MyCornerPoints[index].SetCoverBits(0, 0, 0);  // clear the cover bits
			}
		}

		MyTank.RemoveCornerPointsFromNavPointCaches();

		NotifyInfantryClaimingCornerPoints();

		bNeedsToDropCornerPoints = true;
	}

	return true;
}

function bool RotateTowardLocation(vector RotLocation, optional bool bOverrideNavCheck)
{
	local int index;

	// request that the tank rotate it's body towards a target...
//	Log(name $ "(" $ Pawn.name $ ").RotateTowardFocalPoint(" $ RotLocation $ ")", 'Tank');

	if (bIsNavigating && !bOverrideNavCheck)  // is the tank currently navigating towards a destination?
		return false;  // request denied

	Focus = None;
	FocalPoint = RotLocation;

	if (!bIsRotating)
	{
		bIsRotating = true;

		// disable any previously dropped corner points...
		for (index = 0; index < 8; index++)
		{
			if (MyTank.MyCornerPoints[index] != None)
			{
				MyTank.MyCornerPoints[index].bVehicleBlocked = true;
				MyTank.MyCornerPoints[index].SetCoverBits(0, 0, 0);  // clear the cover bits
			}
		}

		MyTank.RemoveCornerPointsFromNavPointCaches();

		NotifyInfantryClaimingCornerPoints();

		bNeedsToDropCornerPoints = true;
	}

	return true;
}

function Rotator GetMainGunWorldRotation()
{
	Log(name $ ".GetMainGunWorldRotation() - YOU FORGOT TO OVERRIDE THIS FUNCTION!!!");
	return rot(0,0,0);
}

function bool TankHasEnemy()
{
	Log(name $ ".TankHasEnemy() - YOU FORGOT TO OVERRIDE THIS FUNCTION!!!");
	return false;
}


auto state Idle
{
Begin:
	// do nothing
}


state Scripted
{
Begin:
	Log(name $ ".state Scripted - Entering Scripted state", 'Tank');

	while (bIsInScriptedMode)
	{
		Sleep(0.1);

		if (bKeepRotatingTowardsTarget)
			bIsRotating = true;  // keep setting this to true to keep tracking target
	}

	Log(name $ ".state Scripted - Leaving Scripted state", 'Tank');

	GotoState('Idle');
}


state Dead
{
	// needed to override 'Dead' state in Engine\Classes\Controller.uc file...
Begin:
	Destroy();
}


defaultproperties
{
	bHidden=true
	bIsPlayer=true

	SightRadiusWithCommander=+09000.000000
	SightRadiusWithoutCommander=+04000.000000
	HearingThresholdWithCommander=+2100.0  // this gets squared in UnController::CanHear()
	HearingThresholdWithoutCommander=+1000.0  // this gets squared in UnController::CanHear()
	AlertnessWithCommander=0.0  // applies to hearing (range -1.0 to 1.0)
	AlertnessWithoutCommander=0.0  // applies to hearing (range -1.0 to 1.0)

	TimerInterval=0.5
	CombatRadius_Deadlock=2000.0

	RotateToFaceDistance=4000.0
	bNoEnemies=false

	BestDestClampedMaxDistance=5000.0
	BestDestScoreDistanceScalar=5.0
	BestDestScoreVantageScalar=25.0
	BestDestScoreSuppressionScalar=5.0
	BestDestScoreNearbyScalar=10.0

	bIsInScriptedMode=false
	bKeepRotatingTowardsTarget=false
}

class TankControllerGerman extends TankController
	abstract;

var()	float	ThinkIntervalMin;
var()	float	ThinkIntervalMax;
var()	float	ThinkInterval;

// misc. state variables
var()	bool	bEnemiesRecentlyVisible;
var()	gbxPawn HuntingEnemy;
var()	vector	HuntingEnemyLastKnownLocation;
var()	vector	HuntingEnemyFirstHiddenLocation;
var()	bool	bIsHardTarget;
var()	ActorLite BestNavPoint;

var()	bool	bIsLookingForEnemy;
var()	float	LookingForEnemyStartTime;
var()	float	LookingForEnemyTimeout;
var()	float	LookingForEnemyRotateYawMax;	// how many degrees do we rotate the turret back and forth when 'Hunting'?
var()	float	GrenadePlantedRotateYawMax;		// how many degrees do we rotate the turret back and forth when grenade planted?
var()	bool	bHasStartedRotating;
var()	bool	bIsRotationComplete;
var()	int		CenteredYawRotation;	// Yaw of rotation when at centered position
var()	int		RotationYawDelta;
var()	bool	bIsRotatingToTheLeft;
var		rotator	TempRot;
var()	vector	TargetAimLocation;		// for rotating turret/body left and right
var()	bool	bIsPausing;
var()	float	PauseTime;
var()	bool	bIsResettingTurret;
var()	bool	bTickDisabled;
var()	bool	bWasCommanderAlive;
var()	int		PreviousTankHealth;
var()	float	PanickedStopTime;		// time when switching from Panicked state to Befuddled
var()	float	PanickedSteering;
var()	float	OriginalMaxThrust;
var()	float	PanickedDurationMin;
var()	float	PanickedDurationDelta;
var()	float	BefuddledEndTime;
var()	float	BefuddledDuration;


function Timer()
{
	// this is needed because we want the 'state' Timer to call this function (which can be overridden by derrived classes)
	Super.Timer();
}

function MoveToDestination(ActorLite NewDestination)
{
	// German tanks that are nearly dead (1 unit of health) can't move...
	if ((MyTank.Health <= 1) && (!MyTank.bGermanTanksDontStopAtOneHealth))
		return;

	Super.MoveToDestination(NewDestination);
}

function bool RotateTowardTarget(Actor Target, optional bool bOverrideNavCheck)
{
	// German tanks that are nearly dead (1 unit of health) can't move...
	if ((MyTank.Health <= 1) && (!MyTank.bGermanTanksDontStopAtOneHealth))
		return false;

	return Super.RotateTowardTarget(Target);
}

function bool RotateTowardLocation(vector RotLocation, optional bool bOverrideNavCheck)
{
	// German tanks that are nearly dead (1 unit of health) can't move...
	if ((MyTank.Health <= 1) && (!MyTank.bGermanTanksDontStopAtOneHealth))
		return false;

	return Super.RotateTowardLocation(RotLocation);
}

function bool EnemiesAreRecentlyVisible()
{
	// override this function in the derived classes
	Log(name $ ".EnemiesAreRecentlyVisible() - YOU FORGOT TO OVERRIDE THIS FUNCTION!!!");
	return false;
}

function bool NoEnemiesVisibleForAWhile()
{
	// override this function in the derived classes
	Log(name $ ".NoEnemiesVisibleForAWhile() - YOU FORGOT TO OVERRIDE THIS FUNCTION!!!");
	return true;
}

function gbxPawn GetHuntingEnemy(out vector LastKnownLocation, out vector FirstHiddenLocation)
{
	// override this function in the derived classes
	Log(name $ ".GetHuntingEnemy() - YOU FORGOT TO OVERRIDE THIS FUNCTION!!!");
	return None;
}

function DecideState()
{
	// Intentionally blank in global.
}

function ResetTurret(float DeltaTime)
{
	// override this function in the derived classes
	Log(name $ ".ResetTurret() - YOU FORGOT TO OVERRIDE THIS FUNCTION!!!");
}

function HandleTrackingTarget(float DeltaTime)
{
	// override this function in the derived classes
	Log(name $ ".HandleTrackingTarget() - YOU FORGOT TO OVERRIDE THIS FUNCTION!!!");
}

function GrenadeHasBeenPlanted(Pawn GrenadePlanter)
{
	Log(name $ ".GrenadeHasBeenPlanted() - Grenade was planted by " $ GrenadePlanter.name, 'Tank');

	bTickDisabled = true;  // disable Tick() function until Sleep() in GrenadePlanted state is done

	GotoState('GrenadePlanted');
}

function HandleGrenadePlanted(float DeltaTime)
{
	// override this function in the derived classes
	Log(name $ ".HandleGrenadePlanted() - YOU FORGOT TO OVERRIDE THIS FUNCTION!!!");
}

function bool CheckIfCommanderDied()
{
	if ((MyTank != None) && (MyTank.CommanderPawn != None))
	{
		if (bWasCommanderAlive)
		{
			if (MyTank.CommanderPawn.Health <= 0)
			{
				bWasCommanderAlive = false;
				return true;
			}

			bWasCommanderAlive = true;
		}
	}

	return false;
}

function bool CheckIfHealthDropped()
{
	if (MyTank != None)
	{
		// check if Health changed by 2 or more...
		if ((PreviousTankHealth > 0) && ((PreviousTankHealth - MyTank.Health) >= 2))
		{
			PreviousTankHealth = MyTank.Health;
			return true;
		}

		PreviousTankHealth = MyTank.Health;
	}

	return false;
}

function NotifyFormationCenterChange()
{
	// only allow formation center change orders in Idle, Combat, Hunting or Scripted state...
	if ((GetStateName() == 'Idle') ||
		(GetStateName() == 'Combat') ||
		(GetStateName() == 'Hunting') ||
		(GetStateName() == 'Scripted'))
	{
		Super.NotifyFormationCenterChange();

		if (GetStateName() == 'Hunting')
		{
			GotoState('Idle');
		}
	}
}


auto state Idle  // we are idle, tank commander exposes himself here...
{
	function SeeEnemy()
	{
		Global.SeeEnemy();
		GotoState('Combat');
		return;
	}

	function DecideState() 
	{
		local bool bCommanderDied, bHealthDropped;

		// you need to do both of these BEFORE checking the status so that if both happen at once, you don't
		// do one of them, then come back and later do the other one of them...
		bCommanderDied = CheckIfCommanderDied();
		bHealthDropped = CheckIfHealthDropped();

		if (bCommanderDied || bHealthDropped)
		{
			GotoState('Panicked');  // tank panics when commander killed or health drops rapidly
		}
	}

	function Timer()
	{
		Global.Timer();

		if (bIsInScriptedMode)
		{
			GotoState('Scripted');
			return;
		}

		if ((BefuddledEndTime > 0.0) && (BefuddledEndTime < Level.TimeSeconds))
		{
			bCheckForPawnsInTheWay = true;  // check for Pawns in the way
			MyTank.bCrushFriendlyPawns = false;  // ...and don't run over friendlies
			BefuddledEndTime = 0.0f;
		}

		DecideState();
	}

Begin:
	Log(name $ ".state Idle - Begin: at Level.TimeSeconds = " $ Level.TimeSeconds, 'Tank');
}


state Combat  // we are in combat shooting at an enemy...
{
	function DecideState() 
	{
		local bool bCommanderDied, bHealthDropped;

		// you need to do both of these BEFORE checking the status so that if both happen at once, you don't
		// do one of them, then come back and later do the other one of them...
		bCommanderDied = CheckIfCommanderDied();
		bHealthDropped = CheckIfHealthDropped();

		if (bCommanderDied || bHealthDropped)
		{
			GotoState('Panicked');  // tank panics when commander killed or health drops rapidly
		}

		// have we not seen any enemies for a while?...
		bEnemiesRecentlyVisible = EnemiesAreRecentlyVisible();

		if (bEnemiesRecentlyVisible)
		{
			// let tank commander know that there are still enemies around...
			SeeEnemy();
		}
		else
		{
			// if any enemies are being ignored, get the one we should hunt...
			HuntingEnemy = GetHuntingEnemy(HuntingEnemyLastKnownLocation, HuntingEnemyFirstHiddenLocation);

			Log(name $ ".state Combat - No recently visible enemies, HuntingEnemy = " $ HuntingEnemy, 'Tank');

			if ( HuntingEnemy != None )
			{
				GotoState( 'Hunting' );
				return;
			}
			else
			{
				GotoState( 'Idle' );
				return;
			}
		}
	}

	function Timer()
	{
		Global.Timer();

		if (bIsInScriptedMode)
		{
			GotoState('Scripted');
			return;
		}

		if ((BefuddledEndTime > 0.0) && (BefuddledEndTime < Level.TimeSeconds))
		{
			bCheckForPawnsInTheWay = true;  // check for Pawns in the way
			MyTank.bCrushFriendlyPawns = false;  // ...and don't run over friendlies
			BefuddledEndTime = 0.0f;
		}

		DecideState();
	}

Begin:
	Log(name $ ".state Combat - Begin: at Level.TimeSeconds = " $ Level.TimeSeconds, 'Tank');
}


state Hunting  // we are hunting an enemy...
{
	function Tick(float deltaTime)
	{
		Super.Tick(deltaTime);

		if ( bIsNavigating )
		{
			ResetTurret(deltaTime);
		}

		if ( bIsRotationComplete )
		{
			HandleTrackingTarget(deltaTime);  // rotate main gun or body to track a "target"
		}
	}

	function SetContactedTarget()
	{
		// a target has been seen
		Log(name $ ".state Hunting - SetContactedTarget()", 'Tank');

		if (bIsNavigating)		// stop moving (if still moving)
			StopNavigating();

		Global.SeeEnemy();
		GotoState('Combat');
		return;
	}

	function HandleLookingForEnemy()
	{
		// rotate the tank's body to face the direction the enemy disappeared in and
		// rotate the turret back and forth as though "looking for the enemy"...

		if ( !bIsRotating && !bHasStartedRotating)
		{
			bHasStartedRotating = true;
			bIsRotationComplete = false;
			RotateTowardLocation(HuntingEnemyFirstHiddenLocation);
		}

		if ( !bIsRotating && !bIsRotationComplete )
		{
			bIsRotationComplete = true;

			CenteredYawRotation = MyTank.Rotation.Yaw;

			if (FRand() < 0.5)
			{
				bIsRotatingToTheLeft = true;  // rotate left, then right
				RotationYawDelta = (CenteredYawRotation - (LookingForEnemyRotateYawMax * 65536.0 / 360.0)) & 65535;
			}
			else
			{
				bIsRotatingToTheLeft = false;  // rotate right, then left
				RotationYawDelta = (CenteredYawRotation + (LookingForEnemyRotateYawMax * 65536.0 / 360.0)) & 65535;
			}

			TempRot = MyTank.Rotation;
			TempRot.Yaw = RotationYawDelta;

			TargetAimLocation = MyTank.Location + Vector(TempRot) * 1000.0f;

			bIsPausing = false;  // not pausing yet
		}
	}

	function DecideState() 
	{
		local bool bCommanderDied, bHealthDropped;

		// you need to do both of these BEFORE checking the status so that if both happen at once, you don't
		// do one of them, then come back and later do the other one of them...
		bCommanderDied = CheckIfCommanderDied();
		bHealthDropped = CheckIfHealthDropped();

		if (bCommanderDied || bHealthDropped)
		{
			GotoState('Panicked');  // tank panics when commander killed or health drops rapidly
			return;
		}

		if ( bIsNavigating )
			return;

		if ( !bIsLookingForEnemy )
		{
			bIsLookingForEnemy = true;  // we are now looking for enemy

			LookingForEnemyStartTime = Level.TimeSeconds;
		}

		if ((LookingForEnemyStartTime + LookingForEnemyTimeout) < Level.TimeSeconds)
		{
			Log(name $ ".state Hunting - Looking for enemy timed out, going to Idle", 'Tank');

			GotoState( 'Idle' );  // timed out looking for enemy
			return;
		}
		else
		{
			HandleLookingForEnemy();
		}
	}

	function Timer()
	{
		Global.Timer();

		if (bIsInScriptedMode)
		{
			GotoState('Scripted');
			return;
		}
		if ((BefuddledEndTime > 0.0) && (BefuddledEndTime < Level.TimeSeconds))
		{
			bCheckForPawnsInTheWay = true;  // check for Pawns in the way
			MyTank.bCrushFriendlyPawns = false;  // ...and don't run over friendlies
			BefuddledEndTime = 0.0f;
		}

		// let tank commander know that there are still enemies around...
		SeeEnemy();

		DecideState();
	}

Begin:
	Log(name $ ".state Hunting - Begin: at Level.TimeSeconds = " $ Level.TimeSeconds, 'Tank');

	// find a tank friendly NavigationPoint near the HuntingEnemy's last known location...
	BestNavPoint = GetBestTankDestination(HuntingEnemyLastKnownLocation, 0.0f);

	if (BestNavPoint != None)
	{
		Log(name $ ".state Hunting - BestNavPoint = " $ BestNavPoint, 'Tank');

		bPauseMovement = false;
		bDontPause = false;

		MoveToDestination(BestNavPoint);

		bIsLookingForEnemy = false;  // not looking yet until reached destination
		bHasStartedRotating = false;  // haven't started rotating back and forth yet
		bIsRotationComplete = false;

		bIsResettingTurret = true;  // reset the turret while navigating
	}
	else
	{
		Log(name $ ".state Hunting - BestNavPoint = None, going to Idle", 'Tank');

		// can't get closer to the enemy, just go back to Idle state...
		GotoState( 'Idle' );
	}
}


state GrenadePlanted  // a grenade has been thrown in the tank...
{
	function Tick(float deltaTime)
	{
		Super.Tick(deltaTime);

		if (bTickDisabled)
			return;

		HandleGrenadePlanted(deltaTime);  // rotate main gun or body to track a "target"
	}

	function Timer()
	{
		Global.Timer();

		if (bIsInScriptedMode)
		{
			GotoState('Scripted');
			return;
		}

		if ((BefuddledEndTime > 0.0) && (BefuddledEndTime < Level.TimeSeconds))
		{
			bCheckForPawnsInTheWay = true;  // check for Pawns in the way
			MyTank.bCrushFriendlyPawns = false;  // ...and don't run over friendlies
			BefuddledEndTime = 0.0f;
		}

		// tell tank commander to go inside tank...
		SeeEnemy();
	}

Begin:
	Log(name $ ".state GrenadePlanted - Begin: at Level.TimeSeconds = " $ Level.TimeSeconds, 'Tank');

	bRotateToFaceEnemy = false;

	StopRotating();		// stop rotating
	StopNavigating();	// stop navigating

	Sleep(7.0);  // wait for planting grenade animation to finish

	CenteredYawRotation = GetMainGunWorldRotation().Yaw;

	if (FRand() < 0.5)
	{
		bIsRotatingToTheLeft = true;  // rotate left, then right
		RotationYawDelta = (CenteredYawRotation - (GrenadePlantedRotateYawMax * 65536.0 / 360.0)) & 65535;
	}
	else
	{
		bIsRotatingToTheLeft = false;  // rotate right, then left
		RotationYawDelta = (CenteredYawRotation + (GrenadePlantedRotateYawMax * 65536.0 / 360.0)) & 65535;
	}

	TempRot = MyTank.Rotation;
	TempRot.Yaw = RotationYawDelta;

	TargetAimLocation = MyTank.Location + Vector(TempRot) * 1000.0f;

	bTickDisabled = false;
}


state Panicked  // tank is in panicked mode...
{
	function Timer()
	{
		Global.Timer();

		if (bIsInScriptedMode)
		{
			GotoState('Scripted');
			return;
		}

		// tell tank commander to go inside tank...
		SeeEnemy();

		if (PanickedStopTime < Level.TimeSeconds)
		{
			StopRotating();		// stop turning and moving
			StopNavigating();

			MyTank.MaxThrust = OriginalMaxThrust;

			BefuddledEndTime = Level.TimeSeconds + BefuddledDuration;
			bCheckForPawnsInTheWay = false;  // don't check for Pawns in the way
			MyTank.bCrushFriendlyPawns = true;

			GotoState('Idle');
			return;
		}
	}

Begin:
	Log(name $ ".state Panicked - Begin: at Level.TimeSeconds = " $ Level.TimeSeconds, 'Tank');

	bRotateToFaceEnemy = false;

	StopRotating();		// stop rotating
	StopNavigating();	// stop navigating

	PanickedStopTime = Level.TimeSeconds + PanickedDurationMin + (FRand() * PanickedDurationDelta);

	OriginalMaxThrust = MyTank.MaxThrust;

	MyTank.MaxThrust = OriginalMaxThrust * 0.5;

	PanickedSteering = 0.2 + (FRand() * 0.1);

	if (FRand() < 0.5)
		MyTank.Steering = PanickedSteering;
	else
		MyTank.Steering = -PanickedSteering;

	MyTank.Throttle = -1.0f;
}


defaultproperties
{
	ThinkIntervalMin=0.05
	ThinkIntervalMax=0.2

	LookingForEnemyTimeout=20.0			// how long to wait after hunting for enemy before going back to Idle state
	LookingForEnemyRotateYawMax=0.0		// this should be overridden in each German tank class
	GrenadePlantedRotateYawMax=0.0			// this should be overridden in each German tank class

	bWasCommanderAlive=true

	PreviousTankHealth=0  // not set yet
	PanickedDurationMin=4.0
	PanickedDurationDelta=1.0
	BefuddledEndTime=0.0
	BefuddledDuration=3.0  // how long to stay Befuddled after being in the Panicked state (in seconds)
}

class TankControllerUS extends TankController
	abstract;


defaultproperties
{
}

class TankGunController extends Actor
	notplaceable
	native;


var()	Tank			MyTank;
var()	TankController	MyTankController;

// stuff from Engine\Classes\Controller.uc
var()	Actor	Enemy;
var()	float	PeripheralVision;	// current peripheral vision setting
var()	float	PeripheralVisionWithCommander;	// cosine of +/- angle used for seeing enemies
var()	float	PeripheralVisionWithoutCommander;	// cosine of +/- angle used for seeing enemies

var()	float	TimerInterval;  // how often this Controller will "think"

// Perception ////////////////////////////////////////////////////////
var() float	TargetForgetDist;		// Under certain conditions, forget about a target if he's traveled this far since last we saw him.
var() float	TargetForgetTimeLong,
			TargetForgetTimeShort;		// Two timer variables representing the time that it takes to for
var() float	DistractionForgetfulness;	// The amount per think-tick to subtract a target's LastContactTime if I'm distracted by other enemies.

// stuff from FiringController...
var()	bool	bNoAccuracyAdjust;
var()	int		UnitSkillMod_Novice;		// Firing accuracy modifier tied to the novice skill level.
var()	int		UnitSkillMod_Interm;		// Firing accuracy modifier tied to the intermediate skill level.
var()	int		UnitSkillMod_Advanced;		// Firing accuracy modifier tied to the advanced skill level.
var()	int		UnitSkillMod_Veteran;		// Firing accuracy modifier tied to the veteran skill level.
var()	int		UnitSkillMod_Invincible;	// Firing accuracy modifier for U.S. squads.
var()	gbxPawn	BlockingFriendly;			// A friendly Pawn who is in the way of this Pawn's shot.
var()	vector	SeeLoc;						// Location on the target's body at which to shoot.
var const float	FFConeThresh;
var const float	FFSuperCloseRadius;
var()	float	FFBufferDist;

var()	bool	bDoesPurposefulMiss;		// US Tanks don't do purposeful miss with MainGun (on non-hard targets, i.e. infantry)
var()	float	BulletDoNoDamageRange;		// Enemies beyond this distance will take no damage from tank machine guns
var()	float	MainGunDoNoDamageRange;		// Enemies beyond this distance will take no damage from tank shells

// enemy targeting stuff...
struct native export TankTargetInfo
{
	var gbxPawn		Target;

	var byte		bIgnored;				// bool's are BAD for arrays of structs in UnrealScript!!!
	var float		TargetPriority;
	var float		ActualAttackLevel;		// How much is this target actually shooting at me?
	var float		DistractionLevel;		// How much is this target distracting me?
	var float		RelegationTime;
	var float		LastCSSTime;			// The last time this target was checked for CSS exposure.
	var float		LastEvaluationTime;		// The last time this target was evaluated at all.
	var float		LastContactTime;		// The last time I had contact with this target, either seeing it or being shot at by it.
	var vector		LastKnownLocation;
	var byte		bHasSetFirstHiddenLocation;
	var vector		FirstHiddenLocation;	// set as soon as Target becomes hidden (used with LastKnownLocation to get movement direction)

	var float		TargetDistance;
	var float		TargetExposureToMe;
	var float		MyExposureToTarget;
	var float		TargetViewRating;

	var float		TargetPriorityDistance;
	var float		TargetPriorityAttackLevel;
	var float		TargetPriorityWeaponRating;
	var float		TargetPriorityInAssignedUnit;
	var float		TargetPriorityAlreadyTargetted;
	var float		TargetPriorityHumanPlayer;
	var float		TargetPriorityTargetExposureToMe;
	var float		TargetPriorityMyExposureToTarget;
	var float		TargetPriorityViewRating;
	var float		TargetTotalWeight;

	var byte		bUseCannon;		// False (0) by default, if True (1) use cannon to fire at target (group of soldiers) CAN'T USE bool HERE!!! Stupid Unreal struct serialize shit
	var byte		bHasDonePurposefulMiss;
	var byte		bIsHardTarget;			// is this a Tank or other 'hard' target?
	var float		PurposefulMissTimeStarted;	// when the purposeful miss timing started (so we can check for max bonus extended)
	var float		PurposefulMissTimeExpires;	// when the purposeful miss timing will end (can be extended by bonus)
	var vector		PurposefulMissTimeRechargeLoc;  // last location when purposeful miss Expires was set
};

var(Target) array< TankTargetInfo > TargetQueue;
var(Target) bool bTargetQueueNeedsSort;
var(Target) int		ndxEnemyInQueue;		// The index of Enemy in TargetQueue, as of the last PrioritizeTargets call.

var(Target) float TimeLastTargetSort;
var(Target) float ForceTargetSortInterval;

var(Target) float TargetEvaluationIntervalFar;
var(Target) float TargetCSSIntervalMedium;
var(Target) float TargetRangeMedium;
var(Target) float TargetRangeFar;

var(Target) float TargetForgetTime;						// The time it takes for an AI character to forget about a target it hasn't seen or been shot at by.
var(Target) float MaxTargetRange;						// TODO probably should come from weapon.
var(Target) float TargetPriorityScalarDistance;
var(Target) float TargetPriorityScalarAttackLevel;
var(Target) float TargetPriorityScalarWeaponRating;
var(Target) float TargetPriorityScalarAlreadyTargetted;
var(Target) float TargetPriorityScalarTargetExposureToMe;
var(Target) float TargetPriorityScalarMyExposureToTarget;
var(Target) float TargetPriorityScalarInAssignedUnit;
var(Target) float TargetPriorityScalarHumanPlayer;
var(Target) float TargetPriorityScalarViewRating;
var(Target)	float TargetPriorityScalarInAimingDirection;
var(Target) float TargetPriorityScalarEnemyVehicle;

var(Target) float RelegationDuration;
var(Target) float AttackLevelDecay;
var(Target) float DistractionLevelDecay;

var(Target)	float NearbyInfantryTargetDistance;	// how close other Infantry Targets are to be considered "near by"

var(Target)	float TargetRelegateCheckTime;	// how long to wait before checking target again if we ignore them
var(Target) float MaxImpactDistance;

var(Target)	float fGunReactionTime;
var(Target)	float ReactionTimeMin;
var(Target) float ReactionTimeMax;
var(Target)	float ReactionTimeMinEasy;
var(Target) float ReactionTimeMaxEasy;
var(Target)	float ReactionTimeMinNormal;
var(Target) float ReactionTimeMaxNormal;
var(Target)	float ReactionTimeMinHard;
var(Target) float ReactionTimeMaxHard;
var(Target)	float ReactionTimeMinAuthentic;
var(Target) float ReactionTimeMaxAuthentic;

var(Target) float PurposefulMissTimeStart;	// how many seconds of purposeful miss time this gun controller starts with (for 'hard' targets)
var(Target) float PurposefulMissTimeBonus;	// how many additional seconds of purposeful miss time is given for targets moving around
var(Target) float PurposefulMissTimeMax;	// max amount of purposeful miss time give to any one target
var(Target) float PurposefulMissTimeStartEasy;
var(Target) float PurposefulMissTimeBonusEasy;
var(Target) float PurposefulMissTimeMaxEasy;
var(Target) float PurposefulMissTimeStartNormal;
var(Target) float PurposefulMissTimeBonusNormal;
var(Target) float PurposefulMissTimeMaxNormal;
var(Target) float PurposefulMissTimeStartHard;
var(Target) float PurposefulMissTimeBonusHard;
var(Target) float PurposefulMissTimeMaxHard;
var(Target) float PurposefulMissTimeStartAuthentic;
var(Target) float PurposefulMissTimeBonusAuthentic;
var(Target) float PurposefulMissTimeMaxAuthentic;

var(Target) float PurposefulMissRechargeDistance;


// threats...
var() array< TankTargetInfo > WorstThreats;
var() array< Vector > ThreatLocations;
const MAX_WORST_THREATS = 3;


native function PrioritizeTargets();
native function int FindTargetInQueue( Actor potentialTarget );
native function bool TankGunControllerCanSee( Rotator ControllerRotation, Pawn Other );
native function float GetTargetExposureToTankNative( Pawn Target );


function Possess(Tank aPawn, TankController aController)
{
	Log( name $ ".(TankGunController).Possess( " $ aPawn.name $ " " $ aController.name $ " )", 'Tank' );

	MyTank = aPawn;
	MyTankController = aController;

	if (Level.DifficultyLevel == DIFF_Easy)
	{
		Log(name $ ".Possess() - Using EASY skill settings...", 'Tank');
		ReactionTimeMin = ReactionTimeMinEasy;
		ReactionTimeMax = ReactionTimeMaxEasy;
		PurposefulMissTimeStart = PurposefulMissTimeStartEasy;
		PurposefulMissTimeBonus = PurposefulMissTimeBonusEasy;
		PurposefulMissTimeMax = PurposefulMissTimeMaxEasy;
	}
	else if (Level.DifficultyLevel == DIFF_Normal)
	{
		Log(name $ ".Possess() - Using NORMAL skill settings...", 'Tank');
		ReactionTimeMin = ReactionTimeMinNormal;
		ReactionTimeMax = ReactionTimeMaxNormal;
		PurposefulMissTimeStart = PurposefulMissTimeStartNormal;
		PurposefulMissTimeBonus = PurposefulMissTimeBonusNormal;
		PurposefulMissTimeMax = PurposefulMissTimeMaxNormal;
	}
	else if (Level.DifficultyLevel == DIFF_Hard)
	{
		Log(name $ ".Possess() - Using HARD skill settings...", 'Tank');
		ReactionTimeMin = ReactionTimeMinHard;
		ReactionTimeMax = ReactionTimeMaxHard;
		PurposefulMissTimeStart = PurposefulMissTimeStartHard;
		PurposefulMissTimeBonus = PurposefulMissTimeBonusHard;
		PurposefulMissTimeMax = PurposefulMissTimeMaxHard;
	}
	else if (Level.DifficultyLevel == DIFF_Authentic)
	{
		Log(name $ ".Possess() - Using AUTHENTIC skill settings...", 'Tank');
		ReactionTimeMin = ReactionTimeMinAuthentic;
		ReactionTimeMax = ReactionTimeMaxAuthentic;
		PurposefulMissTimeStart = PurposefulMissTimeStartAuthentic;
		PurposefulMissTimeBonus = PurposefulMissTimeBonusAuthentic;
		PurposefulMissTimeMax = PurposefulMissTimeMaxAuthentic;
	}

	SetTimer( TimerInterval, true );
}

function Timer()
{
	local int index;
	local float distance;

//	Log( name $ ".(TankGunController).Timer() - Level.TimeSeconds = " $ Level.TimeSeconds, 'Tank' );

	UpdateActualAttackLevels();

	// Deal with finished goals and empty queues.
	if ( (Enemy != None) && IsTargetDead() )
	{
		RemoveTargetFromQueue( Enemy );
		SetEnemy( None );
	}

	// Occasionally force a re-sort of the target and destination queues by setting their "needs sort" flags.
	if ( Level.TimeSeconds > TimeLastTargetSort + ForceTargetSortInterval )
	{
		bTargetQueueNeedsSort = true;
	}

	// Sort queues as necessary.
	if (( bTargetQueueNeedsSort ) && (!MyTankController.bIsInScriptedMode))
	{
		PrioritizeTargets();

		ReassignTargets();

		// Assign best Target.
		if ( ndxEnemyInQueue >= 0 && ndxEnemyInQueue < TargetQueue.Length )
		{
			SetEnemy( TargetQueue[ ndxEnemyInQueue ].Target );

			if ((TargetQueue[ndxEnemyInQueue].bIsHardTarget == 1) &&
				(TargetQueue[ndxEnemyInQueue].PurposefulMissTimeStarted == 0.0))
			{
				// initialize purposeful miss stuff...
				TargetQueue[ndxEnemyInQueue].PurposefulMissTimeStarted = Level.TimeSeconds;
				TargetQueue[ndxEnemyInQueue].PurposefulMissTimeExpires = Level.TimeSeconds + PurposefulMissTimeStart;
				TargetQueue[ndxEnemyInQueue].PurposefulMissTimeRechargeLoc = TargetQueue[ ndxEnemyInQueue ].Target.Location;
			}

			// make sure the tank controller knows about the enemy, and enemy is recently visible...
			if ((MyTankController != None) &&
				(TargetQueue[ ndxEnemyInQueue ].LastContactTime + TargetForgetTimeShort > Level.TimeSeconds))
			{
				MyTankController.SeeEnemy();
			}
		}
		else if (Enemy != None)
		{
			SetEnemy( None );
		}

		// Assign worst threat.
		if ( TargetQueue.Length > 0 )
		{
			FindWorstThreats();
		}
		else
		{
			WorstThreats.Remove( 0, WorstThreats.Length );
		}

		AnnounceTargetPriorities();
	}

	// check if any targets need the PurposefulMissExpires time extended...
	for (index = 0; index < TargetQueue.Length; index++)
	{
		if ((TargetQueue[index].bIsHardTarget == 1) &&
			(TargetQueue[index].PurposefulMissTimeStarted > 0.0) &&
			(TargetQueue[index].PurposefulMissTimeExpires < Level.TimeSeconds))
		{
			// is the possible new expire time less than the max allowed time?
			if ((TargetQueue[index].PurposefulMissTimeExpires + PurposefulMissTimeBonus) <=
				(TargetQueue[index].PurposefulMissTimeStarted + PurposefulMissTimeMax))
			{
				// check if target has moved far enough for a bonus...
				distance = VSize(TargetQueue[index].Target.Location - TargetQueue[index].PurposefulMissTimeRechargeLoc);
				if (distance > PurposefulMissRechargeDistance)
				{
					TargetQueue[index].PurposefulMissTimeExpires += PurposefulMissTimeBonus;
					TargetQueue[index].PurposefulMissTimeRechargeLoc = TargetQueue[index].Target.Location;
					Log(name $ ".Timer() - Giving Target = " $ TargetQueue[index].Target.name $ " additional purposefull miss time bonus of " $ PurposefulMissTimeBonus $ " seconds.", 'Tank');
					Log(name $ ".Timer() - new expire time = " $ TargetQueue[index].PurposefulMissTimeExpires $ "  purposefull miss duration = " $ TargetQueue[index].PurposefulMissTimeExpires - TargetQueue[index].PurposefulMissTimeStarted, 'Tank');
				}
			}
		}
	}
}

function bool ShouldTankPause()
{
	local UnitControllerAITank UCAITank;
	local float distance, min_distance;
	local vector HitLoc, HitNormal, VecStart, VecEnd, Extent;
	local Actor HitActor;

	if ((MyTankController != None) && MyTankController.bDontPause)
		return false;

	if ((Enemy != None) && (MyTank != None) && (MyTank.MyUnit != None) && (MyTank.MyUnit.MyUnitController != None))
	{
		UCAITank = UnitControllerAITank(MyTank.MyUnit.MyUnitController);

		// are we assaulting a unit?
		if ( MyTank.MyUnit.bAssaultingTargetUnit )
			min_distance = UCAITank.IdealAssaultDistance;
		else if ( TargetQueue[ ndxEnemyInQueue ].bIsHardTarget == 1 )
			min_distance = UCAITank.AssaultHardTargetDistance * 1.5f;
		else
			min_distance = UCAITank.AssaultSoftTargetDistance * 4.0f;

		// are we within the ideal assault distance from the enemy?
		distance = VSize(Enemy.Location - MyTank.Location);
		if ( distance <= min_distance )
		{
			// offset the starting positions up slightly so we don't collide with terrain...
			VecStart = MyTank.Location;
			VecStart.Z += MyTank.VehicleCollisionHeight * 0.5f;
			VecEnd = Enemy.Location;
			VecEnd.Z += Enemy.CollisionHeight * 0.5f;

			// use the Extent of the enemy (since Infantry guys are smaller and could be behind cover or between trees)
			Extent = Enemy.GetCollisionExtent() * 0.75;

			// can we clearly hit the enemy from where we are?
			HitActor = Trace( HitLoc, HitNormal, Enemy.Location, MyTank.Location, true, Extent,,,,, MyTank );

			if ( HitActor == Enemy )
			{
				return true;
			}
		}
	}

	return false;
}

function bool IsInCombat()
{
	return TargetQueue.Length > 0;
}

function bool IsValidEnemy( Pawn aPawn )
{
	local bool bIsValidEnemy;

	bIsValidEnemy = (
		aPawn != None &&
		aPawn.Health > 0 &&
		!MyTank.SameTeamAs( aPawn ) &&
		!( aPawn.Controller.IsA( 'WargamePlayerController') && WargamePlayerController( aPawn.Controller ).bNeverEnemy )
	);
//	Log(name $ ".IsValidEnemy( " $ aPawn $ " ) - returning " $ bIsValidEnemy, 'Tank');

	return bIsValidEnemy;
}

function ConsiderPossibleEnemy( Pawn possibleEnemy, bool bAddToOtherGunController )
{
//	Log( name $ ".(TankGunController-"$MyTank.name$").ConsiderPossibleEnemy( " $ possibleEnemy.name $ " )", 'Tank' );

	if( gbxPawn( possibleEnemy ) != None && IsValidEnemy( possibleEnemy ))
	{
		AddTarget( gbxPawn( possibleEnemy ));
	}
}

function NotifyTakeHit(Pawn InstigatedBy, vector HitLocation, int Damage, class<DamageType> damageType, vector Momentum)
{
	local int ndx;
//	Log( name $ ".(TankGunController-"$MyTank.name$").NotifyTakeHit( " $ InstigatedBy.name $ " " $ Damage $ " " $ damageType.name $ " )", 'Tank' );

	// Might need to resort targets to prioritize the guy who just shot me.
	bTargetQueueNeedsSort = true;

	ConsiderPossibleEnemy( InstigatedBy, true );

	// Note that this guy actually attacked me.
	ndx = FindTargetInQueue( InstigatedBy );
	if( ndx >= 0 )
	{
		TargetQueue[ ndx ].ActualAttackLevel += 1.0;
		TargetQueue[ ndx ].DistractionLevel = 1.0;
		TargetQueue[ ndx ].LastContactTime = Level.TimeSeconds;
		TargetQueue[ ndx ].LastKnownLocation = InstigatedBy.Location;
	}
}

function SeePawn( Pawn Seen )
{
//	Log( name $ ".(TankGunController-"$MyTank.name$").SeePawn( " $ Seen.name $ " )", 'Tank' );

	ConsiderPossibleEnemy( Seen, true );
}

function SeePawnKilled( Pawn Seen, Pawn Killer )
{
//	Log( name $ ".(TankGunController-"$MyTank.name$").SeePawnKilled( " $ Seen.name $ " )", 'Tank' );

	// Seeing your friends get killed.
	ConsiderPossibleEnemy( Killer, true );
}

function SeePawnHit( Pawn Seen )
{
//	Log( name $ ".(TankGunController-"$MyTank.name$").SeePawnHit( " $ Seen.name $ " )", 'Tank' );
}

function HearNoise( float Loudness, Actor NoiseMaker )
{
//	Log( name $ ".(TankGunController-"$MyTank.name$").HearNoise( " $ Loudness $ " " $ NoiseMaker.name $ " )", 'Tank' );

	if( NoiseMaker.IsA( 'Pawn' ))
	{
		// TODO do uncertainty.

		SeePawn( Pawn( NoiseMaker ));
	}
}

function SeePlayer( Pawn Seen )
{
//	Log( name $ ".(TankGunController-"$MyTank.name$").SeePlayer( " $ Seen.name $ " )", 'Tank' );

	SeePawn( Seen );
}

function SeeExplosion( Pawn Instigator )
{
	// override this in the derived classes
//	Log( name $ "(" $ Pawn.name $ ").SeeExplosion( " $ Seen.name $ " )", 'Tank' );

	// Seeing shit get blown up.
	ConsiderPossibleEnemy( Instigator, true );
}



function bool IsTargetDead()
{
	if (Pawn(Enemy) != None)
		return ((Enemy == None) || Pawn(Enemy).IsDead());
	else
		return (Enemy == None);
}

function bool SetEnemy( Actor newEnemy )
{
	if ( newEnemy != Enemy )
	{
		Enemy = newEnemy;
		return true;
	}

	return false;
}

function int GetNumberOfNearbyInfantryTargets(gbxPawn Target)
{
	local int i;
	local float distance;
	local int num_found;

	num_found = 0;

	for (i = 0; i < TargetQueue.Length; i++)
	{
		if ((TargetQueue[i].Target != Target) && (TargetQueue[i].Target.IsA('Infantry')))
		{
			distance = VSize(TargetQueue[i].Target.Location - Target.Location);

			if (distance <= NearbyInfantryTargetDistance)
			{
				num_found++;
			}
		}
	}

	return num_found;
}

event AdjustTargetPriority(int index)
{
	// Allow the UnrealScript class to adjust the priority of the Target AFTER all
	// the native code calculations are done.  This allows the script code to
	// adjust the priority up or down based on other factors that are specific to
	// each unique class of TankGunController.
}

function ReassignTargets()
{
	// Allow the UnrealScript class to reassign targets from one gun controller to
	// another gun controller on the same tank.  This allows specific targets to be
	// assigned to specific types of guns (machine guns vs. main gun cannon).
}

function AnnounceTargetPriorities()
{
	local int i;
	local UnitControllerAI UnitConAI;

	if ( MyTank.MyUnit != None )
	{
		UnitConAI = UnitControllerAI(MyTank.MyUnit.MyUnitController);
	}

	for( i = 0; i < TargetQueue.Length; ++i )
	{
		if ( UnitConAI != None )
		{
			UnitConAI.UnitMemberUpdatedTarget( TargetQueue[ i ].Target );
		}
	}
}

function AddTarget( gbxPawn newTarget )
{
	local TankTargetInfo newTargetInfo;
	local int ndxTarget;
	local PerceptionPawnAddedTarget percep;

//	Log( name $ ".(TankGunController-"$MyTank.name$").AddTarget( " $ newTarget.name $ " )", 'Tank' );

	if( newTarget == None )
		return;

	newTargetInfo.Target = newTarget;

	// Is this target already in the queue?
	ndxTarget = FindTargetInQueue( newTarget );

	if( ndxTarget < 0 )
	{
		Log( name $ ".(TankGunController-"$MyTank.name$").AddTarget( " $ newTarget.name $ " ) - adding new target", 'Tank' );

		if ((MyTank != None) && (MyTank.CommanderPawn != None))
		{
			// make sure the tank commander pawn knows about the enemy...
			MyTank.CommanderPawn.SeeEnemy();
		}

		// Add the new target to the end of the list.
		TargetQueue.Length = TargetQueue.Length + 1;
		TargetQueue[ TargetQueue.Length - 1 ] = newTargetInfo;

		ndxTarget = TargetQueue.Length - 1;

		TargetQueue[ndxTarget].bIgnored = 0;
		TargetQueue[ndxTarget].bHasSetFirstHiddenLocation = 0;
		TargetQueue[ndxTarget].bUseCannon = 0;
		TargetQueue[ndxTarget].bHasDonePurposefulMiss = 0;
		TargetQueue[ndxTarget].bIsHardTarget = 0;  // assume false until known otherwise
		if (newTarget.IsA('Tank'))
		{
			TargetQueue[ndxTarget].bIsHardTarget = 1;
		}
		else if (gbxWeapon(newTarget.Weapon) != None)
		{
			if (gbxWeapon(newTarget.Weapon).bDamagesVehicles)
			{
				TargetQueue[ndxTarget].bIsHardTarget = 1;
			}
		}
		TargetQueue[ndxTarget].PurposefulMissTimeStarted = 0.0f;

		SetContactedTarget(ndxTarget);

		bTargetQueueNeedsSort = true;

		// Alert my friends about this target.
		percep = new( Level.Outer ) class'PerceptionPawnAddedTarget';
		percep.Target = newTarget;

		PostGBXMessage( percep );
	}
	else
	{
		// We already know about this target, but update our contact time for him in case he has been ignored.
		SetContactedTarget( ndxTarget );
	}
}

function RemoveTargetFromQueue( Actor aTarget )
{
	local int ndxTarget;

	ndxTarget = FindTargetInQueue( aTarget );

	if ( ndxTarget >= 0 )
	{
//		Log( name $ ".(TankGunController-"$MyTank.name$").RemoveTargetFromQueue( " $ aTarget.name $ " )", 'Tank' );
		TargetQueue.Remove( ndxTarget, 1 );
	}
}

function FindWorstThreats()
{
	local int i;

	// Scan the queue for the targets with the highest priority.

	WorstThreats.Remove( 0, WorstThreats.Length );

	for ( i = 0; i < TargetQueue.Length; i++ )
	{
		// Try to add this as a worst threat.
		AddWorstThreat( i );
	}

	ThreatLocations.Length = WorstThreats.Length;
	for ( i = 0; i < WorstThreats.Length; i++ )
	{
		ThreatLocations[ i ] = WorstThreats[ i ].Target.Location;
	}
}

function AddWorstThreat( int ndxTarget )
{
	local int i;

	// Don't add targets that are marked "ignore me."
	if ( TargetQueue[ ndxTarget ].bIgnored == 1 )
		return;

	// Find which worst threat this target is even worser than. (sic)
	for ( i = WorstThreats.Length - 1; i >= 0; i-- )
	{
		if( WorstThreats[ i ].TargetPriority > TargetQueue[ ndxTarget ].TargetPriority )
		{
			// This worst threat is worse than the target. If the target is to be added, it will
			// have to be added after this.
			break;
		}
	}

	i++;

	// Don't add this threat off the back end of the array's limit, but do add it if it's in the middle or if the array isn't too long yet.
	if( WorstThreats.Length < MAX_WORST_THREATS || i < ( WorstThreats.Length - 1 ))
	{
		WorstThreats.Insert( i, 1 );
		WorstThreats[ i ] = TargetQueue[ ndxTarget ];
	}

	// Truncate any extra threats so the array doesn't get too long.
	if( WorstThreats.Length > MAX_WORST_THREATS )
	{
		WorstThreats.Remove( MAX_WORST_THREATS, WorstThreats.Length - MAX_WORST_THREATS );
	}
}

event float GetExposureToTarget( Pawn aThreat )
{
	local Vector seeLoc, suppressLoc, failLoc;
	local int isHeadShot;

	if( aThreat == None || aThreat.IsDead() )
	{
		Log( name $ ".(TankGunController-"$MyTank.name$").GetExposureToTarget( " $ aThreat.name $ " )  ERROR: checked none or dead target.", 'Tank' );
		return 0.0;
	}

	if( !aThreat.Controller.CanSeeOrSuppress( MyTank, seeLoc, isHeadShot, suppressLoc, failLoc, 2 ))		// He should assume he is standing
	{
		return 0.0;
	}
	else if( VSize( seeLoc ) > 0.001 )
	{
		return 1.0;
	}
	else
	{
		// Suppression only.
		return 0.5;
	}
}

event float GetTargetExposureToMe( Pawn aThreat )
{
	return GetTargetExposureToTankNative( aThreat );
}

event vector GetGunControllerRotation()
{
	// this function should be overridden in the child classes...
	Log(name $ ".GetGunControllerRotation() - YOU FORGOT TO OVERRIDE THIS FUNCTION!!!");
	return vect(0,0,0);
}


//---------------------------------------------------------
//	GetUnitSkillModified
//---------------------------------------------------------
function int GetUnitSkillModifier( Unit theUnit )
{
	if (theUnit == None)
		return 0;

	switch ( theUnit.BaseSkillLevel )
	{
		case SKILL_Novice:
			return UnitSkillMod_Novice;
		case SKILL_Intermediate:
			return UnitSkillMod_Interm;
		case SKILL_Advanced:
			return UnitSkillMod_Advanced;
		case SKILL_Veteran:
			return UnitSkillMod_Veteran;
		case SKILL_Invincible:
			return UnitSkillMod_Invincible;
		default:
			return 0;
	}
}

//---------------------------------------------------------
//	FriendlyInTheWayFromLocation
//---------------------------------------------------------
function bool FriendlyInTheWayFromLocation( Vector FromLocation, optional out gbxPawn BlockingFriendly )
{
	local Vector EndTrace, GunVector, ToFriendly;
	local gbxPawn OneFriendly;
	local int index;
	local float Dist, DistToTarget, DotVal;

	EndTrace = Enemy.Location;

	GunVector = EndTrace - FromLocation;
	DistToTarget = VSizeIgnoreZ( GunVector );
	GunVector.Z = 0;
	GunVector = Normal( GunVector );

	// Compare the dot-product of the gun's aim direction with a vector to each
	// friendly in the map.  If the dot-product is sufficiently large ( near 1.0 ),
	// this means a friendly is in our cone of fire.
	if ((MyTank.MyUnit != None) && (MyTank.MyUnit.IsA('MultiplayerUnit')))
	{
		index = MyTank.GetNextTeammateByTeam( MultiplayerUnit(MyTank.MyUnit).Team, 0, OneFriendly );
	}
	else
	{
		index = MyTank.GetNextTeammateByTeam( MyTank.PawnTeam, 0, OneFriendly );
	}

	while( index != -1 )
	{
		if ((OneFriendly != MyTank) && !OneFriendly.IsDead() &&
			!OneFriendly.IsA('TankCommanderPawn') && !OneFriendly.IsA('TankCommanderPawnHitCylinder'))
		{
			Dist = VSizeIgnoreZ( OneFriendly.Location - FromLocation );

			// JMW tweaking this for situations I'm coming across in testing:
			if ( Dist < DistToTarget || 		// Friendly in between me and target.
				 Dist - DistToTarget < FFBufferDist	)	// Friendly beyond target; make sure he's *far* beyond the target.
			{
				ToFriendly = OneFriendly.Location - FromLocation;
				ToFriendly.Z = 0;
				ToFriendly = Normal( ToFriendly );

				DotVal = ToFriendly dot GunVector;
				if ( DotVal >= FFConeThresh )
				{
					BlockingFriendly = OneFriendly;
					return true;
				}
				else
				// For pawns that are especially close to the shooter, don't even allow it if
				// the angle to the friendly is less than 60 degrees.
				if ( DotVal >= 0.5 && Dist <= FFSuperCloseRadius )
				{
					BlockingFriendly = OneFriendly;
					return true;
				}
			}
		}

		if ((MyTank.MyUnit != None) && (MyTank.MyUnit.IsA('MultiplayerUnit')))
		{
			index = MyTank.GetNextTeammateByTeam( MultiplayerUnit(MyTank.MyUnit).Team, index, OneFriendly );
		}
		else
		{
			index = MyTank.GetNextTeammateByTeam( MyTank.PawnTeam, index, OneFriendly );
		}
	}

	BlockingFriendly = None;
	return false;
}

//---------------------------------------------------------
//	FriendlyInTheWay
//---------------------------------------------------------
function bool FriendlyInTheWay( optional out gbxPawn BlockingFriendly )
{
	return FriendlyInTheWayFromLocation( MyTank.Location, BlockingFriendly );
}

function bool HasClearShot(Vector StartLoc)
{
	local Vector EndLoc, HitLoc, HitNormal;
	local Actor HitActor;

	// If any level geometry or static meshes block this trace,
	// return false, otherwise return true;

	// Always check against the target's head instead of using the SeeLoc.
	// This avoids situations where the rifle is propped up on a wall and the
	// target is relatively close to the shooter, in which case a line check to the
	// target's torso would clip into the wall.
	if (Pawn(Enemy) != None)
		EndLoc = Enemy.Location + Pawn(Enemy).EyePosition();
	else
		EndLoc = Enemy.Location;

	HitActor = Trace( HitLoc, HitNormal, EndLoc, StartLoc, false );

	if ((HitActor == None) || (HitActor == Enemy))
		return true;
	else if (VSize( HitLoc - StartLoc ) >= 500)  // bullet would go at least 500 units?
		return true;

	return false;
}

//---------------------------------------------------------
//	ApproveShot
//---------------------------------------------------------
function bool ApproveShot( Vector StartLoc, Rotator AimRotator )
{
	local bool bApproved;
	local int IsHeadShot;
	local vector SuppressLoc, FailLoc;

	bApproved = ( !FriendlyInTheWay( BlockingFriendly ) && HasClearShot(StartLoc) );

	if (( bApproved ) && (Pawn(Enemy) != None))
	{
		// Do CSS() here as opposed to in AdjustAimNew() so that it doesn't get called too often
		MyTankController.CanSeeOrSuppress( Pawn(Enemy), SeeLoc, IsHeadShot, SuppressLoc, FailLoc );
	}

	return bApproved;
}

// Apply our final error value to the aim-rotator to determine
// where the shot will actually travel.
function ApplyAccuracy( out Rotator AimRotator, int FinalError )
{
	local Vector NewAimVect;
	local Rotator NewAimRot, NewAimRot2;

	// Use "polar coordinates" to determine the new aim rotator:
	// Pitch the input rotator upwards some random amount (always positive),
	// then roll the resulting rotator around some random amount (0 to 360 degrees).
	// The resulting vector will fall somewhere within a circle centered around the
	// starting rotator and having a radius of FinalError.
	//
	NewAimRot.Pitch += FRand() * FinalError;
	NewAimRot2.Roll = FRand() * 65535;

	NewAimVect = Vector( NewAimRot ) >> NewAimRot2;
	AimRotator = Rotator( NewAimVect >> AimRotator );	
}

//---------------------------------------------------------
//	DoDeadlock
//---------------------------------------------------------
function bool DoDeadlock( float DistToTarget )
{
	// Conditions for doing deadlock:
	// 1) Target is not a player pawn;
	// 2) Target is at a cover point;
	// 3) That cover point provides crouched protection from the shooter.
	// 4) Target is further away than a distance threshold;
	//
	// Results:
	// The shooter misses the target (but not by much!)

	local ActorLite TargetCoverPoint;

	if (Pawn(Enemy) != None)
	{
		if ( Pawn(Enemy).IsHumanControlled() )
		{
			return false;
		}
	}

	if (gbxPawn(Enemy) == None)
		return false;

	// (2) && (3)
	if ( gbxPawn(Enemy).IsCoveredFrom( MyTank.Location, TargetCoverPoint ) )
	{
		// (4)
		if ( DistToTarget >= MyTankController.CombatRadius_Deadlock )
		{
			return true;
		}
	}

	return false;
}

//---------------------------------------------------------
//	ShotHitsPawn
//---------------------------------------------------------
function bool ShotHitsPawn( Vector TargetPos, Vector StartPos, float Range )
{
	local Vector HitLoc, HitNormal, ShotDir;
	local Actor HitActor;

	ShotDir = Normal( TargetPos - StartPos );

	HitActor = Trace( HitLoc, HitNormal, StartPos + (Range * ShotDir), StartPos, true,,,,,, MyTank );

	if ( HitActor != None && HitActor.IsA('Pawn') )
	{
		return true;
	}
	else
		return false;
}

//---------------------------------------------------------
//	DoPurposefulMiss
//---------------------------------------------------------
function Rotator DoPurposefulMissBullet( Vector ProjStart, Vector TargetLoc, gbxPawn MissTarget, InstantFire MyInstantFire, optional out int bSkipDoTrace )
{
	local Vector ToTarget, TargetFacing, PerpVector, BestMissLoc, NextBestMissLoc;
	local bool bTargetFacingAway, bTargetFacingRight;
	local Rotator TempRot;

	ToTarget = Normal( TargetLoc - ProjStart );

	// Do a purposeful miss.  Here's the logic:
	// If we can only see the target's head, shoot to the right or left of the head.
	// If we can see the target's center-of-mass,
	// shoot at the ground in front of the target's feet.

	// Before we get started, mark this bullet as a "purposeful miss" bullet,
	// which prevents it from causing any damage, should something go wrong and this bullet actually hit someone.
	if (MyInstantFire != None)
		MyInstantFire.SetNoDamageThisBullet();

	// First, find what direction the target is facing.
	if (Pawn(Enemy) != None)
	{
		if (Pawn(Enemy).IsHumanControlled())
		{
			TempRot = Enemy.Rotation;
			TempRot.Pitch = 0;
			TargetFacing = Vector( TempRot );
			PerpVector = ToTarget cross Vect(0,0,1);

			if ( TargetFacing dot Normal( ToTarget ) > 0 )
				bTargetFacingAway = true;
			if ( TargetFacing dot PerpVector > 0 )
				bTargetFacingRight = true;
		}
		else
		{
			if (Rand(2) == 0)
				bTargetFacingRight = true;
			else
				bTargetFacingRight = false;
		}
	}

	// Get the "fall back" miss location, in case the ideal miss location is unusable.
	NextBestMissLoc = Enemy.Location;
	if (Pawn(Enemy) != None)
		NextBestMissLoc.Z += (Pawn(Enemy).BaseEyeHeight + 25.0);

	if ( bTargetFacingRight )
		BestMissLoc = TargetLoc + 100.0 * PerpVector;
	else
		BestMissLoc = TargetLoc - 100.0 * PerpVector;

	// Adjust the miss-location upward/downward randomly.
	if ( Rand(2) == 0 )
		BestMissLoc.Z -= Rand(100);
	else
		BestMissLoc.Z += Rand(100);

	// Adjust the miss-location X and Y offset...
	BestMissLoc.X += (FRand() * 100.0) - 50.0;  // offset +/- 50.0 units
	BestMissLoc.Y += (FRand() * 100.0) - 50.0;  // offset +/- 50.0 units

	// Do a last-minute muzzle check on the ideal miss location.
	if ( !ShotHitsPawn( BestMissLoc, ProjStart, MyInstantFire.MaxRange() ) )
	{
		return Rotator( BestMissLoc - ProjStart );
	}
	else
	if ( !ShotHitsPawn( NextBestMissLoc, ProjStart, MyInstantFire.MaxRange() ) )
	{
		return Rotator( NextBestMissLoc - ProjStart );
	}
	else
	{
		// TBD: indicate to caller NOT to do damage.
		bSkipDoTrace = 1;
		return Rotator( NextBestMissLoc - ProjStart );
	}
}

function Rotator DeadlockPurposefulMissBullet( Vector ProjStart, Vector TargetLoc, gbxPawn MissTarget, InstantFire MyInstantFire, optional out int bSkipDoTrace )
{
	return DoPurposefulMissBullet( ProjStart, TargetLoc, MissTarget, MyInstantFire, bSkipDoTrace );
}

function Rotator IntendedTargetPurposefulMissBullet( Vector ProjStart, Vector TargetLoc, gbxPawn MissTarget, InstantFire MyInstantFire, optional out int bSkipDoTrace )
{
	return DoPurposefulMissBullet( ProjStart, TargetLoc, MissTarget, MyInstantFire, bSkipDoTrace );
}

function Rotator AdjustAimNewBullet( Ammunition Ammo, Vector ProjStart, Rotator AimRotator, InstantFire MyInstantFire, optional out int bSkipDoTrace )
{
	local float DistToTarget;
	local Vector HitLoc, HitNormal;
	local Actor HitActor;
	local rotator NewAimRotator;

	if ( bNoAccuracyAdjust )
		return AimRotator;

	if (Enemy == None)
		return AimRotator;

	DistToTarget = VSize( Enemy.Location - MyTank.Location );

	// Is this a deadlock situation or does the target have any "lucky chances?"
	// If so, miss the target on purpose.
	if ( (DistToTarget > BulletDoNoDamageRange) || DoDeadlock( DistToTarget ) )
	{
		if (gbxPawn(Enemy) != None)
		{
			NewAimRotator = DeadlockPurposefulMissBullet( ProjStart, Enemy.Location, gbxPawn(Enemy), MyInstantFire, bSkipDoTrace );
		}
	}
	else if ( DistToTarget > MyTankController.CombatRadius_Deadlock )
	{
		// No deadlock; no chances left; but make sure that the shot will hit its intended target!
		// If it hits anyone else, miss on purpose anyway!
		if (MyInstantFire != None)
		{
			HitActor = Trace( HitLoc, HitNormal, ProjStart + MyInstantFire.MaxRange() * Vector(AimRotator), ProjStart, true,,,,,, MyTank );
			if ( (HitActor != None) && (HitActor != Enemy) && HitActor.IsA( 'Infantry' ) )
			{
				if (gbxPawn(Enemy) != None)
				{
					NewAimRotator = IntendedTargetPurposefulMissBullet( ProjStart, Enemy.Location, gbxPawn(Enemy), MyInstantFire, bSkipDoTrace );
				}
			}
		}
	}

	// Inform the target that we shot at him (so he can timestamp his luck system).
	if ( gbxPawn(Enemy) != None )
		gbxPawn(Enemy).IShotAtYou( MyTank, false );

	// if adjusted aim is more than 15 degrees off from original aim, return original aim rotator...
	if (Vector(NewAimRotator) dot Vector(AimRotator) < 0.9659)
	{
		NewAimRotator = AimRotator;
	}

	return NewAimRotator;
}

function Rotator DoPurposefulMissTankShell( Vector ProjStart, Vector TargetLoc, gbxPawn MissTarget, InstantFire MyInstantFire, optional out int bSkipDoTrace )
{
	local float DistToTarget;
	local float percent;
	local vector VectToTarget;
	local vector VectEnemySide;
	local vector MissLocation;

	DistToTarget = VSize( Enemy.Location - MyTank.Location );

	if (DistToTarget < 800.0)  // are we VERY close to the target?
	{
		// Shoot way over the target's head.
		VectToTarget = ( TargetLoc + Vect(0,0,200.0) ) - MyTank.Location;
	}
	else
	{
		VectToTarget = Normal(TargetLoc - MyTank.Location);
		VectEnemySide = VectToTarget cross vect(0,0,1);

		percent = FRand();

		// randomly choose in front, to the left or to the right of target...
		if (percent < 0.2)
			MissLocation = TargetLoc - (VectToTarget * (400.0 + FRand() * 200.0));  // in front of target
		else if (percent < 0.6)
			MissLocation = TargetLoc + (VectEnemySide * (600.0 + FRand() * 400.0));  // to the side
		else
			MissLocation = TargetLoc - (VectEnemySide * (600.0 + FRand() * 400.0));  // to the other side

		// adjust randomly forward/backward
		MissLocation = MissLocation - (VectToTarget * (150.0 - FRand() * 300.0));

		// adjust Z location downward so that we're sure we hit the ground near target...
		MissLocation.Z -= MyTank.VehicleCollisionHeight * 2.0;

		VectToTarget = MissLocation - MyTank.Location;
	}

	return Rotator( VectToTarget );
}

function Rotator AdjustAimNewTankShell( Ammunition Ammo, Vector ProjStart, Rotator AimRotator, InstantFire MyInstantFire, optional out int bSkipDoTrace )
{
	local int index;

//	Log( name $ ".(TankGunController-"$MyTank.name$").AdjustAimNewTankShell()", 'Tank' );

	if ( bNoAccuracyAdjust )
		return AimRotator;

	if (Enemy == None)
		return AimRotator;

	index = FindTargetInQueue( Enemy );

	if (index < 0)
		return AimRotator;  // target not found in queue?, just return the given aim rotator

	// should we do a purposeful miss and not hit the target?...
	if (bDoesPurposefulMiss && (TargetQueue[index].bHasDonePurposefulMiss == 0))
	{
		AimRotator = DoPurposefulMissTankShell( ProjStart, Enemy.Location, gbxPawn(Enemy), MyInstantFire, bSkipDoTrace );

		TargetQueue[index].bHasDonePurposefulMiss = 1;  // we have now done a purposeful miss
	}
	else if ((TargetQueue[index].bIsHardTarget == 1) && (TargetQueue[index].PurposefulMissTimeExpires > Level.TimeSeconds))
	{
		AimRotator = DoPurposefulMissTankShell( ProjStart, Enemy.Location, gbxPawn(Enemy), MyInstantFire, bSkipDoTrace );
	}

	// Inform the target that we shot at him (so he can timestamp his luck system).
	if ( gbxPawn(Enemy) != None )
		gbxPawn(Enemy).IShotAtYou( MyTank, false );

	return AimRotator;
}

//---------------------------------------------------------
//	UpdateActualAttackLevels
//---------------------------------------------------------
function UpdateActualAttackLevels()
{
	local int i;

	for( i = 0; i < TargetQueue.Length; ++i )
	{
		TargetQueue[ i ].ActualAttackLevel = FClamp( TargetQueue[ i ].ActualAttackLevel - AttackLevelDecay, 0, 1 );
		TargetQueue[ i ].DistractionLevel = FClamp( TargetQueue[ i ].DistractionLevel - DistractionLevelDecay, 0, 1 );
	}
}

event SetContactedTarget(int ndxTarget)
{
//	Log(name $ ".SetContactedTarget() - ndxTarget = " $ ndxTarget $ "  time = " $ Level.TimeSeconds, 'Tank');

	if ( TargetQueue[ ndxTarget ].bIgnored != 0 )
	{
		// was being ignored, but not ignored anymore
		TargetQueue[ ndxTarget ].bIgnored = 0;

		MyTankController.SeeEnemy();  // a target has been seen
	}

	TargetQueue[ ndxTarget ].LastContactTime = Level.TimeSeconds;

	if (TargetQueue[ ndxTarget].Target != None)
		TargetQueue[ ndxTarget ].LastKnownLocation = TargetQueue[ ndxTarget ].Target.Location;
	else
		TargetQueue[ ndxTarget ].LastKnownLocation = vect(0,0,0);

	TargetQueue[ ndxTarget ].bHasSetFirstHiddenLocation = 0;

	MyTankController.SetContactedTarget();
}

function bool EnemiesAreRecentlyVisible()
{
	return !NoEnemiesVisibleForAWhile();
}

function bool NoEnemiesVisibleForAWhile()
{
	local int index;

	if (Enemy != None)
		return false;

	for (index = 0; index < TargetQueue.Length; index++)
	{
		// have we contacted (seen) a target in a little while?
		if (((TargetQueue[index].LastContactTime + TargetForgetTimeShort) > Level.TimeSeconds) &&
			(TargetQueue[index].bIgnored == 0))
			return false;  // someone is recently visible, return false
	}

	return true;
}

function gbxPawn GetHuntingEnemy(out vector LastKnownLocation, out vector FirstHiddenLocation)
{
	local gbxPawn BestHuntingEnemy;
	local float BestTargetPriority;
	local int index;

	BestHuntingEnemy = None;
	BestTargetPriority = -1.0;

	for (index = 0; index < TargetQueue.Length; index++)
	{
		// is this target being ignored?
		if (TargetQueue[index].bIgnored != 0)
		{
			if ((BestHuntingEnemy == None) || (TargetQueue[index].TargetPriority > BestTargetPriority))
			{
				BestHuntingEnemy = TargetQueue[index].Target;
				BestTargetPriority = TargetQueue[index].TargetPriority;
				LastKnownLocation = TargetQueue[index].LastKnownLocation;
				FirstHiddenLocation = TargetQueue[index].FirstHiddenLocation;
			}
		}
	}

	return BestHuntingEnemy;
}

defaultproperties
{
	bHidden=true
	bCollideWorld=false
	bCollideWhenPlacing=false

	TimerInterval=0.2

	PeripheralVision=0.0  // +/- 90 degrees (180 degrees total)
	PeripheralVisionWithCommander=0.0  // +/- 90 degrees (180 degrees total)
	PeripheralVisionWithoutCommander=0.5  // +/- 60 degrees (120 degrees total)

	ForceTargetSortInterval=0.2

	MaxTargetRange=10000.0

	TargetForgetDist=1000.0f
	TargetForgetTimeLong=15.0f
	TargetForgetTimeShort=10.0f
	DistractionForgetfulness=1.5f

	TargetPriorityScalarDistance			=0.5
	TargetPriorityScalarAttackLevel			=0.1
	TargetPriorityScalarWeaponRating		=0.1
	TargetPriorityScalarAlreadyTargetted	=0.1
	TargetPriorityScalarTargetExposureToMe	=0.6
	TargetPriorityScalarMyExposureToTarget	=0.4
	TargetPriorityScalarInAssignedUnit		=0.75
	TargetPriorityScalarHumanPlayer			=0.01
	TargetPriorityScalarViewRating			=2.0
	TargetPriorityScalarInAimingDirection	=0.8
	TargetPriorityScalarEnemyVehicle		=5.0

	AttackLevelDecay=0.03
	DistractionLevelDecay=0.1667	

	TargetRelegateCheckTime=1.0
	MaxImpactDistance=1000.0

	RelegationDuration=10.0
	NearbyInfantryTargetDistance=1000.0

	bDoesPurposefulMiss=true
	BulletDoNoDamageRange=2000.0
	MainGunDoNoDamageRange=3500.0

	TargetEvaluationIntervalFar=6.0
	TargetCSSIntervalMedium=3.0
	TargetRangeMedium=2.0
	TargetRangeFar=4.0

	UnitSkillMod_Novice=0
	UnitSkillMod_Interm=10
	UnitSkillMod_Advanced=20
	UnitSkillMod_Veteran=30
	UnitSkillMod_Invincible=30

	FFSuperCloseRadius=100.0
	FFConeThresh=0.974
	FFBufferDist=1500.0

	ReactionTimeMin=10.0
	ReactionTimeMax=12.0
	ReactionTimeMinEasy=10.0
	ReactionTimeMaxEasy=12.0
	ReactionTimeMinNormal=7.0
	ReactionTimeMaxNormal=8.0
	ReactionTimeMinHard=5.0
	ReactionTimeMaxHard=6.0
	ReactionTimeMinAuthentic=3.0
	ReactionTimeMaxAuthentic=4.0

	PurposefulMissTimeStart=45.0
	PurposefulMissTimeBonus=5.0
	PurposefulMissTimeMax=60.0
	PurposefulMissTimeStartEasy=45.0
	PurposefulMissTimeBonusEasy=5.0
	PurposefulMissTimeMaxEasy=60.0
	PurposefulMissTimeStartNormal=30.0
	PurposefulMissTimeBonusNormal=5.0
	PurposefulMissTimeMaxNormal=45.0
	PurposefulMissTimeStartHard=20.0
	PurposefulMissTimeBonusHard=5.0
	PurposefulMissTimeMaxHard=30.0
	PurposefulMissTimeStartAuthentic=15.0
	PurposefulMissTimeBonusAuthentic=5.0
	PurposefulMissTimeMaxAuthentic=20.0

	PurposefulMissRechargeDistance=400.0
}
class TankM10Controller extends TankControllerUS
	notplaceable;


var()	TankM10_					MyTankM10_;
var()	TankM10MainGunController	MyMainGunController;

// enemy targeting stuff...
var()	Actor	MainGunTarget;


function Possess(Pawn aPawn)
{
	Log( name $ ".(TankM10Controller).Possess( " $ aPawn.name $ " )", 'Tank' );

	Super.Possess(aPawn);

	if ((aPawn == None) || (TankM10_(aPawn) == None))
	{
		Log(name $ ".Possess() - WARNING! TankM10Controller's Pawn is NOT a TankM10!!!");
	}
	else
	{
		MyTankM10_ = TankM10_(aPawn);

		MyMainGunController = spawn(class'TankM10MainGunController', self);
		if (MyMainGunController == None)
			Log( name $ ".(TankM10Controller).Possess() - ERROR Spawning TankM10MainGunController!!!", 'Tank' );
		else
			MyMainGunController.Possess(MyTankM10_, self);
	}
}

function Destroyed()
{
	Log( name $ ".(TankM10Controller).Destroyed()", 'Tank' );

	if (MyMainGunController != None)
		MyMainGunController.Destroy();

	super.Destroyed();
}

function Timer()
{
	Super.Timer();

	if (fPauseMovementCheckTime < Level.TimeSeconds)
	{
		fPauseMovementCheckTime = Level.TimeSeconds + 2.0f;

		bPauseMovement = false;  // stop moving and attack enemy from here

		if ( (MyMainGunController != None) && MyMainGunController.ShouldTankPause() )
		{
			bPauseMovement = true;  // stop moving and attack enemy from here
		}
	}
}

function PawnDied(Pawn P)
{
	Super.PawnDied(P);
}

function Tick(float DeltaTime)
{
	Super.Tick(DeltaTime);

	if (MyTankM10_.WeapUSM10_50calMachineGun != None)
	{
		bIsPlayerMounting = MyTankM10_.WeapUSM10_50calMachineGun.bIsMounting;
	}
}

function NotifyTakeHit(pawn InstigatedBy, vector HitLocation, int Damage, class<DamageType> damageType, vector Momentum)
{
//	Log( name $ "(" $ Pawn.name $ ").NotifyTakeHit( " $ InstigatedBy.name $ " )", 'Tank' );

	if (bIsInScriptedMode)
		return;  // don't do anything if under scripted control

	if (MyMainGunController != None)
		MyMainGunController.NotifyTakeHit(InstigatedBy, HitLocation, Damage, damageType, Momentum);

	Super.NotifyTakeHit( InstigatedBy, HitLocation, Damage, damageType, Momentum );
}

function SeePawn( Pawn Seen )
{
//	Log( name $ "(" $ Pawn.name $ ").SeePawn( " $ Seen.name $ " )", 'Tank' );

	if (bIsInScriptedMode)
		return;  // don't do anything if under scripted control

	if (MyMainGunController != None)
		MyMainGunController.SeePawn(Seen);

	Super.SeePawn(Seen);
}

function SeePawnKilled( Pawn Seen, Pawn Killer )
{
//	Log( name $ "(" $ Pawn.name $ ").SeePawnKilled( " $ Seen.name $ " )", 'Tank' );

	if (bIsInScriptedMode)
		return;  // don't do anything if under scripted control

	// Seeing your friends get killed.
	if (MyMainGunController != None)
		MyMainGunController.SeePawnKilled(Seen, Killer);

	Super.SeePawnKilled(Seen, Killer);
}

function SeePawnHit( Pawn Seen )
{
//	Log( name $ "(" $ Pawn.name $ ").SeePawnHit( " $ Seen.name $ " )", 'Tank' );

	if (bIsInScriptedMode)
		return;  // don't do anything if under scripted control

	if (MyMainGunController != None)
		MyMainGunController.SeePawnHit(Seen);

	Super.SeePawnHit(Seen);
}

function HearNoise( float Loudness, Actor NoiseMaker )
{
//	Log( name $ "(" $ Pawn.name $ ").HearNoise( " $ Loudness $ ", " $ NoiseMaker.name $ " )", 'Tank' );

	if (bIsInScriptedMode)
		return;  // don't do anything if under scripted control

	if (MyMainGunController != None)
		MyMainGunController.HearNoise(Loudness, NoiseMaker);

	Super.HearNoise(Loudness, NoiseMaker);
}

function SeePlayer( Pawn Seen )
{
//	Log( name $ "(" $ Pawn.name $ ").SeePlayer( " $ Seen.name $ " )", 'Tank' );

	if (bIsInScriptedMode)
		return;  // don't do anything if under scripted control

	if (MyMainGunController != None)
		MyMainGunController.SeePlayer(Seen);

	Super.SeePlayer(Seen);
}

function SeeExplosion( Pawn Instigator )
{
//	Log( name $ "(" $ Pawn.name $ ").SeeExplosion( " $ Instigator.name $ " )", 'Tank' );

	if (bIsInScriptedMode)
		return;  // don't do anything if under scripted control

	// Seeing shit get blown up.
	if (MyMainGunController != None)
		MyMainGunController.SeeExplosion(Instigator);

	Super.SeeExplosion(Instigator);
}

function NotifyTargetOrder(Unit targetUnit)
{
	local int i;

	// notify this member about all Targets in the targetUnit...
	for (i = 0; i < targetUnit.NumMembers; i++)
	{
		if (MyMainGunController != None)
			MyMainGunController.AddTarget( targetUnit.Members[i] );
	}
}

function NotifyAssaultOrder(Unit targetUnit)
{
	local int i;

	// notify this member about all Targets in the targetUnit...
	for (i = 0; i < targetUnit.NumMembers; i++)
	{
		if (MyMainGunController != None)
			MyMainGunController.AddTarget( targetUnit.Members[i] );
	}
}

function ConsiderPossibleEnemy( Pawn possibleEnemy )
{
	if (bIsInScriptedMode)
		return;  // don't do anything if under scripted control

	if (MyMainGunController != None)
		MyMainGunController.ConsiderPossibleEnemy(possibleEnemy, false);
}

event float GetTargetExposureToMe( Pawn aThreat )
{
	local float MainGunExp;

	MainGunExp = MyMainGunController.GetTargetExposureToMe(aThreat);

	return MainGunExp;
}

function bool TankHasEnemy()
{
	if (MyMainGunController != None)
	{
		if (MyMainGunController.ndxEnemyInQueue >= 0)
			return true;
	}

	return false;
}


defaultproperties
{
}
class TankM10MainGunController extends TankGunController
	notplaceable;


var()	TankM10_			MyTankM10_;
var()	TankM10Controller	MyTankM10Controller;

// weapon targeting stuff...
var()	bool	bIsOnTarget;
var()	bool	bIsYawOnTarget;

var()	float	fEnemySpottedTime;	// when we first saw the enemy
var()	float	fEnemyNoneTime;		// time when enemy was last set to None
var()	float	fResetTurretTime;	// how long after enemy = none to reset turret back to facing fowards
var()	bool	bIsResettingTurret;
var()	bool	bIsPlayerOnTank;

var(Target)	float TargetPriorityScalarInfantryGroup;

var()	bool	bLogPriority;

var		int		AimErrorAIMain, AimErrorAICoax;


function Possess(Tank aPawn, TankController aController)
{
	Log( name $ ".(TankM10MainGunController).Possess( " $ aPawn.name $ " " $ aController.name $ " )", 'Tank' );

	if (TankM10_(aPawn) == None)
	{
		Log(name $ ".Possess - aPawn (" $ aPawn.name $ ") is NOT a TankM10!!!");
		return;
	}

	if (TankM10Controller(aController) == None)
	{
		Log(name $ ".Possess - aController (" $ aController.name $ ") is NOT a TankM10Controller!!!");
		return;
	}

	Super.Possess(aPawn, aController);

	MyTankM10_ = TankM10_(aPawn);
	MyTankM10Controller = TankM10Controller(aController);

	fEnemyNoneTime = 0.0f;
	fEnemySpottedTime = -1.0f;  // enemy not spotted yet
	MyTankM10Controller.fRotateToFaceCheckTime = -1.0f;

	bIsPlayerOnTank = false;
}

function Timer()
{
//	Log( name $ ".(TankM10MainGunController).Timer()", 'Tank' );

	if (MyTankM10Controller.bIsInScriptedMode)
	{
		Super.Timer();
		return;
	}

	PeripheralVision = PeripheralVisionWithoutCommander;  // default to vision without tank commander

	if (MyTankM10_ != None)
	{
		if (!MyTankM10_.bSpawnCommander)  // if tank was spawned without a commander, use same vision as if had a commander...
		{
			PeripheralVision = PeripheralVisionWithCommander;
		}
		else if ((MyTankM10_.CommanderPawn != None) && (MyTankM10_.CommanderPawn.Health > 0) && (!MyTankM10_.CommanderPawn.bHatchClosing))
		{
			PeripheralVision = PeripheralVisionWithCommander;
		}
	}

	Super.Timer();
}

function SeePawn( Pawn Seen )
{
	local Rotator TurretRotation;

//	Log( name $ ".(TankM10MainGunController-"$MyTank.name$").SeePawn( " $ Seen.name $ " )", 'Tank' );

	if (MyTankController.bNoEnemies)
		return;  // don't target or shoot at any enemies

	if ( MyTankController.bNoTargetPlayer && Seen.IsPlayerPawn() )
		return;  // don't target or shoot at player

	TurretRotation.Pitch = MyTankM10_.Rotation.Pitch;
	TurretRotation.Yaw = (MyTankM10_.Rotation.Yaw - MyTankM10_.TurretYaw) & 65535;
	TurretRotation.Roll = 0;

	if (TankGunControllerCanSee(TurretRotation, Seen))
		ConsiderPossibleEnemy( Seen, true );
}

function HearNoise( float Loudness, Actor NoiseMaker )
{
//	Log( name $ ".(TankM10MainGunController-"$MyTank.name$").HearNoise( " $ Loudness $ " " $ NoiseMaker.name $ " )", 'Tank' );

	if (MyTankController.bNoEnemies)
		return;  // don't target or shoot at any enemies

	if ( MyTankController.bNoTargetPlayer && Pawn(NoiseMaker).IsPlayerPawn() )
		return;  // don't target or shoot at player

	if( NoiseMaker.IsA( 'Pawn' ))
	{
		// TODO do uncertainty.

		ConsiderPossibleEnemy( Pawn( NoiseMaker ), true );
	}
}

function ConsiderPossibleEnemy( Pawn possibleEnemy, bool bAddToOtherGunController )
{
	Super.ConsiderPossibleEnemy(possibleEnemy, bAddToOtherGunController);
}

function bool SetEnemy( Actor newEnemy )
{
	bIsOnTarget = false;
	return Super.SetEnemy( newEnemy );
}

event AdjustTargetPriority(int index)
{
	local gbxPawn Target;
	local float priority, weights, delta_priority;
	local vector vDir, vForward;
	local rotator MainGunRot;
	local float dotTheta;
	local int NearbyTargets;

	Target = TargetQueue[index].Target;

	// recalculate the priority and weights from the native CalculateTargetPriority() function...
	priority = TargetQueue[index].TargetPriority * TargetQueue[index].TargetTotalWeight;
	weights = TargetQueue[index].TargetTotalWeight;

	// give higher priority to targets that are in the direction that the gun is already facing...
	vDir = Normal(Target.Location - MyTankM10_.Location);
	MainGunRot.Pitch = (MyTankM10_.Rotation.Pitch + MyTankM10_.MainGunPitch) & 65535;
	MainGunRot.Yaw = (MyTankM10_.Rotation.Yaw - MyTankM10_.TurretYaw) & 65535;
	MainGunRot.Roll = 0;
	vForward = Vector(MainGunRot);

	dotTheta = (vDir dot vForward);  // 1.0 to -1.0
	dotTheta = (dotTheta / 2.0) + 0.5;  // 1.0 to 0.0

	delta_priority = dotTheta * TargetPriorityScalarInAimingDirection;
	if (bLogPriority)
		Log(name $ ".AdjustTargetPriority: Target " $ Target.name $ " - InAimingDirection priority = " $ delta_priority, 'Tank');
	priority += delta_priority;
	weights += TargetPriorityScalarInAimingDirection;

	// check what type of target this is (or what type of weapon the target is carrying)...

	if (Target.IsA('gbxSVehicle'))  // is this target a vehicle?
	{
		// give higher priority to enemy vehicles (tanks, trucks, jeeps, etc)...
		delta_priority = TargetPriorityScalarEnemyVehicle;
		if (bLogPriority)
			Log(name $ ".AdjustTargetPriority: Target " $ Target.name $ " - EnemyVehicle priority = " $ delta_priority, 'Tank');
		priority += delta_priority;
		weights += TargetPriorityScalarEnemyVehicle;
		TargetQueue[index].bUseCannon = 1;  // use the cannon to fire at this/these target(s)
	}

//	if (Target.IsA('MachineGun'))
//	{
//		if (bLogPriority)
//			Log(name $ ".AdjustTargetPriority: Target " $ Target.name $ " is a manned machine gun", 'Tank');
//		TargetQueue[index].bUseCannon = 1;  // use the cannon to fire at this/these target(s)
//	}

//	if (Target.IsA('Infantry'))
//	{
//		// check what weapon this infantry soldier is carrying...
//		if (Target.Weapon.IsA('PatherFist'))
//		{
//			if (bLogPriority)
//				Log(name $ ".AdjustTargetPriority: Target " $ Target.name $ " is a soldier carrying an anti-tank weapon", 'Tank');
//			TargetQueue[index].bUseCannon = 1;  // use the cannon to fire at this/these target(s)
//		}
//	}

	if (Target.IsA('Infantry'))
	{
		// check to see if this infantry target is close to at least 2 other infantry targets...
		NearbyTargets = GetNumberOfNearbyInfantryTargets(Target);

		if (NearbyTargets >= 2)
		{
			// give higher priority to infantry targets that are in groups of 3 or more
			delta_priority = TargetPriorityScalarInfantryGroup;
			if (bLogPriority)
				Log(name $ ".AdjustTargetPriority: Target " $ Target.name $ " - InfantryGroup priority = " $ delta_priority, 'Tank');
			priority += delta_priority;
			weights += TargetPriorityScalarInfantryGroup;
			TargetQueue[index].bUseCannon = 1;  // use the cannon to fire at this/these target(s)
		}
	}

	priority = FClamp(priority, 0.0, priority);
	TargetQueue[index].TargetTotalWeight = weights;
	TargetQueue[index].TargetPriority = priority / weights;

	if (bLogPriority)
		Log(name $ ".AdjustTargetPriority: Target " $ Target.name $ " - final priority = " $ TargetQueue[index].TargetPriority, 'Tank');
}

function ReassignTargets()
{
	local int index;
	local float bestPriority;

	if (ndxEnemyInQueue < 0)  // no targets in queue?
		return;

	ndxEnemyInQueue = -1;
	bestPriority = 0.0f;

	for (index = 0; index < TargetQueue.Length; index++)
	{
		if (TargetQueue[index].RelegationTime > Level.TimeSeconds)
			continue;

		if ((ndxEnemyInQueue == -1) || (TargetQueue[index].TargetPriority > bestPriority))
		{
			ndxEnemyInQueue = index;
			bestPriority = TargetQueue[index].TargetPriority;
		}
	}
}

event vector GetGunControllerRotation()
{
	local Rotator TurretRotation;

	TurretRotation.Pitch = MyTankM10_.Rotation.Pitch + MyTankM10_.MainGunPitch;
	TurretRotation.Yaw = MyTankM10_.Rotation.Yaw - MyTankM10_.TurretYaw;
	TurretRotation.Roll = 0;

	return vector(TurretRotation);
}

function Tick( float deltaTime )
{
	local int IsHeadShot;
	local vector SuppressLoc, FailLoc;
	local bool bCanSeePawn, bHatchClosed;
	local vector TargetAimLoc;
	local vector aim_offset;
	local float ReactionTimeDelta;
	local float distance;
	local bool bOnTarget;

	Super.Tick( deltaTime );

	if (MyTankM10Controller == None)
		return;

	if (MyTankM10_.WeapUSM10_50calMachineGun != None)
	{
		if (MyTankM10_.WeapUSM10_50calMachineGun.IsInUse() && !bIsPlayerOnTank)
		{
			bIsPlayerOnTank = true;

			bIsResettingTurret = true;
		}
	}

	if (bIsPlayerOnTank)
	{
		bIsPlayerOnTank = MyTankM10_.WeapUSM10_50calMachineGun.IsInUse() || MyTankM10_.IsPlayerOnTank();
	}

	if (Enemy == None)
	{
		if (MyTankM10Controller.MainGunTarget != None)
		{
			fEnemyNoneTime = Level.TimeSeconds;

			MyTankM10Controller.MainGunTarget = None;
			MyTankM10Controller.bRotateToFaceEnemy = false;
			MyTankM10Controller.EnemyRotateToFace = None;
			MyTankM10Controller.fRotateToFaceCheckTime = -1.0f;
		}
	}
	else
	{
		if ((!MyTankM10Controller.bIsInScriptedMode) &&
			((fEnemySpottedTime < 0) || (MyTankM10Controller.MainGunTarget != Enemy)))
		{
			fEnemySpottedTime = Level.TimeSeconds;

			// have we NOT seen a target within the last 5 seconds?
			if (fGunReactionTime + 5.0 < Level.TimeSeconds)
			{
				// long reaction time, tank is not quite as aware...
				ReactionTimeDelta = ReactionTimeMax - ReactionTimeMin;
				fGunReactionTime = Level.TimeSeconds + ReactionTimeMin + (FRand() * ReactionTimeDelta);
			}
			else
			{
				// short reaction time, tank recently had an enemy and is more aware...
				fGunReactionTime = Level.TimeSeconds + 0.5 + (FRand() * 0.5f);
			}

			Log(name $ ".Tick() - MainGun Enemy " $ Enemy.name $ " spotted at " $ Level.TimeSeconds $ "  reaction time = " $ fGunReactionTime, 'Tank');

			MyTankM10Controller.MainGunTarget = Enemy;

			// does the tank need to rotate it's front to face this enemy (armor stronger at front)?
			if (Enemy.IsA('gbxSVehicle'))
			{
				MyTankM10Controller.bRotateToFaceEnemy = true;
				MyTankM10Controller.EnemyRotateToFace = Enemy;
				MyTankM10Controller.fRotateToFaceCheckTime = Level.TimeSeconds;
			}
			else
			{
				if (Enemy.IsA('gbxPawn') && (gbxPawn(Enemy).MyUnit != None) && (gbxPawn(Enemy).MyUnit == MyTank.MyUnit.AssignedTargetUnit))
				{
					MyTankM10Controller.bRotateToFaceEnemy = true;
					MyTankM10Controller.EnemyRotateToFace = Enemy;
					MyTankM10Controller.fRotateToFaceCheckTime = Level.TimeSeconds;
				}
				else
				{
					MyTankM10Controller.bRotateToFaceEnemy = false;
					MyTankM10Controller.EnemyRotateToFace = None;
					MyTankM10Controller.fRotateToFaceCheckTime = Level.TimeSeconds;
				}
			}
		}
	}

	if ((MyTankM10Controller.bRotateToFaceEnemy) && (MyTankM10Controller.EnemyRotateToFace != None))
	{
		if (!MyTankM10Controller.bIsInScriptedMode)
		{
			bCanSeePawn = MyTankController.CanSeeOrSuppress(Pawn(MyTankM10Controller.MainGunTarget), SeeLoc, IsHeadShot, SuppressLoc, FailLoc);
		}
		else
		{
			bCanSeePawn = true;
			SeeLoc = MyTankM10Controller.EnemyRotateToFace.Location;
		}

		// is main gun target visible?, if so, rotate front armor to face target...
		if ((bCanSeePawn) &&
			((SeeLoc.X != 0.0) && (SeeLoc.Y != 0.0) && (SeeLoc.Z != 0.0)))
		{
			// don't need to do this if navigating, the TankController navigation code will do this for us...
			if (!MyTankM10Controller.bIsNavigating)
			{
				MyTankM10Controller.RotateTowardTarget(MyTankM10Controller.EnemyRotateToFace);
			}
		}
	}

	if (MyTankM10Controller.MainGunTarget != None)
	{
		if (!bIsPlayerOnTank)
			bIsResettingTurret = false;

		if (fGunReactionTime < Level.TimeSeconds)
		{
			if (!MyTankM10Controller.bIsInScriptedMode)
			{
				bCanSeePawn = MyTankController.CanSeeOrSuppress(Pawn(MyTankM10Controller.MainGunTarget), SeeLoc, IsHeadShot, SuppressLoc, FailLoc);
			}
			else
			{
				bCanSeePawn = true;
				SeeLoc = MyTankM10Controller.MainGunTarget.Location;
			}

			if (bCanSeePawn)
			{
				if (MyTankM10Controller.MainGunTarget.IsA( 'Infantry' ))  // is target an infantry soldier?
				{
					// aim for the feet...
					aim_offset = vect(0,0,0);
					aim_offset.Z = MyTankM10Controller.MainGunTarget.CollisionHeight;
					TargetAimLoc = SeeLoc - aim_offset;
				}
				else
				{
					// aim slightly below the center (Location) of target...
					aim_offset = vect(0,0,0);
					aim_offset.Z = MyTankM10Controller.MainGunTarget.CollisionHeight / 2.0f;
					TargetAimLoc = SeeLoc - aim_offset;
				}

				if ((SeeLoc.X == 0.0) && (SeeLoc.Y == 0.0) && (SeeLoc.Z == 0.0))
				{
//					TargetAimLoc = SuppressLoc;
					TargetAimLoc = TargetQueue[ndxEnemyInQueue].LastKnownLocation;
				}

				TrackMainGunTarget(deltaTime, TargetAimLoc);  // track using the turret and the main gun

				if (!MyTankM10Controller.bIsInScriptedMode)
				{
					bHatchClosed = true;  // assume true until known otherwise...
					if ((MyTankM10_ != None) && (MyTankM10_.CommanderPawn != None) &&
						(MyTankM10_.CommanderPawn.Health > 0))
					{
						bHatchClosed = MyTankM10_.CommanderPawn.bHatchFullyClosed;
					}

					if (bIsPlayerOnTank)
						bOnTarget = bIsYawOnTarget;  // more forgiving if player is riding on tank
					else
						bOnTarget = bIsOnTarget;

					if ((bOnTarget) && (bHatchClosed) && (MyTankM10_.fMainGunReFireTime < Level.TimeSeconds))
					{
						MyTankM10_.fMainGunReFireTime = Level.TimeSeconds + MyTankM10_.fMainGunReFireDelay + (FRand() * 2.0);
	
						FireMainGun(false);
					}
					else if (bIsYawOnTarget)
					{
						distance = VSize(MyTankM10Controller.MainGunTarget.Location - MyTankM10_.Location);
						if ((distance < MyTankM10_.VehicleCollisionRadius * 3.0) &&
							(bHatchClosed) && (MyTankM10_.fMainGunReFireTime < Level.TimeSeconds))
						{
							MyTankM10_.fMainGunReFireTime = Level.TimeSeconds + MyTankM10_.fMainGunReFireDelay + (FRand() * 2.0);
	
							FireMainGun(false);
						}
					}
				}
			}
		}
	}
	else
	{
		// no current target...
		bIsOnTarget = false;
		fEnemySpottedTime = -1.0f;

		// have we not seen an enemy in a while?
		if ((!bIsResettingTurret) && ((fEnemyNoneTime + fResetTurretTime) < Level.TimeSeconds) &&
			(!MyTankM10Controller.bIsInScriptedMode) &&
			((MyTankM10_.TurretYaw != 0) || (MyTankM10_.MainGunPitch != 0)))
		{
			Log(name $ "(TankM10MainGunController).Tick() - setting bIsResettingTurret = true", 'Tank');
			bIsResettingTurret = true;  // start rotating the turret back to the forwards position
		}
	}

	if (bIsResettingTurret)
	{
		bIsResettingTurret = ResetTurret(deltaTime);

		if (!bIsResettingTurret && MyTankM10_.WeapUSM10_50calMachineGun.bCameraIsPaused)
		{
			MyTankM10_.WeapUSM10_50calMachineGun.bCameraIsPaused = false;
			MyTankM10_.WeapUSM10_50calMachineGun.MountStartStamp = MyTankM10_.WeapUSM10_50calMachineGun.MountStartStamp +
						 (Level.TimeSeconds - MyTankM10_.WeapUSM10_50calMachineGun.CameraPausedTime);
			MyTankM10_.WeapUSM10_50calMachineGun.MyGunner.ResumeAnim();
		}
	}

}

function int GetNewRotation(int current, int desired, int rate)
{
	local int result;

	result = current & 65535;
	current = result;
	desired = desired & 65535;

	if (current > desired)
	{
		if (current - desired < 32768)
			result -= Min((current - desired), abs(rate));
		else
			result += Min((desired + 65536 - current), abs(rate));
	}
	else
	{
		if (desired - current < 32768)
			result += Min((desired - current), abs(rate));
		else
			result -= Min((current + 65536 - desired), abs(rate));
	}

	return (result & 65535);
}

function bool ResetTurret(float DeltaTime)
{
	local int WorldTurretYaw;
	local int WorldMainGunPitch;
	local float YawRate, PitchRate;
	local rotator TurretRot;
	local rotator MainGunRot;

	if (MyTankM10_ == None)
		return false;

	// convert TurretYaw and MainGunPitch to world space...
	WorldTurretYaw = (MyTankM10_.Rotation.Yaw - MyTankM10_.TurretYaw) & 65535;
	WorldMainGunPitch = (MyTankM10_.Rotation.Pitch + MyTankM10_.MainGunPitch) & 65535;

	YawRate = (MyTankM10_.TurretRotationSpeed * DeltaTime / 360.0) * 65536;
	PitchRate = (MyTankM10_.MainGunRotationSpeed * DeltaTime / 360.0) * 65536;

	WorldTurretYaw = GetNewRotation(WorldTurretYaw, MyTankM10_.Rotation.Yaw, int(YawRate));
	WorldMainGunPitch = GetNewRotation(WorldMainGunPitch, MyTankM10_.Rotation.Pitch, int(PitchRate));

	// convert TurretYaw and MainGunPitch back to local space...
	MyTankM10_.TurretYaw = (MyTankM10_.Rotation.Yaw - WorldTurretYaw) & 65535;
	MyTankM10_.MainGunPitch = (WorldMainGunPitch - MyTankM10_.Rotation.Pitch) & 65535;

	TurretRot.Pitch = MyTankM10_.TurretYaw;
	TurretRot.Yaw = 0;
	TurretRot.Roll = 0;

	MyTankM10_.SetBoneRotation(MyTankM10_.TurretBoneName, TurretRot, 0, 1.0);

	MainGunRot.Pitch = 0;
	MainGunRot.Yaw = -MyTankM10_.MainGunPitch;
	MainGunRot.Roll = 0;

	MyTankM10_.SetBoneRotation(MyTankM10_.MainGunBoneName, MainGunRot, 0, 1.0);

	if ((MyTankM10_.TurretYaw == 0) && (MyTankM10_.MainGunPitch == 0))
	{
		Log(name $ "(TankM10MainGunController).ResetTurret() - rotation done, returning false", 'Tank');
		return false;  // finished rotating
	}

	return true;
}

function TrackMainGunTarget(float DeltaTime, vector TargetAimLoc)
{
	local int WorldTurretYaw;
	local int WorldMainGunPitch;
	local vector MainGunBoneLoc;
	local rotator RotToTarget;
	local float YawRate, PitchRate;
	local int MaxPitchUp, MaxPitchDown;
	local rotator TurretRot;
	local rotator MainGunRot;
	local int PitchDiff, YawDiff;

	if (MyTankM10_ == None)
		return;

	// convert TurretYaw and MainGunPitch to world space...
	WorldTurretYaw = (MyTankM10_.Rotation.Yaw - MyTankM10_.TurretYaw) & 65535;
	WorldMainGunPitch = (MyTankM10_.Rotation.Pitch + MyTankM10_.MainGunPitch) & 65535;

	MainGunBoneLoc = MyTankM10_.GetBoneCoords( MyTankM10_.MainGunBoneName ).origin;
	RotToTarget = rotator(TargetAimLoc - MainGunBoneLoc);

	if (bIsPlayerOnTank)
		YawRate = 0;
	else
		YawRate = (MyTankM10_.TurretRotationSpeed * DeltaTime / 360.0) * 65536;

	PitchRate = (MyTankM10_.MainGunRotationSpeed * DeltaTime / 360.0) * 65536;

	WorldTurretYaw = GetNewRotation(WorldTurretYaw, RotToTarget.Yaw, int(YawRate));
	WorldMainGunPitch = GetNewRotation(WorldMainGunPitch, RotToTarget.Pitch, int(PitchRate));

	PitchDiff = abs((WorldMainGunPitch & 65535) - (RotToTarget.Pitch & 65535));
	if (PitchDiff > 32768)
		PitchDiff = 65536 - PitchDiff;

	YawDiff = abs((WorldTurretYaw & 65535) - (RotToTarget.Yaw & 65535));
	if (YawDiff > 32768)
		YawDiff = 65536 - YawDiff;

	bIsOnTarget = false;  // assume not on target until known otherwise
	bIsYawOnTarget = false;

	// is the gun aimed close enough to the target?
	if ((YawDiff < 500) && (PitchDiff < 500))
	{
		bIsOnTarget = true;  // gun is "on target", start shooting
	}

	if (YawDiff < 800)
	{
		bIsYawOnTarget = true;
	}

	if (bIsPlayerOnTank)
	{
		// does the tank need to rotate to aim the main gun at the enemy?...
		if (YawDiff >= 500)
		{
			// request the tank to rotate towards the target...
			MyTankM10Controller.RotateTowardTarget(MyTankM10Controller.MainGunTarget, true);
		}
	}

	// convert TurretYaw and MainGunPitch back to local space...
	MyTankM10_.TurretYaw = (MyTankM10_.Rotation.Yaw - WorldTurretYaw) & 65535;
	MyTankM10_.MainGunPitch = (WorldMainGunPitch - MyTankM10_.Rotation.Pitch) & 65535;

	MaxPitchUp = int((MyTankM10_.MainGunUpwardFireArc / 360.0) * 65536.0);
	MaxPitchDown = int((MyTankM10_.MainGunDownwardFireArc / 360.0) * 65536.0);

	if (MyTankM10_.MainGunPitch > 32767)
		MyTankM10_.MainGunPitch = MyTankM10_.MainGunPitch - 65536;

	MyTankM10_.MainGunPitch = Clamp(MyTankM10_.MainGunPitch, -MaxPitchDown, MaxPitchUp);

	// for cases where gun has reached max pitch up/down, fire if yaw is on target and pitch is within 10 degrees of target...
	if ((YawDiff < 500) && ((MyTankM10_.MainGunPitch == -MaxPitchDown) || (MyTankM10_.MainGunPitch == MaxPitchUp)) &&
		(PitchDiff < 1820))
	{
		bIsOnTarget = true;  // gun is "on target", start shooting
	}

	TurretRot.Pitch = MyTankM10_.TurretYaw;
	TurretRot.Yaw = 0;
	TurretRot.Roll = 0;

	MyTankM10_.SetBoneRotation(MyTankM10_.TurretBoneName, TurretRot, 0, 1.0);

	MainGunRot.Pitch = 0;
	MainGunRot.Yaw = -MyTankM10_.MainGunPitch;
	MainGunRot.Roll = 0;

	MyTankM10_.SetBoneRotation(MyTankM10_.MainGunBoneName, MainGunRot, 0, 1.0);
}

function Rotator AdjustAimNewTankShell( Ammunition Ammo, Vector ProjStart, Rotator AimRotator, InstantFire MyInstantFire, optional out int bSkipDoTrace )
{
	local float DistToTarget;
	local int index;
	local bool bCheckNoDamage;

	// check if the enemy is not a tank...
	if ((Enemy != None) && (!Enemy.IsA('Tank')))
	{
		bCheckNoDamage = false; // assume false until known otherwise

		index = FindTargetInQueue( Enemy );

		// check if the enemy is a "hard" target (Pak36 gunner, Panzerfaust soldier, etc)...
		if ( (index >= 0) && (TargetQueue[index].bIsHardTarget == 1) )
			bCheckNoDamage = true;

		// check if the enemy is manning a machine gun...
		if ( !bCheckNoDamage && (gbxPawn(Enemy) != None) && (gbxPawn(Enemy).bIsManningTurret) )
			bCheckNoDamage = true;

		if (bCheckNoDamage)
		{
			DistToTarget = VSize( Enemy.Location - MyTank.Location );

			// Is this a deadlock situation?
			if ( DistToTarget > MainGunDoNoDamageRange )
			{
				MyTankM10_.MainGunFireMode.bIgnoreDamageThisBullet = true;
			}
		}
	}

	return Super.AdjustAimNewTankShell(Ammo, ProjStart, AimRotator, MyInstantFire, bSkipDoTrace);
}

function FireMainGun(bool bDoNoDamage)
{
	local vector MainGunLoc;
	local rotator MainGunRot;
	local vector RotX, RotY, RotZ;
	local int AimErrorLocal;
	local rotator AdjustedAim;
	local int bSkipDoTrace;
	local gbxTankShell TankShell;

	if (!bDoNoDamage)
		MyTankM10_.MainGunFireMode.bIgnoreDamageThisBullet = false;

	MainGunLoc = MyTankM10_.GetTagCoords( MyTankM10_.MainGunMuzzleBoneName ).origin;

	MainGunRot.Pitch = MyTankM10_.MainGunPitch;
	MainGunRot.Yaw = -MyTankM10_.TurretYaw;
	MainGunRot.Roll = 0;

	MainGunRot = MyTankM10_.Rotation + MainGunRot;

    GetAxes(MainGunRot,RotX,RotY,RotZ);

	MainGunLoc = MainGunLoc + MyTankM10_.MainGunEmitterOffset.X * RotX + MyTankM10_.MainGunEmitterOffset.Y * RotY + MyTankM10_.MainGunEmitterOffset.Z * RotZ;

	MainGunRot.Pitch = 0;  // ignore main gun pitch for main gun smoke and dust emitter
	MainGunRot.Yaw = -MyTankM10_.TurretYaw;
	MainGunRot.Roll = 0;

	MainGunRot = MyTankM10_.Rotation + MainGunRot;

	// spawn main gun smoke and dust emitter...
	spawn(MyTankM10_.MainGunSmokeEmitterClass, None,, MainGunLoc, MainGunRot);

	AimErrorLocal = AimErrorAIMain;

	AdjustedAim = MyTankM10_.AdjustAimMainGun();

	ApplyAccuracy( AdjustedAim, AimErrorAIMain );

	AdjustedAim = AdjustAimNewTankShell(MyTankM10_.MainGunAmmo, MainGunLoc, AdjustedAim, MyTankM10_.MainGunFireMode, bSkipDoTrace);

	// spawn main gun muzzle flash emitter...
	spawn(MyTankM10_.MainGunFlashEmitterClass, None,, MainGunLoc, AdjustedAim);

	if (MyTankM10_.MainGunFireMode.bIgnoreDamageThisBullet)
	{
		Log(name $ ".FireMainGun - bIgnoreDamageThisBullet was True, doing no damage", 'Tank');
		bDoNoDamage = true;
	}

	TankShell = Spawn( class'gbxTankShell', MyTankM10_,, MainGunLoc, AdjustedAim );
	TankShell.Instigator = MyTankM10_;
	if (bDoNoDamage)
		TankShell.Damage = 0.0f;

	MyTankM10_.PlaySoundCue( MyTankM10_.MainGunFireSound, SLOT_NONE, TransientSoundVolume,,,,false);

	MyTankM10_.PlayMainGunFiringAnim(MyTankM10_.TurretYaw);

	if (MyTankM10_.M10LoaderPawn != None)
		MyTankM10_.M10LoaderPawn.GotoState('FireThenReload');
}


defaultproperties
{
	PeripheralVisionWithCommander=-0.7071  // +/- 135 degrees (270 degrees total)
	PeripheralVisionWithoutCommander=0.0  // +/- 90 degrees (180 degrees total)

	bIsOnTarget=false

	fResetTurretTime=5.0  // if no enemy, start resetting the turret after 5.0 seconds

	TargetPriorityScalarInfantryGroup=0.8

	bLogPriority=false

	AimErrorAIMain=50

	BulletDoNoDamageRange=5000.0

	bDoesPurposefulMiss=false

	TargetForgetTimeLong=30.0f
	TargetForgetTimeShort=15.0f

	ReactionTimeMin=0.2
	ReactionTimeMax=0.5
	ReactionTimeMinEasy=0.2
	ReactionTimeMaxEasy=0.5
	ReactionTimeMinNormal=0.2
	ReactionTimeMaxNormal=0.5
	ReactionTimeMinHard=0.5
	ReactionTimeMaxHard=1.0
	ReactionTimeMinAuthentic=2.0
	ReactionTimeMaxAuthentic=3.0

	PurposefulMissTimeStart=20.0
	PurposefulMissTimeBonus=5.0
	PurposefulMissTimeMax=30.0
	PurposefulMissTimeStartEasy=10.0
	PurposefulMissTimeBonusEasy=5.0
	PurposefulMissTimeMaxEasy=20.0
	PurposefulMissTimeStartNormal=15.0
	PurposefulMissTimeBonusNormal=5.0
	PurposefulMissTimeMaxNormal=20.0
	PurposefulMissTimeStartHard=20.0
	PurposefulMissTimeBonusHard=5.0
	PurposefulMissTimeMaxHard=30.0
	PurposefulMissTimeStartAuthentic=20.0
	PurposefulMissTimeBonusAuthentic=5.0
	PurposefulMissTimeMaxAuthentic=30.0
}
class TankMarderController extends TankControllerGerman
	notplaceable;


var()	TankMarder					MyTankMarder;
var()	TankMarderMainGunController	MyMainGunController;

// enemy targeting stuff...
var()	Actor	MainGunTarget;


function Possess(Pawn aPawn)
{
	Log( name $ ".(TankMarderController).Possess( " $ aPawn.name $ " )", 'Tank' );

	Super.Possess(aPawn);

	if ((aPawn == None) || (TankMarder(aPawn) == None))
	{
		Log(name $ ".Possess() - WARNING! TankMarderController's Pawn is NOT a TankMarder!!!");
	}
	else
	{
		MyTankMarder = TankMarder(aPawn);

		MyMainGunController = spawn(class'TankMarderMainGunController', self);
		if (MyMainGunController == None)
			Log( name $ ".(TankMarderController).Possess() - ERROR Spawning TankMarderMainGunController!!!", 'Tank' );
		else
			MyMainGunController.Possess(MyTankMarder, self);

		if (bTargetForgetTimeOverride)
		{
			MyMainGunController.TargetForgetTimeLong = TargetForgetTime;
			MyMainGunController.TargetForgetTimeShort = TargetForgetTime;
		}
	}
}

function Destroyed()
{
	Log( name $ ".(TankMarderController).Destroyed()", 'Tank' );

	if (MyMainGunController != None)
		MyMainGunController.Destroy();

	super.Destroyed();
}

function Timer()
{
	Super.Timer();

	if (fPauseMovementCheckTime < Level.TimeSeconds)
	{
		fPauseMovementCheckTime = Level.TimeSeconds + 2.0f;

		bPauseMovement = false;  // stop moving and attack enemy from here

		if ( (MyMainGunController != None) && MyMainGunController.ShouldTankPause() )
		{
			bPauseMovement = true;  // stop moving and attack enemy from here
		}
	}
}

function PawnDied(Pawn P)
{
	Log( name $ ".(TankMarderController).PawnDied()", 'Tank' );

	Super.PawnDied(P);
}

function NotifyTakeHit(pawn InstigatedBy, vector HitLocation, int Damage, class<DamageType> damageType, vector Momentum)
{
//	Log( name $ "(" $ Pawn.name $ ").NotifyTakeHit( " $ InstigatedBy.name $ " )", 'Tank' );

	if (bIsInScriptedMode)
		return;  // don't do anything if under scripted control

	if (MyMainGunController != None)
		MyMainGunController.NotifyTakeHit(InstigatedBy, HitLocation, Damage, damageType, Momentum);

	Super.NotifyTakeHit( InstigatedBy, HitLocation, Damage, damageType, Momentum );
}

function SeePawn( Pawn Seen )
{
//	Log( name $ "(" $ Pawn.name $ ").SeePawn( " $ Seen.name $ " )", 'Tank' );

	if (bIsInScriptedMode)
		return;  // don't do anything if under scripted control

	if (MyMainGunController != None)
		MyMainGunController.SeePawn(Seen);

	Super.SeePawn(Seen);
}

function SeePawnKilled( Pawn Seen, Pawn Killer )
{
//	Log( name $ "(" $ Pawn.name $ ").SeePawnKilled( " $ Seen.name $ " )", 'Tank' );

	if (bIsInScriptedMode)
		return;  // don't do anything if under scripted control

	// Seeing your friends get killed.
	if (MyMainGunController != None)
		MyMainGunController.SeePawnKilled(Seen, Killer);

	Super.SeePawnKilled(Seen, Killer);
}

function SeePawnHit( Pawn Seen )
{
//	Log( name $ "(" $ Pawn.name $ ").SeePawnHit( " $ Seen.name $ " )", 'Tank' );

	if (bIsInScriptedMode)
		return;  // don't do anything if under scripted control

	if (MyMainGunController != None)
		MyMainGunController.SeePawnHit(Seen);

	Super.SeePawnHit(Seen);
}

function HearNoise( float Loudness, Actor NoiseMaker )
{
//	Log( name $ "(" $ Pawn.name $ ").HearNoise( " $ Loudness $ ", " $ NoiseMaker.name $ " )", 'Tank' );

	if (bIsInScriptedMode)
		return;  // don't do anything if under scripted control

	if (MyMainGunController != None)
		MyMainGunController.HearNoise(Loudness, NoiseMaker);

	Super.HearNoise(Loudness, NoiseMaker);
}

function SeePlayer( Pawn Seen )
{
//	Log( name $ "(" $ Pawn.name $ ").SeePlayer( " $ Seen.name $ " )", 'Tank' );

	if (bIsInScriptedMode)
		return;  // don't do anything if under scripted control

	if (MyMainGunController != None)
		MyMainGunController.SeePlayer(Seen);

	Super.SeePlayer(Seen);
}

function SeeExplosion( Pawn Instigator )
{
//	Log( name $ "(" $ Pawn.name $ ").SeeExplosion( " $ Instigator.name $ " )", 'Tank' );

	if (bIsInScriptedMode)
		return;  // don't do anything if under scripted control

	// Seeing shit get blown up.
	if (MyMainGunController != None)
		MyMainGunController.SeeExplosion(Instigator);

	Super.SeeExplosion(Instigator);
}

function NotifyTargetOrder(Unit targetUnit)
{
	local int i;

	// notify this member about all Targets in the targetUnit...
	for (i = 0; i < targetUnit.NumMembers; i++)
	{
		if (MyMainGunController != None)
			MyMainGunController.AddTarget( targetUnit.Members[i] );
	}
}

function NotifyAssaultOrder(Unit targetUnit)
{
	local int i;

	// notify this member about all Targets in the targetUnit...
	for (i = 0; i < targetUnit.NumMembers; i++)
	{
		if (MyMainGunController != None)
			MyMainGunController.AddTarget( targetUnit.Members[i] );
	}
}

function ConsiderPossibleEnemy( Pawn possibleEnemy )
{
	if (bIsInScriptedMode)
		return;  // don't do anything if under scripted control

	if (MyMainGunController != None)
		MyMainGunController.ConsiderPossibleEnemy(possibleEnemy, false);
}

event float GetTargetExposureToMe( Pawn aThreat )
{
	return MyMainGunController.GetTargetExposureToMe(aThreat);
}

function bool EnemiesAreRecentlyVisible()
{
	if (bIsInScriptedMode)
		return false;  // don't do anything if under scripted control

	if (MyMainGunController.EnemiesAreRecentlyVisible())
		return true;

	return false;
}

function bool NoEnemiesVisibleForAWhile()
{
	if (bIsInScriptedMode)
		return true;  // don't do anything if under scripted control

	if (MyMainGunController != None)
	{
		if (!MyMainGunController.NoEnemiesVisibleForAWhile())
			return false;
	}

	return true;
}

function gbxPawn GetHuntingEnemy(out vector LastKnownLocation, out vector FirstHiddenLocation)
{
	local gbxPawn HuntingEnemy;

	if (MyMainGunController != None)
	{
		HuntingEnemy = MyMainGunController.GetHuntingEnemy(LastKnownLocation, FirstHiddenLocation);

		if (HuntingEnemy != None)
			return HuntingEnemy;
	}

	return None;
}

function ResetTurret(float DeltaTime)
{
	// nothing to do
}

function Rotator GetMainGunWorldRotation()
{
	local rotator GunRotation;

	GunRotation.Pitch = MyTankMarder.Rotation.Pitch + MyTankMarder.MainGunPitch;
	GunRotation.Yaw = MyTankMarder.Rotation.Yaw;
	GunRotation.Roll = 0;

	return GunRotation;
}

function HandleTrackingTarget(float DeltaTime)
{
	if ( bIsPausing )
	{
		if (PauseTime > Level.Timeseconds)
			return;

		bIsPausing = false;
	}

	MyMainGunController.TrackMainGunTarget(DeltaTime, TargetAimLocation);

	if (MyMainGunController.bIsYawOnTarget)
	{
		if (bIsRotatingToTheLeft)
		{
			bIsRotatingToTheLeft = false;

			RotationYawDelta = (CenteredYawRotation + (LookingForEnemyRotateYawMax * 65536.0 / 360.0)) & 65535;

			TempRot = MyTank.Rotation;
			TempRot.Yaw = RotationYawDelta;

			TargetAimLocation = MyTank.Location + Vector(TempRot) * 1000.0f;
		}
		else
		{
			bIsRotatingToTheLeft = true;

			RotationYawDelta = (CenteredYawRotation - (LookingForEnemyRotateYawMax * 65536.0 / 360.0)) & 65535;

			TempRot = MyTank.Rotation;
			TempRot.Yaw = RotationYawDelta;

			TargetAimLocation = MyTank.Location + Vector(TempRot) * 1000.0f;
		}

		bIsPausing = true;
		PauseTime = Level.TimeSeconds + 0.5 + FRand() * 0.3;
	}
}

function HandleGrenadePlanted(float DeltaTime)
{
	MyMainGunController.TrackMainGunTarget(DeltaTime, TargetAimLocation);

	if (MyMainGunController.bIsYawOnTarget)
	{
		if (bIsRotatingToTheLeft)
		{
			bIsRotatingToTheLeft = false;

			RotationYawDelta = (CenteredYawRotation + (GrenadePlantedRotateYawMax * 65536.0 / 360.0)) & 65535;

			TempRot = MyTank.Rotation;
			TempRot.Yaw = RotationYawDelta;

			TargetAimLocation = MyTank.Location + Vector(TempRot) * 1000.0f;
		}
		else
		{
			bIsRotatingToTheLeft = true;

			RotationYawDelta = (CenteredYawRotation - (GrenadePlantedRotateYawMax * 65536.0 / 360.0)) & 65535;

			TempRot = MyTank.Rotation;
			TempRot.Yaw = RotationYawDelta;

			TargetAimLocation = MyTank.Location + Vector(TempRot) * 1000.0f;
		}
	}
}

function bool TankHasEnemy()
{
	if (MyMainGunController != None)
	{
		if (MyMainGunController.ndxEnemyInQueue >= 0)
			return true;
	}

	return false;
}


defaultproperties
{
	LookingForEnemyRotateYawMax=15.0  // in degrees
	GrenadePlantedRotateYawMax=10.0  // in degrees
}
class TankMarderMainGunController extends TankGunController
	notplaceable;


var()	TankMarder			MyTankMarder;
var()	TankMarderController	MyTankMarderController;

// weapon targeting stuff...
var()	bool	bIsOnTarget;
var()	bool	bIsYawOnTarget;

var()	float	fEnemySpottedTime;	// when we first saw the enemy
var()	float	fEnemyNoneTime;		// time when enemy was last set to None
var()	float	fResetMainGunTime;	// how long after enemy = none to reset turret back to facing fowards
var()	bool	bIsResettingMainGun;

var()	float	fMainGunFireDelay;	// short delay between "on target/ready to fire" and "fire gun"
var()	float	fMainGunFireTime;

var(Target)	float TargetPriorityScalarInfantryGroup;

var()	int		AimErrorAI;
var()	int		AimErrorAINormal;
var()	int		AimErrorAIBefuddled;

var()	bool	bLogPriority;


function Possess(Tank aPawn, TankController aController)
{
	Log( name $ ".(TankMarderMainGunController).Possess( " $ aPawn.name $ " " $ aController.name $ " )", 'Tank' );

	if (TankMarder(aPawn) == None)
	{
		Log(name $ ".Possess - aPawn (" $ aPawn.name $ ") is NOT a TankMarder!!!");
		return;
	}

	if (TankMarderController(aController) == None)
	{
		Log(name $ ".Possess - aController (" $ aController.name $ ") is NOT a TankMarderController!!!");
		return;
	}

	Super.Possess(aPawn, aController);

	MyTankMarder = TankMarder(aPawn);
	MyTankMarderController = TankMarderController(aController);

	fEnemyNoneTime = 0.0f;
	fEnemySpottedTime = -1.0f;  // enemy not spotted yet
	fMainGunFireTime = -1.0f;
}

function Timer()
{
//	Log( name $ ".(TankMarderMainGunController).Timer()", 'Tank' );

	if (MyTankMarderController.bIsInScriptedMode)
	{
		Super.Timer();
		return;
	}

	PeripheralVision = PeripheralVisionWithoutCommander;  // default to vision without tank commander

	if (MyTankMarder != None)
	{
		if (!MyTankMarder.bSpawnCommander)  // if tank was spawned without a commander, use same vision as if had a commander...
		{
			PeripheralVision = PeripheralVisionWithCommander;
		}
		else if ((MyTankMarder.CommanderPawn != None) && (MyTankMarder.CommanderPawn.Health > 0))
		{
			PeripheralVision = PeripheralVisionWithCommander;
		}
	}

	if ((MyTankMarderController.BefuddledEndTime > 0.0) && (MyTankMarderController.BefuddledEndTime < Level.TimeSeconds))
	{
		AimErrorAI = AimErrorAIBefuddled;
	}
	else
	{
		AimErrorAI = AimErrorAINormal;
	}

	Super.Timer();
}

function SeePawn( Pawn Seen )
{
	local Rotator GunRotation;

//	Log( name $ ".(TankMarderMainGunController-"$MyTank.name$").SeePawn( " $ Seen.name $ " )", 'Tank' );

	if (MyTankController.bNoEnemies)
		return;  // don't target or shoot at any enemies

	if ( MyTankController.bNoTargetPlayer && Seen.IsPlayerPawn() )
		return;  // don't target or shoot at player

	GunRotation.Pitch = MyTankMarder.Rotation.Pitch;
	GunRotation.Yaw = MyTankMarder.Rotation.Yaw;
	GunRotation.Roll = 0;

	if (TankGunControllerCanSee(GunRotation, Seen))
		ConsiderPossibleEnemy( Seen, true );
}

function HearNoise( float Loudness, Actor NoiseMaker )
{
//	Log( name $ ".(TankMarderMainGunController-"$MyTank.name$").HearNoise( " $ Loudness $ " " $ NoiseMaker.name $ " )", 'Tank' );

	if (MyTankController.bNoEnemies)
		return;  // don't target or shoot at any enemies

	if ( MyTankController.bNoTargetPlayer && Pawn(NoiseMaker).IsPlayerPawn() )
		return;  // don't target or shoot at player

	if( NoiseMaker.IsA( 'Pawn' ))
	{
		// TODO do uncertainty.
		if ( MyTankController.bNoTargetPlayer && Pawn(NoiseMaker).IsPlayerPawn() )
			return;  // don't target or shoot at player

		ConsiderPossibleEnemy( Pawn( NoiseMaker ), true );
	}
}

function bool SetEnemy( Actor newEnemy )
{
	bIsOnTarget = false;
	return Super.SetEnemy( newEnemy );
}

event AdjustTargetPriority(int index)
{
	local gbxPawn Target;
	local float priority, weights, delta_priority;
	local vector vDir, vForward;
	local rotator MainGunRot;
	local float dotTheta;
	local int NearbyTargets;

	Target = TargetQueue[index].Target;

	// recalculate the priority and weights from the native CalculateTargetPriority() function...
	priority = TargetQueue[index].TargetPriority * TargetQueue[index].TargetTotalWeight;
	weights = TargetQueue[index].TargetTotalWeight;

	// give higher priority to targets that are in the direction that the gun is already facing...
	vDir = Normal(Target.Location - MyTankMarder.Location);
	MainGunRot.Pitch = (MyTankMarder.Rotation.Pitch + MyTankMarder.MainGunPitch) & 65535;
	MainGunRot.Yaw = MyTankMarder.Rotation.Yaw & 65535;
	MainGunRot.Roll = 0;
	vForward = Vector(MainGunRot);

	dotTheta = (vDir dot vForward);  // 1.0 to -1.0
	dotTheta = (dotTheta / 2.0) + 0.5;  // 1.0 to 0.0

	delta_priority = dotTheta * TargetPriorityScalarInAimingDirection;
	if (bLogPriority)
		Log(name $ ".AdjustTargetPriority: Target " $ Target.name $ " - InAimingDirection priority = " $ delta_priority, 'Tank');
	priority += delta_priority;
	weights += TargetPriorityScalarInAimingDirection;

	// check what type of target this is (or what type of weapon the target is carrying)...

	if (Target.IsA('gbxSVehicle'))  // is this target a vehicle?
	{
		// give higher priority to enemy vehicles (tanks, trucks, jeeps, etc)...
		delta_priority = TargetPriorityScalarEnemyVehicle;
		if (bLogPriority)
			Log(name $ ".AdjustTargetPriority: Target " $ Target.name $ " - EnemyVehicle priority = " $ delta_priority, 'Tank');
		priority += delta_priority;
		weights += TargetPriorityScalarEnemyVehicle;
		TargetQueue[index].bUseCannon = 1;  // use the cannon to fire at this/these target(s)
	}

//	if (Target.IsA('MachineGun'))
//	{
//		if (bLogPriority)
//			Log(name $ ".AdjustTargetPriority: Target " $ Target.name $ " is a manned machine gun", 'Tank');
//		TargetQueue[index].bUseCannon = 1;  // use the cannon to fire at this/these target(s)
//	}

//	if (Target.IsA('Infantry'))
//	{
//		// check what weapon this infantry soldier is carrying...
//		if (Target.Weapon.IsA('USBazooka'))
//		{
//			if (bLogPriority)
//				Log(name $ ".AdjustTargetPriority: Target " $ Target.name $ " is a soldier carrying an anti-tank weapon", 'Tank');
//			TargetQueue[index].bUseCannon = 1;  // use the cannon to fire at this/these target(s)
//		}
//	}

	if (Target.IsA('Infantry'))
	{
		// check to see if this infantry target is close to at least 2 other infantry targets...
		NearbyTargets = GetNumberOfNearbyInfantryTargets(Target);

		if (NearbyTargets >= 2)
		{
			// give higher priority to infantry targets that are in groups of 3 or more
			delta_priority = TargetPriorityScalarInfantryGroup;
			if (bLogPriority)
				Log(name $ ".AdjustTargetPriority: Target " $ Target.name $ " - InfantryGroup priority = " $ delta_priority, 'Tank');
			priority += delta_priority;
			weights += TargetPriorityScalarInfantryGroup;
			TargetQueue[index].bUseCannon = 1;  // use the cannon to fire at this/these target(s)
		}
	}

	priority = FClamp(priority, 0.0, priority);
	TargetQueue[index].TargetTotalWeight = weights;
	TargetQueue[index].TargetPriority = priority / weights;

	if (bLogPriority)
		Log(name $ ".AdjustTargetPriority: Target " $ Target.name $ " - final priority = " $ TargetQueue[index].TargetPriority, 'Tank');
}

function ReassignTargets()
{
	local int index;
	local gbxPawn Target;
	local float bestPriority;

	if (ndxEnemyInQueue < 0)  // no targets in queue?
		return;

	for (index = 0; index < TargetQueue.Length; index++)
	{
		Target = TargetQueue[index].Target;
	}

	ndxEnemyInQueue = -1;
	bestPriority = 0.0f;

	for (index = 0; index < TargetQueue.Length; index++)
	{
		if (TargetQueue[index].RelegationTime > Level.TimeSeconds)
			continue;

		if ((ndxEnemyInQueue == -1) || (TargetQueue[index].TargetPriority > bestPriority))
		{
			ndxEnemyInQueue = index;
			bestPriority = TargetQueue[index].TargetPriority;
		}
	}
}

event vector GetGunControllerRotation()
{
	local Rotator GunRotation;

	GunRotation.Pitch = MyTankMarder.Rotation.Pitch + MyTankMarder.MainGunPitch;
	GunRotation.Yaw = MyTankMarder.Rotation.Yaw;
	GunRotation.Roll = 0;

	return vector(GunRotation);
}

function Tick( float deltaTime )
{
	local int IsHeadShot;
	local vector SuppressLoc, FailLoc;
	local bool bCanSeePawn;
	local vector TargetAimLoc;
	local vector aim_offset;
	local float ReactionTimeDelta;
	local float distance;

	Super.Tick( deltaTime );

	if (MyTankMarderController == None)
		return;

	if (Enemy == None)
	{
		if (MyTankMarderController.MainGunTarget != None)
		{
			fEnemyNoneTime = Level.TimeSeconds;

			MyTankMarderController.MainGunTarget = None;
			MyTankMarderController.bRotateToFaceEnemy = false;
			MyTankMarderController.EnemyRotateToFace = None;
		}
	}
	else
	{
		if ((!MyTankMarderController.bIsInScriptedMode) &&
			((fEnemySpottedTime < 0) || (MyTankMarderController.MainGunTarget != Enemy)))
		{
			fEnemySpottedTime = Level.TimeSeconds;

			// have we NOT seen a target within the last 5 seconds?
			if (fGunReactionTime + 5.0 < Level.TimeSeconds)
			{
				// long reaction time, tank is not quite as aware...
				ReactionTimeDelta = ReactionTimeMax - ReactionTimeMin;
				fGunReactionTime = Level.TimeSeconds + ReactionTimeMin + (FRand() * ReactionTimeDelta);
			}
			else
			{
				// short reaction time, tank recently had an enemy and is more aware...
				fGunReactionTime = Level.TimeSeconds + 0.5 + (FRand() * 0.5f);
			}

			Log(name $ ".Tick() - MainGun Enemy " $ Enemy.name $ " spotted at " $ Level.TimeSeconds $ "  reaction time = " $ fGunReactionTime, 'Tank');

			MyTankMarderController.MainGunTarget = Enemy;

			// does the tank need to rotate it's front to face this enemy (armor stronger at front)?
			if (Enemy.IsA('gbxSVehicle'))
			{
				MyTankMarderController.bRotateToFaceEnemy = true;
				MyTankMarderController.EnemyRotateToFace = Enemy;
			}
			else
			{
				MyTankMarderController.bRotateToFaceEnemy = false;
				MyTankMarderController.EnemyRotateToFace = None;
			}
		}
	}

	if ((MyTankMarderController.bRotateToFaceEnemy) && (MyTankMarderController.EnemyRotateToFace != None))
	{
		if (!MyTankMarderController.bIsInScriptedMode)
		{
			bCanSeePawn = MyTankController.CanSeeOrSuppress(Pawn(MyTankMarderController.MainGunTarget), SeeLoc, IsHeadShot, SuppressLoc, FailLoc);
		}
		else
		{
			bCanSeePawn = true;
			SeeLoc = MyTankMarderController.EnemyRotateToFace.Location;
		}

		// is main gun target visible?, if so, rotate front armor to face target...
		if ((bCanSeePawn) &&
			((SeeLoc.X != 0.0) && (SeeLoc.Y != 0.0) && (SeeLoc.Z != 0.0)))
		{
			// don't need to do this if navigating, the TankController navigation code will do this for us...
			if (!MyTankMarderController.bIsNavigating)
			{
				MyTankMarderController.RotateTowardTarget(MyTankMarderController.EnemyRotateToFace);
			}
		}
	}

	if (MyTankMarderController.MainGunTarget != None)
	{
		bIsResettingMainGun = false;

		if ((fGunReactionTime < Level.TimeSeconds) &&
			(MyTankMarderController.GetStateName() != 'Hunting') &&
			(MyTankMarderController.GetStateName() != 'GrenadePlanted') &&
			(MyTankMarderController.GetStateName() != 'Panicked'))
		{
			if (!MyTankMarderController.bIsInScriptedMode)
			{
				bCanSeePawn = MyTankController.CanSeeOrSuppress(Pawn(MyTankMarderController.MainGunTarget), SeeLoc, IsHeadShot, SuppressLoc, FailLoc);
			}
			else
			{
				bCanSeePawn = true;
				SeeLoc = MyTankMarderController.MainGunTarget.Location;
			}

			if (bCanSeePawn)
			{
				if (MyTankMarderController.MainGunTarget.IsA( 'Infantry' ))  // is target an infantry soldier?
				{
					// aim for the feet...
					aim_offset = vect(0,0,0);
					aim_offset.Z = MyTankMarderController.MainGunTarget.CollisionHeight;
					TargetAimLoc = SeeLoc - aim_offset;
				}
				else
				{
					// aim slightly below the center (Location) of target...
					aim_offset = vect(0,0,0);
					aim_offset.Z = MyTankMarderController.MainGunTarget.CollisionHeight / 2.0f;
					TargetAimLoc = SeeLoc - aim_offset;
				}

				if ((SeeLoc.X == 0.0) && (SeeLoc.Y == 0.0) && (SeeLoc.Z == 0.0))
				{
//					TargetAimLoc = SuppressLoc;
					TargetAimLoc = TargetQueue[ndxEnemyInQueue].LastKnownLocation;
				}

				TrackMainGunTarget(DeltaTime, TargetAimLoc, true);  // track using the main gun
	
				if ((bIsOnTarget) && (MyTankMarder.fMainGunReFireTime < Level.TimeSeconds) && (fMainGunFireTime < 0))
				{
					fMainGunFireTime = Level.TimeSeconds + fMainGunFireDelay;
				}
				else
				{
					distance = VSize(MyTankMarderController.MainGunTarget.Location - MyTankMarder.Location);
					if ((distance < MyTankMarder.VehicleCollisionRadius * 3.0) &&
						(MyTankMarder.fMainGunReFireTime < Level.TimeSeconds) && (fMainGunFireTime < 0))
					{
						fMainGunFireTime = Level.TimeSeconds + fMainGunFireDelay;
					}
				}
			}
			else
			{
				fMainGunFireTime = -1.0;  // can't see the 
			}

			if (!MyTankMarderController.bIsInScriptedMode)
			{
				// time to fire the main gun yet?
				if ((fMainGunFireTime > 0.0) && (fMainGunFireTime < Level.TimeSeconds))
				{
					MyTankMarder.fMainGunReFireTime = Level.TimeSeconds + MyTankMarder.fMainGunReFireDelay + (FRand() * 2.0);
	
					FireMainGun(false);

					fMainGunFireTime = -1.0;
				}
			}
		}
	}
	else
	{
		// no current target...
		bIsOnTarget = false;
		fEnemySpottedTime = -1.0f;
		fMainGunFireTime = -1.0;

		// have we not seen an enemy in a while?
		if ((!bIsResettingMainGun) && ((fEnemyNoneTime + fResetMainGunTime) < Level.TimeSeconds) &&
			(!MyTankMarderController.bIsInScriptedMode) &&
			(MyTankMarder.MainGunPitch != 0))
		{
			if ((MyTankMarderController.GetStateName() != 'Hunting') &&
				(MyTankMarderController.GetStateName() != 'GrenadePlanted') &&
				(MyTankMarderController.GetStateName() != 'Panicked'))
			{
				Log(name $ "(TankMarderMainGunController).Tick() - setting bIsResettingMainGun = true", 'Tank');
				bIsResettingMainGun = true;  // start rotating the turret back to the forwards position
			}
		}

		if (bIsResettingMainGun)
			bIsResettingMainGun = ResetMainGun(DeltaTime);
	}
}

function int GetNewRotation(int current, int desired, int rate)
{
	local int result;

	result = current & 65535;
	current = result;
	desired = desired & 65535;

	if (current > desired)
	{
		if (current - desired < 32768)
			result -= Min((current - desired), abs(rate));
		else
			result += Min((desired + 65536 - current), abs(rate));
	}
	else
	{
		if (desired - current < 32768)
			result += Min((desired - current), abs(rate));
		else
			result -= Min((current + 65536 - desired), abs(rate));
	}

	return (result & 65535);
}

function bool ResetMainGun(float DeltaTime)
{
	local int WorldMainGunPitch;
	local float PitchRate;
	local rotator MainGunRot;

	if (MyTankMarder == None)
		return false;

	// convert TurretYaw and MainGunPitch to world space...
	WorldMainGunPitch = (MyTankMarder.Rotation.Pitch + MyTankMarder.MainGunPitch) & 65535;

	PitchRate = (MyTankMarder.MainGunRotationSpeed * DeltaTime / 360.0) * 65536;

	WorldMainGunPitch = GetNewRotation(WorldMainGunPitch, MyTankMarder.Rotation.Pitch, int(PitchRate));

	// convert MainGunPitch back to local space...
	MyTankMarder.MainGunPitch = (WorldMainGunPitch - MyTankMarder.Rotation.Pitch) & 65535;

	MainGunRot.Pitch = 0;
	MainGunRot.Yaw = MyTankMarder.MainGunPitch;
	MainGunRot.Roll = 0;

	MyTankMarder.SetBoneRotation(MyTankMarder.MainGunBoneName, MainGunRot, 0, 1.0);

	if (MyTankMarder.MainGunPitch == 0)
	{
		Log(name $ "(TankMarderMainGunController).ResetMainGun() - rotation done, returning false", 'Tank');
		return false;  // finished rotating
	}

	return true;
}

function TrackMainGunTarget(float DeltaTime, vector TargetAimLoc, optional bool bUseMainGunTarget)
{
	local int WorldMainGunPitch;
	local vector MainGunBoneLoc;
	local rotator RotToTarget;
	local float PitchRate;
	local int MaxPitchUp, MaxPitchDown;
	local rotator MainGunRot;
	local int PitchDiff, YawDiff;

	if (MyTankMarder == None)
		return;

	// convert MainGunPitch to world space...
	WorldMainGunPitch = (MyTankMarder.Rotation.Pitch + MyTankMarder.MainGunPitch) & 65535;

	MainGunBoneLoc = MyTankMarder.GetBoneCoords( MyTankMarder.MainGunBoneName ).origin;
	RotToTarget = rotator(TargetAimLoc - MainGunBoneLoc);

	PitchRate = (MyTankMarder.MainGunRotationSpeed * DeltaTime / 360.0) * 65536;

	WorldMainGunPitch = GetNewRotation(WorldMainGunPitch, RotToTarget.Pitch, int(PitchRate));

	PitchDiff = abs((WorldMainGunPitch & 65535) - (RotToTarget.Pitch & 65535));
	if (PitchDiff > 32768)
		PitchDiff = 65536 - PitchDiff;

	YawDiff = abs((MyTankMarder.Rotation.Yaw & 65535) - (RotToTarget.Yaw & 65535));
	if (YawDiff > 32768)
		YawDiff = 65536 - YawDiff;

	bIsOnTarget = false;  // assume not on target until known otherwise
	bIsYawOnTarget = false;

	// is the gun aimed close enough to the target?
	if ((YawDiff < 800) && (PitchDiff < 600))
	{
		bIsOnTarget = true;  // gun is "on target", start shooting
	}

	if (YawDiff < 800)
	{
		bIsYawOnTarget = true;
	}

	// does the tank need to rotate to aim the main gun at the enemy?...
	if (YawDiff >= 800)
	{
		if (!MyTankMarderController.bIsRotating)  // is the tank not currently rotating towards the target?
		{
			// request the tank to rotate towards the target...
			if (bUseMainGunTarget)
				MyTankMarderController.RotateTowardTarget(MyTankMarderController.MainGunTarget);
			else
				MyTankMarderController.RotateTowardLocation(TargetAimLoc);
		}
	}

	// convert MainGunPitch back to local space...
	MyTankMarder.MainGunPitch = (WorldMainGunPitch - MyTankMarder.Rotation.Pitch) & 65535;

	MaxPitchUp = int((MyTankMarder.MainGunUpwardFireArc / 360.0) * 65536.0);
	MaxPitchDown = int((MyTankMarder.MainGunDownwardFireArc / 360.0) * 65536.0);

	if (MyTankMarder.MainGunPitch > 32767)
		MyTankMarder.MainGunPitch = MyTankMarder.MainGunPitch - 65536;

	MyTankMarder.MainGunPitch = Clamp(MyTankMarder.MainGunPitch, -MaxPitchDown, MaxPitchUp);

	// for cases where gun has reached max pitch up/down, fire if yaw is on target and pitch is within 10 degrees of target...
	if ((YawDiff < 800) && ((MyTankMarder.MainGunPitch == -MaxPitchDown) || (MyTankMarder.MainGunPitch == MaxPitchUp)) &&
		(PitchDiff < 1820))
	{
		bIsOnTarget = true;  // gun is "on target", start shooting
	}

	MainGunRot.Pitch = 0;
	MainGunRot.Yaw = MyTankMarder.MainGunPitch;
	MainGunRot.Roll = 0;

	MyTankMarder.SetBoneRotation(MyTankMarder.MainGunBoneName, MainGunRot, 0, 1.0);
}

function Rotator AdjustAimNewTankShell( Ammunition Ammo, Vector ProjStart, Rotator AimRotator, InstantFire MyInstantFire, optional out int bSkipDoTrace )
{
	local float DistToTarget;
	local int index;
	local bool bCheckNoDamage;

	// check if the enemy is not a tank...
	if ((Enemy != None) && (!Enemy.IsA('Tank')))
	{
		bCheckNoDamage = false; // assume false until known otherwise

		index = FindTargetInQueue( Enemy );

		// check if the enemy is a "hard" target (Pak36 gunner, Panzerfaust soldier, etc)...
		if ( (index >= 0) && (TargetQueue[index].bIsHardTarget == 1) )
			bCheckNoDamage = true;

		// check if the enemy is manning a machine gun...
		if ( !bCheckNoDamage && (gbxPawn(Enemy) != None) && (gbxPawn(Enemy).bIsManningTurret) )
			bCheckNoDamage = true;

		if (bCheckNoDamage)
		{
			DistToTarget = VSize( Enemy.Location - MyTank.Location );

			// Is this a deadlock situation?
			if ( DistToTarget > MainGunDoNoDamageRange )
			{
				MyTankMarder.MainGunFireMode.bIgnoreDamageThisBullet = true;
			}
		}
	}

	return Super.AdjustAimNewTankShell(Ammo, ProjStart, AimRotator, MyInstantFire, bSkipDoTrace);
}

function FireMainGun(bool bDoNoDamage)
{
	local vector MainGunLoc;
	local rotator MainGunRot;
	local vector RotX, RotY, RotZ;
	local int AimErrorLocal;
	local rotator AdjustedAim;
	local int bSkipDoTrace;
	local gbxTankShell TankShell;

	if (!bDoNoDamage)
		MyTankMarder.MainGunFireMode.bIgnoreDamageThisBullet = false;

	MainGunLoc = MyTankMarder.GetTagCoords( MyTankMarder.MainGunMuzzleBoneName ).origin;

	MainGunRot.Pitch = MyTankMarder.MainGunPitch;
	MainGunRot.Yaw = 0;
	MainGunRot.Roll = 0;

	MainGunRot = MyTankMarder.Rotation + MainGunRot;

    GetAxes(MainGunRot,RotX,RotY,RotZ);

	MainGunLoc = MainGunLoc + MyTankMarder.MainGunEmitterOffset.X * RotX + MyTankMarder.MainGunEmitterOffset.Y * RotY + MyTankMarder.MainGunEmitterOffset.Z * RotZ;

	MainGunRot.Pitch = 0;  // ignore main gun pitch for main gun smoke and dust emitter
	MainGunRot.Yaw = 0;
	MainGunRot.Roll = 0;

	MainGunRot = MyTankMarder.Rotation + MainGunRot;

	// spawn main gun smoke and dust emitter...
	spawn(MyTankMarder.MainGunSmokeEmitterClass, None,, MainGunLoc, MainGunRot);

	AimErrorLocal = AimErrorAI;

	AdjustedAim = MyTankMarder.AdjustAimMainGun();

	ApplyAccuracy( AdjustedAim, AimErrorLocal );

	AdjustedAim = AdjustAimNewTankShell(MyTankMarder.MainGunAmmo, MainGunLoc, AdjustedAim, MyTankMarder.MainGunFireMode, bSkipDoTrace);

	// spawn main gun muzzle flash emitter...
	spawn(MyTankMarder.MainGunFlashEmitterClass, None,, MainGunLoc, AdjustedAim);

	if (MyTankMarder.MainGunFireMode.bIgnoreDamageThisBullet)
	{
		Log(name $ ".FireMainGun - bIgnoreDamageThisBullet was True, doing no damage", 'Tank');
		bDoNoDamage = true;
	}

	TankShell = Spawn( class'gbxTankShell', MyTankMarder,, MainGunLoc, AdjustedAim );
	TankShell.Instigator = MyTankMarder;

	if (bDoNoDamage)
		TankShell.Damage = 0.0f;

	MyTankMarder.PlaySoundCue( MyTankMarder.MainGunFireSound, SLOT_NONE, TransientSoundVolume,,,,false);

	MyTankMarder.PlayMainGunFiringAnim(0);
}


defaultproperties
{
	TimerInterval=0.2

	PeripheralVisionWithCommander=-0.0  // +/- 90 degrees (180 degrees total)
	PeripheralVisionWithoutCommander=0.2588  // +/- 75 degrees (150 degrees total)

	bIsOnTarget=false

	fResetMainGunTime=5.0  // if no enemy, start resetting the turret after 5.0 seconds
	fMainGunFireDelay=0.25  // how long to wait after main gun is "on target" before firing

	TargetPriorityScalarInfantryGroup=0.8

	bLogPriority=false

	AimErrorAI=400
	AimErrorAINormal=400
	AimErrorAIBefuddled=800

	ReactionTimeMin=4.0
	ReactionTimeMax=6.0
	ReactionTimeMinEasy=5.0
	ReactionTimeMaxEasy=7.0
	ReactionTimeMinNormal=4.0
	ReactionTimeMaxNormal=6.0
	ReactionTimeMinHard=3.0
	ReactionTimeMaxHard=4.0
	ReactionTimeMinAuthentic=2.0
	ReactionTimeMaxAuthentic=3.0

	PurposefulMissTimeStart=30.0
	PurposefulMissTimeBonus=5.0
	PurposefulMissTimeMax=45.0
	PurposefulMissTimeStartEasy=45.0
	PurposefulMissTimeBonusEasy=5.0
	PurposefulMissTimeMaxEasy=60.0
	PurposefulMissTimeStartNormal=30.0
	PurposefulMissTimeBonusNormal=5.0
	PurposefulMissTimeMaxNormal=45.0
	PurposefulMissTimeStartHard=20.0
	PurposefulMissTimeBonusHard=5.0
	PurposefulMissTimeMaxHard=30.0
	PurposefulMissTimeStartAuthentic=15.0
	PurposefulMissTimeBonusAuthentic=5.0
	PurposefulMissTimeMaxAuthentic=20.0

	TargetForgetTimeLong=10.0f
	TargetForgetTimeShort=10.0f
}
class TankPanzerIVBowGunController extends TankGunController
	notplaceable;


var()	TankPanzerIV			MyTankPanzerIV;
var()	TankPanzerIVController	MyTankPanzerIVController;

// weapon targeting stuff...
var()	bool	bIsOnTarget;
var()	bool	bIsFiringBurst;		// are we firing a burst at a target?
var()	float	fBurstEndTime;		// time when this burst will end
var()	float	fBurstStartTime;	// time when next burst can start

var()	float	MinBurstLength;		// in seconds
var()	float	MaxBurstLength;		// in seconds
var()	float	MinPauseLength;		// in seconds
var()	float	MaxPauseLength;		// in seconds

var()	float	fEnemySpottedTime;	// when we first saw the enemy
var()	float	fEnemyNoneTime;		// time when enemy was last set to None

var(Target)	float BowGunTargetSelectionAngle;  // dot product of bow gun target selection angle
var(Target)	float TargetPriorityScalarBowGunSelectionAngle;
var(Target)	float TargetPriorityScalarBowGunRotationAngle;

var()	int		AimErrorAI;
var()	int		AimErrorAINormal;
var()	int		AimErrorAIBefuddled;

var		bool	bLogPriority;


function Possess(Tank aPawn, TankController aController)
{
	Log( name $ ".(TankPanzerIVBowGunController).Possess( " $ aPawn.name $ " " $ aController.name $ " )", 'Tank' );

	if (TankPanzerIV(aPawn) == None)
	{
		Log(name $ ".Possess - aPawn (" $ aPawn.name $ ") is NOT a TankPanzerIV!!!");
		return;
	}

	if (TankPanzerIVController(aController) == None)
	{
		Log(name $ ".Possess - aController (" $ aController.name $ ") is NOT a TankPanzerIVController!!!");
		return;
	}

	Super.Possess(aPawn, aController);

	MyTankPanzerIV = TankPanzerIV(aPawn);
	MyTankPanzerIVController = TankPanzerIVController(aController);

	fEnemyNoneTime = 0.0f;
	fEnemySpottedTime = -1.0f;  // enemy not spotted yet
}

function Timer()
{
//	Log( name $ ".(TankPanzerIVBowGunController).Timer()", 'Tank' );

	if ((MyTankPanzerIVController.BefuddledEndTime > 0.0) && (MyTankPanzerIVController.BefuddledEndTime < Level.TimeSeconds))
	{
		AimErrorAI = AimErrorAIBefuddled;
	}
	else
	{
		AimErrorAI = AimErrorAINormal;
	}

	Super.Timer();
}

function SeePawn( Pawn Seen )
{
//	Log( name $ ".(TankPanzerIVBowGunController-"$MyTank.name$").SeePawn( " $ Seen.name $ " )", 'Tank' );

	if (MyTankController.bNoEnemies)
		return;  // don't target or shoot at any enemies

	if ( MyTankController.bNoTargetPlayer && Seen.IsPlayerPawn() )
		return;  // don't target or shoot at player

	if (TankGunControllerCanSee(MyTankPanzerIV.Rotation, Seen))
		ConsiderPossibleEnemy( Seen, true );
}

function HearNoise( float Loudness, Actor NoiseMaker )
{
//	Log( name $ ".(TankPanzerIVBowGunController-"$MyTank.name$").HearNoise( " $ Loudness $ " " $ NoiseMaker.name $ " )", 'Tank' );

	if (MyTankController.bNoEnemies)
		return;  // don't target or shoot at any enemies

	if ( MyTankController.bNoTargetPlayer && Pawn(NoiseMaker).IsPlayerPawn() )
		return;  // don't target or shoot at player

	if( NoiseMaker.IsA( 'Pawn' ))
	{
		// TODO do uncertainty.

		ConsiderPossibleEnemy( Pawn( NoiseMaker ), true );
	}
}

function ConsiderPossibleEnemy( Pawn possibleEnemy, bool bAddToOtherGunController )
{
	Super.ConsiderPossibleEnemy(possibleEnemy, bAddToOtherGunController);

	// make sure the other gun on this tank knows about this possible enemy...
	if ((MyTankPanzerIVController.MyMainGunController != None) && (bAddToOtherGunController))
	{
		MyTankPanzerIVController.MyMainGunController.ConsiderPossibleEnemy(possibleEnemy, false);
	}
}

function bool SetEnemy( Actor newEnemy )
{
	bIsOnTarget = false;
	return Super.SetEnemy( newEnemy );
}

function int FindTargetInMainGunQueue(gbxPawn Target)
{
	local int i;

	if (MyTankPanzerIVController.MyMainGunController == None)
		return -1;

	for (i = 0; i < MyTankPanzerIVController.MyMainGunController.TargetQueue.Length; i++)
	{
		if (MyTankPanzerIVController.MyMainGunController.TargetQueue[i].Target == Target)
			return i;
	}

	return -1;  // not found
}

event AdjustTargetPriority(int index)
{
	local gbxPawn Target;
	local float priority, weights, delta_priority;
	local vector vDir, vForward;
	local float dotTheta;
	local int NearbyTargets;
	local vector BowGunBoneLoc;

	Target = TargetQueue[index].Target;

	// recalculate the priority and weights from the native CalculateTargetPriority() function...
	priority = TargetQueue[index].TargetPriority * TargetQueue[index].TargetTotalWeight;
	weights = TargetQueue[index].TargetTotalWeight;

	// give higher priority to targets that are in the direction that the gun is already facing...
	vDir = Normal(Target.Location - MyTankPanzerIV.Location);
	vForward = Vector(MyTankPanzerIV.Rotation);

	dotTheta = (vDir dot vForward);  // 1.0 to -1.0
	dotTheta = (dotTheta / 2.0) + 0.5;  // 1.0 to 0.0

	delta_priority = dotTheta * TargetPriorityScalarInAimingDirection;
	if (bLogPriority)
		Log(name $ ".AdjustTargetPriority: Target " $ Target.name $ " - InAimingDirection priority = " $ delta_priority, 'Tank');
	priority += delta_priority;
	weights += TargetPriorityScalarInAimingDirection;

	// check what type of target this is (or what type of weapon the target is carrying)...

	if (Target.IsA('gbxSVehicle'))  // is this target a vehicle?  If so, MainGunController handles it
	{
		if (bLogPriority)
			Log(name $ ".AdjustTargetPriority: Target " $ Target.name $ " is a vehicle", 'Tank');
		TargetQueue[index].bUseCannon = 1;  // use the cannon to fire at this/these target(s)
	}

//	if (!bAssignToMainGun && Target.IsA('MachineGun'))
//	{
//		if (bLogPriority)
//			Log(name $ ".AdjustTargetPriority: Target " $ Target.name $ " is a manned machine gun", 'Tank');
//		TargetQueue[index].bUseCannon = 1;  // use the cannon to fire at this/these target(s)
//	}

//	if (!bAssignToMainGun && Target.IsA('Infantry'))
//	{
//		// check what weapon this infantry soldier is carrying...
//		if (Target.Weapon.IsA('PatherFist'))
//		{
//			if (bLogPriority)
//				Log(name $ ".AdjustTargetPriority: Target " $ Target.name $ " is a soldier carrying an anti-tank weapon", 'Tank');
//			TargetQueue[index].bUseCannon = 1;  // use the cannon to fire at this/these target(s)
//		}
//	}

	if ((Target.IsA('Infantry')) && (MyTankPanzerIVController.MyMainGunController != None))
	{
		// check to see if this infantry target is close to at least 2 other infantry targets...
		NearbyTargets = GetNumberOfNearbyInfantryTargets(Target);

		if (NearbyTargets >= 2)
		{
			// give lower priority to infantry targets that are in groups of 3 or more
			delta_priority = 1.0 - MyTankPanzerIVController.MyMainGunController.TargetPriorityScalarInfantryGroup;
			if (bLogPriority)
				Log(name $ ".AdjustTargetPriority: Target " $ Target.name $ " - InfantryGroup priority = " $ delta_priority, 'Tank');
			priority += delta_priority;
			weights += (1.0 - MyTankPanzerIVController.MyMainGunController.TargetPriorityScalarInfantryGroup);
		}
		else  // otherwise, infantry target is close to no more than 1 other infantry target...
		{
			// check to see if this target is inside the BowGunTargetSelectionAngle for the bow gun...
			vDir = Normal(Target.Location - MyTankPanzerIV.Location);
			vForward = Vector(MyTankPanzerIV.Rotation);
			dotTheta = vDir dot vForward;

			if (dotTheta > BowGunTargetSelectionAngle)
			{
				if (!MyTankPanzerIVController.bIsNavigating)
				{
					// give higher priority to targets that are within the bow gun's selection angle
					delta_priority = dotTheta * TargetPriorityScalarBowGunSelectionAngle;
					if (bLogPriority)
						Log(name $ ".AdjustTargetPriority: Target " $ Target.name $ " - BowGunSelectionAngle priority = " $ delta_priority, 'Tank');
					priority += delta_priority;
					weights += TargetPriorityScalarBowGunSelectionAngle;
				}
				else
				{
					BowGunBoneLoc = MyTankPanzerIV.GetBoneCoords( MyTankPanzerIV.BowGunBoneName ).origin;

					vDir = Normal(Target.Location - BowGunBoneLoc);
					vForward = Vector(MyTankPanzerIV.Rotation);

					dotTheta = cos((MyTankPanzerIV.BowGunRotateMax / 180.0) * 3.14159);

					if ((vDir dot vForward) > dotTheta)
					{
						// give higher priority to targets that are within the bow gun's rotation angle
						delta_priority = dotTheta * MyTankPanzerIVController.MyBowGunController.TargetPriorityScalarBowGunRotationAngle;
						if (bLogPriority)
							Log(name $ ".AdjustTargetPriority: Target " $ Target.name $ " - BowGunRotationAngle priority = " $ delta_priority, 'Tank');
						priority += delta_priority;
						weights += MyTankPanzerIVController.MyBowGunController.TargetPriorityScalarBowGunRotationAngle;
					}
				}
			}
		}
	}

	priority = FClamp(priority, 0.0, priority);
	TargetQueue[index].TargetTotalWeight = weights;
	TargetQueue[index].TargetPriority = priority / weights;

	if (bLogPriority)
		Log(name $ ".AdjustTargetPriority: Target " $ Target.name $ " - final priority = " $ TargetQueue[index].TargetPriority, 'Tank');
}

function ReassignTargets()
{
	local int index;
	local float bestPriority;

	if (ndxEnemyInQueue < 0)  // no targets in queue?
		return;

	ndxEnemyInQueue = -1;
	bestPriority = 0.0f;

	for (index = 0; index < TargetQueue.Length; index++)
	{
		if (TargetQueue[index].RelegationTime > Level.TimeSeconds)
			continue;

		if ((ndxEnemyInQueue == -1) || (TargetQueue[index].TargetPriority > bestPriority))
		{
			ndxEnemyInQueue = index;
			bestPriority = TargetQueue[index].TargetPriority;
		}
	}
}

event vector GetGunControllerRotation()
{
	return vector(MyTankPanzerIV.Rotation);
}

function Tick( float deltaTime )
{
	local vector BowGunLoc;
	local rotator BowGunRot;
	local int IsHeadShot;
	local vector SuppressLoc, FailLoc;
	local bool bCanSeePawn;
	local vector TargetAimLoc;
	local Actor RotateTarget;
	local float ReactionTimeDelta;

	Super.Tick( deltaTime );

	if (MyTankPanzerIVController == None)
		return;

	if (Enemy == None)
	{
		if (MyTankPanzerIVController.BowGunTarget != None)
		{
			fEnemyNoneTime = Level.TimeSeconds;

			MyTankPanzerIVController.BowGunTarget = None;
		}
	}
	else
	{
		if ((fEnemySpottedTime < 0) || (MyTankPanzerIVController.BowGunTarget != Enemy))
		{
			fEnemySpottedTime = Level.TimeSeconds;

			// have we NOT seen a target within the last 5 seconds?
			if (fGunReactionTime + 5.0 < Level.TimeSeconds)
			{
				// long reaction time, tank is not quite as aware...
				ReactionTimeDelta = ReactionTimeMax - ReactionTimeMin;
				fGunReactionTime = Level.TimeSeconds + ReactionTimeMin + (FRand() * ReactionTimeDelta);
			}
			else
			{
				// short reaction time, tank recently had an enemy and is more aware...
				fGunReactionTime = Level.TimeSeconds + 0.5 + (FRand() * 0.5f);
			}

			Log(name $ ".Tick() - BowGun Enemy " $ Enemy.name $ " spotted at " $ Level.TimeSeconds $ "  reaction time = " $ fGunReactionTime, 'Tank');

			MyTankPanzerIVController.BowGunTarget = Enemy;
		}
	}

	if (MyTankPanzerIVController.BowGunTarget != None)
	{
		if ((fGunReactionTime < Level.TimeSeconds) &&
			(MyTankPanzerIVController.GetStateName() != 'Hunting') &&
			(MyTankPanzerIVController.GetStateName() != 'GrenadePlanted') &&
			(MyTankPanzerIVController.GetStateName() != 'Panicked'))
		{
			bCanSeePawn = MyTankController.CanSeeOrSuppress(Pawn(MyTankPanzerIVController.BowGunTarget), SeeLoc, IsHeadShot, SuppressLoc, FailLoc);

			if (bCanSeePawn)
			{
				TargetAimLoc = SeeLoc;
				RotateTarget = MyTankPanzerIVController.BowGunTarget;

				if ((SeeLoc.X == 0.0) && (SeeLoc.Y == 0.0) && (SeeLoc.Z == 0.0))
				{
//					TargetAimLoc = SuppressLoc;
					TargetAimLoc = TargetQueue[ndxEnemyInQueue].LastKnownLocation;
					RotateTarget = None;  // don't rotate to track target since we can't see him
				}

				TrackBowGunTarget(DeltaTime, TargetAimLoc, RotateTarget);  // track using the bow machine gun

				// are we on target AND not firing a burst AND time to start a new burst?
				if ((bIsOnTarget) && (!bIsFiringBurst) && (fBurstStartTime < Level.TimeSeconds))
				{
					BowGunLoc = MyTankPanzerIV.GetTagCoords( MyTankPanzerIV.BowGunMuzzleBoneName ).origin;
					BowGunRot = MyTankPanzerIV.Rotation - MyTankPanzerIV.BowGunRotation;

					// see if we can shoot at what we're aiming at without hitting teammates...
					if (ApproveShot(BowGunLoc, BowGunRot))
					{
						bIsFiringBurst = true;
						MyTankPanzerIV.BowGunSoundHandle = MyTankPanzerIV.PlaySoundCue( MyTankPanzerIV.BowGunFireLoopSound, SLOT_NONE, TransientSoundVolume,,,,false);

						fBurstEndTime = Level.TimeSeconds + MinBurstLength + (FRand() * (MaxBurstLength - MinBurstLength));
						fBurstStartTime = fBurstEndTime + MinPauseLength + (FRand() * (MaxPauseLength - MinPauseLength));
					}
					else
					{
						// try firing again after 0.5 - 2.5 seconds...
						fBurstStartTime = Level.TimeSeconds + 0.5 + (FRand() * 2.0);
					}
				}
			}
		}
	}
	else
	{
		// no current target...
		bIsOnTarget = false;
		fEnemySpottedTime = -1.0f;
	}

	if (bIsFiringBurst)
	{
		if (fBurstEndTime < Level.TimeSeconds)  // has the burst ended?
		{
			bIsFiringBurst = false;
			MyTankPanzerIV.StopSound( MyTankPanzerIV.BowGunSoundHandle );
			MyTankPanzerIV.PlaySoundCue( MyTankPanzerIV.BowGunFireOnceSound, SLOT_NONE, TransientSoundVolume,,,,false);
		}
		else
		{
			if (MyTankPanzerIV.fBowGunReFireTime < Level.Timeseconds)
			{
				FireBowGun(false);
			}
		}
	}
}

function int GetNewRotation(int current, int desired, int rate)
{
	local int result;

	result = current & 65535;
	current = result;
	desired = desired & 65535;

	if (current > desired)
	{
		if (current - desired < 32768)
			result -= Min((current - desired), abs(rate));
		else
			result += Min((desired + 65536 - current), abs(rate));
	}
	else
	{
		if (desired - current < 32768)
			result += Min((desired - current), abs(rate));
		else
			result -= Min((current + 65536 - desired), abs(rate));
	}

	return (result & 65535);
}

function TrackBowGunTarget(float DeltaTime, vector TargetAimLoc, Actor RotateTarget)
{
	local rotator WorldBowGunRot;
	local vector BowGunBoneLoc;
	local rotator RotToTarget;
	local float AdjustRate;
	local rotator BowGunRot;
	local int MaxRot, MinRot;
	local int PitchDiff, YawDiff;

	if ((MyTankPanzerIV == None) || (MyTankPanzerIVController.BowGunTarget == None))
		return;

	// convert BowGunRotation to world space...
	WorldBowGunRot.Pitch = (MyTankPanzerIV.Rotation.Pitch - MyTankPanzerIV.BowGunRotation.Pitch) & 65535;
	WorldBowGunRot.Yaw = (MyTankPanzerIV.Rotation.Yaw - MyTankPanzerIV.BowGunRotation.Yaw) & 65535;
	WorldBowGunRot.Roll = 0;

	BowGunBoneLoc = MyTankPanzerIV.GetBoneCoords( MyTankPanzerIV.BowGunBoneName ).origin;
	RotToTarget = rotator(TargetAimLoc - BowGunBoneLoc);

	AdjustRate = (MyTankPanzerIV.BowGunRotationSpeed * DeltaTime / 360.0) * 65536;

	WorldBowGunRot.Pitch = GetNewRotation(WorldBowGunRot.Pitch, RotToTarget.Pitch, int(AdjustRate));
	WorldBowGunRot.Yaw = GetNewRotation(WorldBowGunRot.Yaw, RotToTarget.Yaw, int(AdjustRate));

	PitchDiff = abs((WorldBowGunRot.Pitch & 65535) - (RotToTarget.Pitch & 65535));
	if (PitchDiff > 32768)
		PitchDiff = 65536 - PitchDiff;

	YawDiff = abs((WorldBowGunRot.Yaw & 65535) - (RotToTarget.Yaw & 65535));
	if (YawDiff > 32768)
		YawDiff = 65536 - YawDiff;

	bIsOnTarget = false;  // assume not on target until known otherwise

	// is the bow machine gun aimed close enough to the target?
	if ((YawDiff < 500) && (PitchDiff < 500))
	{
		bIsOnTarget = true;  // bow gun is "on target", start shooting
	}

	// convert BowGunRotation back to local space...
	MyTankPanzerIV.BowGunRotation.Pitch = (MyTankPanzerIV.Rotation.Pitch - WorldBowGunRot.Pitch) & 65535;
	MyTankPanzerIV.BowGunRotation.Yaw = (MyTankPanzerIV.Rotation.Yaw - WorldBowGunRot.Yaw) & 65535;
	MyTankPanzerIV.BowGunRotation.Roll = 0;

	if (MyTankPanzerIV.BowGunRotation.Pitch > 32767)
		MyTankPanzerIV.BowGunRotation.Pitch = MyTankPanzerIV.BowGunRotation.Pitch - 65536;
	if (MyTankPanzerIV.BowGunRotation.Yaw > 32767)
		MyTankPanzerIV.BowGunRotation.Yaw = MyTankPanzerIV.BowGunRotation.Yaw - 65536;

	MaxRot = int((MyTankPanzerIV.BowGunRotateMax / 360.0) * 65536.0);
	MinRot = int((-MyTankPanzerIV.BowGunRotateMax / 360.0) * 65536.0);

	MyTankPanzerIV.BowGunRotation.Pitch = Clamp(MyTankPanzerIV.BowGunRotation.Pitch, MinRot, MaxRot);
	MyTankPanzerIV.BowGunRotation.Yaw = Clamp(MyTankPanzerIV.BowGunRotation.Yaw, MinRot, MaxRot);

	// is bow machine gun at horizontal limit of rotation range?
	if ((MyTankPanzerIV.BowGunRotation.Yaw == MinRot) ||
		(MyTankPanzerIV.BowGunRotation.Yaw == MaxRot))
	{
		if (!MyTankPanzerIVController.bIsRotating)  // is the tank not currently rotating towards the target?
		{
			// request the tank to rotate towards the target...
			if (RotateTarget != None)
				MyTankPanzerIVController.RotateTowardTarget(RotateTarget);
			else
				MyTankPanzerIVController.RotateTowardLocation(TargetAimLoc);
		}
	}

	BowGunRot.Pitch = MyTankPanzerIV.BowGunRotation.Yaw;
	BowGunRot.Yaw = MyTankPanzerIV.BowGunRotation.Pitch;
	BowGunRot.Roll = 0;

	MyTankPanzerIV.SetBoneRotation(MyTankPanzerIV.BowGunBoneName, BowGunRot, 0, 1.0);
}

function FireBowGun(bool bDoNoDamage)
{
	local vector BowGunLoc;
	local rotator BowGunRot;
	local vector RotX, RotY, RotZ;
	local int AimErrorLocal;
	local rotator AdjustedAim;
	local int bSkipDoTrace;
	local Emitter MuzzleFlash;

	if (MyTankPanzerIV.BowGunFireMode != None)
	{
		MyTankPanzerIV.fBowGunReFireTime = Level.TimeSeconds + MyTankPanzerIV.fBowGunReFireDelay;

		BowGunLoc = MyTankPanzerIV.GetTagCoords( MyTankPanzerIV.BowGunMuzzleBoneName ).origin;

		BowGunRot = MyTankPanzerIV.Rotation - MyTankPanzerIV.BowGunRotation;

	    GetAxes(BowGunRot,RotX,RotY,RotZ);

		BowGunLoc = BowGunLoc + MyTankPanzerIV.BowGunEmitterOffset.X * RotX + MyTankPanzerIV.BowGunEmitterOffset.Y * RotY + MyTankPanzerIV.BowGunEmitterOffset.Z * RotZ;

		MyTankPanzerIV.Owner.MakeNoise(1.0);

		AimErrorLocal = AimErrorAI;

		AdjustedAim = MyTankPanzerIV.AdjustAimBowGun();

		// give TankGunController a chance to adjust the aim...
		if (MyTankPanzerIVController.bIsNavigating)
			AimErrorLocal += 100;

		ApplyAccuracy( AdjustedAim, AimErrorLocal );

		AdjustedAim = AdjustAimNewBullet(MyTankPanzerIV.BowGunAmmo, BowGunLoc, AdjustedAim, MyTankPanzerIV.BowGunFireMode, bSkipDoTrace);

		if (bDoNoDamage)
			MyTankPanzerIV.BowGunFireMode.SetNoDamageThisBullet();

		MyTankPanzerIV.BowGunFireMode.DoTrace(BowGunLoc, AdjustedAim);

		MyTankPanzerIV.BowGunTracerCount++;

		if ( MyTankPanzerIV.BowGunTracerCount >= MyTankPanzerIV.BowGunTracerFrequency )
		{
			MyTankPanzerIV.BowGunTracerCount = 0;

			// Emit a tracer
			if( (MyTankPanzerIV.BowGunTracerEmitter != None) )
				MyTankPanzerIV.BowGunTracerEmitter.TriggerEmitters( BowGunLoc, AdjustedAim );
		}

		MuzzleFlash = MyTankPanzerIV.BowGunFireMode.GetMuzzleFlash();

		MuzzleFlash.SetLocation(BowGunLoc);
		MuzzleFlash.SetRotation(BowGunRot);

		if ( MuzzleFlash.IsA( 'gbxMuzzleFlash' ) )
			gbxMuzzleFlash(MuzzleFlash).ShowMuzzleFlash();
	}
}


defaultproperties
{
	TimerInterval=0.2

	bIsOnTarget=false
	bIsFiringBurst=false

	MinBurstLength=2.0
	MaxBurstLength=3.5
	MinPauseLength=1.0
	MaxPauseLength=2.0

	BowGunTargetSelectionAngle=0.0  // cosine of 90 degrees

	TargetPriorityScalarBowGunSelectionAngle=0.75
	TargetPriorityScalarBowGunRotationAngle=0.9

	AimErrorAI=800
	AimErrorAINormal=800
	AimErrorAIBefuddled=1200

	ReactionTimeMin=1.0
	ReactionTimeMax=1.5
	ReactionTimeMinEasy=2.0
	ReactionTimeMaxEasy=3.0
	ReactionTimeMinNormal=1.0
	ReactionTimeMaxNormal=1.5
	ReactionTimeMinHard=0.7
	ReactionTimeMaxHard=1.0
	ReactionTimeMinAuthentic=0.5
	ReactionTimeMaxAuthentic=0.7

	TargetForgetTimeLong=10.0f
	TargetForgetTimeShort=10.0f
}
class TankPanzerIVController extends TankControllerGerman
	notplaceable;


var()	TankPanzerIV					MyTankPanzerIV;
var()	TankPanzerIVMainGunController	MyMainGunController;
var()	TankPanzerIVBowGunController	MyBowGunController;

// enemy targeting stuff...
var()	Actor	MainGunTarget;
var()	Actor	BowGunTarget;


function Possess(Pawn aPawn)
{
	Log( name $ ".(TankPanzerIVController).Possess( " $ aPawn.name $ " )", 'Tank' );

	Super.Possess(aPawn);

	if ((aPawn == None) || (TankPanzerIV(aPawn) == None))
	{
		Log(name $ ".Possess() - WARNING! TankPanzerIVController's Pawn is NOT a TankPanzerIV!!!");
	}
	else
	{
		MyTankPanzerIV = TankPanzerIV(aPawn);

		MyMainGunController = spawn(class'TankPanzerIVMainGunController', self);
		if (MyMainGunController == None)
			Log( name $ ".(TankPanzerIVController).Possess() - ERROR Spawning TankPanzerIVMainGunController!!!", 'Tank' );
		else
			MyMainGunController.Possess(MyTankPanzerIV, self);

		MyBowGunController = spawn(class'TankPanzerIVBowGunController', self);
		if (MyBowGunController == None)
			Log( name $ ".(TankPanzerIVController).Possess() - ERROR Spawning TankPanzerIVBowGunController!!!", 'Tank' );
		else
			MyBowGunController.Possess(MyTankPanzerIV, self);

		if (bTargetForgetTimeOverride)
		{
			MyMainGunController.TargetForgetTimeLong = TargetForgetTime;
			MyMainGunController.TargetForgetTimeShort = TargetForgetTime;

			MyBowGunController.TargetForgetTimeLong = TargetForgetTime;
			MyBowGunController.TargetForgetTimeShort = TargetForgetTime;
		}
	}
}

function Destroyed()
{
	Log( name $ ".(TankPanzerIVController).Destroyed()", 'Tank' );

	if (MyMainGunController != None)
		MyMainGunController.Destroy();
	if (MyBowGunController != None)
		MyBowGunController.Destroy();

	super.Destroyed();
}

function Timer()
{
	Super.Timer();

	if (fPauseMovementCheckTime < Level.TimeSeconds)
	{
		fPauseMovementCheckTime = Level.TimeSeconds + 2.0f;

		bPauseMovement = false;  // stop moving and attack enemy from here

		if ( (MyMainGunController != None) && MyMainGunController.ShouldTankPause() )
		{
			bPauseMovement = true;  // stop moving and attack enemy from here
		}
		else if ( (MyBowGunController != None) && MyBowGunController.ShouldTankPause() )
		{
			bPauseMovement = true;  // stop moving and attack enemy from here
		}
	}
}

function PawnDied(Pawn P)
{
	Log( name $ ".(TankPanzerIVController).PawnDied()", 'Tank' );

	Super.PawnDied(P);
}

function NotifyTakeHit(pawn InstigatedBy, vector HitLocation, int Damage, class<DamageType> damageType, vector Momentum)
{
//	Log( name $ "(" $ Pawn.name $ ").NotifyTakeHit( " $ InstigatedBy.name $ " )", 'Tank' );

	if (bIsInScriptedMode)
		return;  // don't do anything if under scripted control

	if (MyMainGunController != None)
		MyMainGunController.NotifyTakeHit(InstigatedBy, HitLocation, Damage, damageType, Momentum);

	if (MyBowGunController != None)
		MyBowGunController.NotifyTakeHit(InstigatedBy, HitLocation, Damage, damageType, Momentum);

	Super.NotifyTakeHit( InstigatedBy, HitLocation, Damage, damageType, Momentum );
}

function SeePawn( Pawn Seen )
{
//	Log( name $ "(" $ Pawn.name $ ").SeePawn( " $ Seen.name $ " )", 'Tank' );

	if (bIsInScriptedMode)
		return;  // don't do anything if under scripted control

	if (MyMainGunController != None)
		MyMainGunController.SeePawn(Seen);

	if (MyBowGunController != None)
		MyBowGunController.SeePawn(Seen);

	Super.SeePawn(Seen);
}

function SeePawnKilled( Pawn Seen, Pawn Killer )
{
//	Log( name $ "(" $ Pawn.name $ ").SeePawnKilled( " $ Seen.name $ " )", 'Tank' );

	if (bIsInScriptedMode)
		return;  // don't do anything if under scripted control

	// Seeing your friends get killed.
	if (MyMainGunController != None)
		MyMainGunController.SeePawnKilled(Seen, Killer);

	if (MyBowGunController != None)
		MyBowGunController.SeePawnKilled(Seen, Killer);

	Super.SeePawnKilled(Seen, Killer);
}

function SeePawnHit( Pawn Seen )
{
//	Log( name $ "(" $ Pawn.name $ ").SeePawnHit( " $ Seen.name $ " )", 'Tank' );

	if (bIsInScriptedMode)
		return;  // don't do anything if under scripted control

	if (MyMainGunController != None)
		MyMainGunController.SeePawnHit(Seen);

	if (MyBowGunController != None)
		MyBowGunController.SeePawnHit(Seen);

	Super.SeePawnHit(Seen);
}

function HearNoise( float Loudness, Actor NoiseMaker )
{
//	Log( name $ "(" $ Pawn.name $ ").HearNoise( " $ Loudness $ ", " $ NoiseMaker.name $ " )", 'Tank' );

	if (bIsInScriptedMode)
		return;  // don't do anything if under scripted control

	if (MyMainGunController != None)
		MyMainGunController.HearNoise(Loudness, NoiseMaker);

	if (MyBowGunController != None)
		MyBowGunController.HearNoise(Loudness, NoiseMaker);

	Super.HearNoise(Loudness, NoiseMaker);
}

function SeePlayer( Pawn Seen )
{
//	Log( name $ "(" $ Pawn.name $ ").SeePlayer( " $ Seen.name $ " )", 'Tank' );

	if (bIsInScriptedMode)
		return;  // don't do anything if under scripted control

	if (MyMainGunController != None)
		MyMainGunController.SeePlayer(Seen);

	if (MyBowGunController != None)
		MyBowGunController.SeePlayer(Seen);

	Super.SeePlayer(Seen);
}

function SeeExplosion( Pawn Instigator )
{
//	Log( name $ "(" $ Pawn.name $ ").SeeExplosion( " $ Instigator.name $ " )", 'Tank' );

	if (bIsInScriptedMode)
		return;  // don't do anything if under scripted control

	// Seeing shit get blown up.
	if (MyMainGunController != None)
		MyMainGunController.SeeExplosion(Instigator);

	if (MyBowGunController != None)
		MyBowGunController.SeeExplosion(Instigator);

	Super.SeeExplosion(Instigator);
}

function NotifyTargetOrder(Unit targetUnit)
{
	local int i;

	// notify this member about all Targets in the targetUnit...
	for (i = 0; i < targetUnit.NumMembers; i++)
	{
		if (MyMainGunController != None)
			MyMainGunController.AddTarget( targetUnit.Members[i] );
		if (MyBowGunController != None)
			MyBowGunController.AddTarget( targetUnit.Members[i] );
	}
}

function NotifyAssaultOrder(Unit targetUnit)
{
	local int i;

	// notify this member about all Targets in the targetUnit...
	for (i = 0; i < targetUnit.NumMembers; i++)
	{
		if (MyMainGunController != None)
			MyMainGunController.AddTarget( targetUnit.Members[i] );
		if (MyBowGunController != None)
			MyBowGunController.AddTarget( targetUnit.Members[i] );
	}
}

function ConsiderPossibleEnemy( Pawn possibleEnemy )
{
	if (bIsInScriptedMode)
		return;  // don't do anything if under scripted control

	if (MyMainGunController != None)
		MyMainGunController.ConsiderPossibleEnemy(possibleEnemy, false);

	if (MyBowGunController != None)
		MyBowGunController.ConsiderPossibleEnemy(possibleEnemy, false);
}

event float GetTargetExposureToMe( Pawn aThreat )
{
	local float MainGunExp, BowGunExp;

	MainGunExp = MyMainGunController.GetTargetExposureToMe(aThreat);
	BowGunExp = MyBowGunController.GetTargetExposureToMe(aThreat);

	if (MainGunExp > BowGunExp)
		return MainGunExp;

	return BowGunExp;
}

function bool EnemiesAreRecentlyVisible()
{
	if (bIsInScriptedMode)
		return false;  // don't do anything if under scripted control

	if (MyMainGunController.EnemiesAreRecentlyVisible())
		return true;

	if (MyBowGunController.EnemiesAreRecentlyVisible())
		return true;

	return false;
}

function bool NoEnemiesVisibleForAWhile()
{
	if (bIsInScriptedMode)
		return true;  // don't do anything if under scripted control

	if (MyMainGunController != None)
	{
		if (!MyMainGunController.NoEnemiesVisibleForAWhile())
			return false;
	}

	if (MyBowGunController != None)
	{
		if (!MyBowGunController.NoEnemiesVisibleForAWhile())
			return false;
	}

	return true;
}

function gbxPawn GetHuntingEnemy(out vector LastKnownLocation, out vector FirstHiddenLocation)
{
	local gbxPawn HuntingEnemy;

	if (bIsInScriptedMode)
		return None;  // don't do anything if under scripted control

	if (MyMainGunController != None)
	{
		HuntingEnemy = MyMainGunController.GetHuntingEnemy(LastKnownLocation, FirstHiddenLocation);

		if (HuntingEnemy != None)
			return HuntingEnemy;
	}

	if (MyBowGunController != None)
	{
		HuntingEnemy = MyBowGunController.GetHuntingEnemy(LastKnownLocation, FirstHiddenLocation);

		if (HuntingEnemy != None)
			return HuntingEnemy;
	}

	return None;
}

function ResetTurret(float DeltaTime)
{
	if (bIsResettingTurret)
	{
		bIsResettingTurret = MyMainGunController.ResetTurret(DeltaTime);
	}
}

function Rotator GetMainGunWorldRotation()
{
	local rotator GunRotation;

	GunRotation.Pitch = MyTankPanzerIV.Rotation.Pitch + MyTankPanzerIV.MainGunPitch;
	GunRotation.Yaw = MyTankPanzerIV.Rotation.Yaw - MyTankPanzerIV.TurretYaw;
	GunRotation.Roll = 0;

	return GunRotation;
}

function HandleTrackingTarget(float DeltaTime)
{
	if ( bIsPausing )
	{
		if (PauseTime > Level.Timeseconds)
			return;

		bIsPausing = false;
	}

	MyMainGunController.TrackMainGunTarget(DeltaTime, TargetAimLocation);

	if (MyMainGunController.bIsYawOnTarget)
	{
		if (bIsRotatingToTheLeft)
		{
			bIsRotatingToTheLeft = false;

			RotationYawDelta = (CenteredYawRotation + (LookingForEnemyRotateYawMax * 65536.0 / 360.0)) & 65535;

			TempRot = MyTank.Rotation;
			TempRot.Yaw = RotationYawDelta;

			TargetAimLocation = MyTank.Location + Vector(TempRot) * 1000.0f;
		}
		else
		{
			bIsRotatingToTheLeft = true;

			RotationYawDelta = (CenteredYawRotation - (LookingForEnemyRotateYawMax * 65536.0 / 360.0)) & 65535;

			TempRot = MyTank.Rotation;
			TempRot.Yaw = RotationYawDelta;

			TargetAimLocation = MyTank.Location + Vector(TempRot) * 1000.0f;
		}

		bIsPausing = true;
		PauseTime = Level.TimeSeconds + 0.5 + FRand() * 0.3;
	}
}

function HandleGrenadePlanted(float DeltaTime)
{
	MyMainGunController.TrackMainGunTarget(DeltaTime, TargetAimLocation);

	if (MyMainGunController.bIsYawOnTarget)
	{
		if (bIsRotatingToTheLeft)
		{
			bIsRotatingToTheLeft = false;

			RotationYawDelta = (CenteredYawRotation + (GrenadePlantedRotateYawMax * 65536.0 / 360.0)) & 65535;

			TempRot = MyTank.Rotation;
			TempRot.Yaw = RotationYawDelta;

			TargetAimLocation = MyTank.Location + Vector(TempRot) * 1000.0f;
		}
		else
		{
			bIsRotatingToTheLeft = true;

			RotationYawDelta = (CenteredYawRotation - (GrenadePlantedRotateYawMax * 65536.0 / 360.0)) & 65535;

			TempRot = MyTank.Rotation;
			TempRot.Yaw = RotationYawDelta;

			TargetAimLocation = MyTank.Location + Vector(TempRot) * 1000.0f;
		}
	}
}

function bool TankHasEnemy()
{
	if (MyMainGunController != None)
	{
		if (MyMainGunController.ndxEnemyInQueue >= 0)
			return true;
	}

	if (MyBowGunController != None)
	{
		if (MyBowGunController.ndxEnemyInQueue >= 0)
			return true;
	}

	return false;
}


defaultproperties
{
	LookingForEnemyRotateYawMax=45.0  // in degrees
	GrenadePlantedRotateYawMax=20.0  // in degrees
}
class TankPanzerIVMainGunController extends TankGunController
	notplaceable;


var()	TankPanzerIV			MyTankPanzerIV;
var()	TankPanzerIVController	MyTankPanzerIVController;

// weapon targeting stuff...
var()	bool	bIsOnTarget;
var()	bool	bIsYawOnTarget;

var()	float	fEnemySpottedTime;	// when we first saw the enemy
var()	float	fEnemyNoneTime;		// time when enemy was last set to None
var()	float	fResetTurretTime;	// how long after enemy = none to reset turret back to facing fowards
var()	bool	bIsResettingTurret;

var()	float	fMainGunFireDelay;	// short delay between "on target/ready to fire" and "fire gun"
var()	float	fMainGunFireTime;

var(Target)	float TargetPriorityScalarInfantryGroup;

var()	int		AimErrorAI;
var()	int		AimErrorAINormal;
var()	int		AimErrorAIBefuddled;

var()	bool	bLogPriority;


function Possess(Tank aPawn, TankController aController)
{
	Log( name $ ".(TankPanzerIVMainGunController).Possess( " $ aPawn.name $ " " $ aController.name $ " )", 'Tank' );

	if (TankPanzerIV(aPawn) == None)
	{
		Log(name $ ".Possess - aPawn (" $ aPawn.name $ ") is NOT a TankPanzerIV!!!");
		return;
	}

	if (TankPanzerIVController(aController) == None)
	{
		Log(name $ ".Possess - aController (" $ aController.name $ ") is NOT a TankPanzerIVController!!!");
		return;
	}

	Super.Possess(aPawn, aController);

	MyTankPanzerIV = TankPanzerIV(aPawn);
	MyTankPanzerIVController = TankPanzerIVController(aController);

	fEnemyNoneTime = 0.0f;
	fEnemySpottedTime = -1.0f;  // enemy not spotted yet
	fMainGunFireTime = -1.0f;
}

function Timer()
{
//	Log( name $ ".(TankPanzerIVMainGunController).Timer()", 'Tank' );

	if (MyTankPanzerIVController.bIsInScriptedMode)
	{
		Super.Timer();
		return;
	}

	PeripheralVision = PeripheralVisionWithoutCommander;  // default to vision without tank commander

	if (MyTankPanzerIV != None)
	{
		if (MyTankPanzerIV.bSpawnCommander)  // if tank was spawned without a commander, use same vision as if had a commander...
		{
			PeripheralVision = PeripheralVisionWithCommander;
		}
		else if ((MyTankPanzerIV.CommanderPawn != None) && (MyTankPanzerIV.CommanderPawn.Health > 0) && (!MyTankPanzerIV.CommanderPawn.bHatchClosing))
		{
			PeripheralVision = PeripheralVisionWithCommander;
		}
	}

	if ((MyTankPanzerIVController.BefuddledEndTime > 0.0) && (MyTankPanzerIVController.BefuddledEndTime < Level.TimeSeconds))
	{
		AimErrorAI = AimErrorAIBefuddled;
	}
	else
	{
		AimErrorAI = AimErrorAINormal;
	}

	Super.Timer();
}

function SeePawn( Pawn Seen )
{
	local Rotator TurretRotation;

//	Log( name $ ".(TankPanzerIVMainGunController-"$MyTank.name$").SeePawn( " $ Seen.name $ " )", 'Tank' );

	if (MyTankController.bNoEnemies)
		return;  // don't target or shoot at any enemies

	if ( MyTankController.bNoTargetPlayer && Seen.IsPlayerPawn() )
		return;  // don't target or shoot at player

	TurretRotation.Pitch = MyTankPanzerIV.Rotation.Pitch;
	TurretRotation.Yaw = (MyTankPanzerIV.Rotation.Yaw - MyTankPanzerIV.TurretYaw) & 65535;
	TurretRotation.Roll = 0;

	if (TankGunControllerCanSee(TurretRotation, Seen))
		ConsiderPossibleEnemy( Seen, true );
}

function HearNoise( float Loudness, Actor NoiseMaker )
{
//	Log( name $ ".(TankPanzerIVMainGunController-"$MyTank.name$").HearNoise( " $ Loudness $ " " $ NoiseMaker.name $ " )", 'Tank' );

	if (MyTankController.bNoEnemies)
		return;  // don't target or shoot at any enemies

	if ( MyTankController.bNoTargetPlayer && Pawn(NoiseMaker).IsPlayerPawn() )
		return;  // don't target or shoot at player

	if( NoiseMaker.IsA( 'Pawn' ))
	{
		// TODO do uncertainty.
		if ( MyTankController.bNoTargetPlayer && Pawn(NoiseMaker).IsPlayerPawn() )
			return;  // don't target or shoot at player

		ConsiderPossibleEnemy( Pawn( NoiseMaker ), true );
	}
}

function ConsiderPossibleEnemy( Pawn possibleEnemy, bool bAddToOtherGunController )
{
	Super.ConsiderPossibleEnemy(possibleEnemy, bAddToOtherGunController);

	// make sure the other gun on this tank knows about this possible enemy...
	if ((MyTankPanzerIVController.MyBowGunController != None) && (bAddToOtherGunController))
	{
		MyTankPanzerIVController.MyBowGunController.ConsiderPossibleEnemy(possibleEnemy, false);
	}
}

function bool SetEnemy( Actor newEnemy )
{
	bIsOnTarget = false;
	return Super.SetEnemy( newEnemy );
}

function int FindTargetInBowGunQueue(gbxPawn Target)
{
	local int i;

	if (MyTankPanzerIVController.MyBowGunController == None)
		return -1;

	for (i = 0; i < MyTankPanzerIVController.MyBowGunController.TargetQueue.Length; i++)
	{
		if (MyTankPanzerIVController.MyBowGunController.TargetQueue[i].Target == Target)
			return i;
	}

	return -1;  // not found
}

event AdjustTargetPriority(int index)
{
	local gbxPawn Target;
	local float priority, weights, delta_priority;
	local vector vDir, vForward;
	local rotator MainGunRot;
	local float dotTheta;
	local int NearbyTargets;
	local vector BowGunBoneLoc;

	Target = TargetQueue[index].Target;

	// recalculate the priority and weights from the native CalculateTargetPriority() function...
	priority = TargetQueue[index].TargetPriority * TargetQueue[index].TargetTotalWeight;
	weights = TargetQueue[index].TargetTotalWeight;

	// give higher priority to targets that are in the direction that the gun is already facing...
	vDir = Normal(Target.Location - MyTankPanzerIV.Location);
	MainGunRot.Pitch = (MyTankPanzerIV.Rotation.Pitch + MyTankPanzerIV.MainGunPitch) & 65535;
	MainGunRot.Yaw = (MyTankPanzerIV.Rotation.Yaw - MyTankPanzerIV.TurretYaw) & 65535;
	MainGunRot.Roll = 0;
	vForward = Vector(MainGunRot);

	dotTheta = (vDir dot vForward);  // 1.0 to -1.0
	dotTheta = (dotTheta / 2.0) + 0.5;  // 1.0 to 0.0

	delta_priority = dotTheta * TargetPriorityScalarInAimingDirection;
	if (bLogPriority)
		Log(name $ ".AdjustTargetPriority: Target " $ Target.name $ " - InAimingDirection priority = " $ delta_priority, 'Tank');
	priority += delta_priority;
	weights += TargetPriorityScalarInAimingDirection;

	// check what type of target this is (or what type of weapon the target is carrying)...

	if (Target.IsA('gbxSVehicle'))  // is this target a vehicle?
	{
		// give higher priority to enemy vehicles (tanks, trucks, jeeps, etc)...
		delta_priority = TargetPriorityScalarEnemyVehicle;
		if (bLogPriority)
			Log(name $ ".AdjustTargetPriority: Target " $ Target.name $ " - EnemyVehicle priority = " $ delta_priority, 'Tank');
		priority += delta_priority;
		weights += TargetPriorityScalarEnemyVehicle;
		TargetQueue[index].bUseCannon = 1;  // use the cannon to fire at this/these target(s)
	}

//	if (Target.IsA('MachineGun'))
//	{
//		if (bLogPriority)
//			Log(name $ ".AdjustTargetPriority: Target " $ Target.name $ " is a manned machine gun", 'Tank');
//		TargetQueue[index].bUseCannon = 1;  // use the cannon to fire at this/these target(s)
//	}

//	if (Target.IsA('Infantry'))
//	{
//		// check what weapon this infantry soldier is carrying...
//		if (Target.Weapon.IsA('USBazooka'))
//		{
//			if (bLogPriority)
//				Log(name $ ".AdjustTargetPriority: Target " $ Target.name $ " is a soldier carrying an anti-tank weapon", 'Tank');
//			TargetQueue[index].bUseCannon = 1;  // use the cannon to fire at this/these target(s)
//		}
//	}

	if ((Target.IsA('Infantry')) && (MyTankPanzerIVController.MyBowGunController != None))
	{
		// check to see if this infantry target is close to at least 2 other infantry targets...
		NearbyTargets = GetNumberOfNearbyInfantryTargets(Target);

		if (NearbyTargets >= 2)
		{
			// give higher priority to infantry targets that are in groups of 3 or more
			delta_priority = TargetPriorityScalarInfantryGroup;
			if (bLogPriority)
				Log(name $ ".AdjustTargetPriority: Target " $ Target.name $ " - InfantryGroup priority = " $ delta_priority, 'Tank');
			priority += delta_priority;
			weights += TargetPriorityScalarInfantryGroup;
			TargetQueue[index].bUseCannon = 1;  // use the cannon to fire at this/these target(s)
		}
		else  // otherwise, infantry target is close to no more than 1 other infantry target...
		{
			// check to see if this target is inside the BowGunTargetSelectionAngle for the bow gun...
			vDir = Normal(Target.Location - MyTankPanzerIV.Location);
			vForward = Vector(MyTankPanzerIV.Rotation);
			dotTheta = vDir dot vForward;

			if (dotTheta > MyTankPanzerIVController.MyBowGunController.BowGunTargetSelectionAngle)
			{
				if (!MyTankPanzerIVController.bIsNavigating)
				{
					// give lower priority to targets that are within the bow gun's selection angle
					delta_priority = dotTheta * (1.0 - MyTankPanzerIVController.MyBowGunController.TargetPriorityScalarBowGunSelectionAngle);
					if (bLogPriority)
						Log(name $ ".AdjustTargetPriority: Target " $ Target.name $ " - BowGunSelectionAngle priority = " $ delta_priority, 'Tank');
					priority += delta_priority;
					weights += (1.0 - MyTankPanzerIVController.MyBowGunController.TargetPriorityScalarBowGunSelectionAngle);
				}
				else
				{
					BowGunBoneLoc = MyTankPanzerIV.GetBoneCoords( MyTankPanzerIV.BowGunBoneName ).origin;

					vDir = Normal(Target.Location - BowGunBoneLoc);
					vForward = Vector(MyTankPanzerIV.Rotation);

					dotTheta = cos((MyTankPanzerIV.BowGunRotateMax / 180.0) * 3.14159);

					if ((vDir dot vForward) > dotTheta)
					{
						// give lower priority to targets that are within the bow gun's rotation angle
						delta_priority = dotTheta * (1.0 - MyTankPanzerIVController.MyBowGunController.TargetPriorityScalarBowGunRotationAngle);
						if (bLogPriority)
							Log(name $ ".AdjustTargetPriority: Target " $ Target.name $ " - BowGunRotationAngle priority = " $ delta_priority, 'Tank');
						priority += delta_priority;
						weights += (1.0 - MyTankPanzerIVController.MyBowGunController.TargetPriorityScalarBowGunRotationAngle);
					}
				}
			}
		}
	}

	priority = FClamp(priority, 0.0, priority);
	TargetQueue[index].TargetTotalWeight = weights;
	TargetQueue[index].TargetPriority = priority / weights;

	if (bLogPriority)
		Log(name $ ".AdjustTargetPriority: Target " $ Target.name $ " - final priority = " $ TargetQueue[index].TargetPriority, 'Tank');
}

function ReassignTargets()
{
	local int index;
	local float bestPriority;

	if (ndxEnemyInQueue < 0)  // no targets in queue?
		return;

	ndxEnemyInQueue = -1;
	bestPriority = 0.0f;

	for (index = 0; index < TargetQueue.Length; index++)
	{
		if (TargetQueue[index].RelegationTime > Level.TimeSeconds)
			continue;

		if ((ndxEnemyInQueue == -1) || (TargetQueue[index].TargetPriority > bestPriority))
		{
			ndxEnemyInQueue = index;
			bestPriority = TargetQueue[index].TargetPriority;
		}
	}
}

event vector GetGunControllerRotation()
{
	local Rotator TurretRotation;

	TurretRotation.Pitch = MyTankPanzerIV.Rotation.Pitch + MyTankPanzerIV.MainGunPitch;
	TurretRotation.Yaw = MyTankPanzerIV.Rotation.Yaw - MyTankPanzerIV.TurretYaw;
	TurretRotation.Roll = 0;

	return vector(TurretRotation);
}

function Tick( float deltaTime )
{
	local int IsHeadShot;
	local vector SuppressLoc, FailLoc;
	local bool bCanSeePawn, bHatchClosed;
	local vector TargetAimLoc;
	local vector aim_offset;
	local float ReactionTimeDelta;
	local float distance;

	Super.Tick( deltaTime );

	if (MyTankPanzerIVController == None)
		return;

	if (Enemy == None)
	{
		if (MyTankPanzerIVController.MainGunTarget != None)
		{
			fEnemyNoneTime = Level.TimeSeconds;

			MyTankPanzerIVController.MainGunTarget = None;
			MyTankPanzerIVController.bRotateToFaceEnemy = false;
			MyTankPanzerIVController.EnemyRotateToFace = None;
		}
	}
	else
	{
		if ((!MyTankPanzerIVController.bIsInScriptedMode) &&
			((fEnemySpottedTime < 0) || (MyTankPanzerIVController.MainGunTarget != Enemy)))
		{
			fEnemySpottedTime = Level.TimeSeconds;

			// have we NOT seen a target within the last 5 seconds?
			if (fGunReactionTime + 5.0 < Level.TimeSeconds)
			{
				// long reaction time, tank is not quite as aware...
				ReactionTimeDelta = ReactionTimeMax - ReactionTimeMin;
				fGunReactionTime = Level.TimeSeconds + ReactionTimeMin + (FRand() * ReactionTimeDelta);
			}
			else
			{
				// short reaction time, tank recently had an enemy and is more aware...
				fGunReactionTime = Level.TimeSeconds + 0.5 + (FRand() * 0.5f);
			}

			Log(name $ ".Tick() - MainGun Enemy " $ Enemy.name $ " spotted at " $ Level.TimeSeconds $ "  reaction time = " $ fGunReactionTime, 'Tank');

			MyTankPanzerIVController.MainGunTarget = Enemy;

			// does the tank need to rotate it's front to face this enemy (armor stronger at front)?
			if (Enemy.IsA('gbxSVehicle'))
			{
				MyTankPanzerIVController.bRotateToFaceEnemy = true;
				MyTankPanzerIVController.EnemyRotateToFace = Enemy;
			}
			else
			{
				if (Enemy.IsA('gbxPawn') && (gbxPawn(Enemy).MyUnit != None) && (gbxPawn(Enemy).MyUnit == MyTank.MyUnit.AssignedTargetUnit))
				{
					MyTankPanzerIVController.bRotateToFaceEnemy = true;
					MyTankPanzerIVController.EnemyRotateToFace = Enemy;
				}
				else
				{
					MyTankPanzerIVController.bRotateToFaceEnemy = false;
					MyTankPanzerIVController.EnemyRotateToFace = None;
				}
			}
		}
	}

	if ((MyTankPanzerIVController.bRotateToFaceEnemy) && (MyTankPanzerIVController.EnemyRotateToFace != None))
	{
		if (!MyTankPanzerIVController.bIsInScriptedMode)
		{
			bCanSeePawn = MyTankController.CanSeeOrSuppress(Pawn(MyTankPanzerIVController.MainGunTarget), SeeLoc, IsHeadShot, SuppressLoc, FailLoc);
		}
		else
		{
			bCanSeePawn = true;
			SeeLoc = MyTankPanzerIVController.EnemyRotateToFace.Location;
		}

		// is main gun target visible?, if so, rotate front armor to face target...
		if ((bCanSeePawn) &&
			((SeeLoc.X != 0.0) && (SeeLoc.Y != 0.0) && (SeeLoc.Z != 0.0)))
		{
			// don't need to do this if navigating, the TankController navigation code will do this for us...
			if (!MyTankPanzerIVController.bIsNavigating)
			{
				MyTankPanzerIVController.RotateTowardTarget(MyTankPanzerIVController.EnemyRotateToFace);
			}
		}
	}

	if (MyTankPanzerIVController.MainGunTarget != None)
	{
		bIsResettingTurret = false;

		if ((fGunReactionTime < Level.TimeSeconds) &&
			(MyTankPanzerIVController.GetStateName() != 'Hunting') &&
			(MyTankPanzerIVController.GetStateName() != 'GrenadePlanted') &&
			(MyTankPanzerIVController.GetStateName() != 'Panicked'))
		{
			if (!MyTankPanzerIVController.bIsInScriptedMode)
			{
				bCanSeePawn = MyTankController.CanSeeOrSuppress(Pawn(MyTankPanzerIVController.MainGunTarget), SeeLoc, IsHeadShot, SuppressLoc, FailLoc);
			}
			else
			{
				bCanSeePawn = true;
				SeeLoc = MyTankPanzerIVController.MainGunTarget.Location;
			}

			if (bCanSeePawn)
			{
				if (MyTankPanzerIVController.MainGunTarget.IsA( 'Infantry' ))  // is target an infantry soldier?
				{
					// aim for the feet...
					aim_offset = vect(0,0,0);
					aim_offset.Z = MyTankPanzerIVController.MainGunTarget.CollisionHeight;
					TargetAimLoc = SeeLoc - aim_offset;
				}
				else
				{
					// aim slightly below the center (Location) of target...
					aim_offset = vect(0,0,0);
					aim_offset.Z = MyTankPanzerIVController.MainGunTarget.CollisionHeight / 2.0f;
					TargetAimLoc = SeeLoc - aim_offset;
				}

				if ((SeeLoc.X == 0.0) && (SeeLoc.Y == 0.0) && (SeeLoc.Z == 0.0))
				{
//					TargetAimLoc = SuppressLoc;
					TargetAimLoc = TargetQueue[ndxEnemyInQueue].LastKnownLocation;
				}

				TrackMainGunTarget(DeltaTime, TargetAimLoc);  // track using the turret and the main gun

				if ((bIsOnTarget) && (MyTankPanzerIV.fMainGunReFireTime < Level.TimeSeconds) && (fMainGunFireTime < 0))
				{
					fMainGunFireTime = Level.TimeSeconds + fMainGunFireDelay;
				}
				else if (bIsYawOnTarget)
				{
					distance = VSize(MyTankPanzerIVController.MainGunTarget.Location - MyTankPanzerIV.Location);
					if ((distance < MyTankPanzerIV.VehicleCollisionRadius * 3.0) &&
						(MyTankPanzerIV.fMainGunReFireTime < Level.TimeSeconds) && (fMainGunFireTime < 0))
					{
						fMainGunFireTime = Level.TimeSeconds + fMainGunFireDelay;
					}
				}
			}
			else
			{
				fMainGunFireTime = -1.0;  // can't see the enemy
			}

			if (!MyTankPanzerIVController.bIsInScriptedMode)
			{
				bHatchClosed = true;  // assume true until known otherwise...
				if ((MyTankPanzerIV != None) && (MyTankPanzerIV.CommanderPawn != None) &&
					(MyTankPanzerIV.CommanderPawn.Health > 0))
				{
					bHatchClosed = MyTankPanzerIV.CommanderPawn.bHatchFullyClosed;
				}

				// time to fire the main gun yet?
				if ((bHatchClosed) && (fMainGunFireTime > 0.0) && (fMainGunFireTime < Level.TimeSeconds))
				{
					MyTankPanzerIV.fMainGunReFireTime = Level.TimeSeconds + MyTankPanzerIV.fMainGunReFireDelay + (FRand() * 2.0);
	
					FireMainGun(false);

					fMainGunFireTime = -1.0;
				}
			}
		}
	}
	else
	{
		// no current target...
		bIsOnTarget = false;
		fEnemySpottedTime = -1.0f;
		fMainGunFireTime = -1.0;

		// have we not seen an enemy in a while?
		if ((!bIsResettingTurret) && ((fEnemyNoneTime + fResetTurretTime) < Level.TimeSeconds) &&
			(!MyTankPanzerIVController.bIsInScriptedMode) &&
			((MyTankPanzerIV.TurretYaw != 0) || (MyTankPanzerIV.MainGunPitch != 0)))
		{
			if ((MyTankPanzerIVController.GetStateName() != 'Hunting') &&
				(MyTankPanzerIVController.GetStateName() != 'GrenadePlanted') &&
				(MyTankPanzerIVController.GetStateName() != 'Panicked'))
			{
				Log(name $ "(TankPanzerIVMainGunController).Tick() - setting bIsResettingTurret = true", 'Tank');
				bIsResettingTurret = true;  // start rotating the turret back to the forwards position
			}
		}

		if (bIsResettingTurret)
			bIsResettingTurret = ResetTurret(DeltaTime);
	}
}

function int GetNewRotation(int current, int desired, int rate)
{
	local int result;

	result = current & 65535;
	current = result;
	desired = desired & 65535;

	if (current > desired)
	{
		if (current - desired < 32768)
			result -= Min((current - desired), abs(rate));
		else
			result += Min((desired + 65536 - current), abs(rate));
	}
	else
	{
		if (desired - current < 32768)
			result += Min((desired - current), abs(rate));
		else
			result -= Min((current + 65536 - desired), abs(rate));
	}

	return (result & 65535);
}

function bool ResetTurret(float DeltaTime)
{
	local int WorldTurretYaw;
	local int WorldMainGunPitch;
	local float YawRate, PitchRate;
	local rotator TurretRot;
	local rotator MainGunRot;

	if (MyTankPanzerIV == None)
		return false;

	// convert TurretYaw and MainGunPitch to world space...
	WorldTurretYaw = (MyTankPanzerIV.Rotation.Yaw - MyTankPanzerIV.TurretYaw) & 65535;
	WorldMainGunPitch = (MyTankPanzerIV.Rotation.Pitch + MyTankPanzerIV.MainGunPitch) & 65535;

	YawRate = (MyTankPanzerIV.TurretRotationSpeed * DeltaTime / 360.0) * 65536;
	PitchRate = (MyTankPanzerIV.MainGunRotationSpeed * DeltaTime / 360.0) * 65536;

	WorldTurretYaw = GetNewRotation(WorldTurretYaw, MyTankPanzerIV.Rotation.Yaw, int(YawRate));
	WorldMainGunPitch = GetNewRotation(WorldMainGunPitch, MyTankPanzerIV.Rotation.Pitch, int(PitchRate));

	// convert TurretYaw and MainGunPitch back to local space...
	MyTankPanzerIV.TurretYaw = (MyTankPanzerIV.Rotation.Yaw - WorldTurretYaw) & 65535;
	MyTankPanzerIV.MainGunPitch = (WorldMainGunPitch - MyTankPanzerIV.Rotation.Pitch) & 65535;

	TurretRot.Pitch = 0;
	TurretRot.Yaw = MyTankPanzerIV.TurretYaw;
	TurretRot.Roll = 0;

	MyTankPanzerIV.SetBoneRotation(MyTankPanzerIV.TurretBoneName, TurretRot, 0, 1.0);

	MainGunRot.Pitch = 0;
	MainGunRot.Yaw = 0;
	MainGunRot.Roll = MyTankPanzerIV.MainGunPitch;

	MyTankPanzerIV.SetBoneRotation(MyTankPanzerIV.MainGunBoneName, MainGunRot, 0, 1.0);

	if ((MyTankPanzerIV.TurretYaw == 0) && (MyTankPanzerIV.MainGunPitch == 0))
	{
		Log(name $ "(TankPanzerIVMainGunController).ResetTurret() - rotation done, returning false", 'Tank');
		return false;  // finished rotating
	}

	return true;
}

function TrackMainGunTarget(float DeltaTime, vector TargetAimLoc)
{
	local int WorldTurretYaw;
	local int WorldMainGunPitch;
	local vector MainGunBoneLoc;
	local rotator RotToTarget;
	local float YawRate, PitchRate;
	local int MaxPitchUp, MaxPitchDown;
	local rotator TurretRot;
	local rotator MainGunRot;
	local int PitchDiff, YawDiff;

	if (MyTankPanzerIV == None)
		return;

	// convert TurretYaw and MainGunPitch to world space...
	WorldTurretYaw = (MyTankPanzerIV.Rotation.Yaw - MyTankPanzerIV.TurretYaw) & 65535;
	WorldMainGunPitch = (MyTankPanzerIV.Rotation.Pitch + MyTankPanzerIV.MainGunPitch) & 65535;

	MainGunBoneLoc = MyTankPanzerIV.GetBoneCoords( MyTankPanzerIV.MainGunBoneName ).origin;
	RotToTarget = rotator(TargetAimLoc - MainGunBoneLoc);

	YawRate = (MyTankPanzerIV.TurretRotationSpeed * DeltaTime / 360.0) * 65536;
	PitchRate = (MyTankPanzerIV.MainGunRotationSpeed * DeltaTime / 360.0) * 65536;

	WorldTurretYaw = GetNewRotation(WorldTurretYaw, RotToTarget.Yaw, int(YawRate));
	WorldMainGunPitch = GetNewRotation(WorldMainGunPitch, RotToTarget.Pitch, int(PitchRate));

	PitchDiff = abs((WorldMainGunPitch & 65535) - (RotToTarget.Pitch & 65535));
	if (PitchDiff > 32768)
		PitchDiff = 65536 - PitchDiff;

	YawDiff = abs((WorldTurretYaw & 65535) - (RotToTarget.Yaw & 65535));
	if (YawDiff > 32768)
		YawDiff = 65536 - YawDiff;

	bIsOnTarget = false;  // assume not on target until known otherwise
	bIsYawOnTarget = false;

	// is the gun aimed close enough to the target?
	if ((YawDiff < 500) && (PitchDiff < 500))
	{
		bIsOnTarget = true;  // gun is "on target", start shooting
	}

	if (YawDiff < 500)
	{
		bIsYawOnTarget = true;
	}

	// convert TurretYaw and MainGunPitch back to local space...
	MyTankPanzerIV.TurretYaw = (MyTankPanzerIV.Rotation.Yaw - WorldTurretYaw) & 65535;
	MyTankPanzerIV.MainGunPitch = (WorldMainGunPitch - MyTankPanzerIV.Rotation.Pitch) & 65535;

	MaxPitchUp = int((MyTankPanzerIV.MainGunUpwardFireArc / 360.0) * 65536.0);
	MaxPitchDown = int((MyTankPanzerIV.MainGunDownwardFireArc / 360.0) * 65536.0);

	if (MyTankPanzerIV.MainGunPitch > 32767)
		MyTankPanzerIV.MainGunPitch = MyTankPanzerIV.MainGunPitch - 65536;

	MyTankPanzerIV.MainGunPitch = Clamp(MyTankPanzerIV.MainGunPitch, -MaxPitchDown, MaxPitchUp);

	// for cases where gun has reached max pitch up/down, fire if yaw is on target and pitch is within 10 degrees of target...
	if ((YawDiff < 500) && ((MyTankPanzerIV.MainGunPitch == -MaxPitchDown) || (MyTankPanzerIV.MainGunPitch == MaxPitchUp)) &&
		(PitchDiff < 1820))
	{
		bIsOnTarget = true;  // gun is "on target", start shooting
	}

	TurretRot.Pitch = 0;
	TurretRot.Yaw = MyTankPanzerIV.TurretYaw;
	TurretRot.Roll = 0;

	MyTankPanzerIV.SetBoneRotation(MyTankPanzerIV.TurretBoneName, TurretRot, 0, 1.0);

	MainGunRot.Pitch = 0;
	MainGunRot.Yaw = 0;
	MainGunRot.Roll = MyTankPanzerIV.MainGunPitch;

	MyTankPanzerIV.SetBoneRotation(MyTankPanzerIV.MainGunBoneName, MainGunRot, 0, 1.0);
}

function Rotator AdjustAimNewTankShell( Ammunition Ammo, Vector ProjStart, Rotator AimRotator, InstantFire MyInstantFire, optional out int bSkipDoTrace )
{
	local float DistToTarget;
	local int index;
	local bool bCheckNoDamage;

	// check if the enemy is not a tank...
	if ((Enemy != None) && (!Enemy.IsA('Tank')))
	{
		bCheckNoDamage = false; // assume false until known otherwise

		index = FindTargetInQueue( Enemy );

		// check if the enemy is a "hard" target (Pak36 gunner, Panzerfaust soldier, etc)...
		if ( (index >= 0) && (TargetQueue[index].bIsHardTarget == 1) )
			bCheckNoDamage = true;

		// check if the enemy is manning a machine gun...
		if ( !bCheckNoDamage && (gbxPawn(Enemy) != None) && (gbxPawn(Enemy).bIsManningTurret) )
			bCheckNoDamage = true;

		if (bCheckNoDamage)
		{
			DistToTarget = VSize( Enemy.Location - MyTank.Location );

			// Is this a deadlock situation?
			if ( DistToTarget > MainGunDoNoDamageRange )
			{
				MyTankPanzerIV.MainGunFireMode.bIgnoreDamageThisBullet = true;
			}
		}
	}

	return Super.AdjustAimNewTankShell(Ammo, ProjStart, AimRotator, MyInstantFire, bSkipDoTrace);
}

function FireMainGun(bool bDoNoDamage)
{
	local vector MainGunLoc;
	local rotator MainGunRot;
	local vector RotX, RotY, RotZ;
	local int AimErrorLocal;
	local rotator AdjustedAim;
	local int bSkipDoTrace;
	local gbxTankShell TankShell;

	if (!bDoNoDamage)
		MyTankPanzerIV.MainGunFireMode.bIgnoreDamageThisBullet = false;

	MainGunLoc = MyTankPanzerIV.GetTagCoords( MyTankPanzerIV.MainGunMuzzleBoneName ).origin;

	MainGunRot.Pitch = MyTankPanzerIV.MainGunPitch;
	MainGunRot.Yaw = -MyTankPanzerIV.TurretYaw;
	MainGunRot.Roll = 0;

	MainGunRot = MyTankPanzerIV.Rotation + MainGunRot;

    GetAxes(MainGunRot,RotX,RotY,RotZ);

	MainGunLoc = MainGunLoc + MyTankPanzerIV.MainGunEmitterOffset.X * RotX + MyTankPanzerIV.MainGunEmitterOffset.Y * RotY + MyTankPanzerIV.MainGunEmitterOffset.Z * RotZ;

	MainGunRot.Pitch = 0;  // ignore main gun pitch for main gun smoke and dust emitter
	MainGunRot.Yaw = -MyTankPanzerIV.TurretYaw;
	MainGunRot.Roll = 0;

	MainGunRot = MyTankPanzerIV.Rotation + MainGunRot;

	// spawn main gun smoke and dust emitter...
	spawn(MyTankPanzerIV.MainGunSmokeEmitterClass, None,, MainGunLoc, MainGunRot);

	AimErrorLocal = AimErrorAI;

	AdjustedAim = MyTankPanzerIV.AdjustAimMainGun();

	ApplyAccuracy( AdjustedAim, AimErrorLocal );

	AdjustedAim = AdjustAimNewTankShell(MyTankPanzerIV.MainGunAmmo, MainGunLoc, AdjustedAim, MyTankPanzerIV.MainGunFireMode, bSkipDoTrace);

	// spawn main gun muzzle flash emitter...
	spawn(MyTankPanzerIV.MainGunFlashEmitterClass, None,, MainGunLoc, AdjustedAim);

	if (MyTankPanzerIV.MainGunFireMode.bIgnoreDamageThisBullet)
	{
		Log(name $ ".FireMainGun - bIgnoreDamageThisBullet was True, doing no damage", 'Tank');
		bDoNoDamage = true;
	}

	TankShell = Spawn( class'gbxTankShell', MyTankPanzerIV,, MainGunLoc, AdjustedAim );
	TankShell.Instigator = MyTankPanzerIV;

	if (bDoNoDamage)
		TankShell.Damage = 0.0f;

	MyTankPanzerIV.PlaySoundCue( MyTankPanzerIV.MainGunFireSound, SLOT_NONE, TransientSoundVolume,,,,false);

	MyTankPanzerIV.PlayMainGunFiringAnim(MyTankPanzerIV.TurretYaw);
}


defaultproperties
{
	TimerInterval=0.2

	PeripheralVisionWithCommander=-0.0  // +/- 90 degrees (180 degrees total)
	PeripheralVisionWithoutCommander=0.2588  // +/- 75 degrees (150 degrees total)

	bIsOnTarget=false

	fResetTurretTime=5.0  // if no enemy, start resetting the turret after 5.0 seconds
	fMainGunFireDelay=0.5  // how long to wait after main gun is "on target" before firing

	TargetPriorityScalarInfantryGroup=0.8

	bLogPriority=false

	AimErrorAI=400
	AimErrorAINormal=400
	AimErrorAIBefuddled=800

	ReactionTimeMin=4.0
	ReactionTimeMax=6.0
	ReactionTimeMinEasy=5.0
	ReactionTimeMaxEasy=7.0
	ReactionTimeMinNormal=4.0
	ReactionTimeMaxNormal=6.0
	ReactionTimeMinHard=3.0
	ReactionTimeMaxHard=4.0
	ReactionTimeMinAuthentic=2.0
	ReactionTimeMaxAuthentic=3.0

	PurposefulMissTimeStart=30.0
	PurposefulMissTimeBonus=5.0
	PurposefulMissTimeMax=45.0
	PurposefulMissTimeStartEasy=45.0
	PurposefulMissTimeBonusEasy=5.0
	PurposefulMissTimeMaxEasy=60.0
	PurposefulMissTimeStartNormal=30.0
	PurposefulMissTimeBonusNormal=5.0
	PurposefulMissTimeMaxNormal=45.0
	PurposefulMissTimeStartHard=20.0
	PurposefulMissTimeBonusHard=5.0
	PurposefulMissTimeMaxHard=30.0
	PurposefulMissTimeStartAuthentic=15.0
	PurposefulMissTimeBonusAuthentic=5.0
	PurposefulMissTimeMaxAuthentic=20.0

	TargetForgetTimeLong=10.0f
	TargetForgetTimeShort=10.0f
}
class TankShermanBowGunController extends TankGunController
	notplaceable;


var()	TankSherman				MyTankSherman;
var()	TankShermanController	MyTankShermanController;

// weapon targeting stuff...
var()	bool	bIsOnTarget;
var()	bool	bIsFiringBurst;		// are we firing a burst at a target?
var()	float	fBurstEndTime;		// time when this burst will end
var()	float	fBurstStartTime;	// time when next burst can start

var()	float	MinBurstLength;		// in seconds
var()	float	MaxBurstLength;		// in seconds
var()	float	MinPauseLength;		// in seconds
var()	float	MaxPauseLength;		// in seconds

var()	float	fEnemySpottedTime;	// when we first saw the enemy
var()	float	fEnemyNoneTime;		// time when enemy was last set to None

var(Target)	float BowGunTargetSelectionAngle;  // dot product of bow gun target selection angle
var(Target)	float TargetPriorityScalarBowGunSelectionAngle;
var(Target)	float TargetPriorityScalarBowGunRotationAngle;

var()	bool	bLogPriority;

var int AimErrorAI;


function Possess(Tank aPawn, TankController aController)
{
	Log( name $ ".(TankShermanBowGunController).Possess( " $ aPawn.name $ " " $ aController.name $ " )", 'Tank' );

	if (TankSherman(aPawn) == None)
	{
		Log(name $ ".Possess - aPawn (" $ aPawn.name $ ") is NOT a TankSherman!!!");
		return;
	}

	if (TankShermanController(aController) == None)
	{
		Log(name $ ".Possess - aController (" $ aController.name $ ") is NOT a TankShermanController!!!");
		return;
	}

	Super.Possess(aPawn, aController);

	MyTankSherman = TankSherman(aPawn);
	MyTankShermanController = TankShermanController(aController);

	fEnemyNoneTime = 0.0f;
	fEnemySpottedTime = -1.0f;  // enemy not spotted yet
}

function SeePawn( Pawn Seen )
{
//	Log( name $ ".(TankShermanBowGunController-"$MyTank.name$").SeePawn( " $ Seen.name $ " )", 'Tank' );

	if (MyTankController.bNoEnemies)
		return;  // don't target or shoot at any enemies

	if ( MyTankController.bNoTargetPlayer && Seen.IsPlayerPawn() )
		return;  // don't target or shoot at player

	if (TankGunControllerCanSee(MyTankSherman.Rotation, Seen))
		ConsiderPossibleEnemy( Seen, true );
}

function HearNoise( float Loudness, Actor NoiseMaker )
{
//	Log( name $ ".(TankShermanBowGunController-"$MyTank.name$").HearNoise( " $ Loudness $ " " $ NoiseMaker.name $ " )", 'Tank' );

	if (MyTankController.bNoEnemies)
		return;  // don't target or shoot at any enemies

	if ( MyTankController.bNoTargetPlayer && Pawn(NoiseMaker).IsPlayerPawn() )
		return;  // don't target or shoot at player

	if( NoiseMaker.IsA( 'Pawn' ))
	{
		// TODO do uncertainty.

		ConsiderPossibleEnemy( Pawn( NoiseMaker ), true );
	}
}

function ConsiderPossibleEnemy( Pawn possibleEnemy, bool bAddToOtherGunController )
{
	Super.ConsiderPossibleEnemy(possibleEnemy, bAddToOtherGunController);

	// make sure the other gun on this tank knows about this possible enemy...
	if ((MyTankShermanController.MyMainGunController != None) && (bAddToOtherGunController))
	{
		MyTankShermanController.MyMainGunController.ConsiderPossibleEnemy(possibleEnemy, false);
	}
}

function bool SetEnemy( Actor newEnemy )
{
	bIsOnTarget = false;
	return Super.SetEnemy( newEnemy );
}

function int FindTargetInMainGunQueue(gbxPawn Target)
{
	local int i;

	if (MyTankShermanController.MyMainGunController == None)
		return -1;

	for (i = 0; i < MyTankShermanController.MyMainGunController.TargetQueue.Length; i++)
	{
		if (MyTankShermanController.MyMainGunController.TargetQueue[i].Target == Target)
			return i;
	}

	return -1;  // not found
}

event AdjustTargetPriority(int index)
{
	local gbxPawn Target;
	local float priority, weights, delta_priority;
	local vector vDir, vForward;
	local float dotTheta;
	local int NearbyTargets;
	local vector BowGunBoneLoc;

	Target = TargetQueue[index].Target;

	// recalculate the priority and weights from the native CalculateTargetPriority() function...
	priority = TargetQueue[index].TargetPriority * TargetQueue[index].TargetTotalWeight;
	weights = TargetQueue[index].TargetTotalWeight;

	// give higher priority to targets that are in the direction that the gun is already facing...
	vDir = Normal(Target.Location - MyTankSherman.Location);
	vForward = Vector(MyTankSherman.Rotation);

	dotTheta = (vDir dot vForward);  // 1.0 to -1.0
	dotTheta = (dotTheta / 2.0) + 0.5;  // 1.0 to 0.0

	delta_priority = dotTheta * TargetPriorityScalarInAimingDirection;
	if (bLogPriority)
		Log(name $ ".AdjustTargetPriority: Target " $ Target.name $ " - InAimingDirection priority = " $ delta_priority, 'Tank');
	priority += delta_priority;
	weights += TargetPriorityScalarInAimingDirection;

	// check what type of target this is (or what type of weapon the target is carrying)...

	if (Target.IsA('gbxSVehicle'))  // is this target a vehicle?  If so, MainGunController handles it
	{
		if (bLogPriority)
			Log(name $ ".AdjustTargetPriority: Target " $ Target.name $ " is a vehicle", 'Tank');
		TargetQueue[index].bUseCannon = 1;  // use the cannon to fire at this/these target(s)
	}

//	if (!bAssignToMainGun && Target.IsA('MachineGun'))
//	{
//		if (bLogPriority)
//			Log(name $ ".AdjustTargetPriority: Target " $ Target.name $ " is a manned machine gun", 'Tank');
//		TargetQueue[index].bUseCannon = 1;  // use the cannon to fire at this/these target(s)
//	}

//	if (!bAssignToMainGun && Target.IsA('Infantry'))
//	{
//		// check what weapon this infantry soldier is carrying...
//		if (Target.Weapon.IsA('PatherFist'))
//		{
//			if (bLogPriority)
//				Log(name $ ".AdjustTargetPriority: Target " $ Target.name $ " is a soldier carrying an anti-tank weapon", 'Tank');
//			TargetQueue[index].bUseCannon = 1;  // use the cannon to fire at this/these target(s)
//		}
//	}

	if ((Target.IsA('Infantry')) && (MyTankShermanController.MyMainGunController != None))
	{
		// check to see if this infantry target is close to at least 2 other infantry targets...
		NearbyTargets = GetNumberOfNearbyInfantryTargets(Target);

		if (NearbyTargets >= 2)
		{
			// give lower priority to infantry targets that are in groups of 3 or more
			delta_priority = 1.0 - MyTankShermanController.MyMainGunController.TargetPriorityScalarInfantryGroup;
			if (bLogPriority)
				Log(name $ ".AdjustTargetPriority: Target " $ Target.name $ " - InfantryGroup priority = " $ delta_priority, 'Tank');
			priority += delta_priority;
			weights += (1.0 - MyTankShermanController.MyMainGunController.TargetPriorityScalarInfantryGroup);
		}
		else  // otherwise, infantry target is close to no more than 1 other infantry target...
		{
			// check to see if this target is inside the BowGunTargetSelectionAngle for the bow gun...
			vDir = Normal(Target.Location - MyTankSherman.Location);
			vForward = Vector(MyTankSherman.Rotation);
			dotTheta = vDir dot vForward;

			if (dotTheta > BowGunTargetSelectionAngle)
			{
				if (!MyTankShermanController.bIsNavigating)
				{
					// give higher priority to targets that are within the bow gun's selection angle
					delta_priority = dotTheta * TargetPriorityScalarBowGunSelectionAngle;
					if (bLogPriority)
						Log(name $ ".AdjustTargetPriority: Target " $ Target.name $ " - BowGunSelectionAngle priority = " $ delta_priority, 'Tank');
					priority += delta_priority;
					weights += TargetPriorityScalarBowGunSelectionAngle;
				}
				else
				{
					BowGunBoneLoc = MyTankSherman.GetBoneCoords( MyTankSherman.BowGunBoneName ).origin;

					vDir = Normal(Target.Location - BowGunBoneLoc);
					vForward = Vector(MyTankSherman.Rotation);

					dotTheta = cos((MyTankSherman.BowGunRotateMax / 180.0) * 3.14159);

					if ((vDir dot vForward) > dotTheta)
					{
						// give higher priority to targets that are within the bow gun's rotation angle
						delta_priority = dotTheta * MyTankShermanController.MyBowGunController.TargetPriorityScalarBowGunRotationAngle;
						if (bLogPriority)
							Log(name $ ".AdjustTargetPriority: Target " $ Target.name $ " - BowGunRotationAngle priority = " $ delta_priority, 'Tank');
						priority += delta_priority;
						weights += MyTankShermanController.MyBowGunController.TargetPriorityScalarBowGunRotationAngle;
					}
				}
			}
		}
	}

	priority = FClamp(priority, 0.0, priority);
	TargetQueue[index].TargetTotalWeight = weights;
	TargetQueue[index].TargetPriority = priority / weights;

	if (bLogPriority)
		Log(name $ ".AdjustTargetPriority: Target " $ Target.name $ " - final priority = " $ TargetQueue[index].TargetPriority, 'Tank');
}

function ReassignTargets()
{
	local int index;
	local float bestPriority;

	if (ndxEnemyInQueue < 0)  // no targets in queue?
		return;

	ndxEnemyInQueue = -1;
	bestPriority = 0.0f;

	for (index = 0; index < TargetQueue.Length; index++)
	{
		if (TargetQueue[index].RelegationTime > Level.TimeSeconds)
			continue;

		if ((ndxEnemyInQueue == -1) || (TargetQueue[index].TargetPriority > bestPriority))
		{
			ndxEnemyInQueue = index;
			bestPriority = TargetQueue[index].TargetPriority;
		}
	}
}

event vector GetGunControllerRotation()
{
	return vector(MyTankSherman.Rotation);
}

function Tick( float deltaTime )
{
	local vector BowGunLoc;
	local rotator BowGunRot;
	local int IsHeadShot;
	local vector SuppressLoc, FailLoc;
	local bool bCanSeePawn;
	local vector TargetAimLoc;
	local Actor RotateTarget;
	local float ReactionTimeDelta;

	Super.Tick( deltaTime );

	if (MyTankShermanController == None)
		return;

	if (Enemy == None)
	{
		if (MyTankShermanController.BowGunTarget != None)
		{
			fEnemyNoneTime = Level.TimeSeconds;
		}

		MyTankShermanController.BowGunTarget = None;
	}
	else
	{
		if ((fEnemySpottedTime < 0) || (MyTankShermanController.BowGunTarget != Enemy))
		{
			fEnemySpottedTime = Level.TimeSeconds;

			// have we NOT seen a target within the last 5 seconds?
			if (fGunReactionTime + 5.0 < Level.TimeSeconds)
			{
				// long reaction time, tank is not quite as aware...
				ReactionTimeDelta = ReactionTimeMax - ReactionTimeMin;
				fGunReactionTime = Level.TimeSeconds + ReactionTimeMin + (FRand() * ReactionTimeDelta);
			}
			else
			{
				// short reaction time, tank recently had an enemy and is more aware...
				fGunReactionTime = Level.TimeSeconds + 0.5 + (FRand() * 0.5f);
			}

			Log(name $ ".Tick() - BowGun Enemy " $ Enemy.name $ " spotted at " $ Level.TimeSeconds $ "  reaction time = " $ fGunReactionTime, 'Tank');
		}

		MyTankShermanController.BowGunTarget = Enemy;
	}

	if (MyTankShermanController.BowGunTarget != None)
	{
		if (fGunReactionTime < Level.TimeSeconds)
		{
			bCanSeePawn = MyTankController.CanSeeOrSuppress(Pawn(MyTankShermanController.BowGunTarget), SeeLoc, IsHeadShot, SuppressLoc, FailLoc);

			if (bCanSeePawn)
			{
				TargetAimLoc = SeeLoc;
				RotateTarget = MyTankShermanController.BowGunTarget;

				if ((SeeLoc.X == 0.0) && (SeeLoc.Y == 0.0) && (SeeLoc.Z == 0.0))
				{
//					TargetAimLoc = SuppressLoc;
					TargetAimLoc = TargetQueue[ndxEnemyInQueue].LastKnownLocation;
					RotateTarget = None;  // don't rotate to track target since we can't see him
				}

				TrackBowGunTarget(deltaTime, TargetAimLoc, RotateTarget);  // track using the bow machine gun
	
				// are we on target AND not firing a burst AND time to start a new burst?
				if ((bIsOnTarget) && (!bIsFiringBurst) && (fBurstStartTime < Level.TimeSeconds))
				{
					BowGunLoc = MyTankSherman.GetTagCoords( MyTankSherman.BowGunMuzzleBoneName ).origin;
					BowGunRot = MyTankSherman.Rotation - MyTankSherman.BowGunRotation;

					// see if we can shoot at what we're aiming at without hitting teammates...
					if (ApproveShot(BowGunLoc, BowGunRot))
					{
						bIsFiringBurst = true;
						MyTankSherman.BowGunSoundHandle = MyTankSherman.PlaySoundCue( MyTankSherman.BowGunFireLoopSound, SLOT_NONE, TransientSoundVolume,,,,false);
	
						fBurstEndTime = Level.TimeSeconds + MinBurstLength + (FRand() * (MaxBurstLength - MinBurstLength));
						fBurstStartTime = fBurstEndTime + MinPauseLength + (FRand() * (MaxPauseLength - MinPauseLength));
					}
					else
					{
						// try firing again after 0.5 - 2.5 seconds...
						fBurstStartTime = Level.TimeSeconds + 0.5 + (FRand() * 2.0);
					}
				}
			}
		}
	}
	else
	{
		// no current target...
		bIsOnTarget = false;
		fEnemySpottedTime = -1.0f;
	}

	if (bIsFiringBurst)
	{
		if (fBurstEndTime < Level.TimeSeconds)  // has the burst ended?
		{
			bIsFiringBurst = false;
			MyTankSherman.StopSound( MyTankSherman.BowGunSoundHandle );
			MyTankSherman.PlaySoundCue( MyTankSherman.BowGunFireOnceSound, SLOT_NONE, TransientSoundVolume,,,,false);
		}
		else
		{
			if (MyTankSherman.fBowGunReFireTime < Level.Timeseconds)
			{
				FireBowGun(false);
			}
		}
	}
}

function int GetNewRotation(int current, int desired, int rate)
{
	local int result;

	result = current & 65535;
	current = result;
	desired = desired & 65535;

	if (current > desired)
	{
		if (current - desired < 32768)
			result -= Min((current - desired), abs(rate));
		else
			result += Min((desired + 65536 - current), abs(rate));
	}
	else
	{
		if (desired - current < 32768)
			result += Min((desired - current), abs(rate));
		else
			result -= Min((current + 65536 - desired), abs(rate));
	}

	return (result & 65535);
}

function TrackBowGunTarget(float DeltaTime, vector TargetAimLoc, Actor RotateTarget)
{
	local rotator WorldBowGunRot;
	local vector BowGunBoneLoc;
	local rotator RotToTarget;
	local float AdjustRate;
	local rotator BowGunRot;
	local int MaxRot, MinRot;
	local int PitchDiff, YawDiff;

	if (MyTankSherman == None)
		return;

	// convert BowGunRotation to world space...
	WorldBowGunRot.Pitch = (MyTankSherman.Rotation.Pitch - MyTankSherman.BowGunRotation.Pitch) & 65535;
	WorldBowGunRot.Yaw = (MyTankSherman.Rotation.Yaw - MyTankSherman.BowGunRotation.Yaw) & 65535;
	WorldBowGunRot.Roll = 0;

	BowGunBoneLoc = MyTankSherman.GetBoneCoords( MyTankSherman.BowGunBoneName ).origin;
	RotToTarget = rotator(TargetAimLoc - BowGunBoneLoc);

	AdjustRate = (MyTankSherman.BowGunRotationSpeed * DeltaTime / 360.0) * 65536;

	WorldBowGunRot.Pitch = GetNewRotation(WorldBowGunRot.Pitch, RotToTarget.Pitch, int(AdjustRate));
	WorldBowGunRot.Yaw = GetNewRotation(WorldBowGunRot.Yaw, RotToTarget.Yaw, int(AdjustRate));

	PitchDiff = abs((WorldBowGunRot.Pitch & 65535) - (RotToTarget.Pitch & 65535));
	if (PitchDiff > 32768)
		PitchDiff = 65536 - PitchDiff;

	YawDiff = abs((WorldBowGunRot.Yaw & 65535) - (RotToTarget.Yaw & 65535));
	if (YawDiff > 32768)
		YawDiff = 65536 - YawDiff;

	bIsOnTarget = false;  // assume not on target until known otherwise

	// is the bow machine gun aimed close enough to the target?
	if ((YawDiff < 500) && (PitchDiff < 500))
	{
		bIsOnTarget = true;  // bow gun is "on target", start shooting
	}

	// convert BowGunRotation back to local space...
	MyTankSherman.BowGunRotation.Pitch = (MyTankSherman.Rotation.Pitch - WorldBowGunRot.Pitch) & 65535;
	MyTankSherman.BowGunRotation.Yaw = (MyTankSherman.Rotation.Yaw - WorldBowGunRot.Yaw) & 65535;
	MyTankSherman.BowGunRotation.Roll = 0;

	if (MyTankSherman.BowGunRotation.Pitch > 32767)
		MyTankSherman.BowGunRotation.Pitch = MyTankSherman.BowGunRotation.Pitch - 65536;
	if (MyTankSherman.BowGunRotation.Yaw > 32767)
		MyTankSherman.BowGunRotation.Yaw = MyTankSherman.BowGunRotation.Yaw - 65536;

	MaxRot = int((MyTankSherman.BowGunRotateMax / 360.0) * 65536.0);
	MinRot = int((-MyTankSherman.BowGunRotateMax / 360.0) * 65536.0);

	MyTankSherman.BowGunRotation.Pitch = Clamp(MyTankSherman.BowGunRotation.Pitch, MinRot, MaxRot);
	MyTankSherman.BowGunRotation.Yaw = Clamp(MyTankSherman.BowGunRotation.Yaw, MinRot, MaxRot);

	// is bow machine gun at horizontal limit of rotation range?
	if ((MyTankSherman.BowGunRotation.Yaw == MinRot) ||
		(MyTankSherman.BowGunRotation.Yaw == MaxRot))
	{
		if (!MyTankShermanController.bIsRotating)  // is the tank not currently rotating towards the target?
		{
			// request the tank to rotate towards the target...
			if (RotateTarget != None)
				MyTankShermanController.RotateTowardTarget(RotateTarget);
			else
				MyTankShermanController.RotateTowardLocation(TargetAimLoc);
		}
	}

	BowGunRot.Pitch = MyTankSherman.BowGunRotation.Yaw;
	BowGunRot.Yaw = MyTankSherman.BowGunRotation.Pitch;
	BowGunRot.Roll = 0;

	MyTankSherman.SetBoneRotation(MyTankSherman.BowGunBoneName, BowGunRot, 0, 1.0);
}

function FireBowGun(bool bDoNoDamage)
{
	local vector BowGunLoc;
	local rotator BowGunRot;
	local vector RotX, RotY, RotZ;
	local int AimErrorLocal;
	local rotator AdjustedAim;
	local int bSkipDoTrace;
	local Emitter MuzzleFlash;

	if (MyTankSherman.BowGunFireMode != None)
	{
		MyTankSherman.fBowGunReFireTime = Level.TimeSeconds + MyTankSherman.fBowGunReFireDelay;

		BowGunLoc = MyTankSherman.GetTagCoords( MyTankSherman.BowGunMuzzleBoneName ).origin;

		BowGunRot = MyTankSherman.Rotation - MyTankSherman.BowGunRotation;

	    GetAxes(BowGunRot,RotX,RotY,RotZ);

		BowGunLoc = BowGunLoc + MyTankSherman.BowGunEmitterOffset.X * RotX + MyTankSherman.BowGunEmitterOffset.Y * RotY + MyTankSherman.BowGunEmitterOffset.Z * RotZ;

		MyTankSherman.Owner.MakeNoise(1.0);

		AimErrorLocal = AimErrorAI;

		AdjustedAim = MyTankSherman.AdjustAimBowGun();

		ApplyAccuracy( AdjustedAim, AimErrorLocal );

		AdjustedAim = AdjustAimNewBullet(MyTankSherman.BowGunAmmo, BowGunLoc, AdjustedAim, MyTankSherman.BowGunFireMode, bSkipDoTrace);

		if (bDoNoDamage)
			MyTankSherman.BowGunFireMode.SetNoDamageThisBullet();

		MyTankSherman.BowGunFireMode.DoTrace(BowGunLoc, AdjustedAim);

		MyTankSherman.BowGunTracerCount++;

		if ( MyTankSherman.BowGunTracerCount >= MyTankSherman.BowGunTracerFrequency )
		{
			MyTankSherman.BowGunTracerCount = 0;

			// Emit a tracer
			if( (MyTankSherman.BowGunTracerEmitter != None) )
				MyTankSherman.BowGunTracerEmitter.TriggerEmitters( BowGunLoc, AdjustedAim );
		}

		MuzzleFlash = MyTankSherman.BowGunFireMode.GetMuzzleFlash();

		MuzzleFlash.SetLocation(BowGunLoc);
		MuzzleFlash.SetRotation(BowGunRot);

		if ( MuzzleFlash.IsA( 'gbxMuzzleFlash' ) )
			gbxMuzzleFlash(MuzzleFlash).ShowMuzzleFlash();
	}
}


defaultproperties
{
	bIsOnTarget=false
	bIsFiringBurst=false

	MinBurstLength=2.0
	MaxBurstLength=3.5
	MinPauseLength=1.0
	MaxPauseLength=2.0

	BowGunTargetSelectionAngle=0.5  // cosine of 60 degrees

	BulletDoNoDamageRange=5000.0

	TargetPriorityScalarBowGunSelectionAngle=0.75
	TargetPriorityScalarBowGunRotationAngle=0.9

	bLogPriority=false

	AimErrorAI=400

	ReactionTimeMin=0.3
	ReactionTimeMax=0.7
	ReactionTimeMinEasy=0.3
	ReactionTimeMaxEasy=0.7
	ReactionTimeMinNormal=0.5
	ReactionTimeMaxNormal=1.0
	ReactionTimeMinHard=1.2
	ReactionTimeMaxHard=2.0
	ReactionTimeMinAuthentic=2.0
	ReactionTimeMaxAuthentic=3.0

	TargetForgetTimeLong=30.0f
	TargetForgetTimeShort=15.0f
}
class TankShermanController extends TankControllerUS
	notplaceable;


var()	TankSherman						MyTankSherman;
var()	TankShermanMainGunController	MyMainGunController;
var()	TankShermanBowGunController		MyBowGunController;

// enemy targeting stuff...
var()	Actor	MainGunTarget;
var()	Actor	CoaxGunTarget;
var()	Actor	BowGunTarget;


function Possess(Pawn aPawn)
{
	Log( name $ ".(TankShermanController).Possess( " $ aPawn.name $ " )", 'Tank' );

	Super.Possess(aPawn);

	if ((aPawn == None) || (TankSherman(aPawn) == None))
	{
		Log(name $ ".Possess() - WARNING! TankShermanController's Pawn is NOT a TankSherman!!!");
	}
	else
	{
		MyTankSherman = TankSherman(aPawn);

		MyMainGunController = spawn(class'TankShermanMainGunController', self);
		if (MyMainGunController == None)
			Log( name $ ".(TankShermanController).Possess() - ERROR Spawning TankShermanMainGunController!!!", 'Tank' );
		else
			MyMainGunController.Possess(MyTankSherman, self);

		MyBowGunController = spawn(class'TankShermanBowGunController', self);
		if (MyBowGunController == None)
			Log( name $ ".(TankShermanController).Possess() - ERROR Spawning TankShermanBowGunController!!!", 'Tank' );
		else
			MyBowGunController.Possess(MyTankSherman, self);
	}
}

function Destroyed()
{
	Log( name $ ".(TankShermanController).Destroyed()", 'Tank' );

	if (MyMainGunController != None)
		MyMainGunController.Destroy();
	if (MyBowGunController != None)
		MyBowGunController.Destroy();

	super.Destroyed();
}

function Timer()
{
	Super.Timer();

	if (fPauseMovementCheckTime < Level.TimeSeconds)
	{
		fPauseMovementCheckTime = Level.TimeSeconds + 2.0f;

		bPauseMovement = false;  // stop moving and attack enemy from here

		if ( (MyMainGunController != None) && MyMainGunController.ShouldTankPause() )
		{
			bPauseMovement = true;  // stop moving and attack enemy from here
		}
		else if ( (MyBowGunController != None) && MyBowGunController.ShouldTankPause() )
		{
			bPauseMovement = true;  // stop moving and attack enemy from here
		}
	}
}

function PawnDied(Pawn P)
{
	Super.PawnDied(P);
}

function Tick(float DeltaTime)
{
	Super.Tick(DeltaTime);

	if (MyTankSherman.WeapUSSherman50calMachineGun != None)
	{
		bIsPlayerMounting = MyTankSherman.WeapUSSherman50calMachineGun.bIsMounting;
	}
}

function NotifyTakeHit(pawn InstigatedBy, vector HitLocation, int Damage, class<DamageType> damageType, vector Momentum)
{
//	Log( name $ "(" $ Pawn.name $ ").NotifyTakeHit( " $ InstigatedBy.name $ " )", 'Tank' );

	if (bIsInScriptedMode)
		return;  // don't do anything if under scripted control

	if (MyMainGunController != None)
		MyMainGunController.NotifyTakeHit(InstigatedBy, HitLocation, Damage, damageType, Momentum);

	if (MyBowGunController != None)
		MyBowGunController.NotifyTakeHit(InstigatedBy, HitLocation, Damage, damageType, Momentum);

	Super.NotifyTakeHit( InstigatedBy, HitLocation, Damage, damageType, Momentum );
}

function SeePawn( Pawn Seen )
{
//	Log( name $ "(" $ Pawn.name $ ").SeePawn( " $ Seen.name $ " )", 'Tank' );

	if (bIsInScriptedMode)
		return;  // don't do anything if under scripted control

	if (MyMainGunController != None)
		MyMainGunController.SeePawn(Seen);

	if (MyBowGunController != None)
		MyBowGunController.SeePawn(Seen);

	Super.SeePawn(Seen);
}

function SeePawnKilled( Pawn Seen, Pawn Killer )
{
//	Log( name $ "(" $ Pawn.name $ ").SeePawnKilled( " $ Seen.name $ " )", 'Tank' );

	if (bIsInScriptedMode)
		return;  // don't do anything if under scripted control

	// Seeing your friends get killed.
	if (MyMainGunController != None)
		MyMainGunController.SeePawnKilled(Seen, Killer);

	if (MyBowGunController != None)
		MyBowGunController.SeePawnKilled(Seen, Killer);

	Super.SeePawnKilled(Seen, Killer);
}

function SeePawnHit( Pawn Seen )
{
//	Log( name $ "(" $ Pawn.name $ ").SeePawnHit( " $ Seen.name $ " )", 'Tank' );

	if (bIsInScriptedMode)
		return;  // don't do anything if under scripted control

	if (MyMainGunController != None)
		MyMainGunController.SeePawnHit(Seen);

	if (MyBowGunController != None)
		MyBowGunController.SeePawnHit(Seen);

	Super.SeePawnHit(Seen);
}

function HearNoise( float Loudness, Actor NoiseMaker )
{
//	Log( name $ "(" $ Pawn.name $ ").HearNoise( " $ Loudness $ ", " $ NoiseMaker.name $ " )", 'Tank' );

	if (bIsInScriptedMode)
		return;  // don't do anything if under scripted control

	if (MyMainGunController != None)
		MyMainGunController.HearNoise(Loudness, NoiseMaker);

	if (MyBowGunController != None)
		MyBowGunController.HearNoise(Loudness, NoiseMaker);

	Super.HearNoise(Loudness, NoiseMaker);
}

function SeePlayer( Pawn Seen )
{
//	Log( name $ "(" $ Pawn.name $ ").SeePlayer( " $ Seen.name $ " )", 'Tank' );

	if (bIsInScriptedMode)
		return;  // don't do anything if under scripted control

	if (MyMainGunController != None)
		MyMainGunController.SeePlayer(Seen);

	if (MyBowGunController != None)
		MyBowGunController.SeePlayer(Seen);

	Super.SeePlayer(Seen);
}

function SeeExplosion( Pawn Instigator )
{
//	Log( name $ "(" $ Pawn.name $ ").SeeExplosion( " $ Instigator.name $ " )", 'Tank' );

	if (bIsInScriptedMode)
		return;  // don't do anything if under scripted control

	// Seeing shit get blown up.
	if (MyMainGunController != None)
		MyMainGunController.SeeExplosion(Instigator);

	if (MyBowGunController != None)
		MyBowGunController.SeeExplosion(Instigator);

	Super.SeeExplosion(Instigator);
}

function NotifyTargetOrder(Unit targetUnit)
{
	local int i;

	// notify this member about all Targets in the targetUnit...
	for (i = 0; i < targetUnit.NumMembers; i++)
	{
		if (MyMainGunController != None)
			MyMainGunController.AddTarget( targetUnit.Members[i] );
		if (MyBowGunController != None)
			MyBowGunController.AddTarget( targetUnit.Members[i] );
	}
}

function NotifyAssaultOrder(Unit targetUnit)
{
	local int i;

	// notify this member about all Targets in the targetUnit...
	for (i = 0; i < targetUnit.NumMembers; i++)
	{
		if (MyMainGunController != None)
			MyMainGunController.AddTarget( targetUnit.Members[i] );
		if (MyBowGunController != None)
			MyBowGunController.AddTarget( targetUnit.Members[i] );
	}
}

function ConsiderPossibleEnemy( Pawn possibleEnemy )
{
	if (bIsInScriptedMode)
		return;  // don't do anything if under scripted control

	if (MyMainGunController != None)
		MyMainGunController.ConsiderPossibleEnemy(possibleEnemy, false);

	if (MyBowGunController != None)
		MyBowGunController.ConsiderPossibleEnemy(possibleEnemy, false);
}

event float GetTargetExposureToMe( Pawn aThreat )
{
	local float MainGunExp, BowGunExp;

	MainGunExp = MyMainGunController.GetTargetExposureToMe(aThreat);
	BowGunExp = MyBowGunController.GetTargetExposureToMe(aThreat);

	if (MainGunExp > BowGunExp)
		return MainGunExp;

	return BowGunExp;
}

function bool TankHasEnemy()
{
	if (MyMainGunController != None)
	{
		if (MyMainGunController.ndxEnemyInQueue >= 0)
			return true;
	}

	if (MyBowGunController != None)
	{
		if (MyBowGunController.ndxEnemyInQueue >= 0)
			return true;
	}

	return false;
}


defaultproperties
{
}
class TankShermanMainGunController extends TankGunController
	notplaceable;


var()	TankSherman				MyTankSherman;
var()	TankShermanController	MyTankShermanController;

// weapon targeting stuff...
var()	bool	bIsOnTarget;
var()	bool	bIsYawOnTarget;
var()	bool	bIsFiringBurst;		// are we firing a burst at a target?
var()	float	fBurstEndTime;		// time when this burst will end
var()	float	fBurstStartTime;	// time when next burst can start

var()	float	MinBurstLength;		// in seconds
var()	float	MaxBurstLength;		// in seconds
var()	float	MinPauseLength;		// in seconds
var()	float	MaxPauseLength;		// in seconds

var()	float	fEnemySpottedTime;	// when we first saw the enemy
var()	float	fEnemyNoneTime;		// time when enemy was last set to None
var()	float	fResetTurretTime;	// how long after enemy = none to reset turret back to facing fowards
var()	bool	bIsResettingTurret;
var()	bool	bIsPlayerOnTank;
var()	float	fCoaxGunFrustrationDelay;	// how long the coax gun tries firing at an enemy before switching to the main gun
var()	float 	fCoaxGunFrustrationTime;	// time at which the coax gun becomes frustrated

var(Target)	float TargetPriorityScalarInfantryGroup;

var()	bool	bLogPriority;

var		int		AimErrorAIMain, AimErrorAICoax;


function Possess(Tank aPawn, TankController aController)
{
	Log( name $ ".(TankShermanMainGunController).Possess( " $ aPawn.name $ " " $ aController.name $ " )", 'Tank' );

	if (TankSherman(aPawn) == None)
	{
		Log(name $ ".Possess - aPawn (" $ aPawn.name $ ") is NOT a TankSherman!!!");
		return;
	}

	if (TankShermanController(aController) == None)
	{
		Log(name $ ".Possess - aController (" $ aController.name $ ") is NOT a TankShermanController!!!");
		return;
	}

	Super.Possess(aPawn, aController);

	MyTankSherman = TankSherman(aPawn);
	MyTankShermanController = TankShermanController(aController);

	fEnemyNoneTime = 0.0f;
	fEnemySpottedTime = -1.0f;  // enemy not spotted yet
	MyTankShermanController.fRotateToFaceCheckTime = -1.0f;

	bIsPlayerOnTank = false;
}

function Timer()
{
//	Log( name $ ".(TankShermanMainGunController).Timer()", 'Tank' );

	if (MyTankShermanController.bIsInScriptedMode)
	{
		Super.Timer();
		return;
	}

	PeripheralVision = PeripheralVisionWithoutCommander;  // default to vision without tank commander

	if (MyTankSherman != None)
	{
		if (MyTankSherman.bSpawnCommander)  // if tank was spawned without a commander, use same vision as if had a commander...
		{
			PeripheralVision = PeripheralVisionWithCommander;
		}
		else if ((MyTankSherman.CommanderPawn != None) && (MyTankSherman.CommanderPawn.Health > 0) && (!MyTankSherman.CommanderPawn.bHatchClosing))
		{
			PeripheralVision = PeripheralVisionWithCommander;
		}
	}

	Super.Timer();
}

function SeePawn( Pawn Seen )
{
	local Rotator TurretRotation;

//	Log( name $ ".(TankShermanMainGunController-"$MyTank.name$").SeePawn( " $ Seen.name $ " )", 'Tank' );

	if (MyTankController.bNoEnemies)
		return;  // don't target or shoot at any enemies

	if ( MyTankController.bNoTargetPlayer && Seen.IsPlayerPawn() )
		return;  // don't target or shoot at player

	TurretRotation.Pitch = MyTankSherman.Rotation.Pitch;
	TurretRotation.Yaw = (MyTankSherman.Rotation.Yaw - MyTankSherman.TurretYaw) & 65535;
	TurretRotation.Roll = 0;

	if (TankGunControllerCanSee(TurretRotation, Seen))
		ConsiderPossibleEnemy( Seen, true );
}

function HearNoise( float Loudness, Actor NoiseMaker )
{
//	Log( name $ ".(TankShermanMainGunController-"$MyTank.name$").HearNoise( " $ Loudness $ " " $ NoiseMaker.name $ " )", 'Tank' );

	if (MyTankController.bNoEnemies)
		return;  // don't target or shoot at any enemies

	if ( MyTankController.bNoTargetPlayer && Pawn(NoiseMaker).IsPlayerPawn() )
		return;  // don't target or shoot at player

	if( NoiseMaker.IsA( 'Pawn' ))
	{
		// TODO do uncertainty.

		ConsiderPossibleEnemy( Pawn( NoiseMaker ), true );
	}
}

function ConsiderPossibleEnemy( Pawn possibleEnemy, bool bAddToOtherGunController )
{
	Super.ConsiderPossibleEnemy(possibleEnemy, bAddToOtherGunController);

	// make sure the other gun on this tank knows about this possible enemy...
	if ((MyTankShermanController.MyBowGunController != None) && (bAddToOtherGunController))
	{
		MyTankShermanController.MyBowGunController.ConsiderPossibleEnemy(possibleEnemy, false);
	}
}

function bool SetEnemy( Actor newEnemy )
{
	bIsOnTarget = false;
	return Super.SetEnemy( newEnemy );
}

function int FindTargetInBowGunQueue(gbxPawn Target)
{
	local int i;

	if (MyTankShermanController.MyBowGunController == None)
		return -1;

	for (i = 0; i < MyTankShermanController.MyBowGunController.TargetQueue.Length; i++)
	{
		if (MyTankShermanController.MyBowGunController.TargetQueue[i].Target == Target)
			return i;
	}

	return -1;  // not found
}

event AdjustTargetPriority(int index)
{
	local gbxPawn Target;
	local float priority, weights, delta_priority;
	local vector vDir, vForward;
	local rotator MainGunRot;
	local float dotTheta;
	local int NearbyTargets;
	local vector BowGunBoneLoc;

	Target = TargetQueue[index].Target;

	// recalculate the priority and weights from the native CalculateTargetPriority() function...
	priority = TargetQueue[index].TargetPriority * TargetQueue[index].TargetTotalWeight;
	weights = TargetQueue[index].TargetTotalWeight;

	// give higher priority to targets that are in the direction that the gun is already facing...
	vDir = Normal(Target.Location - MyTankSherman.Location);
	MainGunRot.Pitch = (MyTankSherman.Rotation.Pitch + MyTankSherman.MainGunPitch) & 65535;
	MainGunRot.Yaw = (MyTankSherman.Rotation.Yaw - MyTankSherman.TurretYaw) & 65535;
	MainGunRot.Roll = 0;
	vForward = Vector(MainGunRot);

	dotTheta = (vDir dot vForward);  // 1.0 to -1.0
	dotTheta = (dotTheta / 2.0) + 0.5;  // 1.0 to 0.0

	delta_priority = dotTheta * TargetPriorityScalarInAimingDirection;
	if (bLogPriority)
		Log(name $ ".AdjustTargetPriority: Target " $ Target.name $ " - InAimingDirection priority = " $ delta_priority, 'Tank');
	priority += delta_priority;
	weights += TargetPriorityScalarInAimingDirection;

	// check what type of target this is (or what type of weapon the target is carrying)...

	if (Target.IsA('gbxSVehicle'))  // is this target a vehicle?
	{
		// give higher priority to enemy vehicles (tanks, trucks, jeeps, etc)...
		delta_priority = TargetPriorityScalarEnemyVehicle;
		if (bLogPriority)
			Log(name $ ".AdjustTargetPriority: Target " $ Target.name $ " - EnemyVehicle priority = " $ delta_priority, 'Tank');
		priority += delta_priority;
		weights += TargetPriorityScalarEnemyVehicle;
		TargetQueue[index].bUseCannon = 1;  // use the cannon to fire at this/these target(s)
	}

//	if (Target.IsA('MachineGun'))
//	{
//		if (bLogPriority)
//			Log(name $ ".AdjustTargetPriority: Target " $ Target.name $ " is a manned machine gun", 'Tank');
//		TargetQueue[index].bUseCannon = 1;  // use the cannon to fire at this/these target(s)
//	}

//	if (Target.IsA('Infantry'))
//	{
//		// check what weapon this infantry soldier is carrying...
//		if (Target.Weapon.IsA('PatherFist'))
//		{
//			if (bLogPriority)
//				Log(name $ ".AdjustTargetPriority: Target " $ Target.name $ " is a soldier carrying an anti-tank weapon", 'Tank');
//			TargetQueue[index].bUseCannon = 1;  // use the cannon to fire at this/these target(s)
//		}
//	}

	if ((Target.IsA('Infantry')) && (MyTankShermanController.MyBowGunController != None))
	{
		// check to see if this infantry target is close to at least 2 other infantry targets...
		NearbyTargets = GetNumberOfNearbyInfantryTargets(Target);

		if (NearbyTargets >= 2)
		{
			// give higher priority to infantry targets that are in groups of 3 or more
			delta_priority = TargetPriorityScalarInfantryGroup;
			if (bLogPriority)
				Log(name $ ".AdjustTargetPriority: Target " $ Target.name $ " - InfantryGroup priority = " $ delta_priority, 'Tank');
			priority += delta_priority;
			weights += TargetPriorityScalarInfantryGroup;
			TargetQueue[index].bUseCannon = 1;  // use the cannon to fire at this/these target(s)
		}
		else  // otherwise, infantry target is close to no more than 1 other infantry target...
		{
			// check to see if this target is inside the BowGunTargetSelectionAngle for the bow gun...
			vDir = Normal(Target.Location - MyTankSherman.Location);
			vForward = Vector(MyTankSherman.Rotation);
			dotTheta = vDir dot vForward;

			if (dotTheta > MyTankShermanController.MyBowGunController.BowGunTargetSelectionAngle)
			{
				if (!MyTankShermanController.bIsNavigating)
				{
					// give lower priority to targets that are within the bow gun's selection angle
					delta_priority = dotTheta * (1.0 - MyTankShermanController.MyBowGunController.TargetPriorityScalarBowGunSelectionAngle);
					if (bLogPriority)
						Log(name $ ".AdjustTargetPriority: Target " $ Target.name $ " - BowGunSelectionAngle priority = " $ delta_priority, 'Tank');
					priority += delta_priority;
					weights += (1.0 - MyTankShermanController.MyBowGunController.TargetPriorityScalarBowGunSelectionAngle);
				}
				else
				{
					BowGunBoneLoc = MyTankSherman.GetBoneCoords( MyTankSherman.BowGunBoneName ).origin;

					vDir = Normal(Target.Location - BowGunBoneLoc);
					vForward = Vector(MyTankSherman.Rotation);

					dotTheta = cos((MyTankSherman.BowGunRotateMax / 180.0) * 3.14159);

					if ((vDir dot vForward) > dotTheta)
					{
						// give lower priority to targets that are within the bow gun's rotation angle
						delta_priority = dotTheta * (1.0 - MyTankShermanController.MyBowGunController.TargetPriorityScalarBowGunRotationAngle);
						if (bLogPriority)
							Log(name $ ".AdjustTargetPriority: Target " $ Target.name $ " - BowGunRotationAngle priority = " $ delta_priority, 'Tank');
						priority += delta_priority;
						weights += (1.0 - MyTankShermanController.MyBowGunController.TargetPriorityScalarBowGunRotationAngle);
					}
				}
			}
		}
	}

	priority = FClamp(priority, 0.0, priority);
	TargetQueue[index].TargetTotalWeight = weights;
	TargetQueue[index].TargetPriority = priority / weights;

	if (bLogPriority)
		Log(name $ ".AdjustTargetPriority: Target " $ Target.name $ " - final priority = " $ TargetQueue[index].TargetPriority, 'Tank');
}

function ReassignTargets()
{
	local int index;
	local float bestPriority;

	if (ndxEnemyInQueue < 0)  // no targets in queue?
		return;

	ndxEnemyInQueue = -1;
	bestPriority = 0.0f;

	for (index = 0; index < TargetQueue.Length; index++)
	{
		if (TargetQueue[index].RelegationTime > Level.TimeSeconds)
			continue;

		if ((ndxEnemyInQueue == -1) || (TargetQueue[index].TargetPriority > bestPriority))
		{
			ndxEnemyInQueue = index;
			bestPriority = TargetQueue[index].TargetPriority;
		}
	}
}

event vector GetGunControllerRotation()
{
	local Rotator TurretRotation;

	TurretRotation.Pitch = MyTankSherman.Rotation.Pitch + MyTankSherman.MainGunPitch;
	TurretRotation.Yaw = MyTankSherman.Rotation.Yaw - MyTankSherman.TurretYaw;
	TurretRotation.Roll = 0;

	return vector(TurretRotation);
}

function Tick( float deltaTime )
{
	local vector CoaxGunLoc;
	local rotator CoaxGunRot;
	local int IsHeadShot;
	local vector SuppressLoc, FailLoc;
	local bool bCanSeePawn, bHatchClosed;
	local vector TargetAimLoc;
	local vector aim_offset;
	local float ReactionTimeDelta;
	local float distance;
	local bool bOnTarget;

	Super.Tick( deltaTime );

	if (MyTankShermanController == None)
		return;

	if (MyTankSherman.WeapUSSherman50calMachineGun != None)
	{
		if (MyTankSherman.WeapUSSherman50calMachineGun.IsInUse() && !bIsPlayerOnTank)
		{
			bIsPlayerOnTank = true;

			bIsResettingTurret = true;
		}
	}

	if (bIsPlayerOnTank)
	{
		bIsPlayerOnTank = MyTankSherman.WeapUSSherman50calMachineGun.IsInUse() || MyTankSherman.IsPlayerOnTank();
	}

	if (Enemy == None)
	{
		if ((MyTankShermanController.MainGunTarget != None) ||
			(MyTankShermanController.CoaxGunTarget != None))
		{
			fEnemyNoneTime = Level.TimeSeconds;

			MyTankShermanController.MainGunTarget = None;
			MyTankShermanController.CoaxGunTarget = None;
			MyTankShermanController.bRotateToFaceEnemy = false;
			MyTankShermanController.EnemyRotateToFace = None;
			MyTankShermanController.fRotateToFaceCheckTime = -1.0f;
		}
	}
	else if ((!MyTankShermanController.bIsInScriptedMode) &&
			 (Enemy.IsA('gbxSVehicle') || ((ndxEnemyInQueue >= 0) && (TargetQueue[ndxEnemyInQueue].bUseCannon == 1))))
	{
		if ((fEnemySpottedTime < 0) || (MyTankShermanController.MainGunTarget != Enemy))
		{
			fEnemySpottedTime = Level.TimeSeconds;

			// have we NOT seen a target within the last 5 seconds?
			if (fGunReactionTime + 5.0 < Level.TimeSeconds)
			{
				// long reaction time, tank is not quite as aware...
				ReactionTimeDelta = ReactionTimeMax - ReactionTimeMin;
				fGunReactionTime = Level.TimeSeconds + ReactionTimeMin + (FRand() * ReactionTimeDelta);
			}
			else
			{
				// short reaction time, tank recently had an enemy and is more aware...
				fGunReactionTime = Level.TimeSeconds + 0.5 + (FRand() * 0.5f);
			}

			Log(name $ ".Tick() - MainGun Enemy " $ Enemy.name $ " spotted at " $ Level.TimeSeconds $ "  reaction time = " $ fGunReactionTime, 'Tank');

			MyTankShermanController.MainGunTarget = Enemy;
			MyTankShermanController.CoaxGunTarget = None;

			MyTankShermanController.fRotateToFaceCheckTime = Level.TimeSeconds;
		}
	}
	else
	{
		if ((!MyTankShermanController.bIsInScriptedMode) &&
			((fEnemySpottedTime < 0) || (MyTankShermanController.CoaxGunTarget != Enemy)))
		{
			fEnemySpottedTime = Level.TimeSeconds;

			// have we NOT seen a target within the last 5 seconds?
			if (fGunReactionTime + 5.0 < Level.TimeSeconds)
			{
				// long reaction time, tank is not quite as aware...
				ReactionTimeDelta = ReactionTimeMax - ReactionTimeMin;
				fGunReactionTime = Level.TimeSeconds + ReactionTimeMin + (FRand() * ReactionTimeDelta);
			}
			else
			{
				// short reaction time, tank recently had an enemy and is more aware...
				fGunReactionTime = Level.TimeSeconds + 0.5 + (FRand() * 0.5f);
			}

			fCoaxGunFrustrationTime = fGunReactionTime + fCoaxGunFrustrationDelay + (FRand() * 2.0);

			Log(name $ ".Tick() - CoaxGun Enemy " $ Enemy.name $ " spotted at " $ Level.TimeSeconds $ "  reaction time = " $ fGunReactionTime, 'Tank');

			MyTankShermanController.CoaxGunTarget = Enemy;
			MyTankShermanController.MainGunTarget = None;
			MyTankShermanController.bRotateToFaceEnemy = false;
			MyTankShermanController.EnemyRotateToFace = Enemy;
		}
	}

	// periodically, check to see if tank should stop here and rotate to face enemy (stronger armor at front of tank)...
	if ((MyTankShermanController.fRotateToFaceCheckTime >= 0.0) && (MyTankShermanController.fRotateToFaceCheckTime <= Level.TimeSeconds))
	{
		MyTankShermanController.fRotateToFaceCheckTime = Level.TimeSeconds + 2.0f;

		// do we currently have an enemy, are we not in scripted mode, and is this enemy a 'hard' target (something that damages tanks)?...
		if ((Enemy != None) && (!MyTankShermanController.bIsInScriptedMode) &&
			 ((ndxEnemyInQueue >= 0) && (TargetQueue[ndxEnemyInQueue].bIsHardTarget == 1)))
		{
			// is this enemy a Pawn in a Unit that I've been told to assault?
			if (Enemy.IsA('gbxPawn') && (gbxPawn(Enemy).MyUnit != None) &&
				(gbxPawn(Enemy).MyUnit == MyTank.MyUnit.AssignedTargetUnit) && UnitControllerAI(MyTank.MyUnit.MyUnitController).bAssaultThisTarget)
			{
				distance = VSize(MyTank.Location - Enemy.Location);
				if (distance <= UnitControllerAITank(MyTank.MyUnit.MyUnitController).IdealAssaultDistance)
				{
					// only stop and turn to face enemy if we are already inside the assault radius...
					MyTankShermanController.bRotateToFaceEnemy = true;
					MyTankShermanController.EnemyRotateToFace = Enemy;
				}
			}
			else
			{
				// else, for all other cases, rotate to face this enemy (when distance is less than RotateToFaceDistance)
				MyTankShermanController.bRotateToFaceEnemy = true;
				MyTankShermanController.EnemyRotateToFace = Enemy;
			}
		}
	}

	if ((MyTankShermanController.bRotateToFaceEnemy) && (MyTankShermanController.EnemyRotateToFace != None))
	{
		if (!MyTankShermanController.bIsInScriptedMode)
		{
			bCanSeePawn = MyTankController.CanSeeOrSuppress(Pawn(MyTankShermanController.MainGunTarget), SeeLoc, IsHeadShot, SuppressLoc, FailLoc);
		}
		else
		{
			bCanSeePawn = true;
			SeeLoc = MyTankShermanController.EnemyRotateToFace.Location;
		}

		// is main gun target visible?, if so, rotate front armor to face target...
		if ((bCanSeePawn) &&
			((SeeLoc.X != 0.0) && (SeeLoc.Y != 0.0) && (SeeLoc.Z != 0.0)))
		{
			// don't need to do this if navigating, the TankController navigation code will do this for us...
			if (!MyTankShermanController.bIsNavigating)
			{
				MyTankShermanController.RotateTowardTarget(MyTankShermanController.EnemyRotateToFace);
			}
		}
	}

	if (MyTankShermanController.MainGunTarget != None)
	{
		if (!bIsPlayerOnTank)
			bIsResettingTurret = false;

		if (fGunReactionTime < Level.TimeSeconds)
		{
			if (!MyTankShermanController.bIsInScriptedMode)
			{
				bCanSeePawn = MyTankController.CanSeeOrSuppress(Pawn(MyTankShermanController.MainGunTarget), SeeLoc, IsHeadShot, SuppressLoc, FailLoc);
			}
			else
			{
				bCanSeePawn = true;
				SeeLoc = MyTankShermanController.MainGunTarget.Location;
			}

			if (bCanSeePawn)
			{
				if (MyTankShermanController.MainGunTarget.IsA( 'Infantry' ))  // is target an infantry soldier?
				{
					// aim for the feet...
					aim_offset = vect(0,0,0);
					aim_offset.Z = MyTankShermanController.MainGunTarget.CollisionHeight;
					TargetAimLoc = SeeLoc - aim_offset;
				}
				else
				{
					// aim slightly below the center (Location) of target...
					aim_offset = vect(0,0,0);
					aim_offset.Z = MyTankShermanController.MainGunTarget.CollisionHeight / 2.0f;
					TargetAimLoc = SeeLoc - aim_offset;
				}

				if ((SeeLoc.X == 0.0) && (SeeLoc.Y == 0.0) && (SeeLoc.Z == 0.0))
				{
//					TargetAimLoc = SuppressLoc;
					TargetAimLoc = TargetQueue[ndxEnemyInQueue].LastKnownLocation;
				}

				TrackMainGunTarget(deltaTime, TargetAimLoc, false);  // track using the turret and the main gun

				if (!MyTankShermanController.bIsInScriptedMode)
				{
					bHatchClosed = true;  // assume true until known otherwise...
					if ((MyTankSherman != None) && (MyTankSherman.CommanderPawn != None) &&
						(MyTankSherman.CommanderPawn.Health > 0))
					{
						bHatchClosed = MyTankSherman.CommanderPawn.bHatchFullyClosed;
					}

					if (bIsPlayerOnTank)
						bOnTarget = bIsYawOnTarget;  // more forgiving if player is riding on tank
					else
						bOnTarget = bIsOnTarget;

					if ((bOnTarget) && (bHatchClosed) && (MyTankSherman.fMainGunReFireTime < Level.TimeSeconds))
					{
						MyTankSherman.fMainGunReFireTime = Level.TimeSeconds + MyTankSherman.fMainGunReFireDelay + (FRand() * 2.0);
	
						FireMainGun(false);
					}
					else if (bIsYawOnTarget)
					{
						distance = VSize(MyTankShermanController.MainGunTarget.Location - MyTankSherman.Location);
						if ((distance < MyTankSherman.VehicleCollisionRadius * 3.0) &&
							(bHatchClosed) && (MyTankSherman.fMainGunReFireTime < Level.TimeSeconds))
						{
							MyTankSherman.fMainGunReFireTime = Level.TimeSeconds + MyTankSherman.fMainGunReFireDelay + (FRand() * 2.0);
	
							FireMainGun(false);
						}
					}
				}
			}
		}
	}
	else if (MyTankShermanController.CoaxGunTarget != None)
	{
		if (!bIsPlayerOnTank)
			bIsResettingTurret = false;

		if (fGunReactionTime < Level.TimeSeconds)
		{
			bCanSeePawn = MyTankController.CanSeeOrSuppress(Pawn(MyTankShermanController.CoaxGunTarget), SeeLoc, IsHeadShot, SuppressLoc, FailLoc);

			if (bCanSeePawn)
			{
				TargetAimLoc = SeeLoc;

				if ((SeeLoc.X == 0.0) && (SeeLoc.Y == 0.0) && (SeeLoc.Z == 0.0))
				{
//					TargetAimLoc = SuppressLoc;
					TargetAimLoc = TargetQueue[ndxEnemyInQueue].LastKnownLocation;
				}

				TrackMainGunTarget(deltaTime, TargetAimLoc, true);  // track using the turret and coax machine gun
	
				// are we on target AND not firing a burst AND time to start a new burst?
				if ((bIsOnTarget) && (!bIsFiringBurst) && (fBurstStartTime < Level.TimeSeconds))
				{
					// is it time to switch to the main gun (is the coax gun "frustrated")?
					if ((fCoaxGunFrustrationTime) < Level.TimeSeconds)
					{
						bHatchClosed = true;  // assume true until known otherwise...
						if ((MyTankSherman != None) && (MyTankSherman.CommanderPawn != None) &&
							(MyTankSherman.CommanderPawn.Health > 0))
						{
							bHatchClosed = MyTankSherman.CommanderPawn.bHatchFullyClosed;
						}

						if ((bIsOnTarget) && (bHatchClosed) && (MyTankSherman.fMainGunReFireTime < Level.TimeSeconds))
						{
							MyTankSherman.fMainGunReFireTime = Level.TimeSeconds + MyTankSherman.fMainGunReFireDelay + (FRand() * 2.0);
	
							FireMainGun(false);
	
							// reset the coax gun frustration time...
							fCoaxGunFrustrationTime = Level.TimeSeconds + fCoaxGunFrustrationDelay + (FRand() * 2.0);

							// don't start firing the coax gun again for a little while after firing the main gun...
							fBurstStartTime = Level.TimeSeconds + MinPauseLength + FRand() * 1.0;
						}
					}
					else
					{
						CoaxGunLoc = MyTankSherman.GetTagCoords( MyTankSherman.CoaxGunMuzzleBoneName ).origin;

						CoaxGunRot.Pitch = MyTankSherman.Rotation.Pitch + MyTankSherman.MainGunPitch;
						CoaxGunRot.Yaw = MyTankSherman.Rotation.Yaw - MyTankSherman.TurretYaw;
						CoaxGunRot.Roll = 0;

						// see if we can shoot at what we're aiming at without hitting teammates...
						if (ApproveShot(CoaxGunLoc, CoaxGunRot))
						{
							bIsFiringBurst = true;
							MyTankSherman.CoaxGunSoundHandle = MyTankSherman.PlaySoundCue( MyTankSherman.CoaxGunFireLoopSound, SLOT_NONE, TransientSoundVolume,,,,false);
	
							fBurstEndTime = Level.TimeSeconds + MinBurstLength + (FRand() * (MaxBurstLength - MinBurstLength));
							fBurstStartTime = fBurstEndTime + MinPauseLength + (FRand() * (MaxPauseLength - MinPauseLength));
						}
						else
						{
							// try firing again after 0.5 - 2.5 seconds...
							fBurstStartTime = Level.TimeSeconds + 0.5 + (FRand() * 2.0);
						}
					}
				}
			}
		}
	}
	else
	{
		// no current target...
		bIsOnTarget = false;
		fEnemySpottedTime = -1.0f;

		// have we not seen an enemy in a while?
		if ((!bIsResettingTurret) && ((fEnemyNoneTime + fResetTurretTime) < Level.TimeSeconds) &&
			(!MyTankShermanController.bIsInScriptedMode) &&
			((MyTankSherman.TurretYaw != 0) || (MyTankSherman.MainGunPitch != 0)))
		{
			Log(name $ "(TankShermanMainGunController).Tick() - setting bIsResettingTurret = true", 'Tank');
			bIsResettingTurret = true;  // start rotating the turret back to the forwards position
		}
	}

	if (bIsResettingTurret)
	{
		bIsResettingTurret = ResetTurret(deltaTime);

		if (!bIsResettingTurret && MyTankSherman.WeapUSSherman50calMachineGun.bCameraIsPaused)
		{
			MyTankSherman.WeapUSSherman50calMachineGun.bCameraIsPaused = false;
			MyTankSherman.WeapUSSherman50calMachineGun.MountStartStamp = MyTankSherman.WeapUSSherman50calMachineGun.MountStartStamp +
						 (Level.TimeSeconds - MyTankSherman.WeapUSSherman50calMachineGun.CameraPausedTime);
			MyTankSherman.WeapUSSherman50calMachineGun.MyGunner.ResumeAnim();
		}
	}

	if (bIsFiringBurst)
	{
		bCanSeePawn = MyTankController.CanSeeOrSuppress(Pawn(MyTankShermanController.CoaxGunTarget), SeeLoc, IsHeadShot, SuppressLoc, FailLoc);

		if (bCanSeePawn)
		{
			TargetAimLoc = SeeLoc;

			if ((SeeLoc.X == 0.0) && (SeeLoc.Y == 0.0) && (SeeLoc.Z == 0.0))
			{
//				TargetAimLoc = SuppressLoc;
				TargetAimLoc = TargetQueue[ndxEnemyInQueue].LastKnownLocation;
			}

			TrackMainGunTarget(deltaTime, TargetAimLoc, true);  // track using the turret and coax machine gun
		}

		if (fBurstEndTime < Level.TimeSeconds)  // has the burst ended?
		{
			bIsFiringBurst = false;
			MyTankSherman.StopSound( MyTankSherman.CoaxGunSoundHandle );
			MyTankSherman.PlaySoundCue( MyTankSherman.CoaxGunFireOnceSound, SLOT_NONE, TransientSoundVolume,,,,false);
		}
		else
		{
			if (MyTankSherman.fCoaxGunReFireTime < Level.Timeseconds)
			{
				FireCoaxGun(false);
			}
		}
	}
}

function int GetNewRotation(int current, int desired, int rate)
{
	local int result;

	result = current & 65535;
	current = result;
	desired = desired & 65535;

	if (current > desired)
	{
		if (current - desired < 32768)
			result -= Min((current - desired), abs(rate));
		else
			result += Min((desired + 65536 - current), abs(rate));
	}
	else
	{
		if (desired - current < 32768)
			result += Min((desired - current), abs(rate));
		else
			result -= Min((current + 65536 - desired), abs(rate));
	}

	return (result & 65535);
}

function bool ResetTurret(float DeltaTime)
{
	local int WorldTurretYaw;
	local int WorldMainGunPitch;
	local float YawRate, PitchRate;
	local rotator TurretRot;
	local rotator MainGunRot;

	if (MyTankSherman == None)
		return false;

	// convert TurretYaw and MainGunPitch to world space...
	WorldTurretYaw = (MyTankSherman.Rotation.Yaw - MyTankSherman.TurretYaw) & 65535;
	WorldMainGunPitch = (MyTankSherman.Rotation.Pitch + MyTankSherman.MainGunPitch) & 65535;

	YawRate = (MyTankSherman.TurretRotationSpeed * DeltaTime / 360.0) * 65536;
	PitchRate = (MyTankSherman.MainGunRotationSpeed * DeltaTime / 360.0) * 65536;

	WorldTurretYaw = GetNewRotation(WorldTurretYaw, MyTankSherman.Rotation.Yaw, int(YawRate));
	WorldMainGunPitch = GetNewRotation(WorldMainGunPitch, MyTankSherman.Rotation.Pitch, int(PitchRate));

	// convert TurretYaw and MainGunPitch back to local space...
	MyTankSherman.TurretYaw = (MyTankSherman.Rotation.Yaw - WorldTurretYaw) & 65535;
	MyTankSherman.MainGunPitch = (WorldMainGunPitch - MyTankSherman.Rotation.Pitch) & 65535;

	TurretRot.Pitch = MyTankSherman.TurretYaw;
	TurretRot.Yaw = 0;
	TurretRot.Roll = 0;

	MyTankSherman.SetBoneRotation(MyTankSherman.TurretBoneName, TurretRot, 0, 1.0);

	MainGunRot.Pitch = 0;
	MainGunRot.Yaw = -MyTankSherman.MainGunPitch;
	MainGunRot.Roll = 0;

	MyTankSherman.SetBoneRotation(MyTankSherman.MainGunBoneName, MainGunRot, 0, 1.0);

	if ((MyTankSherman.TurretYaw == 0) && (MyTankSherman.MainGunPitch == 0))
	{
		Log(name $ "(TankShermanMainGunController).ResetTurret() - rotation done, returning false", 'Tank');
		return false;  // finished rotating
	}

	return true;
}

function TrackMainGunTarget(float DeltaTime, vector TargetAimLoc, bool bUseCoax)
{
	local int WorldTurretYaw;
	local int WorldMainGunPitch;
	local vector MainGunBoneLoc, CoaxGunBoneLoc;
	local rotator RotToTarget;
	local float YawRate, PitchRate;
	local int MaxPitchUp, MaxPitchDown;
	local rotator TurretRot;
	local rotator MainGunRot;
	local int PitchDiff, YawDiff;

	if (MyTankSherman == None)
		return;

	// convert TurretYaw and MainGunPitch to world space...
	WorldTurretYaw = (MyTankSherman.Rotation.Yaw - MyTankSherman.TurretYaw) & 65535;
	WorldMainGunPitch = (MyTankSherman.Rotation.Pitch + MyTankSherman.MainGunPitch) & 65535;

	if (!bUseCoax)
	{
		MainGunBoneLoc = MyTankSherman.GetBoneCoords( MyTankSherman.MainGunBoneName ).origin;
		RotToTarget = rotator(TargetAimLoc - MainGunBoneLoc);
	}
	else
	{
		CoaxGunBoneLoc = MyTankSherman.GetTagCoords( MyTankSherman.CoaxGunBoneName ).origin;
		RotToTarget = rotator(TargetAimLoc - CoaxGunBoneLoc);
	}

	if (bIsPlayerOnTank)
		YawRate = 0;
	else
		YawRate = (MyTankSherman.TurretRotationSpeed * DeltaTime / 360.0) * 65536;

	PitchRate = (MyTankSherman.MainGunRotationSpeed * DeltaTime / 360.0) * 65536;

	WorldTurretYaw = GetNewRotation(WorldTurretYaw, RotToTarget.Yaw, int(YawRate));
	WorldMainGunPitch = GetNewRotation(WorldMainGunPitch, RotToTarget.Pitch, int(PitchRate));

	PitchDiff = abs((WorldMainGunPitch & 65535) - (RotToTarget.Pitch & 65535));
	if (PitchDiff > 32768)
		PitchDiff = 65536 - PitchDiff;

	YawDiff = abs((WorldTurretYaw & 65535) - (RotToTarget.Yaw & 65535));
	if (YawDiff > 32768)
		YawDiff = 65536 - YawDiff;

	bIsOnTarget = false;  // assume not on target until known otherwise
	bIsYawOnTarget = false;

	// is the gun aimed close enough to the target?
	if ((YawDiff < 500) && (PitchDiff < 500))
	{
		bIsOnTarget = true;  // gun is "on target", start shooting
	}

	if (YawDiff < 800)
	{
		bIsYawOnTarget = true;
	}

	if (bIsPlayerOnTank)
	{
		// does the tank need to rotate to aim the main gun at the enemy?...
		if (YawDiff >= 500)
		{
			// request the tank to rotate towards the target...
			if (!bUseCoax)
				MyTankShermanController.RotateTowardTarget(MyTankShermanController.MainGunTarget, true);
			else
				MyTankShermanController.RotateTowardLocation(TargetAimLoc, true);
		}
	}

	// convert TurretYaw and MainGunPitch back to local space...
	MyTankSherman.TurretYaw = (MyTankSherman.Rotation.Yaw - WorldTurretYaw) & 65535;
	MyTankSherman.MainGunPitch = (WorldMainGunPitch - MyTankSherman.Rotation.Pitch) & 65535;

	MaxPitchUp = int((MyTankSherman.MainGunUpwardFireArc / 360.0) * 65536.0);
	MaxPitchDown = int((MyTankSherman.MainGunDownwardFireArc / 360.0) * 65536.0);

	if (MyTankSherman.MainGunPitch > 32767)
		MyTankSherman.MainGunPitch = MyTankSherman.MainGunPitch - 65536;

	MyTankSherman.MainGunPitch = Clamp(MyTankSherman.MainGunPitch, -MaxPitchDown, MaxPitchUp);

	// for cases where gun has reached max pitch up/down, fire if yaw is on target and pitch is within 10 degrees of target...
	if ((YawDiff < 500) && ((MyTankSherman.MainGunPitch == -MaxPitchDown) || (MyTankSherman.MainGunPitch == MaxPitchUp)) &&
		(PitchDiff < 1820))
	{
		bIsOnTarget = true;  // gun is "on target", start shooting
	}

	TurretRot.Pitch = MyTankSherman.TurretYaw;
	TurretRot.Yaw = 0;
	TurretRot.Roll = 0;

	MyTankSherman.SetBoneRotation(MyTankSherman.TurretBoneName, TurretRot, 0, 1.0);

	MainGunRot.Pitch = 0;
	MainGunRot.Yaw = -MyTankSherman.MainGunPitch;
	MainGunRot.Roll = 0;

	MyTankSherman.SetBoneRotation(MyTankSherman.MainGunBoneName, MainGunRot, 0, 1.0);
}

function Rotator AdjustAimNewTankShell( Ammunition Ammo, Vector ProjStart, Rotator AimRotator, InstantFire MyInstantFire, optional out int bSkipDoTrace )
{
	local float DistToTarget;
	local int index;
	local bool bCheckNoDamage;

	// check if the enemy is not a tank...
	if ((Enemy != None) && (!Enemy.IsA('Tank')))
	{
		bCheckNoDamage = false; // assume false until known otherwise

		index = FindTargetInQueue( Enemy );

		// check if the enemy is a "hard" target (Pak36 gunner, Panzerfaust soldier, etc)...
		if ( (index >= 0) && (TargetQueue[index].bIsHardTarget == 1) )
			bCheckNoDamage = true;

		// check if the enemy is manning a machine gun...
		if ( !bCheckNoDamage && (gbxPawn(Enemy) != None) && (gbxPawn(Enemy).bIsManningTurret) )
			bCheckNoDamage = true;

		if (bCheckNoDamage)
		{
			DistToTarget = VSize( Enemy.Location - MyTank.Location );

			// Is this a deadlock situation?
			if ( DistToTarget > MainGunDoNoDamageRange )
			{
				MyTankSherman.MainGunFireMode.bIgnoreDamageThisBullet = true;
			}
		}
	}

	return Super.AdjustAimNewTankShell(Ammo, ProjStart, AimRotator, MyInstantFire, bSkipDoTrace);
}

function FireMainGun(bool bDoNoDamage)
{
	local vector MainGunLoc;
	local rotator MainGunRot;
	local vector RotX, RotY, RotZ;
	local int AimErrorLocal;
	local rotator AdjustedAim;
	local int bSkipDoTrace;
	local gbxTankShell TankShell;

	if (!bDoNoDamage)
		MyTankSherman.MainGunFireMode.bIgnoreDamageThisBullet = false;

	MainGunLoc = MyTankSherman.GetTagCoords( MyTankSherman.MainGunMuzzleBoneName ).origin;

	MainGunRot.Pitch = MyTankSherman.MainGunPitch;
	MainGunRot.Yaw = -MyTankSherman.TurretYaw;
	MainGunRot.Roll = 0;

	MainGunRot = MyTankSherman.Rotation + MainGunRot;

    GetAxes(MainGunRot,RotX,RotY,RotZ);

	MainGunLoc = MainGunLoc + MyTankSherman.MainGunEmitterOffset.X * RotX + MyTankSherman.MainGunEmitterOffset.Y * RotY + MyTankSherman.MainGunEmitterOffset.Z * RotZ;

	MainGunRot.Pitch = 0;  // ignore main gun pitch for main gun smoke and dust emitter
	MainGunRot.Yaw = -MyTankSherman.TurretYaw;
	MainGunRot.Roll = 0;

	MainGunRot = MyTankSherman.Rotation + MainGunRot;

	// spawn main gun smoke and dust emitter...
	spawn(MyTankSherman.MainGunSmokeEmitterClass, None,, MainGunLoc, MainGunRot);

	AimErrorLocal = AimErrorAIMain;

	AdjustedAim = MyTankSherman.AdjustAimMainGun();

	ApplyAccuracy( AdjustedAim, AimErrorAIMain );

	AdjustedAim = AdjustAimNewTankShell(MyTankSherman.MainGunAmmo, MainGunLoc, AdjustedAim, MyTankSherman.MainGunFireMode, bSkipDoTrace);

	// spawn main gun muzzle flash emitter...
	spawn(MyTankSherman.MainGunFlashEmitterClass, None,, MainGunLoc, AdjustedAim);

	if (MyTankSherman.MainGunFireMode.bIgnoreDamageThisBullet)
	{
		Log(name $ ".FireMainGun - bIgnoreDamageThisBullet was True, doing no damage", 'Tank');
		bDoNoDamage = true;
	}

	TankShell = Spawn( class'gbxTankShell', MyTankSherman,, MainGunLoc, AdjustedAim );
	TankShell.Instigator = MyTankSherman;
	if (bDoNoDamage)
		TankShell.Damage = 0;

	MyTankSherman.PlaySoundCue( MyTankSherman.MainGunFireSound, SLOT_NONE, TransientSoundVolume,,,,false);

	MyTankSherman.PlayMainGunFiringAnim(MyTankSherman.TurretYaw);
}

function FireCoaxGun(bool bDoNoDamage)
{
	local vector CoaxGunLoc;
	local rotator CoaxGunRot;
	local vector RotX, RotY, RotZ;
	local int AimErrorLocal;
	local rotator AdjustedAim;
	local int bSkipDoTrace;
	local Emitter MuzzleFlash;

	if (MyTankSherman.CoaxGunFireMode != None)
	{
		MyTankSherman.fCoaxGunReFireTime = Level.TimeSeconds + MyTankSherman.fCoaxGunReFireDelay;

		CoaxGunLoc = MyTankSherman.GetTagCoords( MyTankSherman.CoaxGunMuzzleBoneName ).origin;

		CoaxGunRot.Pitch = MyTankSherman.Rotation.Pitch + MyTankSherman.MainGunPitch;
		CoaxGunRot.Yaw = MyTankSherman.Rotation.Yaw - MyTankSherman.TurretYaw;
		CoaxGunRot.Roll = 0;

	    GetAxes(CoaxGunRot,RotX,RotY,RotZ);

		CoaxGunLoc = CoaxGunLoc + MyTankSherman.CoaxGunEmitterOffset.X * RotX + MyTankSherman.CoaxGunEmitterOffset.Y * RotY + MyTankSherman.CoaxGunEmitterOffset.Z * RotZ;

		MyTankSherman.Owner.MakeNoise(1.0);

		AimErrorLocal = AimErrorAICoax;

		AdjustedAim = MyTankSherman.AdjustAimCoaxGun();

		ApplyAccuracy( AdjustedAim, AimErrorLocal );

		AdjustedAim = AdjustAimNewBullet(MyTankSherman.CoaxGunAmmo, CoaxGunLoc, AdjustedAim, MyTankSherman.CoaxGunFireMode, bSkipDoTrace);

		if (bDoNoDamage)
			MyTankSherman.CoaxGunFireMode.SetNoDamageThisBullet();

		MyTankSherman.CoaxGunFireMode.DoTrace(CoaxGunLoc, AdjustedAim);

		MyTankSherman.CoaxGunTracerCount++;

		if ( MyTankSherman.CoaxGunTracerCount >= MyTankSherman.CoaxGunTracerFrequency )
		{
			MyTankSherman.CoaxGunTracerCount = 0;

			// Emit a tracer
			if( (MyTankSherman.CoaxGunTracerEmitter != None) )
				MyTankSherman.CoaxGunTracerEmitter.TriggerEmitters( CoaxGunLoc, AdjustedAim );
		}

		MuzzleFlash = MyTankSherman.CoaxGunFireMode.GetMuzzleFlash();

		MuzzleFlash.SetLocation(CoaxGunLoc);
		MuzzleFlash.SetRotation(CoaxGunRot);

		if ( MuzzleFlash.IsA( 'gbxMuzzleFlash' ) )
			gbxMuzzleFlash(MuzzleFlash).ShowMuzzleFlash();
	}
}

defaultproperties
{
	PeripheralVisionWithCommander=-0.7071  // +/- 135 degrees (270 degrees total)
	PeripheralVisionWithoutCommander=0.0  // +/- 90 degrees (180 degrees total)

	bIsOnTarget=false
	bIsFiringBurst=false

	MinBurstLength=2.0
	MaxBurstLength=3.5
	MinPauseLength=1.0
	MaxPauseLength=2.0

	fResetTurretTime=5.0  // if no enemy, start resetting the turret after 5.0 seconds
	fCoaxGunFrustrationDelay=10.0

	TargetPriorityScalarInfantryGroup=0.8

	bLogPriority=false

	AimErrorAIMain=50
	AimErrorAICoax=300

	BulletDoNoDamageRange=5000.0

	bDoesPurposefulMiss=false

	TargetForgetTimeLong=30.0f
	TargetForgetTimeShort=15.0f

	ReactionTimeMin=0.2
	ReactionTimeMax=0.5
	ReactionTimeMinEasy=0.2
	ReactionTimeMaxEasy=0.5
	ReactionTimeMinNormal=0.2
	ReactionTimeMaxNormal=0.5
	ReactionTimeMinHard=0.5
	ReactionTimeMaxHard=1.0
	ReactionTimeMinAuthentic=2.0
	ReactionTimeMaxAuthentic=3.0

	PurposefulMissTimeStart=20.0
	PurposefulMissTimeBonus=5.0
	PurposefulMissTimeMax=30.0
	PurposefulMissTimeStartEasy=10.0
	PurposefulMissTimeBonusEasy=5.0
	PurposefulMissTimeMaxEasy=20.0
	PurposefulMissTimeStartNormal=15.0
	PurposefulMissTimeBonusNormal=5.0
	PurposefulMissTimeMaxNormal=20.0
	PurposefulMissTimeStartHard=20.0
	PurposefulMissTimeBonusHard=5.0
	PurposefulMissTimeMaxHard=30.0
	PurposefulMissTimeStartAuthentic=20.0
	PurposefulMissTimeBonusAuthentic=5.0
	PurposefulMissTimeMaxAuthentic=30.0
}
class TankStuartBowGunController extends TankGunController
	notplaceable;


var()	TankStuart				MyTankStuart;
var()	TankStuartController	MyTankStuartController;

// weapon targeting stuff...
var()	bool	bIsOnTarget;
var()	bool	bIsFiringBurst;		// are we firing a burst at a target?
var()	float	fBurstEndTime;		// time when this burst will end
var()	float	fBurstStartTime;	// time when next burst can start

var()	float	MinBurstLength;		// in seconds
var()	float	MaxBurstLength;		// in seconds
var()	float	MinPauseLength;		// in seconds
var()	float	MaxPauseLength;		// in seconds

var()	float	fEnemySpottedTime;	// when we first saw the enemy
var()	float	fEnemyNoneTime;		// time when enemy was last set to None

var(Target)	float BowGunTargetSelectionAngle;  // dot product of bow gun target selection angle
var(Target)	float TargetPriorityScalarBowGunSelectionAngle;
var(Target)	float TargetPriorityScalarBowGunRotationAngle;

var		int		AimErrorAI;

var()	bool	bLogPriority;


function Possess(Tank aPawn, TankController aController)
{
	Log( name $ ".(TankStuartBowGunController).Possess( " $ aPawn.name $ " " $ aController.name $ " )", 'Tank' );

	if (TankStuart(aPawn) == None)
	{
		Log(name $ ".Possess - aPawn (" $ aPawn.name $ ") is NOT a TankStuart!!!");
		return;
	}

	if (TankStuartController(aController) == None)
	{
		Log(name $ ".Possess - aController (" $ aController.name $ ") is NOT a TankStuartController!!!");
		return;
	}

	Super.Possess(aPawn, aController);

	MyTankStuart = TankStuart(aPawn);
	MyTankStuartController = TankStuartController(aController);

	fEnemyNoneTime = 0.0f;
	fEnemySpottedTime = -1.0f;  // enemy not spotted yet
}

function SeePawn( Pawn Seen )
{
//	Log( name $ ".(TankStuartBowGunController-"$MyTank.name$").SeePawn( " $ Seen.name $ " )", 'Tank' );

	if (MyTankController.bNoEnemies)
		return;  // don't target or shoot at any enemies

	if ( MyTankController.bNoTargetPlayer && Seen.IsPlayerPawn() )
		return;  // don't target or shoot at player

	if (TankGunControllerCanSee(MyTankStuart.Rotation, Seen))
		ConsiderPossibleEnemy( Seen, true );
}

function HearNoise( float Loudness, Actor NoiseMaker )
{
//	Log( name $ ".(TankStuartBowGunController-"$MyTank.name$").HearNoise( " $ Loudness $ " " $ NoiseMaker.name $ " )", 'Tank' );

	if (MyTankController.bNoEnemies)
		return;  // don't target or shoot at any enemies

	if ( MyTankController.bNoTargetPlayer && Pawn(NoiseMaker).IsPlayerPawn() )
		return;  // don't target or shoot at player

	if( NoiseMaker.IsA( 'Pawn' ))
	{
		// TODO do uncertainty.

		ConsiderPossibleEnemy( Pawn( NoiseMaker ), true );
	}
}

function ConsiderPossibleEnemy( Pawn possibleEnemy, bool bAddToOtherGunController )
{
	Super.ConsiderPossibleEnemy(possibleEnemy, bAddToOtherGunController);

	// make sure the other gun on this tank knows about this possible enemy...
	if ((MyTankStuartController.MyMainGunController != None) && (bAddToOtherGunController))
	{
		MyTankStuartController.MyMainGunController.ConsiderPossibleEnemy(possibleEnemy, false);
	}
}

function bool SetEnemy( Actor newEnemy )
{
	bIsOnTarget = false;
	return Super.SetEnemy( newEnemy );
}

function int FindTargetInMainGunQueue(gbxPawn Target)
{
	local int i;

	if (MyTankStuartController.MyMainGunController == None)
		return -1;

	for (i = 0; i < MyTankStuartController.MyMainGunController.TargetQueue.Length; i++)
	{
		if (MyTankStuartController.MyMainGunController.TargetQueue[i].Target == Target)
			return i;
	}

	return -1;  // not found
}

event AdjustTargetPriority(int index)
{
	local gbxPawn Target;
	local float priority, weights, delta_priority;
	local vector vDir, vForward;
	local float dotTheta;
	local int NearbyTargets;
	local vector BowGunBoneLoc;

	Target = TargetQueue[index].Target;

	// recalculate the priority and weights from the native CalculateTargetPriority() function...
	priority = TargetQueue[index].TargetPriority * TargetQueue[index].TargetTotalWeight;
	weights = TargetQueue[index].TargetTotalWeight;

	// give higher priority to targets that are in the direction that the gun is already facing...
	vDir = Normal(Target.Location - MyTankStuart.Location);
	vForward = Vector(MyTankStuart.Rotation);

	dotTheta = (vDir dot vForward);  // 1.0 to -1.0
	dotTheta = (dotTheta / 2.0) + 0.5;  // 1.0 to 0.0

	delta_priority = dotTheta * TargetPriorityScalarInAimingDirection;
	if (bLogPriority)
		Log(name $ ".AdjustTargetPriority: Target " $ Target.name $ " - InAimingDirection priority = " $ delta_priority, 'Tank');
	priority += delta_priority;
	weights += TargetPriorityScalarInAimingDirection;

	// check what type of target this is (or what type of weapon the target is carrying)...

	if (Target.IsA('gbxSVehicle'))  // is this target a vehicle?  If so, MainGunController handles it
	{
		if (bLogPriority)
			Log(name $ ".AdjustTargetPriority: Target " $ Target.name $ " is a vehicle", 'Tank');
		TargetQueue[index].bUseCannon = 1;  // use the cannon to fire at this/these target(s)
	}

//	if (!bAssignToMainGun && Target.IsA('MachineGun'))
//	{
//		if (bLogPriority)
//			Log(name $ ".AdjustTargetPriority: Target " $ Target.name $ " is a manned machine gun", 'Tank');
//		TargetQueue[index].bUseCannon = 1;  // use the cannon to fire at this/these target(s)
//	}

//	if (!bAssignToMainGun && Target.IsA('Infantry'))
//	{
//		// check what weapon this infantry soldier is carrying...
//		if (Target.Weapon.IsA('PatherFist'))
//		{
//			if (bLogPriority)
//				Log(name $ ".AdjustTargetPriority: Target " $ Target.name $ " is a soldier carrying an anti-tank weapon", 'Tank');
//			TargetQueue[index].bUseCannon = 1;  // use the cannon to fire at this/these target(s)
//		}
//	}

	if ((Target.IsA('Infantry')) && (MyTankStuartController.MyMainGunController != None))
	{
		// check to see if this infantry target is close to at least 2 other infantry targets...
		NearbyTargets = GetNumberOfNearbyInfantryTargets(Target);

		if (NearbyTargets >= 2)
		{
			// give lower priority to infantry targets that are in groups of 3 or more
			delta_priority = 1.0 - MyTankStuartController.MyMainGunController.TargetPriorityScalarInfantryGroup;
			if (bLogPriority)
				Log(name $ ".AdjustTargetPriority: Target " $ Target.name $ " - InfantryGroup priority = " $ delta_priority, 'Tank');
			priority += delta_priority;
			weights += (1.0 - MyTankStuartController.MyMainGunController.TargetPriorityScalarInfantryGroup);
		}
		else  // otherwise, infantry target is close to no more than 1 other infantry target...
		{
			// check to see if this target is inside the BowGunTargetSelectionAngle for the bow gun...
			vDir = Normal(Target.Location - MyTankStuart.Location);
			vForward = Vector(MyTankStuart.Rotation);
			dotTheta = vDir dot vForward;

			if (dotTheta > BowGunTargetSelectionAngle)
			{
				if (!MyTankStuartController.bIsNavigating)
				{
					// give higher priority to targets that are within the bow gun's selection angle
					delta_priority = dotTheta * TargetPriorityScalarBowGunSelectionAngle;
					if (bLogPriority)
						Log(name $ ".AdjustTargetPriority: Target " $ Target.name $ " - BowGunSelectionAngle priority = " $ delta_priority, 'Tank');
					priority += delta_priority;
					weights += TargetPriorityScalarBowGunSelectionAngle;
				}
				else
				{
					BowGunBoneLoc = MyTankStuart.GetBoneCoords( MyTankStuart.BowGunBoneName ).origin;

					vDir = Normal(Target.Location - BowGunBoneLoc);
					vForward = Vector(MyTankStuart.Rotation);

					dotTheta = cos((MyTankStuart.BowGunRotateMax / 180.0) * 3.14159);

					if ((vDir dot vForward) > dotTheta)
					{
						// give higher priority to targets that are within the bow gun's rotation angle
						delta_priority = dotTheta * MyTankStuartController.MyBowGunController.TargetPriorityScalarBowGunRotationAngle;
						if (bLogPriority)
							Log(name $ ".AdjustTargetPriority: Target " $ Target.name $ " - BowGunRotationAngle priority = " $ delta_priority, 'Tank');
						priority += delta_priority;
						weights += MyTankStuartController.MyBowGunController.TargetPriorityScalarBowGunRotationAngle;
					}
				}
			}
		}
	}

	priority = FClamp(priority, 0.0, priority);
	TargetQueue[index].TargetTotalWeight = weights;
	TargetQueue[index].TargetPriority = priority / weights;

	if (bLogPriority)
		Log(name $ ".AdjustTargetPriority: Target " $ Target.name $ " - final priority = " $ TargetQueue[index].TargetPriority, 'Tank');
}

function ReassignTargets()
{
	local int index;
	local float bestPriority;

	if (ndxEnemyInQueue < 0)  // no targets in queue?
		return;

	ndxEnemyInQueue = -1;
	bestPriority = 0.0f;

	for (index = 0; index < TargetQueue.Length; index++)
	{
		if (TargetQueue[index].RelegationTime > Level.TimeSeconds)
			continue;

		if ((ndxEnemyInQueue == -1) || (TargetQueue[index].TargetPriority > bestPriority))
		{
			ndxEnemyInQueue = index;
			bestPriority = TargetQueue[index].TargetPriority;
		}
	}
}

event vector GetGunControllerRotation()
{
	return vector(MyTankStuart.Rotation);
}

function Tick( float deltaTime )
{
	local vector BowGunLoc;
	local rotator BowGunRot;
	local int IsHeadShot;
	local vector SuppressLoc, FailLoc;
	local bool bCanSeePawn;
	local vector TargetAimLoc;
	local Actor RotateTarget;
	local float ReactionTimeDelta;

	Super.Tick( deltaTime );

	if (MyTankStuartController == None)
		return;

	if (Enemy == None)
	{
		if (MyTankStuartController.BowGunTarget != None)
		{
			fEnemyNoneTime = Level.TimeSeconds;
		}

		MyTankStuartController.BowGunTarget = None;
	}
	else
	{
		if ((fEnemySpottedTime < 0) || (MyTankStuartController.BowGunTarget != Enemy))
		{
			fEnemySpottedTime = Level.TimeSeconds;

			// have we NOT seen a target within the last 5 seconds?
			if (fGunReactionTime + 5.0 < Level.TimeSeconds)
			{
				// long reaction time, tank is not quite as aware...
				ReactionTimeDelta = ReactionTimeMax - ReactionTimeMin;
				fGunReactionTime = Level.TimeSeconds + ReactionTimeMin + (FRand() * ReactionTimeDelta);
			}
			else
			{
				// short reaction time, tank recently had an enemy and is more aware...
				fGunReactionTime = Level.TimeSeconds + 0.5 + (FRand() * 0.5f);
			}

			Log(name $ ".Tick() - BowGun Enemy " $ Enemy.name $ " spotted at " $ Level.TimeSeconds $ "  reaction time = " $ fGunReactionTime, 'Tank');
		}

		MyTankStuartController.BowGunTarget = Enemy;
	}

	if (MyTankStuartController.BowGunTarget != None)
	{
		if (fGunReactionTime < Level.TimeSeconds)
		{
			bCanSeePawn = MyTankController.CanSeeOrSuppress(Pawn(MyTankStuartController.BowGunTarget), SeeLoc, IsHeadShot, SuppressLoc, FailLoc);

			if (bCanSeePawn)
			{
				TargetAimLoc = SeeLoc;
				RotateTarget = MyTankStuartController.BowGunTarget;

				if ((SeeLoc.X == 0.0) && (SeeLoc.Y == 0.0) && (SeeLoc.Z == 0.0))
				{
//					TargetAimLoc = SuppressLoc;
					TargetAimLoc = TargetQueue[ndxEnemyInQueue].LastKnownLocation;
					RotateTarget = None;  // don't rotate to track target since we can't see him
				}

				TrackBowGunTarget(deltaTime, TargetAimLoc, RotateTarget);  // track using the bow machine gun
	
				// are we on target AND not firing a burst AND time to start a new burst?
				if ((bIsOnTarget) && (!bIsFiringBurst) && (fBurstStartTime < Level.TimeSeconds))
				{
					BowGunLoc = MyTankStuart.GetTagCoords( MyTankStuart.BowGunMuzzleBoneName ).origin;
					BowGunRot = MyTankStuart.Rotation - MyTankStuart.BowGunRotation;

					// see if we can shoot at what we're aiming at without hitting teammates...
					if (ApproveShot(BowGunLoc, BowGunRot))
					{
						bIsFiringBurst = true;
						MyTankStuart.BowGunSoundHandle = MyTankStuart.PlaySoundCue( MyTankStuart.BowGunFireLoopSound, SLOT_NONE, TransientSoundVolume,,,,false);
	
						fBurstEndTime = Level.TimeSeconds + MinBurstLength + (FRand() * (MaxBurstLength - MinBurstLength));
						fBurstStartTime = fBurstEndTime + MinPauseLength + (FRand() * (MaxPauseLength - MinPauseLength));
					}
					else
					{
						// try firing again after 0.5 - 2.5 seconds...
						fBurstStartTime = Level.TimeSeconds + 0.5 + (FRand() * 2.0);
					}
				}
			}
		}
	}
	else
	{
		// no current target...
		bIsOnTarget = false;
		fEnemySpottedTime = -1.0f;
	}

	if (bIsFiringBurst)
	{
		if (fBurstEndTime < Level.TimeSeconds)  // has the burst ended?
		{
			bIsFiringBurst = false;
			MyTankStuart.StopSound( MyTankStuart.BowGunSoundHandle );
			MyTankStuart.PlaySoundCue( MyTankStuart.BowGunFireOnceSound, SLOT_NONE, TransientSoundVolume,,,,false);
		}
		else
		{
			if (MyTankStuart.fBowGunReFireTime < Level.Timeseconds)
			{
				FireBowGun(false);
			}
		}
	}
}

function int GetNewRotation(int current, int desired, int rate)
{
	local int result;

	result = current & 65535;
	current = result;
	desired = desired & 65535;

	if (current > desired)
	{
		if (current - desired < 32768)
			result -= Min((current - desired), abs(rate));
		else
			result += Min((desired + 65536 - current), abs(rate));
	}
	else
	{
		if (desired - current < 32768)
			result += Min((desired - current), abs(rate));
		else
			result -= Min((current + 65536 - desired), abs(rate));
	}

	return (result & 65535);
}

function TrackBowGunTarget(float DeltaTime, vector TargetAimLoc, Actor RotateTarget)
{
	local rotator WorldBowGunRot;
	local vector BowGunBoneLoc;
	local rotator RotToTarget;
	local float AdjustRate;
	local rotator BowGunRot;
	local int MaxRot, MinRot;
	local int PitchDiff, YawDiff;

	if (MyTankStuart == None)
		return;

	// convert BowGunRotation to world space...
	WorldBowGunRot.Pitch = (MyTankStuart.Rotation.Pitch - MyTankStuart.BowGunRotation.Pitch) & 65535;
	WorldBowGunRot.Yaw = (MyTankStuart.Rotation.Yaw - MyTankStuart.BowGunRotation.Yaw) & 65535;
	WorldBowGunRot.Roll = 0;

	BowGunBoneLoc = MyTankStuart.GetBoneCoords( MyTankStuart.BowGunBoneName ).origin;
	RotToTarget = rotator(TargetAimLoc - BowGunBoneLoc);

	AdjustRate = (MyTankStuart.BowGunRotationSpeed * DeltaTime / 360.0) * 65536;

	WorldBowGunRot.Pitch = GetNewRotation(WorldBowGunRot.Pitch, RotToTarget.Pitch, int(AdjustRate));
	WorldBowGunRot.Yaw = GetNewRotation(WorldBowGunRot.Yaw, RotToTarget.Yaw, int(AdjustRate));

	PitchDiff = abs((WorldBowGunRot.Pitch & 65535) - (RotToTarget.Pitch & 65535));
	if (PitchDiff > 32768)
		PitchDiff = 65536 - PitchDiff;

	YawDiff = abs((WorldBowGunRot.Yaw & 65535) - (RotToTarget.Yaw & 65535));
	if (YawDiff > 32768)
		YawDiff = 65536 - YawDiff;

	bIsOnTarget = false;  // assume not on target until known otherwise

	// is the bow machine gun aimed close enough to the target?
	if ((YawDiff < 500) && (PitchDiff < 500))
	{
		bIsOnTarget = true;  // bow gun is "on target", start shooting
	}

	// convert BowGunRotation back to local space...
	MyTankStuart.BowGunRotation.Pitch = (MyTankStuart.Rotation.Pitch - WorldBowGunRot.Pitch) & 65535;
	MyTankStuart.BowGunRotation.Yaw = (MyTankStuart.Rotation.Yaw - WorldBowGunRot.Yaw) & 65535;
	MyTankStuart.BowGunRotation.Roll = 0;

	if (MyTankStuart.BowGunRotation.Pitch > 32767)
		MyTankStuart.BowGunRotation.Pitch = MyTankStuart.BowGunRotation.Pitch - 65536;
	if (MyTankStuart.BowGunRotation.Yaw > 32767)
		MyTankStuart.BowGunRotation.Yaw = MyTankStuart.BowGunRotation.Yaw - 65536;

	MaxRot = int((MyTankStuart.BowGunRotateMax / 360.0) * 65536.0);
	MinRot = int((-MyTankStuart.BowGunRotateMax / 360.0) * 65536.0);

	MyTankStuart.BowGunRotation.Pitch = Clamp(MyTankStuart.BowGunRotation.Pitch, MinRot, MaxRot);
	MyTankStuart.BowGunRotation.Yaw = Clamp(MyTankStuart.BowGunRotation.Yaw, MinRot, MaxRot);

	// is bow machine gun at horizontal limit of rotation range?
	if ((MyTankStuart.BowGunRotation.Yaw == MinRot) ||
		(MyTankStuart.BowGunRotation.Yaw == MaxRot))
	{
		if (!MyTankStuartController.bIsRotating)  // is the tank not currently rotating towards the target?
		{
			// request the tank to rotate towards the target...
			if (RotateTarget != None)
				MyTankStuartController.RotateTowardTarget(RotateTarget);
			else
				MyTankStuartController.RotateTowardLocation(TargetAimLoc);
		}
	}

	BowGunRot.Pitch = MyTankStuart.BowGunRotation.Yaw;
	BowGunRot.Yaw = MyTankStuart.BowGunRotation.Pitch;
	BowGunRot.Roll = 0;

	MyTankStuart.SetBoneRotation(MyTankStuart.BowGunBoneName, BowGunRot, 0, 1.0);
}

function FireBowGun(bool bDoNoDamage)
{
	local vector BowGunLoc;
	local rotator BowGunRot;
	local vector RotX, RotY, RotZ;
	local int AimErrorLocal;
	local rotator AdjustedAim;
	local int bSkipDoTrace;
	local Emitter MuzzleFlash;

	if (MyTankStuart.BowGunFireMode != None)
	{
		MyTankStuart.fBowGunReFireTime = Level.TimeSeconds + MyTankStuart.fBowGunReFireDelay;

		BowGunLoc = MyTankStuart.GetTagCoords( MyTankStuart.BowGunMuzzleBoneName ).origin;

		BowGunRot = MyTankStuart.Rotation - MyTankStuart.BowGunRotation;

	    GetAxes(BowGunRot,RotX,RotY,RotZ);

		BowGunLoc = BowGunLoc + MyTankStuart.BowGunEmitterOffset.X * RotX + MyTankStuart.BowGunEmitterOffset.Y * RotY + MyTankStuart.BowGunEmitterOffset.Z * RotZ;

		MyTankStuart.Owner.MakeNoise(1.0);

		AimErrorLocal = AimErrorAI;

		AdjustedAim = MyTankStuart.AdjustAimBowGun();

		ApplyAccuracy( AdjustedAim, AimErrorLocal );

		AdjustedAim = AdjustAimNewBullet(MyTankStuart.BowGunAmmo, BowGunLoc, AdjustedAim, MyTankStuart.BowGunFireMode, bSkipDoTrace);

		if (bDoNoDamage)
			MyTankStuart.BowGunFireMode.SetNoDamageThisBullet();

		MyTankStuart.BowGunFireMode.DoTrace(BowGunLoc, AdjustedAim);

		MyTankStuart.BowGunTracerCount++;

		if ( MyTankStuart.BowGunTracerCount >= MyTankStuart.BowGunTracerFrequency )
		{
			MyTankStuart.BowGunTracerCount = 0;

			// Emit a tracer
			if( (MyTankStuart.BowGunTracerEmitter != None) )
				MyTankStuart.BowGunTracerEmitter.TriggerEmitters( BowGunLoc, AdjustedAim );
		}

		MuzzleFlash = MyTankStuart.BowGunFireMode.GetMuzzleFlash();

		MuzzleFlash.SetLocation(BowGunLoc);
		MuzzleFlash.SetRotation(BowGunRot);

		if ( MuzzleFlash.IsA( 'gbxMuzzleFlash' ) )
			gbxMuzzleFlash(MuzzleFlash).ShowMuzzleFlash();
	}
}


defaultproperties
{
	bIsOnTarget=false
	bIsFiringBurst=false

	MinBurstLength=2.0
	MaxBurstLength=3.5
	MinPauseLength=1.0
	MaxPauseLength=2.0

	BulletDoNoDamageRange=5000.0

	BowGunTargetSelectionAngle=0.5  // cosine of 60 degrees

	TargetPriorityScalarBowGunSelectionAngle=0.75
	TargetPriorityScalarBowGunRotationAngle=0.9

	bLogPriority=false

	AimErrorAI=400

	ReactionTimeMin=0.3
	ReactionTimeMax=0.7
	ReactionTimeMinEasy=0.3
	ReactionTimeMaxEasy=0.7
	ReactionTimeMinNormal=0.5
	ReactionTimeMaxNormal=1.0
	ReactionTimeMinHard=1.2
	ReactionTimeMaxHard=2.0
	ReactionTimeMinAuthentic=2.0
	ReactionTimeMaxAuthentic=3.0

	TargetForgetTimeLong=30.0f
	TargetForgetTimeShort=15.0f
}
class TankStuartController extends TankControllerUS
	notplaceable;


var()	TankStuart						MyTankStuart;
var()	TankStuartMainGunController		MyMainGunController;
var()	TankStuartBowGunController		MyBowGunController;

// enemy targeting stuff...
var()	Actor	MainGunTarget;
var()	Actor	CoaxGunTarget;
var()	Actor	BowGunTarget;


function Possess(Pawn aPawn)
{
	Log( name $ ".(TankStuartController).Possess( " $ aPawn.name $ " )", 'Tank' );

	Super.Possess(aPawn);

	if ((aPawn == None) || (TankStuart(aPawn) == None))
	{
		Log(name $ ".Possess() - WARNING! TankStuartController's Pawn is NOT a TankStuart!!!");
	}
	else
	{
		MyTankStuart = TankStuart(aPawn);

		MyMainGunController = spawn(class'TankStuartMainGunController', self);
		if (MyMainGunController == None)
			Log( name $ ".(TankStuartController).Possess() - ERROR Spawning TankStuartMainGunController!!!", 'Tank' );
		else
			MyMainGunController.Possess(MyTankStuart, self);

		MyBowGunController = spawn(class'TankStuartBowGunController', self);
		if (MyBowGunController == None)
			Log( name $ ".(TankStuartController).Possess() - ERROR Spawning TankStuartBowGunController!!!", 'Tank' );
		else
			MyBowGunController.Possess(MyTankStuart, self);
	}
}

function Destroyed()
{
	Log( name $ ".(TankStuartController).Destroyed()", 'Tank' );

	if (MyMainGunController != None)
		MyMainGunController.Destroy();
	if (MyBowGunController != None)
		MyBowGunController.Destroy();

	super.Destroyed();
}

function Timer()
{
	Super.Timer();

	if (fPauseMovementCheckTime < Level.TimeSeconds)
	{
		fPauseMovementCheckTime = Level.TimeSeconds + 2.0f;

		bPauseMovement = false;  // stop moving and attack enemy from here

		if ( (MyMainGunController != None) && MyMainGunController.ShouldTankPause() )
		{
			bPauseMovement = true;  // stop moving and attack enemy from here
		}
		else if ( (MyBowGunController != None) && MyBowGunController.ShouldTankPause() )
		{
			bPauseMovement = true;  // stop moving and attack enemy from here
		}
	}
}

function PawnDied(Pawn P)
{
	Log( name $ ".(TankStuartController).PawnDied()", 'Tank' );

	Super.PawnDied(P);
}

function Tick(float DeltaTime)
{
	Super.Tick(DeltaTime);

	if (MyTankStuart.WeapUSStuart30calMachineGun != None)
	{
		bIsPlayerMounting = MyTankStuart.WeapUSStuart30calMachineGun.bIsMounting;
	}
}

function NotifyTakeHit(pawn InstigatedBy, vector HitLocation, int Damage, class<DamageType> damageType, vector Momentum)
{
//	Log( name $ "(" $ Pawn.name $ ").NotifyTakeHit( " $ InstigatedBy.name $ " )", 'Tank' );

	if (bIsInScriptedMode)
		return;  // don't do anything if under scripted control

	if (MyMainGunController != None)
		MyMainGunController.NotifyTakeHit(InstigatedBy, HitLocation, Damage, damageType, Momentum);

	if (MyBowGunController != None)
		MyBowGunController.NotifyTakeHit(InstigatedBy, HitLocation, Damage, damageType, Momentum);

	Super.NotifyTakeHit( InstigatedBy, HitLocation, Damage, damageType, Momentum );
}

function SeePawn( Pawn Seen )
{
//	Log( name $ "(" $ Pawn.name $ ").SeePawn( " $ Seen.name $ " )", 'Tank' );

	if (bIsInScriptedMode)
		return;  // don't do anything if under scripted control

	if (MyMainGunController != None)
		MyMainGunController.SeePawn(Seen);

	if (MyBowGunController != None)
		MyBowGunController.SeePawn(Seen);

	Super.SeePawn(Seen);
}

function SeePawnKilled( Pawn Seen, Pawn Killer )
{
//	Log( name $ "(" $ Pawn.name $ ").SeePawnKilled( " $ Seen.name $ " )", 'Tank' );

	if (bIsInScriptedMode)
		return;  // don't do anything if under scripted control

	// Seeing your friends get killed.
	if (MyMainGunController != None)
		MyMainGunController.SeePawnKilled(Seen, Killer);

	if (MyBowGunController != None)
		MyBowGunController.SeePawnKilled(Seen, Killer);

	Super.SeePawnKilled(Seen, Killer);
}

function SeePawnHit( Pawn Seen )
{
//	Log( name $ "(" $ Pawn.name $ ").SeePawnHit( " $ Seen.name $ " )", 'Tank' );

	if (bIsInScriptedMode)
		return;  // don't do anything if under scripted control

	if (MyMainGunController != None)
		MyMainGunController.SeePawnHit(Seen);

	if (MyBowGunController != None)
		MyBowGunController.SeePawnHit(Seen);

	Super.SeePawnHit(Seen);
}

function HearNoise( float Loudness, Actor NoiseMaker )
{
//	Log( name $ "(" $ Pawn.name $ ").HearNoise( " $ Loudness $ ", " $ NoiseMaker.name $ " )", 'Tank' );

	if (bIsInScriptedMode)
		return;  // don't do anything if under scripted control

	if (MyMainGunController != None)
		MyMainGunController.HearNoise(Loudness, NoiseMaker);

	if (MyBowGunController != None)
		MyBowGunController.HearNoise(Loudness, NoiseMaker);

	Super.HearNoise(Loudness, NoiseMaker);
}

function SeePlayer( Pawn Seen )
{
//	Log( name $ "(" $ Pawn.name $ ").SeePlayer( " $ Seen.name $ " )", 'Tank' );

	if (bIsInScriptedMode)
		return;  // don't do anything if under scripted control

	if (MyMainGunController != None)
		MyMainGunController.SeePlayer(Seen);

	if (MyBowGunController != None)
		MyBowGunController.SeePlayer(Seen);

	Super.SeePlayer(Seen);
}

function SeeExplosion( Pawn Instigator )
{
//	Log( name $ "(" $ Pawn.name $ ").SeeExplosion( " $ Instigator.name $ " )", 'Tank' );

	if (bIsInScriptedMode)
		return;  // don't do anything if under scripted control

	// Seeing shit get blown up.
	if (MyMainGunController != None)
		MyMainGunController.SeeExplosion(Instigator);

	if (MyBowGunController != None)
		MyBowGunController.SeeExplosion(Instigator);

	Super.SeeExplosion(Instigator);
}

function NotifyTargetOrder(Unit targetUnit)
{
	local int i;

	// notify this member about all Targets in the targetUnit...
	for (i = 0; i < targetUnit.NumMembers; i++)
	{
		if (MyMainGunController != None)
			MyMainGunController.AddTarget( targetUnit.Members[i] );
		if (MyBowGunController != None)
			MyBowGunController.AddTarget( targetUnit.Members[i] );
	}
}

function NotifyAssaultOrder(Unit targetUnit)
{
	local int i;

	// notify this member about all Targets in the targetUnit...
	for (i = 0; i < targetUnit.NumMembers; i++)
	{
		if (MyMainGunController != None)
			MyMainGunController.AddTarget( targetUnit.Members[i] );
		if (MyBowGunController != None)
			MyBowGunController.AddTarget( targetUnit.Members[i] );
	}
}

function ConsiderPossibleEnemy( Pawn possibleEnemy )
{
	if (bIsInScriptedMode)
		return;  // don't do anything if under scripted control

	if (MyMainGunController != None)
		MyMainGunController.ConsiderPossibleEnemy(possibleEnemy, false);

	if (MyBowGunController != None)
		MyBowGunController.ConsiderPossibleEnemy(possibleEnemy, false);
}

event float GetTargetExposureToMe( Pawn aThreat )
{
	local float MainGunExp, BowGunExp;

	MainGunExp = MyMainGunController.GetTargetExposureToMe(aThreat);
	BowGunExp = MyBowGunController.GetTargetExposureToMe(aThreat);

	if (MainGunExp > BowGunExp)
		return MainGunExp;

	return BowGunExp;
}

function bool TankHasEnemy()
{
	if (MyMainGunController != None)
	{
		if (MyMainGunController.ndxEnemyInQueue >= 0)
			return true;
	}

	if (MyBowGunController != None)
	{
		if (MyBowGunController.ndxEnemyInQueue >= 0)
			return true;
	}

	return false;
}


defaultproperties
{
}
class TankStuartMainGunController extends TankGunController
	notplaceable;


var()	TankStuart				MyTankStuart;
var()	TankStuartController	MyTankStuartController;

// weapon targeting stuff...
var()	bool	bIsOnTarget;
var()	bool	bIsYawOnTarget;
var()	bool	bIsFiringBurst;		// are we firing a burst at a target?
var()	float	fBurstEndTime;		// time when this burst will end
var()	float	fBurstStartTime;	// time when next burst can start

var()	float	MinBurstLength;		// in seconds
var()	float	MaxBurstLength;		// in seconds
var()	float	MinPauseLength;		// in seconds
var()	float	MaxPauseLength;		// in seconds

var()	float	fEnemySpottedTime;	// when we first saw the enemy
var()	float	fEnemyNoneTime;		// time when enemy was last set to None
var()	float	fResetTurretTime;	// how long after enemy = none to reset turret back to facing fowards
var()	bool	bIsResettingTurret;
var()	bool	bIsPlayerOnTank;
var()	float	fCoaxGunFrustrationDelay;	// how long the coax gun tries firing at an enemy before switching to the main gun
var()	float 	fCoaxGunFrustrationTime;	// time at which the coax gun becomes frustrated

var(Target)	float TargetPriorityScalarInfantryGroup;

var()	bool	bLogPriority;

var		int		AimErrorAIMain, AimErrorAICoax;


function Possess(Tank aPawn, TankController aController)
{
	Log( name $ ".(TankStuartMainGunController).Possess( " $ aPawn.name $ " " $ aController.name $ " )", 'Tank' );

	if (TankStuart(aPawn) == None)
	{
		Log(name $ ".Possess - aPawn (" $ aPawn.name $ ") is NOT a TankStuart!!!");
		return;
	}

	if (TankStuartController(aController) == None)
	{
		Log(name $ ".Possess - aController (" $ aController.name $ ") is NOT a TankStuartController!!!");
		return;
	}

	Super.Possess(aPawn, aController);

	MyTankStuart = TankStuart(aPawn);
	MyTankStuartController = TankStuartController(aController);

	fEnemyNoneTime = 0.0f;
	fEnemySpottedTime = -1.0f;  // enemy not spotted yet
	MyTankStuartController.fRotateToFaceCheckTime = -1.0f;

	bIsPlayerOnTank = false;
}

function Timer()
{
//	Log( name $ ".(TankStuartMainGunController).Timer()", 'Tank' );

	if (MyTankStuartController.bIsInScriptedMode)
	{
		Super.Timer();
		return;
	}

	PeripheralVision = PeripheralVisionWithoutCommander;  // default to vision without tank commander

	if (MyTankStuart != None)
	{
		if (MyTankStuart.bSpawnCommander)  // if tank was spawned without a commander, use same vision as if had a commander...
		{
			PeripheralVision = PeripheralVisionWithCommander;
		}
		else if ((MyTankStuart.CommanderPawn != None) && (MyTankStuart.CommanderPawn.Health > 0) && (!MyTankStuart.CommanderPawn.bHatchClosing))
		{
			PeripheralVision = PeripheralVisionWithCommander;
		}
	}

	Super.Timer();
}

function SeePawn( Pawn Seen )
{
	local Rotator TurretRotation;

//	Log( name $ ".(TankStuartMainGunController-"$MyTank.name$").SeePawn( " $ Seen.name $ " )", 'Tank' );

	if (MyTankController.bNoEnemies)
		return;  // don't target or shoot at any enemies

	if ( MyTankController.bNoTargetPlayer && Seen.IsPlayerPawn() )
		return;  // don't target or shoot at player

	TurretRotation.Pitch = MyTankStuart.Rotation.Pitch;
	TurretRotation.Yaw = (MyTankStuart.Rotation.Yaw - MyTankStuart.TurretYaw) & 65535;
	TurretRotation.Roll = 0;

	if (TankGunControllerCanSee(TurretRotation, Seen))
		ConsiderPossibleEnemy( Seen, true );
}

function HearNoise( float Loudness, Actor NoiseMaker )
{
//	Log( name $ ".(TankStuartMainGunController-"$MyTank.name$").HearNoise( " $ Loudness $ " " $ NoiseMaker.name $ " )", 'Tank' );

	if (MyTankController.bNoEnemies)
		return;  // don't target or shoot at any enemies

	if ( MyTankController.bNoTargetPlayer && Pawn(NoiseMaker).IsPlayerPawn() )
		return;  // don't target or shoot at player

	if( NoiseMaker.IsA( 'Pawn' ))
	{
		// TODO do uncertainty.

		ConsiderPossibleEnemy( Pawn( NoiseMaker ), true );
	}
}

function ConsiderPossibleEnemy( Pawn possibleEnemy, bool bAddToOtherGunController )
{
	Super.ConsiderPossibleEnemy(possibleEnemy, bAddToOtherGunController);

	// make sure the other gun on this tank knows about this possible enemy...
	if ((MyTankStuartController.MyBowGunController != None) && (bAddToOtherGunController))
	{
		MyTankStuartController.MyBowGunController.ConsiderPossibleEnemy(possibleEnemy, false);
	}
}

function bool SetEnemy( Actor newEnemy )
{
	bIsOnTarget = false;
	return Super.SetEnemy( newEnemy );
}

function int FindTargetInBowGunQueue(gbxPawn Target)
{
	local int i;

	if (MyTankStuartController.MyBowGunController == None)
		return -1;

	for (i = 0; i < MyTankStuartController.MyBowGunController.TargetQueue.Length; i++)
	{
		if (MyTankStuartController.MyBowGunController.TargetQueue[i].Target == Target)
			return i;
	}

	return -1;  // not found
}

event AdjustTargetPriority(int index)
{
	local gbxPawn Target;
	local float priority, weights, delta_priority;
	local vector vDir, vForward;
	local rotator MainGunRot;
	local float dotTheta;
	local int NearbyTargets;
	local vector BowGunBoneLoc;

	Target = TargetQueue[index].Target;

	// recalculate the priority and weights from the native CalculateTargetPriority() function...
	priority = TargetQueue[index].TargetPriority * TargetQueue[index].TargetTotalWeight;
	weights = TargetQueue[index].TargetTotalWeight;

	// give higher priority to targets that are in the direction that the gun is already facing...
	vDir = Normal(Target.Location - MyTankStuart.Location);
	MainGunRot.Pitch = (MyTankStuart.Rotation.Pitch + MyTankStuart.MainGunPitch) & 65535;
	MainGunRot.Yaw = (MyTankStuart.Rotation.Yaw - MyTankStuart.TurretYaw) & 65535;
	MainGunRot.Roll = 0;
	vForward = Vector(MainGunRot);

	dotTheta = (vDir dot vForward);  // 1.0 to -1.0
	dotTheta = (dotTheta / 2.0) + 0.5;  // 1.0 to 0.0

	delta_priority = dotTheta * TargetPriorityScalarInAimingDirection;
	if (bLogPriority)
		Log(name $ ".AdjustTargetPriority: Target " $ Target.name $ " - InAimingDirection priority = " $ delta_priority, 'Tank');
	priority += delta_priority;
	weights += TargetPriorityScalarInAimingDirection;

	// check what type of target this is (or what type of weapon the target is carrying)...

	if (Target.IsA('gbxSVehicle'))  // is this target a vehicle?
	{
		// give higher priority to enemy vehicles (tanks, trucks, jeeps, etc)...
		delta_priority = TargetPriorityScalarEnemyVehicle;
		if (bLogPriority)
			Log(name $ ".AdjustTargetPriority: Target " $ Target.name $ " - EnemyVehicle priority = " $ delta_priority, 'Tank');
		priority += delta_priority;
		weights += TargetPriorityScalarEnemyVehicle;
		TargetQueue[index].bUseCannon = 1;  // use the cannon to fire at this/these target(s)
	}

//	if (Target.IsA('MachineGun'))
//	{
//		if (bLogPriority)
//			Log(name $ ".AdjustTargetPriority: Target " $ Target.name $ " is a manned machine gun", 'Tank');
//		TargetQueue[index].bUseCannon = 1;  // use the cannon to fire at this/these target(s)
//	}

//	if (Target.IsA('Infantry'))
//	{
//		// check what weapon this infantry soldier is carrying...
//		if (Target.Weapon.IsA('PatherFist'))
//		{
//			if (bLogPriority)
//				Log(name $ ".AdjustTargetPriority: Target " $ Target.name $ " is a soldier carrying an anti-tank weapon", 'Tank');
//			TargetQueue[index].bUseCannon = 1;  // use the cannon to fire at this/these target(s)
//		}
//	}

	if ((Target.IsA('Infantry')) && (MyTankStuartController.MyBowGunController != None))
	{
		// check to see if this infantry target is close to at least 2 other infantry targets...
		NearbyTargets = GetNumberOfNearbyInfantryTargets(Target);

		if (NearbyTargets >= 2)
		{
			// give higher priority to infantry targets that are in groups of 3 or more
			delta_priority = TargetPriorityScalarInfantryGroup;
			if (bLogPriority)
				Log(name $ ".AdjustTargetPriority: Target " $ Target.name $ " - InfantryGroup priority = " $ delta_priority, 'Tank');
			priority += delta_priority;
			weights += TargetPriorityScalarInfantryGroup;
			TargetQueue[index].bUseCannon = 1;  // use the cannon to fire at this/these target(s)
		}
		else  // otherwise, infantry target is close to no more than 1 other infantry target...
		{
			// check to see if this target is inside the BowGunTargetSelectionAngle for the bow gun...
			vDir = Normal(Target.Location - MyTankStuart.Location);
			vForward = Vector(MyTankStuart.Rotation);
			dotTheta = vDir dot vForward;

			if (dotTheta > MyTankStuartController.MyBowGunController.BowGunTargetSelectionAngle)
			{
				if (!MyTankStuartController.bIsNavigating)
				{
					// give lower priority to targets that are within the bow gun's selection angle
					delta_priority = dotTheta * (1.0 - MyTankStuartController.MyBowGunController.TargetPriorityScalarBowGunSelectionAngle);
					if (bLogPriority)
						Log(name $ ".AdjustTargetPriority: Target " $ Target.name $ " - BowGunSelectionAngle priority = " $ delta_priority, 'Tank');
					priority += delta_priority;
					weights += (1.0 - MyTankStuartController.MyBowGunController.TargetPriorityScalarBowGunSelectionAngle);
				}
				else
				{
					BowGunBoneLoc = MyTankStuart.GetBoneCoords( MyTankStuart.BowGunBoneName ).origin;

					vDir = Normal(Target.Location - BowGunBoneLoc);
					vForward = Vector(MyTankStuart.Rotation);

					dotTheta = cos((MyTankStuart.BowGunRotateMax / 180.0) * 3.14159);

					if ((vDir dot vForward) > dotTheta)
					{
						// give lower priority to targets that are within the bow gun's rotation angle
						delta_priority = dotTheta * (1.0 - MyTankStuartController.MyBowGunController.TargetPriorityScalarBowGunRotationAngle);
						if (bLogPriority)
							Log(name $ ".AdjustTargetPriority: Target " $ Target.name $ " - BowGunRotationAngle priority = " $ delta_priority, 'Tank');
						priority += delta_priority;
						weights += (1.0 - MyTankStuartController.MyBowGunController.TargetPriorityScalarBowGunRotationAngle);
					}
				}
			}
		}
	}

	priority = FClamp(priority, 0.0, priority);
	TargetQueue[index].TargetTotalWeight = weights;
	TargetQueue[index].TargetPriority = priority / weights;

	if (bLogPriority)
		Log(name $ ".AdjustTargetPriority: Target " $ Target.name $ " - final priority = " $ TargetQueue[index].TargetPriority, 'Tank');
}

function ReassignTargets()
{
	local int index;
	local float bestPriority;

	if (ndxEnemyInQueue < 0)  // no targets in queue?
		return;

	ndxEnemyInQueue = -1;
	bestPriority = 0.0f;

	for (index = 0; index < TargetQueue.Length; index++)
	{
		if (TargetQueue[index].RelegationTime > Level.TimeSeconds)
			continue;

		if ((ndxEnemyInQueue == -1) || (TargetQueue[index].TargetPriority > bestPriority))
		{
			ndxEnemyInQueue = index;
			bestPriority = TargetQueue[index].TargetPriority;
		}
	}
}

event vector GetGunControllerRotation()
{
	local Rotator TurretRotation;

	TurretRotation.Pitch = MyTankStuart.Rotation.Pitch + MyTankStuart.MainGunPitch;
	TurretRotation.Yaw = MyTankStuart.Rotation.Yaw - MyTankStuart.TurretYaw;
	TurretRotation.Roll = 0;

	return vector(TurretRotation);
}

function Tick( float deltaTime )
{
	local vector CoaxGunLoc;
	local rotator CoaxGunRot;
	local int IsHeadShot;
	local vector SuppressLoc, FailLoc;
	local bool bCanSeePawn, bHatchClosed;
	local vector TargetAimLoc;
	local vector aim_offset;
	local float ReactionTimeDelta;
	local float distance;
	local bool bOnTarget;

	Super.Tick( deltaTime );

	if (MyTankStuartController == None)
		return;

	if (MyTankStuart.WeapUSStuart30calMachineGun != None)
	{
		if (MyTankStuart.WeapUSStuart30calMachineGun.IsInUse() && !bIsPlayerOnTank)
		{
			bIsPlayerOnTank = true;

			bIsResettingTurret = true;
		}
	}

	if (bIsPlayerOnTank)
	{
		bIsPlayerOnTank = MyTankStuart.WeapUSStuart30calMachineGun.IsInUse() || MyTankStuart.IsPlayerOnTank();
	}

	if (Enemy == None)
	{
		if ((MyTankStuartController.MainGunTarget != None) ||
			(MyTankStuartController.CoaxGunTarget != None))
		{
			fEnemyNoneTime = Level.TimeSeconds;

			MyTankStuartController.MainGunTarget = None;
			MyTankStuartController.CoaxGunTarget = None;
			MyTankStuartController.bRotateToFaceEnemy = false;
			MyTankStuartController.EnemyRotateToFace = None;
			MyTankStuartController.fRotateToFaceCheckTime = -1.0f;
		}
	}
	else if ((!MyTankStuartController.bIsInScriptedMode) &&
			 (Enemy.IsA('gbxSVehicle') || ((ndxEnemyInQueue >= 0) && (TargetQueue[ndxEnemyInQueue].bUseCannon == 1))))
	{
		if ((fEnemySpottedTime < 0) || (MyTankStuartController.MainGunTarget != Enemy))
		{
			fEnemySpottedTime = Level.TimeSeconds;

			// have we NOT seen a target within the last 5 seconds?
			if (fGunReactionTime + 5.0 < Level.TimeSeconds)
			{
				// long reaction time, tank is not quite as aware...
				ReactionTimeDelta = ReactionTimeMax - ReactionTimeMin;
				fGunReactionTime = Level.TimeSeconds + ReactionTimeMin + (FRand() * ReactionTimeDelta);
			}
			else
			{
				// short reaction time, tank recently had an enemy and is more aware...
				fGunReactionTime = Level.TimeSeconds + 0.5 + (FRand() * 0.5f);
			}

			Log(name $ ".Tick() - MainGun Enemy " $ Enemy.name $ " spotted at " $ Level.TimeSeconds $ "  reaction time = " $ fGunReactionTime, 'Tank');

			MyTankStuartController.MainGunTarget = Enemy;
			MyTankStuartController.CoaxGunTarget = None;

			MyTankStuartController.fRotateToFaceCheckTime = Level.TimeSeconds;
		}
	}
	else
	{
		if ((!MyTankStuartController.bIsInScriptedMode) &&
			((fEnemySpottedTime < 0) || (MyTankStuartController.CoaxGunTarget != Enemy)))
		{
			fEnemySpottedTime = Level.TimeSeconds;

			// have we NOT seen a target within the last 5 seconds?
			if (fGunReactionTime + 5.0 < Level.TimeSeconds)
			{
				// long reaction time, tank is not quite as aware...
				ReactionTimeDelta = ReactionTimeMax - ReactionTimeMin;
				fGunReactionTime = Level.TimeSeconds + ReactionTimeMin + (FRand() * ReactionTimeDelta);
			}
			else
			{
				// short reaction time, tank recently had an enemy and is more aware...
				fGunReactionTime = Level.TimeSeconds + 0.5 + (FRand() * 0.5f);
			}

			fCoaxGunFrustrationTime = fGunReactionTime + fCoaxGunFrustrationDelay + (FRand() * 2.0);

			Log(name $ ".Tick() - CoaxGun Enemy " $ Enemy.name $ " spotted at " $ Level.TimeSeconds $ "  reaction time = " $ fGunReactionTime, 'Tank');

			MyTankStuartController.CoaxGunTarget = Enemy;
			MyTankStuartController.MainGunTarget = None;
			MyTankStuartController.bRotateToFaceEnemy = false;
			MyTankStuartController.EnemyRotateToFace = Enemy;
		}
	}

	// periodically, check to see if tank should stop here and rotate to face enemy (stronger armor at front of tank)...
	if ((MyTankStuartController.fRotateToFaceCheckTime >= 0.0) && (MyTankStuartController.fRotateToFaceCheckTime <= Level.TimeSeconds))
	{
		MyTankStuartController.fRotateToFaceCheckTime = Level.TimeSeconds + 2.0f;

		// do we currently have an enemy, are we not in scripted mode, and is this enemy a 'hard' target (something that damages tanks)?...
		if ((Enemy != None) && (!MyTankStuartController.bIsInScriptedMode) &&
			 ((ndxEnemyInQueue >= 0) && (TargetQueue[ndxEnemyInQueue].bIsHardTarget == 1)))
		{
			// is this enemy a Pawn in a Unit that I've been told to assault?
			if (Enemy.IsA('gbxPawn') && (gbxPawn(Enemy).MyUnit != None) &&
				(gbxPawn(Enemy).MyUnit == MyTank.MyUnit.AssignedTargetUnit) && UnitControllerAI(MyTank.MyUnit.MyUnitController).bAssaultThisTarget)
			{
				distance = VSize(MyTank.Location - Enemy.Location);
				if (distance <= UnitControllerAITank(MyTank.MyUnit.MyUnitController).IdealAssaultDistance)
				{
					// only stop and turn to face enemy if we are already inside the assault radius...
					MyTankStuartController.bRotateToFaceEnemy = true;
					MyTankStuartController.EnemyRotateToFace = Enemy;
				}
			}
			else
			{
				// else, for all other cases, rotate to face this enemy (when distance is less than RotateToFaceDistance)
				MyTankStuartController.bRotateToFaceEnemy = true;
				MyTankStuartController.EnemyRotateToFace = Enemy;
			}
		}
	}

	if ((MyTankStuartController.bRotateToFaceEnemy) && (MyTankStuartController.EnemyRotateToFace != None))
	{
		if (!MyTankStuartController.bIsInScriptedMode)
		{
			bCanSeePawn = MyTankController.CanSeeOrSuppress(Pawn(MyTankStuartController.MainGunTarget), SeeLoc, IsHeadShot, SuppressLoc, FailLoc);
		}
		else
		{
			bCanSeePawn = true;
			SeeLoc = MyTankStuartController.EnemyRotateToFace.Location;
		}

		// is main gun target visible?, if so, rotate front armor to face target...
		if ((bCanSeePawn) &&
			((SeeLoc.X != 0.0) && (SeeLoc.Y != 0.0) && (SeeLoc.Z != 0.0)))
		{
			// don't need to do this if navigating, the TankController navigation code will do this for us...
			if (!MyTankStuartController.bIsNavigating)
			{
				MyTankStuartController.RotateTowardTarget(MyTankStuartController.EnemyRotateToFace);
			}
		}
	}

	if (MyTankStuartController.MainGunTarget != None)
	{
		if (!bIsPlayerOnTank)
			bIsResettingTurret = false;

		if (fGunReactionTime < Level.TimeSeconds)
		{
			if (!MyTankStuartController.bIsInScriptedMode)
			{
				bCanSeePawn = MyTankController.CanSeeOrSuppress(Pawn(MyTankStuartController.MainGunTarget), SeeLoc, IsHeadShot, SuppressLoc, FailLoc);
			}
			else
			{
				bCanSeePawn = true;
				SeeLoc = MyTankStuartController.MainGunTarget.Location;
			}

			if (bCanSeePawn)
			{
				if (MyTankStuartController.MainGunTarget.IsA( 'Infantry' ))  // is target an infantry soldier?
				{
					// aim for the feet...
					aim_offset = vect(0,0,0);
					aim_offset.Z = MyTankStuartController.MainGunTarget.CollisionHeight;
					TargetAimLoc = SeeLoc - aim_offset;
				}
				else
				{
					// aim slightly below the center (Location) of target...
					aim_offset = vect(0,0,0);
					aim_offset.Z = MyTankStuartController.MainGunTarget.CollisionHeight / 2.0f;
					TargetAimLoc = SeeLoc - aim_offset;
				}

				if ((SeeLoc.X == 0.0) && (SeeLoc.Y == 0.0) && (SeeLoc.Z == 0.0))
				{
//					TargetAimLoc = SuppressLoc;
					TargetAimLoc = TargetQueue[ndxEnemyInQueue].LastKnownLocation;
				}

				TrackMainGunTarget(deltaTime, TargetAimLoc, false);  // track using the turret and the main gun

				if (!MyTankStuartController.bIsInScriptedMode)
				{
					bHatchClosed = true;  // assume true until known otherwise...
					if ((MyTankStuart != None) && (MyTankStuart.CommanderPawn != None) &&
						(MyTankStuart.CommanderPawn.Health > 0))
					{
						bHatchClosed = MyTankStuart.CommanderPawn.bHatchFullyClosed;
					}

					if (bIsPlayerOnTank)
						bOnTarget = bIsYawOnTarget;  // more forgiving if player is riding on tank
					else
						bOnTarget = bIsOnTarget;

					if ((bOnTarget) && (bHatchClosed) && (MyTankStuart.fMainGunReFireTime < Level.TimeSeconds))
					{
						MyTankStuart.fMainGunReFireTime = Level.TimeSeconds + MyTankStuart.fMainGunReFireDelay + (FRand() * 2.0);
	
						FireMainGun(false);
					}
					else if (bIsYawOnTarget)
					{
						distance = VSize(MyTankStuartController.MainGunTarget.Location - MyTankStuart.Location);
						if ((distance < MyTankStuart.VehicleCollisionRadius * 3.0) &&
							(bHatchClosed) && (MyTankStuart.fMainGunReFireTime < Level.TimeSeconds))
						{
							MyTankStuart.fMainGunReFireTime = Level.TimeSeconds + MyTankStuart.fMainGunReFireDelay + (FRand() * 2.0);
	
							FireMainGun(false);
						}
					}
				}
			}
		}
	}
	else if (MyTankStuartController.CoaxGunTarget != None)
	{
		if (!bIsPlayerOnTank)
			bIsResettingTurret = false;

		if (fGunReactionTime < Level.TimeSeconds)
		{
			bCanSeePawn = MyTankController.CanSeeOrSuppress(Pawn(MyTankStuartController.CoaxGunTarget), SeeLoc, IsHeadShot, SuppressLoc, FailLoc);

			if (bCanSeePawn)
			{
				TargetAimLoc = SeeLoc;

				if ((SeeLoc.X == 0.0) && (SeeLoc.Y == 0.0) && (SeeLoc.Z == 0.0))
				{
//					TargetAimLoc = SuppressLoc;
					TargetAimLoc = TargetQueue[ndxEnemyInQueue].LastKnownLocation;
				}

				TrackMainGunTarget(deltaTime, TargetAimLoc, true);  // track using the turret and coax machine gun
	
				// are we on target AND not firing a burst AND time to start a new burst?
				if ((bIsOnTarget) && (!bIsFiringBurst) && (fBurstStartTime < Level.TimeSeconds))
				{
					// is it time to switch to the main gun (is the coax gun "frustrated")?
					if ((fCoaxGunFrustrationTime) < Level.TimeSeconds)
					{
						bHatchClosed = true;  // assume true until known otherwise...
						if ((MyTankStuart != None) && (MyTankStuart.CommanderPawn != None) &&
							(MyTankStuart.CommanderPawn.Health > 0))
						{
							bHatchClosed = MyTankStuart.CommanderPawn.bHatchFullyClosed;
						}

						if ((bIsOnTarget) && (bHatchClosed) && (MyTankStuart.fMainGunReFireTime < Level.TimeSeconds))
						{
							MyTankStuart.fMainGunReFireTime = Level.TimeSeconds + MyTankStuart.fMainGunReFireDelay + (FRand() * 2.0);
	
							FireMainGun(false);
	
							// reset the coax gun frustration time...
							fCoaxGunFrustrationTime = Level.TimeSeconds + fCoaxGunFrustrationDelay + (FRand() * 2.0);

							// don't start firing the coax gun again for a little while after firing the main gun...
							fBurstStartTime = Level.TimeSeconds + MinPauseLength + FRand() * 1.0;
						}
					}
					else
					{
						CoaxGunLoc = MyTankStuart.GetTagCoords( MyTankStuart.CoaxGunMuzzleBoneName ).origin;

						CoaxGunRot.Pitch = MyTankStuart.Rotation.Pitch + MyTankStuart.MainGunPitch;
						CoaxGunRot.Yaw = MyTankStuart.Rotation.Yaw - MyTankStuart.TurretYaw;
						CoaxGunRot.Roll = 0;

						// see if we can shoot at what we're aiming at without hitting teammates...
						if (ApproveShot(CoaxGunLoc, CoaxGunRot))
						{
							bIsFiringBurst = true;
							MyTankStuart.CoaxGunSoundHandle = MyTankStuart.PlaySoundCue( MyTankStuart.CoaxGunFireLoopSound, SLOT_NONE, TransientSoundVolume,,,,false);
	
							fBurstEndTime = Level.TimeSeconds + MinBurstLength + (FRand() * (MaxBurstLength - MinBurstLength));
							fBurstStartTime = fBurstEndTime + MinPauseLength + (FRand() * (MaxPauseLength - MinPauseLength));
						}
						else
						{
							// try firing again after 0.5 - 2.5 seconds...
							fBurstStartTime = Level.TimeSeconds + 0.5 + (FRand() * 2.0);
						}
					}
				}
			}
		}
	}
	else
	{
		// no current target...
		bIsOnTarget = false;
		fEnemySpottedTime = -1.0f;

		// have we not seen an enemy in a while?
		if ((!bIsResettingTurret) && ((fEnemyNoneTime + fResetTurretTime) < Level.TimeSeconds) &&
			(!MyTankStuartController.bIsInScriptedMode) &&
			((MyTankStuart.TurretYaw != 0) || (MyTankStuart.MainGunPitch != 0)))
		{
			Log(name $ "(TankStuartMainGunController).Tick() - setting bIsResettingTurret = true", 'Tank');
			bIsResettingTurret = true;  // start rotating the turret back to the forwards position
		}
	}

	if (bIsResettingTurret)
	{
		bIsResettingTurret = ResetTurret(deltaTime);

		if (!bIsResettingTurret && MyTankStuart.WeapUSStuart30calMachineGun.bCameraIsPaused)
		{
			MyTankStuart.WeapUSStuart30calMachineGun.bCameraIsPaused = false;
			MyTankStuart.WeapUSStuart30calMachineGun.MountStartStamp = MyTankStuart.WeapUSStuart30calMachineGun.MountStartStamp +
						 (Level.TimeSeconds - MyTankStuart.WeapUSStuart30calMachineGun.CameraPausedTime);
			MyTankStuart.WeapUSStuart30calMachineGun.MyGunner.ResumeAnim();
		}
	}

	if (bIsFiringBurst)
	{
		bCanSeePawn = MyTankController.CanSeeOrSuppress(Pawn(MyTankStuartController.CoaxGunTarget), SeeLoc, IsHeadShot, SuppressLoc, FailLoc);

		if (bCanSeePawn)
		{
			TargetAimLoc = SeeLoc;

			if ((SeeLoc.X == 0.0) && (SeeLoc.Y == 0.0) && (SeeLoc.Z == 0.0))
			{
//				TargetAimLoc = SuppressLoc;
				TargetAimLoc = TargetQueue[ndxEnemyInQueue].LastKnownLocation;
			}

			TrackMainGunTarget(deltaTime, TargetAimLoc, true);  // track using the turret and coax machine gun
		}

		if (fBurstEndTime < Level.TimeSeconds)  // has the burst ended?
		{
			bIsFiringBurst = false;
			MyTankStuart.StopSound( MyTankStuart.CoaxGunSoundHandle );
			MyTankStuart.PlaySoundCue( MyTankStuart.CoaxGunFireOnceSound, SLOT_NONE, TransientSoundVolume,,,,false);
		}
		else
		{
			if (MyTankStuart.fCoaxGunReFireTime < Level.Timeseconds)
			{
				FireCoaxGun(false);
			}
		}
	}
}

function int GetNewRotation(int current, int desired, int rate)
{
	local int result;

	result = current & 65535;
	current = result;
	desired = desired & 65535;

	if (current > desired)
	{
		if (current - desired < 32768)
			result -= Min((current - desired), abs(rate));
		else
			result += Min((desired + 65536 - current), abs(rate));
	}
	else
	{
		if (desired - current < 32768)
			result += Min((desired - current), abs(rate));
		else
			result -= Min((current + 65536 - desired), abs(rate));
	}

	return (result & 65535);
}

function bool ResetTurret(float DeltaTime)
{
	local int WorldTurretYaw;
	local int WorldMainGunPitch;
	local float YawRate, PitchRate;
	local rotator TurretRot;
	local rotator MainGunRot;

	if (MyTankStuart == None)
		return false;

	// convert TurretYaw and MainGunPitch to world space...
	WorldTurretYaw = (MyTankStuart.Rotation.Yaw - MyTankStuart.TurretYaw) & 65535;
	WorldMainGunPitch = (MyTankStuart.Rotation.Pitch + MyTankStuart.MainGunPitch) & 65535;

	YawRate = (MyTankStuart.TurretRotationSpeed * DeltaTime / 360.0) * 65536;
	PitchRate = (MyTankStuart.MainGunRotationSpeed * DeltaTime / 360.0) * 65536;

	WorldTurretYaw = GetNewRotation(WorldTurretYaw, MyTankStuart.Rotation.Yaw, int(YawRate));
	WorldMainGunPitch = GetNewRotation(WorldMainGunPitch, MyTankStuart.Rotation.Pitch, int(PitchRate));

	// convert TurretYaw and MainGunPitch back to local space...
	MyTankStuart.TurretYaw = (MyTankStuart.Rotation.Yaw - WorldTurretYaw) & 65535;
	MyTankStuart.MainGunPitch = (WorldMainGunPitch - MyTankStuart.Rotation.Pitch) & 65535;

	TurretRot.Pitch = 0;
	TurretRot.Yaw = MyTankStuart.TurretYaw;
	TurretRot.Roll = 0;

	MyTankStuart.SetBoneRotation(MyTankStuart.TurretBoneName, TurretRot, 0, 1.0);

	MainGunRot.Pitch = 0;
	MainGunRot.Yaw = 0;
	MainGunRot.Roll = MyTankStuart.MainGunPitch;

	MyTankStuart.SetBoneRotation(MyTankStuart.MainGunBoneName, MainGunRot, 0, 1.0);

	if ((MyTankStuart.TurretYaw == 0) && (MyTankStuart.MainGunPitch == 0))
	{
		Log(name $ "(TankStuartMainGunController).ResetTurret() - rotation done, returning false", 'Tank');
		return false;  // finished rotating
	}

	return true;
}

function TrackMainGunTarget(float DeltaTime, vector TargetAimLoc, bool bUseCoax)
{
	local int WorldTurretYaw;
	local int WorldMainGunPitch;
	local vector MainGunBoneLoc, CoaxGunBoneLoc;
	local rotator RotToTarget;
	local float YawRate, PitchRate;
	local int MaxPitchUp, MaxPitchDown;
	local rotator TurretRot;
	local rotator MainGunRot;
	local int PitchDiff, YawDiff;

	if (MyTankStuart == None)
		return;

	// convert TurretYaw and MainGunPitch to world space...
	WorldTurretYaw = (MyTankStuart.Rotation.Yaw - MyTankStuart.TurretYaw) & 65535;
	WorldMainGunPitch = (MyTankStuart.Rotation.Pitch + MyTankStuart.MainGunPitch) & 65535;

	if (!bUseCoax)
	{
		MainGunBoneLoc = MyTankStuart.GetBoneCoords( MyTankStuart.MainGunBoneName ).origin;
		RotToTarget = rotator(TargetAimLoc - MainGunBoneLoc);
	}
	else
	{
		CoaxGunBoneLoc = MyTankStuart.GetTagCoords( MyTankStuart.CoaxGunBoneName ).origin;
		RotToTarget = rotator(TargetAimLoc - CoaxGunBoneLoc);
	}

	if (bIsPlayerOnTank)
		YawRate = 0;
	else
		YawRate = (MyTankStuart.TurretRotationSpeed * DeltaTime / 360.0) * 65536;

	PitchRate = (MyTankStuart.MainGunRotationSpeed * DeltaTime / 360.0) * 65536;

	WorldTurretYaw = GetNewRotation(WorldTurretYaw, RotToTarget.Yaw, int(YawRate));
	WorldMainGunPitch = GetNewRotation(WorldMainGunPitch, RotToTarget.Pitch, int(PitchRate));

	PitchDiff = abs((WorldMainGunPitch & 65535) - (RotToTarget.Pitch & 65535));
	if (PitchDiff > 32768)
		PitchDiff = 65536 - PitchDiff;

	YawDiff = abs((WorldTurretYaw & 65535) - (RotToTarget.Yaw & 65535));
	if (YawDiff > 32768)
		YawDiff = 65536 - YawDiff;

	bIsOnTarget = false;  // assume not on target until known otherwise
	bIsYawOnTarget = false;

	// is the gun aimed close enough to the target?
	if ((YawDiff < 500) && (PitchDiff < 500))
	{
		bIsOnTarget = true;  // gun is "on target", start shooting
	}

	if (YawDiff < 800)
	{
		bIsYawOnTarget = true;
	}

	if (bIsPlayerOnTank)
	{
		// does the tank need to rotate to aim the main gun at the enemy?...
		if (YawDiff >= 500)
		{
			// request the tank to rotate towards the target...
			if (!bUseCoax)
				MyTankStuartController.RotateTowardTarget(MyTankStuartController.MainGunTarget, true);
			else
				MyTankStuartController.RotateTowardLocation(TargetAimLoc, true);
		}
	}

	// convert TurretYaw and MainGunPitch back to local space...
	MyTankStuart.TurretYaw = (MyTankStuart.Rotation.Yaw - WorldTurretYaw) & 65535;
	MyTankStuart.MainGunPitch = (WorldMainGunPitch - MyTankStuart.Rotation.Pitch) & 65535;

	MaxPitchUp = int((MyTankStuart.MainGunUpwardFireArc / 360.0) * 65536.0);
	MaxPitchDown = int((MyTankStuart.MainGunDownwardFireArc / 360.0) * 65536.0);

	if (MyTankStuart.MainGunPitch > 32767)
		MyTankStuart.MainGunPitch = MyTankStuart.MainGunPitch - 65536;

	MyTankStuart.MainGunPitch = Clamp(MyTankStuart.MainGunPitch, -MaxPitchDown, MaxPitchUp);

	// for cases where gun has reached max pitch up/down, fire if yaw is on target and pitch is within 10 degrees of target...
	if ((YawDiff < 500) && ((MyTankStuart.MainGunPitch == -MaxPitchDown) || (MyTankStuart.MainGunPitch == MaxPitchUp)) &&
		(PitchDiff < 1820))
	{
		bIsOnTarget = true;  // gun is "on target", start shooting
	}

	TurretRot.Pitch = 0;
	TurretRot.Yaw = MyTankStuart.TurretYaw;
	TurretRot.Roll = 0;

	MyTankStuart.SetBoneRotation(MyTankStuart.TurretBoneName, TurretRot, 0, 1.0);

	MainGunRot.Pitch = 0;
	MainGunRot.Yaw = 0;
	MainGunRot.Roll = MyTankStuart.MainGunPitch;

	MyTankStuart.SetBoneRotation(MyTankStuart.MainGunBoneName, MainGunRot, 0, 1.0);
}

function Rotator AdjustAimNewTankShell( Ammunition Ammo, Vector ProjStart, Rotator AimRotator, InstantFire MyInstantFire, optional out int bSkipDoTrace )
{
	local float DistToTarget;
	local int index;
	local bool bCheckNoDamage;

	// check if the enemy is not a tank...
	if ((Enemy != None) && (!Enemy.IsA('Tank')))
	{
		bCheckNoDamage = false; // assume false until known otherwise

		index = FindTargetInQueue( Enemy );

		// check if the enemy is a "hard" target (Pak36 gunner, Panzerfaust soldier, etc)...
		if ( (index >= 0) && (TargetQueue[index].bIsHardTarget == 1) )
			bCheckNoDamage = true;

		// check if the enemy is manning a machine gun...
		if ( !bCheckNoDamage && (gbxPawn(Enemy) != None) && (gbxPawn(Enemy).bIsManningTurret) )
			bCheckNoDamage = true;

		if (bCheckNoDamage)
		{
			DistToTarget = VSize( Enemy.Location - MyTank.Location );

			// Is this a deadlock situation?
			if ( DistToTarget > MainGunDoNoDamageRange )
			{
				MyTankStuart.MainGunFireMode.bIgnoreDamageThisBullet = true;
			}
		}
	}

	return Super.AdjustAimNewTankShell(Ammo, ProjStart, AimRotator, MyInstantFire, bSkipDoTrace);
}

function FireMainGun(bool bDoNoDamage)
{
	local vector MainGunLoc;
	local rotator MainGunRot;
	local vector RotX, RotY, RotZ;
	local int AimErrorLocal;
	local rotator AdjustedAim;
	local int bSkipDoTrace;
	local gbxTankShell TankShell;

	if (!bDoNoDamage)
		MyTankStuart.MainGunFireMode.bIgnoreDamageThisBullet = false;

	MainGunLoc = MyTankStuart.GetTagCoords( MyTankStuart.MainGunMuzzleBoneName ).origin;

	MainGunRot.Pitch = MyTankStuart.MainGunPitch;
	MainGunRot.Yaw = -MyTankStuart.TurretYaw;
	MainGunRot.Roll = 0;

	MainGunRot = MyTankStuart.Rotation + MainGunRot;

    GetAxes(MainGunRot,RotX,RotY,RotZ);

	MainGunLoc = MainGunLoc + MyTankStuart.MainGunEmitterOffset.X * RotX + MyTankStuart.MainGunEmitterOffset.Y * RotY + MyTankStuart.MainGunEmitterOffset.Z * RotZ;

	MainGunRot.Pitch = 0;  // ignore main gun pitch for main gun smoke and dust emitter
	MainGunRot.Yaw = -MyTankStuart.TurretYaw;
	MainGunRot.Roll = 0;

	MainGunRot = MyTankStuart.Rotation + MainGunRot;

	// spawn main gun smoke and dust emitter...
	spawn(MyTankStuart.MainGunSmokeEmitterClass, None,, MainGunLoc, MainGunRot);

	AimErrorLocal = AimErrorAIMain;

	AdjustedAim = MyTankStuart.AdjustAimMainGun();

	ApplyAccuracy( AdjustedAim, AimErrorLocal );

	AdjustedAim = AdjustAimNewTankShell(MyTankStuart.MainGunAmmo, MainGunLoc, AdjustedAim, MyTankStuart.MainGunFireMode, bSkipDoTrace);

	// spawn main gun muzzle flash emitter...
	spawn(MyTankStuart.MainGunFlashEmitterClass, None,, MainGunLoc, AdjustedAim);

	if (MyTankStuart.MainGunFireMode.bIgnoreDamageThisBullet)
	{
		Log(name $ ".FireMainGun - bIgnoreDamageThisBullet was True, doing no damage", 'Tank');
		bDoNoDamage = true;
	}

	TankShell = Spawn( class'gbxTankShell', MyTankStuart,, MainGunLoc, AdjustedAim );
	TankShell.Instigator = MyTankStuart;
	if (bDoNoDamage)
		TankShell.Damage = 0;

	MyTankStuart.PlaySoundCue( MyTankStuart.MainGunFireSound, SLOT_NONE, TransientSoundVolume,,,,false);

	MyTankStuart.PlayMainGunFiringAnim(MyTankStuart.TurretYaw);
}

function FireCoaxGun(bool bDoNoDamage)
{
	local vector CoaxGunLoc;
	local rotator CoaxGunRot;
	local vector RotX, RotY, RotZ;
	local int AimErrorLocal;
	local rotator AdjustedAim;
	local int bSkipDoTrace;
	local Emitter MuzzleFlash;

	if (MyTankStuart.CoaxGunFireMode != None)
	{
		MyTankStuart.fCoaxGunReFireTime = Level.TimeSeconds + MyTankStuart.fCoaxGunReFireDelay;

		CoaxGunLoc = MyTankStuart.GetTagCoords( MyTankStuart.CoaxGunMuzzleBoneName ).origin;

		CoaxGunRot.Pitch = MyTankStuart.Rotation.Pitch + MyTankStuart.MainGunPitch;
		CoaxGunRot.Yaw = MyTankStuart.Rotation.Yaw - MyTankStuart.TurretYaw;
		CoaxGunRot.Roll = 0;

	    GetAxes(CoaxGunRot,RotX,RotY,RotZ);

		CoaxGunLoc = CoaxGunLoc + MyTankStuart.CoaxGunEmitterOffset.X * RotX + MyTankStuart.CoaxGunEmitterOffset.Y * RotY + MyTankStuart.CoaxGunEmitterOffset.Z * RotZ;

		MyTankStuart.Owner.MakeNoise(1.0);

		AimErrorLocal = AimErrorAICoax;

		AdjustedAim = MyTankStuart.AdjustAimCoaxGun();

		ApplyAccuracy( AdjustedAim, AimErrorLocal );

		AdjustedAim = AdjustAimNewBullet(MyTankStuart.CoaxGunAmmo, CoaxGunLoc, AdjustedAim, MyTankStuart.CoaxGunFireMode, bSkipDoTrace);

		if (bDoNoDamage)
			MyTankStuart.CoaxGunFireMode.SetNoDamageThisBullet();

		MyTankStuart.CoaxGunFireMode.DoTrace(CoaxGunLoc, AdjustedAim);

		MyTankStuart.CoaxGunTracerCount++;

		if ( MyTankStuart.CoaxGunTracerCount >= MyTankStuart.CoaxGunTracerFrequency )
		{
			MyTankStuart.CoaxGunTracerCount = 0;

			// Emit a tracer
			if( (MyTankStuart.CoaxGunTracerEmitter != None) )
				MyTankStuart.CoaxGunTracerEmitter.TriggerEmitters( CoaxGunLoc, AdjustedAim );
		}

		MuzzleFlash = MyTankStuart.CoaxGunFireMode.GetMuzzleFlash();

		MuzzleFlash.SetLocation(CoaxGunLoc);
		MuzzleFlash.SetRotation(CoaxGunRot);

		if ( MuzzleFlash.IsA( 'gbxMuzzleFlash' ) )
			gbxMuzzleFlash(MuzzleFlash).ShowMuzzleFlash();
	}
}

defaultproperties
{
	PeripheralVisionWithCommander=-0.7071  // +/- 135 degrees (270 degrees total)
	PeripheralVisionWithoutCommander=0.0  // +/- 90 degrees (180 degrees total)

	bIsOnTarget=false
	bIsFiringBurst=false

	MinBurstLength=2.0
	MaxBurstLength=3.5
	MinPauseLength=1.0
	MaxPauseLength=2.0

	fResetTurretTime=5.0  // if no enemy, start resetting the turret after 5.0 seconds
	fCoaxGunFrustrationDelay=10.0

	TargetPriorityScalarInfantryGroup=0.8

	bLogPriority=false

	AimErrorAIMain=50
	AimErrorAICoax=300

	BulletDoNoDamageRange=5000.0

	bDoesPurposefulMiss=false

	TargetForgetTimeLong=30.0f
	TargetForgetTimeShort=15.0f

	ReactionTimeMin=0.2
	ReactionTimeMax=0.5
	ReactionTimeMinEasy=0.2
	ReactionTimeMaxEasy=0.5
	ReactionTimeMinNormal=0.2
	ReactionTimeMaxNormal=0.5
	ReactionTimeMinHard=0.5
	ReactionTimeMaxHard=1.0
	ReactionTimeMinAuthentic=2.0
	ReactionTimeMaxAuthentic=3.0

	PurposefulMissTimeStart=20.0
	PurposefulMissTimeBonus=5.0
	PurposefulMissTimeMax=30.0
	PurposefulMissTimeStartEasy=10.0
	PurposefulMissTimeBonusEasy=5.0
	PurposefulMissTimeMaxEasy=20.0
	PurposefulMissTimeStartNormal=15.0
	PurposefulMissTimeBonusNormal=5.0
	PurposefulMissTimeMaxNormal=20.0
	PurposefulMissTimeStartHard=20.0
	PurposefulMissTimeBonusHard=5.0
	PurposefulMissTimeMaxHard=30.0
	PurposefulMissTimeStartAuthentic=20.0
	PurposefulMissTimeBonusAuthentic=5.0
	PurposefulMissTimeMaxAuthentic=30.0
}
class TankStugController extends TankControllerGerman
	notplaceable;


var()	TankStug					MyTankStug;
var()	TankStugMainGunController	MyMainGunController;

// enemy targeting stuff...
var()	Actor	MainGunTarget;


function Possess(Pawn aPawn)
{
	Log( name $ ".(TankStugController).Possess( " $ aPawn.name $ " )", 'Tank' );

	Super.Possess(aPawn);

	if ((aPawn == None) || (TankStug(aPawn) == None))
	{
		Log(name $ ".Possess() - WARNING! TankStugController's Pawn is NOT a TankStug!!!");
	}
	else
	{
		MyTankStug = TankStug(aPawn);

		MyMainGunController = spawn(class'TankStugMainGunController', self);
		if (MyMainGunController == None)
			Log( name $ ".(TankStugController).Possess() - ERROR Spawning TankStugMainGunController!!!", 'Tank' );
		else
			MyMainGunController.Possess(MyTankStug, self);

		if (bTargetForgetTimeOverride)
		{
			MyMainGunController.TargetForgetTimeLong = TargetForgetTime;
			MyMainGunController.TargetForgetTimeShort = TargetForgetTime;
		}
	}
}

function Destroyed()
{
	Log( name $ ".(TankStugController).Destroyed()", 'Tank' );

	if (MyMainGunController != None)
		MyMainGunController.Destroy();

	super.Destroyed();
}

function Timer()
{
	Super.Timer();

	if (fPauseMovementCheckTime < Level.TimeSeconds)
	{
		fPauseMovementCheckTime = Level.TimeSeconds + 2.0f;

		bPauseMovement = false;  // stop moving and attack enemy from here

		if ( (MyMainGunController != None) && MyMainGunController.ShouldTankPause() )
		{
			bPauseMovement = true;  // stop moving and attack enemy from here
		}
	}
}

function PawnDied(Pawn P)
{
	Log( name $ ".(TankStugController).PawnDied()", 'Tank' );

	Super.PawnDied(P);
}

function NotifyTakeHit(pawn InstigatedBy, vector HitLocation, int Damage, class<DamageType> damageType, vector Momentum)
{
//	Log( name $ "(" $ Pawn.name $ ").NotifyTakeHit( " $ InstigatedBy.name $ " )", 'Tank' );

	if (bIsInScriptedMode)
		return;  // don't do anything if under scripted control

	if (MyMainGunController != None)
		MyMainGunController.NotifyTakeHit(InstigatedBy, HitLocation, Damage, damageType, Momentum);

	Super.NotifyTakeHit( InstigatedBy, HitLocation, Damage, damageType, Momentum );
}

function SeePawn( Pawn Seen )
{
//	Log( name $ "(" $ Pawn.name $ ").SeePawn( " $ Seen.name $ " )", 'Tank' );

	if (bIsInScriptedMode)
		return;  // don't do anything if under scripted control

	if (MyMainGunController != None)
		MyMainGunController.SeePawn(Seen);

	Super.SeePawn(Seen);
}

function SeePawnKilled( Pawn Seen, Pawn Killer )
{
//	Log( name $ "(" $ Pawn.name $ ").SeePawnKilled( " $ Seen.name $ " )", 'Tank' );

	if (bIsInScriptedMode)
		return;  // don't do anything if under scripted control

	// Seeing your friends get killed.
	if (MyMainGunController != None)
		MyMainGunController.SeePawnKilled(Seen, Killer);

	Super.SeePawnKilled(Seen, Killer);
}

function SeePawnHit( Pawn Seen )
{
//	Log( name $ "(" $ Pawn.name $ ").SeePawnHit( " $ Seen.name $ " )", 'Tank' );

	if (bIsInScriptedMode)
		return;  // don't do anything if under scripted control

	if (MyMainGunController != None)
		MyMainGunController.SeePawnHit(Seen);

	Super.SeePawnHit(Seen);
}

function HearNoise( float Loudness, Actor NoiseMaker )
{
//	Log( name $ "(" $ Pawn.name $ ").HearNoise( " $ Loudness $ ", " $ NoiseMaker.name $ " )", 'Tank' );

	if (bIsInScriptedMode)
		return;  // don't do anything if under scripted control

	if (MyMainGunController != None)
		MyMainGunController.HearNoise(Loudness, NoiseMaker);

	Super.HearNoise(Loudness, NoiseMaker);
}

function SeePlayer( Pawn Seen )
{
//	Log( name $ "(" $ Pawn.name $ ").SeePlayer( " $ Seen.name $ " )", 'Tank' );

	if (bIsInScriptedMode)
		return;  // don't do anything if under scripted control

	if (MyMainGunController != None)
		MyMainGunController.SeePlayer(Seen);

	Super.SeePlayer(Seen);
}

function SeeExplosion( Pawn Instigator )
{
//	Log( name $ "(" $ Pawn.name $ ").SeeExplosion( " $ Instigator.name $ " )", 'Tank' );

	if (bIsInScriptedMode)
		return;  // don't do anything if under scripted control

	// Seeing shit get blown up.
	if (MyMainGunController != None)
		MyMainGunController.SeeExplosion(Instigator);

	Super.SeeExplosion(Instigator);
}

function NotifyTargetOrder(Unit targetUnit)
{
	local int i;

	// notify this member about all Targets in the targetUnit...
	for (i = 0; i < targetUnit.NumMembers; i++)
	{
		if (MyMainGunController != None)
			MyMainGunController.AddTarget( targetUnit.Members[i] );
	}
}

function NotifyAssaultOrder(Unit targetUnit)
{
	local int i;

	// notify this member about all Targets in the targetUnit...
	for (i = 0; i < targetUnit.NumMembers; i++)
	{
		if (MyMainGunController != None)
			MyMainGunController.AddTarget( targetUnit.Members[i] );
	}
}

function ConsiderPossibleEnemy( Pawn possibleEnemy )
{
	if (bIsInScriptedMode)
		return;  // don't do anything if under scripted control

	if (MyMainGunController != None)
		MyMainGunController.ConsiderPossibleEnemy(possibleEnemy, false);
}

event float GetTargetExposureToMe( Pawn aThreat )
{
	return MyMainGunController.GetTargetExposureToMe(aThreat);
}

function bool EnemiesAreRecentlyVisible()
{
	if (bIsInScriptedMode)
		return false;  // don't do anything if under scripted control

	if (MyMainGunController.EnemiesAreRecentlyVisible())
		return true;

	return false;
}

function bool NoEnemiesVisibleForAWhile()
{
	if (bIsInScriptedMode)
		return true;  // don't do anything if under scripted control

	if (MyMainGunController != None)
	{
		if (!MyMainGunController.NoEnemiesVisibleForAWhile())
			return false;
	}

	return true;
}

function gbxPawn GetHuntingEnemy(out vector LastKnownLocation, out vector FirstHiddenLocation)
{
	local gbxPawn HuntingEnemy;

	if (MyMainGunController != None)
	{
		HuntingEnemy = MyMainGunController.GetHuntingEnemy(LastKnownLocation, FirstHiddenLocation);

		if (HuntingEnemy != None)
			return HuntingEnemy;
	}

	return None;
}

function ResetTurret(float DeltaTime)
{
	// nothing to do
}

function Rotator GetMainGunWorldRotation()
{
	local rotator GunRotation;

	GunRotation.Pitch = MyTankStug.Rotation.Pitch + MyTankStug.MainGunPitch;
	GunRotation.Yaw = MyTankStug.Rotation.Yaw;
	GunRotation.Roll = 0;

	return GunRotation;
}

function HandleTrackingTarget(float DeltaTime)
{
	if ( bIsPausing )
	{
		if (PauseTime > Level.Timeseconds)
			return;

		bIsPausing = false;
	}

	MyMainGunController.TrackMainGunTarget(DeltaTime, TargetAimLocation);

	if (MyMainGunController.bIsYawOnTarget)
	{
		if (bIsRotatingToTheLeft)
		{
			bIsRotatingToTheLeft = false;

			RotationYawDelta = (CenteredYawRotation + (LookingForEnemyRotateYawMax * 65536.0 / 360.0)) & 65535;

			TempRot = MyTank.Rotation;
			TempRot.Yaw = RotationYawDelta;

			TargetAimLocation = MyTank.Location + Vector(TempRot) * 1000.0f;
		}
		else
		{
			bIsRotatingToTheLeft = true;

			RotationYawDelta = (CenteredYawRotation - (LookingForEnemyRotateYawMax * 65536.0 / 360.0)) & 65535;

			TempRot = MyTank.Rotation;
			TempRot.Yaw = RotationYawDelta;

			TargetAimLocation = MyTank.Location + Vector(TempRot) * 1000.0f;
		}

		bIsPausing = true;
		PauseTime = Level.TimeSeconds + 0.5 + FRand() * 0.3;
	}
}

function HandleGrenadePlanted(float DeltaTime)
{
	MyMainGunController.TrackMainGunTarget(DeltaTime, TargetAimLocation);

	if (MyMainGunController.bIsYawOnTarget)
	{
		if (bIsRotatingToTheLeft)
		{
			bIsRotatingToTheLeft = false;

			RotationYawDelta = (CenteredYawRotation + (GrenadePlantedRotateYawMax * 65536.0 / 360.0)) & 65535;

			TempRot = MyTank.Rotation;
			TempRot.Yaw = RotationYawDelta;

			TargetAimLocation = MyTank.Location + Vector(TempRot) * 1000.0f;
		}
		else
		{
			bIsRotatingToTheLeft = true;

			RotationYawDelta = (CenteredYawRotation - (GrenadePlantedRotateYawMax * 65536.0 / 360.0)) & 65535;

			TempRot = MyTank.Rotation;
			TempRot.Yaw = RotationYawDelta;

			TargetAimLocation = MyTank.Location + Vector(TempRot) * 1000.0f;
		}
	}
}

function bool TankHasEnemy()
{
	if (MyMainGunController != None)
	{
		if (MyMainGunController.ndxEnemyInQueue >= 0)
			return true;
	}

	return false;
}


defaultproperties
{
	LookingForEnemyRotateYawMax=15.0  // in degrees
	GrenadePlantedRotateYawMax=10.0  // in degrees
}
class TankStugMainGunController extends TankGunController
	notplaceable;


var()	TankStug			MyTankStug;
var()	TankStugController	MyTankStugController;

// weapon targeting stuff...
var()	bool	bIsOnTarget;
var()	bool	bIsYawOnTarget;

var()	float	fEnemySpottedTime;	// when we first saw the enemy
var()	float	fEnemyNoneTime;		// time when enemy was last set to None
var()	float	fResetMainGunTime;	// how long after enemy = none to reset turret back to facing fowards
var()	bool	bIsResettingMainGun;

var()	float	fMainGunFireDelay;	// short delay between "on target/ready to fire" and "fire gun"
var()	float	fMainGunFireTime;

var(Target)	float TargetPriorityScalarInfantryGroup;

var()	int		AimErrorAI;
var()	int		AimErrorAINormal;
var()	int		AimErrorAIBefuddled;

var()	bool	bLogPriority;


function Possess(Tank aPawn, TankController aController)
{
	Log( name $ ".(TankStugMainGunController).Possess( " $ aPawn.name $ " " $ aController.name $ " )", 'Tank' );

	if (TankStug(aPawn) == None)
	{
		Log(name $ ".Possess - aPawn (" $ aPawn.name $ ") is NOT a TankStug!!!");
		return;
	}

	if (TankStugController(aController) == None)
	{
		Log(name $ ".Possess - aController (" $ aController.name $ ") is NOT a TankStugController!!!");
		return;
	}

	Super.Possess(aPawn, aController);

	MyTankStug = TankStug(aPawn);
	MyTankStugController = TankStugController(aController);

	fEnemyNoneTime = 0.0f;
	fEnemySpottedTime = -1.0f;  // enemy not spotted yet
	fMainGunFireTime = -1.0f;
}

function Timer()
{
//	Log( name $ ".(TankStugMainGunController).Timer()", 'Tank' );

	if (MyTankStugController.bIsInScriptedMode)
	{
		Super.Timer();
		return;
	}

	PeripheralVision = PeripheralVisionWithoutCommander;  // default to vision without tank commander

	if (MyTankStug != None)
	{
		if (MyTankStug.bSpawnCommander)  // if tank was spawned without a commander, use same vision as if had a commander...
		{
			PeripheralVision = PeripheralVisionWithCommander;
		}
		else if ((MyTankStug.CommanderPawn != None) && (MyTankStug.CommanderPawn.Health > 0) && (!MyTankStug.CommanderPawn.bHatchClosing))
		{
			PeripheralVision = PeripheralVisionWithCommander;
		}
	}

	if ((MyTankStugController.BefuddledEndTime > 0.0) && (MyTankStugController.BefuddledEndTime < Level.TimeSeconds))
	{
		AimErrorAI = AimErrorAIBefuddled;
	}
	else
	{
		AimErrorAI = AimErrorAINormal;
	}

	Super.Timer();
}

function SeePawn( Pawn Seen )
{
	local Rotator GunRotation;

//	Log( name $ ".(TankStugMainGunController-"$MyTank.name$").SeePawn( " $ Seen.name $ " )", 'Tank' );

	if (MyTankController.bNoEnemies)
		return;  // don't target or shoot at any enemies

	if ( MyTankController.bNoTargetPlayer && Seen.IsPlayerPawn() )
		return;  // don't target or shoot at player

	GunRotation.Pitch = MyTankStug.Rotation.Pitch;
	GunRotation.Yaw = MyTankStug.Rotation.Yaw;
	GunRotation.Roll = 0;

	if (TankGunControllerCanSee(GunRotation, Seen))
		ConsiderPossibleEnemy( Seen, true );
}

function HearNoise( float Loudness, Actor NoiseMaker )
{
//	Log( name $ ".(TankStugMainGunController-"$MyTank.name$").HearNoise( " $ Loudness $ " " $ NoiseMaker.name $ " )", 'Tank' );

	if (MyTankController.bNoEnemies)
		return;  // don't target or shoot at any enemies

	if ( MyTankController.bNoTargetPlayer && Pawn(NoiseMaker).IsPlayerPawn() )
		return;  // don't target or shoot at player

	if( NoiseMaker.IsA( 'Pawn' ))
	{
		// TODO do uncertainty.
		if ( MyTankController.bNoTargetPlayer && Pawn(NoiseMaker).IsPlayerPawn() )
			return;  // don't target or shoot at player

		ConsiderPossibleEnemy( Pawn( NoiseMaker ), true );
	}
}

function bool SetEnemy( Actor newEnemy )
{
	bIsOnTarget = false;
	return Super.SetEnemy( newEnemy );
}

event AdjustTargetPriority(int index)
{
	local gbxPawn Target;
	local float priority, weights, delta_priority;
	local vector vDir, vForward;
	local rotator MainGunRot;
	local float dotTheta;
	local int NearbyTargets;

	Target = TargetQueue[index].Target;

	// recalculate the priority and weights from the native CalculateTargetPriority() function...
	priority = TargetQueue[index].TargetPriority * TargetQueue[index].TargetTotalWeight;
	weights = TargetQueue[index].TargetTotalWeight;

	// give higher priority to targets that are in the direction that the gun is already facing...
	vDir = Normal(Target.Location - MyTankStug.Location);
	MainGunRot.Pitch = (MyTankStug.Rotation.Pitch + MyTankStug.MainGunPitch) & 65535;
	MainGunRot.Yaw = MyTankStug.Rotation.Yaw & 65535;
	MainGunRot.Roll = 0;
	vForward = Vector(MainGunRot);

	dotTheta = (vDir dot vForward);  // 1.0 to -1.0
	dotTheta = (dotTheta / 2.0) + 0.5;  // 1.0 to 0.0

	delta_priority = dotTheta * TargetPriorityScalarInAimingDirection;
	if (bLogPriority)
		Log(name $ ".AdjustTargetPriority: Target " $ Target.name $ " - InAimingDirection priority = " $ delta_priority, 'Tank');
	priority += delta_priority;
	weights += TargetPriorityScalarInAimingDirection;

	// check what type of target this is (or what type of weapon the target is carrying)...

	if (Target.IsA('gbxSVehicle'))  // is this target a vehicle?
	{
		// give higher priority to enemy vehicles (tanks, trucks, jeeps, etc)...
		delta_priority = TargetPriorityScalarEnemyVehicle;
		if (bLogPriority)
			Log(name $ ".AdjustTargetPriority: Target " $ Target.name $ " - EnemyVehicle priority = " $ delta_priority, 'Tank');
		priority += delta_priority;
		weights += TargetPriorityScalarEnemyVehicle;
		TargetQueue[index].bUseCannon = 1;  // use the cannon to fire at this/these target(s)
	}

//	if (Target.IsA('MachineGun'))
//	{
//		if (bLogPriority)
//			Log(name $ ".AdjustTargetPriority: Target " $ Target.name $ " is a manned machine gun", 'Tank');
//		TargetQueue[index].bUseCannon = 1;  // use the cannon to fire at this/these target(s)
//	}

//	if (Target.IsA('Infantry'))
//	{
//		// check what weapon this infantry soldier is carrying...
//		if (Target.Weapon.IsA('USBazooka'))
//		{
//			if (bLogPriority)
//				Log(name $ ".AdjustTargetPriority: Target " $ Target.name $ " is a soldier carrying an anti-tank weapon", 'Tank');
//			TargetQueue[index].bUseCannon = 1;  // use the cannon to fire at this/these target(s)
//		}
//	}

	if (Target.IsA('Infantry'))
	{
		// check to see if this infantry target is close to at least 2 other infantry targets...
		NearbyTargets = GetNumberOfNearbyInfantryTargets(Target);

		if (NearbyTargets >= 2)
		{
			// give higher priority to infantry targets that are in groups of 3 or more
			delta_priority = TargetPriorityScalarInfantryGroup;
			if (bLogPriority)
				Log(name $ ".AdjustTargetPriority: Target " $ Target.name $ " - InfantryGroup priority = " $ delta_priority, 'Tank');
			priority += delta_priority;
			weights += TargetPriorityScalarInfantryGroup;
			TargetQueue[index].bUseCannon = 1;  // use the cannon to fire at this/these target(s)
		}
	}

	priority = FClamp(priority, 0.0, priority);
	TargetQueue[index].TargetTotalWeight = weights;
	TargetQueue[index].TargetPriority = priority / weights;

	if (bLogPriority)
		Log(name $ ".AdjustTargetPriority: Target " $ Target.name $ " - final priority = " $ TargetQueue[index].TargetPriority, 'Tank');
}

function ReassignTargets()
{
	local int index;
	local gbxPawn Target;
	local float bestPriority;

	if (ndxEnemyInQueue < 0)  // no targets in queue?
		return;

	for (index = 0; index < TargetQueue.Length; index++)
	{
		Target = TargetQueue[index].Target;
	}

	ndxEnemyInQueue = -1;
	bestPriority = 0.0f;

	for (index = 0; index < TargetQueue.Length; index++)
	{
		if (TargetQueue[index].RelegationTime > Level.TimeSeconds)
			continue;

		if ((ndxEnemyInQueue == -1) || (TargetQueue[index].TargetPriority > bestPriority))
		{
			ndxEnemyInQueue = index;
			bestPriority = TargetQueue[index].TargetPriority;
		}
	}
}

event vector GetGunControllerRotation()
{
	local Rotator GunRotation;

	GunRotation.Pitch = MyTankStug.Rotation.Pitch + MyTankStug.MainGunPitch;
	GunRotation.Yaw = MyTankStug.Rotation.Yaw;
	GunRotation.Roll = 0;

	return vector(GunRotation);
}

function Tick( float deltaTime )
{
	local int IsHeadShot;
	local vector SuppressLoc, FailLoc;
	local bool bCanSeePawn, bHatchClosed;
	local vector TargetAimLoc;
	local vector aim_offset;
	local float ReactionTimeDelta;
	local float distance;

	Super.Tick( deltaTime );

	if (MyTankStugController == None)
		return;

	if (Enemy == None)
	{
		if (MyTankStugController.MainGunTarget != None)
		{
			fEnemyNoneTime = Level.TimeSeconds;

			MyTankStugController.MainGunTarget = None;
			MyTankStugController.bRotateToFaceEnemy = false;
			MyTankStugController.EnemyRotateToFace = None;
		}
	}
	else
	{
		if ((!MyTankStugController.bIsInScriptedMode) &&
			((fEnemySpottedTime < 0) || (MyTankStugController.MainGunTarget != Enemy)))
		{
			fEnemySpottedTime = Level.TimeSeconds;

			// have we NOT seen a target within the last 5 seconds?
			if (fGunReactionTime + 5.0 < Level.TimeSeconds)
			{
				// long reaction time, tank is not quite as aware...
				ReactionTimeDelta = ReactionTimeMax - ReactionTimeMin;
				fGunReactionTime = Level.TimeSeconds + ReactionTimeMin + (FRand() * ReactionTimeDelta);
			}
			else
			{
				// short reaction time, tank recently had an enemy and is more aware...
				fGunReactionTime = Level.TimeSeconds + 0.5 + (FRand() * 0.5f);
			}

			Log(name $ ".Tick() - MainGun Enemy " $ Enemy.name $ " spotted at " $ Level.TimeSeconds $ "  reaction time = " $ fGunReactionTime, 'Tank');

			MyTankStugController.MainGunTarget = Enemy;

			// does the tank need to rotate it's front to face this enemy (armor stronger at front)?
			if (Enemy.IsA('gbxSVehicle'))
			{
				MyTankStugController.bRotateToFaceEnemy = true;
				MyTankStugController.EnemyRotateToFace = Enemy;
			}
			else
			{
				MyTankStugController.bRotateToFaceEnemy = false;
				MyTankStugController.EnemyRotateToFace = None;
			}
		}
	}

	if ((MyTankStugController.bRotateToFaceEnemy) && (MyTankStugController.EnemyRotateToFace != None))
	{
		if (!MyTankStugController.bIsInScriptedMode)
		{
			bCanSeePawn = MyTankController.CanSeeOrSuppress(Pawn(MyTankStugController.MainGunTarget), SeeLoc, IsHeadShot, SuppressLoc, FailLoc);
		}
		else
		{
			bCanSeePawn = true;
			SeeLoc = MyTankStugController.EnemyRotateToFace.Location;
		}

		// is main gun target visible?, if so, rotate front armor to face target...
		if ((bCanSeePawn) &&
			((SeeLoc.X != 0.0) && (SeeLoc.Y != 0.0) && (SeeLoc.Z != 0.0)))
		{
			// don't need to do this if navigating, the TankController navigation code will do this for us...
			if (!MyTankStugController.bIsNavigating)
			{
				MyTankStugController.RotateTowardTarget(MyTankStugController.EnemyRotateToFace);
			}
		}
	}

	if (MyTankStugController.MainGunTarget != None)
	{
		bIsResettingMainGun = false;

		if ((fGunReactionTime < Level.TimeSeconds) &&
			(MyTankStugController.GetStateName() != 'Hunting') &&
			(MyTankStugController.GetStateName() != 'GrenadePlanted') &&
			(MyTankStugController.GetStateName() != 'Panicked'))
		{
			if (!MyTankStugController.bIsInScriptedMode)
			{
				bCanSeePawn = MyTankController.CanSeeOrSuppress(Pawn(MyTankStugController.MainGunTarget), SeeLoc, IsHeadShot, SuppressLoc, FailLoc);
			}
			else
			{
				bCanSeePawn = true;
				SeeLoc = MyTankStugController.MainGunTarget.Location;
			}

			if (bCanSeePawn)
			{
				if (MyTankStugController.MainGunTarget.IsA( 'Infantry' ))  // is target an infantry soldier?
				{
					// aim for the feet...
					aim_offset = vect(0,0,0);
					aim_offset.Z = MyTankStugController.MainGunTarget.CollisionHeight;
					TargetAimLoc = SeeLoc - aim_offset;
				}
				else
				{
					// aim slightly below the center (Location) of target...
					aim_offset = vect(0,0,0);
					aim_offset.Z = MyTankStugController.MainGunTarget.CollisionHeight / 2.0f;
					TargetAimLoc = SeeLoc - aim_offset;
				}

				if ((SeeLoc.X == 0.0) && (SeeLoc.Y == 0.0) && (SeeLoc.Z == 0.0))
				{
//					TargetAimLoc = SuppressLoc;
					TargetAimLoc = TargetQueue[ndxEnemyInQueue].LastKnownLocation;
				}

				TrackMainGunTarget(DeltaTime, TargetAimLoc, true);  // track using the main gun
	
				if ((bIsOnTarget) && (MyTankStug.fMainGunReFireTime < Level.TimeSeconds) && (fMainGunFireTime < 0))
				{
					fMainGunFireTime = Level.TimeSeconds + fMainGunFireDelay;
				}
				else
				{
					distance = VSize(MyTankStugController.MainGunTarget.Location - MyTankStug.Location);
					if ((distance < MyTankStug.VehicleCollisionRadius * 3.0) &&
						(MyTankStug.fMainGunReFireTime < Level.TimeSeconds) && (fMainGunFireTime < 0))
					{
						fMainGunFireTime = Level.TimeSeconds + fMainGunFireDelay;
					}
				}
			}
			else
			{
				fMainGunFireTime = -1.0;  // can't see the 
			}

			if (!MyTankStugController.bIsInScriptedMode)
			{
				bHatchClosed = true;  // assume true until known otherwise...
				if ((MyTankStug != None) && (MyTankStug.CommanderPawn != None) &&
					(MyTankStug.CommanderPawn.Health > 0))
				{
					bHatchClosed = MyTankStug.CommanderPawn.bHatchFullyClosed;
				}

				// time to fire the main gun yet?
				if ((bHatchClosed) && (fMainGunFireTime > 0.0) && (fMainGunFireTime < Level.TimeSeconds))
				{
					MyTankStug.fMainGunReFireTime = Level.TimeSeconds + MyTankStug.fMainGunReFireDelay + (FRand() * 2.0);
	
					FireMainGun(false);

					fMainGunFireTime = -1.0;
				}
			}
		}
	}
	else
	{
		// no current target...
		bIsOnTarget = false;
		fEnemySpottedTime = -1.0f;
		fMainGunFireTime = -1.0;

		// have we not seen an enemy in a while?
		if ((!bIsResettingMainGun) && ((fEnemyNoneTime + fResetMainGunTime) < Level.TimeSeconds) &&
			(!MyTankStugController.bIsInScriptedMode) &&
			(MyTankStug.MainGunPitch != 0))
		{
			if ((MyTankStugController.GetStateName() != 'Hunting') &&
				(MyTankStugController.GetStateName() != 'GrenadePlanted') &&
				(MyTankStugController.GetStateName() != 'Panicked'))
			{
				Log(name $ "(TankStugMainGunController).Tick() - setting bIsResettingMainGun = true", 'Tank');
				bIsResettingMainGun = true;  // start rotating the turret back to the forwards position
			}
		}

		if (bIsResettingMainGun)
			bIsResettingMainGun = ResetMainGun(DeltaTime);
	}
}

function int GetNewRotation(int current, int desired, int rate)
{
	local int result;

	result = current & 65535;
	current = result;
	desired = desired & 65535;

	if (current > desired)
	{
		if (current - desired < 32768)
			result -= Min((current - desired), abs(rate));
		else
			result += Min((desired + 65536 - current), abs(rate));
	}
	else
	{
		if (desired - current < 32768)
			result += Min((desired - current), abs(rate));
		else
			result -= Min((current + 65536 - desired), abs(rate));
	}

	return (result & 65535);
}

function bool ResetMainGun(float DeltaTime)
{
	local int WorldMainGunPitch;
	local float PitchRate;
	local rotator MainGunRot;

	if (MyTankStug == None)
		return false;

	// convert TurretYaw and MainGunPitch to world space...
	WorldMainGunPitch = (MyTankStug.Rotation.Pitch + MyTankStug.MainGunPitch) & 65535;

	PitchRate = (MyTankStug.MainGunRotationSpeed * DeltaTime / 360.0) * 65536;

	WorldMainGunPitch = GetNewRotation(WorldMainGunPitch, MyTankStug.Rotation.Pitch, int(PitchRate));

	// convert MainGunPitch back to local space...
	MyTankStug.MainGunPitch = (WorldMainGunPitch - MyTankStug.Rotation.Pitch) & 65535;

	MainGunRot.Pitch = 0;
	MainGunRot.Yaw = 0;
	MainGunRot.Roll = MyTankStug.MainGunPitch;

	MyTankStug.SetBoneRotation(MyTankStug.MainGunBoneName, MainGunRot, 0, 1.0);

	if (MyTankStug.MainGunPitch == 0)
	{
		Log(name $ "(TankStugMainGunController).ResetMainGun() - rotation done, returning false", 'Tank');
		return false;  // finished rotating
	}

	return true;
}

function TrackMainGunTarget(float DeltaTime, vector TargetAimLoc, optional bool bUseMainGunTarget)
{
	local int WorldMainGunPitch;
	local vector MainGunBoneLoc;
	local rotator RotToTarget;
	local float PitchRate;
	local int MaxPitchUp, MaxPitchDown;
	local rotator MainGunRot;
	local int PitchDiff, YawDiff;

	if (MyTankStug == None)
		return;

	// convert MainGunPitch to world space...
	WorldMainGunPitch = (MyTankStug.Rotation.Pitch + MyTankStug.MainGunPitch) & 65535;

	MainGunBoneLoc = MyTankStug.GetBoneCoords( MyTankStug.MainGunBoneName ).origin;
	RotToTarget = rotator(TargetAimLoc - MainGunBoneLoc);

	PitchRate = (MyTankStug.MainGunRotationSpeed * DeltaTime / 360.0) * 65536;

	WorldMainGunPitch = GetNewRotation(WorldMainGunPitch, RotToTarget.Pitch, int(PitchRate));

	PitchDiff = abs((WorldMainGunPitch & 65535) - (RotToTarget.Pitch & 65535));
	if (PitchDiff > 32768)
		PitchDiff = 65536 - PitchDiff;

	YawDiff = abs((MyTankStug.Rotation.Yaw & 65535) - (RotToTarget.Yaw & 65535));
	if (YawDiff > 32768)
		YawDiff = 65536 - YawDiff;

	bIsOnTarget = false;  // assume not on target until known otherwise
	bIsYawOnTarget = false;

	// is the gun aimed close enough to the target?
	if ((YawDiff < 800) && (PitchDiff < 600))
	{
		bIsOnTarget = true;  // gun is "on target", start shooting
	}

	if (YawDiff < 800)
	{
		bIsYawOnTarget = true;
	}

	// does the tank need to rotate to aim the main gun at the enemy?...
	if (YawDiff >= 800)
	{
		if (!MyTankStugController.bIsRotating)  // is the tank not currently rotating towards the target?
		{
			// request the tank to rotate towards the target...
			if (bUseMainGunTarget)
				MyTankStugController.RotateTowardTarget(MyTankStugController.MainGunTarget);
			else
				MyTankStugController.RotateTowardLocation(TargetAimLoc);
		}
	}

	// convert MainGunPitch back to local space...
	MyTankStug.MainGunPitch = (WorldMainGunPitch - MyTankStug.Rotation.Pitch) & 65535;

	MaxPitchUp = int((MyTankStug.MainGunUpwardFireArc / 360.0) * 65536.0);
	MaxPitchDown = int((MyTankStug.MainGunDownwardFireArc / 360.0) * 65536.0);

	if (MyTankStug.MainGunPitch > 32767)
		MyTankStug.MainGunPitch = MyTankStug.MainGunPitch - 65536;

	MyTankStug.MainGunPitch = Clamp(MyTankStug.MainGunPitch, -MaxPitchDown, MaxPitchUp);

	// for cases where gun has reached max pitch up/down, fire if yaw is on target and pitch is within 10 degrees of target...
	if ((YawDiff < 800) && ((MyTankStug.MainGunPitch == -MaxPitchDown) || (MyTankStug.MainGunPitch == MaxPitchUp)) &&
		(PitchDiff < 1820))
	{
		bIsOnTarget = true;  // gun is "on target", start shooting
	}

	MainGunRot.Pitch = 0;
	MainGunRot.Yaw = 0;
	MainGunRot.Roll = MyTankStug.MainGunPitch;

	MyTankStug.SetBoneRotation(MyTankStug.MainGunBoneName, MainGunRot, 0, 1.0);
}

function Rotator AdjustAimNewTankShell( Ammunition Ammo, Vector ProjStart, Rotator AimRotator, InstantFire MyInstantFire, optional out int bSkipDoTrace )
{
	local float DistToTarget;
	local int index;
	local bool bCheckNoDamage;

	// check if the enemy is not a tank...
	if ((Enemy != None) && (!Enemy.IsA('Tank')))
	{
		bCheckNoDamage = false; // assume false until known otherwise

		index = FindTargetInQueue( Enemy );

		// check if the enemy is a "hard" target (Pak36 gunner, Panzerfaust soldier, etc)...
		if ( (index >= 0) && (TargetQueue[index].bIsHardTarget == 1) )
			bCheckNoDamage = true;

		// check if the enemy is manning a machine gun...
		if ( !bCheckNoDamage && (gbxPawn(Enemy) != None) && (gbxPawn(Enemy).bIsManningTurret) )
			bCheckNoDamage = true;

		if (bCheckNoDamage)
		{
			DistToTarget = VSize( Enemy.Location - MyTank.Location );

			// Is this a deadlock situation?
			if ( DistToTarget > MainGunDoNoDamageRange )
			{
				MyTankStug.MainGunFireMode.bIgnoreDamageThisBullet = true;
			}
		}
	}

	return Super.AdjustAimNewTankShell(Ammo, ProjStart, AimRotator, MyInstantFire, bSkipDoTrace);
}

function FireMainGun(bool bDoNoDamage)
{
	local vector MainGunLoc;
	local rotator MainGunRot;
	local vector RotX, RotY, RotZ;
	local int AimErrorLocal;
	local rotator AdjustedAim;
	local int bSkipDoTrace;
	local gbxTankShell TankShell;

	if (!bDoNoDamage)
		MyTankStug.MainGunFireMode.bIgnoreDamageThisBullet = false;

	MainGunLoc = MyTankStug.GetTagCoords( MyTankStug.MainGunMuzzleBoneName ).origin;

	MainGunRot.Pitch = MyTankStug.MainGunPitch;
	MainGunRot.Yaw = 0;
	MainGunRot.Roll = 0;

	MainGunRot = MyTankStug.Rotation + MainGunRot;

    GetAxes(MainGunRot,RotX,RotY,RotZ);

	MainGunLoc = MainGunLoc + MyTankStug.MainGunEmitterOffset.X * RotX + MyTankStug.MainGunEmitterOffset.Y * RotY + MyTankStug.MainGunEmitterOffset.Z * RotZ;

	MainGunRot.Pitch = 0;  // ignore main gun pitch for main gun smoke and dust emitter
	MainGunRot.Yaw = 0;
	MainGunRot.Roll = 0;

	MainGunRot = MyTankStug.Rotation + MainGunRot;

	// spawn main gun smoke and dust emitter...
	spawn(MyTankStug.MainGunSmokeEmitterClass, None,, MainGunLoc, MainGunRot);

	AimErrorLocal = AimErrorAI;

	AdjustedAim = MyTankStug.AdjustAimMainGun();

	ApplyAccuracy( AdjustedAim, AimErrorLocal );

	AdjustedAim = AdjustAimNewTankShell(MyTankStug.MainGunAmmo, MainGunLoc, AdjustedAim, MyTankStug.MainGunFireMode, bSkipDoTrace);

	// spawn main gun muzzle flash emitter...
	spawn(MyTankStug.MainGunFlashEmitterClass, None,, MainGunLoc, AdjustedAim);

	if (MyTankStug.MainGunFireMode.bIgnoreDamageThisBullet)
	{
		Log(name $ ".FireMainGun - bIgnoreDamageThisBullet was True, doing no damage", 'Tank');
		bDoNoDamage = true;
	}

	TankShell = Spawn( class'gbxTankShell', MyTankStug,, MainGunLoc, AdjustedAim );
	TankShell.Instigator = MyTankStug;

	if (bDoNoDamage)
		TankShell.Damage = 0.0f;

	MyTankStug.PlaySoundCue( MyTankStug.MainGunFireSound, SLOT_NONE, TransientSoundVolume,,,,false);

	MyTankStug.PlayMainGunFiringAnim(0);
}


defaultproperties
{
	TimerInterval=0.2

	PeripheralVisionWithCommander=-0.0  // +/- 90 degrees (180 degrees total)
	PeripheralVisionWithoutCommander=0.2588  // +/- 75 degrees (150 degrees total)

	bIsOnTarget=false

	fResetMainGunTime=5.0  // if no enemy, start resetting the turret after 5.0 seconds
	fMainGunFireDelay=0.25  // how long to wait after main gun is "on target" before firing

	TargetPriorityScalarInfantryGroup=0.8

	bLogPriority=false

	AimErrorAI=400
	AimErrorAINormal=400
	AimErrorAIBefuddled=800

	ReactionTimeMin=4.0
	ReactionTimeMax=6.0
	ReactionTimeMinEasy=5.0
	ReactionTimeMaxEasy=7.0
	ReactionTimeMinNormal=4.0
	ReactionTimeMaxNormal=6.0
	ReactionTimeMinHard=3.0
	ReactionTimeMaxHard=4.0
	ReactionTimeMinAuthentic=2.0
	ReactionTimeMaxAuthentic=3.0

	PurposefulMissTimeStart=30.0
	PurposefulMissTimeBonus=5.0
	PurposefulMissTimeMax=45.0
	PurposefulMissTimeStartEasy=45.0
	PurposefulMissTimeBonusEasy=5.0
	PurposefulMissTimeMaxEasy=60.0
	PurposefulMissTimeStartNormal=30.0
	PurposefulMissTimeBonusNormal=5.0
	PurposefulMissTimeMaxNormal=45.0
	PurposefulMissTimeStartHard=20.0
	PurposefulMissTimeBonusHard=5.0
	PurposefulMissTimeMaxHard=30.0
	PurposefulMissTimeStartAuthentic=15.0
	PurposefulMissTimeBonusAuthentic=5.0
	PurposefulMissTimeMaxAuthentic=20.0

	TargetForgetTimeLong=10.0f
	TargetForgetTimeShort=10.0f
}
//=============================================================================
// Basic Unit AI Controller.  Handles all squad-level AI behavior, which mainly 
// includes the behavior necessary to carry out squad commands (move/target/assault).
// This class is subclassed by UnitControllerAIInfantry and UnitControllerAITank
// to handle infantry fire teams and tank fire teams, respectively.
//
// Gearbox Software.
//=============================================================================
class UnitControllerAI extends UnitController
	notplaceable
	native;


//---------------------------------------------------------
//	Variables / Constants
//---------------------------------------------------------

struct native GrenadeReportEntry
{
	var gbxPawn		Member;
	var bool		bReported;
	var bool		bIsThrowing;
	var bool		bGrenadeExploded;
};

var array<GrenadeReportEntry> GrenadeReports;

var() float	KnownEnemyUnitsTimeout;	// Number of seconds that must elapse before an enemy unit is 'forgotten'
var() float	KnownEnemyUnitsRefreshInterval; // Number of seconds that must elapse before the KnownEnemyUnits list is cleaned
var   float	NextKnownEnemyUnitsRefresh;

var float TimerInterval;

var float SuppressionLevelAnalog;
var float SuppressionDecayGray_Novice;
var float SuppressionDecayGray_Interm;
var float SuppressionDecayGray_Advanced;
var float SuppressionDecayGray_Veteran;
	
var float SuppressionDecayRed_Novice;
var float SuppressionDecayRed_Interm;
var float SuppressionDecayRed_Advanced;
var float SuppressionDecayRed_Veteran;

var float SuppressionMag_Novice;
var float SuppressionMag_Interm;
var float SuppressionMag_Advanced;
var float SuppressionMag_Veteran;

var() float IconLerpAlpha;
var() float HoverHeight;

var /*const*/ float PlayerShotSuppressionScalar; // Multiplayer wants to tweak these variables so they can't be consts... 2004-06-02 JWS
var /*const*/ float AIShotSuppressionScalar;

var bool	bNoImpactSup, bNoWhizSup;	// GBX:naj - debug variables to disable see-impact suppression and bullet-whiz-by-suppression.

struct native MoveOutMemberData
{
	var gbxPawn Member;
	var float   Distance;
};

var   transient array< MoveOutMemberData > MoveOutSequence;	// The Members re-ordered in sequence of closeness to new FORMC when moving out.

var() float OverallSuppressionScalarPlayer; // Multiplayer wants to tweak player and AI overall independently. 2004-06-02 JWS
var() float OverallSuppressionScalarAI;
var() float SuppressionSeeAllyHit;
var() float SuppressionSeeAllyKilled;
var() float SuppressionSeeImpact;
var() float SuppressionNearbyTrace;
var   float UnsuppressedStartTime;		// The time at which this unit stopped being suppressed at all.

var bool	bAssaultThisTarget;
var bool	bWaitForTimer;
var() float SufficientPursuitVantageRatio;
var() float InsufficientPursuitVantageRatio;

var	float	OpBurstDuration;
var float	TargetOrderOpBurstDuration;
var	float	StopFreeOpBurstTime;

var float MaxImpactDistance;


// State "local" variables
var int iCount;


native function BuildFormationNavPointCache(int NumMembersInRadius);
native function ExpandFormationNavPointCache();
native function int FormationDirection(ActorLite FormationCenter);


//---------------------------------------------------------
//	PostBeginPlay
//---------------------------------------------------------
simulated function PostBeginPlay()
{
	Super.PostBeginPlay();

	// Stagger the KnownEnemyUnitsRefresh calls
	NextKnownEnemyUnitsRefresh = Level.TimeSeconds + FRand() * KnownEnemyUnitsRefreshInterval;

	// Start timer.
	SetTimer( TimerInterval, true );
}

//---------------------------------------------------------
//	NotifyFormationCenterChange
//---------------------------------------------------------
function NotifyFormationCenterChange(int NumMembersInRadius)
{
	if( MyUnit != None && MyUnit.FormationCenter != None )
	{
		// clear out the FormationPath array (remove all elements)...
		MyUnit.FormationPath.Remove( 0, MyUnit.FormationPath.Length );

		BuildFormationNavPointCache(NumMembersInRadius);
	}

	//GotoState( 'MovingOut' );
}

//---------------------------------------------------------
//	NotifyFormationRadiusIncreased
//---------------------------------------------------------
function NotifyFormationRadiusIncreased()
{
	LogSelective( "NotifyFormationRadiusIncreased()." );

	if( MyUnit != None && MyUnit.FormationCenter != None )
	{
		// clear out the FormationPath array (remove all elements)...
		MyUnit.FormationPath.Remove( 0, MyUnit.FormationPath.Length );

		ExpandFormationNavPointCache();
	}
}

//---------------------------------------------------------
//	NotifyTeammatesOfTarget
//---------------------------------------------------------
function NotifyTeammatesOfTarget( gbxPawn Sender, gbxPawn Target )
{
	local int nMembers, i;

	nMembers = MyUnit.NumMembers;
	for( i = 0; i < nMembers; ++i )
	{
		if ( MyUnit.Members[ i ] != Sender && MyUnit.Members[ i ].Controller.IsA('Mind') )
			Mind( MyUnit.Members[ i ].Controller ).NotifyTeammateShootingAtTarget( Sender, Target );
	}
}

function UpdateToSuperUnitFormationCenterIfNecessary()
{
	local int FormationDir;

	if (MyUnit.SuperUnit != None &&
		MyUnit.IsAttachedToSuperUnit() &&
		MyUnit.FormationCenter != MyUnit.SuperUnit.FormationCenter)
	{
		FormationDir = FormationDirection( MyUnit.SuperUnit.FormationCenter );
		MyUnit.SetFormationDirection(FormationDir);
		MyUnit.SetFormationCenter( MyUnit.SuperUnit.FormationCenter );
	}
}


//---------------------------------------------------------
//	Timer
//---------------------------------------------------------
simulated function Timer()
{
	Super.Timer();

	if( bDeleteMe || MyUnit == None )
	{
		return;
	}

	MyUnit.CalculateUnitCentroid();

	UpdatePursuit();

	if(TimerRate != TimerInterval)
		SetTimer( TimerInterval, true );
}

//---------------------------------------------------------
//	Tick
//---------------------------------------------------------
simulated function Tick( float DeltaTime )
{
	local Vector loc, unitCentroid;

	if( bDeleteMe || MyUnit == None )
	{
		return;
	}

	UpdateMoveOrderQueue();


	if( (MyUnit.NumMembers == 0) && (MyUnit.NumSubUnits == 0) && (MyUnit.MyInWorldIcon != None) )
	{
		// This unit is inert. Just make sure the icon is hidden and do nothing else.
		MyUnit.MyInWorldIcon.Hide();
		return;
	}

	// Update AssignedTargetUnit
	if( MyUnit.AssignedTargetUnit != None && !MyUnit.AssignedTargetUnit.AnyLivingMembers() )
	{
		// Dis-assign this dead unit.
		MyUnit.SetTargetUnit( None );
	}

	Super.Tick( DeltaTime );

	TickSuppression( DeltaTime ); //SDJ 05/27/2004: Moved this to it's own, not simulated function.

	// Update the unit's in-world icon.

	if( MyUnit.MyInWorldIcon != None && MyUnit.MyInWorldIcon.IsShown() )
	{
		MyUnit.CalculateUnitCentroid();
		unitCentroid = MyUnit.GetUnitCentroid() + vect( 0, 0, 1 ) * HoverHeight;

		loc = MyUnit.MyInWorldIcon.Location;

		loc.X = Lerp( IconLerpAlpha, loc.X, unitCentroid.X );
		loc.Y = Lerp( IconLerpAlpha, loc.Y, unitCentroid.Y );
		loc.Z = Lerp( IconLerpAlpha, loc.Z, unitCentroid.Z );

		MyUnit.MyInWorldIcon.SetLocation( loc );

		// Change suppression indicator.		
		TickSuppressionIndicator(); //SDJ 05/27/2004: Moved this to it's own, not simulated function.
	}
	else
	{
		//SDJ 05/27/2004: The server needs to tick the indicator whether its shown or not so appropriate values can be replicated.
		if (((Level.NetMode == NM_DedicatedServer) || (Level.NetMode == NM_ListenServer)) && (Level.Game.GameReplicationInfo.GameType == GT_SKIRMISH))
		{
			TickSuppressionIndicator();
		}
	}

	/// Update the unit's location, if we're attached to our SuperUnit
	UpdateToSuperUnitFormationCenterIfNecessary();

	// Refresh the KnownEnemyUnits list
	if( NextKnownEnemyUnitsRefresh < Level.TimeSeconds )
	{
		RefreshKnownEnemyUnits();
		NextKnownEnemyUnitsRefresh = Level.TimeSeconds + KnownEnemyUnitsRefreshInterval;
	}
}

function TickSuppression( float DeltaTime )
{
	local float OldSuppressionLevel, suppressionDecay;
	local int nMembers, i;
	
	suppressionDecay = GetSuppressionDecayRate();

	// Decay suppression.

	OldSuppressionLevel = SuppressionLevelAnalog;

	SuppressionLevelAnalog -= suppressionDecay * DeltaTime;
	SuppressionLevelAnalog = FClamp( SuppressionLevelAnalog, 0, 2 );

	// GBX:naj - Check if we've become unsuppressed this tick.
	if ( OldSuppressionLevel >= 1.0 && SuppressionLevelAnalog < 1.0 )
	{
		SuppressionLevelAnalog = 0.0;

		// Rally members.
		nMembers = MyUnit.NumMembers;
		for( i = 0; i < nMembers; ++i )
		{
			if (MyUnit.Members[ i ].Controller.IsA('Mind'))
				Mind( MyUnit.Members[ i ].Controller ).NotifyRally();
		}
	}

	if ( OldSuppressionLevel > 0 && SuppressionLevelAnalog < 0.0001 )
	{
		// We have gone from some suppression to none.
		UnsuppressedStartTime = Level.TimeSeconds;
	}		
}

function TickSuppressionIndicator()
{
	if ( GetSuppressionLevelAnalog() >= 1.0 )
	{
		MyUnit.MyInWorldIcon.ClockPercentage = GetSuppressionLevelAnalog() * 100.0 - 100.0;
		MyUnit.MyInWorldIcon.SetSuppressed( true );
	}
	else
	{
		MyUnit.MyInWorldIcon.ClockPercentage = GetSuppressionLevelAnalog() * 100.0;
		MyUnit.MyInWorldIcon.SetSuppressed( false );
		MyUnit.MyInWorldIcon.ClockPercentage = FClamp( MyUnit.MyInWorldIcon.ClockPercentage, 0.0, 100.0 );
	}		
	
	if (int(MyUnit.MyInWorldIcon.ClockPercentage) != MyUnit.MyInWorldIcon.ReplicatedClockPercentage)
	{
		MyUnit.MyInWorldIcon.ReplicatedClockPercentage = MyUnit.MyInWorldIcon.ClockPercentage;
	}
}

//---------------------------------------------------------
//	GetSuppressionDecayRate
//---------------------------------------------------------
function float GetSuppressionDecayRate()
{
	//Log( " UnitControllerAI::GetSuppressionDecayRate() MyUnit.Leader.PawnTeam="$MyUnit.Leader.PawnTeam$ " MyUnit.BaseSkillLevel="$MyUnit.BaseSkillLevel, 'MP' );

	// Use different decay rate for suppression < 1.0 vs. > 1.0.
	// Also, more highly skilled units have faster decay rates.
	if ( SuppressionLevelAnalog < 1.0 )
	{
		switch( MyUnit.BaseSkillLevel )
		{
			case SKILL_Novice:
				return SuppressionDecayRed_Novice;
			case SKILL_Intermediate:
				return SuppressionDecayRed_Interm;
			case SKILL_Advanced:
				return SuppressionDecayRed_Advanced;
			case SKILL_Veteran:
			case SKILL_Invincible:	// Actually, invincible units shouldn't even get suppressed!
				return SuppressionDecayRed_Veteran;			
		}
	}
	else
	{
		switch( MyUnit.BaseSkillLevel )
		{
			case SKILL_Novice:
				return SuppressionDecayGray_Novice;
			case SKILL_Intermediate:
				return SuppressionDecayGray_Interm;
			case SKILL_Advanced:
				return SuppressionDecayGray_Advanced;
			case SKILL_Veteran:
			case SKILL_Invincible:	// Actually, invincible units shouldn't even get suppressed!
				return SuppressionDecayGray_Veteran;
		}	
	}
}

//---------------------------------------------------------
//	GetUnsuppressionDuration
//---------------------------------------------------------
function float GetUnsuppressionDuration()
{
	if( GetSuppressionLevelAnalog() > 0 )
	{
		return 0.0;
	}
	else
	{
		return Level.TimeSeconds - UnsuppressedStartTime;
	}
}

//---------------------------------------------------------
//	UnitMemberUpdatedTarget
//---------------------------------------------------------
simulated function UnitMemberUpdatedTarget( gbxPawn NewTarget )
{
	local int i;
	local bool RefreshedUnit;
	local KnownEnemyUnitEntry NewEntry;

	if( NewTarget.MyUnit != None )
	{
		for( i = 0; i < KnownEnemyUnits.Length; ++i )
		{
			// Refresh the timestamp if we already know about this unit
			if( NewTarget.MyUnit == KnownEnemyUnits[i].EnemyUnit )
			{
				KnownEnemyUnits[i].TimeStamp = Level.TimeSeconds;
				RefreshedUnit = true;
			}
		}

		// Add this pawn's unit if it wasn't refreshed
		if( !RefreshedUnit )
		{
			NewEntry.EnemyUnit = NewTarget.MyUnit;
			NewEntry.TimeStamp = Level.TimeSeconds;

			KnownEnemyUnits.Length = KnownEnemyUnits.Length + 1;
			KnownEnemyUnits[ KnownEnemyUnits.Length - 1 ] = NewEntry;
		}

		// If we have a SuperUnit, send it the same notification
		if( MyUnit.SuperUnit != None )
			MyUnit.SuperUnit.MyUnitController.UnitMemberUpdatedTarget( NewTarget );
	}
}

//---------------------------------------------------------
//	RefreshKnownEnemyUnits
//---------------------------------------------------------
simulated function RefreshKnownEnemyUnits()
{
	local int i;

	for( i = 0; i < KnownEnemyUnits.Length; ++i )
	{
		if( (Level.TimeSeconds - KnownEnemyUnits[i].TimeStamp) > KnownEnemyUnitsTimeout || !KnownEnemyUnits[i].EnemyUnit.AnyLivingMembers() )
		{
			// Remove this index
			KnownEnemyUnits.Remove( i, 1 );

			// Restart the function
			RefreshKnownEnemyUnits();

			// Break after the recursive call returns so we don't try to access the stale array
			break;
		}
	}
}

//---------------------------------------------------------
//	NotifyMemberAdded
//---------------------------------------------------------
function NotifyMemberAdded( gbxPawn newMember )
{
	if (newMember.Controller.IsA('Mind'))
	{
		if( Mind( newMember.Controller ) != None )
		{
			Mind( newMember.Controller ).NotifyFormationCenterChange();
		}
	}

	// update the size of the FormationCenterCache to include size for new member...
	NotifyFormationCenterChange(MyUnit.NumMembers);
}

//---------------------------------------------------------
//	IsUnitKnown
//---------------------------------------------------------
simulated function bool IsUnitKnown( Unit TestUnit )
{
	local int i;

	for( i = 0; i < KnownEnemyUnits.Length; ++i )
	{
		if( KnownEnemyUnits[i].EnemyUnit == TestUnit )
		{
			return true;
		}
	}

	return false;
}

//---------------------------------------------------------
//	IsUnitTargettedByAlly
//---------------------------------------------------------
function bool IsUnitTargettedByAlly( Unit TestUnit )
{
	local Unit aUnit;
	local int ndx;

	// Am I targetting this unit?
	if( MyUnit.AssignedTargetUnit == TestUnit )
	{
		return true;
	}

	// If I haven't built my ally catch yet, build it.
	if ( !MyUnit.bKnowsAllies )
	{
		MyUnit.FindAlliedUnits();
	}

	// Iterate over our allied units, checking if any have TestUnit targetted.
	for( ndx = 0; ndx < MyUnit.AlliedUnits.Length; ++ndx )
	{
		aUnit = MyUnit.AlliedUnits[ ndx ];
		if ( aUnit.AssignedTargetUnit == TestUnit )
		{
			return true;
		}
	}

	return false;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// COMMAND ////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//---------------------------------------------------------
//	BreakRelaxation
//---------------------------------------------------------
/*
function BreakRelaxation()
{
	local int i, nMembers;

	nMembers = MyUnit.NumMembers;
	for( i=0; i < nMembers; ++i )
	{
		if (MyUnit.Members[ i ].Controller.IsA('Mind'))
			Mind( MyUnit.Members[ i ].Controller ).BreakRelaxation();
	}
}
*/

//---------------------------------------------------------
//	ExecuteMove
//---------------------------------------------------------
function ExecuteMove( ActorLite FORMC )
{
	local int FormationDir;	

	LogSelective( "ExecuteMove: FORMC="$FORMC );

	if( FORMC == None )
	{
		return;
	}

	StopAssault();

	MyUnit.SetTargetUnit( None );
	FormationDir = FormationDirection( FORMC );
	MyUnit.SetFormationDirection(FormationDir);
	MyUnit.SetFormationCenter( FORMC );

	/*
	if ( MyUnit.SuperUnit != None )
		MyUnit.SuperUnit.NotifyBreakRelaxation();
	*/
}

//---------------------------------------------------------
//	NotifyMemberDoingOpBurst
//---------------------------------------------------------
function NotifyMemberDoingOpBurst( gbxPawn aMember )
{
	local int i, nMembers;
	
	// Singleplayer: No op-bursts if suppressed.
	if ( ( !Level.UseMPStyleFatigue() ) && GetSuppressionLevel() == SL_SUPPRESSED )
	{
		StopFreeOpBurstTime = 0.0f;
		return;
	}

	StopFreeOpBurstTime = Level.TimeSeconds + OpBurstDuration;

	nMembers = MyUnit.NumMembers;
	for( i = 0; i < nMembers; ++i )
	{
		if ( MyUnit.Members[i] != aMember && MyUnit.Members[ i ].Controller.IsA('Mind'))
		{
			Mind( MyUnit.Members[ i ].Controller ).NotifyDoingOpBurst();
		}
	}
}

//---------------------------------------------------------
//	HasFreeOpBurst
//---------------------------------------------------------
function bool HasFreeOpBurst() 
{ 
	// Singleplayer: No op-bursts if suppressed.
	if ( ( !Level.UseMPStyleFatigue() ) && GetSuppressionLevel() == SL_SUPPRESSED )
		StopFreeOpBurstTime = 0.0f;

	return ( Level.TimeSeconds < StopFreeOpBurstTime );
}

//---------------------------------------------------------
//	OrderMove
//---------------------------------------------------------
function OrderMove( ActorLite FORMC, optional bool bAddToQueue )
{
	AverageSuppressionDir = Vect(0,0,0);
	Super.OrderMove( FORMC, bAddToQueue );
	StopFreeOpBurstTime = 0.0;
}

//---------------------------------------------------------
//	OrderTarget
//---------------------------------------------------------
function OrderTarget( Unit targetUnit )
{
	local int i, nMembers;
	local Mind aMind;
	local TankController TC;

	LogSelective( "OrderTarget." );

	StopAssault();

	MyUnit.DetachFromSuperUnit();			// OrderTarget implies Fall Out.
	MyUnit.SetTargetUnit( targetUnit );

	StopFreeOpBurstTime = Level.TimeSeconds + TargetOrderOpBurstDuration;

	// notify all the members of this Unit that a TargetOrder has been issued...
	nMembers = MyUnit.NumMembers;
	for( i = 0; i < nMembers; ++i )
	{
		if (MyUnit.Members[ i ].Controller.IsA('Mind'))
		{
			aMind = Mind( MyUnit.Members[ i ].Controller );
			aMind.NotifyTargetOrder( targetUnit );
			aMind.NotifyDoingOpBurst();
		}
		else if (MyUnit.Members[ i ].Controller.IsA('TankController'))
		{
			TC = TankController( MyUnit.Members[ i ].Controller );
			TC.NotifyTargetOrder( targetUnit );
		}
	}

	UpdatePursuit();
}

//---------------------------------------------------------
//	OrderAssault
//---------------------------------------------------------
function OrderAssault( Unit targetUnit )
{
	local int i, nMembers;
	local Mind aMind;
	local TankController TC;

	LogSelective( "OrderAssault." );

	MyUnit.DetachFromSuperUnit();			// OrderTarget implies Fall Out.
	MyUnit.SetTargetUnit( targetUnit );

	// notify all the members of this Unit that am AssaultOrder has been issued...
	nMembers = MyUnit.NumMembers;
	for( i = 0; i < nMembers; ++i )
	{
		if (MyUnit.Members[ i ].Controller.IsA('Mind'))
		{
			aMind = Mind( MyUnit.Members[ i ].Controller );
			aMind.NotifyAssaultOrder( targetUnit );
		}
		else if (MyUnit.Members[ i ].Controller.IsA('TankController'))
		{
			TC = TankController( MyUnit.Members[ i ].Controller );
			TC.NotifyAssaultOrder( targetUnit );
		}
	}
}

//---------------------------------------------------------
//	DebugFinishAssault
//---------------------------------------------------------
// Debug; remove when Assault logic is complete.
function DebugFinishAssault()
{
	LogSelective( "DebugFinishAssault." );

	if ( MyUnit.AssignedTargetUnit != None ) 
	{
		bAssaultThisTarget = true;
		UpdatePursuit();
	}
}

//---------------------------------------------------------
//	OrderFallIn
//---------------------------------------------------------
function OrderFallIn()
{
	StopAssault();

	//bAllowPursuit = false;
	MyUnit.SetTargetUnit( None );
	MyUnit.AttachToSuperUnit();	

	/*
	if ( MyUnit.SuperUnit != None )
		MyUnit.SuperUnit.NotifyBreakRelaxation();
	*/
}

//---------------------------------------------------------
//	OrderAllFallIn
//---------------------------------------------------------
function OrderAllFallIn()
{
	StopAssault();

	//bAllowPursuit = false;
	MyUnit.SetTargetUnit( None );
	MyUnit.AttachAllSubUnits();

	/*
	if ( MyUnit.SuperUnit != None )
		MyUnit.SuperUnit.NotifyBreakRelaxation();
	*/
}

//---------------------------------------------------------
//	OrderManTurret
//---------------------------------------------------------
function OrderManTurret( TurretWeapon Turret )
{
	// TBD: Find the closest pawn to the turret and force him to claim the turret.  
	// Give everyone else in the unit a new FORMC around the turret.

	// If the turret has magically been claimed by someone else, check if that someone is an enemy.
	// If so, target the enemy.  If that someone else is a friendly squad, simply ignore the order.


	// TEMP
	OrderMove( Turret.GetMountPoint() );
}

//---------------------------------------------------------
//	StopAssault
//---------------------------------------------------------
function StopAssault()
{
	local int i, nMembers;

	bAssaultThisTarget = false;

	nMembers = MyUnit.NumMembers;
	for( i = 0; i < nMembers; ++i )
	{
		if (MyUnit.Members[ i ].Controller.IsA('Mind'))
		{
			if (Mind( MyUnit.Members[ i ].Controller ) != None)
				Mind( MyUnit.Members[ i ].Controller ).StopAssault();
		}
	}	
}

//---------------------------------------------------------
//	NotifyStoppingAssault
//---------------------------------------------------------
// Called by Mind
function NotifyStoppingAssault()
{
	bAssaultThisTarget = false;	// Don't need to tell the Minds about it, because they've figured it out for themselves.
}

//---------------------------------------------------------
//	WantsToAssault
//---------------------------------------------------------
function bool WantsToAssault()
{
	if ( bAssaultThisTarget )
	{
		if ( MyUnit.AssignedTargetUnit == None || MyUnit.AssignedTargetUnit.GetNumLivingMembers() == 0 )
		{
			bAssaultThisTarget = false;
		}
	}

	return bAssaultThisTarget;
}

//---------------------------------------------------------
//	WantsToTarget
//---------------------------------------------------------
function bool WantsToTarget()
{
	return MyUnit != None && MyUnit.AssignedTargetUnit != None;
}

//---------------------------------------------------------
//	GetAssaultDestination
//---------------------------------------------------------
function ActorLite GetAssaultDestination()
{
	// Assault destination is always the target unit's formation center.
	if( MyUnit.AssignedTargetUnit != None )
	{
		LogSelective( "GetAssaultDestination: New FORMC will the Assigned Target Unit's FORMC: "$MyUnit.AssignedTargetUnit.FormationCenter );
		return MyUnit.AssignedTargetUnit.FormationCenter;
	}
	else
	{
		LogSelective( "GetAssaultDestination: No more Assigned target unit.  Returning None." );
		return None;
	}
}

//---------------------------------------------------------
//	UpdatePursuit
//---------------------------------------------------------
function UpdatePursuit()
{
	if ( WantsToAssault() )
	{
		// Assault the pursued unit.
		MyUnit.SetFormationCenter( GetAssaultDestination() );
	}
	else if ( WantsToTarget() )
	{
		// TBD
	}	
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SUPPRESSION ////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//---------------------------------------------------------
//	ReceiveMemberMessage
//---------------------------------------------------------
function bool ReceiveMemberMessage( gbxMessage msg, float distanceMessageFromMember )
{	
	HandleMemberMessage( msg, distanceMessageFromMember );
	return false;
}

//---------------------------------------------------------
//	HandleMemberMessage
//---------------------------------------------------------
function HandleMemberMessage( gbxMessage msg, float distanceMessageFromMember )
{
	if( msg.IsA( 'Perception' ))
	{
		Perception( msg ).AffectUnit( MyUnit, distanceMessageFromMember );
	}
}

//---------------------------------------------------------
//	MemberSawImpact
//---------------------------------------------------------
function MemberSawImpact( Pawn instigator, float impactDistance, float impactSeverity )
{
	local float PlayerMultiplier;
	local float SkillMultiplier, WeapMultiplier;
	//Log( self$ " UnitControllerAI::MemberSawImpact() instigator="$instigator$" SuppressionSeeImpact="$SuppressionSeeImpact$"MyUnit.GetBoldnessModifier()="$MyUnit.GetBoldnessModifier(), 'MP' );

	if (instigator == None)
		return;

	// Human players suppress slightly better than AI pawns.
	if ( instigator.IsHumanControlled() )
		PlayerMultiplier = PlayerShotSuppressionScalar;
	else
		PlayerMultiplier = AIShotSuppressionScalar; // Multiplayer wants to tweak player and AI overall independently. 2004-06-02 JWS

	//Log( self$ " UnitControllerAI::MemberSawImpact() PlayerMultiplier="$PlayerMultiplier, 'MP' );

	if( !MyUnit.SameTeamAs( instigator ))
	{
		if (( !bNoImpactSup ) )
		{
			if ( gbxWeapon(instigator.Weapon) != None )
				WeapMultiplier = gbxWeapon( instigator.Weapon ).GetSuppressionMultiplier();
			else
				WeapMultiplier = 1.0;

			//Log( self$ " UnitControllerAI::MemberSawImpact() WeapMultiplier="$WeapMultiplier, 'MP' );
				
			if ( WargamePawn(instigator) != None )
				SkillMultiplier = GetSkillMultiplier( WargamePawn( instigator ) );
			else
				SkillMultiplier = 1.0;

			//Log( self$ " UnitControllerAI::MemberSawImpact() SkillMultiplier="$SkillMultiplier, 'MP' );

		AddSuppression(
			instigator,
			1.0 //1.0 - FClamp( impactDistance / class'PerceptionImpact'.default.BroadcastRadius, 0.0, 1.0 ))
			* SuppressionSeeImpact
			* PlayerMultiplier
			* SkillMultiplier 
			* WeapMultiplier 
			* MyUnit.GetBoldnessModifier() );
		}

		if ((instigator.Controller != None) && (instigator.Controller.bIsHumanPlayer))
		{
			Level.NumShotsSuppression += 1;
		}
		else if (Level.Game.IsPawnOnSameTeamAsPlayer(instigator))
		{
			Level.NumAIShotsSuppression += 1;
		}
	}
}


//---------------------------------------------------------
//	MemberSawNearbyBullet
//---------------------------------------------------------
function MemberSawNearbyBullet( Pawn instigator, float missDistanceRelative )
{
	local float PlayerMultiplier;
	local float SkillMultiplier, WeapMultiplier;
	//Log( " UnitControllerAI::MemberSawNearbyBullet()", 'MP' );

	//Log( self$ " UnitControllerAI::MemberSawNearbyBullet() instigator="$instigator$" SuppressionNearbyTrace="$SuppressionNearbyTrace$"MyUnit.GetBoldnessModifier()="$MyUnit.GetBoldnessModifier(), 'MP' );

	if (instigator == None)
		return;

	// Human players suppress slightly better than AI pawns.
	if ( instigator.IsHumanControlled() )
		PlayerMultiplier = PlayerShotSuppressionScalar;
	else
		PlayerMultiplier = 1.0;

	//Log( self$ " UnitControllerAI::MemberSawNearbyBullet() PlayerMultiplier="$PlayerMultiplier, 'MP' );

	if( !MyUnit.SameTeamAs( instigator ))
	{
		// TODO might be reported by multiple members.

		// Get nervous about bullets zipping past.
				
		// GBX:naj - Take weapon strengths into account.
		if ( !bNoWhizSup )
		{
			if ( gbxWeapon(instigator.Weapon) != None )
				WeapMultiplier = gbxWeapon( instigator.Weapon ).GetSuppressionMultiplier();
			else
				WeapMultiplier = 1.0;
	
			//Log( self$ " UnitControllerAI::MemberSawNearbyBullet() WeapMultiplier="$WeapMultiplier, 'MP' );

			if ( WargamePawn(instigator) != None )
				SkillMultiplier = GetSkillMultiplier( WargamePawn( instigator ) );
			else
				SkillMultiplier = 1.0;

			//Log( self$ " UnitControllerAI::MemberSawNearbyBullet() SkillMultiplier="$SkillMultiplier, 'MP' );

			AddSuppression( instigator, 
				SuppressionNearbyTrace 
				* WeapMultiplier
				* PlayerMultiplier
				* SkillMultiplier
				* MyUnit.GetBoldnessModifier() 
				//* (1.0 - missDistanceRelative)
				);

			if ((instigator.Controller != None) && (instigator.Controller.bIsHumanPlayer))
			{
				Level.NumShotsSuppression += 1;
			}
			else if (Level.Game.IsPawnOnSameTeamAsPlayer(instigator))
			{
				Level.NumAIShotsSuppression += 1;
			}
		}
	}
}

//---------------------------------------------------------
//	MemberSurprisedByAttacker
//---------------------------------------------------------
event MemberSurprisedByAttacker( gbxPawn instigator, gbxPawn Notifier )
{
	local int nMembers, i;

	// Tell every Mind to set their LastContactTime for this pawn to now.
	nMembers = MyUnit.NumMembers;
	for( i = 0; i < nMembers; ++i )
	{
		if (MyUnit.Members[ i ].Controller.IsA('Mind'))
			Mind( MyUnit.Members[ i ].Controller ).NotifySurpriseAttack( instigator, Notifier );
	}
}

//---------------------------------------------------------
//	GetSkillMultiplier
//---------------------------------------------------------
function float GetSkillMultiplier( WargamePawn Opponent )
{
	local int SkillDiff;

	// Human attackers always do full suppression.  No more, no less.
	if ( Opponent.IsHumanControlled() )
	{
		return 1.0;
	}

	// Get the skill levels of the two units.  Reward an advantage in skill
	// with a larger multiplier.  Equally skilled units see no bonus on either side.
	if ( Opponent != None )
	{
		if ( MyUnit.BaseSkillLevel != Opponent.MyUnit.BaseSkillLevel )
		{
			SkillDiff = Opponent.MyUnit.BaseSkillLevel - MyUnit.BaseSkillLevel;
			switch( SkillDiff )
			{
				case 4:
					return SuppressionMag_Novice;
				case 3:
					return SuppressionMag_Interm;
				case 2:
					return SuppressionMag_Advanced;
				case 1:
					return SuppressionMag_Veteran;
				default:
					return 1.0;				
			}
		}
	}

	return 1.0;
}

//---------------------------------------------------------
//	MemberSawPawnHit
//---------------------------------------------------------
function MemberSawPawnHit( Pawn PawnHit )
{
	//Log( self$ " UnitControllerAI::MemberSawPawnHit() PawnHit="$PawnHit$" SuppressionSeeAllyHit="$SuppressionSeeAllyHit$"MyUnit.GetBoldnessModifier()="$MyUnit.GetBoldnessModifier(), 'MP' );

	if( MyUnit.SameTeamAs( PawnHit ))
	{
		AddSuppression( None, SuppressionSeeAllyHit * MyUnit.GetBoldnessModifier() );
	}
}

//---------------------------------------------------------
//	MemberSawPawnDie
//---------------------------------------------------------
function MemberSawPawnDie( Pawn PawnDied )
{
	//Log( self$ " UnitControllerAI::MemberSawPawnDie() PawnDied="$PawnDied$" SuppressionSeeAllyKilled="$SuppressionSeeAllyKilled$"MyUnit.GetBoldnessModifier()="$MyUnit.GetBoldnessModifier(), 'MP' );

	if( MyUnit.SameTeamAs( PawnDied ))
	{
		// A friend died.
		AddSuppression( None, SuppressionSeeAllyKilled * MyUnit.GetBoldnessModifier() );
	}
}

//---------------------------------------------------------
//	AddSuppression
//---------------------------------------------------------
function AddSuppression( Pawn suppressionInstigator, float Amount )
{
	local float OldSuppression;
	local int nMembers, i;
	local bool humanInstigator;
	local Vector VectToInstigator;
	//Log( self$" UnitControllerAI::AddSuppression() MyUnit.NumMembers="$MyUnit.NumMembers$" MyUnit.BaseSkillLevel="$MyUnit.BaseSkillLevel, 'MP' );

	if( Amount > 0 && MyUnit.NumMembers > 0 && MyUnit.BaseSkillLevel != SKILL_Invincible )
	{
		if( suppressionInstigator != None && suppressionInstigator.IsHumanControlled() )
		{
			humanInstigator = true;
		}
		else
		{
			humanInstigator = false;
		}

		//Log( self$" UnitControllerAI::AddSuppression() humanInstigator="$humanInstigator$ " RawAmount="$Amount, 'MP' );

		if (humanInstigator)
		{
			Amount *= OverallSuppressionScalarPlayer;
		}
		else
		{
			Amount *= OverallSuppressionScalarAI;
		}

		// Suppression is reduced according to the number of members in this unit.
		Amount /= MyUnit.NumMembers;

		//Log( self$" UnitControllerAI::AddSuppression() humanInstigator="$humanInstigator$ " FinalAmount="$Amount, 'MP' );

		OldSuppression = SuppressionLevelAnalog;
		SuppressionLevelAnalog += Amount;


		if ( MyUnit.FormationCenter != None && suppressionInstigator != None )
		{
			VectToInstigator = suppressionInstigator.Location - GetLocation( MyUnit.FormationCenter );
			if ( AverageSuppressionDir.X < 0.0000001f && AverageSuppressionDir.Y < 0.0000001f && AverageSuppressionDir.Z < 0.0000001f )
				AverageSuppressionDir = VectToInstigator;
			else
				AverageSuppressionDir += ( Amount * SuppressionSway * ( VectToInstigator - AverageSuppressionDir ) );
		}
		SuppressionLevelAnalog = FClamp( SuppressionLevelAnalog, 0, 2 );

		// If this is the/a player, flash the indicator.
		if( humanInstigator && MyUnit.MyInWorldIcon != None)
		{
			MyUnit.MyInWorldIcon.FlashPlayerSuppression( Amount );
		}

		// Add this corresponding amount of suppression as fatigue to the AI so that you can "disorient" them by suppressing
		// fire.
		nMembers = MyUnit.NumMembers;
		for( i = 0; i < nMembers; ++i )
		{
			if (MyUnit.Members[ i ].Controller.IsA('Mind') && ( !Level.UseMPStyleFatigue() ) )
			{
				Mind( MyUnit.Members[ i ].Controller ).JogFatigue( WargamePawn( MyUnit.Members[ i ] ).FatigueJog_Suppression );
			}
		}
			
		// GBX:naj - If the unit has just now become suppressed, push their suppression level all the way to 200%.
		if ( OldSuppression < 1.0 && SuppressionLevelAnalog >= 1.0 )
		{
			SuppressionLevelAnalog = 2.0;
			
			// Notify members of suppression.
			nMembers = MyUnit.NumMembers;
			for( i = 0; i < nMembers; ++i )
			{
				if (MyUnit.Members[ i ].Controller.IsA('Mind'))
					Mind( MyUnit.Members[ i ].Controller ).NotifySuppressed();
			}
		}		
	}
}

//---------------------------------------------------------
//	PawnIsOnUnitFlank
//---------------------------------------------------------
function bool PawnIsOnUnitFlank( gbxPawn ThePawn ) 
{ 
	local Vector ToPawn;

	if ( MyUnit.FormationCenter != None && VSizeSquared( AverageSuppressionDir ) > 0.000001f )
	{
		ToPawn = Normal( ThePawn.Location - GetLocation( MyUnit.FormationCenter ) );
		return ( ToPawn dot Normal( AverageSuppressionDir ) <= 0.2588f ) ;
	}
	else
	{
		return false;
	}
}

//---------------------------------------------------------
//	DoSuppressionGrenade
//---------------------------------------------------------
function DoSuppressionGrenade()
{
	AddSuppression( None, 3.0 );
}


//---------------------------------------------------------
//	DoFleeTNT
//---------------------------------------------------------
//NAC: function added to tell members of my unit to flee TNT while in Multiplayer
function DoFleeTNT(gbxExplosive Tnt)
{
	local int i, nMembers;
	local MultiplayerUnit mpUnit;
	
	// Notify members of the TNT
	ForEach DynamicActors(class'MultiplayerUnit', mpUnit)
	{
		if ( mpUnit != MyUnit )	// Don't add local player's unit
		{
			if ( mpUnit.AnyLivingMembers() )
			{
				if (mpUnit.SameTeamAsUnit(MyUnit))
				{
					//now get the number of members in this unit
					nMembers = mpUnit.NumMembers;
					//loop through the unit and tell each mind to flee
					for( i = 0; i < nMembers; ++i )
					{
						if (mpUnit.Members[ i ].Controller.IsA('Mind'))
						{	
							Mind( mpUnit.Members[ i ].Controller ).SeeTNT(TNT);
						}
					}
				}
			}
		}
	}


}


//---------------------------------------------------------
//	TNTResumeCombat
//---------------------------------------------------------
//NAC: function added to tell members of my unit to go back to combat state and forget about TNT
function TNTResumeCombat()
{
	local int i, nMembers;
	local MultiplayerUnit mpUnit;
	
	// Notify members of the TNT
	ForEach DynamicActors(class'MultiplayerUnit', mpUnit)
	{
		if ( mpUnit != MyUnit )	// Don't add local player's unit
		{
			if ( mpUnit.AnyLivingMembers() )
			{
				if (mpUnit.SameTeamAsUnit(MyUnit))
				{
					//now get the number of members in this unit
					nMembers = mpUnit.NumMembers;
					//loop through the unit and tell each mind to flee
					for( i = 0; i < nMembers; ++i )
					{
						if (mpUnit.Members[ i ].Controller.IsA('Mind'))
						{	
							Mind( mpUnit.Members[ i ].Controller ).CleanTNT();
							Mind( mpUnit.Members[ i ].Controller ).GoToState('InCombat');

						}
					}
				}
			}
		}
	}


}

//---------------------------------------------------------
//	DoGradedSuppressionGrenade
//---------------------------------------------------------
function DoGradedSuppressionGrenade( float Intensity ) 
{
	//Log( " UnitControllerAI::DoGradedSuppressionGrenade() Intensity="$Intensity, 'MP' );
	AddSuppression( None, 2.0f * Intensity );
}

//---------------------------------------------------------
//	GetSuppressionLevel
//---------------------------------------------------------
function ESuppressionLevel GetSuppressionLevel()
{
	if( SuppressionLevelAnalog < 1.0 )
	{
		return SL_UNSUPPRESSED;
	}
	else
	{
		return SL_SUPPRESSED;
	}
}

//---------------------------------------------------------
//	GetSuppressionLevelAnalog
//---------------------------------------------------------
function float GetSuppressionLevelAnalog()
{
	return SuppressionLevelAnalog;
}

function ResetSuppressionLevelAnalog()
{
	SuppressionLevelAnalog = 0.0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// COMMON STATE-OVERRIDE FUNCTIONS ////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//---------------------------------------------------------
//	BeginState
//---------------------------------------------------------
function BeginState()
{
//	Log( name $ "<" $ GetStateName() $ ">.BeginState()", 'Unit' );
}

//---------------------------------------------------------
//	EndState
//---------------------------------------------------------
function EndState()
{
//	Log( name $ "<" $ GetStateName() $ ">.EndState()", 'Unit' );
}

//---------------------------------------------------------
//	GetSmallestDistItemInMoveOutSequence
//---------------------------------------------------------
function int GetSmallestDistItemInMoveOutSequence()
{
	local int i;
	local float smallestDist;
	local int iSmallestItem;

	iSmallestItem = -1;

	for( i = 0; i < MoveOutSequence.Length; ++i )
	{
		if( iSmallestItem < 0 || MoveOutSequence[ i ].Distance < smallestDist )
		{
			smallestDist = MoveOutSequence[ i ].Distance;
			iSmallestItem = i;
		}
	}

	return iSmallestItem;
}

//---------------------------------------------------------
//	SpawnPerceptionPlayerHit
//---------------------------------------------------------
function SpawnPerceptionPlayerHit( gbxPawn PlayerPawn )
{
	local PerceptionPawnHit percep;
	percep = new( None ) class'PerceptionPawnHit';
	percep.PawnHit = PlayerPawn;
	PlayerPawn.PostGBXMessage( percep );
}

//---------------------------------------------------------
//	SpawnPerceptionPlayerWarningShot
//---------------------------------------------------------
function SpawnPerceptionPlayerWarningShot( gbxPawn PlayerPawn )
{
	local PerceptionPawnHit percep;
	percep = new( None ) class'PerceptionPawnHit';
	percep.PawnHit = PlayerPawn;
	percep.bWarningShot = true;
	PlayerPawn.PostGBXMessage( percep );
}


function bool IsAssaulting( optional Unit AssaultedUnit )
{
	return WantsToAssault() && ( AssaultedUnit == None || AssaultedUnit == MyUnit.AssignedTargetUnit );
}

//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
	bHidden=true
	bStatic=false
	TimerInterval=1.0

	SuppressionDecayGray_Novice=0.10
	SuppressionDecayGray_Interm=0.15
	SuppressionDecayGray_Advanced=0.25
	SuppressionDecayGray_Veteran=0.22
	
	SuppressionDecayRed_Novice=0.12
	SuppressionDecayRed_Interm=0.23
	SuppressionDecayRed_Advanced=0.35
	SuppressionDecayRed_Veteran=0.45

	SuppressionMag_Novice=1.0	// Difficulty manager will set these values properly.
	SuppressionMag_Interm=1.0
	SuppressionMag_Advanced=1.0
	SuppressionMag_Veteran=1.0

	IconLerpAlpha=0.1		

	KnownEnemyUnitsRefreshInterval = 10.0;
	KnownEnemyUnitsTimeout = 30.0;

	MaxImpactDistance=1000

	SuppressionSeeAllyHit=0.5
	SuppressionSeeAllyKilled=2  //DLEVY 1/4/05 Change from 1.0 so get max supression when Ally killed 
	SuppressionSeeImpact=0.125
	SuppressionNearbyTrace=0.1

	OverallSuppressionScalarPlayer=0.6 // Multiplayer wants to tweak player and AI overall independently 2004-06-02 JWS
	OverallSuppressionScalarAI=0.4

	SufficientPursuitVantageRatio=0.50
	InsufficientPursuitVantageRatio=0.34

	HoverHeight=120

	PlayerShotSuppressionScalar=0.9		// was 1.6
	AIShotSuppressionScalar=1.0
	
	OpBurstDuration=3.0
	TargetOrderOpBurstDuration=20.0

	SuppressionSway=0.75
}
//=============================================================================
// Infantry Unit AI Controller.  Handles all squad-level AI behavior, which mainly 
// includes the behavior necessary to carry out squad commands (move/target/assault).
//
// Author: Jeff Wofford, Gearbox Software.
//=============================================================================
class UnitControllerAIInfantry extends UnitControllerAI
	native;

cpptext
{
	virtual UBOOL IsBerserk();
}

//---------------------------------------------------------
//	Variables / Constants
//---------------------------------------------------------
struct native GrenadeAttackCacheEntry
{
	var Vector			AttackLocation;
	var float			LastAttackTime;
};

var private bool LeaderDoMoveGesture;
var private gbxPawn ClosestPawnToFCenter;
var private float ClosestPawnToFCenterDist, PawnToFCenterDist;

// Grenade attack management
var array< GrenadeAttackCacheEntry > GrenadeAttackCache;
var bool	bStartReportingGrenades;
var() float	MinGrenadeAttackInterval;		// Minimum amount of time to wait between grenade attacks
var() float MinLocalGrenadeAttackInterval;	// Minimum amount of time to wait between grenade attacks in a particular location
var() float	GrenadeAttackLocationDelta;		// Distance from an attack location considered unique
var	  int   LastGrenadeAttackTime;			// Cache entry for last grenade attack

var() float MoveoutGestureThreshold;		// Moveout sound and animation will not play if movement order is less than this many units
var() name	MoveoutGestureAnim;
var() name	OnMeGestureAnim;
var() name	AttackGestureAnim;
var() name	AssaultGestureAnim;
var() name	RushEnemyGestureAnim;

var() name	MoveoutGestureSpeech;
var() name	OnMeGestureSpeech;
var() name	AcknowledgeOrderSpeech;
var() name	AcknowledgeTargetOrderSpeech;
var() name	AttackGestureSpeech;
var() name	AssaultOrderSpeech;
var() name	FallInOrderSpeech;

//var float	NextCoveringFireSpeakTime;
//var float	CoveringFireSpeakInterval;

var float	TerrifiedStartTime;
var float	TerrifiedDuration;
var float	BerserkStartTime;
var float	BerserkDuration;

//---------------------------------------------------------
//	OrderTarget
//---------------------------------------------------------
function OrderTarget( Unit targetUnit )
{
	Super.OrderTarget(targetUnit);

	// Have the leader obey the order.
	if ( !MyUnit.Leader.IsHumanControlled() )
	{
		if (Level.Game.bHoldFire && (MyUnit.Leader.PawnTeam == TEAM_US))  // is this game configured to hold fire?...
		{
			Level.Game.fHoldFireTime = Level.TimeSeconds;  // let 'em have it!
		}

		if ( MyUnit.GetNumLivingMembers() > 1 )
		{
			Level.TheAISpeechManager.PlaySpeech( 
				MyUnit.Leader, 
				MyUnit.SuperUnit.Leader,	// hoping this is the player
				'OrderAttack',
				,
				, 
				1.0, 
				MyUnit, 
				5.0, 
				0.5
			);
		}
		else
		{
			Level.TheAISpeechManager.PlaySpeech( 
				MyUnit.Leader, 
				MyUnit.SuperUnit.Leader,	// hoping this is the player
				'OrderResponse'
				,
				,
				, 
				2.0, 
				MyUnit, 
				5.0, 
				0.5
			);
		}
	}

	// Have the other members acknowledge the leader.
	FollowersAcknowledgeOrder( AcknowledgeTargetOrderSpeech, 4.0, 7.0, MyUnit );

	//NextCoveringFireSpeakTime = Level.TimeSeconds + CoveringFireSpeakInterval;
	ResetGrenadeAttackTimes();
}

//---------------------------------------------------------
//	OrderFallIn
//---------------------------------------------------------
function OrderFallIn()
{
	Super.OrderFallIn();

	// Have the leader obey the order.
	if ( !MyUnit.Leader.IsHumanControlled() )
	{
		if ( MyUnit.GetNumLivingMembers() > 1 )
		{
			Level.TheAISpeechManager.PlaySpeech( 
				MyUnit.Leader, 
				MyUnit.SuperUnit.Leader,	// hoping this is the player
				'OrderFallIn',
				,
				, 
				1.00, 
				MyUnit, 
				5.0, 
				0.5
			);
		}
		else
		{
			Level.TheAISpeechManager.PlaySpeech( 
				MyUnit.Leader, 
				MyUnit.SuperUnit.Leader,	// hoping this is the player
				'OrderResponse',
				,
				, 
				2.00, 
				MyUnit, 
				5.0, 
				0.5
			);
		}
	}

	// Have the other members acknowledge the leader.
	FollowersAcknowledgeOrder( AcknowledgeOrderSpeech, 4.0, 7.0, MyUnit );

	//NextCoveringFireSpeakTime = 0.0;
}

//---------------------------------------------------------
//	OrderAssault
//---------------------------------------------------------
function OrderAssault( Unit targetUnit )
{
	Super.OrderAssault( targetUnit );

	// Have the leader obey the order.
	if ( !MyUnit.Leader.IsHumanControlled() )
	{
		if (Level.Game.bHoldFire && (MyUnit.Leader.PawnTeam == TEAM_US))  // is this game configured to hold fire?...
		{
			Level.Game.fHoldFireTime = Level.TimeSeconds;  // let 'em have it!
		}

		if ( MyUnit.GetNumLivingMembers() > 1 )
		{
			Level.TheAISpeechManager.PlaySpeech( 
				MyUnit.Leader, 
				MyUnit.SuperUnit.Leader,	// hoping this is the player
				'OrderAssault',
				,
				, 
				1.00, 
				MyUnit, 
				5.0, 
				0.5
			);
		}
		else
		{
			Level.TheAISpeechManager.PlaySpeech( 
				MyUnit.Leader, 
				MyUnit.SuperUnit.Leader,	// hoping this is the player
				'OrderResponse',
				,
				, 
				2.00, 
				MyUnit, 
				5.0, 
				0.5
			);
		}
	}

	// Have the other members acknowledge the leader.
	FollowersAcknowledgeOrder( AcknowledgeOrderSpeech, 4.0, 7.0, MyUnit );

	//NextCoveringFireSpeakTime = 0.0;

	// Let the enemy know he's being assaulted.
	targetUnit.MyUnitController.NotifyBeingAssaulted( MyUnit );

	GoBerserk();

	GotoState( 'Assaulting' );
}

//---------------------------------------------------------
//	OrderMove
//---------------------------------------------------------
function OrderMove( ActorLite FORMC, optional bool bAddToQueue )
{
	Super.OrderMove( FORMC, bAddToQueue );

	if ( MyUnit != None && MyUnit.Leader != None )
	{
		if ( !MyUnit.Leader.IsHumanControlled() )
		{
			if ( MyUnit.GetNumLivingMembers() > 1 )
			{
				Level.TheAISpeechManager.PlaySpeech( 
					MyUnit.Leader, 
					MyUnit.SuperUnit.Leader,	// hoping this is the player
					'OrderMove',
					,
					, 
					1.0, 
					MyUnit, 
					3.0, 
					0.5
				);
			}
			else
			{
				Level.TheAISpeechManager.PlaySpeech( 
					MyUnit.Leader, 
					MyUnit.SuperUnit.Leader,	// hoping this is the player
					'OrderResponse',
					,
					, 
					2.0, 
					MyUnit, 
					3.0, 
					0.5
				);
			}
		}

		// Have the other members acknowledge the order.
		FollowersAcknowledgeOrder( AcknowledgeOrderSpeech, 3.0, 5.0, MyUnit );

		//NextCoveringFireSpeakTime = 0.0;
	}
}

//---------------------------------------------------------
//	NotifyFormationCenterChange
//---------------------------------------------------------
function NotifyFormationCenterChange(int NumMembersInRadius)
{
	Super.NotifyFormationCenterChange( NumMembersInRadius );
	GotoState( 'MovingOut' );
}


//---------------------------------------------------------
//	Timer
//---------------------------------------------------------
simulated function Timer()
{
	local int x, antiVehicleIndex;
	//local float Delay;	
	local bool /*bCantHitTargetUnit, */bHaveAntiVehicleDude;

	Super.Timer();

	// Decide whether to tell the player that we can't hit our assigned target unit.
	/*
	if ( MyUnit.HasTargetOrder() && MyUnit.TimeSinceTargetOrderGiven() > 6.0 )
	{
		bCantHitTargetUnit = true;

		// Logic: Look at each of the unit's members.  If he has been shooting well at a member of the target unit,
		// then do nothing.  Otherwise, our guys are having trouble shooting at the assigned target unit.
		for ( x=0; x < MyUnit.NumMembers; ++x )
		{
			if ( MyUnit.Members[x].Controller != None && MyUnit.Members[x].Controller.IsA( 'Mind' ) )
			{
				if ( !Mind( MyUnit.Members[x].Controller).HasHadVantageProblems() )
				{
					// Has this member shot at an enemy in the assigned unit in the last 10 seconds?
					// If so, then we aren't having problems obeying this order.
					if ( Level.TimeSeconds <= ( Mind( MyUnit.Members[x].Controller ).GetTimeLastShotAtAssignedUnit() + 20.0f ) )
					{
						bCantHitTargetUnit = false;
						break;
					}
				}				
			}
		}

		if ( bCantHitTargetUnit )
		{
			// Pick a member at random to deliver the bad news that we can't hit anyone.
			Level.TheAISpeechManager.PlaySpeech( MyUnit.Members[ Rand( MyUnit.NumMembers ) ], 'CantHitTarget',,, Delay, MyUnit, 3.0, 15.0 );
		}
	}
	*/

	// If unit is op-bursting due to a target order, make sure they routinely say lines like, "Keep up the fire!"
	// If unit has only one member, though, don't do this--most of the lines assume multiple members.
	/*
	if (	NextCoveringFireSpeakTime > 0 && Level.TimeSeconds > NextCoveringFireSpeakTime && 
			MyUnit.NumMembers > 1 && MyUnit.HasTargetOrder() && HasFreeOpBurst() )
	{
		Delay = 0.0;
		for ( x=0; x < MyUnit.NumMembers; ++x )
		{
			if ( MyUnit.Members[x] != MyUnit.Leader )
			{
				Level.TheAISpeechManager.PlaySpeech( MyUnit.Members[x], 'CoveringFire',,, Delay, MyUnit, 3.0, 0.5);
				Delay += 0.5;
			}
		}

		NextCoveringFireSpeakTime = Level.TimeSeconds + CoveringFireSpeakInterval;
	}
	*/

	antiVehicleIndex = -1;
	bHaveAntiVehicleDude = false;

	// Make sure at least one member with an anti-vehicle weapon is told to prioritize vehicle targets, if he's not alone.
	if( MyUnit.GetNumLivingMembers() > 1 )
	{
		for ( x=0; x < MyUnit.NumMembers; ++x )
		{
			if( !MyUnit.Members[x].IsDead() && MyUnit.Members[x].Weapon != None && gbxWeapon(MyUnit.Members[x].Weapon) != None && gbxWeapon(MyUnit.Members[x].Weapon).bDamagesVehicles )
			{
				if( MyUnit.Members[x].bPrioritizeVehicles )
				{
					bHaveAntiVehicleDude = true;
					break;
				}
				else
				{
					if( antiVehicleIndex < 0 )
					{
						// Remember the first member that has one of these weapons
						antiVehicleIndex = x;
					}
				}
			}
		}

		if( !bHaveAntiVehicleDude && antiVehicleIndex >= 0 )
		{
			MyUnit.Members[antiVehicleIndex].bPrioritizeVehicles = true;
		}
	}
	else if( MyUnit.GetNumLivingMembers() == 1 )
	{
		MyUnit.Members[0].bPrioritizeVehicles = false;
	}
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// GRENADE ATTACK MANAGEMENT /////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//---------------------------------------------------------
//	GetGrenadeAttackCacheIndex
//---------------------------------------------------------
function int GetGrenadeAttackCacheIndex( Vector AttackLocation )
{
	local int i;

	for( i = 0; i < GrenadeAttackCache.Length; i++ )
	{
		if( VSize(GrenadeAttackCache[i].AttackLocation - AttackLocation) < GrenadeAttackLocationDelta )
			return i;
	}

	return -1;
}

//---------------------------------------------------------
//	AddGrenadeAttackCacheEntry
//---------------------------------------------------------
function int AddGrenadeAttackCacheEntry( Vector AttackLocation )
{
	local int nIndex;

	GrenadeAttackCache.Length = GrenadeAttackCache.Length + 1;

	nIndex = GrenadeAttackCache.Length - 1;
	GrenadeAttackCache[ nIndex ].AttackLocation = AttackLocation;
	GrenadeAttackCache[ nIndex ].LastAttackTime = Level.TimeSeconds;

	return nIndex;
}

//---------------------------------------------------------
//	CleanGrenadeAttackCache
//---------------------------------------------------------
function bool CleanGrenadeAttackCache()
{
	local int i;

	for( i = 0; i < GrenadeAttackCache.Length; i++ )
	{
		if( Level.TimeSeconds - GrenadeAttackCache[i].LastAttackTime > MinLocalGrenadeAttackInterval )
		{
			GrenadeAttackCache.Remove( i, 1 );
			return true;
		}
	}
}

//---------------------------------------------------------
//	IsAnyGrenadeAttackAllowed
//---------------------------------------------------------
function bool IsAnyGrenadeAttackAllowed()
{
	//LogSelective( "IsAnyGrenadeAttackAllowed(): "$(Level.TimeSeconds - LastGrenadeAttackTime >= MinGrenadeAttackInterval) );
	//return ( Level.TimeSeconds - LastGrenadeAttackTime >= MinGrenadeAttackInterval );
	return ( LastGrenadeAttackTime == 0.0 || 
			( Level.TimeSeconds - LastGrenadeAttackTime ) >= MinGrenadeAttackInterval );
}

//---------------------------------------------------------
//	IsGrenadeAttackAllowed
//---------------------------------------------------------
function bool IsGrenadeAttackAllowed( Vector TargetLocation )
{
	local int AttackIndex;

	// Clean the cache first
	while( CleanGrenadeAttackCache() );

	// Check global time first
	if( Level.TimeSeconds - LastGrenadeAttackTime < MinGrenadeAttackInterval )
	{
		return false;
	}

	AttackIndex = GetGrenadeAttackCacheIndex( TargetLocation );

	// New entry
	if( AttackIndex < 0 )
	{
		// set global entry
		AddGrenadeAttackCacheEntry( TargetLocation );
		LastGrenadeAttackTime = Level.TimeSeconds;
		return true;
	}

	// Check local time
	if( Level.TimeSeconds - GrenadeAttackCache[ AttackIndex ].LastAttackTime > MinLocalGrenadeAttackInterval )
	{
		GrenadeAttackCache[ AttackIndex ].LastAttackTime = Level.TimeSeconds;
		GrenadeAttackCache[ AttackIndex ].AttackLocation = TargetLocation;
		LastGrenadeAttackTime = Level.TimeSeconds;
		return true;
	}

	return false;
}

//---------------------------------------------------------
//	ResetGrenadeAttackTimes
//---------------------------------------------------------
// Force the pawn to throw a grenade, even if he just did already.
function ResetGrenadeAttackTimes()
{
	local int i;

	LastGrenadeAttackTime = 0.0;

	for( i = 0; i < GrenadeAttackCache.Length; i++ )
	{
		GrenadeAttackCache[ i ].LastAttackTime = 0.0;
	}
}

//---------------------------------------------------------
//	FollowersAcknowledgeOrder
//---------------------------------------------------------	
function FollowersAcknowledgeOrder( name SpeechName, float BaseDelay, float WaitTime, Object Regarding )
{
	local int x;
	local float Delay;

	Delay = BaseDelay;
	for ( x=0; x < MyUnit.NumMembers; ++x )
	{
		if ( MyUnit.Members[x] != MyUnit.Leader )
		{
			Level.TheAISpeechManager.PlaySpeech( 
				MyUnit.Members[x], 
				MyUnit.SuperUnit.Leader,	// hoping this is the player
				SpeechName,
				,
				, 
				Delay, 
				Regarding, 
				WaitTime, 
				0.5
			);
			Delay += 0.5;
		}
	}
}


//---------------------------------------------------------
//	Terror and response to being assaulted.
//---------------------------------------------------------	
function NotifyBeingAssaulted( Unit AssaultingUnit )
{
	// When a unit is assaulted, if it is suppressed it becomes "terrified" for a few seconds.
	if( GetSuppressionLevel() == SL_SUPPRESSED )
	{
		BecomeTerrified();
	}
}

function BecomeTerrified()
{
	// MP pawns do not become terrified.
	if ( Level.UseMPStyleFatigue() )
		return;

	if( !IsTerrified() )
	{
		TerrifiedStartTime = Level.TimeSeconds;
	}
}

function bool IsTerrified()
{
	// MP pawns do not become terrified.
	if ( Level.UseMPStyleFatigue() )
		return false;

	if( GetSuppressionLevel() == SL_SUPPRESSED && TerrifiedStartTime > 0 && Level.TimeSeconds - TerrifiedStartTime <= TerrifiedDuration )
	{
		return true;
	}
}

function GoBerserk()
{
	if( !IsBerserk() )
	{
		BerserkStartTime = Level.TimeSeconds;
	}
}

function bool IsBerserk()
{
	if( BerserkStartTime > 0 && Level.TimeSeconds - BerserkStartTime <= BerserkDuration )
	{
		return true;
	}
	else
	{
		return false;
	}
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// UNIT STATES ////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////


//=========================================================
//	State MovingOut
//=========================================================
state MovingOut
{

	//---------------------------------------------------------
	//	CalculateMoveOutSequence (MovingOut)
	//---------------------------------------------------------	
	function bool CalculateMoveOutSequence()
	{
		local bool bAtLeastOneMoving;
		local int i;

		MoveOutSequence.Length = MyUnit.NumMembers;

		for( i = 0; i < MyUnit.NumMembers; ++i )
		{
			MoveOutSequence[i].Member = MyUnit.Members[i];

			// Reject dead or null members.
			if( MyUnit.Members[i] == None || MyUnit.Members[i].bDeleteMe )
				continue;

			// How far is this member from the new formation center?
			if (MyUnit.FormationCenter.bIsNavigationPoint)
				PawnToFCenterDist = VSize(MyUnit.Members[i].Location - NavigationPoint(MyUnit.FormationCenter).Location);
			else if (MyUnit.FormationCenter.bIsNavigationPointLite)
				PawnToFCenterDist = VSize(MyUnit.Members[i].Location - NavigationPointLite(MyUnit.FormationCenter).Location);

			MoveOutSequence[i].Distance = PawnToFCenterDist;

			// Find the closest member to the new location
			if(  PawnToFCenterDist < ClosestPawnToFCenterDist || ClosestPawnToFCenterDist < 0  )
			{
				ClosestPawnToFCenter = MyUnit.Members[i];
				ClosestPawnToFCenterDist = PawnToFCenterDist;
			}

			// At least one member must be outside of the threshold for the leader to gesture.  Don't gesture if we're
			// attached to our Super Unit (we're just following).
			if( PawnToFCenterDist > MoveoutGestureThreshold && !MyUnit.IsAttachedToSuperUnit() )
			{
				bAtLeastOneMoving = true;
			}
		}

		return bAtLeastOneMoving;
	}

	//---------------------------------------------------------
	//	PlayLeaderGesture (MovingOut)
	//---------------------------------------------------------	
	function bool PlayLeaderGesture()
	{
		// If the leader is closest, he will use the "On Me!" gesture.  Otherwise, the "Move Out!" gesture
		if( ClosestPawnToFCenter == MyUnit.Leader )
		{
			return WargamePawn(MyUnit.Leader).PlayGestureAnim( OnMeGestureAnim, true );
		}
		else
		{
			return WargamePawn(MyUnit.Leader).PlayGestureAnim( MoveoutGestureAnim, true );
		}
	}	

	//---------------------------------------------------------
	//	MoveOutOneMember (MovingOut)
	//---------------------------------------------------------	
	function bool MoveOutOneMember( out int MemberToMove )
	{
		local gbxPawn aMember;

		MemberToMove = GetSmallestDistItemInMoveOutSequence();		// TODO Nasty O(N^2) sort algorithm.

		if ( MemberToMove < 0 )
		{
			return false;
		}

		aMember = MoveOutSequence[ MemberToMove ].Member;
		
		if ( aMember != None && aMember.Controller != None )
		{
			if ( aMember.Controller.IsA('gbxAIController') )
			{
				gbxAIController( aMember.Controller ).NotifyFormationCenterChange();
			}
		}

		return true;
	}

//-----------------------------------------
Begin:		// ( state MovingOut )
//-----------------------------------------

	// Initialize not-so-local variables
	ClosestPawnToFCenter = None;
	ClosestPawnToFCenterDist = -1.0;

	// Find the order in which members will move out.
	LeaderDoMoveGesture = CalculateMoveOutSequence();

	Sleep( 0.25 );  // slight delay before leader begins rotating

	// Should the leader gesture?  Start rotating the leader in the desired movement direction...
	if( MyUnit.NumMembers > 1 && LeaderDoMoveGesture && WargamePawn(MyUnit.Leader) != None )
	{
		if (Mind(MyUnit.Leader.Controller) != None)
		{
			Mind(MyUnit.Leader.Controller).FacingVector = GetLocation(MyUnit.FormationCenter);
			Mind(MyUnit.Leader.Controller).SetFacingPolicy(FACE_Vector);
		}
	}

	// Wait for player to finish signalling.
	Sleep( 0.50 );

	// Should the leader gesture?
	if( MyUnit.NumMembers > 1 && LeaderDoMoveGesture && WargamePawn(MyUnit.Leader) != None )
	{
		if ( PlayLeaderGesture() )
		{			
			// Allow unit leader to finish giving assault command
			Sleep( 1.5 );
		}
	}	

	// Send each unit member to new navpoints within a radius of the new formation center, in order of proximity to new FORMC.
	while( MoveOutSequence.Length > 0 )
	{
		if ( MoveOutOneMember( iCount ) )
		{
			Sleep( RandRange( 0.25, 0.75 ));
			MoveOutSequence.Remove( iCount, 1 );
		}		
	}

	GotoState('');
}

//---------------------------------------------------------
//	StopAssault
//---------------------------------------------------------	
function StopAssault()
{
	local int i;

	Super.StopAssault();

	if ( GetAssaultDestination() == MyUnit.FormationCenter )
	{
		MyUnit.SetFormationCenter( MyUnit.PreviousFormationCenter );
		
		for( i = 0; i < MyUnit.NumMembers; ++i )
		{
			Mind( MyUnit.Members[i].Controller ).NotifyFormationCenterChange();
		}
	}
}

//=========================================================
//	State Assaulting
//=========================================================
state Assaulting extends MovingOut
{	
	//---------------------------------------------------------
	//	PlayLeaderGesture (Assaulting)
	//---------------------------------------------------------	
	function bool PlayLeaderGesture()
	{
		if ( !MyUnit.Leader.IsHumanControlled() )
		{
			Level.TheAISpeechManager.PlaySpeech( 
				MyUnit.Leader,
				MyUnit.SuperUnit.Leader,
				'Moving',
				,
				, 
				0.2, 
				MyUnit, 
				3.0, 
				0.5
			);
			return Mind( MyUnit.Leader.Controller ).RequestPlayGesture( AssaultGestureAnim, true );
		}		
		
		return false;
	}

	//---------------------------------------------------------
	//	CancelLeaderGesture (Assaulting)
	//---------------------------------------------------------	
	function CancelLeaderGesture()
	{
		Mind( MyUnit.Leader.Controller ).RequestPlayGesture( '', false );
	}

	//---------------------------------------------------------
	//	PlayLeaderGestureRushTarget (Assaulting)
	//---------------------------------------------------------	
	function bool PlayLeaderGestureRushTarget()
	{
		if ( !MyUnit.Leader.IsHumanControlled() )
		{
			Level.TheAISpeechManager.PlaySpeech( 
				MyUnit.Leader,	
				MyUnit.SuperUnit.Leader,
				'OrderAssault',
				,
				, 
				0.2, 
				MyUnit, 
				3.0, 
				0.5
			);
			return Mind( MyUnit.Leader.Controller ).RequestPlayGesture( RushEnemyGestureAnim, true );
		}

		return false;
	}

	//---------------------------------------------------------
	//	NotifyFormationCenterChange (Assaulting)
	//---------------------------------------------------------	
	function NotifyFormationCenterChange(int NumMembersInRadius)
	{
		if( MyUnit != None && MyUnit.FormationCenter != None )
		{
			// clear out the FormationPath array (remove all elements)...
			MyUnit.FormationPath.Remove( 0, MyUnit.FormationPath.Length );

			BuildFormationNavPointCache(NumMembersInRadius);
		}
	}

	//---------------------------------------------------------
	//	InitGrenadeReports (Assaulting)
	//---------------------------------------------------------	
	function InitGrenadeReports()
	{
		local int i, j;
		local bool bAddEntry;
		local int idx;

		GrenadeReports.Remove( 0, GrenadeReports.Length );

		// First, check if the grenade reports array needs to have new entries added.
		for( i = 0; i < MyUnit.NumMembers; ++i )
		{
			bAddEntry = true;
						
			for ( j = 0; j < GrenadeReports.Length; ++j )
			{
				if ( GrenadeReports[j].Member == MyUnit.Members[i] && !MyUnit.Members[i].IsDead() )
				{
					// This member already in the Grenade Reports list.
					bAddEntry = false;
					break;
				}
			}

			if ( bAddEntry )
			{
				idx = GrenadeReports.Length;
				GrenadeReports.Length = GrenadeReports.Length + 1;	// Implicitly adds new element to the array
				GrenadeReports[ idx ].Member = MyUnit.Members[i];				
			}
		}

		// Finally, prepare all entries for a new Assault session.
		for ( j = 0; j < GrenadeReports.Length; ++j )
		{
			GrenadeReports[ j ].bReported = false;
			GrenadeReports[ j ].bIsThrowing = false;
			GrenadeReports[ j ].bGrenadeExploded = false;
		}
	}

	//---------------------------------------------------------
	//	MoveOutOneMember (MovingOut)
	//---------------------------------------------------------	
	function bool MoveOutOneMember( out int MemberToMove )
	{
		local gbxPawn aMember;

		MemberToMove = GetSmallestDistItemInMoveOutSequence();		// TODO Nasty O(N^2) sort algorithm.

		if ( MemberToMove < 0 )
		{
			return false;
		}

		aMember = MoveOutSequence[ MemberToMove ].Member;
		
		if ( aMember != None && aMember.Controller != None )
		{
			if ( aMember.Controller.IsA('gbxAIController') )
			{
				gbxAIController( aMember.Controller ).NotifyAssaultCommand();
			}
		}

		return true;
	}

	//---------------------------------------------------------
	//	SetOneOffTimer (Assaulting)
	//---------------------------------------------------------
	function SetOneOffTimer( float Duration )
	{
		if ( Duration <= 0.001f )
		{
			bWaitForTimer = false;
			return;
		}
		else
		{
			bWaitForTimer = true;
			SetTimer( Duration, false );
		}
	}

	//---------------------------------------------------------
	//	Timer (Assaulting)
	//---------------------------------------------------------	
	// Handle "one-off" timer requests.
	simulated function Timer()
	{
		if ( bWaitForTimer )
		{
			LogSelective( "Timer." );
			bWaitForTimer = false;
			
			if(TimerRate != TimerInterval)
				SetTimer( TimerInterval, true );
			//SetTimer( TimerInterval, false );
		}
		else
		{
			Super.Timer();
		}
	}

	//---------------------------------------------------------
	//	StopAssault (Assaulting)
	//---------------------------------------------------------	
	function StopAssault()
	{
		Super.StopAssault();

		CancelLeaderGesture();

		GotoState( '' );
	}

//-----------------------------------------
Begin:		// ( state Assaulting )
//-----------------------------------------

	// Wait for player to finish signalling.
	LogSelective( "<statecode>: waiting for player to finish signalling." );
	Sleep( 0.75 );

	// Should the leader gesture?
	if( MyUnit.NumMembers > 1 && WargamePawn(MyUnit.Leader) != None )
	{		
		LogSelective( "<statecode>: Attempting to make the leader gesture." );
		PlayLeaderGesture();		
	}

	// Rush the enemy.
	LogSelective( "<statecode>: Setting new formation center." );

	bAssaultThisTarget = true;
	MyUnit.SetFormationCenter( GetAssaultDestination() );	// Will call my NotifyFormationCenterChange() function indirectly.

	CalculateMoveOutSequence();
	
	while( MoveOutSequence.Length > 0 )
	{
		if ( MoveOutOneMember( iCount ) )
		{
			MoveOutSequence.Remove( iCount, 1 );
		}		
	}

	GotoState( '' );
}

function bool TryToStealTeammatesNavPoint( gbxPawn aMember, out gbxPawn Teammate, out ActorLite NewNavPoint ) 
{
	local int i;

	if ( aMember == None )
		return false;

	for( i = 0; i < MyUnit.NumMembers; ++i )
	{		
		Teammate = MyUnit.Members[i];
		if ( Teammate != None && Teammate != aMember && Teammate.MyClaimedNavPoint != None )
		{
			if ( aMember.HasBetterWeaponThan( Teammate ) )
			{
				if ( Teammate.Controller != None && Teammate.Controller.IsA( 'Mind' ) )
				{
					if ( !Mind( Teammate.Controller ).IsNavigating() && Mind( Teammate.Controller ).HasBeenShootingWell() )
					{
						NewNavPoint = Teammate.MyClaimedNavPoint;
						Teammate.UnClaimNavPoint();						
						aMember.ClaimNavPoint( NewNavPoint );

						Mind( Teammate.Controller ).NavigationPointStolen( NewNavPoint );

						return true;
					}
				}
			}
		}
	}

	NewNavPoint = None;
	Teammate = None;
	return false;
}

//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
	MinGrenadeAttackInterval=5.0
	MinLocalGrenadeAttackInterval=10.0
	GrenadeAttackLocationDelta=512.0

	MoveoutGestureThreshold=1024.0
	
	MoveoutGestureAnim=standing_gesture_move	
	OnMeGestureAnim=standing_gesture_move
	AttackGestureAnim=standing_gesture_target
	AssaultGestureAnim=standing_gesture_fire
	RushEnemyGestureAnim=standing_gesture_move
	
	MoveoutGestureSpeech=MoveOutLeader
	OnMeGestureSpeech=MoveOutLeader		
	AcknowledgeOrderSpeech=OrderResponse
	AcknowledgeTargetOrderSpeech=TargetOrderResponse
	AttackGestureSpeech=TargetOrderLeader
	AssaultOrderSpeech=AssaultLeader
	FallInOrderSpeech=MoveOutLeader

	TerrifiedDuration=10.0
	BerserkDuration=6.0
}//=============================================================================
// Tank Unit AI Controller.  Handles all squad-level AI behavior, which mainly 
// includes the behavior necessary to carry out squad commands (move/target/assault).
//
// Author: Jeff Broome, Gearbox Software.
//=============================================================================
class UnitControllerAITank extends UnitControllerAI;

var int index;
var float PawnToFCenterDist;
var Tank MyTank;

var()	float	MoveoutGestureThreshold;		// Moveout sound and animation will not play if movement order is less than this many units
var()	name	MoveoutGestureSpeech;

var()	float	AssaultHardTargetDistance;  // the ideal distance to be from a 'hard' target (tank or other anti-tank weapon)
var()	float	AssaultSoftTargetDistance;  // the ideal distance to be from a 'soft' target (soft targets = infantry)
var()	float	AssaultDestinationReEvaluateTime;  // how often do we re-evaluate the assault destination location
var()	float	AssaultDestinationReadjustDistance;  // maximum distance re-evaluated NavPoint can be from original assault destination location
var()	bool	bHasSetSuperUnitFormationCenter;
var()	float	IdealAssaultDistance;		// the current ideal distance to be from an assaulted target
var()	float	fCheckAssaultDestTime;

var ActorLite MyAssaultDestination;


simulated function PostBeginPlay()
{
	Super.PostBeginPlay();

	fCheckAssaultDestTime = 0.0f;
}

simulated function Timer()
{
	local int iMyMember;

	Super.Timer();

	if (MyUnit.bAssaultingTargetUnit)
	{
		if (!MyUnit.HasTargetOrder())  // are all members of the Assaulting unit dead?
		{
			Log(name $ ".Timer() - Assaulted Unit is dead, setting FormationCenter to current location...", 'Tank');

			MyUnit.bAssaultingTargetUnit = false;

			// if not assaulting anymore (i.e. assaulted unit is dead), stop where we are...
			MyUnit.FormationCenter = GetNearestNavpoint( MyTank.Location, -1.0f, false, true );

			Log(name $ ".Timer() - new FormationCenter is " $ MyUnit.FormationCenter, 'Tank');

			// MyUnit.OrderMove( MyUnit.FormationCenter );  // NO!!! Don't actually, move, just do same stuff as Unit.OrderMove()...

			if ( MyUnit.TargetOrderIcon != None )
			{
				MyUnit.TargetOrderIcon.Destroy();
				MyUnit.SetTargetOrderIcon( None );
			}

			for( iMyMember = 0; iMyMember < MyUnit.NumMembers; ++iMyMember )
			{
				if ( MyUnit.Members[ iMyMember ].Controller.IsA('TankController') )
				{
					TankController(MyUnit.Members[ iMyMember ].Controller).StopNavigating();
				}
			}
		}
	}
}

function DisableTankControllerPauseMovement()
{
	local int iMyMember;

	for( iMyMember = 0; iMyMember < MyUnit.NumMembers; ++iMyMember )
	{
		if ( MyUnit.Members[ iMyMember ].Controller.IsA('TankController') )
		{
			TankController(MyUnit.Members[ iMyMember ].Controller).bPauseMovement = false;
			TankController(MyUnit.Members[ iMyMember ].Controller).fPauseMovementCheckTime = Level.TimeSeconds + 10.0f;
		}
	}
}

function ExecuteMove( ActorLite FORMC )
{
	local int iMyMember;

	// when OrderMove given while Tank has an Enemy, prevent tank from pausing while
	// on the way to the ordered destination (tank will normally pause to face his target)
	for( iMyMember = 0; iMyMember < MyUnit.NumMembers; ++iMyMember )
	{
		if ( MyUnit.Members[ iMyMember ].Controller.IsA('TankController') )
		{
			// if this tank controller is given a move order while it has an enemy...
			if ( TankController(MyUnit.Members[ iMyMember ].Controller).TankHasEnemy() )
			{
				// don't pause anywhere while navigating towards the destination
				TankController(MyUnit.Members[ iMyMember ].Controller).bDontPause = true;
			}
		}
	}

	MyUnit.SetTargetUnit( None );
	MyUnit.SetFormationCenter( FORMC );
}

//---------------------------------------------------------
//	OrderTarget
//---------------------------------------------------------
function OrderTarget( Unit targetUnit )
{
	local int iMyMember, iTargetMember;

	Super.OrderTarget(targetUnit);

	// We have to do the same sort of loop that Unit SetTargetUnit() does, but call ConsiderPossibleEnemy
	// instead of SeePlayer, because in the Mind, SeePlayer immediately adds target to the queue, in Tank
	// Controller, SeePlayer will filter the Pawn based on whether the Turret can currently see that Pawn.
	for( iMyMember = 0; iMyMember < MyUnit.NumMembers; ++iMyMember )
	{
		for( iTargetMember = 0; iTargetMember < targetUnit.NumMembers; ++iTargetMember )
		{
			if ( MyUnit.Members[ iMyMember ].Controller.IsA('TankController') )
				TankController(MyUnit.Members[ iMyMember ].Controller).ConsiderPossibleEnemy( targetUnit.Members[ iTargetMember ] );
		}
	}
}

//---------------------------------------------------------
//	OrderAssault
//---------------------------------------------------------
function OrderAssault( Unit targetUnit )
{
	local int iMyMember;

	// when OrderAssault given while Tank has an Enemy, prevent tank from pausing while
	// on the way to the assault destination (tank will normally pause to face his target)
	for( iMyMember = 0; iMyMember < MyUnit.NumMembers; ++iMyMember )
	{
		if ( MyUnit.Members[ iMyMember ].Controller.IsA('TankController') )
		{
			// if this tank controller is given an assault order while it has an enemy...
			if (TankController(MyUnit.Members[ iMyMember ].Controller).Enemy != None)
			{
				// don't pause anywhere while navigating towards the destination
				TankController(MyUnit.Members[ iMyMember ].Controller).bDontPause = true;
			}
		}
	}

	Super.OrderAssault( targetUnit );

	GotoState( 'Assaulting' );		
}

function bool IsPlayerRidingOnTank()
{
	local Controller PC;
	local Tank MyTank;
	local float distance;

	PC = Level.GetLocalPlayerController();

	if ((PC != None) && (PC.Pawn != None))
	{
		MyTank = Tank(MyUnit.Leader);

		if (MyTank != None)
		{
			distance = VSizeIgnoreZ(PC.Pawn.Location - MyTank.Location);

			if ((distance < (MyTank.VehicleCollisionRadius * 1.2f)) && (PC.Pawn.Location.Z > MyTank.Location.Z))
				return true;  // player is too close to tank (riding on it?)
		}
	}

	return false;
}

//---------------------------------------------------------
//	OrderFallIn
//---------------------------------------------------------
function OrderFallIn()
{
	DisableTankControllerPauseMovement();

	StopAssault();

	MyUnit.SetTargetUnit( None );
	MyUnit.AttachToSuperUnit();	
}

//---------------------------------------------------------
//	OrderAllFallIn
//---------------------------------------------------------
function OrderAllFallIn()
{
	DisableTankControllerPauseMovement();

	StopAssault();

	MyUnit.SetTargetUnit( None );
	MyUnit.AttachAllSubUnits();
}

function bool ShouldAttachToSuperUnit()
{
	return true;
}

function UpdateToSuperUnitFormationCenterIfNecessary()
{
	if (MyUnit.SuperUnit != None &&
		MyUnit.IsAttachedToSuperUnit() && !IsPlayerRidingOnTank() &&
		!bHasSetSuperUnitFormationCenter)
	{
		MyUnit.SetFormationCenter( MyUnit.SuperUnit.FormationCenter );
		bHasSetSuperUnitFormationCenter = true;
	}
}

function NotifyFormationCenterChange(int NumMembersInRadius)
{
	local bool bIsFORMCTankFriendly;
	local bool bNavTeamCanUse;
	local float distance;
	local gbxPawn Leader;

	if (MyUnit == None)
		return;

	Log(name $ ".NotifyFormationCenterChange() - original FORMC = " $ MyUnit.FormationCenter, 'Tank');

	// each change to the FormationCenter clears this flag, UpdateToSuperUnitFormationCenterIfNecessary() checks this flag and sets it
	bHasSetSuperUnitFormationCenter = false;

	// is this tank attached to a SuperUnit (i.e. is this tank in a "fall-in" state?
	if ((MyUnit.PreviousFormationCenter != None) && MyUnit.IsAttachedToSuperUnit())
	{
		// check if the new formation center is far enough from the old one (so tanks don't keep moving around due to small changes and appear "jittery")
		distance = VSize(GetLocation(MyUnit.PreviousFormationCenter) - GetLocation(MyUnit.FormationCenter));

		if (distance < 1000.0f)  // new formation center not far enough to worry about moving?
		{
			// reset my formation center back to what it was before because Unit has already overridden this...
			MyUnit.FormationCenter = MyUnit.PreviousFormationCenter;
			return;
		}
	}

	Leader = MyUnit.Members[0];

	bIsFORMCTankFriendly = false;

	if (MyUnit.FormationCenter.bIsNavigationPoint)
	{
		bIsFORMCTankFriendly = NavigationPoint(MyUnit.FormationCenter).bTanksCanUse;
		if (NavigationPoint(MyUnit.FormationCenter).TeamNavPoint != NAV_TeamAny)
		{
			if ((Leader.PawnTeam == TEAM_US) &&
				(NavigationPoint(MyUnit.FormationCenter).TeamNavPoint != NAV_TeamUS))
				bNavTeamCanUse = false;
			else if ((Leader.PawnTeam == TEAM_German) &&
					(NavigationPoint(MyUnit.FormationCenter).TeamNavPoint != NAV_TeamGerman))
				bNavTeamCanUse = false;
		}
	}
	else if (MyUnit.FormationCenter.bIsNavigationPointLite)
	{
		bIsFORMCTankFriendly = NavigationPointLite(MyUnit.FormationCenter).bTanksCanUse;
		if (NavigationPointLite(MyUnit.FormationCenter).TeamNavPoint != NAVL_TeamAnyLite)
		{
			if ((Leader.PawnTeam == TEAM_US) &&
				(NavigationPointLite(MyUnit.FormationCenter).TeamNavPoint != NAVL_TeamUSLite))
				bNavTeamCanUse = false;
			else if ((Leader.PawnTeam == TEAM_German) &&
					(NavigationPointLite(MyUnit.FormationCenter).TeamNavPoint != NAVL_TeamGermanLite))
				bNavTeamCanUse = false;
		}
	}

	if (!bIsFORMCTankFriendly || !bNavTeamCanUse)
	{
		if ((MyUnit.Leader != None) && (TankController(MyUnit.Leader.Controller) != None))
		{
			MyUnit.FormationCenter = TankController(MyUnit.Leader.Controller).GetNearestTankFriendlyNavpoint(MyUnit.FormationCenter);
		}
	}

	Super.NotifyFormationCenterChange( NumMembersInRadius );

	GotoState( 'MovingOut' );
}

function ActorLite GetAssaultDestination()
{
	local bool bIsHardTarget;
	local int iTargetMember;
	local ActorLite BestNavPoint;
	local vector UnitFormCLocation;
	local float IdealDistance;
	local float distance;
	local bool bVisible;

	bIsHardTarget = false;

	if (MyUnit.AssignedTargetUnit != None)
	{
		// check if targeted Unit contains any 'hard' targets (tanks, AT weapons, etc.)
		for (iTargetMember = 0; iTargetMember < MyUnit.AssignedTargetUnit.NumMembers; ++iTargetMember)
		{
			if (MyUnit.AssignedTargetUnit.Members[iTargetMember].IsA('Tank'))
			{
				bIsHardTarget = true;
				break;
			}
			else if (gbxWeapon(MyUnit.AssignedTargetUnit.Members[iTargetMember].Weapon) != None)
			{
				if (gbxWeapon(MyUnit.AssignedTargetUnit.Members[iTargetMember].Weapon).bDamagesVehicles)
				{
					bIsHardTarget = true;
					break;
				}
			}
		}

		Log(name $ ".GetAssaultDestination() - bIsHardTarget = " $ bIsHardTarget, 'Tank');

		UnitFormCLocation = GetLocation(MyUnit.AssignedTargetUnit.FormationCenter);

		BestNavPoint = None;

		if ((MyUnit.Leader != None) && (MyUnit.Leader.Controller != None))
		{
			if (bIsHardTarget)
				IdealDistance = AssaultHardTargetDistance;
			else
				IdealDistance = AssaultSoftTargetDistance;

			MyTank = Tank(MyUnit.Leader);

			distance = VSize(UnitFormCLocation - MyTank.Location);

			// if already closer than ideal distance to target...
			if (distance < IdealDistance)
			{
				bVisible = FastTrace(UnitFormCLocation, MyTank.Location, true);  // is target currently visible? (check for VisBlockingVolume)

				if (bVisible)
				{
					Log(name $ ".GetAssaultDestination() - returning None (tank already closer than IdealDistance and target visible)", 'Tank');
					return None;
				}

				IdealDistance = distance;
				Log(name $ ".GetAssaultDestination() - resetting IdealDistance to " $ IdealDistance $ " (tank already closer than IdealDistance, target not visible)", 'Tank');
			}

			IdealAssaultDistance = IdealDistance;

			Log(name $ ".GetAssaultDestination() - IdealDistance = " $ IdealDistance, 'Tank');

			BestNavPoint = TankController(MyUnit.Leader.Controller).GetBestTankDestination(UnitFormCLocation, IdealDistance, 10000.0f);
		}

		Log(name $ ".GetAssaultDestination() - returning " $ BestNavPoint.name, 'Tank');

		return BestNavPoint;
	}
	else
	{
		Log( name $ "<" $ GetStateName() $ ">.GetAssaultDestination() ERROR: called when MyUnit.AssignedTargetUnit == None", 'Unit' );
		return None;
	}
}

//---------------------------------------------------------
//	UpdatePursuit
//---------------------------------------------------------
function UpdatePursuit()
{
	// do nothing here
}

//=========================================================
//	State MovingOut
//=========================================================
state MovingOut
{
//-----------------------------------------
Begin:		// ( state MovingOut )
//-----------------------------------------
	Log(name $ ".state MovingOut() - Begin:", 'Tank');

	// ****************************************************
	// Play any necessary Tank commander animations here!!!
	// ****************************************************

	if (MyUnit.FormationCenter.bIsNavigationPoint)
		PawnToFCenterDist = VSize(MyUnit.Leader.Location - NavigationPoint(MyUnit.FormationCenter).Location);
	else if (MyUnit.FormationCenter.bIsNavigationPointLite)
		PawnToFCenterDist = VSize(MyUnit.Leader.Location - NavigationPointLite(MyUnit.FormationCenter).Location);

	if (PawnToFCenterDist > MoveoutGestureThreshold && !MyUnit.IsAttachedToSuperUnit())
	{
		MyTank = Tank(MyUnit.Leader);
		if ((MyTank != None) && (MyTank.CommanderPawn != None))
		{
			// make sure tank commander isn't buttoned up or dead...
			if ((!MyTank.CommanderPawn.bHatchClosing) && (MyTank.CommanderPawn.Health > 0))
			{
				Level.TheAISpeechManager.PlaySpeech( 
					MyUnit.Leader, 
					MyUnit.SuperUnit.Leader,	// hoping this is the player
					MoveoutGestureSpeech,
					,
					,
					0.0,
					,
					5.0,
					2.0
				);
				MyTank.CommanderPawn.PlayMoveOutAnim();
			}
		}
	}

	for ( index = 0; index < MyUnit.NumMembers; ++index )
	{
		TankController( MyUnit.Members[index].Controller ).NotifyFormationCenterChange();
	}
}


//=========================================================
//	State Assaulting
//=========================================================
state Assaulting
{

//-----------------------------------------
Begin:		// ( state Assaulting )
//-----------------------------------------
	Log(name $ ".state Assaulting() - Begin:", 'Tank');

	// ****************************************************
	// Play any necessary Tank commander animations here!!!
	// ****************************************************

	bAssaultThisTarget = true;

	MyAssaultDestination = GetAssaultDestination();
	Log(name $ ".state Assaulting() - MyAssaultDestination = " $ MyAssaultDestination.name, 'Tank');

	if (MyAssaultDestination != None)
	{
		// This WON'T ever come back because SetFormationCenter will cause NotifyFormationCenter() change to get called which switches to State MovingOut
		MyUnit.SetFormationCenter( MyAssaultDestination );
	}

	GotoState( '' );  // SHOULD NEVER GET HERE!!!
}


defaultproperties
{
	MoveoutGestureThreshold=1024.0
	MoveoutGestureSpeech=ActionMove

	AssaultHardTargetDistance=3000.0
	AssaultSoftTargetDistance=800.0
	AssaultDestinationReEvaluateTime=5.0
	AssaultDestinationReadjustDistance=2000.0
}
