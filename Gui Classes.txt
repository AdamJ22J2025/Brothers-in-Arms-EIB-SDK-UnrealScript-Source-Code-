// ====================================================================
//  (c) 2002, Epic Games, Inc.  All Rights Reserved
// ====================================================================

class fntDefaultFont extends GUIFont;

// GBX:CEK: 3/16/2004 - TEMP GUI REINTEGRATION
//#exec OBJ LOAD File=UT2003Fonts.utx

defaultproperties
{
	KeyName="DefaultFont"
// GBX:CEK: 3/16/2004 - TEMP GUI REINTEGRATION
	FontArrayNames=("Engine.DefaultFont")
//	FontArrayNames=("UT2003Fonts.FontNeuzeit9")
	bFixedSize=true
	ScaleX=0.9
	ScaleY=0.9
}
// ====================================================================
//  (c) 2002, Epic Games, Inc.  All Rights Reserved
// ====================================================================

class fntHeaderFont extends GUIFont;


defaultproperties
{
	KeyName="HeaderFont"

	FontArrayNames=("t_gbxfonts.WargameFont2")
	FontBlurName="t_gbxfonts.WargameFont2_Blur"
	ScaleX=1.1
	ScaleY=1.1
	bFixedSize=true

	ShadowOfsX=0.0
	ShadowOfsY=2.0
}
// ====================================================================
//  (c) 2002, Epic Games, Inc.  All Rights Reserved
// ====================================================================

class fntLargeFont extends GUIFont;


defaultproperties
{
	KeyName="LargeFont"

	FontArrayNames=("t_gbxfonts.WargameFont2")
	FontBlurName="t_gbxfonts.WargameFont2_Blur"
	ScaleX=1.0
	ScaleY=1.0
	bFixedSize=true

	ShadowOfsX=0.0
	ShadowOfsY=2.0
}
// ====================================================================
//  (c) 2002, Epic Games, Inc.  All Rights Reserved
// ====================================================================

class fntMenuFont extends GUIFont;

defaultproperties
{
	KeyName="MenuFont"
	FontArrayNames=("t_gbxfonts.WargameFont")
	FontBlurName="t_gbxfonts.WargameFont"
	ScaleX=0.75
	ScaleY=0.75
	bFixedSize=true

	ShadowOfsX=1.0
	ShadowOfsY=2.0
}
// ====================================================================
//  (c) 2002, Epic Games, Inc.  All Rights Reserved
// ====================================================================

class fntSmallFont extends GUIFont;

defaultproperties
{
	KeyName="SmallFont"
	FontArrayNames=("t_gbxfonts.WargameFont")
	FontBlurName="t_gbxfonts.WargameFont"
	ScaleX=0.90
	ScaleY=0.95
	bFixedSize=true

	ShadowOfsX=1.0
	ShadowOfsY=2.0
}
class fntSmallHeaderFont extends GUIFont;

defaultproperties
{
	KeyName="SmallHeaderFont"
// GBX:CEK: 3/16/2004 - TEMP GUI REINTEGRATION
	FontArrayNames=("Engine.DefaultFont","Engine.DefaultFont","Engine.DefaultFont","Engine.DefaultFont")
//	FontArrayNames=("UT2003Fonts.FontNeuzeit8","UT2003Fonts.FontEurostile9","UT2003Fonts.FontEurostile12","UT2003Fonts.FontEurostile14")
}
class gbx_BrowseMatchBase extends gbx_ScreenABXY
	Abstract;


var() Automated GUILabel			lblTextPrompt;
var Automated GUIMultiColumnListBox	Browser;
var gbx_BrowserMultiColumnListBase	BrowserList;

var localized string				StringBrowsePrompt;
var localized string				StringServerFull;

var float							DefaultPingTimeout;
var bool							bSkirmishBrowser;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	InitExecution();

	SetupYButton(StringCreateMatch);
	OnOpen = BrowserOnOpen;
	OnClose = BrowserOnClose;
	OnAButtonEvent = OnJoinGameButton;
	BrowserList = gbx_BrowserMultiColumnListBase(Browser.List);
	BrowserList.OnListItemDblClick = BrowserListItemOnDblClick;

	lblTextPrompt.SetCaption(StringBrowsePrompt);
}

event HandleParameters( string Param1, string Param2 )
{
	Super.HandleParameters(Param1, Param2);

	bSkirmishBrowser = (Param1 ~= "SKIRMISH");
}

function BrowserOnOpen();
function BrowserOnClose(optional Bool bCancelled);

function BrowserListItemOnDblClick(GUIComponent Sender, int Item)
{
	BrowserList.SetIndex(Item);

	if (hbtnA.bVisible)
	{
		OnJoinGameButton();
	}
}

function Clear()
{
	BrowserList.Clear();
}

function bool ShouldFilterServer(ServerInfo server)
{
	if (server.NumPlayers >= server.MaxPlayers)
	{
		GUILog("Skipping full server :" @server.HostName);
		return true;
	}

	if (bSkirmishBrowser != (server.GameType ~= "gbxGameplay.WargameSkirmish"))
	{
		GUILog("Skipping mismatched skirmish server :" @server.HostName);
		return true;
	}

	return false;
}

// =======================================================================================================================================================
// server joining
// =======================================================================================================================================================
function OnJoinGame(ServerInfo server);

//###+ lbouchard : Use the SystemLink argument, even for PC Lan Games
function string GetExtraJoinParams()
{
	return "?SystemLink";
}
//###-


function bool VerifyJoinGame(ServerInfo server)
{
	if (class'gbx_DlgMissingMap'.Static.PromptNeedMap(self, server.MapFilename))
		return false;

	if (server.MaxPlayers - server.NumPlayers < 1)
	{
		PromptServerFull(server);
		return false;
	}

	return true;
}

function OnJoinGameButton()
{
	local ServerInfo server;

	GUILog("gbx_BrowseMatchLan::OnJoinGame Index=" $BrowserList.Index);
	Controller.PlayClickSound(EClickSound.CS_Click);
	if (BrowserList.Index == -1)
		return;

	server = BrowserList.ServerList[BrowserList.SortData[BrowserList.Index].SortItem];
	if (VerifyJoinGame(server))
		OnJoinGame(server);
}

function PromptServerFull(ServerInfo server)
{
	local gbx_ScreenQuestion dlg;

	dlg = LaunchQuestionDialog(Controller, StringServerFull, "CONTINUE NONE");
//	dlg.OnAnswer = ServerFullPromptAnswer;
}

function bool ServerFullPromptAnswer(string answer)
{
	if (answer ~= "OK")
	{
		GUILog("ServerFullPromptAnswer Index=" $BrowserList.Index);
		if (BrowserList.Index != -1)
		{
			OnJoinGame(BrowserList.ServerList[BrowserList.SortData[BrowserList.Index].SortItem]);
			return false;
		}
	}

	return true;
}

function DoRefresh();

function OnXButton()
{
	DoRefresh();
}

defaultproperties
{
	Begin Object Class=GUILabel Name=cTextPrompt
		StyleName="MenuOptionCaption"
		DrawMenuState=2
		TextAlign=TXTA_Center
		bAcceptsInput=false
		bTabStop=false
		bDrawToFit=true
		WinWidth=0.900000
		WinHeight=0.050000
		WinLeft=0.050000
		WinTop=0.7200000
	End Object
	lblTextPrompt=cTextPrompt

	Begin Object class=GUIMultiColumnListBox Name=cBrowser
		WinWidth=0.9
		WinHeight=0.54
		WinLeft=0.05
		WinTop=0.17
        bVisibleWhenEmpty=true
        DefaultListClass="GUI.gbx_BrowserMultiColumnList"
	End Object

    Browser=cBrowser

	DefaultPingTimeout=15.0
	bSkirmishBrowser=false

	StringServerFull="The game does not have enough openings for all the players on your console."		// DO NOT MERGE INTO XBOX
}

class gbx_BrowseMatchLan extends gbx_BrowseMatchBase
	abstract;

var gbx_BrowseMatchQuery		ServerListQuery;


function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);
	OnYButtonEvent = OnYButton;

	ServerListQuery = PlayerOwner().Spawn(class'gbx_BrowseMatchQuery');
	ServerListQuery.OnListChanged = ListChanged;

	ListChanged();
}

event Free()
{
	if (ServerListQuery != None)
	{
		ServerListQuery.Destroy();
		ServerListQuery = None;
	}

	Super.Free();
}

event Opened(GUIComponent Sender)
{
	Super.Opened(Sender);

	ServerListQuery.EnableBroadcast(true);
}

event OpenedChild(GUIPage child)
{
	Super.OpenedChild(child);

	ServerListQuery.EnableBroadcast(false);
}

function AddServerForBeacon(int index, string text)
{
	local ServerInfo server;

	ParseToken(text);	// ###
	server.HostName = ParseToken(text);
	server.GameType = ParseToken(text);
	server.MapFilename = ParseToken(text);
	server.NumPlayers = int(ParseToken(text));
	server.MaxPlayers = int(ParseToken(text));
	server.IsPasswordProtected = false;
	server.ContextID = index;

	if (!ShouldFilterServer(server))
	{
		server.MapName = class'Gameplay.gbxMPMissionList'.Static.FindMissionName(server.MapFilename);
		BrowserList.AddServer( server );
	}
}

function ListChanged()
{
	local int i, c, newIndex;
	local InternetLink.IpAddr CurrentAddr;

	GUILog("gbx_BrowseMatchLan::ListChanged");

	// get the current list selection
	newIndex = 0;
	if (BrowserList.Index != -1)
	{
		CurrentAddr = ServerListQuery.GetBeaconAddr(BrowserList.ServerList[BrowserList.Index].ContextID);
	}

	// rebuild the list
	Clear();

	c = ServerListQuery.GetUsedBeaconCount();
	for (i=0; i<c; i++)
	{
		AddServerForBeacon(i, ServerListQuery.GetBeaconText(i));
		if (CurrentAddr == ServerListQuery.GetBeaconAddr(i))
			newIndex = i;
	}

	// select the old selection
	if (BrowserList.SetIndex(newIndex) == -1)
		BrowserList.SetIndex(0);

	if (BrowserList.ItemCount > 0)
		SetupAButton(stringJoin);
	else
		SetupAButton();
}

function OnYButton();

function OnJoinGame(ServerInfo server);


defaultproperties
{
	YCaption="Create"
}
class gbx_BrowseMatchLanPC extends gbx_BrowseMatchLan;

var localized string		StringStatus;

var ServerInfo ServerToJoin;


function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);
}

function OnYButton()
{
	Controller.PlayClickSound(EClickSound.CS_Click);

	if (bSkirmishBrowser)
		LaunchSkirmish(Controller,2,"SystemLink");
	else
		Controller.OpenMenu("GUI.gbx_CreateMatchLanPC");
}

function string GetExtraJoinParams()
{
	return "?SystemLink";
}

static function PreloadMenu(GUIController C)
{
	Super.PreloadMenu(C);

	C.PreloadMenu("GUI.gbx_CreateMatchLanPC");
}

function OnJoinGame(ServerInfo server)
{
	ServerToJoin = server;
	GotoState('JoiningServer');
}

state JoiningServer
{
	function BeginState()
    {
		GUILog("BrowseGameLan:JoiningServer::BeginState");
		lblTextPrompt.SetCaption(StringStatus);

		SetupAButton();
		SetupBButton();
		SetupXButton();
		SetupYButton();

		KillTimer();
		SetTimer(0.5, false);
	}

	function Timer()
	{
		local string serverConnectString;
		local string hostName;
		local string mutList;       //added for mutator support JER

		mutList = class'Gameplay.gbxMutatorList'.static.GetActiveMutatorListString();   //Added for MP mutator support JER

		hostName = ServerToJoin.HostName;
		ReplaceText(hostName, " ", "_");

		serverConnectString = ServerListQuery.GetBeaconAddress(ServerToJoin.ContextID);
	    serverConnectString = serverConnectString $"?HostName=" $ hostName $ "?Game=" $ ServerToJoin.GameType $GetExtraJoinParams();

		GUILog("gbx_BrowseMatchLanPC:JoiningServer:Timer: addr=" $ ServerListQuery.GetBeaconAddress(ServerToJoin.ContextID) $ " game=" $ ServerToJoin.GameType);
	    PlayerOwner().ClientTravel( serverConnectString, TRAVEL_Absolute, false );

		Controller.CloseAll(false);
	}
}


defaultproperties
{
	ScreenTitle="Lan Matches"
	StringBrowsePrompt="Searching for Local Area Network Matches..."
	bShowProfileLabels=false
	StringServerFull="The game does not have enough openings."
	StringStatus="Joining LAN game.  Please wait..."

	Begin Object class=GUIMultiColumnListBox Name=cLanBrowser
		WinWidth=0.9
		WinHeight=0.54
		WinLeft=0.05
		WinTop=0.17
        bVisibleWhenEmpty=true
		DefaultListClass="GUI.gbx_BrowserMultiColumnListLan"
	End Object
    Browser=cLanBrowser
}
class gbx_BrowseMatchQuery extends ClientBeaconReceiver
	notplaceable;

var bool			bBroadcastDisabled;

delegate OnListChanged();

function Destroyed()
{
	Super.Destroyed();
	
	OnListChanged = None;
}

function Timer()
{
	if (bBroadcastDisabled)
		return;

	Super.Timer();

	if (bListIsDirty)
	{
		OnListChanged();
	}

	bListIsDirty = false;
}

function EnableBroadcast(bool bEnable)
{
	bBroadcastDisabled = !bEnable;
	log("gbx_BrowseMatchQuery: bBroadcastDisabled=" $bBroadcastDisabled, 'guilog');
}

function int GetUsedBeaconCount()
{
	local int x;
	local int usedCount;
	
	usedCount = 0;
	for (x = 0;x < GetBeaconCount();x++)
	{
		if (GetBeaconText(x) == "")
		{
			break;
		}
		
		usedCount++;
	}
    
    return usedCount;
}

function IpAddr GetBeaconAddr(int index)
{
	return Beacons[index].Addr;
}

defaultproperties
{
}
class gbx_BrowseMatchSysLink extends gbx_BrowseMatchLan;

var float							PingTimeOut;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	BrowserList.EnableQualityColumn(false);
}

function BrowserOnOpen()
{
	Super.BrowserOnOpen();

	PingTimeOut = PlayerOwner().Level.UniversalTimeSeconds + class'gbx_BrowseMatchBase'.default.DefaultPingTimeout;
	SetTimer(1.0, true);
}

function BrowserOnClose(optional Bool bCancelled)
{
	Super.BrowserOnClose(bCancelled);

	PingTimeOut = 0.0;
	KillTimer();
}

function Timer()
{
	if (PlayerOwner().Level.UniversalTimeSeconds > PingTimeOut)
	{
		PingTimeOut = 0.0;
		KillTimer();

		if (BrowserList.ServerList.Length == 0)
		{
			Controller.ReplaceMenu("GUI.gbx_LiveQueryNoResults","GUI.gbx_CreateMatchSysLink");
		}
	}
}

function OnYButton()
{
	Controller.PlayClickSound(EClickSound.CS_Click);
	Controller.OpenMenu("GUI.gbx_CreateMatchSysLink");
}

function bool VerifyJoinGame(ServerInfo server)
{
	if (!Super.VerifyJoinGame(server))
		return false;

	// check for the split-client case
	if (class'gbx_ProfileManager'.Static.ControllerProfileExists(self, 1))
	{
		if (server.MaxPlayers - server.NumPlayers < 2)
		{
			PromptServerFull(server);
			return false;
		}
	}

	return true;
}


function OnJoinGame(ServerInfo server)
{
	// add the split if controller 2 has a profile
	if (class'gbx_ProfileManager'.Static.ControllerProfileExists(self, 1))
	{
		class'gbx_ProfileManager'.Static.SetupProfiles(self);
	}

	// wire up the controllers
	Controller.ApplyControllersToViewports();

	Super.OnJoinGame(server);
}

static function PreloadMenu(GUIController C)
{
	Super.PreloadMenu(C);

	C.PreloadMenu("GUI.gbx_LiveQueryNoResults");
	C.PreloadMenu("GUI.gbx_CreateMatchSysLink");
}

defaultproperties
{
	ScreenTitle="System Link Matches"
	StringBrowsePrompt="Searching for System Link Matches..."
	bRequireLink=true
	bPortLockedOnly=true
	PingTimeOut=0.0
}
class gbx_BrowserMultiColumnList extends gbx_BrowserMultiColumnListBase;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.Initcomponent(MyController, MyOwner);
}

function DrawMatchItem(Canvas Canvas, int i, float X, float Y, float W, float H, bool bSelected)
{
	local float CellLeft, CellWidth;
	local eMenuState drawState;

	if (i == -1)
	{
		GetCellLeftWidth( 0, CellLeft, CellWidth );
		SelStyle.Draw(Canvas,MSAT_Pressed, X+CellLeft, Y, CellWidth, H );

		GetCellLeftWidth( 1, CellLeft, CellWidth );
		SelStyle.Draw(Canvas,MSAT_Pressed, X+CellLeft, Y, CellWidth, H );

		GetCellLeftWidth( 2, CellLeft, CellWidth );
		SelStyle.Draw(Canvas,MSAT_Pressed, X+CellLeft, Y, CellWidth, H );

		GetCellLeftWidth( 3, CellLeft, CellWidth );
		SelStyle.Draw(Canvas,MSAT_Pressed, X+CellLeft, Y, CellWidth, H );

		GetCellLeftWidth( 4, CellLeft, CellWidth );
		SelStyle.Draw(Canvas,MSAT_Pressed, X+CellLeft, Y, CellWidth, H );
	}
	else
	{
		drawState = MSAT_Blurry;

		// Draw the selection border
		if( bSelected )
		{
			class'GUI.gbx_ScreenABXY'.Static.DrawTheThinRedLine(Controller, Canvas, -5, Y+H, X+W+5);
			drawState = MSAT_Focused;
		}

	//		SelStyle.Draw(Canvas,MSAT_Pressed, X, Y-2, W, H+2 );

		GetCellLeftWidth( 0, CellLeft, CellWidth, true );
		Style.DrawTextToFit( Canvas, drawState, X+CellLeft, Y, CellWidth, H, TXTA_Center, ServerList[SortData[i].SortItem].HostName );

		GetCellLeftWidth( 1, CellLeft, CellWidth, true );
		Style.DrawTextToFit( Canvas, drawState, X+CellLeft, Y, CellWidth, H, TXTA_Center, ServerList[SortData[i].SortItem].MapName );

		GetCellLeftWidth( 2, CellLeft, CellWidth, true );
		Style.DrawTextToFit( Canvas, drawState, X+CellLeft, Y, CellWidth, H, TXTA_Center, "" $ ServerList[SortData[i].SortItem].NumPlayers $ "/" $ ServerList[SortData[i].SortItem].MaxPlayers );

		GetCellLeftWidth( 3, CellLeft, CellWidth, true );
                //###+ lbouchard : PING : PC Ping Implementation
		Style.DrawTextToFit( Canvas, drawState, X+CellLeft, Y, CellWidth, H, TXTA_Center, class'gbx_InternetQueryBase'.Static.GetPingString( ServerList[SortData[i].SortItem].Ping ) );
                //###-

		GetCellLeftWidth( 4, CellLeft, CellWidth, true );
		if(ServerList[SortData[i].SortItem].IsPasswordProtected)
			Style.DrawText( Canvas, drawState, X+CellLeft, Y, CellWidth, H, TXTA_Center, class'gbx_ScreenABXY'.default.stringYes );
		else
			Style.DrawText( Canvas, drawState, X+CellLeft, Y, CellWidth, H, TXTA_Center, class'gbx_ScreenABXY'.default.stringNo );
	}
}

function string GetSortString( int i )
{
	switch(SortColumn)
	{
	case 0:
		return ServerList[i].HostName; break;
	case 1:
		return ServerList[i].MapName; break;
	case 2:
		return "" $(ServerList[i].MaxPlayers - ServerList[i].NumPlayers); break;
	case 3:
		return "" $ class'gbx_InternetQueryBase'.Static.GetPingString( ServerList[i].Ping ); break;
		break;
	case 4:
		if(ServerList[i].IsPasswordProtected)
			return class'gbx_ScreenABXY'.default.stringYes;
		else
			return class'gbx_ScreenABXY'.default.stringNo; 
		break;
	}

	return ServerList[SortData[i].SortItem].HostName;
}

function EnableQualityColumn(bool bEnable)
{
	local int i;
	local float extra;

	if (bEnable)
	{
		for (i=0; i<InitColumnPerc.Length; i++)
		{
			InitColumnPerc[i] = default.InitColumnPerc[i];
		}
	}
	else
	{
		extra = default.InitColumnPerc[3] / 3.0;
		InitColumnPerc[3] = 0.0;

		for (i=0; i < 3; i++)
		{
			InitColumnPerc[i] = default.InitColumnPerc[i] + extra;
		}
	}

	bInitialised=false;
}

defaultproperties
{
	ColumnHeadings(0)="Session"
	ColumnHeadings(1)="Mission"
	ColumnHeadings(2)="Size"
	ColumnHeadings(3)="Quality"
	ColumnHeadings(4)="Pass"

	InitColumnPerc(0)=0.37
	InitColumnPerc(1)=0.27
	InitColumnPerc(2)=0.10
	InitColumnPerc(3)=0.15
	InitColumnPerc(4)=0.11

	SortColumn=0
	SortDescending=False
}class gbx_BrowserMultiColumnListBase extends GUIMultiColumnList;

var()	array<gbx_ScreenABXY.ServerInfo>	ServerList;
var		GUIStyles							SelStyle;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	OnDrawItem	= DrawMatchItem;

	Super.Initcomponent(MyController, MyOwner);
	SelStyle = Controller.GetStyle("SquareBar");
}

function AddServer(out gbx_ScreenABXY.ServerInfo server)
{
	local int j;

	j = ServerList.Length;
    ServerList.Length = j+1;

	ServerList[j] = server;

	AddedItem();
	if (ServerList.Length == 1)
		SetIndex(0);
}

function UpdateServer(out gbx_ScreenABXY.ServerInfo server)
{
	local int i;

	for (i=0; i<ServerList.Length; i++)
	{
		if (ServerList[i].ContextID == server.ContextID)
		{
			ServerList[i] = server;
			return;
		}
	}

	AddServer(server);
}

function Clear()
{
	ServerList.Length = 0;
	ItemCount = 0;
	Super.Clear();
}

function DrawMatchItem(Canvas Canvas, int i, float X, float Y, float W, float H, bool bSelected);
function EnableQualityColumn(bool bEnable);


defaultproperties
{
	StyleName="MenuOptionLabel"
}class gbx_BrowserMultiColumnListLan extends gbx_BrowserMultiColumnListBase;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.Initcomponent(MyController, MyOwner);
}

function DrawMatchItem(Canvas Canvas, int i, float X, float Y, float W, float H, bool bSelected)
{
	local float CellLeft, CellWidth;
	local eMenuState drawState;

	if (i == -1)
	{
		GetCellLeftWidth( 0, CellLeft, CellWidth );
		SelStyle.Draw(Canvas,MSAT_Pressed, X+CellLeft, Y, CellWidth, H );

		GetCellLeftWidth( 1, CellLeft, CellWidth );
		SelStyle.Draw(Canvas,MSAT_Pressed, X+CellLeft, Y, CellWidth, H );

		GetCellLeftWidth( 2, CellLeft, CellWidth );
		SelStyle.Draw(Canvas,MSAT_Pressed, X+CellLeft, Y, CellWidth, H );
	}
	else
	{
		drawState = MSAT_Blurry;

		// Draw the selection border
		if( bSelected )
		{
			class'GUI.gbx_ScreenABXY'.Static.DrawTheThinRedLine(Controller, Canvas, -5, Y+H, X+W+5);
			drawState = MSAT_Focused;
		}

	//		SelStyle.Draw(Canvas,MSAT_Pressed, X, Y-2, W, H+2 );

		GetCellLeftWidth( 0, CellLeft, CellWidth, true );
		Style.DrawTextToFit( Canvas, drawState, X+CellLeft, Y, CellWidth, H, TXTA_Center, ServerList[SortData[i].SortItem].HostName );

		GetCellLeftWidth( 1, CellLeft, CellWidth, true );
		Style.DrawTextToFit( Canvas, drawState, X+CellLeft, Y, CellWidth, H, TXTA_Center, ServerList[SortData[i].SortItem].MapName );

		GetCellLeftWidth( 2, CellLeft, CellWidth, true );
		Style.DrawTextToFit( Canvas, drawState, X+CellLeft, Y, CellWidth, H, TXTA_Center, "" $ ServerList[SortData[i].SortItem].NumPlayers $ "/" $ ServerList[SortData[i].SortItem].MaxPlayers );
	}
}

function string GetSortString( int i )
{
	switch(SortColumn)
	{
	case 0:
		return ServerList[i].HostName; break;
	case 1:
		return ServerList[i].MapName; break;
	case 2:
		return "" $(ServerList[i].MaxPlayers - ServerList[i].NumPlayers); break;
	}

	return ServerList[SortData[i].SortItem].HostName;
}

defaultproperties
{
	StyleName="MenuOptionLabel"
	ColumnHeadings(0)="Session"
	ColumnHeadings(1)="Mission"
	ColumnHeadings(2)="Size"

	InitColumnPerc(0)=0.4
	InitColumnPerc(1)=0.4
	InitColumnPerc(2)=0.2

	SortColumn=0
	SortDescending=False
}class gbx_ControllerConfigPCList extends GUIMultiColumnList;

struct PCListItem
{
	var string Cmd;
	var string Bind1;
	var string Bind2;
};

var		array<PCListItem>					BindingList;
var		GUIStyles							SelStyle;
var		bool								bInBindMode;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	OnDrawItem	= DrawItem;

	Super.Initcomponent(MyController, MyOwner);
	SelStyle = Controller.GetStyle("SquareBar");
}

function AddBinding(string cmd, string bind1, string bind2)
{
	local int j;

	j = BindingList.Length;
    BindingList.Length = j+1;

	BindingList[j].Cmd = cmd;
	BindingList[j].Bind1 = bind1;
	BindingList[j].Bind2 = bind2;

	AddedItem();
	if (BindingList.Length == 1)
		SetIndex(0);
}

function Clear()
{
	BindingList.Length = 0;
	ItemCount = 0;
	Super.Clear();
}

function DrawItem(Canvas Canvas, int i, float X, float Y, float W, float H, bool bSelected)
{
	local float CellLeft, CellWidth;
	local eMenuState drawState;
	local EComponentPulseStyle pStyle;

	if (i == -1)
	{
		GetCellLeftWidth( 0, CellLeft, CellWidth );
		SelStyle.Draw(Canvas,MSAT_Pressed, X+CellLeft, Y, CellWidth, H );

		GetCellLeftWidth( 1, CellLeft, CellWidth );
		SelStyle.Draw(Canvas,MSAT_Pressed, X+CellLeft, Y, CellWidth, H );

		GetCellLeftWidth( 2, CellLeft, CellWidth );
		SelStyle.Draw(Canvas,MSAT_Pressed, X+CellLeft, Y, CellWidth, H );
	}
	else
	{
		drawState = MSAT_Blurry;
		pStyle = CPS_None;

		// Draw the selection border
		if( bSelected )
		{
			if (Controller.FocusedControl == self)
				class'GUI.gbx_ScreenABXY'.Static.DrawTheThinRedLine(Controller, Canvas, -5, Y+H, X+W+5);

			drawState = MSAT_Focused;

			if (bInBindMode)
				pStyle = CPS_Slow;
		}

		GetCellLeftWidth( 0, CellLeft, CellWidth, true );
		Style.DrawTextToFit( Canvas, drawState, X+CellLeft, Y, CellWidth, H, TXTA_Center, BindingList[SortData[i].SortItem].Cmd, pStyle );

		GetCellLeftWidth( 1, CellLeft, CellWidth, true );
		Style.DrawTextToFit( Canvas, drawState, X+CellLeft, Y, CellWidth, H, TXTA_Center, BindingList[SortData[i].SortItem].Bind1, pStyle );

		GetCellLeftWidth( 2, CellLeft, CellWidth, true );
		Style.DrawTextToFit( Canvas, drawState, X+CellLeft, Y, CellWidth, H, TXTA_Center, BindingList[SortData[i].SortItem].Bind2, pStyle );
	}
}

function string GetSortString( int i ) { return ""; }

defaultproperties
{
	StyleName="MenuOptionLabel"
	ColumnHeadings(0)="Command"
	ColumnHeadings(1)="Primary"
	ColumnHeadings(2)="Secondary"

	InitColumnPerc(0)=0.4
	InitColumnPerc(1)=0.3
	InitColumnPerc(2)=0.3

	SortColumn=-1
	SortDescending=False
}
class gbx_CreateMatchBase extends gbx_MissionChooser
	Abstract;

var localized array<string>			PlayersSelectList;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);
}

function Set4PModeOnly(out moSpinListControl spn)
{
	spn.SetIndex(1);
	spn.EnableControl(false);
}

function int GetMaxPlayers(int index)
{
	switch(index)
	{
	case 0: return 2; break;
	case 1: return 4; break;
	}
}

function string BuildLaunchString()
{
	return spnMissionSelect.GetExtra() $"?game=gbxGameplay.WargameMultiplayer?Listen";
}
//###+ lbouchard : Added extra argument
function Launch(optional string LaunchStringExtra)
{
	local string URL;
	local string mutList;  //adding MP mutator support JER

	mutList = class'Gameplay.gbxMutatorList'.static.GetActiveMutatorListString();

	URL = BuildLaunchString()$LaunchStringExtra$mutList;

	GUILog("Launching MP Game : " $URL);
	PlayerOwner().ClientTravel( URL, TRAVEL_Absolute, false );

	Controller.CloseAll(false);
}
//###-

defaultproperties
{
	PlayersSelectList=("2 Players","4 Players");

	ACaption="Begin Match"
}

class gbx_CreateMatchLanPC extends gbx_CreateMatchBase;

var moSpinListControl				spnPlayers;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);
	OnAButtonEvent = OnAccept;

	spnPlayers = moSpinListControl(MyComponents[1]);
	spnPlayers.AddFromList(PlayersSelectList);
	spnPlayers.SetIndex(1);
}

function string BuildLaunchString()
{
	return Super.BuildLaunchString() $ "?SystemLink" $ "?maxplayers=" $GetMaxPlayers(spnPlayers.GetIndex());
}

function OnAccept()
{
	Launch();
}

defaultproperties
{
	MyComponents(1)=cSpinMenuOptionV
	MyCaptions(1)="Players"

	ScreenTitle="Create Lan Match"
	bShowProfileLabels=false
}

class gbx_CreateMatchSplitScreen extends gbx_CreateMatchBase;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);
	OnAButtonEvent = OnAccept;
}

function OnAccept()
{
	if (Controller.bIsConsole)
	{
		class'gbx_ProfileManager'.Static.SetupProfiles(self);
	}

	// wire up the controllers
	Controller.ApplyControllersToViewports();

	Launch();
}

function string BuildLaunchString()
{
	return Super.BuildLaunchString() $ "?MaxPlayers=2?SplitScreen";
}

defaultproperties
{
	ScreenTitle="Create Split Screen Match"

}

class gbx_CreateMatchSysLink extends gbx_CreateMatchBase;

var moSpinListControl				spnPlayers;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);
	OnAButtonEvent = OnAccept;

	spnPlayers = moSpinListControl(MyComponents[1]);
	spnPlayers.AddFromList(PlayersSelectList);

	// default to 4 players
	spnPlayers.SetIndex(1);

	if (Controller.bIsConsole)
	{
		if (class'gbx_ProfileManager'.Static.ControllerProfileExists(self, 1))
			Set4PModeOnly(spnPlayers);
	}

	// TODO PARIS REMOVEME
	if (PlayerOwner().bIsDemo)
	{
		Set4PModeOnly(spnPlayers);
	}
}

function string BuildLaunchString()
{
	return Super.BuildLaunchString() $ "?SystemLink" $ "?maxplayers=" $GetMaxPlayers(spnPlayers.GetIndex());
}

function OnAccept()
{
	// create a split if two controllers set up
	if (Controller.bIsConsole)
	{
		if (class'gbx_ProfileManager'.Static.ControllerProfileExists(self, 1))
		{
			class'gbx_ProfileManager'.Static.SetupProfiles(self);
		}

		// wire up the controllers
		Controller.ApplyControllersToViewports();
	}

	Launch();
}

defaultproperties
{
	MyComponents(1)=cSpinMenuOptionV

	MyCaptions(1)="Players"

	ScreenTitle="Create System Link Match"
	bRequireLink=true
	bPortLockedOnly=true
}
//gbxCustomMapScreen.uc
//This Class builds the Custom Map menu used to load custom single player maps JER

class gbx_CustomMapScreen extends gbx_MenuLayoutScreen;

var moSpinListControl				spnMissionSelectSP;
var automated gbx_SPMissionDisplay	SPMissionDisplay;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	spnMissionSelectSP = moSpinListControl(MyComponents[0]);
	spnMissionSelectSP.OnChange = MissionChanged;
	FillMissionList(spnMissionSelectSP, true);
	onAButtonEvent = Launch;
	onXButtonEvent = OpenMutatorMenu;

}

function OpenMutatorMenu()
{
    Controller.OpenMenu("GUI.gbx_MenuMutator");
}


function Launch()
{
    if(class'Gameplay.gbxSPMissionList'.Static.GetMissionCount() != 0)
    {
        Controller.PlayClickSound(EClickSound.CS_Click);
        Controller.OpenMenu("GUI.gbx_SPChooseDifficulty", class'Gameplay.gbxSPMissionList'.Static.GetMap(spnMissionSelectSP.GetIndex()));
    }
}

static function FillMissionList(moSpinListControl spinctrl, optional bool bClear)
{
	local int i, c;
	if (bClear)
		spinctrl.Clear();

	c = class'Gameplay.gbxSPMissionList'.Static.GetMissionCount();
	for (i=0; i<c; i++)
	{
		spinctrl.Add(class'Gameplay.gbxSPMissionList'.Static.GetMissionName(i, true),, class'Gameplay.gbxSPMissionList'.Static.GetMap(i));
	}
}

function MissionChanged(GUIComponent Sender)
{
	SPMissionDisplay.SetMission( spnMissionSelectSP.GetIndex() );
}

function ChooseMap(string mapFileName)
{
	local int index;
	index = class'Gameplay.gbxSPMissionList'.Static.FindMapIndex( mapFileName );
	if (index != -1)
		spnMissionSelectSP.SetIndex(index);
}

static function PreloadMenu(GUIController C)
{
	local int i, count;
	local Texture t;
	Super.PreloadMenu(C);

	count = class'Gameplay.gbxSPMissionList'.Static.GetMissionCount();
	for (i=0; i<count; i++)
	{
		t = Texture(C.DynamicLoadObject(class'Gameplay.gbxSPMissionList'.static.GetMissionImageName(i),class'Texture'));
	}
}

defaultproperties
{
	LayoutPivotPoint=0.18
	LayoutSpacing=0.02
	LayoutPivotStyle=LA_Left_Top
	ACaption = "Select Map"
	XCaption = "Mutators"

	Begin Object Class=gbx_SPMissionDisplay Name=cSPMissionDisplay
		WinWidth=0.450
		WinHeight=0.580000
		WinLeft=0.500000
	End Object
	SPMissionDisplay=cSPMissionDisplay

	MyComponents(0)=cSpinMenuOptionV
	MyCaptions(0)="Mission"
}
class gbx_DlgConnectError extends gbx_ScreenQuestion;
// Param2: <eScreenQuestionType> <eScreenPromptType>

var string ErrorCode;
var localized string StringLiveError;
var localized string StringSysLinkError;
var           string storedParam2;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);
	
	SetTextPrompt( "" );
	
	SetupAButton(StringContinue);
	OnAnswer = MyAnswer;
	storedParam2="";
}

event HandleParameters(string Param1, string Param2)
{
	local string ErrorMessage;
	local string UbiComRawTag;
	
	Super.HandleParameters(Param1, Param2);

	storedParam2 = Param2;
	ErrorCode = Param1;
	UbiComRawTag = "UBICOMRAWMESSAGE:";
	
	
	if (Left(Param1,Len(UbiComRawTag)) != UbiComRawTag)
	{
		ErrorMessage = Class'Engine.gbxNetworkErrors'.Static.GetErrorMessageForErrorCode(ErrorCode);
	}
	else
	{
		ErrorMessage = Right(Param1,Len(Param1) - Len(UbiComRawTag));
	}
	
	GUILog("gbx_DlgConnectError::SetErrorMessage(): ErrorCode = " $ ErrorCode);	
	GUILog("gbx_DlgConnectError::SetErrorMessage(): ErrorMessage = " $ ErrorMessage);
	
	SetTextPrompt( ErrorMessage );

	if (Controller.bIsConsole)
	{
		if (Controller.LiveFunc.IsLiveMode())
			SetCaption(StringLiveError);
		else if (Controller.LiveFunc.IsSystemLinkMode())
			SetCaption(StringSysLinkError);
	}

	class'GameService.GameService'.static.LeaveServer();
}

function bool MyAnswer(string answer)
{
	if (!PlayerOwner().Level.IsMenuMap())
	{
		Disconnect(true);
		Controller.CloseAll(false);
	}
	else if (ParentPage==None && Controller.MenuStack.Length == 1)
	{
	    Controller.ReplaceMenu("GUI.gbx_MenuMain", storedParam2);
    }

	return true;
}

defaultproperties
{
    ScreenTitle="Attention"
	StringLiveError="Xbox Live"
	StringSysLinkError="System Link"


	QuestionType=SQT_CUSTOM
	PromptType=SPT_None

	bAllowedAsLast=true
	bRequireFullScreen=true
	bTopMost=1
	
	ErrorCode=""
}
class gbx_DlgControllerLost extends gbx_ScreenQuestion;

var bool			bPausedGame;
var bool			bForceStart;
var int 			iDeferredControllerLoss;

var int				LostControllerIndex;	// port of controller actually lost
// Param2: <eScreenQuestionType> <eScreenPromptType>

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	Controller.LoadPlayerControllerBindings();
	Controller.DebouncePlayerControllers();

	OnClose = InternalOnClose;
}

function CheckPauseGame()
{
	if (!PlayerOwner().Level.IsMenuMap())
	{
		if (PlayerOwner().Level.Pauser == None)
		{
			bPausedGame = true;
			PlayerOwner().SetPause(true);
		}
	}
}

function bool ShouldSuppressScreen(int index)
{
	local int i;

	for (i=0; i<Controller.MenuStack.Length; i++)
	{
		if (Controller.MenuStack[i] == self)
			continue;

		if ((gbx_DlgControllerLost(Controller.MenuStack[i]) != None) && (gbx_DlgControllerLost(Controller.MenuStack[i]).LostControllerIndex == index))
			return true;
	}

	return false;
}

event HandleParameters(string Param1, string Param2)
{
	Super.HandleParameters(Param1, Param2);

	LostControllerIndex = int(Param1);

	if (ShouldSuppressScreen(LostControllerIndex))
	{
		Controller.CloseMenu(false);
		return;
	}

	if (gbx_ScreenABXY(ParentPage) != None) 
		gbx_ScreenABXY(ParentPage).HandleLossErrors(LostControllerIndex, false, false);

	if (PlayerOwner().Level.NetMode == NM_Standalone)
		CheckPauseGame();

	if (LostControllerIndex == -1)
	{
		SetTextPrompt( Controller.LiveFunc.LocalizedError("WARNING_LOST_CONTROLLER_ANY") );
	}
	else
	{
		SetTextPrompt( Controller.LiveFunc.LocalizedError("WARNING_LOST_CONTROLLER_START") );
		bForceStart=true;
		ReplacePromptText("%d", String(LostControllerIndex+1));
	}

	if (LostControllerIndex != -1)
		SetTimer(0.1,true);
}

event Timer()
{
    if( Controller.LiveFunc.IsControllerConnected(LostControllerIndex) )
    {
        GUILog("Controller was reconnected, pause=" $bPausedGame);
        SetTimer(0, false);
        if( !bForceStart )
        {
            Controller.CloseMenu(false);
        }
    }
}

function InternalOnClose(optional Bool bCancelled)
{
	if (bPausedGame)
		PlayerOwner().SetPause(false);
}

function bool SAB_OnXControllerEvent(byte Id, eXControllerCodes iCode)
{
	if (((LostControllerIndex == -1) || (Id == LostControllerIndex)) && (iCode == XC_Start))
	{
		Controller.CloseMenu(false);
		return true;
	}

	return Super.SAB_OnXControllerEvent(Id, iCode);
}

function bool ShouldShowControllerInfo(int inPlayerIndex)
{
	return false;
}

static function bool TestLostController(gbx_ScreenABXY me, int iControllerId, optional bool bNotBound)
{
	local bool bIsLostNow;

	if (iControllerId == -1)
		return false;

	if (me.Controller.ControllerIdInUse[iControllerId] == 0)
		return false;

	bIsLostNow = false;
	if (me.Controller.ViewportOwner.Actor.Level.IsMenuMap())
	{
		if (!me.Controller.LiveFunc.IsControllerConnected(iControllerId))
			bIsLostNow = true;
	}
	else
	{
		if (me.Controller.LiveFunc.IsControllerLost(iControllerId))
			bIsLostNow = true;
	}
/*
	if (bIsLostNow)
	{
		if (me.Controller.MenuIsOpen("GUI.gbx_DlgControllerLost"))
		{
			me.Controller.ControllerIdInUse[iControllerId] = 0;
			return true;
		}
	}
*/	
	if (me.bDeferControllerLoss)
	{
		if (default.iDeferredControllerLoss == -1)
		{
			if (bIsLostNow)
			{
				me.GUILog( "gbx_DlgControllerLost deferring loss for ControllerIndex=" $iControllerId );
				default.iDeferredControllerLoss = iControllerId;
				return false;
			}
		}

		if (default.iDeferredControllerLoss == iControllerId)
		{
			if (!bIsLostNow)
			{
				me.GUILog( "gbx_DlgControllerLost resetting deferred loss for ControllerIndex=" $iControllerId );
				default.iDeferredControllerLoss = -1;
				return false;
			}
		}

		return false;
	}

	if (default.iDeferredControllerLoss != -1)
	{
		me.GUILog( "gbx_DlgControllerLost invoking deferred loss for ControllerIndex=" $iControllerId );
		iControllerId = default.iDeferredControllerLoss;
		default.iDeferredControllerLoss = -1;
	}
	else if (!bIsLostNow || (me.Controller.ControllerIdInUse[iControllerId] == 0))
	{
		return false;
	}

	me.Controller.ControllerIdInUse[iControllerId] = 0;
	me.GUILog( "gbx_DlgControllerLost invoked for ControllerIndex=" $iControllerId );

	if (bNotBound)
		me.Controller.OpenMenu("GUI.gbx_DlgControllerLost", "-1");
	else
		me.Controller.OpenMenu("GUI.gbx_DlgControllerLost", String(iControllerId));

	return true;
}

//function TestLinkLiveLoss(optional bool bOpened);

defaultproperties
{
    ScreenTitle="Controller Lost"

	QuestionType=SQT_CUSTOM
	PromptType=SPT_None

	bAllowedAsLast=true
	bRequireFullScreen=true
	bMergeAStart=false
	iDeferredControllerLoss=-1

	bTopMost=127
}
class gbx_DlgCorruptContent extends gbx_ScreenQuestion;

var bool					bCorruptProfile;

var localized string		StringTextPromptPC;

static function bool VerifyProfile(GUIComponent me, string vProfileName, optional bool bShowProfileMgr)
{
	if (!class'Engine.GameProfile'.Static.VerifyProfile(me.PlayerOwner().Level, vProfileName))
	{
		if (bShowProfileMgr)
		{
			class'gbx_ProfileManager'.Static.SetProfileForController(me, 0, "");
			me.Controller.OpenMenu("GUI.gbx_ProfileManager");

			// the hack of hacks!  If we think "Player" is damaged, just silently go to the profile mgr.
			// this happens if the system\user.ini is out of synch with the real profiles in the user folder.
			if (vProfileName ~= "Player")
				return false;
		}

		me.Controller.OpenMenu("GUI.gbx_DlgCorruptContent","PROFILE=" $vProfileName);

		return false;
	}

	return true;
}

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

//	OnAnswer = MyAnswer;
}

event HandleParameters(string Param1, string Param2)
{
	Super.HandleParameters(Param1, Param2);

	GUILog("Warning corrupt content found! (" $Param1 $")");

	if (ParseCommand(Param1, "PROFILE="))
	{
		bCorruptProfile = true;
	}

	if (Controller.bIsConsole)
		SetTextPrompt(Controller.LiveFunc.LocalizedError("ERROR_CORRUPT_CONTENT"));
	else
		SetTextPrompt(StringTextPromptPC);

	ReplacePromptText("%s", Param1);
}

function bool MyAnswer(string answer)
{
	if (bCorruptProfile && (PagePlayerIndex == 0))
	{
		Controller.ReplaceMenu("GUI.gbx_ProfileManager");
		return false;
	}

	return true;
}

defaultproperties
{
	ScreenTitle="ATTENTION"
	StringTextPromptPC="%s appears to be damaged and cannot be used."

	QuestionType=SQT_CONTINUE
	PromptType=SPT_None
}
class gbx_DlgFileLimit extends gbx_ScreenQuestion;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	SetTextPrompt( Controller.LiveFunc.LocalizedError("WARNING_MAX_PROFILES") );
	OnAnswer = MyAnswer;
}

event HandleParameters(string Param1, string Param2)
{
	Super.HandleParameters(Param1, Param2);
}

function bool MyAnswer(string answer)
{
	return true;
}

static function bool VerifyProfileSpace(GUIcomponent me, optional string strReplaceMenu)
{
    if ( bool(me.ConsoleCommand("LOADSAVE REACHED_PROFILE_LIMIT DEVICE=0")) )
    {
		if (strReplaceMenu != "")
			me.Controller.ReplaceMenu(strReplaceMenu);

		me.Controller.OpenMenu("GUI.gbx_DlgFileLimit");
        return false;
    }

	return true;
}


defaultproperties
{
	ScreenTitle="Attention"

	QuestionType=SQT_OK
	PromptType=SPT_None
}
class gbx_DlgLinkLost extends gbx_ScreenQuestion;
// Param2: <eScreenQuestionType> <eScreenPromptType>

var bool bCanDismiss;		// controls whether this error can be dismissed without disconnecting if the link returns

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	local string S;
	Super.InitComponent(MyController, MyOwner);

	Controller.LoadPlayerControllerBindings();
	Controller.DebouncePlayerControllers();

	if (Controller.bNoLinkLost || ShouldSuppressScreen())
	{
		Controller.CloseMenu(false);
		return;
	}

// lost connection message
//	S = Controller.LiveFunc.LocalizedError("WARNING_LOST_LINK");
	S = class'GameService.GameServiceError'.static.GetErrorMessage(6, 0); 
	bCanDismiss = true;

	if ((PlayerOwner().Level.NetMode == NM_Standalone) && PlayerOwner().Level.IsMenuMap())
		SetupAButton(StringOk);
	else
		SetupAButton(StringQuit);

	SetTextPrompt( S );
    SetTimer(0.1,true);
	OnAnswer = MyAnswer;

	GUILog("gbx_DlgLinkLost: bCanDismiss=" $String(bCanDismiss));
}

function bool ShouldSuppressScreen()
{
	local int i;

	for (i=0; i<Controller.MenuStack.Length; i++)
	{
		if (Controller.MenuStack[i] == self)
			continue;

		if ((gbx_DlgLinkLost(Controller.MenuStack[i]) != None) || (gbx_LiveErrorMessage(Controller.MenuStack[i]) != None))
			return true;
	}

	return false;
}

function bool MyAnswer(string answer)
{

//###+ lbouchard : LINKLOSS : Link loss detection is only enabled on MP menus, so if it happens, we always disconnect
    Disconnect();
    return true;
//###-

/*### lbouchard : LINKLOSS 
    if( (PlayerOwner().Level.NetMode == NM_Standalone) && PlayerOwner().Level.IsMenuMap() )
    {
		// do nothing here; the screens handle closing themselves if they require a link
		return true;
    }
    else
    {
		Disconnect(true);
		return true;
    }
*/
}

event Timer()
{
	if (bCanDismiss && Controller.LiveFunc.IsLinkActive())
	{
		Controller.CloseMenu(false);
	}
}

function TestLinkLiveLoss(optional bool bOpened)
{
//###+ lbouchard: We test link loss even on PC, for Ubi.com menus
if (Controller.ActivePage != self)
    return;

//oldcode	if (!Controller.bIsConsole || (Controller.ActivePage != self))
//oldcode		return;
//###-


	if (TestControllerLoss(bOpened))
		return;
}

defaultproperties
{
    ScreenTitle="Link Lost"

	QuestionType=SQT_CUSTOM
	PromptType=SPT_None

	bTopMost=1
	bAllowedAsLast=true
	bRequireFullScreen=true
}
class gbx_DlgLoadingProfiles extends gbx_ScreenExtendedWork;

// param1 : ["prompt string"] ["Screen Title"] [PromptWhenDone]
// param2 : [continue menu class]


function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	DoWork = OnWork;
}

function bool OnWork()
{
	PlayerOwner().Level.SaveGameGetManifest();
	return true;
}

defaultproperties
{
	StringAutoTextPrompt="Retrieving profile list..."
	bPromptWhenDone=false
	MinDisplayTime=0
}
class gbx_DlgLogoffToMenu extends gbx_DlgQuitToMenu;

function bool MyAnswer(string answer)
{
	if (answer == "YES")
	{
		Controller.PlayClickSound(EClickSound.CS_Click);

		if ( PlayerOwner().Level.NetMode == NM_DedicatedServer || 
			PlayerOwner().Level.NetMode == NM_ListenServer)
		{
			class'GameService.GameService'.static.UnRegisterServer();
			class'GameService.GameService'.static.SetIsServer(0);
		}
		else
		{
			class'GameService.GameService'.static.LeaveServer();
		}
        Disconnect(true);
		class'GameService.GameService'.static.LogOut();
		class'GameService.GameService'.static.DisableClientService();
		Controller.CloseAll(false);
	}

	return true;
}

defaultproperties
{
	QuestionType=SQT_YESNO
	PromptType=SPT_NONE

	StringPromptMPServer="Logging off Ubi.com now will end this session. Are you sure you want to leave?"
	StringPromptMPClient="You are about log off Ubi.com and leave the current game. Are you sure you want to leave?"
}
class gbx_DlgLowStorage extends gbx_ScreenQuestion;

var() int       				FreeSpace;
var() int       				SaveGameSpace;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);


	OnAnswer = MyAnswer;
}

event HandleParameters(string Param1, string Param2)
{
    local int neededSpace;

	Super.HandleParameters(Param1, Param2);

	CalcStorage(self, FreeSpace, SaveGameSpace);
    neededSpace = SaveGameSpace - FreeSpace;
    neededSpace = Max( neededSpace, 1 );

	if (Param1 ~= "NOCANCEL")
	{
		SetTextPrompt( Controller.LiveFunc.LocalizedError("WARNING_LOW_STORAGE") @ Controller.LiveFunc.LocalizedError("WARNING_LOW_STORAGE_A"));
		SetupBButton();
	}
	else
	{
		SetTextPrompt( Controller.LiveFunc.LocalizedError("WARNING_LOW_STORAGE") @ Controller.LiveFunc.LocalizedError("WARNING_LOW_STORAGE_AB"));
		SetupBButton(StringCancel);
	}

	ReplacePromptText("%d", string(neededSpace));
}

function bool MyAnswer(string answer)
{
	if (answer ~= "A")
	{
		Controller.OpenMenu("GUI.gbx_LiveDashboardConfirm","XLD_LAUNCH_DASHBOARD_MEMORY DRIVE=" $ConsoleCommand("LOADSAVE DRIVE_LETTER DEVICE=0") $" BLOCKS="$SaveGameSpace);
		return false;
	}

	return true;
}

static function CalcStorage(GUIcomponent me, out int free, out int needed)
{
	free = int(me.ConsoleCommand("LOADSAVE SPACE FREE DEVICE=0"));
	needed = int(me.ConsoleCommand("LOADSAVE SPACE PROFILE DEVICE=0"));
	needed += int(me.ConsoleCommand("LOADSAVE SPACE SAVEGAME DEVICE=0"));
}

static function bool VerifyProfileSpace(GUIcomponent me, optional string strReplaceMenu, optional bool bNoCancel)
{
    local int fSpace;
    local int sGameSpace;
	local GUIController C;

	if (!class'gbx_DlgFileLimit'.static.VerifyProfileSpace(me))
		return false;

	C = me.Controller;
	CalcStorage(me, fSpace, sGameSpace);

	if (fSpace < sGameSpace)
	{
		if (strReplaceMenu != "")
			C.ReplaceMenu(strReplaceMenu);

		if (bNoCancel)
			C.OpenMenu("GUI.gbx_DlgLowStorage","NOCANCEL");
		else
			C.OpenMenu("GUI.gbx_DlgLowStorage");
        return false;
	}

	return true;
}


defaultproperties
{
	ScreenTitle="Attention"
	ACaption="Free Blocks"

	QuestionType=SQT_Custom
	PromptType=SPT_None
}
class gbx_DlgMenuPressStart extends gbx_ScreenABXY;

var() Automated GUILabel				lblTextPrompt;
var() Automated GUIImage				imgLogo;

var bool								bCheckSilentSignin;
var bool								bFoundCrossTitleInvite;
var localized string					StringBegin;
var localized string					AttractModeVideo;
var float								fIdleTime;

const IDLE_TIMEOUT = 115.0;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	OnXControllerEvent=PressStartOnXController;
	OnCanClose = CanClose;

	// clear out disconnect class, just in case
	class'GameEngine'.default.DisconnectMenuClass = "";
	class'GameEngine'.default.DisconnectMenuArg = "";
	class'GameEngine'.static.StaticSaveConfig();

	class'gbx_ProfileManager'.Static.SetupCameraView(self);

	bCheckSilentSignin = Controller.LiveFunc.IsOffLine() && !Controller.LiveFunc.IsSigningIn();
	lblTextPrompt.SetCaption(StringBegin);

	fIdleTime = 0.0;
	SetTimer(0.25, true);
}

function bool CanClose(optional Bool bCancelled) {return false;}

function Timer()
{
	CheckForAttractMode();
}

function bool PressStartOnXController(byte Id, eXControllerCodes iCode)
{
	local string S;

	ResetIdle();
	if (iCode == XC_Start)
	{
		// verify our space if we have no profile
		if ((class'Engine.GameProfile'.Static.GetProfileCount(PlayerOwner().Level, false) == 0) && !class'gbx_DlgLowStorage'.static.VerifyProfileSpace(self, "GUI.gbx_ProfileManager", true))
			return true;

		// try silent signin if there's no pending x-title invite
		if (bCheckSilentSignin)
		{
			if (!class'gbx_LiveDlgAcceptCrossTitle'.static.CheckForCrossTitleInvite(self) && Controller.LiveFunc.IsOffLine() && !Controller.LiveFunc.IsSigningIn())
			{
				GUILog("Beginning silent Live Logon...");
				S = ConsoleCommand("XLIVE SILENT_LOGON");
				GUILog("... LOGON_SILENT returned " $S);
			}

			bCheckSilentSignin = false;
		}

		// launch the real menu
		Controller.ReplaceMenu(class'GameEngine'.default.MainMenuClass);
		return true;
	}

	return false;
}

function TestLinkLiveLoss(optional bool bOpened);

function bool ShouldShowControllerInfo(int index)
{
	return false;
}

// =======================================================================================================================================================
// Attract mode stuff
// =======================================================================================================================================================
function ResetIdle()
{
	fIdleTime = PlayerOwner().Level.UniversalTimeSeconds + IDLE_TIMEOUT;
}

function CheckForAttractMode()
{
	if (fIdleTime == 0.0)
	{
		ResetIdle();
	}
	else if (PlayerOwner().Level.UniversalTimeSeconds > fIdleTime)
	{
		fIdleTime = 0.0;
		GUILog("CheckForAttactMode: Launching" @AttractModeVideo);

		Controller.StopMusic();
		ConsoleCommand("PLAYMOVIE" @AttractModeVideo @"0 1 0 0 0 640 480");
		Controller.StartMusic();
	}
}

defaultproperties
{
	StringBegin="Please press START to begin"
	BCaption=""
	AttractModeVideo="..\\media\\attract_mode.bik"

	bAllowedAsLast=true
	bMergeAStart=false
	bCheckSilentSignin=false
	bFoundCrossTitleInvite=false

	Begin Object Class=GUILabel Name=cBeginPrompt
		StyleName="LargeButton"
		DrawMenuState=2
		TextAlign=TXTA_Center
		TextAlignV=TXTA_Center
		bAcceptsInput=false;
		bTabStop=false
		bDrawToFit=true
		WinWidth=0.900000
		WinHeight=0.10000
		WinLeft=0.050000
		WinTop=0.69000000
		pulseStyle=CPS_Slow
	End Object
	lblTextPrompt=cBeginPrompt

	Begin Object Class=GUIImage Name=cImgLogo
		Image=Texture't_interface_mb.GUI.biarh30_logo'
		ImageColor=(R=192,G=192,B=192,A=255)
		ImageStyle=ISTY_Scaled
		WinWidth=0.800000
		WinHeight=0.53
		WinLeft=0.1
		WinTop=0.16
	End Object
	imgLogo=cImgLogo
}
class gbx_DlgMissingMap extends gbx_ScreenQuestion;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

//	OnXButtonEvent = OnDownload;
}

event HandleParameters(string Param1, string Param2)
{
	Super.HandleParameters(Param1, Param2);

	ReplacePromptText("<MAPNAME>", MakeQuotedString(Param1));

	// put the XButton back
//	SetupXButton(XCaption);
}

static function bool PromptNeedMap(GUIComponent me, string mapFileName)
{
	if (class'Gameplay.gbxMPMissionList'.static.FindMapIndex(mapFileName) == -1)
	{
		me.Controller.OpenMenu("GUI.gbx_DlgMissingMap", mapFileName);
		return true;
	}

	return false;
}
/*
function OnDownload()
{
	Controller.PlayClickSound(EClickSound.CS_Change);
	Controller.OpenMenu("GUI.gbx_LiveDlgContentDownload");
}

static function PreloadMenu(GUIController C)
{
	Super.PreloadMenu(C);

	C.PreloadMenu("GUI.gbx_LiveDlgContentDownload");
}
*/

defaultproperties
{
	ScreenTitle="ATTENTION"
//	XCaption="Download"

//	StringAutoTextPrompt="You do not have the map <MAPNAME>.  Please select another session to join or download this map from Xbox Live."
	StringAutoTextPrompt="You do not have the map <MAPNAME>."

	QuestionType=SQT_BACK
	PromptType=SPT_None
}
class gbx_DlgMPRestartMission extends gbx_MenuLayoutScreen;


var Automated GUILabel				lblHeader;

var bool							bLoadCheckpoint;
var bool							bNeedsHelp;

var localized string 				StringPromptRestart;
var localized string 				StringPromptRestart_ch;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	OnAButtonEvent = OnAButton;
	bLoadCheckpoint = class'GameProfile'.static.ProfileHasCheckpoint(PlayerOwner().Level, true);

	if (bLoadCheckpoint)
	{
		bNeedsHelp = PlayerOwner().Level.MissionManager.SkirmishShouldHelpWithCheckpoint();
		lblHeader.SetCaption(StringPromptRestart_ch);
		SetupAButton(StringSelect);
		SetupBButton(StringBack);
	}
	else
	{
		lblHeader.SetCaption(StringPromptRestart @ class'gbx_ScreenQuestion'.default.StringAreYouSure);
		MyComponents[0].Hide();
		MyComponents[1].Hide();
		SetupAButton(StringYes);
		SetupBButton(StringNo);
	}

	// preserve the fade if we're in game-over state
	if (ParentPage.IsA('gbx_SkirmishGameOver'))
	{
		Background = ParentPage.Background;
		BackgroundColor = ParentPage.BackgroundColor;
		BackgroundRStyle = ParentPage.BackgroundRStyle;
		bHideParent = true;
	}
}

function bool OnComponentActivate(int button, GUIComponent Sender)
{
	if (!bLoadCheckpoint)
		return false;

	switch (button)
	{
		case 0:	//"Load Last Checkpoint"
			if (bNeedsHelp)
				Controller.ReplaceMenu("GUI.gbx_DlgPlayerHelp");
			else
				class'gbx_PopupMenuMPServer'.static.DoEndGame(Controller, true);

			return true;

		case 1:	//"Start from the Beginning"
			class'GameProfile'.static.ClearProfileCheckpoint(PlayerOwner().Level, true);
			class'gbx_PopupMenuMPServer'.static.DoEndGame(Controller, true);
			return true;
	}

	return false;
}

function OnAButton()
{
	if (bLoadCheckpoint)
		return;

	class'gbx_PopupMenuMPServer'.static.DoEndGame(Controller, true);
}

defaultproperties
{
	LayoutSpacing=0.01
	LayoutPivotPoint=0.65

	MyComponents(0)=cBtnOption
	MyComponents(1)=cBtnOption

	ScreenTitle="Restart Mission"
	MyCaptions(0)="Load Last Checkpoint"
	MyCaptions(1)="Start from the Beginning"

	bLoadCheckpoint=false;

	StringPromptRestart="You are about to restart the current mission."
	StringPromptRestart_ch="You are about to restart the current mission, but there is a saved checkpoint.  Would you like to start from the beginning or start from the last checkpoint?"

	Begin Object Class=GUILabel Name=cSMPRestartHeader
		StyleName="LargeButton"
		DrawMenuState=1
		TextAlign=TXTA_Center
		TextAlignV=TXTA_Right
		bMultiline=true
		bAcceptsInput=false
		bNeverFocus=true
		bTabStop=false
		WinWidth=0.900000
		WinHeight=0.36000
		WinLeft=0.050000
		WinTop=0.160000
	End Object
	lblHeader=cSMPRestartHeader

	bHideParent=false
	Background=Texture'WhiteTexture'
	BackgroundColor=(R=13,G=5,B=8,A=235)
	BackgroundRStyle=MSTY_Alpha
}
class gbx_DlgOkRestart extends gbx_ScreenQuestion;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	OnAnswer = MyAnswer;
}

function bool MyAnswer(string answer)
{
	return true;
}

defaultproperties
{
	QuestionType=SQT_OK
	PromptType=SPT_None
	StringAutoTextPrompt="Changes will not take effect until you restart the game."
}
class gbx_DlgPlayerHelp extends gbx_ScreenQuestion;

// Param2: <eScreenQuestionType> <eScreenPromptType>

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	SetButtonLayout(SBL_2Centered);
	OnAnswer = MyAnswer;
}

function bool MyAnswer(string answer)
{
	local GUIController C;
	local GameProfile gProfile;

	C = Controller;
	C.PlayClickSound(EClickSound.CS_Click);

	if (answer == "A")
	{
		gProfile = class'GameProfile'.Static.LoadCurrentGameProfile( PlayerOwner().Level );
		if (gProfile != None)
		{
			if (PlayerOwner().Level.Game.IsA('WargameSkirmish'))
			{
				gProfile.SkirmishHelpWithCheckpoint(PlayerOwner().Level);
				gProfile.SkirmishDisableCheckpointReload();
			}
			else
			{
				gProfile.HelpWithCheckpoint(PlayerOwner().Level);
				gProfile.DisableCheckpointReload();
			}

			PlayerOwner().Level.MissionManager.CacheGameProfile(gProfile);

			class'GameProfile'.Static.UnloadProfile( PlayerOwner().Level, gProfile, true );
		}
	}

	if (PlayerOwner().Level.Game.IsA('WargameSkirmish'))
		class'gbx_PopupMenuMPServer'.static.DoEndGame(Controller, true);
	else
		class'gbx_SPMissionFailed'.static.DoReload(PlayerOwner());

	C.CloseAll(false);

	return false;
}

defaultproperties
{
	QuestionType=SQT_CUSTOM
	PromptType=SPT_NONE

	ACaption="Heal then Reload"
	BCaption="Reload Checkpoint"
	StringAutoTextPrompt="War sometimes isn't fair, but a video game should be.  Would you like to heal your squad?"
}
class gbx_DlgQuitGame extends gbx_ScreenQuestion;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	OnAnswer = MyAnswer;
}

function bool MyAnswer(string answer)
{
	local PlayerController PC;
	
	if (answer == "YES")
	{
		if (Controller.bIsDemoVersion)
		{
			PC = PlayerOwner();
			
			if (PC.Level.GetLevelFileName() == "D08_1030_CLOSEQUARTERS")   
            {   
                    ConsoleCommand("DEMO_LEVEL_QUIT_CQ");   
            }   
            else if (PC.Level.GetLevelFileName() == "D15_1130_BOOKENDS")   
            {   
                    ConsoleCommand("DEMO_LEVEL_QUIT_INTRO");   
            }   
				
			PlayerOwner().Level.bMergeGamepadInput = true;	// hack to get bug 14904

			Controller.CloseAll(false);

			// for the demo, kick off the outro script which displays the upsell then quits the game.
			PC.TriggerEvent( 'outroscript', PC.Pawn, PC.Pawn );
			PC.MyHUD.bHideHUD = true;
		}
		else
		{
	        ConsoleCommand("quit");
			Controller.CloseAll(false);
		}
	}

	return true;
}

defaultproperties
{
	QuestionType=SQT_YESNO
	PromptType=SPT_None
	StringAutoTextPrompt="Are you sure you want to quit <TITLENAME>?"
}
class gbx_DlgQuitToMenu extends gbx_ScreenQuestion;

// Param2: <eScreenQuestionType> <eScreenPromptType>
var bool						bIsIntro;
var bool						bHasProfiles;
var bool						bSkipIntro;

var() localized string			StringPromptSkipIntro;
var() localized string			StringPromptSP;
var() localized string			StringPromptMPServer;
var() localized string			StringPromptMPClient;


function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	OnAnswer = MyAnswer;

	bIsIntro = PlayerOwner().Level.MissionManager.FindCurrentMission() == 0;
	bHasProfiles = class'Engine.GameProfile'.Static.GetProfileCount(PlayerOwner().Level, true) > 0;
}

event HandleParameters(string Param1, string Param2)
{
	Super.HandleParameters(Param1, Param2);

	bSkipIntro = bIsIntro && (!bHasProfiles || (Param1 ~= "SKIP"));

	if (bIsIntro)
	{
		PromptType=SPT_AREYOUSURE;

		if (bSkipIntro)
			SetTextPrompt(StringPromptSkipIntro);
		else
			SetTextPrompt(StringPromptSP);
	}
	else
	{
		switch (PlayerOwner().Level.NetMode)
		{
		case NM_ListenServer:
		case NM_DedicatedServer:
			PromptType=SPT_NONE;
			SetTextPrompt(StringPromptMPServer);
			break;

		case NM_Client:
			PromptType=SPT_NONE;
			SetTextPrompt(StringPromptMPClient);
			break;

		case NM_Standalone:
			PromptType=SPT_AREYOUSURE_PROGRESS;
			SetTextPrompt(StringPromptSP);
			break;
		}
	}
}

function bool MyAnswer(string answer)
{	
	if (answer == "YES")
	{
		Controller.PlayClickSound(EClickSound.CS_Click);

   
        if (Controller.bIsDemoVersion)   
        {   
			if (PlayerOwner().Level.GetLevelFileName() == "D08_1030_CLOSEQUARTERS")   
            {   
				ConsoleCommand("DEMO_LEVEL_QUIT_CQ");   
            }   
            else if (PlayerOwner().Level.GetLevelFileName() == "D15_1130_BOOKENDS")   
            {   
				ConsoleCommand("DEMO_LEVEL_QUIT_INTRO");   
            }   
        } 


		if ( PlayerOwner().Level.NetMode == NM_DedicatedServer || 
			PlayerOwner().Level.NetMode == NM_ListenServer)
		{
			class'GameService.GameService'.static.UnRegisterServer  ();
			class'GameService.GameService'.static.SetIsServer(0);
		}
		else
		{
			class'GameService.GameService'.static.LeaveServer();
		}

		if (bSkipIntro)
		{
			PlayerOwner().Level.MissionManager.MissionCompleted();
			PlayerOwner().Level.MissionManager.LoadSPMap("");
/*
// CEK:FIRSTBOOT
			if (!bHasProfiles)
			{
				class'GameEngine'.default.DisconnectMenuClass = class'GameEngine'.default.InitialMenuClass;
				class'GameEngine'.static.StaticSaveConfig();
				ConsoleCommand("disconnect");
			}
			else
			{
				PlayerOwner().Level.MissionManager.MissionCompleted();
				PlayerOwner().Level.MissionManager.LoadSPMap("");
			}
*/
		}
		else
		{
			Disconnect(true);
		}

		Controller.CloseAll(false);
	}

	return true;
}

function bool ShouldShowControllerInfo(int inPlayerIndex)
{
	if (bIsIntro && !bHasProfiles)
		return false;

	return Super.ShouldShowControllerInfo(inPlayerIndex);
}


defaultproperties
{
	QuestionType=SQT_YESNO
	PromptType=SPT_AREYOUSURE_PROGRESS

	StringPromptSkipIntro="You are about to skip the intro sequence."
	StringPromptSP="You are about to quit the chapter."
	StringPromptMPServer="Leaving the game now will end this session. Are you sure you want to leave?"
	StringPromptMPClient="You are about to leave the current game. Are you sure you want to leave?"
}
class gbx_DlgServerPlayAlone extends gbx_ScreenQuestion;

// Param2: <eScreenQuestionType> <eScreenPromptType>

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	/* TODO
    if( PC.IsSharingScreen() )
        Question.Text = Question.Text @ class'MenuStart'.default.StringGuestWillGoToo;

    Question.Text = Caps( Question.Text );
	*/

	// TODO: UC version also did some timer thing to verify the current gamer...
}

defaultproperties
{
	ScreenTitle="Attention"

	QuestionType=SQT_CONTINUE
	PromptType=SPT_None
	StringAutoTextPrompt="At least 2 players must be in the game and ready before it can begin."

	PagePlayerIndex=-3
}
class gbx_DlgSoldiersDied extends gbx_ScreenQuestion;

// Param2: <eScreenQuestionType> <eScreenPromptType>

var bool							bPerfectVictory;

var localized string				StringPerfectVictory;
var localized string				StringRevive;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	bPerfectVictory = !PlayerOwner().Level.MissionManager.DidSquadmateDie();
	if (bPerfectVictory)
	{
		SetupAButton(StringContinue);
		SetupBButton(StringBack);
		StringAutoTextPrompt = StringPerfectVictory;
	}
	else
	{
		SetupAButton(StringRevive);
		SetupBButton(class'gbx_SPMissionFailed'.default.StringRestart);
	}

	SetupXButton();
	SetButtonLayout(SBL_2Centered);
	OnAnswer = MyAnswer;
}

function bool MyAnswer(string answer)
{
	local GUIController C;
	local GameProfile	gProfile;

	C = Controller;

	if (answer == "A")
	{
		class'gbx_SPMissionBriefing'.static.DoNextMap(Controller);
	}
	else if (bPerfectVictory)
	{
		C.CloseMenu(false);
	}
	else
	{
		gProfile = class'GameProfile'.Static.LoadCurrentGameProfile( PlayerOwner().Level );
		if (gProfile != None)
		{
			PlayerOwner().Level.MissionManager.ClearCheckpointData( gProfile );
			class'GameProfile'.Static.UnloadProfile( PlayerOwner().Level, gProfile, true );
		}
		LoadSPMap(PlayerOwner().Level.GetLevelFileName(), int(PlayerOwner().Level.DifficultyManager.GetDifficulty()));
	}

	return false;
}

function bool SAB_OnXControllerEvent(byte Id, eXControllerCodes iCode)
{
	if (iCode == XC_Start)
	{
		Controller.PlayClickSound(EClickSound.CS_Back);
		Controller.OpenMenu(class'GameEngine'.default.PopupSPMenuClass);
		return true;
	}

	return Super.SAB_OnXControllerEvent(Id, iCode);
}

function bool SAB_KeyEvent(out byte Key,out byte State,float delta)
{
	if (Key == 27)	// IK_Escape, IST_Release
	{
		if (State == 3)
		{
			Controller.PlayClickSound(EClickSound.CS_Back);
			Controller.OpenMenu(class'GameEngine'.default.PopupSPMenuClass);
		}
		return true;
	}

	return Super.SAB_KeyEvent(Key, State, delta);
}

defaultproperties
{
	QuestionType=SQT_CUSTOM
	PromptType=SPT_NONE

	ACaption="Continue"
	BCaption="Back"
	StringRevive="Revive and Continue"

	StringAutoTextPrompt="Your victory was earned in blood...  You have lost a soldier who should have survived in Hartsocks story.  Would you like to revive the dead and continue Hartsocks story (no penalty)?"
	StringPerfectVictory="Perfect Victory!|You have accomplished your mission and your decisions prevented casualties.  You are commended!"

	bAllowedAsLast=true
	bMergeAStart=false
}
class gbx_DlgSPRestartMission extends gbx_ScreenQuestion;

// Param1: [CHECKPOINT|RESTART]

var bool bLoadCheckpoint;

var localized string StringPromptRestart;
var localized string StringPromptReload;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	OnAnswer = MyAnswer;
}

event HandleParameters(string Param1, string Param2)
{
	local GameProfile gProfile;
	local int LastMission, FirstIncomplete, LastDifficulty, SaveMissionDifficulty;
	local string SaveMissionName;
	
	Super.HandleParameters(Param1, Param2);

	if (Param1 ~= "CHECKPOINT")
	{
		// load the current profile's savegame and checkpoint data
		gProfile = class'GameProfile'.Static.LoadCurrentGameProfile( PlayerOwner().Level );
		if (gProfile != None)
		{
			LastMission = gProfile.LastMissionCompleted;
			LastDifficulty = gProfile.LastDifficultyCompleted;
			FirstIncomplete = gProfile.FindFirstIncompleteMission();
			SaveMissionName = gProfile.SaveMissionName;
			SaveMissionDifficulty = gProfile.SaveMissionDifficulty;
			class'GameProfile'.Static.UnloadProfile( PlayerOwner().Level, gProfile );

//			if ((PlayerOwner().Level.MissionManager.GetMissionName( LastMission ) == SaveMissionName) && (LastDifficulty == SaveMissionDifficulty))
			if (SaveMissionName != "")
			{
				bLoadCheckpoint = true;
			}
			else
			{
				bLoadCheckpoint = bool(ConsoleCommand("SAVEGAMEEXISTS 1"));
			}
		}
		else
		{
			bLoadCheckpoint = bool(ConsoleCommand("SAVEGAMEEXISTS 1"));
		}
	}

	if (bLoadCheckpoint)
	{
		SetTextPrompt(StringPromptReload);
	}
	else
	{
		SetTextPrompt(StringPromptRestart);
	}
}

function bool MyAnswer(string answer)
{
	local GameProfile	gProfile;
	local int LastMission, FirstIncomplete, LastDifficulty, SaveMissionDifficulty;
	local string SaveMissionName;

	log(self$".MyAnswer( "$answer$" ) - "$bLoadCheckpoint);			
	if (answer == "YES")
	{
		if (bLoadCheckpoint)
		{
			// load the current profile's savegame and checkpoint data
			gProfile = class'GameProfile'.Static.LoadCurrentGameProfile( PlayerOwner().Level );
			if (gProfile != None)
			{
				LastMission = gProfile.LastMissionCompleted;
				LastDifficulty = gProfile.LastDifficultyCompleted;
				FirstIncomplete = gProfile.FindFirstIncompleteMission();
				SaveMissionName = gProfile.SaveMissionName;
				SaveMissionDifficulty = gProfile.SaveMissionDifficulty;
				class'GameProfile'.Static.UnloadProfile( PlayerOwner().Level, gProfile );

//				if ( (PlayerOwner().Level.MissionManager.GetMissionName( LastMission ) == SaveMissionName) && (LastDifficulty == SaveMissionDifficulty))
				if (SaveMissionName != "")
				{
					LoadSPMap(SaveMissionName, SaveMissionDifficulty );
				}
				else
				{
					PlayerOwner().ClientTravel( "?load=1", TRAVEL_Absolute, false); 
				}
			}
			else
			{
				PlayerOwner().ClientTravel( "?load=1", TRAVEL_Absolute, false); 
			}
		}
		else
		{
			gProfile = class'GameProfile'.Static.LoadCurrentGameProfile( PlayerOwner().Level );
			if (gProfile != None)
			{
				PlayerOwner().Level.MissionManager.ClearCheckpointData( gProfile );
				class'GameProfile'.Static.UnloadProfile( PlayerOwner().Level, gProfile, true );
			}
			LoadSPMap(PlayerOwner().Level.GetLevelFileName(), int(PlayerOwner().Level.DifficultyManager.GetDifficulty()));
		}
	}

	return true;
}

defaultproperties
{
	bLoadCheckpoint=false;
	QuestionType=SQT_YESNO
	PromptType=SPT_AREYOUSURE_PROGRESS
//	StringAutoTextPrompt="You are about to restart the current chapter."

	StringPromptRestart="You are about to restart the current chapter."
	StringPromptReload="You are about to reload the last saved checkpoint."
}
class gbx_ExtrasCredits extends gbx_ScreenABXY;

defaultproperties
{
	ScreenTitle="Credits"
}
class gbx_ExtrasDisplayPicture extends gbx_ScreenABXY;

// param1: asset list
// <picture name>&[audio name],<picture name 2>&[audio name 2],...

struct ExtraPicture_s
{
	var string		TextureName;
	var string		AudioClipName;
	var string		CaptionText;
	var string		CalloutText;
};

var int									CurrentImage;
var array<ExtraPicture_s>				MyPictures;

const IMAGE_TWEEN_TIME = 1.0;
var float								FadeTime;
var automated GUIImage					MyImageFront;
var automated GUIImage					MyImageBack;
//var automated GUILabel					lblCaption;
var automated GUIScrollText				lblCaption;
var automated GUIScrollTextBox			txtCaptionBox;
var int									ilblFadeMode;	// -1: out; 0: done; 1: in

// audio play management
var bool								bHasSoundClips;
var float								ClipFinishTime;
var int									iClipSoundId;

var localized string					strPlayAudio;
var localized string					strStopAudio;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	OnClose = ScreenOnClose;
	OnAButtonEvent = NextImage;
	OnYButtonEvent = PrevImage;
	OnXButtonEvent = AudioControl;

	MyImageFront.Image = Controller.GUITexturePool.AllocRenderMaterial();
	MyImageBack.Image = Controller.GUITexturePool.AllocRenderMaterial();

	txtCaptionBox.MyScrollText.SetStyle("MenuOptionLabel");
	//lblCaption.MyScrollText.SetStyle("MenuOptionLabel");

	// RSC: move the buttons down
	hbtnA.SetTop(0.84);
	hbtnB.SetTop(0.84);
	hbtnX.SetTop(0.84);
	hbtnY.SetTop(0.84);

	SetTimer(0.1, true);
}

function ScreenOnClose(optional Bool bCancelled)
{
	local int i;

	StopClip();

	Controller.GUITexturePool.FreeRenderMaterial(MyImageFront.Image);
	Controller.GUITexturePool.FreeRenderMaterial(MyImageBack.Image);
	for (i=0; i<MyPictures.Length; i++)
	{
		Controller.GUITexturePool.MarkAsUnneeded(MyPictures[i].TextureName);
	}

	// if we stopped the music, restart it
	Controller.StartMusic();
}

function ParseAssetEntry(string strIn)
{
	local string s, texName, soundName, captionText, calloutText;
	GUILog("-Parsing : " $s);

	s = ParseTokenDelimited(strIn, "?");
	while(s != "")
	{
		if (ParseCommand(s, "IMG="))
			texName = s;
		else if (ParseCommand(s, "SND="))
			soundName = s;
		else if (ParseCommand(s, "TEXT="))
			captionText = s;
		else if (ParseCommand(s, "CALL="))
			calloutText = s;
		else
			GUILog("--Unknown token parsing " $s);

		s = ParseTokenDelimited(strIn, "?");
	}

	if (texName != "")
	{
		AddPicture(texName, soundName, captionText, calloutText);
	}
	else
	{
		GUILog("--Found no TEXT= entry in string; skipping.");
	}
}

event HandleParameters(string Param1, string Param2)
{
	local string s;//, TextureName;

	Super.HandleParameters(Param1, Param2);

	if (Param1 == "")
	{
		GUILog("Warning: invalid parameters to gbx_ExtrasDisplayPicture");
		return;
	}

	GUILog("----------------------------------------------------");
	GUILog("gbx_ExtrasDisplayPicture parsing params");
    s = ParseTokenDelimited(Param1, ",");
    while( s != "" )
    {
		ParseAssetEntry(s);
		s = ParseTokenDelimited(Param1, ",");
	}

	GUILog("----------------------------------------------------");

	if (MyPictures.Length < 2)
	{
		SetupAButton();
		SetupYButton();
	}

	// if we have sound, stop the menu music!
	if (bHasSoundClips)
	{
		Controller.StopMusic();
	}

	SelectImage(0);
}

function bool ShouldShowControllerInfo(int index)
{
	return false;
}

function bool ScreenOnPreDraw(Canvas C)
{
	ImageTween();
	return Super.ScreenOnPreDraw(C);	// still do the other stuff
}

function bool ScreenOnDrawPre(Canvas C)
{
	return false;	// short-circuit abxy behavior
}

function string LoadCaption(string keyString, string defaultResult)
{
	local string s;
	if (keyString == "")
		return "";

	s = Localize( "Captions", keyString, "Extras" );
	if ((s == "") || (Left(s, 2) ~= "<?"))
		s = defaultResult;

	return s;
}

function int AddPicture(string TextureName, string AudioName, string captionText, string calloutText)
{
	local int i, j;
	local string s;
	local PlayerController PC;
	local string subtitleText;

	GUILog("---Adding : Picture=" $MakeQuotedString(TextureName) $", Audio=" $MakeQuotedString(AudioName) $", Caption=" $MakeQuotedString(captionText) $", Callout=" $MakeQuotedString(calloutText));

	if (Left(TextureName,1) == "#")
		ReplaceText(TextureName, "#", "t_extras.Extras.");

	i = MyPictures.Length;
	MyPictures.Length = i+1;
	MyPictures[i].TextureName = TextureName;
	MyPictures[i].CalloutText = "";
	MyPictures[i].CaptionText = LoadCaption( captionText, "<"$captionText$">" );
	MyPictures[i].AudioClipName = AudioName;

	if (AudioName != "")
	{
		// if subtitles are enabled, try to load the subtitle
		PC = PlayerOwner().Level.GetLocalPlayerController();
		if( !PC.bDisableSubtitles ) 
		{
			subtitleText = captionText $ "_capt";
			s = LoadCaption( subTitleText, "" );
			if (s != "")
			{
				MyPictures[i].CaptionText = s;
			}
		}

		bHasSoundClips = true;
	}

	if (calloutText != "")
	{
		MyPictures[i].CalloutText = LoadCaption( calloutText, "<"$calloutText$">" );

		for (j=1; j<5; j++)
		{
			s = LoadCaption(calloutText$j, "");
			if (s != "")
				MyPictures[i].CalloutText = MyPictures[i].CalloutText $ s;
			else
				break;
		}
	}
	
	return i;
}

function SelectImage(int index)
{
	// if we're still fading, put the current texture to the back image
	if (FadeTime != 0)
		Controller.GUITexturePool.GetTexture(MyImageBack.Image, MyPictures[CurrentImage].TextureName);

	StopClip();

	// put the new image in the front slot, start the tween timer
	Controller.GUITexturePool.GetTexture(MyImageFront.Image, MyPictures[index].TextureName);
	MyImageFront.ImageColor.A = 0;
	ilblFadeMode = -1;
	FadeTime = PlayerOwner().Level.UniversalTimeSeconds + IMAGE_TWEEN_TIME;
	txtCaptionBox.SetContent("");

	CurrentImage = index;
	SetupAudioControl(true);
}

// =======================================================================================================================================================
// Image control related
// =======================================================================================================================================================
function NextImage()
{
	local int i;

	Controller.PlayClickSound(EClickSound.CS_Click);

	i = CurrentImage+1;
	if( i >= MyPictures.Length )
		i = 0;

	if( txtCaptionBox.MyScrollBar.bVisible )
		txtCaptionBox.MyScrollBar.UpdateGripPosition( 0 );

	SelectImage(i);
}

function PrevImage()
{
	local int i;

	Controller.PlayClickSound(EClickSound.CS_Click);

	i = CurrentImage-1;
	if (i < 0)
		i = MyPictures.Length-1;

	SelectImage(i);
}

function ImageTween()
{
	local float timeNow, alpha;

	timeNow = PlayerOwner().Level.UniversalTimeSeconds;
	if (FadeTime != 0)
	{
		if (FadeTime < timeNow)
		{
			// done tweening, copy to the back
			Controller.GUITexturePool.GetTexture(MyImageBack.Image, MyPictures[CurrentImage].TextureName);
			MyImageBack.ImageColor.A = 255;
			MyImageFront.ImageColor.A = 255;
			//lblCaption.TextColor.A = 255;

			ilblFadeMode = 0;
			FadeTime = 0;

			StartClip(MyPictures[CurrentImage].AudioClipName);
		}
		else
		{
			alpha = Lerp( 1.0 - ((FadeTime - timeNow) / IMAGE_TWEEN_TIME), 0, 255);
			MyImageFront.ImageColor.A = alpha;

			if (ilblFadeMode < 0)
			{
				// fade out the old caption by the time the image fades half-way in
				if (alpha > 128)
				{
					txtCaptionBox.SetContent(MyPictures[CurrentImage].CalloutText);
					lblCaption.SetContent(MyPictures[CurrentImage].CaptionText);
					//lblCaption.SetCaption(MyPictures[CurrentImage].CaptionText);
					//lblCaption.TextColor.A = 0;
					ilblFadeMode = 1;
				}
				else
				{
					//lblCaption.TextColor.A = (127-alpha)*2;
				}
			}
			else if (ilblFadeMode > 0)
			{
				// fade in the new caption in the time the new image fades the rest of the way in
				//lblCaption.TextColor.A = (alpha-127)*2;
			}
		}
	}
}

// =======================================================================================================================================================
// Audio control related
// =======================================================================================================================================================
function AudioControl()
{
	Controller.PlayClickSound(EClickSound.CS_Click);

	if (iClipSoundID != default.iClipSoundID)
		StopClip();
	else
		StartClip(MyPictures[CurrentImage].AudioClipName);
}

function StopClip()
{
	if (iClipSoundId != default.iClipSoundID)
	{
		PlayerOwner().StopMusic(iClipSoundId, 0.5);
		iClipSoundId = default.iClipSoundID;

		SetupAudioControl();
	}

	ClipFinishTime = 0.0;
}

function StartClip(string clipName)
{
	local float duration;

	StopClip();

	if ( Len(clipName) > 0 )
	{
		iClipSoundId = PlayerOwner().PlayMusic(clipName, 0.0, duration, false);
	
		// add a small delay as any hitch in framerate can cause sounds to take a tad longer than they are supposed to
		ClipFinishTime = PlayerOwner().Level.UniversalTimeSeconds + PlayerOwner().GetMusicDuration(clipName, iClipSoundId) + 0.5;

		SetupAudioControl();
	}
}

function SetupAudioControl(optional bool bDisable)
{
	if (bDisable)
		SetupXButton();
	else if (iClipSoundID != default.iClipSoundID)
		SetupXButton(strStopAudio);
	else if (Len(MyPictures[CurrentImage].AudioClipName) > 0)
		SetupXButton(strPlayAudio);
	else
		SetupXButton();
}

function Timer()
{
	if (iClipSoundId != default.iClipSoundID)
	{
		if (PlayerOwner().Level.UniversalTimeSeconds > ClipFinishTime)
		{
			iClipSoundId = default.iClipSoundID;

			SetupAudioControl();

			ClipFinishTime = 0.0;
		}
	}
}

defaultproperties
{
	Background=Texture'WhiteTexture'
	BackgroundColor=(R=0,G=0,B=0,A=255)
	ACaption="View Next"
	YCaption="View Prev"
	strPlayAudio="Play Audio"
	strStopAudio="Stop Audio"

	
	Begin Object Class=GUIImage Name=cExtraImageFront
		ImageColor=(R=255,G=255,B=255,A=0)
		ImageStyle=ISTY_Scaled
		ImageAlign=IMGA_Center
		WinLeft=0.20
		WinTop=0.075
		WinHeight=0.59		// RSC: changed from 0.6
		WinWidth=0.59		// RSC: changed from 0.6
		RenderWeight=0.4
	End Object
	MyImageFront=cExtraImageFront

	Begin Object Class=GUIImage Name=cExtraImageBack
		ImageColor=(R=255,G=255,B=255,A=0)
		ImageStyle=ISTY_Scaled
		ImageAlign=IMGA_Center
		WinLeft=0.20
		WinTop=0.075
		WinHeight=0.59		// RSC: changed from 0.6
		WinWidth=0.59		// RSC: changed from 0.6
		RenderWeight=0.35
	End Object
	MyImageBack=cExtraImageBack

	Begin Object Class=GUIScrollTextBox Name=ctxtCaptionBox
		WinLeft=0.52
		WinTop=0.075
		WinHeight=0.59		// RSC: changed from 0.6
		WinWidth=0.33
		RenderWeight=0.45
		InitialDelay=0.0
		CharDelay=0
		EOLDelay=0.075
		bNoTeletype=true
		bNoTeletypeCursor=true
		bNeverFocus=false
		bAcceptsInput=true
		bTabStop=true
	End Object
	txtCaptionBox=ctxtCaptionBox

	Begin Object Class=GUIScrollText Name=clblCaption
		StyleName="MenuOptionLabel"
		TextAlign=TXTA_Left
		WinLeft=0.1
		WinTop=0.67			// RSC: changed from 0.68
		WinHeight=0.175		// RSC: changed from 0.13
		WinWidth=0.9
		RenderWeight=0.40
		InitialDelay=0.0
		CharDelay=0.035
		EOLDelay=0.5
		RepeatDelay=8.0
		bNoTeletype=false
		bAcceptsInput=false
		bTabStop=false
		bNoTeletypeCursor=true
		bNeverFocus=true
		bRepeat=true
	End Object
	lblCaption=clblCaption

	//Begin Object Class=GUILabel Name=clblCaption
	//	StyleName="MenuOptionLabel"
	//	DrawMenuState=1
	//	bUseTextColorForStyle=true
	//	TextColor=(R=221,G=211,B=193,A=255)
	//	TextAlign=TXTA_Center
	//	TextAlignV=TXTA_Center
	//	bAcceptsInput=false
	//	bMultiline=true
	//	bTabStop=false
	//	bClientBounded=false
	//	WinLeft=0.05
	//	WinTop=0.67			// RSC: changed from 0.68
	//	WinHeight=0.175		// RSC: changed from 0.13
	//	WinWidth=0.9
	//End Object
	//lblCaption=clblCaption

	CurrentImage=-1
	ilblFadeMode=0
//	iClipSoundID=-1
	iClipSoundID=0
}
class gbx_ExtrasDisplayVideo extends gbx_ScreenABXY;

struct ExtraVideo_s
{
	var string	VideoName;
	var BOOL	IsCaptioned;
};

var ExtraVideo_s		Video;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);
}

//
// RSC: load the video from a variable
//
function string LoadVideo( string keyString )
{
	local string s;
	if( keyString == "" )
		return "";

	s = Localize( "Videos", keyString, "Extras" );
	//s = GetConfigString( keyString, "Descriptions", "Extras" );
	if( s == "" ) {
		s = "<" @ keyString @ ">";
	}

	// look for a caption file if it exists

	return s;
}

//
// RSC: added to parse video entry in extras menu
//
function string ParseVideoEntry( string strIn )
{
	local string strOut;

	if( ParseCommand( strIn, "VID=" ) ) {
		strOut = LoadVideo( strIn );
		return strOut;
	}

	return strIn;	// just return the string we were given if the VID= keystring was not in it.
}

event HandleParameters( string Param1, string Param2 )
{
	local string s;

	Super.HandleParameters(Param1, Param2);

	GUILog( "-------------------------------------------------------------" );
	GUILog( "gbx_ExtrasDisplayVideo" );

	s = ParseVideoEntry( Param1 );
	if( s == "" ) {
		return;
	}

	Video.VideoName = s;

	GUILog( "-------------------------------------------------------------" );

	SetTimer(0.25, true);
}

function Timer()
{
        //DLEVY 1/9/04 --change so will check for PlayerController.bDisableSubtitles option
	local PlayerController PC;
	PC = PlayerOwner().Level.GetLocalPlayerController();
	Controller.StopMusic();
	if( PC.bDisableSubtitles && PlayerOwner().GetLanguage() ~= "int" )	// RSC: only allow disable of subtitles for english version
	{
		ConsoleCommand("PLAYMOVIE" @Video.VideoName @"0 1 0 0 0 640 480" );

		// note you can use the built-in HUD movie player to play a scaled movie using the command below
		// but movie must be power of two in size or it wont play
		//    PC.myHud.PlayMovieScaledDirect("E3BiADemo512.bik", 0, 0, 1, 1, false, false, false);

	}
	else
	{
		ConsoleCommand("PLAYMOVIECAPTIONED" @Video.VideoName @"0 1 0 0 0 640 480" );
	}	
	Controller.StartMusic();

	Controller.CloseMenu(false);
}

function bool ScreenOnDrawPre(Canvas C)
{
	return false;	// short-circuit abxy behavior
}

function bool ShouldShowControllerInfo(int index)
{
	return false;
}

defaultproperties
{
	Background=Texture'WhiteTexture'
	BackgroundColor=(R=0,G=0,B=0,A=255)
	BCaption=""
}
// ====================================================================
//  (c) 2002, Epic Games, Inc.  All Rights Reserved
// ====================================================================

class gbx_fntCaption extends GUIFont;


defaultproperties
{
	KeyName="gbx_CaptionFont"
	FontArrayNames=("t_gbxfonts.WargameFont")
	FontBlurName="t_gbxfonts.WargameFont"
	ScaleX=1.1
	ScaleY=1.15
	bFixedSize=true

	ShadowOfsX=1.0
	ShadowOfsY=2.0
}
// ====================================================================
//  (c) 2002, Epic Games, Inc.  All Rights Reserved
// ====================================================================

class gbx_fntHeader extends GUIFont;


defaultproperties
{
	KeyName="gbx_HeaderFont"
	FontArrayNames=("t_gbxfonts.WargameFont")
	ScaleX=2.0
	ScaleY=2.0
	bFixedSize=true
}
// ====================================================================
//  (c) 2002, Epic Games, Inc.  All Rights Reserved
// ====================================================================

class gbx_fntHelpButton extends GUIFont;


defaultproperties
{
	KeyName="gbx_HelpButtonFont"
	FontArrayNames=("t_gbxfonts.WargameFont")
	FontBlurName="t_gbxfonts.WargameFont"
	ScaleX=0.80
	ScaleY=0.85
	bFixedSize=true

	ShadowOfsX=1.0
	ShadowOfsY=2.0
}
// ====================================================================
//  (c) 2002, Epic Games, Inc.  All Rights Reserved
// ====================================================================

class gbx_fntMainButton extends GUIFont;


defaultproperties
{
	KeyName="gbx_MainButtonFont"
	FontArrayNames=("t_gbxfonts.WargameFont2")
	FontBlurName="t_gbxfonts.WargameFont2_Blur"
	ScaleX=1.45
	ScaleY=1.45
	bFixedSize=true

	ShadowOfsX=0.0
	ShadowOfsY=2.0
}
class gbx_GameTimeline extends GUIPanel
		Config(storyline);

const CI_Width = 29;		// width, height of a chapter icon button
const CI_Height = 17;
const CI_Spacing = 27;

const Segment_Height = 12;
const Tick_Width = 2;

enum EndCapStyle
{
	ECS_None,
	ECS_Cap,
	ECS_Tick,
};

struct TimelineSegment
{
	var array<int>					Chapters;					// one of the chapters in gbxMissionMan, index into TimeLineChapters
	var EndCapStyle					capLeft, capRight;
	var int							DayOffset;

	var float						fLeft, fWidth;
	var GUILabel					DayLabel;
};

struct TimelineChapter
{
	var int									MapListIndex;
	var gbxMissionMan.EChapterIconStyle		ChapterIconStyle;
	var int									SegmentIndex;
	var GUIImage							ChapterIcon;
};

var config array<TimelineSegment>	TimeLineSegments;
var array<TimelineChapter>			TimeLineChapters;
var localized string				strDayFormatDDay;
var localized string				strDayFormatDay;

var config int						CI_Padding;			// space between adjacent chapter icons
var config int						Bar_Spacing;		// space between adjacent timeline bars
var int								HighlightedSegment;

	// timeline bar segments ------------------------------------------------------------------------------
var color							SegmentColorNormal;
var color							SegmentColorHi;

	// chapter icons ------------------------------------------------------------------------------
var Canvas.CanvasIcon				ChapterIcons[7];
enum EChapterIcon
{
	CI_Gold,
	CI_Silver,
	CI_Bronze,
	CI_Iron,
	CI_Empty,
	CI_Film,
	CI_Film_Empty,
};

	// selection marker ------------------------------------------------------------------------------
var Canvas.CanvasIcon				SelectionIcon;
var string							stySelectionLabelName;
var GUIStyles						stySelectionLabel;

var bool							bNonInteractive,		// no selection cursor
									bCycleUnplayedChapters;	// can unplayed chapters be selected?
var int								TimelineSelection, WantSelection;
var string							SelectionDate;
var float							fSelectionX,
									fSelectionY, 
									fCurrentX,
									fLerpX;
var float							SelectionLerpStartTime;
const SELECTOR_LERP_TIME = 0.25;


	// background ------------------------------------------------------------------------------
var automated GUIImage				imgBackground[3];
var GUIFRect						imgBackgroundPositions[3];
var Canvas.CanvasIcon				BackgroundIcon[3];


var bool							bDidPreDraw;

	// callbacks ------------------------------------------------------------------------------
delegate OnChapterIconDblClicked(int Index);

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	local int i, j, k;
	local bool bHasDisabledChapters;
	Super.Initcomponent(MyController, MyOwner);

	OnPreDraw = TimeLinePreDraw;
	OnDraw = TimeLineDraw;

	stySelectionLabel = Controller.GetStyle(stySelectionLabelName);

	if (!bNonInteractive)
	{
		OnKeyEvent = TimelineKeyEvent;
		OnXControllerEvent=TimelineXControllerEvent;
	}

	for (i=0; i<3; i++)
	{
		if (imgBackground[i] != None)
		{
			imgBackground[i].SetWinDims(imgBackgroundPositions[i]);
			imgBackground[i].SetFromIcon(BackgroundIcon[i]);
		}
	}

	OnClick = ChapterIconClick;
	OnDblClick = ChapterIconDblClick;

	GUILog("Timeline segments :" @TimeLineSegments.Length);
	for (i=0; i<TimeLineSegments.Length; i++)
	{
		GUILog("--- Segment" @i @":" @TimeLineSegments[i].Chapters.Length @"chapters");
		TimeLineSegments[i].DayLabel = ConstructSegmentLabel();

		for (j=0; j<TimeLineSegments[i].Chapters.Length; j++)
		{
			GUILog("------- Chapter" @j @":" @TimeLineSegments[i].Chapters[j]);
			k = TimeLineChapters.Length;
			TimeLineChapters.Length = k+1;

			TimeLineChapters[k].ChapterIcon = ConstructChapterIcon();
			TimeLineChapters[k].ChapterIcon.Hide();

			TimeLineChapters[k].MapListIndex = TimeLineSegments[i].Chapters[j];
			TimeLineChapters[k].SegmentIndex = i;
			TimeLineChapters[k].ChapterIconStyle = PlayerOwner().Level.MissionManager.Missions[TimeLineChapters[k].MapListIndex].Style;

			if (TimeLineChapters[k].ChapterIconStyle == ECIS_Disabled)
				bHasDisabledChapters = true;
		}
	}

	if (bHasDisabledChapters)
		bCycleUnplayedChapters = false;

	SetProfile(None);
	HiliteTimelineSegment(-1);
	SelectChapter(0, true);
}

function GUIImage ConstructChapterIcon()
{
	local GUIImage result;

	result = GUIImage(AddComponent("GUI.GUIImage"));

	result.ImageStyle=ISTY_Scaled;
	result.WinLeft=0;
	result.WinTop=0.5;
	result.WinHeight=0.2125;
	result.WinWidth=0.0453125;
	result.bBoundToParent=true;
	result.bScaleToParent=true;

	return result;
}

function GUILabel ConstructSegmentLabel()
{
	local GUILabel result;

	result = GUILabel(AddComponent("GUI.GUILabel"));

	result.SetStyle("TextLabel");
	result.TextAlign=TXTA_Center;
	result.DrawMenuState=2;
	result.bAcceptsInput=false;
	result.bNeverFocus=true;
	result.bTabStop=false;
	result.WinLeft=0;
	result.WinTop=0.7725;
	result.WinHeight=0.21;
	result.WinWidth=0.0421875;
	result.bBoundToParent=true;
	result.bScaleToParent=true;

	return result;
}

// =======================================================================================================================================================
// Drawing
// =======================================================================================================================================================
function bool TimeLinePreDraw(Canvas C)
{
	local int i, j;
	local float barLength, fLeft;
	local float diff;

	if (!bDidPreDraw)
	{
		for (i=1; i<3; i++)
		{
			if (imgBackground[i] != None)
			{
				imgBackground[i].SetLeft(imgBackground[i-1].ActualLeft() + imgBackground[i-1].ActualWidth());
			}
		}

		// calc total bar width (start to end)
		barLength = 0;
		for (i=0; i<TimeLineSegments.Length; i++)
		{
			// spacing between capped bar segments
			if ((i>0) && (TimeLineSegments[i].capLeft == ECS_Cap))
			{
				barLength += Bar_Spacing * Controller.CanvasScaleX;
			}

			barLength += TimeLineSegments[i].Chapters.Length * (CI_Spacing+CI_Padding+1) * Controller.CanvasScaleX;
		}

		fLeft = int(ActualLeft() + 0.5*(ActualWidth() - barLength));
		for (i=0; i<TimeLineSegments.Length; i++)
		{
			if ((i>0) && (TimeLineSegments[i].capLeft == ECS_Cap))
			{
				fLeft = int(fLeft + Bar_Spacing * Controller.CanvasScaleX);
			}

			TimeLineSegments[i].fLeft = fLeft;
			TimeLineSegments[i].fWidth = int(TimeLineSegments[i].Chapters.Length * (CI_Spacing+CI_Padding+1) * Controller.CanvasScaleX);
			fLeft = int(fLeft + TimeLineSegments[i].fWidth);
		}

		for (i=0; i<TimeLineSegments.Length; i++)
		{
			// align the chapter icons
			for (j=0; j<TimeLineSegments[i].Chapters.Length; j++)
			{
				if (j == 0)
				{
					fLeft = TimeLineSegments[i].fLeft + ((0.5*CI_Padding - 1)*Controller.CanvasScaleX);
				}
				else
				{
					fLeft += (CI_Spacing+CI_Padding) * Controller.CanvasScaleX;
				}

				TimeLineChapters[ TimeLineSegments[i].Chapters[j] ].ChapterIcon.SetLeft(fLeft);
			}

			// align the labels
			TimeLineSegments[i].DayLabel.SetLeft(TimeLineSegments[i].fLeft);
			TimeLineSegments[i].DayLabel.SetWidth(TimeLineSegments[i].fWidth);
			TimeLineSegments[i].DayLabel.SetCaption(FormatDayLabel(TimeLineSegments[i].DayOffset));
		}

		bDidPreDraw = true;
		if (WantSelection == -1)
			WantSelection = TimelineSelection;
	}

	if (WantSelection != -1)
	{
		SelectChapter(WantSelection);
	}

	if (!bNonInteractive)
	{
		if (SelectionLerpStartTime != 0.0)
		{
			diff = PlayerOwner().Level.UniversalTimeSeconds - SelectionLerpStartTime;

			if (diff > SELECTOR_LERP_TIME)
			{
				fCurrentX = fSelectionX;
				SelectionLerpStartTime = 0.0;
				SelectionChanged();
			}
			else
			{
				fCurrentX = Lerp( diff / SELECTOR_LERP_TIME, fLerpX, fSelectionX );
			}
		}
	}

	return false;
}

function bool TimeLineDraw(Canvas C)
{
	local float Xc, Yc;
	local int tW, tH;

	if (!bNonInteractive)
	{
		Xc = fCurrentX;
		Yc = fSelectionY;

		C.Style = EMenuRenderStyle.MSTY_Alpha;
		C.DrawCanvasIcon(Xc, Yc, Controller.CanvasAspectScale, Controller.CanvasScaleY, SelectionIcon);

		stySelectionLabel.TextSize(C, eMenuState.MSAT_Focused, SelectionDate, tW, tH);
		
		// clamp at the safe area
		Xc = fCurrentX - 0.5*tW;
		if (Xc < HorizontalOffset(0.0375))
		{
			Xc = HorizontalOffset(0.0375);
		}
		else if (Xc+tW > HorizontalOffset(0.0375, true))
		{
			Xc = HorizontalOffset(0.0375, true) - tW;
		}

		Yc = VerticalOffset(0.08);

		stySelectionLabel.DrawText(C, eMenuState.MSAT_Focused, Xc, Yc, tW, tH, TXTA_Center, SelectionDate);
	}

	DrawTimeline(C);

	return false;
}

// endcap	0,45 * 2,12
// tick		193,45 * 2,12
// segment	2,45 * 27,12
function DrawTick(Canvas C, int capWidth, int segHeight, EndCapStyle capStyle)
{
	if (capStyle == ECS_Cap)
		C.DrawTileClipped(Material't_interface_mb.hud.chapters_comp', capWidth, segHeight, 0, 45, 2, 12);
	else if (capStyle == ECS_Tick)
		C.DrawTileClipped(Material't_interface_mb.hud.chapters_comp', capWidth, segHeight, 194, 45, 2, 12);
}

function DrawSegment(Canvas C, float segLeft, float segWidth, EndCapStyle leftCap, optional EndCapStyle rightCap)
{
	local int capWidth, segHeight, segTop;

	segTop = VerticalOffset(0.6625);
	capWidth = Tick_Width * Controller.CanvasScaleX;
	segHeight = Segment_Height * Controller.CanvasScaleY;

	if (leftCap != ECS_None)
	{
		C.SetPos(segLeft, segTop);
		DrawTick(C, capWidth, segHeight, leftCap);

		segLeft = int(segLeft + capWidth);
		segWidth = int(segWidth - capWidth);
	}

	if (rightCap != ECS_None)
	{
		segWidth = int(segWidth - capWidth);

		C.SetPos(segLeft + segWidth, segTop);
		DrawTick(C, capWidth, segHeight, rightCap);
	}

	C.SetPos(segLeft, segTop);
	C.DrawTileClipped(Material't_interface_mb.hud.chapters_comp', segWidth, segHeight, 3, 45, 25, 12);
}

function DrawTimeline(Canvas C)
{
	local int i;

	for (i=0; i<TimeLineSegments.Length; i++)
	{
		if (HighlightedSegment == i)
			C.DrawColor = SegmentColorHi;
		else
			C.DrawColor = SegmentColorNormal;

		DrawSegment(C, TimeLineSegments[i].fLeft, TimeLineSegments[i].fWidth, TimeLineSegments[i].capLeft, TimeLineSegments[i].capRight);
	}
}

function GetSelectionIconPosition(int whichChapter, out float Xc, out float Yc)
{
	Xc = TimeLineChapters[whichChapter].ChapterIcon.HorizontalOffset(0.5);
	Yc = ActualTop() - 0.05*ActualHeight();
}

// =======================================================================================================================================================
// Input handling
// =======================================================================================================================================================
function SelectionChanged()
{
	HiliteTimelineSegment(TimeLineChapters[TimelineSelection].SegmentIndex);
	OnChange(self);
}

function SelectChapter(int chapterIndex, optional bool bNoLerp)
{
	local bool bChanged;
	bChanged = TimelineSelection != chapterIndex;
	TimelineSelection = chapterIndex;

	GetSelectionIconPosition(chapterIndex, fSelectionX, fSelectionY);

	// don't lerp cursor.  it gets too far behind
	fCurrentX = fSelectionX;
	fLerpX = fCurrentX;
	SelectionLerpStartTime = 0;
	SelectionChanged();
	WantSelection = -1;

	SelectionDate = PlayerOwner().Level.MissionManager.GetMissionDate(TimelineSelection);
	if (bChanged)
		Controller.PlayClickSound(EClickSound.CS_Change);
}

function SelectFirstChapter()
{
	TimelineSelection = -1;
	SelectChapter(NextChapter(true));
}

function bool ChapterIconClick(GUIComponent Sender)
{
	local int i;

	if (Controller.bIsConsole)
		return false;

	for (i=0; i<TimeLineChapters.Length; i++)
	{
		if (TimeLineChapters[i].ChapterIcon.IsInBounds() && TimeLineChapters[i].ChapterIcon.bVisible)
		{
			SelectChapter(i, true);
			return true;
		}
	}

	return false;
}

function bool ChapterIconDblClick(GUIComponent Sender)
{
	local int i;

	if (Controller.bIsConsole)
		return false;

	for (i=0; i<TimeLineChapters.Length; i++)
	{
		if (TimeLineChapters[i].ChapterIcon.IsInBounds() && TimeLineChapters[i].ChapterIcon.bVisible)
		{
			OnChapterIconDblClicked(i);
			return true;
		}
	}

	return false;
}

function int PrevChapter(optional bool bWrap)
{
	local int i;

	i = TimelineSelection - 1;
	while(i != TimelineSelection)
	{
		if (i < 0)
		{
			if (!bWrap)
				break;
			else
			{
				i = TimeLineChapters.Length - 1;
				continue;
			}
		}

		if (TimeLineChapters[i].ChapterIcon.bVisible)
			return i;

		i--;
	}


	return TimelineSelection;
}

function int NextChapter(optional bool bWrap)
{
	local int i;

	i = TimelineSelection + 1;
	while(i != TimelineSelection)
	{
		if (i >= TimeLineChapters.Length)
		{
			if (!bWrap)
				break;
			else
			{
				i = 0;
				continue;
			}
		}

		if (TimeLineChapters[i].ChapterIcon.bVisible)
			return i;

		i++;
	}

	return TimelineSelection;
}

function bool TimelineXControllerEvent(byte Id, eXControllerCodes iCode)
{
	switch(iCode)
	{
	case XC_PadLeft:
		SelectChapter(PrevChapter(true));
		return true;
		break;

	case XC_PadRight:
		SelectChapter(NextChapter(true));
		return true;
		break;
	}	

	return false;
}

function bool TimelineKeyEvent(out byte Key,out byte State,float delta)
{
	// 37=left
	// 39=right
	switch(Key)
	{
	case 37:
		if (State == 1)
			SelectChapter(PrevChapter(true));
		return true;
		break;

	case 39:
		if (State == 1)
			SelectChapter(NextChapter(true));
		return true;
		break;
	}	

	return false;
}

// =======================================================================================================================================================
// Utility
// =======================================================================================================================================================
function HiliteTimelineSegment(int index)
{
	local int i;

	HighlightedSegment = index;

	for (i=0; i<TimeLineSegments.Length; i++)
	{
		if ((index == -1) || (i == index))
		{
			TimeLineSegments[i].DayLabel.DrawMenuState=2;
		}
		else
		{
			TimeLineSegments[i].DayLabel.DrawMenuState=4;
		}
	}
}

function GetSelectionCursorPos(out float X, out float Y)
{
	X = fCurrentX;
	Y = fSelectionY;
}

function SetProfile(GameProfile profile)
{
	local int i, j, continueMission, ch;
	local GUIImage img;

	if (profile == None)
	{
		for (i=0; i<TimeLineSegments.Length; i++)
		{
			for (j=0; j<TimeLineSegments[i].Chapters.Length; j++)
			{
				img = TimeLineChapters[ TimeLineSegments[i].Chapters[j] ].ChapterIcon;
				if ((i == 0) && (j == 0))
				{
					if (TimeLineChapters[ TimeLineSegments[i].Chapters[j] ].ChapterIconStyle == ECIS_Film)
						img.SetFromIcon( ChapterIcons[EChapterIcon.CI_Film_Empty] );
					else
						img.SetFromIcon( ChapterIcons[EChapterIcon.CI_Empty] );

					img.Show();
				}
				else
				{
					img.Hide();
				}
			}
		}

		WantSelection = 0;
		if (!bCycleUnplayedChapters && !bNonInteractive)
			HiliteTimelineSegment(0);
	}
	else
	{
		continueMission = PlayerOwner().Level.MissionManager.GetContinueMissionIndex(profile.LastMissionCompleted, true);

		// hilite the segment with the last mission here
		if (!bCycleUnplayedChapters && !bNonInteractive)
			HiliteTimelineSegment(TimeLineChapters[continueMission].SegmentIndex);

		for (i=0; i<TimeLineSegments.Length; i++)
		{
			for (j=0; j<TimeLineSegments[i].Chapters.Length; j++)
			{
				ch = TimeLineSegments[i].Chapters[j];
				img = TimeLineChapters[ch].ChapterIcon;
				img.Show();
/*
				if ((i == 0) && (j == 0))
				{
					if (TimeLineChapters[ TimeLineSegments[i].Chapters[j] ].ChapterIconStyle == ECIS_Film)
					{
						if (profile.CompletedMission(i) == 0)
						{
							img.SetFromIcon( ChapterIcons[EChapterIcon.CI_Film_Empty] );
						}
						else
						{
							img.SetFromIcon( ChapterIcons[EChapterIcon.CI_Film] );
						}
					}
					else if (TimeLineChapters[ TimeLineSegments[i].Chapters[j] ].ChapterIconStyle == ECIS_Disabled)
					{
						if (bCycleUnplayedChapters)
						{
							img.SetFromIcon( ChapterIcons[EChapterIcon.CI_Empty] );
						}
						else
						{
							img.Hide();
						}
					}
					else
					{
						img.SetFromIcon( ChapterIcons[EChapterIcon.CI_Empty] );
					}
				}
				else */
				if (TimeLineChapters[ch].ChapterIconStyle == ECIS_Film)
				{
					if (profile.CompletedMission(ch) == 0)
					{
						if (bCycleUnplayedChapters || (ch == continueMission))
						{
							img.SetFromIcon( ChapterIcons[EChapterIcon.CI_Film_Empty] );
						}
						else
						{
							img.Hide();
						}
					}
					else
					{
						img.SetFromIcon( ChapterIcons[EChapterIcon.CI_Film] );
					}
				}
				else if (TimeLineChapters[ch].ChapterIconStyle == ECIS_Disabled)
				{
					if (bCycleUnplayedChapters)
					{
						img.SetFromIcon( ChapterIcons[EChapterIcon.CI_Empty] );
					}
					else
					{
						img.Hide();
					}
				}
				else 
				{
					switch(profile.HighestCompletedDifficulty(ch))
					{
					case -1:
						if (bCycleUnplayedChapters || (ch == continueMission) || profile.IsMissionUnlocked(ch))
						{
							img.SetFromIcon( ChapterIcons[EChapterIcon.CI_Empty] );
						}
						else
						{
							img.Hide();
						}
						break;

					case 0:
						img.SetFromIcon( ChapterIcons[EChapterIcon.CI_Iron] );
						break;

					case 1:
						img.SetFromIcon( ChapterIcons[EChapterIcon.CI_Bronze] );
						break;

					case 2:
						img.SetFromIcon( ChapterIcons[EChapterIcon.CI_Silver] );
						break;

					case 3:
						img.SetFromIcon( ChapterIcons[EChapterIcon.CI_Gold] );
						break;
					}
				}
			}
		}

		WantSelection = continueMission;
	}
}

function string FormatDayLabel(int dayOffset)
{
	local string s;

	if (dayOffset == 0)
	{
		s = strDayFormatDDay;
	}
	else
	{
		s = strDayFormatDay;

		if (dayOffset > 0)
			ReplaceText(s, "<DAYOFS>", "+"$dayOffset);
		else
			ReplaceText(s, "<DAYOFS>", String(dayOffset));
	}

	return s;
}

// X scales
// 27=0.0421875
// 31=0.0484375
// 54=0.084375
// 29=0.0453125

// Y scales
// 12=0.015
// 17=0.2125
// 380=0.791667

// 80 pixels high
defaultproperties
{
	bNonInteractive=false
	bCycleUnplayedChapters=false

	WinLeft=0
	WinTop=0.59
	WinWidth=1
	WinHeight=0.166667

	HighlightedSegment=-1

	WantSelection=-1
// =======================================================================================================================================================
// Icon and class templates
// =======================================================================================================================================================
	// timeline bar segments ------------------------------------------------------------------------------
	SegmentColorNormal=(R=255,G=255,B=255,A=64)
	SegmentColorHi=(R=255,G=255,B=255,A=255)

	// timeline day labels ------------------------------------------------------------------------------
	Begin Object Class=GUILabel Name=clblDayLabel
		StyleName="TextLabel"
		TextAlign=TXTA_Center
		DrawMenuState=2
		bAcceptsInput=false
		bNeverFocus=true
		bTabStop=false
		WinWidth=0
		WinHeight=0
		WinLeft=0
		WinTop=0
	End Object


	// chapter icons ------------------------------------------------------------------------------
	Begin Object Class=GUIImage Name=cChapterIcon
		ImageStyle=ISTY_Scaled
		WinLeft=0
		WinTop=0
		WinHeight=0
		WinWidth=0
		bBoundToParent=true
		bScaleToParent=true
	End Object
	ChapterIcons(0)=(Icon=Material't_interface_mb.hud.chapters_comp',U=0,V=166,UL=29,VL=17,DrawColor=(R=255,G=255,B=255,A=255))
	ChapterIcons(1)=(Icon=Material't_interface_mb.hud.chapters_comp',U=0,V=183,UL=29,VL=17,DrawColor=(R=255,G=255,B=255,A=255))
	ChapterIcons(2)=(Icon=Material't_interface_mb.hud.chapters_comp',U=0,V=200,UL=29,VL=17,DrawColor=(R=255,G=255,B=255,A=255))
	ChapterIcons(3)=(Icon=Material't_interface_mb.hud.chapters_comp',U=0,V=217,UL=29,VL=17,DrawColor=(R=255,G=255,B=255,A=255))
	ChapterIcons(4)=(Icon=Material't_interface_mb.hud.chapters_comp',U=0,V=234,UL=29,VL=17,DrawColor=(R=255,G=255,B=255,A=255))
	ChapterIcons(5)=(Icon=Material't_interface_mb.hud.chapters_comp',U=29,V=183,UL=29,VL=17,DrawColor=(R=255,G=255,B=255,A=255))
	ChapterIcons(6)=(Icon=Material't_interface_mb.hud.chapters_comp',U=29,V=166,UL=29,VL=17,DrawColor=(R=255,G=255,B=255,A=255))

	// selection marker ------------------------------------------------------------------------------
	SelectionIcon=(Icon=Material't_interface_mb.hud.chapters_comp',U=324,V=57,UL=37,VL=56,DrawColor=(R=255,G=255,B=255,A=255),ScaleX=1.0,ScaleY=1.0,PivotU=0.5,PivotV=0.0)
	stySelectionLabelName="MenuOptionLabel"

	// background ------------------------------------------------------------------------------
	Begin Object Class=GUIImage Name=cimgBackground
		ImageStyle=ISTY_Scaled
		WinLeft=0
		WinTop=0
		WinHeight=0
		WinWidth=0
		bBoundToParent=true
		bScaleToParent=true
		RenderWeight=0.05
	End Object
	BackgroundIcon(0)=(Icon=Material't_interface_mb.hud.chapters_comp',U=0,V=0,UL=37,VL=45,DrawColor=(R=13,G=5,B=8,A=200))
	BackgroundIcon(1)=(Icon=Material't_interface_mb.hud.chapters_comp',U=37,V=0,UL=438,VL=45,DrawColor=(R=13,G=5,B=8,A=200))
	BackgroundIcon(2)=(Icon=Material't_interface_mb.hud.chapters_comp',U=475,V=0,UL=37,VL=45,DrawColor=(R=13,G=5,B=8,A=200))

	imgBackground(0)=cimgBackground
	imgBackground(1)=cimgBackground
	imgBackground(2)=cimgBackground
	imgBackgroundPositions(0)=(fL=0.0375,fT=0.4375,fW=0.0578125,fH=0.5625)
	imgBackgroundPositions(1)=(fL=0.0953125,fT=0.4375,fW=0.809375,fH=0.5625)
	imgBackgroundPositions(2)=(fL=0.9046875,fT=0.4375,fW=0.0578125,fH=0.5625)

	bAcceptsInput=true
	bNeverFocus=true
	bHandleMouseRelease=true

	strDayFormatDDay="D-DAY"
	strDayFormatDay="<DAYOFS>"
	CI_Padding=4
	Bar_Spacing=12
}
class gbx_GUIProfile extends Actor
	native
	config(GUIProfile);
	
var config  Bool    bRememberPassword;
var config  String  sLoginName;

native static function GetPassword(out string password);  // this just returns a string of '*' for display purposes
native static function bool SetPassword(string password);
native static function bool ModifyAccount(string old_password,string new_password);

native static function string GetLoginName();
native static function bool SetLoginName(string new_name);

native static function bool GetRememberPassword();
native static function SetRememberPassword(bool remeber);

native static function ClearPassword();

defaultproperties
{
}
class gbx_InternetCreateMatch extends gbx_CreateMatchBase;

var	moSpinListControl			spnPlayers;
var moEditBox					EditServerName;
var moEditBox					EditPassword;
var() Automated GUILabel		lblStatusLine;

var localized string			StringStatusCreate;
var int							ServerNameMaxLen;
var int							PasswordMaxLen;
var bool						bSkirmishBrowser;

var string						strBadCharsServerName;

//###+ lbouchard
function bool RegisterServerOnline (string serverName, string password)
{
	if (bSkirmishBrowser)
	{
		LaunchSkirmish(Controller,2,"ServerName="$serverName$"?Password="$password);
	}
	else
	{
		Launch("?ServerName="$serverName$"?Password="$password);
	}

	return true;
}
//###-

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
    local string szUserName;

	Super.InitComponent(MyController, MyOwner);
	InitExecution();
	
//###+ lbouchard : LINKLOSS: Check the connection link for Ubi.com Games
    if (!IsSystemLinkGame())
		bRequireLink=true;
//###- 	

	OnAButtonEvent = OnAccept;

	spnPlayers = moSpinListControl(MyComponents[1]);
	
	EditServerName = moEditBox(MyComponents[2]);
	EditServerName.MyEditBox.MaxWidth = ServerNameMaxLen;
	EditServerName.MyEditBox.VerifyInput = VI_ServerName;

	EditPassword = moEditBox(MyComponents[3]);
	EditPassword.MyEditBox.MaxWidth = PasswordMaxLen;
    
	spnPlayers.AddFromList(PlayersSelectList);
	spnPlayers.SetIndex(1);

    SetPageReadOnly(false);

	class'GameService.GameService'.static.GetUserName(szUserName);
    if (szUserName=="")
        szUserName = class'gbx_ProfileManager'.Static.GetProfileForController(self, 0);

	EditServerName.SetText(szUserName);
}

event HandleParameters( string Param1, string Param2 )
{
	Super.HandleParameters(Param1, Param2);

	bSkirmishBrowser = (Param1 ~= "SKIRMISH");
	if (bSkirmishBrowser)
	{
		MyComponents[0].Hide();
		MyComponents[1].Hide();
		MissionDisplay.Hide();

		DoComponentLayout();
	}
}

static function bool VI_ServerName(string currentString, string newChar)
{
	newChar = Left(newChar,1);

	if (InStr(default.strBadCharsServerName $ "\"", newChar) != -1)
		return false;

	return true;
}

function string BuildLaunchString()
{
	local string launchStr;

	launchStr = Super.BuildLaunchString() $ "?WasInvited=true" $ "?maxplayers=" $GetMaxPlayers(spnPlayers.GetIndex());

	return launchStr;
}

function OnAccept()
{
	GUILog("gbx_InternetCreateMatch::OnAccept()");

	GotoState('RegisterServer');
}

function string GetServerName()
{
    local string szUserName;

	class'GameService.GameService'.static.GetUserName(szUserName);

	if (EditServerName.GetText() != "")
		return EditServerName.GetText();
	else if (szUserName != "")
		return szUserName;
	else if (class'gbx_ProfileManager'.Static.GetProfileForController(self, 0) != "")
		return class'gbx_ProfileManager'.Static.GetProfileForController(self, 0);
	else
		return "EiBServer";
}

state RegisterServer
{
	function BeginState()
    {
		GUILog("gbx_InternetCreateMatch:RegisterServer::BeginState");

        SetPageReadOnly(true);
        
        RegisterServerOnline(GetServerName(), EditPassword.GetText() );		
        
        /*###+ lbouchard : skip directly to the launch of the server
		class'GameService.GameService'.static.SetIsServer(1);
		class'GameService.GameService'.static.EnableServerService();
		class'GameService.GameService'.static.UpdateGameData(spnMissionSelect.GetExtra());
		
		class'GameService.GameService'.static.RegisterServer(
			GetServerName(),
			GetMaxPlayers(spnPlayers.GetIndex()),
			PlayerOwner().Level.Game.GetServerPort(),
			EditPassword.GetText() );
		SetTimer(0.5, true);
		lblStatusLine.SetCaption(StringStatusCreate);
		*/
		
	}

	function EndState()
    {
        SetTimer( 0, false );
		lblStatusLine.SetCaption("");
    }

	function Timer()
	{
		local bool test;
		local int errorType;
		local int error;
		local string errorMessage;

		test = class'GameService.GameService'.static.RegisterServerIsFinished();
		if (test)
		{
			test = class'GameService.GameService'.static.RegisterServerGetResult(errorType, error);
			if (test)
			{
				Launch();
			}
			else
			{
                SetPageReadOnly(false);
				errorMessage = class'GameService.GameServiceError'.static.GetErrorMessage(errorType, error);
				LaunchErrorDialog(Controller, errorMessage, "OK NONE");
				GotoState('');
			}
		}
	}
}

function SetPageReadOnly(bool bValue)
{
    if (bValue)
    {
        SetupAButton();
        SetupBButton();
    }
    else
    {
        SetupAButton(ACaption);
        SetupBButton(BCaption);
    }
    
    MyComponents[1].EnableControl(!bValue);
    spnMissionSelect.EnableControl(!bValue);
    EditPassword.EnableControl(!bValue);
    EditServerName.EnableControl(!bValue);
}

defaultproperties
{
	Begin Object Class=GUILabel Name=cStatusLine
		StyleName="MenuOptionCaption"
		DrawMenuState=2
		TextAlign=TXTA_Center
		bAcceptsInput=false;
		bTabStop=false
		WinWidth=0.800000
		WinHeight=0.050000
		WinLeft=0.100000
		WinTop=0.7700000
	End Object
	lblStatusLine=cStatusLine

	ServerNameMaxLen=24
	PasswordMaxLen=8

	MyComponents(1)=cSpinMenuOptionV
	MyComponents(2)=cEditMenuOptionV
	MyComponents(3)=cEditMenuOptionV

	MyCaptions(1)="Players"
	MyCaptions(2)="Server Name"
	MyCaptions(3)="Password"

	ScreenTitle="Create Ubi.com Match"
	StringStatusCreate="Creating match on Ubi.com service.  Please wait..."

	bShowProfileLabels=false
    bShowOnlineIcon=true

	strBadCharsServerName="#?_"
}

class gbx_InternetQuery extends gbx_InternetQueryBase;

// param1 = query arg list

var Automated   GUIMultiColumnListBox	        Browser;
var             gbx_BrowserMultiColumnList		BrowserList;
var Automated   GUILabel			            lblStatusLine;

var Automated	moCheckBox						ShowFullServersCheckBox;
var Automated	moCheckBox						ShowEmptyServersCheckBox;

var localized   string                          StringStatus;
var localized	string							StringShowFull;
var localized	string							StringShowEmpty;

var bool		bInitialShowFullServers;
var bool		bInitialShowEmptyServers;


// =======================================================================================================================================================
// Initialization
// =======================================================================================================================================================
function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
    Super.InitComponent(MyController, MyOwner);

    OnYButtonEvent = OnYButton;
    BrowserList = gbx_BrowserMultiColumnList(Browser.List);

    SetupAButton();
    SetupXButton();
    SetupYButton();

	BrowserList.OnListItemDblClick = BrowserListItemOnDblClick;

	// set these first, otherwise the "Change" functions get called when it gets set...
	ShowFullServersCheckBox.Checked(PlayerOwner().bShowFullServers);
	ShowEmptyServersCheckBox.Checked(PlayerOwner().bShowEmptyServers);

	bInitialShowFullServers = PlayerOwner().bShowFullServers;
	bInitialShowEmptyServers = PlayerOwner().bShowEmptyServers;

	ShowFullServersCheckBox.SetCaption(StringShowFull);
	ShowFullServersCheckBox.OnChange = ShowFullServersChange;
	ShowFullServersCheckBox.TabOrder = 0;

	ShowEmptyServersCheckBox.SetCaption(StringShowEmpty);
	ShowEmptyServersCheckBox.OnChange = ShowEmptyServersChange;
	ShowEmptyServersCheckBox.TabOrder = 1;
}

function BrowserListItemOnDblClick(GUIComponent Sender, int Item)
{
	BrowserList.SetIndex(Item);

	if (hbtnA.bVisible)
	{
		OnAButton();
	}
}

function ShowFullServersChange(GUIComponent Sender)
{
	PlayerOwner().bShowFullServers = !PlayerOwner().bShowFullServers;

	// parse the server list
	ParseServerList();

	BeginServerProbes(ServerList);
}

function ShowEmptyServersChange(GUIComponent Sender)
{
	PlayerOwner().bShowEmptyServers = !PlayerOwner().bShowEmptyServers;

	// parse the server list
	ParseServerList();

	BeginServerProbes(ServerList);
}

function InternalOnClose(optional Bool bCancelled)
{
	// have the current bShowFullServers or bShowEmptyServers state changed from when this screen was created?...
	if ((bInitialShowFullServers != PlayerOwner().bShowFullServers) ||
		(bInitialShowEmptyServers != PlayerOwner().bShowEmptyServers))
	{
		// save the current bShowFullServers and bShowEmptyServers state in the .ini file...
		ConsoleCommand("LOADSAVE PROFILE UPDATENAMED NAME=\"" $ class'gbx_ProfileManager'.Static.GetProfileForController(self, 0) $"\"");
	}
}

function OnYButton()
{
	//GotoState('NoResults');//Why were we doing this ?  It causes problem when comming back from the 'create game' sub menu
	Controller.OpenMenu("GUI.gbx_InternetCreateMatch", LParam1);
}

// =======================================================================================================================================================
// Futility functions
// =======================================================================================================================================================
function ServerList_AddItem(out ServerInfo server)
{
	Super.ServerList_AddItem(server);
	BrowserList.AddServer( ServerList[ServerList.Length-1] );
}

function ServerList_Clear()
{
	Super.ServerList_Clear();
	BrowserList.Clear();
}

function ServerList_UpdatedItem(int listIndex)
{
	BrowserList.UpdateServer( ServerList[listIndex] );
}

function ServerList_Updated()
{
	if (ServerList.Length > 0)
		SetupAButton(stringJoin);
	else
		SetupAButton();
}

// =======================================================================================================================================================
// =======================================================================================================================================================
// state logic
// =======================================================================================================================================================
// =======================================================================================================================================================
state WaitingToStartQuery
{
    function BeginState()
    {
		Super.BeginState();
		SetupAButton();
		SetupXButton();
		SetupYButton();
		SetupYButton(StringCreateMatch);
	}
}

state WaitingForResults
{
    function BeginState()
    {
		Super.BeginState();
		SetupAButton();
		SetupXButton();
		SetupYButton(StringCreateMatch);
	}
	function OnYButton()
	{
        ConsoleCommand("XLIVE CANCEL_QUERY" );
		global.OnYButton();
	}
}

state GotResults
{
    function BeginState()
    {
		GUILog("gbx_InternetQuery:GotResults::BeginState");
		lblStatusLine.SetCaption("");
		Super.BeginState();

		lblTextPrompt.Hide();
		if (ServerList.Length > 0)
			SetupAButton(stringJoin);
		else
			SetupAButton();
		SetupBButton(StringBack);
		SetupXButton(StringRefresh);
		SetupYButton(StringCreateMatch);

		// parse the server list
		ParseServerList();

		// begin the QOS update
		BeginServerProbes(ServerList);
		//###+ lbouchard : We want more accuracy for ping calculation
		SetTimer(0.001, true);
		//###-
	}

	function InternalOnClose(optional Bool bCancelled)
	{
		Global.InternalOnClose(bCancelled);
		SetTimer(0, false);
		EndServerProbes();
	}

	function Timer()
	{
                //###+ lbouchard : PING : PC Ping Implementation
		RefreshServerProbes();
                //###-
	}

	function OnXButton()
	{
        ConsoleCommand("XLIVE CANCEL_QUERY" );
        GotoState('WaitingForResults');
	}
	function OnYButton()
	{
        ConsoleCommand("XLIVE CANCEL_QUERY" );
		global.OnYButton();
	}

	function OnAButton()
	{
		//ConnectToServer(ServerList[BrowserList.Index]);
		if (ServerList[BrowserList.SortData[BrowserList.Index].SortItem].IsPasswordProtected)
		{
			GotoState('WaitingPwd');
		}
		else
		{
			GotoState('JoiningServer');
		}
	}

}

state NoResults
{
	function OnXButton()
	{
        GotoState('WaitingForResults');
	}
	function OnAButton();
}

state WaitingPwd
{
	function BeginState()
    {
		Controller.OpenMenu("GUI.gbx_UbiEnterPwd");
		SetTimer(0.25, true);
	}

	function EndState()
    {
		KillTimer();
    }

	function Timer()
	{
		if 	( class'gbx_UbiEnterPwd'.static.IsPwdMenuClose() )
		{
		    if (class'gbx_UbiEnterPwd'.static.GetPwd() != "")
		    {
		        mPassword = class'gbx_UbiEnterPwd'.static.GetPwd();
			    GotoState('JoiningServer');
			}
			else
			    GotoState('GotResults');
		}
	}
}

state JoiningServer
{
	function BeginState()
    {
		GUILog("gbx_InternetQuery:JoiningServer::BeginState");
		lblStatusLine.SetCaption(StringStatus);

		SetupAButton();
		SetupBButton();
		SetupXButton();
		SetupYButton();

		KillTimer();
		SetTimer(0.2, true);
	}

	function Timer()
	{
		KillTimer();
		if ( !ConnectToServer(ServerList[BrowserList.SortData[BrowserList.Index].SortItem]) )
		    GotoState('GotResults');
	}
}

static function PreloadMenu(GUIController C)
{
	Super.PreloadMenu(C);

	C.PreloadMenu("GUI.gbx_UbiEnterPwd");
	C.PreloadMenu("GUI.gbx_InternetCreateMatch");
}

defaultproperties
{
	Begin Object class=GUIMultiColumnListBox Name=cBrowser
		WinWidth=0.9
		WinHeight=0.54
		WinLeft=0.05
		WinTop=0.17
        bVisibleWhenEmpty=true
        DefaultListClass="GUI.gbx_BrowserMultiColumnList"
	End Object
    Browser=cBrowser

	Begin Object Class=GUILabel Name=cStatusLine
		StyleName="MenuOptionCaption"
		DrawMenuState=2
		TextAlign=TXTA_Center
		bAcceptsInput=false;
		bTabStop=false
		WinWidth=0.800000
		WinHeight=0.050000
		WinLeft=0.100000
		WinTop=0.7200000
	End Object
	lblStatusLine=cStatusLine

	Begin Object Class=GUICheckBoxButton Name=cFullServerTheBox
		Graphic=Texture't_interface_mb.hud.dead_x'
	End Object

	Begin Object Class=moCheckBox Name=cShowFullServersCheckBox
	    MyCheckBox=cFullServerTheBox
		LabelJustification=TXTA_Right
		CaptionWidth=0.85000
		ComponentWidth=0.0748
		WinWidth=0.40000
		WinHeight=0.045000
		WinLeft=0.0500000
		WinTop=0.78000
		bHeightFromComponent=false
	End Object
	ShowFullServersCheckBox=cShowFullServersCheckBox

	Begin Object Class=GUICheckBoxButton Name=cEmptyServerTheBox
		Graphic=Texture't_interface_mb.hud.dead_x'
	End Object

	Begin Object Class=moCheckBox Name=cShowEmptyServersCheckBox
	    MyCheckBox=cEmptyServerTheBox
		LabelJustification=TXTA_Right
		CaptionWidth=0.85000
		ComponentWidth=0.0748
		WinWidth=0.40000
		WinHeight=0.045000
		WinLeft=0.5500000
		WinTop=0.78000
		bHeightFromComponent=false
	End Object
	ShowEmptyServersCheckBox=cShowEmptyServersCheckBox

	ScreenTitle="Ubi.com"
	StringStatus="Joining game on Ubi.com service.  Please wait..."
	StringQueryCommand="RUN_QUERY_INTERNET"
	bShowProfileLabels=false
    bShowOnlineIcon=true
	StringShowFull="Show Full Servers"
	StringShowEmpty="Show Empty Servers"
}

class gbx_InternetQueryBase extends gbx_ScreenABXY
	Abstract;


var() Automated GUILabel			lblTextPrompt;

var array<ServerInfo>				ServerList;

var bool							bFakeServerList;
var bool							bGenFakeServers;
var bool							bSkirmishBrowser;

var() int							PingWarningThreshold; // warn about bad network if server ping >=
var() localized String				PingLabels[5];
var localized string				StringGettingList;
var string							StringQueryCommand;



var string                          mPassword;

var ServerInfo						ConnectServer;


// =======================================================================================================================================================
// Initialization
// =======================================================================================================================================================
function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	InitExecution();

//###+ lbouchard : LINKLOSS: Check the connection link for Ubi.com Games
    if (!IsSystemLinkGame())
		bRequireLink=true;
//###-    


	lblTextPrompt.Caption = StringGettingList;
	lblTextPrompt.Hide();

	OnAButtonEvent = OnAButton;
	OnBButtonEvent = OnBButton;
	OnXButtonEvent = OnXButton;
	OnClose = InternalOnClose;
}

event HandleParameters(string Param1, string Param2)
{
	Super.HandleParameters(Param1, Param2);
	bSkirmishBrowser = (Param1 ~= "SKIRMISH");

    GotoState('WaitingToStartQuery');
}

function OnAButton();
function OnXButton();
function OnBButton()
{
	KillTimer();
	BaseOnBButton();
}

function InternalOnClose(optional Bool bCancelled);

// =======================================================================================================================================================
// Futility functions
// =======================================================================================================================================================
// override!
function ServerList_AddItem(out ServerInfo server)
{
	local int i;

	i = ServerList.Length;
	ServerList.Length = i+1;
	ServerList[i] = server;
}

function ServerList_Clear()
{
	ServerList.Length = 0;
}
function ServerList_UpdatedItem(int listIndex);			// called when an entry's ping has been updated
function ServerList_Updated();							// called after the server list has been parsed

// retrieves the list of servers
// uses AddItem, Clear and Sort functions above
final function ParseServerList()
{
    local int Count;
    local int i;
    local string ServerLine, S;
	local ServerInfo server;
	local string sModName;
	local bool bShowFullServers;
	local bool bShowEmptyServers;

	if (bFakeServerList) return;

	sModName = GetConfigString("ModName", "Engine.GameEngine", "GIni");

	if (sModName == "")  // ModName= not found in .ini file?...
		sModName="EarnedInBlood";  // reset to the BiA:EiB default

	bShowFullServers = PlayerOwner().bShowFullServers;
	bShowEmptyServers = PlayerOwner().bShowEmptyServers;

    Count = class'GameService.GameService'.static.ServerQueryGetCount();

	ServerList_Clear();
    for( i = 0; i < Count; i++ )
    {
		class'GameService.GameService'.static.ServerQueryGetResult(i, ServerLine);
		
		server.ContextID = i;
		server.ModName = ParseToken(ServerLine);
		server.GameType = ParseToken(ServerLine);
        server.HostName = ParseToken(ServerLine);
        server.MapFilename = ParseToken(ServerLine);
        server.NumPlayers = int(ParseToken(ServerLine));
        server.MaxPlayers = int(ParseToken(ServerLine));
		server.LobbyID = int(ParseToken(ServerLine));
		server.RoomID = int(ParseToken(ServerLine));        
		server.IsDedicatedServer = bool(ParseToken(ServerLine));
        server.IsPasswordProtected = bool(ParseToken(ServerLine));
        server.ServerExtPingAddress = int(ParseToken(ServerLine));
        server.ServerExtPingPort    = int(ParseToken(ServerLine));
        server.ServerAltPingAddress = int(ParseToken(ServerLine));
        server.ServerAltPingPort    = int(ParseToken(ServerLine));

        S = ParseToken(ServerLine);
        if( S != "###" )
        {
            log("Expected ### got:"@ S, 'Error' );
            break;
        }
              
		// hide servers that are full?...
		if (!bShowFullServers && (server.NumPlayers == server.MaxPlayers))
			continue;  // don't add this one to the list
              
		// hide servers that are empty?...
		if (!bShowEmptyServers && (server.NumPlayers == 0))
			continue;  // don't add this one to the list

		if (bSkirmishBrowser != (server.GameType ~= "gbxGameplay.WargameSkirmish"))
		{
			GUILog("Skipping mismatched skirmish server :" @server.HostName);
			continue;
		}

		// does the mod running on the server match the ModName in the .ini file?...
		if (server.ModName ~= sModName)  // match?
		{
			server.MapName = class'Gameplay.gbxMPMissionList'.Static.FindMissionName(server.MapFilename);
			server.GameName = server.GameType;
			server.GameAcronym = "???";

			server.Ping = -1; // unknown

			ServerList_AddItem(server);
	    }
    }

	ServerList_Updated();
}

// QOS Update funcs
function BeginServerProbes( out Array<ServerInfo> Servers )
{
	//###+ lbouchard : PING : PC Ping Implementation
    local int i;
	if (bFakeServerList) return;
	
	class'IpDrv.PingManagerInterface'.static.Init();	

	for( i=0; i<Servers.Length; i++ )
    {
		// ping the external address
		class'IpDrv.PingManagerInterface'.static.AddPing(Servers[i].ServerExtPingAddress, Servers[i].ServerExtPingPort);

		// ping the internal address
		class'IpDrv.PingManagerInterface'.static.AddPing(Servers[i].ServerAltPingAddress, Servers[i].ServerAltPingPort);
    }	
	//###-
}

function bool RefreshServerProbes()
{
	
	//###+ lbouchard : PING : PC Ping Implementation    

    local int i;
    local bool Dirty;

	local int ExtPing;
	local int AltPing;

	if (bFakeServerList) return false;

    class'IpDrv.PingManagerInterface'.static.Poll();
	
    for( i=0; i<ServerList.Length; i++ )
    {
	   ExtPing = class'IpDrv.PingManagerInterface'.static.FetchPing(ServerList[i].ServerExtPingAddress, ServerList[i].ServerExtPingPort);
	   AltPing = class'IpDrv.PingManagerInterface'.static.FetchPing(ServerList[i].ServerAltPingAddress, ServerList[i].ServerAltPingPort);
	
	   if (ServerList[i].Ping == -1)
	   {
			// means the Ping hasnt been set yet for this server, we only set it once
		   if ((AltPing == -1) && (ExtPing == -1))
		   {			
			   // We do nothing, no meaning full results yet
		   }
		   else if ((AltPing == -2) && (ExtPing == -2))
		   {
			   // Both ip addresses timed out
				ServerList[i].Ping = -2;
				ServerList_UpdatedItem(i);
				Dirty = true;
		   }
		   else if (AltPing>=0)
		   {
			    // delete the other ping, we don't need it
				class'IpDrv.PingManagerInterface'.static.DeletePing(ServerList[i].ServerExtPingAddress, ServerList[i].ServerExtPingPort);

			    ServerList[i].Ping = AltPing;
				ServerList_UpdatedItem(i);
				Dirty = true;
		   }
		   else 
		   {
			    // delete the other ping, we don't need it
				class'IpDrv.PingManagerInterface'.static.DeletePing(ServerList[i].ServerAltPingAddress, ServerList[i].ServerAltPingPort);

			    ServerList[i].Ping = ExtPing;
				ServerList_UpdatedItem(i);
				Dirty = true;
		   }
	   }
    }        
    return Dirty;
}

function EndServerProbes()
{
	if (bFakeServerList) return;
	
	//###+ lbouchard : PING : PC Ping Implementation
	class'IpDrv.PingManagerInterface'.static.CancelPings();
	class'IpDrv.PingManagerInterface'.static.UnInit();
	//###-


}

static function string GetPingString(int ping)
{
    //###+ lbouchard: PING : PC Ping Implementation
    if( Ping == -2 )
        return "---";  // timed out
    else if( Ping == -1 )
        return "...";  // pending
    else if( Ping < 100 )
        return Default.PingLabels[1];
    else if( Ping < 200 )
        return Default.PingLabels[2];
    else if( Ping < 300 )
        return Default.PingLabels[3];

	return Default.PingLabels[4];
    //###-
   
}

function bool VerifyJoinGame()
{
	if (class'gbx_DlgMissingMap'.Static.PromptNeedMap(self, ConnectServer.MapFilename))
		return false;

	if (ConnectServer.MaxPlayers - ConnectServer.NumPlayers < 1)
	{
		PopErrorMessage(class'gbx_BrowseMatchLanPC'.default.StringServerFull);
		return false;
	}

	return true;
}

function OnJoinGame()
{
	local string URL;
	local string hostName;

	hostName = ConnectServer.HostName;
	ReplaceText(hostName, " ", "_");


	URL = "0.0.0.0" $ ":" $ 0
		$ "/" $ ConnectServer.MapFilename
		$ "?LobbyId=" $ ConnectServer.LobbyID
		$ "?RoomId="  $ ConnectServer.RoomID
		$ "?HostName=" $ hostName;

	if (mPassword != "")
	{
		URL = URL $ "?Password=" $ mPassword;
	}

	GUILog("gbx_InternetQueryBase::ConnectToServer: URL="$URL);

	// launch!
	PlayerOwner().ClientTravel( URL, TRAVEL_Absolute, false );
	Controller.CloseAll(false);
}



function bool ConnectToServer(out ServerInfo server)
{
	if (bFakeServerList) 
	    return false;
	
	ConnectServer = server;

	if (VerifyJoinGame())
	{
		OnJoinGame();
		return true;
    }
    else
        return false;
}


function bool ServerJoinPromptAnswer(string answer)
{
	if ((answer ~= "YES") || (answer ~= "OK"))
	{
		OnJoinGame();
		return false;
	}
	
	mPassword = "";
	return true;
}

function PopErrorMessage(string promptString)
{
	local gbx_ScreenQuestion dlg;

	dlg = LaunchQuestionDialog(Controller, promptString, "BACK NONE");
	dlg.OnAnswer = None;
}

// =======================================================================================================================================================
// debug stuff
// =======================================================================================================================================================
function RandomizeServer( out ServerInfo S )
{
	local int mapindex;

    S.HostName = "TESTING-" $ String( Rand(1000) );

	mapindex = Rand( class'Gameplay.gbxMPMissionList'.Static.GetMissionCount() );
    S.MapFilename = class'Gameplay.gbxMPMissionList'.Static.GetMap(mapindex);
    S.MapName = class'Gameplay.gbxMPMissionList'.Static.GetMissionName(mapindex);

	if (Rand(2) == 1)
		S.IsDedicatedServer = true;
	else
		S.IsDedicatedServer = false;

    S.MaxPlayers = Rand( 3 ) + 2;
    S.NumPlayers = Rand( S.MaxPlayers + 1 );

    S.Ping = Rand(200) + 20;
}

function GenerateRandomServers()
{
	local int i, count;
	local ServerInfo server;

	ServerList_Clear();

	count = Rand(25) + 5;
	for (i=0; i<count; i++)
	{
		RandomizeServer(server);
		ServerList_AddItem(server);
	}

	ServerList_Updated();
}

// =======================================================================================================================================================
// =======================================================================================================================================================
// state logic
// =======================================================================================================================================================
// =======================================================================================================================================================

// =======================================================================================================================================================
// state WaitingToStartQuery
// =======================================================================================================================================================
state WaitingToStartQuery
{
    function BeginState()
    {
//        Timer();
        SetTimer( 1.0, true );

		SetupAButton();
		SetupBButton(StringBack);
		SetupXButton();
		lblTextPrompt.Show();
	}
    
    function Timer()
    {
// GUITODO:        if( Level.TimeSeconds > PlayerController(Owner).NextMatchmakingQueryTime )
            GotoState('WaitingForResults');
    }

    function EndState()
    {
        SetTimer( 0, false );
    }
}

// =======================================================================================================================================================
// state WaitingForResults
// =======================================================================================================================================================
state WaitingForResults
{
    function BeginState()
    {
// GUITODO        PlayerController(Owner).NextMatchmakingQueryTime = Level.TimeSeconds + class'PlayerController'.default.TimeBetweenMatchmakingQueries;    
		SetupAButton();
		SetupBButton(StringBack);
		SetupXButton();
		lblTextPrompt.Show();

		bFakeServerList = false;
        class'GameService.GameService'.static.ServerQuery();
        SetTimer( 0.1, true );
    }

    function EndState()
    {
        SetTimer( 0, false );
    }

    function Timer()
    {
        local bool bQueryCompleted;
        local int ResultCount;
        
		bQueryCompleted = class'GameService.GameService'.static.ServerQueryIsFinished();
        
        if( !bQueryCompleted ) // Still waiting.
            return;

        SetTimer( 0, false );
	
		ResultCount = class'GameService.GameService'.static.ServerQueryGetCount();

		GUILog("Internet Matchmaking query success.  Results=" $ResultCount);
        if( ResultCount == 0 )
		{
			if (bGenFakeServers)
			{
				GUILog("############## Generating fake server list #####################");
				GenerateRandomServers();
				bFakeServerList=true;
				GotoState('GotResults');
			}	
			else
			{
			    ServerList_Clear();
				Controller.OpenMenu("GUI.gbx_InternetQueryNoResults", LParam1);
				GotoState('NoResults');
			}
		}
        else
		{
			GotoState('GotResults');
		}
    }

	function OnBButton()
	{
        ConsoleCommand("XLIVE CANCEL_QUERY" );
		global.OnBButton();
	}
}

state GotResults
{
}

state NoResults
{
    function BeginState()
    {
		SetupAButton();
		SetupBButton(StringBack);
		SetupXButton(StringRefresh);
		SetupYButton(StringCreateMatch);
		lblTextPrompt.Hide();
	}
}

defaultproperties
{
	Begin Object Class=GUILabel Name=cTextPrompt
		StyleName="MenuOptionCaption"
		DrawMenuState=2
		TextAlign=TXTA_Center
		bAcceptsInput=false;
		bTabStop=false
		WinWidth=0.800000
		WinHeight=0.050000
		WinLeft=0.100000
		WinTop=0.7200000
	End Object
	lblTextPrompt=cTextPrompt

    PingLabels(0)="?"
    PingLabels(1)="****"
    PingLabels(2)="***"
    PingLabels(3)="**"
    PingLabels(4)="*"
	PingWarningThreshold=200


	bGenFakeServers=false
	bFakeServerList=false

	StringGettingList="Getting list of matches.  Please stand by..."
	StringQueryCommand=""
	bShowProfileLabels=false
    bShowOnlineIcon=true
}
class gbx_InternetQueryNoResults extends gbx_ScreenQuestion;

// Param2: <eScreenQuestionType> <eScreenPromptType>

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	OnAnswer = QueryNoResultsAnswer;
}

function bool QueryNoResultsAnswer(string answer)
{
	if (answer == "YES")
	{
		Controller.ReplaceMenu("GUI.gbx_InternetCreateMatch", LParam1);
		return false;
	}

	return true;
}

defaultproperties
{
	ScreenTitle="No Matches Found"
	StringAutoTextPrompt="Would you like to create a new match?"
	QuestionType=SQT_YESNO
	PromptType=SPT_None
}

// This is the list of maps displayed in the map-selection screen for leaderboards
class gbx_LeaderboardMapSelectMultiColumnList extends GUIMultiColumnList;

var()	array<gbx_LiveLeaderboardMapSelect.MapInfo>	MapList;
var		GUIStyles									SelStyle;

var localized string								StringOverallRanking;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	local gbx_LiveLeaderboardMapSelect.MapInfo MapInfo; // TEMP_AR
	local int i, TotalMaps;

	OnDrawItem	= DrawMapItem;

	Super.InitComponent(MyController, MyOwner);
	SelStyle = Controller.GetStyle("SquareBar");

	TotalMaps = class'Gameplay.gbxMPMissionList'.Static.GetMissionCount();
	MapList.Length = TotalMaps+1;
	MapInfo.Display = StringOverallRanking;
	MapInfo.LeaderboardID = 0;
	MapList[0] = MapInfo;
	AddedItem();

	for(i = 0; i < TotalMaps; i++)
	{
		MapInfo.Display = class'Gameplay.gbxMPMissionList'.Static.GetMissionName(i, true);
		MapInfo.LeaderboardID = class'Gameplay.gbxMPMissionList'.Static.GetMissionID(i);
		MapList[i+1] = MapInfo;
		AddedItem();
	}
}

function DrawMapItem(Canvas Canvas, int i, float X, float Y, float W, float H, bool bSelected)
{
	local float CellLeft, CellWidth;
	local eMenuState drawState;

	if (i == -1)
	{
		GetCellLeftWidth( 0, CellLeft, CellWidth );
		SelStyle.Draw(Canvas,MSAT_Pressed, X+CellLeft, Y, CellWidth, H );
	}
	else
	{
		drawState = MSAT_Blurry;

		// Draw the selection border
		if( bSelected )
		{
			class'GUI.gbx_ScreenABXY'.Static.DrawTheThinRedLine(Controller, Canvas, -5, Y+H, X+W+5);
			drawState = MSAT_Focused;
		}

		GetCellLeftWidth( 0, CellLeft, CellWidth, true );
		Style.DrawText( Canvas, drawState, X+CellLeft, Y, CellWidth, H, TXTA_Left, MapList[SortData[i].SortItem].Display );

	}
}

function string GetSortString( int i )
{
	return "";
}

defaultproperties
{
	StyleName="MenuOptionLabel"
	ColumnHeadings(0)="Select Mission To View Statistics"
	StringOverallRanking="Overall Mission Ranking"

	InitColumnPerc(0)=1.0

	SortColumn=-1
	SortDescending=False
}
// List of players and their rankings displayed on the leaderboard screen
class gbx_LeaderboardMultiColumnList extends GUIMultiColumnList;

var()	array<gbx_LiveLeaderboard.RankInfo>	PlayerList;
var		GUIStyles							SelStyle;
var gbx_LiveLeaderboard Leaderboard;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	OnDrawItem	= DrawGamerItem;

	Super.InitComponent(MyController, MyOwner);
	SelStyle = Controller.GetStyle("SquareBar");

	Leaderboard = gbx_LiveLeaderboard(MenuOwner.MenuOwner);
}

function AddPlayer(out gbx_LiveLeaderboard.RankInfo player)
{
	if (PlayerList.Length == 1)
		SetIndex(0);

	PlayerList[PlayerList.Length] = player;

	AddedItem();
}

function Clear()
{
	PlayerList.Length = 0;
	ItemCount = 0;
	Super.Clear();
}

function Down()
{
	if (Index==ItemCount-1)
		Leaderboard.OnPageDown();
	else
		Super.Down();
}
function Up()
{
	if (Index==0)
		Leaderboard.OnPageUp();
	else
		Super.Up();
}

function DrawGamerItem(Canvas Canvas, int i, float X, float Y, float W, float H, bool bSelected)
{
	local float CellLeft, CellWidth;
	local int index;
	local eMenuState drawState;
	
	local string Percent;
	local int DotLoc;
	
	local string PlayerName;
	
	if (i == -1)
	{
		// For each column
		for(index = 0; index < InitColumnPerc.Length; index++)
		{
			GetCellLeftWidth( index, CellLeft, CellWidth );
			SelStyle.Draw(Canvas,MSAT_Pressed, X+CellLeft, Y, CellWidth, H );
		}
	}
	else
	{
		drawState = MSAT_Blurry;

		// Draw the selection border
		if( bSelected )
		{
			class'GUI.gbx_ScreenABXY'.Static.DrawTheThinRedLine(Controller, Canvas, -5, Y+H, X+W+5);
		}

		if( PlayerList[SortData[i].SortItem].LocalPlayer )
		{
			Style.FontColors[0].R = 128;
			Style.FontColors[0].G = 128;
			Style.FontColors[0].B = 255;
		}

		GetCellLeftWidth( 0, CellLeft, CellWidth, true );
		Style.DrawTextToFit( Canvas, drawState, X+CellLeft, Y, CellWidth, H, TXTA_Left, string(PlayerList[SortData[i].SortItem].Rank) );

		PlayerName = PlayerList[SortData[i].SortItem].Name;
		if(Len(PlayerName) > 16)
			PlayerName = Left(PlayerName,15)$"..."; //ellipsis character

		GetCellLeftWidth( 1, CellLeft, CellWidth, true );
		Style.DrawTextToFit( Canvas, drawState, X+CellLeft, Y, CellWidth, H, TXTA_Left, PlayerName );

		GetCellLeftWidth( 2, CellLeft, CellWidth, true );
		Style.DrawText( Canvas, drawState, X+CellLeft, Y, CellWidth, H, TXTA_Left, string(PlayerList[SortData[i].SortItem].XBLRating) );

		GetCellLeftWidth( 3, CellLeft, CellWidth, true );
		Style.DrawText( Canvas, drawState, X+CellLeft, Y, CellWidth, H, TXTA_Left, string(PlayerList[SortData[i].SortItem].Games) );

		if (PlayerList[SortData[i].SortItem].Games == 0)
			Percent = "0.0";
		else
			Percent = string(100.0*PlayerList[SortData[i].SortItem].Wins/PlayerList[SortData[i].SortItem].Games);

		DotLoc = InStr(Percent,".");
		GetCellLeftWidth( 4, CellLeft, CellWidth, true );
		Style.DrawTextToFit( Canvas, drawState, X+CellLeft, Y, CellWidth, H, TXTA_Left, Left(Percent,DotLoc+2)$"%" );


		if( PlayerList[SortData[i].SortItem].LocalPlayer )
		{
			Style.FontColors[0] = Style.default.FontColors[0];
		}
	}
}

function string GetSortString( int i )
{
	return "";
}

defaultproperties
{
	StyleName="MenuOptionLabel"
	ColumnHeadings(0)="Rank"
	ColumnHeadings(1)="Name"
	ColumnHeadings(2)="Points"
	ColumnHeadings(3)="Games"
	ColumnHeadings(4)="Win"

	InitColumnPerc(0)=0.13
	InitColumnPerc(1)=0.40
	InitColumnPerc(2)=0.18
	InitColumnPerc(3)=0.15
	InitColumnPerc(4)=0.14

	SortColumn=-1
	SortDescending=False
}
class gbx_LiveCreateMatch extends gbx_CreateMatchBase;

var	moSpinListControl			spnPlayers;
var	moSpinListControl			spnPrivate;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);
	OnAButtonEvent = OnAccept;

	spnPlayers = moSpinListControl(MyComponents[1]);
	spnPrivate = moSpinListControl(MyComponents[2]);

	spnPlayers.AddFromList(PlayersSelectList);
	spnPrivate.AddFromList(StringListNoYes);

	// default to 4 players
	spnPlayers.SetIndex(1);

	if (Controller.bIsConsole)
	{
		if (class'gbx_ProfileManager'.Static.ControllerProfileExists(self, 1) && Controller.LiveFunc.IsSignedIn(1))
			Set4PModeOnly(spnPlayers);
	}
}

function string BuildLaunchString()
{
	local string launchStr;

	launchStr = Super.BuildLaunchString() $ "?WasInvited=true?Live" $ "?maxplayers=" $GetMaxPlayers(spnPlayers.GetIndex());

	if (spnPrivate.GetIndex() != 0)
	{
		launchStr = launchStr $ "?ReservedSlots=" $ GetMaxPlayers(spnPlayers.GetIndex());
	}	

	return launchStr;
}

function OnAccept()
{
	// create a split if two controllers signed in
	if (Controller.bIsConsole)
	{
		if (class'gbx_ProfileManager'.Static.ControllerProfileExists(self, 1) && Controller.LiveFunc.IsSignedIn(1))
		{
			class'gbx_ProfileManager'.Static.SetupProfiles(self);
		}

		// wire up the controllers
		Controller.ApplyControllersToViewports();
	}

	Launch();
}

defaultproperties
{
	MyComponents(1)=cSpinMenuOptionV
	MyComponents(2)=cSpinMenuOptionV

	MyCaptions(1)="Players"
	MyCaptions(2)="Private"


	ScreenTitle="Create Xbox Live Match"

	bRequireLink=true
	bRequireLive=true
	bPortLockedOnly=true
}
class gbx_LiveDashboardConfirm extends gbx_ScreenQuestion;

// Param1: <XLD_LAUNCH_DASHBOARD_ENUM> [Options]

var() localized String StringDashMain;
var() localized String StringDashError;
var() localized String StringDashMemory;
var() localized String StringDashSettings;
var() localized String StringDashMusic;
var() localized String StringDashNetwork;
var() localized String StringDashNewAccount;
var() localized String StringDashManageAccount;
var() localized String StringDashOnlineMenu;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	OnAButtonEvent = OnAccept;	// overriding gbx_ScreenQuestion
}

event HandleParameters(string Param1, string Param2)
{
    local string DashType;

	Super.HandleParameters(Param1, Param2);

    DashType = ParseToken( Param1 );

    if( DashType == "XLD_LAUNCH_DASHBOARD_MAIN_MENU" )
        SetTextPrompt(StringDashMain);
    else if( DashType == "XLD_LAUNCH_DASHBOARD_ERROR" )
        SetTextPrompt(StringDashError);
    else if( DashType == "XLD_LAUNCH_DASHBOARD_MEMORY" )
        SetTextPrompt(StringDashMemory);
    else if( DashType == "XLD_LAUNCH_DASHBOARD_SETTINGS" )
        SetTextPrompt(StringDashSettings);
    else if( DashType == "XLD_LAUNCH_DASHBOARD_MUSIC" )
        SetTextPrompt(StringDashMusic);
    else if( DashType == "XLD_LAUNCH_DASHBOARD_NETWORK_CONFIGURATION" )
        SetTextPrompt(StringDashNetwork);
    else if( DashType == "XLD_LAUNCH_DASHBOARD_NEW_ACCOUNT_SIGNUP" )
        SetTextPrompt(StringDashNewAccount);
    else if( DashType == "XLD_LAUNCH_DASHBOARD_ACCOUNT_MANAGEMENT" )
        SetTextPrompt(StringDashManageAccount);
    else if( DashType == "XLD_LAUNCH_DASHBOARD_ONLINE_MENU" )
        SetTextPrompt(StringDashOnlineMenu);
    else
    {
        GUILog( "Unknown value for ALLOW_BOOT_TO_DASH:" @ DashType );
        Controller.CloseMenu();
    }
}

function OnAccept()
{
	ConsoleCommand( "DASHBOARD" @ LParam1 );
	BaseOnAButton();
}

defaultproperties
{
    StringDashMain="You are about to leave Brothers in Arms to load the Xbox Dashboard main menu."
    StringDashError="You are about to leave Brothers in Arms to load the Xbox Dashboard diagnostic tool."
    StringDashMemory="You are about to leave Brothers in Arms."
    StringDashSettings="You are about to leave Brothers in Arms to load the Xbox Dashboard settings."
    StringDashMusic="You are about to leave Brothers in Arms to load the Xbox Dashboard music manager."
    StringDashNetwork="You are about to leave Brothers in Arms to load the Xbox Network troubleshooter."
    StringDashNewAccount="You are about to leave Brothers in Arms to create a new Xbox Live account."
    StringDashManageAccount="You are about to leave Brothers in Arms to manage your Xbox Live account."
    StringDashOnlineMenu="You are about to leave Brothers in Arms to load the Xbox Live online menu."
    
	ACaption="Yes"
	BCaption="No"

	PromptType=SPT_AREYOUSURE_PROGRESS
	QuestionType=SQT_Custom

	PagePlayerIndex=-2
	bTopMost=1
//    bShowGamertag=true
}class gbx_LiveDlgAcceptCrossTitle extends gbx_ScreenQuestion;

// Param2: <eScreenQuestionType> <eScreenPromptType>
var String Inviter, Invited;
var bool Invitation;
var bool bAccepted;
var bool bContinueJoin;

var localized String InviteTitle, JoinTitle;
var localized String InviteQuestion, JoinQuestion;


function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
    local String S;
    
	Super.InitComponent(MyController, MyOwner);

	OnAnswer = MyAnswer;
	OnOpen = InternalOnOpen;

    S = ConsoleCommand( "XLIVE GET_CROSS_TITLE_INVITE_INFO" );

    Inviter = ParseToken( S );
    Invited = ParseToken( S );
    Invitation = bool(ParseToken( S ));
    
	if (Invited != "")
	{
		if( Invitation )
		{
			SetCaption(InviteTitle);
			SetTextPrompt(InviteQuestion);
		}
		else
		{
			SetCaption(JoinTitle);
			SetTextPrompt(JoinQuestion);
		}

		ReplacePromptText( "<INVITED>", CapsL(Invited) );
		ReplacePromptText( "<INVITER>", CapsL(Inviter) );
	}
	else
	{
		if( Invitation )
			SetCaption(InviteTitle);
		else
			SetCaption(JoinTitle);

		SetTextPrompt(Controller.LiveFunc.LocalizedError("XONLINE_E_ACCOUNT_NOT_FOUND"));
		SetQuestionType(SQT_OK);
	}
}


function bool MyAnswer(string answer)
{
	if (answer ~= "OK")
	{
		ConsoleCommand( "XLIVE REJECT_CROSS_TITLE_INVITE" );
	}
	else if (answer ~= "YES")
	{
		bAccepted = true;
		Controller.BindPlayerToController(0, Controller.ControllerId);
		Controller.OpenMenu("GUI.gbx_ProfileScreenBase", "SIGNIN", Invited);
		return false;
	}
	else
	{
		return RejectJoin(self);
	}

	return true;
}

function InternalOnOpen()
{
	if (bAccepted)
	{
		bAccepted = false;
		
		if (bContinueJoin)
		{
			bContinueJoin = false;
			if (CommenceJoin(self))
			{
				Controller.ReplaceMenu("GUI.gbx_LiveDlgJoinConnecting");
			}
		}
	}
}

static function bool RejectJoin(GUIComponent me)
{
	if( "SUCCESS" != me.ConsoleCommand( "XLIVE REJECT_CROSS_TITLE_INVITE" ) )
	{
		me.Controller.LiveFunc.LiveErrorMessage("REJECT_CROSS_TITLE_INVITE_FAILED", true);
		return false;
	}

	return true;
}

static function bool CommenceJoin(GUIComponent me)
{
	local bool bResult;

	// proceed with the join if we're signed in
	if (me.Controller.LiveFunc.IsSignedIn(0))
	{
		me.GUILog("Successful authentication... Cross title join commencing...");
		if( "SUCCESS" != me.ConsoleCommand( "XLIVE ACCEPT_CROSS_TITLE_INVITE " ) )
		{
			me.Controller.LiveFunc.LiveErrorMessage("FRIEND_ACCEPT_CROSS_TITLE_INVITE_FAILED", true);

			bResult = false;
		}
		else
		{
			// add the split if controller 2 is signed in
			if (me.Controller.LiveFunc.IsSignedIn(1))
			{
				class'gbx_ProfileManager'.Static.SetupProfiles(me);
			}

			// wire up the controllers
			me.Controller.ApplyControllersToViewports();

			bResult =  true;
		}
	}

	if (!bResult)
	{
		me.Controller.BindPlayerToController(0, -1);
		me.Controller.BindPlayerToController(1, -1);
	}

	return bResult;
}

static function bool CheckForCrossTitleInvite(GUIComponent me)
{
    return "TRUE" == me.ConsoleCommand("XLIVE IS_CROSS_TITLE_INVITE");
}

static function bool DoCrossTitleInvite(GUIComponent me, optional bool bReplace)
{
    if(CheckForCrossTitleInvite(me))
    {
		if (bReplace)
			me.Controller.ReplaceMenu("GUI.gbx_LiveDlgAcceptCrossTitle");
		else
			me.Controller.OpenMenu("GUI.gbx_LiveDlgAcceptCrossTitle");
		return true;
    }

	return false;
}

static function PreloadMenu(GUIController C)
{
	Super.PreloadMenu(C);

	C.PreloadMenu("GUI.gbx_ProfileScreenBase");
}

defaultproperties
{
	QuestionType=SQT_YESNO
	PromptType=SPT_NONE

    InviteTitle="Game Invitation"
    JoinTitle="Join Game"
    
    InviteQuestion="<INVITED> has a pending game invitation from <INVITER>. Would you like to accept this invitation?"
    JoinQuestion="<INVITED> wants to join <INVITER> in a game.  Would you like to join this session?"
}
class gbx_LiveDlgAutoUpdate extends gbx_ScreenQuestion;

// Param2: <eScreenQuestionType> <eScreenPromptType>

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	OnAButtonEvent = InternalOnAButton;
}

function InternalOnAButton()
{
	ConsoleCommand("XLIVE PERSIST");
    ConsoleCommand("XLIVE UPDATE_TITLE");

	SQ_OnAButton();
}

defaultproperties
{
	QuestionType=SQT_Custom
	PromptType=SPT_None
	StringAutoTextPrompt="A required update is available for the Xbox Live service. Press A to update or B to cancel. You cannot connect to Xbox Live until the update is installed."
	ACaption="Update Now"
	BCaption="Cancel"

	PagePlayerIndex=-3
}
class gbx_LiveDlgContentDownload extends gbx_ScreenQuestion;

// Param2: <eScreenQuestionType> <eScreenPromptType>

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	OnAButtonEvent = InternalOnAButton;
}

function InternalOnAButton()
{
//    GUITODO: ConsoleCommand("XLIVE PERSIST");
    ConsoleCommand("XLIVE CONTENT_DOWNLOAD");

	SQ_OnAButton();
}

defaultproperties
{
	QuestionType=SQT_YESNO
	PromptType=SPT_None
	StringAutoTextPrompt="There is new content available for Brothers in Arms.  The content is dowloaded to your Xbox Hard Disk and is accessible through the menu.  Would you like to see what new content is available to download?"

	PagePlayerIndex=-3
}
class gbx_LiveDlgInsertDisc extends gbx_ScreenQuestion;

// Param2: <eScreenQuestionType> <eScreenPromptType>

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);
}

event HandleParameters(string Param1, string Param2)
{
	Super.HandleParameters(Param1, Param2);

    ReplaceText( lblTextPrompt.Caption, "<GAME>", Param1 );
}

defaultproperties
{
    ScreenTitle="Game Disc Required"

	QuestionType=SQT_BACK
	PromptType=SPT_None
	StringAutoTextPrompt="Please insert game disc for|<GAME>"

	PagePlayerIndex=-3
}
class gbx_LiveDlgJoinConnecting extends gbx_ScreenQuestion;

// Param2: <eScreenQuestionType> <eScreenPromptType>
var float						fGiveUpTime;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	OnAnswer = MyAnswer;

	SetTimer(0.25, true);
	fGiveUpTime = PlayerOwner().Level.UniversalTimeSeconds + 15.0;
}

function bool CanCancel()
{
	return bool(ConsoleCommand("XLIVE CAN_CANCEL_JOIN"));
}

function bool DoCancelJoin(string reason)
{
	if (CanCancel())		// we can't stop.. it's too dangerous (TM)
	{
		GUILog("gbx_LiveDlgJoinConnecting::DoCancelJoin ABORTING" @reason);

		KillTimer();

		ConsoleCommand("XLIVE REJECT_CROSS_TITLE_INVITE");	// halt any cross-title invites
		ConsoleCommand("XLIVE CANCEL_QUERY");				// halt any session queries
		ConsoleCommand("XLIVE CLEAR_RELAUNCH");				// undo the split madness
		ConsoleCommand("XLIVE CANCEL_JOIN");

		return true;
	}

	return false;
}

function bool MyAnswer(string answer)
{
	if (DoCancelJoin("MANUAL"))
		Controller.CloseMenu(true);

	return false;
}

event Timer()
{
	local string S;
	if (PlayerOwner().Level.UniversalTimeSeconds > fGiveUpTime)
	{
		if (DoCancelJoin("TIMEOUT"))
			Controller.ReplaceMenu("GUI.gbx_DlgConnectError", "ServerDown");
	}
	else
	{
		S = ConsoleCommand("XLIVE GETMATCHSTATE");
		if (S ~= "NONE")
		{
			// if the cancel doesn't let us stop, it means the join is continuing... don't close
			if (DoCancelJoin("GETMATCHSTATE=NONE"))
				Controller.CloseMenu(true);
		}
		else if (S ~= "QUERYRESULTS")
		{
			S = ConsoleCommand("XLIVE GETQUERYCOUNT");

			if (int(S) == 0)
			{
				if (DoCancelJoin("NOMATCHES"))
				{
					Controller.ReplaceMenu("GUI.gbx_DlgConnectError", "ServerDown");
				}
			}
		}
	}
}

defaultproperties
{
	QuestionType=SQT_CANCEL
	PromptType=SPT_None
    ScreenTitle="Xbox Live"
	StringAutoTextPrompt="Connecting to Xbox Live game session.  Please wait."

	PagePlayerIndex=-3
}
class gbx_LiveDlgJoinServerFull extends gbx_ScreenQuestion;

// Param2: <eScreenQuestionType> <eScreenPromptType>

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	/* TODO
    if( PC.IsSharingScreen() )
        Question.Text = Question.Text @ class'MenuStart'.default.StringGuestWillGoToo;

    Question.Text = Caps( Question.Text );
	*/

	// TODO: UC version also did some timer thing to verify the current gamer...
}

defaultproperties
{
	QuestionType=SQT_CONTINUE
	PromptType=SPT_None
	StringAutoTextPrompt="The game does not have enough openings. Press ENTER to continue."	// DO NOT MERGE INTO XBOX

	PagePlayerIndex=-3
}
class gbx_LiveDlgSignOut extends gbx_ScreenQuestion;

// Param2: <eScreenQuestionType> <eScreenPromptType>
// Param1: Change sign-in string to send to gbx_LiveEnterPasscode if non-empty.

var localized string			StringPromptSignOut;
var localized string			StringPromptSignOutGuests;
var localized string			StringPromptChangeSignIn;
var localized string			StringPromptChangeSignInGuests;
var bool						bSignedOut;

static function gbx_LiveDlgSignOut PromptSignOut(GUIController C, int inPlayerIndex, optional string Param1)
{
	default.PagePlayerIndex = inPlayerIndex;
	C.OpenMenu("GUI.gbx_LiveDlgSignOut",Param1);
	default.PagePlayerIndex = -1;

	return gbx_LiveDlgSignOut(C.ActivePage);
}

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	OnAnswer = MyAnswer;
}

event HandleParameters(string Param1, string Param2)
{
	local string S;

	Super.HandleParameters(Param1, Param2);

	if (LParam1 == "")
	{
		S = StringPromptSignOut;
		if (!Controller.LiveFunc.IsGuest(PagePlayerIndex))
			S = S @ StringPromptSignOutGuests;
	}
	else
	{
		if (!Controller.LiveFunc.IsGuest(PagePlayerIndex))
			S = StringPromptChangeSignIn;
		else
			S = StringPromptChangeSignInGuests;
	}

	SetTextPrompt(S);
}

function bool MyAnswer(string answer)
{
	local GUIController C;
	local string S;

	if (answer ~= "YES")
	{
		bSignedOut = true;

		if (LParam1 == "")
		{
			Controller.LiveFunc.SignOut(PagePlayerIndex);
		}
		else
		{
			C = Controller;
			S = LParam1;

			C.PlayClickSound(EClickSound.CS_Click);
			C.CloseMenu(false);

			C.OpenMenu("GUI.gbx_LiveEnterPasscode", S);
		}
	}

	return true;
}

defaultproperties
{
	QuestionType=SQT_YESNO
	PromptType=SPT_AREYOUSURE

	StringPromptSignOut="You are about to sign out of Xbox Live."
	StringPromptSignOutGuests="Any Guests of your account will be signed out as well."
	StringPromptChangeSignIn="You are about to sign in with another Xbox Live account.  If you sign in with another account, the current account and Guests will be signed out."
	StringPromptChangeSignInGuests="You are about to sign in with another Xbox Live account.  If you sign in with another account you will be signed out as a Guest."

	PagePlayerIndex=-1
}
class gbx_LiveDlgTravelConfirm extends gbx_ScreenQuestion;

// Param2: <eScreenQuestionType> <eScreenPromptType>

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	/* TODO
    if( PC.IsSharingScreen() )
        Question.Text = Question.Text @ class'MenuStart'.default.StringGuestWillGoToo;

    Question.Text = Caps( Question.Text );
	*/

	// TODO: UC version also did some timer thing to verify the current gamer...
}

defaultproperties
{
	QuestionType=SQT_YESNO
	PromptType=SPT_AREYOUSURE_PROGRESS
	StringAutoTextPrompt="You are about to leave the current game to join your friend in an Xbox Live session."

	PagePlayerIndex=-3
}
class gbx_LiveDlgUserHasMessage extends gbx_ScreenQuestion;

// Param2: <eScreenQuestionType> <eScreenPromptType>

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	OnAnswer = MyAnswer;

	SetTextPrompt(Localize( "Errors", "XONLINE_S_LOGON_USER_HAS_MESSAGE", "XboxLive" ));
}

function bool MyAnswer(string answer)
{
	if (answer ~= "A")
	{
		Controller.OpenMenu("GUI.gbx_LiveDashboardConfirm","XLD_LAUNCH_DASHBOARD_ACCOUNT_MANAGEMENT");
		return false;
	}

	return true;
}

defaultproperties
{
    ScreenTitle="Message Waiting"

	ACaption="Read Now"
	BCaption="Read Later"

	QuestionType=SQT_CUSTOM
	PromptType=SPT_None
}

class gbx_LiveEnterPasscode extends gbx_ScreenABXY;

enum ePasscodeEntryState
{
	PES_EnteringPasscode,
	PES_SigningIn,
	PES_SignedIn,
};

var Automated GUILabel				lblHeader;
var Automated GUILabel				lblAccount;
var Automated GUILabel				lblPasscode;

var	ePasscodeEntryState				PasscodeEntryState;
var string							PassCode[4];
var int								nCurrentPasscodeDigit;

var string							SignInAccountName;
var string							GuestLoginMode;
var bool							bAccountHasPassword;
var bool							bCloseOnActivate;	// close when reactivated...
var bool							bIsSilentSignIn;

var localized string				strPasscodeHeader;
var localized string				strSignInHeader;
var localized string				strHeaderEnterPasscode;
var localized string				strHeaderSignIn;
var localized string				strSignInSilent;
var localized string				strPasscodeErase;

// =======================================================================================================================================================
// Initialization
// =======================================================================================================================================================
function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	OnXControllerEvent = HandleXControllerEvent;
	OnActivate = InternalOnActivate;

	lblHeader.Hide();
	lblAccount.Hide();
}

event HandleParameters(string Param1, string Param2)
{
	local string S;

	Super.HandleParameters(Param1, Param2);

	S = ParseToken(Param1);
	if (S ~= "SILENT")
	{
		bIsSilentSignIn = true;
		lblAccount.Caption = strSignInSilent;
		BeginWaitForSignIn();
	}
	else
	{
		PagePlayerIndex = int(S);	// override default controller
		SignInAccountName = ParseToken(Param1);
		GuestLoginMode = Caps(ParseToken(Param1));

		lblAccount.Caption = SignInAccountName;

		GUILog("gbx_LiveEnterPasscode::HandleParameters=" $PagePlayerIndex $"," $SignInAccountName $"," $GuestLoginMode);
		bAccountHasPassword = Controller.LiveFunc.AccountNeedsPassword(SignInAccountName);

		if (!UsePasscodeEntry())
		{
			BeginAccountSignIn(false);
		}
		else
		{
			BeginPasscodeEntry();
		}
	}
}

function InternalOnActivate()
{
	if (bCloseOnActivate)
		Controller.CloseMenu(true);
}

// =======================================================================================================================================================
// Passcode entry functions
// =======================================================================================================================================================
function BeginPasscodeEntry()
{
	ResetPasscodeEntry();
	PasscodeEntryState = PES_EnteringPasscode;
	lblHeader.Caption = strPasscodeHeader;
	lblHeader.Show();
	lblAccount.Show();

	SetCaption(strHeaderEnterPasscode);
}

function ResetPasscodeEntry()
{
	PassCode[0] = "";
	PassCode[1] = "";
	PassCode[2] = "";
	PassCode[3] = "";
	nCurrentPasscodeDigit=0;

	lblPasscode.Caption = "";
	SetupAButton();
	SetupBButton(StringBack);
}

function string BuildPasscodeString(bool bRealCodes)
{
	local string s;
	local int i;

	s = "";
	if (bRealCodes)
	{
		for (i=0; i<nCurrentPasscodeDigit; i++)
		{
			s = s $ Passcode[i] $ " ";
		}
	}
	else
	{
		for (i=0; i<nCurrentPasscodeDigit; i++)
		{
			s = s $ "* ";
		}
	}

	return s;
}

function EnterPasscodeDigit(string s)
{
	if (nCurrentPasscodeDigit < 4)
	{
		Passcode[nCurrentPasscodeDigit] = s;
		nCurrentPasscodeDigit++;

		lblPasscode.Caption = BuildPasscodeString(false);

		Controller.PlayClickSound(EClickSound.CS_Change);

		// turn off the A button
		if (nCurrentPasscodeDigit == 4)
			SetupAButton(StringContinue);

		// set B button to Erase
		SetupBButton(strPasscodeErase);
	}
	else
	{
		// TODO play a beep or something
	}
}

function bool RewindPasscodeDigit()
{
	if (nCurrentPasscodeDigit > 0)
	{
		nCurrentPasscodeDigit--;
		Passcode[nCurrentPasscodeDigit] = "";

		lblPasscode.Caption = BuildPasscodeString(false);

		Controller.PlayClickSound(EClickSound.CS_Change);

		// turn off the A button
		SetupAButton();

		if (nCurrentPasscodeDigit == 0)
			SetupBButton(StringBack);

		return true;
	}
	else
	{
		SetupBButton(StringBack);
		// TODO play a beep or something
	}

	return false;
}

function bool UsePasscodeEntry()
{
	return ((GuestLoginMode != "TRUE") && bAccountHasPassword);
}

// =======================================================================================================================================================
// Account sign-in functions
// =======================================================================================================================================================
function CancelAccountSignIn(bool bSignOut)
{
	if (bSignOut)
		Controller.LiveFunc.SignOut(PagePlayerIndex);

	if (!UsePasscodeEntry())
	{
		BaseOnBButton();
	}
	else
	{
		BeginPasscodeEntry();
	}
}

function BeginWaitForSignIn()
{
	SetTimer(0.25f, true);

	PasscodeEntryState = PES_SigningIn;
	lblHeader.Caption = strSignInHeader;
	lblHeader.Show();
	lblAccount.Show();

	// set up help buttons
	SetupAButton();
	SetupBButton();
	SetCaption(strHeaderSignIn);
}

function BeginAccountSignIn(bool bPasscodeRequired)
{
	local string passcode, loginString;
	local gbx_LiveErrorMessage msgBox;

	// build the passcode
	if (bPasscodeRequired && (GuestLoginMode != "TRUE"))
		passcode = BuildPasscodeString(true);
	else
		passcode = " ";

	// build the login string
	loginString = Controller.LiveFunc.SignIn(PagePlayerIndex, SignInAccountName, passcode, GuestLoginMode);
	GUILog("BeginAccountSignIn: " $loginString);

	if (loginString == "SUCCESS")
	{
		GUILog("BeginAccountSignIn: Success");
		BeginWaitForSignIn();
	}
    else if (loginString == "FAILED_MUST_UPDATE")
    {
		Controller.ReplaceMenu("GUI.gbx_LiveDlgAutoUpdate");
	}
	else
	{
		msgBox = Controller.LiveFunc.LiveErrorMessage("");
		if (msgBox != None)
		{
			if (msgBox.LiveErrorCode != "BAD_PASSCODE")
			{
				bCloseOnActivate = true;
			}
			else
			{
				ResetPasscodeEntry();
			}
		}
	}
}

event Timer()
{
	local string s;

	s = Controller.LiveFunc.GetAuthState();
    if( s == "SIGNING_ON" || s == "CHANGING_LOGON" )
	{
        return;
	}
	else
	{
		GUILog("SignIn(Controller " $PagePlayerIndex $") : " $s $ " : " $SignInAccountName);

		if (s == "ONLINE")
		{
			// wait until the sign-in logic thinks we're signed in...
			if (bIsSilentSignIn || Controller.LiveFunc.IsSignedIn(PagePlayerIndex))
			{
				KillTimer();
				PasscodeEntryState = PES_SignedIn;
				Controller.CloseMenu(false);
			}
		}
		else if ( s == "FAILED_MUST_UPDATE" )
		{
			KillTimer();
			Controller.LiveFunc.SignOut(PagePlayerIndex);
			Controller.ReplaceMenu("GUI.gbx_LiveDlgAutoUpdate");
		}
		else if ( s == "FAILURE" || s == "BAD_STATE" || s == "ERROR" )
		{
			KillTimer();
			Controller.LiveFunc.LiveErrorMessage("", true);
		}
	}
}

// =======================================================================================================================================================
// Input handling
// =======================================================================================================================================================
function bool HandleXControllerEvent(byte Id, eXControllerCodes iCode)
{
	if ((PasscodeEntryState == PES_SignedIn) || !bVisible) return false;

	if (PasscodeEntryState == PES_SigningIn)
	{
		if ((iCode == XC_B) || (iCode == XC_Back))
		{
//			Controller.PlayClickSound(EClickSound.CS_Back);
//			CancelAccountSignIn(true);
			return true;
		}
	}
	else if (PasscodeEntryState == PES_EnteringPasscode)
	{
		switch(iCode)
		{
		case XC_B:
		case XC_Back:
			if (!RewindPasscodeDigit())
			{
				ResetPasscodeEntry();
				BaseOnBButton();
			}
			return true;
			break;

		case XC_A:
		case XC_Start:
			if (nCurrentPasscodeDigit == 4)
			{
				Controller.PlayClickSound(EClickSound.CS_Click);
				BeginAccountSignIn(true);
			}
			else
			{
				// GUITODO play a beep or something
			}

			return true;
			break;

		case XC_PadUp:
			EnterPasscodeDigit("U"); return true; break;
		case XC_PadDown:
			EnterPasscodeDigit("D"); return true; break;
		case XC_PadLeft:
			EnterPasscodeDigit("L"); return true; break;
		case XC_PadRight:
			EnterPasscodeDigit("R"); return true; break;
		case XC_X:
			EnterPasscodeDigit("X"); return true; break;
		case XC_Y:
			EnterPasscodeDigit("Y"); return true; break;
		case XC_LeftTrigger:
			EnterPasscodeDigit("LT"); return true; break;
		case XC_RightTrigger:
			EnterPasscodeDigit("RT"); return true; break;
//		case XC_Black:
//			EnterPasscodeDigit("K"); return true; break;
//		case XC_White:
//			EnterPasscodeDigit("W"); return true; break;
		}
	}

	return false;
}

// =======================================================================================================================================================
// Dialog Callbacks
// =======================================================================================================================================================

static function PreloadMenu(GUIController C)
{
	Super.PreloadMenu(C);

	C.PreloadMenu("GUI.gbx_LiveDlgAutoUpdate");
}

function bool TestControllerLoss(optional bool bOpened)
{
	if (PasscodeEntryState == PES_SigningIn)
		return false;

	return Super.TestControllerLoss(bOpened);
}

defaultproperties
{
	Begin Object Class=GUILabel Name=cEP_Header
		StyleName="Header"
		DrawMenuState=1
		TextAlign=TXTA_Center
		TextAlignV=TXTA_Right
		bMultiline=true
		bAcceptsInput=false
		bTabStop=false
		WinWidth=0.900000
		WinHeight=0.15000
		WinLeft=0.050000
		WinTop=0.250000
	End Object
	lblHeader=cEP_Header

	Begin Object Class=GUILabel Name=cEP_Account
		StyleName="Header"
		DrawMenuState=1
		TextAlign=TXTA_Center
		bAcceptsInput=false;
		bTabStop=false
		WinWidth=0.900000
		WinHeight=0.10000
		WinLeft=0.050000
		WinTop=0.400000
	End Object
	lblAccount=cEP_Account

	Begin Object Class=GUILabel Name=cEP_Passcode
		StyleName="Header"
		DrawMenuState=1
		TextAlign=TXTA_Center
		bAcceptsInput=false;
		bTabStop=false
		WinWidth=0.900000
		WinHeight=0.10000
		WinLeft=0.050000
		WinTop=0.6000000
	End Object
	lblPasscode=cEP_Passcode


	strPasscodeHeader="Please enter the Pass Code for:"
	strSignInHeader="Signing in:"
	strSignInSilent="Completing Silent Sign-In"
	strHeaderEnterPasscode="Enter Pass Code"
	strHeaderSignIn="Sign-In"
	strPasscodeErase="Erase"

	PasscodeEntryState=PES_EnteringPasscode
	nCurrentPasscodeDigit=0

	bCloseOnActivate=false
	bMergeAxesToPads=false

}
class gbx_LiveErrorMessage extends gbx_ScreenABXY;

// Args: <OPERATION_NAME>

var() Automated GUILabel lblErrorText;
/*
var() Automated GUILabel lblServiceNumber;
var() Automated GUILabel lblServiceCode;

var() Automated GUILabel lblErrorNumber;
var() Automated GUILabel lblErrorCode;
*/
var() String LiveErrorCode;
var() String LiveErrorNumber;
var() String LiveErrorString;

var() String LiveServiceCode;
var() String LiveServiceNumber;
var() String LiveServiceString;

var string	LastLiveErrorString;
var string	LastAuthErrorCode;

const LivePrefix = "XONLINE_";

var() String LastErrorDash;
var() localized String StringDashMain;
var() localized String StringDashError;
var() localized String StringDashMemory;
var() localized String StringDashSettings;
var() localized String StringDashMusic;
var() localized String StringDashNetwork;
var() localized String StringDashNewAccount;
var() localized String StringDashManageAccount;
var() localized String StringDashOnlineMenu;

var() localized String StringReadMessage;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	// suppress if we're outside of a live match/main menu
	if (!Controller.LiveFunc.IsLiveMode() && !PlayerOwner().Level.IsMenuMap())
	{
		Controller.CloseMenu(false);
		return;
	}

	OnAButtonEvent = OnAccept;
	OnBButtonEvent = OnBack;
}


event HandleParameters(string Param1, string Param2)
{
    local String OperationName;
    local String S;
	local string DashErrorString;

    Super.HandleParameters( Param1, Param2 );

    OperationName = Param1;
        
    LastErrorDash = ConsoleCommand("XLIVE ALLOW_BOOT_TO_DASH");
  
	if (LastErrorDash == "")
		DashErrorString = "";
    if( LastErrorDash == "XLD_LAUNCH_DASHBOARD_MAIN_MENU" )
		DashErrorString = StringDashMain;
    else if( LastErrorDash == "XLD_LAUNCH_DASHBOARD_ERROR" )
		DashErrorString = StringDashError;
    else if( LastErrorDash == "XLD_LAUNCH_DASHBOARD_MEMORY" )
		DashErrorString = StringDashMemory;
    else if( LastErrorDash == "XLD_LAUNCH_DASHBOARD_SETTINGS" )
		DashErrorString = StringDashSettings;
    else if( LastErrorDash == "XLD_LAUNCH_DASHBOARD_MUSIC" )
		DashErrorString = StringDashMusic;
    else if( LastErrorDash == "XLD_LAUNCH_DASHBOARD_NETWORK_CONFIGURATION" )
		DashErrorString = StringDashNetwork;
    else if( LastErrorDash == "XLD_LAUNCH_DASHBOARD_NEW_ACCOUNT_SIGNUP" )
		DashErrorString = StringDashNewAccount;
    else if( LastErrorDash == "XLD_LAUNCH_DASHBOARD_ACCOUNT_MANAGEMENT" )
		DashErrorString = StringDashManageAccount;
    else if( LastErrorDash == "XLD_LAUNCH_DASHBOARD_ONLINE_MENU" )
		DashErrorString = StringDashOnlineMenu;
    else
	{
        GUILog( "Unknown value for ALLOW_BOOT_TO_DASH:" @ LastErrorDash );
	}
    
	SetupBButton(DashErrorString);

    S = ReadLastErrorString(self);
	GUILog("LASTERROR result=" $S);

    LiveErrorCode = ParseToken(S);
    LiveErrorNumber = ParseToken(S);
    LiveErrorString = ParseToken(S);

    LiveServiceCode = ParseToken(S);
    LiveServiceNumber = ParseToken(S);
    LiveServiceString = ParseToken(S);

	if (Param2 != "")
	{
		LiveErrorCode = Param2;
	}

	GUILog("LiveErrorCode=" $LiveErrorCode);
    if( ForceLogoff() )
    {
        GUILog("Forcing logoff:"@ LiveErrorCode);
        ConsoleCommand("XLIVE LOGOFF -1");
    }
/*
    lblErrorCode.Caption = lblErrorCode.Caption @ LiveErrorCode;
    lblErrorNumber.Caption = lblErrorNumber.Caption @ LiveErrorNumber;

    lblServiceCode.Caption = lblServiceCode.Caption @ LiveServiceCode;
    lblServiceNumber.Caption = lblServiceNumber.Caption @ LiveServiceNumber;
*/
	if (LiveErrorCode == "XONLINE_E_NOTIFICATION_USER_ALREADY_EXISTS")
	{
        lblErrorText.Caption = LiveErrorString;
		SetupAButton(StringContinue);
	}
	else if (LiveErrorCode == "XONLINE_E_FRIENDS_LIST_ERROR")
	{
        lblErrorText.Caption = Controller.LiveFunc.LocalizedError(OperationName);
		SetupAButton(StringContinue);
	}
    else if( (OperationName != "") && 
		(LiveErrorCode != "XONLINE_E_LOGON_USER_ACCOUNT_REQUIRES_MANAGEMENT") && 
		(LiveErrorCode != "XONLINE_E_LOGON_INVALID_USER") )
	{
        lblErrorText.Caption = Controller.LiveFunc.LocalizedError(OperationName) @ LiveErrorString;
	}
    else
	{
        lblErrorText.Caption = LiveErrorString;
	}

	if (LiveErrorCode == "BAD_PASSCODE")
	{
        SetupBButton(StringCancel);
	}
	else if( (LiveErrorCode == "XONLINE_E_CANNOT_ACCESS_SERVICE") || 
		(LiveErrorCode == "XONLINE_E_LOGON_CANNOT_ACCESS_SERVICE") || 
		(LiveErrorCode == "XONLINE_E_LOGON_CONNECTION_LOST") || 
		(LiveErrorCode == "XONLINE_E_LOGON_NO_NETWORK_CONNECTION") )
    {
        lblErrorText.Caption = LiveErrorString;
		SetupAButton(DashErrorString);
        SetupBButton(StringCancel);
    }
    else if( LiveErrorCode == "XONLINE_E_ACCOUNT_NOT_FOUND" )
    {
        lblErrorText.Caption = LiveErrorString;
		SetupAButton(StringContinue);
        SetupBButton();
    }
    else if( LiveErrorCode == "XONLINE_E_LOGON_USER_ACCOUNT_REQUIRES_MANAGEMENT" )
    {
        SetupAButton(StringReadMessage);
        SetupBButton(StringCancel);
    }
    else if( LiveErrorCode == "XONLINE_E_LOGON_INVALID_USER" )
    {
        SetupAButton(DashErrorString);
        SetupBButton(StringCancel);
    }

    if( InStr(LiveErrorCode, LivePrefix) >= 0 )
    {
        if( LiveServiceString != "" )
            lblErrorText.Caption = LiveServiceString @ LiveErrorCode;
    }

	GUILog("gbx_LiveErrorMessage : " $ lblErrorText.Caption);
}

simulated function bool StartsWith( String TestString, String Prefix )
{
    return( Left( TestString, Len( Prefix) ) == Prefix );
}

function OnBack()
{
	local GUIController C;

	if (LiveErrorCode == "BAD_PASSCODE")
	{
		C = Controller;
		if (ParentPage.IsA('gbx_LiveEnterPasscode'))
		{
			BaseOnBButton();
			C.CloseMenu(true);
		}
		else
		{
			BaseOnBButton();
		}
	}
    else if
    (
        (LiveErrorCode == "XONLINE_E_CANNOT_ACCESS_SERVICE") ||
        (LiveErrorCode == "XONLINE_E_LOGON_CANNOT_ACCESS_SERVICE") ||
		(LiveErrorCode == "XONLINE_E_LOGON_CONNECTION_LOST") || 
        (LiveErrorCode == "XONLINE_E_LOGON_USER_ACCOUNT_REQUIRES_MANAGEMENT") ||
        (LiveErrorCode == "XONLINE_E_LOGON_INVALID_USER") ||
        (LiveErrorCode == "XONLINE_E_ACCOUNT_NOT_FOUND") ||
        (LiveErrorCode == "XONLINE_E_LOGON_NO_NETWORK_CONNECTION")
    )
    {
		ForceLogoffPost();
    
		if (Controller.LiveFunc.IsLiveMode())
		{
			Disconnect(true);
		}
		else
		{
			BaseOnBButton();
		}
    }    
    else
    {
		Controller.OpenMenu("GUI.gbx_LiveDashboardConfirm",LastErrorDash);
    }
}

simulated function ForceLogoffPost()
{
    if
    (
        (LiveErrorCode == "XONLINE_E_LOGON_INVALID_USER") ||
        (LiveErrorCode == "XONLINE_E_LOGON_USER_ACCOUNT_REQUIRES_MANAGEMENT")
    )
    {
        GUILog("Post-Forcing logoff:"@ LiveErrorCode);
        ConsoleCommand("XLIVE LOGOFF -1");
	}
}

simulated function bool ForceLogoff()
{
    if
    (
        StartsWith( LiveErrorCode, "PLAYER_" ) ||
        StartsWith( LiveErrorCode, "FRIEND_" ) ||
        StartsWith( LiveErrorCode, "STATS_" ) ||
        StartsWith( LiveErrorCode, "MATCHMAKING_" ) ||
        (LiveErrorCode == "BAD_PASSCODE") ||
        (LiveErrorCode == "XONLINE_E_FRIENDS_LIST_ERROR") ||
        (LiveErrorCode == "XONLINE_E_LOGON_INVALID_USER") ||
        (LiveErrorCode == "XONLINE_E_ACCOUNT_NOT_FOUND") ||
        (LiveErrorCode == "XONLINE_E_LOGON_USER_ACCOUNT_REQUIRES_MANAGEMENT") ||
        (LiveErrorCode == "FRIEND_ACCEPT_CROSS_TITLE_INVITE_FAILED") ||
        (LiveErrorCode == "XONLINE_E_NOTIFICATION_LIST_FULL") ||
        (LiveErrorCode == "XONLINE_E_NOTIFICATION_USER_ALREADY_EXISTS")
    )
    {
        return false;
    }
    else
    {
        return true;
    }
 
}

function OnAccept()
{
    if( 
		(LiveErrorCode == "XONLINE_E_CANNOT_ACCESS_SERVICE") || 
		(LiveErrorCode == "XONLINE_E_LOGON_CANNOT_ACCESS_SERVICE") || 
		(LiveErrorCode == "XONLINE_E_LOGON_USER_ACCOUNT_REQUIRES_MANAGEMENT") || 
		(LiveErrorCode == "XONLINE_E_LOGON_CONNECTION_LOST") || 
        (LiveErrorCode == "XONLINE_E_LOGON_INVALID_USER") ||
		(LiveErrorCode == "XONLINE_E_LOGON_NO_NETWORK_CONNECTION") )
    {
		Controller.OpenMenu("GUI.gbx_LiveDashboardConfirm",LastErrorDash);
    }
    else if
    (
        StartsWith( LiveErrorCode, "PLAYER_" ) ||
        StartsWith( LiveErrorCode, "FRIEND_" ) ||
        StartsWith( LiveErrorCode, "STATS_" ) ||
        StartsWith( LiveErrorCode, "MATCHMAKING_" ) ||
        (LiveErrorCode == "BAD_PASSCODE") ||
        (LiveErrorCode == "XONLINE_E_FRIENDS_LIST_ERROR") ||
        (LiveErrorCode == "XONLINE_E_NOTIFICATION_USER_ALREADY_EXISTS") ||
        (LiveErrorCode == "XONLINE_E_ACCOUNT_NOT_FOUND") ||
        (LiveErrorCode == "XONLINE_E_NOTIFICATION_LIST_FULL")
    )
    {
        // Let them go back to the last menu they were at.
		BaseOnAButton();
    }
    else if( LiveErrorCode == "FRIEND_ACCEPT_CROSS_TITLE_INVITE_FAILED" )
    {
		// GUITODO: back to the main menu or something...
//        GotoMenuClass("XInterfaceLive.MenuLiveMain");
		BaseOnAButton();
    }
    else
    {
		if (Controller.LiveFunc.IsLiveMode())
		{
			Disconnect(true);
		}
		else
		{
			BaseOnAButton();
		}
    }
}

static function string ReadLastErrorString(optional GUIComponent me)
{
	local string S;
	if (me == None)
	{
		default.LastLiveErrorString = "";
		default.LastAuthErrorCode = "";
	}
	else if (default.LastLiveErrorString == "")
	{
		default.LastLiveErrorString = me.ConsoleCommand("XLIVE LASTERROR");

		S = default.LastLiveErrorString;
		default.LastAuthErrorCode = ParseToken(S);
	}

	return default.LastLiveErrorString;
}

static function PreloadMenu(GUIController C)
{
	Super.PreloadMenu(C);

	C.PreloadMenu("GUI.gbx_LiveDashboardConfirm");
}

function TestLinkLiveLoss(optional bool bOpened)
{
	if (!Controller.bIsConsole || (Controller.ActivePage != self))
		return;

	if (TestControllerLoss(bOpened))
		return;
}

defaultproperties
{
	ScreenTitle="Xbox Live"
	Background=Texture'WhiteTexture'
	BackgroundColor=(R=13,G=5,B=8,A=235)
	BackgroundRStyle=MSTY_Alpha

	Begin Object Class=GUILabel Name=cErrorText
		StyleName="LargeButton"
		DrawMenuState=1
		TextAlign=TXTA_Center
		TextAlignV=TXTA_Center
		bAcceptsInput=false;
		bMultiLine=true
		bTabStop=false
		WinWidth=0.800000
		WinHeight=0.50000
		WinLeft=0.100000
		WinTop=0.200000
	End Object
	lblErrorText=cErrorText

//    ServiceNumber=(bHidden=1,Text="SERVICE NUMBER:",PosX=0.90,PosY=0.68,DrawPivot=DP_MiddleRight,Style=LabelText,MaxSizeX=0.80)
//    ServiceCode=(bHidden=1,Text="",PosX=0.90,PosY=72,DrawPivot=DP_MiddleRight,Style=LabelText,MaxSizeX=0.80)

//    ErrorNumber=(bHidden=1,Text="ERROR NUMBER:",PosX=0.90,PosY=0.76,DrawPivot=DP_MiddleRight,Style=LabelText,MaxSizeX=0.80)
//    ErrorCode=(bHidden=1,Text="",PosX=0.90,PosY=0.80,DrawPivot=DP_MiddleRight,Style=LabelText,MaxSizeX=0.80)

	ACaption="Continue"
    BCaption=""

    StringDashMain="Dashboard"
    StringDashError="Diagnostics"
    StringDashMemory="Memory Manager"
    StringDashSettings="Settings"
    StringDashMusic="Music Browser"
    StringDashNetwork="Troubleshooter"
    StringDashNewAccount="Create Account"
    StringDashManageAccount="Manage Account"
    StringDashOnlineMenu="Online Menu"
    
    StringReadMessage="Read Message"

	PagePlayerIndex=-3
	bAllowedAsLast=true
	bTopMost=1
//    bShowGamertag=true
//    bFullscreenOnly=true
}
class gbx_LiveFeedbackScreen extends gbx_LiveGamerScreen;

var String						FeedbackCommand;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	OnAButtonEvent = InternalOnAButton;

	MapControls();
	FocusFirst(none);
}

// just want to eat the default behavior
function InternalOnAButton();

function bool ConfirmAnswer(string answer)
{
	if (answer == "YES")
	{
		Controller.PlayClickSound(EClickSound.CS_Click);

		DoSendFeedback();	
		return false;
	}

	FeedbackCommand = "";
	return true;
}

function bool DoSendFeedback()
{
	if ("SUCCESS" != ConsoleCommand( FeedbackCommand ))
	{
		Controller.LiveFunc.LiveErrorMessage("PLAYER_SEND_FEEDBACK_FAILED", true);
		return false;
	}
	else
	{
		Controller.ReplaceMenu("GUI.gbx_LiveGamerFeedbackSent");
		return true;
	}
}

function OpenFeedbackConfirm(String FeedbackText)
{
	local gbx_LiveGamerFeedbackConfirm dlg;

	Controller.OpenMenu("GUI.gbx_LiveGamerFeedbackConfirm");

	dlg = gbx_LiveGamerFeedbackConfirm(Controller.ActivePage);
	if (dlg == None)
	{
		GUILog("##### OpenFeedbackConfirm failed to open the feedback confirm dialog #####");
		return;
	}

	dlg.OnAnswer = ConfirmAnswer;
	dlg.SetUp(CurrentGamer, FeedbackText);
}

function HandleFeedback(string FeedbackEnum, optional string ConfirmCaption)
{
	FeedbackCommand = "XLIVE FRIENDS USER=" $ PagePlayerIndex @ "PLAYER FEEDBACK" @ FeedbackEnum @ "GAMERTAG=\"" $ CurrentGamer.Gamertag $ "\"";
	GUILog("HandleFeedback:"@FeedbackCommand);

	if (ConfirmCaption != "")
	{
		OpenFeedbackConfirm( ConfirmCaption );
	}
	else
	{
		DoSendFeedback();
	}
}

static function PreloadMenu(GUIController C)
{
	Super.PreloadMenu(C);

	C.PreloadMenu("GUI.gbx_LiveGamerFeedbackSent");
	C.PreloadMenu("GUI.gbx_LiveGamerFeedbackConfirm");
}

defaultproperties
{
	PagePlayerIndex=-3
	ScreenTitle="Send Feedback"
	LayoutPivotPoint=0.525
	LayoutSpacing=0.005
	LayoutPivotStyle=LA_Center

	Begin Object Class=GUIButton Name=cFeedbackButton
		StyleName="MenuOptionCaption"
		WinWidth=0.800000
		WinHeight=0.04500
		WinLeft=0.100000
		WinTop=0.250000
		TabOrder=0
		bForceCaps=true
	End Object
	Begin Object Class=GUILabel Name=cFeedbackHeader
		TextAlign=TXTA_Center
		StyleName="SquareButton"
		WinWidth=0.800000
		WinHeight=0.055000
		WinLeft=0.100000
		WinTop=0.250000
		bNeverFocus=true
		bTabStop=false
		bAcceptsInput=false
		bTransparent=false
		bForceCaps=true
	End Object

	StringInfoHeader="Feedback For :"

	ACaption="Choose"
	BCaption="Cancel"
}

class gbx_LiveFriendOptions extends gbx_LiveGamerOptions;


function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);
}

function InitCustomOptions()
{
	local bool bCanCancelInvite;

	Super.InitCustomOptions();

    if( CurrentGamer.bIsFriend != 0 )
	{
		// already friends...
		// remove
		MyComponents[EOptionButton.OB_FRIEND_REMOVE].Show();

		bCanCancelInvite = (CurrentGamer.bSentInvite != 0) && ( CurrentGamer.bInviteAccepted == 0 ) && ( CurrentGamer.bInviteRejected == 0 );

		// send invitaion
        if( (CurrentGamer.bInvitable != 0) && !bCanCancelInvite)
			MyComponents[EOptionButton.OB_INVITATION_SEND].Show();

		// sent invitation
		// cancel
        if( bCanCancelInvite )
        {
			MyComponents[EOptionButton.OB_INVITATION_CANCEL].Show();
        }

        if( CurrentGamer.bReceivedInvite != 0 )
        {
			// received invitaion
			// accept, decline
			MyComponents[EOptionButton.OB_INVITATION_ACCEPT].Show();
			MyComponents[EOptionButton.OB_INVITATION_DECLINE].Show();

			if (CurrentGamer.bReceivedInviteHasVoiceAttachment != 0)
			{
				MyComponents[EOptionButton.OB_PLAY_VOICE_ATTACHMENT].Show();
			}
        }
        else if( (CurrentGamer.bOnline != 0) && (CurrentGamer.bJoinable != 0) )
        {
			// didn't receive an invite but they're joinable
			// join game
			MyComponents[EOptionButton.OB_FRIEND_JOIN_GAME].Show();
        }
	}
	else
	{
		if ( (CurrentGamer.bSentRequest != 0) && (CurrentGamer.bReceivedRequest != 0))
		{
			GUILog("Yikes, non-friend in friends list!");
			MyComponents[EOptionButton.OB_FRIEND_REMOVE].Show();
			MyComponents[EOptionButton.OB_FRIEND_REQUEST_SEND].Hide();
		}
	}
}


defaultproperties
{
	ScreenTitle="Friend Options"
}
class gbx_LiveFriendsList extends gbx_LiveGamerList;

static function LaunchFriendsList(GUIController C, int inPlayerIndex, optional bool bNoSound)
{
	local int cIndex;
	
	if ((inPlayerIndex >= 0) && (inPlayerIndex <= 1))
	{
		cIndex = C.GetControllerIndexForPlayer(inPlayerIndex);
		if ((cIndex != -1) && C.LiveFunc.IsSignedIn(inPlayerIndex) && !C.LiveFunc.IsGuest(inPlayerIndex))
		{
			class'GUI.gbx_LiveFriendsList'.default.PagePlayerIndex = inPlayerIndex;

			if (!bNoSound)
				C.PlayClickSound(EClickSound.CS_Click);
			C.OpenMenu("GUI.gbx_LiveFriendsList");

			class'GUI.gbx_LiveFriendsList'.default.PagePlayerIndex = -1;
		}
	}
}

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	InitExecution();
}

function InternalOnOpen()
{
    GotoState('WaitingForLogin');
}

function GetGamerList()
{
	Controller.GetGamers(Gamers, PagePlayerIndex, false);
}

function OnAccept();

// =======================================================================================================================================================
// =======================================================================================================================================================
// state logic
// =======================================================================================================================================================
// =======================================================================================================================================================
state WaitingForLogin
{
    simulated function BeginState()
    {
        SetTimer( 0.33, true );
        Timer();
    }

    simulated function Timer()
    {
        if( ConsoleCommand("XLIVE GETAUTHSTATE") == "ONLINE" )
            GotoState('LoggedIn');
    }

	function OnAccept();
}

state LoggedIn
{
    simulated function BeginState()
    {
		BeginUpdate();
    }

	function InternalOnOpen()
	{
		GUILog("LoggedIn:InternalOnOpen");
		RefreshList();
	}

	function OnAccept()
	{
		Super.OnAccept();
		Controller.OpenMenu("GUI.gbx_LiveFriendOptions");
	}
}

static function PreloadMenu(GUIController C)
{
	Super.PreloadMenu(C);

	C.PreloadMenu("GUI.gbx_LiveFriendOptions");
}

defaultproperties
{
	strDirtyCommand="FRIENDSISDIRTY"
	strUpdateCommand="GETFRIENDS"

	ScreenTitle="Friends List"
	TextEmptyList="Your Friends List is currently empty."
}
class gbx_LiveFunc extends GUI;

/*
var() localized String StringDashMain;
var() localized String StringDashError;
var() localized String StringDashMemory;
var() localized String StringDashSettings;
var() localized String StringDashMusic;
var() localized String StringDashNetwork;
var() localized String StringDashNewAccount;
var() localized String StringDashManageAccount;
var() localized String StringDashOnlineMenu;
*/

function bool IsLinkActive()
{
	//###+ lbouchard: LINKLOSS: We test link loss even on PC, for Ubi.com menus
	return (class'GameService.GameService'.static.IsOnline());
	//oldcode return ConsoleCommand("XLIVE GET_LINK_ACTIVE") == "TRUE";
        //###-
}

function bool IsLiveMode()
{
	return int( ConsoleCommand("XLIVE IS_LIVE_MODE") ) != 0;
}

function bool IsSystemLinkMode()
{
	return int( ConsoleCommand("IS_SYSTEMLINK_MODE") ) != 0;
	//oldcode return int( ConsoleCommand("XLIVE IS_SYSTEMLINK_MODE") ) != 0;
}

function bool IsControllerConnected(int ControllerIndex)
{
	return ConsoleCommand("XCLIENT CONTROLLER_CONNECTED" @ ControllerIndex) == "TRUE";
}

function bool IsControllerLost(int ControllerIndex)
{
	return ConsoleCommand("XCLIENT CONTROLLER_LOST" @ ControllerIndex) == "TRUE";
}

// =======================================================================================================================================================
// Sign In
// =======================================================================================================================================================
function bool IsAccountSignedIn(string accountName)
{
	local int i;

	for (i=0; i<4; i++)
	{
		if (GetGamerTag(i) == accountName)
			return true;
	}

	return false;
}

function bool IsValidControllerIndex(int ControllerIndex)
{
	return (ControllerIndex >= 0) && (ControllerIndex <= 4);
}

function bool IsGuest(int ControllerIndex)
{
	local string s;

	if (!IsValidControllerIndex(ControllerIndex)) return false;

	s = ConsoleCommand( "XLIVE GET_GAMER_XUID " $ControllerIndex );
	if (s != "")
	{
		return ConsoleCommand( "XLIVE IS_GUEST " $s ) == "TRUE";
	}

	return false;
}

function bool IsSignedIn(int ControllerIndex)
{
	if (!IsValidControllerIndex(ControllerIndex)) return false;

	return ConsoleCommand( "XLIVE GET_GAMER_XUID " $ControllerIndex ) != "";
}

function int GetFirstSignedInController()
{
	local int i;
	for (i=0; i<4; i++)
	{
		if (Controller.LiveFunc.IsSignedIn(i))
			return i;
	}

	return -1;
}

function string SignIn(int ControllerIndex, string AccountName, string passcode, string GuestLoginMode)
{
	if (!IsValidControllerIndex(ControllerIndex)) return "";

	class'gbx_LiveErrorMessage'.static.ReadLastErrorString();
	return ConsoleCommand( "XLIVE LOGON " $ControllerIndex $" \"" $AccountName $"\" \"" $passcode $"\" " $GuestLoginMode );
}

function string SignOut(int ControllerIndex)
{
	class'gbx_LiveErrorMessage'.static.ReadLastErrorString();
	return ConsoleCommand("XLIVE LOGOFF " $ControllerIndex);
}

function bool IsOffLine()
{
	local string S;

	S = GetAuthState();
	return ((S ~= "OFFLINE") || (S ~= "ERROR") || (S ~= "FAILED_MUST_UPDATE") || (S ~= "BAD_STATE")) && (GetFirstSignedInController() == -1);
}

function bool IsSigningIn()
{
	local string S;

	S = GetAuthState();
	return (S ~= "SIGNING_ON") || (S ~= "SIGNING_ON_SILENT") || (S ~= "CHANGING_LOGON");
}

function string GetAuthState()
{
	return ConsoleCommand( "XLIVE GETAUTHSTATE" );
}

function string GetUserAuthState(int ControllerIndex)
{
	if (!IsValidControllerIndex(ControllerIndex)) return "";

	return ConsoleCommand( "XLIVE GETUSERAUTHSTATE USER=" $ControllerIndex);
}

function string GetGamerTag(int ControllerIndex)
{
	local string result;

	if (!IsValidControllerIndex(ControllerIndex)) return "";

	result = "";
	if (IsSignedIn(ControllerIndex))
		result = ConsoleCommand( "XLIVE GET_GAMER_TAG " $ControllerIndex );

	return result;
}

function bool AccountNeedsPassword(string AccountName)
{
	return ConsoleCommand( "XLIVE REQUIRE_PASSCODE \"" $ AccountName $ "\"" ) == "TRUE";
}

function gbx_LiveErrorMessage LiveErrorMessage(string msg, optional bool bReplace, optional string strErrorCode)
{
	if (bReplace)
		Controller.ReplaceMenu("GUI.gbx_LiveErrorMessage", msg, strErrorCode);
	else
		Controller.OpenMenu("GUI.gbx_LiveErrorMessage", msg, strErrorCode);

	return gbx_LiveErrorMessage(Controller.ActivePage);
}

// =======================================================================================================================================================
// Gamers (Friends / Players)
// =======================================================================================================================================================

function string LocalizedError(string S)
{
	return Localize( "Errors", S, "XboxLive" );
}

defaultproperties
{
    //StringDashMain="You are about to leave Brothers in Arms to load the Xbox Dashboard main menu."
    //StringDashError="You are about to leave Brothers in Arms to load the Xbox Dashboard diagnostic tool."
    //StringDashMemory="You are about to leave Brothers in Arms."
    //StringDashSettings="You are about to leave Brothers in Arms to load the Xbox Dashboard settings."
    //StringDashMusic="You are about to leave Brothers in Arms to load the Xbox Dashboard music manager."
    //StringDashNetwork="You are about to leave Brothers in Arms to load the Xbox Network troubleshooter."
    //StringDashNewAccount="You are about to leave Brothers in Arms to create a new Xbox Live account."
    //StringDashManageAccount="You are about to leave Brothers in Arms to manage your Xbox Live account."
    //StringDashOnlineMenu="You are about to leave Brothers in Arms to load the Xbox Live online menu."
}class gbx_LiveGamerConfirm extends gbx_ScreenQuestion
	dependson(gbx_LiveGamerList);

var gbx_LiveGamerList.Gamer		CurrentGamer;

var() String 					CommandText;
var() String 					FailedOperation;
var() String 					FailedErrorCode;
var() bool						bAcceptToList;	// accepting goes to friends list (pops twice)


function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	OnAButtonEvent = InternalOnAButton;
}

function SetUp( string prompt, string cmd, string failed )
{
	lblTextPrompt.Caption = prompt;
	CommandText = cmd;
	FailedOperation = failed;

    ReplaceText( lblTextPrompt.Caption, "<GAMER>", class'gbx_LiveGamerList'.Static.FormatGamerName(CurrentGamer) );
}

function InternalOnAButton()
{
	local GUIController c;

	Controller.PlayClickSound(EClickSound.CS_Click);

	if( "SUCCESS" != ConsoleCommand( CommandText ) )
	{
		Controller.LiveFunc.LiveErrorMessage(FailedOperation, true, FailedErrorCode);
	}
    else
    {
		c = Controller;
		SQ_OnAButton();

		if (bAcceptToList)
			class'gbx_LiveGamerList'.static.CloseToGamerList(c);
    }
}

defaultproperties
{
	PagePlayerIndex=-3

	ScreenTitle="Please Confirm"
	CommandText=""
	FailedOperation=""
	FailedErrorCode=""
	bAcceptToList=false;
	QuestionType=SQT_YESNO
	PromptType=SPT_None

	bRequireLink=true
	bRequireLive=true
	PlayerStatusDisplayStyle=CD_Signin
}
class gbx_LiveGamerFeedback extends gbx_LiveFeedbackScreen;


function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);
}

function bool OnComponentActivate(int button, GUIComponent Sender)
{
	switch (button)
	{
	// GOOD ATTITUDE
	case 1:
		HandleFeedback("XONLINE_FEEDBACK_POS_ATTITUDE");
		return true;

	// GREAT SESSION
	case 2:
		HandleFeedback("XONLINE_FEEDBACK_POS_SESSION");
		return true;

	// BAD NAME
	case 4:
		HandleFeedback("XONLINE_FEEDBACK_NEG_NICKNAME", MyCaptions[button]);
		return true;

	// POOR GAMEPLAY OR CHEATING
	case 5:
		HandleFeedback("XONLINE_FEEDBACK_NEG_GAMEPLAY", MyCaptions[button]);
		return true;

	// SPAMMING OR SCREAMING
	case 6:
		HandleFeedback("XONLINE_FEEDBACK_NEG_SCREAMING", MyCaptions[button]);
		return true;

	// THREATS OR HARASSMENT
	case 7:
		HandleFeedback("XONLINE_FEEDBACK_NEG_HARASSMENT", MyCaptions[button]);
		return true;

	// CURSING OR LEWDNESS
	case 8:
		HandleFeedback("XONLINE_FEEDBACK_NEG_LEWDNESS", MyCaptions[button]);
		return true;
	}

	return false;
}

defaultproperties
{
	MyComponents(0)=cFeedbackHeader
	MyComponents(1)=cFeedbackButton
	MyComponents(2)=cFeedbackButton
	MyComponents(3)=cFeedbackHeader
	MyComponents(4)=cFeedbackButton
	MyComponents(5)=cFeedbackButton
	MyComponents(6)=cFeedbackButton
	MyComponents(7)=cFeedbackButton
	MyComponents(8)=cFeedbackButton

	MyCaptions(0)="Feedback"
	MyCaptions(1)="Good Attitude"
	MyCaptions(2)="Great Session"
	MyCaptions(3)="Complaints"
	MyCaptions(4)="Bad Name"
	MyCaptions(5)="Cheating"
	MyCaptions(6)="Screaming"
	MyCaptions(7)="Threats or Harassment"
	MyCaptions(8)="Cursing or Lewdness"
}
class gbx_LiveGamerFeedbackConfirm extends gbx_ScreenQuestion;

var() Automated GUILabel			lblFeedbackPrompt;
var automated array<moLabel>		ComplaintInfo;
var localized array<string>			ComplaintInfoCaptions;
var localized string				FeedbackInfo;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	local int i;

	Super.InitComponent(MyController, MyOwner);

	for (i=0; i<ComplaintInfo.Length; i++)
	{
		ComplaintInfo[i].MyLabel2.bForceCaps = true;
		ComplaintInfo[i].SetCaption(ComplaintInfoCaptions[i]);
	}

	ComplaintInfo[2].SetText(StringBiA);

	lblFeedbackPrompt.SetCaption(FeedbackInfo);
	LayoutControlArray(ComplaintInfo, 0.17, 0.0, LA_Left_Top);
	MapControls();
	FocusFirst(none);
}

function SetUp(out Gamer G, String FeedbackText)
{
	ComplaintInfo[0].SetText(FeedbackText);
	ComplaintInfo[1].SetText(G.Gamertag);
}

defaultproperties
{
	PagePlayerIndex=-3
	ScreenTitle="Feedback Confirm"

	QuestionType=SQT_YESNO
	PromptType=SPT_None
	bHideParent=true

	Begin Object Class=moLabel Name=cComplaintInfo
		CompStyle="MenuOptionLabel"
		LabelJustification=TXTA_Center
		CaptionWidth=0.50
		ComponentWidth=0.40
		WinWidth=0.7000000
		WinHeight=0.1000
		WinLeft=0.1500000
		WinTop=0.28000
		bHeightFromComponent=false
		bVerticalLayout=true
		bNeverFocus=true
		bTabStop=false
	End Object

	ComplaintInfo(0)=cComplaintInfo
	ComplaintInfo(1)=cComplaintInfo
	ComplaintInfo(2)=cComplaintInfo

	ComplaintInfoCaptions(0)="Complaint"
	ComplaintInfoCaptions(1)="Gamertag"
	ComplaintInfoCaptions(2)="Game Name"

	FeedbackInfo="The Xbox Live community is managed by its users.  Multiple reports from other users about this Gamer can lead to Voice Banning, Lockout, and Account Termination.  Do you wish to proceed with your complaint?"
	Begin Object Class=GUILabel Name=cFeedbackPrompt
		StyleName="TextLabel"
		DrawMenuState=1
		TextAlign=TXTA_Center
		bAcceptsInput=false;
		bMultiLine=true
		bTabStop=false
		bForceCaps=true
		WinWidth=0.800000
		WinHeight=0.200000
		WinLeft=0.100000
		WinTop=0.580000
	End Object
	lblFeedbackPrompt=cFeedbackPrompt
}
class gbx_LiveGamerFeedbackSent extends gbx_ScreenQuestion;


function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	OnAButtonEvent = InternalOnAButton;
}

function InternalOnAButton()
{
	local GUIController c;
	c = Controller;

	SQ_OnAButton();
	c.CloseMenu(false);
}

defaultproperties
{
	PagePlayerIndex=-3
	ScreenTitle="FEEDBACK SENT"
	StringAutoTextPrompt="Your feedback has been sent."

	QuestionType=SQT_OK
	PromptType=SPT_None
}
class gbx_LiveGamerList extends gbx_ScreenABXY
	Abstract;



var Automated GUIListBox		GamerList;				// listbox for friends/players list
var Automated GUILabel			lblStatusCaption;
var Automated GUILabel			lblSelectionName;
var Automated GUILabel			lblSelectionOnline;
var Automated GUILabel			lblSelectionVoice;
var Automated GUILabel			lblSelectionFriend;
var Automated GUILabel			lblListHeaderStatus;
var Automated GUILabel			lblListHeaderName;
var Automated GUILabel			lblListEmpty;

var() Array<Gamer>				Gamers;

// list-wide notification status
var bool						bListInvalidated;

var string						strDirtyCommand;
var string						strUpdateCommand;

enum ELiveIcon
{
	LI_NONE,
	LI_COMM_MUTED,
	LI_COMM_TALKING,
	LI_COMM_ON,
	LI_COMM_OFF,
	LI_INVITE_RECEIVED,
	LI_INVITE_SENT,
	LI_FRIEND_RECEIVED,
	LI_FRIEND_SENT,
	LI_ONLINE,			// online player or friend
	LI_FRIEND,			// not online but is a friend (same visual icon as LI_ONLINE
	LI_OFFLINE,			// offline player or friend
};

enum ELiveIconColor
{
	LIC_OFFLINE,
	LIC_ONLINE,
	LIC_PLAYING,
	LIC_SIGNIN,
	LIC_ERROR,
	LIC_UNKNOWN,	// say, an offline non-friend (regular player)
};

var	Canvas.CanvasIcon			LiveIcons[12];
var	Color						LiveIconColors[6];

var() localized string  		TextEmptyList;
var() localized string  		TextReceivedInvite;
var() localized string  		TextReceivedRequest;
var() localized string  		TextOnline;
var() localized string  		TextFriend;
var() localized string  		TextOffline;
var() localized string  		TextSentInvite;
var() localized string  		TextSentRequest;
var() localized string  		TextVoiceOn;
var() localized string  		TextVoiceOff;
var() localized string  		TextVoiceTV;
var() localized string  		TextVoiceMuted;
var() localized string  		TextInviteAccepted;
var() localized string  		TextInviteRejected;
var() localized string  		TextPlaying;
var() localized string  		TextJoinable;

var() localized string  		TextHintReceivedInvite;
var() localized string  		TextHintSentInvite;
var() localized string  		TextHintReceivedFriend;
var() localized string  		TextHintSentFriend;
var() localized string  		TextHintCancel;
var() localized string  		TextHintAccept;

var() localized string  		TextHintOffline;
var() localized string  		TextHintOnline;
var() localized string  		TextHintPlaying;
var() localized string  		TextHintJoinable;

var() localized string  		StrTextHintPlayer;
var() localized string  		StrTextHintFriend;


var() localized string  		StrStatus;
var() localized string  		StrName;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);
	OnAButtonEvent = OnAccept;
	OnBButtonEvent = OnBack;
	OnOpen = InternalOnOpen;

	GamerList.OnChange = GamerListOnChange;
	GamerList.List.SetStyle("MenuOptionCaption");
	GamerList.List.OnDrawItem = GamerListDrawItem;
	GamerList.List.SelectedImage = None;

	lblListHeaderStatus.SetCaption(StrStatus);
	lblListHeaderName.SetCaption(StrName);

	EnableFakeIt();
}

notinship function EnableFakeIt()
{
	if (class'GUI.gbx_MenuDebug'.Default.bEnableDebug)
	{
		SetupXButton("FakeIt");
		OnXButtonEvent = FakeIt;
	}
}

function OnAccept()
{
	Controller.PlayClickSound(EClickSound.CS_Click);
}

function OnBack()
{
	EndUpdate();
    BaseOnBButton();
}

function Timer()
{
	Update();
}

function GamerListOnChange(GUIComponent Sender)
{
	GamerSelected(GamerList.List.Index);
}

function InternalOnOpen();

function DrawSeparator(Canvas C, float X, float Y, float W)
{
	C.DrawColor = Controller.BackgroundBoxColor;
	C.DrawColor.A = 255;

	C.SetDrawColor(120,120,100,220);
	C.SetPos(X, Y);
	C.DrawTileTiledClip(	Texture't_interface_mb.hud.interface_comp', 
							W, 6 * Controller.CanvasScaleY, 
							284, 128, 128, 128,
							32, 32);
}

function bool ScreenOnDrawPre(Canvas C)
{
	local float si_top, si_height, W;
	local Canvas.CanvasIcon icon;
	local Gamer G;

	C.DrawColor = Controller.BackgroundBoxColor;

	W = ActualWidth();

	DrawBackground(C, HorizontalOffset(0.05), VerticalOffset(0.46), 0.90*W, VerticalOffset(0.3), 4.0, 4.0);
	DrawSeparator(C, HorizontalOffset(0.06), VerticalOffset(0.50), 0.88*W);

	if (Gamers.Length > 0)
	{
		C.DrawColor = Controller.BackgroundBoxColor;
		DrawBackground(C, HorizontalOffset(0.05), VerticalOffset(0.16), 0.90*W, VerticalOffset(0.2875));

		DrawSeparator(C, HorizontalOffset(0.06), VerticalOffset(0.290), 0.88*W);
		DrawSeparator(C, HorizontalOffset(0.06), VerticalOffset(0.205), 0.88*W);

		// draw the status icons
		if (GamerList.List.Index != -1)
		{
			G = Gamers[GamerList.List.Index];
			si_height = 0.0525*W;
			si_top = lblSelectionVoice.VerticalOffset(0.5) - 0.5 * si_height;

			GetOnlineIcon(G, icon);
			DrawLiveIcon(C, icon, HorizontalOffset(0.105), si_top, si_height);

			GetFriendIcon(G, icon);
			DrawLiveIcon(C, icon, HorizontalOffset(0.625), si_top, si_height);

			DrawLiveIcon(C, LiveIcons[GetCommunicatorIcon( G )], HorizontalOffset(0.37), si_top, si_height);
		}
	}

	return Super.ScreenOnDrawPre(C);
}

function GamerListDrawItem(Canvas Canvas, int Item, float X, float Y, float W, float H, bool bSelected)
{
	local eMenuState drawState;
	local Canvas.CanvasIcon icon;
	local int XL, YL;
	local string S;

	if (Item == -1)
		return;

	CopyCanvasIcon(GetPresenceIcon( Gamers[Item] ), icon);
	icon.DrawColor = GetIconColor(Gamers[Item]);
	DrawLiveIcon(Canvas, icon, X, Y, H);

	DrawLiveIcon(Canvas, LiveIcons[GetCommunicatorIcon( Gamers[Item] )], X+1.5*H, Y, H);

	if( bSelected )
		drawState = MSAT_Focused;
	else
		drawState = MSAT_Blurry;

	W += X;	// right
	X = lblListHeaderName.HorizontalOffset(0);	// new left
	W -= X;	// right-left

	if (IsA('gbx_LivePlayersList'))
	{
		if(Gamers[Item].bIsActivePlayer != 0)
			GamerList.List.Style.SetOverrideColor(LiveIconColors[ELiveIconColor.LIC_PLAYING]);
		else
			GamerList.List.Style.SetOverrideColor(LiveIconColors[ELiveIconColor.LIC_OFFLINE]);
	}

	S = GamerList.List.GetItemAtIndex(Item);
	GamerList.List.Style.TextSize( Canvas, drawState, S, XL, YL );
	GamerList.List.Style.DrawTextToFit( Canvas, drawState, X, Y, W, H, TXTA_Left, S );

	GamerList.List.Style.ClearOverrideColor();

	if (bSelected)
		class'GUI.gbx_ScreenABXY'.Static.DrawTheThinRedLine(Controller, Canvas, 0, Y+H-2, X+XL);
}

function DrawLiveIcon(Canvas Canvas, out Canvas.CanvasIcon Icon, float L, float T, float WH)
{
	if (Icon.Icon != None)
	{
		Canvas.Style = EMenuRenderStyle.MSTY_Alpha;
		Canvas.SetPos(L+2,T+2);
		Canvas.DrawColor = Icon.DrawColor;
		Canvas.DrawTile( Icon.Icon, 
							WH-4, WH-4, 
							Icon.U, Icon.V, Icon.UL, Icon.VL);
	}
}

function GamerSelected(int index)
{
	local Gamer G;
	local int i;
	local string s;

	if (Gamers.Length == 0)
	{
		lblListEmpty.SetCaption(TextEmptyList);
	}
	else
	{
		lblListEmpty.SetCaption("");
	}

	if ((index >= 0) && (index < Gamers.Length))
	{
		G = Gamers[index];
		i = 0;

		GetInfoText(G, s);
		lblStatusCaption.SetCaption(s);

		lblSelectionName.SetCaption(InternalFormatGamer(G));
		lblSelectionOnline.SetCaption(GetOnlineLabel(G));
		lblSelectionVoice.SetCaption(GetVoiceLabel(G));
		lblSelectionFriend.SetCaption(GetFriendLabel(G));

		// no selecting self now...
		if (G.GamerTag ~= Controller.LiveFunc.GetGamerTag(PagePlayerIndex))
			SetupAButton();
		else
			SetupAButton(StringOptions);
	}
	else
	{
		lblStatusCaption.SetCaption("");
		lblSelectionName.SetCaption("");
		lblSelectionOnline.SetCaption("");
		lblSelectionVoice.SetCaption("");
		lblSelectionFriend.SetCaption("");

		SetupAButton();
	}
}
// =======================================================================================================================================================
// Live interface functions
// =======================================================================================================================================================
function BeginUpdate()
{
    ConsoleCommand("XLIVE FRIENDS USER=" $ PagePlayerIndex @ "REALTIMEUPDATE TRUE");
    SetTimer( 0.33, true );
	RefreshList();
}

function EndUpdate()
{
    ConsoleCommand("XLIVE FRIENDS USER=" $ PagePlayerIndex @ "REALTIMEUPDATE FALSE");
    SetTimer( 0.0, false );
}

function bool NeedsUpdate()
{
    local String rc;

    rc = ConsoleCommand("XLIVE FRIENDS USER=" $ PagePlayerIndex @ strDirtyCommand);
	return (rc != "") && bool(rc);
}

function Update()
{
	bListInvalidated = false;

	if (NeedsUpdate()) 
		RefreshList();
}

// update the list
function RefreshList()
{
	GUILog("RefreshList: GetGamerList");
	GetGamerList();
	ParseList( "" );
}

function FakeIt()
{
    local int i, c;
    Gamers.Length = 0;

    c = Rand(90) + 10;
    
	EndUpdate();

  	GamerList.List.Clear();
    Gamers.Length = 0;

	GUILog("gbx_LiveGamerList::FakeIt");

	for( i = 0; i < c; i++ )
    {
		Gamers.Length = i+1;

        Gamers[i].UID = "";
        Gamers[i].Gamertag = "Asstag" $ Rand(1000) $"_" $i;
        Gamers[i].NickName = "Assnick" $ Rand(1000);
		Gamers[i].iPlayerListIndex = i;

        Gamers[i].bIsFriend = Rand(2);

        Gamers[i].bOnline = Rand(2);
        
        if( Gamers[i].bOnline != 0 )
        {
            Gamers[i].GameTitle = "Shitty Crapgame" @ Rand(1000);
            Gamers[i].bIsInDifferentTitle = Rand(2);
            
            if( Gamers[i].bIsFriend != 0 )
            {
                Gamers[i].bJoinable = Rand(2);
                Gamers[i].bInviteAccepted = Rand(2);
                Gamers[i].bInviteRejected = Rand(2);
                Gamers[i].bInvitable = Rand(2);
                Gamers[i].bReceivedInvite = Rand(2);
                Gamers[i].bSentInvite = Rand(2);
            }            
            else
            {
                Gamers[i].bReceivedRequest = Rand(2);

                if( Gamers[i].bReceivedRequest == 0 )
				{
					if (IsA('gbx_LiveFriendsList'))
						Gamers[i].bSentRequest = 1;
					else
						Gamers[i].bSentRequest = Rand(2);
				}
            }
                        
            Gamers[i].bPlaying = Rand(2);

			Gamers[i].bIsActivePlayer = 0;
			if ((Gamers[i].bPlaying != 0) && IsA('gbx_LivePlayersList'))
			{
				Gamers[i].bIsActivePlayer = Rand(2);
			}

            Gamers[i].bIsMuted = Rand(2);
            Gamers[i].bIsGuest = Rand(2);
            
            Gamers[i].bHasVoice = Rand(2);
            
            if( Gamers[i].bHasVoice != 0 )
                Gamers[i].bIsTalking = Rand(2);
        }
		else if (IsA('gbx_LiveFriendsList'))
		{
            if( Gamers[i].bIsFriend == 0 )
            {
                Gamers[i].bReceivedRequest = Rand(2);
                if( Gamers[i].bReceivedRequest == 0 )
					Gamers[i].bSentRequest = 1;
			}
		}
    }

    SortList();

	// add to the listbox
	for (i=0; i<Gamers.Length; i++)
	{
		GamerList.List.Add(InternalFormatGamer(Gamers[i], true),,Gamers[i].Gamertag);
	}

	GamerList.List.SetIndex(0);
}

function GetGamerList();

function EmptyList()
{
	GamerList.List.Clear();
    Gamers.Length = 0;
}

simulated function ParseList( String FriendsList )
{
    local int i, newFocusIndex;
    local String LastGamerTag;
	local String MyGamerTag;

	MyGamerTag = Controller.LiveFunc.GetGamerTag(PagePlayerIndex);

	newFocusIndex = 0;
	if (GamerList.List.Index != 0)
		LastGamerTag = GamerList.List.GetExtra();

	GamerList.List.Clear();
//    Gamers.Length = 0;

    SortList();

	// add to the listbox
	for (i=0; i<Gamers.Length; i++)
	{
		if (Gamers[i].Gamertag ~= MyGamerTag)
		{
			Gamers.Remove(i,1);
			i--;
			continue;
		}

		GamerList.List.Add(InternalFormatGamer( Gamers[i], true ),,Gamers[i].Gamertag);

		if (LastGamerTag == Gamers[i].Gamertag)
		{
			newFocusIndex = i;
		}
	}

	GamerList.List.SetIndex(newFocusIndex);
	bListInvalidated = true;
}

static function string FormatGamerName(Gamer G)
{
	if (G.bIsGuest != 0)
		return class'gbx_ScreenABXY'.default.StringIsGuest @ G.Gamertag;
	else
		return G.Gamertag;
}

function string InternalFormatGamer( Gamer G, optional bool bIncludeNickName )
{
	return FormatGamerName(G);
}

// =======================================================================================================================================================
// List / Gamer Management
// =======================================================================================================================================================
function GetGamerSortKey( out Gamer G )
{
    local int rc;
    
    rc = 0;
    
    if( G.bOnline != 0 )
        rc = rc | 0x0010000;
    if( G.bReceivedInvite != 0 )
        rc = rc | 0x4000000;
    if( G.bReceivedRequest != 0 )
        rc = rc | 0x2000000;
    if( (G.bSentInvite != 0) && (G.bInviteAccepted == 0) && (G.bInviteRejected == 0) )
        rc = rc | 0x1000000;
    if( G.bSentRequest != 0 )
        rc = rc | 0x0800000;
    if( G.bJoinable != 0 )
        rc = rc | 0x0400000;
    if( G.bIsFriend != 0 )
        rc = rc | 0x0200000;
    if( G.bPlaying != 0 )
        rc = rc | 0x0100000;

	G.iSortKey = rc;
}

function bool GamersInOrder( Gamer A, Gamer B )
{
    if( A.iSortKey < B.iSortKey )
        return( false );
    else if( A.iSortKey > B.iSortKey )
        return( true );

    if( A.Gamertag > B.Gamertag )
        return( false );
    
    return( true );
}

function SortList()
{
    local int i;

	for (i=0; i<Gamers.Length; i++)
	{
		GetGamerSortKey( Gamers[i] );
	}

	Controller.SortGamers(Gamers);
}
  
function ELiveIcon GetCommunicatorIcon( out Gamer G )
{
    if( G.bIsMuted != 0 )
        return( LI_COMM_MUTED );
    else if( G.bOnline == 0 )
        return( LI_NONE );
    else if( G.bIsTalking != 0 )
        return( LI_COMM_TALKING );
    else if( G.bHasVoice != 0 )
        return( LI_COMM_ON );
    else
        return( LI_NONE );
}

function ELiveIcon GetPresenceIcon( out Gamer G )
{
    if( G.bReceivedInvite != 0 )
        return( LI_INVITE_RECEIVED );
    else if( G.bReceivedRequest != 0 )
        return( LI_FRIEND_RECEIVED );
    else if( (G.bSentInvite != 0) && (G.bInviteAccepted == 0) && (G.bInviteRejected == 0) )
        return( LI_INVITE_SENT );
    else if( G.bSentRequest != 0 )
        return( LI_FRIEND_SENT );
    else if(( G.bIsFriend != 0 ) && ( G.bOnline != 0 ))
        return( LI_FRIEND );
    else
        return( LI_OFFLINE );
//    else if( G.bOnline != 0 )
//        return( LI_ONLINE );
}

function CopyCanvasIcon( ELiveIcon pIcon, out Canvas.CanvasIcon result )
{
	result.Icon = LiveIcons[pIcon].Icon;
	if (pIcon != LI_NONE)
	{
		result.U = LiveIcons[pIcon].U;
		result.V = LiveIcons[pIcon].V;
		result.UL = LiveIcons[pIcon].UL;
		result.VL = LiveIcons[pIcon].VL;
	}
}

function Color GetIconColor( Gamer G )
{
	if ((G.bIsFriend != 0) || (G.bReceivedRequest != 0) || (G.bSentRequest != 0) )
	{
		if ((G.bIsFriend != 0) && ((G.bJoinable != 0) || (G.bPlaying != 0)))
			return LiveIconColors[ELiveIconColor.LIC_PLAYING];
		else if (G.bOnline != 0)
			return LiveIconColors[ELiveIconColor.LIC_ONLINE];

		return LiveIconColors[ELiveIconColor.LIC_OFFLINE];
	}
	else if (G.bOnline != 0)
	{
		return LiveIconColors[ELiveIconColor.LIC_ONLINE];
	}

	return LiveIconColors[ELiveIconColor.LIC_UNKNOWN];
}

function string GetOnlineLabel( Gamer G )
{
    if( G.bReceivedInvite != 0 )
        return TextReceivedInvite;
    else if( (G.bSentInvite != 0) && (G.bInviteAccepted == 0) && (G.bInviteRejected == 0) )
        return TextSentInvite;
    else if( G.bIsFriend != 0 )
	{
		if (G.bJoinable != 0)
			return TextPlaying $"|" $TextJoinable;
		else if (G.bPlaying != 0)
			return TextPlaying;
		else if (G.bOnline != 0)
			return TextOnline;

		return TextOffline;
	}
	else if (G.bOnline != 0)
		return TextOnline;

	return TextOffline;
}

function GetOnlineIcon( Gamer G, out Canvas.CanvasIcon result)
{
	local ELiveIcon pIcon;

    if( G.bReceivedInvite != 0 )
        pIcon = LI_INVITE_RECEIVED;
    else if( (G.bSentInvite != 0) && (G.bInviteAccepted == 0) && (G.bInviteRejected == 0) )
        pIcon = LI_INVITE_SENT;
	else if ((G.bIsFriend != 0) && (G.bOnline != 0))
		pIcon = LI_FRIEND;
	else
		pIcon = LI_OFFLINE;
//    else if(G.bOnline != 0)
//		pIcon = LI_ONLINE;

	CopyCanvasIcon(pIcon, result);
	result.DrawColor = GetIconColor(G);
}

function string GetVoiceLabel( Gamer G )
{
    if( G.bIsMuted != 0 )
        return TextVoiceMuted;
    else if( G.bOnline == 0 )
        return "";
    else if( G.bIsTalking != 0 )
        return TextVoiceOn;
    else if( G.bHasVoice != 0 )
        return TextVoiceOn;
    else
        return TextVoiceOff;
}

function string GetFriendLabel( Gamer G )
{
    if( G.bReceivedRequest != 0 )
		return TextReceivedRequest;
    else if( G.bSentRequest != 0 )
		return TextSentRequest;
    else if( G.bIsFriend != 0 )
		return TextFriend;

	return "";
}

function GetFriendIcon( Gamer G, out Canvas.CanvasIcon result)
{
	local ELiveIcon pIcon;

    if( G.bReceivedRequest != 0 )
		pIcon = LI_FRIEND_RECEIVED;
    else if( G.bSentRequest != 0 )
		pIcon = LI_FRIEND_SENT;
    else if( (G.bIsFriend != 0) && (G.bOnline != 0) )
		pIcon = LI_FRIEND;
	else
		pIcon = LI_OFFLINE;

	CopyCanvasIcon(pIcon, result);
	result.DrawColor = GetIconColor(G);
}


function GetInfoText( out Gamer G, out String S )
{
	S = "";

    if( G.bOnline == 0 )
	{
        S = TextHintOffline;
	}
    else
	{
		if( G.bIsFriend != 0 )
		{
			if (G.bIsActivePlayer != 0)
				S = class'gbx_LivePlayersList'.default.TextHintPlayerInSession;
			else if (G.bPlaying != 0)
				S = TextHintPlaying;
			else
				S = TextHintOnline;

			if (G.bJoinable != 0)
				S = S @ TextHintJoinable;
		}
		else
		{
			if (G.bIsActivePlayer != 0)
				S = class'gbx_LivePlayersList'.default.TextHintPlayerInSession;
			else
				S = TextHintOnline;
		}
	}

    if( G.bIsFriend == 0 )
    {
        if( G.bSentRequest != 0 )
            S = S @ TextHintSentFriend @ TextHintCancel;
        else if( G.bReceivedRequest != 0 )
            S = S @ TextHintReceivedFriend @ TextHintAccept;

		ReplaceText(S, "<P_OR_F>", StrTextHintPlayer);
    }
	else
	{
		if( G.bReceivedInvite != 0 )
			S = S @ TextHintReceivedInvite @ TextHintAccept;

		if( G.bSentInvite != 0 )
		{
			if( G.bInviteAccepted != 0 )
				S = S @ TextInviteAccepted;
			else if( G.bInviteRejected != 0 )
				S = S @ TextInviteRejected;
			else
			{
				S = S @ TextHintSentInvite;

				if( G.bReceivedInvite == 0 )
					S = S @ TextHintCancel;
			}
		}

		ReplaceText(S, "<P_OR_F>", StrTextHintFriend);
	}

	S = CapsL(S);
	ReplaceText( S, "<GAME>", "\"" $G.GameTitle $"\"");
}

function bool GetCurrentGamer( out Gamer G )
{
	local int index;

	index = GamerList.List.Index;
	if ((index >= 0) && (index < Gamers.Length))
	{
		G = Gamers[index];
		return true;
	}
	else
	{
		return false;
	}
}

function int FindGamer(string Gamertag, bool bIsGuest, out Gamer G)
{
	local int i;

	for (i=0; i<Gamers.Length; i++)
	{
		if ((Gamers[i].Gamertag ~= Gamertag) && ((Gamers[i].bIsGuest != 0) == bIsGuest))
		{
			G = Gamers[i];
			return i;
		}
	}

	return -1;
}

static function Canvas.CanvasIcon GetLiveIcon(ELiveIcon icon)
{
	return Default.LiveIcons[icon];	// heh awesome, can't do this from outside the class
}

static function CloseToGamerList(GUIController C)
{
	do
	{
		C.CloseMenu(false);
	} until((C.ActivePage == None) || C.ActivePage.IsA('gbx_LiveGamerList'));
}


defaultproperties
{
	PagePlayerIndex=-1
	strDirtyCommand=""
	strUpdateCommand=""

	Begin Object class=GUIListBox Name=cGamerList
		WinWidth=0.885
		WinHeight=0.25
		WinLeft=0.065
		WinTop=0.51
        bVisibleWhenEmpty=true
		TextAlign=TXTA_Left
	End Object
	GamerList=cGamerList

	Begin Object Class=GUILabel Name=cListHeaderStatus
		StyleName="MenuOptionCaption"
		TextAlign=TXTA_Left
		DrawMenuState=1
		WinWidth=0.185
		WinHeight=0.05
		WinLeft=0.065
		WinTop=0.455
		bNeverFocus=true
	End Object
	Begin Object Class=GUILabel Name=cListHeaderName
		StyleName="MenuOptionCaption"
		TextAlign=TXTA_Left
		DrawMenuState=1
		WinWidth=0.65
		WinHeight=0.05
		WinLeft=0.25
		WinTop=0.455
		bNeverFocus=true
	End Object
	lblListHeaderStatus=cListHeaderStatus
	lblListHeaderName=cListHeaderName

	// selected player name
	Begin Object Class=GUILabel Name=cSelectionName
		StyleName="MenuOptionCaption"
		TextAlign=TXTA_Center
		DrawMenuState=2
		WinWidth=0.8
		WinHeight=0.047500
		WinLeft=0.1
		WinTop=0.1625
		bNeverFocus=true
		bMultiLine=false
		bTransparent=true
	End Object
	lblSelectionName=cSelectionName

	// selected player status line
	Begin Object Class=GUILabel Name=cStatusOnline
		StyleName="TextLabel"
		TextAlign=TXTA_Left
		TextAlignV=TXTA_Center
		DrawMenuState=1
		WinWidth=0.20
		WinHeight=0.09
		WinLeft=0.16
		WinTop=0.21
		bNeverFocus=true
		bMultiLine=true
		bClientBounded=false
	End Object
	Begin Object Class=GUILabel Name=cStatusVoice
		StyleName="TextLabel"
		TextAlign=TXTA_Left
		TextAlignV=TXTA_Center
		DrawMenuState=1
		WinWidth=0.20
		WinHeight=0.09
		WinLeft=0.42
		WinTop=0.21
		bNeverFocus=true
		bMultiLine=true
		bClientBounded=false
	End Object
	Begin Object Class=GUILabel Name=cStatusFriend
		StyleName="TextLabel"
		TextAlign=TXTA_Left
		TextAlignV=TXTA_Center
		DrawMenuState=1
		WinWidth=0.21
		WinHeight=0.09
		WinLeft=0.68
		WinTop=0.21
		bNeverFocus=true
		bMultiLine=true
		bClientBounded=false
	End Object
	lblSelectionOnline=cStatusOnline
	lblSelectionVoice=cStatusVoice
	lblSelectionFriend=cStatusFriend

	Begin Object Class=GUILabel Name=cStatusCaption
		StyleName="TextLabel"
		TextAlign=TXTA_Left
		DrawMenuState=1
		WinWidth=0.885
		WinHeight=0.14
		WinLeft=0.065
		WinTop=0.3
		bNeverFocus=true
		bMultiLine=true
		bClientBounded=false
	End Object
	lblStatusCaption=cStatusCaption

	Begin Object Class=GUILabel Name=cSlblListEmpty
		StyleName="MenuOptionCaption"
		TextAlign=TXTA_Center
		TextAlignV=TXTA_Center
		DrawMenuState=1
		WinWidth=0.885
		WinHeight=0.25
		WinLeft=0.065
		WinTop=0.51
		bNeverFocus=true
		bMultiLine=true
		bTransparent=true
	End Object
	lblListEmpty=cSlblListEmpty

	TextEmptyList=""
    TextOnline="Online"
    TextJoinable="Joinable"
    TextOffline="Offline"
    TextPlaying="Playing"
    TextFriend="Friend"
    TextReceivedRequest="Received|Request"
    TextSentRequest="Sent|Request"
    TextReceivedInvite="Received|Invite"
    TextSentInvite="Sent|Invite"
	TextVoiceOn="Voice|Enabled"
    TextVoiceOff="Voice|Off"
    TextVoiceTV="Voice|Through TV"
    TextVoiceMuted="Voice|Muted"
    TextInviteAccepted="Your invitation was accepted."
    TextInviteRejected="Your invitation was declined."

	TextHintOffline="<P_OR_F> is offline."
	TextHintOnline="<P_OR_F> is online in <GAME>."
	TextHintPlaying="<P_OR_F> is playing <GAME>."
	TextHintJoinable="You may join their session."

	TextHintReceivedInvite="You received an invite to join their game."
	TextHintSentInvite="You invited them to join your game."
	TextHintReceivedFriend="They want to be your friend."
	TextHintSentFriend="You asked them to be your friend."

	TextHintCancel="You may cancel this invitation."
	TextHintAccept="You may accept or decline this invitation."

	StrTextHintPlayer="This player"
	StrTextHintFriend="This friend"

	StrStatus="Status"
	StrName="Gamertag"

	LiveIcons(0)=(Icon=None,U=0,V=0,UL=0,VL=0,DrawColor=(R=255,G=255,B=255,A=255),ScaleX=0.0,ScaleY=0.0,PivotU=0.0,PivotV=0.0)		//	LI_NONE
	LiveIcons(1)=(Icon=Texture't_interface_mb.hud.chapters_comp',U=196,V=166,UL=23,VL=23,DrawColor=(R=200,G=56,B=41,A=255),ScaleX=1.0,ScaleY=1.0,PivotU=0.0,PivotV=0.0)		//	LI_COMM_MUTED,
	LiveIcons(2)=(Icon=Texture't_interface_mb.hud.chapters_comp',U=219,V=166,UL=23,VL=23,DrawColor=(R=180,G=180,B=41,A=255),ScaleX=1.0,ScaleY=1.0,PivotU=0.0,PivotV=0.0)		//	LI_COMM_TALKING,
	LiveIcons(3)=(Icon=Texture't_interface_mb.hud.chapters_comp',U=173,V=166,UL=23,VL=23,DrawColor=(R=200,G=200,B=200,A=255),ScaleX=1.0,ScaleY=1.0,PivotU=0.0,PivotV=0.0)	//	LI_COMM_ON,
	LiveIcons(4)=(Icon=Texture't_interface_mb.hud.chapters_comp',U=173,V=166,UL=23,VL=23,DrawColor=(R=40,G=40,B=40,A=255),ScaleX=1.0,ScaleY=1.0,PivotU=0.0,PivotV=0.0)		//	LI_COMM_OFF
	LiveIcons(5)=(Icon=Material't_interface_mb.hud.interface_comp',U=335,V=104,UL=23,VL=23,DrawColor=(R=200,G=200,B=200,A=255),ScaleX=1.0,ScaleY=1.0,PivotU=0.0,PivotV=0.0)	//	LI_INVITE_RECEIVED,
	LiveIcons(6)=(Icon=Texture't_interface_mb.hud.chapters_comp',U=81,V=166,UL=23,VL=23,DrawColor=(R=200,G=200,B=200,A=255),ScaleX=1.0,ScaleY=1.0,PivotU=0.0,PivotV=0.0)	//	LI_INVITE_SENT,
	LiveIcons(7)=(Icon=Material't_interface_mb.hud.interface_comp',U=412,V=122,UL=23,VL=23,DrawColor=(R=200,G=200,B=200,A=255),ScaleX=1.0,ScaleY=1.0,PivotU=0.0,PivotV=0.0)	//	LI_FRIEND_RECEIVED,
	LiveIcons(8)=(Icon=Texture't_interface_mb.hud.chapters_comp',U=127,V=166,UL=23,VL=23,DrawColor=(R=200,G=200,B=200,A=255),ScaleX=1.0,ScaleY=1.0,PivotU=0.0,PivotV=0.0)	//	LI_FRIEND_SENT,
	LiveIcons(9)=(Icon=Texture't_interface_mb.hud.chapters_comp',U=150,V=166,UL=23,VL=23,DrawColor=(R=200,G=200,B=200,A=255),ScaleX=1.0,ScaleY=1.0,PivotU=0.0,PivotV=0.0)	//	LI_ONLINE
	LiveIcons(10)=(Icon=Material't_interface_mb.hud.chapters_comp',U=150,V=166,UL=23,VL=23,DrawColor=(R=200,G=200,B=200,A=255),ScaleX=1.0,ScaleY=1.0,PivotU=0.0,PivotV=0.0)	//	LI_FRIEND
	LiveIcons(11)=(Icon=None,U=0,V=0,UL=0,VL=0,DrawColor=(R=255,G=255,B=255,A=255),ScaleX=0.0,ScaleY=0.0,PivotU=0.0,PivotV=0.0)	//	LI_OFFLINE

	LiveIconColors(0)=(R=90,G=90,B=90,A=255)	// LIC_OFFLINE
	LiveIconColors(1)=(R=200,G=200,B=200,A=255)	// LIC_ONLINE
	LiveIconColors(2)=(R=56,G=200,B=41,A=255)		// LIC_PLAYING
	LiveIconColors(3)=(R=180,G=180,B=41,A=255)	// LIC_SIGNIN
	LiveIconColors(4)=(R=200,G=28,B=20,A=255)		// LIC_ERROR
	LiveIconColors(5)=(R=40,G=40,B=40,A=255)	// LIC_UNKNOWN

	bRequireLink=true
	bRequireLive=true
	PlayerStatusDisplayStyle=CD_Signin
}

class gbx_LiveGamerOptions extends gbx_LiveGamerScreen
	Abstract;

enum EOptionButton
{
	OB_INVITATION_ACCEPT,
	OB_INVITATION_DECLINE,
	OB_INVITATION_SEND,
	OB_INVITATION_CANCEL,
	OB_FRIEND_JOIN_GAME,
	OB_FRIEND_REMOVE,
	OB_FRIEND_REQUEST_SEND,
	OB_FRIEND_REQUEST_ACCEPT,
	OB_FRIEND_REQUEST_DECLINE,
	OB_FRIEND_REQUEST_BLOCK,
	OB_FRIEND_REQUEST_CANCEL,
	OB_VOICE_MUTE,
	OB_VOICE_UNMTE,
	OB_SEND_FEEDBACK,
	OB_PLAY_VOICE_ATTACHMENT,
};

enum EMessageType
{
	MT_INVITATION,
	MT_FRIEND_REQUEST,
};


var gbx_LiveGamerList			GamerList;

var() localized String 			StringCaptionHeader;
var() localized String 			StringCancelFriendRequest;
var() localized String 			StringBlockFriendRequest;
var() localized String 			StringRemoveFriend;
var() localized String 			StringCancelInvite;
var() localized String 			StringDeclineInvite;
var() localized String 			StringDeclineFriendRequest;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	local gbx_LiveGamerList.Gamer G;

	Super.InitComponent(MyController, MyOwner);

	GamerList = gbx_LiveGamerList(ParentPage);
	if (!GamerList.GetCurrentGamer(G))
	{
		GUILog("#### Invalid current gamer ####");
		Controller.CloseMenu();
		return;
	}
	
	SetupAButton(StringSelect);
	PagePlayerIndex = GamerList.PagePlayerIndex;
	Setup(G);

	InitOptions();
    SetTimer( 0.33, true );
}

function OpenInsertDisc(optional bool bReplaceMenu)
{
	local gbx_LiveDlgInsertDisc dlg;

	if (bReplaceMenu)
		Controller.ReplaceMenu("GUI.gbx_LiveDlgInsertDisc", CurrentGamer.GameTitle);
	else
		Controller.OpenMenu("GUI.gbx_LiveDlgInsertDisc", CurrentGamer.GameTitle);

	dlg = gbx_LiveDlgInsertDisc(Controller.ActivePage);
	if (dlg == None)
	{
		GUILog("##### Failed to open the Insert Disc dialog #####");
		return;
	}

	dlg.PagePlayerIndex = PagePlayerIndex;
}

function gbx_LiveDlgTravelConfirm OpenTravelConfirm()
{
	local gbx_LiveDlgTravelConfirm dlg;

	Controller.OpenMenu("GUI.gbx_LiveDlgTravelConfirm");

	dlg = gbx_LiveDlgTravelConfirm(Controller.ActivePage);
	if (dlg == None)
	{
		GUILog("##### Failed to open the Travel Confirm dialog #####");
		return None;
	}

	dlg.PagePlayerIndex = PagePlayerIndex;

	return dlg;
}

function SetupAcceptJoin()
{
	// only do this in the menu.  While in gameplay, all of the players already exist in the game.
	if (Controller.bIsConsole && PlayerOwner().Level.IsMenuMap())
	{
		if (class'gbx_ProfileManager'.Static.ControllerProfileExists(self, 1) && Controller.LiveFunc.IsSignedIn(1))
		{
			class'gbx_ProfileManager'.Static.SetupProfiles(self, true);
		}

		// wire up the controllers
		Controller.ApplyControllersToViewports();
	}
}

function bool DoAcceptInvite(optional bool bReplaceMenu)
{
	// tell Live what we're doing (needs done with same or cross-title join)
	if( "SUCCESS" != ConsoleCommand( "XLIVE FRIENDS USER=" $ PagePlayerIndex @ "INVITE ACCEPT GAMERTAG=\"" $ CurrentGamer.Gamertag $ "\"" ) )
	{
		Controller.LiveFunc.LiveErrorMessage("FRIEND_INVITE_ACCEPT_FAILED", true);
		return true;
	}
	else
	{
		// the accept doesn't happen immediately... we can handle this here
		SetupAcceptJoin();
	}

	// tell the user to insert the disc
	if( CurrentGamer.bIsInDifferentTitle != 0 )
	{
		OpenInsertDisc(bReplaceMenu);
	}
	else
	{
		if (bReplaceMenu)
			Controller.ReplaceMenu("GUI.gbx_LiveDlgJoinConnecting");
		else
			Controller.OpenMenu("GUI.gbx_LiveDlgJoinConnecting");
	}

	return !bReplaceMenu;
}

function bool AcceptInviteTravelAnswer(string answer)
{
	if (answer == "YES")
	{
		// logic here:
		// if the insert disc screen is shown, since we passed true, we'll get false back so we don't close the screen immediately
		return DoAcceptInvite(true);
	}

	return true;
}

function bool DoJoinFriend(optional bool bReplaceMenu)
{
	// tell Live what we're doing (needs done with same or cross-title join)
	if( "SUCCESS" != ConsoleCommand( "XLIVE FRIENDS USER=" $ PagePlayerIndex @ "FRIEND JOIN GAMERTAG=\"" $ CurrentGamer.Gamertag $ "\"" ) )
	{
		Controller.LiveFunc.LiveErrorMessage("FRIEND_JOIN_FAILED", true);
		return true;
	}
	else
	{
		// the join doesn't happen immediately... we can handle this here
		SetupAcceptJoin();
	}

	// tell the user to insert the disc
	if( CurrentGamer.bIsInDifferentTitle != 0 )
	{
		OpenInsertDisc(bReplaceMenu);
	}
	else
	{
		if (bReplaceMenu)
			Controller.ReplaceMenu("GUI.gbx_LiveDlgJoinConnecting");
		else
			Controller.OpenMenu("GUI.gbx_LiveDlgJoinConnecting");
	}

	return !bReplaceMenu;
}

function bool JoinFriendTravelAnswer(string answer)
{
	if (answer == "YES")
	{
		// logic here:
		// if the insert disc screen is shown, since we passed true, we'll get false back so we don't close the screen immediately
		return DoJoinFriend(true);
	}

	return true;
}

// =======================================================================================================================================================
// voice attachment stuff
// =======================================================================================================================================================
function gbx_LiveGamerPromptAttachVoice PromptAttachVoice(string cmd, string err, EMessageType messageType)
{
	local gbx_LiveGamerPromptAttachVoice dlg;
	local GUIController C;
	local int index;
	local string test;

	if ( (int(ConsoleCommand("VOICE_IS_COMMUNICATOR_CONNECTED " $GetControllerIndex())) == 1) &&
		 (CurrentGamer.bIsMuted == 0) )
	{
		C = Controller;

		index = PagePlayerIndex;
		switch (messageType)
		{
			case MT_INVITATION:
				C.ReplaceMenu("GUI.gbx_LiveGamerPromptAttachVoiceInvitation");
			break;

			case MT_FRIEND_REQUEST:
				C.ReplaceMenu("GUI.gbx_LiveGamerPromptAttachVoiceFriendRequest");
			break;
		}

		dlg = gbx_LiveGamerPromptAttachVoice(C.ActivePage);
		if (dlg == None)
		{
			GUILog("##### Failed to open the voice attach dialog #####");
			return None;
		}

		dlg.PagePlayerIndex = index;
		dlg.FinishedCommand = cmd;
		dlg.FinishedErr = err;
		dlg.SetUp(CurrentGamer);

		return dlg;
	}
	else
	{
		if( "SUCCESS" != ConsoleCommand(cmd) )
		{
			Controller.LiveFunc.LiveErrorMessage(err, true);
		}
		else
		{
			do
			{
				test = ConsoleCommand("XLIVE FRIENDS USER=" $ PagePlayerIndex @ "PUMP_VOICE_UPLOAD");
			} until(test != "SUCCESS");

			if (test != "COMPLETE")
			{
				Controller.LiveFunc.LiveErrorMessage(err, true, "XONLINE_E_FRIENDS_LIST_ERROR");
			}
			else
			{
				Controller.CloseMenu(false);
			}
		}
	}

	return None;
}

function LaunchVoicePlayback(string cmd)
{
	local gbx_LiveGamerVoicePlayback dlg;

	Controller.OpenMenu("GUI.gbx_LiveGamerVoicePlayback", cmd);

	dlg = gbx_LiveGamerVoicePlayback(Controller.ActivePage);
	if (dlg == None)
	{
		GUILog("##### Failed to open the voice feedback dialog #####");
		return;
	}

	dlg.PagePlayerIndex = PagePlayerIndex;
	dlg.SetUp(CurrentGamer);
}

// =======================================================================================================================================================
// input handler
// =======================================================================================================================================================
function bool OnComponentActivate(int button, GUIComponent Sender)
{
    local gbx_LiveDlgTravelConfirm dlg;

	switch (button)
	{
	case EOptionButton.OB_INVITATION_ACCEPT:
		if( !PlayerOwner().Level.IsMenuMap() )
		{
			dlg = OpenTravelConfirm();
			dlg.OnAnswer = AcceptInviteTravelAnswer;
		}
		else
		{
			// not in a game, just do the work
			DoAcceptInvite();
		}

		return true;

	case EOptionButton.OB_INVITATION_DECLINE:
		OpenConfirmDialog(StringDeclineInvite, "XLIVE FRIENDS USER=" $ PagePlayerIndex @ "INVITE DECLINE GAMERTAG=" $ MakeQuotedString(CurrentGamer.Gamertag), "FRIEND_INVITE_DECLINE_FAILED", true, "XONLINE_E_FRIENDS_LIST_ERROR");
		return true;

	case EOptionButton.OB_INVITATION_SEND:
		PromptAttachVoice("XLIVE FRIENDS USER=" $ PagePlayerIndex @ "INVITE SEND GAMERTAG=" $MakeQuotedString(CurrentGamer.Gamertag), "FRIEND_INVITE_SEND_FAILED", MT_INVITATION);
		return true;

	case EOptionButton.OB_INVITATION_CANCEL:
		OpenConfirmDialog(StringCancelInvite, "XLIVE FRIENDS USER=" $ PagePlayerIndex @ "INVITE CANCEL GAMERTAG=" $ MakeQuotedString(CurrentGamer.Gamertag), "INVITE_CANCEL_FAILED", true, "XONLINE_E_FRIENDS_LIST_ERROR");
		return true;

	case EOptionButton.OB_FRIEND_JOIN_GAME:
		if( !PlayerOwner().Level.IsMenuMap() )
		{
			dlg = OpenTravelConfirm();
			dlg.OnAnswer = JoinFriendTravelAnswer;
		}
		else
		{
			// not in a game, just do the work
			DoJoinFriend();
		}

		return true;

	case EOptionButton.OB_FRIEND_REMOVE:
		OpenConfirmDialog(StringRemoveFriend, "XLIVE FRIENDS USER=" $ PagePlayerIndex @ "FRIEND REMOVE GAMERTAG=" $ MakeQuotedString(CurrentGamer.Gamertag), "FRIEND_REMOVE_FAILED", true, "XONLINE_E_FRIENDS_LIST_ERROR");
		return true;

	case EOptionButton.OB_FRIEND_REQUEST_SEND:
		PromptAttachVoice("XLIVE FRIENDS USER=" $ PagePlayerIndex @ "PLAYER ADDFRIEND GAMERTAG=" $MakeQuotedString(CurrentGamer.Gamertag), "FRIEND_REQUEST_FAILED", MT_FRIEND_REQUEST );
		return true;

	case EOptionButton.OB_FRIEND_REQUEST_ACCEPT:
		if( "SUCCESS" != ConsoleCommand( "XLIVE FRIENDS USER=" $ PagePlayerIndex @ "REQUEST ACCEPT GAMERTAG=" $ MakeQuotedString(CurrentGamer.Gamertag) ) )
			Controller.LiveFunc.LiveErrorMessage("FRIEND_ACCEPT_FAILED", true, "XONLINE_E_FRIENDS_LIST_ERROR");
		else
			Controller.CloseMenu(false);
		return true;

	case EOptionButton.OB_FRIEND_REQUEST_DECLINE:
		OpenConfirmDialog(StringDeclineFriendRequest, "XLIVE FRIENDS USER=" $ PagePlayerIndex @ "REQUEST DECLINE GAMERTAG=" $ MakeQuotedString(CurrentGamer.Gamertag), "FRIEND_DECLINE_FAILED", true, "XONLINE_E_FRIENDS_LIST_ERROR");
		return true;

	case EOptionButton.OB_FRIEND_REQUEST_BLOCK:
		OpenConfirmDialog(StringBlockFriendRequest, "XLIVE FRIENDS USER=" $ PagePlayerIndex @ "REQUEST BLOCK GAMERTAG=" $ MakeQuotedString(CurrentGamer.Gamertag), "FRIEND_BLOCK_FAILED", true, "XONLINE_E_FRIENDS_LIST_ERROR");
		return true;

	case EOptionButton.OB_FRIEND_REQUEST_CANCEL:
		OpenConfirmDialog(StringCancelFriendRequest, "XLIVE FRIENDS USER=" $ PagePlayerIndex @ "REQUEST CANCEL GAMERTAG=" $ MakeQuotedString(CurrentGamer.Gamertag), "FRIEND_CANCEL_FAILED", true, "XONLINE_E_FRIENDS_LIST_ERROR");
		return true;

	case EOptionButton.OB_VOICE_MUTE:
		if( "SUCCESS" != ConsoleCommand( "XLIVE FRIENDS USER=" $ PagePlayerIndex @ "PLAYER MUTE GAMERTAG=" $ MakeQuotedString(CurrentGamer.Gamertag) ) )
			Controller.LiveFunc.LiveErrorMessage("PLAYER_MUTE_FAILED", true, "XONLINE_E_FRIENDS_LIST_ERROR");
		else
			Controller.CloseMenu(false);
		return true;

	case EOptionButton.OB_VOICE_UNMTE:
		if( "SUCCESS" != ConsoleCommand( "XLIVE FRIENDS USER=" $ PagePlayerIndex @ "PLAYER UNMUTE GAMERTAG=" $ MakeQuotedString(CurrentGamer.Gamertag) ) )
			Controller.LiveFunc.LiveErrorMessage("PLAYER_UNMUTE_FAILED", true, "XONLINE_E_FRIENDS_LIST_ERROR");
		else
			Controller.CloseMenu(false);
		return true;

	case EOptionButton.OB_SEND_FEEDBACK:
		OpenFeedbackDialog("GUI.gbx_LiveGamerFeedback");
		return true;

	case EOptionButton.OB_PLAY_VOICE_ATTACHMENT:
		if( "TRUE" == ConsoleCommand( "XLIVE IS_VOICE_BANNED USER=" $ PagePlayerIndex ) )
		{
			LaunchQuestionDialog(Controller, Controller.LiveFunc.LocalizedError("VOICE_BANNED_FEATURE_UNAVAILABLE"), "OK NONE" );
		}
		else
		{
			LaunchVoicePlayback("XLIVE FRIENDS USER=" $ PagePlayerIndex @ "START_VOICE_DOWNLOAD_PROCESS GAMERTAG=" $ MakeQuotedString(CurrentGamer.Gamertag));
		}
		return true;
	}
}

function InitCustomOptions();

function InitOptions(optional bool bResetFocus)
{
	local int i, lastFocus;

	lastFocus = -1;
    for( i = 0; i < MyComponents.Length; i++ )
	{
		if (MyComponents[i].bHasFocus && (lastFocus == -1))
			lastFocus = i;

		MyComponents[i].Hide();
	}

    if( CurrentGamer.bIsFriend == 0 )
    {
		// non-friends
        if( CurrentGamer.bSentRequest != 0 )
        {
			// sent a friend request
			// cancel
			MyComponents[EOptionButton.OB_FRIEND_REQUEST_CANCEL].Show();
        }
        else if( CurrentGamer.bReceivedRequest != 0 )
        {
			// received a friend request
			// accept/decline/block
			MyComponents[EOptionButton.OB_FRIEND_REQUEST_ACCEPT].Show();
			MyComponents[EOptionButton.OB_FRIEND_REQUEST_DECLINE].Show();
			MyComponents[EOptionButton.OB_FRIEND_REQUEST_BLOCK].Show();

			if (CurrentGamer.bReceivedRequestHasVoiceAttachment != 0)
			{
				MyComponents[EOptionButton.OB_PLAY_VOICE_ATTACHMENT].Show();
			}
        }
        else
        {
			// send friend request
			MyComponents[EOptionButton.OB_FRIEND_REQUEST_SEND].Show();
        }
    }

	InitCustomOptions();

	DoComponentLayout();

	if (bResetFocus && (lastFocus != -1) && (MyComponents[lastFocus].bVisible))
		MyComponents[lastFocus].SetFocus(None);
}

function Timer()
{
	local string S;
	local bool bIsGuest;

	S = CurrentGamer.Gamertag;
	bIsGuest = CurrentGamer.bIsGuest != 0;

	GamerList.Update();

	if (GamerList.bListInvalidated)
	{
		GUILog("Gamer list invalidated, reloading options");

		if (GamerList.FindGamer(S, bIsGuest, CurrentGamer) == -1)
		{
			Controller.CloseMenu(true);
			return;
		}

		InitOptions(true);
	}
}

static function PreloadMenu(GUIController C)
{
	Super.PreloadMenu(C);

	C.PreloadMenu("GUI.gbx_LiveDlgInsertDisc");
	C.PreloadMenu("GUI.gbx_LiveDlgTravelConfirm");
	C.PreloadMenu("GUI.gbx_LiveGamerPromptAttachVoiceInvitation");
	C.PreloadMenu("GUI.gbx_LiveGamerPromptAttachVoiceFriendRequest");
	C.PreloadMenu("GUI.gbx_LiveGamerVoicePlayback");
	C.PreloadMenu("GUI.gbx_LiveGamerFeedback");
}

defaultproperties
{
	PagePlayerIndex=-3
	ScreenTitle=""
	LayoutPivotPoint=0.55
	LayoutSpacing=0.005
	LayoutPivotStyle=LA_Center

	MyComponents(0)=cBtnOption
	MyComponents(1)=cBtnOption
	MyComponents(2)=cBtnOption
	MyComponents(3)=cBtnOption
	MyComponents(4)=cBtnOption
	MyComponents(5)=cBtnOption
	MyComponents(6)=cBtnOption
	MyComponents(7)=cBtnOption
	MyComponents(8)=cBtnOption
	MyComponents(9)=cBtnOption
	MyComponents(10)=cBtnOption
	MyComponents(11)=cBtnOption
	MyComponents(12)=cBtnOption
	MyComponents(13)=cBtnOption
	MyComponents(14)=cBtnOption

	MyCaptions(0)="Accept Game Invitation"
	MyCaptions(1)="Decline Game Invitation"
	MyCaptions(2)="Send Game Invitation"
	MyCaptions(3)="Cancel Game Invitation"
	MyCaptions(4)="Join Friend's Game"
	MyCaptions(5)="Remove From Friends List"
	MyCaptions(6)="Send Friend Request"
	MyCaptions(7)="Accept Friend Request"
	MyCaptions(8)="Decline Friend Request"
	MyCaptions(9)="Block Friend Request"
	MyCaptions(10)="Cancel Friend Request"
	MyCaptions(11)="Mute Player"
	MyCaptions(12)="Unmute Player"
	MyCaptions(13)="Send Feedback"
	MyCaptions(14)="Play Voice Attachment"

	StringInfoHeader="Options for :"
    StringCancelFriendRequest="Really cancel the friend request you sent to <GAMER>?"
    StringBlockFriendRequest="Really block all future friend requests from <GAMER>?"
    StringRemoveFriend="Really remove <GAMER> from your friends list?"
    StringCancelInvite="Really cancel the invitation you sent to <GAMER>?"

    StringDeclineInvite="Really decline the invitation from <GAMER>?"
    StringDeclineFriendRequest="Really decline the friend request from <GAMER>?"
}


class gbx_LiveGamerPromptAttachVoice extends gbx_ScreenQuestion;

var string 						FinishedCommand;
var string 						FinishedErr;
var gbx_LiveGamerList.Gamer		CurrentGamer;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	OnAnswer = MyAnswer;
}

function SetUp(out Gamer G)
{
	CurrentGamer = G;
    ReplaceText( lblTextPrompt.Caption, "<GAMER>", class'gbx_LiveGamerList'.Static.FormatGamerName(CurrentGamer) );
}

function OpenVoiceRecordMenu()
{
	local gbx_LiveGamerVoiceRecord dlg;
	local GUIController C;
	local string MyCmd, MyErr;
	local Gamer MyGamer;

	MyCmd = FinishedCommand;
	MyErr = FinishedErr;
	MyGamer = CurrentGamer;

	C = Controller;
	C.ReplaceMenu("GUI.gbx_LiveGamerVoiceRecord");
	dlg = gbx_LiveGamerVoiceRecord(C.ActivePage);
	if (dlg != None)
	{
		dlg.FinishedCommand = MyCmd;
		dlg.FinishedErr = MyErr;
		dlg.SetUp(MyGamer);
	}
}

function bool MyAnswer(string answer)
{
	local string test;

	if (answer ~= "YES")
	{
		OpenVoiceRecordMenu();
	}
	else
	{
		if( "SUCCESS" != ConsoleCommand(FinishedCommand) )
		{
			Controller.LiveFunc.LiveErrorMessage(FinishedErr, true, "XONLINE_E_FRIENDS_LIST_ERROR");
		}
		else
		{
			do
			{
				test = ConsoleCommand("XLIVE FRIENDS USER=" $ PagePlayerIndex @ "PUMP_VOICE_UPLOAD");
			} until(test != "SUCCESS");

			if (test != "COMPLETE")
			{
				Controller.LiveFunc.LiveErrorMessage(FinishedErr, true, "XONLINE_E_FRIENDS_LIST_ERROR");
			}
			else
			{
				Controller.CloseMenu(false);
			}
		}
	}

	return false;
}

static function PreloadMenu(GUIController C)
{
	Super.PreloadMenu(C);

	C.PreloadMenu("GUI.gbx_LiveGamerVoiceRecord");
}

defaultproperties
{
	PagePlayerIndex=-3
	ScreenTitle="Please Confirm"
	StringAutoTextPrompt=""

	QuestionType=SQT_YESNO
	PromptType=SPT_None

	bRequireLink=true
	bRequireLive=true
}
class gbx_LiveGamerPromptAttachVoiceFriendRequest extends gbx_LiveGamerPromptAttachVoice;

defaultproperties
{
	StringAutoTextPrompt="Would you like to attach a voice message to your Friend Request to <GAMER>?"
}
class gbx_LiveGamerPromptAttachVoiceInvitation extends gbx_LiveGamerPromptAttachVoice;

defaultproperties
{
	StringAutoTextPrompt="Would you like to attach a voice message to your Game Invitation to <GAMER>?"
}
class gbx_LiveGamerScreen extends gbx_MenuLayoutScreen
	dependson(gbx_LiveGamerList)
	Abstract;


var Automated GUILabel			lblInfo;
var automated array<moLabel>	MyGamerInfo;

var gbx_LiveGamerList.Gamer		CurrentGamer;

var localized string			StringInfoHeader;
var localized array<string>		StringGamerInfoCaptions;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	MyGamerInfo[0].MyLabel2.bForceCaps = true;
	MyGamerInfo[1].MyLabel2.bForceCaps = true;
	MyGamerInfo[0].SetCaption(StringGamerInfoCaptions[0]);
	LayoutControlArray(MyGamerInfo, 0.215, 0.005, LA_Left_Top);

	lblInfo.SetCaption(StringInfoHeader);
}

function SetUp(out gbx_LiveGamerList.Gamer G)
{
	CurrentGamer = G;

	MyGamerInfo[0].SetText(G.Gamertag);
}

function bool ScreenOnDrawPre(Canvas C)
{
	C.DrawColor = Controller.BackgroundBoxColor;

	if (MyGamerInfo[0].bVisible)
		MyGamerInfo[0].DrawComponentBackground(C, 2.0, 2.0);

	return Super.ScreenOnDrawPre(C);
}

function OpenConfirmDialog(string prompt, string cmd, string failure, optional bool bAcceptToList, optional string strErrorCode)
{
	local gbx_LiveGamerConfirm dlg;

	Controller.OpenMenu("GUI.gbx_LiveGamerConfirm");

	dlg = gbx_LiveGamerConfirm(Controller.ActivePage);
	if (dlg == None)
	{
		GUILog("##### OpenConfirmDialog failed to open the confirm dialog #####");
		return;
	}

	dlg.bAcceptToList = bAcceptToList;
	dlg.CurrentGamer = CurrentGamer;
	dlg.FailedErrorCode = strErrorCode;
	dlg.SetUp(prompt, cmd, failure);
}

function OpenFeedbackDialog(string FeedbackScreen)
{
	local gbx_LiveFeedbackScreen dlg;

	Controller.OpenMenu(FeedbackScreen);

	dlg = gbx_LiveFeedbackScreen(Controller.ActivePage);
	if (dlg == None)
	{
		GUILog("##### OpenFeedback failed to open the feedback dialog #####");
		return;
	}

	dlg.PagePlayerIndex = PagePlayerIndex;
	dlg.SetUp(CurrentGamer);
}

static function PreloadMenu(GUIController C)
{
	Super.PreloadMenu(C);

	C.PreloadMenu("GUI.gbx_LiveGamerConfirm");
}

defaultproperties
{
	PagePlayerIndex=-3

	Begin Object Class=GUILabel Name=clblInfo
		StyleName="LargeButton"
		DrawMenuState=1
		TextAlign=TXTA_Center
		bMultiLine=false
		bNeverFocus=true
		WinWidth=0.700000
		WinHeight=0.050000
		WinLeft=0.150000
		WinTop=0.160000
		TabOrder=0
	End Object
	lblInfo=clblInfo

	Begin Object Class=moLabel Name=cGamerInfo
		CompStyle="MenuOptionLabel"
		LabelStyle="MenuOptionLabel"
		CompTextAlign=TXTA_Left
		LabelJustification=TXTA_Right
		CaptionWidth=0.495
		ComponentWidth=0.5
		WinWidth=0.90
		WinHeight=0.052000
		WinLeft=0.050
		WinTop=0.28000
		bHeightFromComponent=false
		bNeverFocus=true
		bAcceptsInput=false
		bFocusOnWatch=false
	End Object
	MyGamerInfo(0)=cGamerInfo

//	StringInfoHeader="Feedback For :"
	StringGamerInfoCaptions(0)="Gamertag :"

	bRequireLink=true
	bRequireLive=true
	PlayerStatusDisplayStyle=CD_Signin
}
class gbx_LiveGamerVoice extends gbx_LiveGamerScreen;

var automated GUILabel			lblCaption;
var automated GUILabel			lblProgressBack;

var bool						bHasCommunicator;
var bool						bSkipCommunicatorCheck;		// ugly hack to skip the next communicator check after changing XHV_ENABLE

const MAX_RECORD_TIME = 15.0;	// same as XHV_MAX_VOICEMAIL_DURATION_MS

var localized string			StrPlay;
var localized string			StrStop;
var localized string			StrRecord;
var localized string			StrSend;
var localized string			StrDeleteMessage;
var localized string			StrCapNothingRecorded;
var localized string			StrCapNoMessage;
var localized string			StrCapMessageRtrieved;
var localized string			StrCapRecording;
var localized string			StrCapPlaying;
var localized string			StrCapRecorded;
var localized string			StrCapUploading;
var localized string			StrCapDownloading;
var localized string			StrInsertCommunicator;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	OnXButtonEvent = OnDeleteMessage;
	EnableDelete(false);
}

function SetUp(out gbx_LiveGamerList.Gamer G)
{
	Super.SetUp(G);

	bHasCommunicator = int(ConsoleCommand("VOICE_IS_COMMUNICATOR_CONNECTED " $GetControllerIndex())) != 0;	
}

function EnableDelete(bool bEnable)
{
	if (bEnable)
		SetupXButton(StrDeleteMessage);
	else
		SetupXButton();
}

function EnableXHV(bool bEnable)
{
	if (bEnable)
	{
		ConsoleCommand("XHV_ENABLE " $ GetControllerIndex());
		bSkipCommunicatorCheck = true;
	}
	else
	{
		ConsoleCommand("XHV_DISABLE");
	}
}

function OnDeleteMessage();

function string FormatCaptionString(string base, float time)
{
	ReplaceText( base, "<TIME>", String(int(time + 0.5)) );
	return base;
}

function bool ScreenOnDraw(Canvas C)
{
	// blah, skip the menulayoutscreen
	return Super(gbx_ScreenABXY).ScreenOnDraw(C);
}

function DrawProgressBar(Canvas C, float fraction)
{
	local float L, T, R;

	// background
	C.DrawColor = Controller.BackgroundBoxColor;
	lblProgressBack.DrawComponentBackground(C);

	// empty channel
	L = lblProgressBack.HorizontalOffset(0.05);
	R = lblProgressBack.HorizontalOffset(0.95);
	T = lblProgressBack.VerticalOffset(0.5);
	C.SetDrawColor(0, 0, 0, 255);
	DrawBackground(C, L, T, R-L, 0, 0.0, 3.0);

	// the bar
	if (fraction > 0.0)
	{
		R = lblProgressBack.HorizontalOffset(0.05 + 0.9 * fraction);

		C.DrawColor = Controller.RedLineColor;
		DrawBackground(C, L, T, R-L, 0, 0.0, 3.0);
	}
}

function HandleCommunicatorLoss()
{
	GUILog("HandleCommunicatorLoss");
	bHasCommunicator = false;
}

function HandleCommunicatorFound()
{
	GUILog("HandleCommunicatorFound");
	bHasCommunicator = true;
}

function HandleLossErrors(int iLostController, bool bLostLive, bool bLostLink)
{
	if (bHasCommunicator && (iLostController == GetControllerIndex()))
	{
		HandleCommunicatorLoss();
	}
}

function Timer()
{
	if (bHasCommunicator && !bSkipCommunicatorCheck)
	{
		if (int(ConsoleCommand("VOICE_IS_COMMUNICATOR_CONNECTED " $GetControllerIndex())) == 0)
		{
			HandleCommunicatorLoss();
		}
	}
	else
	{
		if (int(ConsoleCommand("VOICE_IS_COMMUNICATOR_CONNECTED " $GetControllerIndex())) != 0)
		{
			HandleCommunicatorFound();
		}
	}

	bSkipCommunicatorCheck = false;
}

defaultproperties
{
	PagePlayerIndex=-3

	StrPlay="Play"
	StrStop="Stop"
	StrRecord="Record"
	StrSend="Send"
	StrDeleteMessage="Delete Message"
	StrCapNothingRecorded="Nothing Recorded"
	StrCapNoMessage="Press Play to Retrieve Message ..."
	StrCapMessageRtrieved="Message Retrieved"
	StrCapRecording="Recording (<TIME>s) ..."
	StrCapPlaying="Playing (<TIME>s) ..."
	StrCapRecorded="Recorded (<TIME>s)"
	StrCapUploading="Uploading Message ..."
	StrCapDownloading="Retrieving Message ..."
	StrInsertCommunicator="Insert headset to port <PORT>"

	// recording caption
	Begin Object Class=GUILabel Name=clblCaption
		StyleName="MenuOptionCaption"
		DrawMenuState=2
		TextAlign=TXTA_Left
		bAcceptsInput=false
		bNeverFocus=true
		bTabStop=false
		bTransparent=true
		bDrawToFit=true
		WinWidth=0.700000
		WinHeight=0.050000
		WinLeft=0.15000
		WinTop=0.3400000
	End Object
	lblCaption=clblCaption

	// simple, empty label to contain the progress bar thingy
	Begin Object Class=GUILabel Name=clblProgressBack
		StyleName="MenuOptionLabel"
		TextAlign=TXTA_Left
		bAcceptsInput=false
		bNeverFocus=true
		bTabStop=false
		bTransparent=true
		WinWidth=0.700000
		WinHeight=0.050000
		WinLeft=0.15000
		WinTop=0.3900000
	End Object
	lblProgressBack=clblProgressBack
}
class gbx_LiveGamerVoicePlayback extends gbx_LiveGamerVoice;

// start command is in LParam1

var automated GUIButton			btnPlay;
var automated GUIButton			btnStop;

var bool						bPlayedMessage;
var float						RecordPlayStartTime;

var localized string			StringErrorDownload;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	InitExecution();

	Super.InitComponent(MyController, MyOwner);
	OnClose = VoicePlaybackClosed;
	OnBButtonEvent = OnBButton;
	OnYButtonEvent = OnFeedback;

	btnPlay.SetCaption(StrPlay);
	btnStop.SetCaption(StrStop);

	btnPlay.OnClick = OnPlay;
	btnStop.OnClick = OnStop;

	RecordPlayStartTime = PlayerOwner().Level.UniversalTimeSeconds;
	SetTimer(0.1, true);
	GotoState('NoData');
}

function VoicePlaybackClosed(optional bool bCancelled)
{
	EnableXHV(false);
}

function SetupHelpButtons()
{
	if (FocusedControl == btnPlay)
	{
		SetupAButton(StrPlay);
	}
	else if (FocusedControl == btnStop)
	{
		SetupAButton(StrStop);
	}
}

event SetFocus(GUIComponent Who)
{
	Super.SetFocus(Who);
	SetupHelpButtons();
}

function OnBButton()
{
	BaseOnBButton();
}

function bool OnPlay(GUIComponent Sender)	{return true;}
function bool OnStop(GUIComponent Sender)	{return true;}
function bool OnGet(GUIComponent Sender)	{return true;}

function Timer()
{
	Super.Timer();
}

function bool ScreenOnDraw(Canvas C)
{
	return Super.ScreenOnDraw(C);
}

function StoreStartTime()
{
	RecordPlayStartTime = PlayerOwner().Level.UniversalTimeSeconds;
}
function float TimeElapsed()
{
	if (RecordPlayStartTime > 0.0)
		return PlayerOwner().Level.UniversalTimeSeconds - RecordPlayStartTime;
	else
		return 0.0;
}

function SetRecordCaption();
function float GetProgressTime()
{
	return FClamp(TimeElapsed(), 0, MAX_RECORD_TIME);
}

function OnFeedback()
{
	local gbx_LiveVoicePlaybackOptions dlg;

	Controller.PlayClickSound(EClickSound.CS_Click);
	Controller.OpenMenu("GUI.gbx_LiveVoicePlaybackOptions");

	dlg = gbx_LiveVoicePlaybackOptions(Controller.ActivePage);
	dlg.PagePlayerIndex = PagePlayerIndex;
	dlg.SetUp(CurrentGamer);
}

state NoData
{
	function BeginState()
	{
		btnPlay.EnableControl(true);
		btnStop.EnableControl(false);

		RecordPlayStartTime = 0.0;

		SetupHelpButtons();
		SetRecordCaption();
	}

	function SetRecordCaption()
	{
		lblCaption.SetCaption( StrCapNoMessage );
	}

	function bool ScreenOnDraw(Canvas C)
	{
		DrawProgressBar(C, 0);
		return Global.ScreenOnDraw(C);
	}

	function SetupHelpButtons()
	{
		Global.SetupHelpButtons();
		SetupBButton(StringBack);
		SetupXButton();
	}

	function bool OnPlay(GUIComponent Sender)
	{
		GotoState('Downloading');
		return true;
	}
}

state Downloading
{
	function BeginState()
	{
		btnPlay.EnableControl(false);
		btnStop.EnableControl(false);

		SetupHelpButtons();
		SetRecordCaption();

		EnableXHV(true);
		if ( !("SUCCESS" ~= ConsoleCommand( LParam1 )) )
		{
			DownloadError();
		}
	}

	function SetRecordCaption()
	{
		lblCaption.SetCaption( StrCapDownloading );
	}

	function bool ScreenOnDraw(Canvas C)
	{
		DrawProgressBar(C, 0);
		return Global.ScreenOnDraw(C);
	}

	function SetupHelpButtons()
	{
		SetupBButton();
		SetupAButton();
		SetupXButton();
	}

	function Timer()
	{
		local string test;
		
		Global.Timer();
		test = ConsoleCommand("XLIVE FRIENDS USER=" $ PagePlayerIndex @ "PUMP_VOICE_DOWNLOAD");
		if (test ~= "COMPLETE")
		{
			test = ConsoleCommand( "XLIVE FRIENDS USER=" $ PagePlayerIndex @ "SEND_VOICE_DOWNLOAD_TO_XHV");
			if (test ~= "SUCCESS")
			{
				GotoState('GotMessage');
			}
			else
			{
				DownloadError();
			}
		}
		else if (test ~= "FAILURE")
		{
			DownloadError();
		}
	}

	function DownloadError()
	{
		LaunchErrorDialog(Controller, StringErrorDownload, "OK NONE");
		GotoState('NoData');
	}
}

state GotMessage
{
	function BeginState()
	{
		btnPlay.EnableControl(true);
		btnStop.EnableControl(false);

		btnPlay.SetFocus(None);

		SetupHelpButtons();
		SetRecordCaption();

		if (!bPlayedMessage && (Controller.ActivePage == self))
			OnPlay(None);
	}

	function SetRecordCaption()
	{
		lblCaption.SetCaption( StrCapMessageRtrieved );
	}

	function bool ScreenOnDraw(Canvas C)
	{
		DrawProgressBar(C, 0);
		return Global.ScreenOnDraw(C);
	}

	function SetupHelpButtons()
	{
		Global.SetupHelpButtons();
		SetupBButton(StringBack);
		SetupXButton();
	}

	function bool OnPlay(GUIComponent Sender)
	{
		GotoState('Playing');
		return true;
	}
}

state Playing
{
	function BeginState()
	{
		btnPlay.EnableControl(false);
		btnStop.EnableControl(true);

		btnStop.SetFocus(None);

		SetupHelpButtons();
		SetRecordCaption();

		StoreStartTime();
		ConsoleCommand("XHV_START_PLAYBACK");
	}

	function EndState()
	{
		RecordPlayStartTime = 0.0;
		ConsoleCommand("XHV_STOP_PLAYBACK");
		bPlayedMessage = true;
	}

	function SetupHelpButtons()
	{
		Global.SetupHelpButtons();
		SetupBButton(StringCancel);
		SetupXButton();
	}

	function SetRecordCaption()
	{
		lblCaption.SetCaption( FormatCaptionString(StrCapPlaying, GetProgressTime()) );
	}

	function bool ScreenOnDraw(Canvas C)
	{
		DrawProgressBar(C, GetProgressTime() / MAX_RECORD_TIME);
		return Global.ScreenOnDraw(C);
	}

	function Timer()
	{
		Global.Timer();

		if (ConsoleCommand("XHV_IS_PLAYING") == "FALSE")
		{
			GUILog("Playback complete");
			OnStop(None);
		}

		SetRecordCaption();
	}

	function HandleLossErrors(int iLostController, bool bLostLive, bool bLostLink)
	{
		if (iLostController != -2)
		{
			OnStop(None);
		}

		Global.HandleLossErrors(iLostController, bLostLive, bLostLink);
	}
	function bool OnStop(GUIComponent Sender)
	{
		GotoState('GotMessage');
		return true;
	}
	function OnBButton()
	{
		Controller.PlayClickSound(EClickSound.CS_Change);
		OnStop(None);
	}
	function OnFeedback()
	{
		OnStop(None);
		Global.OnFeedback();
	}
}

static function PreloadMenu(GUIController C)
{
	Super.PreloadMenu(C);

	C.PreloadMenu("GUI.gbx_LiveVoicePlaybackOptions");
}

defaultproperties
{
	ScreenTitle="Play Message"
	YCaption="Message Options"

	// the buttons
	Begin Object Class=GUIButton Name=cBtnPlay
		StyleName="TextButton"
		WinWidth=0.200000
		WinHeight=0.05000
		WinLeft=0.4000000
		WinTop=0.450000
		TabOrder=0
		bForceCaps=true
	End Object
	btnPlay=cBtnPlay
	Begin Object Class=GUIButton Name=cBtnStop
		StyleName="TextButton"
		WinWidth=0.200000
		WinHeight=0.05000
		WinLeft=0.65000000
		WinTop=0.450000
		TabOrder=0
		bForceCaps=true
	End Object
	btnStop=cBtnStop

	StringErrorDownload="An error occurred while downloading the voice message."
	StringInfoHeader="Message From :"
}
class gbx_LiveGamerVoiceRecord extends gbx_LiveGamerVoice;

var automated GUIButton			btnPlay;
var automated GUIButton			btnStop;
var automated GUIButton			btnRecord;
var automated GUIButton			btnSend;

var string 						FinishedCommand;
var string 						FinishedErr;

var float						RecordedSeconds;
var float						RecordPlayStartTime;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	InitExecution();

	Super.InitComponent(MyController, MyOwner);
	OnClose = VoiceRecordClosed;
	OnBButtonEvent = OnBButton;

	btnRecord.SetCaption(StrRecord);
	btnPlay.SetCaption(StrPlay);
	btnStop.SetCaption(StrStop);
	btnSend.SetCaption(StrSend);

	btnPlay.OnClick = OnPlay;
	btnStop.OnClick = OnStop;
	btnRecord.OnClick = OnRecord;
	btnSend.OnClick = OnSend;

	// manually set up the navigation links
	btnRecord.SetLinkOverrides(btnSend, btnSend, btnPlay, btnStop);
	btnStop.SetLinkOverrides(btnSend, btnSend, btnRecord, btnPlay);
	btnPlay.SetLinkOverrides(btnSend, btnSend, btnStop, btnRecord);
	btnSend.SetLinkOverrides(btnRecord, btnPlay, btnRecord, btnPlay);
	MapControls();

	RecordPlayStartTime = PlayerOwner().Level.UniversalTimeSeconds;
}

function SetUp(out gbx_LiveGamerList.Gamer G)
{
	Super.SetUp(G);

	SetTimer(0.1, true);
	EnableXHV(true);

	if (bHasCommunicator)
		GotoState('NoData');
	else
		GotoState('NoCommunicator');
}

function VoiceRecordClosed(optional bool bCancelled)
{
	EnableXHV(false);
}

function SetupHelpButtons()
{
	if (FocusedControl == btnPlay)
	{
		SetupAButton(StrPlay);
	}
	else if (FocusedControl == btnStop)
	{
		SetupAButton(StrStop);
	}
	else if (FocusedControl == btnRecord)
	{
		SetupAButton(StrRecord);
	}
	else if (FocusedControl == btnSend)
	{
		SetupAButton(StringDone);
	}
}

function bool SAB_OnXControllerEvent(byte Id, eXControllerCodes iCode)
{
	return Super.SAB_OnXControllerEvent(Id, iCode);
}

event SetFocus(GUIComponent Who)
{
	Super.SetFocus(Who);
	SetupHelpButtons();
}

function OnBButton()
{
	BaseOnBButton();
}

function BackToNoData()
{
	if (!IsInState('NoData'))
	{
		GotoState('NoData');
	}
}

function OnDeleteMessage()
{
	Controller.PlayClickSound(EClickSound.CS_Click);
	BackToNoData();
}

function HandleCommunicatorLoss()
{
	Super.HandleCommunicatorLoss();
	GotoState('NoCommunicator');
}

function HandleCommunicatorFound()
{
	Super.HandleCommunicatorFound();
	BackToNoData();
}

function HandleLossErrors(int iLostController, bool bLostLive, bool bLostLink)
{
	if (iLostController != -2)
	{
		BackToNoData();
	}

	Super.HandleLossErrors(iLostController, bLostLive, bLostLink);
}

function bool OnPlay(GUIComponent Sender)	{return true;}
function bool OnStop(GUIComponent Sender)	{return true;}
function bool OnRecord(GUIComponent Sender) {return true;}
function bool OnSend(GUIComponent Sender)	{return true;}

function Timer()
{
	Super.Timer();
}

function bool ScreenOnDraw(Canvas C)
{
	DrawProgressBar(C, GetProgressTime() / MAX_RECORD_TIME);
	return Super.ScreenOnDraw(C);
}

function StoreStartTime()
{
	RecordPlayStartTime = PlayerOwner().Level.UniversalTimeSeconds;
}
function float TimeElapsed()
{
	if (RecordPlayStartTime > 0.0)
		return PlayerOwner().Level.UniversalTimeSeconds - RecordPlayStartTime;
	else
		return 0.0;
}

function SetRecordCaption();
function float GetProgressTime()
{
	return FClamp(TimeElapsed(), 0, MAX_RECORD_TIME);
}

state NoCommunicator
{
	function BeginState()
	{
		EnableDelete(false);

		btnRecord.EnableControl(false);
		btnPlay.EnableControl(false);
		btnStop.EnableControl(false);
		btnSend.EnableControl(false);

		RecordedSeconds = 0.0;
		RecordPlayStartTime = 0.0;

		SetupHelpButtons();
		SetRecordCaption();
	}
	function SetRecordCaption()
	{
		local string S;

		S = StrInsertCommunicator;
		ReplaceText(S, "<PORT>", String(GetControllerIndex() + 1));
		lblCaption.SetCaption( S );
	}
	function SetupHelpButtons()
	{
		SetupAButton();
		SetupBButton(StringCancel);
	}
	function bool SAB_OnXControllerEvent(byte Id, eXControllerCodes iCode)
	{
		switch(iCode)
		{
			case XC_PadUp:
			case XC_PadDown:
			case XC_PadLeft:
			case XC_PadRight:
				return true;
		}

		return Global.SAB_OnXControllerEvent(Id, iCode);
	}
}

state NoData
{
	function BeginState()
	{
		EnableDelete(false);

		btnRecord.EnableControl(true);
		btnPlay.EnableControl(false);
		btnStop.EnableControl(false);
		btnSend.EnableControl(false);

		btnRecord.SetFocus(None);

		RecordedSeconds = 0.0;
		RecordPlayStartTime = 0.0;

		SetupHelpButtons();
		SetRecordCaption();
	}

	function SetRecordCaption()
	{
		lblCaption.SetCaption( FormatCaptionString(StrCapNothingRecorded, 0) );
	}

	function SetupHelpButtons()
	{
		Global.SetupHelpButtons();
		SetupBButton(StringCancel);
	}

	function bool OnRecord(GUIComponent Sender)
	{
		GotoState('Recording');
		return true;
	}

	function bool SAB_OnXControllerEvent(byte Id, eXControllerCodes iCode)
	{
		switch(iCode)
		{
			case XC_PadUp:
			case XC_PadDown:
			case XC_PadLeft:
			case XC_PadRight:
				return true;
		}

		return Global.SAB_OnXControllerEvent(Id, iCode);
	}
}

state PreRecording
{
	function BeginState()
	{
		GotoState('Recording');
	}
}

state Recording
{
	function BeginState()
	{
		btnRecord.EnableControl(false);
		btnPlay.EnableControl(false);
		btnStop.EnableControl(true);
		btnSend.EnableControl(false);

		btnStop.SetFocus(None);

		SetupHelpButtons();
		SetRecordCaption();

		RecordedSeconds = 0.0;
		StoreStartTime();
		ConsoleCommand("XHV_START_RECORDING");
		EnableDelete(true);
	}

	function EndState()
	{
		RecordedSeconds = GetProgressTime();
		RecordPlayStartTime = 0.0;
		ConsoleCommand("XHV_STOP_RECORDING");
	}

	function SetupHelpButtons()
	{
		Global.SetupHelpButtons();
		SetupBButton(StringCancel);
	}

	function SetRecordCaption()
	{
		lblCaption.SetCaption( FormatCaptionString(StrCapRecording, GetProgressTime()) );
	}

	function Timer()
	{
		Global.Timer();

		if (TimeElapsed() > MAX_RECORD_TIME)
			OnStop(None);
		if (ConsoleCommand("XHV_IS_RECORDING") == "FALSE")
			OnStop(None);

		SetRecordCaption();
	}

	function bool OnStop(GUIComponent Sender)
	{
		GotoState('Recorded');
		return true;
	}
	function OnBButton()
	{
		OnStop(None);
	}
	function OnDeleteMessage()
	{
		ConsoleCommand("XHV_STOP_RECORDING");
		Global.OnDeleteMessage();
	}
	function bool SAB_OnXControllerEvent(byte Id, eXControllerCodes iCode)
	{
		switch(iCode)
		{
			case XC_PadUp:
			case XC_PadDown:
			case XC_PadLeft:
			case XC_PadRight:
				return true;
		}

		return Global.SAB_OnXControllerEvent(Id, iCode);
	}
}

state Recorded
{
	function BeginState()
	{
		btnRecord.EnableControl(true);
		btnPlay.EnableControl(true);
		btnStop.EnableControl(false);
		btnSend.EnableControl(true);

		btnPlay.SetFocus(None);

		SetupHelpButtons();
		SetRecordCaption();
		EnableDelete(true);
	}

	function SetupHelpButtons()
	{
		Global.SetupHelpButtons();
		SetupBButton(StringCancel);
	}

	function SetRecordCaption()
	{
		lblCaption.SetCaption( FormatCaptionString(StrCapRecorded, RecordedSeconds) );
	}

	function bool OnPlay(GUIComponent Sender)
	{
		GotoState('Playing');
		return true;
	}
	function bool OnSend(GUIComponent Sender)
	{
		if( "SUCCESS" != ConsoleCommand(FinishedCommand) )
		{
			Controller.LiveFunc.LiveErrorMessage(FinishedErr, true, "XONLINE_E_FRIENDS_LIST_ERROR");
			return true;
		}
		else
		{
			GotoState('Uploading');
			//BaseOnAButton();
			return true;
		}
	}
	function bool OnRecord(GUIComponent Sender)
	{
		GotoState('Recording');
		return true;
	}
}

state Playing
{
	function BeginState()
	{
		btnRecord.EnableControl(false);
		btnPlay.EnableControl(false);
		btnStop.EnableControl(true);
		btnSend.EnableControl(false);

		btnStop.SetFocus(None);

		SetupHelpButtons();
		SetRecordCaption();

		StoreStartTime();
		ConsoleCommand("XHV_START_PLAYBACK");
		EnableDelete(true);
	}

	function EndState()
	{
		RecordPlayStartTime = 0.0;
		ConsoleCommand("XHV_STOP_PLAYBACK");
	}

	function SetupHelpButtons()
	{
		Global.SetupHelpButtons();
		SetupBButton(StringCancel);
	}

	function SetRecordCaption()
	{
		lblCaption.SetCaption( FormatCaptionString(StrCapPlaying, GetProgressTime()) );
	}

	function Timer()
	{
		Global.Timer();

		if (TimeElapsed() > RecordedSeconds)
			OnStop(None);
		if (ConsoleCommand("XHV_IS_PLAYING") == "FALSE")
			OnStop(None);

		SetRecordCaption();
	}

	function bool OnStop(GUIComponent Sender)
	{
		GotoState('Recorded');
		return true;
	}
	function OnBButton()
	{
		OnStop(None);
	}
	function OnDeleteMessage()
	{
		ConsoleCommand("XHV_STOP_PLAYBACK");
		Global.OnDeleteMessage();
	}

	function bool SAB_OnXControllerEvent(byte Id, eXControllerCodes iCode)
	{
		switch(iCode)
		{
			case XC_PadUp:
			case XC_PadDown:
			case XC_PadLeft:
			case XC_PadRight:
				return true;
		}

		return Global.SAB_OnXControllerEvent(Id, iCode);
	}
}

state Uploading
{
	function BeginState()
	{
		EnableDelete(false);
		btnRecord.EnableControl(false);
		btnPlay.EnableControl(false);
		btnStop.EnableControl(false);
		btnSend.EnableControl(false);

		btnPlay.SetFocus(None);

		SetupHelpButtons();
		SetupAButton();
		SetupBButton();

		SetRecordCaption();
		SetTimer(0.1, true);
	}

	function Timer()
	{
		local string test;
		
		Global.Timer();
		test = ConsoleCommand("XLIVE FRIENDS USER=" $ PagePlayerIndex @ "PUMP_VOICE_UPLOAD");
		log("PUMP_VOICE_UPLOAD returned " $ test, 'MP');
		if (test != "SUCCESS")
		{
			if (test != "COMPLETE")
			{
				Controller.LiveFunc.LiveErrorMessage(FinishedErr, true, "XONLINE_E_FRIENDS_LIST_ERROR");
			}
			else
			{
				Controller.CloseMenu(false);
			}
		}
	}

	function HandleCommunicatorLoss();

	function SetupHelpButtons()
	{
		Global.SetupHelpButtons();
	}

	function SetRecordCaption()
	{
		lblCaption.SetCaption( FormatCaptionString(StrCapUploading, RecordedSeconds) );
	}

	function bool OnPlay(GUIComponent Sender)
	{
		return false;
	}
	function bool OnSend(GUIComponent Sender)
	{
		return false;
	}
	function bool OnRecord(GUIComponent Sender)
	{
		return false;
	}

	function bool SAB_OnXControllerEvent(byte Id, eXControllerCodes iCode)
	{
		switch(iCode)
		{
			case XC_PadUp:
			case XC_PadDown:
			case XC_PadLeft:
			case XC_PadRight:
				return true;
		}

		return Global.SAB_OnXControllerEvent(Id, iCode);
	}
}

defaultproperties
{
	ScreenTitle="Record Message"

	// the buttons
	Begin Object Class=GUIButton Name=cBtnRecord
		StyleName="TextButton"
		WinWidth=0.200000
		WinHeight=0.05000
		WinLeft=0.1500000
		WinTop=0.450000
		TabOrder=0
		bForceCaps=true
	End Object
	btnRecord=cBtnRecord
	Begin Object Class=GUIButton Name=cBtnStop
		StyleName="TextButton"
		WinWidth=0.200000
		WinHeight=0.05000
		WinLeft=0.4000000
		WinTop=0.450000
		TabOrder=0
		bForceCaps=true
	End Object
	btnStop=cBtnStop
	Begin Object Class=GUIButton Name=cBtnPlay
		StyleName="TextButton"
		WinWidth=0.200000
		WinHeight=0.05000
		WinLeft=0.65000000
		WinTop=0.450000
		TabOrder=0
		bForceCaps=true
	End Object
	btnPlay=cBtnPlay

	Begin Object Class=GUIButton Name=cBtnSend
		StyleName="TextButton"
		WinWidth=0.200000
		WinHeight=0.05000
		WinLeft=0.40000000
		WinTop=0.510000
		TabOrder=0
		bForceCaps=true
	End Object
	btnSend=cBtnSend

	StringInfoHeader="Message To :"
}
class gbx_LiveLeaderboard extends gbx_ScreenLRWB;

const RANK_ROW_COUNT = 10;

struct RankInfo
{
	var int Rank;
	var string Name;
	var int Games;
	var int Wins;
	var int Losses;
	var int ELORating;
	var int XBLRating;
	var bool SPCompleted;
	var bool LocalPlayer;
};

var automated GUILabel					lblMode;
var automated GUILabel					lblMission;

var Automated GUIMultiColumnListBox	Gamer;
var gbx_LeaderBoardMultiColumnList		GamerList;


var int LeaderBoardID;
var() string MapName;

//#if XLIVE_STATS_WEEKLY, change 2 -> 3
var() localized String LeaderBoardDurations[2];

var() int LeaderBoardDurationIndex;

var() int LeaderBoardPivot;
var int DesiredLeaderBoardPivot;
var int OldPivot;
var() bool AtTop;
var() bool AtBottom;
var() bool NoResults;
var() string LocalGamer;

var automated gbx_LiveLeaderboardProgress ProgressMessage;

var float RequestTime; //make sure we throttle to one request per second
var bool ProcessedResults; //have we processed the results sent to us, yet?
var bool ValidResults; //did we receive valid results? or an empty leaderboard?

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);
	InitExecution();

	OnAButtonEvent = OnSelectGamer;
	OnBButtonEvent = OnBack;
//	OnXButtonEvent = OnShowFriends;
	OnYButtonEvent = OnChooseTimeframe;
	OnLButtonEvent = OnPageUp;
	OnRButtonEvent = OnPageDown;
	OnBlButtonEvent = OnJumpToMe;
	OnWhButtonEvent = OnJumpToTop;
	OnClose = InternalOnClose;
	GamerList = gbx_LeaderBoardMultiColumnList(Gamer.List);

	LocalGamer = ConsoleCommand("XLIVE GET_GAMER_TAG" @PagePlayerIndex);
}

event HandleParameters(string Param1, string Param2)
{
	local int MapIndex;
	Super.HandleParameters(Param1, Param2);
	LeaderBoardID = int(Param1);
	MapIndex = int(Param2);
	if( MapIndex == 0 )
		MapName = class'gbx_LeaderboardMapSelectMultiColumnList'.default.StringOverallRanking;
	else
		MapName = class'Gameplay.gbxMPMissionList'.Static.GetMissionName(MapIndex-1, true);
	
	UpdateTimeframe();

	LiveInitComponent();
}

function InternalOnClose(optional Bool bCancelled);

function ResetFocus()
{
	if( ProgressMessage.bVisible )
		SetFocus( ProgressMessage );
	else
		FocusFirst(None);
}

function OnBack()
{
	if( IsInState('AwaitingQuery') )
		ConsoleCommand("XLIVE STAT_CANCEL");
	BaseOnBButton();
}

function Clear()
{
	GamerList.Clear();
}

function OnSelectGamer()
{
	if(GamerList.Index < GamerList.PlayerList.Length)
	{
		Controller.PlayClickSound(EClickSound.CS_Click);

		Controller.OpenMenu("GUI.gbx_LiveLeaderboardPlayer", GamerList.PlayerList[GamerList.Index].Name);
	}
}

function UpdateTimeframe()
{
	lblMode.SetCaption(LeaderBoardDurations[LeaderBoardDurationIndex]);
	lblMission.SetCaption(MapName);

	SetupYButton(YCaption$LeaderBoardDurations[(LeaderBoardDurationIndex+1)%ArrayCount(LeaderBoardDurations)],YHint);
}

function OnChooseTimeframe()
{
	Controller.PlayClickSound(EClickSound.CS_Click);

	LeaderBoardPivot = 0;
	LeaderBoardDurationIndex = (LeaderBoardDurationIndex+1) % ArrayCount(LeaderBoardDurations);

	UpdateTimeframe();
	
	QueryPivot( 0 );
}

function OnPageUp()
{
	Controller.PlayClickSound(EClickSound.CS_Change);

	if( !AtTop )
	{
		QueryPivot( Max(LeaderBoardPivot - RANK_ROW_COUNT, 1) );
	}
}

function OnPageDown()
{
	Controller.PlayClickSound(EClickSound.CS_Change);

	if ( !AtBottom )
	{
		QueryPivot( LeaderBoardPivot + RANK_ROW_COUNT );
	}
}

function OnJumpToTop()
{
	Controller.PlayClickSound(EClickSound.CS_Change);

	if( !AtTop || NoResults )
	{
		QueryPivot( 1 );
	}
}

function OnJumpToMe()
{	
	Controller.PlayClickSound(EClickSound.CS_Change);

	QueryPivot( 0 );
}


function LiveInitComponent()
{
	LeaderBoardDurationIndex = 0;
	LeaderBoardPivot = 0;

	UpdateTimeframe();
	QueryPivot(0);
}

simulated function GetResults()
{
	local int i;
	local string Results;
	local int CurGamerIndex;
	local int NumResults;
	local RankInfo rank;
	
	UpdateTimeframe();

	Results = ConsoleCommand("XLIVE STAT_LEADERBOARD_RESULTS");
	
	NoResults = (Results == "");

	// If there are no results, there are a couple of scenarios
	if( NoResults )
	{
		// And of course, no results implies the bottom of the list
		// In the case of a "backed up" result set, we still want this set 
		// so they can't scroll down any further
		if( LeaderboardPivot > 0 )
			AtBottom = true;

		// If we are trying to view the top 10 and there are no results
		if( LeaderBoardPivot == 1 )
		{
			// Then we are at the top of the list
			AtTop = true;
		}
		else
		{
			// Otherwise, we tried to scroll down too far
			// So "back up" our LeaderBoardPivot to the previous screen
			DesiredLeaderBoardPivot = OldPivot;
		}
		
		// Don't do any further processing
		return;
	}

	i = 0;
	CurGamerIndex = -1;
	NumResults = 0;
	AtTop = false;
	AtBottom = false;

	GamerList.Clear();
	
	while( Len(Results)>1 )
	{
		rank.Name = ParseToken(Results);
		rank.Games = int(ParseToken(Results));
		rank.Wins = int(ParseToken(Results));
		rank.Losses = rank.Games - rank.Wins;
		rank.ELORating = int(ParseToken(Results));
		rank.XBLRating = int(ParseToken(Results));
		rank.SPCompleted = bool(int(ParseToken(Results)));
		rank.Rank = int(ParseToken(Results));
		rank.LocalPlayer = (rank.Name == LocalGamer);

		GamerList.AddPlayer(rank);

		if( rank.Rank == 1 )
		{
			AtTop = true;
		}

		if( LeaderBoardPivot == 0 && rank.Name == LocalGamer )
		{
			CurGamerIndex = i;

			LeaderBoardPivot = GamerList.PlayerList[0].Rank;
			DesiredLeaderBoardPivot = LeaderBoardPivot;
			// don't set the pivot to the player, because then pagedown jumps to pivot+RANK_ROW_COUNT, possibly skipping some
			// LeaderBoardPivot = rank.Rank;
		}
		
		i++;
	}

	NumResults = i;

	if( NumResults>0 && NumResults != RANK_ROW_COUNT )
	{
		AtBottom = true;
	}

	if( CurGamerIndex == -1 )
		CurGamerIndex = Clamp((NumResults / 2)-1, 0, RANK_ROW_COUNT);

	SetListPosition(CurGamerIndex);
}

simulated function SetListPosition( int NewPosition )
{
	GamerList.SetIndex(NewPosition);
}

function QueryPivot(int NewPivot)
{
	local string s;
	local string interval;
	local int PassedPivot;
	
	OldPivot = LeaderBoardPivot;
	LeaderBoardPivot = NewPivot;
	DesiredLeaderBoardPivot = LeaderBoardPivot;

	switch( LeaderBoardDurationIndex )
	{
	case 0:
		interval = "TOTAL";
		break;
	case 1:
		interval = "MONTH";
		break;
	case 2:
		interval = "WEEK";
		break;
	}

	// request at the pivot passed in
	PassedPivot = LeaderBoardPivot;
	// if we weren't passed a pivot:
	//   we want to center around the GamerTag for the current controller
	if( PassedPivot == 0 )
		PassedPivot = -PagePlayerIndex;
	
	s = ConsoleCommand("XLIVE STAT_GET_LEADERBOARD"@LeaderBoardID@interval@string(PassedPivot));
	if( s == "SUCCESS" )
	{
		GotoState('AwaitingQuery');
	}
	else
	{
		// show error
		ShowStatsError();
	}
}

function ShowStatsError()
{
	log("STAT ERROR!");
	//TODO
}

function ShowStatsProgress( bool bShow )
{
	ProgressMessage.SetVisibility(bShow);
	if( bShow )
		SetFocus( ProgressMessage );
	else
		SetFocus( Gamer );
}

state AwaitingQuery
{
	simulated function BeginState()
	{
		RequestTime = Controller.ViewportOwner.Actor.Level.TimeSeconds;
		bDeferControllerLoss = true;
		ProcessedResults = false;
		SetTimer( 0.1, true );
		ShowStatsProgress( true );
	}
	
	simulated function EndState()
	{
		SetTimer( 0, false );
		ShowStatsProgress( false );
		bDeferControllerLoss = false;
	}

	simulated function Timer()
	{
		local String s;
		// If we've already processed results
		if( ProcessedResults )
		{
			// Wait for the timer to elapse
			if(Controller.ViewportOwner.Actor.Level.TimeSeconds > RequestTime + 1.2)
			{
				// If the timer's elapsed, leave this state
				GotoState('');
				
				// If we have a blank leaderboard (player isn't on leaderboard)
				// and if we weren't already trying to load the top of the list...
				if( NoResults )
				{
					if( LeaderBoardPivot == 0 )
						// Force a jump to the top of the list
						OnJumpToTop();
					else if( DesiredLeaderBoardPivot != LeaderBoardPivot )
						// requery at old pivot, to re-setup player list
						// so that we can drill down into a player correctly
						QueryPivot( DesiredLeaderBoardPivot );
				}
					
			}
			// Waiting on timeout, so don't process GetResults() data
			return;
		}

		s = ConsoleCommand("XLIVE STAT_GET_STATE");
		if( s == "READING_LEADERBOARD" )
			return;
		else if ( s == "DONE" )
		{
			// Grab the data
			GetResults();
			// And set the flag for Timer()
			ProcessedResults = true;
		}
		else if ( s == "ERROR" || s == "BAD_STATE" )
		{
			ShowStatsError();
		}
	}

	function bool SAB_OnXControllerEvent(byte Id, eXControllerCodes iCode)
	{
		switch(iCode)
		{
			case XC_PadUp:
			case XC_PadDown:
			case XC_PadLeft:
			case XC_PadRight:
				return true;
		}

		return Super.SAB_OnXControllerEvent(Id, iCode);
	}

	function InternalOnClose(optional Bool bCancelled)
	{
		ConsoleCommand("XLIVE STAT_CANCEL");
	}

    simulated function OnSelectGamer(){}
    simulated function OnShowFriends(){}
    simulated function OnChooseTimeframe(){}
    simulated function OnPageUp(){}
    simulated function OnPageDown(){}
    simulated function OnJumpToMe(){}
    simulated function QueryPivot(int NewPivot){}
}

static function PreloadMenu(GUIController C)
{
	Super.PreloadMenu(C);

	C.PreloadMenu("GUI.gbx_LiveLeaderboardPlayer");
}

defaultproperties
{
	ScreenTitle="Leaderboard"
	PlayerStatusDisplayStyle=CD_Signin
	bRequireLive=true
	PagePlayerIndex=-2

	Begin Object class=GUIMultiColumnListBox Name=cGamer
		WinWidth=0.9
		WinHeight=0.49
		WinLeft=0.05
		WinTop=0.205
		bVisibleWhenEmpty=true
		DefaultListClass="GUI.gbx_LeaderboardMultiColumnList"
	End Object
	Gamer=cGamer

	
	Begin Object Class=gbx_LiveLeaderboardProgress Name=cProgress
		bAcceptsInput=false
		bTabStop=false
		WinWidth=0.400000
		WinHeight=0.20000
		WinLeft=0.300000
		WinTop=0.400000
	End Object
	ProgressMessage=cProgress
	
	Begin Object Class=GUILabel Name=clblLBMode
		StyleName="MenuOptionCaption"
		TextAlign=TXTA_Left
		DrawMenuState=1
		bAcceptsInput=false
		bNeverFocus=true
		bTabStop=false
		bDrawToFit=true
		bTransparent=true
		WinWidth=0.45
		WinHeight=0.050000
		WinLeft=0.0500
		WinTop=0.15500000
	End Object
	lblMode=clblLBMode

	Begin Object Class=GUILabel Name=clblLBMission
		StyleName="MenuOptionCaption"
		TextAlign=TXTA_Right
		DrawMenuState=1
		bAcceptsInput=false
		bNeverFocus=true
		bTabStop=false
		bDrawToFit=true
		bTransparent=true
		WinWidth=0.45
		WinHeight=0.050000
		WinLeft=0.500
		WinTop=0.15500000
	End Object
	lblMission=clblLBMission

	ACaption="View Player"
//	XCaption="Show Friends"
	YCaption="Show " //changes with use
	LCaption="Page Up"
	RCaption="Page Down"
	WhCaption="Top Ten"
	BlCaption="My Ranking"

	LeaderBoardDurations(0)="All Time"
	LeaderBoardDurations(1)="Monthly"
//#if XLIVE_STATS_WEEKLY, uncomment below
//	LeaderBoardDurations(2)="Weekly"

}
// The leaderboard map selection screen.
// Players select a map from the list displayed on this screen and then are
// sent to the leaderboard (gbx_LiveLeaderboard)

class gbx_LiveLeaderboardMapSelect extends gbx_ScreenABXY;

struct MapInfo
{
	var string Display;
	var int LeaderboardID;
};

var Automated GUIMultiColumnListBox	MapListBox;
var gbx_LeaderboardMapSelectMultiColumnList		MapList;

static function LaunchLeaderboard(GUIController C, int inPlayerIndex)
{
	class'gbx_LiveLeaderboardMapSelect'.default.PagePlayerIndex = inPlayerIndex;
	C.OpenMenu("GUI.gbx_LiveLeaderboardMapSelect");
	class'gbx_LiveLeaderboardMapSelect'.default.PagePlayerIndex = -1;
}

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	OnAButtonEvent = OnSelectMap;
	OnBButtonEvent = OnBack;
	MapList = gbx_LeaderboardMapSelectMultiColumnList(MapListBox.List);
}

function OnBack()
{
	BaseOnBButton();
}

function OnSelectMap()
{
	Controller.PlayClickSound(EClickSound.CS_Click);

	Controller.OpenMenu("GUI.gbx_LiveLeaderboard", string(MapList.MapList[MapList.Index].LeaderboardID), string(MapList.Index));
}

static function PreloadMenu(GUIController C)
{
	Super.PreloadMenu(C);

	C.PreloadMenu("GUI.gbx_LiveLeaderboard");
}

defaultproperties
{
	ScreenTitle="Leaderboard"
	PlayerStatusDisplayStyle=CD_Signin
	bRequireLive=true

	Begin Object class=GUIMultiColumnListBox Name=cMapListBox
		WinWidth=0.8
		WinHeight=0.54
		WinLeft=0.1
		WinTop=0.18
		bVisibleWhenEmpty=true
		DefaultListClass="GUI.gbx_LeaderboardMapSelectMultiColumnList"
	End Object
	MapListBox=cMapListBox

	ACaption="Select Mission"
}
class gbx_LiveLeaderboardPlayer extends gbx_MenuLayoutScreen;

var string GamerTag;

event HandleParameters(string Param1, string Param2)
{
	Super.HandleParameters(Param1, Param2);

	GamerTag = Param1;
	GetResults();
}

simulated function GetResults()
{
	local int Games, Wins;
	local string Percent;
	local int DotLoc;
	local int i;
	local string Temp;
	
	local string Results;

	Results = ConsoleCommand("XLIVE STAT_GAMER_LEADERBOARD_DETAILS \""$GamerTag$"\"");
	Log("Player Detail Results: "$Results,'Stats');

	moLabel(MyComponents[i]).SetText(ParseToken(Results));
	i++;
	Games = int(ParseToken(Results));
	Wins = int(ParseToken(Results));
	moLabel(MyComponents[i]).SetText(String(Games));
	i++;
	moLabel(MyComponents[i]).SetText(String(Wins));
	i++;
	moLabel(MyComponents[i]).SetText(String(Games-Wins));
	i++;

	if (Games == 0)
		Percent = "0.0";
	else
		Percent = string(100.0*Wins/Games);

	DotLoc = InStr(Percent,".");
	moLabel(MyComponents[i]).SetText( Left(Percent,DotLoc+2)$"%" );
	i++;

	ParseToken(Results); //elo rating
	moLabel(MyComponents[i]).SetText(ParseToken(Results));
	i++;
	Temp = ParseToken(Results);
	log("Just parsed sp completed, and got "$Temp@int(Temp)@(int(Temp)!=0));
	if( int(Temp) != 0 )
		moLabel(MyComponents[i]).SetText(class'gbx_ScreenABXY'.default.StringYes);
	else
		moLabel(MyComponents[i]).SetText(class'gbx_ScreenABXY'.default.StringNo);
	i++;
	moLabel(MyComponents[i]).SetText(ParseToken(Results));
	i++;

	MyComponents[6].Hide();
	DoComponentLayout();
}

function bool ScreenOnDrawPre(Canvas C)
{
	local int i;

	C.DrawColor = Controller.BackgroundBoxColor;

	for (i=0; i<MyComponents.Length; i++)
	{
		if (MyComponents[i].bVisible)
			MyComponents[i].DrawComponentBackground(C, 2.0, 2.0);
	}

	return Super.ScreenOnDrawPre(C);
}

defaultproperties
{
	ScreenTitle="Player Statistics"
	PagePlayerIndex=-2
	PlayerStatusDisplayStyle=CD_Signin
	bRequireLive=true

	LayoutSpacing=0.005
	LayoutPivotStyle=LA_Center

	Begin Object Class=moLabel Name=cLBPlayerInfo
		CompStyle="MenuOptionCaption"
		LabelStyle="MenuOptionLabel"
		CompTextAlign=TXTA_Left
		LabelJustification=TXTA_Right
		CaptionWidth=0.495
		ComponentWidth=0.5
		WinWidth=0.90
		WinHeight=0.052000
		WinLeft=0.050
		WinTop=0.28000
		bHeightFromComponent=false
		bNeverFocus=true
		bAcceptsInput=false
		bFocusOnWatch=false
	End Object

	MyComponents(0)=cLBPlayerInfo
	MyComponents(1)=cLBPlayerInfo
	MyComponents(2)=cLBPlayerInfo
	MyComponents(3)=cLBPlayerInfo
	MyComponents(4)=cLBPlayerInfo
	MyComponents(5)=cLBPlayerInfo
	MyComponents(6)=cLBPlayerInfo
	MyComponents(7)=cLBPlayerInfo

	MyCaptions(0)="Name: "
	MyCaptions(1)="Games: "
	MyCaptions(2)="Wins: "
	MyCaptions(3)="Losses: "
	MyCaptions(4)="Win Percentage: "
	MyCaptions(5)="Rating: "
	MyCaptions(6)="Singleplayer Completed: "
	MyCaptions(7)="Ranking: "
}

class gbx_LiveLeaderboardPlayerInner extends GUIPanel;
// CEK: moved to parent screen

class gbx_LiveLeaderboardProgress extends GUIPanel;

var Automated GUILabel				lblProgress;
var localized string				StringMessage;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	SetCaption(StringMessage);
}

function SetCaption(optional string S)
{
	lblProgress.SetCaption(S);
}

defaultproperties {
	StyleName="SquareBar"
	StringMessage="Loading Leaderboard Data..."

	// mission title
	Begin Object Class=GUILabel Name=clblMissionTitle
		StyleName="LargeButton"
		DrawMenuState=1
		TextAlign=TXTA_Center
		TextAlignV=TXTA_Center
		WinWidth=0.96
		WinHeight=0.96000
		WinLeft=0.02
		WinTop=0.02
		bNeverFocus=true
		bMultiLine=true
	End Object
	lblProgress=clblMissionTitle
}


class gbx_LiveOptiMatchRules extends gbx_MenuLayoutScreen;

var automated gbx_MissionDisplay	MissionDisplay;

var moSpinListControl			spnMissionSelect;
var moSpinListControl			spnPlayers;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);
	OnAButtonEvent = OnAccept;

	spnMissionSelect = moSpinListControl(MyComponents[0]);
	spnPlayers = moSpinListControl(MyComponents[1]);

	spnMissionSelect.OnChange = MissionChanged;
	spnMissionSelect.Add(StringAny,,StringAny);
	class'gbx_CreateMatchBase'.Static.FillMissionList(spnMissionSelect);

	spnPlayers.Add(StringAny);
	spnPlayers.AddFromList(class'gbx_CreateMatchBase'.Default.PlayersSelectList);
}

function int GetPlayersFilter()
{
	switch(spnPlayers.GetIndex())
	{
	case 0: return -1; break;
	case 1: return 2; break;
	case 2: return 4; break;
	}
}

function OnAccept()
{
	Controller.PlayClickSound(EClickSound.CS_Click);

	Controller.OpenMenu("GUI.gbx_LiveQueryOptiMatch", String(GetPlayersFilter()) @ String(spnMissionSelect.GetIndex() - 1) );
}

function MissionChanged(GUIComponent Sender)
{
	MissionDisplay.SetMission( spnMissionSelect.GetIndex() - 1 );
}

static function PreloadMenu(GUIController C)
{
	Super.PreloadMenu(C);

	C.PreloadMenu("GUI.gbx_LiveQueryOptiMatch");
}

defaultproperties
{
	ScreenTitle="OptiMatch"
	ACaption="Find Matches"

	LayoutPivotPoint=0.18
	LayoutSpacing=0.02
	LayoutPivotStyle=LA_Left_Top

	Begin Object Class=gbx_MissionDisplay Name=cMissionDisplay
		WinWidth=0.450
		WinHeight=0.580000
		WinLeft=0.500000
	End Object
	MissionDisplay=cMissionDisplay

	MyComponents(0)=cSpinMenuOptionV
	MyComponents(1)=cSpinMenuOptionV

	MyCaptions(0)="Mission"
	MyCaptions(1)="Players"

	bRequireLink=true
	bRequireLive=true
	bPortLockedOnly=true
}

class gbx_LivePlayerOptions extends gbx_LiveGamerOptions;


function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);
}

function InitCustomOptions()
{
	Super.InitCustomOptions();

    if( CurrentGamer.bIsMuted == 0 )
	{
		MyComponents[EOptionButton.OB_VOICE_MUTE].Show();
	}
	else
	{
		MyComponents[EOptionButton.OB_VOICE_UNMTE].Show();
	}

	MyComponents[EOptionButton.OB_SEND_FEEDBACK].Show();
}

defaultproperties
{
	ScreenTitle="Player Options"
}
class gbx_LivePlayersList extends gbx_LiveGamerList;

var() localized string			StringKickPlayer;
var() localized string			TextHintPlayerFriend;
var() localized string			TextHintPlayerNone;
var() localized string			TextHintPlayerInSession;

static function LaunchPlayersList(GUIController C, int inPlayerIndex, optional bool bNoSound)
{
	local int cIndex;
	
	if ((inPlayerIndex >= 0) && (inPlayerIndex <= 1))
	{
		cIndex = C.GetControllerIndexForPlayer(inPlayerIndex);
		if ((cIndex != -1) && C.LiveFunc.IsSignedIn(inPlayerIndex) && !C.LiveFunc.IsGuest(inPlayerIndex))
		{
			class'GUI.gbx_LivePlayersList'.default.PagePlayerIndex = inPlayerIndex;

			if (!bNoSound)
				C.PlayClickSound(EClickSound.CS_Click);
			C.OpenMenu("GUI.gbx_LivePlayersList");

			class'GUI.gbx_LivePlayersList'.default.PagePlayerIndex = -1;
		}
	}
}


function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);
/*
	if (!class'GUI.gbx_MenuDebug'.Default.bEnableDebug)
	{
		OnXButtonEvent = KickPlayer;
	}
*/
}

/*
function GamerSelected(int index)
{
	Super.GamerSelected(index);

	if (!class'GUI.gbx_MenuDebug'.Default.bEnableDebug)
	{
		if (PlayerOwner().Level.NetMode == NM_ListenServer)
		{
			GUILog("GamerSelected" @index);
			if ((index >= 0) && (index < Gamers.Length))
			{
				if (GamerInCurrentGame(Gamers[index]))
				{
					SetupXButton(StringKickPlayer);
					return;
				}
			}
		}

		SetupXButton();
	}
}
*/
function GetGamerList()
{
	Controller.GetGamers(Gamers, PagePlayerIndex, true);
}

function OnAccept()
{
	Super.OnAccept();
	Controller.OpenMenu("GUI.gbx_LivePlayerOptions");
}

function OnFriends()
{
	class'gbx_LiveFriendsList'.static.LaunchFriendsList(Controller, PagePlayerIndex);
}

/*
function KickPlayer()
{
	GUILog("KickPlayer" @Gamers[GamerList.List.Index].NickName);

	// TODO: display kick confirm dialog
	Controller.PlayClickSound(EClickSound.CS_Click);
	ConsoleCommand("Kick" @ Gamers[GamerList.List.Index].NickName);
}
*/

function InternalOnOpen()
{
	BeginUpdate();
}

function bool GamerInCurrentGame( Gamer G )
{
	return (G.bIsActivePlayer != 0);
}

function GetGamerSortKey( out Gamer G )
{
    local int rc;
    
    rc = 0;
    if (G.bIsActivePlayer != 0)
		rc = rc | 0x0010000;

	rc += G.iPlayerListIndex;

	G.iSortKey = rc;
}

function ELiveIcon GetPresenceIcon( out Gamer G )
{
    if( G.bReceivedRequest != 0 )
        return( LI_FRIEND_RECEIVED );
    else if( G.bSentRequest != 0 )
        return( LI_FRIEND_SENT );
    else if((G.bIsFriend != 0) && (G.bOnline != 0))
        return( LI_FRIEND );
    else
        return( LI_OFFLINE );
//    else if( G.bOnline != 0 )
//        return( LI_ONLINE );
}

function Color GetIconColor( Gamer G )
{
	if (GamerInCurrentGame(G))
		return LiveIconColors[ELiveIconColor.LIC_PLAYING];
	else if (G.bOnline != 0)
		return LiveIconColors[ELiveIconColor.LIC_ONLINE];
	else if ((G.bIsFriend != 0) || (G.bReceivedRequest != 0) || (G.bSentRequest != 0) )
		return LiveIconColors[ELiveIconColor.LIC_OFFLINE];

	return LiveIconColors[ELiveIconColor.LIC_UNKNOWN];
}

function string GetOnlineLabel( Gamer G )
{
	if (GamerInCurrentGame(G))
		return TextPlaying;
	else if (G.bOnline != 0)
		return TextOnline;

	return TextOffline;
}

function GetOnlineIcon( Gamer G, out Canvas.CanvasIcon result)
{
	local ELiveIcon pIcon;

	if (((G.bIsFriend != 0) && (G.bOnline != 0)) || (G.bReceivedRequest != 0) || (G.bSentRequest != 0) )
		pIcon = LI_FRIEND;
	else
		pIcon = LI_OFFLINE;

	CopyCanvasIcon(pIcon, result);
	result.DrawColor = GetIconColor(G);
}

function GetInfoText( out Gamer G, out String S )
{
	if (GamerInCurrentGame(G))
	{
        S = TextHintPlayerInSession;
	}
	else
	{
		if( G.bOnline == 0 )
		{
			S = TextHintOffline;
		}
		else if( G.bIsFriend != 0 )
		{
			if (G.bPlaying != 0)
				S = TextHintPlaying;
			else
				S = TextHintOnline;
		}
		else
		{
			S = TextHintOnline;
		}
	}

    if( G.bIsFriend == 0 )
    {
        if( G.bSentRequest != 0 )
            S = S @ TextHintSentFriend @ TextHintCancel;
        else if( G.bReceivedRequest != 0 )
            S = S @ TextHintReceivedFriend @ TextHintAccept;

		ReplaceText(S, "<P_OR_F>", StrTextHintPlayer);
    }
	else
	{
		ReplaceText(S, "<P_OR_F>", StrTextHintFriend);
	}

	if( (G.bReceivedRequest != 0) || (G.bSentRequest != 0) || (G.bIsFriend != 0))
		S = S @ TextHintPlayerFriend;
    else
		S = S @ TextHintPlayerNone;

	S = CapsL(S);
	ReplaceText( S, "<GAME>", "\"" $G.GameTitle $"\"");
}

static function PreloadMenu(GUIController C)
{
	Super.PreloadMenu(C);

	C.PreloadMenu("GUI.gbx_LivePlayerOptions");
}

defaultproperties
{
	strDirtyCommand="PLAYERSISDIRTY"
	strUpdateCommand="GETPLAYERS"

	StringKickPlayer="Kick Player"
	TextHintPlayerFriend="You may send feedback or mute them."
	TextHintPlayerNone="You may ask them to be your friend, send feedback or mute them."
	TextHintPlayerInSession="<P_OR_F> is in your session."

	ScreenTitle="Players List"
	TextEmptyList="Your Players List is currently empty.|You have not played with any other players yet."
}

class gbx_LiveQueryBase extends gbx_ScreenABXY
	Abstract;

// param1 = query arg list


var() Automated GUILabel			lblTextPrompt;

var array<ServerInfo>				ServerList;

var bool							bFakeServerList;
var bool							bGenFakeServers;

var() int							PingWarningThreshold; // warn about bad network if server ping >=
var() localized String				PingLabels[5];
var localized string				StringGettingList;
var string							StringQueryCommand;

var ServerInfo						ConnectServer;
// =======================================================================================================================================================
// Initialization
// =======================================================================================================================================================
function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);
	InitExecution();

	lblTextPrompt.Caption = StringGettingList;
	lblTextPrompt.Hide();

	OnAButtonEvent = OnAButton;
	OnBButtonEvent = OnBButton;
	OnXButtonEvent = OnXButton;
	OnClose = InternalOnClose;
}

event HandleParameters(string Param1, string Param2)
{
	Super.HandleParameters(Param1, Param2);
    GotoState('WaitingToStartQuery');
}

function OnAButton();
function OnXButton();
function OnBButton()
{
	KillTimer();
	BaseOnBButton();
}

function InternalOnClose(optional Bool bCancelled);

// =======================================================================================================================================================
// Futility functions
// =======================================================================================================================================================
// override!
function ServerList_AddItem(out ServerInfo server)
{
	local int i;

	i = ServerList.Length;
	ServerList.Length = i+1;
	ServerList[i] = server;
}

function ServerList_Clear()
{
	ServerList.Length = 0;
}
function ServerList_Updated();							// called after the server list has been parsed

// retrieves the list of servers from the XLIVE query manager
// uses AddItem, Clear and Sort functions above
final function ParseServerList()
{
    local int Count;
    local int i;
    local String ServerLine, S;
	local ServerInfo server;

	if (bFakeServerList) return;

    Count = int( ConsoleCommand("XLIVE GETQUERYCOUNT") );

	ServerList_Clear();
    for( i = 0; i < Count; i++ )
    {
        ServerLine = ConsoleCommand("XLIVE GETQUERYRESULTS" @ i );

		server.ContextID = i;
        server.HostName = ParseToken(ServerLine);
        server.MapFilename = ParseToken(ServerLine);
        server.NumPlayers = int(ParseToken(ServerLine));
        server.MaxPlayers = int(ParseToken(ServerLine));
        server.URLAppend = ParseToken(ServerLine);
        
//        assert( server.URLAppend != "###" );
        
        S = ParseToken(ServerLine);
        if( S != "###" )
        {
            log("Expected ### got:"@ S, 'Error' );
            break;
        }
        
        server.MapName = class'Gameplay.gbxMPMissionList'.Static.FindMissionName(server.MapFilename);
        server.GameName = server.GameType;
        server.GameAcronym = "???";


        server.Ping = -1; // unknown

		ServerList_AddItem(server);
    }

	ServerList_Updated();
}

// QOS Update funcs
function BeginServerProbes()
{
    local string ProbeString;
    local int i;

	if (bFakeServerList) return;

	for( i=0; i<ServerList.Length; i++ )
    {
        if( ServerList[i].URLAppend != "" )
            ProbeString = ProbeString @ "0.0.0.1" $ ServerList[i].URLAppend;
    }

    ConsoleCommand("XLIVE QOS_LOOKUP"@ProbeString);
}

function bool RefreshServerProbes()
{
    local string ProbeResponse;
    local int i, p;
    local bool Dirty;

	if (bFakeServerList) return false;

    ProbeResponse = ConsoleCommand("XLIVE QOS_REFRESH_RESULTS");

    for( i=0; i<ServerList.Length; i++ )
    {
        p = int(ParseToken(ProbeResponse));
/*
        if( default.FakePings )
        {
            if( ServerList[i].Ping < 0 )
                p = Clamp(Rand(100) - 90, -1, 100);
            else
                p = ServerList[i].Ping;
        }
*/        
        if( ServerList[i].Ping != p )
        {
            ServerList[i].Ping = p;
            Dirty = true;
        }
    }   

	if (Dirty)
		ServerList_Updated();

    return Dirty;
}

function EndServerProbes()
{
	if (bFakeServerList) return;

	ConsoleCommand("XLIVE QOS_RELEASE");
}

static function string GetPingString(int ping)
{
    if( Ping == -1 )
        return Default.PingLabels[0]; // no ping reply
    else if( Ping < 50 )
        return Default.PingLabels[1];
    else if( Ping < 100 )
        return Default.PingLabels[2];
    else if( Ping < 200 )
        return Default.PingLabels[3];

    return Default.PingLabels[4];
}

function bool VerifyJoinGame()
{
	local int needPlayers;

	if (class'gbx_DlgMissingMap'.Static.PromptNeedMap(self, ConnectServer.MapFilename))
		return false;

	if (class'gbx_ProfileManager'.Static.ControllerProfileExists(self, 1) && Controller.LiveFunc.IsSignedIn(1))
		needPlayers = 2;
	else
		needPlayers = 1;

	if (ConnectServer.MaxPlayers - ConnectServer.NumPlayers < needPlayers)
	{
		PromptServerJoin(class'gbx_BrowseMatchBase'.default.StringServerFull, "OK NONE", true);
		return false;
	}

    if( ConnectServer.Ping >= PingWarningThreshold || ConnectServer.Ping==-1 )
	{
		PromptServerJoin(Controller.LiveFunc.LocalizedError("WARNING_BAD_NETWORK"), "OKBACK NONE");
		return false;
	}

	return true;
}

function OnJoinGame()
{
	local string URL;
	local string hostName;

	// add the split if controller 2 is signed in
	if (class'gbx_ProfileManager'.Static.ControllerProfileExists(self, 1) && Controller.LiveFunc.IsSignedIn(1))
	{
		class'gbx_ProfileManager'.Static.SetupProfiles(self);
	}

	// wire up the controllers
	Controller.ApplyControllersToViewports();

	hostName = ConnectServer.HostName;
	ReplaceText(hostName, " ", "_");

	URL = "0.0.0.1" $ ConnectServer.URLAppend;
    URL = URL $ "?HostName=" $ hostName $ "?Game=" $ ConnectServer.GameType $"?Live";
	GUILog("gbx_LiveQueryBase::OnJoinGame: URL="$URL);

	// launch!
	PlayerOwner().ClientTravel( URL, TRAVEL_Absolute, false );
	Controller.CloseAll(false);
}

function ConnectToServer(out ServerInfo server)
{
	if (bFakeServerList) return;

	Controller.PlayClickSound(EClickSound.CS_Click);

	ConnectServer = server;
	if (VerifyJoinGame())
		OnJoinGame();
}

function bool ServerJoinPromptAnswer(string answer)
{
	if ((answer ~= "YES") || (answer ~= "OK"))
	{
		OnJoinGame();
		return false;
	}

	return true;
}

function PromptServerJoin(string promptString, optional string buttons, optional bool bCantJoin)
{
	local gbx_ScreenQuestion dlg;

	if (buttons == "")
		buttons = "YESNO AREYOUSURE";

	dlg = LaunchQuestionDialog(Controller, promptString, buttons);

	if (!bCantJoin)
		dlg.OnAnswer = ServerJoinPromptAnswer;
}


// =======================================================================================================================================================
// debug stuff
// =======================================================================================================================================================
function RandomizeServer( out ServerInfo S )
{
	local int mapindex;

    S.HostName = "TESTING-" $ String( Rand(1000) );

	mapindex = Rand( class'Gameplay.gbxMPMissionList'.Static.GetMissionCount() );
    S.MapFilename = class'Gameplay.gbxMPMissionList'.Static.GetMap(mapindex);
    S.MapName = class'Gameplay.gbxMPMissionList'.Static.GetMissionName(mapindex);

	if (Rand(2) == 1)
		S.IsDedicatedServer = true;
	else
		S.IsDedicatedServer = false;

    S.MaxPlayers = Rand( 3 ) + 2;
    S.NumPlayers = Rand( S.MaxPlayers + 1 );

    S.Ping = Rand(200) + 20;
}

function GenerateRandomServers()
{
	local int i, count;
	local ServerInfo server;

	ServerList_Clear();

	count = Rand(25) + 5;
	for (i=0; i<count; i++)
	{
		RandomizeServer(server);
		ServerList_AddItem(server);
	}

	ServerList_Updated();
}

// =======================================================================================================================================================
// =======================================================================================================================================================
// state logic
// =======================================================================================================================================================
// =======================================================================================================================================================

// =======================================================================================================================================================
// state WaitingToStartQuery
// =======================================================================================================================================================
state WaitingToStartQuery
{
    function BeginState()
    {
//        Timer();
        SetTimer( 1.0, true );

		SetupAButton();
		SetupBButton(StringBack);
		SetupXButton();
		lblTextPrompt.Show();
	}
    
    function Timer()
    {
// GUITODO:        if( Level.TimeSeconds > PlayerController(Owner).NextMatchmakingQueryTime )
            GotoState('WaitingForResults');
    }

    function EndState()
    {
        SetTimer( 0, false );
    }
}

// =======================================================================================================================================================
// state WaitingForResults
// =======================================================================================================================================================
state WaitingForResults
{
    function BeginState()
    {
// GUITODO        PlayerController(Owner).NextMatchmakingQueryTime = Level.TimeSeconds + class'PlayerController'.default.TimeBetweenMatchmakingQueries;    
		SetupAButton();
		SetupBButton(StringBack);
		SetupXButton();
		lblTextPrompt.Show();

		bFakeServerList = false;
        ConsoleCommand("XLIVE" @StringQueryCommand @LParam1);
        SetTimer( 0.1, true );
    }

    function EndState()
    {
        SetTimer( 0, false );
    }

    function Timer()
    {
        local String QueryState;
        local int ResultCount;
        
        QueryState = ConsoleCommand("XLIVE GETMATCHSTATE");
        
        if( QueryState == "QUERY" ) // Still waiting.
            return;

        SetTimer( 0, false );

        if( QueryState != "QUERYRESULTS" )
        {
			Controller.LiveFunc.LiveErrorMessage("MATCHMAKING_QUERY_FAILED", true);
            return;
        }
        
        ResultCount = int( ConsoleCommand("XLIVE GETQUERYCOUNT") );

		GUILog("XLIVE Matchmaking query success.  Results=" $ResultCount);
        if( ResultCount == 0 )
		{
			if (bGenFakeServers)
			{
				GUILog("############## Generating fake server list #####################");
				GenerateRandomServers();
				bFakeServerList=true;
				GotoState('GotResults');
			}	
			else
			{
				Controller.ReplaceMenu("GUI.gbx_LiveQueryNoResults","GUI.gbx_LiveCreateMatch");
			}
		}
        else
		{
			GotoState('GotResults');
		}
    }

	function OnBButton()
	{
        ConsoleCommand("XLIVE CANCEL_QUERY" );
		global.OnBButton();
	}
}

state GotResults
{
}

static function PreloadMenu(GUIController C)
{
	Super.PreloadMenu(C);

	C.PreloadMenu("GUI.gbx_LiveQueryNoResults");
	C.PreloadMenu("GUI.gbx_LiveCreateMatch");
}

defaultproperties
{
	Begin Object Class=GUILabel Name=cTextPrompt
		StyleName="MenuOptionCaption"
		DrawMenuState=2
		TextAlign=TXTA_Center
		bAcceptsInput=false
		bTabStop=false
		bDrawToFit=true
		WinWidth=0.900000
		WinHeight=0.050000
		WinLeft=0.050000
		WinTop=0.7200000
	End Object
	lblTextPrompt=cTextPrompt

    PingLabels(0)="?"
    PingLabels(1)="****"
    PingLabels(2)="***"
    PingLabels(3)="**"
    PingLabels(4)="*"
	PingWarningThreshold=200

	bGenFakeServers=false
	bFakeServerList=false

	StringGettingList="Getting list of matches.  Please stand by..."
	StringQueryCommand=""

	bRequireLink=true
	bRequireLive=true
	bPortLockedOnly=true
}
class gbx_LiveQueryNoResults extends gbx_ScreenQuestion;

// Param2: <eScreenQuestionType> <eScreenPromptType>
// Param1: On-Yes screen to launch

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	OnAnswer = QueryNoResultsAnswer;
}

event HandleParameters(string Param1, string Param2)
{
    Super.HandleParameters( Param1, Param2 );

	bRequireLive = LParam1 ~= "GUI.gbx_LiveCreateMatch";
	bRequireLink = !bRequireLive;

	GUILog("gbx_LiveQueryNoResults: LParam1=" $LParam1 $" bRequireLive=" $bRequireLive $" bRequireLink=" $bRequireLink);
}

function bool QueryNoResultsAnswer(string answer)
{
	if (answer == "YES")
	{
		Controller.PlayClickSound(EClickSound.CS_Click);

		Controller.ReplaceMenu(LParam1);
		return false;
	}

	return true;
}

defaultproperties
{
	ScreenTitle="No Matches Found"
	StringAutoTextPrompt="Would you like to create a new match?"
	QuestionType=SQT_YESNO
	PromptType=SPT_None

	bRequireLink=false
	bRequireLive=false
	bPortLockedOnly=true
}

class gbx_LiveQueryOptiMatch extends gbx_LiveQueryBase;

// param1 = query arg list

var Automated GUIMultiColumnListBox	Browser;
var gbx_BrowserMultiColumnList		BrowserList;

var float							PingTimeOut;

// =======================================================================================================================================================
// Initialization
// =======================================================================================================================================================
function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	OnYButtonEvent = OnYButton;
	BrowserList = gbx_BrowserMultiColumnList(Browser.List);

	SetupAButton();
	SetupXButton();
	SetupYButton();
}

function OnYButton()
{
	Controller.PlayClickSound(EClickSound.CS_Click);

	Controller.ReplaceMenu("GUI.gbx_LiveCreateMatch");
}

// =======================================================================================================================================================
// Futility functions
// =======================================================================================================================================================
function ServerList_Clear()
{
	Super.ServerList_Clear();
	BrowserList.Clear();
}

function ServerList_Updated()
{
	local int i;
	BrowserList.Clear();

	for (i=0; i<ServerList.Length; i++)
	{
		if (bFakeServerList || (ServerList[i].Ping != -1))
			BrowserList.AddServer( ServerList[i] );
	}
}

function SetupAButton(optional string newCap, optional string newHint)
{ 
	if (BrowserList.ServerList.Length == 0)
		Super.SetupAButton();
	else
		Super.SetupAButton(newCap, newHint);
}

// =======================================================================================================================================================
// =======================================================================================================================================================
// state logic
// =======================================================================================================================================================
// =======================================================================================================================================================
state WaitingToStartQuery
{
    function BeginState()
    {
		Super.BeginState();
		SetupAButton();
		SetupXButton();
		SetupYButton();
	}
}

state WaitingForResults
{
    function BeginState()
    {
		Super.BeginState();
		SetupAButton();
		SetupXButton();
		SetupYButton(StringCreateMatch);
	}
}

state GotResults
{
    function BeginState()
    {
		GUILog("gbx_LiveQueryOptiMatch:GotResults::BeginState");
		Super.BeginState();

		lblTextPrompt.Hide();
		SetupAButton();
		SetupBButton(StringBack);
		SetupXButton(StringRefresh);
		SetupYButton(StringCreateMatch);

		// parse the server list
		ParseServerList();

		// begin the QOS update
		PingTimeOut = PlayerOwner().Level.UniversalTimeSeconds + class'gbx_BrowseMatchBase'.default.DefaultPingTimeout;
		BeginServerProbes();
		SetTimer(0.5, true);
	}
	function EndState()
	{
		PingTimeOut = 0;
		Super.EndState();
	}

	function InternalOnClose(optional Bool bCancelled)
	{
		SetTimer(0, false);
		EndServerProbes();
	}

	function Timer()
	{
		RefreshServerProbes();

		if (BrowserList.ServerList.Length != 0)
			SetupAButton(stringJoin);

		if (!bFakeServerList && (BrowserList.ServerList.Length == 0) && (PlayerOwner().Level.UniversalTimeSeconds > PingTimeOut))
		{
			Controller.ReplaceMenu("GUI.gbx_LiveQueryNoResults","GUI.gbx_LiveCreateMatch");
		}
	}

	function OnXButton()
	{
        ConsoleCommand("XLIVE CANCEL_QUERY" );
        GotoState('WaitingForResults');
	}
	function OnYButton()
	{
        ConsoleCommand("XLIVE CANCEL_QUERY" );
		global.OnYButton();
	}

	function OnAButton()
	{
		if (BrowserList.Index != -1)
			ConnectToServer(BrowserList.ServerList[BrowserList.Index]);
	}

}

static function PreloadMenu(GUIController C)
{
	Super.PreloadMenu(C);

	C.PreloadMenu("GUI.gbx_LiveQueryNoResults");
	C.PreloadMenu("GUI.gbx_LiveCreateMatch");
}

defaultproperties
{
	Begin Object class=GUIMultiColumnListBox Name=cBrowser
		WinWidth=0.9
		WinHeight=0.54
		WinLeft=0.05
		WinTop=0.17
        bVisibleWhenEmpty=true
        DefaultListClass="GUI.gbx_BrowserMultiColumnList"
	End Object
    Browser=cBrowser

	ScreenTitle="OptiMatch"
	StringQueryCommand="RUN_QUERY_OPTI_MATCH"
}

class gbx_LiveQueryQuickMatch extends gbx_LiveQueryBase;

// param1 = query arg list

var automated gbx_MissionDisplay	MissionDisplay;
var automated array<moLabel>		MissionInfo;
var localized array<string>			MissionInfoCaptions;

var localized string				StringNextMatch;
var int								nCurrentServer;

// =======================================================================================================================================================
// Initialization
// =======================================================================================================================================================
function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
//	local float wTop;
	local int i;

	Super.InitComponent(MyController, MyOwner);

	for (i=0; i<MissionInfo.Length; i++)
	{
		MissionInfo[i].SetCaption(MissionInfoCaptions[i]);
	}

	LayoutControlArray(MissionInfo, 0.18, 0.02, LA_Left_Top);
	MapControls();
	FocusFirst(none);
}

// =======================================================================================================================================================
// Futility functions
// =======================================================================================================================================================
/*
// GBX:CEK: 4/24/2004 - yuck, need something way better than this...
function bool InOrder( out ServerInfo A, out ServerInfo B )
{
    if( A.IsDedicatedServer && !B.IsDedicatedServer )  // a > b
        return true;

    if( !A.IsDedicatedServer && B.IsDedicatedServer )  // a < b
        return false;

    if( (A.NumPlayers != 0) && (B.NumPlayers == 0) )
        return true;

    if( (A.NumPlayers == 0) && (B.NumPlayers != 0) )
        return false;

    if( (A.NumPlayers == 0) && (B.NumPlayers == 0) )
        return true;

	return true;
}
function ServerList_Updated()
{
    local int i, j;
    local ServerInfo tmp;

    for (i=0; i<ServerList.Length-1; i++)
    {
        for (j=i+1; j<ServerList.Length; j++)
        {
           if( !InOrder( ServerList[i], ServerList[j] ) )
            {
                tmp = ServerList[i];
                ServerList[i] = ServerList[j];
                ServerList[j] = tmp;
            }
        }
    }
}
*/

function ShowServer(out ServerInfo server)
{
	MissionDisplay.SetMissionFromMissionName(Server.MapFilename);
	MissionInfo[0].SetText(Server.HostName);
	MissionInfo[1].SetText(class'Gameplay.gbxMPMissionList'.Static.FindMissionName(Server.MapFilename, true));
	MissionInfo[2].SetText("" $ server.NumPlayers $ " / " $ server.MaxPlayers);
	MissionInfo[3].SetText(GetPingString(server.Ping));
}

function ShowNextServer()
{
    if( ServerList.Length == 0 )
        return;
    
    nCurrentServer = (nCurrentServer + 1) % ServerList.Length;
    ShowServer( ServerList[nCurrentServer] );
}

function DimServerResults(bool bDim)
{
	local int i;

	for (i=0; i<MissionInfo.Length; i++)
	{
		MissionInfo[i].EnableControl(!bDim);
	}

	if (bDim)
	{
		MissionDisplay.Hide();
	}
	else
	{
		MissionDisplay.Show();
	}
}

function bool ScreenOnDrawPre(Canvas C)
{
    local int i;

	C.DrawColor = Controller.BackgroundBoxColor;

	for (i=0; i<MissionInfo.Length; i++)
	{
		MissionInfo[i].MyComponent.DrawComponentBackground(C, 2.0, 2.0);
	}

	return Super.ScreenOnDrawPre(C);
}

// =======================================================================================================================================================
// =======================================================================================================================================================
// state logic
// =======================================================================================================================================================
// =======================================================================================================================================================

state WaitingToStartQuery
{
    function BeginState()
    {
		Super.BeginState();
		DimServerResults(true);
	}
}

state GotResults
{
    function BeginState()
    {
		GUILog("gbx_LiveQueryQuickMatch:GotResults::BeginState");
		Super.BeginState();
		lblTextPrompt.Hide();
		SetupAButton(stringJoin);
		SetupBButton(StringBack);

		// parse the server list
		ParseServerList();

		// begin the QOS update
		BeginServerProbes();
		SetTimer(1.0, true);

		// show the first server
		DimServerResults(false);
		ShowNextServer();

		// enable the X button if there is more than one server to cycle though
		if (ServerList.Length > 1)
			SetupXButton(StringNextMatch);
	}

	function InternalOnClose(optional Bool bCancelled)
	{
		SetTimer(0, false);
		EndServerProbes();
	}

	simulated function Timer()
	{
		RefreshServerProbes();
		if( ServerList.Length == 0 )
			return;

		ShowServer( ServerList[nCurrentServer] );
	}

	function OnXButton()
	{
		ShowNextServer();
	}

	function OnAButton()
	{
		ConnectToServer(ServerList[nCurrentServer]);
	}
}

defaultproperties
{
	ScreenTitle="Quick Match"
	StringQueryCommand="RUN_QUERY_QUICK_MATCH"
	StringNextMatch="Next Match"
	nCurrentServer=-1

	Begin Object Class=gbx_MissionDisplay Name=cMissionDisplay
		WinWidth=0.450
		WinHeight=0.580000
		WinLeft=0.500000
	End Object
	MissionDisplay=cMissionDisplay

	Begin Object Class=moLabel Name=cMissionInfo
		CompStyle="MenuOptionLabel"
		LabelJustification=TXTA_Center
		CaptionWidth=0.50
		ComponentWidth=0.40
		WinWidth=0.42000000
		WinHeight=0.1000
		WinLeft=0.0500000
		WinTop=0.28000
		bHeightFromComponent=false
		bVerticalLayout=true
		bNeverFocus=true
		bTabStop=false
	End Object

	MissionInfo(0)=cMissionInfo
	MissionInfo(1)=cMissionInfo
	MissionInfo(2)=cMissionInfo
	MissionInfo(3)=cMissionInfo

	MissionInfoCaptions(0)="Host Name"
	MissionInfoCaptions(1)="Mission"
	MissionInfoCaptions(2)="Players"
	MissionInfoCaptions(3)="Quality"
}
class gbx_LiveVoiceFeedback extends gbx_LiveFeedbackScreen;

function bool OnComponentActivate(int button, GUIComponent Sender)
{
	switch (button)
	{
	// Offensive Message
	case 1:
		HandleFeedback("XONLINE_FEEDBACK_NEG_MESSAGE_INAPPROPRIATE", MyCaptions[button]);
		return true;

	// Spam Message
	case 2:
		HandleFeedback("XONLINE_FEEDBACK_NEG_MESSAGE_SPAM", MyCaptions[button]);
		return true;
	}

	return false;
}

defaultproperties
{
	MyComponents(0)=cFeedbackHeader
	MyComponents(1)=cBtnOption
//	MyComponents(2)=cBtnOption

	MyCaptions(0)="Complaints"
	MyCaptions(1)="Offensive Message"
//	MyCaptions(2)="Spam Message"
}

class gbx_LiveVoicePlaybackOptions extends gbx_LiveGamerScreen;


var() localized String 			StringDeleteMessageInvite;
var() localized String 			StringBlockMessageInvite;

var() localized String 			StringDeleteMessageRequest;
var() localized String 			StringBlockMessageRequest;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);
	SetupAButton(StringSelect);
}

function SetUp(out Gamer G)
{
	Super.SetUp(G);

	InitOptions();
	DoComponentLayout();
}

// =======================================================================================================================================================
// input handler
// =======================================================================================================================================================
function bool OnComponentActivate(int button, GUIComponent Sender)
{
	switch (button)
	{
	case 0:
		if( CurrentGamer.bIsFriend == 0 )
		{
			OpenConfirmDialog(StringDeleteMessageRequest, "XLIVE FRIENDS USER=" $ PagePlayerIndex @ "REQUEST DECLINE GAMERTAG=" $ MakeQuotedString(CurrentGamer.Gamertag), "FRIEND_DECLINE_FAILED", true, "XONLINE_E_FRIENDS_LIST_ERROR");
		}
		else
		{
			OpenConfirmDialog(StringDeleteMessageInvite, "XLIVE FRIENDS USER=" $ PagePlayerIndex @ "INVITE DECLINE GAMERTAG=" $ MakeQuotedString(CurrentGamer.Gamertag), "FRIEND_INVITE_DECLINE_FAILED", true, "XONLINE_E_FRIENDS_LIST_ERROR");
		}
		return true;

	case 1:
		if( CurrentGamer.bIsFriend == 0 )
		{
			OpenConfirmDialog(StringBlockMessageRequest, "XLIVE FRIENDS USER=" $ PagePlayerIndex @ "REQUEST BLOCK GAMERTAG=" $ MakeQuotedString(CurrentGamer.Gamertag), "FRIEND_BLOCK_FAILED", true, "XONLINE_E_FRIENDS_LIST_ERROR");
		}
		else
		{
			OpenConfirmDialog(StringBlockMessageInvite, "XLIVE FRIENDS USER=" $ PagePlayerIndex @ "FRIEND REMOVE GAMERTAG=" $ MakeQuotedString(CurrentGamer.Gamertag), "FRIEND_REMOVE_FAILED", true, "XONLINE_E_FRIENDS_LIST_ERROR");
		}
		return true;

	case 2:
		OpenFeedbackDialog("GUI.gbx_LiveVoiceFeedback");
		return true;
	}

	return false;
}

function InitOptions()
{
}

static function PreloadMenu(GUIController C)
{
	Super.PreloadMenu(C);

	C.PreloadMenu("GUI.gbx_LiveVoiceFeedback");
}

defaultproperties
{
	ScreenTitle="Message Options"
	PagePlayerIndex=-3
	LayoutPivotPoint=0.55
	LayoutSpacing=0.005
	LayoutPivotStyle=LA_Center

	MyComponents(0)=cBtnOption
	MyComponents(1)=cBtnOption
	MyComponents(2)=cBtnOption

	MyCaptions(0)="Delete Message"
	MyCaptions(1)="Block Message"
	MyCaptions(2)="Send Feedback"

	StringInfoHeader="Message From :"
	StringDeleteMessageInvite="Deleting this message will also decline the game invitation from <GAMER>.  Really delete this message?"
	StringBlockMessageInvite="Blocking this message will remove <GAMER> from your friends list.  Really block this message?"

	StringDeleteMessageRequest="Deleting this message will also decline the friend request from <GAMER>.  Really delete this message?"
	StringBlockMessageRequest="Blocking this message will block all future friend requests from <GAMER>.  Really block this message?"
}


class gbx_MenuCheats extends gbx_MenuLayoutScreen
	config(User);

/*
CheatCommand:
"CON:<cmd>" simply executes a console command.
"INT:<key>" executes an internal action by keyname.
"VAR:<object> <variable> <value>" uses set/get to edit a value.
*/
struct CheatInfo_s
{
	var int									UnlockExtra;	// extra that unlocks this item (0-based index into extras.ini array) -1 is a secret cmd
	var string								CheatCommand;
};

var Automated GUILabel						lblNoCheats;
var array<CheatInfo_s>						CheatCommands;
var int										NumCheatsUnlocked;

var array<eXControllerCodes>				InputMatch;
var array<eXControllerCodes>				Input;
var config bool								bAltLayout;

var localized string						StringNoCheats;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	local int i;
	local GameProfile gProfile;

	Super.InitComponent(MyController, MyOwner);

	gProfile = class'GameProfile'.Static.LoadCurrentGameProfile( PlayerOwner().Level );
	GUILog("gbx_MenuCheats::InitComponent gProfile = " $gProfile $" name=" $gProfile.GetGameName());

	// seed the captions for the buttons
	NumCheatsUnlocked = 0;
	for (i=0; i<MyComponents.Length; i++)
	{
		MyComponents[i].Hide();
	}

	for (i=0; i<CheatCommands.Length; i++)
	{
		NumCheatsUnlocked += AddCheat(gProfile, i);
	}

	DoComponentLayout();

	class'GameProfile'.Static.UnloadProfile( PlayerOwner().Level, gProfile );

	if (NumCheatsUnlocked == 0)
	{
		lblNoCheats.SetCaption(StringNoCheats);
	}
}

function int AddCheat(GameProfile gProfile, int CheatIndex)
{
	local int chapter, medal, result;

	result = 0;
	if (CheatIndex >= MyComponents.Length)
		return result;

	GUILog("gbx_MenuCheats: Cheat=" $CheatCommands[CheatIndex].CheatCommand);
	if (CheatCommands[CheatIndex].CheatCommand == "")
		return result;

	if (CheatCommands[CheatIndex].UnlockExtra == -1)
	{
		if (bAltLayout)
		{
			result = 1;
		}
		else if( gProfile.GameName == "DuvalMagic" && CheatCommands[CheatIndex].CheatCommand == "CON:refreshhealth" )
		{
			result = 1;
		}
	}
	else if (CheatCommands[CheatIndex].UnlockExtra < 80)
	{
		chapter = CheatCommands[CheatIndex].UnlockExtra / 4;
		medal = CheatCommands[CheatIndex].UnlockExtra % 4;

		if (gProfile.CompletedMissionDifficulty(chapter, EDifficulty(medal)))
			result = 1;
	}

	if (result != 0)
		MyComponents[CheatIndex].Show();

	return result;
}

function bool OnComponentActivate(int button, GUIComponent Sender)
{
	local string cmd, s;

	if (NumCheatsUnlocked != 0)
	{
	cmd = CheatCommands[button].CheatCommand;
	if (ParseCommand(cmd,"CON:"))
	{
		ConsoleCommand(cmd);
	}
	else if (ParseCommand(cmd,"VARBOOL:"))
	{
		// TODO: gah, doesn't quite work; "get" doesn't return its value properly :/
		s = ConsoleCommand("GET" @cmd);
		GUILog("GET" @cmd @" = " $s);

		if (int(s) == 1)
			ConsoleCommand("SET" @cmd @"0");
		else
			ConsoleCommand("SET" @cmd @"1");
	}
	else if (ParseCommand(cmd,"INT:"))
	{
		if (cmd ~= "Slomo")
		{
			if (PlayerOwner().Level.Game.GameSpeed != 0.2)
				ConsoleCommand("Slomo 0.2");
			else
				ConsoleCommand("Slomo 1.0");
		}
		else if (cmd ~= "Fast")
		{
			if (PlayerOwner().Level.Game.GameSpeed != 4.0)
				ConsoleCommand("Slomo 4.0");
			else
				ConsoleCommand("Slomo 1.0");
		}
		else if (cmd ~= "FPS")
		{
			if (Controller.GetEngine().bShowFramerate == 0)
				Controller.GetEngine().bShowFramerate = 1;
			else
				Controller.GetEngine().bShowFramerate = 0;
		}
	}
	}

	return true;
}

function HandleInput(eXControllerCodes iCode)
{
	local int i;

	if (bAltLayout)
		return;

	i = Input.Length;
	if (i >= InputMatch.Length)
	{
		Input.Remove(0,1);
	}
	else
	{
		Input.Length = i + 1;
	}

	Input[i] = iCode;

	if (Input.Length == InputMatch.Length)
	{
		for (i=0; i<InputMatch.Length; i++)
		{
			if (InputMatch[i] != Input[i])
				return;
		}

		GUILog("HandleInput: Unlocked!");
		bAltLayout = true;
		SaveConfig();
		ConsoleCommand("LOADSAVE PROFILE UPDATENAMED NAME=" $MakeQuotedString(class'gbx_ProfileManager'.Static.GetProfileForController(self, 0)));
	}
}

function bool SAB_OnXControllerEvent(byte Id, eXControllerCodes iCode)
{
/*
	if (!bAltLayout)
	{
		switch(iCode)
		{
		case XC_PadUp: 
		case XC_PadDown:
		case XC_PadLeft:
		case XC_PadRight:
			HandleInput(iCode);
		}
	}
*/
	return Super.SAB_OnXControllerEvent(Id, iCode);
}

defaultproperties
{
	ScreenTitle="Cheats Menu"
	LayoutSpacing=0.00
	bAltLayout=false

	MyComponents(0)=cBtnOption
	MyComponents(1)=cBtnOption
	MyComponents(2)=cBtnOption
	MyComponents(3)=cBtnOption
	MyComponents(4)=cBtnOption
	MyComponents(5)=cBtnOption
	MyComponents(6)=cBtnOption
	MyComponents(7)=cBtnOption
	MyComponents(8)=cBtnOption
	MyComponents(9)=cBtnOption
	MyComponents(10)=cBtnOption

	MyCaptions(0)="Old Movie"
	MyCaptions(1)="Infinite Ammunition"
	MyCaptions(2)="Super Squad"
	MyCaptions(3)="Refresh Health"

	CheatCommands(0)=(UnlockExtra=64,CheatCommand="CON:oldmovie")
	CheatCommands(1)=(UnlockExtra=65,CheatCommand="CON:unloaded")
	CheatCommands(2)=(UnlockExtra=67,CheatCommand="CON:supersquad")
	CheatCommands(3)=(UnlockExtra=-1,CheatCommand="CON:refreshhealth")

	Begin Object Class=GUILabel Name=clblNoCheats
		StyleName="MenuOptionCaption"
		DrawMenuState=1
		TextAlign=TXTA_Center
		TextAlignV=TXTA_Center
		bAcceptsInput=false
		bMultiLine=true
		bTabStop=false
		bNeverFocus=true
		WinWidth=0.800000
		WinHeight=0.15000
		WinLeft=0.100000
		WinTop=0.4000000
	End Object
	lblNoCheats=clblNoCheats
	StringNoCheats="You have no cheats unlocked.  See the extras menu to see what extras you have unlocked."

	InputMatch=(XC_PadLeft,XC_PadLeft,XC_PadLeft,XC_PadLeft)
}
class gbx_MenuDebug extends gbx_ScreenABXY
	config(Debug);

var Automated GUIListBox					CommandListBox;

var config bool								bEnableDebug;
var config array<string>					Commands;


function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);
	InitExecution();

	OnAButtonEvent = OnChooseCommand;
	OnBButtonEvent = OnBack;
	OnXButtonEvent = OpenCheatsMenu;
	OnYButtonEvent = OnExit;
	CommandListBox.List.OnDrawItem	= DrawListItem;
	CommandListBox.List.SelectedImage = None;

	GotoState('Menu');
}

function ExecuteCommand(string cmd)
{
	GUILog("ExecuteCommand(" $cmd $")");
	ConsoleCommand( cmd );
}

function OnChooseCommand()
{
	if (CommandListBox.List.Index != -1)
	{
		ExecuteCommand( CommandListBox.List.GetExtra() );
	}
}

function OnExit()
{
	Controller.CloseAll(false);
}

function OnBack()
{
	BaseOnBButton();
}

function OpenCheatsMenu()
{
	Controller.OpenMenu("GUI.gbx_MenuCheats" );
}

function DrawListItem(Canvas C, int Item, float X, float Y, float W, float H, bool bSelected)
{
	local eMenuState drawState;

	if (Item == -1)
		return;

	if( bSelected )
		drawState = MSAT_Focused;
	else
		drawState = MSAT_Blurry;

	CommandListBox.List.Style.DrawText( C, drawState, X, Y, W, H, TXTA_Center, CommandListBox.List.GetItemAtIndex(Item) );

	if (bSelected)
	{
		W += X;
		X = 0;
		class'GUI.gbx_ScreenABXY'.Static.DrawTheThinRedLine(Controller, C, X, Y+H, W);
	}
}

function int MapListCompare(GUIListElem ElemA, GUIListElem ElemB)
{
	if (ElemA.item < ElemB.item)
		return -1;
	else if (ElemA.item > ElemB.item)
		return 1;

	return 0;
}

function AddCommand(string cmd, optional string title)
{
	if (title == "")
		CommandListBox.List.Add(cmd,, cmd);
	else
		CommandListBox.List.Add(title,, cmd);
}

// parse a line of the form cmd;title
function ParseDebugCommand(string rawCmd)
{
	local string cmd;

	if (rawCmd == "") return;

	cmd = ParseTokenDelimited(rawCmd, ";");
	if (rawCmd == "")
		AddCommand(cmd, cmd);
	else
		AddCommand(cmd, rawCmd);
}

function AddCommandsFromList(out array<string> list)
{
	local int i;

	for (i=0; i<list.Length; i++)
	{
		ParseDebugCommand(list[i]);
	}
}

state DebugBase
{
	function BeginState()
	{
		if (CommandListBox.ItemCount() > 0)
		{
			CommandListBox.List.SetIndex(0);
			CommandListBox.List.SetTopItem(0);
			SetupAButton("Execute");
		}
		else
			SetupAButton();
	}
}

state Menu extends DebugBase
{
	function BeginState()
	{
		CommandListBox.List.CompareItem = None;
		CommandListBox.List.Clear();
		AddCommandsFromList(Commands);

		Super.BeginState();
	}

	function ExecuteCommand(string cmd)
	{
		if (cmd == "MAP")
		{
			GotoState('MapList');
			return;
		}
		else if (cmd == "RECONNECT")
		{
			cmd = "open "$PlayerOwner().Level.GetLevelFileName();
		}

		Global.ExecuteCommand(cmd);
	}
}

state MapList extends DebugBase
{
	function BeginState()
	{
		local int i;
		local string S;

		CommandListBox.List.Clear();
		Controller.GetMapList("", CommandListBox.List);

		for (i=0; i<CommandListBox.ItemCount(); i++)
		{
			S = Caps(CommandListBox.List.GetItemAtIndex(i));

			CommandListBox.List.SetItemAtIndex(i, S);
			CommandListBox.List.SetExtraAtIndex(i, "open " $S);
		}

		CommandListBox.List.CompareItem = MapListCompare;
		CommandListBox.List.SortList();

		Super.BeginState();
	}

	function OnBack()
	{
		GotoState('Menu');
	}
}

defaultproperties
{
	ScreenTitle="Debug Menu"

	Begin Object class=GUIListBox Name=cProfileList
		WinWidth=0.6
		WinHeight=0.58
		WinLeft=0.20
		WinTop=0.18
        bVisibleWhenEmpty=true
	End Object
	CommandListBox=cProfileList

	YCaption="Exit Menu"
	XCaption="Cheats"
}
class gbx_MenuExtras extends gbx_ScreenTimeline
	config(Extras);

const EAT_Count = 5;
enum eExtraAssetType
{
	EAT_None,
	EAT_Picture,
	EAT_Video,
	EAT_Feature,
	EAT_Misc,
};

enum eExtraUnlockType
{
	EUT_Normal,
	EUT_Unlocked,
};

struct ExtraItem_s
{
	var	eExtraAssetType			AType;
	var eExtraUnlockType		UType;
	var string					Desc;
	var string					Asset;
};

var automated GUILabel						staticBackground;
var automated GUILabel						lblChapterName;

var automated GUILabel						lblExtraInfoText1[4];
var automated GUILabel						lblExtraInfoText2[4];
var GUIFRect								ExtraInfoLabelPositions1[4];
var GUIFRect								ExtraInfoLabelPositions2[4];
var Canvas.CanvasIcon						UnlockedIcon;
var Canvas.CanvasIcon						CheatIcon;
var Canvas.CanvasIcon						BookendIcon;
var config ExtraItem_s						ExtraList[80];
var int										CurrentSelectedExtra;

var localized string						StringCompletePrompt[4];
var localized string						StringUseMessages[EAT_Count];
var localized string						StringUseCaptions[EAT_Count];

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	local int i;
	Super.InitComponent(MyController, MyOwner);

	OnAButtonEvent = OnChooseExtra;

	for (i=0; i<4; i++)
	{
		if (lblExtraInfoText1[i] != None)
		{
			lblExtraInfoText1[i].SetWinDims(ExtraInfoLabelPositions1[i]);
			lblExtraInfoText2[i].SetWinDims(ExtraInfoLabelPositions2[i]);

			if (!Controller.bIsConsole)
			{
				lblExtraInfoText1[i].bAcceptsInput = true;
				lblExtraInfoText1[i].OnClick = ExtraItemClick;
				lblExtraInfoText1[i].OnDblClick = ExtraItemDblClick;
				lblExtraInfoText2[i].bAcceptsInput = true;
				lblExtraInfoText2[i].OnClick = ExtraItemClick;
				lblExtraInfoText2[i].OnDblClick = ExtraItemDblClick;
			}
		}
	}
}

function ScreenOnOpen()
{
	local bool bAlreadyOpen;

	bAlreadyOpen = bOpened;
	Super.ScreenOnOpen();

	if (!bAlreadyOpen)
	{
		Timeline.SelectFirstChapter();
	}
}

function int FindExtra(GUIComponent item)
{
	local int i, result;

	result = -1;
	for (i=0; i<4; i++)
	{
		if ((lblExtraInfoText1[i] == item) || (lblExtraInfoText2[i] == item))
		{
			result = i;
			break;
		}
	}

	return result;
}

function bool ExtraItemClick(GUIComponent Sender)
{
	local int i;

	if (Controller.bIsConsole)
		return false;

	i = FindExtra(Sender);
	if (i != -1)
	{
		SelectExtra(i);
	}

	return true;
}

function bool ExtraItemDblClick(GUIComponent Sender)
{
	local int i;

	if (Controller.bIsConsole)
		return false;

	i = FindExtra(Sender);
	if (i != -1)
	{
		SelectExtra(i);
		if (GotMedal(CurrentSelectedExtra))
		{
			OnChooseExtra();
		}
	}

	return true;
}

//
// RSC: load the caption from a variable
//
static function string LoadDescription( string keyString )
{
	local string s;
	if( keyString == "" )
		return "";

	s = Localize( "Descriptions", keyString, "Extras" );
	//s = GetConfigString( keyString, "Descriptions", "Extras" );
	if( s == "" )
		s = "<" @ keyString @ ">";

	return s;
}

//
// RSC: added to parse description entry in extras menu
//
static function string ParseDescEntry( string strIn )
{
	local string strOut;

	if( ParseCommand( strIn, "TEXT=" ) ) {
		strOut = LoadDescription( strIn );
		return strOut;
	}

	return strIn;	// just return the string we were given if the TEXT= keystring was not in it.
}

function SetExtraLabelCaptions()
{
	local int i, index;
	local string S;
	local string desc;

	for (i=0; i<4; i++)
	{
		index = GetExtraListIndex(i);
//		if (!((ExtraList[index].AType == EAT_None) || ((i == 3) && !bAuthenticUnlocked)))
		if (ExtraList[index].AType != EAT_None)
		{
			if (GotMedal(i) || (ExtraList[index].UType == EUT_Unlocked))
			{
				desc = ParseDescEntry( ExtraList[index].Desc );
				
				lblExtraInfoText1[i].SetCaption( desc );
				lblExtraInfoText2[i].SetCaption( StringUseMessages[ ExtraList[index].AType ] );
			}
			else
			{
				desc = ParseDescEntry( ExtraList[index].Desc );
				
				lblExtraInfoText1[i].SetCaption( desc );
				lblExtraInfoText2[i].SetCaption( StringCompletePrompt[i] );

				if (CurrentSelection == Timeline.TimeLineChapters.Length-1)
					S = StringBiA;
				else
					S = PlayerOwner().Level.MissionManager.GetMissionTitle(CurrentSelection);

				ReplaceText(lblExtraInfoText2[i].Caption, "<LEVEL>", MakeQuotedString(S));
			}
		}
	}
}

function ChapterListOnChange(GUIComponent Sender)
{
	local int i, index;

	Super.ChapterListOnChange(Sender);
	lblChapterName.SetCaption(PlayerOwner().Level.MissionManager.GetMissionTitle(CurrentSelection));


	for (i=0; i<4; i++)
	{
		index = GetExtraListIndex(i);
		if (ExtraList[index].AType == EAT_None)
		{
			// hide if this extra isn't assigned or if this is authentic but authentic is not unlocked
			lblExtraInfoText1[i].Hide();
			lblExtraInfoText2[i].Hide();
		}
		else
		{
			lblExtraInfoText1[i].Show();
			lblExtraInfoText2[i].Show();
		}
	}

	if ((CurrentSelectedExtra == -1) || !lblExtraInfoText1[CurrentSelectedExtra].bVisible)
	{
		CurrentSelectedExtra = -1;
		for (i=0; i<4; i++)
		{
			if (lblExtraInfoText1[i].bVisible)
			{
				SelectExtra(i);
				break;
			}
		}

		if (CurrentSelectedExtra == -1)
			SelectExtra(-1);
	}
	else
	{
		SelectExtra(CurrentSelectedExtra);
	}
}

function bool ScreenOnDrawPre(Canvas C)
{
	local float sX, sY, X;

	C.DrawColor = Controller.BackgroundBoxColor;
	staticBackground.DrawComponentBackground(C);

	C.DrawColor = Controller.RedLineColor;

	X = staticBackground.ActualLeft();
	if (CurrentSelectedExtra == -1)
	{
		// horizontal span
		class'GUI.gbx_ScreenABXY'.Static.DrawTheThinRedLine(Controller, C, X, staticBackground.ActualTop(), C.ClipX - X + 10);

		// vertical
		DrawBackground(C, X, staticBackground.ActualTop(), 5*Controller.CanvasScaleY, staticBackground.ActualHeight());
	}
	else
	{
		// horizontal span
		if (CurrentSelectedExtra == 3)
		{
			Timeline.GetSelectionCursorPos(sX, sY);
		}
		else
		{
			sY = VerticalOffset(MedalIconPositions[CurrentSelectedExtra].fT + MedalIconPositions[CurrentSelectedExtra].fH);
		}


		class'GUI.gbx_ScreenABXY'.Static.DrawTheThinRedLine(Controller, C, X, sY, C.ClipX - X + 10);

		// vertical
		DrawBackground(C, X, sY, 5*Controller.CanvasScaleY, staticBackground.ActualHeight() - (sY - staticBackground.ActualTop()));
	}

	if (CurrentSelectedExtra != 3)
	{
		Timeline.GetSelectionCursorPos(sX, sY);

		class'GUI.gbx_ScreenABXY'.Static.DrawTheThinRedLine(Controller, C, X, sY + 3*Controller.CanvasScaleY, sX + 3*Controller.CanvasAspectScale - X);
	}

	return Super.ScreenOnDrawPre(C);	// still do the other stuff
}

function byte GetItemDrawAlpha(int index)
{
	if (index == CurrentSelectedExtra)
		return 0;
	else
		return 60;
}

function Canvas.CanvasIcon GetMedalIcon(int medalIndex, int extraIndex)
{
	if (ExtraList[extraIndex].UType == EUT_Unlocked)
	{
		return UnlockedIcon;
	}
	else if (GotMedal(medalIndex))
	{
		if (ExtraList[extraIndex].AType == EAT_Feature)
			return CheatIcon;
		else if (PlayerOwner().Level.MissionManager.GetMissionStyle(CurrentSelection) == ECIS_Film)
			return BookendIcon;
		else
			return MedalIcons[medalIndex];
	}
	
	return nilIcon;
}

function bool ScreenOnDraw(Canvas C)
{
	local bool bResult;
	local int index;
	local byte alpha;
	bResult = Super.ScreenOnDraw(C);	// still do the other stuff

	index = GetExtraListIndex(0);
	alpha = GetItemDrawAlpha(0);
	if (ExtraList[index].AType != EAT_None)
	{
		DrawMedalIcons(C, MedalIconPositions[0], GetMedalIcon(0,index), MedalBracketIcons[0], alpha);
	}

	index = GetExtraListIndex(1);
	alpha = GetItemDrawAlpha(1);
	if (ExtraList[index].AType != EAT_None)
	{
		DrawMedalIcons(C, MedalIconPositions[1], GetMedalIcon(1,index), MedalBracketIcons[0], alpha);
	}

	index = GetExtraListIndex(2);
	alpha = GetItemDrawAlpha(2);
	if (ExtraList[index].AType != EAT_None)
	{
		DrawMedalIcons(C, MedalIconPositions[2], GetMedalIcon(2,index), MedalBracketIcons[0], alpha);
	}

	index = GetExtraListIndex(3);
	alpha = GetItemDrawAlpha(3);
	if (ExtraList[index].AType != EAT_None)
	{
		DrawMedalIcons(C, MedalIconPositions[3], GetMedalIcon(3,index), MedalBracketIcons[0], alpha);
	}

	return bResult;
}

function int GetExtraListIndex(int selectedExtraIndex)
{
	return selectedExtraIndex + CurrentSelection * 4;
}

function SelectExtra(int newExtra)
{
	local int i;

	CurrentSelectedExtra = newExtra;

	for (i=0; i<4; i++)
	{
		if (lblExtraInfoText1[i] != None)
		{
			if (i == CurrentSelectedExtra)
			{
				lblExtraInfoText1[i].DrawMenuState = eMenuState.MSAT_Focused;
				lblExtraInfoText2[i].DrawMenuState = eMenuState.MSAT_Focused;
			}
			else
			{
				lblExtraInfoText1[i].DrawMenuState = eMenuState.MSAT_Blurry;
				lblExtraInfoText2[i].DrawMenuState = eMenuState.MSAT_Blurry;
			}
		}
	}

	SetExtraLabelCaptions();

	if (CurrentSelectedExtra != -1)
	{
		i = GetExtraListIndex(CurrentSelectedExtra);

		if (GotMedal(CurrentSelectedExtra) || (ExtraList[i].UType == EUT_Unlocked))
			SetupAButton(StringUseCaptions[ ExtraList[i].AType ]);
		else
			SetupAButton();
	}
	else
	{
		SetupAButton();
	}
}

function PrevExtra()
{
	local int i;

	i = CurrentSelectedExtra - 1;
	while(i != CurrentSelectedExtra)
	{
		if (i < 0)
			i = 3;

		if (lblExtraInfoText1[i].bVisible)
		{
			if (i != CurrentSelectedExtra)
			{
				Controller.PlayClickSound(EClickSound.CS_Change);
				SelectExtra(i);
			}
			break;
		}
		i--;
	}
}

function NextExtra()
{
	local int i;

	i = CurrentSelectedExtra + 1;
	while(i != CurrentSelectedExtra)
	{
		if (i >= 4)
			i = 0;

		if (lblExtraInfoText1[i].bVisible)
		{
			if (i != CurrentSelectedExtra)
			{
				Controller.PlayClickSound(EClickSound.CS_Change);
				SelectExtra(i);
			}
			break;
		}
		i++;
	}
}

function bool ScreenXControllerEvent(byte Id, eXControllerCodes iCode)
{
	if (CurrentSelectedExtra != -1)
	{
		switch(iCode)
		{
		case XC_PadUp:
			PrevExtra();
			return true;
			break;

		case XC_PadDown:
			NextExtra();
			return true;
			break;
		}	
	}

	return Super.ScreenXControllerEvent(Id, iCode);
}

function bool ScreenKeyEvent(out byte Key,out byte State,float delta)
{
	if (CurrentSelectedExtra != -1)
	{
		// 38=up
		// 40=down
		switch(Key)
		{
		case 38:
			if (State == 1)
				PrevExtra();
			return true;
			break;

		case 40:
			if (State == 1)
				NextExtra();
			return true;
			break;
		}
	}

	return Super.ScreenKeyEvent(Key, State, delta);
}

function OnChooseExtra()
{
	local int index;
	index = GetExtraListIndex(CurrentSelectedExtra);
	if (ExtraList[index].Asset != "")
	{
		switch (ExtraList[index].AType)
		{
		case eExtraAssetType.EAT_Picture:
			Controller.PlayClickSound(EClickSound.CS_Click);
			Controller.OpenMenu("GUI.gbx_ExtrasDisplayPicture",ExtraList[index].Asset);
			break;
		case eExtraAssetType.EAT_Video:
			Controller.PlayClickSound(EClickSound.CS_Click);
			Controller.OpenMenu("GUI.gbx_ExtrasDisplayVideo",ExtraList[index].Asset);
			break;
		}
	}
}

static function bool HasExtra(int chapterIndex, int medal)
{
	if ((chapterIndex < 0) || (medal < 0) || (medal >= MEDAL_Count-1))
		return false;

	medal = chapterIndex*4 + medal;
	return (default.ExtraList[medal].AType != EAT_None) && (default.ExtraList[medal].UType != EUT_Unlocked) && (default.ExtraList[medal].Asset != "");
}

static function string GetExtraDesc(int chapterIndex, int medal)
{
	if (!HasExtra(chapterIndex, medal))
		return "";

	medal = chapterIndex*4 + medal;
	return ParseDescEntry( default.ExtraList[medal].Desc );
}

static function PreloadMenu(GUIController C)
{
	Super.PreloadMenu(C);

	C.PreloadMenu("GUI.gbx_ExtrasDisplayVideo");
	C.PreloadMenu("GUI.gbx_ExtrasDisplayPicture");
}

defaultproperties
{
	ScreenTitle="Extras"

	CurrentSelectedExtra=-1
	UnlockedIcon=(Icon=Material't_interface_mb.hud.chapters_comp',U=361,V=166,UL=63,VL=89,DrawColor=(R=255,G=255,B=255,A=255))
	BookendIcon=(Icon=Material't_interface_mb.hud.chapters_comp',U=303,V=175,UL=57,VL=80,DrawColor=(R=255,G=255,B=255,A=255))
	CheatIcon=(Icon=Material't_interface_mb.hud.chapters_comp',U=426,V=166,UL=63,VL=89,DrawColor=(R=255,G=255,B=255,A=255))

	Begin Object Class=gbx_GameTimeline Name=cgametimeline
		bNonInteractive=false
		bCycleUnplayedChapters=true
	End Object
	Timeline=cgametimeline

	// static background box thingy
	Begin Object Class=GUILabel Name=cStaticBackground
		StyleName="TextLabel"
		TextAlign=TXTA_Left
		DrawMenuState=1
		WinWidth=0.925
		WinHeight=0.38
		WinLeft=0.0375
		WinTop=0.21
		bNeverFocus=true
		bMultiLine=true
		bTransparent=true
	End Object
	staticBackground=cStaticBackground

	// chapter name
	Begin Object Class=GUILabel Name=clblChapter
		StyleName="MenuOptionCaption"
		DrawMenuState=2
		TextAlign=TXTA_Left
		bAcceptsInput=false
		bTabStop=false
		bDrawToFit=true
		WinWidth=0.7775
		WinHeight=0.0475
		WinLeft=0.04375
		WinTop=0.16
	End Object
	lblChapterName=clblChapter

	// extra info text
	Begin Object Class=GUILabel Name=clblExtraInfo
		StyleName="TextLabel"
		DrawMenuState=1
		TextAlign=TXTA_Center
		TextAlignV=TXTA_Center
		bMultiline=false
		bAcceptsInput=false
		bTabStop=false
		bForceCaps=false
		bDrawToFit=true
		WinWidth=0
		WinHeight=0
		WinLeft=0
		WinTop=0
	End Object
	lblExtraInfoText1(0)=clblExtraInfo
	lblExtraInfoText1(1)=clblExtraInfo
	lblExtraInfoText1(2)=clblExtraInfo
	lblExtraInfoText1(3)=clblExtraInfo
	lblExtraInfoText2(0)=clblExtraInfo
	lblExtraInfoText2(1)=clblExtraInfo
	lblExtraInfoText2(2)=clblExtraInfo
	lblExtraInfoText2(3)=clblExtraInfo

	ExtraInfoLabelPositions1(0)=(fL=0.085,fT=0.22,fW=0.855,fH=0.04125)
	ExtraInfoLabelPositions1(1)=(fL=0.085,fT=0.3125,fW=0.855,fH=0.04125)
	ExtraInfoLabelPositions1(2)=(fL=0.085,fT=0.405,fW=0.855,fH=0.04125)
	ExtraInfoLabelPositions1(3)=(fL=0.085,fT=0.4975,fW=0.855,fH=0.04125)

	ExtraInfoLabelPositions2(0)=(fL=0.085,fT=0.26125,fW=0.855,fH=0.04125)
	ExtraInfoLabelPositions2(1)=(fL=0.085,fT=0.35375,fW=0.855,fH=0.04125)
	ExtraInfoLabelPositions2(2)=(fL=0.085,fT=0.44625,fW=0.855,fH=0.04125)
	ExtraInfoLabelPositions2(3)=(fL=0.085,fT=0.53875,fW=0.855,fH=0.04125)
	
	MedalIconPositions(0)=(fL=0.05,fT=0.22,fW=0.034375,fH=0.0825)
	MedalIconPositions(1)=(fL=0.05,fT=0.3125,fW=0.034375,fH=0.0825)
	MedalIconPositions(2)=(fL=0.05,fT=0.405,fW=0.034375,fH=0.0825)
	MedalIconPositions(3)=(fL=0.05,fT=0.4975,fW=0.034375,fH=0.08)

	StringCompletePrompt(0)="Complete <LEVEL> on Easy"
	StringCompletePrompt(1)="Complete <LEVEL> on Normal"
	StringCompletePrompt(2)="Complete <LEVEL> on Difficult"
	StringCompletePrompt(3)="Complete <LEVEL> on Authentic"

	StringUseMessages(0)=""
	StringUseMessages(1)="Select to view this image set."
	StringUseMessages(2)="Select to play this video clip."
	StringUseMessages(3)="Activate from in-game Cheats Menu."
	StringUseMessages(4)=""

	StringUseCaptions(0)=""
	StringUseCaptions(1)="View Images"
	StringUseCaptions(2)="Play Video"
	StringUseCaptions(3)=""
	StringUseCaptions(4)=""
//	ExtraList(0)=(AType=EAT_None,Desc="",Asset="")
}
// =======================================================================================================================================================
// gbx_MenuLayoutScreen
// Holds an array of components, automatically laid out
// =======================================================================================================================================================

class gbx_MenuLayoutScreen extends gbx_ScreenABXY
	abstract;

var automated array<GUIComponent>	MyComponents;
var localized array<string>			MyCaptions;

var float							LayoutPivotPoint;
var float							LayoutSpacing;
var ELayoutAlign					LayoutPivotStyle;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	local int i;

	Super.InitComponent(MyController, MyOwner);

	if (MyComponents.Length != MyCaptions.Length)
		GUILog("WARNING: Menu " $ScreenTitle $" has different component and caption array lengths.");

	for (i=0; i<MyComponents.Length; i++)
	{
		MyComponents[i].SetCaption(MyCaptions[i]);
		MyComponents[i].OnClick = LayoutScreenButtonClick;
		MyComponents[i].OnChange = LayoutScreenButtonChanged;
		MyComponents[i].TabOrder = i;
	}

	hBtnA.TabOrder = i++;
	hBtnB.TabOrder = i++;
	hBtnX.TabOrder = i++;
	hBtnY.TabOrder = i++;

	DoComponentLayout();
}

function DoComponentLayout()
{
	LayoutControlArray(MyComponents, LayoutPivotPoint, LayoutSpacing, LayoutPivotStyle);
	MapControls();
	FocusFirst(none);
}

function bool OnComponentActivate(int button, GUIComponent Sender)
{
	return true;
}

function OnComponentChanged(int button, GUIComponent Sender);

function bool LayoutScreenButtonClick(GUIComponent Sender)
{
	local int i;

	for (i=0; i<MyComponents.Length; i++)
	{
		if (MyComponents[i] == Sender)
			return OnComponentActivate(i, Sender);
	}

	return false;
}

function LayoutScreenButtonChanged(GUIComponent Sender)
{
	local int i;

	for (i=0; i<MyComponents.Length; i++)
	{
		if (MyComponents[i] == Sender)
		{
			OnComponentChanged(i, Sender);
			break;
		}
	}
}

function bool ScreenOnDraw(Canvas C)
{
	DrawFocusedControl(C);

	return Super.ScreenOnDraw(C);	// still do the other stuff
}

// TODO REMOVEME
function OpenDebugMenu()
{
	Controller.OpenMenu("GUI.gbx_MenuDebug");
}

function bool EnableDebugMenu()
{
	if (class'GUI.gbx_MenuDebug'.Default.bEnableDebug)
	{
		SetupXButton("Debug Menu");
		OnXButtonEvent = OpenDebugMenu;
		return true;
	}

	return false;
}

// 37=left
// 38=up
// 39=right
// 40=down
// 32=space
function bool SAB_KeyEvent(out byte Key,out byte State,float delta)
{
	local int i;

	if (HelpButtonHasFocus() && (State == 1))
	{
		if (Key == 38)	// up
		{
			for (i=MyComponents.Length-1; i>= 0; i--)
			{
				if (MyComponents[i].bVisible && !MyComponents[i].bDisabled)
				{
					MyComponents[i].SetFocus(None);
					break;
				}
			}

			return true;
		}
		else if (Key == 40)
		{
			for (i=0; i<MyComponents.Length; i++)
			{
				if (MyComponents[i].bVisible && !MyComponents[i].bDisabled)
				{
					MyComponents[i].SetFocus(None);
					break;
				}
			}

			return true;
		}
	}
	else if ((GUIMenuOption(FocusedControl) != None) && (State == 1))
	{
		if (Key == 38)
		{
			PrevControl(FocusedControl);
			return true;
		}
		else if (Key == 40)
		{
			NextControl(FocusedControl);
			return true;
		}
	}

	return Super.SAB_KeyEvent(Key,State,delta);
}

defaultproperties
{
	LayoutPivotPoint=0.46
	LayoutSpacing=0.015
	LayoutPivotStyle=LA_Center

//	MyComponents(0)=
//	MyComponents(1)=
//	MyComponents(2)=
//	MyComponents(3)=
//	MyComponents(4)=
//	MyComponents(5)=

//	MyCaptions(0)=""
//	MyCaptions(1)=""
//	MyCaptions(2)=""
//	MyCaptions(3)=""
//	MyCaptions(4)=""
//	MyCaptions(5)=""

	// widget prototype classes
	Begin Object Class=GUIButton Name=cBlockMenuButton
		bFocusOnWatch=true
		StyleName="MainButton"
		WinWidth=0.800000
		WinHeight=0.08000
		WinLeft=0.100000
		WinTop=0.20000
	End Object

	Begin Object Class=GUIButton Name=cBtnOption
		bFocusOnWatch=true
		StyleName="LargeButton"
		WinWidth=0.800000
		WinHeight=0.05000
		WinLeft=0.100000
		WinTop=0.250000
		TabOrder=0
	End Object

	Begin Object Class=moSpinListControl Name=cSpinMenuOption
		bFocusOnWatch=true
		LabelJustification=TXTA_Right
		CaptionWidth=0.50
		ComponentWidth=0.45
		WinWidth=0.90
		WinHeight=0.052000
		WinLeft=0.050
		WinTop=0.28000
		bHeightFromComponent=false
	End Object
	Begin Object Class=moSpinListControl Name=cSpinMenuOptionV
		bFocusOnWatch=true
		LabelJustification=TXTA_Center
		CaptionWidth=0.50
		ComponentWidth=0.40
		WinWidth=0.42000000
		WinHeight=0.1000
		WinLeft=0.0500000
		WinTop=0.28000
		bHeightFromComponent=false
		bVerticalLayout=true
	End Object


	Begin Object Class=moEditBox Name=cEditMenuOption
		bFocusOnWatch=true
		LabelJustification=TXTA_Right
		CaptionWidth=0.50
		ComponentWidth=0.45
		WinWidth=0.90
		WinHeight=0.052000
		WinLeft=0.050
		WinTop=0.28000
		bHeightFromComponent=false
	End Object
	Begin Object Class=moEditBox Name=cEditMenuOptionV
		bFocusOnWatch=true
		LabelJustification=TXTA_Center
		CaptionWidth=0.50
		ComponentWidth=0.40
		WinWidth=0.42000000
		WinHeight=0.1000
		WinLeft=0.0500000
		WinTop=0.28000
		bHeightFromComponent=false
		bVerticalLayout=true
	End Object


	Begin Object Class=moPasswordBox Name=cEditPasswordMenuOption
		bFocusOnWatch=true
		LabelJustification=TXTA_Right
		CaptionWidth=0.50
		ComponentWidth=0.45
		WinWidth=0.90
		WinHeight=0.052000
		WinLeft=0.050
		WinTop=0.28000
		bHeightFromComponent=false
	End Object
}
class gbx_MenuMain extends gbx_MenuLayoutScreen;

var string								strOnOpenTarget;	// if set, jump to this screen on open
var string								CreateProfileName;
var bool								bCheckSilentSignin;		// for triggering silent signon
var bool								bFoundCrossTitleInvite;
var bool								bCompletedTraining;

var localized string					VideoFileTraining;

var Automated GUILabel				lblVersion;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

 	OnCanClose = MM_CanClose;
	OnBButtonEvent = OnQuit;
	OnOpen = MM_OnOpen;

	// clear out disconnect class, just in case
	class'GameEngine'.default.DisconnectMenuClass = "";
	class'GameEngine'.default.DisconnectMenuArg = "";
	class'GameEngine'.static.StaticSaveConfig();

	if (!Controller.bIsConsole)
	{	
		SetupBButton(StringQuit);
	}

	// TODO PARIS REMOVEME
	if (!PlayerOwner().bIsDemo)
	{
		if (EnableDebugMenu())
		{
			SetupYButton("Exit GUI");
			OnYButtonEvent = ExitGUI;
		}
	}
	else
	{
		MyComponents[0].EnableControl( false );
		MyComponents[2].EnableControl( false );
		MyComponents[3].EnableControl( false );
		MyComponents[4].EnableControl( false );
	}

	// Remove mulitplayer option in the demo
	if (Controller.bIsDemoVersion)
	{
		MyComponents[2].EnableControl( false );
		MyComponents[6].Hide();
		MyComponents[6].EnableControl( false );
	}

	// ok if we're already signed in, no need to do silent sign in :D
	if( Controller.bIsConsole )
	{
		bCheckSilentSignin = Controller.LiveFunc.IsOffLine() && !Controller.LiveFunc.IsSigningIn();
	}

	class'gbx_ProfileManager'.Static.SetupCameraView(self);

    lblVersion.SetCaption(Controller.GetVersionString());
	
	DisableSelectAButton();
}

function HandleDisconnectArgs()
{
	local string S, S1, S2;
	local int c1, c2;

	// should we launch straight to the MP menu?
	if (Controller.bIsConsole && (LParam1 != ""))
	{
		GUILog("Looking for disconnect args");
		if (RetrieveDisconnectArgs(LParam1, S))
		{
			LParam1 = "";
			
			if(Controller.bIsDemoVersion || Controller.bIsPreviewVersion)
				return;

			Controller.GetUsedControllersFromCmdLine(c1, c2);

			Controller.BindPlayerToController(0, c1);
			Controller.BindPlayerToController(1, c2);

			Controller.GetUsedProfilesFromCmdLine(S1, S2);
//			class'gbx_ProfileManager'.Static.SetProfileForController(self, 0, S1);
			class'gbx_ProfileManager'.Static.SetProfileForController(self, 1, S2);

			if (S2 == "")
				Controller.BindPlayerToController(1, -1);
			
			Controller.OpenMenu("GUI.gbx_ProfileScreenBase", "PROFILE", Caps(S));

			return;
		}
	}
	else if (LParam1 != "")
	{
		if (RetrieveDisconnectArgs(LParam1, S))
		{
			LParam1 = "";

			if(Controller.bIsDemoVersion || Controller.bIsPreviewVersion)
				return;

			if (Left(S,3) == "SK_")
			{
				Controller.BindPlayerToController(0, 0);
				Controller.OpenMenu("GUI.gbx_MenuSkirmish", Right(S,Len(S)-3));
			}
			else if (S ~= "UBICOM")
			{
                Controller.OpenMenu("GUI.gbx_MenuMP");
		        if (!class'GameService.GameService'.Static.IsOnline())
		        {
	                //Commented this, there was a problem where the fields filled only partially when comming back automatically
	                //so just stay in the multiplayer screen
	                //Controller.OpenMenu("GUI.gbx_UbiLoginAccount");
                }
		        else
		        {
			        Controller.OpenMenu("GUI.gbx_UbiWelcome");

			        if (Controller.MenuStack[Controller.MenuStack.Length-1].IsA('gbx_UbiWelcome'))
			            gbx_UbiWelcome(Controller.MenuStack[Controller.MenuStack.Length-1]).SkipMOTD();
			        
        			Controller.OpenMenu("GUI.gbx_InternetQuery");
                }
			}
			else if (S ~= "LANPLAY")
			{
                Controller.OpenMenu("GUI.gbx_MenuMP");
    			Controller.OpenMenu("GUI.gbx_BrowseMatchLanPC");
            }
        }
	}
}

function bool ScreenOnPreDraw(Canvas C)
{
	Super.ScreenOnPreDraw(C);

	HandleDisconnectArgs();
	return false;
}

function bool Work_CreatingProfile()
{
	if (class'gbx_ProfileManager'.Static.CreateNewProfile(self, CreateProfileName, true))
		class'gbx_ProfileManager'.Static.SetProfileForController(self, 0, CreateProfileName);

	CreateProfileName = "";

	return true;
}

function NewProfileDone(string currentString, bool bCancelled)
{
	local gbx_ScreenExtendedWork dlg;

	GUILog("NewProfileDone " $currentString);

	if (!bCancelled)
	{
		CreateProfileName = currentString;

		dlg = LaunchWorkDialog(Controller, class'gbx_ProfileManager'.default.StringCreatingProfile,, 1.0);
		dlg.DoWork = Work_CreatingProfile;
	}
	else
	{
		currentString = "";
		class'gbx_ProfileManager'.Static.WarnCreateProfileFailed(self, currentString, bCancelled);
	}
}

function bool CheckForCrossTitleInvite()
{
    if( bFoundCrossTitleInvite )
        return false;
    
	if (class'gbx_LiveDlgAcceptCrossTitle'.static.DoCrossTitleInvite(self))
	{
        bFoundCrossTitleInvite = true;
		return true;
	}

	return false;
}

function bool MM_CanClose(optional Bool bCancelled)
{
	return false;
}

function OnQuit()
{
	if (!Controller.bIsConsole)
	{
		Controller.OpenMenu("GUI.gbx_DlgQuitGame");
	}
}

// TODO REMOVEME
function ExitGUI()
{
	Controller.CloseAll(false);
}

function bool ScreenOnDraw(Canvas C)
{
	// rss: need to clear active mutators when user hits mainmenu!
	class'Gameplay.gbxMutatorList'.static.SetAllDeactive();

	return Super.ScreenOnDraw(C);
}

function HandleSilentSignin()
{
	local string S;

	if (bCheckSilentSignin)
	{
		if (Controller.LiveFunc.IsOffLine() && !Controller.LiveFunc.IsSigningIn())
		{
			GUILog("Beginning silent Live Logon...");
			S = ConsoleCommand("XLIVE SILENT_LOGON");
			GUILog("... LOGON_SILENT returned " $S);
		}

		bCheckSilentSignin = false;
	}
}

function bool SAB_OnXControllerEvent(byte Id, eXControllerCodes iCode)
{
	// TODO PARIS REMOVEME
	if (PlayerOwner().bIsDemo)
		return Super.SAB_OnXControllerEvent(Id, iCode);

	HandleSilentSignin();

	return Super.SAB_OnXControllerEvent(Id, iCode);
}

function MM_OnOpen()
{
	local string S;
	local gbx_ScreenTextEntry dlg;
	local GameProfile gProfile;
	local string ProfileName;

	// if we have no profiles, create our default here
	if (class'Engine.GameProfile'.Static.GetProfileCount(PlayerOwner().Level) == 0)
	{
		dlg = class'gbx_ProfileManager'.Static.PromptNewProfile(self);
		dlg.EntryFinished = NewProfileDone;
		return;
	}

	// if our current profile is damaged, display the notification and jump to the profile manager
	if (!class'gbx_DlgCorruptContent'.Static.VerifyProfile(self, class'gbx_ProfileManager'.Static.GetProfileForController(self, 0), true))
	{
		class'gbx_ProfileManager'.Static.SetProfileForController(self, 0, "");
		return;
	}
	
	// check for a x-title invite now
	if (CheckForCrossTitleInvite())
		return;

	// handle silent sign-in if we skipped it in the PRESS START screen because of a x-title invite
    if( bFoundCrossTitleInvite )
		HandleSilentSignin();

	// disable continue if we can't load the profile
	if (!class'gbx_ProfileManager'.Static.ControllerProfileExists(self, 0))
	{
		Controller.OpenMenu("GUI.gbx_ProfileManager", "0");
		MyComponents[0].EnableControl( false );
		return;
	}
	else
	{
		if (!PlayerOwner().bIsDemo)
		{
			MyComponents[0].EnableControl( true );
		}
	}

	if (strOnOpenTarget != "")
	{
		S = strOnOpenTarget;
		strOnOpenTarget = "";

		if (!ShouldBlockMenuOpen(S, false))
		{
			Controller.OpenMenu(S);
			return;
		}
	}

	// change the caption of the "continue" button if this is a fresh game
	gProfile = class'GameProfile'.Static.LoadCurrentGameProfile( PlayerOwner().Level );
	if (gProfile == None)
	{
		ProfileName = class'Engine.GameProfile'.Static.GetCurrentGameProfile(PlayerOwner().Level);
		class'Engine.GameProfile'.Static.CreateGameProfile(PlayerOwner().Level, ProfileName);
		gProfile = class'GameProfile'.Static.LoadCurrentGameProfile( PlayerOwner().Level );
	}

	class'gbx_MenuStory'.static.CacheGameProfileInfo(gProfile);
	default.bCompletedTraining = (gProfile.CompletedMission(1) > 0) || gProfile.CompletedSkirmishMission();
	class'GameProfile'.Static.UnloadProfile( PlayerOwner().Level, gProfile );

	// Prevent the bCompletedTraining menu from ever showing in the demo
	if (Controller.bIsDemoVersion)
	{
		default.bCompletedTraining = true;
	}

	Controller.BindPlayerToController(0, -1);
	Controller.BindPlayerToController(1, -1);
}

function bool ShouldBlockMenuOpen(string target, bool bInitialEntry)
{
	// TODO PARIS REMOVEME
	if (PlayerOwner().bIsDemo)
		return false;

	if (target == "GUI.gbx_MenuMP")
	{
		// always reject if no player 1 profile
		if (!class'gbx_ProfileManager'.Static.ControllerProfileExists(self, 0))
			return true;

		// reject initially for player 2
		if (bInitialEntry && Controller.bIsConsole)
			return (Controller.LiveFunc.IsControllerConnected(1) && !class'gbx_ProfileManager'.Static.ControllerProfileExists(self, 1));
	}
	else if (target == "GUI.gbx_MenuStory")
	{
		// always reject if no player 1 profile
		if (!class'gbx_ProfileManager'.Static.ControllerProfileExists(self, 0))
			return true;
	}

	return false;
}

function OpenScreen(string menu)
{
	// prompt profiles if player 2 is connected but has no profile
	// or if player 1 has no profile
	if (ShouldBlockMenuOpen(menu, true))
	{
		strOnOpenTarget = menu;
		Controller.OpenMenu("GUI.gbx_ProfileManager");
	}
	else
	{
		Controller.OpenMenu(menu);
	}
}

function bool OnComponentActivate(int button, GUIComponent Sender)
{
	local PlayerController PC;

	switch (button)
	{
		case 0:	// Story
			OpenScreen("GUI.gbx_MenuStory"); return true; break;

		case 1:	// Skirmish
			Controller.BindPlayerToController(0, Controller.ControllerId);
			OpenScreen("GUI.gbx_MenuSkirmish"); return true; break;

		case 2:	// Multiplayer
			if (Controller.bIsConsole)
			{
				Controller.BindPlayerToController(0, Controller.ControllerId);
				Controller.OpenMenu("GUI.gbx_ProfileScreenBase", "PROFILE");
			}
			else
			{
				OpenScreen("GUI.gbx_MenuMP");
			}
			return true;

		case 3: // Options
			if(Controller.bIsConsole){ //NAC: ADDED for PC Options Menu
				return Controller.OpenMenu("GUI.gbx_MenuOptions"); break;}
			else{return Controller.OpenMenu("GUI.gbx_MenuOptionsPC"); break;}//NAC: ADDED for PC Options Menu
					

		case 4: // Profiles
			return Controller.OpenMenu("GUI.gbx_ProfileManager"); break;

		case 5:	// Extras
			return Controller.OpenMenu("GUI.gbx_MenuExtras"); break;

		case 6:	// Tutorial
				// RSC: force subtitles for languages other than English
				PC = PlayerOwner().Level.GetLocalPlayerController();

				Controller.StopMusic();
				if( PC.bDisableSubtitles && PlayerOwner().GetLanguage() ~= "int" )
					ConsoleCommand("PLAYMOVIE" @VideoFileTraining @"0 1 0 0 0 640 480");
				else
					ConsoleCommand("PLAYMOVIECAPTIONED" @VideoFileTraining @"0 1 0 0 0 640 480");
				Controller.StartMusic();

				return true;
			break;
	}

	return false;
}

static function PreloadMenu(GUIController C)
{
	Super.PreloadMenu(C);

	C.PreloadMenu("GUI.gbx_MenuStory");
	C.PreloadMenu("GUI.gbx_MenuSkirmish");
	C.PreloadMenu("GUI.gbx_ProfileManager");
	C.PreloadMenu("GUI.gbx_MenuExtras");
	C.PreloadMenu("GUI.gbx_SPChooseDifficulty");

	if (C.bIsConsole)
	{
		C.PreloadMenu("GUI.gbx_DlgMenuPressStart");
		C.PreloadMenu("GUI.gbx_ProfileScreenBase");
		C.PreloadMenu("GUI.gbx_MenuOptions");
	}
	else
	{
		C.PreloadMenu("GUI.gbx_MenuMP");
		C.PreloadMenu("GUI.gbx_MenuOptionsPC");  //NAC Added PC MenuOptions
		C.PreloadMenu("GUI.gbx_DlgQuitGame");
		C.PreloadMenu("GUI.gbx_DlgOkRestart");	//NAC Added for Restart game prompt
		
	}
}

defaultproperties
{
	LayoutSpacing=0.005
	MyComponents(0)=cBlockMenuButton
	MyComponents(1)=cBlockMenuButton
	MyComponents(2)=cBlockMenuButton
	MyComponents(3)=cBlockMenuButton
	MyComponents(4)=cBlockMenuButton
	MyComponents(5)=cBlockMenuButton
	MyComponents(6)=cBlockMenuButton

	MyCaptions(0)="Story"
	MyCaptions(1)="Skirmish"
	MyCaptions(2)="Multiplayer"
	MyCaptions(3)="Options"
	MyCaptions(4)="Profiles"
	MyCaptions(5)="Extras"
	MyCaptions(6)="Tutorial"

	bAllowedAsLast=true
	bCheckSilentSignin=false

	ACaption="Select"
	BCaption=""
	VideoFileTraining="..\\media\\training.bik"

	Begin Object Class=GUILabel Name=cLblVersion
		StyleName="TextLabel"
		TextAlign=TXTA_Left
		TextAlignV=TXTA_Left
		bAcceptsInput=false
		bTabStop=false
		WinWidth=0.500000
		WinHeight=0.05000
		WinLeft=0.010000
		WinTop=0.95000
		TextColor=(R=120,G=120,B=120,A=120)
	End Object
	lblVersion=cLblVersion
}
class gbx_MenuMP extends gbx_MenuLayoutScreen;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	if(Controller.bIsDemoVersion || Controller.bIsPreviewVersion)
		MyComponents[0].EnableControl( false );
}

function bool OnComponentActivate(int button, GUIComponent Sender)
{
	switch (button)
	{
		case 0:	// ubi.com
			if (class'GameService.GameService'.Static.IsOnline())
				Controller.OpenMenu("GUI.gbx_UbiWelcome");
			else
			    Controller.OpenMenu("GUI.gbx_UbiPatchScreen");

			return true;

		case 1:	// lan
			Controller.OpenMenu("GUI.gbx_BrowseMatchLanPC");
			return true;
	}

	return false;
}

static function PreloadMenu(GUIController C)
{
	Super.PreloadMenu(C);

	C.PreloadMenu("GUI.gbx_UbiWelcome");
	C.PreloadMenu("GUI.gbx_UbiPatchScreen");
	C.PreloadMenu("GUI.gbx_BrowseMatchLanPC");
}

defaultproperties
{
	LayoutSpacing=0.01
	MyComponents(0)=cBlockMenuButton
	MyComponents(1)=cBlockMenuButton

	MyCaptions(0)="Play It on Ubi.com"
	MyCaptions(1)="Lan Play"

	ScreenTitle="MultiPlayer"
	ACaption=""
	bShowProfileLabels=false
}
//
// gbx_MenuMutator - allow users to select mutators for bia
//
class gbx_MenuMutator extends gbx_ScreenABXY;

var Automated GUIListBox      lb_Avail, lb_Active;
var automated GUILabel          AvailTitle, ActiveTitle, DescTitle;
var automated GUIScrollTextBox			DescBox;

var int CurrentAvailIndex;
var int CurrentActiveIndex;

var localized string AvailTextLabel, ActiveTextLabel, DescTextTitle, AddTextButton, RemoveTextButton, BackTextButton, TitleScreenText; 
// jer 
var bool						bAvailFocus;
var bool						bActiveFocus;


function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
    super.InitComponent( MyController, MyOwner );
    
    OnXButtonEvent = OnAdd;
    OnYButtonEvent = OnRemove;
	OnBButtonEvent = OnBack;


	SetCaption(TitleScreenText);
	SetupBButton(BackTextButton);
	SetupXButton(AddTextButton);
	SetupYButton(RemoveTextButton);

	lb_Avail.List.OnDrawItem	= DrawListItemAvail;
	lb_Avail.List.SelectedImage = None;
	AvailTitle.SetCaption(AvailTextLabel);

	lb_Active.List.OnDrawItem	= DrawListItemActive;
	lb_Active.List.SelectedImage = None;
	ActiveTitle.SetCaption(ActiveTextLabel);

	DescBox.MyScrollText.SetStyle("TextLabel");
	DescBox.SetContent("");
	DescTitle.SetCaption(DescTextTitle);

	BuildList();
}

function SetDescBox()
{
	local string s;
	
	if( bAvailFocus )
		s = class'Gameplay.gbxMutatorList'.static.GetMutatorDescription(CurrentAvailIndex);
	else
		s = class'Gameplay.gbxMutatorList'.static.GetMutatorDescription(CurrentActiveIndex);
	if(Len(s) >= 411) // rss: limit to 411 characters at one time!
	{
		s = Left( s , 411 );
		s = s$ "...";
	}
	DescBox.SetContent(s);
}

function SetButtons()
{
	if( lb_Avail.List.Elements.Length != 0 )
	{
		if( bAvailFocus )
		{
			SetupXButton(AddTextButton);
			SetupYButton("");
		}
		else
			SetupXButton("");
	}
	if( lb_Active.List.Elements.Length != 0 )
	{
		if( bActiveFocus )
		{
			SetupXButton("");
			SetupYButton(RemoveTextButton);
		}
		else
			SetupYButton("");
	}
}

function OnAdd()
{
    if( class'Gameplay.gbxMutatorList'.static.IsIndexValid(CurrentAvailIndex) )
    {
        if( !class'Gameplay.gbxMutatorList'.static.GetIsActive(CurrentAvailIndex) )
            class'Gameplay.gbxMutatorList'.static.Activate(CurrentAvailIndex);
    }

    BuildList();

    if( lb_Avail.List.Elements.Length == 0 )
    {
		bActiveFocus = true;
		bAvailFocus = false;
	}
}

function OnRemove()
{
    if( class'Gameplay.gbxMutatorList'.static.IsIndexValid(CurrentActiveIndex) )
    {
        if( class'Gameplay.gbxMutatorList'.static.GetIsActive(CurrentActiveIndex) )
            class'Gameplay.gbxMutatorList'.static.Deactivate(CurrentActiveIndex);
    }

    BuildList();

    if( lb_Active.List.Elements.Length == 0 )
    {
		bAvailFocus = true;
		bActiveFocus = false;
	}
}

function BuildList()
{
   local int i;

   class'Gameplay.gbxMutatorList'.static.GetMutatorList();
   lb_Avail.List.Clear();
   lb_Active.List.Clear();

   for( i=0; i < (class'Gameplay.gbxMutatorList'.static.GetMutatorListSize()); i++)
   {
       if( !class'Gameplay.gbxMutatorList'.static.GetIsActive(i) )
           lb_Avail.List.Add(class'Gameplay.gbxMutatorList'.static.GetMutatorFriendlyName(i),,class'Gameplay.gbxMutatorList'.static.GetMutatorName(i));
       else
           lb_Active.List.Add(class'Gameplay.gbxMutatorList'.static.GetMutatorFriendlyName(i),,class'Gameplay.gbxMutatorList'.static.GetMutatorName(i));
   }
}



function OnBack()
{
   BaseOnBButton();
}

function DrawListItemAvail(Canvas C, int Item, float X, float Y, float W, float H, bool bSelected)
{
	local eMenuState drawState;

	if(lb_Avail.bHasFocus)
	{
		bAvailFocus = true;
		bActiveFocus = false;
	}

	if (Item == -1)
		return;

	if( bSelected && bAvailFocus && !lb_Active.bHasFocus)
		drawState = MSAT_Focused;
	else
		drawState = MSAT_Blurry;

	lb_Avail.List.Style.DrawText( C, drawState, X, Y, W, H, TXTA_Center, lb_Avail.List.GetItemAtIndex(Item) );

	if (bSelected && bAvailFocus && !lb_Active.bHasFocus)
	{
		W += X;
		X = 0;
		CurrentAvailIndex = class'Gameplay.gbxMutatorList'.static.GetIndexByName( lb_Avail.List.GetItemAtIndex(Item) );
		class'GUI.gbx_ScreenABXY'.Static.DrawTheThinRedLine(Controller, C, X, Y+H, W);
	}

	SetDescBox();
	SetButtons();
}

function DrawListItemActive(Canvas C, int Item, float X, float Y, float W, float H, bool bSelected)
{
	local eMenuState drawState;

	if(lb_Active.bHasFocus)
	{
		bActiveFocus = true;
		bAvailFocus = false;
	}

	if (Item == -1)
		return;

	if( bSelected && bActiveFocus && !lb_Avail.bHasFocus )
		drawState = MSAT_Focused;
	else
		drawState = MSAT_Blurry;

	lb_Active.List.Style.DrawText( C, drawState, X, Y, W, H, TXTA_Center, lb_Active.List.GetItemAtIndex(Item) );

	if (bSelected && bActiveFocus && !lb_Avail.bHasFocus )
	{
		W += X;
		CurrentActiveIndex = class'Gameplay.gbxMutatorList'.static.GetIndexByName( lb_Active.List.GetItemAtIndex(Item) );
		class'GUI.gbx_ScreenABXY'.Static.DrawTheThinRedLine(Controller, C, X, Y+H, W);
	}

	SetDescBox();
	SetButtons();
}


defaultproperties
{
    ScreenTitle=""
    
   	Begin Object Class=GUIListBox Name=IAMutatorAvailList
		WinWidth=0.378955
		WinHeight=0.3
		WinLeft=0.026108
		WinTop=0.20  // 0.18
		bVisibleWhenEmpty=true
		Hint="These are the available mutators."
		TabOrder=0
		StyleName="NoBackground"
	End Object
	lb_Avail = IAMutatorAvailList;

	Begin Object Class=GUIListBox Name=IAMutatorActiveList
		WinWidth=0.378955
		WinLeft=0.584376
		WinHeight=0.3
		WinTop=0.20
		bVisibleWhenEmpty=true
		Hint="These are the current selected mutators."
		TabOrder=5
		StyleName="NoBackground"
	End Object
	lb_Active = IAMutatorActiveList
	// 0.584376

	Begin Object Class=GUILabel Name=cLblAvail
		StyleName="TextLabel"
		TextAlign=TXTA_Left
		TextAlignV=TXTA_Left
		bAcceptsInput=false
		bTabStop=false
		WinWidth=0.500000
		WinHeight=0.05000
		WinLeft=0.026108
		WinTop=0.15  // .95
		TextColor=(R=120,G=120,B=120,A=120)
	End Object
	AvailTitle = cLblAvail

	Begin Object Class=GUILabel Name=cLblActive
		StyleName="TextLabel"
		TextAlign=TXTA_Left
		TextAlignV=TXTA_Left
		bAcceptsInput=false
		bTabStop=false
		WinWidth=0.500000
		WinHeight=0.05000
		WinLeft=0.584376
		WinTop=0.15
		TextColor=(R=120,G=120,B=120,A=120)
	End Object
	ActiveTitle = cLblActive

	Begin Object Class=GUILabel Name=cLblDesc
		StyleName="TextLabel"
		TextAlign=TXTA_Left
		TextAlignV=TXTA_Left
		bAcceptsInput=false
		bTabStop=false
		WinWidth=0.500000
		WinHeight=0.05000
		WinLeft=0.026108
		WinTop=0.54  // .95
		TextColor=(R=120,G=120,B=120,A=120)
	End Object
	DescTitle = cLblDesc
	
	Begin Object Class=GUIScrollTextBox Name=stbDesc
		StyleName="NoBackground"
		RenderWeight=0.45
		InitialDelay=0.0
		CharDelay=0.075
		EOLDelay=0.075
		bNoTeletype=true
		bNoTeletypeCursor=true
		bVisibleWhenEmpty=true
		bTabStop=false
		WinWidth=0.94
		WinHeight=0.20000
		WinLeft=0.026108
		WinTop=0.59  // .95
	End Object
	DescBox = stbDesc
	
	
	ACaption="";
	BCaption="";

    XCaption="";
	YCaption="";

	// rss: for loc
    TitleScreenText = "Mutators";
    AvailTextLabel = "Available Mutators";
    ActiveTextLabel = "Active Mutators";
    AddTextButton = "Add";
    RemoveTextButton = "Remove";
    BackTextButton = "Back";
    DescTextTitle = "Mutator Description";

    bShowProfileLabels=false

}
class gbx_MenuOptions extends gbx_MenuLayoutScreen;

var string						strOld1PProfile;
var bool						bDone;
var bool						bSettingsChanged;
var bool						bSwappedProfiles;
var int							oldControllerIndex;
var int							EditPlayerIndex;
var int							EditControllerIndex;

var WargamePlayerController		EditPlayerController;
var WargamePlayerInput			EditPlayerInput;

var localized string			strSavingProfile;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	OnOpen = OptionsOpen;
	OnClose = OptionsClose;
	OnBButtonEvent = OnBButton;
}

event HandleParameters(string Param1, string Param2)
{
	Super.HandleParameters(Param1, Param2);
	
	if (Param1 != "")
	{
		PagePlayerIndex = int(Param1);
		EditPlayerIndex = PagePlayerIndex;
	}

	if (PagePlayerIndex == -1)
	{
		EditControllerIndex = Controller.ControllerId;
		PagePlayerIndex = 0;
		EditPlayerIndex = 0;

		oldControllerIndex = Controller.GetControllerIndexForPlayer(PagePlayerIndex);
		Controller.BindPlayerToController(PagePlayerIndex, EditControllerIndex);
	}
	else
	{
		EditControllerIndex = Controller.GetControllerIndexForPlayer(PagePlayerIndex);
	}

	// disable the live menu.
	if (!class'gbx_OptionsLive'.static.ShouldEnableMenu(self, EditPlayerIndex))
	{
		MyComponents[4].Hide();
		DoComponentLayout();
	}

	SwapProfiles();
}

function bool OnComponentActivate(int button, GUIComponent Sender)
{
	switch (button)
	{
		case 0:	// Controls
			return Controller.OpenMenu("GUI.gbx_OptionsControllerConfig"); break;

		case 1:	// Controller Options
			return Controller.OpenMenu("GUI.gbx_OptionsController"); break;

		case 2:	// Audio Options
			return Controller.OpenMenu("GUI.gbx_OptionsAudio"); break;

//		case 3:	// Video Options
//			return Controller.OpenMenu("GUI.gbx_OptionsVideo"); break;

		case 3: // Game Options
			return Controller.OpenMenu("GUI.gbx_OptionsGame"); break;

		case 4: // Xbox Live
			return Controller.OpenMenu("GUI.gbx_OptionsLive"); break;
	}

	return false;
}

function RestoreProfiles()
{
	if (strOld1PProfile != "")//((PagePlayerIndex != 0) && (strOld1PProfile != ""))
	{
		// switch the folgers crystals back
		class'gbx_ProfileManager'.Static.SetProfileForController(self, 0, strOld1PProfile, true);
		GUILog("gbx_MenuOptions: restoring " $strOld1PProfile $" as profile 0");
	}
}

function bool ShouldSwapProfiles()
{
	return Controller.GetPlayerControllerForPlayer(EditPlayerIndex) == None;
}

function SwapProfiles()
{
	local gbx_ScreenExtendedWork dlg;

	if (ShouldSwapProfiles())//(PagePlayerIndex != 0) && class'gbx_ProfileManager'.Static.ControllerProfileExists(self,PagePlayerIndex))
	{
		if (class'gbx_ProfileManager'.Static.GetProfileForController(self, 0) != class'gbx_ProfileManager'.Static.GetProfileForController(self, 1))
		{
			dlg = LaunchWorkDialog(Controller, class'gbx_ProfileManager'.Default.StringLoadingProfileData);
			dlg.DoWork = Work_SwitchingProfiles;
			return;
		}
	}

	GetEditObjects();
}

function OptionsOpen()
{
	if (bDone)
	{
		Controller.CloseMenu(false);
	}
}

function OptionsClose(optional Bool bCancelled)
{
	if (oldControllerIndex != -2)
		Controller.BindPlayerToController(PagePlayerIndex, oldControllerIndex);

	EditPlayerController = None;
	EditPlayerInput = None;
}

function OnBButton()
{
	local gbx_ScreenExtendedWork dlg;

	if (bSettingsChanged)
	{
		bDone = true;
		Controller.PlayClickSound(EClickSound.CS_Back);

		dlg = LaunchWorkDialog(Controller, strSavingProfile,, 3.0); //DLEVY changed time from 2.0 for bug #8837
		dlg.DoWork = Work_SavingProfiles;
	}
	else
	{
		RestoreProfiles();
		BaseOnBButton();
	}
}

function bool Work_SwitchingProfiles()
{
	strOld1PProfile = class'gbx_ProfileManager'.Static.GetProfileForController(self, 0);
	class'gbx_ProfileManager'.Static.SetProfileForController(self, 0, class'gbx_ProfileManager'.Static.GetProfileForController(self, PagePlayerIndex), true);

	GUILog("gbx_MenuOptions: replacing " $strOld1PProfile $" with " $ class'gbx_ProfileManager'.Static.GetProfileForController(self, 0) $" as profile 0");

	GetEditObjects();

	return true;
}

function bool Work_SavingProfiles()
{
//	EditPlayerController.SaveConfig();
//	EditPlayerInput.SaveConfig();
	ConsoleCommand("LOADSAVE PROFILE UPDATENAMED GAMEPADINDEX=" $EditPlayerController.Player.GamePadIndex @"NAME=\"" $ class'gbx_ProfileManager'.Static.GetProfileForController(self, EditPlayerIndex) $"\"");

	RestoreProfiles();
	return true;
}

function GetEditObjects()
{
	local PlayerController PC;

	PC = Controller.GetPlayerControllerForPlayer(EditPlayerIndex);
	if (PC == None)
	{
		PC = PlayerOwner();
	}

	EditPlayerController = WargamePlayerController(PC);
	EditPlayerInput = WargamePlayerInput(EditPlayerController.GetPlayerInput());

	GUILog("Editing Player=" $EditPlayerIndex $", Controller=" $EditControllerIndex @":" @EditPlayerController @"," @EditPlayerInput);
}

static function PreloadMenu(GUIController C)
{
	Super.PreloadMenu(C);

	C.PreloadMenu("GUI.gbx_OptionsControllerConfig");
	C.PreloadMenu("GUI.gbx_OptionsController");
	C.PreloadMenu("GUI.gbx_OptionsAudio");
	C.PreloadMenu("GUI.gbx_OptionsGame");
	C.PreloadMenu("GUI.gbx_OptionsLive");
}

defaultproperties
{
	PagePlayerIndex=-1
	EditPlayerIndex=0
	EditControllerIndex=-1
	oldControllerIndex=-2

	LayoutSpacing=0.01
	MyComponents(0)=cBlockMenuButton
	MyComponents(1)=cBlockMenuButton
	MyComponents(2)=cBlockMenuButton
	MyComponents(3)=cBlockMenuButton
	MyComponents(4)=cBlockMenuButton

	MyCaptions(0)="Controls"
	MyCaptions(1)="Controller Options"
	MyCaptions(2)="Audio/Video"
	MyCaptions(3)="Game"
	MyCaptions(4)="Xbox Live"

	ScreenTitle="Options"
	ACaption="Select"

	strSavingProfile="Saving profile..."
}
class gbx_MenuOptionsPC extends gbx_MenuLayoutScreen;

var string						strOld1PProfile;
var bool						bDone;
var bool						bSettingsChanged;
var bool						bSwappedProfiles;
var int							oldControllerIndex;
var int							EditPlayerIndex;
var int							EditControllerIndex;

var WargamePlayerController		EditPlayerController;
var WargamePlayerInput			EditPlayerInput;

var localized string			strSavingProfile;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	OnOpen = OptionsOpen;
	OnClose = OptionsClose;
	OnBButtonEvent = OnBButton;
}

event HandleParameters(string Param1, string Param2)
{
	Super.HandleParameters(Param1, Param2);
	
	if (Param1 != "")
	{
		PagePlayerIndex = int(Param1);
		EditPlayerIndex = PagePlayerIndex;
	}

	if (PagePlayerIndex == -1)
	{
		EditControllerIndex = Controller.ControllerId;
		PagePlayerIndex = 0;
		EditPlayerIndex = 0;

		oldControllerIndex = Controller.GetControllerIndexForPlayer(PagePlayerIndex);
		Controller.BindPlayerToController(PagePlayerIndex, EditControllerIndex);
	}
	else
	{
		EditControllerIndex = Controller.GetControllerIndexForPlayer(PagePlayerIndex);
	}

	if (((PlayerOwner().Level.NetMode != NM_Standalone) && (PlayerOwner().GameReplicationInfo.GameType == GT_Multiplayer))
		|| ((PlayerOwner().Level.NetMode == NM_Standalone) && (PlayerOwner().Level.DifficultyManager.GetDifficulty() == DIFF_Authentic)))
	{
		MyComponents[5].EnableControl(false);
	}

	hbtnA.EnableControl(false);  //NAC Disable the 'Select' component.  It has no use for PC
	DoComponentLayout();

	GetEditObjects();
}

function bool OnComponentActivate(int button, GUIComponent Sender)
{
	switch (button)
	{
		case 0:	// Control Options
			return Controller.OpenMenu("GUI.gbx_OptionsControlsPC"); break;

		case 1:	// Input Options
			return Controller.OpenMenu("GUI.gbx_OptionsInputPC"); break;

		case 2:	// Audio Options
			return Controller.OpenMenu("GUI.gbx_OptionsAudioPC"); break;

		case 3:	// Video Options
			return Controller.OpenMenu("GUI.gbx_OptionsVideoPC"); break;

		case 4: // Performance Options
			return Controller.OpenMenu("GUI.gbx_OptionsPerformancePC"); break;

		case 5: // Game Options
			return Controller.OpenMenu("GUI.gbx_OptionsGame"); break;
	}

	return false;
}

function OptionsOpen()
{
	if (bDone)
	{
		Controller.CloseMenu(false);
	}
}

function OptionsClose(optional Bool bCancelled)
{
	if (oldControllerIndex != -2)
		Controller.BindPlayerToController(PagePlayerIndex, oldControllerIndex);

	EditPlayerController = None;
	EditPlayerInput = None;
}

function OnBButton()
{
	local gbx_ScreenExtendedWork dlg;

	if (bSettingsChanged)
	{
		bDone = true;
		Controller.PlayClickSound(EClickSound.CS_Back);

		dlg = LaunchWorkDialog(Controller, strSavingProfile,, 3.0); //DLEVY changed time from 2.0 for bug #8837
		dlg.DoWork = Work_SavingProfiles;
	}
	else
	{
		BaseOnBButton();
	}
}

function bool Work_SwitchingProfiles()
{
	strOld1PProfile = class'gbx_ProfileManager'.Static.GetProfileForController(self, 0);
	class'gbx_ProfileManager'.Static.SetProfileForController(self, 0, class'gbx_ProfileManager'.Static.GetProfileForController(self, PagePlayerIndex), true);

	GUILog("gbx_MenuOptions: replacing " $strOld1PProfile $" with " $ class'gbx_ProfileManager'.Static.GetProfileForController(self, 0) $" as profile 0");

	GetEditObjects();

	return true;
}

function bool Work_SavingProfiles()
{
	ConsoleCommand("LOADSAVE PROFILE UPDATENAMED GAMEPADINDEX=" $EditPlayerController.Player.GamePadIndex @"NAME=\"" $ class'gbx_ProfileManager'.Static.GetProfileForController(self, EditPlayerIndex) $"\"");

	return true;
}

function GetEditObjects()
{
	local PlayerController PC;

	PC = Controller.GetPlayerControllerForPlayer(EditPlayerIndex);
	if (PC == None)
	{
		PC = PlayerOwner();
	}

	EditPlayerController = WargamePlayerController(PC);
	EditPlayerInput = WargamePlayerInput(EditPlayerController.GetPlayerInput());

	GUILog("Editing Player=" $EditPlayerIndex $", Controller=" $EditControllerIndex @":" @EditPlayerController @"," @EditPlayerInput);
}

static function PreloadMenu(GUIController C)
{
	Super.PreloadMenu(C);

	C.PreloadMenu("GUI.gbx_OptionsControlsPC");
	C.PreloadMenu("GUI.gbx_OptionsInputPC");
	C.PreloadMenu("GUI.gbx_OptionsAudioPC");
	C.PreloadMenu("GUI.gbx_OptionsVideoPC");
	C.PreloadMenu("GUI.gbx_OptionsPerformancePC");
	C.PreloadMenu("GUI.gbx_OptionsGame");

}

defaultproperties
{
	PagePlayerIndex=-1
	EditPlayerIndex=0
	EditControllerIndex=-1
	oldControllerIndex=-2

	LayoutSpacing=0.01
	MyComponents(0)=cBlockMenuButton
	MyComponents(1)=cBlockMenuButton
	MyComponents(2)=cBlockMenuButton
	MyComponents(3)=cBlockMenuButton
	MyComponents(4)=cBlockMenuButton
	MyComponents(5)=cBlockMenuButton

	MyCaptions(0)="Controls"
	MyCaptions(1)="Input Options"
	MyCaptions(2)="Audio"
	MyCaptions(3)="Video"
	MyCaptions(4)="Performance"
	MyCaptions(5)="Game Options"

	ScreenTitle="Options"
	ACaption="Select"

	strSavingProfile="Saving profile..."
}
class gbx_MenuSkirmish extends gbx_MenuLayoutScreen;

var bool						bChoosing2PProfile;
var bool						bNaggedPlayer;

var localized string			StringPromtSkirmish;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);
	
	if(Controller.bIsDemoVersion || Controller.bIsPreviewVersion)
		MyComponents[1].EnableControl( false );
	
	DisableSelectAButton();
}

function bool OpenPromptAnswer(string answer)
{
	local GUIController C;
	if (answer ~= "CONTINUE")
	{
		return true;
	}
	else
	{
		C = Controller;
		C.CloseMenu(false);
		C.CloseMenu(false);
		return false;
	}
}

event HandleParameters(string Param1, string Param2)
{
	local gbx_ScreenQuestion dlg;
	Super.HandleParameters(Param1, Param2);

	if (Param1 != "")
	{
		// if we're here, they've already played skirmish... no sense nagging them again.
		default.bNaggedPlayer = true;

		if (Param1 == "UBICOM")
		{
			if (class'GameService.GameService'.Static.IsOnline())
				Controller.OpenMenu("GUI.gbx_UbiWelcome", "SKIRMISH");
		}
		else if (Param1 == "LANPLAY")
		{
    		Controller.OpenMenu("GUI.gbx_BrowseMatchLanPC", "SKIRMISH");
		}
	}
	else if (!default.bNaggedPlayer)
	{
		if (!class'gbx_MenUMain'.default.bCompletedTraining)
		{
			default.bNaggedPlayer = true;

			dlg = LaunchQuestionDialog(Controller, StringPromtSkirmish, "CONTINUEBACK AREYOUSURE");
			dlg.OnAnswer = OpenPromptAnswer;
		}
	}
}

function bool OnComponentActivate(int button, GUIComponent Sender)
{
	switch (button)
	{
		case 0:	// solo
			Controller.OpenMenu("GUI.gbx_SkirmishLobbyServerOffline");
			return true;

		case 1:	// Ubi.com
			if (class'GameService.GameService'.Static.IsOnline())
				Controller.OpenMenu("GUI.gbx_UbiWelcome", "SKIRMISH");
			else
			    Controller.OpenMenu("GUI.gbx_UbiPatchScreen", "SKIRMISH");

			return true;

		case 2:	// LAN
			Controller.OpenMenu("GUI.gbx_BrowseMatchLanPC", "SKIRMISH");
			return true;
	}

	return false;
}

static function PreloadMenu(GUIController C)
{
	Super.PreloadMenu(C);

	C.PreloadMenu("GUI.gbx_SkirmishLobbyServerOffline");
	C.PreloadMenu("GUI.gbx_UbiPatchScreen");
	C.PreloadMenu("GUI.gbx_UbiWelcome");
	C.PreloadMenu("GUI.gbx_BrowseMatchLanPC");
}

defaultproperties
{
	LayoutSpacing=0.01
	MyComponents(0)=cBlockMenuButton
	MyComponents(1)=cBlockMenuButton
	MyComponents(2)=cBlockMenuButton

	MyCaptions(0)="Solo Play"
	MyCaptions(1)="Play It on Ubi.com"
	MyCaptions(2)="LAN Play"

	ScreenTitle="Skirmish"
	ACaption="Select"
	StringPromtSkirmish="You are about to play bonus combat challenges not intended for new players.  You haven't completed the training included in the Story."

	bPortLockedOnly=true
}
class gbx_MenuSP extends gbx_ScreenTimeline;

var automated GUILabel						staticBackground;
var automated GUILabel						lblChapterName;
var automated GUIImage						imgChapter;
var automated GUIScrollTextBox				txtChapterDescBox;

var color									colImgDisabled;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	txtChapterDescBox.MyScrollText.SetStyle("MenuOptionLabel");
	txtChapterDescBox.SetContent("");
	OnAButtonEvent = OnChooseChapter;
	OnYButtonEvent = OpenScenario;//On button Event Call for new CustomMaps button JER
	OnXButtonEvent = OnMutatorMenu; // rss: added for modification of MutatorList for sp missions
	imgChapter.Image = Controller.GUITexturePool.AllocRenderMaterial();

	Timeline.OnChapterIconDblClicked = ScreenOnChapterIconDblClicked;

	if(Controller.bIsDemoVersion || Controller.bIsPreviewVersion)
	{
		SetupYButton();
		SetupXButton();
	}
}

function OpenScenario()//OnButtonEvent function   JER
{
    Controller.PlayClickSound(EClickSound.CS_Click);
    Controller.OpenMenu("GUI.gbx_CustomMapScreen");
}

function OnMutatorMenu()
{
	Controller.PlayClickSound(EClickSound.CS_Click);
    Controller.OpenMenu("GUI.gbx_MenuMutator");
}

function ScreenOnChapterIconDblClicked(int Index)
{
	if (hbtnA.bVisible)
	{
		OnChooseChapter();
	}
}

function ScreenOnClose(optional Bool bCancelled)
{
	local int i;

	Controller.GUITexturePool.FreeRenderMaterial(imgChapter.Image);
	for (i=0; i<PlayerOwner().Level.MissionManager.Missions.Length; i++)
	{
		Controller.GUITexturePool.MarkAsUnneeded(PlayerOwner().Level.MissionManager.GetMissionImage(i));
	}

	Super.ScreenOnClose(bCancelled);
}

function OnChooseChapter()
{
	if (!IsChapterEnabled(CurrentSelection))
		return;

	Controller.PlayClickSound(EClickSound.CS_Click);

	Controller.OpenMenu("GUI.gbx_SPChooseDifficulty", PlayerOwner().Level.MissionManager.GetMissionName(CurrentSelection));
}

function ChapterListOnChange(GUIComponent Sender)
{
	Super.ChapterListOnChange(Sender);

	GUILog("ChapterListOnChange txtChapterDescBox=" $txtChapterDescBox);
	lblChapterName.SetCaption(PlayerOwner().Level.MissionManager.GetMissionTitle(CurrentSelection));
	if (!Controller.GUITexturePool.GetTexture(imgChapter.Image, PlayerOwner().Level.MissionManager.GetMissionImage(CurrentSelection)))
		Controller.GUITexturePool.GetTexture(imgChapter.Image, "t_interface_mb.eib_chaper_preview.sp_unknown");
	txtChapterDescBox.SetContent( PlayerOwner().Level.MissionManager.GetMissionCaption(CurrentSelection) );

	if (IsChapterEnabled(CurrentSelection))
	{
		imgChapter.ImageColor = default.imgChapter.ImageColor;
		SetupAButton(ACaption);
	}
	else
	{
		imgChapter.ImageColor = colImgDisabled;
		SetupAButton();
	}
}

function bool ScreenOnDrawPre(Canvas C)
{
	local float sX, sY, X;

	C.DrawColor = Controller.BackgroundBoxColor;
	staticBackground.DrawComponentBackground(C);

	X = staticBackground.ActualLeft();
	C.DrawColor = Controller.RedLineColor;
	DrawBackground(C, X, staticBackground.ActualTop(), C.ClipX - staticBackground.ActualLeft() + 10, 5*Controller.CanvasScaleY);
	DrawBackground(C, X, staticBackground.ActualTop(), 5*Controller.CanvasScaleY, staticBackground.ActualHeight());

	Timeline.GetSelectionCursorPos(sX, sY);

	class'GUI.gbx_ScreenABXY'.Static.DrawTheThinRedLine(Controller, C, X, sY + 3*Controller.CanvasScaleY, sX + 3*Controller.CanvasAspectScale - X);

	return Super.ScreenOnDrawPre(C);	// still do the other stuff
}

function bool ScreenOnDraw(Canvas C)
{
	Super.ScreenOnDraw(C);	// still do the other stuff

	
	switch(PlayerOwner().Level.MissionManager.GetMissionStyle(CurrentSelection))
	{
	case ECIS_Disabled:
	case ECIS_Film:
		return false;
	}

	// regular icons draw the back all the time.  the medal shows when you win it
	if (GotMedal(0))
		DrawMedalIcons(C, MedalIconPositions[0], MedalIcons[0], MedalBracketIcons[0]);
	else
		DrawMedalIcons(C, MedalIconPositions[0], nilIcon, MedalBracketIcons[0]);

	if (GotMedal(1))
		DrawMedalIcons(C, MedalIconPositions[1], MedalIcons[1], MedalBracketIcons[0]);
	else
		DrawMedalIcons(C, MedalIconPositions[1], nilIcon, MedalBracketIcons[0]);

	if (GotMedal(2))
		DrawMedalIcons(C, MedalIconPositions[2], MedalIcons[2], MedalBracketIcons[0]);
	else
		DrawMedalIcons(C, MedalIconPositions[2], nilIcon, MedalBracketIcons[0]);

	if (GotMedal(3))
		DrawMedalIcons(C, MedalIconPositions[3], MedalIcons[3], MedalBracketIcons[0]);
	else
		DrawMedalIcons(C, MedalIconPositions[3], nilIcon, MedalBracketIcons[0]);

	// authentic, medal of honor only show when you can achieve them
	if (bAuthenticUnlocked)
	{
		// medal of honor shows up when you win them all.  show background if you win the first 3
		if (GotMedal(0) && GotMedal(1) && GotMedal(2) && GotMedal(3))
			DrawMedalIcons(C, MedalIconPositions[4], MedalIcons[4], MedalBracketIcons[1]);
		else
			DrawMedalIcons(C, MedalIconPositions[4], nilIcon, MedalBracketIcons[1]);
	}

	return false;
}


static function PreloadMenu(GUIController C)
{
	local int i;
	local Texture t;
	Super.PreloadMenu(C);

	for (i=0; i<C.ViewportOwner.Actor.Level.MissionManager.Missions.Length; i++)
	{
		t = Texture(C.DynamicLoadObject(C.ViewportOwner.Actor.Level.MissionManager.GetMissionImage(i),class'Texture'));
	}

}

defaultproperties
{
	PagePlayerIndex=0
	ScreenTitle="Chapters"
	ACaption="Play Chapter"
	YCaption="Custom Map"  //Button Caption for Custom Map Screen  JER
	XCaption="Mutators" // rss: added for mutator support

	Begin Object Class=gbx_GameTimeline Name=cgametimeline
		bNonInteractive=false
		bCycleUnplayedChapters=false
	End Object
	Timeline=cgametimeline

	// static background box thingy
	Begin Object Class=GUILabel Name=cStaticBackground
		StyleName="TextLabel"
		TextAlign=TXTA_Left
		DrawMenuState=1
		WinWidth=0.925
		WinHeight=0.38
		WinLeft=0.0375
		WinTop=0.21
		bNeverFocus=true
		bMultiLine=true
		bTransparent=true
	End Object
	staticBackground=cStaticBackground

	// map image
	Begin Object Class=GUIImage Name=cimgChapter
//		Image=Texture't_interface_mb.chaper_preview.sp_hill30_intro'
		ImageColor=(R=255,G=255,B=255,A=255)
		ImageStyle=ISTY_Scaled
		WinLeft=0.48
		WinTop=0.17
		WinHeight=0.41
		WinWidth=0.46875
		bBoundToParent=true
		bScaleToParent=true
		RenderWeight=0.05
	End Object
	imgChapter=cimgChapter

	// chapter name
	Begin Object Class=GUILabel Name=clblChapter
		StyleName="MenuOptionCaption"
		DrawMenuState=2
		TextAlign=TXTA_Left
		bAcceptsInput=false
		bTabStop=false
		bDrawToFit=true
		WinWidth=0.43625
		WinHeight=0.0475
		WinLeft=0.04375
		WinTop=0.16
	End Object
	lblChapterName=clblChapter

	// chapter description
	Begin Object Class=GUIScrollTextBox Name=ctxtChapterDescBox
		WinWidth=0.428
		WinHeight=0.36
		WinLeft=0.06
		WinTop=0.22
		RenderWeight=0.45
		InitialDelay=0.0
		CharDelay=0.075
		EOLDelay=0.075
		bNoTeletype=true
		bNoTeletypeCursor=true
	End Object
	txtChapterDescBox=ctxtChapterDescBox


	// medals ------------------------------------------------------------------------------
	// 28x50 - 32, 45x66
	MedalIconPositions(0)=(fL=0.875,fT=0.4395833,fW=0.04375,fH=0.104167)
	MedalIconPositions(1)=(fL=0.825,fT=0.4395833,fW=0.04375,fH=0.104167)
	MedalIconPositions(2)=(fL=0.775,fT=0.4395833,fW=0.04375,fH=0.104167)
	MedalIconPositions(3)=(fL=0.725,fT=0.4395833,fW=0.04375,fH=0.104167)
	MedalIconPositions(4)=(fL=0.505,fT=0.40875,fW=0.0703125,fH=0.1375)

	colImgDisabled=(R=80,G=80,B=80,A=255)
}
class gbx_MenuStory extends gbx_MenuLayoutScreen;

var localized string					StringStartGame;

// cache some goodies for the current profile
var int LastMission, LastDifficulty, SaveMissionDifficulty;
var string SaveMissionName;
var bool bProfileCached;


function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	if (((default.LastMission == -1) || (PlayerOwner().Level.MissionManager.GetContinueMission(default.LastMission) == "")) && (default.SaveMissionName == ""))
	{
		MyComponents[0].SetCaption(StringStartGame);
	}
	else
	{
		MyComponents[0].SetCaption(MyCaptions[0]);
	}
	
	DisableSelectAButton();
}

function bool OnComponentActivate(int button, GUIComponent Sender)
{
	switch (button)
	{
		case 0:	// continue/begin game
			OnContinue();
			return true;

		case 1:	// chapters
			Controller.BindPlayerToController(0, Controller.ControllerId);
			Controller.OpenMenu("GUI.gbx_MenuSP"); return true; break;
			return true;
	}

	return false;
}

function OnContinue()
{
	local GUIController C;
	local string S;

	if (!default.bProfileCached)
	{
		GUILog("OnContinue - Unknown profile!");

		Controller.OpenMenu("GUI.gbx_ProfileManager", "0");
		MyComponents[0].EnableControl( false );
		return;
	}
	else
	{
		Controller.BindPlayerToController(0, Controller.ControllerId);

		if (default.SaveMissionName != "")
		{
			// apply the controllers
			Controller.ApplyControllersToViewports();

                        if (Controller.bIsDemoVersion)
                        {
			     if (default.SaveMissionName == "D08_1030_CLOSEQUARTERS")
			          ConsoleCommand("DEMO_LEVEL_START_CQ");
			     else if (default.SaveMissionName == "D15_1130_BOOKENDS")
			          ConsoleCommand("DEMO_LEVEL_START_INTRO");
                        }
			LoadSPMap(default.SaveMissionName, default.SaveMissionDifficulty );
			Controller.CloseAll(false);
		}
		else
		{
			GUILog("OnContinue - no savegamee exists, choosing continue map.");
			GUILog("LastMission = " $default.LastMission);

			S = PlayerOwner().Level.MissionManager.GetContinueMission(default.LastMission);
			if ((default.LastMission == -1) || (S == ""))	// haven't started the game yet or continuing to another demo map
			{
				// start from the top, after asking for difficulty
				Controller.OpenMenu("GUI.gbx_SPChooseDifficulty");
			}
			else
			{
				// apply the controllers
				Controller.ApplyControllersToViewports();

				C = Controller;

                                if (C.bIsDemoVersion)
                                {
				     if (S == "D08_1030_CLOSEQUARTERS")
				          ConsoleCommand("DEMO_LEVEL_START_CQ");
				     else if (S == "D15_1130_BOOKENDS")
				          ConsoleCommand("DEMO_LEVEL_START_INTRO");
                                }
				LoadSPMap(S, default.LastDifficulty );
				C.CloseAll(false);
			}
		}
	}
}


static function CacheGameProfileInfo(GameProfile profile)
{
	if (profile == None)
	{
		default.LastMission = -1;
		default.LastDifficulty = -1;
		default.SaveMissionDifficulty = -1;
		default.SaveMissionName = "";
		default.bProfileCached = false;
	}
	else
	{
		default.LastMission = profile.LastMissionCompleted;
		default.LastDifficulty = profile.LastDifficultyCompleted;
		default.SaveMissionName = profile.SaveMissionName;
		default.SaveMissionDifficulty = profile.SaveMissionDifficulty;
		default.bProfileCached = true;
	}
}

static function PreloadMenu(GUIController C)
{
	Super.PreloadMenu(C);

	C.PreloadMenu("GUI.gbx_MenuSP");
	C.PreloadMenu("GUI.gbx_SPChooseDifficulty");
}

defaultproperties
{
	LayoutSpacing=0.01
	MyComponents(0)=cBlockMenuButton
	MyComponents(1)=cBlockMenuButton

	MyCaptions(0)="Continue"
	MyCaptions(1)="Chapters"

	ScreenTitle="Story"
	ACaption="Select"
	StringStartGame="Begin Game"
}

class gbx_MissionChooser extends gbx_MenuLayoutScreen;

var moSpinListControl				spnMissionSelect;
var automated gbx_MissionDisplay	MissionDisplay;
var localized string				strMutator;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	spnMissionSelect = moSpinListControl(MyComponents[0]);
	spnMissionSelect.OnChange = MissionChanged;
	FillMissionList(spnMissionSelect, true);

	SetupXButton(strMutator);
    OnXButtonEvent = OpenMutatorMenu;

	// TODO PARIS REMOVEME
	if (PlayerOwner().bIsDemo)
	{
		spnMissionSelect.SetIndex(0);
		spnMissionSelect.EnableControl(false);
	}

	if(Controller.bIsDemoVersion || Controller.bIsPreviewVersion)
		SetupXButton();
}

function OpenMutatorMenu()
{
    Controller.OpenMenu("GUI.gbx_MenuMutator");
}

static function FillMissionList(moSpinListControl spinctrl, optional bool bClear)
{
	local int i, c;
	if (bClear)
		spinctrl.Clear();

	c = class'Gameplay.gbxMPMissionList'.Static.GetMissionCount();
	for (i=0; i<c; i++)
	{
		if (class'Gameplay.gbxMPMissionList'.Static.GetGameType(i) == MGT_MP)
			spinctrl.Add(class'Gameplay.gbxMPMissionList'.Static.GetMissionName(i, true),, class'Gameplay.gbxMPMissionList'.Static.GetMap(i));
	}
}

function MissionChanged(GUIComponent Sender)
{
	MissionDisplay.SetMission( spnMissionSelect.GetIndex() );
}

function ChooseMap(string mapFileName)
{
	local int index;
	index = class'Gameplay.gbxMPMissionList'.Static.FindMapIndex( mapFileName );
	if (index != -1)
		spnMissionSelect.SetIndex(index);
}

static function PreloadMenu(GUIController C)
{
	local int i, count;
	local Texture t;
	Super.PreloadMenu(C);

	count = class'Gameplay.gbxMPMissionList'.Static.GetMissionCount();
	for (i=0; i<count; i++)
	{
		t = Texture(C.DynamicLoadObject(class'Gameplay.gbxMPMissionList'.static.GetMissionImageName(i),class'Texture'));
	}
}

defaultproperties
{
	LayoutPivotPoint=0.18
	LayoutSpacing=0.02
	LayoutPivotStyle=LA_Left_Top

	strMutator="Mutators"

	Begin Object Class=gbx_MissionDisplay Name=cMissionDisplay
		WinWidth=0.450
		WinHeight=0.580000
		WinLeft=0.500000
	End Object
	MissionDisplay=cMissionDisplay

	MyComponents(0)=cSpinMenuOptionV
	MyCaptions(0)="Mission"
}


class gbx_MissionDisplay extends GUIPanel;

var Automated GUIScrollTextBox		txtDescription;
var Automated GUILabel				lblMissionTitle;
var Automated GUIImage				imgMission;
var int								CurrentMissionIndex;
var int								CurrentGameType;		// -1=MP : other = WargameSkirmish.ESkirmishGameType

var bool							bDisplayMissionName;
var bool							bDisplayMissingInfo;

var localized string				StringDefaultGameTypeBriefings[4];
var localized string				StringMissingMap;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	txtDescription.SetContent("");
	txtDescription.MyScrollText.bTransparent = true;
	txtDescription.MyScrollText.bAcceptsInput = false;
	txtDescription.MyScrollText.bNeverFocus = true;

	imgMission.Image = Controller.GUITexturePool.AllocRenderMaterial();
	SetMission(0);
}

event Free() 			// This control is no longer needed
{
	local int i;

	Controller.GUITexturePool.FreeRenderMaterial(imgMission.Image);
	for (i=-1; i<class'Gameplay.gbxMPMissionList'.static.GetMissionCount(); i++)
	{
		Controller.GUITexturePool.MarkAsUnneeded(class'Gameplay.gbxMPMissionList'.static.GetMissionImageName(i));
	}

	Super.Free();
}

event Show()
{
	Super.Show();

	if (!bDisplayMissionName)
		lblMissionTitle.Hide();
}

function SetGameType(int newGameType)
{
	CurrentGameType = newGametype;
	SetDescription();
}

function SetMissionFromMissionName(string mapName)
{
	SetMission (class'gbxMPMissionList'.static.FindMapIndex(mapName) );
}

function SetMission(int missionIndex)
{
	if (CurrentMissionIndex == missionIndex)
		return;

	CurrentMissionIndex = missionIndex;

	if (CurrentMissionIndex == -1)
	{
		Controller.GUITexturePool.GetTexture(imgMission.Image, class'Gameplay.gbxMPMissionList'.static.GetMissionImageName(-1));

		if (bDisplayMissingInfo)
		{
			txtDescription.SetContent(StringMissingMap);
			txtDescription.Show();
		}
		else
		{
			txtDescription.SetContent("");
			txtDescription.Hide();
		}

		lblMissionTitle.Hide();
	}
	else
	{
		lblMissionTitle.Show();
		imgMission.Show();
		txtDescription.Show();

		lblMissionTitle.SetCaption(class'Gameplay.gbxMPMissionList'.static.GetMissionName(CurrentMissionIndex, true));
		SetDescription();

		Controller.GUITexturePool.GetTexture(imgMission.Image, class'Gameplay.gbxMPMissionList'.static.GetMissionImageName(CurrentMissionIndex));
	}

	if (!bDisplayMissionName)
		lblMissionTitle.Hide();
}

function SetDescription()
{
	local string S;

	switch(CurrentGameType)
	{
	case 0://ESkirmishGameType.SGT_Objective:
		S = class'Gameplay.gbxMPMissionList'.static.GetBriefing(CurrentMissionIndex, "SKR_Objective");
		if (S == "") S = StringDefaultGameTypeBriefings[0];
		break;
	case 1://WargameSkirmish.ESkirmishGameType.SGT_TimeChallenge:
		S = class'Gameplay.gbxMPMissionList'.static.GetBriefing(CurrentMissionIndex, "SKR_Time");
		if (S == "") S = StringDefaultGameTypeBriefings[1];
		break;
	case 2://WargameSkirmish.ESkirmishGameType.SGT_Defense:
		S = class'Gameplay.gbxMPMissionList'.static.GetBriefing(CurrentMissionIndex, "SKR_Defense");
		if (S == "") S = StringDefaultGameTypeBriefings[2];
		break;
	case 3://WargameSkirmish.ESkirmishGameType.SGT_TourOfDuty:
		S = StringDefaultGameTypeBriefings[3];
		break;
	default:
		S = class'Gameplay.gbxMPMissionList'.static.GetBriefing(CurrentMissionIndex, "MP");
		break;
	}

	txtDescription.SetContent(S);
}

defaultproperties
{
	StyleName="SquareBar"
	WinWidth=0.50
	WinHeight=0.540000
	WinLeft=0.100000
	WinTop=0.1800000

	CurrentMissionIndex=-1
	CurrentGameType=-1

	Begin Object Class=GUIScrollTextBox Name=ctxtDescription
		TextAlign=TXTA_Left
		WinWidth=0.96
		WinHeight=0.54
		WinLeft=0.02
		WinTop=0.48
		InitialDelay=0.0
		CharDelay=0.05
		EOLDelay=0.05
		RepeatDelay=5.0
		bNoTeletype=false
		bAcceptsInput=false
		bTabStop=false
		bNoTeletypeCursor=true
		bNeverFocus=true
		bRepeat=true
		bNoScrollbar=true
		bNoRepeatIfUnfilled=true
		bAutoFill=true
	End Object
	txtDescription=ctxtDescription

	// mission pic
	Begin Object Class=GUIImage Name=cimgMission
		ImageColor=(R=255,G=255,B=255,A=255)
		ImageStyle=ISTY_Scaled
		ImageAlign=IMGA_Center
		WinWidth=0.94
		WinHeight=0.48
		WinLeft=0.03
		WinTop=0.02
	End Object
	imgMission=cimgMission

	// mission title
	Begin Object Class=GUILabel Name=clblMissionTitle
		StyleName="MenuOptionCaption"
		DrawMenuState=1
		TextAlign=TXTA_Center
		WinWidth=0.96
		WinHeight=0.16000
		WinLeft=0.02
		WinTop=0.02
		bNeverFocus=true
		bMultiLine=true
	End Object
	lblMissionTitle=clblMissionTitle

	bDisplayMissionName=false

	StringDefaultGameTypeBriefings(0)="Play Objective-based missions without any special combat challenges."
	StringDefaultGameTypeBriefings(1)="Eliminate all enemy forces in a limited amount of time. Time will be awarded for killing enemies; using your squads to do so will award more bonus time. There are no checkpoints."
	StringDefaultGameTypeBriefings(2)="Each wave of enemies is tougher than the last.  How many can you withstand?"
	StringDefaultGameTypeBriefings(3)="This authentic challenge is 5 missions in length, and must be completed without dying. Complete the American or German Tour to unlock the next level of difficulty."

	StringMissingMap="This map is missing or damaged.  You must download it before it can be played."
}
class gbx_MPBase extends gbx_ScreenABXY
	abstract;

var Automated GUIEditBox						editText;
var automated GUIScrollTextBox					txtChatBox;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	local int i;

	Super.InitComponent(MyController, MyOwner);

	txtChatBox.MyScrollText.SetStyle("TextLabel");
	txtChatBox.SetContent("");

	i = 0;
	hBtnA.TabOrder = i++;
	hBtnB.TabOrder = i++;
	hBtnX.TabOrder = i++;
	hBtnY.TabOrder = i++;
	editText.TabOrder = i++;
	editText.MaxWidth = 399;

	SetupChat();

	if (!PlayerOwner().Level.IsMenuMap())
		Controller.WantMusicNow();
}

static function GetPlayerList(PlayerController MyPC, out array<PlayerReplicationInfo> players, optional bool bWantRemotePlayers, optional bool bNoClear)
{
	local PlayerReplicationInfo pri;
	local GameReplicationInfo GRI;
	local PlayerController PC;
	local int i,used;
	local bool bPlayerIsLocal;

	if (!bNoClear)
		players.Length = 0;

	GRI = MyPC.GameReplicationInfo;

	for (i=0; i<GRI.PRIArray.Length; i++)
	{
		pri = GRI.PRIArray[i];
		if ( pri != None && !pri.bBot )
		{
			PC = class'gbx_MPLobbyPlayer'.static.FindPlayerControllerForPRI(MyPC, pri);
			bPlayerIsLocal = (PC != None) && (Viewport(PC.Player) != None);

			if (bWantRemotePlayers == !bPlayerIsLocal)
			{
				used = players.Length;
				players.Length = used + 1;
				players[used] = pri;
			}
		}
	}
}

function SetupPlayerNames()
{
	local array<PlayerReplicationInfo> players;
	local int i,used,iClientNum;
	local bool bIsSkirmish;

	bIsSkirmish = PlayerOwner().GameReplicationInfo.GameType == GT_Skirmish;

	used = 0;
	for (i=0; i<lblProfileName.Length; i++)
	{
		SetPlayerNameForPlayerMarkerLabel(i, -1);
	}

	GetPlayerList(PlayerOwner(), players);
	for (i=0; i<players.Length; i++)
	{
		if (!bIsSkirmish && (players[i].bIsSpectator || players[i].bWaitingPlayer || players[i].bOnlySpectator))
			iClientNum = 4;	// "4" is the "no-player/dimmed" color
		else
			iClientNum = players[i].LobbyClientNum - 1;

		SetPlayerNameForPlayerMarkerLabel(used, used, iClientNum, players[i].GetHumanReadableName(), players[i].GamerTag);
		used++;
	}


	GetPlayerList(PlayerOwner(), players, true);
	for (i=0; i<players.Length; i++)
	{
		if (!bIsSkirmish && (players[i].bIsSpectator || players[i].bWaitingPlayer || players[i].bOnlySpectator))
			iClientNum = 4;	// "4" is the "no-player/dimmed" color
		else
			iClientNum = players[i].LobbyClientNum - 1;

		SetPlayerNameForPlayerMarkerLabel(used, -1, iClientNum, players[i].GetHumanReadableName(), players[i].GamerTag);
		used++;
	}
}

function SetPlayerNameForPlayerMarkerLabel(int labelIndex, int localPlayerIndex, optional int clientIndex, optional string PlayerName, optional string GamerTag)
{
//	GUILog("SetPlayerNameForPlayerMarkerLabel label=" $labelIndex $",player=" $localPlayerIndex $",client=" $clientIndex $",name=" $PlayerName $",gamertag=" $GamerTag);
	if (PlayerName == "")
	{
		SetupPlayerStatusInfo(labelIndex, localPlayerIndex, class'gbx_MPLobby'.Default.StrSlotEmpty);
		lblProfileName[labelIndex].TextColor = class'gbxMP.WargameMultiplayerScoreboard'.default.PlayerColors[4];
	}
	else
	{
		SetupPlayerStatusInfo(labelIndex, localPlayerIndex, PlayerName, GamerTag);

		lblProfileName[labelIndex].TextColor = class'gbxMP.WargameMultiplayerScoreboard'.default.PlayerColors[clientIndex];
		lblProfileName[labelIndex].TextColor.A = 255;
	}
}

function string GetPlayerStatusCaption(int inPlayerIndex)
{
	local string StoredUbiComUserName;

	if (ShouldShowControllerInfo(inPlayerIndex))
	{	
		if (PlayerStatus[inPlayerIndex].MyPlayerIndex == -1)
		{
			return StringProfile @ PlayerStatus[inPlayerIndex].MyDisplayName;
		}

		if (Controller.bIsConsole)
		{
		    if ( (PlayerStatusDisplayStyle == CD_Signin) || ((PlayerStatusDisplayStyle == CD_Default) 
		            && (class'gbx_ScreenABXY'.default.DefPlayerStatusDisplayStyle == CD_Signin))           )
		    {
			    return GetSigninCaption(inPlayerIndex);
		    }
        }

		//PlayerMarkers[i].MyPlayer)

        if (class'GameService.GameService'.static.IsInLobby())
        {
            class'GameService.GameService'.static.GetUserName(StoredUbiComUserName);
            return StringProfile @ StoredUbiComUserName;
        }
        else
    		return StringProfile @ class'gbx_ProfileManager'.Static.GetProfileForController(self, inPlayerIndex);
	}

	return "";
}


function bool ScreenOnDrawPre(Canvas C)
{
	if (!Controller.bIsConsole)
	{
		if (bVisible)
		{
			DrawBars(C, 0.10);

			if (editText.bVisible)
			{
				if (editText.bHasFocus)
					C.SetDrawColor(180,180,160,255);
				else
					C.SetDrawColor(100,100,80,255);

				editText.DrawComponentBackground(C);
			}
		}

		return false;
	}
	else
	{
		return Super.ScreenOnDrawPre(C);
	}
}

function EnableChat(bool bEnable)
{
	editText.EnableControl(bEnable);
	editText.SetVisibility(bEnable);
	txtChatBox.EnableControl(bEnable);
	txtChatBox.SetVisibility(bEnable);
}

function ProcessChatCommand(string text)
{
	GUILog("ProcessChatCommand: " $text);
	PlayerOwner().ConsoleCommand("say " $ text);
}

function SetupChat()
{
	local array<string> Messages;
	local int i;

	// Pre-populate the chat box with any messages still in the HUD chat queue. This allows users to continue conversations in debriefing.
	PlayerOwner().myHud.GetConsoleMessagesOldestFirst(Messages);

	for (i = 0; i < Messages.Length; i++)
	{
		// The HUD messages are pre-formatted to include player names (and possibly teams) so there is no need to re-format them here.
		// Instead just add them manually to the list box.
		txtChatBox.AddText(Messages[i]);
	}
}

function OnChat(PlayerReplicationInfo ChattingPRI, string Message)
{
	local string FormattedMessage;

	FormattedMessage = class'SayMessagePlus'.static.AssembleString(PlayerOwner().myHud, 0, ChattingPRI, Message);
	txtChatBox.AddText(FormattedMessage);
}

function bool SAB_KeyEvent(out byte Key,out byte State,float delta)
{
	if (editText.bHasfocus)
	{
		if ((Key == 13) && (State == 1))
		{
			ProcessChatCommand(editText.GetText());
			editText.SetText("");
		}
		else if ((Key == 27) && (State == 3))	// IK_Escape, IST_Release
		{
			if (editText.GetText() == "")
				return Super.SAB_KeyEvent(Key, State, delta);
			else
				editText.SetText("");
		}

		return false;
	}

	return Super.SAB_KeyEvent(Key, State, delta);
}

defaultproperties
{
	// LAYOUT OVERRIDES NOMERGE
	lblScreenTitle=cCMB_ScreenTitle_Alt
	hbtnA=cMP_hbtnA_Alt
	hbtnB=cMP_hbtnB_Alt
	hbtnX=cMP_hbtnX_Alt
	hbtnY=cMP_hbtnY_Alt

	lblProfileName(0)=clblProfile1_Alt
	lblProfileName(1)=clblProfile2_Alt
	editText=cChatTextEntryEditBox

	Begin Object Class=GUIScrollTextBox Name=ctxtChatBox
		WinWidth=0.9
		WinHeight=0.205
		WinLeft=0.05
		WinTop=0.645
		RenderWeight=0.45
		InitialDelay=0.0
		CharDelay=0.075
		EOLDelay=0.075
		bNoTeletype=true
		bNoTeletypeCursor=true
		bVisibleWhenEmpty=true
		bTabStop=false
	End Object
	txtChatBox=ctxtChatBox
}
class gbx_MPDebriefing extends gbx_MPBase
	abstract;

var automated GUILabel lblWinner;
var automated GUILabel lblNextMission;

var int WinningTeam;
var localized string TeamNames[3];
var localized string StringNextMission;

const WINNER_ICON_SCALE = 1.75;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
    bShowOnlineIcon=class'GameService.GameService'.static.IsInLobby();
	Super.InitComponent(MyController, MyOwner);

//###+ lbouchard : LINKLOSS: Check the connection link for Ubi.com Games
    if (!IsSystemLinkGame())
		bRequireLink=true;
//###- 

	Controller.LoadPlayerControllerBindings();

	OnBButtonEvent = OnBButton;
	OnYButtonEvent = OnYButton;

	OnOpen = DebriefingOpen;
	OnClose = DebriefingClose;

//	edReason = moEditBox(MyComponents[0]);

	lblProfileName[0].bUseTextColorForStyle = true;
	lblProfileName[1].bUseTextColorForStyle = true;
	lblProfileName[2].bUseTextColorForStyle = true;
	lblProfileName[3].bUseTextColorForStyle = true;

	// TODO PARIS REMOVEME
	if (PlayerOwner().bIsDemo)
	{
		SetupBButton();
	}

	// if we're in live mode, enable the y button
	if (PlayerOwner().Level.AuthMode == AM_Live)
	{
		SetupYButton(StrPlayers);
	}

	RemapComponents();
	editText.SetFocus(None);

	SetupPlayerNames();
}

function SetupPlayerNames()
{
	Super.SetupPlayerNames();

	// get rid of the 3,4 slots if there are only 2 players
	if (PlayerOwner().GameReplicationInfo.MaxPlayers <= 2)
	{
		lblProfileName[2].Hide();
		lblProfileName[3].Hide();
	}
	else
	{
		lblProfileName[2].Show();
		lblProfileName[3].Show();
	}
}

function bool ShouldShowControllerInfo(int inPlayerIndex)
{
	return (inPlayerIndex < PlayerOwner().GameReplicationInfo.MaxPlayers);
}

function DebriefingOpen()
{
	WargameMultiplayerScoreboard(PlayerOwner().myHUD.Scoreboard).TeamBoxYOffsetPercentage = 0.15;

	SetTimer(0.15, true);
	Timer();
}

function DebriefingClose(optional Bool bCancelled)
{
	WargameMultiplayerScoreboard(PlayerOwner().myHUD.Scoreboard).TeamBoxYOffsetPercentage = WargameMultiplayerScoreboard(PlayerOwner().myHUD.Scoreboard).default.TeamBoxYOffsetPercentage;

	KillTimer();
}

function SetWinningTeamCaptions()
{
	lblWinner.SetCaption( GetWinningTeam() );
}

function Timer()
{
	if (WinningTeam == 0)
	{
		WinningTeam = GetWinningTeamIndex();
		SetWinningTeamCaptions();
	}

	if (lblNextMission != None)
		lblNextMission.SetCaption( StringNextMission $ GetNextMission() );

	SetupPlayerNames();
}

function bool ScreenOnDraw(Canvas C)
{
	local Scoreboard thescoreboard;
	thescoreboard = PlayerOwner().myHUD.Scoreboard;
	
	if (thescoreboard != None)
	{
		thescoreboard.DrawScoreboard(C, PlayerOwner().myHUD.ScaleX, PlayerOwner().myHUD.ScaleY, true);
	}

	if (Controller.bIsConsole)
	{
		DrawAttachedPlayerStatusIcon(C, 2, lblProfileName[2], false);
		DrawAttachedPlayerStatusIcon(C, 3, lblProfileName[3], true);
	}

	return Super.ScreenOnDraw(C);
}

function OnBButton()
{
	Controller.PlayClickSound(EClickSound.CS_Back);
	Controller.OpenMenu(class'GameEngine'.default.PopupMPMenuClass, "NOCLOSEALL");
}

// Y button will open the players list if in a Live game.
function OnYButton()
{
	class'gbx_LivePlayersList'.static.LaunchPlayersList(Controller, Controller.FindPlayerForControllerIndex(Controller.ControllerId));
}

function int GetWinningTeamIndex()
{
	return PlayerOwner().GameReplicationInfo.WinningTeam;
}

function string GetWinningTeam()
{
	return TeamNames[ WinningTeam ];
}

function string GetNextMission()
{
	return class'Gameplay.gbxMPMissionList'.static.FindMissionName(GetNextMapName(), true);
}

function string GetNextMapName();

function bool ScreenOnDrawPre(Canvas C)
{
	if (!Controller.bIsConsole)
	{
		if (bVisible)
		{
			DrawBars(C, 0.10);

			if (editText.bHasFocus)
				C.SetDrawColor(180,180,160,255);
			else
				C.SetDrawColor(100,100,80,255);

			editText.DrawComponentBackground(C);
		}

		return false;
	}
	else
	{
		return Super.ScreenOnDrawPre(C);
	}
}


//###+ lbouchard : LINKLOSS: Make sure we don't test the link on Open, it seems like to crashes the game
function TestLinkLiveLoss(optional bool bOpened)
{
    if (!bOpened)
    {
		Super.TestLinkLiveLoss(bOpened);
    }
}
//###

function DoLinkLoss(bool bOpened)
{
	if (!Controller.MenuIsOpen("GUI.gbx_DlgLinkLost") && !Controller.MenuIsOpen("GUI.gbx_LiveErrorMessage"))
	{
		HandleLossErrors(-2, false, true);
		if (!bOpened)
		{
			Controller.ReplaceMenu("GUI.gbx_DlgLinkLost");
		}
		else
		{
			Controller.CloseMenu(false);
		}
		bRequireLink = false;
		return;
	}
}

defaultproperties
{
	Begin Object Class=GUILabel Name=clblWinner
		StyleName="MenuOptionCaption"
		DrawMenuState=2
		TextAlign=TXTA_Center
		WinWidth=0.90
		WinHeight=0.050000// NOMERGE 0.08
		WinLeft=0.0500
		WinTop=0.09// NOMERGE 0.17
		bNeverFocus=true
		bMultiLine=true
		bDrawToFit=true
	End Object
	lblWinner=clblWinner

	Begin Object Class=GUILabel Name=clblNextMission
		StyleName="MenuOptionLabel"
		DrawMenuState=2
		TextAlign=TXTA_Center
		WinWidth=0.825
		WinHeight=0.05000
		WinLeft=0.0875000
		WinTop=0.570000// NOMERGE 0.670000
		bNeverFocus=true
	End Object

	// player name labels
	lblProfileName(2)=clblPlayerName3_Alt// NOMERGE
	lblProfileName(3)=clblPlayerName4_Alt// NOMERGE

	ScreenTitle="After Action Report"

    StringProfile="Player:"

	bAllowedAsLast=true
	bRequireFullScreen=true

	TeamNames(0) = "Mission Aborted!"
	TeamNames(1) = "Americans Win!"
	TeamNames(2) = "Germans Win!"

	StringNextMission="Next Mission : "
	bCloseNonTopMost=true
}class gbx_MPDebriefingChooseMission extends gbx_MissionChooser;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	OnAButtonEvent = OnAButton;
	SetupXButton(""); // rss: disable mid-game changes to mutators
}

function OnAButton()
{
	gbx_MPDebriefingServer(ParentPage).SetNextMapName(spnMissionSelect.GetExtra());
	BaseOnAButton();
}

event HandleParameters(string Param1, string Param2)
{
	Super.HandleParameters(Param1, Param2);

	if (Param1 != "")
	{
		ChooseMap(Param1);
	}
}

defaultproperties
{
	ACaption="Continue"
	XCaption=""
}class gbx_MPDebriefingClient extends gbx_MPDebriefing;

var moEditBox edMap;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);
/*
	edMap = moEditBox(MyComponents[0]);
	// TODO PARIS REMOVEME
	if (PlayerOwner().bIsDemo)
	{
		edMap.Hide();
	}
*/
}

function string GetNextMapName()
{
	return PlayerOwner().GameReplicationInfo.NextMapName;
}

defaultproperties
{
	lblNextMission=clblNextMission
}class gbx_MPDebriefingServer extends gbx_MPDebriefing;

var automated moSpinListControl		spnNextMission;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	OnAButtonEvent = OnAButton;
	OnXButtonEvent = OnXButton;

	spnNextMission.SetCaption(StringNextMission);
	class'gbx_CreateMatchBase'.Static.FillMissionList(spnNextMission);
	SetNextMapName(PlayerOwner().Level.GetLevelFileName());
  
	class'GameService.GameService'.static.FinishMatch();
}

function OnAButton()
{
	local string nextmap;

	nextmap = GetNextMapName() $ "?wascycle=1" $ GetHostAuthString(Controller);

	Controller.PlayClickSound(EClickSound.CS_Click);	

	log(self $ " gbx_MPDebriefingServer::OnAButton() Proceeding to next map: " $ nextmap, 'JWS');
	PlayerOwner().Level.ServerTravel(nextmap, false);
	PlayerOwner().ClientCloseMenu(true,,true);
}

function OnXButton()
{
	Controller.PlayClickSound(EClickSound.CS_Click);
	Controller.OpenMenu("GUI.gbx_MPDebriefingChooseMission", GetNextMapName());
}

function Timer()
{
	Super.Timer();

	PlayerOwner().GameReplicationInfo.NextMapName = GetNextMapName();
}

function SetNextMapName(string s)
{
  	local int index;

	index = spnNextMission.MySpinListControl.Find(s, true);
	if (index != -1)
		spnNextMission.SetIndex(index);
}

function string GetNextMapName()
{
	return spnNextMission.GetExtra();
}

function ProcessChatCommand(string text)
{
	local string PlayerName;
	local string ChatCommand;

	if (Left(text, 1) == "/")
	{
		ChatCommand = Right(text, (Len(text)-1));

		if (Left(ChatCommand, 4) ~= "kick")
		{
			PlayerName = Right(ChatCommand, (Len(ChatCommand)-5)); // length of the word kick plus the space

			if (PlayerName == "")
			{
				ProcessChatCommand("/help");
			}
			else
			{
				txtChatBox.AddText("Kicked " $ PlayerName $ " out of the game session.");
				PlayerOwner().ConsoleCommand("kick " $ PlayerName);
			}
		}
		else if (Left(ChatCommand, 4) ~= "help")
		{
			txtChatBox.AddText("Use /kick <playername> to kick a player from the game session.");
		}
		else
		{
			txtChatBox.AddText("Unrecognized command. Use /help to get help.");
		}
	}
	else
	{
		Super.ProcessChatCommand(text);
	}
}

static function PreloadMenu(GUIController C)
{
	Super.PreloadMenu(C);

	C.PreloadMenu("GUI.gbx_MPDebriefingChooseMission");
}

defaultproperties
{
	ACaption="Continue"
	XCaption="New Mission"

	Begin Object Class=moSpinListControl Name=cspnNextMission
		bFocusOnWatch=true
		LabelJustification=TXTA_Right
		CaptionWidth=0.50
		ComponentWidth=0.45
		WinWidth=0.90
		WinHeight=0.052000
		WinLeft=0.050
		WinTop=0.57000
		bHeightFromComponent=false
	End Object
	spnNextMission=cspnNextMission
}class gbx_MPLobby extends gbx_MPBase
	Abstract;

var Automated array<gbx_MPLobbyPlayer>			PlayerSlots;
var Automated array<gbx_MPLobbyPlayerMarker>	PlayerMarkers;
var automated gbx_MissionDisplay				MissionDisplay;

var int											CurrentMissionIndex;
var Automated GUILabel							lblDescription;
var Automated GUILabel							lblMissionTitle;
var Automated GUIImage							imgMission;

var GUIStyles								styLinePlayerNum;

var localized string						StrUSA;
var localized string						StrGerman;
var localized string						StrSlotEmpty;
var localized string						StrMenu;

var localized string						StrCountdown;

var Canvas.CanvasIcon						IconRole[3];	// in same order as EUnitType
var Canvas.CanvasIcon						IconUSA;
var Canvas.CanvasIcon						IconGerman;
var Canvas.CanvasIcon						IconBackUSA;
var Canvas.CanvasIcon						IconBackGerman;

var int										MyMaxPlayers;
var bool									bAlways4PLobbyStyle;

var string CountdownCaptionA, CountdownCaptionB, CountdownCaptionX, CountdownCaptionY;

var Sound CountdownProgressSound, CountdownFinishedSound;

const TEAM_ICON_SCALE = 1.8;

// Lame countdown management stuff
const COUNTDOWN_TIME = 5;
const COUNTDOWN_ABORTED = -1;
const COUNTDOWN_SUCCESS = -2;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	local int slot;

    bShowOnlineIcon=class'GameService.GameService'.static.IsInLobby();

    //bShowOnlineIcon=!PlayerOwner().IsLanGame();

	Super.InitComponent(MyController, MyOwner);

//###+ lbouchard : LINKLOSS: Check the connection link for Ubi.com Games
    if (!IsSystemLinkGame())
		bRequireLink=true;
//###-    


	if (!PlayerOwner().Level.IsXbox())
		lblDescription.bForceCaps = false;

	Controller.LoadPlayerControllerBindings();

	OnOpen = LobbyOpen;
	OnClose = LobbyClose;
	OnCanClose = CanClose;
	OnXControllerEvent = LobbyOnXControllerEvent;
	OnKeyEvent = LobbyOnKeyEvent;

	OnAButtonEvent = OnAButton;
	OnBButtonEvent = OnBButton;
	OnXButtonEvent = OnXButton;
	OnYButtonEvent = OnYButton;

	styLinePlayerNum = Controller.GetStyle("TextLabel");

	for (slot=0; slot<PlayerSlots.Length; slot++)
	{
		PlayerSlots[slot].OnClick = PlayerSlotClick;
	}

	PlayerSlots[0].SetPlayerSlot(0);
	PlayerSlots[1].SetPlayerSlot(1);
	PlayerSlots[2].SetPlayerSlot(2);
	PlayerSlots[3].SetPlayerSlot(3);

	lblProfileName[0].bUseTextColorForStyle = true;
	lblProfileName[1].bUseTextColorForStyle = true;
	lblProfileName[2].bUseTextColorForStyle = true;
	lblProfileName[3].bUseTextColorForStyle = true;

	// fill in the text fields
	CurrentMissionIndex = class'Gameplay.gbxMPMissionList'.static.FindMapIndex(PlayerOwner().Level.GetLevelFileName());
//	MissionDisplay.SetMission( MissionDisplay );

	imgMission.Image = Controller.GUITexturePool.AllocRenderMaterial();
	Controller.GUITexturePool.GetTexture(imgMission.Image, class'Gameplay.gbxMPMissionList'.static.GetMissionImageName(CurrentMissionIndex));
	ResetMissionTitle();
	lblDescription.SetCaption(class'Gameplay.gbxMPMissionList'.static.GetBriefing(CurrentMissionIndex));

//	txtChatBox.TabOrder = slot++;

	UpdateDisplayArray();
	RemapComponents();

	hBtnA.SetFocus(None);

	UpdatePlayerMarkerPositions();
	
	class'GameService.GameService'.static.UpdateGameData(class'Gameplay.gbxMPMissionList'.static.GetMap(CurrentMissionIndex));

	InitExecution();

	MakeAmbientSoundHappen();
}

function MakeAmbientSoundHappen()
{
	local PhysicsVolume Volume;
	local PhysicsVolume BestVolume;
	local string soundname;

	ForEach PlayerOwner().AllActors(class'PhysicsVolume', Volume)
	{
		if (Volume.AmbientSound != None && (BestVolume == None || Volume.Priority < BestVolume.Priority) )
		{
			BestVolume = Volume;
			soundname = string(BestVolume.AmbientSound);
		}
	}

	if (soundname != "")
	{
		PlayerOwner().PlayMusic(soundname, 0.0);
	}
}

function ResetMissionTitle()
{
	lblMissionTitle.SetCaption(class'Gameplay.gbxMPMissionList'.static.GetMissionName(CurrentMissionIndex, true));
}

function bool CanClose(optional Bool bCancelled) {return false;}
function LobbyOpen()
{
	SetTimer(0.15, true);
	Timer();
}
function LobbyClose(optional Bool bCancelled)
{
	Controller.GUITexturePool.FreeRenderMaterial(imgMission.Image);
	Controller.GUITexturePool.MarkAsUnneeded(class'Gameplay.gbxMPMissionList'.static.GetMissionImageName(CurrentMissionIndex));

	KillTimer();

	PlayerOwner().PlaySound(CountdownFinishedSound, SLOT_Interact, 1.0, false );
}

function OnChat(PlayerReplicationInfo ChattingPRI, string Message)
{
	local string FormattedMessage;

	FormattedMessage = class'SayMessagePlus'.static.AssembleString(PlayerOwner().myHud, 0, ChattingPRI, Message);
	txtChatBox.AddText(FormattedMessage);
}

function SetupAButtonCaptions(string capBothReady, string capNotReady)
{
	local int marker, marker1;

	marker = FindPlayerMarkerForController(Controller.GetControllerIndexForPlayer(0));
	if (marker != -1)
	{
		if (PlayerMarkers[marker].IsAttached())
		{
			marker1 = FindPlayerMarkerForController(Controller.GetControllerIndexForPlayer(1));
			if (marker1 != -1)
			{
				if (PlayerMarkers[marker1].IsAttached())
				{
					SetupAButton(capBothReady);
				}
				else
				{
					SetupAButton(capNotReady);
				}
			}
			else
			{
				SetupAButton(capBothReady);
			}
		}
		else
		{
			hbtnA.EnableControl(true);
			SetupAButton(capNotReady);
		}
	}
}

function Timer()
{
	local PlayerReplicationInfo pri;
	local int slot, marker;
	local bool bChanged;

	Controller.LoadPlayerControllerBindings();
	bChanged = false;

	if (MyMaxPlayers != PlayerOwner().GameReplicationInfo.MaxPlayers)
	{
		GUILog("Mystery slot would have happened!");
		UpdateDisplayArray();
	}

	// reset the touched state so we can remove players that left
	for (slot=0; slot<PlayerMarkers.Length; slot++)
	{
		PlayerMarkers[slot].bTouched = false;
	}

	// iterate the list of player replication infos and add/update them
	ForEach PlayerOwner().DynamicActors(class'PlayerReplicationInfo', pri)
	{
		slot = FindPlayerMarker(pri);
		if (slot == -1)
		{
			if (AddNewPlayer(pri))
				bChanged = true;
		}
		else
		{
			PlayerMarkers[slot].SetPlayer(pri);
		}
	}

	// remove any untouched players
	for (slot=0; slot<PlayerMarkers.Length; slot++)
	{
		if (!PlayerMarkers[slot].bTouched)
		{
			RemovePlayer(PlayerMarkers[slot].MyPlayer);
			bChanged = true;
		}
	}

	if (bChanged)
	{
		UpdatePlayerMarkerPositions();
	}

	if (hbtnY.Caption == "")
	{
		// if we're in live mode, enable the y button
		if (PlayerOwner().Level.AuthMode == AM_Live)
		{
			SetupYButton(StrPlayers);
		}
	}

	marker = FindPlayerMarkerForController(Controller.GetControllerIndexForPlayer(0));
	if (marker != -1)
	{
		if (PlayerMarkers[marker].IsAttached())
		{
			SetupBButton(StrUnReady);
		}
		else
		{
			// TODO PARIS REMOVEME
			if (PlayerOwner().bIsDemo)
				SetupBButton();
			else
				SetupBButton(StrMenu);
		}
	}
}

function int GetAttachmentSlotForLocalPlayer(int localControllerNum)
{
	local int marker;
	marker = FindPlayerMarkerForController(localControllerNum);

	if (marker == -1)
		return -1;

	return PlayerMarkers[marker].MyPlayerSlot;
}

function DrawPlayerCursor(Canvas C, int localPlayerNum)
{
	local int marker, slot, X, Y, XL, nXL, nYL, localControllerNum;
	local float yOfs;
	local string s;

	localControllerNum = Controller.GetControllerIndexForPlayer(localPlayerNum);
	if (localControllerNum == -1)
	{
//		GUILog("Invalid player->controller");
		return;
	}

	// make sure this controller has a marker
	marker = FindPlayerMarkerForController(localControllerNum);
	if (marker == -1)
	{
//		GUILog("Invalid marker");
		return;
	}

	// if this is P2 or P1 on a client, don't draw if they're attached
	if (((localPlayerNum == 1) || (IsA('gbx_MPLobbyClient'))) && PlayerMarkers[marker].IsAttached())
	{
//		GUILog("2P is attached");
		return;
	}

	slot = GetAttachmentSlotForLocalPlayer(localControllerNum);
	// get the position/size from the slot we're attached to
	X = 0;
	Y = PlayerSlots[slot].VerticalOffset(1.0);
	XL = PlayerSlots[slot].HorizontalOffset(1.0);

	// nudge P1 down if P2 is on the same slot
	if ((localControllerNum == Controller.GetControllerIndexForPlayer(0)) && (slot == GetAttachmentSlotForLocalPlayer(Controller.GetControllerIndexForPlayer(1))))
	{
		yOfs = 2*Controller.CanvasScaleY;
	}

	C.DrawColor = Controller.BackgroundBoxColor;
	C.SetPos(X+1, Y + yOfs - (2*Controller.CanvasScaleY)+1);
	C.DrawTileTiledClip(	Texture't_interface_mb.hud.interface_comp', 
							XL, 5 * Controller.CanvasScaleY, 
							284, 128, 128, 128,
							32, 32);

	C.DrawColor = class'gbxMP.WargameMultiplayerScoreboard'.default.PlayerColors[ PlayerMarkers[marker].GetClientIndex() ];
	C.SetPos(X, Y + yOfs - (2*Controller.CanvasScaleY));
	C.DrawTileTiledClip(	Texture't_interface_mb.hud.interface_comp', 
							XL, 5 * Controller.CanvasScaleY, 
							284, 128, 128, 128,
							32, 32);

	if (!Controller.bIsConsole || PlayerMarkers[marker].IsAttached())
		return;

	s = PlayerMarkers[marker].GetPlayerNumString();
	if (s != "")
	{
		styLinePlayerNum.TextSize(C, eMenuState.MSAT_Focused, s, nXL, nYL);
			X = HorizontalOffset(0.0375);
		if (localPlayerNum == 1)
			X += nXL + 8 * Controller.CanvasAspectScale;

		styLinePlayerNum.SetOverrideColor(C.DrawColor);
		styLinePlayerNum.DrawText(C, MSAT_Focused, X, Y - nYL, nXL, nYL, TXTA_Left, s);
		styLinePlayerNum.ClearOverrideColor();
	}
}


function bool ScreenOnDrawPre(Canvas C)
{
	local float xLeft,xPos, yPos, XL, YL;

	Controller.CanvasIconSize(IconBackUSA, XL, YL, TEAM_ICON_SCALE, TEAM_ICON_SCALE);

	xPos = HorizontalOffset(0.54) - 0.5*XL;
	xLeft = -0.03 * ActualWidth();

	C.Style = EMenuRenderStyle.MSTY_Alpha;
	C.DrawColor = Controller.BackgroundBoxColor;

	// draw the backdrop
	yPos = VerticalOffset(0.20);	// NOMERGE yPos = VerticalOffset(0.28);
	DrawBackground(C, xLeft, yPos - 0.5*YL, xPos - xLeft, YL);

	yPos = VerticalOffset(0.34);	// NOMERGE yPos = VerticalOffset(0.42);
	DrawBackground(C, xLeft, yPos - 0.5*YL, xPos - xLeft, YL);

	lblDescription.DrawComponentBackground(C, 2.0, 2.0);

	// draw the usa/german icons
	IconBackUSA.DrawColor.A = 255;
	IconUSA.DrawColor.A = 255;
	IconBackGerman.DrawColor.A = 255;
	IconGerman.DrawColor.A = 255;

	yPos = VerticalOffset(0.20);	// NOMERGE yPos = VerticalOffset(0.28);
	C.DrawCanvasIconComposite(	xPos, yPos,
						TEAM_ICON_SCALE * Controller.CanvasAspectScale,
						TEAM_ICON_SCALE * Controller.CanvasScaleY,
						IconUSA, IconBackUSA );

	yPos = VerticalOffset(0.34);	// NOMERGE yPos = VerticalOffset(0.42);
	C.DrawCanvasIconComposite(	xPos, yPos,
						TEAM_ICON_SCALE * Controller.CanvasAspectScale,
						TEAM_ICON_SCALE * Controller.CanvasScaleY,
						IconGerman, IconBackGerman );

	IconBackUSA.DrawColor.A = default.IconBackUSA.DrawColor.A;
	IconUSA.DrawColor.A = default.IconUSA.DrawColor.A;
	IconBackGerman.DrawColor.A = default.IconBackGerman.DrawColor.A;
	IconGerman.DrawColor.A = default.IconGerman.DrawColor.A;

	return Super.ScreenOnDrawPre(C);
}

function bool ScreenOnDraw(Canvas C)
{
	DrawPlayerCursor(C, 1);
	DrawPlayerCursor(C, 0);

	if (Controller.bIsConsole)
	{
		DrawAttachedPlayerStatusIcon(C, 2, lblProfileName[2], false);
		DrawAttachedPlayerStatusIcon(C, 3, lblProfileName[3], true);
	}

	return Super.ScreenOnDraw(C);
}

function int GetRoleForPlayerSlot(int slot, int iconNum)
{
	// CEK: the magic numbers below are fine as that's how the maps are designed.
	if (!bAlways4PLobbyStyle && (MyMaxPlayers <= 2))
	{
		if (IconNum == 0)
			return 0;// hax for assault
		else
			return 1;// hax for base
	}
	else
	{
		if ((slot == 0) || (slot == 2))
		{
			return 0;// hax for assault
		}
		else
		{
			return 1;// hax for base
		}
	}
}

function UpdateDisplayArray()
{
	MyMaxPlayers = PlayerOwner().GameReplicationInfo.MaxPlayers;

	if (!bAlways4PLobbyStyle && (MyMaxPlayers <= 2))
	{
		PlayerSlots[1].Hide();
		PlayerSlots[3].Hide();
		lblProfileName[2].Hide();
		lblProfileName[3].Hide();

		PlayerSlots[0].WinTop = 0.26;
		PlayerSlots[2].WinTop = 0.40;
	}
	else
	{
		PlayerSlots[1].Show();
		PlayerSlots[3].Show();
		lblProfileName[2].Show();
		lblProfileName[3].Show();

		PlayerSlots[0].WinTop = default.PlayerSlots[0].WinTop;
		PlayerSlots[2].WinTop = default.PlayerSlots[2].WinTop;
	}

	PlayerSlots[0].SetPlayerSlot(0);
	PlayerSlots[1].SetPlayerSlot(1);
	PlayerSlots[2].SetPlayerSlot(2);
	PlayerSlots[3].SetPlayerSlot(3);

	MapControls();
}

// =======================================================================================================================================================
// Marker focus/attachment
// =======================================================================================================================================================
function BindMarkerToSlot(gbx_MPLobbyPlayerMarker marker)
{
	PlayerSlots[marker.MyPlayerSlot].BindMarker(marker, marker.MyMarkerPos);
}

function AttachMarkerToSlot(gbx_MPLobbyPlayerMarker marker)
{
	local int i;

	if (marker.IsAttached())
	{
		PlayerSlots[marker.MyPlayerSlot].SetPlayer(marker.MyPlayer);
	}
	else
	{
		for (i=0; i<PlayerSlots.Length; i++)
		{
			if (marker.MyPlayer == PlayerSlots[i].MyPlayer)
			{
				PlayerSlots[i].SetPlayer(None);
			}
		}
	}
}

// =======================================================================================================================================================
// Player marker list management
// =======================================================================================================================================================
function bool AddNewPlayer(PlayerReplicationInfo PRI)
{
	local int i;

	for (i=0; i<PlayerMarkers.Length; i++)
	{
		if (None == PlayerMarkers[i].MyPlayer)
		{
			return PlayerMarkers[i].SetPlayer(PRI);
		}
	}

	return false;
}

function RemovePlayer(PlayerReplicationInfo PRI)
{
	local int slot;

	slot = FindPlayerMarker(PRI);
	if (slot != -1)
	{
		// remove from the known players list
		PlayerMarkers[slot].SetPlayer(None);
	}
}

function int FindPlayerMarker(PlayerReplicationInfo PRI)
{
	local int i;
	
	for (i=0; i<PlayerMarkers.Length; i++)
	{
		if (PRI == PlayerMarkers[i].MyPlayer)
			return i;
	}

	return -1;
}

function int FindPlayerMarkerForController(int inControllerIndex)
{
	local int i;
	
	for (i=0; i<PlayerMarkers.Length; i++)
	{
		if (PlayerMarkers[i].IsController(inControllerIndex))
			return i;
	}

	return -1;
}

function int GetPlayerMarkerAttachedToSlot(int slot)
{
	local int marker;
	for (marker=0; marker<PlayerMarkers.Length; marker++)
	{
		if ((PlayerMarkers[marker].MyPlayer != None) && (PlayerMarkers[marker].MyPlayerSlot == slot) && PlayerMarkers[marker].IsAttached())
		{
			return marker;
		}
	}

	return -1;
}

function SetPlayerNameForPlayerMarkerLabel(int labelIndex, int localPlayerIndex, optional int clientIndex, optional string PlayerName, optional string GamerTag)
{
	if (PlayerName == "")
	{
		SetupPlayerStatusInfo(labelIndex, localPlayerIndex, StrSlotEmpty);
		lblProfileName[labelIndex].TextColor = class'gbxMP.WargameMultiplayerScoreboard'.default.PlayerColors[4];
	}
	else
	{
		SetupPlayerStatusInfo(labelIndex, localPlayerIndex, PlayerName, GamerTag);

		lblProfileName[labelIndex].TextColor = class'gbxMP.WargameMultiplayerScoreboard'.default.PlayerColors[clientIndex];
		lblProfileName[labelIndex].TextColor.A = 255;
	}
}

function UpdatePlayerMarkerPositions()
{
	local int i, used;
	
	// reset the markers
	for (i=0; i<PlayerMarkers.Length; i++)
	{
		PlayerMarkers[i].MyMarkerPos = LMP_None;
		SetPlayerNameForPlayerMarkerLabel(i, -1);
	}

	// set the local ones to their controller index
	used = 0;
	for (i=0; i<PlayerMarkers.Length; i++)
	{
		if (PlayerMarkers[i].bIsLocal)
		{
			PlayerMarkers[i].SetMarkerPos(ELobbyMarkerPos(PlayerMarkers[i].GetMarkerController()));

			// update the caption
			if (PlayerMarkers[i].MyPlayer != None)
			{
   				SetPlayerNameForPlayerMarkerLabel(used, used, PlayerMarkers[i].GetClientIndex(), PlayerMarkers[i].MyPlayer.GetHumanReadableName(), PlayerMarkers[i].MyPlayer.GamerTag);
			}
			used++;
		}
	}

	// now set the remotes in order
	for (i=0; i<PlayerMarkers.Length; i++)
	{
		if (PlayerMarkers[i].MyMarkerPos == LMP_None)
		{
			PlayerMarkers[i].SetMarkerPos(ELobbyMarkerPos(used));

			// update the caption
			if (PlayerMarkers[i].MyPlayer != None)
			{
			    SetPlayerNameForPlayerMarkerLabel(used, -1, PlayerMarkers[i].GetClientIndex(), PlayerMarkers[i].MyPlayer.GetHumanReadableName(), PlayerMarkers[i].MyPlayer.GamerTag);
			}

			used++;
		}
	}
}

function bool GetPlayerCounts(out int plUSA, out int plGerman)
{
	local int i;
	local bool bAllReady;

	bAllReady = true;
	plUSA = 0;
	plGerman = 0;

	for (i=0; i<PlayerMarkers.Length; i++)
	{
		if (!PlayerMarkers[i].InUse())
			continue;

		if (PlayerMarkers[i].IsTeamGerman())
			plGerman++;
		else if (PlayerMarkers[i].IsTeamUSA())
			plUSA++;

		if (!PlayerMarkers[i].IsAttached())
			bAllReady = false;
	}

	return bAllReady;
}

function bool ShouldShowControllerInfo(int inPlayerIndex)
{
	return (inPlayerIndex < MyMaxPlayers);
}

// =======================================================================================================================================================
// Slot cycling
// =======================================================================================================================================================
function OnChooseSlot(int marker, int slot)
{
	Controller.PlayClickSound(EClickSound.CS_Change);
}

function int GetPrevSlot(int start)
{
	local int slot;

	slot = start;
	while(true)
	{
		slot--;
		if (slot < 0)
			slot = PlayerMarkers.Length-1;

		if (PlayerSlots[slot].InUse())
			break;
		if (slot == start)
			break;
	}

	return slot;
}
function int GetNextSlot(int start)
{
	local int slot;

	slot = start;
	while(true)
	{
		slot++;
		if (slot > PlayerMarkers.Length-1)
			slot = 0;

		if (PlayerSlots[slot].InUse())
			break;
		if (slot == start)
			break;
	}

	return slot;
}
function int GetTeamChangeSlot(int start)
{
	switch(start)
	{
	case 0:
	case 1:
		start += 2;
		break;

	case 2:
	case 3:
		start -= 2;
		break;
	}

	return start;
}

function int PrevSlot(int marker)
{
	local int slot;

	if (!PlayerMarkers[marker].IsAttached())
	{
		slot = GetPrevSlot( PlayerMarkers[marker].MyPlayerSlot );

		PlayerMarkers[marker].SetPlayerSlot(slot);

		OnChooseSlot(marker, slot);
	}

	return slot;
}

function int NextSlot(int marker)
{
	local int slot;

	if (!PlayerMarkers[marker].IsAttached())
	{
		slot = GetNextSlot( PlayerMarkers[marker].MyPlayerSlot );

		PlayerMarkers[marker].SetPlayerSlot(slot);

		OnChooseSlot(marker, slot);
	}
	return slot;
}

function int ChangeTeam(int marker)
{
	local int slot;

	if (!PlayerMarkers[marker].IsAttached())
	{
		slot = GetTeamChangeSlot(PlayerMarkers[marker].MyPlayerSlot);

		PlayerMarkers[marker].SetPlayerSlot( slot );
		OnChooseSlot(marker, slot);
	}

	return slot;
}

// =======================================================================================================================================================
// Input Handling
// =======================================================================================================================================================
function bool LobbyOnXControllerEvent(byte Id, eXControllerCodes iCode)
{
	local int marker;

	marker = FindPlayerMarkerForController(Controller.ControllerId);
	GUILog("LobbyOnXControllerEvent marker=" $marker $" controller=" $Controller.ControllerId);

	if (marker != -1)
	{
		if ((iCode == XC_PadUp) || (iCode == XC_PadDown))
		{
			if (iCode == XC_PadUp)
				PrevSlot(marker);
			else
				NextSlot(marker);

			return true;
		}
/*
		else if ((iCode == XC_PadLeft) || (iCode == XC_PadRight))
		{
			ChangeTeam(marker);
			return true;
		}
*/
	}

	return SAB_OnXControllerEvent(Id, iCode);
}

// 37=left
// 38=up
// 39=right
// 40=down
// 32=space
function bool LobbyOnKeyEvent(out byte Key,out byte State,float delta)
{
	local int marker;

	if (!editText.bHasfocus && (State == 1))
	{
		marker = FindPlayerMarkerForController(Controller.ControllerId);
		GUILog("LobbyOnKeyEvent marker=" $marker $" controller=" $Controller.ControllerId);

		if (marker != -1)
		{
			if (Key == 38)
			{
				PrevSlot(marker);
				return true;
			}
			else if (Key == 40)
			{
				NextSlot(marker);
				return true;
			}
/*
			else if ((Key == 37) || (Key == 39))
			{
				ChangeTeam(marker);
				return true;
			}
*/
			else if (Key == 32)
			{
				if (!PlayerMarkers[marker].IsAttached())
					PlayerMarkers[marker].AttachToSlot(true);
				else
					PlayerMarkers[marker].AttachToSlot(false);

				return true;
			}
		}
	}

	return SAB_KeyEvent(Key, State, delta);
}

function bool PlayerSlotClick(GUIComponent Sender)
{
	local gbx_MPLobbyPlayer selPlayer;
	local int marker;
	
	if (Controller.bIsConsole) return false;

	selPlayer = gbx_MPLobbyPlayer(Sender);
	if (selPlayer != None)
	{
		marker = FindPlayerMarkerForController(Controller.ControllerId);
		GUILog("PlayerSlotClick marker=" $marker $" controller=" $Controller.ControllerId);
		if (marker != -1)
		{
			if (PlayerMarkers[marker].MyPlayerSlot == selPlayer.MyPlayerSlot)
			{
				// toggle the attach state if we clicked the focused slot
				if (!PlayerMarkers[marker].IsAttached())
					PlayerMarkers[marker].AttachToSlot(true);
				else
					PlayerMarkers[marker].AttachToSlot(false);
			}
			else if (!PlayerMarkers[marker].IsAttached())
			{
				// move the slot if we aren't attached
				PlayerMarkers[marker].SetPlayerSlot(selPlayer.MyPlayerSlot);
			}

			OnChooseSlot(marker, selPlayer.MyPlayerSlot);
		}

		return true;
	}

	return false;
}


// X button is for removing a player from a slot, server only
function OnXButton();

// A button attaches a player to a slot, will begin game on server.
function OnAButton()
{
	local int marker;

	marker = FindPlayerMarkerForController(Controller.ControllerId);
	if (marker != -1)
	{
		PlayerMarkers[marker].AttachToSlot(true);
	}
}

// B button pulls a player back out of their slot, quits if they're already out of their slot
function OnBButton()
{
	local int marker;

	marker = FindPlayerMarkerForController(Controller.ControllerId);
	if (marker != -1)
	{
		if (PlayerMarkers[marker].IsAttached())
			PlayerMarkers[marker].AttachToSlot(false);
		else
		{
			Controller.PlayClickSound(EClickSound.CS_Back);
			Controller.OpenMenu(class'GameEngine'.default.PopupMPMenuClass, "NOCLOSEALL");
		}
	}
}

// Y button will open the players list if in a Live game.
function OnYButton()
{
	local int marker;

	// unready this player
	marker = FindPlayerMarkerForController(Controller.ControllerId);
	if (marker != -1)
	{
		if (PlayerMarkers[marker].IsAttached())
			PlayerMarkers[marker].AttachToSlot(false);
	}

	class'gbx_LivePlayersList'.static.LaunchPlayersList(Controller, Controller.FindPlayerForControllerIndex(Controller.ControllerId));
}


// =======================================================================================================================================================
// Countdown stuff
// =======================================================================================================================================================

state CountDownBase
{
	// No cursors in the countdown
	function DrawPlayerCursor(Canvas C, int localPlayerNum)
	{
	}

	function Timer()
	{
		local string text;
		local int i;
		local int time;

		time = PlayerOwner().GameReplicationInfo.LobbyCountdownTime;

		if (time > 0)
		{
			i = InStr(StrCountdown, "%time%", true);

			if (i != -1)
			{
				text = Left(StrCountdown, i) $ time $ Mid(StrCountdown, i + 6);
			}
			else
			{
				text = StrCountdown;
			}

			if (text != lblMissionTitle.Caption)
			{
				PlayerOwner().PlaySound(CountdownProgressSound, SLOT_Interact, 1.0, false );
			}

			lblMissionTitle.SetCaption(text);
		}
	}

	// Eat all the input
	function bool LobbyOnXControllerEvent(byte Id, eXControllerCodes iCode)
	{
		return true;
	}

	function bool LobbyOnKeyEvent(out byte Key,out byte State,float delta)
	{
		return true;
	}

	function HideUnwantedControls()
	{
		CountdownCaptionA = hbtnA.Caption;
		SetupAButton("");

		CountdownCaptionB = hbtnB.Caption;
		SetupBButton("");

		CountdownCaptionX = hbtnX.Caption;
		SetupXButton("");

		CountdownCaptionY = hbtnY.Caption;
		SetupYButton("");
	}

	function UnHideUnwantedControls()
	{
		SetupAButton(CountdownCaptionA);
		SetupBButton(CountdownCaptionB);
		SetupXButton(CountdownCaptionX);
		SetupYButton(CountdownCaptionY);

		ResetMissionTitle();
	}
}

defaultproperties
{
	// usa = 1,2
	Begin Object Class=gbx_MPLobbyPlayer Name=cPlayerSlot1
		WinTop=0.15// NOMERGE 0.23
		RenderWeight=0.4
	End Object
	Begin Object Class=gbx_MPLobbyPlayer Name=cPlayerSlot2
		WinTop=0.21// NOMERGE 0.29
		RenderWeight=0.4
	End Object

	// german = 3,4
	Begin Object Class=gbx_MPLobbyPlayer Name=cPlayerSlot3
		WinTop=0.29// NOMERGE 0.37
		RenderWeight=0.4
	End Object
	Begin Object Class=gbx_MPLobbyPlayer Name=cPlayerSlot4
		WinTop=0.35// NOMERGE 0.43
		RenderWeight=0.4
	End Object


	PlayerSlots(0)=cPlayerSlot1
	PlayerSlots(1)=cPlayerSlot2
	PlayerSlots(2)=cPlayerSlot3
	PlayerSlots(3)=cPlayerSlot4

	// player markers
	Begin Object Class=gbx_MPLobbyPlayerMarker Name=cPlayerMarker
	End Object
	PlayerMarkers(0)=cPlayerMarker
	PlayerMarkers(1)=cPlayerMarker
	PlayerMarkers(2)=cPlayerMarker
	PlayerMarkers(3)=cPlayerMarker

	// mission display
	// mission pic
	Begin Object Class=GUIImage Name=cLobbyimgMission
		ImageColor=(R=255,G=255,B=255,A=255)
		ImageStyle=ISTY_Scaled
		ImageAlign=IMGA_Center
		WinWidth=0.40
		WinHeight=0.27
		WinLeft=0.55
		WinTop=0.135// NOMERGE 0.215
	End Object
	imgMission=cLobbyimgMission
	Begin Object Class=GUILabel Name=clblLobbyHeaderMission
		StyleName="MenuOptionCaption"
		DrawMenuState=1
		TextAlign=TXTA_Center
		bAcceptsInput=false
		bTabStop=false
		WinWidth=0.900000
		WinHeight=0.050000
		WinLeft=0.05
		WinTop=0.080000// NOMERGE 0.160000
	End Object
	lblMissionTitle=clblLobbyHeaderMission

	Begin Object Class=GUILabel Name=cLobbyDescMission
		StyleName="TextLabel"
		TextAlign=TXTA_Left
		DrawMenuState=1
		WinWidth=0.70
		WinHeight=0.22000
		WinLeft=0.15
		WinTop=0.42// NOMERGE 0.50
		bNeverFocus=true
		bMultiLine=true
		bTransparent=true
		bForceCaps=true
	End Object
	lblDescription=cLobbyDescMission

	// player name labels
	lblProfileName(2)=clblPlayerName3_Alt// NOMERGE
	lblProfileName(3)=clblPlayerName4_Alt// NOMERGE

	bAllowedAsLast=true
	bRequireFullScreen=true

	StrUSA="USA"
	StrGerman="German"
	StrSlotEmpty="< No Player >"
	StrMenu="Back"

	StrCountdown="Mission Begins in: %time%"

	ScreenTitle="Choose Team"
    StringProfile="Player:"

	MyMaxPlayers=4

	IconUSA=(Icon=Texture't_interface_mb.hud.interface_comp',U=276,V=99,UL=29,VL=29,DrawColor=(R=128,G=128,B=128,A=200),ScaleX=0.8,ScaleY=0.8,PivotU=0.5,PivotV=0.5)
	IconGerman=(Icon=Texture't_interface_mb.hud.interface_comp',U=305,V=99,UL=29,VL=29,DrawColor=(R=0,G=0,B=0,A=200),ScaleX=0.8,ScaleY=0.8,PivotU=0.5,PivotV=0.5)

//	IconBackUSA=(Icon=Texture't_interface_mb.hud.interface_comp',U=192,V=131,UL=46,VL=46,DrawColor=(R=53,G=73,B=14,A=200),ScaleX=0.8,ScaleY=0.8,PivotU=0.5,PivotV=0.5)
//	IconBackGerman=(Icon=Texture't_interface_mb.hud.interface_comp',U=192,V=131,UL=46,VL=46,DrawColor=(R=128,G=0,B=0,A=200),ScaleX=0.8,ScaleY=0.8,PivotU=0.5,PivotV=0.5)
	IconBackUSA=(Icon=Texture't_interface_mb.hud.interface_comp',U=192,V=131,UL=46,VL=46,DrawColor=(R=44,G=52,B=24,A=255),ScaleX=0.8,ScaleY=0.8,PivotU=0.5,PivotV=0.5)
	IconBackGerman=(Icon=Texture't_interface_mb.hud.interface_comp',U=192,V=131,UL=46,VL=46,DrawColor=(R=90,G=28,B=21,A=255),ScaleX=0.8,ScaleY=0.8,PivotU=0.5,PivotV=0.5)

	IconRole(0)=(Icon=Texture't_interface_mb.hud.interface_comp',U=132,V=93,UL=40,VL=36,DrawColor=(R=0,G=0,B=0,A=255),ScaleX=0.7,ScaleY=0.7,PivotU=0.5,PivotV=0.5)	// SIT_UNIT_MOVE (icon_team_move)
	IconRole(1)=(Icon=Texture't_interface_mb.hud.interface_comp',U=214,V=105,UL=40,VL=24,DrawColor=(R=0,G=0,B=0,A=255),ScaleX=0.6,ScaleY=0.6,PivotU=0.5,PivotV=0.5)	// SIT_UNIT_FIRE (icon_team_fire)
	IconRole(2)=(Icon=Texture't_interface_mb.hud.interface_comp',U=176,V=106,UL=40,VL=23,DrawColor=(R=0,G=0,B=0,A=255),ScaleX=0.7,ScaleY=0.7,PivotU=0.5,PivotV=0.5)	// SIT_UNIT_TANK (icon_team_tank)

	CountdownProgressSound=Sound'MP_MISC.COUNTDOWN'
	CountdownFinishedSound=Sound'MP_MISC.COUNTDOWN_END'

	bAlways4PLobbyStyle=true
}class gbx_MPLobbyClient extends gbx_MPLobby;

var Mutator M;
var localized string strMutButton;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	GUILog("Opening client lobby....");

	Super.InitComponent(MyController, MyOwner);
	
	// rss: setup the mutator button for Active Mutators List Menu (gbx_PopupMenuMPMut)
        SetupXButton( strMutButton );

	if(Controller.bIsDemoVersion || Controller.bIsPreviewVersion)
		SetupXButton();
}

// rss: clients need a way to display the servers current mutators
function OnXButton()
{
	//added to release player from his attached place if he goes into the mutator description page.

    local int marker;

	marker = FindPlayerMarkerForController(Controller.ControllerId);

	if (marker != -1)
	{
		if (PlayerMarkers[marker].IsAttached())
			PlayerMarkers[marker].AttachToSlot(false);
	}


    Controller.OpenMenu("GUI.gbx_PopupMenuMPMut", String(Controller.FindPlayerForControllerIndex(Controller.ControllerId)));
}

function Timer()
{
	Super.Timer();

	SetupAButtonCaptions("", StrReady);

	if (PlayerOwner().GameReplicationInfo.LobbyCountdownTime > 0)
	{
		GotoState('CountDown');
	}
}

state CountDown extends CountDownBase
{
	function Timer()
	{
		local int time;

		time = PlayerOwner().GameReplicationInfo.LobbyCountdownTime;

		if (time == COUNTDOWN_ABORTED)
		{
			UnHideUnwantedControls();
			SetupAButtonCaptions("", StrReady);
			GotoState('');
		}
		else if (time == COUNTDOWN_SUCCESS)
		{
			// do nothing
		}

		Super.Timer();
	}

	function BeginState()
	{
		HideUnwantedControls();
	}
}

defaultproperties
{
	strMutButton="Mutators"
}
class gbx_MPLobbyPlayer extends GUIPanel
	dependson(GUIImage)
	dependson(gbx_MPLobbyPlayerMarker)
	Native;


enum ELobbyPlayerIcon
{
	LPI_NOTREADY,
	LPI_READY,
	LPI_NOTCHATTING,
	LPI_CHATTING,
};

var Automated GUILabel				lblPlayer;
var Automated GUIButton				MyButton;

var gbx_MPLobby						MyLobby;
var PlayerReplicationInfo			MyPlayer;
var int								MyPlayerSlot;
var ETeamIdentifier					MyTeam;

var int								PlayerMarkerOffset;

var bool							bIsUSA;
var bool							bTouched;
var bool							bIsLocal;

var localized string				StringMixedSquads;
native function BindMarker(GUIComponent marker, gbx_MPLobbyPlayerMarker.ELobbyMarkerPos pos);

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	OnDrawPre = PlayerOnDrawPre;
	OnShow = OnPlayerShow;
	MyButton.OnClick = MyButtonClick;

	MyLobby = gbx_MPLobby(MenuOwner);

	SetPlayer(None);
}

function bool PlayerOnDrawPre(Canvas C)
{
	local float xPos, yPos, XL, YL;
	local int marker;

	if (!bVisible)
		return false;

	// both are the same size.
	Controller.CanvasIconSize(MyLobby.IconBackUSA, XL, YL, 0.75, 0.75);

	// draw the background
	C.DrawColor = Controller.BackgroundBoxColor;
	DrawComponentBackground(C, 2.0, 2.0);

	if ((MyPlayer != None) && MyPlayer.bLobbyAttached)
	{
		marker = MyLobby.FindPlayerMarker(MyPlayer);
		if (marker != -1)
		{
			C.DrawColor = class'gbxMP.WargameMultiplayerScoreboard'.default.PlayerColors[ MyLobby.PlayerMarkers[marker].GetClientIndex() ];
			DrawComponentBackground(C);
		}
	}

	xPos = ActualLeft();
	yPos = VerticalOffset(0.5);

	// draw the role icon
	if (MyTeam == ETeamIdentifier.TEAM_US)
	{
		C.DrawCanvasIconComposite(	xPos, yPos,
							0.75*Controller.CanvasAspectScale,
							0.75*Controller.CanvasScaleY,
							MyLobby.IconRole[ MyLobby.GetRoleForPlayerSlot(MyPlayerSlot,0) ], MyLobby.IconBackUSA );

		if (!MyLobby.bAlways4PLobbyStyle && (MyLobby.MyMaxPlayers <= 2))
		{
			// draw both role icons
			xPos = lblPlayer.ActualLeft() - 0.25*XL;
			yPos = VerticalOffset(0.5) + 0.1*YL;
			C.DrawCanvasIconComposite(	xPos, yPos,
								0.75*Controller.CanvasAspectScale,
								0.75*Controller.CanvasScaleY,
								MyLobby.IconRole[ MyLobby.GetRoleForPlayerSlot(MyPlayerSlot,1) ], MyLobby.IconBackUSA );
		}
	}
	else
	{
		C.DrawCanvasIconComposite(	xPos, yPos,
							0.75*Controller.CanvasAspectScale,
							0.75*Controller.CanvasScaleY,
							MyLobby.IconRole[ MyLobby.GetRoleForPlayerSlot(MyPlayerSlot,0) ], MyLobby.IconBackGerman );

		if (!MyLobby.bAlways4PLobbyStyle && (MyLobby.MyMaxPlayers <= 2))
		{
			// draw both role icons
			xPos = lblPlayer.ActualLeft() - 0.25*XL;
			yPos = VerticalOffset(0.5) + 0.1*YL;
			C.DrawCanvasIconComposite(	xPos, yPos,
								0.75*Controller.CanvasAspectScale,
								0.75*Controller.CanvasScaleY,
								MyLobby.IconRole[ MyLobby.GetRoleForPlayerSlot(MyPlayerSlot,1) ], MyLobby.IconBackGerman );
		}
	}

	return false;
}

function OnPlayerShow()
{
}

function bool MyButtonClick(GUIComponent Sender)
{
	if (Sender == MyButton)
	{
		OnClick(self);
		return true;
	}

	return false;
}

static function PlayerController FindPlayerControllerForPRI(PlayerController MyPC, PlayerReplicationInfo PRI)
{
	local PlayerController PC;

	ForEach MyPC.DynamicActors(class'PlayerController', PC)
	{
		if (PC.PlayerReplicationInfo == PRI)
			return PC;
	}

	return None;
}

function SetPlayerSlot(int slot)
{
	MyPlayerSlot = slot;
	MyTeam = class'PlayerReplicationInfo'.Static.GetLobbyTeamChoice(slot);

	UpdateCaptionText();
}

function UpdateCaptionText()
{
	if (!MyLobby.bAlways4PLobbyStyle && (MyLobby.MyMaxPlayers <= 2))
	{
		lblPlayer.SetCaption(StringMixedSquads);
	}
	else
	{
		switch (MyLobby.GetRoleForPlayerSlot(MyPlayerSlot,0))
		{
		case 0://EUnitType.UnitType_Assault:
		case 2://EUnitType.UnitType_Vehicle:
			lblPlayer.SetCaption(class'gbxMP.WargameMultiplayerScoreboard'.default.AssaultText);
			break;
		case 1://EUnitType.UnitType_Base:
			lblPlayer.SetCaption(class'gbxMP.WargameMultiplayerScoreboard'.default.BaseText);
			break;
		}
	}
}

function bool SetPlayer(PlayerReplicationInfo PRI)
{
	local PlayerController PC;

	// validate what we're trying to do...
	if ((PRI != None) && PRI.bBot)
	{
		PRI = None;
	}

	MyPlayer = PRI;
	bTouched = true;
	bIsLocal = false;
	lblPlayer.Caption = "";

	if (MyPlayer != None)
	{
		PC = FindPlayerControllerForPRI(PlayerOwner(), PRI);

//		GUILog("Player Added: found=" $PC $" player=" $PC.Player $" gp index=" $PC.Player.GamePadIndex);

		bIsLocal = Viewport(PC.Player) != None;
	}

	UpdateCaptionText();

	return PRI != None;
}

function bool InUse()
{
	return bVisible;
}

defaultproperties
{
	WinLeft=0.1375
	WinWidth=0.30
	WinHeight=0.04
	PlayerMarkerOffset=4	// # pixels at 640x480

	bTouched=false
	bIsLocal=false

	bAcceptsInput=true
	bTabStop=false
	bForceScaleToParent=false
	bForceBindToParent=false
	bNeverFocus=true
	bIsUSA=true
	TabOrder=0
	PropagateVisibility=false

	Begin Object Class=GUILabel Name=clblPlayer
		StyleName="TextLabel"
		DrawMenuState=1
		TextAlign=TXTA_Center
		bMultiLine=false
		bAcceptsInput=false
		bTabStop=false
		bNeverFocus=true
		bBoundToParent=true
		bScaleToParent=true
		bDrawToFit=true
		bForceCaps=true
		WinWidth=0.930000
		WinHeight=1.00000
		WinLeft=0.070000
		WinTop=0.000000
	End Object
	lblPlayer=clblPlayer

	Begin Object Class=GUIButton Name=cMyButton
		StyleName="NoBackground"
		WinWidth=1.0
		WinHeight=1.0
		WinLeft=0.0
		WinTop=0.0
		TabOrder=0
		bScaleToParent=true
		bBoundToParent=true
		bNoArrowNavigation=true
		bNeverFocus=true
	End Object
	MyButton=cMyButton

	StringMixedSquads="Assault+Fire"
}
class gbx_MPLobbyPlayerMarker extends GUIMultiComponent
	Native;


enum ELobbyMarkerPos
{
	LMP_TopLeft,
	LMP_BottomLeft,
	LMP_BottomRight,
	LMP_TopRight,
	LMP_None,
};

var gbx_MPLobby						MyLobby;
var PlayerReplicationInfo			MyPlayer;
var PlayerController				MyPC;
var ELobbyMarkerPos					MyMarkerPos;


// used to track which player slot we're attached to.  If non-local,
// this value is derived from the playerReplicationInfo.  If local, this value
// is authoritative, after the initial assignment from the server.
var int								MyPlayerSlot;

var bool							bIsLocal;
var bool							bTouched;
var bool							bIsAttached;	// mirror of the playerrepinfo so we can toggle the attachment

var localized string				StrPlayerNum;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	MyLobby = gbx_MPLobby(MenuOwner);
	SetPlayer(None);
}

function bool SetPlayer(PlayerReplicationInfo pri)
{
	local PlayerController PC;

	// validate what we're trying to do...
	if ((PRI != None) && PRI.bBot)
	{
		PRI = None;
	}

	bTouched = true;

	if ((MyPlayer == pri) && (MyPlayer != None) && (MyPC == None))
	{
		PC = class'gbx_MPLobbyPlayer'.static.FindPlayerControllerForPRI(PlayerOwner(), PRI);
		if (PC != None)
		{
			GUILog("SetPlayer(): Player " $ MyPlayer.PlayerName $ " had no player controller but now he does!");
			MyPlayer = None;
		}
	}

	if (MyPlayer != pri)
	{
		bIsLocal = false;

		if (pri == None)
		{
			KillTimer();

			MyLobby.AttachMarkerToSlot(self);
		}
		else
		{
			MyPC = class'gbx_MPLobbyPlayer'.static.FindPlayerControllerForPRI(PlayerOwner(), PRI);
			bIsLocal = Viewport(MyPC.Player) != None;

			if (bIsLocal && (MyLobby.FindPlayerMarkerForController(MyPC.Player.GamePadIndex) != -1))
			{
				GUILog("gbx_MPLobbyPlayerMarker::Deferring player -" @pri $" GamePadIndex=" $MyPC.Player.GamePadIndex);
				pri = None;
				bTouched = false;
				bIsLocal = false;
				MyPC = None;
			}
			else
			{
				GUILog("gbx_MPLobbyPlayerMarker::SetPlayer -" @pri $"(local=" $bIsLocal $") Using PC=" @MyPC);
				if (bIsLocal)
				{
					GUILog("gbx_MPLobbyPlayerMarker::SetPlayer - MyControllerIndex=" $MyPC.Player.GamePadIndex);
				}

				// get the player slot from the pri
				MyPlayerSlot = pri.LobbyPlayerSlot;

				Show();
				SetTimer(0.1, true);
			}
		}

		MyPlayer = pri;
	}

	if ((pri == None) && bVisible)
	{
		Hide();
	}

	return PRI != None;
}

function string GetPlayerNumString()
{
	if (bIsLocal)
	{
		return String(GetMarkerController()+1) $ StrPlayerNum;
	}

	return "";
}

function int GetClientIndex()
{
	if (MyPlayer != None)
		return MyPlayer.LobbyClientNum - 1;

	return 0;
}

function bool InUse()
{
	return MyPlayer != None;
}

function int GetMarkerController()
{
	if ((MyPlayer != None) && bIsLocal && (MyPC != None))
		return MyPC.Player.GamePadIndex;

	return -1;
}

function bool IsController(int ControllerNum)
{
	if (ControllerNum == -1)
		return false;

	return GetMarkerController() == ControllerNum;
/*
	local bool result;

	if (InUse())
		result = bIsLocal && (ControllerNum == MyControllerIndex);

	return result;
*/
}

function Timer()
{
	local bool bOldAttached;

	if (InUse())
	{
		if (!bIsLocal)
		{
			// if remote, update the player slot
			if (MyPlayerSlot != MyPlayer.LobbyPlayerSlot)
			{
				// this nonsense is needed to properly set/reset in the case where players change slots while the user
				// is viewing another menu on top of the lobby.
				GUILog("Player slot change detected");
				bOldAttached = MyPlayer.bLobbyAttached;
				MyPlayer.bLobbyAttached = false;
				bIsAttached = false;

				MyPlayerSlot = MyPlayer.LobbyPlayerSlot;
				MyLobby.AttachMarkerToSlot(self);
				MyLobby.BindMarkerToSlot(self);

				MyPlayer.bLobbyAttached = bOldAttached;
				if (MyPlayer.bLobbyAttached)
				{
					MyLobby.AttachMarkerToSlot(self);
					bIsAttached = true;
				}
			}
		}

		// if we become attached, hide; if unattached, show again
		if (MyPlayer.bLobbyAttached && !bIsAttached)
		{
			MyPlayerSlot = MyPlayer.LobbyPlayerSlot;
			MyLobby.AttachMarkerToSlot(self);
			bIsAttached = true;

			if (bIsLocal)
			{
				Controller.PlayClickSound(EClickSound.CS_Click);
			}
		}
		else if (!MyPlayer.bLobbyAttached && bIsAttached)
		{
			MyPlayerSlot = MyPlayer.LobbyPlayerSlot;
			MyLobby.AttachMarkerToSlot(self);
			bIsAttached = false;

			if (bIsLocal)
			{
				Controller.PlayClickSound(EClickSound.CS_Back);
			}
		}
	}
}

// =======================================================================================================================================================
// marker position and slot modification
// =======================================================================================================================================================
function SetMarkerPos(ELobbyMarkerPos pos)
{
	MyMarkerPos = pos;
	MyLobby.BindMarkerToSlot(self);
}

function SetPlayerSlot(int newSlot)
{
	if (InUse())
	{
		// we'll adjust local immediately
		if (bIsLocal)
		{
			MyPlayerSlot = newSlot;
			MyLobby.BindMarkerToSlot(self);
		}

		// replicate too
		MyPlayer.SetLobbyPlayerSlot(newSlot);
	}
}

// =======================================================================================================================================================
// attachment state test/modification
// =======================================================================================================================================================
function bool IsAttached()
{
	if (InUse())
		return MyPlayer.bLobbyAttached;
	else
		return false;
}

function AttachToSlot(bool bAttach)
{
	if (InUse())
	{
		MyPlayer.SetLobbyAttached(bAttach);
	}
}

function bool IsTeamGerman()
{
	if (InUse())
		return MyPlayer.IsTeamGerman();

	return false;
}

function bool IsTeamUSA()
{
	if (InUse())
		return MyPlayer.IsTeamUSA();

	return false;
}

defaultproperties
{
	WinWidth=0.04
	WinHeight=0.06
	WinLeft=0.0

	bIsLocal=false
	bIsAttached=false

	bAcceptsInput=false
	bTabStop=false
	bNeverFocus=true

	StrPlayerNum="P"
}
class gbx_MPLobbyServer extends gbx_MPLobby;


var int					ServerPlayerSlot;

var localized string	strRemovePlayer;
var localized string	strBeginGame;
var localized string	strCancelCountdown;
var localized string	strSpeedupCountdown;

var float				CountdownStopTime;					

var bool				ServerMayPlayAlone;
var bool				AllowUnbalancedTeams;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	GUILog("Opening server lobby....");
	Super.InitComponent(MyController, MyOwner);

	// initialize the server player slot to be the same as the player slot the server is in
	SetServerPlayerSlot(PlayerMarkers[0].MyPlayerSlot);	// server is always controller 0
}

function Timer()
{
	local gbx_MPLobbyPlayer selPlayer;
	local int marker;

	Super.Timer();

	selPlayer = PlayerSlots[ServerPlayerSlot];
	if (selPlayer != None)
	{
		marker = GetPlayerMarkerAttachedToSlot(selPlayer.MyPlayerSlot);

		if ((marker != -1) && (marker != FindPlayerMarkerForController(Controller.GetControllerIndexForPlayer(0)) ))
		{
			SetupXButton(strRemovePlayer);
		}
		else
		{
			SetupXButton();
		}
	}

	if (AllReady())
		SetupAButtonCaptions(strBeginGame, StrReady);
	else
		SetupAButtonCaptions("", StrReady);
}

function int GetAttachmentSlotForLocalPlayer(int localControllerNum)
{
	if (localControllerNum == Controller.GetControllerIndexForPlayer(0))
		return ServerPlayerSlot;

	return Super.GetAttachmentSlotForLocalPlayer(localControllerNum);
}

function SetServerPlayerSlot(int slot)
{
	GUILog("Setting ServerPlayerSlot=" $slot $" with current server player slot=" $PlayerMarkers[0].MyPlayerSlot);
	ServerPlayerSlot = slot;
}

function OnChooseSlot(int marker, int slot)
{
	Super.OnChooseSlot(marker, slot);
	if (Controller.ControllerID == Controller.GetControllerIndexForPlayer(0))	// the "host" controller
	{
		SetServerPlayerSlot(slot);
	}
}

function int PrevSlot(int marker)
{
	local int slot;

	// if we're the host controller and attached, move the cursor instead
	if ((Controller.ControllerID == Controller.GetControllerIndexForPlayer(0)) && PlayerMarkers[marker].IsAttached())
	{
		slot = GetPrevSlot(ServerPlayerSlot);
		OnChooseSlot(marker, slot);
		return slot;
	}
	
	return Super.PrevSlot(marker);
}

function int NextSlot(int marker)
{
	local int slot;

	// if we're the host controller and attached, move the cursor instead
	if ((Controller.ControllerID == Controller.GetControllerIndexForPlayer(0)) && PlayerMarkers[marker].IsAttached())
	{
		slot = GetNextSlot(ServerPlayerSlot);
		OnChooseSlot(marker, slot);
		return slot;
	}
	
	return Super.NextSlot(marker);
}

function int ChangeTeam(int marker)
{
	local int slot;

	// if we're the host controller and attached, move the cursor instead
	if ((Controller.ControllerID == Controller.GetControllerIndexForPlayer(0)) && PlayerMarkers[marker].IsAttached())
	{
		slot = GetTeamChangeSlot(ServerPlayerSlot);
		OnChooseSlot(marker, slot);
		return slot;
	}

	return Super.ChangeTeam(marker);
}

function bool AllReady()
{
	local int plUSA, plGerman;
	if (GetPlayerCounts(plUSA, plGerman))
	{
		return AllowUnbalancedTeams || (abs(plUSA - plGerman) <= 1);
	}

	return false;
}

NotInShip function ShouldAllowServerToPlayAlone()
{
	ServerMayPlayAlone = true;	
}

function bool EverybodyReadyToGo()
{
	local int plUSA, plGerman;
	local bool bAllReady;

	bAllReady = GetPlayerCounts(plUSA, plGerman);

	// 2v1, 2v2, 1v1
	// TODO: what to do when it's 1v0
	if (!bAllReady)
	{
		// TODO: allow server to start game anyway?
		GUILog("Lobby StartGameClick - all players not ready");
		return false;
	}
	else if ( abs(plUSA - plGerman) > 1 )
	{
		// TODO: notify that the teams are out of wack
		GUILog("Lobby StartGameClick - teams unbalanced, USA=" $plUSA $" German=" $plGerman);
		return AllowUnbalancedTeams;
	}
	else if ( (plUSA + plGerman) == 1 )
	{
		ShouldAllowServerToPlayAlone();

		if (!ServerMayPlayAlone)
		{
			Controller.OpenMenu("GUI.gbx_DlgServerPlayAlone");
		}

		return ServerMayPlayAlone;
	}
	else
	{
		return true;
	}
}

function ResolvePlayerAssignments()
{
	local WargamePlayerController PC;
	local PlayerReplicationInfo pri;
	local GameInfo gi;

	gi = PlayerOwner().Level.Game;

	ForEach PlayerOwner().DynamicActors(class'WargamePlayerController', PC)
	{
		pri = PC.PlayerReplicationInfo;

		// Bug 8848: Guys that joined during the countdown should become spectators
		if (FindPlayerMarker(pri) == -1)
		{
			pri.bIsSpectator = true;
			pri.bOnlySpectator = true;
			pri.bOutOfLives = true;

			gi.NumSpectators++;
			gi.NumPlayers--;

			PC.ServerSpectate();
			PC.ClientGotoState('Spectating', 'Begin');
		}
	}
}

// need to figure out what to do if the server op decides to "just go"
function bool TryStartGame()
{
	if (EverybodyReadyToGo())
	{
		ResolvePlayerAssignments();
		ConsoleCommand("SetGameOn 1");
		Controller.CloseAll(false);
	
		class'GameService.GameService'.static.StartMatch();
		
		return true;
	}
}

// on the server, X button detaches a player from the current slot
function OnXButton()
{
	local int marker;
	local gbx_MPLobbyPlayer selPlayer;

	if (Controller.ControllerId == Controller.GetControllerIndexForPlayer(0))
	{
		selPlayer = PlayerSlots[ServerPlayerSlot];
		if (selPlayer != None)
		{
			marker = GetPlayerMarkerAttachedToSlot(selPlayer.MyPlayerSlot);
			if (marker != -1)
			{
				PlayerMarkers[marker].AttachToSlot(false);
			}
		}
	}
}

function OnBButton()
{
	local int marker;

	marker = FindPlayerMarkerForController(Controller.ControllerId);
	if (marker != -1)
	{
		if (PlayerMarkers[marker].IsAttached())
		{
			PlayerMarkers[marker].AttachToSlot(false);

			// resynchronize the marker with the server cursor
			if (Controller.ControllerID == Controller.GetControllerIndexForPlayer(0))
			{
				PlayerMarkers[marker].SetPlayerSlot(ServerPlayerSlot);
				OnChooseSlot(marker, ServerPlayerSlot);
			}
		}
		else
		{
			Controller.PlayClickSound(EClickSound.CS_Back);
			Controller.OpenMenu(class'GameEngine'.default.PopupMPMenuClass, "NOCLOSEALL");
		}
	}
}


function OnAButton()
{
	local int marker;

	if (!Controller.bIsConsole || (Controller.ControllerId == Controller.GetControllerIndexForPlayer(0)))
	{
		marker = FindPlayerMarkerForController(Controller.GetControllerIndexForPlayer(0));
		if (PlayerMarkers[marker].IsAttached())
		{
			Controller.PlayClickSound(EClickSound.CS_Click);

			if (EverybodyReadyToGo())
			{
				StartCountdown();
			}
			return;
		}
	}

	Super.OnAButton();
}

function ProcessChatCommand(string text)
{
	local string PlayerName;
	local string ChatCommand;

	if (Left(text, 1) == "/")
	{
		ChatCommand = Right(text, (Len(text)-1));

		if (Left(ChatCommand, 4) ~= "kick")
		{
			PlayerName = Right(ChatCommand, (Len(ChatCommand)-5)); // length of the word kick plus the space

			if (PlayerName == "")
			{
				ProcessChatCommand("/help");
			}
			else
			{
				txtChatBox.AddText("Kicked " $ PlayerName $ " out of the game session.");
				PlayerOwner().ConsoleCommand("kick " $ PlayerName);
			}
		}
		else if (Left(ChatCommand, 4) ~= "help")
		{
			txtChatBox.AddText("Use /kick <playername> to kick a player from the game session.");
		}
		else
		{
			txtChatBox.AddText("Unrecognized command. Use /help to get help.");
		}
	}
	else
	{
		Super.ProcessChatCommand(text);
	}
}

// =======================================================================================================================================================
// Countdown stuff
// =======================================================================================================================================================

function StartCountdown()
{
	GotoState('Countdown');
}

state CountDown extends CountDownBase
{
	function bool LobbyOnXControllerEvent(byte Id, eXControllerCodes iCode)
	{
		return SAB_OnXControllerEvent(Id, iCode);
	}

	function bool LobbyOnKeyEvent(out byte Key,out byte State,float delta)
	{
		return SAB_KeyEvent(Key, State, delta);
	}

	function OnBButton()
	{
		StopCountdown(COUNTDOWN_ABORTED);
	}

	function OnAButton()
	{
		CountdownStopTime -= 1.0f;
	}

	function OnXButton()
	{
	}

	function OnYButton()
	{
	}

	function StopCountdown(int Status)
	{
		assert(Status < 0);

		if (Status == COUNTDOWN_ABORTED ||
			(Status == COUNTDOWN_SUCCESS && !TryStartGame()))
		{
			UnHideUnwantedControls();
			GotoState('');

			PlayerOwner().GameReplicationInfo.LobbyCountdownTime = COUNTDOWN_ABORTED;
		}
		else
		{
			PlayerOwner().GameReplicationInfo.LobbyCountdownTime = Status;
		}
	}

	function Timer()
	{
		local int difference;
		local float diffBeforeCeil;

		if (PlayerOwner().Level.UniversalTimeSeconds >= CountdownStopTime)
		{
			StopCountdown(COUNTDOWN_SUCCESS);
		}
		else
		{
			diffBeforeCeil = (CountdownStopTime - PlayerOwner().Level.UniversalTimeSeconds);
			difference = Ceil(diffBeforeCeil);
			
			if (difference != PlayerOwner().GameReplicationInfo.LobbyCountdownTime)
			{
				PlayerOwner().GameReplicationInfo.LobbyCountdownTime = difference;
			}
		}

		Super.Timer();
	}

	function TestLinkLiveLoss(optional bool bOpened)
	{
		Super.TestLinkLiveLoss(bOpened);
		//###+ lbouchard: LINKLOSS: We test link loss even on PC, for Ubi.com menus
		//SDJ 03/07/2005: The Ubi.com link test was being done even in LAN games!
		if (!IsSystemLinkGame() && !Controller.LiveFunc.IsLinkActive())
		//oldcode if (Controller.bIsConsole && !Controller.LiveFunc.IsLinkActive())
		//###-
		{
			StopCountdown(COUNTDOWN_ABORTED);
		}
	}

	function HandleLossErrors(int iLostController, bool bLostLive, bool bLostLink)
	{
		StopCountdown(COUNTDOWN_ABORTED);
	}

	function BeginState()
	{
		HideUnwantedControls();

		PlayerOwner().GameReplicationInfo.LobbyCountdownTime = COUNTDOWN_TIME;
		CountdownStopTime = PlayerOwner().Level.UniversalTimeSeconds + COUNTDOWN_TIME;

//		SetupAButton(strSpeedupCountdown);
		SetupBButton(strCancelCountdown);
	}
}

defaultproperties
{
	strRemovePlayer="Unready Player"
	strBeginGame="Begin Game"

	strCancelCountdown="Stop Countdown"
	strSpeedupCountdown="Continue"

	ServerMayPlayAlone=false
	AllowUnbalancedTeams=false
}
class gbx_OptionsAudio extends gbx_OptionsScreen;

var int								iCurrentBrightness;
var int								iCurrentMasterVol;
var int								iCurrentMusicVol;
var bool							bInitializing;

var localized array<string>			StringListVolume;
var localized array<string>			StringListBrightness;

const OPTION_BRIGHTNESS		= 0;
const OPTION_VOL_MASTER		= 1;
const OPTION_VOL_MUSIC		= 2;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	bInitializing = true;  // avoid setting video options prematurely (otherwise screen flickers)
	moSpinListControl(MyComponents[OPTION_BRIGHTNESS]).AddFromList(StringListBrightness);
	moSpinListControl(MyComponents[OPTION_VOL_MASTER]).AddFromList(StringListVolume);
	moSpinListControl(MyComponents[OPTION_VOL_MUSIC]).AddFromList(StringListVolume);
	bInitializing = false;
}

function PageOptionsInit()
{
	iCurrentBrightness = OptionsMenuPage.EditPlayerController.iScreenBrightness;
	iCurrentMasterVol = OptionsMenuPage.EditPlayerController.iMasterVolume;
	iCurrentMusicVol = OptionsMenuPage.EditPlayerController.iMusicVolume;

	SetIntOption(OPTION_BRIGHTNESS, iCurrentBrightness);
	SetIntOption(OPTION_VOL_MASTER, iCurrentMasterVol);
	SetIntOption(OPTION_VOL_MUSIC, iCurrentMusicVol);
}

function bool PageOptionsChanged()
{
	return	IntOptionChanged(OPTION_BRIGHTNESS, iCurrentBrightness) ||
			IntOptionChanged(OPTION_VOL_MASTER, iCurrentMasterVol) ||
			IntOptionChanged(OPTION_VOL_MUSIC, iCurrentMusicVol);
}

function OnComponentChanged(int button, GUIComponent Sender)
{
	if (bInitializing)
		return;

	Super.OnComponentChanged(button, Sender);

	switch(button)
	{
	case OPTION_BRIGHTNESS:
		if (Controller.bIsConsole)
			ConsoleCommand("XBOXBRIGHTNESS" @GetIntOption(OPTION_BRIGHTNESS));
		else
			ConsoleCommand("BRIGHTNESS" @ float(GetIntOption(OPTION_BRIGHTNESS) + 1) / 10.0f);
		break;
	case OPTION_VOL_MASTER:
		ConsoleCommand("SetMasterVolume" @GetIntOption(OPTION_VOL_MASTER));
		break;
	case OPTION_VOL_MUSIC:
		ConsoleCommand("SetMusicVolume" @GetIntOption(OPTION_VOL_MUSIC));
		break;
	}
}

function PageOptionsSave()
{
	if (IntOptionChanged(OPTION_BRIGHTNESS, iCurrentBrightness))
	{
		OptionsMenuPage.EditPlayerController.iScreenBrightness = GetIntOption(OPTION_BRIGHTNESS);
		if (Controller.bIsConsole)
			ConsoleCommand("XBOXBRIGHTNESS" @OptionsMenuPage.EditPlayerController.iScreenBrightness);
		else
			ConsoleCommand("BRIGHTNESS" @ float(OptionsMenuPage.EditPlayerController.iScreenBrightness + 1) / 10.0f);
	}

	if (IntOptionChanged(OPTION_VOL_MASTER, iCurrentMasterVol))
	{
		OptionsMenuPage.EditPlayerController.iMasterVolume = GetIntOption(OPTION_VOL_MASTER);
		ConsoleCommand("SetMasterVolume" @OptionsMenuPage.EditPlayerController.iMasterVolume);
	}

	if (IntOptionChanged(OPTION_VOL_MUSIC, iCurrentMusicVol))
	{
		OptionsMenuPage.EditPlayerController.iMusicVolume = GetIntOption(OPTION_VOL_MUSIC);
		ConsoleCommand("SetMusicVolume" @OptionsMenuPage.EditPlayerController.iMusicVolume);
	}
}

function PageOptionsCancel()
{
	if (IntOptionChanged(OPTION_BRIGHTNESS, iCurrentBrightness))
	{
		if (Controller.bIsConsole)
			ConsoleCommand("XBOXBRIGHTNESS" @iCurrentBrightness);
		else
			ConsoleCommand("BRIGHTNESS" @ float(iCurrentBrightness + 1) / 10.0f);
	}

	if (IntOptionChanged(OPTION_VOL_MASTER, iCurrentMasterVol))
	{
		ConsoleCommand("SetMasterVolume" @iCurrentMasterVol);
	}

	if (IntOptionChanged(OPTION_VOL_MUSIC, iCurrentMusicVol))
	{
		ConsoleCommand("SetMusicVolume" @iCurrentMusicVol);
	}
}

function PageOptionsDefaults()
{
	local string s;

	s = GetConfigString("iScreenBrightness", "Engine.PlayerController", "DefUser");
	SetIntOption(OPTION_BRIGHTNESS, int(s));

	s = GetConfigString("iMasterVolume", "Engine.PlayerController", "DefUser");
	SetIntOption(OPTION_VOL_MASTER, int(s));

	s = GetConfigString("iMusicVolume", "Engine.PlayerController", "DefUser");
	SetIntOption(OPTION_VOL_MUSIC, int(s));
}

defaultproperties
{
	ScreenTitle="Audio/Video Options"

	MyComponents(0)=cSpinMenuOption
	MyComponents(1)=cSpinMenuOption
	MyComponents(2)=cSpinMenuOption

	MyCaptions(0)="Screen Brightness"
	MyCaptions(1)="Master Volume"
	MyCaptions(2)="Music Volume"

	StringListBrightness=("1","2","3","4","5","6","7","8","9","10")
	StringListVolume=("Off","1","2","3","4","5","6","7","8","9","10")
}
class gbx_OptionsAudioPC extends gbx_OptionsScreen;

var int								iCurrentMasterVol;
var int								iCurrentAudioMode;
var bool							bCurrentSystemDriver;
var bool							bCurrentReverseStereo;
var bool							bStreamingAudio;


var localized array<string>			StringListVolume;
var localized array<string>			StringListAudioMode;


const OPTION_VOL_MASTER		= 0;
const OPTION_AUDIO_MODE		= 1;
const OPTION_SYSTEM_DRIVER	= 2;
const OPTION_REVERSE_STEREO	= 3;
const OPTION_STREAMING_AUDIO = 4;


function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	moSpinListControl(MyComponents[OPTION_VOL_MASTER]).AddFromList(StringListVolume);
	moSpinListControl(MyComponents[OPTION_AUDIO_MODE]).AddFromList(StringListAudioMode);
	moSpinListControl(MyComponents[OPTION_SYSTEM_DRIVER]).AddFromList(StringListNoYes);	
	moSpinListControl(MyComponents[OPTION_REVERSE_STEREO]).AddFromList(StringListNoYes);	
	moSpinListControl(MyComponents[OPTION_STREAMING_AUDIO]).AddFromList(StringListNoYes);	

	MyComponents[OPTION_VOL_MASTER].Hide();
	DoComponentLayout();
}

function PageOptionsInit()
{
	iCurrentMasterVol = OptionsMenuPagePC.EditPlayerController.iMasterVolume;
	iCurrentAudioMode = OptionsMenuPagePC.EditPlayerController.iAudioMode;
	bCurrentSystemDriver = OptionsMenuPagePC.EditPlayerController.bSystemDriver;
	bCurrentReverseStereo = OptionsMenuPagePC.EditPlayerController.bReverseStereo;
	bStreamingAudio = OptionsMenuPagePC.EditPlayerController.bStreamingAudio;
	
	SetIntOption(OPTION_VOL_MASTER, iCurrentMasterVol);
	SetIntOption(OPTION_AUDIO_MODE, iCurrentAudioMode);
	SetNoYesOption(OPTION_SYSTEM_DRIVER, bCurrentSystemDriver);
	SetNoYesOption(OPTION_REVERSE_STEREO, bCurrentReverseStereo);
	SetNoYesOption(OPTION_STREAMING_AUDIO, bStreamingAudio);
}

function bool PageOptionsChanged()
{
	return IntOptionChanged(OPTION_AUDIO_MODE, iCurrentAudioMode) ||
		   NoYesOptionChanged(OPTION_SYSTEM_DRIVER, bCurrentSystemDriver) ||
		   NoYesOptionChanged(OPTION_REVERSE_STEREO, bCurrentReverseStereo) ||
		   NOYesOptionChanged(OPTION_STREAMING_AUDIO, bStreamingAudio);
}

function OnComponentChanged(int button, GUIComponent Sender)
{
	Super.OnComponentChanged(button, Sender);

	switch(button)
	{
	//case OPTION_VOL_MASTER:
	//	ConsoleCommand("SetMasterVolume" @GetIntOption(OPTION_VOL_MASTER));
	//	break;
	
	case OPTION_AUDIO_MODE:
		ConsoleCommand("SetAudioMode" @moSpinListControl(MyComponents[OPTION_AUDIO_MODE]).GetIndex());
		break;
			
	case OPTION_SYSTEM_DRIVER:
		ConsoleCommand("SetSystemDriver" @moSpinListControl(MyComponents[OPTION_SYSTEM_DRIVER]).GetIndex());
		break;

	case OPTION_REVERSE_STEREO:
		ConsoleCommand("SetReverseStereo" @moSpinListControl(MyComponents[OPTION_REVERSE_STEREO]).GetIndex());
		break;

	case OPTION_STREAMING_AUDIO:
		ConsoleCommand("SetStreamingAudio" @moSpinListControl(MyComponents[OPTION_STREAMING_AUDIO]).GetIndex());
		break;

	}
}

function PageOptionsSave()
{
	local bool bRestartAudioSystem;

	bRestartAudioSystem = false;

	//if (IntOptionChanged(OPTION_VOL_MASTER, iCurrentMasterVol))
	//{
	//	OptionsMenuPagePC.EditPlayerController.iMasterVolume = GetIntOption(OPTION_VOL_MASTER);
	//	ConsoleCommand("SetMasterVolume" @OptionsMenuPagePC.EditPlayerController.iMasterVolume);
	//}

	if (IntOptionChanged(OPTION_AUDIO_MODE, iCurrentAudioMode))
	{
		OptionsMenuPagePC.EditPlayerController.iAudioMode = GetIntOption(OPTION_AUDIO_MODE);
		ConsoleCommand("SetAudioMode" @moSpinListControl(MyComponents[OPTION_AUDIO_MODE]).GetIndex());
		
		Controller.ReplaceMenu("GUI.gbx_DlgOkRestart" );	//NAC: Replace this menu with the menu that tells them that effects won't change until user restarts
	}

	if (NoYesOptionChanged(OPTION_SYSTEM_DRIVER, bCurrentSystemDriver))
	{
		OptionsMenuPagePC.EditPlayerController.bSystemDriver = GetNoYesOption(OPTION_SYSTEM_DRIVER);
		ConsoleCommand("SetSystemDriver" @moSpinListControl(MyComponents[OPTION_SYSTEM_DRIVER]).GetIndex());
		
		Controller.ReplaceMenu("GUI.gbx_DlgOkRestart" );	//NAC: Replace this menu with the menu that tells them that effects won't change until user restarts
	}
	
	if (NoYesOptionChanged(OPTION_REVERSE_STEREO, bCurrentReverseStereo))
	{
		OptionsMenuPagePC.EditPlayerController.bReverseStereo = GetNoYesOption(OPTION_REVERSE_STEREO);
		ConsoleCommand("SetReverseStereo" @moSpinListControl(MyComponents[OPTION_REVERSE_STEREO]).GetIndex());
	}

	if (NoYesOptionChanged(OPTION_STREAMING_AUDIO, bStreamingAudio))
	{
		OptionsMenuPagePC.EditPlayerController.bStreamingAudio = GetNoYesOption(OPTION_STREAMING_AUDIO);
		ConsoleCommand("SetStreamingAudio" @moSpinListControl(MyComponents[OPTION_STREAMING_AUDIO]).GetIndex());

		Controller.ReplaceMenu("GUI.gbx_DlgOkRestart" );	//NAC: Replace this menu with the menu that tells them that effects won't change until user restarts
	}

	//  PSV: 4/1/2005 No more lame prompting to restart game, let's tear down and recreate the audio engine instead.
	/*if ( bRestartAudioSystem )
	{
		// Stop music.
		log( self$ " Audio system needs to be restarted.  Stopping Music...", 'DevSound' );
		Controller.StopMusic();
		
		log( self$ " Audio system needs to be restarted.  Rebooting sound system...", 'DevSound' );
		PlayerOwner().ConsoleCommand("SOUND_REBOOT");
		
		// Restart music.
		log( self$ " Audio system needs to be restarted.  Restarting Music...", 'DevSound' );
		Controller.StartMusic();
	}*/
}

function PageOptionsCancel()
{

	//if (IntOptionChanged(OPTION_VOL_MASTER, iCurrentMasterVol))
	//{
	//	ConsoleCommand("SetMasterVolume" @iCurrentMasterVol);
	//}

	if (IntOptionChanged(OPTION_AUDIO_MODE, iCurrentAudioMode))
	{
		ConsoleCommand("SetAudioMode" @iCurrentAudioMode);
	}

	if (NoYesOptionChanged(OPTION_SYSTEM_DRIVER, bCurrentSystemDriver))
	{
		if (bCurrentSystemDriver)
			ConsoleCommand("SetSystemDriver 1");
		else
			ConsoleCommand("SetSystemDriver 0");
	}

	if (NoYesOptionChanged(OPTION_REVERSE_STEREO, bCurrentReverseStereo))
	{
		if (bCurrentReverseStereo)
			ConsoleCommand("SetReverseStereo 1");
		else
			ConsoleCommand("SetReverseStereo 0");
	}

	if (NoYesOptionChanged(OPTION_STREAMING_AUDIO, bStreamingAudio))
	{
		if (bStreamingAudio)
			ConsoleCommand("SetStreamingAudio 1");
		else
			ConsoleCommand("SetStreamingAudio 0");
	}
}

function PageOptionsDefaults()
{
	local string s;

	//s = GetConfigString("iMasterVolume", "Engine.PlayerController", "DefUser");
	//SetIntOption(OPTION_VOL_MASTER, int(s));

	s = GetConfigString("iAudioMode", "Engine.PlayerController", "DefUser");
	SetIntOption(OPTION_AUDIO_MODE, int(s));

	s = GetConfigString("bSystemDriver", "Engine.PlayerController", "DefUser");
	SetNoYesOption(OPTION_SYSTEM_DRIVER, bool(s));

	s = GetConfigString("bReverseStereo", "Engine.PlayerController", "DefUser");
	SetNoYesOption(OPTION_REVERSE_STEREO, bool(s));

	s = GetConfigString("bStreamingAudio", "Engine.PlayerController", "DefUser");
	SetNoYesOption(OPTION_STREAMING_AUDIO, bool(s));
}

defaultproperties
{
	ScreenTitle="Audio Options"

	MyComponents(0)=cSpinMenuOption
	MyComponents(1)=cSpinMenuOption
	MyComponents(2)=cSpinMenuOption
	MyComponents(3)=cSpinMenuOption
	MyComponents(4)=cSpinMenuOption


	MyCaptions(0)="Master Volume"
	MyCaptions(1)="Audio Mode"
	MyCaptions(2)="System Driver"
	MyCaptions(3)="Reverse Stereo"
	MyCaptions(4)="Streaming Audio"

	StringListVolume=("Off","1","2","3","4","5","6","7","8","9","10")
	StringListAudioMode=("H/W 3D Audio + EAX","H/W 3D Audio","3D Audio","Safe Mode")
}
class gbx_OptionsController extends gbx_OptionsScreen;

var bool							bCurrentInvert;
var bool							bCurrentVibration;
var int								iCurrentSensVert;
var int								iCurrentSensHorz;

const OPTION_INVERT_THUMBSTICK	= 0;
const OPTION_SENS_HORIZ			= 1;
const OPTION_SENS_VERT			= 2;
const OPTION_CONT_VIBRATION		= 3;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	local int i;
	Super.InitComponent(MyController, MyOwner);

	moSpinListControl(MyComponents[OPTION_INVERT_THUMBSTICK]).AddFromList(StringListNoYes);
	moSpinListControl(MyComponents[OPTION_CONT_VIBRATION]).AddFromList(StringListOffOn);

	for (i=0; i<OptionsMenuPage.EditPlayerInput.LOOK_ACCELERATION_RATE_COUNT; i++)
	{
		moSpinListControl(MyComponents[OPTION_SENS_HORIZ]).Add(String(i+1));
		moSpinListControl(MyComponents[OPTION_SENS_VERT]).Add(String(i+1));
	}

//	moSpinListControl(MyComponents[OPTION_SENS_HORIZ]).AddFromList(StringListSensitivity);
//	moSpinListControl(MyComponents[OPTION_SENS_VERT]).AddFromList(StringListSensitivity);
}

function PageOptionsInit()
{
	bCurrentInvert = !OptionsMenuPage.EditPlayerInput.bInvertMouse;
	bCurrentVibration = OptionsMenuPage.EditPlayerController.bEnableForceFeedback;

	iCurrentSensHorz = OptionsMenuPage.EditPlayerInput.LookYawAcceleration;
	iCurrentSensVert = OptionsMenuPage.EditPlayerInput.LookPitchAcceleration;

	SetNoYesOption(OPTION_INVERT_THUMBSTICK, bCurrentInvert);
	SetNoYesOption(OPTION_CONT_VIBRATION, bCurrentVibration);

	SetIntOption(OPTION_SENS_HORIZ, iCurrentSensHorz);
	SetIntOption(OPTION_SENS_VERT, iCurrentSensVert);
}

function bool PageOptionsChanged()
{
	return	NoYesOptionChanged(OPTION_INVERT_THUMBSTICK, bCurrentInvert) ||
			NoYesOptionChanged(OPTION_CONT_VIBRATION, bCurrentVibration) ||
			IntOptionChanged(OPTION_SENS_HORIZ, iCurrentSensHorz) ||
			IntOptionChanged(OPTION_SENS_VERT, iCurrentSensVert);
}

function PageOptionsSave()
{
	if (NoYesOptionChanged(OPTION_INVERT_THUMBSTICK, bCurrentInvert))
		OptionsMenuPage.EditPlayerInput.bInvertMouse = !GetNoYesOption(OPTION_INVERT_THUMBSTICK);

	if (NoYesOptionChanged(OPTION_CONT_VIBRATION, bCurrentVibration))
		OptionsMenuPage.EditPlayerController.bEnableForceFeedback = GetNoYesOption(OPTION_CONT_VIBRATION);

	if (IntOptionChanged(OPTION_SENS_HORIZ, iCurrentSensHorz))
		OptionsMenuPage.EditPlayerInput.LookYawAcceleration = GetIntOption(OPTION_SENS_HORIZ);

	if (IntOptionChanged(OPTION_SENS_VERT, iCurrentSensVert))
		OptionsMenuPage.EditPlayerInput.LookPitchAcceleration = GetIntOption(OPTION_SENS_VERT);
}

function PageOptionsDefaults()
{
	local string s;

	s = GetConfigString("bInvertMouse", "Engine.PlayerInput", "DefUser");
	SetNoYesOption(OPTION_INVERT_THUMBSTICK, !bool(s));

	s = GetConfigString("bEnableForceFeedback", "Engine.PlayerController", "DefUser");
	SetNoYesOption(OPTION_CONT_VIBRATION, bool(s));

	s = GetConfigString("LookYawAcceleration", "gbxGameplay.WargamePlayerInput", "DefUser");
	SetIntOption(OPTION_SENS_HORIZ, int(s));

	s = GetConfigString("LookPitchAcceleration", "gbxGameplay.WargamePlayerInput", "DefUser");
	SetIntOption(OPTION_SENS_VERT, int(s));
}

defaultproperties
{
	ScreenTitle="Controller Options"

	MyComponents(0)=cSpinMenuOption
	MyComponents(1)=cSpinMenuOption
	MyComponents(2)=cSpinMenuOption
	MyComponents(3)=cSpinMenuOption

	MyCaptions(0)="Invert Thumbstick"
	MyCaptions(1)="Horizontal Sensitivity"
	MyCaptions(2)="Vertical Sensitivity"
	MyCaptions(3)="Controller Vibration"
}
class gbx_OptionsControllerConfig extends gbx_OptionsScreen
	config(Presets);


const COMMAND_Count = 20;
const CONTROLS_Count = 20;
const BUTTONS_Count = 16;
const AXIS_Count = 4;
const BUTTONLABEL_Count = 14;
const AXISLABEL_Count = 6;

enum ECommandType
{
	CT_Invalid,
	CT_None,
	CT_Button,
	CT_Axis,
};

struct ControlCommand
{
	var() ECommandType				CommandType;							// type of this command
	var() string					CommandName;							// config-file name of this command
	var() string					CommandExtra;							// extra info that goes along with this command
};

struct ControlBinding
{
	var() ECommandType				ControlType;							// type of this key
	var() string					ControlName;							// config-file name of this key
	var() int						CommandIndex;							// which item in CommandList is this control assigned to?
	var() string					ButtonCommandName;						// commands hard-wired to a particular button
};

struct BindingPreset
{
	var() ECommandType				PresetType;								// type of this preset.
	var() string					PresetName;								// displayed name of this preset
	var() array<string>				PresetCommands;							// one-one mapping to a ControlBinding array
	var() ControlBinding			PresetControlBinding[CONTROLS_Count];
};

struct ControlLabelDef
{
	var() GUIFRect					WinRect;								// position of the on-screen label
	var() int						ControlIndex;							// index of the ControlBinding that's displayed in this label
	var() eTextAlign				TextAlign;
	var() GUILabel					MyLabel;								// ref to an entry in lblControlBindings
};

// controller gfx/overlays
var automated GUIImage				imgController;
var automated GUIImage				imgLTrigger;
var automated GUIImage				imgRTrigger;
var automated GUIImage				imgBackgroundLeft;
var automated GUIImage				imgBackgroundRight;

var localized string				CommandDescNames[COMMAND_Count];
var ControlCommand					CommandList[COMMAND_Count];				// pool of possible commands
var ControlBinding					ControlBindings[CONTROLS_Count];		// current displayed control bindings
var ControlBinding					ActiveBindings[CONTROLS_Count];			// active set of control bindings

// labels
var automated array<GUILabel>		lblControlBindings;
var ControlLabelDef					ButtonBindings[BUTTONLABEL_Count];			// labels viewed in CT_Button mode
var ControlLabelDef					AxisBindings[AXISLABEL_Count];				// labels viewed in CT_Axis mode

// spin controls
var ECommandType					ChangingCommandType;
var moSpinListControl				spnAxisPresets;
var moSpinListControl				spnButtonPresets;


var config array<BindingPreset>		BindingPresets;


var localized string				StrCurrentConfig;
var localized string				StrUnknownCommand;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	local int i, c, presetIndex;

	Super.InitComponent(MyController, MyOwner);

	// get the grigger graphics
	class'GUIHelpLButton'.static.GetTexCoords(self, imgLTrigger.X1, imgLTrigger.Y1, imgLTrigger.X2, imgLTrigger.Y2);
	imgLTrigger.X2 += imgLTrigger.X1;
	imgLTrigger.Y2 += imgLTrigger.Y1;

	class'GUIHelpRButton'.static.GetTexCoords(self, imgRTrigger.X1, imgRTrigger.Y1, imgRTrigger.X2, imgRTrigger.Y2);
	imgRTrigger.X2 += imgRTrigger.X1;
	imgRTrigger.Y2 += imgRTrigger.Y1;

	spnAxisPresets = moSpinListControl(MyComponents[0]);
	spnButtonPresets = moSpinListControl(MyComponents[1]);

	InitPresets();

	InitBinding(ActiveBindings, true);
	InitCommandExtras();
	CopyBindings(ControlBindings, ActiveBindings, CT_None);

	// find the current (active) bindings and select the correct spin list item

	// set up the binding labels
	c = 0;
	for (i=0; i<BUTTONLABEL_Count; i++)
	{
		ButtonBindings[i].MyLabel = lblControlBindings[c];
		ButtonBindings[i].MyLabel.SetWinDims(ButtonBindings[i].WinRect);
		ButtonBindings[i].MyLabel.TextAlign = ButtonBindings[i].TextAlign;
		c++;
	}

	for (i=0; i<AXISLABEL_Count; i++)
	{
		AxisBindings[i].MyLabel = lblControlBindings[c];
		AxisBindings[i].MyLabel.SetWinDims(AxisBindings[i].WinRect);
		AxisBindings[i].MyLabel.TextAlign = AxisBindings[i].TextAlign;
		c++;
	}

	spnAxisPresets.LoseFocus(None);
	spnAxisPresets.SetFocus(None);

	// choose a binding set to display by default
	for (i=1; i<spnButtonPresets.ItemCount(); i++)
	{
		presetIndex = int(spnButtonPresets.MySpinListControl.GetExtraAtIndex(i));
		if (presetIndex != -1)
		{
			if (SameBindings(ActiveBindings, BindingPresets[presetIndex].PresetControlBinding, CT_Button))
				break;
		}
	}

	if (i == spnButtonPresets.ItemCount()) i = 0;
	spnButtonPresets.SetIndex(i);

	for (i=1; i<spnAxisPresets.ItemCount(); i++)
	{
		presetIndex = int(spnAxisPresets.MySpinListControl.GetExtraAtIndex(i));
		if (presetIndex != -1)
		{
			if (SameBindings(ActiveBindings, BindingPresets[presetIndex].PresetControlBinding, CT_Axis))
				break;
		}
	}

	if (i == spnAxisPresets.ItemCount()) i = 0;
	spnAxisPresets.SetIndex(i);

}

function InitBinding(out ControlBinding dst[CONTROLS_Count], optional bool bLookupActive)
{
	local int i;
	local string s;

    for (i=0; i<CONTROLS_Count; i++)
	{
		dst[i].ControlType = ControlBindings[i].ControlType;
		dst[i].ControlName = ControlBindings[i].ControlName;

		if (bLookupActive)
		{
			s = GetActiveCommandForKeyName( dst[i].ControlName, dst[i].ButtonCommandName, dst[i].ControlType );
			dst[i].CommandIndex = FindCommandIndex(s);
			GUILog("InitBinding:" @dst[i].ControlName @"=" @GetCommandBindingString(GetCommandName(dst[i].CommandIndex), dst[i].ButtonCommandName, dst[i].ControlType));
		}
	}
}

function InitCommandExtras()
{
	local int i;

    for (i=0; i<CONTROLS_Count; i++)
	{
		if (ActiveBindings[i].ControlType == CT_Axis)
		{
			CommandList[ ActiveBindings[i].CommandIndex ].CommandExtra = ActiveBindings[i].ButtonCommandName;
		}
	}
}

function InitPresets()
{
	local int preset;

	// first, add entries for the current settings
	spnButtonPresets.Add(StrCurrentConfig,,"-1");
	spnAxisPresets.Add(StrCurrentConfig,,"-1");

	for (preset=0; preset<BindingPresets.Length; preset++)
	{
		BindingPresets[preset].PresetName = Localize("Names",BindingPresets[preset].PresetName,"Presets");

		GUILog("Initializing preset " $BindingPresets[preset].PresetName $", type=" $BindingPresets[preset].PresetType );

		if (InitPresetBinding(BindingPresets[preset].PresetControlBinding, BindingPresets[preset].PresetCommands))
		{
			// add the preset to the proper list
			if (BindingPresets[preset].PresetType == CT_Button)
			{
				GUILog("	Preset added to button list.");

				spnButtonPresets.Add(BindingPresets[preset].PresetName,,String(preset));
			}
			else if (BindingPresets[preset].PresetType == CT_Axis)
			{
				GUILog("	Preset added to axis list.");

				spnAxisPresets.Add(BindingPresets[preset].PresetName,,String(preset));
			}
			else if (BindingPresets[preset].PresetType == CT_None)
			{
				GUILog("	Preset added to both lists.");

				spnButtonPresets.Add(BindingPresets[preset].PresetName,,String(preset));
				spnAxisPresets.Add(BindingPresets[preset].PresetName,,String(preset));
			}
			else
			{
				GUILog("	Preset has invalid type.");
			}
		}
		else
		{
			BindingPresets[preset].PresetType = CT_Invalid;
		}
	}
}

function bool InitPresetBinding(out ControlBinding dst[CONTROLS_Count], array<string> commands)
{
	local int i;

	if (commands.Length != CONTROLS_Count)
	{
		GUILog("	Preset has incorrect number of commands in PresetCommands List.");
		return false;
	}

	// seed the values in the preset
    for (i=0; i<CONTROLS_Count; i++)
    {
        dst[i].ControlType = ControlBindings[i].ControlType;
		dst[i].ControlName = ControlBindings[i].ControlName;
		dst[i].CommandIndex = FindCommandIndex(commands[i]);
    }

	return true;
}

function int FindCommandIndex(out string cmd)
{
	local int i;

	for (i=0; i<COMMAND_Count; i++)
	{
		if (cmd ~= CommandList[i].CommandName)
		{
			cmd = CommandList[i].CommandName;	// keep things uniform so return the exact string also
			return i;
		}
	}

	return -1;
}

function string GetActiveCommandForKeyName(string keyname, out string extraCommands, ECommandType cmdType)
{
	local string s, result;
	local bool bFoundBinding;
	local int i;

	extraCommands = "";
	keyname = OptionsMenuPage.EditPlayerController.ConsoleCommand("KEYBINDING "$keyname);

	if (cmdType == CT_Axis)
	{
		for (i=0; i<COMMAND_Count; i++)
		{
			if (CommandList[i].CommandType == CT_Axis)
			{
				if (ParseCommand(keyname, CommandList[i].CommandName))
				{
					result = CommandList[i].CommandName;
					extraCommands = keyname;
					TrimSpaces(extraCommands);
					break;
				}
			}
		}
	}
	else
	{
		s = ParseKeyBindingToken(keyname);
		while (s != "")
		{
			if (!bFoundBinding)
			{
				if (FindCommandIndex(s) != -1)
				{
					result = s;
					bFoundBinding = true;
					s = "";
				}
			}

			if (s != "")
			{
				if (extraCommands != "")
					extraCommands = extraCommands $ " | ";

				extraCommands = extraCommands $ s;
			}

			s = ParseKeyBindingToken(keyname);
		}
	}

	return result;
}

function CopyBindings(out ControlBinding dst[CONTROLS_Count], ControlBinding src[CONTROLS_Count], ECommandType copyType)
{
    local int i;
    for (i=0; i<CONTROLS_Count; i++)
    {
		if ((copyType == CT_None) || (src[i].ControlType == copyType))
		{
			dst[i].CommandIndex = src[i].CommandIndex;
		}
    }
}

function bool SameBindings(ControlBinding cb1[CONTROLS_Count], ControlBinding cb2[CONTROLS_Count], ECommandType compareType)
{
    local int i;
    for (i=0; i<CONTROLS_Count; i++)
    {
		// if comparing including axis type then ignore entries whose types differ
		if (compareType != CT_None)
		{
			if ((cb1[i].ControlType != compareType) || (cb1[i].ControlType != compareType))
				continue;
		}

		// otherwise, all fields must be the same
        if (cb1[i].CommandIndex != cb2[i].CommandIndex)
        {
            return false;
        }
    }

    return true;
}

function string GetCommandName(int index)
{
	if ((index >= 0) && (index < COMMAND_Count))
		return CommandList[index].CommandName;
	else
		return "";
}

function string GetCommandDesc(int index)
{
	if ((index >= 0) && (index < COMMAND_Count))
		return CommandDescNames[index];
	else
		return StrUnknownCommand;
}

function PopulateBindingstoLabels(ControlBinding src[CONTROLS_Count])
{
    local int i,index;

	for (i=0; i<lblControlBindings.Length; i++)
    {
		lblControlBindings[i].Hide();
	}

//	return;
	if (ChangingCommandType == CT_Axis)
	{
		for (i=0; i<AXISLABEL_Count; i++)
		{
			// binding control index -> command -> desc
			index = src[AxisBindings[i].ControlIndex].CommandIndex;
			AxisBindings[i].MyLabel.SetCaption( GetCommandDesc(index) );
			AxisBindings[i].MyLabel.Show();
		}
	}
	else
	{
		for (i=0; i<BUTTONLABEL_Count; i++)
		{
			// binding control index -> command -> desc
			index = src[ButtonBindings[i].ControlIndex].CommandIndex;
			ButtonBindings[i].MyLabel.SetCaption( GetCommandDesc(index) );
			ButtonBindings[i].MyLabel.Show();
		}
	}
}

function SetupControllerPic()
{
	if (ChangingCommandType == CT_Axis)
	{
		imgController.Y1 = 256;
		imgController.Y2 = 511;
	}
	else
	{
		imgController.Y1 = 0;
		imgController.Y2 = 255;
	}
}

event SetFocus(GUIComponent Who)
{
	Super.SetFocus(Who);

	GUILog("ControllerConfig SetFocus " $Who);
	if (Who == spnAxisPresets)
	{
		ChangingCommandType = CT_Axis;
		spnAxisPresets.SetIndex(spnAxisPresets.GetIndex());
		imgRTrigger.Hide();
		imgLTrigger.Hide();
	}
	else if (Who == spnButtonPresets)
	{
		ChangingCommandType = CT_Button;
		spnButtonPresets.SetIndex(spnButtonPresets.GetIndex());
		imgRTrigger.Show();
		imgLTrigger.Show();
	}

	SetupControllerPic();
}

function OnComponentChanged(int button, GUIComponent Sender)
{
	local int presetIndex;

	presetIndex = -1;
	if (button == 0)
	{
		presetIndex = spnAxisPresets.GetIndex();
		if (presetIndex != -1)
			presetIndex = int(spnAxisPresets.GetExtra());
	}
	else if (button == 1)
	{
		presetIndex = spnButtonPresets.GetIndex();
		if (presetIndex != -1)
			presetIndex = int(spnButtonPresets.GetExtra());
	}
	
	if (presetIndex != -1)
	{
		GUILog("Copying bindings from preset #" $presetIndex $BindingPresets[presetIndex].PresetName);
		CopyBindings(ControlBindings, BindingPresets[presetIndex].PresetControlBinding, ChangingCommandType);
	}
	else
	{
		GUILog("Copying bindings from current settings");
		CopyBindings(ControlBindings, ActiveBindings, ChangingCommandType);
	}

	PopulateBindingstoLabels(ControlBindings);

	Super.OnComponentChanged(button, Sender);
}

function bool PageOptionsChanged()
{
	return !SameBindings(ControlBindings, ActiveBindings, CT_None);
}

function string GetCommandBindingString(string keyname, string extraCommands, ECommandType cmdType)
{
	if (extraCommands != "")
	{
		if (cmdType == CT_Button)
			keyname = keyname @"|" @extraCommands;
		else if (cmdType == CT_Axis)
			keyname = keyname @extraCommands;
	}

	return keyname;
}

function PageOptionsSave()
{
	local int i;
	local string keyname, binding;

    for (i=0; i<CONTROLS_Count; i++)
    {
        keyname = ControlBindings[i].ControlName;
		if (ControlBindings[i].ControlType == CT_Axis)
			binding = GetCommandBindingString(GetCommandName(ControlBindings[i].CommandIndex), CommandList[ControlBindings[i].CommandIndex].CommandExtra, ControlBindings[i].ControlType);
		else
			binding = GetCommandBindingString(GetCommandName(ControlBindings[i].CommandIndex), ActiveBindings[i].ButtonCommandName, ControlBindings[i].ControlType);

		GUILog("Applying keybinding: " $keyname $"=" $binding);
		OptionsMenuPage.EditPlayerController.ConsoleCommand("SETINPUT GAMEPAD_INDEX="$OptionsMenuPage.EditPlayerController.Player.GamePadIndex @"KEY="$keyname$" BINDING="$MakeQuotedString(binding));
    }
}

function PageOptionsDefaults()
{
	local ECommandType oldCmdType;

	oldCmdType = ChangingCommandType;

	ChangingCommandType = CT_Axis;
	spnAxisPresets.SetIndex(1);

	ChangingCommandType = CT_Button;
	spnButtonPresets.SetIndex(1);

	ChangingCommandType = oldCmdType;
	PopulateBindingstoLabels(ControlBindings);
}

defaultproperties
{
	ScreenTitle="Controls"
	LayoutPivotPoint=0.17
	LayoutSpacing=0.01
	LayoutPivotStyle=LA_Left_Top

	ChangingCommandType=CT_Axis
	MyComponents(0)=cSpinMenuOption
	MyComponents(1)=cSpinMenuOption

	MyCaptions(0)="Thumbstick Controls"
	MyCaptions(1)="Button Controls"

	CommandList(0)=(CommandType=CT_Button,CommandName="Jump")
	CommandList(1)=(CommandType=CT_Button,CommandName="MeleeAttack")
	CommandList(2)=(CommandType=CT_Button,CommandName="AUse")
	CommandList(3)=(CommandType=CT_Button,CommandName="AltFire")
	CommandList(4)=(CommandType=CT_Button,CommandName="ASelectWeapon")
	CommandList(5)=(CommandType=CT_Button,CommandName="UnitSelect")
	CommandList(6)=(CommandType=CT_Button,CommandName="ACommand")
	CommandList(7)=(CommandType=CT_Button,CommandName="Fire")
	CommandList(8)=(CommandType=CT_Button,CommandName="FallOutInput")
	CommandList(9)=(CommandType=CT_Button,CommandName="FallInInput")
	CommandList(10)=(CommandType=CT_Button,CommandName="ASelectUnitFire")
	CommandList(11)=(CommandType=CT_Button,CommandName="ASelectUnitAssault")
	CommandList(12)=(CommandType=CT_Button,CommandName="ShowMenu")
	CommandList(13)=(CommandType=CT_Button,CommandName="ActivateOracle")
	CommandList(14)=(CommandType=CT_Button,CommandName="Duck")
	CommandList(15)=(CommandType=CT_Button,CommandName="AZoom")
	CommandList(16)=(CommandType=CT_Axis,CommandName="Axis aStrafe")
	CommandList(17)=(CommandType=CT_Axis,CommandName="Axis aBaseY")
	CommandList(18)=(CommandType=CT_Axis,CommandName="Axis aBaseX")
	CommandList(19)=(CommandType=CT_Axis,CommandName="Axis aLookup")

	CommandDescNames(0)="Jump"
	CommandDescNames(1)="Melee"
	CommandDescNames(2)="Reload / Context Use"
	CommandDescNames(3)="Throw Grenade"
	CommandDescNames(4)="Select Weapon"
	CommandDescNames(5)="Select Unit"
	CommandDescNames(6)="Command Unit"
	CommandDescNames(7)="Fire"
	CommandDescNames(8)="Fall Out"
	CommandDescNames(9)="Fall In"
	CommandDescNames(10)="Select Fire Team"
	CommandDescNames(11)="Select Assault / Tank Team"
	CommandDescNames(12)="Pause Menu"
	CommandDescNames(13)="Situational Awareness"
	CommandDescNames(14)="Crouch"
	CommandDescNames(15)="Zoom"
	CommandDescNames(16)="Strafe"
	CommandDescNames(17)="Move Foward / Back"
	CommandDescNames(18)="Turn"
	CommandDescNames(19)="Look Up / Down"

	ControlBindings(0)=(ControlType=CT_Button,ControlName="Joy1",CommandIndex=0)	// A
	ControlBindings(1)=(ControlType=CT_Button,ControlName="Joy2",CommandIndex=0)	// B
	ControlBindings(2)=(ControlType=CT_Button,ControlName="Joy3",CommandIndex=0)	// X
	ControlBindings(3)=(ControlType=CT_Button,ControlName="Joy4",CommandIndex=0)	// Y
	ControlBindings(4)=(ControlType=CT_Button,ControlName="Joy5",CommandIndex=0)	// Black
	ControlBindings(5)=(ControlType=CT_Button,ControlName="Joy6",CommandIndex=0)	// white
	ControlBindings(6)=(ControlType=CT_Button,ControlName="Joy7",CommandIndex=0)	// L-Trigger
	ControlBindings(7)=(ControlType=CT_Button,ControlName="Joy8",CommandIndex=0)	// R-Trigger
	ControlBindings(8)=(ControlType=CT_Button,ControlName="Joy9",CommandIndex=0)	// D-Up
	ControlBindings(9)=(ControlType=CT_Button,ControlName="Joy10",CommandIndex=0)	// D-Down
	ControlBindings(10)=(ControlType=CT_Button,ControlName="Joy11",CommandIndex=0)	// D-Left
	ControlBindings(11)=(ControlType=CT_Button,ControlName="Joy12",CommandIndex=0)	// D-Right
	ControlBindings(12)=(ControlType=CT_Button,ControlName="Joy13",CommandIndex=0)	// start
	ControlBindings(13)=(ControlType=CT_Button,ControlName="Joy14",CommandIndex=0)	// back
	ControlBindings(14)=(ControlType=CT_Button,ControlName="Joy15",CommandIndex=0)	// L-Thumb Click
	ControlBindings(15)=(ControlType=CT_Button,ControlName="Joy16",CommandIndex=0)	// R-Thumb Click
	ControlBindings(16)=(ControlType=CT_Axis,ControlName="JoyX",CommandIndex=0)
	ControlBindings(17)=(ControlType=CT_Axis,ControlName="JoyY",CommandIndex=0)
	ControlBindings(18)=(ControlType=CT_Axis,ControlName="JoyU",CommandIndex=0)
	ControlBindings(19)=(ControlType=CT_Axis,ControlName="JoyV",CommandIndex=0)

	Begin Object Class=GUILabel Name=clblControllerButton
		StyleName="TextLabel"
		TextAlign=TXTA_Left
		TextAlignV=TXTA_Center
		DrawMenuState=1
		bAcceptsInput=false
		bMultiline=true
		bNeverFocus=true
		bTabStop=false
		WinWidth=0.400000
		WinHeight=0.0350000
		WinLeft=0.0875000
		WinTop=0.7700000
		RenderWeight=0.5
		bClientBounded=false
		bForceCaps=true
	End Object
	lblControlBindings(0)=clblControllerButton
	lblControlBindings(1)=clblControllerButton
	lblControlBindings(2)=clblControllerButton
	lblControlBindings(3)=clblControllerButton
	lblControlBindings(4)=clblControllerButton
	lblControlBindings(5)=clblControllerButton
	lblControlBindings(6)=clblControllerButton
	lblControlBindings(7)=clblControllerButton
	lblControlBindings(8)=clblControllerButton
	lblControlBindings(9)=clblControllerButton
	lblControlBindings(10)=clblControllerButton
	lblControlBindings(11)=clblControllerButton
	lblControlBindings(12)=clblControllerButton
	lblControlBindings(13)=clblControllerButton
	lblControlBindings(14)=clblControllerButton
	lblControlBindings(15)=clblControllerButton
	lblControlBindings(16)=clblControllerButton
	lblControlBindings(17)=clblControllerButton
	lblControlBindings(18)=clblControllerButton
	lblControlBindings(19)=clblControllerButton

	Begin Object Class=GUIImage Name=cimgController
		Image=Material't_interface_mb.HUD.xbox_controller_b'
		ImageColor=(R=255,G=255,B=255,A=255)
		ImageStyle=ISTY_Scaled
		ImageRenderStyle=MSTY_Alpha
		X1=0
		Y1=0
		X2=389
		Y2=256
		WinLeft=0.19609375
//		WinTop=0.27
//		WinHeight=0.53333
		WinTop=0.295
		WinHeight=0.48
		WinWidth=0.6078125
		RenderWeight=0.4
		bAcceptsInput=false
		bNeverFocus=true
		bTabStop=false
	End Object
	imgController=cimgController

	Begin Object Class=GUIImage Name=cimgBackgroundLeft
		Image=Material't_interface_mb.HUD.controller_bg'
		ImageColor=(R=13,G=5,B=8,A=220)
		ImageStyle=ISTY_Scaled
		ImageRenderStyle=MSTY_Alpha
		X1=0
		Y1=0
		X2=275
		Y2=256
		WinLeft=-0.03
		WinTop=0.295
		WinHeight=0.48
		WinWidth=0.43
		RenderWeight=0.3
		bAcceptsInput=false
		bNeverFocus=true
		bTabStop=false
	End Object
	imgBackgroundLeft=cimgBackgroundLeft

	Begin Object Class=GUIImage Name=cimgBackgroundRight
		Image=Material't_interface_mb.HUD.controller_bg'
		ImageColor=(R=13,G=5,B=8,A=220)
		ImageStyle=ISTY_Scaled
		ImageRenderStyle=MSTY_Alpha
		X1=275
		Y1=0
		X2=0
		Y2=256
		WinLeft=0.6
		WinTop=0.295
		WinHeight=0.48
		WinWidth=0.43
		RenderWeight=0.3
		bAcceptsInput=false
		bNeverFocus=true
		bTabStop=false
	End Object
	imgBackgroundRight=cimgBackgroundRight

	Begin Object Class=GUIImage Name=cimgLTrigger
		Image=Material't_interface_mb.hud.xbox_button_art'
		ImageColor=(R=255,G=255,B=255,A=255)
		ImageStyle=ISTY_Scaled
		ImageRenderStyle=MSTY_Alpha
		X1=0
		Y1=0
		X2=0
		Y2=0
		WinLeft=0.41
		WinTop=0.31
		WinHeight=0.048
		WinWidth=0.05
		RenderWeight=0.5
		bAcceptsInput=false
		bNeverFocus=true
		bTabStop=false
	End Object
	imgLTrigger=cimgLTrigger

	Begin Object Class=GUIImage Name=cimgRTrigger
		Image=Material't_interface_mb.hud.xbox_button_art'
		ImageColor=(R=255,G=255,B=255,A=255)
		ImageStyle=ISTY_Scaled
		ImageRenderStyle=MSTY_Alpha
		X1=0
		Y1=0
		X2=0
		Y2=0
		WinLeft=0.54
		WinTop=0.31
		WinHeight=0.048
		WinWidth=0.05
		RenderWeight=0.5
		bAcceptsInput=false
		bNeverFocus=true
		bTabStop=false
	End Object
	imgRTrigger=cimgRTrigger

//	ButtonBindings(0)=(WinRect=(fL=0.0375,fT=0.6625,fW=0.046875,fH=0.035), )
//	ButtonBindings(0)=(WinRect=(fL=0.0375,fT=0.6625,fW=0.046875,fH=0.035), )

	// left side: left trigger, back, start, dpad (up, down, left, right)
	ButtonBindings(0)=(WinRect=(fL=0.0375,fT=0.305,fW=0.24,fH=0.067),ControlIndex=6,TextAlign=TXTA_Right)
	ButtonBindings(1)=(WinRect=(fL=0.0375,fT=0.372,fW=0.24,fH=0.067),ControlIndex=13,TextAlign=TXTA_Right)
	ButtonBindings(2)=(WinRect=(fL=0.0375,fT=0.439,fW=0.24,fH=0.067),ControlIndex=12,TextAlign=TXTA_Right)
	ButtonBindings(3)=(WinRect=(fL=0.0375,fT=0.506,fW=0.24,fH=0.067),ControlIndex=8,TextAlign=TXTA_Right)
	ButtonBindings(4)=(WinRect=(fL=0.0375,fT=0.573,fW=0.24,fH=0.067),ControlIndex=9,TextAlign=TXTA_Right)
	ButtonBindings(5)=(WinRect=(fL=0.0375,fT=0.64,fW=0.24,fH=0.067),ControlIndex=10,TextAlign=TXTA_Right)
	ButtonBindings(6)=(WinRect=(fL=0.0375,fT=0.707,fW=0.24,fH=0.067),ControlIndex=11,TextAlign=TXTA_Right)

	// right side: right trigger, x, y, b, a, black, white
	ButtonBindings(7)=(WinRect=(fL=0.7225,fT=0.305,fW=0.24,fH=0.067),ControlIndex=7,TextAlign=TXTA_Left)
	ButtonBindings(8)=(WinRect=(fL=0.7225,fT=0.372,fW=0.24,fH=0.067),ControlIndex=2,TextAlign=TXTA_Left)
	ButtonBindings(9)=(WinRect=(fL=0.7225,fT=0.439,fW=0.24,fH=0.067),ControlIndex=3,TextAlign=TXTA_Left)
	ButtonBindings(10)=(WinRect=(fL=0.7225,fT=0.506,fW=0.24,fH=0.067),ControlIndex=1,TextAlign=TXTA_Left)
	ButtonBindings(11)=(WinRect=(fL=0.7225,fT=0.573,fW=0.24,fH=0.067),ControlIndex=0,TextAlign=TXTA_Left)
	ButtonBindings(12)=(WinRect=(fL=0.7225,fT=0.64,fW=0.24,fH=0.067),ControlIndex=4,TextAlign=TXTA_Left)
	ButtonBindings(13)=(WinRect=(fL=0.7225,fT=0.707,fW=0.24,fH=0.067),ControlIndex=5,TextAlign=TXTA_Left)

	// left side: X, Y, click
	AxisBindings(0)=(WinRect=(fL=0.0375,fT=0.305,fW=0.24,fH=0.067),ControlIndex=17,TextAlign=TXTA_Right)
	AxisBindings(1)=(WinRect=(fL=0.0375,fT=0.372,fW=0.24,fH=0.067),ControlIndex=16,TextAlign=TXTA_Right)
	AxisBindings(2)=(WinRect=(fL=0.0375,fT=0.439,fW=0.24,fH=0.067),ControlIndex=14,TextAlign=TXTA_Right)

	// right side: click, X, Y
	AxisBindings(3)=(WinRect=(fL=0.7225,fT=0.305,fW=0.24,fH=0.067),ControlIndex=19,TextAlign=TXTA_Left)
	AxisBindings(4)=(WinRect=(fL=0.7225,fT=0.372,fW=0.24,fH=0.067),ControlIndex=18,TextAlign=TXTA_Left)
	AxisBindings(5)=(WinRect=(fL=0.7225,fT=0.439,fW=0.24,fH=0.067),ControlIndex=15,TextAlign=TXTA_Left)

//	BindingPresets(0)=(PresetName="Default Button",PresetCommands=("AJump","AMelee","AUse","AGrenade","ASelectWeapon","ASelectUnit","ACommand","AFire","AFallOut","AFallIn","ASelectUnitFire","ASelectUnitAssault","ShowMenu","AActivateOracle","Duck","AZoom","AStickStrafe","AStickMove","AStickTurn","AStickLook"))

	StrCurrentConfig="Current"
	StrUnknownCommand="Unrecognized"
}
class gbx_OptionsControlsPC extends gbx_OptionsScreen;

const NUM_COMMAND_GROUPS = 5;
const NUM_COMMANDS = 35;
const NUM_KEYS = 256;
const MAX_BINDS_PER_COMMAND = 2;

struct KeyBindInfo
{
	var int							KeyIndex;
	var string						KeyName;
};

struct KeyInfo
{
	var bool						bManaged;		// we encountered this key so update its bindings when we save
	var string						ExtraBinds;		// extra binds that must be attached to this key
};

struct CommandGroupKeys
{
	var array<KeyBindInfo>			Keys;
};

struct CommandGroup
{
	var array<int>					Commands;		// index into comand manifest
};


var moSpinListControl						spnCategory;
var Automated gbx_LiveLeaderboardProgress	lblPressPrompt;
var Automated GUIMultiColumnListBox			Bindings;
var gbx_ControllerConfigPCList				BindingsList;

var int										SelectedEditBind;

var KeyInfo									AllKeys[NUM_KEYS];
var CommandGroup							CommandGroups[NUM_COMMAND_GROUPS];
var CommandGroupKeys						CommandBinds[NUM_COMMANDS];				// current edit binding table
var CommandGroupKeys						InitialBinds[NUM_COMMANDS];				// currently active binding table 

var int										CommandBank[NUM_COMMANDS];				// keys in different banks won't affect each other
var string									CommandManifest[NUM_COMMANDS];			// List of known button binding commands
var localized string						CommandFormat[NUM_COMMANDS];			// how to display the binding in the list
var localized string						CommandNames[NUM_COMMANDS];
var localized string						CommandGroupNames[NUM_COMMAND_GROUPS];

var localized string						StringPressKeyPrompt;

Delegate bool OldOnClick(GUIComponent Sender);

// =======================================================================================================================================================
// Initialization
// =======================================================================================================================================================
function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	local int i, j, cmd;

	InitExecution();

	Super.InitComponent(MyController, MyOwner);

	spnCategory = moSpinListControl(MyComponents[0]);
	lblPressPrompt.SetCaption();

	// reset the tab order
	for (i=0; i<MyComponents.Length; i++)
	{
		MyComponents[i].TabOrder = i;
	}

	Bindings.TabOrder = i++;
	hBtnA.TabOrder = i++;
	hBtnB.TabOrder = i++;
	hBtnX.TabOrder = i++;
	hBtnY.TabOrder = i++;
	RemapComponents();

	for (i=0; i<NUM_COMMAND_GROUPS; i++)
	{
		spnCategory.Add(CommandGroupNames[i]);

		for (j=0; j<CommandGroups[i].Commands.Length; j++)
		{
			cmd = CommandGroups[i].Commands[j];
			LoadBindingsForCommand(cmd);
		}
	}

	BindingsList = gbx_ControllerConfigPCList(Bindings.List);

	OldOnClick = BindingsList.OnClick;
	BindingsList.OnClick = BindListClick;

	spnCategory.SetFocus(None);
	spnCategory.SetIndex(0);
}

event Free()
{
	OldOnClick = None;
	Controller.OnNeedRawKeyPress = None;
	Super.Free();
}

function LoadBindingsForCommand(int cmdIndex)
{
	local string s, bindings;
	local int count, key;

	if ((cmdIndex < 0) || (cmdIndex >= NUM_COMMANDS))
		return;

	bindings = ConsoleCommand("FUNCTIONBINDING FUNC=" $CommandManifest[cmdIndex] @"EXACT=0");
	
	count = 0;
	s = ParseTokenDelimited(bindings, ",");
	while ((s != "") && (count < MAX_BINDS_PER_COMMAND))
	{
		key = int(s);

		CommandBinds[cmdIndex].Keys.Length = count+1;
		CommandBinds[cmdIndex].Keys[count].KeyIndex = key;
		CommandBinds[cmdIndex].Keys[count].KeyName = GetNameForKey( key, true );

		InitialBinds[cmdIndex].Keys.Length = count+1;
		InitialBinds[cmdIndex].Keys[count].KeyIndex = key;

		AllKeys[key].bManaged = true;

		s = ParseTokenDelimited(bindings, ",");
		count++;
	}
}

function AddBindingsToList()
{
	local int i, group, cmd, lastIndex;

	if (BindingsList == None)
		return;

	lastIndex = BindingsList.Index;

	BindingsList.Clear();

	group = GetIntOption(0);
	for (i=0; i<CommandGroups[group].Commands.Length; i++)
	{
		cmd = CommandGroups[group].Commands[i];
		BindingsList.AddBinding(CommandNames[cmd], GeneratePrintString(cmd, 0), GeneratePrintString(cmd, 1));
	}

	lastIndex = Min(BindingsList.ItemCount-1, lastIndex);
	BindingsList.SetIndex(lastIndex);
}

// =======================================================================================================================================================
// Page event handlers
// =======================================================================================================================================================
function OnComponentChanged(int button, GUIComponent Sender)
{
	Super.OnComponentChanged(button, Sender);

	AddBindingsToList();
	SelectedEditBind = -1;
}

function bool PageOptionsChanged()
{
	local int i;

	for (i=0; i<NUM_COMMANDS; i++)
	{
		if (BindingChanged(i))
			return true;
	}

	return false;
}

function PageOptionsSave()
{
	local int i;
	local string keyname, binding;

    for (i=0; i<NUM_KEYS; i++)
    {
		if (!AllKeys[i].bManaged)
			continue;

		keyname = GetNameForKey(i);
		binding = GetBindingForKey(i);

		GUILog("Applying keybinding: " $keyname $"=" $binding);
		ConsoleCommand("SETINPUT GAMEPAD_INDEX="$OptionsMenuPagePC.EditPlayerController.Player.GamePadIndex @"KEY="$keyname$" BINDING="$MakeQuotedString(binding));
    }
}

function PageOptionsDefaults()
{
	local int i, cmd;
	local string s, keyname, binding;

	// unbind everything
	for (i=0; i<NUM_COMMANDS; i++)
	{
		CommandBinds[i].Keys.Length = 0;
	}

	// load the default values from defuser
    for (i=NUM_KEYS-1; i>=0; i--)
    {
		keyname = GetNameForKey(i);
		binding = GetConfigString(keyname, "Engine.Input", "DefUser");

		s = ParseKeyBindingToken(binding);
		while (s != "")
		{
			cmd = FindManifestIndex(s);
			if (cmd != -1)
			{
				BindKey(cmd, i);
			}

			s = ParseKeyBindingToken(binding);
		}
	}

	EnableApply(!PageOptionsChanged());
	AddBindingsToList();
}

function bool RawKeyPress(byte NewKey) {return false;}

function OnChangeKey()
{
	Controller.PlayClickSound(EClickSound.CS_Click);

	GotoState('BindingKey');
}

function bool ScreenOnDraw(Canvas C)
{
	if (Bindings.bHasFocus)
	{
		return Super(gbx_ScreenABXY).ScreenOnDraw(C);	// still do the other stuff
	}

	return Super.ScreenOnDraw(C);	// still do the other stuff
}

function bool BindListClick(GUIComponent Sender)
{
	local bool result;

	result = OldOnClick(Sender);

	if (SelectedEditBind == BindingsList.Index)
	{
		GotoState('BindingKey');
	}

	SelectedEditBind = BindingsList.Index;

	return result;
}

function bool SAB_KeyEvent(out byte Key,out byte State,float delta)
{
	if (Bindings.bHasFocus)
	{
		if ((Key == 13) && (State == 3))
		{
			GotoState('BindingKey');
			return true;
		}
		else if ( ((Key == 37) || (Key == 39)) && (State == 1) )
		{
			return spnCategory.MySpinListControl.OnKeyEvent(Key, State, Delta);
		}
	}

	return Super.SAB_KeyEvent( Key, State, delta);
}

// =======================================================================================================================================================
// Binding and unbinding
// =======================================================================================================================================================
function bool KeyIsBound(int cmdIndex, int keyIndex)
{
	local int i;
	local bool result;

	result = false;

	if ((cmdIndex >= 0) && (cmdIndex < NUM_COMMANDS))
	{
		for (i=0; i<CommandBinds[cmdIndex].Keys.Length; i++)
		{
			if (CommandBinds[cmdIndex].Keys[i].KeyIndex == keyIndex)
			{
				result = true;
				break;
			}
		}
	}

	return result;
}

function PrintBinds(int cmdIndex)
{
	local int i;

	GUILog("Printing binds for" @CommandManifest[cmdIndex]);

	for (i=0; i<CommandBinds[cmdIndex].Keys.Length; i++)
	{
		GUILog("--" @CommandBinds[cmdIndex].Keys[i].KeyName);
	}
}

function BindKey(int cmdIndex, int keyIndex)
{
	local int i;

	if ((cmdIndex < 0) || (cmdIndex >= NUM_COMMANDS) || (CommandManifest[cmdIndex] == "") || KeyIsBound(cmdIndex, keyIndex))
		return;
	
	UnbindKeyInBank(keyIndex, CommandBank[cmdIndex]);

	// trim back to 2 binds
	if (CommandBinds[cmdIndex].Keys.Length >= MAX_BINDS_PER_COMMAND)
	{
		CommandBinds[cmdIndex].Keys.Remove(1, CommandBinds[cmdIndex].Keys.Length - (MAX_BINDS_PER_COMMAND-1) );
	}

	// expand and add the key
	CommandBinds[cmdIndex].Keys.Insert(0,1);

	CommandBinds[cmdIndex].Keys[0].KeyIndex = keyIndex;
	CommandBinds[cmdIndex].Keys[0].KeyName = GetNameForKey( CommandBinds[cmdIndex].Keys[i].KeyIndex, true );

	AllKeys[keyIndex].bManaged = true;
}

function UnbindKeyInBank(int keyIndex, int bankIndex)
{
	local int i, j;

	for (i=0; i<NUM_COMMANDS; i++)
	{
		if ((CommandBank[i] != bankIndex) || (CommandManifest[i] == ""))
			continue;

		for (j=0; j<CommandBinds[i].Keys.Length; j++)
		{
			if (CommandBinds[i].Keys[j].KeyIndex == keyIndex)
			{
				CommandBinds[i].Keys.Remove(j,1);
				break;
			}
		}
	}

	AllKeys[keyIndex].bManaged = true;
}

function AppendBindingCommand(out string current, string add)
{
	if (add == "")
		return;

	if (current != "")
		current = current $ " | ";

	current = current $ add;
}

function string GetBindingForKey(int keyIndex)
{
	local int i, j;
	local string result;

	result = "";
	for (i=0; i<NUM_COMMANDS; i++)
	{
		if (CommandManifest[i] == "")
			continue;

		for (j=0; j<CommandBinds[i].Keys.Length; j++)
		{
			if (CommandBinds[i].Keys[j].KeyIndex == keyIndex)
			{
				AppendBindingCommand(result, CommandManifest[i]);
			}
		}
	}

	AppendBindingCommand(result, AllKeys[keyIndex].ExtraBinds);

	return result;
}

// =======================================================================================================================================================
// Futility functions
// =======================================================================================================================================================
function string GetNameForKey(int keyIndex, optional bool bLocalized)
{
	if (bLocalized)
		return ConsoleCommand("LOCALIZEDKEYNAME" @keyIndex);
	else
		return ConsoleCommand("KEYNAME" @keyIndex);
}

function bool BindingChanged(int cmdIndex)
{
	local int i, j;
	local bool bFound;

	if ((cmdIndex < 0) || (cmdIndex >= NUM_COMMANDS))
		return false;

	for (i=0; i<CommandBinds[cmdIndex].Keys.Length; i++)
	{
		bFound = false;
		for (j=0; j<InitialBinds[cmdIndex].Keys.Length; j++)
		{
			if (CommandBinds[cmdIndex].Keys[i].KeyIndex == InitialBinds[cmdIndex].Keys[j].KeyIndex)
			{
				bFound = true;
				break;
			}
		}

		if (!bFound)
			return true;
	}

	for (i=0; i<InitialBinds[cmdIndex].Keys.Length; i++)
	{
		bFound = false;
		for (j=0; j<CommandBinds[cmdIndex].Keys.Length; j++)
		{
			if (InitialBinds[cmdIndex].Keys[i].KeyIndex == CommandBinds[cmdIndex].Keys[j].KeyIndex)
			{
				bFound = true;
				break;
			}
		}

		if (!bFound)
			return true;
	}

	return false;
}

// Extracts the actual key format string a format string token <[command]>
function string KeyFormatStringToManifestString(string mStr, int cmdIndex)
{
	if ((mStr == "") || (Left(mStr,1) != "<") || (cmdIndex < 0) || (cmdIndex >= NUM_COMMANDS))
		return "";

	if (mStr ~= "<KEY>")
	{
		mStr = CommandManifest[cmdIndex];
	}
	else
	{
		mStr = Mid(mStr, 1, Len(mStr)-2);
	}

	return mStr;
}

// finds a format string token <*******> in a string
function string GetKeyFormatString(out string strIn)
{
	local int i1, i2;
	local string result;

	i1 = InStr(strIn, "<");
	i2 = InStr(strIn, ">");
	
	if ((i1 != -1) && (i2 != -1))
	{
		result = Mid(strIn, i1, i2-i1+1);
		strIn = Right(strIn, Len(strIn)-i2-1);
	}

	if (result == "")
		strIn = "";

	return result;
}

// convert a CommandFormat to a printable string for the given command manifest index and slot
function string GeneratePrintString(int cmdIndex, int slot)
{
	local string s, result, keystr, replace;

	if ((cmdIndex < 0) || (cmdIndex >= NUM_COMMANDS))
		return "";

	result = CommandFormat[cmdIndex];
	s = result;

	while (true)
	{
		// parse out a replacement string
		keystr = GetKeyFormatString(s);
		if (keystr == "")
			break;

		// get the manifest name (function name)
		replace = KeyFormatStringToManifestString(keystr, cmdIndex);
		if (replace == "")
		{
			GUILog("WARNING : Empty command manifest for cmdIndex=" $cmdIndex $", keyStr=" $keystr);
			continue;
		}

		// resolve the manifest name to the key bound to this function in the given slot
		replace = GetKeyForFunction(replace, slot);
		if (replace == "")
		{
			// key is unbound... this binding is incomplete
			return "---";
		}

		ReplaceText(result, keystr, replace);
	}

	return result;
}

// locate a function binding in the manifest
function int FindManifestIndex(string strManifestName)
{
	local int i;

	for (i=0; i<NUM_COMMANDS; i++)
	{
		if (CommandManifest[i] ~= strManifestName)
		{
			return i;
		}
	}

	return -1;
}

// returns the key bound to function in strIn in a particular slot
function string GetKeyForFunction(string strIn, int slot)
{
	local int i;

	i = FindManifestIndex(strIn);
	if (i == -1)
		return "";

	if (slot >= CommandBinds[i].Keys.Length)
		return "";

	return CommandBinds[i].Keys[slot].KeyName;
}

function int GetSelectedManifestIndex()
{
	local int group;

	group = GetIntOption(0);
	return CommandGroups[group].Commands[BindingsList.Index];
}

// =======================================================================================================================================================
// =======================================================================================================================================================
// state logic
// =======================================================================================================================================================
// =======================================================================================================================================================
state BindingKey
{
	function BeginState()
	{
		local string s;

		GUILog("BindingKey::BeginState");

		s = StringPressKeyPrompt;
		ReplaceText( s, "<COMMAND>", MakeQuotedString(CommandNames[GetSelectedManifestIndex()]) );

		lblPressPrompt.SetCaption(s);
		lblPressPrompt.Show();
		SetFocus( lblPressPrompt );

		Controller.OnNeedRawKeyPress = RawKeyPress;
		BindingsList.bInBindMode = true;
	}

	function EndState()
	{
		GUILog("BindingKey::EndState");
		Controller.OnNeedRawKeyPress = None;
		BindingsList.bInBindMode = false;

		lblPressPrompt.Hide();
		ResetFocusToBindList();
	}

	function ResetFocusToBindList()
	{
		FocusFirst(None);
		NextControl(FocusedControl);
	}

	function bool RawKeyPress(byte NewKey)
	{
		GUILog("BindingKey::RawKeyPress " @NewKey);
		if (newKey == 27)	// IK_Escape
		{
			GotoState('');
			return true;
		}
		else if ( ((NewKey==236) || (NewKey==237)) && ((GetSelectedManifestIndex()==16) || (GetSelectedManifestIndex()==11)) )
		{
			return true;
		}
		else
		{
			BindKey(GetSelectedManifestIndex(), NewKey);
			EnableApply(!PageOptionsChanged());
			AddBindingsToList();
		}

		GotoState('');
		return true;
	}

	function bool ScreenOnDraw(Canvas C)
	{
		return Super(gbx_ScreenABXY).ScreenOnDraw(C);	// still do the other stuff
	}
}

defaultproperties
{
	ScreenTitle="Controls"
	LayoutPivotPoint=0.17
	LayoutSpacing=0.01
	LayoutPivotStyle=LA_Left_Top

	SelectedEditBind=-1

	Begin Object Class=moSpinListControl Name=cSpinMenuOption2
		bFocusOnWatch=true
		LabelJustification=TXTA_Right
		CaptionWidth=0.45
		ComponentWidth=0.5
		WinWidth=0.90
		WinHeight=0.052000
		WinLeft=0.050
		WinTop=0.28000
		bHeightFromComponent=false
	End Object

	MyComponents(0)=cSpinMenuOption
	MyCaptions(0)="Category"

	CommandGroupNames(0)="Movement"
	CommandGroupNames(1)="Action"
	CommandGroupNames(2)="Squad/Tank Commands"
	CommandGroupNames(3)="Situational Awareness"
	CommandGroupNames(4)="Multiplayer/Menu"

	CommandGroups(0)=(Commands=(0,1,2,3,4,5))
	CommandGroups(1)=(Commands=(6,7,8,9,10,11,12,34))
//	CommandGroups(2)=(Commands=(13,14,15,16,17,18,19,20))
	CommandGroups(2)=(Commands=(13,16,17,18,19,20))
//	CommandGroups(3)=(Commands=(21,22,23,24,25,26,27,28,29,30))
	CommandGroups(3)=(Commands=(26,27,28,29))
//	CommandGroups(4)=(Commands=(31,32,33,34))
	CommandGroups(4)=(Commands=(31,32,33))

// ==================== COMMAND BINDING NAMES ============================
	// movement
	CommandNames(0)="Move Forward"
	CommandNames(1)="Move Backward"
	CommandNames(2)="Strafe Left"
	CommandNames(3)="Strafe Right"
	CommandNames(4)="Jump"
	CommandNames(5)="Crouch Toggle"

	// action
	CommandNames(6)="Fire Weapon"
	CommandNames(7)="Throw Grenade"
	CommandNames(8)="Switch Weapon"
	CommandNames(9)="Melee Attack"
	CommandNames(10)="Zoom Toggle"
	CommandNames(11)="Context Action"
	CommandNames(12)="Toggle Situational Awareness View"

	// squad/tank
	CommandNames(13)="Command Team"
	CommandNames(14)="Move/Fire Command"
	CommandNames(15)="Rush/Assault Command"
	CommandNames(16)="Switch Team/Fall In (hold)"
	CommandNames(17)="Fall In"
	CommandNames(18)="Fall Out"
	CommandNames(19)="Select Assault Team"
	CommandNames(20)="Select Fire Team"

	// situational awareness
	CommandNames(21)="Tilt Camera Up"
	CommandNames(22)="Rotate Camera Left"
	CommandNames(23)="Tilt Camera Down"
	CommandNames(24)="Rotate Camera Right"
	CommandNames(25)="Zoom Toggle"
	CommandNames(26)="Select Next"
	CommandNames(27)="Select Previous"
	CommandNames(28)="Select Objective"
	CommandNames(29)="Select Hartsock"
	CommandNames(30)="Select Team/Switch Team"

	// MP/Menu
	CommandNames(31)="Chat"
	CommandNames(32)="Team Chat"
	CommandNames(33)="Pause"
	CommandNames(34)="Reload"

// ==================== COMMAND BINDING FUNCTIONS ============================
	// movement
	CommandManifest(0)="MoveForward"
	CommandManifest(1)="MoveBackward"
	CommandManifest(2)="StrafeLeft"
	CommandManifest(3)="StrafeRight"
	CommandManifest(4)="Jump"
	CommandManifest(5)="Duck"

	// action
	CommandManifest(6)="Fire"
	CommandManifest(7)="AltFire"
	CommandManifest(8)="ASelectWeapon"
	CommandManifest(9)="MeleeAttack"
	CommandManifest(10)="AZoom"
	CommandManifest(11)="AUse"
	CommandManifest(12)="ActivateOracleKey"

	// squad/tank
	CommandManifest(13)="ACommand"
	CommandManifest(14)=""
	CommandManifest(15)=""
	CommandManifest(16)="UnitSelect"
	CommandManifest(17)="FallInInput"
	CommandManifest(18)="FallOutInput"
	CommandManifest(19)="ASelectUnitAssault"
	CommandManifest(20)="ASelectUnitFire"

	// situational awareness
	CommandManifest(21)=""
	CommandManifest(22)=""
	CommandManifest(23)=""
	CommandManifest(24)=""
	CommandManifest(25)=""
	CommandManifest(26)="NextOracleCamTarget"
	CommandManifest(27)="PrevOracleCamTarget"
	CommandManifest(28)="OracleCamTargetObjective"
	CommandManifest(29)="OracleCamTargetSelf"
	CommandManifest(30)=""

	// MP/Menu
	CommandManifest(31)="Talk"
	CommandManifest(32)="TeamTalk"
	CommandManifest(33)="Pause"
	CommandManifest(34)="ReloadKey"

	CommandBank(26)=1
	CommandBank(27)=1
	CommandBank(28)=1
	CommandBank(29)=1

// ==================== COMMAND BINDING FORMATTING ============================
	// movement
	CommandFormat(0)="<KEY>"
	CommandFormat(1)="<KEY>"
	CommandFormat(2)="<KEY>"
	CommandFormat(3)="<KEY>"
	CommandFormat(4)="<KEY>"
	CommandFormat(5)="<KEY>"

	// action
	CommandFormat(6)="<KEY>"
	CommandFormat(7)="<KEY>"
	CommandFormat(8)="<KEY>"
	CommandFormat(9)="<KEY>"
	CommandFormat(10)="<KEY>"
	CommandFormat(11)="<KEY>"
	CommandFormat(12)="<KEY>"

	// squad/tank
	CommandFormat(13)="Hold <KEY>"
	CommandFormat(14)="Release <ACommand>"
	CommandFormat(15)="Hold <ACommand>, Press <Fire>"
	CommandFormat(16)="<KEY>"
	CommandFormat(17)="<KEY>"
	CommandFormat(18)="<KEY>"
	CommandFormat(19)="<KEY>"
	CommandFormat(20)="<KEY>"

	// situational awareness
	CommandFormat(21)="Hold <MoveForward>"
	CommandFormat(22)="Hold <MoveBackward>"
	CommandFormat(23)="Hold <StrafeLeft>"
	CommandFormat(24)="Hold <StrafeRight>"
	CommandFormat(25)="<AZoom>"
	CommandFormat(26)="<KEY>"
	CommandFormat(27)="<KEY>"
	CommandFormat(28)="<KEY>"
	CommandFormat(29)="<KEY>"
	CommandFormat(30)="<UnitSelect>"

	// MP/Menu
	CommandFormat(31)="<KEY>"
	CommandFormat(32)="<KEY>"
	CommandFormat(33)="<KEY>"
	CommandFormat(34)="<KEY>"

	AllKeys(32)=(bManaged=true,ExtraBinds="Continue")		// IK_Space

	Begin Object class=GUIMultiColumnListBox Name=cBindings
		WinWidth=0.9
		WinHeight=0.54
		WinLeft=0.05
		WinTop=0.22
        bVisibleWhenEmpty=true
        DefaultListClass="GUI.gbx_ControllerConfigPCList"
	End Object
    Bindings=cBindings

	StringPressKeyPrompt="Press a key to bind to <COMMAND> or press ESCAPE to cancel."
	Begin Object Class=gbx_LiveLeaderboardProgress Name=clblPressPrompt
		bVisible=false
		bAcceptsInput=false
		bTabStop=false
		WinWidth=0.500000
		WinHeight=0.40000
		WinLeft=0.250000
		WinTop=0.300000
	End Object
	lblPressPrompt=clblPressPrompt
}
class gbx_OptionsDlgChangeRes extends gbx_ScreenQuestion;

const DELAY_PRECHANGE = 3.0;
const DELAY_POSTCHANGE = 10.0;

var float						EventTimer;
var string						Oldres;

var localized string			StringPreChangePrompt;
var localized string			StringPostChangePrompt;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	InitExecution();

	Super.InitComponent(MyController, MyOwner);

	GUILog("InitComponent");
	OnAnswer = MyAnswer;

	Oldres = ConsoleCommand("GetCurrentRes");
}

event HandleParameters(string Param1, string Param2)
{
	Super.HandleParameters(Param1, Param2);

	GotoState('PreChange');
}

event Timer();

function bool MyAnswer(string answer)
{
	return true;
}

state PreChange
{
	function BeginState()
	{
		GUILog("PreChange");
		SetTextPrompt(StringPreChangePrompt);
		EventTimer = PlayerOwner().Level.UniversalTimeSeconds + DELAY_PRECHANGE;	// change res when this timeout is over
		SetTimer(0.2, true);
	}
	event Timer()
	{
		if ((EventTimer > 0) && (PlayerOwner().Level.UniversalTimeSeconds >= EventTimer))
		{
			GotoState('ChangeRes');
		}
	}
	function bool MyAnswer(string answer)
	{
		if (answer ~= "OK")
		{
			GotoState('ChangeRes');
		}
		else
		{
			return true;
		}
	}
}

function AbortChange()
{
	GUILog("AbortChange");
	KillTimer();
	ConsoleCommand("SETRES" @Oldres);
}

function SetPostChangeMessage()
{
	local string s;
	local int time;

	time = Clamp(EventTimer-PlayerOwner().Level.UniversalTimeSeconds, 1, DELAY_POSTCHANGE);
	s = StringPostChangePrompt;
	ReplaceText(s, "<TIME>", String(time));
	SetTextPrompt(s);
}

state ChangeRes
{
	function BeginState()
	{
		GUILog("ChangeRes");

		EventTimer = 0;
		ConsoleCommand("SETRES" @LParam1);

		EventTimer = PlayerOwner().Level.UniversalTimeSeconds + DELAY_POSTCHANGE;	// revert changes when this timeout is over
		SetPostChangeMessage();
	}
	event Timer()
	{
		SetPostChangeMessage();
		if ((EventTimer > 0) && (PlayerOwner().Level.UniversalTimeSeconds >= EventTimer))
		{
			AbortChange();
			Controller.CloseMenu(true);
		}
	}
	function bool MyAnswer(string answer)
	{
		if (!(answer ~= "OK"))
		{
			AbortChange();
		}

		return true;
	}
}

defaultproperties
{
	ScreenTitle="Attention"
	StringPreChangePrompt="Your video resolution is about to be changed."
	StringPostChangePrompt="Your video resolution has been changed.  Do you want to keep this setting? | |Setting will revert in <TIME>s."

	QuestionType=SQT_OKCANCEL
	PromptType=SPT_None
}
class gbx_OptionsGame extends gbx_OptionsScreen;

var localized array<string>			StringListCrosshairs;
var GUISpinListControl				spnCrosshair;

var bool							bGermanMode;
var bool							bCurrentSuppIcon;
var bool							bCurrentSubtitles;
var bool							bCurrentHints;
var bool							bCurrentTraining;
var bool							bCurrentNames;
var bool							bLCDEnabled;
var bool							bCurrentRemoveWeaponFromHud;
var int								iCurrentCrosshair;

var array<Canvas.CanvasIcon>		CrosshairIcons;

var WargamePlayerController		EditPlayerController;

const OPTION_SUPP_ICON		= 0;
const OPTION_CROSSHAIR		= 1;
const OPTION_SUBTITLES		= 2;
const OPTION_HINTS			= 3;
const OPTION_TRAINING		= 4;
const OPTION_NAMES			= 5;
const OPTION_LCD			= 6;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	moSpinListControl(MyComponents[OPTION_SUPP_ICON]).AddFromList(StringListOffOn);
	moSpinListControl(MyComponents[OPTION_CROSSHAIR]).AddFromList(StringListCrosshairs);
	moSpinListControl(MyComponents[OPTION_SUBTITLES]).AddFromList(StringListOffOn);
	moSpinListControl(MyComponents[OPTION_HINTS]).AddFromList(StringListOffOn);
	moSpinListControl(MyComponents[OPTION_TRAINING]).AddFromList(StringListOffOn);
	moSpinListControl(MyComponents[OPTION_NAMES]).AddFromList(StringListOffOn);
	moSpinListControl(MyComponents[OPTION_LCD]).AddFromList(StringListNoYes);

	spnCrosshair = moSpinListControl(MyComponents[OPTION_CROSSHAIR]).MySpinListControl;

	MyComponents[OPTION_HINTS].Hide();

	bGermanMode = PlayerOwner().GetLanguage() ~= "det";
	bLCDEnabled = ConsoleCommand("LCD_AVAILABLE") ~= "TRUE";

	if (!bLCDEnabled)
		MyComponents[OPTION_LCD].Hide();

	DoComponentLayout();
}

function PageOptionsInit()
{
	local bool bIsMP, bIsSkirmish, bIsAuthentic, bIsMenu;

	local PlayerController PC;
	PC = PlayerOwner();
	EditPlayerController = WargamePlayerController(PC);

	bCurrentSuppIcon = !EditPlayerController.bNoSuppressionIcons;
	bCurrentSubtitles = !EditPlayerController.bDisableSubtitles;
//	bCurrentHints = !EditPlayerController.bDisableHints;
	bCurrentTraining = !EditPlayerController.bDisableTraining;
	bCurrentNames = !EditPlayerController.bFriendlyFireIDDisable;
	bCurrentRemoveWeaponFromHud = EditPlayerController.bRemoveWeaponFromHud;

	iCurrentCrosshair = EditPlayerController.iCrossHairIndex;

	SetNoYesOption(OPTION_SUPP_ICON, bCurrentSuppIcon);
	SetNoYesOption(OPTION_SUBTITLES, bCurrentSubtitles);
//	SetNoYesOption(OPTION_HINTS, bCurrentHints);
	SetNoYesOption(OPTION_TRAINING, bCurrentTraining);
	SetNoYesOption(OPTION_NAMES, bCurrentNames);
	SetNoYesOption(OPTION_LCD, bCurrentRemoveWeaponFromHud);

	SetIntOption(OPTION_CROSSHAIR, iCurrentCrosshair);

	bIsMP = PlayerOwner().Level.NetMode != NM_Standalone;
	bIsMenu = PlayerOwner().Level.IsMenuMap();
	if (bIsMP)
		bIsSkirmish = PlayerOwner().GameReplicationInfo.GameType == GT_Skirmish;
	else if (!bIsMenu)
		bIsAuthentic = PlayerOwner().Level.DifficultyManager.GetDifficulty() == DIFF_Authentic;

	if (bIsSkirmish)
	{
		EnableOption(OPTION_SUPP_ICON, true);
		EnableOption(OPTION_SUBTITLES, false);
//		EnableOption(OPTION_HINTS, true);
		EnableOption(OPTION_TRAINING, false);
		EnableOption(OPTION_NAMES, false);
		EnableOption(OPTION_CROSSHAIR, true);
	}
	else if (bIsMP)
	{
		EnableOption(OPTION_SUPP_ICON, false);
		EnableOption(OPTION_SUBTITLES, false);
//		EnableOption(OPTION_HINTS, true);
		EnableOption(OPTION_TRAINING, false);
		EnableOption(OPTION_NAMES, false);
		EnableOption(OPTION_CROSSHAIR, false);
	}
	else if (bIsAuthentic)
	{
		EnableOption(OPTION_SUPP_ICON, false);
		EnableOption(OPTION_SUBTITLES, false);
//		EnableOption(OPTION_HINTS, true);
		EnableOption(OPTION_TRAINING, false);
		EnableOption(OPTION_NAMES, true);
		EnableOption(OPTION_CROSSHAIR, false);
	}
}

function bool PageOptionsChanged()
{
	return	NoYesOptionChanged(OPTION_SUPP_ICON, bCurrentSuppIcon) ||
			NoYesOptionChanged(OPTION_SUBTITLES, bCurrentSubtitles) ||
//			NoYesOptionChanged(OPTION_HINTS, bCurrentHints) ||
			NoYesOptionChanged(OPTION_TRAINING, bCurrentTraining) ||
			NoYesOptionChanged(OPTION_NAMES, bCurrentNames) ||
			(bLCDEnabled && NoYesOptionChanged(OPTION_LCD, bCurrentRemoveWeaponFromHud)) ||
			IntOptionChanged(OPTION_CROSSHAIR, iCurrentCrosshair);
}

function PageOptionsSave()
{
	local PlayerController PC;
	PC = PlayerOwner();
	EditPlayerController = WargamePlayerController(PC);
	if (NoYesOptionChanged(OPTION_SUPP_ICON, bCurrentSuppIcon))
		EditPlayerController.bNoSuppressionIcons = !GetNoYesOption(OPTION_SUPP_ICON);

	if (NoYesOptionChanged(OPTION_SUBTITLES, bCurrentSubtitles))
		EditPlayerController.bDisableSubtitles = !GetNoYesOption(OPTION_SUBTITLES);

//	if (NoYesOptionChanged(OPTION_HINTS, bCurrentHints))
//		OptionsMenuPage.EditPlayerController.bDisableHints = !GetNoYesOption(OPTION_HINTS);

	if (NoYesOptionChanged(OPTION_TRAINING, bCurrentTraining))
		EditPlayerController.bDisableTraining = !GetNoYesOption(OPTION_TRAINING);

	if (NoYesOptionChanged(OPTION_NAMES, bCurrentNames))
		EditPlayerController.bFriendlyFireIDDisable = !GetNoYesOption(OPTION_NAMES);

	if (bLCDEnabled && NoYesOptionChanged(OPTION_LCD, bCurrentRemoveWeaponFromHud))
		EditPlayerController.bRemoveWeaponFromHud = GetNoYesOption(OPTION_LCD);

	if (IntOptionChanged(OPTION_CROSSHAIR, iCurrentCrosshair))
		EditPlayerController.iCrossHairIndex = GetIntOption(OPTION_CROSSHAIR);
}

function PageOptionsDefaults()
{
	local string s;

	s = GetConfigString("bNoSuppressionIcons", "gbxBase.gbxPlayerController", "DefUser");
	SetNoYesOption(OPTION_SUPP_ICON, !bool(s));

	s = GetConfigString("bDisableSubtitles", "Engine.PlayerController", "DefUser");
	SetNoYesOption(OPTION_SUBTITLES, !bool(s));

//	s = GetConfigString("bDisableHints", "Engine.PlayerController", "DefUser");
//	SetNoYesOption(OPTION_HINTS, !bool(s));

	s = GetConfigString("bDisableTraining", "Engine.PlayerController", "DefUser");
	SetNoYesOption(OPTION_TRAINING, !bool(s));

	s = GetConfigString("bFriendlyFireIDDisable", "Engine.PlayerController", "DefUser");
	SetNoYesOption(OPTION_NAMES, !bool(s));

	SetNoYesOption(OPTION_LCD, false);

	s = GetConfigString("iCrossHairIndex", "Engine.PlayerController", "DefUser");
	SetIntOption(OPTION_CROSSHAIR, int(s));
}

function bool ScreenOnDraw(Canvas C)
{
	local int i;
	local float X, Y;
	local bool result;

	result = Super.ScreenOnDraw(C);

	i = GetIntOption(OPTION_CROSSHAIR) - 1;
	if ((i >= 0) && (i < CrosshairIcons.Length))
	{
		X = spnCrosshair.HorizontalOffset(0.5);
		Y = spnCrosshair.VerticalOffset(0.5);
//		C.bNoSmooth = false;
		C.Style = EMenuRenderStyle.MSTY_Additive;
		C.DrawCanvasIcon(X, Y, Controller.CanvasAspectScale, Controller.CanvasScaleY, CrosshairIcons[i]);
//		C.bNoSmooth = true;
	}

	return result;
}

defaultproperties
{
	ScreenTitle="Game Options"

	MyComponents(0)=cSpinMenuOption
	MyComponents(1)=cSpinMenuOption
	MyComponents(2)=cSpinMenuOption
	MyComponents(3)=cSpinMenuOption
	MyComponents(4)=cSpinMenuOption
	MyComponents(5)=cSpinMenuOption
	MyComponents(6)=cSpinMenuOption

	MyCaptions(0)="Suppression Indicators"
	MyCaptions(1)="Crosshair"
	MyCaptions(2)="Subtitles"
	MyCaptions(3)="Hints"
	MyCaptions(4)="Training"
	MyCaptions(5)="Ally Names"
	MyCaptions(6)="Hide Weapon HUD"

	StringListCrosshairs=("Off","","","","","","")

	CrosshairIcons(0)=(Icon=Texture'gbxBase.crosshair_a',U=0,V=0,UL=64,VL=64,DrawColor=(R=200,G=200,B=200,A=255),ScaleX=0.35,ScaleY=0.35,PivotU=0.5,PivotV=0.5)
	CrosshairIcons(1)=(Icon=Texture'gbxBase.crosshair_b',U=0,V=0,UL=64,VL=64,DrawColor=(R=200,G=200,B=200,A=255),ScaleX=0.35,ScaleY=0.35,PivotU=0.5,PivotV=0.5)
	CrosshairIcons(2)=(Icon=Texture'gbxBase.crosshair_c',U=0,V=0,UL=64,VL=64,DrawColor=(R=200,G=200,B=200,A=255),ScaleX=0.35,ScaleY=0.35,PivotU=0.5,PivotV=0.5)
	CrosshairIcons(3)=(Icon=Texture'gbxBase.crosshair_d',U=0,V=0,UL=64,VL=64,DrawColor=(R=200,G=200,B=200,A=255),ScaleX=0.35,ScaleY=0.35,PivotU=0.5,PivotV=0.5)
	CrosshairIcons(4)=(Icon=Texture'gbxBase.crosshair_e',U=0,V=0,UL=64,VL=64,DrawColor=(R=200,G=200,B=200,A=255),ScaleX=0.35,ScaleY=0.35,PivotU=0.5,PivotV=0.5)
	CrosshairIcons(5)=(Icon=Texture'gbxBase.crosshair_f',U=0,V=0,UL=64,VL=64,DrawColor=(R=200,G=200,B=200,A=255),ScaleX=0.35,ScaleY=0.35,PivotU=0.5,PivotV=0.5)
}
class gbx_OptionsInputPC extends gbx_OptionsScreen;

var bool							bCurrentInvert;
var int								iSensitivity;
var PlayerInput						EditPlayerInput;

var localized array<string>			StringListSensitivity; 

const OPTION_INVERT			= 0;
const OPTION_SENSITIVITY		= 1;


var WargamePlayerController		EditPlayerController;


function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	moSpinListControl(MyComponents[OPTION_INVERT]).AddFromList(StringListNoYes);
	moSpinListControl(MyComponents[OPTION_SENSITIVITY]).AddFromList(StringListSensitivity);
}

function PageOptionsInit()
{
	local PlayerController PC;

	PC = PlayerOwner();
	EditPlayerController = WargamePlayerController(PC);

	EditPlayerInput = EditPlayerController.GetPlayerInput();

	iSensitivity = EditPlayerInput.MouseSensitivity - 1;
	bCurrentInvert = EditPlayerInput.bInvertMouse;

	SetNoYesOption(OPTION_INVERT, bCurrentInvert);
	SetIntOption(OPTION_SENSITIVITY, iSensitivity);
}

function bool PageOptionsChanged()
{
	return	NoYesOptionChanged(OPTION_INVERT, bCurrentInvert) ||
			IntOptionChanged(OPTION_SENSITIVITY, iSensitivity);
}


function PageOptionsSave()
{
	local PlayerController PC;

	PC = PlayerOwner();
	EditPlayerController = WargamePlayerController(PC);

	EditPlayerInput = EditPlayerController.GetPlayerInput();

	if (NoYesOptionChanged(OPTION_INVERT, bCurrentInvert)){
		ConsoleCommand("invertmouse");
	}

	if (IntOptionChanged(OPTION_SENSITIVITY, iSensitivity)){
		ConsoleCommand("SetMouseSensitivity" @GetIntOption(OPTION_SENSITIVITY)+1);
	}
}

function PageOptionsDefaults()
{
	local string s;
	local PlayerController PC;

	PC = PlayerOwner();
	EditPlayerController = WargamePlayerController(PC);

	s = GetConfigString("bInvertMouse", "Engine.PlayerInput", "DefUser");
	SetNoYesOption(OPTION_INVERT, bool(s));

	s = GetConfigString("MouseSensitivity", "Engine.PlayerInput", "DefUser");
	SetIntOption(OPTION_SENSITIVITY, int(s)-1);
}

defaultproperties
{
	ScreenTitle="Input Options"

	MyComponents(0)=cSpinMenuOption
	MyComponents(1)=cSpinMenuOption


	MyCaptions(0)="Invert Mouse"
	MyCaptions(1)="Mouse Sensitivity"

	StringListSensitivity=("1","2","3","4","5");



}
class gbx_OptionsLive extends gbx_OptionsScreen;

var moSpinListControl				spnAppearOffline;
var moSpinListControl				spnVoiceThroughSpeaker;

var localized array<string>			StringListAppear;
var localized array<string>			StringListVoice;
var localized array<string>			StringListVoiceBanned;

var bool							bVoiceBanned;
var bool							bHasCommunicator;
var bool							bActiveAppearOffline;
var bool							bActiveVoiceThroughSpeaker;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	SetupXButton();

	spnAppearOffline = moSpinListControl(MyComponents[0]);
	spnAppearOffline.AddFromList(StringListAppear);
	
	spnVoiceThroughSpeaker = moSpinListControl(MyComponents[1]);

	if ( "TRUE" == ConsoleCommand( "XLIVE IS_VOICE_BANNED USER=" $ OptionsMenuPage.EditPlayerIndex ) )
	{
		bHasCommunicator = false;
		bVoiceBanned = true;

		spnVoiceThroughSpeaker.AddFromList(StringListVoiceBanned);
		spnVoiceThroughSpeaker.SetIndex(0);
		spnVoiceThroughSpeaker.OnChange = VoiceThroughSpeakerOnChange;
	}
	else
	{
		spnVoiceThroughSpeaker.AddFromList(StringListVoice);

		CommunicatorChanged( PlayerHasCommunicator(self, OptionsMenuPage.EditControllerIndex) );

		SetTimer(0.25, true);
	}	

	bActiveAppearOffline = bool( ConsoleCommand("XLIVE IS_CLOAKED" @OptionsMenuPage.EditPlayerIndex) );
	SetCurrentAppearOffline(bActiveAppearOffline);
}

function SetCurrentAppearOffline(bool bAppearOffline)
{
	GUILog("SetCurrentAppearOffline=" $String(bAppearOffline));
	if (bAppearOffline)
		spnAppearOffline.SetIndex(1);
	else
		spnAppearOffline.SetIndex(0);
}
function bool GetCurrentAppearOffline()
{
	return spnAppearOffline.GetIndex() == 1;
}

function SetCurrentVoiceThroughSpeaker(bool bVoiceThroughSpeaker)
{
	GUILog("SetCurrentVoiceThroughSpeaker=" $String(bVoiceThroughSpeaker));
	if (bVoiceThroughSpeaker)
		spnVoiceThroughSpeaker.SetIndex(1);
	else
		spnVoiceThroughSpeaker.SetIndex(0);
}
function bool GetCurrentVoiceThroughSpeaker()
{
	return spnVoiceThroughSpeaker.GetIndex() == 1;
}

function bool PageOptionsChanged()
{
	return (GetCurrentAppearOffline() != bActiveAppearOffline) || (bHasCommunicator && (GetCurrentVoiceThroughSpeaker() != bActiveVoiceThroughSpeaker));
}

function OnApply()
{
	if (GetCurrentAppearOffline())
		ConsoleCommand("XLIVE SET_CLOAKED" @OptionsMenuPage.EditPlayerIndex @ "1");
	else
		ConsoleCommand("XLIVE SET_CLOAKED" @OptionsMenuPage.EditPlayerIndex @ "0");

	if (bHasCommunicator)
	{
		if (GetCurrentVoiceThroughSpeaker())
			ConsoleCommand("VOICE_SET_TO_SPEAKER" @OptionsMenuPage.EditControllerIndex @ "1");
		else
			ConsoleCommand("VOICE_SET_TO_SPEAKER" @OptionsMenuPage.EditControllerIndex @ "0");
	}

	BaseOnAButton();
}

function VoiceThroughSpeakerOnChange(GUIComponent Sender)
{
	if ( "TRUE" == ConsoleCommand( "XLIVE IS_VOICE_BANNED USER=" $ OptionsMenuPage.EditPlayerIndex ) )
	{
		LaunchQuestionDialog(Controller, Controller.LiveFunc.LocalizedError("VOICE_BANNED_FEATURE_UNAVAILABLE"), "OK NONE" );
	}
}

function CommunicatorChanged(bool bHasComm)
{
	if (bVoiceBanned)
		return;

	bHasCommunicator = bHasComm;

	if (bHasCommunicator)
	{
		bActiveVoiceThroughSpeaker = int( ConsoleCommand("VOICE_GET_TO_SPEAKER" @OptionsMenuPage.EditControllerIndex) ) == 1;
		spnVoiceThroughSpeaker.EnableControl(true);
	}
	else
	{
		bActiveVoiceThroughSpeaker = true;
		spnVoiceThroughSpeaker.EnableControl(false);
	}

	SetCurrentVoiceThroughSpeaker(bActiveVoiceThroughSpeaker);
}

event Timer()
{
	local bool hasComm;
	
	if (!bVoiceBanned)
	{
		hasComm = PlayerHasCommunicator(self, OptionsMenuPage.EditControllerIndex);

		if (hasComm != bHasCommunicator)
			CommunicatorChanged( hasComm );
	}
}

static function bool PlayerHasCommunicator(GUIPage caller, int index)
{
	return int( caller.ConsoleCommand("VOICE_IS_COMMUNICATOR_CONNECTED" @index) ) == 1;
}

static function bool ShouldEnableMenu(GUIPage caller, int inPlayerIndex)
{
	if (!caller.Controller.bIsConsole)
		return false;
	
	if (inPlayerIndex == -1)
		return false;

	// must be signed in and not a guest to use this screen.
	if (!caller.Controller.LiveFunc.IsSignedIn(inPlayerIndex) || caller.Controller.LiveFunc.IsGuest(inPlayerIndex))
		return false;

	return true;
}

defaultproperties
{
	ScreenTitle="Xbox Live Options"

	MyComponents(0)=cSpinMenuOption
	MyComponents(1)=cSpinMenuOption

	MyCaptions(0)="Appear"
	MyCaptions(1)="Voice Playback"

	StringListAppear=("Online","Offline")
	StringListVoice=("Xbox Communicator","Speakers")
	StringListVoiceBanned=("Xbox Communicator")

	bVoiceBanned=false
}
class gbx_OptionsPerformancePC extends gbx_OptionsScreen;

var bool							bCurrentTexDetail;
var int								iCurrentTexDetail;

var bool							bBlobShadowsOnly;
var bool							bNoShadows;
var int								iCurrentShadows;

var bool							bCurrentCube;
var int								iCurrentCube;
var bool							bCurrentHDRL;

var int								iCurrentDecals;

var float							fCurrentGrass;
var int								iCurrentGrass;

var localized array<string>			StringListShadows;
var localized array<string>			StringListReflections;
var localized array<string>			StringListDecalsLimit;   
var localized array<string>			StringListGrass; 
var localized array<string>			StringListTexDetail;  

const OPTION_SHADOWS		= 0;
const OPTION_REFLECTIONS	= 1;
const OPTION_DECALS			= 2;
const OPTION_GRASS			= 3;
const OPTION_HDRL			= 4;	//High Dynamic Range Lighting
const OPTION_TEXDETAIL		= 5;



function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	AddListReversed(OPTION_SHADOWS, StringListShadows);
	AddListReversed(OPTION_DECALS, StringListDecalsLimit);
	AddListReversed(OPTION_GRASS, StringListGrass);

	moSpinListControl(MyComponents[OPTION_REFLECTIONS]).AddFromList(StringListReflections);
	moSpinListControl(MyComponents[OPTION_HDRL]).AddFromList(StringListOffOn);
	moSpinListControl(MyComponents[OPTION_TEXDETAIL]).AddFromList(StringListTexDetail);
}

function AddListReversed(int compIndex, array<string> srcList)
{
	local int i, c;
	local array<string> list;

	list.length = srcList.Length;
	c = 0;
	for (i=srcList.Length-1; i>=0; i--)
	{
		list[c] = srcList[i];
		c++;
	}

	moSpinListControl(MyComponents[compIndex]).AddFromList(list);
}

function PageOptionsInit()
{
	local GameInfo gi;
	local ImpactManager im;
	
	gi = PlayerOwner().Level.Game;
	im = ImpactManager(PlayerOwner().Level.TheImpactManager);
	//Texture Detail init
	bCurrentTexDetail = OptionsMenuPagePC.EditPlayerController.bLowDetailTextures;
	if (bCurrentTexDetail)
		iCurrentTexDetail = 0;
	else
		iCurrentTexDetail = 1;

	// Shadow init
	bBlobShadowsOnly = gi.bBlobShadowsOnly;
	bNoShadows = gi.bNoShadows;

	if (bNoShadows)
		iCurrentShadows = 0;
	else if (bBlobShadowsOnly)
		iCurrentShadows = 1;
	else 
		iCurrentShadows = 2;

	//Reflection init
	bCurrentCube = OptionsMenuPagePC.EditPlayerController.bUseCube;
	if (bCurrentCube)
		iCurrentCube = 0;
	else
		iCurrentCube = 1;

	//HDRL init
	bCurrentHDRL = OptionsMenuPagePC.EditPlayerController.bFullTimeHDR;

	//Decals init
	switch (im.MaxBulletDecals){
		case 24:
			iCurrentDecals = 0;  //Low
			break;
		case 64:
			iCurrentDecals = 1;	//Medium
			break;
		case 256:
			iCurrentDecals = 2;	//High
			break;
	}
	
	//Grass init
	fCurrentGrass = OptionsMenuPagePC.EditPlayerController.fGrassDetail;
	if (fCurrentGrass == 0.0){
		iCurrentGrass = 0;				//Off
	}
	else if (fCurrentGrass == 0.5){
		iCurrentGrass = 1;				//Low
	}
	else if (fCurrentGrass == 1.0){
		iCurrentGrass = 2;				//Medium
	}
	else{
		iCurrentGrass = 3;				//High
	}
	
	SetIntOption(OPTION_SHADOWS, iCurrentShadows);
	SetIntOption(OPTION_REFLECTIONS, iCurrentCube);
	SetIntOption(OPTION_DECALS, iCurrentDecals);
	SetIntOption(OPTION_GRASS, iCurrentGrass);
	SetNoYesOption(OPTION_HDRL, bCurrentHDRL);
	SetIntOption(OPTION_TEXDETAIL, iCurrentTexDetail);

}

function bool PageOptionsChanged()
{
	local bool result;

	//TODO:  This does not work as it is supposed to
	result = IntOptionChanged(OPTION_SHADOWS, iCurrentShadows) ||
			IntOptionChanged(OPTION_REFLECTIONS, iCurrentCube) ||
			IntOptionChanged(OPTION_DECALS, iCurrentDecals) ||
			IntOptionChanged(OPTION_GRASS, iCurrentGrass) ||
			NoYesOptionChanged(OPTION_HDRL, bCurrentHDRL) ||
			IntOptionChanged(OPTION_TEXDETAIL, iCurrentTexDetail);

	if (result)
		lblTextPrompt.SetCaption(class'gbx_DlgOkRestart'.default.StringAutoTextPrompt);
	else
		lblTextPrompt.SetCaption("");

	return result;
}


//TODO: Finish this function
function PageOptionsSave()
{
	local bool restart;
	local int i;
	local GameInfo gi;
	local ImpactManager im;

	restart=false;

	gi = PlayerOwner().Level.Game;
	im = ImpactManager(PlayerOwner().Level.TheImpactManager);


	if (IntOptionChanged(OPTION_SHADOWS, iCurrentShadows)){
		i = moSpinListControl(MyComponents[OPTION_SHADOWS]).GetIndex();
		ConsoleCommand("SHADOWS" @i);
		switch (i){
			case 0:
				gi.bNoShadows = true;
				gi.bBlobShadowsOnly = false;	
				break;
			case 1:
				gi.bNoShadows = false;
				gi.bBlobShadowsOnly = true;
				break;
			case 2:
				gi.bNoShadows = false;
				gi.bBlobShadowsOnly = false;
				break;
		}
		restart = true;
	}
	if (IntOptionChanged(OPTION_TEXDETAIL, iCurrentTexDetail))
	{
		OptionsMenuPagePC.EditPlayerController.bLowDetailTextures = !bCurrentTexDetail; //Low will be 0, high will be 1

		if (OptionsMenuPagePC.EditPlayerController.bLowDetailTextures)
			ConsoleCommand("LOWDETAILTEX");
		else
			ConsoleCommand("HIGHDETAILTEX");
		restart = true;
	}

	if (IntOptionChanged(OPTION_REFLECTIONS, iCurrentCube)){
		OptionsMenuPagePC.EditPlayerController.bUseCube = !bCurrentCube;  // Cube = false, True = true
		if(OptionsMenuPagePC.EditPlayerController.bUseCube)
			ConsoleCommand("CUBEMAPRENDERTARGET 1");
		else
			ConsoleCommand("CUBEMAPRENDERTARGET 0");
		restart = true;
	}

	if(NoYesOptionChanged(OPTION_HDRL,bCurrentHDRL)){
		OptionsMenuPagePC.EditPlayerController.bFullTimeHDR = GetNoYesOption(OPTION_HDRL);
		restart = true;
	}

	if (IntOptionChanged(OPTION_DECALS, iCurrentDecals)){
		i = moSpinListControl(MyComponents[OPTION_DECALS]).GetIndex();
		ConsoleCommand("DETAILSETTING" @i);
		switch (i){
			case 0:
				im.MaxBulletDecals = 24;
				break;
			case 1:
				im.MaxBulletDecals = 64;
				break;
			case 2:
				im.MaxBulletDecals = 256;
				break;
		}
		restart = true;		
	}

	if (IntOptionChanged(OPTION_GRASS, iCurrentGrass)){
		i = moSpinListControl(MyComponents[OPTION_GRASS]).GetIndex();
		ConsoleCommand("GRASSDETAILSETTING" @i);
		switch (i){
			case 0:
				OptionsMenuPagePC.EditPlayerController.fGrassDetail = 0.0;
				break;
			case 1:
				OptionsMenuPagePC.EditPlayerController.fGrassDetail = 0.5;
				break;
			case 2:
				OptionsMenuPagePC.EditPlayerController.fGrassDetail = 1.0;
				break;
			case 3:
				OptionsMenuPagePC.EditPlayerController.fGrassDetail = 2.0;
				break;
		}
        restart = true;		
	}

	//if we have changed an item that will need the user to restart, replace with the restart dialog menu
	if (restart){
		Controller.ReplaceMenu("GUI.gbx_DlgOkRestart" );	//NAC: Replace this menu with the menu that tells them that effects won't change until user restarts

	}

}

function PageOptionsDefaults()
{
	local string s;

	s = GetConfigString("bNoShadows", "Engine.GameInfo", "Default");
	if (bool(s))
		SetIntOption(OPTION_SHADOWS,0);  //default shadows to off
	else{
		s = GetConfigString("bBlobShadowsOnly", "Engine.GameInfo", "Default");
		if(bool(s))
			SetIntOption(OPTION_SHADOWS,1);  //default shadows to blob
		else
			SetIntOption(OPTION_SHADOWS,2);  //default shadows to projected
	}
	
	s = GetConfigString("bUseCube", "Engine.PlayerController", "DefUser");
	if(bool(s))
		SetIntOption(OPTION_REFLECTIONS, 0);
	else
		SetIntOption(OPTION_REFLECTIONS, 1);

	s = GetConfigString("MaxBulletDecals", "gbxBase.ImpactManager", "Default");
	switch (int(s)){
		case 24:
			SetIntOption(OPTION_DECALS, 0);
			break;
		case 64:
			SetIntOption(OPTION_DECALS,1);
			break;
		case 256:
			SetIntOption(OPTION_DECALS,2);
			break;
	}
	

	s = GetConfigString("fGrassDetail", "Engine.PlayerController", "DefUser");
	switch (float(s)){
		case 0.0:
			SetIntOption(OPTION_GRASS, 0);
			break;
		case 0.5:
			SetIntOption(OPTION_GRASS, 1);
			break;
		case 1.0:
			SetIntOption(OPTION_GRASS, 2);
			break;
		case 2.0:
			SetIntOption(OPTION_GRASS, 3);
			break;
	}
	
	s = GetConfigString("bFullTimeHDR", "Engine.PlayerController", "DefUser");
	SetNoYesOption(OPTION_HDRL, bool(s));
	
	s = GetConfigString("bUseLowDetailTextures", "Engine.PlayerController", "DefUser");
	if (bool(s))
		SetIntOption(OPTION_TEXDETAIL, 0);
	else
		SetIntOption(OPTION_TEXDETAIL, 1);
}

defaultproperties
{
	ScreenTitle="Performance Options"

	MyComponents(0)=cSpinMenuOption
	MyComponents(1)=cSpinMenuOption
	MyComponents(2)=cSpinMenuOption
	MyComponents(3)=cSpinMenuOption
	MyComponents(4)=cSpinMenuOption
	MyComponents(5)=cSpinMenuOption


	MyCaptions(0)="Shadows"
	MyCaptions(1)="Reflections"
	MyCaptions(2)="Decals Limit"
	MyCaptions(3)="Grass Detail"
	MyCaptions(4)="High Dynamic Range/Soft Lighting"
	MyCaptions(5)="Texture Detail"



	StringListShadows=("Projected","Blob","Off");
	StringListReflections=("True","Cube");
	StringListDecalsLimit=("High","Medium","Low");
	StringListTexDetail=("Low","High");
	StringListGrass = ("High","Medium","Low","Off");


}
class gbx_OptionsScreen extends gbx_MenuLayoutScreen;

var() Automated GUILabel			lblTextPrompt;

var gbx_MenuOptions					OptionsMenuPage;
var gbx_MenuOptionsPC				OptionsMenuPagePC;	//NAC WORKS FOR NOW

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	SetupXButton(StringDefaults);

	OnAButtonEvent = OnApply;
	OnBButtonEvent = OnCancel;
	OnXButtonEvent = OnDefaults;
	EnableApply(false);

	OptionsMenuPage = gbx_MenuOptions(ParentPage);
	OptionsMenuPagePC = gbx_MenuOptionsPC(ParentPage);  //NAC WORKS FOR NOW
}

event Opened(GUIComponent Sender)
{
	Super.Opened(Sender);

	PageOptionsInit();
}

function PageOptionsInit();
function bool PageOptionsChanged() {return false;}
function PageOptionsSave();
function PageOptionsCancel();
function PageOptionsDefaults();

function OnComponentChanged(int button, GUIComponent Sender)
{
	EnableApply(!PageOptionsChanged());
}

function OnApply()
{

	if (PageOptionsChanged())
	{
		PageOptionsSave();
		OptionsMenuPage.bSettingsChanged = true;
		OptionsMenuPagePC.bSettingsChanged = true; //NAC: WORKS FOR NOW
	}

	BaseOnAButton();
}

function OnCancel()
{
	PageOptionsCancel();
	BaseOnBButton();
}

function OnDefaults()
{
	Controller.PlayClickSound(EClickSound.CS_Click);
	PageOptionsDefaults();
}

function EnableApply(optional bool bDisabled)
{
	if (bDisabled)
		SetupAButton();
	else
		SetupAButton(ACaption);
}

function EnableOption(int iCtrlIndex, bool bEnable)
{
	MyComponents[iCtrlIndex].EnableControl(bEnable);
}

function SetNoYesOption(int iCtrlIndex, bool bSetYes)
{
	if (bSetYes)
		moSpinListControl(MyComponents[iCtrlIndex]).SetIndex(1);
	else
		moSpinListControl(MyComponents[iCtrlIndex]).SetIndex(0);
}
function bool GetNoYesOption(int iCtrlIndex)
{
	return moSpinListControl(MyComponents[iCtrlIndex]).GetIndex() == 1;
}
function bool NoYesOptionChanged(int iCtrlIndex, bool bOldYes)
{
	return GetNoYesOption(iCtrlIndex) != bOldYes;
}

function SetIntOption(int iCtrlIndex, int newIndex)
{
	moSpinListControl(MyComponents[iCtrlIndex]).SetIndex(newIndex);
}
function int GetIntOption(int iCtrlIndex)
{
	return moSpinListControl(MyComponents[iCtrlIndex]).GetIndex();
}
function bool IntOptionChanged(int iCtrlIndex, int oldIndex)
{
	return GetIntOption(iCtrlIndex) != oldIndex;
}

function TrimSpaces(out string s)
{
	while( Left(s,1)==" " || Asc(Left(s,1))==9 )
		s = Mid(s, 1);

	while( Right(s,1)==" " || Asc(Left(s,1))==9 )
		s = Left(s, Len(s)-1);
}

function string ParseKeyBindingToken(out string strIn)
{
	local string s;

	s = ParseTokenDelimited(strIn, "|");
	TrimSpaces(s);

	return s;
}

defaultproperties
{
	PagePlayerIndex=-3
	ACaption="Apply"

	Begin Object Class=GUILabel Name=cChangedPrompt
		StyleName="MenuOptionCaption"
		DrawMenuState=2
		TextAlign=TXTA_Center
		bAcceptsInput=false
		bTabStop=false
		bDrawToFit=true
		WinWidth=0.900000
		WinHeight=0.050000
		WinLeft=0.050000
		WinTop=0.7200000
	End Object
	lblTextPrompt=cChangedPrompt
}
class gbx_OptionsVideo extends gbx_OptionsScreen;


function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	SetupXButton(StringDefaults);
}

defaultproperties
{
	ScreenTitle="Video Options"
}
class gbx_OptionsVideoPC extends gbx_OptionsScreen;

var string							sCurrentResolution;
var int								iCurrentResolutionIndex;
var int								iCurrentGamma;
var int								iCurrentBrightness;
var int								iCurrentContrast;
var bool							bCurrentVsync;
var int								iCurrentAFiltering;  //Anisotropic Filtering
var bool							bInitializing;

var localized array<string>			StringListGBC;  //Gamma, Brightness, Contrast...they all use the same list
var localized array<string>			StringListAF;	//AFiltering
var localized array<string>			StringListRes;  //TODO:  Import the list of valid resolutions into this list

struct resolutionSetting{
	var string resolution;
	var array<string>refreshRates;
};

var array<resolutionSetting> Resolutions;
const OPTION_RESOLUTION		= 0;
//const OPTION_REFRESHRATE	= 1;
const OPTION_GAMMA			= 1;
const OPTION_BRIGHTNESS		= 2;
const OPTION_CONTRAST		= 3;
const OPTION_VSYNC			= 4;
const OPTION_AFILTERING		= 5;

var WargamePlayerController		EditPlayerController;


//NAC +
function int GetStringOptionIndex(int iCtrlIndex, string s, array<string> stringArray){
	local int i;

	for (i=0; i<stringArray.Length;i++){
		//loop through the components and see which index the string is at, return that index
		if (stringArray[i]==s){
			return i;
		}
	}
	return 0;
}
//NAC -


function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	local int i,j, refresh, refNum;
	local int resNum;
	local string resString, refString;
	local string width, height,wxh;

	Super.InitComponent(MyController, MyOwner);

	refNum = 0;
	bInitializing = true;  // avoid setting video options prematurely (otherwise screen flickers)

	resNum = int(ConsoleCommand("NUMD3DMODES"));
	Resolutions.Insert(0,resNum);  
	for (i=0; i<resNum;i++){
		resString = ConsoleCommand("GETD3DMODE" @i);
		width = ParseToken(resString);
		height = ParseToken(resString);
		refresh = int(ParseToken(resString));
		wxh=width$"x"$height;
		Resolutions[i].resolution=wxh;

		Resolutions[i].refreshRates.Insert(0,refresh);
		for (j=0;j<refresh;j++){
			refString = ConsoleCommand("GETD3DREFRESHRATE MODE="$i$" NUM="$j);
			Resolutions[i].refreshRates[j] = refString;
		}
		StringListRes[i] = Resolutions[i].resolution;
		if (refresh > refNum){
			refNum=refresh;
		}
	}
	//StringListRefresh.Insert(0,refNum);
	moSpinListControl(MyComponents[OPTION_RESOLUTION]).AddFromList(StringListRes);
	moSpinListControl(MyComponents[OPTION_GAMMA]).AddFromList(StringListGBC);
	moSpinListControl(MyComponents[OPTION_BRIGHTNESS]).AddFromList(StringListGBC);
	moSpinListControl(MyComponents[OPTION_CONTRAST]).AddFromList(StringListGBC);
	moSpinListControl(MyComponents[OPTION_VSYNC]).AddFromList(StringListOffOn);
	moSpinListControl(MyComponents[OPTION_AFILTERING]).AddFromList(StringListAF);
	bInitializing = false;
}

function PageOptionsInit()
{
	local PlayerController PC;
	PC = PlayerOwner();
	EditPlayerController = WargamePlayerController(PC);
	sCurrentResolution = PC.ConsoleCommand("GetCurrentRes");  //Get the current Resolution
	iCurrentResolutionIndex = GetStringOptionIndex(OPTION_RESOLUTION,sCurrentResolution,StringListRes);
	iCurrentGamma = EditPlayerController.iScreenGamma;
	iCurrentBrightness = EditPlayerController.iScreenBrightness;
	iCurrentContrast = EditPlayerController.iScreenContrast;
	bCurrentVsync = EditPlayerController.bUseVsync;
	iCurrentAFiltering = GetStringOptionIndex(OPTION_AFILTERING,string(OptionsMenuPagePC.EditPlayerController.iAFiltering),StringListAF);


	SetIntOption(OPTION_RESOLUTION, iCurrentResolutionIndex);
	SetIntOption(OPTION_GAMMA, iCurrentGamma);
	SetIntOption(OPTION_BRIGHTNESS, iCurrentBrightness);
	SetIntOption(OPTION_CONTRAST, iCurrentContrast);
	SetNoYesOption(OPTION_VSYNC, bCurrentVsync);
	SetIntOption(OPTION_AFILTERING, iCurrentAFiltering);
}

function bool RequiresRestart()
{
	return	NoYesOptionChanged(OPTION_VSYNC, bCurrentVsync) ||
			IntOptionChanged(OPTION_AFILTERING, iCurrentAFiltering);
}

function bool PageOptionsChanged()
{
	if (RequiresRestart())
		lblTextPrompt.SetCaption(class'gbx_DlgOkRestart'.default.StringAutoTextPrompt);
	else
		lblTextPrompt.SetCaption("");

	return	IntOptionChanged(OPTION_RESOLUTION, iCurrentResolutionIndex) ||
			IntOptionChanged(OPTION_GAMMA, iCurrentGamma) ||
			IntOptionChanged(OPTION_BRIGHTNESS, iCurrentBrightness) ||
			IntOptionChanged(OPTION_CONTRAST, iCurrentContrast) ||
			NoYesOptionChanged(OPTION_VSYNC, bCurrentVsync) ||
			IntOptionChanged(OPTION_AFILTERING, iCurrentAFiltering);
}

function OnComponentChanged(int button, GUIComponent Sender)
{
	if (bInitializing)
		return;

	Super.OnComponentChanged(button, Sender);

	switch(button)
	{
	case OPTION_GAMMA:
		// NOTE: somebody was adding 1 to the Int value of OPTION_GAMMA here which is NOT correct, the correct code is below - GBX:jlb
		ConsoleCommand("GAMMA" @ (float(GetIntOption(OPTION_GAMMA) ) / 10.0f) + 0.5);
		break;
	case OPTION_BRIGHTNESS:
		ConsoleCommand("BRIGHTNESS" @ float(GetIntOption(OPTION_BRIGHTNESS)) / 10.0f);
		break;
	case OPTION_CONTRAST:
		ConsoleCommand("CONTRAST" @ float(GetIntOption(OPTION_CONTRAST)) / 10.0f);
		break;
	}
}

//TODO: Finish this function
function PageOptionsSave()
{
	local string s;
	local PlayerController PC;
	local bool restart;
	

	restart = false;
	PC = PlayerOwner();
	EditPlayerController = WargamePlayerController(PC);
	if (IntOptionChanged(OPTION_BRIGHTNESS, iCurrentBrightness))
	{
		EditPlayerController.iScreenBrightness = GetIntOption(OPTION_BRIGHTNESS);
	}

	if (IntOptionChanged(OPTION_GAMMA, iCurrentGamma))
	{
		EditPlayerController.iScreenGamma = GetIntOption(OPTION_GAMMA);
	}

	if (IntOptionChanged(OPTION_CONTRAST, iCurrentContrast))
	{
		EditPlayerController.iScreenContrast = GetIntOption(OPTION_CONTRAST);
	}

	if (IntOptionChanged(OPTION_AFILTERING, iCurrentAFiltering))
	{
		s = StringListAF[moSpinListControl(MyComponents[OPTION_AFILTERING]).GetIndex()];
		ConsoleCommand("ANISOTROPICLEVEL" @s);
		EditPlayerController.iAFiltering = int(s);
		restart = true;
	}
	
	if (NoYesOptionChanged(OPTION_VSYNC, bCurrentVSync)){
		EditPlayerController.bUseVSync = GetNoYesOption(OPTION_VSYNC);
		if (GetNoYesOption(OPTION_VSYNC))
			ConsoleCommand("VSYNCPC 1");
		else
			ConsoleCommand("VSYNCPC 0");
		restart = true;
	}

	if (IntOptionChanged(OPTION_RESOLUTION, iCurrentResolutionIndex))
	{
		s = StringListRes[moSpinListControl(MyComponents[OPTION_RESOLUTION]).GetIndex()];
		Controller.ReplaceMenu("GUI.gbx_OptionsDlgChangeRes", s);
//		ConsoleCommand("SETRES" @s);
	}
	else if (restart)
	{
		Controller.ReplaceMenu("GUI.gbx_DlgOkRestart" );	//NAC: Replace this menu with the menu that tells them that effects won't change until user restarts
	}
}

//TODO: Finish this function
function PageOptionsCancel()
{
	if (IntOptionChanged(OPTION_BRIGHTNESS, iCurrentBrightness))
	{
		ConsoleCommand("BRIGHTNESS" @ float( iCurrentBrightness) / 10.0f);
	}

	if (IntOptionChanged(OPTION_GAMMA, iCurrentGamma))
	{
		ConsoleCommand("GAMMA" @ (float(iCurrentGamma) / 10.0f)+0.5);
	}

	if (IntOptionChanged(OPTION_CONTRAST, iCurrentContrast))
	{
		ConsoleCommand("CONTRAST" @ float(iCurrentContrast) / 10.0f);
	}

	if (IntOptionChanged(OPTION_AFILTERING, iCurrentAFiltering))
	{
		ConsoleCommand("ANISOTROPICLEVEL" @iCurrentAFiltering);
	}
}


function PageOptionsDefaults()
{
	local string s;
	local PlayerController PC;

	PC = PlayerOwner();
	EditPlayerController = WargamePlayerController(PC);

	//s = EditPlayerController.ConsoleCommand("GetCurrentRes");
	s = GetConfigString("defaultResolution", "Engine.PlayerController", "DefUser");
	SetIntOption(OPTION_RESOLUTION, GetStringOptionIndex(OPTION_RESOLUTION,s,StringListRes));

	s = GetConfigString("iScreenGamma", "Engine.PlayerController", "DefUser");
	SetIntOption(OPTION_GAMMA, int(s));

	s = GetConfigString("iScreenBrightness", "Engine.PlayerController", "DefUser");
	SetIntOption(OPTION_BRIGHTNESS, int(s));

	s = GetConfigString("iScreenContrast", "Engine.PlayerController", "DefUser");
	SetIntOption(OPTION_CONTRAST, int(s));

	s = GetConfigString("iAFiltering", "Engine.PlayerController", "DefUser");
	SetIntOption(OPTION_AFILTERING, GetStringOptionIndex(OPTION_AFILTERING, s,StringListAF));

	s = GetConfigString("bUseVsync", "Engine.PlayerController", "DefUser");
	SetNoYesOption(OPTION_VSYNC, bool(s));
}

defaultproperties
{
	ScreenTitle="Video Options"

	MyComponents(0)=cSpinMenuOption
	MyComponents(1)=cSpinMenuOption
	MyComponents(2)=cSpinMenuOption
	MyComponents(3)=cSpinMenuOption
	MyComponents(4)=cSpinMenuOption
	MyComponents(5)=cSpinMenuOption
	//MyComponents(6)=cSpinMenuOption

	MyCaptions(0)="Resolution"
	//MyCaptions(1)="Refresh Rate"
	MyCaptions(1)="Gamma"
	MyCaptions(2)="Brightness"
	MyCaptions(3)="Contrast"
	MyCaptions(4)="Vsync"
	MyCaptions(5)="Anisotropic Filtering"

	StringListGBC=("0","1","2","3","4","5","6","7","8","9")
	StringListAF = ("0","1","2","4","8","16");
}
class gbx_PopupMenuBase extends gbx_MenuLayoutScreen
	Abstract;

var bool						bStartCloses;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	Controller.LoadPlayerControllerBindings();

	bStartCloses = (ParentPage == None) || ParentPage.IsA('gbx_SPMissionOver') || ParentPage.IsA('gbx_DlgSoldiersDied');
	if (bStartCloses)
		bMergeAStart = false;

	if (ParentPage == None)
		Controller.WantMusicNow();

	SetTimer(0.5, true);
}

function bool SAB_OnXControllerEvent(byte Id, eXControllerCodes iCode)
{
	if (bStartCloses)
	{
		if (iCode == XC_Start)
		{
			BaseOnBButton();
			return true;
		}
		else if (iCode == XC_A)
		{
			iCode = XC_Start;
		}
	}

	return Super.SAB_OnXControllerEvent(Id, iCode);
}

function bool EnableFriendsMenu()
{
	return Controller.LiveFunc.GetFirstSignedInController() != -1;
}

event Timer();
function UpdateFriendsMenuItem(int itemIndex)
{
	local bool bEnable;
	local GUIComponent oldFocusedControl;

	bEnable = EnableFriendsMenu(); 
	oldFocusedControl = FocusedControl;

	if (bEnable != MyComponents[itemIndex].bVisible)
	{
		if (bEnable)
		{
			MyComponents[itemIndex].Show();
			DoComponentLayout();
			oldFocusedControl.SetFocus(None);
		}
		else
		{
			MyComponents[itemIndex].Hide();
			DoComponentLayout();
			oldFocusedControl.SetFocus(None);
		}
	}
}

event Opened(GUIComponent Sender)
{
	Super.Opened(Sender);

	// Bug 5398: Play a sound as feedback

	Controller.PlayClickSound(EClickSound.CS_Click);
}

defaultproperties
{
}
class gbx_PopupMenuMP extends gbx_PopupMenuBase;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
    bShowOnlineIcon=class'GameService.GameService'.static.IsInLobby();

	Super.InitComponent(MyController, MyOwner);

	Controller.LoadPlayerControllerBindings();

	if (PlayerOwner().Level.AuthMode != AM_Live)
		MyComponents[1].Hide();

	if (!EnableFriendsMenu())
		MyComponents[2].Hide();
		
    if (!class'GameService.GameService'.static.IsInLobby())
		MyComponents[5].Hide();

	LayoutControlArray(MyComponents, LayoutPivotPoint, LayoutSpacing, LayoutPivotStyle);
	MapControls();

	Controller.DebouncePlayerControllers();

	EnableDebugMenu();

	DisableSelectAButton();
}

function bool ScreenOnDraw(Canvas C)
{
	if (Controller.bIsConsole)
		DrawAdornmentIcons(C, MyComponents[2]);

	return Super.ScreenOnDraw(C);
}

function bool ShouldCloseAll()
{
	return !(LParam1 ~= "NOCLOSEALL");
}

function bool OnComponentActivate(int button, GUIComponent Sender)
{
	switch (button)
	{
		case 0:	// Resume
			if (!ShouldCloseAll())
				Controller.CloseMenu(false); 
			else
				Controller.CloseAll(false); 
			
			return true;

		case 1: // Players
			class'gbx_LivePlayersList'.static.LaunchPlayersList(Controller, Controller.FindPlayerForControllerIndex(Controller.ControllerId), true);
			return true;

		case 2: // Friends
			class'gbx_LiveFriendsList'.static.LaunchFriendsList(Controller, Controller.FindPlayerForControllerIndex(Controller.ControllerId), true);
			return true;

		case 3:	// Options
			if(Controller.bIsConsole){			//NAC Added for PC Options menu support
				return Controller.OpenMenu("GUI.gbx_MenuOptions", String(Controller.FindPlayerForControllerIndex(Controller.ControllerId)) ); 
				break;
			}
			else{
				return Controller.OpenMenu("GUI.gbx_MenuOptionsPC", String(Controller.FindPlayerForControllerIndex(Controller.ControllerId)) ); 
				break;
			}

		case 4: // Quit Mission
			return Controller.OpenMenu("GUI.gbx_DlgQuitToMenu"); break;

		case 5: // Logoff Ubi.com
			return Controller.OpenMenu("GUI.gbx_DlgLogoffToMenu"); break;
	}

	return false;
}

event Timer()
{
	UpdateFriendsMenuItem(2);
}

static function PreloadMenu(GUIController C)
{
	Super.PreloadMenu(C);

	C.PreloadMenu("GUI.gbx_LivePlayersList");
	C.PreloadMenu("GUI.gbx_LiveFriendsList");
	if (C.bIsConsole)							//NAC Added for PC Options menu support
		C.PreloadMenu("GUI.gbx_MenuOptions");
	else
		C.PreloadMenu("GUI.gbx_MenuOptionsPC");
	C.PreloadMenu("GUI.gbx_DlgQuitToMenu");
	C.PreloadMenu("GUI.gbx_MPLobbyClient");
	C.PreloadMenu("GUI.gbx_MPDebriefingClient");
	C.PreloadMenu("GUI.gbx_MPLobbyServer");
	C.PreloadMenu("GUI.gbx_MPDebriefingServer");
	C.PreloadMenu("GUI.gbx_DlgServerPlayAlone");

	C.PreloadMenu("GUI.gbx_SkirmishLobbyServerOffline");
	C.PreloadMenu("GUI.gbx_SkirmishLobbyServerOnline");
	C.PreloadMenu("GUI.gbx_SkirmishLobbyClientOnline");
	C.PreloadMenu("GUI.gbx_SkirmishGameOverClient");
	C.PreloadMenu("GUI.gbx_SkirmishGameOverServer");
}

defaultproperties
{
	LayoutSpacing=0.01
	MyComponents(0)=cBlockMenuButton
	MyComponents(1)=cBlockMenuButton
	MyComponents(2)=cBlockMenuButton
	MyComponents(3)=cBlockMenuButton
	MyComponents(4)=cBlockMenuButton
	MyComponents(5)=cBlockMenuButton

	MyCaptions(0)="Resume Game"
	MyCaptions(1)="Players List"
	MyCaptions(2)="Friends List"
	MyCaptions(3)="Options"
	MyCaptions(4)="Quit to Main Menu"
	MyCaptions(5)="Logoff Ubi.com"

	//WinLeft=0.2
	//WinTop=0.2
	//WinWidth=0.6
	//WinHeight=0.6

	bAllowedAsLast=true
	bRequireFullScreen=true
	ACaption="Select"

	bShowProfileLabels=false
}
class gbx_PopupMenuMPMut extends gbx_PopupMenuBase;

var Automated GUIListBox					MutatorListBox;


function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
    super.InitComponent( MyController, MyOwner );

    MutatorListBox.List.OnDrawItem	= DrawListItem;
	MutatorListBox.List.SelectedImage = None;

	BuildActiveList( PlayerOwner().GameReplicationInfo.mutators );
}

function BuildActiveList(string Mutators)
{
    local int pos;
    local string LeftOpt;

    if ( Mutators != "" )
	{
        while ( Mutators != "" )
		{
			pos = InStr(Mutators,",");
			if ( pos > 0 )
			{
				LeftOpt = Left(Mutators, pos);
				Mutators = Right(Mutators, Len(Mutators) - pos - 1);
			}
			else
			{
				LeftOpt = Mutators;
				Mutators = "";
			}
			MutatorListBox.List.Add( LeftOpt );
		}
	}
}

function DrawListItem(Canvas C, int Item, float X, float Y, float W, float H, bool bSelected)
{
	local eMenuState drawState;
	bSelected = false;

	if (Item == -1)
		return;

	if( bSelected )
		drawState = MSAT_Focused;
	else
		drawState = MSAT_Blurry;

	MutatorListBox.List.Style.DrawText( C, drawState, X, Y, W, H, TXTA_Center, MutatorListBox.List.GetItemAtIndex(Item) );

	if (bSelected)
	{
		W += X;
		X = 0;
		//class'GUI.gbx_ScreenABXY'.Static.DrawTheThinRedLine(Controller, C, X, Y+H, W);
	}
}
// rss: dont allow it to draw the red line
static function DrawTheThinRedLine(GUIController Con, Canvas C, int X, int Y, int XL)
{
}

defaultproperties
{

    ScreenTitle="Active Server Mutators"

	Begin Object class=GUIListBox Name=cMutatorListBox
		WinWidth=0.6
		WinHeight=0.58
		WinLeft=0.20
		WinTop=0.18
        bVisibleWhenEmpty=true
	End Object
	MutatorListBox=cMutatorListBox
}
class gbx_PopupMenuMPServer extends gbx_PopupMenuBase;

var localized string				StringPromptEndGame;
var localized string				StringPromptRestartGame;

var bool							bPromptingRestart;
var bool							bPaused;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
    bShowOnlineIcon=class'GameService.GameService'.static.IsInLobby();

	Super.InitComponent(MyController, MyOwner);

	Controller.LoadPlayerControllerBindings();

	if (PlayerOwner().Level.AuthMode != AM_Live)
		MyComponents[1].Hide();

	if (!EnableFriendsMenu())
		MyComponents[2].Hide();

    if (!class'GameService.GameService'.static.IsInLobby())
		MyComponents[7].Hide();

	if (!PlayerOwner().Level.Game.IsA('WargameSkirmish') || (WargameSkirmish(PlayerOwner().Level.Game).GameType == SGT_TourOfDuty))
		MyComponents[5].Hide();

	LayoutControlArray(MyComponents, LayoutPivotPoint, LayoutSpacing, LayoutPivotStyle);
	MapControls();

	Controller.DebouncePlayerControllers();

	EnableDebugMenu();

	// pause the game
	if(PlayerOwner().Level.Game.bPauseable && PlayerOwner().Level.Game.IsA('WargameSkirmish') && (PlayerOwner().Level.Pauser == None))
	{
		PlayerOwner().SetPause(true);
		bPaused = true;
	}
	OnClose = InternalOnClose;

	DisableSelectAButton();
}

function InternalOnClose(optional Bool bCancelled)
{
	if (bPaused)
		PlayerOwner().SetPause(false);
}

function bool ScreenOnDraw(Canvas C)
{
	if (Controller.bIsConsole)
		DrawAdornmentIcons(C, MyComponents[2]);

	return Super.ScreenOnDraw(C);
}

static function DoEndGame(GUIController C, bool bRestart)
{
	local GameInfo Game;

	Game = C.ViewportOwner.Actor.Level.Game;

	if (bRestart && Game.IsA('WargameSkirmish'))
	{
		// prevent player from moving around and rotating their view while the map reloads...
		C.ViewportOwner.Actor.bInterpolating = true;

		if (C.ViewportOwner.Actor != None)
		{
			C.ViewportOwner.Actor.bIsEndingMission = true;
		}
		ServerTravelSkirmish(C, C.ViewportOwner.Actor.Level.GetLevelFileName(), WargameSkirmish(Game).GetRulesString());
	}
	else
	{
		C.CloseAll(false);
		Game.EndGame(None, "aborted");
	}
}

function bool EndGameAnswer(string answer)
{
	if (answer ~= "YES")
	{
		DoEndGame(Controller, bPromptingRestart);
		return false;
	}

	return true;
}

function PromptEndGame(bool bIsRestart)
{
	local gbx_ScreenQuestion dlg;

	bPromptingRestart = bIsRestart;
	if (bPromptingRestart)
	{
		Controller.OpenMenu("GUI.gbx_DlgMPRestartMission");
	}
	else
	{
		// actually end mission to lobby
		if ((WargameSkirmish(PlayerOwner().Level.Game) != None) && (WargameSkirmish(PlayerOwner().Level.Game).GameType == SGT_TourOfDuty))
			dlg = LaunchQuestionDialog(Controller, class'gbx_SkirmishGameOverServer'.default.StringPromptToLobbyToD, "YESNO AREYOUSURE");
		else
			dlg = LaunchQuestionDialog(Controller, StringPromptEndGame, "YESNO AREYOUSURE");

		dlg.OnAnswer = EndGameAnswer;
	}
}

function bool OnComponentActivate(int button, GUIComponent Sender)
{
	switch (button)
	{
		case 0:	// Resume
			Controller.CloseAll(false); return true; break;

		case 1: // Players
			class'gbx_LivePlayersList'.static.LaunchPlayersList(Controller, Controller.FindPlayerForControllerIndex(Controller.ControllerId), true);
			return true;

		case 2: // Friends
			class'gbx_LiveFriendsList'.static.LaunchFriendsList(Controller, Controller.FindPlayerForControllerIndex(Controller.ControllerId), true);
			return true;

		case 3:	// Options
			if (Controller.bIsConsole){			//NAC Added for PC Options menu support
				return Controller.OpenMenu("GUI.gbx_MenuOptions", String(Controller.FindPlayerForControllerIndex(Controller.ControllerId)) ); 
				break;
			}
			else{
				return Controller.OpenMenu("GUI.gbx_MenuOptionsPC", String(Controller.FindPlayerForControllerIndex(Controller.ControllerId)) ); 
				break;
			}

		case 4: // Return to Lobby
			PromptEndGame(false);
			return true;

		case 5: // Restart Mission (skirmish only)
			PromptEndGame(true);
			return true;

		case 6: // Quit Mission
			return Controller.OpenMenu("GUI.gbx_DlgQuitToMenu"); break;

		case 7: // Logoff Ubi.com
			return Controller.OpenMenu("GUI.gbx_DlgLogoffToMenu"); break;
	}

	return false;
}

event Timer()
{
	UpdateFriendsMenuItem(2);
}

static function PreloadMenu(GUIController C)
{
	Super.PreloadMenu(C);

	C.PreloadMenu("GUI.gbx_PopupMenuMP");
}

defaultproperties
{
	LayoutSpacing=0.01
	MyComponents(0)=cBlockMenuButton
	MyComponents(1)=cBlockMenuButton
	MyComponents(2)=cBlockMenuButton
	MyComponents(3)=cBlockMenuButton
	MyComponents(4)=cBlockMenuButton
	MyComponents(5)=cBlockMenuButton
	MyComponents(6)=cBlockMenuButton
	MyComponents(7)=cBlockMenuButton

	MyCaptions(0)="Resume Game"
	MyCaptions(1)="Players List"
	MyCaptions(2)="Friends List"
	MyCaptions(3)="Options"
	MyCaptions(4)="End Mission"
	MyCaptions(5)="Restart Mission"
	MyCaptions(6)="Quit to Main Menu"
	MyCaptions(7)="Logoff Ubi.com"

	//WinLeft=0.2
	//WinTop=0.2
	//WinWidth=0.6
	//WinHeight=0.6

	bAllowedAsLast=true
	bRequireFullScreen=true
	ACaption="Select"

	StringPromptEndGame="You are about to end the current mission."
	StringPromptRestartGame="You are about to restart the current mission."
	bShowProfileLabels=false
}
class gbx_PopupMenuSP extends gbx_PopupMenuBase;

var bool						bIsIntro;
var bool						bHasProfiles;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	local GameProfile gProfile;
	local int LastMission, FirstIncomplete, LastDifficulty, SaveMissionDifficulty;
	local string SaveMissionName;
	
	Super.InitComponent(MyController, MyOwner);

	bIsIntro = PlayerOwner().Level.MissionManager.FindCurrentMission() == 0;
	bHasProfiles = class'Engine.GameProfile'.Static.GetProfileCount(PlayerOwner().Level, true) > 0;
/*
// CEK:FIRSTBOOT
	// if we're in the intro with no profiles, just quit to the "press start" screen immediately
	if (bIsIntro && !bHasProfiles)
	{
		class'GameEngine'.default.DisconnectMenuClass = class'GameEngine'.default.InitialMenuClass;
		class'GameEngine'.static.StaticSaveConfig();
		ConsoleCommand("disconnect");
		return;
	}
*/
	Controller.LoadPlayerControllerBindings();

	if ((gbx_SPMissionOver(ParentPage) != None) || (gbx_DlgSoldiersDied(ParentPage) != None))
	{
		MyComponents[0].Hide();
	}

	// load the current profile's savegame and checkpoint data
	gProfile = class'GameProfile'.Static.LoadCurrentGameProfile( PlayerOwner().Level );
	if (gProfile != None)
	{
		LastMission = gProfile.LastMissionCompleted;
		LastDifficulty = gProfile.LastDifficultyCompleted;
		FirstIncomplete = gProfile.FindFirstIncompleteMission();
		SaveMissionName = gProfile.SaveMissionName;
		SaveMissionDifficulty = gProfile.SaveMissionDifficulty;
		class'GameProfile'.Static.UnloadProfile( PlayerOwner().Level, gProfile );

//		if ( ((PlayerOwner().Level.MissionManager.GetMissionName( LastMission ) != SaveMissionName) || (LastDifficulty != SaveMissionDifficulty)) && !bool(ConsoleCommand("SAVEGAMEEXISTS 1")))
		if (SaveMissionName == "")
		{
			MyComponents[2].Hide();
		}
	}
	else
	{
		if ( !bool(ConsoleCommand("SAVEGAMEEXISTS 1")) )	// do we have a saved checkpoint?
		{
			MyComponents[2].Hide();
		}
	}

	if (!EnableFriendsMenu())
		MyComponents[3].Hide();

	if (bIsIntro)
	{
		// disable restart/reload
		MyComponents[2].Hide();
/*
// CEK:FIRSTBOOT
		// disable options/friends/quit if we have no profiles (first-boot run)
		if (!bHasProfiles)
		{
			MyComponents[3].Hide();
			MyComponents[4].Hide();
			MyComponents[5].Hide();
		}
*/
	}
	else
	{
		MyComponents[6].Hide();
	}

	DoComponentLayout();

	// pause the game
	if(PlayerOwner().Level.Pauser == None)
		PlayerOwner().SetPause(true);

	OnXButtonEvent = OpenCheatsMenu;
	OnClose = InternalOnClose;

	// EnableDebugMenu may override X
	EnableDebugMenu();

	DisableSelectAButton();
}

function InternalOnClose(optional Bool bCancelled)
{
	PlayerOwner().SetPause(false);
}

function OpenCheatsMenu()
{
	Controller.OpenMenu("GUI.gbx_MenuCheats" );
}

function bool ScreenOnDraw(Canvas C)
{
	if (Controller.bIsConsole)
		DrawAdornmentIcons(C, MyComponents[3]);

	return Super.ScreenOnDraw(C);
}

function bool OnComponentActivate(int button, GUIComponent Sender)
{
	switch (button)
	{
		case 0:	// Resume
			Controller.CloseAll(false); return true; break;

		case 1: // Restart Mission
			return Controller.OpenMenu("GUI.gbx_DlgSPRestartMission", "RESTART"); break;

		case 2: // Reload Chapter
			return Controller.OpenMenu("GUI.gbx_DlgSPRestartMission", "CHECKPOINT"); break;

		case 3: // Friends
			class'gbx_LiveFriendsList'.static.LaunchFriendsList(Controller, 0, true);
			return true;

		case 4:	// Options
			if(Controller.bIsConsole){ //NAC: ADDED for PC Options Menu
				return Controller.OpenMenu("GUI.gbx_MenuOptions", String(Controller.FindPlayerForControllerIndex(Controller.ControllerId))); break;}
			else{return Controller.OpenMenu("GUI.gbx_MenuOptionsPC", String(Controller.FindPlayerForControllerIndex(Controller.ControllerId))); break;}//NAC: ADDED for PC Options Menu
			//return Controller.OpenMenu("GUI.gbx_MenuOptions", String(Controller.FindPlayerForControllerIndex(Controller.ControllerId)) ); break;

		case 5: // Quit Mission
			return Controller.OpenMenu("GUI.gbx_DlgQuitToMenu"); break;

		case 6: // Skip Intro
			return Controller.OpenMenu("GUI.gbx_DlgQuitToMenu","SKIP"); break;
	}

	return false;
}

event Timer()
{
	UpdateFriendsMenuItem(3);
}

function bool ShouldShowControllerInfo(int inPlayerIndex)
{
	if (bIsIntro && !bHasProfiles)
		return false;

	return Super.ShouldShowControllerInfo(inPlayerIndex);
}

static function PreloadMenu(GUIController C)
{
	Super.PreloadMenu(C);

	C.PreloadMenu("GUI.gbx_DlgSPRestartMission");
	C.PreloadMenu("GUI.gbx_LiveFriendsList");
	if (C.bIsConsole)					//NAC Added for PC Options menu support
		C.PreloadMenu("GUI.gbx_MenuOptions");
	else
		C.PreloadMenu("GUI.gbx_MenuOptionsPC");
	C.PreloadMenu("GUI.gbx_DlgQuitToMenu");
	C.PreloadMenu("GUI.gbx_MenuCheats");
}

defaultproperties
{
	LayoutSpacing=0.01
	MyComponents(0)=cBlockMenuButton
	MyComponents(1)=cBlockMenuButton
	MyComponents(2)=cBlockMenuButton
	MyComponents(3)=cBlockMenuButton
	MyComponents(4)=cBlockMenuButton
	MyComponents(5)=cBlockMenuButton
	MyComponents(6)=cBlockMenuButton

	MyCaptions(0)="Resume Chapter"
	MyCaptions(1)="Restart Chapter"
	MyCaptions(2)="Reload Checkpoint"
	MyCaptions(3)="Friends List"
	MyCaptions(4)="Options"
	MyCaptions(5)="Quit Chapter"
	MyCaptions(6)="Skip Intro"

	//WinLeft=0.2
	//WinTop=0.2
	//WinWidth=0.6
	//WinHeight=0.6

	bAllowedAsLast=true
	ACaption="Select"
	XCaption="Cheats"
}

class gbx_ProfileChooserMenuBase extends gbx_ProfileChooserSubMenu;

var automated array<GUIComponent>	MyComponents;
var localized array<string>			MyCaptions;
var array<bool>						IsReadyButton;

var GUIComponent					MyFocusedControl;


function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	local int i;
	Super.InitComponent(MyController, MyOwner);

	for (i=0; i<MyComponents.Length; i++)
	{
		MyComponents[i].SetCaption(MyCaptions[i]);
		MyComponents[i].OnClick = OnButtonClick;
		MyComponents[i].TabOrder = i;
	}

	DoComponentLayout();
}

function DoComponentLayout()
{
	LayoutControlArray(MyComponents, 0.4750, 0.01, LA_Center);
	MapControls();

	MoveFocusToControl(FocusedControl);
}

function SubMenuOnShow()
{
	Super.SubMenuOnShow();

	MoveFocusToControl(MyComponents[0]);
	SetReady(false);
}

function SetReady(bool bSetReady)
{	
	local int i;

	Super.SetReady(bSetReady);
	UpdateMenuButtonStates();

	// reset captions, flashing
	if (!bSetReady)
	{
		for (i=0; i<MyComponents.Length; i++)
		{
			if (IsReadyButton[i])
			{
				MyComponents[i].SetCaption(MyCaptions[i]);
				MyComponents[i].pulseStyle = CPS_None;
			}
		}
	}
}

function UpdateMenuButtonStates()
{
	local int i;

	for (i=0; i<MyComponents.Length; i++)
	{
		if (MyChooserRoot.bReady && (MyComponents[i] != MyFocusedControl))
			SetMenuButtonEnabled(i, false);
		else
			SetMenuButtonEnabled(i, true);
	}

	if (GetFirstControl() != -1)
	{
		if ((MyFocusedControl == None) || MyFocusedControl.bDisabled)
		{
			for (i=0; i<MyComponents.Length; i++)
			{
				if (!MyComponents[i].bDisabled)
					MyComponents[i].MenuStateChange(MSAT_Blurry);
			}

			if (GetComponentIndex(FocusedControl) != -1)
				MoveFocusToControl(FocusedControl);
			else
				MoveFocusToControl(MyComponents[GetFirstControl()]);
		}
	}
}

function SetMenuButtonEnabled(int index, bool bEnable)
{
	MyComponents[index].EnableControl(bEnable);
}

function MoveFocusToControl(GUIComponent comp)
{
	if (MyFocusedControl != None)
		MyFocusedControl.MenuStateChange(MSAT_Blurry);

	comp.MenuStateChange(MSAT_Focused);
	MyFocusedControl = comp;
	FocusedControl = None;
}

event LoseFocus(GUIComponent Sender)
{
	Super.LoseFocus(Sender);
	MoveFocusToControl(MyFocusedControl);
}

function int GetComponentIndex(GUIComponent comp)
{
	local int i;

	if (comp != None)
	{
		for (i=0; i<MyComponents.Length; i++)
		{
			if (MyComponents[i] == comp)
				return i;
		}
	}

	return -1;
}

function int GetFirstControl()
{
	if (!MyComponents[0].bDisabled)
		return 0;

	return GetNextControl(0, false);
}

function int GetNextControl(int start, bool bWrap)
{
	local int i;

	i = start+1;
	while(i != start)
	{
		if (i >= MyComponents.Length)
		{
			if (!bWrap)
				break;
			else
			{
				i = 0;
				continue;
			}
		}

		if (!MyComponents[i].bDisabled)
			return i;

		i++;
	}

	return -1;
}

function int GetPrevControl(int start, bool bWrap)
{
	local int i;

	i = start-1;
	while(i != start)
	{
		if (i < 0)
		{
			if (!bWrap)
				break;
			else
			{
				i = MyComponents.Length - 1;
				continue;
			}
		}

		if (!MyComponents[i].bDisabled)
			return i;

		i--;
	}

	return -1;
}

function bool OnCursor(byte Id, eXControllerCodes iCode)
{
	local int i;

	if (!MyChooserRoot.bReady)
	{
		i = GetComponentIndex(MyFocusedControl);
		
		if (i == -1)
		{
			i = GetFirstControl();
		}
		else if (iCode == XC_PadUp)
		{
			i = GetPrevControl(i, true);
		}
		else if (iCode == XC_PadDown)
		{
			i = GetNextControl(i, true);
		}

		if ((i != -1) && (MyFocusedControl != MyComponents[i]))
		{
			MoveFocusToControl(MyComponents[i]);

			Controller.PlayClickSound(EClickSound.CS_Focus);
		}
	}

	return true;
}

function OnBButton()
{
	if (MyChooserRoot.bReady)
	{
		Controller.PlayClickSound(EClickSound.CS_Back);
		SetReady(false);
	}
	else
		Super.OnBButton();
}

function bool MenuButtonActivated(GUIComponent which, int buttonIndex)
{
	if (buttonIndex == -1) return false;

	if (IsReadyButton[buttonIndex])
	{
		SetReady(true);
		MyComponents[buttonIndex].SetCaption(MyChooserRoot.StringWaiting);
		MyComponents[buttonIndex].pulseStyle = CPS_Slow;
	}

	return true;
}

function OnAButton()
{
	Controller.PlayClickSound(EClickSound.CS_Click);
	OnButtonClick(MyFocusedControl);
}

function bool OnButtonClick(GUIComponent Sender)
{
	local int i;

	i = GetComponentIndex(Sender);
	if (i != -1)
		return MenuButtonActivated(Sender, i);

	return false;
}

function DrawChooserPanel(Canvas C)
{
	if (!MyChooserRoot.bReady)
	{
		if (MyChooserRoot.PagePlayerIndex == 0)
			MyChooserRoot.ChooserBase.DrawFocusedControl(C, MyFocusedControl, -1);
		else
			MyChooserRoot.ChooserBase.DrawFocusedControl(C, MyFocusedControl, 1);
	}
}

function SetupHelpButtons()
{
	MyChooserRoot.SetupAButton(MyChooserRoot.ChooserBase.StringSelect);
	MyChooserRoot.SetupBButton(MyChooserRoot.ChooserBase.StringBack);
}

function Tick()
{
	Super.Tick();
	if (!bVisible) return;

	UpdateMenuButtonStates();
}


defaultproperties
{
	Begin Object Class=GUIButton Name=cChooserMenuButton
		StyleName="LargeButton"
		WinWidth=0.900000
		WinHeight=0.06000
		WinLeft=0.050000
		WinTop=0.250000
		TabOrder=0
	End Object
}

class gbx_ProfileChooserNew1P extends gbx_ProfileChooserNewBase;

var automated gbx_ProfileChooserNew1PMenuMP MPViewMenu1P;
var automated gbx_ProfileChooserNew1PMenuLive LiveViewMenu1P;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	MPViewMenu = MPViewMenu1P;
	LiveViewMenu = LiveViewMenu1P;
}

// =======================================================================================================================================================
// =======================================================================================================================================================
// state logic
// =======================================================================================================================================================
// =======================================================================================================================================================
state Init
{
	function BeginState()
	{
		bAllowSkipStartState = true;
		bReady = false;
		bCancel = false;

		HideAll();

		GotoState('PressStart');

		bAllowSkipStartState = false;
	}
}

state MPView
{
	function StateBack()
	{
		if (CanOtherCancel())
			bCancel = true;
		else
			GotoState('PressStart');
	}
}

defaultproperties
{
	Begin Object Class=gbx_ProfileChooserNew1PMenuMP Name=c1PMPViewMenu
	End Object
	MPViewMenu1P=c1PMPViewMenu

	Begin Object Class=gbx_ProfileChooserNew1PMenuLive Name=c1PLiveViewMenu
	End Object
	LiveViewMenu1P=c1PLiveViewMenu

	StringWaiting="Waiting for P2..."
}

class gbx_ProfileChooserNew1PMenuLive extends gbx_ProfileChooserMenuBase;

var float					ContentDownloadCheckTime;
var float					ContentDownloadCheckInterval;
var bool					bContentAvailable;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);
}

function SubMenuOnShow()
{
	ContentDownloadCheckTime = PlayerOwner().Level.UniversalTimeSeconds;

	Super.SubMenuOnShow();
}

function Tick()
{
	Super.Tick();

	if (!Controller.LiveFunc.IsSignedIn(MyChooserRoot.PagePlayerIndex) && MyChooserRoot.bReady)
		SetReady(false);
/*
	if (PlayerOwner().Level.UniversalTimeSeconds >= ContentDownloadCheckTime)
	{
        bContentAvailable = ConsoleCommand("XLIVE NEW_CONTENT") ~= "YES";
		ContentDownloadCheckTime = PlayerOwner().Level.UniversalTimeSeconds + ContentDownloadCheckInterval;

		if (bContentAvailable)
			MyComponents[7].pulseStyle = CPS_Slow;
		else
			MyComponents[7].pulseStyle = CPS_None;
	}
*/
}

function DrawChooserPanel(Canvas C)
{
	local Canvas.CanvasIcon icon;

	MyChooserRoot.ChooserBase.GetNotificationIcon(MyChooserRoot.PagePlayerIndex, icon);
	MyChooserRoot.ChooserBase.DrawAttachedPlayerIcon(C, icon, MyComponents[3], false);

	Super.DrawChooserPanel(C);
}

// DS-BEGIN
// Changed around because the indicies changes
function SetMenuButtonEnabled(int index, bool bEnable)
{
	if (bEnable)
	{
		switch(index)
		{
		case 0:	// quick only available if signed in
		case 1:	// opti only available if signed in
		case 2:	// create only available if signed in
		case 6:	// can sign out if we're signed in
			bEnable = MyChooserRoot.SignInAccountName != "";
			break;

		case 3:	// friends only if signed in and not a guest
		case 4: // Leaderboard only if signed in and not a guest
//		case 7:	// Bug 8806 : Prevent guests from downloading content.
			bEnable = !MyChooserRoot.bIsGuest && (MyChooserRoot.SignInAccountName != "");
			break;

		case 5:	// can "change" signin at any time
			break;
		}
	}

	Super.SetMenuButtonEnabled(index, bEnable);
}
// DS-END

// DS-BEGIN
// Changed around because the indicies changes
function bool MenuButtonActivated(GUIComponent which, int buttonIndex)
{
	if (!Super.MenuButtonActivated(which, buttonIndex)) return false;

	switch(buttonIndex)
	{
	case 3: 
		class'gbx_LiveFriendsList'.static.LaunchFriendsList(Controller, MyChooserRoot.PagePlayerIndex, true);
		break;
	case 4:
		class'gbx_LiveLeaderboardMapSelect'.static.LaunchLeaderboard(Controller, MyChooserRoot.PagePlayerIndex);
		break;
	case 5: 
		MyChooserRoot.GotoState('ChangeSignIn');
		break;

	case 6: 
		class'gbx_LiveDlgSignOut'.static.PromptSignOut(Controller, MyChooserRoot.PagePlayerIndex);
		break;

//	case 7: Controller.OpenMenu("GUI.gbx_LiveDlgContentDownload"); break;
	}

	return true;
}
// DS-END

function ScreenClosed(bool bCancelled)
{
	local int i;

	if (!bCancelled)
	{
		i = GetComponentIndex(MyFocusedControl);
		switch(i)
		{
		case 0: SetReady(false); Controller.OpenMenu("GUI.gbx_LiveQueryQuickMatch"); break;
		case 1: SetReady(false); Controller.OpenMenu("GUI.gbx_LiveOptiMatchRules"); break;
		case 2: SetReady(false); Controller.OpenMenu("GUI.gbx_LiveCreateMatch"); break;
		}
	}
}


// DS-BEGIN
// Some new components, some index changes
defaultproperties
{
	MyComponents(0)=cChooserMenuButton
	MyComponents(1)=cChooserMenuButton
	MyComponents(2)=cChooserMenuButton
	MyComponents(3)=cChooserMenuButton
	MyComponents(4)=cChooserMenuButton
	MyComponents(5)=cChooserMenuButton
	MyComponents(6)=cChooserMenuButton
//	MyComponents(7)=cChooserMenuButton

	MyCaptions(0)="Quick Match"
	MyCaptions(1)="OptiMatch"
	MyCaptions(2)="Create Match"
	MyCaptions(3)="Friends List"
	MyCaptions(4)="Leaderboard"
	MyCaptions(5)="Change Sign-In"
	MyCaptions(6)="Sign-Out"
//	MyCaptions(7)="Downloads"

	IsReadyButton(0)=true
	IsReadyButton(1)=true
	IsReadyButton(2)=true
	IsReadyButton(3)=false
	IsReadyButton(4)=false
	IsReadyButton(5)=false
	IsReadyButton(6)=false
	IsReadyButton(7)=false

	StringPanelHeader="Xbox Live"
	ContentDownloadCheckInterval=3

	bRequireLive=true
}
// DS-END


class gbx_ProfileChooserNew1PMenuMP extends gbx_ProfileChooserMenuBase;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);
}

function SetMenuButtonEnabled(int index, bool bEnable)
{
	if (bEnable)
	{
		switch(index)
		{
		case 1:	// System Link
			bEnable = Controller.LiveFunc.IsLinkActive();
			break;

		case 0:	// split screen
		case 2:	// Live
		case 3:	// profile
		case 4:	// options
			break;
		}
	}

	Super.SetMenuButtonEnabled(index, bEnable);
}

function bool MenuButtonActivated(GUIComponent which, int buttonIndex)
{
	if (!Super.MenuButtonActivated(which, buttonIndex)) return false;

	switch(buttonIndex)
	{
	case 0: MyChooserRoot.GotoState('LiveView'); break;
	case 3: MyChooserRoot.GotoState('ChangeProfile'); break;
	case 4: 
		if (Controller.bIsConsole){			//NAC Added for PC Options menu support
			Controller.OpenMenu("GUI.gbx_MenuOptions", "0"); 
			break;
		}
		else{
			Controller.OpenMenu("GUI.gbx_MenuOptionsPC", "0"); 
		}
	}

	return true;
}

function ScreenClosed(bool bCancelled)
{
	local int i;

	if (!bCancelled)
	{
		i = GetComponentIndex(MyFocusedControl);
		switch(i)
		{
		case 2: SetReady(false); Controller.OpenMenu("GUI.gbx_CreateMatchSplitScreen"); break;
		case 1: SetReady(false); Controller.OpenMenu("GUI.gbx_BrowseMatchSysLink"); break;
		}
	}
}

function bool TestReady()
{
	local int i;

	if (MyChooserRoot.bReady)
	{
		// system link requres the other controller to be ready too
		i = GetComponentIndex(MyFocusedControl);
		if (i == 2)
		{
			return MyChooserRoot.IsOtherReady() && (MyChooserRoot.ChooserBase.GetPlayerState(1) != 'PressStart');
		}
	}

	return MyChooserRoot.bReady;
}

defaultproperties
{
	MyComponents(0)=cChooserMenuButton
	MyComponents(1)=cChooserMenuButton
	MyComponents(2)=cChooserMenuButton
	MyComponents(3)=cChooserMenuButton
	MyComponents(4)=cChooserMenuButton

	MyCaptions(0)="Xbox Live"
	MyCaptions(1)="System Link"
	MyCaptions(2)="Split Screen"
	MyCaptions(3)="Profile"
	MyCaptions(4)="Options"

	IsReadyButton(0)=false
	IsReadyButton(1)=true
	IsReadyButton(2)=true
	IsReadyButton(3)=false
	IsReadyButton(4)=false

	StringPanelHeader="Multiplayer"
}

class gbx_ProfileChooserNew2P extends gbx_ProfileChooserNewBase;

var automated gbx_ProfileChooserNew2PMenuMP MPViewMenu2P;
var automated gbx_ProfileChooserNew2PMenuLive LiveViewMenu2P;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	MPViewMenu = MPViewMenu2P;
	LiveViewMenu = LiveViewMenu2P;
}

// =======================================================================================================================================================
// =======================================================================================================================================================
// state logic
// =======================================================================================================================================================
// =======================================================================================================================================================
state Init
{
	function BeginState()
	{
		bAllowSkipStartState = false;
		Super.BeginState();
	}
}


// =======================================================================================================================================================
// state PressStart
// =======================================================================================================================================================
state PressStart
{
	function BeginState()
	{
		// P2 is ready to exit if here
		bReady = true;

		Super.BeginState();
	}

	function ScreenClosed(bool bCancelled)
	{
		// unbind player 2 if we continue through with P2 at the start screen
		if (!bCancelled)
		{
			SetProfile("");
		}

		Super.ScreenClosed(bCancelled);
	}
}

state MPView
{
	function StateBack()
	{
		GotoState('PressStart');
	}
}

defaultproperties
{
	Begin Object Class=gbx_ProfileChooserNew2PMenuMP Name=c2PMPViewMenu
	End Object
	MPViewMenu2P=c2PMPViewMenu

	Begin Object Class=gbx_ProfileChooserNew2PMenuLive Name=c2PLiveViewMenu
	End Object
	LiveViewMenu2P=c2PLiveViewMenu

	StringWaiting="Waiting for P1..."
}

class gbx_ProfileChooserNew2PMenuLive extends gbx_ProfileChooserMenuBase;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);
}

function DrawChooserPanel(Canvas C)
{
	local Canvas.CanvasIcon icon;

	MyChooserRoot.ChooserBase.GetNotificationIcon(MyChooserRoot.PagePlayerIndex, icon);
	MyChooserRoot.ChooserBase.DrawAttachedPlayerIcon(C, icon, MyComponents[1], true);

	Super.DrawChooserPanel(C);
}

function SetMenuButtonEnabled(int index, bool bEnable)
{
	if (bEnable)
	{
		switch(index)
		{
		case 1:	// friends/leaderboard only if signed in and not a guest
		case 2:
			bEnable = !MyChooserRoot.bIsGuest && (MyChooserRoot.SignInAccountName != "");
			break;

		case 3:	// can "change" signin at any time
			break;

		case 0:
		case 4:	// can sign out if we're signed in
			bEnable = MyChooserRoot.SignInAccountName != "";
			break;
		}
	}

	Super.SetMenuButtonEnabled(index, bEnable);
}

function bool MenuButtonActivated(GUIComponent which, int buttonIndex)
{
	if (!Super.MenuButtonActivated(which, buttonIndex)) return false;

	switch(buttonIndex)
	{
	case 1: class'gbx_LiveFriendsList'.static.LaunchFriendsList(Controller, MyChooserRoot.PagePlayerIndex, true); break;
	case 2: class'gbx_LiveLeaderboardMapSelect'.static.LaunchLeaderboard(Controller, MyChooserRoot.PagePlayerIndex); break;

	case 3:
		MyChooserRoot.GotoState('ChangeSignIn');
		break;

	case 4: 
		class'gbx_LiveDlgSignOut'.static.PromptSignOut(Controller, MyChooserRoot.PagePlayerIndex);
		break;
	}

	return true;
}

function ScreenClosed(bool bCancelled)
{
	if (!bCancelled)
	{
		SetReady(false);
	}
}

function Tick()
{
	Super.Tick();

	if (!Controller.LiveFunc.IsSignedIn(MyChooserRoot.PagePlayerIndex) && MyChooserRoot.bReady)
		SetReady(false);
}

defaultproperties
{
	MyComponents(0)=cChooserMenuButton
	MyComponents(1)=cChooserMenuButton
	MyComponents(2)=cChooserMenuButton
	MyComponents(3)=cChooserMenuButton
	MyComponents(4)=cChooserMenuButton

	MyCaptions(0)="Ready"
	MyCaptions(1)="Friends List"
	MyCaptions(2)="Leaderboard"
	MyCaptions(3)="Change Sign-In"
	MyCaptions(4)="Sign-Out"

	IsReadyButton(0)=true
	IsReadyButton(1)=false
	IsReadyButton(2)=false
	IsReadyButton(3)=false
	IsReadyButton(4)=false

	StringPanelHeader="Xbox Live"
	bRequireLive=true
}

class gbx_ProfileChooserNew2PMenuMP extends gbx_ProfileChooserMenuBase;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);
}

function bool MenuButtonActivated(GUIComponent which, int buttonIndex)
{
	if (!Super.MenuButtonActivated(which, buttonIndex)) return false;

	switch(buttonIndex)
	{
	case 1: MyChooserRoot.GotoState('LiveView'); break;
	case 2: MyChooserRoot.GotoState('ChangeProfile'); break;
	case 3: 
		if(Controller.bIsConsole){	//NAC Added for PC Options menu support
			Controller.OpenMenu("GUI.gbx_MenuOptions", "1"); 
			break;
		}
		else{
			Controller.OpenMenu("GUI.gbx_MenuOptions", "1"); 
			break;
		}
	}

	return true;
}

function ScreenClosed(bool bCancelled)
{
	if (!bCancelled)
	{
		SetReady(false);
	}
}

defaultproperties
{
	MyComponents(0)=cChooserMenuButton
	MyComponents(1)=cChooserMenuButton
	MyComponents(2)=cChooserMenuButton
	MyComponents(3)=cChooserMenuButton

	MyCaptions(0)="Ready"
	MyCaptions(1)="Xbox Live"
	MyCaptions(2)="Profile"
	MyCaptions(3)="Options"

	IsReadyButton(0)=true
	IsReadyButton(1)=false
	IsReadyButton(2)=false
	IsReadyButton(3)=false

	StringPanelHeader="Multiplayer"
}

class gbx_ProfileChooserNewBase extends GUIPage;

var automated	gbx_ProfileChooserPressStart	PressStartChooser;
var automated 	gbx_ProfileSelect				ProfileSelect;
var Automated	gbx_ProfileChooser_LiveSignIn	AccountChooser;
var	Automated	gbx_ProfileChooserNewMenuLiveOnly	LiveOnlyMenu;

var				gbx_ProfileChooserMenuBase		MPViewMenu;
var				gbx_ProfileChooserMenuBase		LiveViewMenu;

var	gbx_ProfileChooserSubMenu				ActiveMenu;
var	gbx_ProfileScreenBase					ChooserBase;

var automated 	GUIHelpButton				hbtnA;
var automated 	GUIHelpButton				hbtnB;
var	float									hbtnALeft[2];
var	float									hbtnBLeft[2];

var string									SignInAccountName;
var bool									bIsGuest;
var bool									bAllowSkipStartState;
var bool									bInitializing;
var bool									bReady, bCancel;
var bool									bSignInShouldAutoExit;
var bool									bSignInReturnToMPView;
var bool									bNoForceSignIn;
var bool									bSignInLastTest;


var localized string						StrSigningIn;
var localized string						StrSignIn;
var localized string						StrSignOut;
var localized string						StringWaiting;


function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	InitExecution();

	Super.InitComponent(MyController, MyOwner);
	ChooserBase = gbx_ProfileScreenBase(MyOwner);

	hBtnA.WinLeft = hbtnALeft[PagePlayerIndex];
	hBtnB.WinLeft = hbtnBLeft[PagePlayerIndex];
}

// nothing happens until this function is called!
function SetMode(bool bSignIn)
{
	if (!bSignIn && (GetControllerIndex() != -1) && (ChooserBase.LParam2 != ""))
	{
		if ((ChooserBase.LParam2 ~= "LINK") || (ChooserBase.LParam2 ~= "SPLIT"))
		{
			if (HasProfile())
				GotoState('MPView');
			else
				GotoState('PickProfile');

			return;
		}
		else if ((ChooserBase.LParam2 ~= "LIVE") || Controller.LiveFunc.IsSignedIn(PagePlayerIndex))
		{
			if (!HasProfile())
				GotoState('PickProfile');
			else
				GotoState('LiveView');

			return;
		}
	}
	
	if ((PagePlayerIndex == 1) && (GetControllerIndex() != -1))
		GotoState('PickProfile');
	else
		GotoState('Init');
}

function RefreshSignIn()
{
	local string workaroundForBug9705;

	if ((GetControllerIndex() == 0) && (Controller.LiveFunc.GetAuthState() ~= "SIGNING_ON_SILENT"))
	{
		SignInAccountName = StrSigningIn;
		bIsGuest = false;
	}
	else
	{
		workaroundForBug9705 = Controller.LiveFunc.GetGamerTag(PagePlayerIndex);
		SignInAccountName = workaroundForBug9705;
		bIsGuest = Controller.LiveFunc.IsGuest(PagePlayerIndex);
	}
}

function bool HandleXControllerEvent(byte Id, eXControllerCodes iCode)
{
	if (GetControllerIndex() != Controller.ControllerId) return false;

	if (ActiveMenu != None)
	{
		// eat a,b,start,back if the help button isn't active
		switch(iCode)
		{
		case XC_A:
		case XC_Start:
			if (!hbtnA.bVisible) return true;
			break;

		case XC_B:
		case XC_Back:
			if (!hbtnB.bVisible) return true;
			break;

		}

		return ActiveMenu.HandleXControllerEvent(Id, iCode);
	}

	return false;
}

function DoFullUpdate()
{
	if (ActiveMenu != None)
		ActiveMenu.FullUpdate();
}

function DrawChooser(Canvas C)
{
	if (ActiveMenu != None)
		ActiveMenu.DrawChooserPanel(C);
}

function SetReady(bool bReady)
{
	if (ActiveMenu != None)
		ActiveMenu.SetReady(bReady);
}

function bool CanOtherCancel()
{
	if (PagePlayerIndex == 0)
		return ChooserBase.CanCancel(1);
	else if (PagePlayerIndex == 1)
		return ChooserBase.CanCancel(0);

	return false;
}

function bool IsOtherReady()
{
	if (PagePlayerIndex == 0)
		return ChooserBase.IsReady(1);
	else if (PagePlayerIndex == 1)
		return ChooserBase.IsReady(0);

	return false;
}

function ChooseNewProfile();

function HideAll()
{
	PressStartChooser.Hide();
	ProfileSelect.Hide();
	AccountChooser.Hide();
	MPViewMenu.Hide();
	LiveViewMenu.Hide();
	LiveOnlyMenu.Hide();
}

function Tick()
{
	RefreshSignIn();

	if (ActiveMenu != None)
		ActiveMenu.Tick();
}

function ShowPanel(gbx_ProfileChooserSubMenu panel)
{
	HideAll();

	ActiveMenu = panel;
	panel.Show();
}

function SetupAButton(optional string newCap, optional string newHint) { class'gbx_ScreenABXY'.Static.SetupHelpButton(hBtnA, newCap, newHint); }
function SetupBButton(optional string newCap, optional string newHint) { class'gbx_ScreenABXY'.Static.SetupHelpButton(hBtnB, newCap, newHint); }

function ScreenClosed(bool bCancelled)
{
	if (ActiveMenu != None)
		ActiveMenu.ScreenClosed(bCancelled);
}


// these are called by the submenus to move the process along
function StateNext();
function StateBack();

function string GetProfileName()
{
	return class'gbx_ProfileManager'.Static.GetProfileForController(self, PagePlayerIndex);
}

function SetProfile(string ProfileName)
{
	class'gbx_ProfileManager'.Static.SetProfileForController(self, PagePlayerIndex, ProfileName);
}

function bool HasProfile()
{
	return GetProfileName() != "";
}

function bool TestReady()
{
	if (ActiveMenu != None)
		return ActiveMenu.TestReady();

	return bReady;
}

function DoneSignOut(optional Bool bCancelled);
// =======================================================================================================================================================
// =======================================================================================================================================================
// state logic
// =======================================================================================================================================================
// =======================================================================================================================================================

// =======================================================================================================================================================
// state Init
// =======================================================================================================================================================
state Init
{
	function BeginState()
	{
		bReady = false;
		bCancel = false;
		bInitializing = true;

		HideAll();

		GotoState('PressStart');

		bAllowSkipStartState = false;
		bInitializing = false;
	}
}

state CommonBase
{/*
	function Tick()
	{
		if (!Controller.LiveFunc.IsControllerConnected(GetControllerIndex()))
		{
			GotoState('Init');
		}

		Global.Tick();
	}*/
}

state PressStart
{
	function BeginState()
	{
		local int controllerIndex;
		local gbx_LiveDlgSignOut dlg;
		Super.BeginState();

		// if we are allowed to skip, jump if we are connected and have a profile
		if (!bAllowSkipStartState || (Controller.bHandledInput && !Controller.LiveFunc.IsControllerConnected(GetControllerIndex())) || !HasProfile())
		{
			controllerIndex = GetControllerIndex();

			if (!bInitializing)
			{
				// 2P signs out at this point
				if ((PagePlayerIndex == 1) && Controller.LiveFunc.IsSignedIn(PagePlayerIndex))
				{
					ChooserBase.SetReady(0, false);

					dlg = class'gbx_LiveDlgSignOut'.static.PromptSignOut(Controller, PagePlayerIndex);
					dlg.OnClose = DoneSignOut;
					return;
				}

				// reset in-use state for this controller
				if (controllerIndex != -1)
				{
					GUILog("resetting inuse for controller="$controllerIndex);
					Controller.ControllerIdInUse[controllerIndex] = 0;
				}
			}

			// both panels unbind their controller
			Controller.BindPlayerToController(PagePlayerIndex, -1);

			bCancel = true;
			ShowPanel(PressStartChooser);
		}
		else
		{
			StateNext();
		}
	}

	function DoneSignOut(optional Bool bCancelled)
	{
		local int controllerIndex;

		GUILog("DONE SIGNING OUT PLAYER");
		if (!gbx_LiveDlgSignOut(Controller.ActivePage).bSignedOut)
		{
			StateNext();
		}
		else
		{
			controllerIndex = GetControllerIndex();

			// reset in-use state for this controller
			if (controllerIndex != -1)
			{
				GUILog("resetting inuse for controller="$controllerIndex);
				Controller.ControllerIdInUse[controllerIndex] = 0;
			}

			// both panels unbind their controller
			Controller.BindPlayerToController(PagePlayerIndex, -1);

			bCancel = true;
			ShowPanel(PressStartChooser);
		}
	}

	function bool HandleXControllerEvent(byte Id, eXControllerCodes iCode)
	{
		if ((GetControllerIndex() == -1) && (Controller.FindPlayerForControllerIndex(Id) == -1))
		{
			switch(iCode)
			{
			case XC_A:
			case XC_Start:
				GUILog("PressStart::HandleXControllerEvent: Binding to player " $PagePlayerIndex);
				Controller.BindPlayerToController(PagePlayerIndex, Id);
				RefreshSignIn();

				StateNext();
				return true;

			case XC_B:
			case XC_Back:
				if (CanOtherCancel())
				{
					StateBack();
					return true;
				}

				return false;
			}
		}

		return Global.HandleXControllerEvent(Id, iCode);
	}

	function EndState()
	{
		bReady = false;
		bCancel = false;
	}

	function StateBack()
	{
		bCancel = true;
	}

	function StateNext()
	{
		GotoState('PickProfile');
	}
}

// user is forced to pick a profile or go back to start
state PickProfile extends CommonBase
{
	function BeginState()
	{
		Super.BeginState();

		if (HasProfile())
		{
			StateNext();
		}
		else
		{
			ShowPanel(ProfileSelect);
		}
	}

	function StateBack()
	{
		SetProfile("");
		GotoState('PressStart');
	}

	function StateNext()
	{
		GotoState('MPView');
	}
}

// user wants to change their profile
state ChangeProfile extends CommonBase
{
	function BeginState()
	{
		Super.BeginState();
		ShowPanel(ProfileSelect);
	}

	function StateBack()
	{
		GotoState('MPView');
	}

	function StateNext()
	{
		GotoState('MPView');
	}
}

state ChangeSignIn extends CommonBase
{
	function BeginState()
	{
		bSignInShouldAutoExit = !Controller.LiveFunc.IsSignedIn(PagePlayerIndex) || (Controller.LiveFunc.GetAuthState() ~= "SIGNING_ON_SILENT");
		ShowPanel(AccountChooser);
	}

	function EndState()
	{
		bSignInReturnToMPView = false;
	}

	function StateNext()
	{
		GotoState('LiveView');
	}

	function StateBack()
	{
		if (bSignInReturnToMPView || !Controller.LiveFunc.IsSignedIn(PagePlayerIndex))
		{
			if (ChooserBase.LiveOnlyMode)
			{
				GotoState('PressStart');
			}
			else
			{
				GotoState('MPView');
			}
		}
		else
		{
			GotoState('LiveView');
		}
	}

	function Tick()
	{
		Super.Tick();

		if (bSignInShouldAutoExit && Controller.LiveFunc.IsSignedIn(PagePlayerIndex))
		{
			ChooserBase.FullUpdate();
			StateNext();
		}
	}
}

// displays the "MULTIPLAYER VIEW" menu choices
state MPView extends CommonBase
{
	function BeginState()
	{
		Super.BeginState();

		if (ChooserBase.LiveOnlyMode)
		{
			GotoState('LiveOnlyView');
		}
		else
		{
			// show the MP view panel
			ShowPanel(MPViewMenu);
		}
	}

	function EndState()
	{
		bReady = false;
		bCancel = false;
	}
}

// displays the "LIVE VIEW" menu choices
state LiveView extends CommonBase
{
	function BeginState()
	{
		Super.BeginState();

		if (ChooserBase.LiveOnlyMode)
		{
			GotoState('LiveOnlyView');
		}
		else
		{
			if (Controller.LiveFunc.IsSignedIn(PagePlayerIndex))
			{
				// show the Live view panel
				ShowPanel(LiveViewMenu);
			}
			else
			{
				bSignInReturnToMPView = true;
				GotoState('ChangeSignIn');
			}
		}
	}

	function StateBack()
	{
		GotoState('MPView');
	}
}


// displays the "LIVE VIEW" menu choices
state LiveOnlyView extends CommonBase
{
	function BeginState()
	{
		Super.BeginState();

		if (bNoForceSignIn || Controller.LiveFunc.IsSignedIn(PagePlayerIndex))
		{
			// show the Live view panel
			ShowPanel(LiveOnlyMenu);
			bNoForceSignIn = false;
		}
		else
		{
			bSignInReturnToMPView = true;
			GotoState('ChangeSignIn');
		}
	}

	function StateBack()
	{
		GotoState('PressStart');
	}
}

function bool TestLinkLiveLoss(optional bool bOpened)
{
	local bool oldSignIn;

	if (GetControllerIndex() == -1)
		bSignInLastTest = false;

	if (ActiveMenu.bRequireLive)
	{
		oldSignIn = bSignInLastTest;
		bSignInLastTest = Controller.LiveFunc.IsSignedIn(PagePlayerIndex);
		return oldSignIn && !bSignInLastTest;
	}
	else if (bSignInLastTest)
	{
		if (!Controller.LiveFunc.IsSignedIn(PagePlayerIndex))
			bSignInLastTest = false;
	}

	return false;
}

defaultproperties
{
	Begin Object Class=gbx_ProfileChooserPressStart Name=cPM_PressStart
	End Object
	PressStartChooser=cPM_PressStart

	Begin Object Class=gbx_ProfileSelect Name=cPM_ProfileSelect
	End Object
	ProfileSelect=cPM_ProfileSelect
	
	Begin Object Class=gbx_ProfileChooser_LiveSignIn Name=cPC_AcctChooser
	End Object
	AccountChooser=cPC_AcctChooser

	Begin Object Class=gbx_ProfileChooserNewMenuLiveOnly Name=cPCLiveOnly
	End Object
	LiveOnlyMenu=cPCLiveOnly

	Begin Object Class=GUIHelpAButton Name=cMP_hbtnA
		WinLeft=0.0
		WinTop=0.820000
		Layout=IBL_ICON_TOP
		Align=TXTA_Center
		bScaleToParent=false
		bBoundToParent=false
	End Object
	hbtnA=cMP_hbtnA
	hbtnALeft(0)=0.0375
	hbtnALeft(1)=0.5

	Begin Object Class=GUIHelpBButton Name=cMP_hbtnB
		WinLeft=0.5
		WinTop=0.820000
		Layout=IBL_ICON_TOP
		Align=TXTA_Center
		bScaleToParent=false
		bBoundToParent=false
	End Object
	hbtnB=cMP_hbtnB
	hbtnBLeft(0)=0.26875
	hbtnBLeft(1)=0.73125


	WinWidth=0.5000
	WinHeight=1.00000
	WinTop=0.00000

	SignInAccountName=""

	StrSigningIn="Signing In..."
	StrSignIn="Sign-In"
	StrSignOut="Sign-Out"
}

class gbx_ProfileChooserNewMenuLiveOnly extends gbx_ProfileChooserMenuBase;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	// don't need friends list here
	MyComponents[2].Hide();
	DoComponentLayout();
}

function SetMenuButtonEnabled(int index, bool bEnable)
{
	if (bEnable)
	{
		switch(index)
		{
		case 2:	// bah, no friends list here.  complicates things dramatically
			bEnable = false;
			break;

		case 3: // second player can use this freely.  first player can only re-sign-in with the same account
			bEnable = (MyChooserRoot.PagePlayerIndex != 0) || (MyChooserRoot.SignInAccountName == "");
			break;

		case 0:
		case 4:	// can sign out if we're signed in
			bEnable = MyChooserRoot.SignInAccountName != "";
			break;
		}
	}

	Super.SetMenuButtonEnabled(index, bEnable);
}

function bool MenuButtonActivated(GUIComponent which, int buttonIndex)
{
	if (!Super.MenuButtonActivated(which, buttonIndex)) return false;

	switch(buttonIndex)
	{
	case 1: MyChooserRoot.GotoState('ChangeProfile'); break;
	case 2: class'gbx_LiveFriendsList'.static.LaunchFriendsList(Controller, MyChooserRoot.PagePlayerIndex, true); break;

	case 3:
		MyChooserRoot.GotoState('ChangeSignIn');
		break;

	case 4: 
		class'gbx_LiveDlgSignOut'.static.PromptSignOut(Controller, MyChooserRoot.PagePlayerIndex);
		break;
	}

	return true;
}

function ScreenClosed(bool bCancelled)
{
	gbx_LiveDlgAcceptCrossTitle(MyChooserRoot.ChooserBase.ParentPage).bContinueJoin = !bCancelled;
	if (!bCancelled)
		Controller.CloseMenu(false);
}

function Tick()
{
	Super.Tick();

	if (!Controller.LiveFunc.IsSignedIn(MyChooserRoot.PagePlayerIndex) && MyChooserRoot.bReady)
		SetReady(false);
}

defaultproperties
{
	MyComponents(0)=cChooserMenuButton
	MyComponents(1)=cChooserMenuButton
	MyComponents(2)=cChooserMenuButton
	MyComponents(3)=cChooserMenuButton
	MyComponents(4)=cChooserMenuButton

	MyCaptions(0)="Ready"
	MyCaptions(1)="Profile"
	MyCaptions(2)="Friends List"
	MyCaptions(3)="Change Sign-In"
	MyCaptions(4)="Sign-Out"

	IsReadyButton(0)=true
	IsReadyButton(1)=false
	IsReadyButton(2)=false
	IsReadyButton(3)=false
	IsReadyButton(4)=false

	StringPanelHeader="Xbox Live"

	bRequireLive=true
}

class gbx_ProfileChooserPressStart extends gbx_ProfileChooserSubMenu;

var Automated GUILabel							lblPressStart;

var localized string							strPressStart;
var localized string							strInsertController;

var bool										bControllerConnected;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	OnDrawPre = PressStartOnDraw;
}

function bool PressStartOnDraw(Canvas C)
{
//	C.SetDrawColor(13, 5, 8, 200);
//	lblPressStart.DrawComponentBackground(C);
	
	return false;
}

function SubMenuOnShow()
{
	MyChooserRoot.ChooserBase.CountConnectedControllers();
	Super.SubMenuOnShow();
}

function bool ControllerConnected()
{
	// if we're mapped and this controller is plugged in, we're good
	if ((MyChooserRoot.GetControllerIndex() != -1) && (Controller.LiveFunc.IsControllerConnected(MyChooserRoot.GetControllerIndex())))
		return true;

	// otherwise, we're good if we have enough controllers plugged in
	return (MyChooserRoot.ChooserBase.ConnectedControllerCount > MyChooserRoot.ChooserBase.UsedControllerCount);
}

function Tick()
{
	if (bShowing || (ControllerConnected() != bControllerConnected))
	{
		if (Controller.bHandledInput)
			bControllerConnected = ControllerConnected();
		else
			bControllerConnected = false;

		if (bControllerConnected)
			lblPressStart.SetCaption(strPressStart);
		else
			lblPressStart.SetCaption(strInsertController);

		SetupHelpButtons();
	}

	UpdateBackButton();

	Super.Tick();
}

function UpdateBackButton()
{
	if (bControllerConnected && (MyChooserRoot.PagePlayerIndex == 0))
	{
		if (bShowing)
			MyChooserRoot.SetupBButton();

		if (MyChooserRoot.CanOtherCancel() && !MyChooserRoot.hbtnB.bVisible)
			MyChooserRoot.SetupBButton(MyChooserRoot.ChooserBase.StringBack);
		else if (!MyChooserRoot.CanOtherCancel() && MyChooserRoot.hbtnB.bVisible)
			MyChooserRoot.SetupBButton();
	}
}

function SetupHelpButtons()
{
	if (bControllerConnected)
	{
		MyChooserRoot.SetupAButton();

		if (MyChooserRoot.PagePlayerIndex == 1)
		{
/*	TODO: do we want "leave" for P2?
			if (MyChooserRoot.HasProfile())
			{
				MyChooserRoot.SetupBButton(MyChooserRoot.ChooserBase.StringLeave);
			}
			else
*/
				MyChooserRoot.SetupBButton();
		}
		else
			UpdateBackButton();
	}
	else
	{
		MyChooserRoot.SetupAButton();
		MyChooserRoot.SetupBButton();
	}
}

function OnBButton()
{
/*	TODO: do we want "leave" for P2?
	if (MyChooserRoot.PagePlayerIndex == 1)
	{
		if (MyChooserRoot.HasProfile())
		{
			MyChooserRoot.SetProfile("");
			SetupHelpButtons();
			return;
		}
	}
*/
	Super.OnBButton();
}

defaultproperties
{
	strPressStart="Press START to Join"
	strInsertController="Connect Controller to Join"

	Begin Object Class=GUILabel Name=clblPressStart
		StyleName="LargeButton"
		DrawMenuState=2
		TextAlign=TXTA_Center
		TextAlignV=TXTA_Center
		WinWidth=0.8
		WinHeight=0.6
		WinLeft=0.10
		WinTop=0.2
		bNeverFocus=true
		bMultiLine=true
		pulseStyle=CPS_Slow
	End Object
	lblPressStart=clblPressStart
}

class gbx_ProfileChooserSubMenu extends GUIPanel;

var Automated GUILabel							lblHeader;

var gbx_ProfileChooserNewBase					MyChooserRoot;
var	float										PanelLeft[2];

var bool										bShowing;	// set in on show, cleared in tick
var bool										bRequireLive;

var localized string							strNotSignedIn;
var localized string							strNoProfile;
var localized string							strSignedInGuest;
var localized string							StringPanelHeader;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	MyChooserRoot = gbx_ProfileChooserNewBase(MyOwner);
	OnShow = SubMenuOnShow;

	WinLeft = PanelLeft[MyChooserRoot.PagePlayerIndex];
	lblHeader.SetCaption(StringPanelHeader);
}

function SetupHelpButtons();
function bool OnCursor(byte Id, eXControllerCodes iCode) {return false;}
function OnAButton()
{
	Controller.PlayClickSound(EClickSound.CS_Click);
	MyChooserRoot.StateNext();
}

function OnBButton()
{
	Controller.PlayClickSound(EClickSound.CS_Back);
	MyChooserRoot.StateBack();
}

function SubMenuOnShow()
{
	bShowing = true;

	Tick();
	SetupHelpButtons();

	bShowing = false;
}

function Tick()
{
}

function bool HandleXControllerEvent(byte Id, eXControllerCodes iCode)
{
	switch(iCode)
	{
	case XC_A:
	case XC_Start:
		OnAButton();
		return true;

	case XC_B:
	case XC_Back:
		OnBButton();
		return true;

	case XC_PadUp:
	case XC_PadDown:
	case XC_PadLeft:
	case XC_PadRight:
		return OnCursor(Id, iCode);
	}

	return false;
}

function bool TestReady()
{
	return MyChooserRoot.bReady;
}

function SetReady(bool bSetReady)
{	
	MyChooserRoot.bReady = bSetReady;
}

function ScreenClosed(bool bCancelled);
function FullUpdate();
function DrawChooserPanel(Canvas C);

defaultproperties
{
	WinWidth=0.925
	WinHeight=0.8
	WinTop=0.1
	WinLeft=0.2

	PanelLeft(0)=0.075
	PanelLeft(1)=0.0

	bScaleToParent=true
	bBoundToParent=true
	PropagateVisibility=false

	strNotSignedIn="Signed Out"
	strSignedInGuest="Guest"
	strNoProfile="No Profile"
	StringPanelHeader=""

	Begin Object Class=GUILabel Name=cAC_Header
		StyleName="MenuOptionCaption"
		DrawMenuState=2
		TextAlign=TXTA_Center
		bAcceptsInput=false
		bTabStop=false
		WinWidth=0.900000
		WinHeight=0.070000
		WinLeft=0.0500000
		WinTop=0.070000
	End Object
	lblHeader=cAC_Header
}

class gbx_ProfileChooser_LiveSignIn extends gbx_ProfileChooserSubMenu;

var Automated GUIListBox			AccountListBox;
var int								GuestAccountIndex;

var localized string				strGuest;
var localized string				strNewAccount;

var string							LastAccountList;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	AccountListBox.List.OnDrawItem	= DrawListItem;
	AccountListBox.List.SelectedImage = None;
}

function Tick()
{
	RefreshAccountList();
}

function SubMenuOnShow()
{
	Super.SubMenuOnShow();

	if (Controller.LiveFunc.GetAuthState() ~= "SIGNING_ON_SILENT")
	{
		Controller.OpenMenu("GUI.gbx_LiveEnterPasscode", "SILENT");
	}
	else if ((MyChooserRoot.PagePlayerIndex == 0) && (MyChooserRoot.ChooserBase.AutoSignInAccount != ""))
	{
		BeginSignIn( MyChooserRoot.ChooserBase.AutoSignInAccount );
		MyChooserRoot.bNoForceSignIn = true;
		MyChooserRoot.StateNext();
//		MyChooserRoot.ChooserBase.AutoSignInAccount = "";
	}
	else
	{
		RefreshAccountList();
	}
}

function FullUpdate()
{
	RefreshAccountList();
}

function DrawListItem(Canvas C, int Item, float X, float Y, float W, float H, bool bSelected)
{
	local eMenuState drawState;
	local int XL, YL;
	local string S;

	if (Item == -1)
		return;

	if( bSelected )
		drawState = MSAT_Focused;
	else
		drawState = MSAT_Blurry;

	S = AccountListBox.List.GetItemAtIndex(Item);
	AccountListBox.List.Style.DrawTextToFit( C, drawState, X, Y, W, H, TXTA_Center, S );
	AccountListBox.List.Style.TextSize( C, drawState, S, XL, YL );

	if (bSelected)
	{
		Y += YL-2;

		if (MyChooserRoot.PagePlayerIndex == 0)
		{
			W = X + 0.5*(W+XL);
			X = 0;
		}
		else
		{
			X = X + 0.5*(W-XL);
			W = C.ClipX - X;
		}

		class'GUI.gbx_ScreenABXY'.Static.DrawTheThinRedLine(Controller, C, X, Y, W);
	}
}

function int GuestLoginController()
{
	local int i;

	for (i=0; i<2; i++)
	{
		if (i == (MyChooserRoot.PagePlayerIndex)) continue;

		if (Controller.LiveFunc.IsSignedIn(i))
			return i;
	}

	return -1;
}

function RefreshAccountList()
{
	local string s, currentSelection, name;
	local int newFocusIndex;
	local bool bEnableGuest;

	s = ConsoleCommand( "XLIVE GETACCOUNTS" );

	// only enable guest if we have a known account to guest to
	bEnableGuest = (s != "") && (GuestLoginController() != -1);

	// don't early-out if the list is empty; still need to enable the new account item
	if ((s != "") && (s == LastAccountList))
	{
		// account list the same, see if guest login changed
		if ((bEnableGuest && (GuestAccountIndex != -1)) ||
			(!bEnableGuest && (GuestAccountIndex == -1)))
		{
			return;
		}
	}

	LastAccountList = s;
	GuestAccountIndex = -1;

	// remember our last selection and clear
	currentSelection = AccountListBox.List.GetExtra();
	AccountListBox.List.Clear();

	// set up the new list
	newFocusIndex = 0;
    name = ParseToken(s);
    while( name != "" )
    {
		AccountListBox.List.Add(name,,name);

		if (CurrentSelection == name)
		{
			newFocusIndex = AccountListBox.List.ItemCount-1;
		}

        name = ParseToken(s);
    }

	// add the guest account
	if (bEnableGuest)
	{
		AccountListBox.List.Add(strGuest,,"GuestAccount");
		GuestAccountIndex = AccountListBox.List.ItemCount-1;

		if (CurrentSelection == "GuestAccount")
			newFocusIndex = GuestAccountIndex;
	}

	// add the New Account item and select the old selection
	AccountListBox.List.Add(strNewAccount,,"NewAccount");
	if (CurrentSelection == "NewAccount")
		newFocusIndex = AccountListBox.List.ItemCount-1;

	// select the old item
	AccountListBox.List.SetIndex(newFocusIndex);
}

function BeginSignIn(string GamerTag, optional bool bIsGuest)
{
	local string S;

	// don't try to sign in with the same gamertag again.
	if (GamerTag ~= Controller.LiveFunc.GetGamerTag(MyChooserRoot.PagePlayerIndex))
	{
		MyChooserRoot.StateBack();
		return;
	}

	S = MyChooserRoot.PagePlayerIndex @ MakeQuotedString(GamerTag);
	if (bIsGuest)
		S = S @ "TRUE";
	else
		S = S @ "FALSE";

	MyChooserRoot.bSignInShouldAutoExit = true;

	if (Controller.LiveFunc.IsSignedIn( MyChooserRoot.PagePlayerIndex ))
	{
		class'gbx_LiveDlgSignOut'.static.PromptSignOut(Controller, MyChooserRoot.PagePlayerIndex, S);
	}
	else
	{
		Controller.OpenMenu("GUI.gbx_LiveEnterPasscode", S);
	}
}

function OnAButton()
{
	local int i;

	Controller.PlayClickSound(EClickSound.CS_Click);

	if (AccountListBox.List.Index == AccountListBox.List.ItemCount-1)
	{
		Controller.OpenMenu("GUI.gbx_LiveDashboardConfirm","XLD_LAUNCH_DASHBOARD_NEW_ACCOUNT_SIGNUP 1");
		Controller.ActivePage.PagePlayerIndex = MyChooserRoot.PagePlayerIndex;	// force the controller index for the dialog.
	}
	else if (AccountListBox.List.Index == GuestAccountIndex)
	{
		i = GuestLoginController();
		if (i != -1)
		{
			BeginSignIn( Controller.LiveFunc.GetGamerTag(i), true );
		}
	}
	else
	{
		BeginSignIn( AccountListBox.List.GetExtra(), Controller.LiveFunc.IsAccountSignedIn(AccountListBox.List.GetExtra()) );
	}
}

function bool OnCursor(byte Id, eXControllerCodes iCode)
{
	return AccountListBox.List.OnXControllerEvent(Id, iCode);
}

function SetupHelpButtons()
{
	MyChooserRoot.SetupAButton(MyChooserRoot.StrSignIn);
	MyChooserRoot.SetupBButton(MyChooserRoot.ChooserBase.StringCancel);
}


defaultproperties
{
	Begin Object class=GUIListBox Name=cAC_AcctList
		WinWidth=0.9
		WinHeight=0.4
		WinLeft=0.05
		WinTop=0.35
        bVisibleWhenEmpty=true
	End Object
	AccountListBox=cAC_AcctList

	StringPanelHeader="Select Account"
	strGuest="Guest"
	strNewAccount="New Account"

	bRequireLive=true
}

class gbx_ProfileDisplay extends GUIPanel;

var Automated GUILabel						lblProfileName;
var Automated GUILabel						lblControls;
var Automated GUILabel						lblProfileBad;
var Automated GUIImage						imgProfilePic;
var Automated GUIImage						imgProfileBad;
var Automated array<GUIImage>				imgLevelProgression;

var bool									bDisplayNewProfile;
var bool									bDamaged;
var bool									bNoName;

var Manifest								savedGameManifest;
var Manifest.ManifestEntry					profileManifestEntry;

const MEDAL_Count = 5;
var GUIFRect								MedalIconPositions[MEDAL_Count];

var string									styCompletionCaptionName;
var GUIStyles								styCompletionCaption;

var localized string						StringDamagedProfile;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	savedGameManifest = PlayerOwner().Level.SaveGameGetManifest();

	styCompletionCaption = Controller.GetStyle(styCompletionCaptionName);
	
	OnDraw = ProfileOnDraw;
	imgProfilePic.Image = Controller.GUITexturePool.AllocRenderMaterial();

	if (bNoName)
		lblProfileName.Hide();
}

event Free()
{
	Controller.GUITexturePool.FreeRenderMaterial(imgProfilePic.Image);
	Super.Free();
}

function SetFromProfile(string ProfileName, optional bool bIsNewProfile)
{
	lblProfileName.SetCaption( ProfileName );

	bDisplayNewProfile = bIsNewProfile;
	bDamaged = false;

	if (!bDisplayNewProfile)
	{
		bDamaged = !class'Engine.GameProfile'.Static.VerifyProfile(PlayerOwner().Level, ProfileName);
		bDisplayNewProfile = bDamaged || !savedGameManifest.GetManifestEntry(profileManifestEntry, ProfileName);
	}

	if (bDamaged)
	{
		imgProfileBad.ImageColor.A = default.imgProfileBad.ImageColor.A;
		lblProfileBad.SetCaption(StringDamagedProfile);
	}
	else
	{
		imgProfileBad.ImageColor.A = 0;
		lblProfileBad.SetCaption("");
	}

	if (!bDisplayNewProfile)
	{
		Controller.GUITexturePool.GetTexture(imgProfilePic.Image, PlayerOwner().Level.MissionManager.GetMissionImage( PlayerOwner().Level.MissionManager.GetContinueMissionIndex(profileManifestEntry.LastMissionCompleted, true) ));

		// setup the config, invert status
		//lblControls.SetCaption("SomeConfig, Inverted");
		lblControls.Show();
	}
	else
	{
		Controller.GUITexturePool.GetTexture(imgProfilePic.Image, PlayerOwner().Level.MissionManager.GetMissionImage(0));
	}
}

function DrawMedalIcons(Canvas C, GUIFRect rect, Canvas.CanvasIcon medal, Canvas.CanvasIcon back, optional string strCaption)
{
	local int XL, YL;

	C.Style = EMenuRenderStyle.MSTY_Alpha;

	if (back.Icon != None)
	{
		C.DrawColor = back.DrawColor;
		C.SetPos(HorizontalOffset(rect.fL), VerticalOffset(rect.fT));
		C.DrawTile(back.Icon, rect.fW*ActualWidth(), rect.fH*ActualHeight(),
					back.U, back.V, back.UL, back.VL );
	}

	if (medal.Icon != None)
	{
		C.DrawColor = medal.DrawColor;
		C.SetPos(HorizontalOffset(rect.fL), VerticalOffset(rect.fT));
		C.DrawTile(medal.Icon, rect.fW*ActualWidth(), rect.fH*ActualHeight(),
					medal.U, medal.V, medal.UL, medal.VL );
	}

	if (strCaption != "")
	{
		styCompletionCaption.TextSize(C, EMenuState.MSAT_Focused, strCaption, XL, YL);
		styCompletionCaption.DrawText(	C, EMenuState.MSAT_Focused,
										HorizontalOffset(rect.fL), VerticalOffset(rect.fT) - YL, rect.fW*ActualWidth(), YL,
										TXTA_Center, strCaption);
	}
}

function bool ProfileOnDraw(Canvas C)
{
	local int missionCount;
	missionCount = PlayerOwner().Level.MissionManager.Missions.Length;

	if (!bDisplayNewProfile)
	{
		if (profileManifestEntry.bCompleted[0] != 0)
			DrawMedalIcons(C, MedalIconPositions[0], class'gbx_ScreenTimeline'.Default.MedalIcons[0], class'gbx_ScreenTimeline'.Default.MedalBracketIcons[0], String(profileManifestEntry.bCompleted[0] - profileManifestEntry.bCompletedFilm[0]));
		else
			DrawMedalIcons(C, MedalIconPositions[0], class'gbx_ScreenTimeline'.Default.nilIcon, class'gbx_ScreenTimeline'.Default.MedalBracketIcons[0]);

		if (profileManifestEntry.bCompleted[1] != 0)
			DrawMedalIcons(C, MedalIconPositions[1], class'gbx_ScreenTimeline'.Default.MedalIcons[1], class'gbx_ScreenTimeline'.Default.MedalBracketIcons[0], String(profileManifestEntry.bCompleted[1] - profileManifestEntry.bCompletedFilm[1]));
		else
			DrawMedalIcons(C, MedalIconPositions[1], class'gbx_ScreenTimeline'.Default.nilIcon, class'gbx_ScreenTimeline'.Default.MedalBracketIcons[0]);

		if (profileManifestEntry.bCompleted[2] != 0)
			DrawMedalIcons(C, MedalIconPositions[2], class'gbx_ScreenTimeline'.Default.MedalIcons[2], class'gbx_ScreenTimeline'.Default.MedalBracketIcons[0], String(profileManifestEntry.bCompleted[2] - profileManifestEntry.bCompletedFilm[2]));
		else
			DrawMedalIcons(C, MedalIconPositions[2], class'gbx_ScreenTimeline'.Default.nilIcon, class'gbx_ScreenTimeline'.Default.MedalBracketIcons[0]);

		if (profileManifestEntry.bCompleted[3] != 0)
			DrawMedalIcons(C, MedalIconPositions[3], class'gbx_ScreenTimeline'.Default.MedalIcons[3], class'gbx_ScreenTimeline'.Default.MedalBracketIcons[0], String(profileManifestEntry.bCompleted[3] - profileManifestEntry.bCompletedFilm[3]));
		else
			DrawMedalIcons(C, MedalIconPositions[3], class'gbx_ScreenTimeline'.Default.nilIcon, class'gbx_ScreenTimeline'.Default.MedalBracketIcons[0]);

		if ((profileManifestEntry.bCompleted[0] == missionCount) && (profileManifestEntry.bCompleted[1] == missionCount) && (profileManifestEntry.bCompleted[2] == missionCount))
		{
			if (profileManifestEntry.bCompleted[3] == missionCount)
				DrawMedalIcons(C, MedalIconPositions[4], class'gbx_ScreenTimeline'.Default.MedalIcons[4], class'gbx_ScreenTimeline'.Default.MedalBracketIcons[1]);
			else
				DrawMedalIcons(C, MedalIconPositions[4], class'gbx_ScreenTimeline'.Default.nilIcon, class'gbx_ScreenTimeline'.Default.MedalBracketIcons[1]);
		}
	}

	return false;
}

defaultproperties
{
	StyleName="SquareBar"
	WinWidth=0.9
	WinLeft=0.05
	WinHeight=0.60

	Begin Object Class=GUILabel Name=cimgProfileName
		StyleName="MenuOptionLabel"
		DrawMenuState=1
		TextAlign=TXTA_Center
		bAcceptsInput=false;
		bTabStop=false
		bDrawToFit=true
		WinWidth=1.00000
		WinHeight=0.1000
		WinLeft=0.00000
		WinTop=0.010000
	End Object
	lblProfileName=cimgProfileName

	Begin Object Class=GUIImage Name=cimgProfilePic
		ImageColor=(R=255,G=255,B=255,A=255)
		ImageStyle=ISTY_Scaled
		WinWidth=0.9500000
		WinHeight=0.65000
		WinLeft=0.025000
		WinTop=0.100000
	End Object
	imgProfilePic=cimgProfilePic

	Begin Object Class=GUIImage Name=cimgProfileBad
		Image=Material't_interface_mb.HUD.dead_x'
		ImageColor=(R=255,G=255,B=255,A=80)
		ImageStyle=ISTY_Scaled
		WinWidth=0.900000
		WinHeight=0.6000
		WinLeft=0.05000
		WinTop=0.1250000
		RenderWeight=0.5
	End Object
	imgProfileBad=cimgProfileBad
	Begin Object Class=GUILabel Name=clblProfileBad
		StyleName="MenuOptionCaption"
		TextAlign=TXTA_Right
		DrawMenuState=0
		TextColor=(R=128,G=20,B=20,A=255)
		bUseTextColorForStyle=true
		bTransparent=true
		bAcceptsInput=false
		bTabStop=false
		WinWidth=0.700000
		WinHeight=0.12000
		WinLeft=0.2250000
		WinTop=0.10000
	End Object
	lblProfileBad=clblProfileBad

	Begin Object Class=GUILabel Name=clblControls
		StyleName="TextLabel"
		DrawMenuState=0
		TextAlign=TXTA_Left
		bAcceptsInput=false;
		bTabStop=false
		WinWidth=0.900000
		WinHeight=0.10000
		WinLeft=0.050000
		WinTop=0.900000
	End Object
	lblControls=clblControls

	// 28x50 - 32, 45x66
	MedalIconPositions(0)=(fL=0.82875,fT=0.5145833,fW=0.095,fH=0.1875)
	MedalIconPositions(1)=(fL=0.72875,fT=0.5145833,fW=0.095,fH=0.1875)
	MedalIconPositions(2)=(fL=0.62875,fT=0.5145833,fW=0.095,fH=0.1875)
	MedalIconPositions(3)=(fL=0.52875,fT=0.5145833,fW=0.095,fH=0.1875)
	MedalIconPositions(4)=(fL=0.085,fT=0.4545833,fW=0.140625,fH=0.2475)

	styCompletionCaptionName="TextLabel"
	StringDamagedProfile="DAMAGED"
	bNoName=false
}
class gbx_ProfileManager extends gbx_ScreenABXY;

var Automated gbx_ProfileDisplay			CurrentProfileDisplay;

var Automated GUIListBox					ProfileListBox;
var Automated GUILabel						lblHeader;
var Automated GUILabel						lblNoProfiles;

var int										WorkingPlayerIndex;		// player index we're editing (usually 0)
var bool									bRequireChooseProfile;	// disable 'back' if true
var bool									bCloseAfterLoading;		// we double clicked so close the ui after the profile loads.
var string									InitialProfileName;
var string									CreateProfileName;
var name									DefCameraView;			// tracks the current known camera view so we can avoid multiple switches.

var localized string						StringCaptionNoProfiles;
var localized string						StringSelectProfile;
var localized string						StringCurrentProfile;
var localized string						StringDeletePrompt;
var localized string						StringCreatePrompt;
var localized string						StringCreateError;
var localized string						StringMustCreateError;
var localized string						StringCreateErrorInvalid;
var localized string						StringCreateErrorInUse;
var localized string						StringCreateErrorEmpty;
var localized string						StringFriendlyPrompt;
var localized string						StringLoadingProfileData;
var localized string						StringCreatingProfile;

var localized string						DefaultProfileName;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	OnOpen = ProfileManagerOpen;
	OnAButtonEvent = OnChooseProfile;
	OnBButtonEvent = OnDone;
	OnYButtonEvent = OnCreateProfile;
	OnXButtonEvent = OnDeleteProfile;

	ProfileListBox.List.OnDrawItem	= DrawListItem;
	ProfileListBox.List.SelectedImage = None;
	ProfileListBox.List.OnListItemDblClick = ProfileListItemOnDblClick;
	ProfileListBox.OnChange = ProfileListOnChange;

	bRequireChooseProfile = false;
	bCloseAfterLoading = false;
	lblNoProfiles.SetCaption(StringCaptionNoProfiles);
}

event HandleParameters(string Param1, string Param2)
{
	Super.HandleParameters(Param1, Param2);

	if (Param1 != "")
	{
		// TODO PLAYER INDEX
		WorkingPlayerIndex = int(Param1);
	}

	InitialProfileName = GetProfileForController(self, WorkingPlayerIndex);
	RefreshProfileList();

	GUILog("Opened profile manager for Player=" $WorkingPlayerIndex);
}

function ProfileManagerOpen()
{
	RefreshProfileList();
}

function RefreshProfileList(optional string newSelection)
{
	local int i, newIndex;
	local array<string> list;

	// force controller 0 to pick a profile if it doesn't exist or is bad
	if (WorkingPlayerIndex == 0)
	{
		bRequireChooseProfile = !ControllerProfileExists(self, WorkingPlayerIndex) || 
								!class'Engine.GameProfile'.Static.VerifyProfile(PlayerOwner().Level, GetProfileForController(self, WorkingPlayerIndex));
	}

	// remember old selection
	newIndex = 0;
	if (newSelection == "")
		newSelection = ProfileListBox.List.SelectedText();

	ProfileListBox.List.Clear();

	GetProfileList(self, list);
	for (i=0; i<list.Length; i++)
	{
		if (list[i] ~= newSelection)
			newIndex = i;

		ProfileListBox.List.Add(list[i]);
	}

	// show/hide stuff if the list is empty/not
	if (ProfileListBox.ItemCount() == 0)
	{
		bRequireChooseProfile = true;

		ProfileListBox.Hide();
		CurrentProfileDisplay.Hide();
		lblNoProfiles.Show();
		lblHeader.Hide();

		SetupAButton();
		SetupXButton();
	}
	else
	{
		ProfileListBox.List.SetIndex(newIndex);
		ProfileListBox.List.SetTopItem(newIndex);

		ProfileListBox.Show();
		CurrentProfileDisplay.Show();
		lblNoProfiles.Hide();
		lblHeader.Show();

		SetupAButton(Default.ACaption);
		if (WorkingPlayerIndex != 0)
		{
			if (GetProfileForController(self, WorkingPlayerIndex) != "")
				SetupXButton(stringLeave);
			else
				SetupXButton();
		}
		else
		{
			SetupXButton(Default.XCaption);
		}
	}

	// disable B button if we can't go back
	// also set the header
	if (bRequireChooseProfile)
	{
		SetupBButton();
		lblHeader.SetCaption( StringSelectProfile );
	}
	else
	{
		SetupBButton(StringBack);
		lblHeader.SetCaption( StringCurrentProfile $ GetProfileForController(self, WorkingPlayerIndex) );
	}
}

function ProfileListOnChange(GUIComponent Sender)
{
	local string S;

	S = ProfileListBox.List.SelectedText();
	if (S != "")
		CurrentProfileDisplay.SetFromProfile( ProfileListBox.List.SelectedText() );
}

function DrawListItem(Canvas C, int Item, float X, float Y, float W, float H, bool bSelected)
{
	local eMenuState drawState;
	local int XL, YL;
	local string S;

	if (Item == -1)
		return;

	if( bSelected )
		drawState = MSAT_Focused;
	else
		drawState = MSAT_Blurry;

	S = ProfileListBox.List.GetItemAtIndex(Item);
	ProfileListBox.List.Style.DrawTextToFit( C, drawState, X, Y, W-2, H, TXTA_Center, S );
	ProfileListBox.List.Style.TextSize( C, drawState, S, XL, YL );

	if (bSelected)
	{
		Y += YL-2;
		W = X + 0.5*(W+XL);
		X = 0;
		class'GUI.gbx_ScreenABXY'.Static.DrawTheThinRedLine(Controller, C, X, Y, W);
	}
}

function bool DeleteProfileAnswer(string answer)
{
	local bool bIsCurrent;

	if (answer ~= "YES")
	{
		bIsCurrent = ProfileListBox.List.SelectedText() == GetProfileForController(self, WorkingPlayerIndex);
		DeleteProfile( self, ProfileListBox.List.SelectedText(), bIsCurrent );

		if (bIsCurrent)
			bRequireChooseProfile = true;
	}

	return true;
}

function bool Work_LoadingProfile()
{
	local string S;
	S = ProfileListBox.List.SelectedText();
/*
	if (WorkingPlayerIndex == 0)
	{
		if ((S != "") && (S != InitialProfileName))
		{
			class'Engine.GameProfile'.Static.ProfileCheckpoints(PlayerOwner().Level, "LOAD", S);
		}
	}
*/
	return true;
}

function Work_LoadingDone(optional Bool bCancelled)
{
	GUILog("Work_LoadingDone:: sel=" $ ProfileListBox.List.SelectedText() $ " index=" $ WorkingPlayerIndex);
	SetProfileForController( self, WorkingPlayerIndex, ProfileListBox.List.SelectedText() );
	RefreshProfileList();

	// always close after we load.
	Controller.CloseMenu(false);
}

function OnDone()
{
	BaseOnBButton();
}

function ProfileListItemOnDblClick(GUIComponent Sender, int Item)
{
	ProfileListBox.List.SetIndex(Item);

	if (hbtnA.bVisible)
	{
		bCloseAfterLoading = true;
		OnChooseProfile();
	}
}

function OnChooseProfile()
{
	local gbx_ScreenExtendedWork dlg;

	Controller.PlayClickSound(EClickSound.CS_Click);

	GUILog("OnChooseProfile:: sel=" $ ProfileListBox.List.SelectedText() $ " current=" $ GetProfileForController(self, WorkingPlayerIndex));

	// verify the profile first!
	if (!class'gbx_DlgCorruptContent'.Static.VerifyProfile(self, ProfileListBox.List.SelectedText()))
		return;

	if (ProfileListBox.List.SelectedText() != GetProfileForController(self, WorkingPlayerIndex))
	{
		dlg = LaunchWorkDialog(Controller, StringLoadingProfileData,, 1.0);
		dlg.DoWork = Work_LoadingProfile;
		dlg.OnClose = Work_LoadingDone;
	}
	else
	{
		Controller.CloseMenu(false);
	}
}

function OnDeleteProfile()
{
	local string S;
	local gbx_ScreenQuestion result;

	Controller.PlayClickSound(EClickSound.CS_Click);

	if (WorkingPlayerIndex != 0)
	{
		SetProfileForController(self, WorkingPlayerIndex, "");

		RefreshProfileList();
	}
	else
	{
		S = StringDeletePrompt;
		ReplaceText( S, "<PROFILE>", ProfileListBox.List.SelectedText() );
		result = LaunchQuestionDialog(Controller, S, "YESNO NONE");
		result.OnAnswer = DeleteProfileAnswer;
	}
}

function OnCreateProfile()
{
	local gbx_ScreenTextEntry dlg;

	Controller.PlayClickSound(EClickSound.CS_Click);

	if (class'gbx_DlgLowStorage'.static.VerifyProfileSpace(self))
	{
		dlg = PromptNewProfile(self);
		dlg.EntryFinished = ProfileNameDone;
	}
}

function ProfileNameDone(string currentString, bool bCancelled)
{
	local gbx_ScreenExtendedWork dlg;

	GUILog("ProfileNameDone " $currentString);

	if (!bCancelled)
	{
		CreateProfileName = currentString;
		dlg = LaunchWorkDialog(Controller, StringCreatingProfile,, 1.0);
		dlg.DoWork = Work_CreatingProfile;
	}
}

function bool Work_CreatingProfile()
{
	if (CreateNewProfile(self, CreateProfileName, true))
		SetProfileForController(self, WorkingPlayerIndex, CreateProfileName);

	RefreshProfileList(CreateProfileName);
	CreateProfileName = "";

	return true;
}

// =======================================================================================================================================================
// Utility functions for working with profiles
// =======================================================================================================================================================
static function int GetProfileList(GUIComponent me, out array<string> list)
{
	local string S, name;

	S = me.ConsoleCommand("LOADSAVE PROFILE LIST DEVICE=0 UNIQUE=0");

    name = ParseTokenDelimited(s);
    while( name != "" )
    {
		AddStringListItem(list, name);
		name = ParseTokenDelimited(s);
	}

	SortStringList(list);

	return list.Length;
}

static function bool CreateNewProfile(GUIComponent me, string ProfileName, optional bool bReplaceOnWarn)
{
	if (!class'Engine.GameProfile'.Static.CreatePlayerProfile(me.PlayerOwner().Level, ProfileName))
	{
		WarnCreateProfileFailed(me, ProfileName,,bReplaceOnWarn);
		return false;
	}

	return true;
}

static function WarnCreateProfileFailed(GUIComponent me, string ProfileName, optional bool bWarnMustCreate, optional bool bReplace)
{
	local string S;

	if (bWarnMustCreate)
		S = Default.StringMustCreateError;
	else if (ProfileName == "")
		S = Default.StringCreateErrorEmpty @ default.StringFriendlyPrompt;
	else if (!class'Engine.GameProfile'.Static.ProfileNameValid(me.PlayerOwner().Level, ProfileName))
		S = Default.StringCreateError $Default.StringCreateErrorInUse @ default.StringFriendlyPrompt;
	else
		S = Default.StringCreateError $Default.StringCreateErrorInvalid @ default.StringFriendlyPrompt;

	ReplaceText( S, "<PROFILE>", ProfileName );

	if (bReplace)
		me.controller.CloseMenu(false);

	LaunchQuestionDialog(me.Controller, S, "OK NONE");
}

static function DeleteProfile(GUIComponent me, string ProfileName, optional bool bDelCurrent)
{
	// if this profile is set up for 2P, clear it out
	if (GetProfileForController(me, 1) ~= ProfileName)
		SetProfileForController(me, 1, "");

	class'Engine.GameProfile'.Static.DeletePlayerProfile(me.PlayerOwner().Level, ProfileName, bDelCurrent);
}

static function string GetProfileForController(GUIComponent me, int index)
{
	local string result;

	//FIX-ME : CurrentProfiles is hard coded size 2 and this function is often called with index = 2 or 3
	if (index > 1)
		index = 1;

	if (index == 0)
	{
		result = me.PlayerOwner().ProfileName;
		if (result == "")
			result = me.PlayerOwner().GetDefaultURL("Name");
	}
	else
	{
		result = me.Controller.CurrentProfiles[index];
	}

	return result;
}

static function bool ControllerProfileExists(GUIComponent me, int index)
{
	return int( me.ConsoleCommand("LOADSAVE PROFILE INLIST NAME=\"" $GetProfileForController(me, index) $"\"") ) != 0;
}

static function bool LoadProfile(GUIComponent me, int index, string ProfileName)
{
	local string S;

	S = "LOADSAVE PROFILE LOAD DEVICE=0 NAME=" $me.MakeQuotedString(ProfileName);
	if (index != 0)
		S = S @ "GAMEPADINDEX=" $index;

	return bool( me.ConsoleCommand(S) );
}

// set up the camera view for the current profile
static function SetupCameraView(GUIComponent me)
{
	local name CameraView;
	if (me.PlayerOwner().Level.IsMenuMap())
	{
		if (class'gbx_ProfileManager'.Static.ControllerProfileExists(me, 0))
			CameraView = class'Engine.GameProfile'.Static.GetProfileCameraView(me.PlayerOwner().Level, GetProfileForController(me, 0));
		else
			CameraView = class'Engine.gbxMissionMan'.Static.GetCameraView(0);

		GUILog("Switching to camera view " $CameraView);

		if (CameraView != default.DefCameraView)
		{
			default.DefCameraView = CameraView;
			me.PlayerOwner().TriggerEvent( CameraView, me.PlayerOwner().Pawn, me.PlayerOwner().Pawn );
		}
	}
}

static function SetProfileForController(GUIComponent me, int index, string ProfileName, optional bool bNoChangeCameraView)
{
	if ((index == 0) && (ProfileName != ""))
	{
		LoadProfile(me, index, ProfileName);

		if (!bNoChangeCameraView)
			SetupCameraView(me);

		// TODO: warning if failure here
	}

	me.Controller.CurrentProfiles[index] = ProfileName;
}

static function bool TwoProfilesJoined(GUIComponent me)
{
	return ControllerProfileExists(me, 0) && ControllerProfileExists(me, 1);
}

static function SetupProfiles(GUIComponent me, optional bool liveOnly)
{
	local int viewport;

	// first controller is already enabled
	if (!me.Controller.bIsConsole)
		return;

	if ((me.Controller.CurrentProfiles[1] != "") && ( (liveOnly == false) ||
		( (liveOnly == true) && (me.Controller.LiveFunc.IsSignedIn(1) == true) ) ))
	{		
		viewport = 1;

		if ((liveOnly == true) && (me.Controller.LiveFunc.IsSignedIn(0) == false))
		{
			viewport = 0;
		}

		me.ConsoleCommand("XLIVE ADD_RELAUNCH" @viewport @"1" @me.Controller.GetControllerIndexForPlayer(1) @me.MakeQuotedString(me.Controller.CurrentProfiles[1]));
}
	else
	{
		me.ConsoleCommand("XLIVE CLEAR_RELAUNCH");
	}
}

static function gbx_ScreenTextEntry PromptNewProfile(GUIComponent me, optional string profileName)
{
	if (profileName == "")
		profileName = Default.DefaultProfileName;

	return me.Controller.LaunchTextEntry(Default.StringCreatePrompt, me.PlayerOwner().ConsoleCommand("LOADSAVE CHECK_NAME NAME=" $profileName),"PROFILE", 15);
}

defaultproperties
{
	PagePlayerIndex=-1
	WorkingPlayerIndex=0
	ScreenTitle="Profile Manager"

	ACaption="Select"
	XCaption="Delete"
	YCaption="Create"

	Begin Object Class=gbx_ProfileDisplay Name=cProfileDisplay
		WinTop=0.23
		WinWidth=0.40
		WinLeft=0.50
		WinHeight=0.53
	End Object
	CurrentProfileDisplay=cProfileDisplay

	Begin Object class=GUIListBox Name=cProfileList
		WinWidth=0.40
		WinHeight=0.53
		WinLeft=0.05
		WinTop=0.23
        bVisibleWhenEmpty=true
	End Object
	ProfileListBox=cProfileList

	Begin Object Class=GUILabel Name=clblProfileHeader
		StyleName="MenuOptionCaption"
		DrawMenuState=2
		TextAlign=TXTA_Left
		bAcceptsInput=false
		bTabStop=false
		WinWidth=0.900000
		WinHeight=0.050000
		WinLeft=0.05
		WinTop=0.1700000
	End Object
	lblHeader=clblProfileHeader

	Begin Object Class=GUILabel Name=clblNoProfiles
		StyleName="MenuOptionCaption"
		DrawMenuState=1
		TextAlign=TXTA_Center
		bAcceptsInput=false;
		bMultiLine=true
		bTabStop=false
		WinWidth=0.800000
		WinHeight=0.10000
		WinLeft=0.100000
		WinTop=0.500000
	End Object
	lblNoProfiles=clblNoProfiles

	StringCaptionNoProfiles="No Profiles Found..."
	StringCurrentProfile="Current Profile : "
	StringSelectProfile="Choose a Profile"
	StringDeletePrompt="You are about to delete player profile <PROFILE>.  All progress for this profile will be deleted.  Are you sure?"
	StringCreatePrompt="Enter a Profile Name"
	StringCreateError="Unable to create player profile <PROFILE>."
	StringCreateErrorInvalid="The profile name entered contains invalid characters."
	StringCreateErrorInUse="The profile name entered is already in use."
	StringCreateErrorEmpty="Player profile names may not be empty."
	StringFriendlyPrompt="Please enter another profile name."
	StringMustCreateError="You must create a new player profile before continuing."

	StringLoadingProfileData="Loading profile..."
	StringCreatingProfile="Creating profile..."

	DefaultProfileName="JoeHartsock"

}

class gbx_ProfileScreenBase extends gbx_ScreenABXY;
//	Abstract;

// param1 : SIGNIN | PROFILE
// param2 : auto-signin account

var automated 	gbx_ProfileChooserNew1P	ProfileChooser;
var automated 	gbx_ProfileChooserNew2P	ProfileChooser2;

var int	ConnectedControllerCount;
var int	UsedControllerCount;
var string AutoSignInAccount;
var bool LiveOnlyMode;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);
	OnXControllerEvent=PS_OnXControllerEvent;
	OnCanClose = PS_CanClose;
	OnOpen = PS_OnOpen;
	SetTimer(0.25f, true);
}

event HandleParameters(string Param1, string Param2)
{
//	local int iP1, i;
	Super.HandleParameters(Param1, Param2);

	if (Param1 == "SIGNIN")
	{
		AutoSignInAccount = Param2;
		LiveOnlyMode = AutoSignInAccount != "";

		ProfileChooser.SetMode(true);
		ProfileChooser2.SetMode(true);
	}
	else
	{
		ProfileChooser.SetMode(false);
		ProfileChooser2.SetMode(false);
	}
}

function PS_OnOpen()
{
	FullUpdate();
	Timer();
}

function bool PS_CanClose(optional Bool bCancelled)
{
	// handle this ourselves
	return false;
}

function bool ScreenOnDraw(Canvas C)
{
	C.DrawColor = Controller.BackgroundBoxColor;
	DrawBackground(C, HorizontalOffset(0.495), VerticalOffset(0.20), 0.01*ActualWidth(), 0.60*ActualHeight());

	ProfileChooser.DrawChooser(C);
	ProfileChooser2.DrawChooser(C);

	return Super.ScreenOnDraw(C);	// still do the other stuff
}


function bool PS_OnXControllerEvent(byte Id, eXControllerCodes iCode)
{
	if (ProfileChooser.HandleXControllerEvent(Id, iCode))
	{
		TestExitConditions();
		return true;
	}
	if (ProfileChooser2.HandleXControllerEvent(Id, iCode))
	{
		TestExitConditions();
		return true;
	}

	return true;
}

function CountConnectedControllers()
{
	local int i;

	ConnectedControllerCount = 0;
	UsedControllerCount = 0;

	for (i=0; i<4; i++)
	{
		if (Controller.LiveFunc.IsControllerConnected(i))
			ConnectedControllerCount++;
	}

	if (Controller.CurrentControllers[0] != -1) UsedControllerCount++;
	if (Controller.CurrentControllers[1] != -1) UsedControllerCount++;
}

event Timer()
{
	CountConnectedControllers();

	ProfileChooser.Tick();
	ProfileChooser2.Tick();

	TestExitConditions();
}

function TestExitConditions()
{
	if (CanCancel(0) && CanCancel(1))
	{
		ProfileChooser.ScreenClosed(true);
		ProfileChooser2.ScreenClosed(true);

		// ok hacksaw time.  if our parent is gbx_MenuMain, we need to unset "strOnOpenTarget" because we cancelled
		if (gbx_MenuMain(ParentPage) != None)
			gbx_MenuMain(ParentPage).strOnOpenTarget = "";

		Controller.CloseMenu(true);
		return;
	}
	else if (IsReady(0) && IsReady(1))
	{
		ProfileChooser.ScreenClosed(false);
		ProfileChooser2.ScreenClosed(false);
		return;
	}
}

function bool CanCancel(int index)
{
	if (index == 0)
		return ProfileChooser.bCancel;
	else if (index == 1)
		return ProfileChooser2.bCancel;

	return false;
}

function bool IsReady(int index)
{
	if (index == 0)
		return ProfileChooser.TestReady();
	else if (index == 1)
		return ProfileChooser2.TestReady();

	return false;
}

function name GetPlayerState(int index)
{
	if (index == 0)
		return ProfileChooser.GetStateName();
	else if (index == 1)
		return ProfileChooser2.GetStateName();

	return '';
}

function SetReady(int index, bool bReady)
{
	if (index == 0)
		ProfileChooser.SetReady(bReady);
	else if (index == 1)
		ProfileChooser2.SetReady(bReady);
}

function FullUpdate()
{
	ProfileChooser.DoFullUpdate();
	ProfileChooser2.DoFullUpdate();
}

function bool ShouldShowControllerInfo(int index)
{
	if (index == 0)
		return ProfileChooser.GetControllerIndex() != -1;
	else if (index == 1)
		return ProfileChooser2.GetControllerIndex() != -1;

	return true;
}

function int GetControllerInfoIndex(int inPlayerIndex)
{
	return Controller.GetControllerIndexForPlayer(inPlayerIndex);
}

function TestLinkLiveLoss(optional bool bOpened)
{
	local int i1, i2;

	if (!Controller.bIsConsole || ((Controller.ActivePage != self) && !Controller.ActivePage.IsTopMost()))
		return;

	if (Controller.bHandledInput && (Controller.ActivePage == self))
	{
		i1 = Controller.GetControllerIndexForPlayer(0);
		i2 = Controller.GetControllerIndexForPlayer(1);

		if (class'gbx_DlgControllerLost'.static.TestLostController(self, i1))
			return;
		if (class'gbx_DlgControllerLost'.static.TestLostController(self, i2))
			return;
	}

	if (PlayerOwner().Level.UniversalTimeSeconds > fNextLinkLiveTest)
	{
		fNextLinkLiveTest = PlayerOwner().Level.UniversalTimeSeconds + LINK_LIVE_TEST_INTERVAL;

		if (ProfileChooser.TestLinkLiveLoss(bOpened))
		{
			if (!bOpened)
			{
				DoLiveLoss(bOpened);
			}
		}
		if (ProfileChooser2.TestLinkLiveLoss(bOpened))
		{
			if (!bOpened)
			{
				DoLiveLoss(bOpened);
			}
		}
	}
}

static function PreloadMenu(GUIController C)
{
	Super.PreloadMenu(C);

	C.PreloadMenu("GUI.gbx_LiveFriendsList");
	C.PreloadMenu("GUI.gbx_LiveLeaderboardMapSelect");
	C.PreloadMenu("GUI.gbx_LiveDlgSignOut");
//	C.PreloadMenu("GUI.gbx_LiveDlgContentDownload");
	C.PreloadMenu("GUI.gbx_LiveQueryQuickMatch");
	C.PreloadMenu("GUI.gbx_LiveOptiMatchRules");
	C.PreloadMenu("GUI.gbx_LiveCreateMatch");
	if(C.bIsConsole)
		C.PreloadMenu("GUI.gbx_MenuOptions");
	else 
		C.PreloadMenu("GUI.gbx_MenuOptionsPC"); //NAC added for PC Options menu support
	C.PreloadMenu("GUI.gbx_CreateMatchSplitScreen");
	C.PreloadMenu("GUI.gbx_BrowseMatchSysLink");
	C.PreloadMenu("GUI.gbx_LiveEnterPasscode");
}


defaultproperties
{
	Begin Object Class=gbx_ProfileChooserNew1P Name=cPM_ProfileChooser
		WinLeft=0.0
		PagePlayerIndex=0
	End Object
	Begin Object Class=gbx_ProfileChooserNew2P Name=cPM_ProfileChooser2
		WinLeft=0.50
		PagePlayerIndex=1
	End Object
	ProfileChooser=cPM_ProfileChooser
	ProfileChooser2=cPM_ProfileChooser2

	ScreenTitle="Multiplayer"
	BCaption=""
	BHint=""
}

class gbx_ProfileSelect extends gbx_ProfileChooserSubMenu;

var Automated GUISpinListControl			ProfileList;
var Automated gbx_ProfileDisplay			CurrentProfileDisplay;

var localized string						StringNewProfile;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);
	ProfileList.OnChange = ProfileListChanged;
}

function BuildProfileList()
{
	local array<string> AvailableProfiles;
	
	class'gbx_ProfileManager'.Static.GetProfileList(self, AvailableProfiles);
	AddStringListItem(AvailableProfiles, StringNewProfile);

	ProfileList.Clear();
	ProfileList.AddFromList(AvailableProfiles);
}

function ProfileListChanged(GUIComponent Sender)
{
	CurrentProfileDisplay.SetFromProfile( ProfileList.Get(), (ProfileList.GetIndex() == ProfileList.ItemCount()-1) );
}

function SubMenuOnShow()
{
	local int i;
	Super.SubMenuOnShow();

	BuildProfileList();

	i = FindMyProfile();
	if (i == -1) i = 0;
	ProfileList.SetIndex(i);
}

function int FindMyProfile()
{
	local int i;
	local string S;

	S = MyChooserRoot.GetProfileName();
	for (i=0; i<ProfileList.ItemCount(); i++)
	{
		if (S ~= ProfileList.GetAt(i))
			return i;
	}

	return -1;
}

function ProfileNameDone(string currentString, bool bCancelled)
{
	if (!bCancelled)
	{
		if (class'gbx_ProfileManager'.Static.CreateNewProfile(self, currentString))
		{
			MyChooserRoot.SetProfile(currentString);
			Super.OnAButton();
		}
	}
}

function bool Work_LoadingProfile()
{
	return true;
}

function Work_LoadingDone(optional Bool bCancelled)
{
	MyChooserRoot.SetProfile( ProfileList.Get() );
	MyChooserRoot.StateNext();
}

function OnAButton()
{
	local gbx_ScreenTextEntry dlg;
	local gbx_ScreenExtendedWork wdlg;

	if (ProfileList.GetIndex() == ProfileList.ItemCount()-1)
	{
		Controller.PlayClickSound(EClickSound.CS_Click);

		if (class'gbx_DlgLowStorage'.static.VerifyProfileSpace(MyChooserRoot))
		{
			dlg = class'gbx_ProfileManager'.Static.PromptNewProfile(self);
			dlg.EntryFinished = ProfileNameDone;
		}
	}
	else
	{
		Controller.PlayClickSound(EClickSound.CS_Click);

		if (ProfileList.Get() ~= class'gbx_ProfileManager'.Static.GetProfileForController(self, MyChooserRoot.PagePlayerIndex))
		{
			MyChooserRoot.StateNext();
		}
		else
		{
			// verify the profile first!
			if (class'gbx_DlgCorruptContent'.Static.VerifyProfile(self, ProfileList.Get()))
			{
				wdlg = MyChooserRoot.ChooserBase.LaunchWorkDialog(Controller, class'gbx_ProfileManager'.default.StringLoadingProfileData,, 1.0);
				wdlg.DoWork = Work_LoadingProfile;
				wdlg.OnClose = Work_LoadingDone;
			}
		}
	}
}

function bool OnCursor(byte Id, eXControllerCodes iCode)
{
	switch(iCode)
	{
	case XC_PadLeft:
	case XC_PadRight:
		ProfileList.OnXControllerEvent(Id, iCode);
		return true;
	}

	return false;
}

function SetupHelpButtons()
{
	MyChooserRoot.SetupAButton(MyChooserRoot.ChooserBase.StringSelect);
	MyChooserRoot.SetupBButton(MyChooserRoot.ChooserBase.StringBack);
}

defaultproperties
{
	Begin Object Class=GUISpinListControl name=cProfileList
		WinTop=0.16
		WinWidth=0.865
		WinLeft=0.0675
		WinHeight=0.066
	End Object
	ProfileList=cProfileList

	Begin Object Class=gbx_ProfileDisplay Name=cProfileDisplay
//		bScaleToParent=false
		WinTop=0.16
		WinWidth=0.865
		WinLeft=0.0675
		WinHeight=0.66
		bNoName=true
	End Object
	CurrentProfileDisplay=cProfileDisplay

//	bForceScaleToParent=false
	StringNewProfile="New Profile"
	StringPanelHeader="Choose Profile"
}

class gbx_ScreenABXY extends GUIPage
	Abstract;

// these control what gets displayed in the controller display labels
enum EControllerDisplay
{
	CD_None,					// display nothing in the label
	CD_Default,					// use the default of gbx_ScreenABXY (auto-toggle)
	CD_Signin,					// switch between profile and sign-in display
	CD_Profile,					// switch between profile and sign-in display
};

struct ServerInfo
{
    // From Matchmaking server:
	var() String ModName;
    var() String HostName;
    var() String MapFilename;
    var() String GameType;
    var() String Mutators;
    var() int NumPlayers;
    var() int MaxPlayers;
    var() int HaveMutators;
    var() int HaveSpeciesStats;
    var() int AverageSkill;
    var() int BandwidthUsage;

    // Connection info:
    var() String URLAppend;
    var() int URLPort;

    // Sythesized:
    var() String MapName;
    var() String GameName;
    var() String GameAcronym;
    
    // Updated:
    var() int Ping;

	var() int ContextID;	// linked to the xbox matchmaking list index

	//SDJ 09/28/2004: Ubisoft Gameservice data.
	var() int LobbyID;
	var() int RoomID;
	var() bool IsDedicatedServer;
	var() bool IsPasswordProtected;
	var() int ServerExtPingAddress;
	var() int ServerExtPingPort;
	var() int ServerAltPingAddress;
	var() int ServerAltPingPort;

};

struct native PlayerInfoStatus
{
	var int							MyPlayerIndex;
	var string						MyGamerTag;
	var string						MyDisplayName;
};


var	automated	GUILabel			lblScreenTitle;
var automated 	GUIHelpButton		hbtnA;
var automated 	GUIHelpButton		hbtnB;
var automated 	GUIHelpButton		hbtnX;
var automated 	GUIHelpButton		hbtnY;

var automated   GUIImage            onlineIcon;
var bool							bShowOnlineIcon;

var automated 	array<GUILabel>		lblProfileName;
var bool							bShowProfileLabels;

// link, live loss detection
var bool							bRequireLink, bRequireLive, bDeferControllerLoss;
var float							fNextLinkLiveTest;
const LINK_LIVE_TEST_INTERVAL = 0.75;

// sign-in status variables
var PlayerInfoStatus				PlayerStatus[4];
var float							fNextToggleTime;			// accessed through default.
var EControllerDisplay				DefPlayerStatusDisplayStyle;
var EControllerDisplay				PlayerStatusDisplayStyle;
var string							LastAuthState;
const PLAYER_STATUS_TOGGLE_DELAY = 3.0;
const PLAYER_STATUS_ICON_SCALE = 0.9;


var(Menu) localized string			ScreenTitle;
var(Menu) localized string			ACaption;
var(Menu) localized string			BCaption;
var(Menu) localized string			XCaption;
var(Menu) localized string			YCaption;
var(Menu) localized string			AHint;
var(Menu) localized string			BHint;
var(Menu) localized string			XHint;
var(Menu) localized string			YHint;

var() localized String 				StringQuit;
var() localized String 				StringYes;
var() localized String 				StringOk;
var() localized String 				StringNo;
var() localized String 				StringCancel;
var() localized String 				StringContinue;
var() localized String 				StringBack;
var() localized string				StringAny;
var() localized string				StringDefaults;
var() localized string  			StringSelect;
var() localized string  			StringOptions;
var() localized string  			stringJoin;
var() localized string  			stringLeave;
var() localized string				StrUnReady;
var() localized string				StrReady;
var() localized string				StrPlayers;
var() localized string				StringBiA;
var() localized string				StringDone;
var() localized string				StringError;
var() localized string				StringCreateMatch;
var() localized string				StringRefresh;

var() localized string				StringNotSignedIn;
var() localized string				StringNotSignedIn_PC;
var() localized string				StringSigningIn;
var() localized string				StringSignedIn;
var() localized string				StringSignInFailed;
var() localized string				StringIsGuest;
var() localized string				StringProfile;

var() localized array<string>		StringListNoYes;
var() localized array<string>		StringListOffOn;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	OnKeyEvent = SAB_KeyEvent;
	OnXControllerEvent=SAB_OnXControllerEvent;
	OnCanClose = CanClose;

	OnBButtonEvent = BaseOnBButton;
	OnPreDraw = ScreenOnPreDraw;
	OnDraw = ScreenOnDraw;
	OnDrawPre = ScreenOnDrawPre;

	hbtnA.OnClick = ABScreen_ButtonClick;
	hbtnB.OnClick = ABScreen_ButtonClick;
	hbtnX.OnClick = ABScreen_ButtonClick;
	hbtnY.OnClick = ABScreen_ButtonClick;

	SetupAButton(ACaption, AHint);
	SetupBButton(BCaption, BHint);
	SetupXButton(XCaption, XHint);
	SetupYButton(YCaption, YHint);

	SetCaption(ScreenTitle);

	if (!bShowProfileLabels)
	{
		lblProfileName[0].Hide();
		lblProfileName[1].Hide();
	}
	
	if (!bShowOnlineIcon)
	    onlineIcon.Hide();
}

event Opened(GUIComponent Sender)
{
	Super.Opened(Sender);

	fNextLinkLiveTest = 0.0;
	TestLinkLiveLoss(true);

	// force these to reset without popping
	lblProfileName[0].SetCaption( "" );
	lblProfileName[1].SetCaption( "" );
}

// handle this ourselves
function bool CanClose(optional Bool bCancelled) {return false;}

// override to provide custom functionality
delegate OnAButtonEvent();
delegate OnBButtonEvent();
delegate OnXButtonEvent();
delegate OnYButtonEvent();

final function BaseOnAButton()
{
	Controller.PlayClickSound(EClickSound.CS_Click);
	Controller.CloseMenu(false);
}
final function BaseOnBButton()
{
	Controller.PlayClickSound(EClickSound.CS_Back);
	Controller.CloseMenu(true);
}

function SetCaption(optional string S)
{
	lblScreenTitle.Caption = S;
}

function DisableSelectAButton()
{
	if (!Controller.bIsConsole)
		SetupAButton();
}

function SetupAButton(optional string newCap, optional string newHint) { SetupHelpButton(hBtnA, newCap, newHint); }
function SetupBButton(optional string newCap, optional string newHint) { SetupHelpButton(hBtnB, newCap, newHint); }
function SetupXButton(optional string newCap, optional string newHint) { SetupHelpButton(hBtnX, newCap, newHint); }
function SetupYButton(optional string newCap, optional string newHint) { SetupHelpButton(hBtnY, newCap, newHint); }
static function SetupHelpButton(GUIHelpButton button, optional string newCap, optional string newHint)
{
	if (button == None) return;

	if (newCap == "")
	{
		button.SetVisibility(false);
	}
	else
	{
		button.SetCaption(newCap);
		button.Hint = newHint;
		button.SetVisibility(true);
	}
}

function bool ScreenOnPreDraw(Canvas C)
{
	local string authState;
	local int i;

	if (controller.bIsConsole && (PlayerStatusDisplayStyle == CD_Default))
	{
		// trip us over to displaying the signin info
		authState = Controller.LiveFunc.GetAuthState();
		if (!(class'gbx_ScreenABXY'.default.LastAuthState ~= authState))
		{
			if (class'gbx_ScreenABXY'.default.LastAuthState != "")
			{
				class'gbx_ScreenABXY'.default.fNextToggleTime = PlayerOwner().Level.UniversalTimeSeconds + PLAYER_STATUS_TOGGLE_DELAY;
				if (class'gbx_ScreenABXY'.default.DefPlayerStatusDisplayStyle == CD_Profile)
					class'gbx_ScreenABXY'.default.DefPlayerStatusDisplayStyle = CD_Signin;
			}

			class'gbx_ScreenABXY'.default.LastAuthState = authState;
		}

		// handle toggling profile-signin
		if (PlayerOwner().Level.UniversalTimeSeconds > class'gbx_ScreenABXY'.default.fNextToggleTime)
		{
			if (class'gbx_ScreenABXY'.default.DefPlayerStatusDisplayStyle == CD_Signin)
				class'gbx_ScreenABXY'.default.DefPlayerStatusDisplayStyle = CD_Profile;
			else
				class'gbx_ScreenABXY'.default.DefPlayerStatusDisplayStyle = CD_Signin;

			class'gbx_ScreenABXY'.default.fNextToggleTime = PlayerOwner().Level.UniversalTimeSeconds + PLAYER_STATUS_TOGGLE_DELAY;
		}
	}

	if (bShowProfileLabels)
	{
		for (i=0; i<lblProfileName.Length; i++)
		{
			lblProfileName[i].SetCaption( GetPlayerStatusCaption(i) );
		}
//		lblProfileName[0].SetCaption( GetPlayerStatusCaption(0) );
//		lblProfileName[1].SetCaption( GetPlayerStatusCaption(1) );
	}

	return false;	// still do the other stuff
}

function DrawBars(Canvas C, float barHeight)
{
	local float extra;

	barHeight = barHeight * ActualHeight();
	extra = 0.02 * ActualHeight();

	C.DrawColor = Controller.BackgroundBoxColor;
	C.DrawColor.A = 255;

	C.SetPos(-5.0, -extra);
	C.DrawTileTiledClip(	Texture't_interface_mb.hud.interface_comp', 
							C.ClipX + 10, barHeight, 
							284, 128, 128, 128,
							32, 32);

	C.SetPos(-5.0, C.ClipY - barHeight + extra);
	C.DrawTileTiledClip(	Texture't_interface_mb.hud.interface_comp', 
							C.ClipX + 10, barHeight, 
							284, 128, 128, 128,
							32, 32);
}

function bool ScreenOnDrawPre(Canvas C)
{
	if (!bVisible)
		return false;

	DrawBars(C, 0.18);

	return false;	// still do the other stuff
}

function bool ScreenOnDraw(Canvas C)
{
	if (Controller.bIsConsole)
	{
		DrawAttachedPlayerStatusIcon(C, 0, lblProfileName[0], false);
		DrawAttachedPlayerStatusIcon(C, 1, lblProfileName[1], true);
	}

	if (Controller.bDesignMode)
	{
		C.Font = Controller.GetMenuFont("SmallFont").GetFont(C.ClipX);
		C.SetDrawColor(255,255,255,255);
		C.DrawTextJustified(String(PagePlayerIndex+1) $"P : 1P=" $Controller.CurrentControllers[0] $", 2P=" $Controller.CurrentControllers[1], 0, 
							HorizontalOffset(0.05), VerticalOffset(0.05), HorizontalOffset(0.6), VerticalOffset(0.15), 0.7, 0.7);
	}

	TestLinkLiveLoss();

	return false;	// still do the other stuff
}

// drawDirection: -1=from left, 1=from right.  0=Automatic
// drawController: -1=skip, 0=auto (owner if owned or last controller input), #= controller #
function DrawFocusedControl(Canvas C, optional GUIComponent drawControl, optional int drawDirection, optional int drawController)
{
	local float X, Y, XL;
//	local int nXL, nYL;
//	local string S;
//	local GUIStyles tStyle;

	if (drawControl == None)
		drawControl = FocusedControl;

	if ((drawControl == None) || HelpButtonHasFocus(drawControl))
		return;

	if (!drawControl.bVisible)
		return;

	if (drawDirection == 0)
	{
		if (drawControl.IsA('GUIButton'))
		{
			drawDirection = 1;
		}
		else
		{
			drawDirection = -1;
		}
	}

	if (drawDirection > 0)
	{
		X = drawControl.GetCaptionPos(C, true);
		XL = C.ClipX - X + 16;
	}
	else
	{
		X = -16;
		XL = drawControl.GetCaptionPos(C, false) - X;
	}

	Y = drawControl.ActualTop() + drawControl.ActualHeight();
	DrawTheThinRedLine(Controller, C, X, Y, XL);
}

function bool HelpButtonHasFocus(optional GUIComponent testControl)
{
	if (testControl == None)
		testControl = FocusedControl;

	return (testControl == hbtnA) || (testControl == hbtnB) || (testControl == hbtnX) || (testControl == hbtnY);
}

static function DrawTheThinRedLine(GUIController Con, Canvas C, int X, int Y, int XL)
{
	C.DrawColor = con.BackgroundBoxColor;

	C.SetPos(X+1, Y - (2*Con.CanvasAspectScale)+1);
	C.DrawTileTiledClip(	Texture't_interface_mb.hud.interface_comp', 
							XL, 5 * Con.CanvasScaleY, 
							284, 128, 128, 128,
							32, 32);

	C.DrawColor = con.RedLineColor;
	C.SetPos(X, Y - (2*Con.CanvasScaleY));
	C.DrawTileTiledClip(	Texture't_interface_mb.hud.interface_comp', 
							XL, 5 * Con.CanvasScaleY, 
							284, 128, 128, 128,
							32, 32);
}

// =======================================================================================================================================================
// controller and profile/signin display stuff
// =======================================================================================================================================================
function bool ShouldShowControllerInfo(int inPlayerIndex)
{
	if ((Controller.GetControllerIndexForPlayer(inPlayerIndex) != -1) && ((PagePlayerIndex == inPlayerIndex) || (PagePlayerIndex == -1)))
	{
		return true;
	}
	else if (PagePlayerIndex == -1)
	{
		return (inPlayerIndex == 0);
	}

	return false;
}

function int GetControllerInfoIndex(int inPlayerIndex)
{
	local int result;
//	local string authState;

	if (!ShouldShowControllerInfo(inPlayerIndex))
		return -1;

	result = Controller.GetControllerIndexForPlayer(inPlayerIndex);
	if (result == -1)
	{
		result = 0;
/*
		// yikes, find first signed in controller
		if ((inPlayerIndex == 0) && (PagePlayerIndex == -1))
		{
			result = Controller.LiveFunc.GetFirstSignedInController();

			// try to find a silent sign-in
			if (result == -1)
			{
				authState = Controller.LiveFunc.GetAuthState();
				if ((authState ~= "FAILED_MUST_UPDATE") || (authState ~= "SIGNING_ON_SILENT") || (authState ~= "ERROR"))
					result = 0;
			}
		}
*/
	}

	return result;
}

function DrawAdornmentIcons(Canvas C, GUIComponent friendsMenuItem, optional float sX, optional float SY)
{
	local Canvas.CanvasIcon icon;

	GetNotificationIcon(0, icon);
	DrawAttachedPlayerIcon(C, icon, friendsMenuItem, false, sX, sY);

	GetNotificationIcon(1, icon);
	DrawAttachedPlayerIcon(C, icon, friendsMenuItem, true, sX, sY);
}

function DrawPlayerStatusIcon(Canvas C, Canvas.CanvasIcon icon, float X, float Y, optional float sX, optional float SY)
{
	local color oldColor;
	local float xPos, yPos, XL, YL;

	if (icon.Icon == None)
		return;

	if (sX == 0.0) sX = PLAYER_STATUS_ICON_SCALE;
	if (sY == 0.0) sY = PLAYER_STATUS_ICON_SCALE;

	sX *= Controller.CanvasAspectScale;
	sY *= Controller.CanvasScaleY;
	C.CanvasIconSize(icon, XL, YL, sX, sY);

	xPos = X + 0.1 * XL;
	yPos = Y + 0.1 * YL;
	oldColor = icon.DrawColor;
	C.CanvasIconSetColor(icon, 13,5,8,255);
	C.DrawCanvasIcon(xPos, yPos, sX, sY, icon);
	icon.DrawColor = oldColor;

	C.DrawCanvasIcon(X, Y, sX, sY, icon);
}

function DrawPlayerIcon(Canvas C, int inPlayerIndex, float X, float Y, optional float sX, optional float SY)
{
	local Canvas.CanvasIcon icon;

	GetPlayerStatusIcon(inPlayerIndex, icon);
	if (icon.Icon == None)
		return;

	DrawPlayerStatusIcon(C, icon, X, Y, sX, sY);
}

function DrawAttachedPlayerIcon(Canvas C, Canvas.CanvasIcon icon, GUIComponent attach, bool bAttachRight, optional float sX, optional float SY)
{
	local float xPos, yPos, XL, YL;
	if (icon.Icon == None)
		return;

	if (sX == 0.0) sX = PLAYER_STATUS_ICON_SCALE;
	if (sY == 0.0) sY = PLAYER_STATUS_ICON_SCALE;

	C.CanvasIconSize(icon, XL, YL, sX*Controller.CanvasAspectScale, sY*Controller.CanvasScaleY);

	yPos = attach.VerticalOffset(0.5) - 0.5*YL;
	if (bAttachRight)
	{
//		xPos = attach.HorizontalOffset(1.0) + 0.05*XL;
		xPos = attach.GetCaptionPos(C, false) + 0.11*XL;
	}
	else
	{
//		xPos = attach.HorizontalOffset(0.0) - 1.05*XL;
		xPos = attach.GetCaptionPos(C, true) - 1.11*XL;
	}

	DrawPlayerStatusIcon(C, icon, xPos, yPos, sX, sY);
}

function DrawAttachedPlayerStatusIcon(Canvas C, int inPlayerIndex, GUIComponent attach, bool bAttachRight, optional float sX, optional float SY)
{
	local Canvas.CanvasIcon icon;

	GetPlayerStatusIcon(inPlayerIndex, icon);
	if (icon.Icon == None)
		return;

	DrawAttachedPlayerIcon(C, icon, attach, bAttachRight, sX, sY);
}

function bool DisplayRemotePlayerFriendIcon(string GamerTag)
{
	local int inControllerIndex;
	if (PlayerOwner().Level.AuthMode != AM_Live)
		return false;

	inControllerIndex = Controller.GetControllerIndexForPlayer(0);
	if (inControllerIndex != -1)
	{
		if ( bool(ConsoleCommand("XLIVE FRIENDS USER=" $"0" @ "IS_FRIEND GAMERTAG=" $GamerTag)) )
			return true;
	}

	inControllerIndex = Controller.GetControllerIndexForPlayer(1);
	if (inControllerIndex != -1)
	{
		if ( bool(ConsoleCommand("XLIVE FRIENDS USER=" $"1" @ "IS_FRIEND GAMERTAG=" $GamerTag)) )
			return true;
	}

	return false;
}

function GetPlayerStatusIcon(int inPlayerIndex, out Canvas.CanvasIcon icon)
{
	local int inControllerIndex;
	local string S;

	icon.Icon = None;

	// this will check for players talking and put an icon for remote players
	if ((PlayerStatus[inPlayerIndex].MyGamerTag != "") && (PlayerOwner().Level.AuthMode != AM_None))
	{
		S = "\"" $PlayerStatus[inPlayerIndex].MyGamerTag $"\"";
		if ( bool(ConsoleCommand("XLIVE IS_TALKING" @S)) )
		{
			icon = class'gbx_LiveGamerList'.Static.GetLiveIcon(LI_COMM_TALKING);
			return;
		}
		else// if (PlayerStatus[inPlayerIndex].MyPlayerIndex == -1)	// remote players have this set...
		{
			if (DisplayRemotePlayerFriendIcon(S))
			{
				icon = class'gbx_LiveGamerList'.Static.GetLiveIcon(LI_ONLINE);
				icon.DrawColor = class'gbx_LiveGamerList'.default.LiveIconColors[2];	// LIC_PLAYING
				return;
			}
		}
	}

	inControllerIndex = GetControllerInfoIndex(inPlayerIndex);
	if (inControllerIndex == -1)
		return;

	if (!Controller.LiveFunc.IsSignedIn(inPlayerIndex) || Controller.LiveFunc.IsGuest(inPlayerIndex))
		return;

	if ( ConsoleCommand("XLIVE FRIENDS USER=" $inPlayerIndex @ "NOTIFICATION INVITE") == "TRUE" )
	{
		icon = class'gbx_LiveGamerList'.Static.GetLiveIcon(LI_INVITE_RECEIVED);
		return;
	}
	else if ( ConsoleCommand("XLIVE FRIENDS USER=" $inPlayerIndex @ "NOTIFICATION FRIEND") == "TRUE" )
	{
		icon = class'gbx_LiveGamerList'.Static.GetLiveIcon(LI_FRIEND_RECEIVED);
		return;
	}
}

function bool GetNotificationIcon(int inPlayerIndex, out Canvas.CanvasIcon icon)
{
	icon.Icon = None;

	if (GetControllerInfoIndex(inPlayerIndex) == -1)
		return false;

	if (!Controller.LiveFunc.IsSignedIn(inPlayerIndex) || Controller.LiveFunc.IsGuest(inPlayerIndex))
		return false;

	if ( ConsoleCommand("XLIVE FRIENDS USER=" $inPlayerIndex @ "NOTIFICATION INVITE") == "TRUE" )
	{
		icon = class'gbx_LiveGamerList'.Static.GetLiveIcon(LI_INVITE_RECEIVED);
		return true;
	}
	else if ( ConsoleCommand("XLIVE FRIENDS USER=" $inPlayerIndex @ "NOTIFICATION FRIEND") == "TRUE" )
	{
		icon = class'gbx_LiveGamerList'.Static.GetLiveIcon(LI_FRIEND_RECEIVED);
		return true;
	}

	return false;
}

function string GetSigninCaption(int inPlayerIndex)
{
	local string authState;
	local int inControllerIndex;

	inControllerIndex = GetControllerInfoIndex(inPlayerIndex);
	if (inControllerIndex != -1)
	{
		if ((PlayerStatus[inPlayerIndex].MyDisplayName != "") && (PlayerStatus[inPlayerIndex].MyPlayerIndex == -1) && (PlayerOwner().Level.AuthMode != AM_None))
		{
			// display the gamertag for a remote player (they set MyGamerTag and MyPlayerIndex)
			return PlayerStatus[inPlayerIndex].MyDisplayName;
		}
		else
		{
			authState = Controller.LiveFunc.GetAuthState();
			if ((authState ~= "SIGNING_ON") || (authState ~= "CHANGING_LOGON") || (authState ~= "SIGNING_ON_SILENT"))
			{
				return StringSigningIn;
			}
			else if (Controller.LiveFunc.IsSignedIn(inPlayerIndex))
			{
				if (Controller.LiveFunc.IsGuest(inPlayerIndex))
				{
					return StringIsGuest @Controller.LiveFunc.GetGamerTag(inPlayerIndex);
				}
				else
				{
					return StringSignedIn @Controller.LiveFunc.GetGamerTag(inPlayerIndex);
				}
			}
			else if (((authState ~= "FAILURE") || (authState ~= "FAILED_MUST_UPDATE") || (authState ~= "BAD_STATE") || (authState ~= "ERROR")) && ( Controller.LiveFunc.GetUserAuthState(inPlayerIndex) == "ERROR" ))
			{
				class'gbx_LiveErrorMessage'.static.ReadLastErrorString(self);

				if (class'gbx_LiveErrorMessage'.default.LastAuthErrorCode ~= "BAD_PASSCODE")
					return StringNotSignedIn_PC;
				else if (class'gbx_LiveErrorMessage'.default.LastAuthErrorCode != "")
					return StringSignInFailed;
			}
		}
	}

	if (class'gbx_LiveErrorMessage'.default.LastAuthErrorCode ~= "BAD_PASSCODE")
		return StringNotSignedIn_PC;
	else
		return StringNotSignedIn;
}

function string GetPlayerStatusCaption(int inPlayerIndex)
{
	if (ShouldShowControllerInfo(inPlayerIndex))
	{	
		if (Controller.bIsConsole &&
			((PlayerStatusDisplayStyle == CD_Signin) ||
			!class'gbx_ProfileManager'.Static.ControllerProfileExists(self, inPlayerIndex) ||
			((PlayerStatusDisplayStyle == CD_Default) && (class'gbx_ScreenABXY'.default.DefPlayerStatusDisplayStyle == CD_Signin))))
		{
			return GetSigninCaption(inPlayerIndex);
		}
		else
		{
			if (class'gbx_ProfileManager'.Static.ControllerProfileExists(self, inPlayerIndex))
				return StringProfile @class'gbx_ProfileManager'.Static.GetProfileForController(self, inPlayerIndex);
		}
	}

	return "";
}

function SetupPlayerStatusInfo(int labelIndex, int localPlayerIndex, optional string displayName, optional string GamerTag)
{
	PlayerStatus[labelIndex].MyPlayerIndex = localPlayerIndex;
	PlayerStatus[labelIndex].MyGamerTag = GamerTag;
	if ( PlayerStatus[labelIndex].MyDisplayName == class'gbx_MPLobby'.Default.StrSlotEmpty ||
		displayName == class'gbx_MPLobby'.Default.StrSlotEmpty)
	{
		PlayerStatus[labelIndex].MyDisplayName = displayName;
	}
}

// =======================================================================================================================================================
// Input handling
// =======================================================================================================================================================
// if overriding OnXControllerEvent, simply call SAB_OnXControllerEvent as a fallback case
function bool SAB_OnXControllerEvent(byte Id, eXControllerCodes iCode)
{
	if ((iCode == XC_Start) || (iCode == XC_A))
	{
		if (hbtnA.bVisible && !hbtnA.bDisabled)
		{
			OnAButtonEvent();
			return false;
		}
	}
	else if ((iCode == XC_Back) || (iCode == XC_B))
	{
		if (hbtnB.bVisible && !hbtnB.bDisabled)
		{
			OnBButtonEvent();
			return true;
		}
	}
	else if (iCode == XC_X)
	{
		if (hbtnX.bVisible && !hbtnX.bDisabled)
		{
			OnXButtonEvent();
			return true;
		}
	}
	else if (iCode == XC_Y)
	{
		if (hbtnY.bVisible && !hbtnY.bDisabled)
		{
			OnYButtonEvent();
			return true;
		}
	}

	return false;
}

function CycleHelpButtonFocus(GUIComponent start, bool bForward)
{
	local GUIComponent newFocus;

	newFocus = start;
	if (bForward)
	{
		do
		{
			if (newFocus == hbtnA)
				newFocus = hbtnB;
			else if (newFocus == hbtnB)
				newFocus = hbtnX;
			else if (newFocus == hbtnX)
				newFocus = hbtnY;
			else if (newFocus == hbtnY)
				newFocus = hbtnA;

		}
		until (( newFocus == start ) || (newFocus.bVisible && !newFocus.bDisabled))
	}	
	else
	{
		do
		{
			if (newFocus == hbtnA)
				newFocus = hbtnY;
			else if (newFocus == hbtnB)
				newFocus = hbtnA;
			else if (newFocus == hbtnX)
				newFocus = hbtnB;
			else if (newFocus == hbtnY)
				newFocus = hbtnX;

		}
		until (( newFocus == start ) || (newFocus.bVisible && !newFocus.bDisabled))
	}

	if (newFocus != start)
		newFocus.SetFocus(None);
}

// if overriding OnKeyEvent, simply call SAB_KeyEvent as a fallback case
function bool SAB_KeyEvent(out byte Key,out byte State,float delta)
{
	if (HelpButtonHasFocus() && (State == 1))
	{
		if (Key == 37)
		{
			CycleHelpButtonFocus(FocusedControl, false);
			return true;
		}
		else if (Key == 39)
		{
			CycleHelpButtonFocus(FocusedControl, true);
			return true;
		}
	}
	else if ((Key == 13) && (State == 3))	// IK_Enter, IST_Release
	{
		if (hbtnA.bVisible && !hbtnA.bDisabled)
		{
			OnAButtonEvent();
			return true;
		}
	}
	else if ((Key == 27) && (State == 3))	// IK_Escape, IST_Release
	{
		if (hbtnB.bVisible && !hbtnB.bDisabled)
		{
			OnBButtonEvent();
			return true;
		}
	}
	return false;
}

function bool ABScreen_ButtonClick(GUIComponent Sender)
{
	local GUIButton Selected;

	Selected = GUIButton(Sender);
	if (Selected == None) return false;

	switch (Selected)
	{
		case hbtnA:
			OnAButtonEvent(); return true; break;
		case hbtnB:
			OnBButtonEvent(); return true; break;
		case hbtnX:
			OnXButtonEvent(); return true; break;
		case hbtnY:
			OnYButtonEvent(); return true; break;
	}

	return false;
}

static function gbx_ScreenQuestion LaunchErrorDialog(GUIController con, string prompt, optional string params)
{
	return LaunchQuestionDialog(con, prompt, params, default.StringError);
}

static function gbx_ScreenQuestion LaunchQuestionDialog(GUIController con, string prompt, optional string params, optional string strTitle)
{
	local gbx_ScreenQuestion result;

	con.OpenMenu("GUI.gbx_ScreenQuestion",, params);
	result = gbx_ScreenQuestion(con.ActivePage);
	if (result != None)
	{
		result.SetTextPrompt(prompt);
		if (strTitle != "")
			result.SetCaption(strTitle);
	}

	return result;
}

static function gbx_ScreenExtendedWork LaunchWorkDialog(GUIController con, string prompt, optional string title, optional float fMinDisplayTime, optional bool bPromptOnExit, optional string nextMenuClass)
{
	local gbx_ScreenExtendedWork dlg;
	local string s;

	s = "\"" $prompt $"\" \"" $title $"\"";
	if (bPromptOnExit)
		s = s @ "PromptWhenDone";

	con.OpenMenu("GUI.gbx_ScreenExtendedWork", s, nextMenuClass);
	dlg = gbx_ScreenExtendedWork(con.ActivePage);
	if (dlg != None)
		dlg.MinDisplayTime = fMinDisplayTime;

	return dlg;
}

function LoadSPMap(string mapName, optional int difficulty, optional bool bNoCloseAll)
{
    // rss: added this for mutator support!
    local string mutList;
    mutList = class'Gameplay.gbxMutatorList'.static.GetActiveMutatorListString();

	PlayerOwner().Level.MissionManager.LoadSPMap(mapName, difficulty, mutList);

	if (!bNoCloseAll)
		Controller.CloseAll(false);
}

function Disconnect(optional bool bPreserveState)
{
	local string S;

	//log("LAPSUSQ Disconnect bPreserveState=" $ bPreserveState);
	
	if (bPreserveState && Controller.bIsConsole)
	{
		class'GameEngine'.default.DisconnectMenuArg = StoreDisconnectArgs();
		if (class'GameEngine'.default.DisconnectMenuArg != "")
		{
			class'GameEngine'.default.DisconnectMenuClass = class'GameEngine'.default.MainMenuClass;
			class'GameEngine'.static.StaticSaveConfig();
		}

		GUILog("============ Preserving player state [" $class'GameEngine'.default.DisconnectMenuArg $"]");
	}
	else if (bPreserveState)
	{
	    class'GameEngine'.default.DisconnectMenuArg = "";
	    
	    if (PlayerOwner().Level.NetMode != NM_Standalone)
	    {
			S = "MP=";

			if (ConsoleCommand("GAMEMODE IS_SKIRMISH") ~= "TRUE")
			{
				S = S$"SK_";
			}

    	    if (PlayerOwner().Level.AuthMode == AM_SystemLink)
			{
				if (PlayerOwner().Level.Game.MaxPlayers == 1)
					S = S$"SOLO";
				else
    				S = S$"LANPLAY";
			}
	        else
			{
	            S = S$"UBICOM";
			}

	        class'GameEngine'.default.DisconnectMenuArg=MakeQuotedString(S);
	    }
	    
		if (class'GameEngine'.default.DisconnectMenuArg != "")
		{
		    class'GameEngine'.default.DisconnectMenuClass = class'GameEngine'.default.MainMenuClass;
		    class'GameEngine'.static.StaticSaveConfig();
		}
	}

	ConsoleCommand("disconnect");
}

function string StoreDisconnectArgs()
{
	local string S;

	if (Controller.LiveFunc.IsLiveMode())
	{
		S = "MP=LIVE";
	}
	else if (Controller.LiveFunc.IsSystemLinkMode())
	{
		S = "MP=LINK";
	}
	else if (PlayerOwner().Level.NetMode != NM_Standalone)
	{
		S = "MP=SPLIT";
	}
/*
	// spaces in names = fux0r'd
	// GetUsedControllersFromCmdLine for controller
	// similar func to retrieve profiles
	S = S @ "P1=" $ class'gbx_ProfileManager'.Static.GetProfileForController(self, 0);
	S = S @ "C1=" $ String(Controller.GetControllerIndexForPlayer(0));
	S = S @ "P2=" $ class'gbx_ProfileManager'.Static.GetProfileForController(self, 1);
	S = S @ "C2=" $ String(Controller.GetControllerIndexForPlayer(1));
*/
	return MakeQuotedString(S);
}

function bool RetrieveDisconnectArgs(string strIn, out string auth)
{
	local string S;
	if (StrIn == "")
		return false;

	GUILog("============ Retrieving player state [" $strIn $"]");

	s = ParseToken(strIn);
	while(s != "")
	{
		if (ParseCommand(s, "MP="))
			auth = s;
/*
		else if (ParseCommand(s, "P1="))
			prof1 = s;
		else if (ParseCommand(s, "C1="))
			cont1 = int(s);
		else if (ParseCommand(s, "P2="))
			prof2 = s;
		else if (ParseCommand(s, "C2="))
			cont2 = int(s);
		else
		{
			GUILog("-- RetrieveDisconnectArgs Unknown token parsing " $s);
			return false;
		}
*/
		s = ParseToken(strIn);
	}

	return auth != "";
}

static function LaunchSkirmish(GUIController C, int players, optional string serverMode, optional string map)
{
	local GameProfile	gProfile;

	gProfile = class'GameProfile'.Static.LoadCurrentGameProfile( C.ViewportOwner.Actor.Level );
	if (gProfile != None)
	{
		C.ViewportOwner.Actor.Level.MissionManager.SkirmishClearCheckpointData( gProfile );
		class'GameProfile'.Static.UnloadProfile( C.ViewportOwner.Actor.Level, gProfile, true );
	}
	if (map == "")
		map = "SKR_Menu_map";


	if (serverMode != "")
		C.ViewportOwner.Actor.ClientTravel( map$"?game=gbxGameplay.WargameSkirmish?" $serverMode $"?Listen?maxplayers=" $players, TRAVEL_Absolute, false );
	else
		C.ViewportOwner.Actor.ClientTravel( map$"?game=gbxGameplay.WargameSkirmish?Listen?maxplayers=" $players, TRAVEL_Absolute, false );



	C.CloseAll(false);
}

static function ServerTravelSkirmish(GUIController C, string mapName, string rules)
{
	local string nextmap;

	nextmap = mapName $ "?NoLobby?wascycle=1" $ GetHostAuthString(C) $"?game=gbxGameplay.WargameSkirmish?" $rules;

	GUILog("ServerTravelSkirmish Proceeding to next map: " $ nextmap);
	C.ViewportOwner.Actor.Level.ServerTravel(nextmap, false);
	C.CloseAll(false);
}

static function string GetHostAuthString(GUIController C)
{
	local PlayerController PC;
	local string hostName;
	local string authMode;

  	PC = C.ViewportOwner.Actor.Level.GetLocalPlayerController();
	if (PC != None)
	{
		hostName = PC.PlayerReplicationInfo.PlayerName;
    }
    else
    {
		hostName = C.ViewportOwner.Actor.Level.ComputerName;
	}	

	if (C.ViewportOwner.Actor.Level.AuthMode == AM_SystemLink)
	{
		authMode = "?SystemLink";
	}
	else if (C.ViewportOwner.Actor.Level.AuthMode == AM_SplitScreen)
	{
		authMode = "?SplitScreen";
	}
	else if (C.ViewportOwner.Actor.Level.AuthMode == AM_Live)
	{
		if (PC != None)
		{
			hostName = PC.PlayerReplicationInfo.GamerTag;
		}
		authMode = "?Live";	
	}
	else
	{
		hostName = class'GameService.GameService'.static.GetServerName();
	}

	ReplaceText(hostName, " ", "_");

	return authMode $ "?HostName=" $hostName;
}

function HandleLossErrors(int iLostController, bool bLostLive, bool bLostLink);

function bool TestControllerLoss(optional bool bOpened)
{
	local int i1, i2;

	i1 = Controller.GetControllerIndexForPlayer(0);
	i2 = Controller.GetControllerIndexForPlayer(1);

	// wait until the controllers have been polled once before we do this
	if (Controller.bHandledInput && (Controller.ActivePage == self))
	{
		if (class'gbx_DlgControllerLost'.static.TestLostController(self, i1))
			return true;
		if (class'gbx_DlgControllerLost'.static.TestLostController(self, i2))
			return true;
	}

	return false;
}

function DoLiveLoss(bool bOpened)
{
	if (!Controller.MenuIsOpen("GUI.gbx_DlgLinkLost") && !Controller.MenuIsOpen("GUI.gbx_LiveErrorMessage"))
	{
		HandleLossErrors(-2, true, false);
		if (!bOpened)
		{
			Controller.OpenMenu("GUI.gbx_LiveErrorMessage");
		}
		else
		{
			Controller.CloseMenu(false);
		}
	}
}

function DoLinkLoss(bool bOpened)
{
	if (!Controller.MenuIsOpen("GUI.gbx_DlgLinkLost") && !Controller.MenuIsOpen("GUI.gbx_LiveErrorMessage"))
	{
		HandleLossErrors(-2, false, true);
		if (!bOpened)
		{
			Controller.OpenMenu("GUI.gbx_DlgLinkLost");
		}
		else
		{
			Controller.CloseMenu(false);
		}
		return;
	}
}

function TestLinkLiveLoss(optional bool bOpened)
{
	local int i1, i2;
	
//###+ lbouchard : LINKLOSS: We test this even if we are not on a console, the live stuff has been replaced by Ubi.com
	if ((Controller.ActivePage != self) && !Controller.ActivePage.IsTopMost())
		return;
//oldcode	if (!Controller.bIsConsole || ((Controller.ActivePage != self) && !Controller.ActivePage.IsTopMost()))
//oldcode		return;
//###-

	i1 = Controller.GetControllerIndexForPlayer(0);
	i2 = Controller.GetControllerIndexForPlayer(1);

	if (TestControllerLoss(bOpened))
		return;
		
	if (!(bRequireLink || bRequireLive))
		return;

	if (PlayerOwner().Level.UniversalTimeSeconds > fNextLinkLiveTest)
	{
		fNextLinkLiveTest = PlayerOwner().Level.UniversalTimeSeconds + LINK_LIVE_TEST_INTERVAL;

		if (bRequireLive)
		{
			if (((PagePlayerIndex == -1) || (PagePlayerIndex == 0)) && (i1 != -1) && !Controller.LiveFunc.IsSignedIn(0))
			{
				DoLiveLoss(bOpened);
				return;
			}
			if (((PagePlayerIndex == -1) || (PagePlayerIndex == 1)) && (i2 != -1) && !Controller.LiveFunc.IsSignedIn(1))
			{
				DoLiveLoss(bOpened);
				return;
			}
		}

		if (bRequireLink)
		{
			if (!Controller.LiveFunc.IsLinkActive())
			{
				DoLinkLoss(bOpened);
				return;
			}
		}
	}
}

//###+ lbouchard : LINKLOSS: Helper to tell us if it's a systemlink (LAN) game
function bool IsSystemLinkGame()
{
	// because of timing, this check may fail if executed during a map load
//	return (PlayerOwner().Level.AuthMode == AM_SystemLink);

	return Controller.LiveFunc.IsSystemLinkMode();
}
//###-


defaultproperties
{
	Begin Object Class=GUILabel Name=cCMB_ScreenTitle
		StyleName="Header"
		TextAlign=TXTA_Center
		Caption=""
		TextColor=(R=255,G=255,B=255,A=255)
		TextStyle=MSTY_Normal
		bUseTextColorForStyle=true
		bAcceptsInput=false
		bNeverFocus=true
		bTabStop=false
		WinWidth=0.9250000
		WinHeight=0.060000
		WinLeft=0.0375000
		WinTop=0.07500000
	End Object
	lblScreenTitle=cCMB_ScreenTitle

	// live notification icons, profile label
	Begin Object Class=GUILabel Name=clblProfile1
		StyleName="TextLabel"
		TextColor=(R=161,G=161,B=133,A=255)
		TextAlign=TXTA_Left
		DrawMenuState=1
		bUseTextColorForStyle=true
		bAcceptsInput=false
		bNeverFocus=true
		bTabStop=false
		bDrawToFit=true
		bTransparent=true
		bForceCaps=true
		WinWidth=0.425000
		WinHeight=0.050000
		WinLeft=0.0700
		WinTop=0.7700000
		fTweenChangeTime=0.2
	End Object

	Begin Object Class=GUILabel Name=clblProfile2
		StyleName="TextLabel"
		TextColor=(R=161,G=161,B=133,A=255)
		TextAlign=TXTA_Left
		DrawMenuState=1
		bAcceptsInput=false
		bNeverFocus=true
		bTabStop=false
		bDrawToFit=true
		bTransparent=true
		bForceCaps=true
		WinWidth=0.425000
		WinHeight=0.050000
		WinLeft=0.505000
		WinTop=0.7700000
		fTweenChangeTime=0.2
	End Object

	Begin Object Class=GUILabel Name=clblPlayerName3
		StyleName="TextLabel"
		TextColor=(R=161,G=161,B=133,A=255)
		TextAlign=TXTA_Left
		bUseTextColorForStyle=true
		DrawMenuState=1
		bAcceptsInput=false
		bNeverFocus=true
		bTabStop=false
		bDrawToFit=true
		bTransparent=true
		bForceCaps=true
		WinWidth=0.425000
		WinHeight=0.050000
		WinLeft=0.0700
		WinTop=0.7200000
	End Object

	// top-right (4P)
	Begin Object Class=GUILabel Name=clblPlayerName4
		StyleName="TextLabel"
		TextColor=(R=161,G=161,B=133,A=255)
		TextAlign=TXTA_Left
		bUseTextColorForStyle=true
		DrawMenuState=1
		bAcceptsInput=false
		bNeverFocus=true
		bTabStop=false
		bDrawToFit=true
		bTransparent=true
		bForceCaps=true
		WinWidth=0.425000
		WinHeight=0.050000
		WinLeft=0.505000
		WinTop=0.7200000
	End Object

	bShowProfileLabels=true
	bShowOnlineIcon=false
	lblProfileName(0)=clblProfile1
	lblProfileName(1)=clblProfile2

	// bottom row, help buttons
	Begin Object Class=GUIHelpAButton Name=cMP_hbtnA
		WinLeft=0.500000
		WinTop=0.820000
		Layout=IBL_ICON_TOP
		Align=TXTA_Center
	End Object
	hbtnA=cMP_hbtnA

	Begin Object Class=GUIHelpBButton Name=cMP_hbtnB
		WinLeft=0.73125
		WinTop=0.820000
		Layout=IBL_ICON_TOP
		Align=TXTA_Center
	End Object
	hbtnB=cMP_hbtnB

	Begin Object Class=GUIHelpXButton Name=cMP_hbtnX
		WinLeft=0.0375
		WinTop=0.820000
		Layout=IBL_ICON_TOP
		Align=TXTA_Center
	End Object
	hbtnX=cMP_hbtnX

	Begin Object Class=GUIHelpYButton Name=cMP_hbtnY
		WinLeft=0.26875
		WinTop=0.820000
		Layout=IBL_ICON_TOP
		Align=TXTA_Center
	End Object
	hbtnY=cMP_hbtnY
	
	Begin Object Class=GUIImage Name=cOnlineIcon
		Image=Texture't_interface_mb.hud.ubi_internet'
		ImageColor=(R=255,G=255,B=255,A=255)
		ImageStyle=ISTY_Scaled
		WinWidth=0.048
		WinHeight=0.064
		WinLeft=0.925
		WinTop=0.9
		RenderWeight=0.4
		pulseStyle=CPS_Slow
	End Object
	onlineIcon=cOnlineIcon

	WinWidth=1.0
	WinHeight=1.0
	WinTop=0.0
	WinLeft=0.0
	bHideParent=true

	ScreenTitle=""
	ACaption=""
	BCaption="Back"
	XCaption=""
	YCaption=""
	AHint=""
	BHint=""
	XHint=""
	YHint=""

	StringQuit="Quit"
	StringYes="Yes"
	StringOk="Ok"
	StringNo="No"
	StringCancel="Cancel"
	StringContinue="Continue"
	StringBack="Back"
	StringAny="Any"
	StringDefaults="Defaults"
	StringSelect="Select"
	StringOptions="Options"
	stringJoin="Join Match"
	stringLeave="Leave"
	StrUnReady="UnReady"
	StrReady="Ready"
	StrPlayers="Players List"
	StringBiA="Brothers in Arms Earned in Blood"
	StringDone="Done"
	StringError="Error"
	StringCreateMatch="Create Match"
	StringRefresh="Refresh"

	StringNotSignedIn="Not Signed In"
	StringNotSignedIn_PC="Not Signed In : Pass Code Needed"
	StringSigningIn="Signing In..."
	StringSignedIn="Signed In:"
	StringSignInFailed="Sign-In Failed"
	StringIsGuest="Guest:"
	StringProfile="Profile:"

	StringListNoYes=("No","Yes")
	StringListOffOn=("Off","On")

	bRequireLink=false
	bRequireLive=false
	bDeferControllerLoss=false
	fNextLinkLiveTest=0.0

	PlayerStatus(0)=(MyPlayerIndex=0,MyGamerTag="")
	PlayerStatus(1)=(MyPlayerIndex=1,MyGamerTag="")
	PlayerStatus(2)=(MyPlayerIndex=-1,MyGamerTag="")
	PlayerStatus(3)=(MyPlayerIndex=-1,MyGamerTag="")
	PlayerStatusDisplayStyle=CD_Default
	DefPlayerStatusDisplayStyle=CD_Profile

	// LAYOUT OVERRIDES NOMERGE
	Begin Object Class=GUILabel Name=cCMB_ScreenTitle_Alt
		StyleName="Header"
		TextAlign=TXTA_Center
		Caption=""
		TextColor=(R=255,G=255,B=255,A=255)
		TextStyle=MSTY_Normal
		bUseTextColorForStyle=true
		bAcceptsInput=false
		bNeverFocus=true
		bTabStop=false
		WinWidth=0.9250000
		WinHeight=0.060000
		WinLeft=0.0375000
		WinTop=0.01500000
	End Object

	Begin Object Class=GUIHelpAButton Name=cMP_hbtnA_Alt
		WinLeft=0.500000
		WinTop=0.92500
		WinHeight=0.03000
		Layout=IBL_ICON_TOP
		Align=TXTA_Center
	End Object
	Begin Object Class=GUIHelpBButton Name=cMP_hbtnB_Alt
		WinLeft=0.73125
		WinTop=0.92500
		WinHeight=0.03000
		Layout=IBL_ICON_TOP
		Align=TXTA_Center
	End Object
	Begin Object Class=GUIHelpXButton Name=cMP_hbtnX_Alt
		WinLeft=0.0375
		WinTop=0.92500
		WinHeight=0.03000
		Layout=IBL_ICON_TOP
		Align=TXTA_Center
	End Object
	Begin Object Class=GUIHelpYButton Name=cMP_hbtnY_Alt
		WinLeft=0.26875
		WinTop=0.92500
		WinHeight=0.03000
		Layout=IBL_ICON_TOP
		Align=TXTA_Center
	End Object

	Begin Object Class=GUILabel Name=clblProfile1_Alt
		StyleName="TextLabel"
		TextColor=(R=161,G=161,B=133,A=255)
		TextAlign=TXTA_Left
		DrawMenuState=1
		bUseTextColorForStyle=true
		bAcceptsInput=false
		bNeverFocus=true
		bTabStop=false
		bDrawToFit=true
		bTransparent=true
		bForceCaps=true
		WinWidth=0.425000
		WinHeight=0.050000
		WinLeft=0.0700
		WinTop=0.8700000
		fTweenChangeTime=0.2
	End Object
	Begin Object Class=GUILabel Name=clblProfile2_Alt
		StyleName="TextLabel"
		TextColor=(R=161,G=161,B=133,A=255)
		TextAlign=TXTA_Left
		DrawMenuState=1
		bAcceptsInput=false
		bNeverFocus=true
		bTabStop=false
		bDrawToFit=true
		bTransparent=true
		bForceCaps=true
		WinWidth=0.425000
		WinHeight=0.050000
		WinLeft=0.505000
		WinTop=0.8700000
		fTweenChangeTime=0.2
	End Object
	Begin Object Class=GUILabel Name=clblPlayerName3_Alt
		StyleName="TextLabel"
		TextColor=(R=161,G=161,B=133,A=255)
		TextAlign=TXTA_Left
		bUseTextColorForStyle=true
		DrawMenuState=1
		bAcceptsInput=false
		bNeverFocus=true
		bTabStop=false
		bDrawToFit=true
		bTransparent=true
		bForceCaps=true
		WinWidth=0.425000
		WinHeight=0.050000
		WinLeft=0.0700
		WinTop=0.8400000
	End Object
	Begin Object Class=GUILabel Name=clblPlayerName4_Alt
		StyleName="TextLabel"
		TextColor=(R=161,G=161,B=133,A=255)
		TextAlign=TXTA_Left
		bUseTextColorForStyle=true
		DrawMenuState=1
		bAcceptsInput=false
		bNeverFocus=true
		bTabStop=false
		bDrawToFit=true
		bTransparent=true
		bForceCaps=true
		WinWidth=0.425000
		WinHeight=0.050000
		WinLeft=0.505000
		WinTop=0.8400000
	End Object

	Begin Object Class=GUIEditBox Name=cChatTextEntryEditBox
		StyleName="TextLabel"
		TextStr=""
		WinWidth=1.0
		WinHeight=0.04
		WinLeft=0.0
		WinTop=0.96
		bAlwaysShowCursor=true
	End Object
}
class gbx_ScreenExtendedWork extends gbx_ScreenABXY;

// param1 : ["prompt string"] ["Screen Title"] [PromptWhenDone]
// param2 : [continue menu class]

var() Automated GUILabel		lblTextPrompt;
var localized string			StringAutoTextPrompt;		// automatically filled into lblTextPrompt
var float						MinDisplayTime;				// minimum time to display this dialog
var float						StartTime;
var bool						bPromptWhenDone;			// when work is done, A=Continue prompt shows
var bool						bFinished;
var bool						bStarted;					// wait until we've drawn once before starting
var EComponentPulseStyle		LabelPulseStyle;

Delegate bool DoWork();	// return true if the work is done

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	OnAButtonEvent = OnContinue;

	lblTextPrompt.SetCaption(StringAutoTextPrompt);

	bFinished = false;
	StartTime = PlayerOwner().Level.UniversalTimeSeconds;

	lblTextPrompt.PulseStyle = LabelPulseStyle;
}

function OnContinue()
{
	if (LParam2 != "")
	{
		Controller.ReplaceMenu(LParam2);
	}
	else
	{
		if (bPromptWhenDone)
			BaseOnAButton();
		else
			Controller.CloseMenu(false);
	}
}

function bool ScreenOnDraw(Canvas C)
{
	Super.ScreenOnDraw(C);

	if (!bStarted)
	{
		bStarted = true;
		SetTimer(0.2, true);
	}

	return false;
}

function Timer()
{
	if (bFinished)
	{
		if (bPromptWhenDone)
		{
			SetupAButton(StringContinue);
			KillTimer();
		}
		else if (PlayerOwner().Level.UniversalTimeSeconds - StartTime > MinDisplayTime)
		{
			OnContinue();
		}
	}
	else
	{
		bFinished = DoWork();
	}
}

event HandleParameters(string Param1, string Param2)
{
	local string s;

	Super.HandleParameters(Param1, Param2);

	if (Param1 != "")
	{
		s = ParseToken( Param1 );
		if (s != "")
			lblTextPrompt.SetCaption(s);

		s = ParseToken( Param1 );
		if (s != "")
			SetCaption(s);

		s = ParseToken( Param1 );
		if (s ~= "PromptWhenDone")
			bPromptWhenDone = true;
	}
}

function bool ShouldShowControllerInfo(int index)
{
	return false;
}

function TestLinkLiveLoss(optional bool bOpened)
{
	if (bPromptWhenDone && bFinished)
		Super.TestLinkLiveLoss(bOpened);
}

defaultproperties
{
    ScreenTitle="Please Wait..."
	BCaption=""

	Background=Texture'WhiteTexture'
	BackgroundColor=(R=13,G=5,B=8,A=235)
	BackgroundRStyle=MSTY_Alpha
	bHideParent=false

	StringAutoTextPrompt=""
	bPromptWhenDone=false
	MinDisplayTime=0
	bShowProfileLabels=false
	bDeferControllerLoss=true
	LabelPulseStyle=CPS_None

	Begin Object Class=GUILabel Name=cTextPrompt
		StyleName="LargeButton"
		DrawMenuState=1
		TextAlign=TXTA_Center
		TextAlignV=TXTA_Center
		bAcceptsInput=false;
		bMultiLine=true
		bTabStop=false
		WinWidth=0.800000
		WinHeight=0.50000
		WinLeft=0.100000
		WinTop=0.200000
	End Object
	lblTextPrompt=cTextPrompt
	bTopMost=128
}
class gbx_ScreenLRWB extends gbx_ScreenABXY
	Abstract;

var automated 	GUIHelpButton		hbtnL;
var automated 	GUIHelpButton		hbtnR;
var automated 	GUIHelpButton		hbtnWh;
var automated 	GUIHelpButton		hbtnBl;

var(Menu) localized string			LCaption;
var(Menu) localized string			RCaption;
var(Menu) localized string			WhCaption;
var(Menu) localized string			BlCaption;
var(Menu) localized string			LHint;
var(Menu) localized string			RHint;
var(Menu) localized string			WhHint;
var(Menu) localized string			BlHint;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	// The LRWB will propely call the super for these delegates
	OnPreDraw = ScreenOnPreDraw;
	OnDraw = ScreenOnDraw;
	OnDrawPre = ScreenOnDrawPre;

	OnXControllerEvent=SAB_OnXControllerEvent;

	hbtnL.OnClick = LRScreen_ButtonClick;
	hbtnR.OnClick = LRScreen_ButtonClick;
	hbtnWh.OnClick = LRScreen_ButtonClick;
	hbtnBl.OnClick = LRScreen_ButtonClick;
	
	lblProfileName[0].SetTop(0.70);
	lblProfileName[1].SetTop(0.70);
	hbtnA.SetTop(0.75);
	hbtnB.SetTop(0.75);
	hbtnX.SetTop(0.75);
	hbtnY.SetTop(0.75);

	SetupLButton(LCaption, LHint);
	SetupRButton(RCaption, RHint);
	SetupWhButton(WhCaption, WhHint);
	SetupBlButton(BlCaption, BlHint);
}

// override to provide custom functionality
delegate OnLButtonEvent();
delegate OnRButtonEvent();
delegate OnWhButtonEvent();
delegate OnBlButtonEvent();


function SetupLButton(optional string newCap, optional string newHint) { SetupHelpButton(hBtnL, newCap, newHint); }
function SetupRButton(optional string newCap, optional string newHint) { SetupHelpButton(hBtnR, newCap, newHint); }
function SetupWhButton(optional string newCap, optional string newHint) { SetupHelpButton(hBtnWh, newCap, newHint); }
function SetupBlButton(optional string newCap, optional string newHint) { SetupHelpButton(hBtnBl, newCap, newHint); }



function DrawFocusedControl(Canvas C, optional GUIComponent drawControl, optional int drawDirection, optional int drawController)
{
	// These checks copied from gbx_ScreenABXY so we don't focus on the L, R, White, and Black buttons
	if (drawControl == None)
		drawControl = FocusedControl;

	if ((drawControl == None) || (drawControl == hbtnL) || (drawControl == hbtnR) || (drawControl == hbtnWh) || (drawControl == hbtnBl))
		return;

	Super.DrawFocusedControl( C, drawControl, drawDirection, drawController);
}



function bool ScreenOnPreDraw(Canvas C)
{
	return Super.ScreenOnPreDraw(C);
}

function bool ScreenOnDrawPre(Canvas C)
{
	local float topBarHeight, extra, bottomBarHeight;

	if (!bVisible)
		return false;

	topBarHeight = 0.18 * ActualHeight();
	bottomBarHeight = 0.25 * ActualHeight();
	extra = 0.02 * ActualHeight();


	C.DrawColor = Controller.BackgroundBoxColor;
	C.DrawColor.A = 255;

	C.SetPos(-5.0, -extra);
	C.DrawTileTiledClip(	Texture't_interface_mb.hud.interface_comp', 
							C.ClipX + 10, topBarHeight, 
							284, 128, 128, 128,
							32, 32);

	C.SetPos(-5.0, C.ClipY - bottomBarHeight + extra);
	C.DrawTileTiledClip(	Texture't_interface_mb.hud.interface_comp', 
							C.ClipX + 10, bottomBarHeight, 
							284, 128, 128, 128,
							32, 32);

	return false;	// still do the other stuff
}

function bool ScreenOnDraw(Canvas C)
{
	return Super.ScreenOnDraw(C);
}



// =======================================================================================================================================================
// Input handling
// =======================================================================================================================================================
// if overriding OnXControllerEvent, simply call SAB_OnXControllerEvent as a fallback case
function bool SAB_OnXControllerEvent(byte Id, eXControllerCodes iCode)
{
	Super.SAB_OnXControllerEvent(Id,iCode);
	if (iCode == XC_LeftTrigger)
	{
		if (hbtnL.bVisible && !hbtnL.bDisabled)
		{
			OnLButtonEvent();
			return false;
		}
	}
	else if (iCode == XC_RightTrigger)
	{
		if (hbtnR.bVisible && !hbtnR.bDisabled)
		{
			OnRButtonEvent();
			return true;
		}
	}
	else if (iCode == XC_White)
	{
		if (hbtnWh.bVisible && !hbtnWh.bDisabled)
		{
			OnWhButtonEvent();
			return true;
		}
	}
	else if (iCode == XC_Black)
	{
		if (hbtnBl.bVisible && !hbtnBl.bDisabled)
		{
			OnBlButtonEvent();
			return true;
		}
	}

	return false;
}

function bool LRScreen_ButtonClick(GUIComponent Sender)
{
	local GUIButton Selected;

	Selected = GUIButton(Sender);
	if (Selected == None) return false;

	switch (Selected)
	{
		case hbtnL:
			OnLButtonEvent(); return true; break;
		case hbtnR:
			OnRButtonEvent(); return true; break;
		case hbtnWh:
			OnWhButtonEvent(); return true; break;
		case hbtnBl:
			OnBlButtonEvent(); return true; break;
	}

	return false;
}

defaultproperties
{
	// second-to-bottom row, help buttons
	Begin Object Class=GUIHelpLButton Name=cMP_hbtnL
		WinLeft=0.03750
		WinTop=0.840000
		Layout=IBL_ICON_TOP
		Align=TXTA_Center
	End Object
	hbtnL=cMP_hbtnL

	Begin Object Class=GUIHelpRButton Name=cMP_hbtnR
		WinLeft=0.26875
		WinTop=0.840000
		Layout=IBL_ICON_TOP
		Align=TXTA_Center
	End Object
	hbtnR=cMP_hbtnR

	Begin Object Class=GUIHelpWhButton Name=cMP_hbtnWh
		WinLeft=0.50000
		WinTop=0.840000
		Layout=IBL_ICON_TOP
		Align=TXTA_Center
	End Object
	hbtnWh=cMP_hbtnWh

	Begin Object Class=GUIHelpBlButton Name=cMP_hbtnBl
		WinLeft=0.73125
		WinTop=0.840000
		Layout=IBL_ICON_TOP
		Align=TXTA_Center
	End Object
	hbtnBl=cMP_hbtnBl

	LCaption=""
	RCaption=""
	WhCaption=""
	BlCaption=""
	LHint=""
	RHint=""
	WhHint=""
	BlHint=""
}
class gbx_ScreenQuestion extends gbx_ScreenABXY;

// Param2: <eScreenQuestionType> <eScreenPromptType>

enum eScreenQuestionType
{
	SQT_CUSTOM,		// presumably set up in default properties.  Nothing changes
	SQT_OK,
	SQT_BACK,
	SQT_OKBACK,
	SQT_OKCANCEL,
	SQT_YESNO,
	SQT_YESNOCANCEL,
	SQT_CONTINUEBACK,
	SQT_CONTINUE,
	SQT_CANCEL,
};

enum eScreenPromptType
{
	SPT_NONE,
	SPT_AREYOUSURE,
	SPT_AREYOUSURE_PROGRESS,
};

enum EScreenButtonLayout
{
	SBL_Default,	// default 4-button layout
	SBL_2Centered,	// A and B buttons centered horizontally.  Do not use X,Y with this layout
	SBL_1Centered,	// A button centered horizontally.  Only use A button with this layout.
};

var() Automated GUILabel		lblTextPrompt;
var() eScreenQuestionType		QuestionType;
var() eScreenPromptType			PromptType;
var() localized string			StringAutoTextPrompt;		// automatically filled into lblTextPrompt

var() localized String			StringAreYouSure;
var() localized String			StringProgressLost;

Delegate bool OnAnswer(string answer)
{
	return true;
}

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	OnAButtonEvent = SQ_OnAButton;
	OnBButtonEvent = SQ_OnBButton;
	OnXButtonEvent = SQ_OnXButton;

	SetQuestionType(QuestionType);
}

event HandleParameters(string Param1, string Param2)
{
	local string s;

	Super.HandleParameters(Param1, Param2);

	if (Param2 != "")
	{
		s = ParseToken( Param2 );

		if (s == "OK")					SetQuestionType(SQT_OK);
		else if (s == "BACK")			SetQuestionType(SQT_BACK);
		else if (s == "OKCANCEL")		SetQuestionType(SQT_OKCANCEL);
		else if (s == "OKBACK")			SetQuestionType(SQT_OKBACK);
		else if (s == "YESNO")			SetQuestionType(SQT_YESNO);
		else if (s == "YESNOCANCEL")	SetQuestionType(SQT_YESNOCANCEL);
		else if (s == "CONTINUEBACK")	SetQuestionType(SQT_CONTINUEBACK);
		else if (s == "CONTINUE")		SetQuestionType(SQT_CONTINUE);
		else if (s == "CUSTOM")			SetQuestionType(SQT_CUSTOM);
		else if (s == "CANCEL")			SetQuestionType(SQT_CANCEL);
		
		s = ParseToken( Param2 );
		if (s == "NONE") PromptType = SPT_NONE;
		else if (s == "AREYOUSURE") PromptType = SPT_AREYOUSURE;
		else if (s == "AREYOUSURE_PROGRESS") PromptType = SPT_AREYOUSURE_PROGRESS;
	}


	if (StringAutoTextPrompt != "")
		SetTextPrompt(StringAutoTextPrompt);
}

function SetQuestionType(eScreenQuestionType newQT)
{
	QuestionType = newQT;

	// set up the prompt buttons
	switch(QuestionType)
	{
	case SQT_OK:
		SetupAButton(StringOk);
		SetupBButton();
		SetupXButton();
		break;
	case SQT_BACK:
		SetupAButton();
		SetupBButton(StringBack);
		SetupXButton();
		hBtnB.SetFocus(None);
		break;
	case SQT_OKBACK:
		SetupAButton(StringOk);
		SetupBButton(StringBack);
		SetupXButton();
		hBtnB.SetFocus(None);
		break;
	case SQT_OKCANCEL:
		SetupAButton(StringOk);
		SetupBButton(StringCancel);
		SetupXButton();
		hBtnB.SetFocus(None);
		break;
	case SQT_YESNO:
		SetupAButton(StringYes);
		SetupBButton(StringNo);
		SetupXButton();
		hBtnB.SetFocus(None);
		break;
	case SQT_YESNOCANCEL:
		SetupAButton(StringYes);
		SetupBButton(StringCancel);
		SetupXButton(StringNo);
		hBtnB.SetFocus(None);
		break;
	case SQT_CONTINUEBACK:
		SetupAButton(StringContinue);
		SetupBButton(StringBack);
		SetupXButton();
		hBtnB.SetFocus(None);
		break;
	case SQT_CONTINUE:
		SetupAButton(StringContinue);
		SetupBButton();
		SetupXButton();
		break;
	case SQT_CANCEL:
		SetupAButton();
		SetupBButton(StringCancel);
		SetupXButton();
		hBtnB.SetFocus(None);
		break;

	case SQT_CUSTOM:
		break;
	}
}

function SetTextPrompt(string s)
{
	switch(PromptType)
	{
	case SPT_AREYOUSURE_PROGRESS:
		if ((PlayerOwner().Level.NetMode == NM_Standalone) && !PlayerOwner().Level.IsMenuMap())
			s = s @ StringProgressLost;

	// fall on through
	case SPT_AREYOUSURE:
		s = s @ StringAreYouSure;
		break;
	}

	lblTextPrompt.Caption = s;

	ReplacePromptText("<TITLENAME>", StringBiA);
}

function SetButtonLayout(EScreenButtonLayout newButtonLayout)
{
	switch(newButtonLayout)
	{
	case SBL_Default:
		hbtnA.SetLeft(default.hBtnA.WinLeft);
		hbtnA.SetWidth(default.hBtnA.WinWidth);
		hbtnB.SetLeft(default.hBtnB.WinLeft);
		hbtnB.SetWidth(default.hbtnB.WinWidth);
		break;
	case SBL_2Centered:
		hbtnA.SetLeft(0.1);
		hbtnA.SetWidth(0.35);
		hbtnB.SetLeft(0.55);
		hbtnB.SetWidth(0.35);
		break;
	case SBL_1Centered:
		hbtnA.SetLeft(0.3);
		hbtnA.SetWidth(0.40);
		break;
	}
}

function ReplacePromptText(string Replace, string With)
{
    ReplaceText( lblTextPrompt.Caption, Replace, With );
}

final function SQ_OnAButton()
{
	local bool result;

	result = true;
	switch(QuestionType)
	{
	case SQT_OKCANCEL:
	case SQT_OK:
	case SQT_OKBACK:
		result = OnAnswer("OK");
		break;
	case SQT_YESNO:
	case SQT_YESNOCANCEL:
		result = OnAnswer("YES");
		break;
	case SQT_CONTINUE:
	case SQT_CONTINUEBACK:
		result = OnAnswer("CONTINUE");
		break;

	case SQT_CANCEL:
	case SQT_CUSTOM:
		result = OnAnswer("A");
		break;
	}

	if (result)
		BaseOnAButton();
}
final function SQ_OnBButton()
{
	local bool result;

	result = true;
	switch(QuestionType)
	{
	case SQT_CANCEL:
	case SQT_OKCANCEL:
	case SQT_YESNOCANCEL:
		result = OnAnswer("CANCEL");
		break;
	case SQT_YESNO:
		result = OnAnswer("NO");
		break;
	case SQT_BACK:
	case SQT_CONTINUEBACK:
	case SQT_OKBACK:
		result = OnAnswer("BACK");
		break;

	case SQT_OK:
	case SQT_CUSTOM:
	case SQT_CONTINUE:
		result = OnAnswer("B");
		break;
	}

	if (result)
		BaseOnBButton();
}
final function SQ_OnXButton()
{
	local bool result;

	result = true;
	switch(QuestionType)
	{
	case SQT_YESNOCANCEL:
		result = OnAnswer("NO");
		break;

	case SQT_CANCEL:
	case SQT_CONTINUEBACK:
	case SQT_YESNO:
	case SQT_OKCANCEL:
	case SQT_OKBACK:
	case SQT_OK:
	case SQT_CUSTOM:
	case SQT_CONTINUE:
		result = OnAnswer("X");
		break;
	}

	if (result)
		Controller.CloseMenu(false);
}

function bool ShouldShowControllerInfo(int inPlayerIndex)
{
	return false;
}

defaultproperties
{
    ScreenTitle="Please Confirm"

	Background=Texture'WhiteTexture'
	BackgroundColor=(R=13,G=5,B=8,A=235)
	BackgroundRStyle=MSTY_Alpha
	bHideParent=false

	Begin Object Class=GUILabel Name=cTextPrompt
		StyleName="LargeButton"
		DrawMenuState=1
		TextAlign=TXTA_Center
		TextAlignV=TXTA_Center
		bAcceptsInput=false;
		bMultiLine=true
		bTabStop=false
		WinWidth=0.800000
		WinHeight=0.50000
		WinLeft=0.100000
		WinTop=0.200000
	End Object
	lblTextPrompt=cTextPrompt

    StringAreYouSure="Are you sure?"
	StringProgressLost="Progress will only be saved up to the last checkpoint."

	BCaption=""
	QuestionType=SQT_Custom
	PromptType=SPT_None
	StringAutoTextPrompt=""
}class gbx_ScreenTextEntry extends gbx_ScreenABXY;

var Automated GUIEditBox					editText;
var string									strInputMode;


var string									strBadCharsFileName;
var string									strBadCharsUserName;
var string									strBadCharsPassword;

delegate EntryFinished(string currentString, bool bCancelled);
delegate bool VerifyInput(string currentString, string newChar) {return true;}



function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	OnClose = ScreenOnClose;
}

event HandleParameters(string Param1, string Param2)
{
	local string s, newText;

	Super.HandleParameters(Param1, Param2);

	s = ParseToken( Param1 );
	newText = s;

	s = ParseToken( Param1 );

	editText.MaxWidth = int(s);
	editText.SetText(newText);

	strInputMode = Param2;
	if (strInputMode != "")
	{
		if (strInputMode == "PROFILE")
		{
			GUILog("gbx_ScreenTextEntry using profile naming rules");
			VerifyInput = VI_Profilename;
		}
		else if (strInputMode == "FILE")
		{
			GUILog("gbx_ScreenTextEntry using file naming rules");
			VerifyInput = VI_Filename;
		}
		else
		{
			strInputMode = "";
		}
	}
}

function ScreenOnClose(optional Bool bCancelled)
{
	EntryFinished(GetText(), bCancelled);
}

static function bool VI_Filename(string currentString, string newChar)
{
	local int ascChr;

	newChar = Left(newChar,1);

	if (InStr(default.strBadCharsFileName $ "\"", newChar) != -1)
		return false;

	ascChr = Asc(newChar);
	if ((ascChr <= 31) || (ascChr >= 128))
		return false;

	return true;
}

static function bool VI_Profilename(string currentString, string newChar)
{
	local int ascChr;

	newChar = Left(newChar,1);

	if (InStr(default.strBadCharsFileName $ "\"# .", newChar) != -1)
		return false;

	ascChr = Asc(newChar);
	if (ascChr <= 31)
		return false;

	return true;
}

function bool DoInputVerify(string newChar)
{
	if (newChar == "")
		return false;

	return VerifyInput(GetText(), newChar);
}

function string GetText()
{
	return editText.TextStr;
}

defaultproperties
{
	PagePlayerIndex=-3
	ScreenTitle="Enter Text"
	BCaption="Cancel"

	Begin Object Class=GUIEditBox Name=cTextEntryEditBox
		TextStr=""
		WinWidth=0.8125
		WinHeight=0.070000
		WinLeft=0.09375
		WinTop=0.22500000
	End Object
	editText=cTextEntryEditBox

	strBadCharsFileName="<>=?:;*+,/\\|"
	strBadCharsUserName=""
	strBadCharsPassword=""
}
class gbx_ScreenTextEntryPC extends gbx_ScreenTextEntry;


function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	OnAButtonEvent = BaseOnAButton;
}

event HandleParameters(string Param1, string Param2)
{
	Super.HandleParameters(Param1, Param2);
	
	if (strInputMode != "")
	{
		editText.VerifyInput = VerifyInput;
	}
}

defaultproperties
{
	ACaption="Done"
}
class gbx_ScreenTextEntryXbox extends gbx_ScreenTextEntry;

/*
	<Prompt :>

	| edit text area								 |

	 --- --- --- --- --- --- --- --- --- ---
	| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 0 |
	 -------- --- --- --- --- --- --- --- -- --------
	| a | b | c | d | e | f | g | h | i | j |Symbols |
	 -------- --- --- --- --- --- --- --- -- --------
	| k | l | m | n | o | p | q | r | s | t |  Caps  |
	 -------- --- --- --- --- --- --- ------ --------
	| u | v | w | x | y | z |  <=   |  =>   | Shift  |
	 -------- --- --- --- --- --- --- ------ --------
	|         Space         |   Backspace   |  Done  |
     ----------------------- ------- ------- --------
*/

// Param1 = [default string] [max length]
// Param2 = prompt string

var Automated array<GUIButton>				vkbButtons1;
var Automated array<GUIButton>				vkbButtons2;
var Automated array<GUIButton>				vkbButtons3;
var Automated array<GUIButton>				vkbButtons4;
var Automated array<GUIButton>				vkbButtons5;

var GUIButton								vkbButtonDone;
var GUIButton								vkbButtonAccents;
var GUIButton								vkbButtonSymbols;
var GUIButton								vkbButtonCaps;
var GUIButton								vkbButtonShift;
var GUIButton								vkbButtonSpace;
var GUIButton								vkbButtonBackspace;
var GUIButton								vkbButtonLeft;
var GUIButton								vkbButtonRight;

// character tables
var localized array<string>					vkbCharsNormal1;
var localized array<string>					vkbCharsNormal2;
var localized array<string>					vkbCharsNormal3;
var localized array<string>					vkbCharsNormal4;

var localized array<string>					vkbCharsShift1;
var localized array<string>					vkbCharsShift2;
var localized array<string>					vkbCharsShift3;
var localized array<string>					vkbCharsShift4;

var localized array<string>					vkbCharsCaps1;
var localized array<string>					vkbCharsCaps2;
var localized array<string>					vkbCharsCaps3;
var localized array<string>					vkbCharsCaps4;

var localized array<string>					vkbCharsSymbols1;
var localized array<string>					vkbCharsSymbols2;
var localized array<string>					vkbCharsSymbols3;
var localized array<string>					vkbCharsSymbols4;
var localized array<string>					vkbCharsShiftSymbols1;
var localized array<string>					vkbCharsShiftSymbols2;
var localized array<string>					vkbCharsShiftSymbols3;
var localized array<string>					vkbCharsShiftSymbols4;

var localized array<string>					vkbCharsAccents1;
var localized array<string>					vkbCharsAccents2;
var localized array<string>					vkbCharsAccents3;
var localized array<string>					vkbCharsAccents4;
var localized array<string>					vkbCharsShiftAccents1;
var localized array<string>					vkbCharsShiftAccents2;
var localized array<string>					vkbCharsShiftAccents3;
var localized array<string>					vkbCharsShiftAccents4;

var localized string						vkbStringDone;
var localized string						vkbStringAccents;
var localized string						vkbStringSymbols;
var localized string						vkbStringCaps;
var localized string						vkbStringShift;
var localized string						vkbStringSpace;
var localized string						vkbStringBackspace;
var localized string						vkbStringLeft;
var localized string						vkbStringRight;

// which bank to display
var bool									bShift, bCaps, bSymbols, bAccents;
var bool									bUseSymbols, bUseAccents;

var float									vkbButtonTop1;	// in winTop style coords
var float									vkbButtonTop2;
var float									vkbButtonTop3;
var float									vkbButtonTop4;
var float									vkbButtonTop5;
var float									vkbButtonPivot;
var float									vkbButtonSpacing;

var int										iLastFocusKeyRow, iLastFocusKeyCol;
var int										iLastAlphaKeyCol;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	OnXButtonEvent = OnBackspace;
	OnYButtonEvent = OnShift;
	OnKeyType = InternalOnKeyType;

	// no focusing the edit box!
	editText.bNeverFocus = true;
	editText.bAlwaysShowCursor = true;

	LayoutControlArray(vkbButtons1, vkbButtonPivot, vkbButtonSpacing, LA_Left_Top, LO_Horizontal);
	LayoutControlArray(vkbButtons2, vkbButtonPivot, vkbButtonSpacing, LA_Left_Top, LO_Horizontal);
	LayoutControlArray(vkbButtons3, vkbButtonPivot, vkbButtonSpacing, LA_Left_Top, LO_Horizontal);
	LayoutControlArray(vkbButtons4, vkbButtonPivot, vkbButtonSpacing, LA_Left_Top, LO_Horizontal);
	LayoutControlArray(vkbButtons5, vkbButtonPivot, vkbButtonSpacing, LA_Left_Top, LO_Horizontal);

	SetArrayTop(vkbButtons1, vkbButtonTop1);
	SetArrayTop(vkbButtons2, vkbButtonTop2);
	SetArrayTop(vkbButtons3, vkbButtonTop3);
	SetArrayTop(vkbButtons4, vkbButtonTop4);
	SetArrayTop(vkbButtons5, vkbButtonTop5);

	vkbButtonAccents = vkbButtons1[10];

	vkbButtonSymbols = vkbButtons2[10];
	vkbButtonCaps = vkbButtons3[10];

	vkbButtonLeft = vkbButtons4[6];
	vkbButtonRight = vkbButtons4[7];
	vkbButtonShift = vkbButtons4[8];

	vkbButtonSpace = vkbButtons5[0];
	vkbButtonBackspace = vkbButtons5[1];
	vkbButtonDone = vkbButtons5[2];

	// set up the vertical links for our special buttons
	vkbButtonAccents.LinkOverrides[0] = vkbButtonDone;
	vkbButtonAccents.LinkOverrides[1] = vkbButtonSymbols;
	vkbButtonSymbols.LinkOverrides[0] = vkbButtonAccents;
	vkbButtonSymbols.LinkOverrides[1] = vkbButtonCaps;
	vkbButtonCaps.LinkOverrides[0] = vkbButtonSymbols;
	vkbButtonCaps.LinkOverrides[1] = vkbButtonShift;
	vkbButtonShift.LinkOverrides[0] = vkbButtonCaps;
	vkbButtonShift.LinkOverrides[1] = vkbButtonDone;
	vkbButtonDone.LinkOverrides[0] = vkbButtonShift;
	vkbButtonDone.LinkOverrides[1] = vkbButtonAccents;

	bUseSymbols = StringListHasEntry(vkbCharsSymbols1) && StringListHasEntry(vkbCharsSymbols2) && StringListHasEntry(vkbCharsSymbols3) && StringListHasEntry(vkbCharsSymbols4);
	bUseAccents = StringListHasEntry(vkbCharsAccents1) && StringListHasEntry(vkbCharsAccents2) && StringListHasEntry(vkbCharsAccents3) && StringListHasEntry(vkbCharsAccents4);

	if (!bUseSymbols)
		vkbButtonSymbols.Hide();
	if (!bUseAccents)
		vkbButtonAccents.Hide();

	SetupXButton(vkbStringBackspace);
	SetupYButton(vkbStringShift);

	MapControls();
	vkbButtonDone.SetFocus(None);
}

event HandleParameters(string Param1, string Param2)
{
	Super.HandleParameters(Param1, Param2);
	UpdateArrayCaptions();
}

function SetArrayTop(out array<GUIComponent> list, float fTop)
{
	local int i;
	for (i=0; i<list.Length; i++)
	{
		list[i].WinTop = fTop;
		list[i].OnClick = vkbButtonClick;

		// set up the horizontal links
		if (i == 0)
		{
			list[i].LinkOverrides[2] = list[list.Length-1];
			list[i].LinkOverrides[3] = list[i+1];
		}
		else if (i == list.Length-1)
		{
			list[i].LinkOverrides[2] = list[i-1];
			list[i].LinkOverrides[3] = list[0];
		}
		else
		{
			list[i].LinkOverrides[2] = list[i-1];
			list[i].LinkOverrides[3] = list[i+1];
		}
	}
}

function string FilterCharacter(string inChar)
{
	if (inChar ~= "<QUOT>")
		inChar = "\"";
	return inChar;
}

function SetArrayCaptions(out array<GUIComponent> list, out array<string> captions)
{
	local int i, c;
	local string s;

	c = Min(list.Length, captions.Length);
	for (i=0; i<c; i++)
	{
		s = FilterCharacter(captions[i]);
		list[i].SetCaption(s);
		list[i].EnableControl(DoInputVerify(s));
	}
}

function SetSpecialButtonCaptions()
{
	vkbButtonDone.SetCaption(vkbStringDone);
	vkbButtonAccents.SetCaption(vkbStringAccents);
	vkbButtonSymbols.SetCaption(vkbStringSymbols);
	vkbButtonCaps.SetCaption(vkbStringCaps);
	vkbButtonShift.SetCaption(vkbStringShift);
	vkbButtonBackspace.SetCaption(vkbStringBackspace);
	vkbButtonLeft.SetCaption(vkbStringLeft);
	vkbButtonRight.SetCaption(vkbStringRight);

	vkbButtonSpace.SetCaption(vkbStringSpace);
	vkbButtonSpace.EnableControl(DoInputVerify(" "));
}

function bool FindControlInRow(GUIComponent control, int rowIndex, out int index)
{
	local int i;
	local array<GUIComponent> list;

	GetButtonList(list, rowIndex);
	index = -1;
	for (i=0; i<list.Length; i++)
	{
		if (list[i] == control)
		{
			index = i;
			break;
		}
	}

	return index != -1;
}

function GetButtonList(out array<GUIComponent> result, int rowIndex)
{
	switch(rowIndex)
	{
	case 0: result = vkbButtons1; break;
	case 1: result = vkbButtons2; break;
	case 2: result = vkbButtons3; break;
	case 3: result = vkbButtons4; break;
	case 4: result = vkbButtons5; break;
	}
}

function bool FindControl(GUIComponent control, out int lineIndex, out int colIndex)
{
	local int i, found;

	if (control != None)
	{
		for (i=0; i<5; i++)
		{
			if (FindControlInRow(control, i, found))
			{
				lineIndex = i;
				colIndex = found;
				return true;
			}
		}
	}

	lineIndex = -1;
	colIndex = -1;
	return false;
}

function GUIComponent GetKeyInRow(out array<GUIComponent> list, int colIndex)
{
	if ((colIndex < list.Length) && (colIndex >= 0))
		return list[colIndex];
}

function GUIComponent GetAlphaKeyInColumn(int colIndex, bool bStartFromTop)
{
	local GUIComponent result;

	if (bStartFromTop)
	{
		result = GetKeyInRow(vkbButtons1, colIndex);
		if ((result != None) && IsAlphaKey(result) && !result.bDisabled && result.bVisible)
			return result;
		result = GetKeyInRow(vkbButtons2, colIndex);
		if ((result != None) && IsAlphaKey(result) && !result.bDisabled && result.bVisible)
			return result;
		result = GetKeyInRow(vkbButtons3, colIndex);
		if ((result != None) && IsAlphaKey(result) && !result.bDisabled && result.bVisible)
			return result;
		result = GetKeyInRow(vkbButtons4, colIndex);
		if ((result != None) && IsAlphaKey(result) && !result.bDisabled && result.bVisible)
			return result;
	}
	else
	{
		result = GetKeyInRow(vkbButtons4, colIndex);
		if ((result != None) && IsAlphaKey(result) && !result.bDisabled && result.bVisible)
			return result;
		result = GetKeyInRow(vkbButtons3, colIndex);
		if ((result != None) && IsAlphaKey(result) && !result.bDisabled && result.bVisible)
			return result;
		result = GetKeyInRow(vkbButtons2, colIndex);
		if ((result != None) && IsAlphaKey(result) && !result.bDisabled && result.bVisible)
			return result;
		result = GetKeyInRow(vkbButtons1, colIndex);
		if ((result != None) && IsAlphaKey(result) && !result.bDisabled && result.bVisible)
			return result;
	}

	return None;
}

function bool IsAlphaKey(GUIComponent control)
{
	return !((control == vkbButtonDone) || (control == vkbButtonAccents) || (control == vkbButtonSymbols) || (control == vkbButtonCaps) ||
			(control == vkbButtonShift) || (control == vkbButtonSpace) || (control == vkbButtonBackspace) || (control == vkbButtonBackspace) ||
			(control == vkbButtonLeft) || (control == vkbButtonRight));
}

function DrawArrayBackgrounds(Canvas C, out array<GUIComponent> list)
{
	local int i;
	local Color oldColor;

	for (i=0; i<list.Length; i++)
	{
		if (!list[i].bVisible)
			continue;

		if (list[i] == FocusedControl)
		{
			oldColor = C.DrawColor;
			C.DrawColor = Controller.RedLineColor;
			C.DrawColor.A = oldColor.A;
			
			list[i].DrawComponentBackground(C, 2.0, 2.0);

			C.DrawColor = oldColor;
		}

		if ((GUIButton(list[i]).Caption == "") || (list[i].bDisabled))
		{
			oldColor = C.DrawColor;
			C.DrawColor.A = 120;

			list[i].DrawComponentBackground(C);

			C.DrawColor = oldColor;
		}
		else
		{
			list[i].DrawComponentBackground(C);
		}
	}
}

function bool ScreenOnDrawPre(Canvas C)
{
	C.SetDrawColor(250,218,77,220);

	if (bShift)
	{
		vkbButtonShift.DrawComponentBackground(C, 2.0, 2.0);
	}
	if (bCaps)
	{
		vkbButtonCaps.DrawComponentBackground(C, 2.0, 2.0);
	}
	if (bSymbols)
	{
		vkbButtonSymbols.DrawComponentBackground(C, 2.0, 2.0);
	}
	if (bAccents)
	{
		vkbButtonAccents.DrawComponentBackground(C, 2.0, 2.0);
	}

	C.DrawColor = Controller.BackgroundBoxColor;
	DrawArrayBackgrounds(C,vkbButtons1);
	DrawArrayBackgrounds(C,vkbButtons2);
	DrawArrayBackgrounds(C,vkbButtons3);
	DrawArrayBackgrounds(C,vkbButtons4);
	DrawArrayBackgrounds(C,vkbButtons5);

	return Super.ScreenOnDrawPre(C);
}

/*
function bool ScreenOnDraw(Canvas C)
{
	local float X, Y, XL;

	if ((FocusedControl != None) && (FocusedControl != hbtnA) && (FocusedControl != hbtnB) && (FocusedControl != hbtnX) && (FocusedControl != hbtnY))
	{
		XL = HorizontalOffset(0.003125);
		X = FocusedControl.HorizontalOffset(0) - XL;
		XL = XL + FocusedControl.HorizontalOffset(1) - X;
		Y = FocusedControl.VerticalOffset(1.0);

		DrawTheThinRedLine(Controller, C, X, Y, XL);
	}

	return Super.ScreenOnDraw(C);	// still do the other stuff
}
*/
function UpdateArrayCaptions()
{
	if (bSymbols)
	{
		if (bShift)
		{
			if (StringListHasEntry(vkbCharsShiftSymbols1))
				SetArrayCaptions(vkbButtons1, vkbCharsShiftSymbols1);
			else
				SetArrayCaptions(vkbButtons1, vkbCharsSymbols1);

			if (StringListHasEntry(vkbCharsShiftSymbols2))
				SetArrayCaptions(vkbButtons2, vkbCharsShiftSymbols2);
			else
				SetArrayCaptions(vkbButtons2, vkbCharsSymbols2);

			if (StringListHasEntry(vkbCharsShiftSymbols3))
				SetArrayCaptions(vkbButtons3, vkbCharsShiftSymbols3);
			else
				SetArrayCaptions(vkbButtons3, vkbCharsSymbols3);

			if (StringListHasEntry(vkbCharsShiftSymbols4))
				SetArrayCaptions(vkbButtons4, vkbCharsShiftSymbols4);
			else
				SetArrayCaptions(vkbButtons4, vkbCharsSymbols4);
		}
		else
		{
			SetArrayCaptions(vkbButtons1, vkbCharsSymbols1);
			SetArrayCaptions(vkbButtons2, vkbCharsSymbols2);
			SetArrayCaptions(vkbButtons3, vkbCharsSymbols3);
			SetArrayCaptions(vkbButtons4, vkbCharsSymbols4);
		}
	}
	else if (bAccents)
	{
		if (bShift ^^ bCaps)
		{
			if (StringListHasEntry(vkbCharsShiftAccents1))
				SetArrayCaptions(vkbButtons1, vkbCharsShiftAccents1);
			else
				SetArrayCaptions(vkbButtons1, vkbCharsAccents1);

			if (StringListHasEntry(vkbCharsShiftAccents2))
				SetArrayCaptions(vkbButtons2, vkbCharsShiftAccents2);
			else
				SetArrayCaptions(vkbButtons2, vkbCharsAccents2);

			if (StringListHasEntry(vkbCharsShiftAccents3))
				SetArrayCaptions(vkbButtons3, vkbCharsShiftAccents3);
			else
				SetArrayCaptions(vkbButtons3, vkbCharsAccents3);

			if (StringListHasEntry(vkbCharsShiftAccents4))
				SetArrayCaptions(vkbButtons4, vkbCharsShiftAccents4);
			else
				SetArrayCaptions(vkbButtons4, vkbCharsAccents4);
		}
		else
		{
			SetArrayCaptions(vkbButtons1, vkbCharsAccents1);
			SetArrayCaptions(vkbButtons2, vkbCharsAccents2);
			SetArrayCaptions(vkbButtons3, vkbCharsAccents3);
			SetArrayCaptions(vkbButtons4, vkbCharsAccents4);
		}
	}
	else if (bShift && bCaps)
	{
		SetArrayCaptions(vkbButtons1, vkbCharsShift1);
		SetArrayCaptions(vkbButtons2, vkbCharsNormal2);
		SetArrayCaptions(vkbButtons3, vkbCharsNormal3);
		SetArrayCaptions(vkbButtons4, vkbCharsNormal4);
	}
	else if (bShift)
	{
		SetArrayCaptions(vkbButtons1, vkbCharsShift1);
		SetArrayCaptions(vkbButtons2, vkbCharsShift2);
		SetArrayCaptions(vkbButtons3, vkbCharsShift3);
		SetArrayCaptions(vkbButtons4, vkbCharsShift4);
	}
	else if (bCaps)
	{
		SetArrayCaptions(vkbButtons1, vkbCharsCaps1);
		SetArrayCaptions(vkbButtons2, vkbCharsCaps2);
		SetArrayCaptions(vkbButtons3, vkbCharsCaps3);
		SetArrayCaptions(vkbButtons4, vkbCharsCaps4);
	}
	else
	{
		SetArrayCaptions(vkbButtons1, vkbCharsNormal1);
		SetArrayCaptions(vkbButtons2, vkbCharsNormal2);
		SetArrayCaptions(vkbButtons3, vkbCharsNormal3);
		SetArrayCaptions(vkbButtons4, vkbCharsNormal4);
	}

	SetSpecialButtonCaptions();
}

function bool StringListHasEntry(out array<string> captions)
{
	local int i;

	for (i=0; i<captions.Length; i++)
	{
		if (captions[i] != "")
			return true;
	}

	return false;
}

function bool vkbButtonClick(GUIComponent Sender)
{
	if (GUIButton(Sender) == None)
		return false;

	if (Sender == vkbButtonDone)
	{
		Controller.CloseMenu(false);
		return true;
	}
	else if (Sender == vkbButtonAccents)
	{
		bSymbols = false;
		bAccents = !bAccents;
		UpdateArrayCaptions();
	}
	else if (Sender == vkbButtonSymbols)
	{
		bAccents = false;
		bSymbols = !bSymbols;
		UpdateArrayCaptions();
	}
	else if (Sender == vkbButtonCaps)
	{
		bCaps = !bCaps;
		UpdateArrayCaptions();
	}
	else if (Sender == vkbButtonShift)
	{
		bShift = !bShift;
		UpdateArrayCaptions();
	}
	else if (Sender == vkbButtonSpace)
	{
		editText.AddChar( " " );
	}
	else if (Sender == vkbButtonBackspace)
	{
		editText.DoBackspace();
	}
	else if (Sender == vkbButtonLeft)
	{
		editText.DoCursorLeft();
	}
	else if (Sender == vkbButtonRight)
	{
		editText.DoCursorRight();
	}
	else
	{
		editText.AddChar( GUIButton(Sender).Caption );

		// undo shift if it's pressed
		if (bShift)
		{
			bShift = !bShift;
			UpdateArrayCaptions();
		}
	}

	Controller.PlayClickSound(EClickSound.CS_Change);

	return true;
}

function OnBackspace()
{
	Controller.PlayClickSound(EClickSound.CS_Change);
	editText.DoBackspace();
}

function OnShift()
{
	Controller.PlayClickSound(EClickSound.CS_Change);
	bShift = !bShift;
	UpdateArrayCaptions();
}


function bool InternalOnKeyType(out byte Key, optional string Unicode)
{
	return editText.OnKeyType(Key, Unicode);
}

function GUIComponent vkbButtonCursor(GUIComponent start, eXControllerCodes iCode)
{
	local GUIComponent result;
	local int iRow, iCol;
	local array<GUIComponent> list;

	if (GUIButton(start) == None)
		return None;

	if (start == vkbButtonDone)
	{
		switch(iCode)
		{
		case XC_PadUp:
			result = vkbButtonShift;
			break;
		case XC_PadDown:
			result = vkbButtonAccents;
			break;
		case XC_PadLeft:
			result = vkbButtonBackspace;
			break;
		case XC_PadRight:
			result = vkbButtonSpace;
			break;
		}
	}
	else if (start == vkbButtonAccents)
	{
		switch(iCode)
		{
		case XC_PadUp:
			result = vkbButtonDone;
			break;
		case XC_PadDown:
			result = vkbButtonSymbols;
			break;
		case XC_PadLeft:
			result = vkbButtons1[9];
			break;
		case XC_PadRight:
			result = vkbButtons1[0];
			break;
		}
	}
	else if (start == vkbButtonSymbols)
	{
		switch(iCode)
		{
		case XC_PadUp:
			result = vkbButtonAccents;
			break;
		case XC_PadDown:
			result = vkbButtonCaps;
			break;
		case XC_PadLeft:
			result = vkbButtons2[9];
			break;
		case XC_PadRight:
			result = vkbButtons2[0];
			break;
		}
	}
	else if (start == vkbButtonCaps)
	{
		switch(iCode)
		{
		case XC_PadUp:
			result = vkbButtonSymbols;
			break;
		case XC_PadDown:
			result = vkbButtonShift;
			break;
		case XC_PadLeft:
			result = vkbButtons3[9];
			break;
		case XC_PadRight:
			result = vkbButtons3[0];
			break;
		}
	}
	else if (start == vkbButtonShift)
	{
		switch(iCode)
		{
		case XC_PadUp:
			result = vkbButtonCaps;
			break;
		case XC_PadDown:
			result = vkbButtonDone;
			break;
		case XC_PadLeft:
			result = vkbButtonRight;
			break;
		case XC_PadRight:
			result = vkbButtons4[0];
			break;
		}
	}
	else if (start == vkbButtonSpace)
	{
		switch(iCode)
		{
		case XC_PadUp:
			if ((iLastAlphaKeyCol >= 0) && (iLastAlphaKeyCol <= 5))
				result = vkbButtons4[iLastAlphaKeyCol];
			else
				result = vkbButtons4[0];
			break;
		case XC_PadDown:
			if ((iLastAlphaKeyCol >= 0) && (iLastAlphaKeyCol <= 5))
				result = vkbButtons1[iLastAlphaKeyCol];
			else
				result = vkbButtons1[0];
			break;
			break;
		case XC_PadLeft:
			result = vkbButtonDone;
			break;
		case XC_PadRight:
			result = vkbButtonBackspace;
			break;
		}
	}
	else if (start == vkbButtonBackspace)
	{
		switch(iCode)
		{
		case XC_PadUp:
			if ((iLastAlphaKeyCol >= 8) && (iLastAlphaKeyCol <= 9))
				result = vkbButtonRight;
			else
				result = vkbButtonLeft;
			break;
		case XC_PadDown:
			if ((iLastAlphaKeyCol >= 6) && (iLastAlphaKeyCol <= 9))
				result = vkbButtons1[iLastAlphaKeyCol];
			else
				result = vkbButtons1[6];
			break;
		case XC_PadLeft:
			result = vkbButtonSpace;
			break;
		case XC_PadRight:
			result = vkbButtonDone;
			break;
		}
	}
	else if (start == vkbButtonLeft)
	{
		switch(iCode)
		{
		case XC_PadUp:
			if (iLastAlphaKeyCol == 7)
				result = vkbButtons3[iLastAlphaKeyCol];
			else
				result = vkbButtons3[6];
			break;
		case XC_PadDown:
			result = vkbButtonBackspace;
			break;
		case XC_PadLeft:
			result = vkbButtons4[5];
			break;
		case XC_PadRight:
			result = vkbButtonRight;
			break;
		}
	}
	else if (start == vkbButtonRight)
	{
		switch(iCode)
		{
		case XC_PadUp:
			if (iLastAlphaKeyCol == 9)
				result = vkbButtons3[iLastAlphaKeyCol];
			else
				result = vkbButtons3[8];
			break;
		case XC_PadDown:
			result = vkbButtonBackspace;
			break;
		case XC_PadLeft:
			result = vkbButtonLeft;
			break;
		case XC_PadRight:
			result = vkbButtonShift;
			break;
		}
	}
	else if (FindControl(start, iRow, iCol))
	{
		GetButtonList(list, iRow);
		switch(iCode)
		{
		case XC_PadUp:
			if (iRow == 0)
			{
				if ((iCol >= 0) && (iCol <= 5))
					result = vkbButtonSpace;
				else
					result = vkbButtonBackspace;
			}
			else
			{
				GetButtonList(list, iRow-1);
				result = list[iCol];
			}
			break;
		case XC_PadDown:
			if ((iRow == 3) && (iCol >= 0) && (iCol <= 5))
			{
				result = vkbButtonSpace;
			}
			else if ((iRow == 2) && (iCol >= 6) && (iCol <= 7))
			{
				result = vkbButtonLeft;
			}
			else if ((iRow == 2) && (iCol >= 8) && (iCol <= 9))
			{
				result = vkbButtonRight;
			}
			else
			{
				GetButtonList(list, iRow+1);
				result = list[iCol];
			}
			break;
		case XC_PadLeft:
			iCol--;
			if (iCol < 0) iCol = list.Length-1;
			result = list[iCol];
			break;
		case XC_PadRight:
			iCol++;
			if (iCol >= list.Length) iCol = 0;
			result = list[iCol];
			break;
		}
	}

	if (result != None)
	{
		if (result.bDisabled || !result.bVisible)
			result = vkbButtonCursor(result, iCode);
	}

	return result;
}


function bool SAB_OnXControllerEvent(byte Id, eXControllerCodes iCode)
{
	local GUIComponent comp;

	switch(iCode)
	{
	case XC_PadUp:
	case XC_PadDown:
	case XC_PadLeft:
	case XC_PadRight:
		comp = vkbButtonCursor(FocusedControl, iCode);
		if (comp != None)
		{
			comp.SetFocus(None);
		}
		return true;
	}

	return Super.SAB_OnXControllerEvent(Id, iCode);
}

event SetFocus(GUIComponent Who)
{
	Super.SetFocus(Who);

	FindControl(FocusedControl, iLastFocusKeyRow, iLastFocusKeyCol);

	// ok this is weird but we need to force the last alpha key if we come to one of the arrow buttons
	if ((FocusedControl == vkbButtonLeft) && ((iLastAlphaKeyCol < 6) || (iLastAlphaKeyCol > 7)))
	{
		iLastAlphaKeyCol = 6;
	}
	else if ((FocusedControl == vkbButtonRight) && ((iLastAlphaKeyCol < 8) || (iLastAlphaKeyCol > 9)))
	{
		iLastAlphaKeyCol = 8;
	}
	else if ((iLastFocusKeyCol == -1) || IsAlphaKey(FocusedControl))
	{
		iLastAlphaKeyCol = iLastFocusKeyCol;
	}

	GUILog("FocusedControl=" $GUIButton(FocusedControl).Caption $" LastAlphaKeyCol=" $iLastAlphaKeyCol $" iLastFocusKeyRow=" $iLastFocusKeyRow $" iLastFocusKeyCol=" $iLastFocusKeyCol);
}

defaultproperties
{
	ACaption="Select"

	Begin Object Class=GUIButton Name=cvkbBtnSmall
		StyleName="MenuOptionCaption"
		WinWidth=0.0625		// 40pix
		WinHeight=0.07
		WinLeft=0.09375
		WinTop=0.4
	End Object
	Begin Object Class=GUIButton Name=cvkbBtnMed
		StyleName="MenuOptionCaption"
		WinWidth=0.13125	// 80pix + 1 gap
		WinHeight=0.07
		WinLeft=0.09375
		WinTop=0.4
	End Object
	Begin Object Class=GUIButton Name=cvkbBtnMed2
		StyleName="MenuOptionLabel"
		WinWidth=0.13125	// 80pix + 1 gap
		WinHeight=0.07
		WinLeft=0.09375
		WinTop=0.4
	End Object
	Begin Object Class=GUIButton Name=cvkbBtnLg
		StyleName="MenuOptionCaption"
		WinWidth=0.26875	// 160pix + 3 gaps
		WinHeight=0.07
		WinLeft=0.09375
	End Object
	Begin Object Class=GUIButton Name=cvkbBtnGrande
		StyleName="MenuOptionCaption"
		WinWidth=0.40625	// 240pix + 5 gaps
		WinHeight=0.07
		WinLeft=0.09375
	End Object

	vkbButtons1(0)=cvkbBtnSmall
	vkbButtons1(1)=cvkbBtnSmall
	vkbButtons1(2)=cvkbBtnSmall
	vkbButtons1(3)=cvkbBtnSmall
	vkbButtons1(4)=cvkbBtnSmall
	vkbButtons1(5)=cvkbBtnSmall
	vkbButtons1(6)=cvkbBtnSmall
	vkbButtons1(7)=cvkbBtnSmall
	vkbButtons1(8)=cvkbBtnSmall
	vkbButtons1(9)=cvkbBtnSmall
	vkbButtons1(10)=cvkbBtnMed2

	vkbButtons2(0)=cvkbBtnSmall
	vkbButtons2(1)=cvkbBtnSmall
	vkbButtons2(2)=cvkbBtnSmall
	vkbButtons2(3)=cvkbBtnSmall
	vkbButtons2(4)=cvkbBtnSmall
	vkbButtons2(5)=cvkbBtnSmall
	vkbButtons2(6)=cvkbBtnSmall
	vkbButtons2(7)=cvkbBtnSmall
	vkbButtons2(8)=cvkbBtnSmall
	vkbButtons2(9)=cvkbBtnSmall
	vkbButtons2(10)=cvkbBtnMed2

	vkbButtons3(0)=cvkbBtnSmall
	vkbButtons3(1)=cvkbBtnSmall
	vkbButtons3(2)=cvkbBtnSmall
	vkbButtons3(3)=cvkbBtnSmall
	vkbButtons3(4)=cvkbBtnSmall
	vkbButtons3(5)=cvkbBtnSmall
	vkbButtons3(6)=cvkbBtnSmall
	vkbButtons3(7)=cvkbBtnSmall
	vkbButtons3(8)=cvkbBtnSmall
	vkbButtons3(9)=cvkbBtnSmall
	vkbButtons3(10)=cvkbBtnMed2

	vkbButtons4(0)=cvkbBtnSmall
	vkbButtons4(1)=cvkbBtnSmall
	vkbButtons4(2)=cvkbBtnSmall
	vkbButtons4(3)=cvkbBtnSmall
	vkbButtons4(4)=cvkbBtnSmall
	vkbButtons4(5)=cvkbBtnSmall
	vkbButtons4(6)=cvkbBtnMed
	vkbButtons4(7)=cvkbBtnMed
	vkbButtons4(8)=cvkbBtnMed2

	vkbButtons5(0)=cvkbBtnGrande
	vkbButtons5(1)=cvkbBtnLg
	vkbButtons5(2)=cvkbBtnMed2

	vkbCharsNormal1=("1","2","3","4","5","6","7","8","9","0")
	vkbCharsNormal2=("a","b","c","d","e","f","g","h","i","j")
	vkbCharsNormal3=("k","l","m","n","o","p","q","r","s","t")
	vkbCharsNormal4=("u","v","w","x","y","z")

	vkbCharsShift1=("!","@","#","$","%","^","&","*","(",")")
	vkbCharsShift2=("A","B","C","D","E","F","G","H","I","J")
	vkbCharsShift3=("K","L","M","N","O","P","Q","R","S","T")
	vkbCharsShift4=("U","V","W","X","Y","Z")

	vkbCharsCaps1=("1","2","3","4","5","6","7","8","9","0")
	vkbCharsCaps2=("A","B","C","D","E","F","G","H","I","J")
	vkbCharsCaps3=("K","L","M","N","O","P","Q","R","S","T")
	vkbCharsCaps4=("U","V","W","X","Y","Z")

	vkbCharsSymbols1=("!","@","#","$","%","^","&","*","(",")")
	vkbCharsSymbols2=("[","]","{","}","\\","|",";",":","'","<QUOT>")
	vkbCharsSymbols3=("<",">","?",",",".","/","-","_","+","=")
	vkbCharsSymbols4=("~","`","","","","")
	vkbCharsShiftSymbols1=("","","","","","","","","","")
	vkbCharsShiftSymbols2=("","","","","","","","","","")
	vkbCharsShiftSymbols3=("","","","","","","","","","")
	vkbCharsShiftSymbols4=("","","","","","")

	vkbCharsAccents1=("","","","","","","","","","")
	vkbCharsAccents2=("","","","","","","","","","")
	vkbCharsAccents3=("","","","","","","","","","")
	vkbCharsAccents4=("","","","","","")
	vkbCharsShiftAccents1=("","","","","","","","","","")
	vkbCharsShiftAccents2=("","","","","","","","","","")
	vkbCharsShiftAccents3=("","","","","","","","","","")
	vkbCharsShiftAccents4=("","","","","","")

	vkbStringDone="Done"
	vkbStringAccents="Accents"
	vkbStringSymbols="Symbols"
	vkbStringCaps="Caps"
	vkbStringShift="Shift"
	vkbStringSpace="Space"
	vkbStringBackspace="Backspace"
	vkbStringLeft="<--"
	vkbStringRight="-->"

	vkbButtonTop1=0.325
	vkbButtonTop2=0.405
	vkbButtonTop3=0.485
	vkbButtonTop4=0.565
	vkbButtonTop5=0.645
	vkbButtonPivot=0.09375
//	vkbButtonPivot=0.90625
	vkbButtonSpacing=0.00625

	iLastAlphaKeyCol=-1
	iLastFocusKeyRow=-1
	iLastFocusKeyCol=-1
	bPortLockedOnly=true
}
class gbx_ScreenTimeline extends gbx_ScreenABXY;

var automated gbx_GameTimeline				Timeline;

var int										CurrentSelection;
var byte									CurrentMedals[80];
var bool									bAuthenticUnlocked;
var bool									bOpened;

	// medals ------------------------------------------------------------------------------
const MEDAL_Count = 5;
var localized string						MedalNames[MEDAL_Count];
var GUIFRect								MedalIconPositions[MEDAL_Count];
var Canvas.CanvasIcon						MedalIcons[MEDAL_Count];
var Canvas.CanvasIcon						MedalBracketIcons[2];
var Canvas.CanvasIcon						nilIcon;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	OnClose = ScreenOnClose;
	OnOpen = ScreenOnOpen;
	OnKeyEvent = ScreenKeyEvent;
	OnXControllerEvent = ScreenXControllerEvent;

}

function ScreenOnClose(optional Bool bCancelled)
{
	Timeline.OnChange = None;
	Timeline.SetProfile(None);
	bOpened = false;
}

function ScreenOnOpen()
{
	local int i, c, ch;
	local GameProfile gProfile;

	if (!bOpened)
	{
		Timeline.OnChange = ChapterListOnChange;

		gProfile = class'GameProfile'.Static.LoadCurrentGameProfile( PlayerOwner().Level );

		bAuthenticUnlocked = gProfile.IsAuthenticUnlocked();
		Timeline.SetProfile(gProfile);

		// get the medals
		c = 0;
		for (ch=0; ch<Timeline.TimeLineChapters.Length; ch++)
		{
			for (i=EDifficulty.DIFF_Easy; i<=EDifficulty.DIFF_Authentic; i++)
			{
				if ((gProfile != None) && gProfile.CompletedMissionDifficulty(ch, EDifficulty(i)))
				{
					// the last chapter represents completing the entire game on that difficulty
					if ((ch != (Timeline.TimeLineChapters.Length-1)) || (gProfile.CompletedDifficulty(EDifficulty(i)) == (Timeline.TimeLineChapters.Length)))
						CurrentMedals[c] = 1;
					else
						CurrentMedals[c] = 0;
				}
				else
					CurrentMedals[c] = 0;

				c++;
			}
		}

		class'GameProfile'.Static.UnloadProfile( PlayerOwner().Level, gProfile );

		bOpened = true;
	}
}

function ChapterListOnChange(GUIComponent Sender)
{
	CurrentSelection = Timeline.TimelineSelection;
}

function bool ScreenXControllerEvent(byte Id, eXControllerCodes iCode)
{
	if (Timeline.OnXControllerEvent(Id, iCode))
		return true;

	return Super.SAB_OnXControllerEvent(Id, iCode);
}

function bool ScreenKeyEvent(out byte Key,out byte State,float delta)
{
	if (Timeline.OnKeyEvent(Key, State, delta))
		return true;


	return Super.SAB_KeyEvent(Key, State, delta);
}

static function StaticDrawMedalIcons(Canvas C, GUIComponent me, GUIFRect rect, Canvas.CanvasIcon medal, Canvas.CanvasIcon back, optional byte backAlpha)
{
	C.Style = EMenuRenderStyle.MSTY_Alpha;

	if (back.Icon != None)
	{
		C.DrawColor = back.DrawColor;
		if (backAlpha != 0)
			C.DrawColor.A = backAlpha;

		C.SetPos(me.HorizontalOffset(rect.fL), me.VerticalOffset(rect.fT));
		C.DrawTile(back.Icon, rect.fW*me.ActualWidth(), rect.fH*me.ActualHeight(),
					back.U, back.V, back.UL, back.VL );
	}

	if (medal.Icon != None)
	{
		C.DrawColor = medal.DrawColor;
		C.SetPos(me.HorizontalOffset(rect.fL), me.VerticalOffset(rect.fT));
		C.DrawTile(medal.Icon, rect.fW*me.ActualWidth(), rect.fH*me.ActualHeight(),
					medal.U, medal.V, medal.UL, medal.VL );
	}
}

function DrawMedalIcons(Canvas C, GUIFRect rect, Canvas.CanvasIcon medal, Canvas.CanvasIcon back, optional byte backAlpha)
{
	StaticDrawMedalIcons(C, self, rect, medal, back, backAlpha);
}

function bool GotMedal(int medalIndex)
{
	return CurrentMedals[CurrentSelection*4 + medalIndex] != 0;
}

function bool IsChapterEnabled(int index)
{ 
	return PlayerOwner().Level.MissionManager.MissionEnabled(CurrentSelection); 
}

defaultproperties
{
	ScreenTitle="Extras"

	MedalIcons(0)=(Icon=Material't_interface_mb.hud.chapters_comp',U=63,V=57,UL=63,VL=109,DrawColor=(R=255,G=255,B=255,A=255))
	MedalIcons(1)=(Icon=Material't_interface_mb.hud.chapters_comp',U=127,V=57,UL=63,VL=109,DrawColor=(R=255,G=255,B=255,A=255))
	MedalIcons(2)=(Icon=Material't_interface_mb.hud.chapters_comp',U=189,V=57,UL=63,VL=109,DrawColor=(R=255,G=255,B=255,A=255))
	MedalIcons(3)=(Icon=Material't_interface_mb.hud.chapters_comp',U=0,V=57,UL=63,VL=109,DrawColor=(R=255,G=255,B=255,A=255))
	MedalIcons(4)=(Icon=Material't_interface_mb.hud.chapters_comp',U=252,V=57,UL=72,VL=109,DrawColor=(R=255,G=255,B=255,A=255))

	MedalNames(0)="WW2 Service Medal"
	MedalNames(1)="Bronze Star"
	MedalNames(2)="Silver Star"
	MedalNames(3)="Distinguished Service Cross"
	MedalNames(4)="Medal of Honor"

	MedalBracketIcons(0)=(Icon=Material't_interface_mb.hud.chapters_comp',U=361,V=57,UL=66,VL=109,DrawColor=(R=255,G=255,B=255,A=200))
	MedalBracketIcons(1)=(Icon=Material't_interface_mb.hud.chapters_comp',U=427,V=57,UL=75,VL=109,DrawColor=(R=255,G=255,B=255,A=200))
}
class gbx_SkirmishGameOver extends gbx_MPBase
	abstract;

var() Automated array<moLabel>				lblObjComplete;

var GameReplicationInfo						GRI;
var PlayerReplicationInfo					Players[2];		// 0 = server, 1 = client
var WargameSkirmish.ESkirmishGameType		SkirmishGameType;
var bool									bSavedPlayerScores;
var float									LayoutOffset;
var gbxMPMissionList.EMissionGameType		GameType;

var GUIFRect								MedalIconPosition;
var Canvas.CanvasIcon						MedalUS;
var Canvas.CanvasIcon						MedalDE;

var localized string						ScreenHeader;
var localized string						StringWavesComplete;
var localized string						StringEnemiesDefeated;
var localized string						StringTimeRemaining;
var localized string						StringParTime;
var localized string						StringBestTime;
var localized string						StringObjectiveComplete;
var localized string						StringObjectiveFailed;
var localized string						StringTourComplete;
var localized string						StringMissionAborted;
var localized string						StrSavingScore;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	local int i;

	InitExecution();

	Super.InitComponent(MyController, MyOwner);

	OnAButtonEvent = OnAButton;
	OnBButtonEvent = OnBButton;
	OnXButtonEvent = OnXButton;

	Controller.LoadPlayerControllerBindings();

	GRI = MyController.ViewportOwner.Actor.GameReplicationInfo;
	SkirmishGameType = ESkirmishGameType(GRI.Skirmish_Mode);
	GUILog("gbx_SkirmishGameOver::SkirmishGameType=" $SkirmishGameType);

	BuildPlayerList();

	lblProfileName[0].bUseTextColorForStyle = true;
	lblProfileName[1].bUseTextColorForStyle = true;

	for (i=0; i<lblObjComplete.Length; i++)
	{
		lblObjComplete[i].MyLabel.bTransparent = true;
		lblObjComplete[i].MyLabel2.bTransparent = true;
		lblObjComplete[i].Hide();
	}

	GameType = class'Gameplay.gbxMPMissionList'.static.GetGameType( class'Gameplay.gbxMPMissionList'.static.FindMapIndex(PlayerOwner().Level.GetLevelFileName()) );

	EnableChat(GRI.MaxPlayers > 1);
	SetupAButton();
	SetupXButton();
	GotoState('WaitingForScores');
}

function BuildPlayerList();

event Free()
{
	// unfade
// GBX:PAD: The skirmish end game fade is a "potential" TCR violation, so lets remove it and not take the chance.
//	PlayerOwner().Level.m_bFadeScreen = 2;
//	PlayerOwner().Level.m_flStartFadeTime = PlayerOwner().Level.TimeSeconds;
//	PlayerOwner().Level.m_flFadeTime = 2.0;
//	PlayerOwner().MyHUD.SetPersistantFadeOverride( true );
	
	Super.Free();
}

event HandleParameters(string Param1, string Param2)
{
	Super.HandleParameters(Param1, Param2);
}

function Timer()
{
	Super.Timer();

	SetupPlayerNames();
}

function OnAButton();
function OnXButton();
function OnBButton()
{
	Controller.PlayClickSound(EClickSound.CS_Back);
	Controller.OpenMenu(class'GameEngine'.default.PopupMPMenuClass, "NOCLOSEALL");
}

function SetScreenCaption()
{
	local string S;

	S = ScreenHeader;
	ReplaceText(S, "<MODE>", class'gbx_SkirmishLobby'.default.StringListModes[SkirmishGameType]);
	lblScreenTitle.SetCaption(S);
}

function bool Work_SavePlayerScores() {return false;}

function SavePlayerScores()
{
	local gbx_ScreenExtendedWork dlg;
	GUILog("SavePlayerScores");

	dlg = LaunchWorkDialog(Controller, StrSavingScore,, 3.0);
	dlg.DoWork = Work_SavePlayerScores;

	bSavedPlayerScores = true;
}

function bool NeedSavePlayerScores()
{
	return !bSavedPlayerScores && (GRI.FinalScore != -1);// && DidPlayersWin();
}

function SkirmishSaveMapStats(string profileName, int nMaxWaves, float flBestTime)
{
	local GameProfile gProfile;
	local bool bSave;

	if (profileName != "")
	{
		gProfile = class'GameProfile'.Static.LoadGameProfile( PlayerOwner().Level, profileName );
		if (gProfile != None)
		{
			if (SkirmishGameType == 0)	// objective
				bSave = gProfile.SkirmishSetCompleted(PlayerOwner().Level, GRI.Skirmish_Skill+1);
			else
				bSave = gProfile.SkirmishSaveMapStats(PlayerOwner().Level, nMaxWaves, flBestTime, GRI.Skirmish_Skill);

			GUILog("SkirmishSaveMapStats" @PlayerOwner().Level.GetLevelFileName() @profileName @nMaxWaves @flBestTime @bSave);
			class'GameProfile'.Static.UnloadProfile( PlayerOwner().Level, gProfile, bSave );
		}
	}
}

function bool SkirmishGetMapStats(string profileName, out int nMaxWaves, out float flBestTime)
{
	local Manifest savedGameManifest;
	local Manifest.ManifestEntry mePlayer;

	if (profileName != "")
	{
		GUILog("SkirmishGetMapStats" @profileName);
		savedGameManifest = PlayerOwner().Level.SaveGameGetManifest();
		if(savedGameManifest.GetManifestEntry(mePlayer, profileName))
		{
			nMaxWaves = savedGameManifest.GetScore(mePlayer, 2, PlayerOwner().Level.GetLevelFileName(), , GRI.Skirmish_Skill);
			flBestTime = savedGameManifest.GetScore(mePlayer, 1, PlayerOwner().Level.GetLevelFileName(), , GRI.Skirmish_Skill);
			GUILog("SkirmishGetMapStats" @profileName @PlayerOwner().Level.GetLevelFileName() @nMaxWaves @GRI.Skirmish_Skill @flBestTime);
			return true;
		}
	}

	return false;
}

function SetGameOverMessage(string cap)
{
	lblObjComplete[0].SetCaption(cap);
	lblObjComplete[0].Show();
}

function SetGameOverScore(int index, string cap, string score)
{
	lblObjComplete[index].SetCaption(cap);
	lblObjComplete[index].SetText(score);
	lblObjComplete[index].Show();
}

function DoComponentLayout()
{
	LayoutControlArray(lblObjComplete, LayoutOffset, 0.0, LA_Center);
}

// =======================================================================================================================================================
// Scoring
// =======================================================================================================================================================
function string GetEnemiesDefeated()
{
	return String(GRI.TotalKills);
}

function int GetTimeScore()
{
	return GRI.FinalScore;
}

function string GetTimeRemaining()
{
	return class'ScoreBoard'.static.FormatTime( GetTimeScore() );
}

function int SetParTimeMessage(int index)
{
	local string keyBase;
	local int i;
	local string result;

	if (GRI.MaxPlayers == 1)
		keyBase = "SKR_SoloParTime";
	else
		keyBase = "SKR_ParTime";

	// get the par time for the highest skill in the file
	for (i=GRI.Skirmish_Skill; (i>= 0) && (result==""); i--)
	{
		result = class'gbxMPMissionList'.static.GetLocalizedString(PlayerOwner().Level.GetLevelFileName(), keyBase $ i+1);
	}

	// if no par time was found, look for a global par time
	if (result == "")
	{
		result = class'gbxMPMissionList'.static.GetLocalizedString(PlayerOwner().Level.GetLevelFileName(), "SKR_ParTime");
	}

	// if we found a par time, convert it to a string
	if (result != "")
	{
		result = class'ScoreBoard'.static.FormatTime( int(result) );
		SetGameOverScore(index, StringParTime, result);
		index++;
	}

	return index;
}

function int GetBestTimeRemaining() {return 0;}

function int SetBestTimeMessage(int index)
{
	local int i;
	local string result;

	i = GetBestTimeRemaining();
	if (i != 0)
	{
		result = class'ScoreBoard'.static.FormatTime( i );
		SetGameOverScore(index, StringBestTime, result);
		index++;
	}

	return index;
}

function int GetWavesScore()
{
	return GRI.FinalScore;
}

function string GetWavesDefeated()
{
	return String( GetWavesScore() );
}

function string GetToursComplete()
{
	local string result;

	result = StringTourComplete;
	ReplaceText(result, "<TOUR>", String(GRI.FinalScore));

	return result;
}

function bool DidPlayersWin()
{
	local bool result;

	switch(GRI.WinningTeam)
	{
	case 1:	// American
		result = GameType == MGT_Skirmish_US;
		break;

	case 2:	// German
		result = GameType == MGT_Skirmish_DE;
		break;
	}

	return result;
}

function string GetGameOverMessage()
{
	local string result;

	switch(GRI.WinningTeam)
	{
	case 0:
		result = StringMissionAborted;
		break;

	case 1:
	case 2:
	default:
		if (DidPlayersWin())
			result = StringObjectiveComplete;
		else
			result = StringObjectiveFailed;

		break;
	}

	return result;
}

function bool ShouldShowControllerInfo(int inPlayerIndex)
{
	return (inPlayerIndex < GRI.MaxPlayers);
}

function bool ScreenOnDraw(Canvas C)
{
	return Super.ScreenOnDraw(C);
}

function bool IsNonCustomSkill()
{
	return (GRI.Skirmish_Skill >= 0) && (GRI.Skirmish_Skill <= 3);
}

// =======================================================================================================================================================
// State management
// =======================================================================================================================================================
state WaitingForScores
{
	function BeginState()
	{
		SetScreenCaption();
		SetTimer(0.1, true);
	}
	function GotFinalScores()
	{
		switch(int(SkirmishGameType))
		{
		case 0://WargameSkirmish.ESkirmishGameType.SGT_Objective:
			GotoState('SKR_Objective');
			break;
		case 1://WargameSkirmish.ESkirmishGameType.SGT_TimeChallenge:
			GotoState('SKR_Time');
			break;
		case 2://WargameSkirmish.ESkirmishGameType.SGT_Defense:
			GotoState('SKR_Defense');
			break;
		case 3://WargameSkirmish.ESkirmishGameType.SGT_TourOfDuty:
			GotoState('SKR_ToD');
			break;
		}
	}
	function Timer()
	{
		Global.Timer();

		if (GRI.FinalScore != -1)
			GotFinalScores();
	}
	function bool NeedSavePlayerScores() {return false;}
}

state GotScores
{
	function BeginState()
	{
		if (NeedSavePlayerScores())
			SavePlayerScores();

		DoComponentLayout();
	}

	function bool NeedSavePlayerScores() {return false;}
}

state SKR_Objective extends GotScores
{
	function BeginState()
	{
		SetGameOverMessage( GetGameOverMessage() );
		Super.BeginState();
	}
	function bool NeedSavePlayerScores() {return Global.NeedSavePlayerScores() && DidPlayersWin() && IsNonCustomSkill();}
}

state SKR_Time extends GotScores
{
	function BeginState()
	{
		local int i;

		SetGameOverMessage( GetGameOverMessage() );

		i = 1;
		SetGameOverScore(i++, StringTimeRemaining, GetTimeRemaining());

		if (IsNonCustomSkill())
		{
			i = SetBestTimeMessage(i);
			i = SetParTimeMessage(i);
		}

		SetGameOverScore(i++, StringEnemiesDefeated, GetEnemiesDefeated());

		Super.BeginState();
	}
	function bool NeedSavePlayerScores() {return Global.NeedSavePlayerScores() && DidPlayersWin() && IsNonCustomSkill();}
}

state SKR_Defense extends GotScores
{
	function BeginState()
	{
		SetGameOverScore(1, StringWavesComplete, GetWavesDefeated());
		Super.BeginState();
	}
	function bool NeedSavePlayerScores() {return Global.NeedSavePlayerScores();}
}

state SKR_ToD extends GotScores
{
	function BeginState()
	{
		if (CompletedTier() && DidPlayersWin())
		{
			LayoutOffset = 0.4;
		}

		SetGameOverMessage( GetGameOverMessage() );
		Super.BeginState();
	}
	function bool NeedSavePlayerScores()
	{
		return Global.NeedSavePlayerScores() && CompletedTier() && DidPlayersWin();
	}
	function bool CompletedTier()
	{
		return (GRI.NextMapName == "");
	}
	function string GetGameOverMessage()
	{
		local string result;

		if (DidPlayersWin() && CompletedTier())
			result = GetToursComplete();
		else
			result = Global.GetGameOverMessage();

		return result;
	}
	function bool ScreenOnDraw(Canvas C)
	{
		local Canvas.CanvasIcon nilIcon;

		if (CompletedTier() && DidPlayersWin())
		{
			if (GameType == MGT_Skirmish_DE)
				class'gbx_ScreenTimeline'.static.StaticDrawMedalIcons(C, self, MedalIconPosition, MedalDE, nilIcon);
			else
				class'gbx_ScreenTimeline'.static.StaticDrawMedalIcons(C, self, MedalIconPosition, MedalUS, nilIcon);
		}

		return Global.ScreenOnDraw(C);
	}
}

defaultproperties
{
	Background=Texture'WhiteTexture'
	BackgroundColor=(R=13,G=5,B=8,A=185)
	BackgroundRStyle=MSTY_Alpha

	Begin Object Class=moLabel Name=cMissionResult
		LabelStyle="Header"
		LabelJustification=TXTA_Center
		CaptionWidth=1
		ComponentWidth=0
		WinWidth=0.6000000
		WinHeight=0.075
		WinLeft=0.200000
		WinTop=0.28000
		bHeightFromComponent=false
		bVerticalLayout=false
		bNeverFocus=true
		bTabStop=false
		bAcceptsInput=false
		CompTransparent=true
		CompStyle="Header"
	End Object
	Begin Object Class=moLabel Name=cMissionScore
		LabelStyle="LargeButton"
		LabelJustification=TXTA_Left
		CaptionWidth=0.75
		ComponentWidth=0.23
		WinWidth=0.6000000
		WinHeight=0.06
		WinLeft=0.200000
		WinTop=0.28000
		bHeightFromComponent=false
		bVerticalLayout=false
		bNeverFocus=true
		bTabStop=false
		bAcceptsInput=false
		CompTransparent=true
		CompTextAlign=TXTA_Right
		CompStyle="LargeButton"
	End Object

	lblObjComplete(0)=cMissionResult
	lblObjComplete(1)=cMissionScore
	lblObjComplete(2)=cMissionScore
	lblObjComplete(3)=cMissionScore
	lblObjComplete(4)=cMissionScore
	LayoutOffset=0.46

	MedalIconPosition=(fL=0.45,fT=0.5,fW=0.1,fH=0.24)
	MedalUS=(Icon=Material't_interface_mb.hud.chapters_comp_additional',U=3,V=3,UL=48,VL=104,DrawColor=(R=255,G=255,B=255,A=255))
	MedalDE=(Icon=Material't_interface_mb.hud.chapters_comp_additional',U=55,V=1,UL=52,VL=104,DrawColor=(R=255,G=255,B=255,A=255))

	ScreenHeader="Skirmish : <MODE>"
	StringWavesComplete="Waves Completed :"
	StringEnemiesDefeated="Enemies Defeated :"
	StringTimeRemaining="Time Remaining :"
	StringParTime="Par Time Remaining:"
	StringBestTime="Best Time Remaining:"
	StringObjectiveComplete="Objective Complete!"
	StringObjectiveFailed="Mission Failed!"
	StringTourComplete="Tour <TOUR> Complete!"
	StringMissionAborted="Mission Aborted!"
	StrSavingScore="Saving score."
}
class gbx_SkirmishGameOverClient extends gbx_SkirmishGameOver;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	hBtnA.Hide();
}

function BuildPlayerList()
{
	local array<PlayerReplicationInfo> pList;

	GetPlayerList(PlayerOwner(), pList, true);
	Players[0] = pList[0];
	Players[1] = PlayerOwner().PlayerReplicationInfo;
}

function int GetBestTimeRemaining()
{
	local int waves;
	local float bestTime1;

	if (SkirmishGetMapStats(class'gbx_ProfileManager'.Static.GetProfileForController(self, 0), waves, bestTime1))
	{
		if (DidPlayersWin())
			bestTime1 = Max(bestTime1,GetTimeScore());

		return bestTime1;
	}

	return Super.GetBestTimeRemaining();
}

function bool NeedSavePlayerScores()
{
	if (PlayerOwner().PlayerReplicationInfo.bIsSpectator || PlayerOwner().PlayerReplicationInfo.bWaitingPlayer || PlayerOwner().PlayerReplicationInfo.bOnlySpectator)
	{
		GUILog("NeedSavePlayerScores ignoring spectator"); 
		return false;
	}

	return Super.NeedSavePlayerScores();
}

// =======================================================================================================================================================
// State management
// =======================================================================================================================================================
state SKR_Objective
{
	function bool Work_SavePlayerScores()
	{
		SkirmishSaveMapStats( class'gbx_ProfileManager'.Static.GetProfileForController(self, 0), 0, 0 );
		return true;
	}
}

state SKR_Time
{
	function bool Work_SavePlayerScores()
	{
		SkirmishSaveMapStats( class'gbx_ProfileManager'.Static.GetProfileForController(self, 0), 0, GetTimeScore() );
		return true;
	}
}

state SKR_Defense
{
	function bool Work_SavePlayerScores()
	{
		SkirmishSaveMapStats( class'gbx_ProfileManager'.Static.GetProfileForController(self, 0), GetWavesScore(), 0 );
		return true;
	}
}

state SKR_ToD
{
	function bool Work_SavePlayerScores()
	{
		// save the client slot (always player 0)
		class'GameProfile'.static.SetToDLevelForProfile(PlayerOwner().Level, class'gbx_ProfileManager'.Static.GetProfileForController(self, 0), true, GRI.FinalScore);
		return true;
	}
}

defaultproperties
{
}
class gbx_SkirmishGameOverServer extends gbx_SkirmishGameOver;

var localized string					StringToLobby;
var localized string					StringToNextMission;
var localized string					StringPromptToLobby;
var localized string					StringPromptToLobbyToD;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);
}

function BuildPlayerList()
{
	local array<PlayerReplicationInfo> pList;

	GetPlayerList(PlayerOwner(), pList, false, false);		// local players
	GetPlayerList(PlayerOwner(), pList, true, true);		// remote players

	if (pList.Length > 0)
		Players[0] = pList[0];

	if (pList.Length > 1)
		Players[1] = pList[1];
}

function MovePlayerToLobby(PlayerReplicationInfo PRI)
{
	local PlayerController PC;
	
	if (PRI != None)
	{
		PC = class'gbx_MPLobbyPlayer'.static.FindPlayerControllerForPRI(PlayerOwner(), PRI);
		if (PC != None)
		{
			PC.ClientGotoState('Debriefing_SkirmishLobby', '');
		}
	}
}

function DoMoveToLobby()
{
	class'GameProfile'.static.ClearProfileCheckpoint(PlayerOwner().Level, true);

	// move the clients to the lobby
	WargameSkirmish(PlayerOwner().Level.Game).GotoState('MatchOver_Lobby');
}
function bool CheckpointPromptAnswer(string answer)
{
	if ((answer ~= "YES") || (answer ~= "OK"))
	{
		DoMoveToLobby();
		return false;
	}

	return true;
}

function OnAButton()
{
	Controller.PlayClickSound(EClickSound.CS_Back);
	Controller.OpenMenu("GUI.gbx_DlgMPRestartMission");
}

function OnXButton()
{
	Controller.PlayClickSound(EClickSound.CS_Back);
	DoMoveToLobby();
}

function StateHandleAButton()
{
	if (!DidPlayersWin())
	{
		Global.OnAButton();
	}
	else
	{
		OnXButton();
	}
}

function int GetBestTimeRemaining()
{
	local int waves;
	local float bestTime1, bestTime2;

	if (SkirmishGetMapStats(class'gbx_ProfileManager'.Static.GetProfileForController(self, 0), waves, bestTime1))
	{
		if (SkirmishGetMapStats(class'gbx_ProfileManager'.Static.GetProfileForController(self, 1), waves, bestTime2))
			bestTime1 = Max(bestTime1, bestTime2);

		if (DidPlayersWin())
			bestTime1 = Max(bestTime1,GetTimeScore());

		return bestTime1;
	}

	return Super.GetBestTimeRemaining();
}

// =======================================================================================================================================================
// State management
// =======================================================================================================================================================
state WaitingForScores
{
	function BeginState()
	{
		SetScreenCaption();
		SetTimer(0.1, true);
	}
	function EndState()
	{
		if (!DidPlayersWin())
		{
			SetupAButton(XCaption);
			SetupXButton(StringToLobby);
		}
		else
		{
			SetupAButton(StringToLobby);
			SetupXButton();
		}
	}
}

state SKR_Objective
{
	function OnXButton()
	{
		local gbx_ScreenQuestion dlg;
		if (!DidPlayersWin() && class'GameProfile'.static.ProfileHasCheckpoint(PlayerOwner().Level, true))
		{
			Controller.PlayClickSound(EClickSound.CS_Back);

			dlg = LaunchQuestionDialog(Controller, StringPromptToLobby, "YESNO AREYOUSURE");
			dlg.OnAnswer = CheckpointPromptAnswer;
		}
		else
		{
			Global.OnXButton();
		}
	}
	function bool Work_SavePlayerScores()
	{
		SkirmishSaveMapStats( class'gbx_ProfileManager'.Static.GetProfileForController(self, 0), 0, 0 );
		SkirmishSaveMapStats( class'gbx_ProfileManager'.Static.GetProfileForController(self, 1), 0, 0 );
		return true;
	}
	function OnAButton()
	{
		StateHandleAButton();
	}
}

state SKR_Time
{
	function bool Work_SavePlayerScores()
	{
		SkirmishSaveMapStats( class'gbx_ProfileManager'.Static.GetProfileForController(self, 0), 0, GetTimeScore() );
		SkirmishSaveMapStats( class'gbx_ProfileManager'.Static.GetProfileForController(self, 1), 0, GetTimeScore() );
		return true;
	}
	function OnAButton()
	{
		StateHandleAButton();
	}
}

state SKR_Defense
{
	function BeginState()
	{
		Super.BeginState();
		SetupAButton(XCaption);
		SetupXButton(StringToLobby);
	}
	function bool Work_SavePlayerScores()
	{
		SkirmishSaveMapStats( class'gbx_ProfileManager'.Static.GetProfileForController(self, 0), GetWavesScore(), 0 );
		SkirmishSaveMapStats( class'gbx_ProfileManager'.Static.GetProfileForController(self, 1), GetWavesScore(), 0 );
		return true;
	}
}

state SKR_ToD
{
	function BeginState()
	{
		Super.BeginState();

		if (!DidPlayersWin())
		{
			SetupAButton(XCaption);
			SetupXButton(StringToLobby);
		}
		else if (CompletedTier())
		{
			SetupAButton(StringToLobby);
			SetupXButton();
		}
		else
		{
			SetupAButton(StringToNextMission);
			SetupXButton(StringToLobby);
		}
	}
	function OnAButton()
	{
		if (!DidPlayersWin())
		{
			class'gbx_ScreenABXY'.static.ServerTravelSkirmish(Controller, 
				WargameSkirmish(PlayerOwner().Level.Game).FindNextToDMap(true), 
				WargameSkirmish(PlayerOwner().Level.Game).GetRulesString(false));
		}
		else if (CompletedTier())
		{
			Global.OnXButton();
		}
		else
		{
			// if we've only completed a mission, simply launch the next one here.
			class'gbx_ScreenABXY'.static.ServerTravelSkirmish(Controller, 
				GRI.NextMapName, 
				WargameSkirmish(PlayerOwner().Level.Game).GetRulesString(true));
		}
	}
	function OnXButton()
	{
		local gbx_ScreenQuestion dlg;

		if (DidPlayersWin())
		{
			Controller.PlayClickSound(EClickSound.CS_Back);

			dlg = LaunchQuestionDialog(Controller, StringPromptToLobbyToD, "YESNO AREYOUSURE");
			dlg.OnAnswer = CheckpointPromptAnswer;
		}
		else
		{
			Global.OnXButton();
		}
	}
	function bool Work_SavePlayerScores()
	{
		local string clientPlayer;

		clientPlayer = class'gbx_ProfileManager'.Static.GetProfileForController(self, 1);

		// save the server slot (always player 0)
		class'GameProfile'.static.SetToDLevelForProfile(PlayerOwner().Level, class'gbx_ProfileManager'.Static.GetProfileForController(self, 0), GRI.MaxPlayers > 1, GRI.FinalScore);

		// save the client if it exists
		if (clientPlayer != "")
			class'GameProfile'.static.SetToDLevelForProfile(PlayerOwner().Level, clientPlayer, GRI.MaxPlayers > 1, GRI.FinalScore);

		return true;
	}
}

defaultproperties
{
	ACaption="Continue"
	XCaption="Restart Mission"

	StringToLobby="To Lobby"
	StringToNextMission="To Next Mission"
	StringPromptToLobby="You are about to quit the current mission.  Your saved checkpoint will be lost."
	StringPromptToLobbyToD="You are about to quit the current Tour of Duty.  Your progress will be lost."
}
class gbx_SkirmishLobby extends gbx_MPBase
	Abstract;

const NUM_SKILLSETS = 3;	// mirrors value in WargameSkirmish
const TEAM_ICON_SCALE = 1.8;
const TEAM_ICON_SCALE_WAIT = 2.0;
const UNLOCKED_TOUR_COUNT = 3;

// Lame countdown management stuff
const COUNTDOWN_TIME = 5;
const COUNTDOWN_ABORTED = -1;
const COUNTDOWN_SUCCESS = -2;

var Automated moSpinListControl				TeamChooser;
var Automated GUISpinListControl			RoleChooser[2];
var Automated moSpinListControl				ModeChooser;
var Automated moSpinListControl				SkillChooser;
var Automated moSpinListControl				SkillCustomChooser[3];
var Automated moSpinListControl				MissionList;
var automated gbx_MissionDisplay			MissionDisplay;
var automated GUILabel						lblHighScores;
var array<GUIComponent>						ServerControlList;

var GUIStyles								styLinePlayerNum;

var localized string						StringCaptionMission;
var localized string						StringCaptionMissionUnknown;
var localized string						StringModeCaption;
var localized string						StringSkillCaption;
var localized string						StringSkillToDContinue;
var localized array<string>					StringCustomSkillCaption;
var localized array<string>					StringListTeams;
var localized array<string>					StringListRolesUS;
var localized array<string>					StringListRolesDE;
var localized string						StringWaitingForPlayer;
var array<string>							StringListModeId;
var localized array<string>					StringListModes;
var localized array<string>					StringListSkills;
var localized array<string>					StringListCustomSkills;
var localized array<string>					StringListCustomSkills1;
var localized string						StringHSToD;
var localized string						StringHSDefense;
var localized string						StringHSTimed;
var localized string						StringHSNone;


var Canvas.CanvasIcon						IconRole[3];	// in same order as EUnitType
var Canvas.CanvasIcon						IconUSA;
var Canvas.CanvasIcon						IconGerman;
var Canvas.CanvasIcon						IconBackUSA;
var Canvas.CanvasIcon						IconBackGerman;
var Canvas.CanvasIcon						PortraitUS[2];
var Canvas.CanvasIcon						PortraitDE[2];
var Canvas.CanvasIcon						WeaponUS[4];	// assault1,2 fire1,2
var Canvas.CanvasIcon						WeaponDE[4];
var float									fRoleTabMid;

// high score stuff
var float									fNextToggleHSTime;
var int										DisplayedPlayerHS;

var bool									bWaitLobby;		// nonfunctional, simply waiting for players to join up
var bool									bIsToDMode;		// lobby is in Tour of Duty mode
var bool									bLocalPlayersInitialized;	// the local pri/playercontroller and profile are all properly set up
var int										DefaultSkillLevel;
var int										ServerControllerId;
var int										ClientControllerId;
var GameReplicationInfo						GRI;

// use to cache data for client/server so we don't have to hammer the profile system
var Manifest								savedGameManifest;
var Manifest.ManifestEntry					meServer, meClient;

var string CountdownCaptionA, CountdownCaptionB, CountdownCaptionX, CountdownCaptionY;

var Sound CountdownProgressSound, CountdownFinishedSound;

var int skillEasy[NUM_SKILLSETS];
var int skillNormal[NUM_SKILLSETS];
var int skillHard[NUM_SKILLSETS];
var int skillAuthentic[NUM_SKILLSETS];
var int skillCustom[NUM_SKILLSETS];

var array<string>							ToDSkillLevels;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	local int i;

	Super.InitComponent(MyController, MyOwner);

	Controller.LoadPlayerControllerBindings();
	savedGameManifest = PlayerOwner().Level.SaveGameGetManifest();

	OnOpen = LobbyOpen;
	OnClose = LobbyClose;
	OnCanClose = CanClose;
	OnXControllerEvent = LobbyOnXControllerEvent;
	OnKeyEvent = LobbyOnKeyEvent;

	OnAButtonEvent = OnAButton;
	OnBButtonEvent = OnBButton;
//	OnXButtonEvent = OnXButton;
//	OnYButtonEvent = OnYButton;

	styLinePlayerNum = Controller.GetStyle("TextLabel");

	TeamChooser.OnChange = UIOnChangeTeam;
	RoleChooser[0].OnChange = UIOnChangeRole;
	RoleChooser[1].OnChange = UIOnChangeRole;
	ModeChooser.OnChange = UIOnChangeMode;
	SkillChooser.OnChange = UIOnChangeSkill;
	SkillCustomChooser[0].OnChange = UIOnChangeSkillCustom;
	SkillCustomChooser[1].OnChange = UIOnChangeSkillCustom;
	SkillCustomChooser[2].OnChange = UIOnChangeSkillCustom;
	MissionList.OnChange = UIOnChangeMission;

	lblProfileName[0].bUseTextColorForStyle = true;
	lblProfileName[1].bUseTextColorForStyle = true;

	// Remove Tour of duty from the Demo and Preview builds
	if (Controller.bIsPreviewVersion)
	{
		TeamChooser.AddFromList(StringListTeams);
		StringListModes.Remove(3,1);
		StringListModeId.Remove(3,1);
	}
	else if (Controller.bIsDemoVersion)
	{		
		TeamChooser.Add(StringListTeams[0]);
		StringListModes.Remove(3,1);
		StringListModeId.Remove(3,1);
	}
	else
	{
		TeamChooser.AddFromList(StringListTeams);
	}
	

	ModeChooser.AddFromLists(StringListModes,StringListModeId);

	RoleChooser[0].AddFromList(StringListRolesUS);
	RoleChooser[1].AddFromList(StringListRolesUS);

	ModeChooser.SetCaption(StringModeCaption);

	SkillChooser.SetCaption(StringSkillCaption);
	SkillChooser.AddFromList(StringListSkills);

	SkillCustomChooser[0].SetCaption(StringCustomSkillCaption[0]);
	SkillCustomChooser[0].AddFromList(StringListCustomSkills);
	SkillCustomChooser[1].SetCaption(StringCustomSkillCaption[1]);
	SkillCustomChooser[1].AddFromList(StringListCustomSkills1);
	SkillCustomChooser[2].SetCaption(StringCustomSkillCaption[2]);
	SkillCustomChooser[2].AddFromList(StringListCustomSkills);


	i = 0;
	TeamChooser.TabOrder = i++;
	MissionList.TabOrder = i++;
	RoleChooser[0].TabOrder = i++;
	RoleChooser[1].TabOrder = i++;
	ModeChooser.TabOrder = i++;
	SkillChooser.TabOrder = i++;
	SkillCustomChooser[0].TabOrder = i++;
	SkillCustomChooser[1].TabOrder = i++;
	SkillCustomChooser[2].TabOrder = i++;
	hBtnA.TabOrder = i++;
	hBtnB.TabOrder = i++;
	hBtnX.TabOrder = i++;
	hBtnY.TabOrder = i++;
	editText.TabOrder = i++;

	RemapComponents();
	FocusFirst(none);

	InitExecution();

	MakeAmbientSoundHappen();
//	Controller.bDesignMode = true;

	EnableClientComponents(false);
	ServerControlList.Length = 9;
	ServerControlList[0] = TeamChooser;
	ServerControlList[1] = MissionList;
	ServerControlList[2] = RoleChooser[0];
	ServerControlList[3] = RoleChooser[1];
	ServerControlList[4] = ModeChooser;
	ServerControlList[5] = SkillChooser;
	ServerControlList[6] = SkillCustomChooser[0];
	ServerControlList[7] = SkillCustomChooser[1];
	ServerControlList[8] = SkillCustomChooser[2];
}

event Free()
{
	if (IsWaitLobby())
	{
		PlayerOwner().Level.m_bFadeScreen = 1;
		PlayerOwner().Level.m_flStartFadeTime = PlayerOwner().Level.TimeSeconds;
		PlayerOwner().Level.m_flFadeTime = 1.0;
		PlayerOwner().MyHUD.SetPersistantFadeOverride( true );
	}
	
	savedGameManifest = None;
	Super.Free();
}

event HandleParameters( string Param1, string Param2 )
{
	Super.HandleParameters(Param1, Param2);

	bWaitLobby = (Param1 ~= "WAIT");
	GUILog("Skirmish lobby bWaitLobby=" $String(bWaitLobby));

	if (bWaitLobby)
	{
		TeamChooser.Hide();
		MissionList.Hide();
		RoleChooser[0].Hide();
		RoleChooser[1].Hide();
		ModeChooser.Hide();
		SkillChooser.Hide();
		SkillCustomChooser[0].Hide();
		SkillCustomChooser[1].Hide();
		SkillCustomChooser[2].Hide();
		MissionDisplay.SetLeft(0.09);
		lblHighScores.SetLeft(0.09);
	}
}

function EnableServerComponents(bool bEnable)
{
	TeamChooser.EnableControl(bEnable);
	RoleChooser[0].EnableControl(bEnable);
	RoleChooser[1].EnableControl(bEnable);
	ModeChooser.EnableControl(bEnable);
	SkillChooser.EnableControl(bEnable);
	EnableCustomSkills(bEnable && !bIsToDMode && (SkillChooser.GetIndex() == 4));
	MissionList.EnableControl(bEnable && !bIsToDMode);
}

function EnableClientComponents(bool bEnable)
{
}

function EnableCustomSkills(bool bEnable)
{
	SkillCustomChooser[0].EnableControl(bEnable);
	SkillCustomChooser[1].EnableControl(bEnable);
	SkillCustomChooser[2].EnableControl(bEnable);
}

function bool EnableToDMode(bool bEnable)
{
	local string S;
	local bool result;
	local int i;

	result = bEnable != bIsToDMode;
	bIsToDMode = bEnable;

	if (result)
	{
		SkillCustomChooser[0].SetVisibility(!bIsToDMode);
		SkillCustomChooser[1].SetVisibility(!bIsToDMode);
		SkillCustomChooser[2].SetVisibility(!bIsToDMode);

		SkillChooser.Clear();
		if (bEnable)
		{
			// add 3 always-enabled entries
			for (i=0; i<UNLOCKED_TOUR_COUNT; i++)
			{
				S = StringSkillToDContinue;
				ReplaceText(S, "<TOUR>", String(i+1));

				SkillChooser.Add(S,,String(i+1));
			}

			// add higher levels from players
			for (i=0; i<ToDSkillLevels.Length; i++)
			{
				S = StringSkillToDContinue;
				ReplaceText(S, "<TOUR>", ToDSkillLevels[i]);

				SkillChooser.Add(S,,ToDSkillLevels[i]);
			}
		}
		else
		{
			SkillChooser.AddFromList(StringListSkills);
		}
	}

	return result;
}

function EnableDefenseMode(bool bEnable)
{
	//Log( " gbx_SkirmishLobby::EnableDefenseMode() bEnable="$bEnable, 'MP' );
	SkillChooser.SetVisibility(!bEnable && !bWaitLobby);

	if (!bIsToDMode)
	{
		SkillCustomChooser[0].SetVisibility(!bEnable && !bWaitLobby);
		SkillCustomChooser[1].SetVisibility(!bEnable && !bWaitLobby);
		SkillCustomChooser[2].SetVisibility(!bEnable && !bWaitLobby);

		// If defense mode, set sLevels manually
		if ( bEnable )
		{
			SkillChooser.SetIndex(0);
		}
		else
		{
			SkillChooser.SetIndex(DefaultSkillLevel);
		}
	}
}

function string GetSelectedMissionName()
{
	return class'Gameplay.gbxMPMissionList'.Static.FindMissionName(MissionList.GetExtra(), true);
}

function PopulateMissionList(gbxMPMissionList.EMissionGameType gameType)
{
	local int i, c, t;

	MissionList.Clear();
	c = class'Gameplay.gbxMPMissionList'.Static.GetMissionCount();
	for (i=0; i<c; i++)
	{
		if (class'Gameplay.gbxMPMissionList'.Static.GetGameType(i) == gameType)
		{
			t++;
			MissionList.Add(StringCaptionMission @t,, class'Gameplay.gbxMPMissionList'.Static.GetMap(i));
		}
	}
}

function PopulateRoleList(array<string> roleList)
{
	local int index;

	// disable callbacks
	RoleChooser[0].OnChange = None;
	RoleChooser[1].OnChange = None;

	index = RoleChooser[0].GetIndex();
	RoleChooser[0].Clear();
	RoleChooser[0].AddFromList(roleList);
	RoleChooser[0].SetIndex(index);

	index = RoleChooser[1].GetIndex();
	RoleChooser[1].Clear();
	RoleChooser[1].AddFromList(roleList);
	RoleChooser[1].SetIndex(index);

	// re-enable callbacks
	RoleChooser[0].OnChange = UIOnChangeRole;
	RoleChooser[1].OnChange = UIOnChangeRole;
}

function OnMapChanged(string newMap)
{
	if (newMap == "-1")
		MissionDisplay.SetMission(-1);
	else
		MissionDisplay.SetMissionFromMissionName(newMap);

	ForceScoresUpdate();
}

function OnTeamChanged(int newTeam)
{
	if (newTeam == 0)
	{
		PopulateMissionList(MGT_Skirmish_US);
		PopulateRoleList(StringListRolesUS);
	}
	else
	{
		PopulateMissionList(MGT_Skirmish_DE);
		PopulateRoleList(StringListRolesDE);
	}
}

function OnRoleChanged(int playerIndex, int roleIndex)
{
//	GUILog(String(self) @":OnRoleChanged:" $playerIndex @roleIndex);
}

function OnGameTypeChanged(int newGameIndex)
{
	//Log( " gbx_SkirmishLobby::OnGameTypeChanged() newGameIndex="$newGameIndex, 'MP' );

	MissionDisplay.SetGameType(newGameIndex);
	EnableToDMode(newGameIndex == 3);
	EnableDefenseMode(newGameIndex == 2);

	ForceScoresUpdate();

	SetCaption(ScreenTitle @":" @ModeChooser.Get());
}

function OnSkillChanged(int newSkillIndex, int skillLevels[NUM_SKILLSETS])
{
//	GUILog(String(self) @":OnSkillchanged:" $newSkillIndex @skillLevels[0] @skillLevels[1] @skillLevels[2]);
}

function int GetMaxPlayers();
function bool IsWaitLobby() {return bWaitLobby;}
function bool LobbyHasPlayer(int playerIndex) {return false;}
function bool PlayerIsReady(int playerIndex) {return false;}
function bool LocalPlayersReady() {return false;}
function bool PlayersReady() {return PlayerIsReady(0) && ((GetMaxPlayers() == 1) || PlayerIsReady(1));}
function bool IsUSMode() {return TeamChooser.GetIndex() == 0;}

function int GetPlayerRole(int playerIndex)
{
	if (playerIndex == 0)
	{
		return RoleChooser[0].GetIndex();
	}
	else
	{
		return RoleChooser[1].GetIndex();
	}
}

function SetPlayerReady(int playerIndex, bool bReady)
{
	if (playerIndex == 0)
	{
		EnableServerComponents(!PlayerIsReady(playerIndex));
	}
	else
	{
		EnableClientComponents(!PlayerIsReady(playerIndex));
	}
}

function GetSkillLevels(int difficulty, out int skillLevels[NUM_SKILLSETS])
{
	switch(difficulty)
	{
	case 0:	// easy
		skillLevels[0] = skillEasy[0];
		skillLevels[1] = skillEasy[1];
		skillLevels[2] = skillEasy[2];
		break;

	case 1:	// normal
		skillLevels[0] = skillNormal[0];
		skillLevels[1] = skillNormal[1];
		skillLevels[2] = skillNormal[2];
		break;

	case 2:	// difficult
		skillLevels[0] = skillHard[0];
		skillLevels[1] = skillHard[1];
		skillLevels[2] = skillHard[2];
		break;

	case 3:	// authentic
		skillLevels[0] = skillAuthentic[0];
		skillLevels[1] = skillAuthentic[1];
		skillLevels[2] = skillAuthentic[2];
		break;

	case 4:	// custom
		skillLevels[0] = skillCustom[0];
		skillLevels[1] = skillCustom[1];
		skillLevels[2] = skillCustom[2];
		break;
	}
}

function bool IsDifficultyLevel(int difficulty, int skillLevels[NUM_SKILLSETS])
{
	local int sLevels[NUM_SKILLSETS];

	GetSkillLevels(difficulty, sLevels);
	return (skillLevels[0] == sLevels[0]) && (skillLevels[1] == sLevels[1]) && (skillLevels[2] == sLevels[2]);
}

function int FindDifficulty(int skillLevels[NUM_SKILLSETS])
{
	local int i;

	for (i=0; i<4; i++)
	{
		if (IsDifficultyLevel(i, skillLevels))
			return i;
	}

	return 4;
}

function GetCurrentSkillLevel(out int skillLevels[NUM_SKILLSETS])
{
	skillLevels[0] = SkillCustomChooser[0].GetIndex();
	skillLevels[1] = SkillCustomChooser[1].GetIndex();
	skillLevels[2] = SkillCustomChooser[2].GetIndex();
}

// =======================================================================================================================================================
// UI Input Handling
// =======================================================================================================================================================
function UIOnChangeTeam(GUIComponent Sender)
{
	OnTeamChanged(TeamChooser.GetIndex());
}

function UIOnChangeRole(GUIComponent Sender)
{
	if (Sender == RoleChooser[0])
	{
		OnRoleChanged(0, RoleChooser[0].GetIndex());
	}
	else if (Sender == RoleChooser[1])
	{
		OnRoleChanged(1, RoleChooser[1].GetIndex());
	}
}

function WargameSkirmish.ESkirmishGameType GetUIModeChoice()
{
	local int i;

	i = int(ModeChooser.GetExtra());
	switch(i)
	{
	case 0:
	case 1:
	case 2:
	case 3:
		return ESkirmishGameType(i);
	}

	return SGT_None;
}

function SetUIModeChoice(WargameSkirmish.ESkirmishGameType gameType)
{
	local string S;
	local int i;

	S = string(int(gameType));
	i = ModeChooser.MySpinListControl.Find(S, true);
	if (i != -1)
		SetSpinIndex(ModeChooser.MySpinListControl, i );
}

function UIOnChangeMode(GUIComponent Sender)
{
	OnGameTypeChanged(int(GetUIModeChoice()));
}

function UIOnChangeSkill(GUIComponent Sender)
{
	local int sLevels[NUM_SKILLSETS];

	GetCurrentSkillLevel(sLevels);
	OnSkillChanged(SkillChooser.GetIndex(), sLevels);
}

function UIOnChangeSkillCustom(GUIComponent Sender)
{
	local int sLevels[NUM_SKILLSETS];

	GetCurrentSkillLevel(sLevels);
	OnSkillChanged(SkillChooser.GetIndex(), sLevels);
}

function UIOnChangeMission(GUIComponent Sender)
{
	OnMapChanged(MissionList.GetExtra());
}

// =======================================================================================================================================================
// Basic screen functionality
// =======================================================================================================================================================
function MakeAmbientSoundHappen()
{
	local PhysicsVolume Volume;
	local PhysicsVolume BestVolume;
	local string soundname;

	ForEach PlayerOwner().AllActors(class'PhysicsVolume', Volume)
	{
		if (Volume.AmbientSound != None && (BestVolume == None || Volume.Priority < BestVolume.Priority) )
		{
			BestVolume = Volume;
			soundname = string(BestVolume.AmbientSound);
		}
	}

	if (soundname != "")
	{
		PlayerOwner().PlayMusic(soundname, 0.0);
	}
}

function bool CanClose(optional Bool bCancelled) {return false;}
function LobbyOpen()
{
	SetTimer(0.15, true);
}
function LobbyClose(optional Bool bCancelled)
{
	KillTimer();

	PlayerOwner().PlaySound(CountdownFinishedSound, SLOT_Interact, 1.0, false );
}

function SetupAButtonCaptions(string capBothReady, string capNotReady)
{
	if (LocalPlayersReady())
	{
		SetupAButton(capBothReady);
	}
	else
	{
		SetupAButton(capNotReady);
	}
}

function FindClient(optional bool bForceUpdate);
function bool InitLocalPlayers();
function CheckForToDSkillChange();

function Timer()
{
	FindClient();

	if (!bLocalPlayersInitialized)
		bLocalPlayersInitialized = InitLocalPlayers();

	CheckForToDSkillChange();

	CycleHighScoreInfo();
}

function PlayerReplicationInfo FindRemotePlayer()
{
	local PlayerReplicationInfo pri;
	local PlayerController PC;
	local int i;

	for (i=0; i<GRI.PRIArray.Length; i++)
	{
		pri = GRI.PRIArray[i];
		if ( pri != None && !pri.bBot )
		{
			PC = class'gbx_MPLobbyPlayer'.static.FindPlayerControllerForPRI(PlayerOwner(), pri);
//			GUILog("Testing PRI=" $pri $" PC=" $PC $" Viewport=" $Viewport(PC.Player));
			if ((PC == None) || (Viewport(PC.Player) == None))
			{
				return pri;
			}
		}
	}

	return None;
}

function color GetPlayerColor(int playerIndex)
{
	local color result;
	result = class'gbxMP.WargameMultiplayerScoreboard'.default.PlayerColors[ playerIndex ];
	if (!PlayerIsReady(playerIndex))
		result.A = 70;

	return result;
}

function SetupWeaponGraphics()
{
	local int ofs;
	local gbxMPPlayerStart P;
	local class<WargameWeapon> weapClass[2];

	if ((weaponUS[0].Icon != None) || (WeaponDE[0].Icon != None))
		return;

	ForEach PlayerOwner().AllActors(class'gbxMPPlayerStart', P)
	{
		weapClass[0] = class<WargameWeapon>( DynamicLoadObject(P.RequiredEquipment[0], class'class' ) );
		weapClass[1] = class<WargameWeapon>( DynamicLoadObject(P.RequiredEquipment[1], class'class' ) );

		if (P.TeamMemberID != 0)
			ofs = 2;
		else
			ofs = 0;

		if (IsUSMode())
		{
			if (WeaponUS[ofs].Icon != None)
				continue;

			WeaponUS[ofs].Icon = weapClass[0].default.Icon;
			WeaponUS[ofs].U = weapClass[0].default.nIconX;
			WeaponUS[ofs].V = weapClass[0].default.nIconY;
			WeaponUS[ofs].UL = weapClass[0].default.nIconW;
			WeaponUS[ofs].VL = weapClass[0].default.nIconH;

			WeaponUS[ofs+1].Icon = weapClass[1].default.Icon;
			WeaponUS[ofs+1].U = weapClass[1].default.nIconX;
			WeaponUS[ofs+1].V = weapClass[1].default.nIconY;
			WeaponUS[ofs+1].UL = weapClass[1].default.nIconW;
			WeaponUS[ofs+1].VL = weapClass[1].default.nIconH;
		}
		else
		{
			if (WeaponDE[ofs].Icon != None)
				continue;

			WeaponDE[ofs].Icon = weapClass[0].default.Icon;
			WeaponDE[ofs].U = weapClass[0].default.nIconX;
			WeaponDE[ofs].V = weapClass[0].default.nIconY;
			WeaponDE[ofs].UL = weapClass[0].default.nIconW;
			WeaponDE[ofs].VL = weapClass[0].default.nIconH;

			WeaponDE[ofs+1].Icon = weapClass[1].default.Icon;
			WeaponDE[ofs+1].U = weapClass[1].default.nIconX;
			WeaponDE[ofs+1].V = weapClass[1].default.nIconY;
			WeaponDE[ofs+1].UL = weapClass[1].default.nIconW;
			WeaponDE[ofs+1].VL = weapClass[1].default.nIconH;
		}
	}
}

function DrawPlayerPanel(Canvas C, int index)
{
	local float xRight,xPos,xPos0, yPos,yPos0, XL, YL, wScale;
	local int role;
	local string sName;
	local Canvas.CanvasIcon iconPortrait, iconWeapon1, iconWeapon2;

	if (index >= GetMaxPlayers())
		return;

	SetupWeaponGraphics();
	Controller.CanvasIconSize(IconBackUSA, XL, YL, TEAM_ICON_SCALE_WAIT, TEAM_ICON_SCALE_WAIT);

	xPos0 = HorizontalOffset(0.55) + 0.5*XL;
	xRight = 1.03 * ActualWidth();
	yPos0 = VerticalOffset(0.27) + float(index)*1.75*YL;

	xPos = xPos0;
	yPos = yPos0;

	C.Style = EMenuRenderStyle.MSTY_Alpha;
	C.DrawColor = Controller.BackgroundBoxColor;
	DrawBackground(C, xPos, yPos - 0.5*YL, xRight - xPos, YL);

	role = GetPlayerRole(index);
	if (IsUSMode())
	{
		iconPortrait = PortraitUS[role];
		iconWeapon1 = WeaponUS[role*2];
		iconWeapon2 = WeaponUS[role*2+1];
		sName = StringListRolesUS[role];
	}
	else
	{
		iconPortrait = PortraitDE[role];
		iconWeapon1 = WeaponDE[role*2];
		iconWeapon2 = WeaponDE[role*2+1];
		sName = StringListRolesDE[role];
	}

	if (!LobbyHasPlayer(index))
	{
		C.CanvasIconSetColor(iconPortrait, 150,150,150,255);
		C.CanvasIconSetColor(iconWeapon1, 150,150,150,255);
		C.CanvasIconSetColor(iconWeapon2, 150,150,150,255);
		sName = StringWaitingForPlayer;
	}

	// draw the portrait
	xPos = xPos0 + 0.75*XL;
	yPos = yPos0 + 0.2*YL;
	C.DrawCanvasIcon(xPos, yPos, 1.2*Controller.CanvasAspectScale, 1.2*Controller.CanvasScaleY, iconPortrait);

	// draw the weapons
	wScale = FMin(1.0, 100.0/float(iconWeapon1.VL));
	xPos = xPos0 + 0.75*XL + 90*Controller.CanvasAspectScale;
	yPos = yPos0 + 0.2*YL;
	C.DrawCanvasIcon(xPos, yPos, 1.2*Controller.CanvasAspectScale, wScale*Controller.CanvasScaleY, iconWeapon1);

	wScale = FMin(1.0, 100.0/float(iconWeapon2.VL));
	xPos = xPos0 + 0.75*XL + 130*Controller.CanvasAspectScale;
	yPos = yPos0 + 0.2*YL;
	C.DrawCanvasIcon(xPos, yPos, 1.2*Controller.CanvasAspectScale, wScale*Controller.CanvasScaleY, iconWeapon2);

	// draw slot name
	xPos = xPos0;
	yPos = yPos0 + 0.2*YL;
	YL = 0.3*YL - 4.0*Controller.CanvasScaleY;
	xRight = HorizontalOffset(1.0);

	C.DrawColor = GetPlayerColor(index);
	DrawBackground(C, xPos, yPos, xRight - xPos, YL, 2.0, 2.0);

	C.DrawColor = Controller.BackgroundBoxColor;
	DrawBackground(C, xPos, yPos, xRight - xPos, YL);

	xPos += HorizontalOffset(0.05);
	xRight = HorizontalOffset(0.96);
	RoleChooser[0].MyLabel.Style.DrawTextToFit( C, MSAT_Blurry, xPos, yPos, xRight - xPos, YL, TXTA_Center, sName );

	// draw team icon
	xPos = xPos0;
	yPos = yPos0;

	if (!IsUSMode())
	{
		IconBackGerman.DrawColor.A = 255;
		IconGerman.DrawColor.A = 255;

		C.DrawCanvasIconComposite(	xPos, yPos,
							TEAM_ICON_SCALE_WAIT * Controller.CanvasAspectScale,
							TEAM_ICON_SCALE_WAIT * Controller.CanvasScaleY,
							IconGerman, IconBackGerman );

		IconBackGerman.DrawColor.A = default.IconBackGerman.DrawColor.A;
		IconGerman.DrawColor.A = default.IconGerman.DrawColor.A;
	}
	else
	{
		IconBackUSA.DrawColor.A = 255;
		IconUSA.DrawColor.A = 255;

		C.DrawCanvasIconComposite(	xPos, yPos,
							TEAM_ICON_SCALE_WAIT * Controller.CanvasAspectScale,
							TEAM_ICON_SCALE_WAIT * Controller.CanvasScaleY,
							IconUSA, IconBackUSA );

		IconBackUSA.DrawColor.A = default.IconBackUSA.DrawColor.A;
		IconUSA.DrawColor.A = default.IconUSA.DrawColor.A;
	}
}


function bool ScreenOnDrawPre(Canvas C)
{
	local float xLeft,xPos, yPos, XL, YL;

	if (!bVisible)
		return false;

	C.Style = EMenuRenderStyle.MSTY_Alpha;
	C.DrawColor = Controller.BackgroundBoxColor;

	lblHighScores.DrawComponentBackground(C);

	if (IsWaitLobby())
	{
		DrawPlayerPanel(C, 0);
		DrawPlayerPanel(C, 1);
	}
	else
	{
		Controller.CanvasIconSize(IconBackUSA, XL, YL, TEAM_ICON_SCALE, TEAM_ICON_SCALE);

		xPos = HorizontalOffset(0.49) - 0.5*XL;
		xLeft = -0.03 * ActualWidth();

		// draw the backdrop
		C.DrawColor = Controller.BackgroundBoxColor;
		yPos = VerticalOffset(fRoleTabMid);
		DrawBackground(C, xLeft, yPos - 0.5*YL, xPos - xLeft, YL);

		yPos = VerticalOffset(fRoleTabMid);
		if (!IsUSMode())
		{
			IconBackGerman.DrawColor.A = 255;
			IconGerman.DrawColor.A = 255;

			C.DrawCanvasIconComposite(	xPos, yPos,
								TEAM_ICON_SCALE * Controller.CanvasAspectScale,
								TEAM_ICON_SCALE * Controller.CanvasScaleY,
								IconGerman, IconBackGerman );

			IconBackGerman.DrawColor.A = default.IconBackGerman.DrawColor.A;
			IconGerman.DrawColor.A = default.IconGerman.DrawColor.A;
		}
		else
		{
			IconBackUSA.DrawColor.A = 255;
			IconUSA.DrawColor.A = 255;

			C.DrawCanvasIconComposite(	xPos, yPos,
								TEAM_ICON_SCALE * Controller.CanvasAspectScale,
								TEAM_ICON_SCALE * Controller.CanvasScaleY,
								IconUSA, IconBackUSA );

			IconBackUSA.DrawColor.A = default.IconBackUSA.DrawColor.A;
			IconUSA.DrawColor.A = default.IconUSA.DrawColor.A;
		}

		C.DrawColor = GetPlayerColor(0);
		RoleChooser[0].DrawComponentBackground(C,2.0,2.0);

		if (LobbyHasPlayer(1))
		{
			C.DrawColor = GetPlayerColor(1);
			RoleChooser[1].DrawComponentBackground(C,2.0,2.0);
		}
	}

	return Super.ScreenOnDrawPre(C);
}

function bool ScreenOnDraw(Canvas C)
{
	local bool result;
	local float xRight, xPos, yPos, XL, YL;
	local Canvas.CanvasIcon iconFront, iconBack;
	local int i, score,score1, mode, skill;
	local Color colBack;

	result = Super.ScreenOnDraw(C);

	mode = int(GetUIModeChoice());
	skill = SkillChooser.GetIndex();

	if (mode == 0)
	{
		i = 0;
		GetHighScoreInfo(score, i, MissionList.GetExtra(), mode, skill);
		i = 1;
		GetHighScoreInfo(score1, i, MissionList.GetExtra(), mode, skill);

		score = Max(score,score1) - 1;
		if (!IsUSMode())
		{
			iconFront = IconGerman;
			iconBack = IconBackGerman;
		}
		else
		{
			iconFront = IconUSA;
			iconBack = IconBackUSA;
		}

		colBack = iconBack.DrawColor;
		Controller.CanvasIconSize(iconBack, XL, YL, 1.2, 1.2);
		XL *= 1.1;
		xRight = MissionDisplay.HorizontalOffset(0.15);

		for (i=0; i<4; i++)
		{
			xPos = xRight + (XL*i);
			yPos = MissionDisplay.imgMission.VerticalOffset(0.95) - 0.5*YL;

			if (score >= i)
			{
				if (i == skill)
				{
					iconFront.DrawColor.A = 255;
					iconBack.DrawColor.A = 255;
				}
				else
				{
					iconFront.DrawColor.A = 192;
					iconBack.DrawColor.A = 192;
				}

				C.DrawCanvasIconComposite(	xPos, yPos,
									1.2 * Controller.CanvasAspectScale,
									1.2 * Controller.CanvasScaleY,
									iconFront, iconBack );
			}
			else
			{
				C.CanvasIconSetColor(iconBack, 50,50,50,255);
				if (i == skill)
				{
					iconFront.DrawColor.A = 255;
					iconBack.DrawColor.A = 255;
				}
				else
				{
					iconBack.DrawColor.A = 90;
					iconFront.DrawColor.A = 90;
				}

				C.DrawCanvasIconComposite(	xPos, yPos,
									1.2 * Controller.CanvasAspectScale,
									1.2 * Controller.CanvasScaleY,
									iconFront, iconBack );

				iconBack.DrawColor = colBack;
			}
		}
	}
	else if (mode == 3)
	{
		i = 0;
		GetHighScoreInfo(score, i, MissionList.GetExtra(), mode, 0);
		i = 1;
		GetHighScoreInfo(score1, i, MissionList.GetExtra(), mode, 0);

		score = Max(score,score1);
		if (score > 0)
		{
			if (!IsUSMode())
				iconFront = class'gbx_SkirmishGameOver'.default.MedalDE;
			else
				iconFront = class'gbx_SkirmishGameOver'.default.MedalUS;

			C.DrawColor = iconFront.DrawColor;
			C.SetPos(MissionDisplay.imgMission.HorizontalOffset(0.05), MissionDisplay.imgMission.VerticalOffset(0.95) - 0.2475*MissionDisplay.ActualHeight());
			C.DrawTile(iconFront.Icon, 0.12*MissionDisplay.ActualWidth(), 0.2475*MissionDisplay.ActualHeight(),
						iconFront.U, iconFront.V, iconFront.UL, iconFront.VL );
		}
	}

	return result;
}

function SetPlayerNameForPlayerMarkerLabel(int labelIndex, int localPlayerIndex, optional int clientIndex, optional string PlayerName, optional string GamerTag)
{
	if (PlayerName == "")
	{
		SetupPlayerStatusInfo(labelIndex, localPlayerIndex, class'gbx_MPLobby'.default.StrSlotEmpty);
		lblProfileName[labelIndex].TextColor = class'gbxMP.WargameMultiplayerScoreboard'.default.PlayerColors[4];
	}
	else
	{
		SetupPlayerStatusInfo(labelIndex, localPlayerIndex, PlayerName, GamerTag);

		lblProfileName[labelIndex].TextColor = class'gbxMP.WargameMultiplayerScoreboard'.default.PlayerColors[clientIndex];
		lblProfileName[labelIndex].TextColor.A = 255;
	}
}


// =======================================================================================================================================================
// Input Handling
// =======================================================================================================================================================
function CycleServerFocus(bool bPrev, optional int startPos)
{
	local int i, start;

	if (startPos < 0)
	{
		if (bPrev)
			start = 0;
		else
			start = ServerControlList.Length-1;
	}
	else if (startPos > 0)
	{
		if (bPrev)
			start = ServerControlList.Length-1;
		else
			start = 0;
	}
	else
	{
		for (i=0; i<ServerControlList.Length; i++)
		{
			if (ServerControlList[i] == FocusedControl)
			{
				start = i;
				break;
			}
		}

		if (i == ServerControlList.Length)
		{
			ServerControlList[0].SetFocus(None);
			return;
		}
	}

	if (bPrev)
	{
		i = start;
		do
		{
			i--;
			if (i < 0)
				i = ServerControlList.Length-1;

			if (!ServerControlList[i].bDisabled && ServerControlList[i].bVisible)
			{
				ServerControlList[i].SetFocus(None);
				return;
			}
		}
		until (i == start)
	}
	else
	{
		i = start;
		do
		{
			i++;
			if (i >= ServerControlList.Length)
				i = 0;

			if (!ServerControlList[i].bDisabled && ServerControlList[i].bVisible)
			{
				ServerControlList[i].SetFocus(None);
				return;
			}
		}
		until (i == start)
	}
}

function bool LobbyOnXControllerEvent(byte Id, eXControllerCodes iCode)
{
	if (Id == ServerControllerId)
	{
		switch(iCode)
		{
			case XC_PadUp:
				CycleServerFocus(true);
				return true;

			case XC_PadDown:
				CycleServerFocus(false);
				return true;

		}

		return SAB_OnXControllerEvent(Id, iCode);
	}
	else if (Id == ClientControllerId)
	{
		return SAB_OnXControllerEvent(Id, iCode);
	}

	return true;
}

function bool LobbyOnKeyEvent(out byte Key,out byte State,float delta)
{
	if (!editText.bHasfocus && (State == 1))
	{
		if (Key == 38)
		{
			if (hBtnA.bHasFocus || hBtnB.bHasFocus)
				CycleServerFocus(true, 1);
			else
				CycleServerFocus(true);

			return true;
		}
		else if (Key == 40)
		{
			if (hBtnA.bHasFocus || hBtnB.bHasFocus)
				CycleServerFocus(false, -1);
			else
				CycleServerFocus(false);

			return true;
		}
	}

	return SAB_KeyEvent(Key, State, delta);
}

function OnAButton()
{
	if (Controller.ControllerId == ServerControllerId)
	{
		SetPlayerReady(0, true);
	}
	else if (Controller.ControllerId == ClientControllerId)
	{
		SetPlayerReady(1, true);
	}
}

function OnBButton()
{
	if (Controller.ControllerId == ServerControllerId)
	{
		SetPlayerReady(0, false);
	}
	else if (Controller.ControllerId == ClientControllerId)
	{
		SetPlayerReady(1, false);
	}
}

function SetSpinIndex(GUISpinListControl spn, int index)
{
	if (spn.GetIndex() != index)
		spn.SetIndex(index);
}

// =======================================================================================================================================================
// tour of duty management
// =======================================================================================================================================================
function string GetNextToDMap(optional string currentMap)
{
	return class'WargameSkirmish'.static.GetNextToDMap(IsUSMode(), currentMap);
}

function bool ReEnableToDMode()
{
	if (bIsToDMode)
	{
		EnableToDMode(false);
		EnableToDMode(true);
	}

	return bIsToDMode;
}

function string GetProfileNameForPlayer(PlayerReplicationInfo PRI)
{
	local string result;
	local PlayerController PC;

	PC = class'gbx_MPLobbyPlayer'.static.FindPlayerControllerForPRI(PlayerOwner(), PRI);
	if ((PC != None) && (Viewport(PC.Player) != None))
	{
		result = PC.ProfileName;
	}
	GUILog("GetProfileNameForPlayer for" @PRI @PC @result);

	return result;
}

function bool SkillLevelMissingFromList(int newSkill)
{
	local string S;
	local int i;

	if (newSkill <= UNLOCKED_TOUR_COUNT)
		return false;

	S = String(newSkill);
	for (i=0; i<ToDSkillLevels.Length; i++)
	{
		if (S ~= ToDSkillLevels[i])
			return false;
	}

	return true;
}

function TryAddToDLevel(int newSkill)
{
	local int i;
	local string S;

	// exclude first 3 levels
	if (newSkill <= UNLOCKED_TOUR_COUNT)
		return;

	S = String(newSkill);
	for (i=0; i<ToDSkillLevels.Length; i++)
	{
		if (S ~= ToDSkillLevels[i])
			return;
	}

	GUILog("Adding" @newSkill @" to ToD skill list");
	i = ToDSkillLevels.Length;
	ToDSkillLevels.Length = i+1;
	ToDSkillLevels[i] = S;
}

// =======================================================================================================================================================
// High score display
// =======================================================================================================================================================
function GetHighScoreInfo(out int Score, out int playerIndex, string mapName, int modechoice, int skillChoice)
{
	playerIndex = -1;
	Score = 0;
}

function bool ShouldDisplayPlayerNum() { return false; }

function CycleHighScoreInfo()
{
	local int Score, modeChoice, skillChoice;
	local string out, strScore;

	modeChoice = int(GetUIModeChoice());

	if (modeChoice == 3)
		skillChoice = 0;
	else
		skillChoice = SkillChooser.GetIndex();

	Score = -1;
	if (fNextToggleHSTime <= 0.0)
	{
		DisplayedPlayerHS = -1;
		GetHighScoreInfo(Score, DisplayedPlayerHS, MissionList.GetExtra(), modeChoice, skillChoice);
	}
	else if (PlayerOwner().Level.UniversalTimeSeconds >= fNextToggleHSTime)
	{
		DisplayedPlayerHS++;
		GetHighScoreInfo(Score, DisplayedPlayerHS, MissionList.GetExtra(), modeChoice, skillChoice);
	}

	if (Score != -1)
	{
		if (DisplayedPlayerHS != -1)
		{
			switch(modeChoice)
			{
				case 1:	// SGT_TimeChallenge
					if ((skillChoice >= 0) && (skillChoice <= 3))
					{
						out = StringHSTimed;
						if (Score == 0)
							strScore = StringHSNone;
						else
							strScore = class'Scoreboard'.static.FormatTime( Score );
					}
					break;
				case 2:	// SGT_Defense
					out = StringHSDefense;
					if (Score == 0)
						strScore = StringHSNone;
					else
						strScore = String(Score);
					break;
				case 3:	// SGT_TourOfDuty
					out = StringHSToD;
					if (Score == 0)
						strScore = StringHSNone;
					else
						strScore = String(Score-1);	// completed up to "last" tour
					break;

				case 0:	// SGT_Objective
				default:
					break;
			}

			if (out != "")
			{
				ReplaceText(out, "<SCORE>", strScore);
				lblHighScores.TextColor = lblProfileName[DisplayedPlayerHS].TextColor;

				if (ShouldDisplayPlayerNum())
				{
					out = "("$String(DisplayedPlayerHS+1) $ class'gbx_MPLobbyPlayerMarker'.default.StrPlayerNum $")" @out;
				}
			}
		}
		else
		{
			out = GetSelectedMissionName() $ strScore;
			lblHighScores.TextColor = default.lblHighScores.TextColor;
		}

		if (out != "")
		{
			lblHighScores.SetCaption(out);
			ForceScoresUpdate(2.0);
		}
	}
}

function ForceScoresUpdate(optional float fDelay)
{
	if (fDelay == 0.0)
		fNextToggleHSTime = -1.0;
	else
		fNextToggleHSTime = PlayerOwner().Level.UniversalTimeSeconds + fDelay;
}

function int GetScoreFromManifest(Manifest.ManifestEntry mEntry, int modeChoice, string mapName, optional bool bCoop, optional int ToDIndex)
{
	if (modeChoice == -1)
		modeChoice = int(GetUIModeChoice());

	return savedGameManifest.GetScore(mEntry, modeChoice, mapName, bCoop, ToDIndex);
}

// =======================================================================================================================================================
// Countdown stuff
// =======================================================================================================================================================
/*
state CountDownBase
{
	// No cursors in the countdown
	function DrawPlayerCursor(Canvas C, int localPlayerNum)
	{
	}

	function Timer()
	{
		local string text;
		local int i;
		local int time;

		time = PlayerOwner().GameReplicationInfo.LobbyCountdownTime;

		if (time > 0)
		{
			i = InStr(StrCountdown, "%time%", true);

			if (i != -1)
			{
				text = Left(StrCountdown, i) $ time $ Mid(StrCountdown, i + 6);
			}
			else
			{
				text = StrCountdown;
			}

			if (text != lblMissionTitle.Caption)
			{
				PlayerOwner().PlaySound(CountdownProgressSound, SLOT_Interact, 1.0, false );
			}

			lblMissionTitle.SetCaption(text);
		}
	}

	// Eat all the input
	function bool LobbyOnXControllerEvent(byte Id, eXControllerCodes iCode)
	{
		return true;
	}

	function bool LobbyOnKeyEvent(out byte Key,out byte State,float delta)
	{
		return true;
	}

	function HideUnwantedControls()
	{
		CountdownCaptionA = hbtnA.Caption;
		SetupAButton("");

		CountdownCaptionB = hbtnB.Caption;
		SetupBButton("");

		CountdownCaptionX = hbtnX.Caption;
		SetupXButton("");

		CountdownCaptionY = hbtnY.Caption;
		SetupYButton("");
	}

	function UnHideUnwantedControls()
	{
		SetupAButton(CountdownCaptionA);
		SetupBButton(CountdownCaptionB);
		SetupXButton(CountdownCaptionX);
		SetupYButton(CountdownCaptionY);

		ResetMissionTitle();
	}
}
*/
defaultproperties
{
	bAllowedAsLast=true
	bRequireFullScreen=true

	ScreenTitle="Skirmish"

	IconUSA=(Icon=Texture't_interface_mb.hud.interface_comp',U=276,V=99,UL=29,VL=29,DrawColor=(R=128,G=128,B=128,A=200),ScaleX=0.8,ScaleY=0.8,PivotU=0.5,PivotV=0.5)
	IconGerman=(Icon=Texture't_interface_mb.hud.interface_comp',U=305,V=99,UL=29,VL=29,DrawColor=(R=0,G=0,B=0,A=200),ScaleX=0.8,ScaleY=0.8,PivotU=0.5,PivotV=0.5)

	IconBackUSA=(Icon=Texture't_interface_mb.hud.interface_comp',U=192,V=131,UL=46,VL=46,DrawColor=(R=44,G=52,B=24,A=255),ScaleX=0.8,ScaleY=0.8,PivotU=0.5,PivotV=0.5)
	IconBackGerman=(Icon=Texture't_interface_mb.hud.interface_comp',U=192,V=131,UL=46,VL=46,DrawColor=(R=90,G=28,B=21,A=255),ScaleX=0.8,ScaleY=0.8,PivotU=0.5,PivotV=0.5)

	IconRole(0)=(Icon=Texture't_interface_mb.hud.interface_comp',U=132,V=93,UL=40,VL=36,DrawColor=(R=0,G=0,B=0,A=255),ScaleX=0.7,ScaleY=0.7,PivotU=0.5,PivotV=0.5)	// SIT_UNIT_MOVE (icon_team_move)
	IconRole(1)=(Icon=Texture't_interface_mb.hud.interface_comp',U=214,V=105,UL=40,VL=24,DrawColor=(R=0,G=0,B=0,A=255),ScaleX=0.6,ScaleY=0.6,PivotU=0.5,PivotV=0.5)	// SIT_UNIT_FIRE (icon_team_fire)
	IconRole(2)=(Icon=Texture't_interface_mb.hud.interface_comp',U=176,V=106,UL=40,VL=23,DrawColor=(R=0,G=0,B=0,A=255),ScaleX=0.7,ScaleY=0.7,PivotU=0.5,PivotV=0.5)	// SIT_UNIT_TANK (icon_team_tank)

	PortraitUS(0)=(Icon=Texture't_interface_mb.baker_side',U=0,V=0,UL=64,VL=64,DrawColor=(R=255,G=255,B=255,A=255),ScaleX=1.0,ScaleY=1.0,PivotU=0.0,PivotV=1.0)
	PortraitUS(1)=(Icon=Texture't_interface_mb.hartsock_side',U=0,V=0,UL=64,VL=64,DrawColor=(R=255,G=255,B=255,A=255),ScaleX=1.0,ScaleY=1.0,PivotU=0.0,PivotV=1.0)
	PortraitDE(0)=(Icon=Texture't_interface_mb.infantry_hans',U=0,V=0,UL=64,VL=64,DrawColor=(R=255,G=255,B=255,A=255),ScaleX=1.0,ScaleY=1.0,PivotU=0.0,PivotV=1.0)
	PortraitDE(1)=(Icon=Texture't_interface_mb.infantry_lars',U=0,V=0,UL=64,VL=64,DrawColor=(R=255,G=255,B=255,A=255),ScaleX=1.0,ScaleY=1.0,PivotU=0.0,PivotV=1.0)

	// assault
	WeaponUS(0)=(Icon=None,U=0,V=0,UL=0,VL=0,DrawColor=(R=255,G=255,B=255,A=255),ScaleX=1.0,ScaleY=1.0,PivotU=0.0,PivotV=1.0) // WeapUSThompson
	WeaponUS(1)=(Icon=None,U=0,V=0,UL=0,VL=0,DrawColor=(R=255,G=255,B=255,A=255),ScaleX=1.0,ScaleY=1.0,PivotU=0.0,PivotV=1.0)	// WeapUSM1Carbine
	// fire
	WeaponUS(2)=(Icon=None,U=0,V=0,UL=0,VL=0,DrawColor=(R=255,G=255,B=255,A=255),ScaleX=1.0,ScaleY=1.0,PivotU=0.0,PivotV=1.0) // WeapUSBar
	WeaponUS(3)=(Icon=None,U=0,V=0,UL=0,VL=0,DrawColor=(R=255,G=255,B=255,A=255),ScaleX=1.0,ScaleY=1.0,PivotU=0.0,PivotV=1.0) // WeapUSM1_

	// assault
	WeaponDE(0)=(Icon=None,U=0,V=0,UL=0,VL=0,DrawColor=(R=255,G=255,B=255,A=255),ScaleX=1.0,ScaleY=1.0,PivotU=0.0,PivotV=1.0) // WeapDEMP40_
	WeaponDE(1)=(Icon=None,U=0,V=0,UL=0,VL=0,DrawColor=(R=255,G=255,B=255,A=255),ScaleX=1.0,ScaleY=1.0,PivotU=0.0,PivotV=1.0) // WeapDEK98_
	// fire
	WeaponDE(2)=(Icon=None,U=0,V=0,UL=0,VL=0,DrawColor=(R=255,G=255,B=255,A=255),ScaleX=1.0,ScaleY=1.0,PivotU=0.0,PivotV=1.0) // WeapDEFG42_
	WeaponDE(3)=(Icon=None,U=0,V=0,UL=0,VL=0,DrawColor=(R=255,G=255,B=255,A=255),ScaleX=1.0,ScaleY=1.0,PivotU=0.0,PivotV=1.0) // WeapDEK98_

	CountdownProgressSound=Sound'MP_MISC.COUNTDOWN'
	CountdownFinishedSound=Sound'MP_MISC.COUNTDOWN_END'

	ServerControllerId=-1
	ClientControllerId=-1

	// high scores display
	Begin Object Class=GUILabel name=cHighScores
		StyleName="MenuOptionLabel"
		TextColor=(R=161,G=161,B=133,A=255)
		TextAlign=TXTA_Center
		bUseTextColorForStyle=true
		DrawMenuState=1
		bAcceptsInput=false
		bNeverFocus=true
		bTabStop=false
		bDrawToFit=true
		bTransparent=false
		bForceCaps=false
		WinTop=0.08// NOMERGE 0.1525
		WinWidth=0.450
		WinLeft=0.500000
		WinHeight=0.05
	End Object
	lblHighScores=cHighScores
	StringHSToD="Highest Tour Completed : <SCORE>"
	StringHSDefense="Most Waves Completed : <SCORE>"
	StringHSTimed="Best Time Remaining : <SCORE>"
	StringHSNone="None"
	fNextToggleHSTime=-1.0

	// team chooser
	StringListTeams=("Team : American","Team : German")
	Begin Object Class=moSpinListControl name=cTeamChooser
		bFocusOnWatch=true
		LabelJustification=TXTA_Right
		CaptionWidth=0
		ComponentWidth=1
		WinTop=0.08// NOMERGE 0.1525
		WinWidth=0.45
		WinLeft=0.04
		WinHeight=0.05
		bHeightFromComponent=false
	End Object
	TeamChooser=cTeamChooser

	// mission chooser
	StringCaptionMission="Mission"
	StringCaptionMissionUnknown="(Missing)"
	Begin Object Class=gbx_MissionDisplay Name=cLobbyMissionDisplay
		WinTop=0.125// NOMERGE 0.1975000
		WinWidth=0.450
		WinHeight=0.580000
		WinLeft=0.500000
		bDisplayMissingInfo=true
	End Object
	MissionDisplay=cLobbyMissionDisplay
	Begin Object Class=moSpinListControl name=cMissionList
		bFocusOnWatch=true
		LabelJustification=TXTA_Right
		CaptionWidth=0
		ComponentWidth=1
		WinTop=0.14// NOMERGE 0.21
		WinWidth=0.45
		WinLeft=0.04
		WinHeight=0.05
		bHeightFromComponent=false
	End Object
	MissionList=cMissionList

	// role chooser
	fRoleTabMid=0.26
	StringListRolesUS=("Matt Baker","Joe Hartsock")
	StringListRolesDE=("Theodor Luether","Lukas Wilhelm")
	StringWaitingForPlayer="Waiting for Player..."
	Begin Object Class=GUISpinListControl name=cRoleChooser1
		bFocusOnWatch=true
		WinTop=0.21// NOMERGE
		WinWidth=0.34
		WinLeft=0.04
		WinHeight=0.045
	End Object
	RoleChooser(0)=cRoleChooser1
	Begin Object Class=GUISpinListControl name=cRoleChooser2
		bFocusOnWatch=true
		WinTop=0.27// NOMERGE
		WinWidth=0.34
		WinLeft=0.04
		WinHeight=0.045
	End Object
	RoleChooser(1)=cRoleChooser2

	// game type
	StringModeCaption="Skirmish Type"
	StringListModes=("Objective","Timed Assault","Defense","Tour of Duty")
	StringListModeId=("0","1","2","3")
	Begin Object Class=moSpinListControl Name=cModeChooser
		bFocusOnWatch=true
		LabelJustification=TXTA_Center
		CaptionWidth=0.50
		ComponentWidth=0.40
		WinWidth=0.45
		WinHeight=0.1000
		WinLeft=0.04
		WinTop=0.33// NOMERGE
		bHeightFromComponent=false
		bVerticalLayout=true
	End Object
	ModeChooser=cModeChooser

	// skill
	StringSkillCaption="Enemy Skill Level"
	StringSkillToDContinue="Tour <TOUR>"
	StringListSkills=("Novice","Intermediate","Advanced","Veteran","Custom")
	Begin Object Class=moSpinListControl Name=cSkillChooser
		bFocusOnWatch=true
		LabelJustification=TXTA_Center
		CaptionWidth=0.50
		ComponentWidth=0.40
		WinWidth=0.45
		WinHeight=0.1000
		WinLeft=0.04
		WinTop=0.43// NOMERGE
		bHeightFromComponent=false
		bVerticalLayout=true
	End Object
	SkillChooser=cSkillChooser

	// custom skill
	StringCustomSkillCaption=("Accuracy","Tactics","Suppression")
	StringListCustomSkills=("1","2","3","4","5","6","7","8","9","10")
	StringListCustomSkills1=("1","2","3","4")
	Begin Object Class=moSpinListControl Name=cSkillCustom1
		bFocusOnWatch=true
		LabelJustification=TXTA_Right
		CaptionWidth=0.65
		ComponentWidth=0.30
		WinWidth=0.45
		WinHeight=0.052000
		WinLeft=0.04
		WinTop=0.53// NOMERGE
		bHeightFromComponent=false
	End Object
	SkillCustomChooser(0)=cSkillCustom1
	Begin Object Class=moSpinListControl Name=cSkillCustom2
		bFocusOnWatch=true
		LabelJustification=TXTA_Right
		CaptionWidth=0.65
		ComponentWidth=0.30
		WinWidth=0.45
		WinHeight=0.052000
		WinLeft=0.04
		WinTop=0.58// NOMERGE
		bHeightFromComponent=false
	End Object
	SkillCustomChooser(1)=cSkillCustom2
	Begin Object Class=moSpinListControl Name=cSkillCustom3
		bFocusOnWatch=true
		LabelJustification=TXTA_Right
		CaptionWidth=0.65
		ComponentWidth=0.30
		WinWidth=0.45
		WinHeight=0.052000
		WinLeft=0.04
		WinTop=0.63// NOMERGE
		bHeightFromComponent=false
	End Object
	SkillCustomChooser(2)=cSkillCustom3

	DefaultSkillLevel=1
	skillEasy(0)=0
	skillEasy(1)=0
	skillEasy(2)=0

	skillNormal(0)=2
	skillNormal(1)=1
	skillNormal(2)=2

	skillHard(0)=4
	skillHard(1)=2
	skillHard(2)=4

	skillAuthentic(0)=6
	skillAuthentic(1)=3
	skillAuthentic(2)=6

	skillCustom(0)=5
	skillCustom(1)=2
	skillCustom(2)=5

	Begin Object Class=GUIScrollTextBox Name=ctxtChatBox_SK
		WinWidth=0.9
		WinHeight=0.17
		WinLeft=0.05
		WinTop=0.71
		RenderWeight=0.45
		InitialDelay=0.0
		CharDelay=0.075
		EOLDelay=0.075
		bNoTeletype=true
		bNoTeletypeCursor=true
		bVisibleWhenEmpty=true
		bTabStop=false
	End Object
	txtChatBox=ctxtChatBox_SK
}
class gbx_SkirmishLobbyClientOnline extends gbx_SkirmishLobby;
// used for system link, live

var PlayerReplicationInfo			ServerPlayer;
var PlayerReplicationInfo			ClientPlayer;
var GUIComponent					OldClientFocusComp;
var bool							bUnknownMapSelected;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	GUILog("Opening online client skirmish lobby....");

	EnableClientComponents(true);
}

event HandleParameters( string Param1, string Param2 )
{
	Super.HandleParameters(Param1, Param2);

	EnableServerComponents(false);
}

function int GetMaxPlayers()
{
	return GRI.MaxPlayers;
}

function EnableClientComponents(bool bEnable)
{
	if (IsWaitLobby())
		bEnable = false;

	if (!bEnable)
		OldClientFocusComp = FocusedControl;

	Super.EnableClientComponents(bEnable);

	if (bEnable)
	{
		OldClientFocusComp.SetFocus(None);
		OldClientFocusComp = None;
	}
}

function bool PlayerIsReady(int playerIndex) 
{
	if (!LobbyHasPlayer(playerIndex))
		return false;

	if (playerIndex == 0)
		return ServerPlayer.bLobbyAttached;
	else
		return ClientPlayer.bLobbyAttached;
}

function bool LocalPlayersReady()
{
	return PlayerIsReady(1);
}

function bool LobbyHasPlayer(int playerIndex) 
{
	return (playerIndex == 0) || (ClientPlayer != None);
}

function SetPlayerReady(int playerIndex, bool bReady)
{
	if (playerIndex == 0)
	{
		return;
	}
	else
	{
		if (ClientPlayer != None)
		{
			ClientPlayer.SetLobbyAttached(bReady);
			ClientPlayer.bLobbyAttached = bReady;	// takes time to propagate so set manually
		}
		else
		{
			return;
		}
	}

	Super.SetPlayerReady(playerIndex, bReady);
}

function string GetSelectedMissionName()
{
	if (MissionList.GetExtra() == "-1")
	{
		return GRI.Skirmish_Mission;
	}

	return Super.GetSelectedMissionName();
}

function PopulateMissionList(gbxMPMissionList.EMissionGameType gameType)
{
	Super.PopulateMissionList(gameType);

	MissionList.Add(StringCaptionMission @StringCaptionMissionUnknown,, "-1");
}

function bool LobbyOnKeyEvent(out byte Key,out byte State,float delta)
{
	return SAB_KeyEvent(Key, State, delta);
}

function OnAButton()
{
	if (IsWaitLobby() || PlayerIsReady(1))
	{
		return;
	}
	else if (bUnknownMapSelected)
	{
		Controller.OpenMenu("GUI.gbx_DlgMissingMap", GRI.Skirmish_Mission);
		return;
	}

	Super.OnAButton();
}

function OnBButton()
{
	if (!PlayerIsReady(1) || IsWaitLobby())
	{
		Controller.PlayClickSound(EClickSound.CS_Back);
		Controller.OpenMenu(class'GameEngine'.default.PopupMPMenuClass, "NOCLOSEALL");
		return;
	}

	Super.OnBButton();
}

function Timer()
{
	local int i;

	ServerPlayer = FindRemotePlayer();

	Super.Timer();

	// update the ui to match the GRI
	i = MissionList.MySpinListControl.Find(GRI.Skirmish_Mission, true);
	bUnknownMapSelected = (i == -1);
	if (bUnknownMapSelected)
	{
		if (PlayerIsReady(1) && !IsWaitLobby())
		{
			SetPlayerReady(1, false);
		}

		i = MissionList.ItemCount() - 1;
	}

	SetSpinIndex(MissionList.MySpinListControl, i );

	SetSpinIndex(TeamChooser.MySpinListControl, GRI.Skirmish_Team );
	SetUIModeChoice( ESkirmishGameType(GRI.Skirmish_Mode) );
	SetSpinIndex(SkillChooser.MySpinListControl, GRI.Skirmish_Skill );
	SetSpinIndex(SkillCustomChooser[0].MySpinListControl, GRI.Skirmish_Skills[0] );
	SetSpinIndex(SkillCustomChooser[1].MySpinListControl, GRI.Skirmish_Skills[1] );
	SetSpinIndex(SkillCustomChooser[2].MySpinListControl, GRI.Skirmish_Skills[2] );

	SetSpinIndex(RoleChooser[0], ServerPlayer.LobbyPlayerSlot);
	SetSpinIndex(RoleChooser[1], ClientPlayer.LobbyPlayerSlot);

	SetupPlayerNames();

	if (!PlayerIsReady(1))
	{
		if (IsWaitLobby())
		{
			SetPlayerReady(1, true);
			SetupAButton();
			SetupBButton(class'gbx_MPLobby'.default.StrMenu);
		}
		else
		{
			SetupAButton(class'gbx_MPLobby'.default.StrReady);
			SetupBButton(class'gbx_MPLobby'.default.StrMenu);
		}
	}
	else
	{
		SetupAButton();
		if (!IsWaitLobby())
			SetupBButton(class'gbx_MPLobby'.default.StrUnReady);
		else
			SetupBButton(class'gbx_MPLobby'.default.StrMenu);
	}
}

function CheckForToDSkillChange()
{
	// check for changes to the skirmish tod skill list from the GRI and reload the UI if changes were found.
	if (SkillLevelMissingFromList(GRI.Skirmish_ToDSkills[0]) || SkillLevelMissingFromList(GRI.Skirmish_ToDSkills[1]))
	{
		GUILog("CheckForToDSkillChange: Client detected new ToD levels");

		ToDSkillLevels.Length = 0;
		TryAddToDLevel(GRI.Skirmish_ToDSkills[0]);
		TryAddToDLevel(GRI.Skirmish_ToDSkills[1]);

		ReEnableToDMode();
	}
}

function FindClient(optional bool bForceUpdate)
{
	// hook up the controller ID when it is available
	if (ClientControllerId == -1)
	{
		Controller.LoadPlayerControllerBindings();
		ClientControllerId = Controller.GetControllerIndexForPlayer(0);
		GUILog("Found client player controller" @ClientControllerId);
	}

	// detect changes to the client player
	if (bForceUpdate || (ClientPlayer != PlayerOwner().PlayerReplicationInfo))
	{
		ClientPlayer = PlayerOwner().PlayerReplicationInfo;
		GRI = PlayerOwner().GameReplicationInfo;

		GUILog("Found client player" @ClientPlayer);
		if (IsWaitLobby())
		{
			GUILog("Setting ready in wait lobby");
			SetPlayerReady(1, true);
		}

		// initialize gui
		SetSpinIndex(RoleChooser[1], ClientPlayer.LobbyPlayerSlot);
	}
}

function bool InitLocalPlayers()
{
	// as with the server, this check needs delayed a bit as it can take some time for these to be set up properly
	if ((ClientPlayer != None) && (class'gbx_ProfileManager'.Static.GetProfileForController(self, 0) != ""))
	{
		if(savedGameManifest.GetManifestEntry(meClient, class'gbx_ProfileManager'.Static.GetProfileForController(self, 0)))
		{
			ClientPlayer.SetSkirmishToDLevel( GetScoreFromManifest(meClient, 3, "", true, 1), GetScoreFromManifest(meClient, 3, "", true, 2) );
			return true;
		}
	}

	return false;
}

function bool ReEnableToDMode()
{
	local bool result;

	result = Super.ReEnableToDMode();
	if (result)
	{
		SetSpinIndex(SkillChooser.MySpinListControl, GRI.Skirmish_Skill );
	}

	return result;
}

function bool ShouldShowControllerInfo(int inPlayerIndex)
{
	return (inPlayerIndex < GetMaxPlayers());
}

function GetHighScoreInfo(out int Score, out int playerIndex, string mapName, int modechoice, int skillChoice)
{
	Score = -1;

	if (playerIndex == 0)
	{
		Score = GetScoreFromManifest(meClient, modechoice, mapName, true, skillChoice);
	}

	if (Score == -1)
	{
		playerIndex = -1;
		Super.GetHighScoreInfo(Score, playerIndex, mapName, modeChoice, skillChoice);
	}
}

defaultproperties
{
}
class gbx_SkirmishLobbyServer extends gbx_SkirmishLobby
	Abstract;

var GUIComponent							OldServerFocusComp;

var int										DefaultMissionChoice;
var bool									bIsLobbyMap;
var bool									bChangingRole;	// set while the server is toggling the player roles
var bool									bChangingType;	// set while the server is toggling the game type

var WargameSkirmish							MySkirmish;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	MySkirmish = WargameSkirmish(PlayerOwner().Level.Game);
	DefaultSkillLevel = default.DefaultSkillLevel;

	GRI = MyController.ViewportOwner.Actor.GameReplicationInfo;
}

event HandleParameters( string Param1, string Param2 )
{
	local int i;

	Super.HandleParameters(Param1, Param2);

	// set the team chooser
	i = class'gbxMPMissionList'.static.FindMapIndex(PlayerOwner().Level.GetLevelFileName());
	bIsLobbyMap = class'gbxMPMissionList'.static.GetGameType(i) == MGT_Lobby;

	if ((i == -1) || (class'gbxMPMissionList'.static.GetGameType(i) != MGT_Skirmish_DE))
		TeamChooser.SetIndex(0);
	else
		TeamChooser.SetIndex(1);

	// find and pick the mission
	i = MissionList.MySpinListControl.Find(PlayerOwner().Level.GetLevelFileName(), true);
	if (i == -1) i = 0;
	GUILog("gbx_SkirmishLobbyServer found map " $i);
	MissionList.SetIndex(i);

	InitSkillPreset();
}

function InitSkillPreset()
{
	local int diff;
	local int sLevels[NUM_SKILLSETS];
	//Log( " gbx_SkirmishLobbyServer::InitSkillPreset()", 'MP' );

	if ((MySkirmish != None) && !bIsLobbyMap)
	{
		SetUIModeChoice(MySkirmish.GameType);

		if (MySkirmish.PlayerRoleChoice[0] == UnitType_Base)
			RoleChooser[0].SetIndex(1);
		else
			RoleChooser[0].SetIndex(0);

		if (bIsToDMode)
		{
			diff = SkillChooser.ItemCount()-1;
		}
		else
		{
			sLevels[0] = MySkirmish.iSkillSets[0];
			sLevels[1] = MySkirmish.iSkillSets[1];
			sLevels[2] = MySkirmish.iSkillSets[2];

			diff = FindDifficulty(sLevels);
			if (diff == 4)
			{
				skillCustom[0] = sLevels[0];
				skillCustom[1] = sLevels[1];
				skillCustom[2] = sLevels[2];
			}
		}

		SkillChooser.SetIndex(diff);
	}
	else
	{
		SkillChooser.SetIndex(DefaultSkillLevel);
		RoleChooser[0].SetIndex(0);
		SetUIModeChoice(SGT_Objective);
	}
}

function OnTeamChanged(int newTeam)
{
	Super.OnTeamChanged(newTeam);
	DoToDRefresh();
}

//function OnGameTypeChanged(int newGameIndex);

function OnMapChanged(string newMap)
{
	Super.OnMapChanged(newMap);

	if (!bIsToDMode)
	{
		DefaultMissionChoice = MissionList.GetIndex();
		if (DefaultMissionChoice == -1)
			DefaultMissionChoice = 0;
	}
}

function OnGameTypeChanged(int newGameIndex)
{
	//Log( " gbx_SkirmishLobbyServer::OnGameTypeChanged() newGameIndex="$newGameIndex, 'MP' );
	GRI.Skirmish_Mode = newGameIndex;

	Super.OnGameTypeChanged(newGameIndex);
	DoToDRefresh();
}

//function OnSkillChanged(int newSkillIndex, int skillLevels[NUM_SKILLSETS]);

function EnableServerComponents(bool bEnable)
{
	if (IsWaitLobby())
		bEnable = false;

	if (!bEnable)
		OldServerFocusComp = FocusedControl;

	Super.EnableServerComponents(bEnable);

	if (bEnable && (OldServerFocusComp != None))
	{
		Controller.FocusedControl = None;		// coax the focus into actually working

		OldServerFocusComp.SetFocus(None);
		OldServerFocusComp = None;
	}
}

function UIOnChangeRole(GUIComponent Sender)
{
	Super.UIOnChangeRole(Sender);

	if (!bChangingRole)
	{
		bChangingRole = true;
		if (Sender == RoleChooser[0])
		{
			if (RoleChooser[0].GetIndex() != -1)
				RoleChooser[1].SetIndex(1 - RoleChooser[0].GetIndex());
		}
		else if (Sender == RoleChooser[1])
		{
			if (RoleChooser[1].GetIndex() != -1)
				RoleChooser[0].SetIndex(1 - RoleChooser[1].GetIndex());
		}

		bChangingRole = false;
	}
}

function UIOnChangeSkill(GUIComponent Sender)
{
	local int sLevels[NUM_SKILLSETS];
	//Log( " gbx_SkirmishLobbyServer::UIOnChangeSkill()", 'MP' );

	GetSkillLevels(SkillChooser.GetIndex(), sLevels);

	SkillCustomChooser[0].SetIndex(sLevels[0]);
	SkillCustomChooser[1].SetIndex(sLevels[1]);
	SkillCustomChooser[2].SetIndex(sLevels[2]);
	EnableCustomSkills(SkillChooser.GetIndex() == 4);

	if (!bIsToDMode && !bChangingType && (GetUIModeChoice() != SGT_Defense) )
	{
		DefaultSkillLevel = SkillChooser.GetIndex();
	}

	Super.UIOnChangeSkill(Sender);
}

function UIOnChangeSkillCustom(GUIComponent Sender)
{
	if (SkillChooser.GetIndex() == 4)
	{
		if (Sender == SkillCustomChooser[0])
		{
			skillCustom[0] = SkillCustomChooser[0].GetIndex();
		}
		else if (Sender == SkillCustomChooser[1])
		{
			skillCustom[1] = SkillCustomChooser[1].GetIndex();
		}
		else if (Sender == SkillCustomChooser[2])
		{
			skillCustom[2] = SkillCustomChooser[2].GetIndex();
		}
	}

	Super.UIOnChangeSkillCustom(Sender);
}

function bool LobbyOnXControllerEvent(byte Id, eXControllerCodes iCode)
{
	if (Id == ServerControllerId)
	{
		// let through only A,B
		if (PlayerIsReady(0))
		{
			if ((iCode == XC_A) || (iCode == XC_Start) || (iCode == XC_B) || (iCode == XC_Back))
			{
				return Super.LobbyOnXControllerEvent(Id, iCode);
			}

			return true;
		}
	}
	else if (Id == ClientControllerId)
	{
		// let through only B
		if (PlayerIsReady(1))
		{
			if ((iCode == XC_B) || (iCode == XC_Back))
			{
				return Super.LobbyOnXControllerEvent(Id, iCode);
			}

			return true;
		}
	}

	return Super.LobbyOnXControllerEvent(Id, iCode);
}

function string GetRulesString()
{
	local string result;
	local int	 nCheckpointID;

	if (bIsToDMode)
	{
		result = "?SMode=" $int(GetUIModeChoice())
			$ "?SSkill=" $SkillChooser.GetIndex()
			$ "?SDiff1=" $SkillChooser.GetExtra()
			$ "?SRole=" $RoleChooser[0].GetIndex();
	}
	else
	{
		if ( GetUIModeChoice() != SGT_Defense )
		{
			result = "?SMode=" $int(GetUIModeChoice())
				$ "?SSkill=" $SkillChooser.GetIndex()
				$ "?SDiff1=" $SkillCustomChooser[0].GetIndex()
				$ "?SDiff2=" $SkillCustomChooser[1].GetIndex()
				$ "?SDiff3=" $SkillCustomChooser[2].GetIndex()
				$ "?SRole=" $RoleChooser[0].GetIndex();
		}
		else
		{
			result = "?SMode=" $int(GetUIModeChoice())
			$ "?SSkill=0"
			$ "?SDiff1=0"
			$ "?SDiff2=0"
			$ "?SDiff3=0"
			$ "?SRole=" $RoleChooser[0].GetIndex();
		}
	}

	nCheckpointID = PlayerOwner().Level.MissionManager.SkirmishLastSavedCheckpointID();
	if (nCheckpointID > 0)
	{
		result = result $ "?Checkpoint=" $nCheckpointID;
	}
	
	return result;
}

function Timer()
{
	if (ServerControllerId == -1)
	{
		Controller.LoadPlayerControllerBindings();
		ServerControllerId = Controller.GetControllerIndexForPlayer(0);
	}

	if (IsWaitLobby())
	{
		if (PlayersReady() && (PlayerOwner().Level.Game.NumPlayers == PlayerOwner().Level.Game.MaxPlayers))
			SetupAButton(class'gbx_MPLobbyServer'.default.strBeginGame);
		else
			SetupAButton();
	}
	else
	{
		SetupAButtonCaptions(class'gbx_MPLobbyServer'.default.strBeginGame, class'gbx_MPLobby'.default.StrReady);
	}

	Super.Timer();
}

// =======================================================================================================================================================
// tour of duty management
// =======================================================================================================================================================
function DoToDRefresh()
{
	RefreshToDLevels();
	ReEnableToDMode();
}

function RefreshToDLevels()
{
	local int i;

	// sort the list (should only be 2 items in the list)
	if (ToDSkillLevels.Length > 1)
	{
		if (int(ToDSkillLevels[0]) > int(ToDSkillLevels[1]))
		{
			i = int(ToDSkillLevels[1]);
			ToDSkillLevels[1] = ToDSkillLevels[0];
			ToDSkillLevels[0] = String(i);
		}
	}
}

function bool ReEnableToDMode()
{
	local bool result;

	result = Super.ReEnableToDMode();
	if (result)
	{
		if (SkillChooser.ItemCount() > UNLOCKED_TOUR_COUNT)
			SkillChooser.SetIndex(SkillChooser.ItemCount()-1);
		else
			SkillChooser.SetIndex(0);
	}

	return result;
}

function bool EnableToDMode(bool bEnable)
{
	local bool result;

	bChangingType = true;

	result = Super.EnableToDMode(bEnable);
	if (result)
	{
		EnableServerComponents(!TeamChooser.bDisabled);		// team chooser is always enabled unless we're in the wait state.

		if (bEnable)
		{
			if (SkillChooser.ItemCount() > UNLOCKED_TOUR_COUNT)
				SkillChooser.SetIndex(SkillChooser.ItemCount()-1);
			else
				SkillChooser.SetIndex(0);

			if (bWaitLobby)
				MissionList.SetIndex( MissionList.MySpinListControl.Find(PlayerOwner().Level.GetLevelFileName(), true) );		// in wait lobby, use current ToD map
			else
				MissionList.SetIndex( MissionList.MySpinListControl.Find(GetNextToDMap(), true) );		// not in wait lobby, use next ToD map
		}
		else
		{
			SkillChooser.SetIndex(DefaultSkillLevel);
			MissionList.SetIndex(DefaultMissionChoice);
		}
	}

	bChangingType = false;
	return result;
}

// =======================================================================================================================================================
// Countdown stuff
// =======================================================================================================================================================
/*
state CountDownBase
{
	// No cursors in the countdown
	function DrawPlayerCursor(Canvas C, int localPlayerNum)
	{
	}

	function Timer()
	{
		local string text;
		local int i;
		local int time;

		time = PlayerOwner().GameReplicationInfo.LobbyCountdownTime;

		if (time > 0)
		{
			i = InStr(StrCountdown, "%time%", true);

			if (i != -1)
			{
				text = Left(StrCountdown, i) $ time $ Mid(StrCountdown, i + 6);
			}
			else
			{
				text = StrCountdown;
			}

			if (text != lblMissionTitle.Caption)
			{
				PlayerOwner().PlaySound(CountdownProgressSound, SLOT_Interact, 1.0, false );
			}

			lblMissionTitle.SetCaption(text);
		}
	}

	// Eat all the input
	function bool LobbyOnXControllerEvent(byte Id, eXControllerCodes iCode)
	{
		return true;
	}

	function bool LobbyOnKeyEvent(out byte Key,out byte State,float delta)
	{
		return true;
	}

	function HideUnwantedControls()
	{
		CountdownCaptionA = hbtnA.Caption;
		SetupAButton("");

		CountdownCaptionB = hbtnB.Caption;
		SetupBButton("");

		CountdownCaptionX = hbtnX.Caption;
		SetupXButton("");

		CountdownCaptionY = hbtnY.Caption;
		SetupYButton("");
	}

	function UnHideUnwantedControls()
	{
		SetupAButton(CountdownCaptionA);
		SetupBButton(CountdownCaptionB);
		SetupXButton(CountdownCaptionX);
		SetupYButton(CountdownCaptionY);

		ResetMissionTitle();
	}
}
*/
defaultproperties
{
	DefaultMissionChoice=0
}
class gbx_SkirmishLobbyServerOffline extends gbx_SkirmishLobbyServer;
// used for solo, splitscreen

var bool			bPlayer1Ready, bPlayer2Ready;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);
	GUILog("Opening offline server skirmish lobby....");

	// set up the player colors
	lblProfileName[0].TextColor = class'gbxMP.WargameMultiplayerScoreboard'.default.PlayerColors[0];
	lblProfileName[1].TextColor = class'gbxMP.WargameMultiplayerScoreboard'.default.PlayerColors[1];
}

event HandleParameters( string Param1, string Param2 )
{
	Super.HandleParameters(Param1, Param2);

	FindClient(true);
	EnableServerComponents(true);

	if (IsWaitLobby())
	{
		SetPlayerReady(0, true);
	}

	EnableChat(false);
}

function int GetMaxPlayers()
{
	if (LobbyHasPlayer(1))
		return 2;

	return 1;
}

function bool PlayerIsReady(int playerIndex) 
{
	if (playerIndex == 0)
		return bPlayer1Ready;
	else
		return bPlayer2Ready;
}

function bool LocalPlayersReady()
{
	return PlayersReady();
}

function bool LobbyHasPlayer(int playerIndex) 
{
	if (playerIndex == 0)
		return true;
	else
		return (ClientControllerId != -1);
}

function SetPlayerReady(int playerIndex, bool bReady)
{
	if (playerIndex == 0)
	{
		bPlayer1Ready = bReady;
	}
	else
	{
		bPlayer2Ready = bReady;
	}

	Super.SetPlayerReady(playerIndex, bReady);
}

function FindClient(optional bool bForceUpdate)
{
	local int newControllerId;

	if (ClientControllerId != -1)
		return;

	Controller.LoadPlayerControllerBindings();
	newControllerId = Controller.GetControllerIndexForPlayer(1);
	if (bForceUpdate || (ClientControllerId != newControllerId))
	{
		ClientControllerId = newControllerId;

		if (ClientControllerId == -1)
		{
			meClient = default.meClient;
			RoleChooser[1].Hide();
			EnableClientComponents(false);
			DoToDRefresh();
		}
		else
		{
			EnableClientComponents(true);
			if (IsWaitLobby())
			{
				SetPlayerReady(1, true);
			}
			else
			{
				RoleChooser[1].Show();
			}

			savedGameManifest.GetManifestEntry(meClient, class'gbx_ProfileManager'.Static.GetProfileForController(self, 1));
			DoToDRefresh();
		}
	}
}

function bool InitLocalPlayers()
{
	local string ProfileName;

	ProfileName = class'gbx_ProfileManager'.Static.GetProfileForController(self, 0);
	if (ProfileName != "")
	{
		if(savedGameManifest.GetManifestEntry(meServer, ProfileName))
		{
			DoToDRefresh();
			return true;
		}
	}

	return false;
}

function OnAButton()
{
	if (Controller.ControllerId == ServerControllerId)
	{
		Controller.PlayClickSound(EClickSound.CS_Click);	

		if (IsWaitLobby())
		{
			ConsoleCommand("SetGameOn 1");
			Controller.CloseAll(false);
			return;
		}
		else if (PlayersReady())
		{
			if (PlayerOwner().Level.NetMode == NM_Standalone)
			{
				LaunchSkirmish(Controller,1,"NoLobby?SystemLink?" $GetRulesString(), MissionList.GetExtra());
			}
			else
			{
				ServerTravelSkirmish(Controller, MissionList.GetExtra(), GetRulesString());
			}

			return;
		}
	}
	else if ((Controller.ControllerId == ClientControllerId) && IsWaitLobby())
	{
		return;
	}

	Super.OnAButton();
}

function OnBButton()
{
	if ((Controller.ControllerId == ServerControllerId) && (!PlayerIsReady(0) || IsWaitLobby()))
	{
		if (PlayerOwner().Level.NetMode == NM_Standalone)
		{
			Controller.CloseMenu(true);
		}
		else
		{
			Controller.PlayClickSound(EClickSound.CS_Back);
			Controller.OpenMenu(class'GameEngine'.default.PopupMPMenuClass, "NOCLOSEALL");
		}

		return;
	}

	Super.OnBButton();
}

function Timer()
{
	Super.Timer();

	if (!IsWaitLobby() && (PlayerIsReady(0) || (LobbyHasPlayer(1) && PlayerIsReady(1))))
	{
		SetupBButton(class'gbx_MPLobby'.default.StrUnReady);
	}
	else
	{
		SetupBButton(class'gbx_MPLobby'.default.StrMenu);
	}
}

function string GetPlayerStatusCaption(int inPlayerIndex)
{
	return Super(gbx_ScreenABXY).GetPlayerStatusCaption(inPlayerIndex);
}

function RefreshToDLevels()
{
	local int ToDIndex;

	ToDSkillLevels.Length = 0;

	if (IsWaitLobby())
	{
		TryAddToDLevel( MySkirmish.iSkillToD );
	}
	else
	{
		if (IsUsMode())
			ToDIndex = 1;
		else
			ToDIndex = 2;

		if (ClientControllerId != -1)
		{
			TryAddToDLevel( GetScoreFromManifest(meServer, 3, "", true, ToDIndex) );
			TryAddToDLevel( GetScoreFromManifest(meClient, 3, "", true, ToDIndex) );
		}
		else
		{
			TryAddToDLevel( GetScoreFromManifest(meServer, 3, "", false, ToDIndex) );
		}
	}

	Super.RefreshToDLevels();
}

function bool ShouldDisplayPlayerNum()
{ 
	if (GetMaxPlayers() > 1)
		return !(meServer.ProfileName ~= meClient.ProfileName);

	return false;
}

function GetHighScoreInfo(out int Score, out int playerIndex, string mapName, int modechoice, int skillChoice)
{
	Score = -1;

	if (LobbyHasPlayer(playerIndex))
	{
		if (playerIndex == 0)
		{
			Score = GetScoreFromManifest(meServer, modechoice, mapName, (ClientControllerId != -1), skillChoice);
		}
		else if ((playerIndex == 1) && !(meServer.ProfileName ~= meClient.ProfileName))
		{
			Score = GetScoreFromManifest(meClient, modechoice, mapName, (ClientControllerId != -1), skillChoice);
		}
	}

	if (Score == -1)
	{
		playerIndex = -1;
		Super.GetHighScoreInfo(Score, playerIndex, mapName, modeChoice, skillChoice);
	}
}

defaultproperties
{
}
class gbx_SkirmishLobbyServerOnline extends gbx_SkirmishLobbyServer;
// used for system link, live

var PlayerReplicationInfo			ServerPlayer;
var PlayerReplicationInfo			ClientPlayer;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	GRI = MyController.ViewportOwner.Actor.GameReplicationInfo;
	ServerPlayer = MyController.ViewportOwner.Actor.PlayerReplicationInfo;

	Super.InitComponent(MyController, MyOwner);

	GUILog("Opening online server skirmish lobby....");
}

event HandleParameters( string Param1, string Param2 )
{
	Super.HandleParameters(Param1, Param2);

	SetClientPlayer(None, true);
	EnableServerComponents(true);

	if (IsWaitLobby())
	{
		SetPlayerReady(0, true);
	}

	EnableChat(GetMaxPlayers() > 1);
}

function int GetMaxPlayers()
{
	return GRI.MaxPlayers;
}

function OnMapChanged(string newMap)
{
	Super.OnMapChanged(newMap);

	GRI.Skirmish_Mission = newMap;
}

function OnTeamChanged(int newTeam)
{
	Super.OnTeamChanged(newTeam);

	GRI.Skirmish_Team = newTeam;
}

function OnRoleChanged(int playerIndex, int roleIndex)
{
	if (playerIndex == 0)
	{
		ServerPlayer.SetLobbyPlayerSlot(roleIndex);
	}
	else if (playerIndex == 1)
	{
		ClientPlayer.SetLobbyPlayerSlot(roleIndex);
	}

	Super.OnRoleChanged(playerIndex, roleIndex);
}

function OnGameTypeChanged(int newGameIndex)
{
	GRI.Skirmish_Mode = newGameIndex;

	Super.OnGameTypeChanged(newGameIndex);
}

function OnSkillChanged(int newSkillIndex, int skillLevels[NUM_SKILLSETS])
{
	Super.OnSkillChanged(newSkillIndex, skillLevels);
	GRI.Skirmish_Skill = newSkillIndex;
	GRI.Skirmish_Skills[0] = skillLevels[0];
	GRI.Skirmish_Skills[1] = skillLevels[1];
	GRI.Skirmish_Skills[2] = skillLevels[2];
}

function bool PlayerIsReady(int playerIndex) 
{
	if (!LobbyHasPlayer(playerIndex))
		return false;

	if (playerIndex == 0)
		return ServerPlayer.bLobbyAttached;
	else
		return ClientPlayer.bLobbyAttached;
}

function bool LocalPlayersReady()
{
	return PlayerIsReady(0);
}

function bool LobbyHasPlayer(int playerIndex) 
{
	return (playerIndex == 0) || (ClientPlayer != None);
}

function SetPlayerReady(int playerIndex, bool bReady)
{
	if (playerIndex == 0)
	{
		ServerPlayer.SetLobbyAttached(bReady);
	}
	else
	{
		if (ClientPlayer != None)
			ClientPlayer.SetLobbyAttached(bReady);
		else
			return;
	}

	Super.SetPlayerReady(playerIndex, bReady);
}

function OnAButton()
{
	if (IsWaitLobby())
	{
		Controller.PlayClickSound(EClickSound.CS_Click);	
		ConsoleCommand("SetGameOn 1");
		Controller.CloseAll(false);
		return;
	}
	else if (PlayersReady())
	{
		Controller.PlayClickSound(EClickSound.CS_Click);	
		ServerTravelSkirmish(Controller, MissionList.GetExtra(), GetRulesString());
		return;
	}
	else if (PlayerIsReady(0))
	{
		Controller.OpenMenu("GUI.gbx_DlgServerPlayAlone");
	}

	Super.OnAButton();
}

function OnBButton()
{
	if (!PlayerIsReady(0) || IsWaitLobby())
	{
		Controller.PlayClickSound(EClickSound.CS_Back);
		Controller.OpenMenu(class'GameEngine'.default.PopupMPMenuClass, "NOCLOSEALL");
		return;
	}

	Super.OnBButton();
}

function Timer()
{
	Super.Timer();

	if (ClientPlayer != None)
		SetSpinIndex(RoleChooser[1], ClientPlayer.LobbyPlayerSlot);

	SetupPlayerNames();

	if (!PlayerIsReady(0) || IsWaitLobby())
	{
		SetupBButton(class'gbx_MPLobby'.default.StrMenu);
	}
	else
	{
		SetupBButton(class'gbx_MPLobby'.default.StrUnReady);
	}
}

function SetClientPlayer(PlayerReplicationInfo PRI, optional bool bForce)
{
	if ((bForce || (ClientPlayer == None)) && (PRI != None))
	{
		ClientPlayer = PRI;
		ClientPlayer.SetLobbyPlayerSlot(RoleChooser[1].GetIndex());

		if (!IsWaitLobby())
			RoleChooser[1].Show();

		EnableClientComponents(false);
		DoToDRefresh();
	}
	else if ((bForce || (ClientPlayer != None)) && (PRI == None))
	{
		ClientPlayer = None;

		RoleChooser[1].Hide();
		EnableClientComponents(false);
		DoToDRefresh();
	}
}

function FindClient(optional bool bForceUpdate)
{
	SetClientPlayer(FindRemotePlayer());
}

function bool InitLocalPlayers()
{
	// the initialization of the server needs delayed a bit because the profile is loaded a bit after the screen is constructed
	if ((ServerPlayer != None) && (GetProfileNameForPlayer(ServerPlayer) != ""))
	{
		if(savedGameManifest.GetManifestEntry(meServer, GetProfileNameForPlayer(ServerPlayer)))
		{
			DoToDRefresh();
			return true;
		}
	}

	return false;
}

function int GetToDLevelForPlayer(PlayerReplicationInfo PRI)
{
	if (IsUSMode())
		return PRI.SkirmishToDLevel[0];
	else
		return PRI.SkirmishToDLevel[1];
}

function CheckForToDSkillChange()
{
	// check to see that the server and client's skirmish tod levels are in the list.  If not, refresh
	if ((ServerPlayer != None) && SkillLevelMissingFromList( GetToDLevelForPlayer(ServerPlayer) ) ||
		(ClientPlayer != None) && SkillLevelMissingFromList( GetToDLevelForPlayer(ClientPlayer) ))
	{
		GUILog("CheckForToDSkillChange: Server detected new skirmish skill level choices");
		DoToDRefresh();
	}
}

function RefreshToDLevels()
{
	local int i;

	// refresh the list of tod skill levels on the server
	ToDSkillLevels.Length = 0;

	if (IsWaitLobby())
	{
		TryAddToDLevel( MySkirmish.iSkillToD );
	}
	else
	{
		if (ServerPlayer != None)
		{
			ServerPlayer.SetSkirmishToDLevel( GetScoreFromManifest(meServer, 3, "", true, 1), GetScoreFromManifest(meServer, 3, "", true, 2) );

			TryAddToDLevel( GetToDLevelForPlayer(ServerPlayer) );
		}

		if (ClientPlayer != None)
		{
			TryAddToDLevel( GetToDLevelForPlayer(ClientPlayer) );
		}
	}

	Super.RefreshToDLevels();
	GUILog("CheckForToDSkillChange: Server refreshed available ToD levels");

	// copy to the GRI for the client
	for (i=0; i<2; i++)
	{
		if (i < ToDSkillLevels.Length)
			GRI.Skirmish_ToDSkills[i] = int(ToDSkillLevels[i]);
		else
			GRI.Skirmish_ToDSkills[i] = 0;
	}
}

function bool ShouldShowControllerInfo(int inPlayerIndex)
{
	return (inPlayerIndex < GetMaxPlayers());
}

function GetHighScoreInfo(out int Score, out int playerIndex, string mapName, int modechoice, int skillChoice)
{
	Score = -1;

	if (playerIndex == 0)
	{
		Score = GetScoreFromManifest(meServer, modechoice, mapName, true, skillChoice);
	}

	if (Score == -1)
	{
		playerIndex = -1;
		Super.GetHighScoreInfo(Score, playerIndex, mapName, modeChoice, skillChoice);
	}
}

defaultproperties
{
}
class gbx_SPChooseDifficulty extends gbx_MenuLayoutScreen;

// target map is in LParam1
var Automated GUILabel							lblDescription;

var int											SelectedDifficulty;		// if we have to prompt
var localized string							StringPromptCheckpoint;
var localized string							StringDescDifficulty[4];

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	local GameProfile gProfile;

	Super.InitComponent(MyController, MyOwner);

	gProfile = class'GameProfile'.Static.LoadCurrentGameProfile( PlayerOwner().Level );
	GUILog("gbx_SPChooseDifficulty::InitComponent gProfile = " $gProfile $" name=" $gProfile.GetGameName());

	// handle the authentic button
	if ((gProfile == None) || (!gProfile.IsAuthenticUnlocked()))
	{
		MyComponents[3].EnableControl(false);
		DoComponentLayout();
	}

	class'GameProfile'.Static.UnloadProfile( PlayerOwner().Level, gProfile );
	SetupAButton(StringSelect);

	MyComponents[1].SetFocus(None);

	DisableSelectAButton();
}

function LaunchChosenChapter()
{
	local GameProfile	gProfile;
	local string nextMap;
	
	nextMap = LParam1;
	if (nextMap == "")
	{
		nextMap = PlayerOwner().Level.MissionManager.GetFirstMission(SelectedDifficulty);
	}

	// apply the controllers
	Controller.ApplyControllersToViewports();

	gProfile = class'GameProfile'.Static.LoadCurrentGameProfile( PlayerOwner().Level );
	if (gProfile != None)
	{
		PlayerOwner().Level.MissionManager.ClearCheckpointData( gProfile );
		class'GameProfile'.Static.UnloadProfile( PlayerOwner().Level, gProfile, true );
	}
	
	if (nextMap == "D08_1030_CLOSEQUARTERS")
		ConsoleCommand("DEMO_LEVEL_START_CQ");
	else if (nextMap == "D15_1130_BOOKENDS")
		ConsoleCommand("DEMO_LEVEL_START_INTRO");
		
	LoadSPMap(nextMap, SelectedDifficulty);
}

function bool LoadWarningAnswer(string answer)
{
	if (answer ~= "YES")
	{
		LaunchChosenChapter();
		return false;
	}

	return true;
}

function StartGame(int difficulty)
{
	local gbx_ScreenQuestion dlg;
	local GameProfile gProfile;
	local string SaveMissionName;

	SelectedDifficulty = difficulty;

	gProfile = class'GameProfile'.Static.LoadCurrentGameProfile( PlayerOwner().Level );
	if (gProfile != None)
	{
		SaveMissionName = gProfile.SaveMissionName;
		class'GameProfile'.Static.UnloadProfile( PlayerOwner().Level, gProfile );
	}

	if ( bool(ConsoleCommand("SAVEGAMEEXISTS 1")) || (SaveMissionName != "") )	// do we have a saved checkpoint?
	{
		dlg = LaunchQuestionDialog(Controller, StringPromptCheckpoint, "YESNO AREYOUSURE_PROGRESS");
		dlg.OnAnswer = LoadWarningAnswer;
	}
	else
	{
		LaunchChosenChapter();
	}
}

function bool OnComponentActivate(int button, GUIComponent Sender)
{
	switch (button)
	{
		case 0:	// Easy
		case 1:	// Normal
		case 2: // Difficult
		case 3: // Authentic
			StartGame(button);
			return true;
	}

	return false;
}

event SetFocus(GUIComponent Who)
{
	local int i;
	local string prompt;

	Super.SetFocus(Who);

	for (i=0; i<MyComponents.Length; i++)
	{
		if (Who == MyComponents[i])
		{
			prompt = StringDescDifficulty[i];
			break;
		}
	}

	lblDescription.SetCaption(prompt);
}

function bool ScreenOnDrawPre(Canvas C)
{
	if (!bVisible)
		return false;

	if (lblDescription.Caption != "")
	{
		C.DrawColor = Controller.BackgroundBoxColor;
		lblDescription.DrawComponentBackground(C, 3.0, 3.0);
	}

	return Super.ScreenOnDrawPre(C);
}

defaultproperties
{
	LayoutPivotPoint=0.33
	LayoutSpacing=0.01

	MyComponents(0)=cBlockMenuButton
	MyComponents(1)=cBlockMenuButton
	MyComponents(2)=cBlockMenuButton
	MyComponents(3)=cBlockMenuButton

	MyCaptions(0)="Easy"
	MyCaptions(1)="Normal"
	MyCaptions(2)="Difficult"
	MyCaptions(3)="Authentic"

	Begin Object Class=GUILabel Name=cDiffDesc
		StyleName="MenuOptionLabel"
		TextAlign=TXTA_Center
		TextAlignV=TXTA_Center
		DrawMenuState=1
		WinWidth=0.90
		WinHeight=0.25000
		WinLeft=0.05
		WinTop=0.52
		bNeverFocus=true
		bMultiLine=true
		bTransparent=false
	End Object
	lblDescription=cDiffDesc

	ScreenTitle="Choose Difficulty"
	ACaption="Select"

	StringPromptCheckpoint="You are about to begin playing a new chapter but a previously saved checkpoint exists."
	StringDescDifficulty(0)="A soldier can't earn his stripes here, but we're not all meant to be soldiers.  Tactical combat is not required to beat this enemy."
	StringDescDifficulty(1)="New recruits for Earned in Blood apply here.  The Germans keep you occupied in challenging engagements.  This is the minimum difficulty that offers a tactical experience."
	StringDescDifficulty(2)="For seasoned squad leaders.   The Germans are tough-as-nails with deadly accuracy.  Tactical excellence is required."
	StringDescDifficulty(3)="The closest you can get to strapping on a parachute and jumping into France.  Checkpoints and suppression icons are disabled.  For your safety and well-being, the game must be completed on Difficult before attempting this challenge."

}

class gbx_SPMissionBriefing extends gbx_SPMissionOver;

var() Automated GUILabel			lblMedalAwarded;
var() Automated GUILabel			lblExtraUnlocked;
var() Automated GUILabel			lblExtraUnlocked2;
var int								iMedalAwarded;
var GUIFRect						MedalIconPosition;

var localized string				StringCompleteCaption;
var localized string				StringMedalAwarded;
var localized string				StringExtraContent;
var localized string				StringViewExtra;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	lblMedalAwarded.Hide();
	lblExtraUnlocked.Hide();
	lblExtraUnlocked2.Hide();

	SetCaptions(StringCompleteCaption);
}

event HandleParameters(string Param1, string Param2)
{
	local int i;

	Super.HandleParameters(Param1, Param2);

	if (ParseCommand(Param1, "MEDALS="))
	{
		if (Param1 != "")
		{
			i = PlayerOwner().Level.MissionManager.FindCurrentMission();
			if (i != -1)
			{
				iMedalAwarded = int(Param1);

				if (class'gbx_MenuExtras'.Static.HasExtra(i, iMedalAwarded))
				{
					lblExtraUnlocked.SetCaption(StringExtraContent $"|" $ StringViewExtra);
					lblExtraUnlocked2.SetCaption(class'gbx_MenuExtras'.Static.GetExtraDesc(i, iMedalAwarded));
					lblExtraUnlocked.Show();
					lblExtraUnlocked2.Show();
				}

				if (PlayerOwner().Level.MissionManager.GetMissionStyle(i) != ECIS_Film)
				{
					lblObjComplete[0].WinTop = 0.18;
					lblObjComplete[1].WinTop = 0.24;
					lblObjComplete[2].WinTop = 0.30;
					lblMedalAwarded.SetCaption(StringMedalAwarded $"|" $ class'gbx_ScreenTimeline'.default.MedalNames[iMedalAwarded]);
					lblMedalAwarded.Show();
				}
				else
				{
					iMedalAwarded = -1;
				}
			}
		}
	}
}

function bool MissionOverOnDraw(Canvas C)
{
	if (iMedalAwarded != -1)
	{
		class'gbx_ScreenTimeline'.static.StaticDrawMedalIcons(C, self, MedalIconPosition, class'gbx_ScreenTimeline'.default.MedalIcons[iMedalAwarded], class'gbx_ScreenTimeline'.default.MedalBracketIcons[0]);
	}

	return Super.MissionOverOnDraw(C);
}

static function DoNextMap(GUIController C)
{
	local string nextMap;

	nextMap = C.ViewportOwner.Actor.Level.MissionManager.GetNextMission();

	C.PlayClickSound(EClickSound.CS_Click);

	if (nextMap == "")
	{
		C.ConsoleCommand("disconnect");
	}
	else
	{
		C.ViewportOwner.Actor.Level.MissionManager.LoadSPMap(nextMap, int(C.ViewportOwner.Actor.Level.DifficultyManager.GetDifficulty()));
	}

	C.CloseAll(false);
}

function bool ContinuesToPlayableChapter()
{
	local int i;

	for (i=PlayerOwner().Level.MissionManager.FindCurrentMission()+1; i<PlayerOwner().Level.MissionManager.Missions.Length; i++)
	{
		if (PlayerOwner().Level.MissionManager.GetMissionStyle(i) == ECIS_Normal)
			return true;
	}

	return false;
}

function bool CurrentLevelIsPlayable()
{
	local int i;

	i = PlayerOwner().Level.MissionManager.FindCurrentMission();
	return (PlayerOwner().Level.MissionManager.GetMissionStyle(i) == ECIS_Normal);
}

function OnAButton()
{
	if (CurrentLevelIsPlayable() && (ContinuesToPlayableChapter() || !PlayerOwner().Level.MissionManager.DidSquadmateDie()))
	{
		Controller.OpenMenu("GUI.gbx_DlgSoldiersDied");
	}
	else
	{
		DoNextMap(Controller);
	}
}

static function PreloadMenu(GUIController C)
{
	Super.PreloadMenu(C);

	C.PreloadMenu("GUI.gbx_DlgSoldiersDied");
}

//2.4:1
defaultproperties
{
	ACaption="Continue"
	iMedalAwarded=-1

	Begin Object Class=GUILabel Name=clblMedal
		StyleName="MenuOptionCaption"
		DrawMenuState=2
		TextAlign=TXTA_Center
		bAcceptsInput=false
		bMultiLine=true
		bTabStop=false
		WinWidth=0.800000
		WinHeight=0.1000
		WinLeft=0.100000
		WinTop=0.370000
	End Object
	lblMedalAwarded=clblMedal
	Begin Object Class=GUILabel Name=clblExtra
		StyleName="MenuOptionLabel"
		DrawMenuState=1
		TextAlign=TXTA_Center
		bAcceptsInput=false
		bMultiLine=true
		bTabStop=false
		WinWidth=0.800000
		WinHeight=0.1000
		WinLeft=0.100000
		WinTop=0.670000
	End Object
	lblExtraUnlocked=clblExtra
	Begin Object Class=GUILabel Name=clblExtra2
		StyleName="MenuOptionLabel"
		DrawMenuState=1
		TextAlign=TXTA_Center
		bAcceptsInput=false
		bMultiLine=false
		bDrawToFit=true
		bTabStop=false
		WinWidth=0.800000
		WinHeight=0.05000
		WinLeft=0.100000
		WinTop=0.770000
	End Object
	lblExtraUnlocked2=clblExtra2
	MedalIconPosition=(fL=0.46875,fT=0.48,fW=0.0625,fH=0.15)

	StringCompleteCaption="Chapter Complete"
	StringMedalAwarded="A medal has been awarded!"
	StringExtraContent="New extra content has been unlocked!"
	StringViewExtra="View this new content in the extras menu."
}
class gbx_SPMissionDisplay extends gbx_MissionDisplay;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	imgMission.Image = Controller.GUITexturePool.AllocRenderMaterial();
	SetMission(0);
}

event Show()
{
	Super.Show();

	if (!bDisplayMissionName)
		lblMissionTitle.Hide();
}

function SetMissionFromMissionName(string mapName)
{
	SetMission (class'gbxSPMissionList'.static.FindMapIndex(mapName) );
}

function SetMission(int missionIndex)
{
	if (CurrentMissionIndex == missionIndex)
		return;

	CurrentMissionIndex = missionIndex;

	if (CurrentMissionIndex == -1)
	{
		Controller.GUITexturePool.GetTexture(imgMission.Image, class'Gameplay.gbxSPMissionList'.static.GetMissionImageName(-1));

		lblMissionTitle.Hide();
		txtDescription.Hide();
	}
	else
	{
		lblMissionTitle.Show();
		imgMission.Show();
		txtDescription.Show();

		lblMissionTitle.SetCaption(class'Gameplay.gbxSPMissionList'.static.GetMissionName(CurrentMissionIndex, true));
		txtDescription.SetContent(class'Gameplay.gbxSPMissionList'.static.GetBriefing(CurrentMissionIndex));

		Controller.GUITexturePool.GetTexture(imgMission.Image, class'Gameplay.gbxSPMissionList'.static.GetMissionImageName(CurrentMissionIndex));
	}

	if (!bDisplayMissionName)
		lblMissionTitle.Hide();
}
class gbx_SPMissionFailed extends gbx_SPMissionOver;

var() Automated GUILabel			lblBorn;
var() Automated GUILabel			lblDied;

var bool						bHasCheckpoint;
var bool						bNeedsHelp;
var localized string			StringReload;
var localized string			StringRestart;
var localized string			StringCapBorn;
var localized string			StringCapDied;
var localized string			StringCapMissionFailed[2];
var localized string			StringCapPlayerDied[2];



function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	local GameProfile gProfile;
	local int LastMission, FirstIncomplete, LastDifficulty, SaveMissionDifficulty;
	local string SaveMissionName;
	local int currentMission;

	Super.InitComponent(MyController, MyOwner);

	// load the current profile's savegame and checkpoint data
	gProfile = class'GameProfile'.Static.LoadCurrentGameProfile( PlayerOwner().Level );
	if (gProfile != None)
	{
		LastMission = gProfile.LastMissionCompleted;
		LastDifficulty = gProfile.LastDifficultyCompleted;
		FirstIncomplete = gProfile.FindFirstIncompleteMission();
		SaveMissionName = gProfile.SaveMissionName;
		SaveMissionDifficulty = gProfile.SaveMissionDifficulty;

		class'GameProfile'.Static.UnloadProfile( PlayerOwner().Level, gProfile );

//		if ( (PlayerOwner().Level.MissionManager.GetMissionName( LastMission ) == SaveMissionName) && (LastDifficulty == SaveMissionDifficulty))
		if (SaveMissionName != "")
		{
			bHasCheckpoint = true;
			bNeedsHelp = PlayerOwner().Level.MissionManager.ShouldHelpWithCheckpoint();
		}
		else
		{
			bHasCheckpoint = bool(ConsoleCommand("SAVEGAMEEXISTS 1"));
		}
	}
	else
	{
		bHasCheckpoint = bool(ConsoleCommand("SAVEGAMEEXISTS 1"));
	}

	if (bHasCheckpoint)
		hbtnA.SetCaption(StringReload);
	else
		hbtnA.SetCaption(StringRestart);

	currentMission = PlayerOwner().Level.MissionManager.FindCurrentMission();
	if (CurrentMission == -1)
	{
		GUILog("Warning: Current mission is unknown");
		CurrentMission = 0;
	}

	lblBorn.SetCaption(StringCapBorn);
	lblDied.SetCaption(StringCapDied);
	ReplaceText(lblBorn.Caption, "<DATE>", PlayerOwner().Level.MissionManager.HartsockBornDate);
	ReplaceText(lblDied.Caption, "<DATE>", PlayerOwner().Level.MissionManager.GetMissionDate(CurrentMission));
}

event HandleParameters(string Param1, string Param2)
{
	Super.HandleParameters(Param1, Param2);

	if (Param1 ~= "NODEATH")
	{
		lblBorn.Hide();
		lblDied.Hide();
		SetCaptions(StringCapMissionFailed[1],StringCapMissionFailed[0]);
	}
	else
	{
		SetCaptions(StringCapPlayerDied[1],PlayerOwner().Level.MissionManager.PlayerRankName);
	}
}

static function DoReload(PlayerController PC)
{
	local GameProfile gProfile;
	local int LastMission, FirstIncomplete, LastDifficulty, SaveMissionDifficulty;
	local string SaveMissionName;

	// load the current profile's savegame and checkpoint data
	gProfile = class'GameProfile'.Static.LoadCurrentGameProfile( PC.Level );
	if (gProfile != None)
	{
		LastMission = gProfile.LastMissionCompleted;
		LastDifficulty = gProfile.LastDifficultyCompleted;
		FirstIncomplete = gProfile.FindFirstIncompleteMission();
		SaveMissionName = gProfile.SaveMissionName;
		SaveMissionDifficulty = gProfile.SaveMissionDifficulty;
		class'GameProfile'.Static.UnloadProfile( PC.Level, gProfile );

//		if ( (PlayerOwner().Level.MissionManager.GetMissionName( LastMission ) == SaveMissionName) && (LastDifficulty == SaveMissionDifficulty))
		if (SaveMissionName != "")
		{
//			PC.Level.MissionManager.IncrementCheckpointReload();
			gProfile = class'GameProfile'.Static.LoadCurrentGameProfile( PC.Level );
			PC.Level.MissionManager.CachedGameProfile.IncrementCheckpointReload();
			if (gProfile != None)
			{
				PC.Level.MissionManager.UncacheGameProfile( gProfile );
			}
			class'GameProfile'.Static.UnloadProfile( PC.Level, gProfile, true );
			PC.Level.MissionManager.LoadSPMap(SaveMissionName, SaveMissionDifficulty );
		}
		else
		{
			PC.ClientTravel( "?load=1", TRAVEL_Absolute, false); 
		}
	}
	else
	{
		PC.ClientTravel( "?load=1", TRAVEL_Absolute, false); 
	}
}

function OnAButton()
{
	local GUIController C;

	C = Controller;
	C.PlayClickSound(EClickSound.CS_Click);

	if (bHasCheckpoint)
	{
		if (bNeedsHelp)
		{
			C.ReplaceMenu("GUI.gbx_DlgPlayerHelp");
			return;
		}
		else
		{
			DoReload(PlayerOwner());
		}
	}
	else
	{
		PlayerOwner().Level.MissionManager.LoadSPMap(PlayerOwner().Level.GetLevelFileName(), int(PlayerOwner().Level.DifficultyManager.GetDifficulty()));
	}

	C.CloseAll(false);
}

static function PreloadMenu(GUIController C)
{
	Super.PreloadMenu(C);

	C.PreloadMenu("GUI.gbx_DlgPlayerHelp");
}

defaultproperties
{
	StringCapMissionFailed(0)="Mission Objectives Failed"
	StringCapMissionFailed(1)="American Tank Must Survive"
	StringCapPlayerDied(0)="Sgt. Joe Hartsock"
	StringCapPlayerDied(1)="Killed in Action"

	StringReload="Reload Checkpoint"
	StringRestart="Restart Chapter"
	StringCapBorn="Born: <DATE>"
	StringCapDied="Died: <DATE>"

	Begin Object Class=GUILabel Name=clblBorn
		StyleName="MenuOptionCaption"
		DrawMenuState=1
		TextAlign=TXTA_Center
		bAcceptsInput=false
		bMultiLine=true
		bTabStop=false
		WinWidth=0.800000
		WinHeight=0.05000
		WinLeft=0.100000
		WinTop=0.470000
	End Object
	lblBorn=clblBorn
	Begin Object Class=GUILabel Name=clblDied
		StyleName="MenuOptionCaption"
		DrawMenuState=1
		TextAlign=TXTA_Center
		bAcceptsInput=false
		bMultiLine=true
		bTabStop=false
		WinWidth=0.800000
		WinHeight=0.05000
		WinLeft=0.100000
		WinTop=0.520000
	End Object
	lblDied=clblDied

}

class gbx_SPMissionOver extends GUIPage
	Abstract;

var() Automated GUILabel			lblObjComplete[3];
var automated 	GUIHelpButton		hbtnA;
var automated 	GUIHelpButton		hbtnB;

var localized string				ACaption;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	hbtnA.OnClick = MissionOverButtonClick;
	hbtnB.OnClick = BackButtonClick;
	hbtnA.SetCaption(ACaption);
	hbtnB.SetCaption(class'gbx_ScreenABXY'.default.StringBack);

	OnKeyEvent = MissionOverKeyEvent;
	OnXControllerEvent=MissionOverXControllerEvent;
	OnDraw = MissionOverOnDraw;
	OnCanClose = CanClose;
}

function SetCaptions(optional string capBottom, optional string capTop, optional string capTop2)
{
	lblObjComplete[0].SetCaption(capTop2);
	lblObjComplete[1].SetCaption(capTop);
	lblObjComplete[2].SetCaption(capBottom);
}

function bool CanClose(optional Bool bCancelled) {return false;}

function OnAButton();

function OnBButton()
{
	Controller.PlayClickSound(EClickSound.CS_Back);
	Controller.OpenMenu(class'GameEngine'.default.PopupSPMenuClass);
}

function bool MissionOverXControllerEvent(byte Id, eXControllerCodes iCode)
{
	if ((iCode == XC_A))
	{
		OnAButton();
		return true;
	}
	else if ((iCode == XC_Start) || (iCode == XC_Back) || (iCode == XC_B))
	{
		OnBButton();
		return true;
	}

	return false;
}

function bool MissionOverKeyEvent(out byte Key,out byte State,float delta)
{
	if (((key == 37) || (key == 39)) && (State == 1))
	{
		if (FocusedControl == hbtnA)
			hbtnB.SetFocus(None);
		else
			hbtnA.SetFocus(None);
	}
	if ((Key == 13) && (State == 3))	// IK_Enter, IST_Release
	{
		OnAButton();
		return true;
	}
	else if ((Key == 27) && (State == 3))	// IK_Escape, IST_Release
	{
		OnBButton();
		return true;
	}
	return false;
}

function bool MissionOverButtonClick(GUIComponent Sender)
{
	OnAButton();
	return true;
}

function bool BackButtonClick(GUIComponent Sender)
{
	OnBButton();
	return true;
}

function bool MissionOverOnDraw(Canvas C)
{
	local float X, Y, XL, delta;

	delta = HorizontalOffset(0.01);

	X = lblObjComplete[2].GetCaptionPos(C, true) + delta;
	XL = lblObjComplete[2].GetCaptionPos(C, false) - delta - X;
	Y = lblObjComplete[2].VerticalOffset(1.0);

	class'GUI.gbx_ScreenABXY'.Static.DrawTheThinRedLine(Controller, C, X, Y, XL);

	return false;	// still do the other stuff
}

defaultproperties
{
	Begin Object Class=GUILabel Name=cObjComplete0
		StyleName="LargeButton"
		DrawMenuState=1
		TextAlign=TXTA_Center
		bAcceptsInput=false
		bMultiLine=true
		bTabStop=false
		WinWidth=0.800000
		WinHeight=0.06000
		WinLeft=0.100000
		WinTop=0.280000
	End Object
	lblObjComplete(0)=cObjComplete0
	Begin Object Class=GUILabel Name=cObjComplete1
		StyleName="LargeButton"
		DrawMenuState=1
		TextAlign=TXTA_Center
		bAcceptsInput=false
		bMultiLine=true
		bTabStop=false
		WinWidth=0.800000
		WinHeight=0.06000
		WinLeft=0.100000
		WinTop=0.340000
	End Object
	lblObjComplete(1)=cObjComplete1
	Begin Object Class=GUILabel Name=cObjComplete2
		StyleName="LargeButton"
		DrawMenuState=1
		TextAlign=TXTA_Center
		bAcceptsInput=false
		bMultiLine=true
		bTabStop=false
		WinWidth=0.800000
		WinHeight=0.06000
		WinLeft=0.100000
		WinTop=0.400000
	End Object
	lblObjComplete(2)=cObjComplete2

	// bottom row, help buttons

	Begin Object Class=GUIHelpAButton Name=cMP_hbtnA1
		WinLeft=0.100000
		WinWidth=0.35
		WinTop=0.820000
		Layout=IBL_ICON_TOP
		Align=TXTA_Center
	End Object
	Begin Object Class=GUIHelpBButton Name=cMP_hbtnB1
		WinLeft=0.55
		WinWidth=0.35
		WinTop=0.820000
		Layout=IBL_ICON_TOP
		Align=TXTA_Center
	End Object
	hbtnA=cMP_hbtnA1
	hbtnB=cMP_hbtnB1

	bAllowedAsLast=true
	bMergeAStart=false
	bCloseNonTopMost=true
}
class gbx_TVCalibration extends gbx_ScreenABXY;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	OnAButtonEvent = OnDone;
}

function OnDone()
{
	BaseOnAButton();
}

defaultproperties
{
	ScreenTitle="TV Calibration"
}
class gbx_UbiCDKey extends gbx_MenuLayoutScreen;

var moEditBox						EditCDKEY;
var int								CDKEYLen;
var localized string				StringCDKeyLabel;
var string							StringCDKey;
var bool							bCDKeyValidated;
var bool							bCDKeyClose;

static function string GetCDKey() {return default.StringCDKey;}
static function bool IsCDKeyValidated() {return default.bCDKeyValidated;}
static function bool IsCDKeyMenuClose() {return default.bCDKeyClose;}

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	InitExecution();

	Super.InitComponent(MyController, MyOwner);
	
	EditCDKEY = moEditBox(MyComponents[0]);
	EditCDKEY.MyEditBox.MaxWidth = CDKEYLen;
//	EditCDKEY.MyEditBox.MinWidth = CDKEYLen;

	EditCDKEY.SetCaption(StringCDKeyLabel);
	EditCDKEY.SetText(GetCDKey());
	
	OnAButtonEvent = OnOk;
	OnBButtonEvent = OnCancel;
	OnClose = CDKeyClose;

	default.bCDKeyValidated = false;
	default.bCDKeyClose = false;
	GotoState('Init');
}

function OnOK ()
{
	default.StringCDKey = EditCDKEY.GetText();
	default.bCDKeyValidated = true;
	Controller.CloseMenu();
}

function OnCancel ()
{
	Controller.CloseMenu();
}


function CDKeyClose(optional Bool bCancelled)
{
	default.bCDKeyClose = true;
}

state Init
{
	function BeginState()
    {
		SetupBButton(BCaption);
		SetupAButton(ACaption);

		OnComponentChanged(0,self);
	}
}


defaultproperties
{
	Begin Object Class=moEditBox Name=cEditCDKey
		bFocusOnWatch=true
		LabelJustification=TXTA_Right
		CaptionWidth=0.37
		ComponentWidth=0.58
		WinWidth=0.90
		WinHeight=0.052000
		WinLeft=0.050
		WinTop=0.28000
		bHeightFromComponent=false
	End Object
	
	MyComponents(0)=cEditCDKey
	CDKEYLen=23
	ACaption="OK"
	BCaption="Cancel"

	StringCDKeyLabel="Enter CDKey"
	bShowProfileLabels=false
}
class gbx_UbiCreateAccount extends gbx_UbiLoginScreen;

var moEditBox						EditFirstName;
var moEditBox						EditLastName;
var moEditBox						EditEmail;
var moComboBox						ComboCountry;
var moPasswordBox					EditPasswordConfirm;

var localized string				StringCreateAccountCountry;
var localized string				StringStatusCreate;
var localized string				StringErrorCreate;

var const  localized string         Countries[239];
var const  array<string>			CountryCodes;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	local int i;
	Super.InitComponent(MyController, MyOwner);

	OnAButtonEvent = OnCreateAccount;

	EditUserName = moEditBox(MyComponents[0]);
	EditUserName.MyEditBox.MaxWidth = UserNameMaxLen;
	EditUserName.MyEditBox.VerifyInput = VI_UserName;

	EditFirstName = moEditBox(MyComponents[1]);
	EditFirstName.MyEditBox.MaxWidth = 32;
	EditFirstName.MyEditBox.VerifyInput = VI_Name;

	EditLastName = moEditBox(MyComponents[2]);
	EditLastName.MyEditBox.MaxWidth = 32;
	EditLastName.MyEditBox.VerifyInput = VI_Name;

	EditEmail = moEditBox(MyComponents[3]);
	EditEmail.MyEditBox.VerifyInput = VI_Email;

	ComboCountry = moComboBox(MyComponents[4]);
	
	for (i=0; i<239; i++)
	{
		if (Countries[i] != "")
		{
			ComboCountry.AddItem(Countries[i]);
		}
	}
	ComboCountry.SetIndex(221); // US
	ComboCountry.ReadOnly(true);

	EditPassword = moPasswordBox(MyComponents[5]);
	EditPassword.MaskText(true);
	EditPassword.MyEditBox.MaxWidth = PasswordMaxLen;
	//EditPassword.MyEditBox.VerifyInput = VI_Password;

	EditPasswordConfirm = moPasswordBox(MyComponents[6]);
	EditPasswordConfirm.MaskText(true);
	EditPasswordConfirm.MyEditBox.MaxWidth = PasswordMaxLen;
	//EditPasswordConfirm.MyEditBox.VerifyInput = VI_Password;

	GotoState('Init');
}

function string GetPasswordConfirm() {return EditPasswordConfirm.GetText();}

function OnComponentChanged(int button, GUIComponent Sender)
{
	if (GetUserName() != "" && GetPassword() != "" && GetPasswordConfirm() != "" && EditFirstName.GetText() != "" && EditLastName.GetText() != "" && EditEmail.GetText() != "")
		SetupAButton(ACaption);
	else
		SetupAButton();
}

function bool DoCreate()
{
	if (!class'GameService.GameService'.static.EiBCreateAccount(
		GetUserName(), 
		GetPassword(), 
		EditFirstName.GetText(), 
		EditLastName.GetText(), 
		EditEmail.GetText(), 
		CountryCodes[ComboCountry.GetIndex()]))
//		ComboCountry.GetItem( ComboCountry.GetIndex() )))
	{
		LaunchErrorDialog(Controller, StringErrorCreate, "OK NONE");
		return false;
	}
	
	GotoState('CreateAcct');
	return true;
}

function OnCreateAccount()
{
	local string err;

	if (!IsValidUserName(GetUserName(), err))
	{
		LaunchErrorDialog(Controller, err, "OK NONE");
		return;
	}
	else if (!IsValidPassword(GetUserName(), EditPassword.MyEditBox, err))
	{
		LaunchErrorDialog(Controller, err, "OK NONE");
		return;
	}
	else if (!IsValidEmail(EditEmail.GetText(), err))
	{
		LaunchErrorDialog(Controller, err, "OK NONE");
		return;
	}
	else if (GetPassword() != GetPasswordConfirm())
	{
		LaunchErrorDialog(Controller, StringPwdConfirm, "OK NONE");
		return;
	}

	DoCreate();
}

function SetReadOnly(bool bReadOnly)
{
	EditUserName.ReadOnly(bReadOnly);
	EditFirstName.ReadOnly(bReadOnly);
	EditLastName.ReadOnly(bReadOnly);
	EditEmail.ReadOnly(bReadOnly);
	ComboCountry.ReadOnly(true);
	EditPassword.ReadOnly(bReadOnly);
	EditPasswordConfirm.ReadOnly(bReadOnly);
}

state Init
{
	function BeginState()
    {
		SetReadOnly(false);
		SetupBButton(StringBack);

		OnComponentChanged(0,self);
		lblStatusLine.SetCaption("");
		KillTimer();
	}

	function EndState()
    {
    }
}


state CreateAcct
{
	function BeginState()
    {
		SetTimer(0.25, true);

		lblStatusLine.SetCaption(StringStatusCreate);
		SetReadOnly(true);
		SetupAButton();
		SetupBButton(StringBack);
	}

	function EndState()
    {
		KillTimer();
    }

	function Timer()
	{
		local bool test;
		local int error;
		local int errorType;
		local string errorMessage;

		test = class'GameService.GameService'.static.CreateAccountIsFinished();
		if (test)
		{
			test = class'GameService.GameService'.static.CreateAccountGetResult(errorType, error);
			if (test)
			{
				class'GUI.gbx_GUIProfile'.static.SetLoginName(GetUserName());
				class'GUI.gbx_GUIProfile'.static.SetRememberPassword(false);
				class'GUI.gbx_GUIProfile'.static.SetPassword(GetPassword());

				Controller.CloseMenu(false);
			}
			else
			{
				errorMessage = class'GameService.GameServiceError'.static.GetErrorMessage(errorType, error);
				LaunchErrorDialog(Controller, errorMessage, "OK NONE");
				GotoState('Init');
			}
		}
	}
}

defaultproperties
{
	Begin Object Class=moComboBox Name=cComboMenuOption
		bFocusOnWatch=true
		LabelJustification=TXTA_Right
		CaptionWidth=0.50
		ComponentWidth=0.45
		WinWidth=0.90
		WinHeight=0.052000
		WinLeft=0.050
		WinTop=0.28000
		bHeightFromComponent=false
	End Object

	ScreenTitle="Create Ubi.com Account"

	MyComponents(0)=cEditMenuOption
	MyComponents(1)=cEditMenuOption
	MyComponents(2)=cEditMenuOption
	MyComponents(3)=cEditMenuOption
	MyComponents(4)=cComboMenuOption
	MyComponents(5)=cEditPasswordMenuOption
	MyComponents(6)=cEditPasswordMenuOption

	MyCaptions(0)="User Name"
	MyCaptions(1)="First Name"
	MyCaptions(2)="Last Name"
	MyCaptions(3)="Email Address"
	MyCaptions(4)="Country"
	MyCaptions(5)="Password"
	MyCaptions(6)="Confirm Password"

	ACaption="Create"
	StringCreateAccountCountry="US"
	StringStatusCreate="Registering new account with Ubi.com service.  Please wait..."
	StringErrorCreate="Unable to register new account with Ubi.com service.  Please try again."
	
	CountryCodes=("AD","AE","AF","AG","AI","AL","AM","AN","AO","AQ","AR","AS","AT","AU","AW","AZ","BA","BB","BD","BE","BF","BG","BH","BI","BJ","BM","BN","BO","BR","BS","BT","BV","BW","BY","BZ","CA","CC","CF","CG","CH","CI","CK","CL","CM","CN","CO","CR","CU","CV","CX","CY","CZ","DE","DJ","DK","DM","DO","DZ","EC","EE","EG","EH","ER","ES","ET","FI","FJ","FK","FM","FO","FR","FX","GA","GB","GD","GE","GF","GH","GI","GL","GM","GN","GP","GQ","GR","GS","GT","GU","GW","GY","HK","HM","HN","HR","HT","HU","ID","IE","IL","IN","IO","IQ","IR","IS","IT","JM","JO","JP","KE","KG","KH","KI","KM","KN","KP","KR","KW","KY","KZ","LA","LB","LC","LI","LK","LR","LS","LT","LU","LV","LY","MA","MC","MD","MG","MH","MK","ML","MM","MN","MO","MP","MQ","MR","MS","MT","MU","MV","MW","MX","MY","MZ","N/","NA","NC","NE","NF","NG","NI","NL","NO","NP","NR","NU","NZ","OM","PA","PE","PF","PG","PH","PK","PL","PM","PN","PR","PT","PW","PY","QA","RE","RO","RU","RW","SA","SB","SC","SD","SE","SG","SH","SI","SJ","SK","SL","SM","SN","SO","SR","ST","SV","SY","SZ","TC","TD","TF","TG","TH","TJ","TK","TM","TN","TO","TP","TR","TT","TV","TW","TZ","UA","UG","UM","US","UY","UZ","VA","VC","VE","VG","VI","VN","VU","WF","WS","YE","YT","YU","ZA","ZM","ZR","ZW")

	bShowProfileLabels=false

    Countries(0)="Andorra"
    Countries(1)="United Arab Emirates"
    Countries(2)="Afghanistan"
    Countries(3)="Antigua and Barbuda"
    Countries(4)="Anguilla"
    Countries(5)="Albania"
    Countries(6)="Armenia"
    Countries(7)="Netherlands Antilles"
    Countries(8)="Angola"
    Countries(9)="Antarctica"
    Countries(10)="Argentina"
    Countries(11)="American Samoa"
    Countries(12)="Austria"
    Countries(13)="Australia"
    Countries(14)="Aruba"
    Countries(15)="Azerbaijan"
    Countries(16)="Bosnia-Herzegovina"
    Countries(17)="Barbados"
    Countries(18)="Bangladesh"
    Countries(19)="Belgium"
    Countries(20)="Burkina Faso"
    Countries(21)="Bulgaria"
    Countries(22)="Bahrain"
    Countries(23)="Burundi"
    Countries(24)="Benin"
    Countries(25)="Bermuda"
    Countries(26)="Brunei Darussalam"
    Countries(27)="Bolivia"
    Countries(28)="Brazil"
    Countries(29)="Bahamas"
    Countries(30)="Bhutan"
    Countries(31)="Bouvet Island"
    Countries(32)="Botswana"
    Countries(33)="Belarus"
    Countries(34)="Belize"
    Countries(35)="Canada"
    Countries(36)="Cocos (Keeling) Islands"
    Countries(37)="Central African Republic"
    Countries(38)="Congo"
    Countries(39)="Switzerland"
    Countries(40)="Ivory Coast (Cote D'Ivoire)"
    Countries(41)="Cook Islands"
    Countries(42)="Chile"
    Countries(43)="Cameroon"
    Countries(44)="China"
    Countries(45)="Colombia"
    Countries(46)="Costa Rica"
    Countries(47)="Cuba"
    Countries(48)="Cape Verde"
    Countries(49)="Christmas Island"
    Countries(50)="Cyprus"
    Countries(51)="Czech Republic"
    Countries(52)="Germany"
    Countries(53)="Djibouti"
    Countries(54)="Denmark"
    Countries(55)="Dominica"
    Countries(56)="Dominican Republic"
    Countries(57)="Algeria"
    Countries(58)="Ecuador"
    Countries(59)="Estonia"
    Countries(60)="Egypt"
    Countries(61)="Western Sahara"
    Countries(62)="Eritrea"
    Countries(63)="Spain"
    Countries(64)="Ethiopia"
    Countries(65)="Finland"
    Countries(66)="Fiji"
    Countries(67)="Falkland Islands"
    Countries(68)="Micronesia"
    Countries(69)="Faroe Islands"
    Countries(70)="France"
    Countries(71)="France (European Territory)"
    Countries(72)="Gabon"
    Countries(73)="United Kingdom"
    Countries(74)="Grenada"
    Countries(75)="Georgia"
    Countries(76)="French Guyana"
    Countries(77)="Ghana"
    Countries(78)="Gibraltar"
    Countries(79)="Greenland"
    Countries(80)="Gambia"
    Countries(81)="Guinea"
    Countries(82)="Guadeloupe (French)"
    Countries(83)="Equatorial Guinea"
    Countries(84)="Greece"
    Countries(85)="S. Georgia & S. Sandwich Isls."
    Countries(86)="Guatemala"
    Countries(87)="Guam (USA)"
    Countries(88)="Guinea Bissau"
    Countries(89)="Guyana"
    Countries(90)="Hong Kong"
    Countries(91)="Heard and McDonald Islands"
    Countries(92)="Honduras"
    Countries(93)="Croatia"
    Countries(94)="Haiti"
    Countries(95)="Hungary"
    Countries(96)="Indonesia"
    Countries(97)="Ireland"
    Countries(98)="Israel"
    Countries(99)="India"
    Countries(100)="British Indian Ocean Territory"
    Countries(101)="Iraq"
    Countries(102)="Iran"
    Countries(103)="Iceland"
    Countries(104)="Italy"
    Countries(105)="Jamaica"
    Countries(106)="Jordan"
    Countries(107)="Japan"
    Countries(108)="Kenya"
    Countries(109)="Kyrgyzstan"
    Countries(110)="Cambodia"
    Countries(111)="Kiribati"
    Countries(112)="Comoros"
    Countries(113)="Saint Kitts & Nevis Anguilla"
    Countries(114)="North Korea"
    Countries(115)="South Korea"
    Countries(116)="Kuwait"
    Countries(117)="Cayman Islands"
    Countries(118)="Kazakhstan"
    Countries(119)="Laos"
    Countries(120)="Lebanon"
    Countries(121)="Saint Lucia"
    Countries(122)="Liechtenstein"
    Countries(123)="Sri Lanka"
    Countries(124)="Liberia"
    Countries(125)="Lesotho"
    Countries(126)="Lithuania"
    Countries(127)="Luxembourg"
    Countries(128)="Latvia"
    Countries(129)="Libya"
    Countries(130)="Morocco"
    Countries(131)="Monaco"
    Countries(132)="Moldavia"
    Countries(133)="Madagascar"
    Countries(134)="Marshall Islands"
    Countries(135)="Macedonia"
    Countries(136)="Mali"
    Countries(137)="Myanmar"
    Countries(138)="Mongolia"
    Countries(139)="Macau"
    Countries(140)="Northern Mariana Islands"
    Countries(141)="Martinique (French)"
    Countries(142)="Mauritania"
    Countries(143)="Montserrat"
    Countries(144)="Malta"
    Countries(145)="Mauritius"
    Countries(146)="Maldives"
    Countries(147)="Malawi"
    Countries(148)="Mexico"
    Countries(149)="Malaysia"
    Countries(150)="Mozambique"
    Countries(151)="Other"
    Countries(152)="Namibia"
    Countries(153)="New Caledonia (French)"
    Countries(154)="Niger"
    Countries(155)="Norfolk Island"
    Countries(156)="Nigeria"
    Countries(157)="Nicaragua"
    Countries(158)="Netherlands"
    Countries(159)="Norway"
    Countries(160)="Nepal"
    Countries(161)="Nauru"
    Countries(162)="Niue"
    Countries(163)="New Zealand"
    Countries(164)="Oman"
    Countries(165)="Panama"
    Countries(166)="Peru"
    Countries(167)="Polynesia (French)"
    Countries(168)="Papua New Guinea"
    Countries(169)="Philippines"
    Countries(170)="Pakistan"
    Countries(171)="Poland"
    Countries(172)="Saint Pierre and Miquelon"
    Countries(173)="Pitcairn Island"
    Countries(174)="Puerto Rico"
    Countries(175)="Portugal"
    Countries(176)="Palau"
    Countries(177)="Paraguay"
    Countries(178)="Qatar"
    Countries(179)="Reunion (French)"
    Countries(180)="Romania"
    Countries(181)="Russian Federation"
    Countries(182)="Rwanda"
    Countries(183)="Saudi Arabia"
    Countries(184)="Solomon Islands"
    Countries(185)="Seychelles"
    Countries(186)="Sudan"
    Countries(187)="Sweden"
    Countries(188)="Singapore"
    Countries(189)="Saint Helena"
    Countries(190)="Slovenia"
    Countries(191)="Svalbard and Jan Mayen Islands"
    Countries(192)="Slovak Republic"
    Countries(193)="Sierra Leone"
    Countries(194)="San Marino"
    Countries(195)="Senegal"
    Countries(196)="Somalia"
    Countries(197)="Suriname"
    Countries(198)="Saint Tome (Sao Tome) and Principe"
    Countries(199)="El Salvador"
    Countries(200)="Syria"
    Countries(201)="Swaziland"
    Countries(202)="Turks and Caicos Islands"
    Countries(203)="Chad"
    Countries(204)="French Southern Territories"
    Countries(205)="Togo"
    Countries(206)="Thailand"
    Countries(207)="Tajikistan"
    Countries(208)="Tokelau"
    Countries(209)="Turkmenistan"
    Countries(210)="Tunisia"
    Countries(211)="Tonga"
    Countries(212)="East Timor"
    Countries(213)="Turkey"
    Countries(214)="Trinidad and Tobago"
    Countries(215)="Tuvalu"
    Countries(216)="Taiwan"
    Countries(217)="Tanzania"
    Countries(218)="Ukraine"
    Countries(219)="Uganda"
    Countries(220)="United States Minor Outlying Islands"
    Countries(221)="United States"
    Countries(222)="Uruguay"
    Countries(223)="Uzbekistan"
    Countries(224)="Vatican City State"
    Countries(225)="St. Vincent and the Grenadines"
    Countries(226)="Venezuela"
    Countries(227)="Virgin Islands (British)"
    Countries(228)="Virgin Islands (USA)"
    Countries(229)="Vietnam"
    Countries(230)="Vanuatu"
    Countries(231)="Wallis and Futuna Islands"
    Countries(232)="Samoa"
    Countries(233)="Yemen"
    Countries(234)="Mayotte"
    Countries(235)="Yugoslavia"
    Countries(236)="South Africa"
    Countries(237)="Zambia"
    Countries(238)="Zaire"
}
class gbx_UbiEnterPwd extends gbx_MenuLayoutScreen;

var moEditBox						EditPwd;
var localized string				StringPwdLabel;
var string							StringPwd;
var bool							bPwdClose;
var int							PasswordMaxLen;

static function string GetPwd() {return default.StringPwd;}
static function bool IsPwdMenuClose() {return default.bPwdClose;}

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	InitExecution();

	Super.InitComponent(MyController, MyOwner);
	
	EditPwd = moEditBox(MyComponents[0]);

	EditPwd.SetCaption(StringPwdLabel);
	if (GetPwd() != "P_9wZh3_d")
	    EditPwd.SetText(GetPwd());
	else
	    EditPwd.SetText("");
	EditPwd.MyEditBox.MaxWidth = PasswordMaxLen;
	
	OnAButtonEvent = OnOk;
	OnBButtonEvent = OnCancel;
	OnClose = PwdClose;

	default.bPwdClose = false;
	GotoState('Init');
}

function OnOK ()
{
	default.StringPwd = EditPwd.GetText();
	if (default.StringPwd=="")
	    default.StringPwd="P_9wZh3_d"; //Just so the login is attempted if no password is supplied but OK is pressed.
	Controller.CloseMenu();
}

function OnCancel ()
{
	default.StringPwd = "";
	Controller.CloseMenu();
}


function PwdClose(optional Bool bCancelled)
{
	default.bPwdClose = true;
}

state Init
{
	function BeginState()
    {
		SetupBButton(BCaption);
		SetupAButton(ACaption);

		OnComponentChanged(0,self);
	}
}


defaultproperties
{
	Begin Object Class=moEditBox Name=cEditJoinServerPwd
		bFocusOnWatch=true
		LabelJustification=TXTA_Center
		CaptionWidth=0.50
		ComponentWidth=0.40
		WinWidth=0.42000000
		WinHeight=0.1000
		WinLeft=0.30
		WinTop=0.28000
		bHeightFromComponent=false
		bVerticalLayout=true
	End Object
	
	MyCaptions(0)="Password"
	MyComponents(0)=cEditJoinServerPwd
	ACaption="OK"
	BCaption="Cancel"
	PasswordMaxLen=8

	StringPwdLabel="Enter Password"
	bShowProfileLabels=false
    bShowOnlineIcon=true
}
class gbx_UbiLoginAccount extends gbx_UbiLoginScreen;

var localized string				StringErrorLogin;
var localized string				StringStatusLogin;
var	moCheckBox         	            RememberPasswordCheckBox;
var bool                            bRefreshFromOnlineProfileOnOpen;
var float                           fTimer;
var bool                            bLockLogging;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
    local string						password; // rss: used for testing stuff
    
	Super.InitComponent(MyController, MyOwner);

	EditUserName = moEditBox(MyComponents[0]);
	EditUserName.MyEditBox.MaxWidth = UserNameMaxLen;
	EditUserName.MyEditBox.VerifyInput = VI_UserName;

	EditPassword = moPasswordBox(MyComponents[1]);
	EditPassword.MaskText(true);
	EditPassword.MyEditBox.MaxWidth = PasswordMaxLen;
	//EditPassword.MyEditBox.VerifyInput = VI_Password;

    RememberPasswordCheckBox = moCheckBox(MyComponents[2]);
    
	OnAButtonEvent = OnLogin;
	OnBButtonEvent = OnBack;
	OnYButtonEvent = OnCreateAccount;
	
		
	// rss: get the old password from the old ini (if there is one)
	class'GUI.gbx_GUIProfile'.static.SetPassword("");

	EditUserName.SetText(class'GUI.gbx_GUIProfile'.static.GetLoginName());
    RememberPasswordCheckBox.Checked(class'GUI.gbx_GUIProfile'.static.GetRememberPassword());
    class'GUI.gbx_GUIProfile'.static.GetPassword(password);
	if (class'GUI.gbx_GUIProfile'.static.GetRememberPassword())
		EditPassword.SetText(password);
    
	class'GameService.GameService'.static.EnableClientService();

	GotoState('Init');
}

function OnComponentChanged(int button, GUIComponent Sender)
{
    if (bLockLogging)
    {
		SetupAButton();
		return;
    }
	if (GetUserName() != "" && GetPassword() != "")
	{
		SetupAButton(ACaption);
	}
	else
	{
		SetupAButton();
    }
}

event Opened(GUIComponent Sender)
{
    local string						password;
    
    class'GUI.gbx_GUIProfile'.static.GetPassword(password);

	Super.Opened(Sender);

    if (bRefreshFromOnlineProfileOnOpen)
    {
	    EditUserName.SetText(class'GUI.gbx_GUIProfile'.static.GetLoginName());
        EditPassword.SetText(password);
        bRefreshFromOnlineProfileOnOpen=false;
    }
}

function bool DoLogin()
{
	class'GUI.gbx_GUIProfile'.static.SetRememberPassword(RememberPasswordCheckBox.IsChecked());
	if( class'GUI.gbx_GUIProfile'.static.GetRememberPassword() )
	{
		class'GUI.gbx_GUIProfile'.static.SetLoginName(GetUserName());
		class'GUI.gbx_GUIProfile'.static.SetPassword(GetPassword());
	}
	if ( !class'GameService.GameService'.static.EiBLogin(
		GetUserName(), 
		GetPassword(), 
		class'gbx_UbiCDKey'.static.GetCDKey()) )
	{
	    //log("LAPSUSW1 : GetPassword()=" $ GetPassword() );
		LaunchErrorDialog(Controller, StringErrorLogin, "OK NONE");
		return false;
	}
	
	GotoState('LoggingIn');
	return true;
}

function OnBack()
{
	DoBack();
	BaseOnBButton();
}

function DoBack()
{
}

function OnLogin()
{
	local string err;

	Controller.PlayClickSound(EClickSound.CS_Click);

	if (!IsValidUserName(GetUserName(), err))
	{
	    //log("LAPSUSW2 : GetPassword()=" $ GetPassword() );
		LaunchErrorDialog(Controller, err, "OK NONE");
		return;
	}

	/*
	// Dont check for password consistency on login, just on accound creation and modification.  Bug 11860.
	else if (!IsValidPassword(GetUserName(), GetPassword(), err))
	{
	    //log("LAPSUSW3 : GetPassword()=" $ GetPassword() );
		LaunchErrorDialog(Controller, err, "OK NONE");
		return;
	}
	*/

	if (class'GameService.GameService'.static.NeedCDKey())
	{
	    //log("LAPSUSW4 : GetPassword()=" $ GetPassword() );
		Controller.OpenMenu("GUI.gbx_UbiCDKey");
		GotoState('WaitingCDKey');
	}
	else
	{
		DoLogin();
	}
}

function OnCreateAccount()
{
	Controller.PlayClickSound(EClickSound.CS_Click);
	bRefreshFromOnlineProfileOnOpen=true;
    Controller.OpenMenu("GUI.gbx_UbiTermsOfUse");
}

function OnModifyAccount()
{
	Controller.PlayClickSound(EClickSound.CS_Click);
	bRefreshFromOnlineProfileOnOpen=true;
	Controller.OpenMenu("GUI.gbx_UbiModifyAccount");
}

function SetReadOnly(bool bReadOnly)
{
	EditUserName.ReadOnly(bReadOnly);
	EditPassword.ReadOnly(bReadOnly);
	EditUserName.EnableControl(!bReadOnly);
	EditPassword.EnableControl(!bReadOnly);
    RememberPasswordCheckBox.EnableControl(!bReadOnly);
}

static function bool IsLoggedIn()
{
	local int error;
	local int errorType;
	return (class'GameService.GameService'.static.LoginIsFinished()==true 
		&& class'GameService.GameService'.static.LoginGetResult(error, errorType) == true);
}

state Init
{
	function BeginState()
    {
		bLockLogging = true;
		SetTimer(1.5, true);
		
		SetReadOnly(false);
		SetupYButton(YCaption);
		SetupBButton(StringBack);

		OnComponentChanged(0,self);
		lblStatusLine.SetCaption("");
	}

	function EndState()
    {
		bLockLogging = false;
		OnComponentChanged(0,None);
		KillTimer();
    }

	function Timer()
	{
		bLockLogging = false;
		OnComponentChanged(0,None);
		KillTimer();
	}
}

state WaitingCDKey
{
	function BeginState()
    {
		SetTimer(0.25, true);
	}

	function EndState()
    {
		KillTimer();
    }

	function Timer()
	{
		if 	( class'gbx_UbiCDKey'.static.IsCDKeyMenuClose() )
		{
			if 	( class'gbx_UbiCDKey'.static.IsCDKeyValidated() )
			{
				if (!DoLogin())
				{
					GotoState('Init');
				}
			}
			else
			{
				GotoState('Init');
			}
		}
	}
}

state LoggingIn
{
	function BeginState()
    {
		SetTimer(0.25, true);

		lblStatusLine.SetCaption(StringStatusLogin);
		SetReadOnly(true);
		SetupAButton();
		SetupYButton();
		
		SetupBButton();
		
		fTimer = PlayerOwner().Level.TimeSeconds + 10;
	}

	function EndState()
    {
		SetupBButton(StringBack);
		KillTimer();
    }

	function Timer()
	{
		local int error;
		local int errorType;
		local bool test;
		local string errorMessage;

		if (fTimer > 0 && fTimer < PlayerOwner().Level.TimeSeconds)
		{
		    fTimer = -1;
    		SetupBButton(StringBack);
		}

		test = class'GameService.GameService'.static.LoginIsFinished();

		if (test)
		{
			test = class'GameService.GameService'.static.LoginGetResult(errorType, error);
			if (test)
			{
				//Loggin successful

                class'GUI.gbx_GUIProfile'.static.SetLoginName(GetUserName());
                class'GUI.gbx_GUIProfile'.static.SetRememberPassword(RememberPasswordCheckBox.IsChecked());
                if(!RememberPasswordCheckBox.IsChecked())
					class'GUI.gbx_GUIProfile'.static.ClearPassword();
				else
					class'GUI.gbx_GUIProfile'.static.SetPassword(GetPassword());

				Controller.ReplaceMenu("GUI.gbx_UbiWelcome", LParam1);
			}
			else
			{
        	    //log("LAPSUSW5 : GetPassword()=" $ GetPassword() );
				KillTimer();
				errorMessage = class'GameService.GameServiceError'.static.GetErrorMessage(errorType, error);
				LaunchErrorDialog(Controller, errorMessage, "OK NONE");
				GotoState('Init');
			}
		}
	}

	function DoBack()
	{
		class'GameService.GameService'.static.Logout();
		GotoState('Init');	
	}	
}


static function PreloadMenu(GUIController C)
{
	Super.PreloadMenu(C);

	C.PreloadMenu("GUI.gbx_UbiTermsOfUse");
	C.PreloadMenu("GUI.gbx_UbiCreateAccount");
	C.PreloadMenu("GUI.gbx_UbiCDKey");
}

defaultproperties
{
	Begin Object Class=GUICheckBoxButton Name=cTheBox
		Graphic=Texture't_interface_mb.hud.dead_x'
	End Object

	Begin Object Class=moCheckBox Name=cRememberPasswordCheckBox
	    MyCheckBox=cTheBox
		LabelJustification=TXTA_Right
		CaptionWidth=0.8411
		ComponentWidth=0.0748
		WinWidth=0.535
		WinHeight=0.052000
		WinLeft=0.050
		WinTop=0.28000
		bHeightFromComponent=false
	End Object

	MyComponents(0)=cEditMenuOption
	MyComponents(1)=cEditPasswordMenuOption
	MyComponents(2)=cRememberPasswordCheckBox
    
	MyCaptions(0)="User Name"
	MyCaptions(1)="Password"
	MyCaptions(2)="Remember Password"

	ScreenTitle="Log In to Ubi.com"
	ACaption="Log In"
	YCaption="Create Account"

	StringErrorLogin="Unable to log in to Ubi.com service.  Please try again."
	StringStatusLogin="Logging in to Ubi.com service.  Please wait..."

	bShowProfileLabels=false
	bRefreshFromOnlineProfileOnOpen=false;
	bLockLogging=false;
}class gbx_UbiLoginScreen extends gbx_MenuLayoutScreen
	Abstract;

var() Automated GUILabel			lblStatusLine;
var moEditBox						EditUserName;
var moPasswordBox					EditPassword;

var int								UserNameMinLen, UserNameMaxLen;
var int								PasswordMinLen, PasswordMaxLen;

var localized string				StringUserNameLength;
var localized string				StringUserNameFormat;
var localized string				StringPasswordLength;
var localized string				StringPasswordChars;
var localized string				StringPasswordFormat;
var localized string				StringPwdInUserName;
var localized string				StringPwdConfirm;
var localized string				StringEmailFormat;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	InitExecution();

	Super.InitComponent(MyController, MyOwner);
}

function string GetUserName() {return EditUserName.GetText();}
function string GetPassword() {return EditPassword.GetText();}

function SetReadOnly(bool bReadOnly);


// =======================================================================================================================================================
// Input validation functions
// =======================================================================================================================================================
static function bool VI_Name(string currentString, string newChar)
{
	newChar = Left(newChar,1);
	if (IsAlphaChar(newChar))
		return true;

	return false;
}

//^[a-zA-Z][a-zA-Z0-9_\.-]{2,14}$
static function bool VI_UserName(string currentString, string newChar)
{
	newChar = Left(newChar,1);
	if (IsAlphaChar(newChar))
		return true;

	if (currentString != "")
		return IsNumChar(newChar) || IsValidSymbol(newChar);

	return false;
}

static function bool IsValidUserName(string userName, optional out string err)
{
	local int c,i;
	local string ch;
	
	c = Len(userName);
	if ((c < default.UserNameMinLen) || (c > default.UserNameMaxLen))
	{
		err = default.StringUserNameLength;
		ReplaceText(err,"<MIN>", String(default.UserNameMinLen));
		ReplaceText(err,"<MAX>", String(default.UserNameMaxLen));
		return false;
	}
	for (i=0; i<c; i++)
	{
		ch = Mid(userName, i, 1);
		if ( !IsNumChar(ch) && !IsAlphaChar(ch) && !IsValidSymbol(ch) )
			{
			err = default.StringUserNameFormat;
			return false;
			}
	}
	return true;
}

//^[a-zA-Z0-9_\.-]{6,16}$
static function bool VI_Password(string currentString, string newChar)
{
	newChar = Left(newChar,1);
	return IsAlphaChar(newChar) || IsNumChar(newChar) || IsValidSymbol(newChar);
}

static function bool IsValidPassword(string userName, GUIPasswordBox passwordBox, optional out string err)
{
	if (!passwordBox.IsPasswordValidLength(default.PasswordMinLen, default.PasswordMaxLen))
	{
		err = default.StringPasswordLength;
		ReplaceText(err,"<MIN>", String(default.PasswordMinLen));
		ReplaceText(err,"<MAX>", String(default.PasswordMaxLen));
		return false;
	}
	else if (passwordBox.DoesPasswordContainUserName(userName))
	{
		err = default.StringPwdInUserName;
		return false;
	}
	else if (!passwordBox.DoesPasswordContainLetterAndNumber())
	{
		err = default.StringPasswordChars;
		return false;
	}

	return true;
}

// ^[a-zA-Z0-9]+((\.|-)[a-zA-Z0-9]+)*\@[a-zA-Z0-9]+((\.|-)[a-zA-Z0-9]+)*\.[a-zA-Z0-9]+$
static function bool VI_Email(string currentString, string newChar)
{
	newChar = Left(newChar,1);
	if (IsAlphaChar(newChar) || IsNumChar(newChar))
		return true;

	if (currentString == "")
	{
		// only alpha/numeric is valid for the first character
		return false;
	}

	return InStr("@.-_",newChar) != -1;
}

static function bool IsValidEmail(string email, out string err)
{
	local int i, c, iGotAtPos;
	local string testChar;

	iGotAtPos = -1;
	c = Len(email);
	if (c == 0)
		return false;

	for (i=0; i<c; i++)
	{
		testChar = Mid(email, i, 1);
		if ((i == 0) || (i == iGotAtPos-1))
		{
			if (!IsAlphaChar(testChar) && !IsNumChar(testChar))
			{
				err = default.StringEmailFormat;
				return false;
			}
		}
		else if (testChar == "@")
		{
			if ((iGotAtPos != -1) || (InStr(".-",Mid(email,i-1,1)) != -1))
			{
				// name can't end in a separator
				// only one @
				err = default.StringEmailFormat;
				return false;
			}

			iGotAtPos = i;
		}
		else if (InStr(".-_",testChar) != -1)
		{
			// separators only valid if not next to each other and not valid at the end
			if ((i == c-1) || (InStr(".-_",Mid(email,i-1,1)) != -1))
			{
				err = default.StringEmailFormat;
				return false;
			}
		}
	}

	if (iGotAtPos != -1)
	{
		return true;
	}
	else
	{
		err = default.StringEmailFormat;
		return false;
	}
}


static function bool IsNumChar(string newChar)
{
	return InStr("0123456789",newChar) != -1;
}

static function bool IsValidSymbol(string newChar)
{
	return InStr("_.-",newChar) != -1;
}

static function bool IsAlphaChar(string newChar)
{
	local int aNewChar;

	aNewChar = asc(newChar);
	return (((asc("a") <= aNewChar) && (asc("z") >= aNewChar)) || 
			((asc("A") <= aNewChar) && (asc("Z") >= aNewChar)));
}

defaultproperties
{
	UserNameMinLen=3
	UserNameMaxLen=15
	PasswordMinLen=6
	PasswordMaxLen=16

	Begin Object Class=GUILabel Name=cStatusLine
		StyleName="MenuOptionCaption"
		DrawMenuState=2
		TextAlign=TXTA_Center
		bAcceptsInput=false;
		bTabStop=false
		WinWidth=0.800000
		WinHeight=0.050000
		WinLeft=0.100000
		WinTop=0.7200000
	End Object
	lblStatusLine=cStatusLine

	StringUserNameLength="Your user name must be between <MIN> and <MAX> characters in length."
	StringUserNameFormat="Your user name must can only contain symbol '-' '_' '.'."
	StringPasswordLength="Your password must be between <MIN> and <MAX> characters in length."
	StringPasswordChars="Your password must contain at least one letter and one number."
	StringPasswordFormat="Your password must contain only letters and numbers."
	StringPwdInUserName="Your user name may not appear in your password."
	StringPwdConfirm="Your password and password confirmation do not match.  Please try again."
	StringEmailFormat="The email address entered is not valid.  Please try again."

	bShowProfileLabels=false
}
class gbx_UbiModifyAccount extends gbx_UbiCreateAccount;

var localized string				StringErrorModify;

var localized string                stringConfirmTitle;
var localized string                stringConfirmMessage;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	local string username;
	local string password;
	
	Super.InitComponent(MyController, MyOwner);
	
//###+ lbouchard : LINKLOSS: Check the connection link for Ubi.com Games
    if (!IsSystemLinkGame())
		bRequireLink=true;
//###- 	
	
	class'GameService.GameService'.static.GetUserName(username);
	class'GameService.GameService'.static.GetPassword(password);
	
	//log("LAPSUSY1 : username=" $ username);
	//log("LAPSUSY2 : password=" $ password);
	
	EditUserName.SetText(username);
	EditPassword.SetText(password);
	EditPasswordConfirm.SetText(password);

    EditUserName.bTabStop=false;
    EditUserName.bNeverFocus=true;
	EditUserName.bAcceptsInput=false;
    EditPassword.SetFocus(None);

//	rss: EditFirstName is being used for old password confirm in this menu!
//	EditFirstName.Hide();
	EditFirstName.MyEditBox.VerifyInput = VI_Password;
	EditFirstName.MaskText(true);
	EditLastName.Hide();
	EditEmail.Hide();
	ComboCountry.Hide();
	
	OnAButtonEvent = OnModifyAccount;
}

function OnComponentChanged(int button, GUIComponent Sender)
{
	if (GetUserName() != "" && GetPassword() != "" && GetPasswordConfirm() != "")
		SetupAButton(ACaption);
	else
		SetupAButton();
}

function bool DoCModify()
{
	// rss: added security check!
	if (!class'GUI.gbx_GUIProfile'.static.ModifyAccount( EditFirstName.GetText(), GetPassword() ))
	{
		LaunchErrorDialog(Controller, StringErrorModify, "OK NONE");
		return false;
	}
	else
		class'GUI.gbx_GUIProfile'.static.SetPassword(GetPassword());
	
	GotoState('ModifyAcct');
	return true;
}

function OnModifyAccount()
{
	local string err;

    if (!IsValidPassword(GetUserName(), EditPassword.MyEditBox, err))
	{
	    //log("LAPSUSK2 : GetUserName()=" $ GetUserName() $ " GetPassword()=" $ GetPassword());
		LaunchErrorDialog(Controller, err, "OK NONE");
		return;
	}
	else if (GetPassword() != GetPasswordConfirm())
	{
        //log("LAPSUSK3 : GetPassword()=" $ GetPassword() $ " GetPasswordConfirm()=" $ GetPasswordConfirm());
		LaunchErrorDialog(Controller, StringPwdConfirm, "OK NONE");
		return;
	}

	DoCModify();
}


function SetReadOnly(bool bReadOnly)
{
	Super.SetReadOnly(bReadOnly);
	EditUserName.ReadOnly(true);
}


state ModifyAcct
{
	function BeginState()
    {
		SetTimer(0.25, true);

		lblStatusLine.SetCaption(StringStatusCreate);
		SetReadOnly(true);
		SetupAButton();
		SetupBButton(StringBack);
	}

	function EndState()
    {
		KillTimer();
    }

	function Timer()
	{
		local bool test;
		local int errorType;
		local int error;
		local string errorMessage;
		local GUIController pCtrl;

		test = class'GameService.GameService'.static.ModifyAccountIsFinished();
		if (test)
		{
			test = class'GameService.GameService'.static.ModifyAccountGetResult(errorType, error);
			if (test)
			{                    
                pCtrl = Controller;
				Controller.CloseMenu(false);
				LaunchQuestionDialog(pCtrl, stringConfirmMessage, "OK NONE", stringConfirmTitle);
			}
			else
			{
				errorMessage = class'GameService.GameServiceError'.static.GetErrorMessage(errorType, error);
				LaunchErrorDialog(Controller, errorMessage, "OK NONE");
				GotoState('Init');
			}
		}
	}
}

defaultproperties
{
	ScreenTitle="Modify Ubi.com Account"

	MyCaptions(1)="Current Password"

	MyCaptions(5)="New Password"
	MyCaptions(6)="Confirm New Password"

	ACaption="Update"
	StringStatusCreate="Modifying account with Ubi.com service.  Please wait..."
	StringErrorModify="Unable to modify account Ubi.com service.  Please try again."

    stringConfirmTitle="Ubi.com"
    stringConfirmMessage="Account modification successful."
    bShowOnlineIcon=true
}
class gbx_UbiPatchScreen extends gbx_MenuLayoutScreen;

var automated GUILabel			lblProgressBack;
var automated GUILabel			lblCaption;

var localized string			PatchCheck;
var localized string			PatchDownload;

var float						mTotalBytes;
var float						mTotalRecvdBytes;
var float						mFileBytes;
var float						mFileRecvdBytes;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	InitExecution();

	Super.InitComponent(MyController, MyOwner);
	class'GameService.GameService'.static.StartPatchService();
	class'GameService.GameService'.static.ApplyPatch(true);
	
	OnBButtonEvent = OnBButton;
	OnClose = InternalOnClose;

	GotoState('Init');
}

function OnBButton()
{
	class'GameService.GameService'.static.AbortPatchUpdate();
	GoToLoginScreen();
}

function InternalOnClose(optional Bool bCancelled)
{
	class'GameService.GameService'.static.EndPatchService();
}

function DrawProgressBar(Canvas C, float fraction)
{
	local float L, T, R;

	// background
	C.DrawColor = Controller.BackgroundBoxColor;
	lblProgressBack.DrawComponentBackground(C);

	// empty channel
	L = lblProgressBack.HorizontalOffset(0.05);
	R = lblProgressBack.HorizontalOffset(0.95);
	T = lblProgressBack.VerticalOffset(0.5);
	C.SetDrawColor(0, 0, 0, 255);
	DrawBackground(C, L, T, R-L, 0, 0.0, 3.0);

	// the bar
	if (fraction > 0.0)
	{
		R = lblProgressBack.HorizontalOffset(0.05 + 0.9 * fraction);

		C.DrawColor = Controller.RedLineColor;
		DrawBackground(C, L, T, R-L, 0, 0.0, 3.0);
	}
}

function GoToLoginScreen()
{
	Controller.ReplaceMenu("GUI.gbx_UbiLoginAccount", LParam1);
}

state Init
{
	function BeginState()
    {
		SetTimer(2.00, true);
		SetupBButton(BCaption);
		lblCaption.SetCaption(PatchCheck);
		lblProgressBack.Hide();
		
		OnComponentChanged(0,self);
	}

	function Timer()
	{
		SetTimer(0.25, true);
		if 	( !class'GameService.GameService'.static.PatchUpdateIsFinished(mTotalBytes,
																mTotalRecvdBytes,
																mFileBytes,
																mFileRecvdBytes) )
		{
			if (mTotalRecvdBytes>0 && mTotalBytes>0)
			{
				GotoState('Download');
			}
		}
		else
		{
			GoToLoginScreen();
		}
	}
	
	function EndState()
    {
		KillTimer();
    }
}

state Download
{
	function BeginState()
    {
		SetTimer(0.25, true);
		lblCaption.SetCaption(PatchDownload);
		lblProgressBack.Show();
	}

	function Timer()
	{
		if 	( class'GameService.GameService'.static.PatchUpdateIsFinished(mTotalBytes,
																mTotalRecvdBytes,
																mFileBytes,
																mFileRecvdBytes) )
		{
			GoToLoginScreen();
		}
	}
	
	function EndState()
    {
		KillTimer();
    }
    
    function bool ScreenOnDraw(Canvas C)
	{
		if (mTotalBytes>=0)
		{
			DrawProgressBar(C, mTotalRecvdBytes/mTotalBytes);
		}
		else
		{
			DrawProgressBar(C, 0.5);
		}
		return Super.ScreenOnDraw(C);
	}

}

defaultproperties
{
	mTotalBytes = 0
	mTotalRecvdBytes = 0
	mFileBytes = 0
	mFileRecvdBytes = 0

	PatchCheck = "Checking if a patch is available..."
	PatchDownload = "Downloading the patch..."

	// caption
	Begin Object Class=GUILabel Name=clblCaption
		StyleName="MenuOptionCaption"
		DrawMenuState=2
		TextAlign=TXTA_Center
		bAcceptsInput=false
		bNeverFocus=true
		bTabStop=false
		bTransparent=true
		WinWidth=0.700000
		WinHeight=0.050000
		WinLeft=0.15000
		WinTop=0.3400000
	End Object
	lblCaption=clblCaption
	
	BCaption="Skip"
	
	
	// simple, empty label to contain the progress bar thingy
	Begin Object Class=GUILabel Name=clblProgressBack
		StyleName="MenuOptionLabel"
		TextAlign=TXTA_Left
		bAcceptsInput=false
		bNeverFocus=true
		bTabStop=false
		bTransparent=true
		WinWidth=0.700000
		WinHeight=0.050000
		WinLeft=0.15000
		WinTop=0.3900000
	End Object
	lblProgressBack=clblProgressBack

	bShowProfileLabels=false
}
class gbx_UbiTermsOfUse extends gbx_ScreenABXY;

var Automated GUIScrollTextBox			TouListBox;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	local string TouLine;

	InitExecution();
	Super.InitComponent(MyController, MyOwner);

	OnAButtonEvent = OnAccept;
	OnBButtonEvent = OnDecline;
	
	SetupAButton(ACaption);
	SetupBButton(BCaption);

	TouLine = GetTouLine(true);
	ReplaceText(TouLine, Chr(13)$Chr(10), "|");

	TouListBox.SetContent(TouLine);
}

function OnAccept()
{
	Controller.PlayClickSound(EClickSound.CS_Click);
	Controller.ReplaceMenu("GUI.gbx_UbiCreateAccount");
}

function OnDecline()
{
	Controller.CloseMenu(true);
}

defaultproperties
{
	Begin Object Class=GUIScrollText Name=cTouList
		StyleName="NoBackground"
	End Object
	Begin Object Class=GUIScrollTextBox Name=cTouListBox
		StyleName="NoBackground"
		WinWidth=0.75
		WinHeight=0.55
		WinLeft=0.125
		WinTop=0.2
		RenderWeight=0.45
		InitialDelay=0.0
		CharDelay=0
		EOLDelay=0.075
		bNoTeletype=true
		bNoTeletypeCursor=true
		bNeverFocus=false
		bAcceptsInput=true
		bTabStop=true
		TextAlign=TXTA_Center
		MyScrollText=cTouList
	End Object

	TouListBox=cTouListBox
	
	ACaption="I Accept"
	BCaption="Decline"
	bShowProfileLabels=false
}

class gbx_UbiWelcome extends gbx_MenuLayoutScreen;

var automated GUILabel				lblMOTD, lblESRB;
var string							strMOTDUbi, strMOTDGame;

var localized string				StringMOTDRequestLanguage;
var localized string				StringMOTDRetrieving;
var localized string				StringMOTDlabel;
var localized string				StringESRB;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	InitExecution();

	Super.InitComponent(MyController, MyOwner);
	
//###+ lbouchard : LINKLOSS: Check the connection link for Ubi.com Games
    if (!IsSystemLinkGame())
		bRequireLink=true;
//###- 
	
	OnAButtonEvent = OnAButton;
	OnBButtonEvent = OnBButton;
	
	lblESRB.SetCaption(StringESRB);

	GotoState('GetMOTD');
}

function bool OnComponentActivate(int button, GUIComponent Sender)
{
	switch (button)
	{
		case 0:	// find game
			Controller.OpenMenu("GUI.gbx_InternetQuery", LParam1);
			return true;

		case 1:	// create game
			Controller.OpenMenu("GUI.gbx_InternetCreateMatch", LParam1);
			return true;

		case 2:	// Modify account
			Controller.OpenMenu("GUI.gbx_UbiModifyAccount");
			return true;
		
		case 3:	// log out
			class'GameService.GameService'.static.LogOut();
			class'GameService.GameService'.static.DisableClientService();
			Controller.CloseMenu(false);
			return true;
	}

	return false;
}

function Timer();
function OnBButton()
{
	BaseOnBButton();
}

function OnAButton();

function SkipMOTD()
{
    if (!IsInState('Menu'))
        GotoState('Menu');
}

/*
function bool ScreenOnDrawPre(Canvas C)
{
	C.DrawColor = Controller.BackgroundBoxColor;
	lblMOTD.DrawComponentBackground(C, 2.0, 2.0);

	return Super.ScreenOnDrawPre(C);
}
*/
state GetMOTD
{
    function BeginState()
    {
		GUILog("GetMOTD::BeginState");
		MyComponents[0].Hide();
		MyComponents[1].Hide();
		MyComponents[2].Hide();
		MyComponents[3].Hide();
		hBtnA.SetFocus(None);

		SetupAButton();

		lblMOTD.Show();
		lblMOTD.SetCaption(StringMOTDRetrieving);
		lblMOTD.TextAlign = TXTA_Center;

		SetTimer(0.25, true);
		class'GameService.GameService'.static.RequestMOTD(StringMOTDRequestLanguage);
	}
	function EndState()
	{
		GUILog("GetMOTD::EndState");
		KillTimer();
	}

	function Timer()
	{
		local bool result;
		if (class'GameService.GameService'.static.RequestMOTDIsFinished())
		{
			result = class'GameService.GameService'.static.RequestMOTDGetResult(strMOTDUbi, strMOTDGame);
			if (result)
			{
				ReplaceText(strMOTDUbi, Chr(10), "");
				ReplaceText(strMOTDUbi, Chr(13), "|");
				ReplaceText(strMOTDGame, Chr(10),"");
				ReplaceText(strMOTDGame, Chr(13),"|");
			}
			else
			{
				GUILog("Error requesting MOTD");
			}

			GotoState('GotMOTD');
		}
	}

	function OnAButton()
	{
		GotoState('Menu');
	}
	function bool OnComponentActivate(int button, GUIComponent Sender) {return true;}

}

state GotMOTD
{
    function BeginState()
    {
		lblMOTD.SetCaption(StringMOTDlabel $ "|" $ strMOTDUbi $ "||" $ strMOTDGame);
		lblMOTD.TextAlign = TXTA_Left;
		SetTimer(15.0, true);
		SetupAButton(ACaption);
	}

	function EndState()
	{
		KillTimer();
	}

	function Timer()
	{
		GotoState('Menu');
	}
	function OnAButton()
	{
		GotoState('Menu');
	}
	function bool OnComponentActivate(int button, GUIComponent Sender) {return true;}
}

state Menu
{
    function BeginState()
    {
		MyComponents[0].Show();
		MyComponents[1].Show();
		MyComponents[2].Show();
		MyComponents[3].Show();
		
		SetupAButton();

		lblMOTD.Hide();
		MyComponents[0].SetFocus(None);
		if (!class'GameService.GameService'.static.IsOnline())
		{
			class'GameService.GameService'.static.Logout();
			Controller.CloseMenu(false);
		}
	}
}

static function PreloadMenu(GUIController C)
{
	Super.PreloadMenu(C);

	C.PreloadMenu("GUI.gbx_InternetQuery");
	C.PreloadMenu("GUI.gbx_InternetCreateMatch");
}

defaultproperties
{
	ScreenTitle="Welcome to Ubi.com"

	LayoutSpacing=0.01
	MyComponents(0)=cBlockMenuButton
	MyComponents(1)=cBlockMenuButton
	MyComponents(2)=cBlockMenuButton
	MyComponents(3)=cBlockMenuButton
	MyCaptions(0)="Find Game"
	MyCaptions(1)="Create Game"
	MyCaptions(2)="Modify Account"
	MyCaptions(3)="Log Out"

	Begin Object Class=GUILabel Name=clblMOTD
		StyleName="TextLabel"
		TextAlign=TXTA_Left
		TextAlignV=TXTA_Center
		DrawMenuState=1
		WinWidth=0.90
		WinHeight=0.55
		WinLeft=0.05
		WinTop=0.18
		bNeverFocus=true
		bMultiLine=true
		bClientBounded=true
	End Object
	lblMOTD=clblMOTD

	Begin Object Class=GUILabel Name=clblESRB
		StyleName="TextLabel"
		TextAlign=TXTA_Center
		TextAlignV=TXTA_Center
		DrawMenuState=1
		WinWidth=0.90
		WinHeight=0.12
		WinLeft=0.05
		WinTop=0.73
		bNeverFocus=true
		bMultiLine=true
		bClientBounded=true
	End Object
	lblESRB=clblESRB

	ACaption="Continue"

	StringMOTDRequestLanguage="EN"
	StringMOTDRetrieving="Retrieving Message of the Day..."
	StringMOTDlabel="Message of the day : "
	StringESRB="ESRB Notice : Game Experience May Change During Online Play"

	bShowProfileLabels=false
    bShowOnlineIcon=true
}
// ====================================================================
//  Class:  GUI.GUI
// 
//  GUI is an abstract class that holds all of the enums and structs
//  for the UI system 
//
//  Written by Joe Wilcox
//  (c) 2002, Epic Games, Inc.  All Rights Reserved
// ====================================================================

class GUI extends object
	Abstract instanced native;

// -- These are set at spawn

var				GUIController 		Controller;				// Callback to the GUIController running the show
	
enum eMenuState		// Defines the various states of a component
{
	MSAT_Blurry,			// Component has no focus at all
	MSAT_Watched,			// Component is being watched (ie: Mouse is hovering over, etc)  
	MSAT_Focused,			// Component is Focused (ie: selected)
	MSAT_Pressed,			// Component is being pressed
	MSAT_Disabled,			// Component is disabled.
};

enum eTextAlign		// Used for aligning text in a box
{
	TXTA_Left,
	TXTA_Center,
	TXTA_Right,
};

enum eTextCase		// Used for forcing case on text
{
	TXTC_None,
	TXTC_Upper,
	TXTC_Lower,
};

enum eImgStyle		// Used to define the style for an image
{
	ISTY_Normal,
	ISTY_Stretched,
	ISTY_Scaled,
	ISTY_Bound,
	ISTY_Justified,
	ISTY_TileTiled,		// cool new border/box thingy
	ISTY_BorderTiled,	// hollow version of ISTY_TileTiled
};

enum eImgAlign		// Used for aligning justified images in a box
{
	IMGA_TopLeft,
	IMGA_Center,
	IMGA_BottomRight,
};

enum eEditMask		// Used to define the mask of an input box
{
	EDM_None,
	EDM_Alpha,
	EDM_Numeric,
};

enum EMenuRenderStyle
{
	MSTY_None,
	MSTY_Normal,
	MSTY_Masked,
	MSTY_Translucent,
	MSTY_Modulated,
	MSTY_Alpha,
	MSTY_Additive,
	MSTY_Subtractive,
	MSTY_Particle,
	MSTY_AlphaZ,
};

enum eIconPosition
{
	ICP_Normal,
	ICP_Center,
	ICP_Scaled,
	ICP_Stretched,
	ICP_Bound,
	ICP_ScaledClip,
};

enum ePageAlign			// Used to Align panels to a form.
{
	PGA_None,
	PGA_Client,
	PGA_Left,
	PGA_Right,
	PGA_Top,
	PGA_Bottom,
};

enum eXControllerCodes
{
	XC_Up, XC_Down, XC_Left, XC_Right,
    XC_A, XC_B, XC_X, XC_Y,
    XC_Black, XC_White,
    XC_LeftTrigger, XC_RightTrigger,
    XC_PadUp, XC_PadDown, XC_PadLeft, XC_PadRight,
    XC_Start, XC_Back,
    XC_LeftThumb, XC_RightThumb,
};

enum EGUIPropertyType
{
	MP_Default,	// see what the super class default wants
	MP_Yes,		// property is editable/managed
	MP_No		// property is not editable/managed
};

enum ELayoutOrientation
{
	LO_Vertical,
	LO_Horizontal,
};

enum ELayoutAlign
{
	LA_Left_Top,
	LA_Center,
	LA_Right_Bottom,
};

enum EClickSound
{
	CS_None,
	CS_Click,
	CS_Edit,
	CS_Up,
	CS_Down,
	CS_Back,
	CS_Focus,
	CS_Change,
};

enum EComponentPulseStyle
{
	CPS_None,
	CPS_Slow,
	CPS_Fast
};

const QBTN_Ok			=1;
const QBTN_Cancel		=2;
const QBTN_Retry		=4;
const QBTN_Continue		=8;
const QBTN_Yes			=16;
const QBTN_No			=32;
const QBTN_Abort		=64;
const QBTN_Ignore		=128;
const QBTN_OkCancel		=3;
const QBTN_AbortRetry	=68;
const QBTN_YesNo		=48;
const QBTN_YesNoCancel	=50;

struct GUIListElem
{
	var string item;
	var object ExtraData;
	var string ExtraStrData;
};

struct GUITexCoords
{
	var () string KeyName;
	var () int U,V,UL,VL;
};

struct GUIIntRect
{
	var () int L,T,R,B;
};

struct GUIFRect
{
	var () float fL,fT,fW,fH;
};

// add some utility functions for things I'm tired of typing
static final function GUILog(string s)
{
	Log(s,'guilog');
}
function string ConsoleCommand(string cmd)
{
	return Controller.ViewportOwner.Actor.ConsoleCommand(cmd);
}

// ====================================================================
//  Class:  GUI.GUIButton
//
//	GUIButton - The basic button class
//
//  Written by Joe Wilcox
//  (c) 2002, Epic Games, Inc.  All Rights Reserved
// ====================================================================

class GUIButton extends GUIComponent
		Native;

cpptext
{
		void Draw(UCanvas* Canvas);
}		
		
var(Menu)		localized	string			Caption;
var(Menu)					bool			bNoArrowNavigation;
var(Menu)					bool			bForceCaps;			// Automatically call Caps() on contents of SetCaption()
var							bool			bTransparent;		// don't draw the style's background

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);
	OnKeyEvent=InternalOnKeyEvent;
    OnXControllerEvent=InternalOnXControllerEvent;
}

function bool InternalOnKeyEvent(out byte Key, out byte State, float delta)
{
	if (!bVisible || bDisabled)
		return false;

	if (key==0x0D && State==3)	// ENTER Pressed
	{
		Controller.PlayClickSound(OnClickSound);
		OnClick(self);
		return true;
	}
	
	if (!bNoArrowNavigation)
	{
		if (key==0x026 && State==1)
		{
			PrevControl(none);
			return true;
		}
				
		if (key==0x028 && State==1)
		{
			NextControl(none);
			return true;
		}
	}

	return false;
}

function bool InternalOnXControllerEvent(byte Id, eXControllerCodes iCode)
{
	if ((iCode==XC_Start) || (iCode==XC_A))	// added in case we're not merging
    {
 		Controller.PlayClickSound(OnClickSound);
   		OnClick(Self);
        return true;
    }
    return false;
}

function int GetCaptionPos(Canvas C, bool bCaptionFront)
{
	local int XL, YL;

	Style.TextSize(C, MenuState, Caption, XL, YL);

	XL = Min(XL, ActualWidth());

	// always centered...
	if (bCaptionFront)
		return ActualLeft() + 0.5 * (ActualWidth() - XL);
	else
		return ActualLeft() + 0.5 * (ActualWidth() + XL);
}

function SetCaption(optional string S)
{
	if (bForceCaps)
		Caption = CapsL(S);
	else
		Caption = S;
}

event ButtonPressed();		// Called when the button is pressed;
event ButtonReleased();		// Called when the button is released;

defaultproperties
{
	StyleName="RoundButton"	
	bAcceptsInput=true
	bCaptureMouse=True
	bNeverFocus=false
	bTabStop=true
	WinHeight=0.06
	WinWidth=0.15000
	bMouseOverSound=true
	OnClickSound=CS_Click
	bNoArrowNavigation=false
	bTransparent=false
}
// ====================================================================
//  Class:  GUI.GUIGFXButton
//
//  Written by Joe Wilcox
//  (c) 2002, Epic Games, Inc.  All Rights Reserved
// ====================================================================

class GUICheckBoxButton extends GUIGFXButton
	Native;


function string LoadINI()
{
	local string s;

	s = Super.LoadINI();

	if (S=="")
		return s;

	bChecked = bool(s);
	return s;
}

function SaveINI(string Value)
{
	Super.SaveINI(""$bChecked);
}


defaultproperties
{
	bCheckBox=true
	Position=ICP_Scaled
	bRepeatClick=false
// GBX:CEK: 3/16/2004 - TEMP GUI REINTEGRATION
	//Graphic=Texture'WhiteTexture'
	Graphic=Texture't_interface_mb.hud.dead_x'
//	Graphic=Material'GUIContent.menus.CheckBoxMark'
    bTabStop=true
}// ====================================================================
//  Class:  GUI.GUICircularList
//  Parent: GUI.GUIListBase
//
//  <Enter a description here>
// ====================================================================

class GUICircularList extends GUIListBase
	Native;

cpptext
{
	void Draw(UCanvas* Canva);	
}
		
var		bool		bCenterInBounds;		// Center the list in the bounding box
var		bool		bFillBounds;			// If true, the list will take up the whole bounding box
var		bool		bIgnoreBackClick;		// If true, will ignore any click on back region
var		bool		bAllowSelectEmpty;		// If true, allows selection of empty slots
var		int			FixedItemsPerPage;		// There are a fixed number of items in the list

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.Initcomponent(MyController, MyOwner);

	// Sanity
	
	if (bFillBounds)
		bCenterInBounds=false;

	if (!bAllowSelectEmpty && ItemCount == 0)
		Index = -1;

	OnKeyEvent=InternalOnKeyEvent;
	OnXControllerEvent=InternalOnXControllerEvent;
	OnClick=InternalOnClick;
}	

function float CalculateOffset(float MouseX)
{
	local float x,x1,x2,Width,xMod;
	local int i;

	x1 = ClientBounds[0];
	x2 = ClientBounds[2];

	if ( (MouseX<x1) || (MouseX>x2) )
		return -1.0;
	
	width = x2-x1;
		 
	if ( (bCenterInBounds) && (ItemsPerPage*ItemWidth<Width) )
	{
	
		xMod = (Width - (ItemsPerPage*ItemWidth)) / 2;
		x1+=xMod;
		x2-=xMod;
	
		if ( (MouseX>=x1) && (MouseX<=x2) )
			return (MouseX-x1) / ItemWidth;
		else
			return -1;
	}
	
	if ( (bFillBounds) && (ItemsPerPage*ItemWidth<Width) )
	{
		xMod = (Width - (ItemsPerPage*ItemWidth)) / ItemsPerPage;
		
		i = 0;
		x = x1;
		while (x<=x2)
		{
			if ((MouseX>=x) && (MouseX<=x+ItemWidth) )
				return i;
			
			i++;
			x+= ItemWidth+xmod;
		} 
		
		return -1;
	}
	
	return (MouseX-x1)/ItemWidth;
						
}
		
function bool InternalOnClick(GUIComponent Sender)
{
	local int NewIndex, Col;

	if ( ( !IsInClientBounds() ) || (ItemsPerPage==0) )
		return false;
		
	// Get the Col

	Col = CalculateOffset(Controller.MouseX);

	NewIndex = (Top + Col) % ItemCount;
	
	// Keep selected index in range
	if (NewIndex == -1 && bIgnoreBackClick)
		return false;
		
	// check if allowed to go out of range
	if ( (!bAllowSelectEmpty) 
		&& ( (NewIndex >= 0) && (NewIndex > ItemCount - 1))
		) 
		return false;

	SetIndex(NewIndex);
	return true;
}

function bool InternalOnKeyEvent(out byte Key, out byte State, float delta)
{

	if (ItemsPerPage==0) return false;

	
	if ( (Key==0x25 || Key==0x64) && (State==1) )	// Left Arrow
	{
		ScrollLeft();
		return true;
	}
	
	if ( (Key==0x27 || Key==0x66) && (State==1) ) // Left Arrow
	{
		ScrollRight();
		return true;
	}
	
	if ( (Key==0x24 || Key==0x67) && (State==1) ) // Home
	{
		Home();
		return true;
	}
	
	if ( (Key==0x23 || Key==0x61) && (State==1) ) // End
	{
		End();
		return true;
	}
	
	if ( (key==0xEC) && (State==3) )
	{
	
		WheelUp();
		return true;
	}
	
	if ( (key==0xED) && (State==3) )
	{
	
		WheelDown();
		return true;
	}
	
	
	return false;
}

function bool InternalOnXControllerEvent(byte Id, eXControllerCodes iCode)
{

	if (ItemsPerPage==0) return false;

	if (iCode==XC_Left || iCode==XC_PadLeft)
    {
    	ScrollLeft();
        return true;
    }
    else if (iCode==XC_Right || iCode==XC_PadRight)
    {
    	ScrollRight();
        return true;
    }

    else if (iCode==XC_Black)
    {
    	Home();
        return true;
    }

    else if (iCode==XC_White)
    {
    	End();
        return true;
    }

    else if (iCode==XC_X)
    {
    	PgDown();
        return true;
    }

    else if (iCode==XC_Y)
    {
    	PgUp();
        return true;
    }

	else if (iCode==XC_Start)
    {
    	OnClick(self);
        return true;
    }
    return false;
}



function WheelUp()
{
	ScrollLeft();
}

function WheelDown()
{
	ScrollRight();
}
	
function ScrollLeft()
{
	local int last;

	if (ItemCount<2)  return;

	Last = Index;
	
	if (Index==0)
		Index=ItemCount-1;
	else
		Index--;
		
	if (Last==Top)
		Top=Index;

	OnChange(self);

}

function ScrollRight()
{
	local int last;
	
	if (ItemCount<2)  return;

	Last = Index;
	
	Index++;
	if (Index==ItemCOunt)
		Index = 0;
		
	if (Last==(Top+ItemsPerPage-1)%ItemCount)
	{
		Top++;
		if (Top==ItemCount)
		  Top=0;
	}
	
	OnChange(self);
}
	
function Home()
{
	if (ItemCount<2)	return;	

	SetIndex(0);
	Top = 0;

	OnChange(self);
	
}

function End()
{
	if (ItemCount<2)	return;	

	Top = ItemCount - ItemsPerPage;
	if (Top<0)
		Top = 0;
		
	SetIndex(ItemCount-1);
}	

function PgUp()
{
	local int moveCount, Last;

	if (ItemCount<2)  return;

	for(moveCount=0; moveCount<ItemsPerPage-1; moveCount++)
	{
		Last = Index;

		if (Index==0)
			Index=ItemCount-1;
		else
			Index--;

		if (Last==Top)
			Top=Index;
	}

	OnChange(self);
}

function PgDown()
{
	local int moveCount, Last;

	if (ItemCount<2)  return;

	for(moveCount=0; moveCount<ItemsPerPage-1; moveCount++)
	{
		Last = Index;

		Index++;
		if (Index==ItemCOunt)
			Index = 0;

		if (Last==(Top+ItemsPerPage-1)%ItemCount)
		{
			Top++;
			if (Top==ItemCount)
				Top=0;
		}
	}

	OnChange(self);
}
		

defaultproperties
{
	bCenterInBounds=true
	bIgnoreBackClick=true
	FixedItemsPerPage=0;
	bAllowSelectEmpty=true
}
// ====================================================================
//	Class: GUI.GUIComboBox
//
//  A Combination of an EditBox, a Down Arrow Button and a ListBox
//
//  Written by Michel Comeau
//  (c) 2002, Epic Games, Inc.  All Rights Reserved
// ====================================================================

class GUIComboBox extends GUIMultiComponent
	Native;

cpptext
{
		void PreDraw(UCanvas* Canvas);

}

var Automated 	GUIEditBox 		Edit;
var Automated 	GUIComboButton 	MyShowListBtn;
var Automated 	GUIListBox 		MyListBox;
var				GUIList			List;


var(Menu)	int			MaxVisibleItems;
var(Menu)	bool		bListItemsOnly;
var(Menu)	bool		bShowListOnFocus;
var(Menu)	bool		bReadOnly;

var		int		Index;
var		string	TextStr;


function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.Initcomponent(MyController, MyOwner);

	List 			  = MyListBox.List;
	List.OnChange 	  = ItemChanged;
	List.bHotTrack	  = true;
	List.OnClickSound = CS_Click;
	List.OnCLick 	  = InternalListClick;
    List.OnInvalidate = InternalOnInvalidate;

    MyListBox.Hide();

	Edit.OnChange 			= TextChanged;
	Edit.OnMousePressed 	= InternalEditPressed;
	Edit.INIOption  		= INIOption;
	Edit.INIDefault 		= INIDefault;
	Edit.bReadOnly  		= bReadOnly;

	List.OnDeActivate = InternalListDeActivate;

	MyShowListBtn.OnClick = ShowListBox;
	MyShowListBtn.FocusInstead = List;

    SetHint(Hint);

}

function SetHint(string NewHint)
{
	local int i;
	Super.SetHint(NewHint);

    for (i=0;i<Controls.Length;i++)
    	Controls[i].SetHint(NewHint);
}

function InternalListDeActivate()
{
	if (!Edit.bPendingFocus)
		MyListBox.Hide();
}

function InternalOnInvalidate(GUIComponent Who)
{
	if ( Who != Controller.ActivePage )
    	return;

	MyListBox.Hide();
    Edit.SetFocus(None);
}

function InternalEditPressed(GUIComponent Sender, bool bRepeat)
{
	if ( (Edit.bReadOnly) && (!bRepeat) )
	{
		Controller.bIgnoreNextRelease = true;

		if ( !MyListBox.bVisible )
		{
			ShowListBox(Self);
		}
		else
			HideListBox();
	}

	return;
}

function bool InternalListClick(GUIComponent Sender)
{
	List.InternalOnClick(Sender);
	Edit.SetFocus(none);
	return true;

}

function HideListBox()
{
	MyListBox.Hide();
}

event SetVisibility(bool bIsVisible)
{
	Super.SetVisibility(bIsVisible);

	Edit.SetVisibility(bIsVisible);
	MyShowListBtn.SetVisibility(bIsVisible);
	MyListBox.SetVisibility(false);
}


function bool ShowListBox(GUIComponent Sender)
{

	MyListBox.SetVisibility(!MyListBox.bVisible);

	if (MyListBox.bVisible)
		List.SetFocus(none);

	return true;
}

function ItemChanged(GUIComponent Sender)
{
	Edit.SetText(List.SelectedText());
	Index = List.Index;
}

function TextChanged(GUIComponent Sender)
{
	TextStr = Edit.TextStr;
	OnChange(self);
}

function SetText(string NewText)
{
	Edit.SetText(NewText);
	List.Find(NewText);
}

function string Get()
{
	local string temp;

	temp = List.Get();

	if ( temp~=Edit.GetText() )
		return Edit.GetText();
	else
		return temp;
}

function string GetText() {
	return self.Get();
}

function object GetObject()
{
	local string temp;

	temp = List.Get();

	if ( temp~=Edit.GetText() )
		return List.GetObject();
	else
		return none;
}

function string GetExtra()
{
	local string temp;

	temp = List.Get();

	if ( temp~=Edit.GetText() )
		return List.GetExtra();
	else
		return "";
}

function SetIndex(int I)
{
	List.SetIndex(i);
}

function int GetIndex()
{
	return List.Index;
}

function AddItem(string Item, Optional object Extra, Optional string Str)
{
	List.Add(Item,Extra,Str);
}

function RemoveItem(int item, optional int Count)
{
	List.Remove(item, Count);
}

function string GetItem(int index)
{
	List.SetIndex(Index);
	return List.Get();
}

function object GetItemObject(int index)
{
	List.SetIndex(Index);
	return List.GetObject();
}

function string find(string Text, optional bool bExact)
{
	return List.Find(Text,bExact);
}

function int ItemCount()
{
	return List.ItemCount;
}

function ReadOnly(bool b)
{
	Edit.bReadOnly = b;
}

function InternalOnMousePressed(GUIComponent Sender, bool bRepeat)
{
	if (!bRepeat)
    {
		MyListBox.Show();
    }
}

defaultproperties
{
	Begin Object Class=GUIEditBox Name=EditBox1
		TextStr=""
	End Object

	Begin Object Class=GUIComboButton Name=ShowList
 		bRepeatClick=false
	End Object

	Begin Object Class=GUIListBox Name=ListBox1
		StyleName="ComboListBox"
		bVisible=false
	End Object

	Edit=EditBox1
	MyShowListBtn=ShowList
	MyListBox=ListBox1


	MaxVisibleItems=8
	WinHeight=0.06
	WinWidth=0.2000

	PropagateVisibility=true
}// ====================================================================
//  Class:  GUI.GUIComboButton
//
//  Written by Joe Wilcox
//  (c) 2002, Epic Games, Inc.  All Rights Reserved
// ====================================================================

class GUIComboButton extends GUIVertScrollButton
	native;

defaultproperties
{
	UpButton=false
	bRepeatClick=false
	OnClickSound=CS_Edit
}// ====================================================================
//  Class:  GUI.GUIComponent
//
//	GUIComponents are the most basic building blocks of menus.
//
//  Written by Joe Wilcox
//  (c) 2002, Epic Games, Inc.  All Rights Reserved
// ====================================================================

class GUIComponent extends GUI
		Native;

cpptext
{
		virtual void PreDraw(UCanvas *Canvas);	// Should be overridden in a subclass
		virtual void Draw(UCanvas* Canvas);		// Should be overridden in a subclass

		virtual UBOOL PerformHitTest(INT MouseX, INT MouseY);					// Check to see if a mouse press affects the control
		virtual void  UpdateBounds();											// Updates the Bounds for hit tests and such
		virtual FLOAT ActualWidth();											// Returns the actual width (including scaling) of a component
		virtual FLOAT ActualHeight();											// Returns the actual height (including scaling) of a component
		virtual FLOAT ActualLeft();												// Returns the actual left (including scaling) of a component
		virtual FLOAT ActualTop();												// Returns the actual top (including scaling) of a component
		virtual void  SaveCanvasState(UCanvas* Canvas);							// Save the current state of the canvas
		virtual void  RestoreCanvasState(UCanvas* Canvas);						// Restores the state of the canvas

		virtual UGUIComponent* UnderCursor(FLOAT MouseX, FLOAT MouseY);

		virtual UBOOL MouseMove(INT XDelta, INT YDelta);			// The Mouse has moved
		virtual UBOOL MousePressed(UBOOL IsRepeat);					// The Mouse was pressed
		virtual UBOOL MouseReleased();								// The Mouse was released
		virtual UBOOL MouseHover();									// The Mouse is over a non-pressed thing

		virtual UBOOL NativeKeyType(BYTE& iKey, TCHAR Unicode );				// Handle key presses
		virtual UBOOL NativeKeyEvent(BYTE& iKey, BYTE& State, FLOAT Delta);	// Handle key events

		virtual void SetDims(FLOAT Width, FLOAT Height, FLOAT Left, FLOAT Top);	// Set the dims quickly
		virtual void  CloneDims(UGUIComponent* From);	// Clones the Width,Height, Top, Left settings

		// helper functions that will set the size, position parameters, undoing any editor-related projections
		virtual void SetWidth(FLOAT Width);
		virtual void SetHeight(FLOAT Height);
		virtual void SetLeft(FLOAT Left);
		virtual void SetTop(FLOAT Top);

		virtual UBOOL SpecialHit();
		virtual void  NativeInvalidate(UGUIComponent* Who);
        virtual UBOOL XControllerEvent(int Id, eXControllerCodes iCode);
        virtual UBOOL RawXController(int Id, BYTE& iKey, BYTE& State, FLOAT Axis);
}

// Variables

var		GUIComponent 		MenuOwner;				// Callback to the Component that owns this one
var		eMenuState		MenuState;					// Used to determine the current state of this component

// RenderStyle and MenuColor are usually pulled from the Parent menu, unless specificlly overridden

var(Menu)	string				IniOption;					// Points to the INI option to load for this component
var(Menu)	string				IniDefault;					// The default value for a missing ini option
var(Menu)	string				StyleName;					// Name of my Style
var(Menu)	bool				bBoundToParent;				// Use the Parents Bounds for all positioning
var(Menu)	bool				bScaleToParent;				// Use the Parent for scaling
var(Menu)	bool				bHasFocus;					// Does this component currently have input focus
var(Menu)	bool				bVisible;					// Is this component currently visible
var(Menu)	bool				bAcceptsInput;				// Does this control accept input
var(Menu)	bool				bCaptureTabs;				// This control wants tabs
var(Menu)	bool				bCaptureMouse;				// Set this if the control should capture the mouse when pressed
var(Menu)	bool				bNeverFocus;				// This control should never fully receive focus
var(Menu)	bool				bRepeatClick;				// Have the system accept holding down of the mouse
var(Menu)	bool				bRequireReleaseClick;		// If True, this component wants the click on release even if it's not active
var(Menu)	bool				bTabStop;					// Does a TAB/Shift-Tab stop here
var(Menu)	bool				bFocusOnWatch;				// If true, watching focuses
var(Menu)	bool				bMouseOverSound;			// Should component bleep when mouse goes over it
var(Menu)	bool				bDisabled;
var(Menu)	GUIComponent		FocusInstead;				// Who should get the focus instead of this control if bNeverFocus
var(Menu)	localized string	Hint;						// The hint that gets displayed for this component
var(Menu)	float				WinTop,WinLeft;				// Where does this component exist (in world space) - Grr.. damn Left()
var(Menu)	float				WinWidth,WinHeight;			// Where does this component exist (in world space) - Grr.. damn Left()
var(Menu)	int					MouseCursorIndex;			// The mouse cursor to use when over this control
var(Menu)   int					TabOrder;					// Used to figure out tabbing
var(Menu)	float				RenderWeight;				// Used to determine sorting in the controls stack
var(Menu)	int					Tag;						// Not used.
var(Menu)	GUILabel			FriendlyLabel;				// My state is projected on this objects state.

var(Menu)	EClickSound			OnClickSound;

var			GUIComponent		BoundScaleControl;			// control, instead of MenuOwner to act as parent for bind/scale to parent

// Style holds a pointer to the GUI style of this component.

var			GUIStyles				Style;						// My GUI Style
var			EComponentPulseStyle	pulseStyle;

// Notes about the Top/Left/Width/Height : This is a somewhat hack but it's really good for functionality.  If
// the value is <=1, then the control is considered to be scaled.  If they are >1 they are considered to be normal world coords.
// 0 = 0, 1 = 100%

var			int			Bounds[4];								// Internal normalized positions in world space
var			int			ClientBounds[4];						// The bounds of the actual client area (minus any borders)

var			bool		bPendingFocus;							// Big big hack for ComboBoxes..

// Timer Support
var const	int			TimerIndex;			// For easier maintenance
var			bool		bTimerRepeat;
var			float		TimerCountdown;
var			float		TimerInterval;

// Used for Saving the last state before drawing natively

var		float 	SaveX,SaveY;
var 	color	SaveColor;
var		font	SaveFont;
var		byte	SaveStyle;

// If you want to override a link to force this component to point to a given
// component on your page, set it here.

// 0 = Up
// 1 = Down
// 2 = Left
// 3 = Right
var GUIComponent LinkOverrides[4];
var GUIComponent Links[4];

// Delegates

// Drawing delegates return true if you want to short-circuit the default drawing code

Delegate bool OnPreDraw(Canvas Canvas);
Delegate bool OnDrawPre(Canvas Canvas);		// after predraw, before draw
Delegate bool OnDraw(Canvas Canvas);		// after draw

Delegate OnActivate();													// Called when the component gains focus
Delegate OnDeActivate();												// Called when the component loses focus
Delegate OnWatch();														// Called when the component is being watched
Delegate OnHitTest(float MouseX, float MouseY);							// Called when Hit test is performed for mouse input
Delegate OnRender(canvas Canvas);										// Called when the component is rendered
Delegate OnMessage(coerce string Msg, float MsgLife); 					// When a message comes down the line

Delegate OnHide();
Delegate OnShow();

Delegate OnInvalidate(GUIComponent Who);	// Called when the background is clicked

// -- Input event delegates

Delegate bool OnClick(GUIComponent Sender);			// The mouse was clicked on this control
Delegate bool OnDblClick(GUIComponent Sender);		// The mouse was double-clicked on this control
Delegate bool OnRightClick(GUIComponent Sender);	// Control was right clicked.

Delegate OnMousePressed(GUIComponent Sender, bool bRepeat);		// Sent when a mouse is pressed (initially)
Delegate OnMouseRelease(GUIComponent Sender);		// Sent when the mouse is released.

Delegate OnChange(GUIComponent Sender);	// Called when a component changes it's value

Delegate bool OnKeyType(out byte Key, optional string Unicode)  	// Key Strokes
{
	return false;
}

Delegate bool OnKeyEvent(out byte Key, out byte State, float delta)
{
	return false;
}

Delegate bool OnCapturedMouseMove(float deltaX, float deltaY)
{
	return false;
}

// Allows a control to process raw Console controller events

Delegate bool OnRawXController(byte Id, out byte Key, out byte State, out float Axis)
{
	return false;
}

Delegate bool OnXControllerEvent(byte Id, eXControllerCodes iCode); // XBox Controller Events


Delegate OnLoadINI(GUIComponent Sender, string s);		// Do the actual work here
Delegate string OnSaveINI(GUIComponent Sender); 		// Do the actual work here

event Opened(GUIComponent Sender);	// Called when the Menu Owner is opened
event Closed(GUIComponent Sender, bool bCancelled);	// Called when the Menu Owner is closed

event Free() 			// This control is no longer needed
{
	Controller.MarkForDestruction(self);
	MenuOwner 		= None;
    Controller	 	= None;
    FocusInstead 	= None;
    FriendlyLabel 	= None;
    Style			= None;

	LinkOverrides[0] = None;
	LinkOverrides[1] = None;
	LinkOverrides[2] = None;
	LinkOverrides[3] = None;
	Links[0] = None;
	Links[1] = None;
	Links[2] = None;
	Links[3] = None;
}

function PlayerController PlayerOwner()
{
	return Controller.ViewportOwner.Actor;
}


event Timer();		// Should be subclassed

function native final SetTimer(float Interval, optional bool bRepeat);
function native final KillTimer();
function native final string GetConfigString(string keyName, string section, string iniFile);

function string LoadINI()
{
	local string s;

	if ( (PlayerOwner()==None) || (INIOption=="") )
		return "";

	if(!(INIOption~="@INTERNAL"))
		s = PlayerOwner().ConsoleCommand("get"@IniOption);

	if (s=="")
		s = IniDefault;

	OnLoadINI(Self,s);

	return s;
}

function SaveINI(string Value)
{
	local string s;

	if (INIOption=="")
		return;

	if (PlayerOwner()==None)
		return;

	s = OnSaveINI(Self);
	if ( s!="" )
	{
	}
}

function string ParseOption(string URL, string Key, string DefaultVal)
{
	local string s;

	if (PlayerOwner()==None)
		return DefaultVal;

	s = PlayerOwner().Level.Game.ParseOption( URL, Key);
	if (s=="")
		return DefaultVal;
	else
		return s;
}

// Take a string and strip out colour codes
static function string StripColorCodes(string InString)
{
	local int CodePos;

	CodePos = InStr(InString, Chr(27));
	while(CodePos != -1 && CodePos < Len(InString)-3) // ignore colour codes at the end of the string
	{
		InString = Left(InString, CodePos)$Mid(InString, CodePos+4);

		CodePos = InStr(InString, Chr(27));
	}

	return InString;
}

static function string MakeColorCode(color NewColor)
{
	// Text colours use 1 as 0.
	if(NewColor.R == 0)
		NewColor.R = 1;

	if(NewColor.G == 0)
		NewColor.G = 1;

	if(NewColor.B == 0)
		NewColor.B = 1;

	return Chr(0x1B)$Chr(NewColor.R)$Chr(NewColor.G)$Chr(NewColor.B);
}

// Functions

event MenuStateChange(eMenuState Newstate)
{
	// if we're disabled, force the state to disabled
	if (bDisabled)
		Newstate = MSAT_Disabled;

	// Check for never focus

	bPendingFocus=false;

	if (NewState==MSAT_Focused && bNeverFocus)
		NewState = MSAT_Blurry;

	MenuState = NewState;

	switch (MenuState)
	{
		case MSAT_Blurry:
			bHasFocus = false;
			OnDeActivate();
			break;

		case MSAT_Watched:
			if (bFocusOnWatch)
			{
				SetFocus(None);
				return;
			}

			OnWatch();
			break;

		case MSAT_Focused:
			bHasFocus = true;
			OnActivate();
			break;

		case MSAT_Disabled:
			bHasFocus = false;
			OnDeActivate();
			break;
	}

	if (FriendlyLabel!=None)
		FriendlyLabel.MenuState=MenuState;

}

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{

	Controller = MyController;
	MenuOwner = MyOwner;

	SetStyle(StyleName);
}

function SetStyle(string s)
{
	if (s != "")
	{
		Style = Controller.GetStyle(s);
	}
}

function InitDelegates();

function bool IsInBounds()	// Script version of PerformHitTest
{
	return ( (Controller.MouseX >= Bounds[0] && Controller.MouseX<=Bounds[2]) && (Controller.MouseY >= Bounds[1] && Controller.MouseY <=Bounds[3]) );
}

function bool IsInClientBounds()
{
	return ( (Controller.MouseX >= ClientBounds[0] && Controller.MouseX<=ClientBounds[2]) && (Controller.MouseY >= ClientBounds[1] && Controller.MouseY <=ClientBounds[3]) );
}

event SetFocus(GUIComponent Who)
{
	if (bNeverFocus)
	{
		if (FocusInstead != None)
			FocusInstead.SetFocus(Who);

		return;
	}

	MenuStateChange(MSAT_Focused);

	if (Controller.FocusedControl!=None)
    {
    	if  (Controller.FocusedControl == Self)	// Already Focused
			return;
        else
			Controller.FocusedControl.LoseFocus(None);
	}

	bPendingFocus = true;

	Controller.FocusedControl = self;

	if (MenuOwner!=None)
		MenuOwner.SetFocus(self);
}

event LoseFocus(GUIComponent Sender)
{
	if (Controller!=None)
		Controller.FocusedControl = None;

	MenuStateChange(MSAT_Blurry);

	if (MenuOwner!=None)
		MenuOwner.LoseFocus(Self);
}

event bool FocusFirst(GUIComponent Sender)	// Focus your first child, or yourself if no childrean
{
	if ( (!bVisible) || (bNeverFocus) || (MenuState==MSAT_Disabled) || (!bTabStop) )
		return false;

	return true;
}

event bool FocusLast(GUIComponent Sender) // Focus your last child, or yourself
{
	if ( (!bVisible) || (bNeverFocus) || (MenuState==MSAT_Disabled) || (!bTabStop) )
		return false;

	SetFocus(None);
	return true;
}

event bool NextControl(GUIComponent Sender)
{
	if (MenuOwner!=None)
		return MenuOwner.NextControl(Self);

	return false;
}

event bool PrevControl(GUIComponent Sender)
{
	if (MenuOwner!=None)
		return MenuOwner.PrevControl(Self);

	return false;
}

event bool NextPage()
{
	if (MenuOwner != None)
		return MenuOwner.NextPage();

	return false;
}

event bool PrevPage()
{
	if (MenuOwner != None)
		return MenuOwner.PrevPage();

	return false;
}

// Force control to use same area as its MenuOwner.
function FillOwner()
{
	WinLeft = 0.0;
	WinTop = 0.0;
	WinWidth = 1.0;
	WinHeight = 1.0;
	bScaleToParent = true;
	bBoundToParent = true;
}

event SetVisibility(bool bIsVisible)
{
	bVisible = bIsVisible;

    if (bVisible)
    	OnShow();
    else
    	OnHide();
}

event Hide()
{
	SetVisibility(false);
}

event Show()
{
	SetVisibility(true);
}

function SetFriendlyLabel(GUILabel NewLabel)
{
	FriendlyLabel = NewLabel;
}

function SetHint(string NewHint)
{
	Hint = NewHint;
}

function SetLinks(GUIComponent cUp,GUIComponent cDown,GUIComponent cLeft,GUIComponent cRight)
{
	Links[0] = cUp;
    Links[1] = cDown;
    Links[2] = cLeft;
    Links[3] = cRight;
}

function SetLinkOverrides(GUIComponent cUp,GUIComponent cDown,GUIComponent cLeft,GUIComponent cRight)
{
	LinkOverrides[0] = cUp;
    LinkOverrides[1] = cDown;
    LinkOverrides[2] = cLeft;
    LinkOverrides[3] = cRight;
}

function int GetCaptionPos(Canvas C, bool bCaptionFront)
{
	return ActualLeft();
}

function SetCaption(optional string S)
{
	if (FriendlyLabel != None)
		FriendlyLabel.SetCaption(s);
}

// helper function to manage the menu state, based on a simple enable/disable bool
function EnableControl(bool enable)
{
	if (!enable && !bDisabled)
	{
		bDisabled = true;
		if (bHasFocus) NextControl(None);	// skip to the next control if we have focus

		MenuStateChange(MSAT_Disabled);
	}
	else if (enable && bDisabled)//(MenuState == MSAT_Disabled)
	{
		bDisabled = false;
		MenuStateChange(MSAT_Blurry);
	}
}

// Incorporate token parser for xbox live stuff
static simulated function String ParseToken(out String Str)
{
    local String Ret;
    local int len;

    Ret = "";
    len = 0;

	// Skip spaces and tabs.
	while( Left(Str,1)==" " || Asc(Left(Str,1))==9 )
		Str = Mid(Str, 1);

	if( Asc(Left(Str,1)) == 34 )
	{
		// Get quoted String.
		Str = Mid(Str, 1);
		while( Str!="" && Asc(Left(Str,1))!=34 )
		{
			Ret = Ret $ Mid(Str,0,1);
            Str = Mid(Str, 1);
		}
		if( Asc(Left(Str,1))==34 )
			Str = Mid(Str, 1);
	}
	else
	{
		// Get unquoted String.
		for( len=0; (Str!="" && Left(Str,1)!=" " && Asc(Left(Str,1))!=9); Str = Mid(Str, 1) )
            Ret = Ret $ Mid(Str,0,1);
	}

	return Ret;
}

static function string ParseTokenDelimited(out string str, optional string delimiter)
{
	local string result;
	local int index;

	result = "";
	if (delimiter == "")
		delimiter = ",";

    index = InStr(str, delimiter);
    if (index < 0)
    {
        result = str;
		str = "";
    }
	else
	{
		result = Left(str, index);
		str = Right(str, Len(str) - index - 1);
	}

	return result;
}

static function bool ParseCommand(out string strIn, string strTest)
{
	local int testLen;

	testLen = Len(strTest);
	if (Left(strIn, testLen) ~= strTest)
	{
		strIn = Right(strIn, Len(strIn) - testLen);
		return true;
	}

	return false;
}

// *yoink* from Actor
static final function ReplaceText(out string Text, string Replace, string With)
{
	local int i;
	local string Input;

	Input = Text;
	Text = "";
	i = InStr(Input, Replace);
	while(i != -1)
	{
		Text = Text $ Left(Input, i) $ With;
		Input = Mid(Input, i + Len(Replace));
		i = InStr(Input, Replace);
	}
	Text = Text $ Input;
}

final function string MakeQuotedString( string in )
{
    return "\""$in$"\"";
}

// 0=top, 1=center, 2=bottom
static function LayoutControlArray(out array<GUIComponent> list, float fPivot, float spacing, ELayoutAlign alignMode, optional ELayoutOrientation layoutDir)
{
	local int i;
	local float totalSize;
	local float fPos;

	if (list.Length == 0)
		return;

	if (alignMode != LA_Left_Top)
	{
		totalSize = 0;
		for (i=0; i<list.Length; i++)
		{
			if (list[i].bVisible)
			{
				if (layoutDir == LO_Horizontal)
					totalSize += list[i].WinWidth;
				else
					totalSize += list[i].WinHeight;

				if (i < list.Length-1)
				{
					totalSize += spacing;
				}
			}
		}

		if (alignMode == LA_Center)
			fPos = fPivot - 0.5f*totalSize;
		else
			fPos = fPivot - totalSize;
	}
	else
	{
		fPos = fPivot;
	}

	for (i=0; i<list.Length; i++)
	{
		if (list[i].bVisible)
		{
			if (layoutDir == LO_Horizontal)
			{
				list[i].WinLeft = fPos;
				fPos += list[i].WinWidth + spacing;
			}
			else
			{
				list[i].WinTop = fPos;
				fPos += list[i].WinHeight + spacing;
			}
		}
	}
}

function SetWinDims(GUIFRect newDims)
{
	SetLeft(newDims.fL);
	SetTop(newDims.fT);
	SetWidth(newDims.fW);
	SetHeight(newDims.fH);
}

function SetWinPos(GUIFRect newPos)
{
	SetLeft(newPos.fL);
	SetTop(newPos.fT);
}

function SetWinSize(GUIFRect newSize)
{
	SetWidth(newSize.fW);
	SetHeight(newSize.fH);
}

function DrawBackground(Canvas C, float X, float Y, float XL, float YL, optional float expandX, optional float expandY)
{
	expandX *= Controller.CanvasAspectScale;
	expandY *= Controller.CanvasScaleY;

	C.SetPos( X - expandX, Y - expandY );
	C.DrawTileTiledClip(	Texture't_interface_mb.hud.interface_comp', 
							XL + 2.0 * expandX, YL + 2.0 * expandY, 
							284, 128, 128, 128,
							32, 32);
}

function DrawComponentBackground(Canvas C, optional float expandX, optional float expandY)
{
	DrawBackground(C, ActualLeft(), ActualTop(), ActualWidth(), ActualHeight(), expandX, expandY);
}

static function SortStringList(out array<string> list, optional bool bDescending)
{
    local int i, j;
    local string tmp;

	for	(i=0; i<list.Length-1; i++)
	{
		for	(j=i+1;	j<list.Length; j++)
		{
			if(	(bDescending && (list[i] < list[j])) || (!bDescending && (list[i] > list[j])))
			{
				tmp	= list[i];
				list[i]	= list[j];
				list[j]	= tmp;
			}
		}
	}
}

static function int AddStringListItem(out array<string> list, string item)
{
	local int len;

	len = list.Length;
	list.Length = len + 1;
	list[len] = item;

	return len;
}

// The ActualXXXX functions are not viable until after the first render so don't
// use them in inits
native function float ActualWidth();
native function float ActualHeight();
native function float ActualLeft();
native function float ActualTop();

native function SetWidth(float fWidth);
native function SetHeight(float fHeight);
native function SetLeft(float fLeft);
native function SetTop(float fTop);

function float HorizontalOffset(float frac, optional bool bFromRight)
{
	if (bFromRight)
		frac = 1 - frac;

	return ActualLeft() + ActualWidth() * frac;
}

function float VerticalOffset(float frac, optional bool bFromBottom)
{
	if (bFromBottom)
		frac = 1 - frac;

	return ActualTop() + ActualHeight() * frac;
}

defaultproperties
{
	MenuState=MSAT_Blurry
	IniOption=""
	bBoundToParent=false
	bScaleToParent=false
	bHasFocus=false
	bVisible=true
	bAcceptsInput=false
	bCaptureTabs=false
	bCaptureMouse=false
	bNeverFocus=false
	bRepeatClick=false
	WinTop=0.0
	WinLeft=0.0
	WinWidth=1.0
	WinHeight=1.0
	Tag=-1
	MouseCursorIndex=0
	bFocusOnWatch=false
	bRequireReleaseClick=false
	TimerIndex=-1
	bMouseOverSound=false
	OnClickSound=CS_None
    RenderWeight=0.5
    bTabStop=false
	bDisabled=false

	pulseStyle=CPS_None
}// ====================================================================
//  Class:  Engine.GUIController
//
//  The GUIController is a simple FILO menu stack.  You have 3 things
//  you can do.  You can Open a menu which adds the menu to the top of the
//  stack.  You can Replace a menu which replaces the current menu with the
//  new menu.  And you can close a menu, which returns you to the last menu
//  on the stack.
//
//  Written by Joe Wilcox
//  (c) 2002, Epic Games, Inc.  All Rights Reserved
// ====================================================================

class GUIController extends BaseGUIController
		Native;

#exec OBJ LOAD FILE=..\texture\t_interface_mb.utx

cpptext
{
		void  NativeMessage(const FString Msg, FLOAT MsgLife);
		UBOOL NativeKeyType(BYTE& iKey, TCHAR Unicode );
		UBOOL NativeKeyEvent(BYTE& iKey, BYTE& State, FLOAT Delta );
		void  NativeTick(FLOAT DeltaTime);
		void  NativePreRender(UCanvas* Canvas);
		void  NativePostRender(UCanvas* Canvas);

		UBOOL DoXControllerEvent(int Id, eXControllerCodes iCode);

		virtual void LookUnderCursor(FLOAT dX, FLOAT dY);
		UGUIComponent* UnderCursor(FLOAT MouseX, FLOAT MouseY);

		UBOOL virtual MousePressed(UBOOL IsRepeat);
		UBOOL virtual MouseReleased();

		UBOOL HasMouseMoved();

		void PlayInterfaceSound(USound* sound);
		void PlayClickSound(BYTE SoundNum);
}

var	transient			TexturePool			GUITexturePool;

var	editinline export	array<GUIPage>		MenuStack;			// Holds the stack of menus
var						GUIPage				ActivePage;			// Points to the currently active page
var editinline 			Array<GUIFont>		FontStack;			// Holds all the possible fonts
var 					Array<GUIStyles>	StyleStack;			// Holds all of the possible styles
var						Array<string>		StyleNames;			// Holds the name of all styles to use
var editinline 			Array<Material>		MouseCursors;		// Holds a list of all possible mouse
var editinline			Array<vector>		MouseCursorOffset;  // Only X,Y used, between 0 and 1. 'Hot Spot' of cursor material.
var						Array<GUIPage>		PersistentStack;	// Holds the set of pages which are persistent across close/open
var	editinline export	array<GUIComponent>	DestroyComps;		// Destroy these pages at the end of the next tick

var						byte				ControllerMask;		// Used to mask input for various Controllers
var						byte				ControllerId;		// The current Controller ID #
var						byte				ControllerIdInUse[4];	// has this controller been used for input?
var						int					LastXControllerId;	// The last controller ID to provide actual input
var						float				MouseX,MouseY;		// Where is the mouse currently located

var						float				LastMouseX, LastMouseY;

var						bool				ShiftPressed;		// Shift key is being held
var						bool				AltPressed;			// Alt key is being held
var						bool				CtrlPressed;		// Ctrl key is being held


var						float				DblClickWindow;			// How long do you have for a double click
var						float				LastClickTime;			// When did the last click occur
var						int					LastClickX,LastClickY;	// Who was the active component

var						float				ButtonRepeatDelay;		// The amount of delay for faking button repeats
var						byte				RepeatKey[4];			// Used to determine what should repeat
var						float				RepeatDelta[4];			// Data var
var						float				RepeatTime[4];			// How long until the next repeat;
var						float				CursorFade;				// How visible is the cursor
var	config				float				CursorFadeRate;			// How fast does the cursor flash?
var						int					CursorStep;				// Are we fading in or out

var						float				FastCursorFade;			// How visible is the cursor
var	config				float				FastCursorFadeRate;		// How fast does the cursor flash?
var						int					FastCursorStep;			// Are we fading in or out

var						GUIComponent		FocusedControl;			// Top most Focused control
var						GUIComponent 		ActiveControl;			// Which control is currently active
var						GUIComponent		SkipControl;			// This control should be skipped over and drawn at the end
var						GUIComponent		MoveControl;			// Used for visual design

var						bool				bIgnoreNextRelease;		// Used to make sure discard errant releases.

var config				bool 				bModAuthor;				// Allows bDesign Mode
var 					bool				bDesignMode;			// Are we in design mode;
var						bool				bHighlightCurrent;		// Highlight the current control being edited
var						GUIPage				theEditor;

var						bool				bCurMenuInitialized;	// Has the current Menu Finished initialization

var						string				GameResolution;
var config				float				MenuMouseSens;
var config				float				MenuMouseAccel;

var						bool				MainNotWanted;			// Set to true if you don't want main to appear.

// Sounds
var						sound				MouseOverSound;
var						sound				ClickSound;
var						sound				EditSound;
var						sound				UpSound;
var						sound				DownSound;
var						sound				BackSound;
var						sound				FocusSound;
var						sound				ChangeSound;

// music!
var 					int					iMusicHandle;
var						float				fWantMusicTime;

var config				bool				bNoLinkLost;
var						bool				bForceMouseCheck;		// HACK
var						bool				bIgnoreUntilPress;		// HACK
var						bool				bGotEscapeDown;			// make sure we got an escape down before we send an escape up through the system
var						bool				bHidHUD;
var						int					iRestoreHandedness;

var	config				array<string>		AutoLoad;	// Any menu classes in here will be automatically loaded

var					float					CanvasScaleX, CanvasScaleY;
var					float					CanvasAspectScale;
var					float					ScreenSafeBorderX, ScreenSafeBorderY;	// fractions of the screen determined to be "off-limits"
var					float					fWideScreenCompensateScale;

var string									CurrentProfiles[2];
var int										CurrentControllers[2];
var bool									bHandledInput;


// Joystick/JoyPad/Console Specific

var	config	bool	bEmulatedJoypad;	// Have the cursor keys emulate a XBox controller
var	config	bool	bJoyMouse;			// When true, right control stick acts as a 1 button mouse
var config  bool	bHideMouseCursor;	// When true, the mouse cursor will be hidden
var config  float	JoyDeadZone;		// The DeadZone for joysticks
var config	string	MenuTextEntry;		// virtual keyboard/text entry screen

var		Float	JoyLeftXAxis[4];
var		Float 	JoyLeftYAxis[4];
var		Float	JoyRightXAxis[4];
var		Float	JoyRightYAxis[4];
var		Byte	JoyButtons[64];

var float JoyControlsDelta[16];	// How long since a joystick was converted

var gbx_LiveFunc		LiveFunc;
var class<gbx_LiveFunc>	LiveFuncClass;

// Temporary for Design Mode
var Material WhiteBorder;

var Color									RedLineColor;
var Color									BackgroundBoxColor;

native event GUIFont GetMenuFont(string FontName); 	// Finds a given font in the FontStack
native event GUIStyles GetStyle(string StyleName); 	// Find a style on the stack
native function string GetCurrentRes();				// Returns the current res as a string
native function string GetMainMenuClass();			// Returns GameEngine.MainMenuClass

// Utility functions for the UI

native function GetMapList(string Prefix, GUIList list);

native function ResetKeyboard();
native function MouseEmulation(bool On);
native function Engine GetEngine();

native function string GetVersionString();

delegate bool OnNeedRawKeyPress(byte NewKey);

// ================================================
// sound/music functions

native function PlayClickSound(byte SoundNum);

event StartMusic()
{
	local float trashDuration;
	
	if (iMusicHandle == default.iMusicHandle)
	{
		if ( ViewportOwner.Actor.Level.IsMenuMap() )
			iMusicHandle = ViewportOwner.Actor.PlayMusic( "UI_MUSIC.MUSIC", 0.0, trashDuration, true );
		// PSV: 9/10/2005 - DaveM says music should only play in the main menu
		//else
		//	iMusicHandle = ViewportOwner.Actor.PlayMusic( "MUSIC.UI", 0.0, trashDuration, true );
	}

	Log("GUIController::StartMusic " $iMusicHandle, 'guilog');
}

function StopMusic()
{
	Log("GUIController::StopMusic", 'guilog');

	if( iMusicHandle != default.iMusicHandle )
	{
		ViewportOwner.Actor.StopMusic( iMusicHandle, 0.0 );
		iMusicHandle = default.iMusicHandle;
	}
}

function CacheSounds()
{
	BackSound = Sound( DynamicLoadObject( "UI.BACK", class'Sound' ) );
	ClickSound = Sound( DynamicLoadObject( "UI.CONTINUE", class'Sound' ) );
	FocusSound = Sound( DynamicLoadObject( "UI.HIGHLIGHT", class'Sound' ) );
	ChangeSound = Sound( DynamicLoadObject( "UI.MENU_ADJ", class'Sound' ) );

	// PSV: 2/23/2005 The PC plays the same sound for both
	if ( ViewportOwner.Actor.Level.IsMenuMap() )
		DynamicLoadObject( "UI_MUSIC.MUSIC", class'Sound' );
	else
		DynamicLoadObject( "MUSIC.UI", class'Sound' );			
}


// ================================================
// CreateMenu - Attempts to Create a menu.  Returns none if it can't

event GUIPage CreateMenu(string NewMenuName)
{
	local class<GUIPage> NewMenuClass;
	local GUIPage NewMenu;
	local int i;

	// Load the menu's package if needed

	NewMenuClass = class<GUIPage>(DynamicLoadObject(NewMenuName,class'class'));
	if (NewMenuClass != None)
	{
		// If it's persistent, try to find an instance in the PersistentStack.
		if( NewMenuClass.default.bPersistent )
		{
			for( i=0;i<PersistentStack.Length;i++ )
            {
				if( PersistentStack[i].Class == NewMenuClass )
				{
					NewMenu = PersistentStack[i];
					break;
				}
            }
		}

		// Not found, spawn a new menu
		if( NewMenu == None )
		{
			NewMenu = new(None) NewMenuClass;

			// Check for errors
			if (NewMenu == None)
			{
				log("Could not create requested menu"@NewMenuName, 'guilog');
				return None;
			}
			else
			if( NewMenuClass.default.bPersistent )
			{
				// Save in PersistentStack if it's persistent.
				i = PersistentStack.Length;
				PersistentStack.Length = i+1;
				PersistentStack[i] = NewMenu;
			}
		}
		return NewMenu;
	}
	else
	{
		log("Could not DLO menu '"$NewMenuName$"'", 'guilog');
		return none;
	}

}

function CloseAllNonTopMost()
{
	local int i;

	for (i=0;i<MenuStack.Length;i++)
	{
		if (MenuStack[i].IsTopMost())
			continue;

		// notify them that they're being closed...
		MenuStack[i].Closed(None,false);

		MenuStack[i].CheckResolution(true);
        MenuStack[i].ParentPage = None;

    	if (!MenuStack[i].bPersistent)
        	MenuStack[i].Free();

		if (MenuStack[i] == ActivePage)
			ActivePage = None;

		MenuStack[i] = None;
	}

	for (i=MenuStack.Length-1; i>=0; i--)
	{
		if (MenuStack[i] == None)
		{
			MenuStack.Remove(i,1);
		}
	}

	if ((ActivePage == None) && (MenuStack.Length > 0))
		ActivePage = MenuStack[MenuStack.Length-1];
}

// ================================================
// OpenMenu - Opens a new menu and places it on top of the stack

function SetupNewMenuController(GUIPage newPage, GUIPage PrevPage)
{
	// new system only support inheriting; ownership must be set manually
	if (newPage.default.PagePlayerIndex < -1)
	{
		if (PrevPage != None)
			newPage.PagePlayerIndex = PrevPage.PagePlayerIndex;
		else
		{
			log("WARNING: page trying to inherit PlayerIndex from PrevPage but no PrevPage exists.", 'guilog');
			newPage.PagePlayerIndex = -1;
		}
	}
/*
	if (newPage.Default.ControllerIndex == -3)
	{
		if (PrevPage != None)
			newPage.ControllerIndex = PrevPage.ControllerIndex;
	}
	else if (newPage.Default.ControllerIndex == -2)
	{
		newPage.ControllerIndex = ControllerId;
	}
*/		
	log("Binding page" @newPage $" to player " $newPage.PagePlayerIndex, 'guilog');
}

event bool OpenMenu(string NewMenuName, optional string Param1, optional string Param2, optional bool bAvoidDuplicates)
{
	local GUIPage NewMenu,CurMenu;

	// Sanity Check

	//log("GUIController::OpenMenu - Attempt to open menu ["$NewMenuName$"]");
	//log("GUIController::MenuMouseSens="$MenuMouseSens);

	if (bAvoidDuplicates && MenuIsOpen(NewMenuName))
		return false;

	NewMenu = CreateMenu(NewMenuName);

	if (NewMenu.bCloseNonTopMost)
		CloseAllNonTopMost();

	bCurMenuInitialized=false;
	if (NewMenu!=None)
	{
		CurMenu = ActivePage;

		NewMenu.ParentPage = CurMenu;

		// Add this menu to the stack and give it focus

		MenuStack.Length = MenuStack.Length+1;
		MenuStack[MenuStack.Length-1] = NewMenu;

		SetupNewMenuController(NewMenu, CurMenu);

		ActivePage = NewMenu;

		ResetFocus();

		// If not persistent, Initialize this Menu

        if (NewMenu.Controller == None)
			NewMenu.InitComponent(Self, none);

		if (ActivePage == NewMenu)
		{
			// Remove focus from the last menu

			if (CurMenu!=None)
			{
				CurMenu.MenuState = MSAT_Blurry;
				CurMenu.OnDeActivate();
				CurMenu.OpenedChild(NewMenu);
			}

			NewMenu.CheckResolution(false);
			NewMenu.Opened(None);	// Pass along the event
			NewMenu.MenuState = MSAT_Focused;

			SetControllerStatus(true);
			bCurMenuInitialized=true;

			NewMenu.HandleParameters(Param1, Param2);

			bForceMouseCheck = true;

			if (NewMenu.bDisconnectOnOpen)
			{
        		ConsoleCommand("disconnect");
			}
		}

		return true;
	}
	else
	{
		log("Could not open menu"@NewMenuName, 'guilog');
		return false;
	}
}

event AutoLoadMenus()
{
	local GUIPage NewMenu;
    local int i;

    super.AutoLoadMenus();

    for (i=0;i<AutoLoad.Length;i++)
	{
    	NewMenu = CreateMenu(AutoLoad[i]);
		if (NewMenu==None)
        	log("Could not auto-load"@AutoLoad[i], 'guilog');
	}
}

// ================================================
// Replaces a menu in the stack.  returns true if success

event bool ReplaceMenu(string NewMenuName, optional string Param1, optional string Param2, optional bool bAvoidDuplicates)
{
	local GUIPage NewMenu,CurMenu;

	if (bAvoidDuplicates && MenuIsOpen(NewMenuName))
		return false;

	NewMenu = CreateMenu(NewMenuName);

	if (NewMenu.bCloseNonTopMost)
		CloseAllNonTopMost();

	bCurMenuInitialized=false;
	if (NewMenu!=None)
	{
		CurMenu = ActivePage;

		SetupNewMenuController(NewMenu, CurMenu);

		// Add this menu to the stack and give it focus

		NewMenu.MenuState = MSAT_Focused;

		if (CurMenu==None)
			MenuStack.Length = MenuStack.Length+1;
        else
       		CurMenu.OnClose(false);

		MenuStack[MenuStack.Length-1] = NewMenu;
		ActivePage = NewMenu;
		NewMenu.ParentPage = CurMenu.ParentPage;

		ResetFocus();

        if (NewMenu.Controller == None)
			NewMenu.InitComponent(Self, None);

		NewMenu.CheckResolution(false);
		NewMenu.Opened(None);						// Pass along the event
		NewMenu.MenuState = MSAT_Focused;
		NewMenu.OnActivate();

		SetControllerStatus(true);
		bCurMenuInitialized=true;

		NewMenu.HandleParameters(Param1, Param2);
		bForceMouseCheck = true;

        if (CurMenu!=None) // Close out the current page
        {
		    CurMenu.ParentPage=None;

	        if (!CurMenu.bPersistent)       // keep access to the controller if we are not up
	            CurMenu.Free();
        }

		return true;
	}
	else
		return false;
}
event bool CloseMenu(optional bool bCanceled)	// Close the top menu.  returns true if success.
{

	local GUIPage CurMenu;
	local int 	  CurIndex;

	if (MenuStack.Length <= 0)
	{
		log("Attempting to close a non-existing menu page", 'guilog');
		return false;
	}

	CurIndex = MenuStack.Length-1;
	CurMenu = MenuStack[CurIndex];

	log("GUIController::CloseMenu - "@CurMenu, 'guilog');

	// Remove the menu from the stack
	MenuStack.Remove(MenuStack.Length-1,1);

	// Look for the resolution switch

	if (MenuStack.Length>0)
	{
		MenuStack[MenuStack.Length-1].Show();
	}

	CurMenu.Closed(None,bCanceled);

    CurMenu.ParentPage=None;

	if (!CurMenu.bPersistent)		// keep access to the controller if we are not up
		CurMenu.Free();				// Free up this menu

	MoveControl = None;
	SkipControl = None;

	// Gab the next page on the stack
	bCurMenuInitialized=false;
	if (MenuStack.Length>0)	// Pass control back to the previous menu
	{
		ActivePage = MenuStack[MenuStack.Length-1];
		ActivePage.MenuState = MSAT_Focused;
		ActivePage.CheckResolution(true);

		ActivePage.Opened(none);
		ActivePage.OnActivate();

		ActiveControl = none;

		ActivePage.ResetFocus();
	}
	else
	{

		if (!CurMenu.bAllowedAsLast && ViewportOwner.Actor.Level.IsMenuMap())
		{
			OpenMenu(GetMainMenuClass());
			return true;
		}

		ActivePage = None;
 		SetControllerStatus(false);
	}

	bCurMenuInitialized=true;

	bForceMouseCheck = true;

	return true;
}

function GUIPage TopPage()
{
	return ActivePage;
}

function bool MenuIsOpen(string MenuClassName)
{
	local class<GUIPage> NewMenuClass;
	local int i;

	NewMenuClass = class<GUIPage>(DynamicLoadObject(MenuClassName,class'class'));
	if (NewMenuClass != None)
	{
		for (i=0;i<MenuStack.Length;i++)
		{
			if (MenuStack[i].Class == NewMenuClass)
			{
				return true;
			}
		}
	}

	return false;
}

function SetControllerStatus(bool On)
{
	Log("GUIController::SetControllerStatus " $String(bActive) @String(On), 'guilog');
	if (bActive != On)
	{
		if (On)
		{
			// hide the HUD
			bHidHUD = !ViewportOwner.Actor.MyHUD.bHideHUD;
			ViewportOwner.Actor.MyHUD.bHideHUD = true;

			// hide the weapon
//			iRestoreHandedness = ViewportOwner.Actor.Handedness;
//			ViewportOwner.Actor.SetHand(2);

			// automagically start the music if we're in the menu map
			if (ViewportOwner.Actor.Level.IsMenuMap())
				WantMusicNow();
//				StartMusic();

			if (bIsConsole)
			{
				ConsoleCommand("FULLSCREENVIEWPORT 0");	
			}
		}
		else
		{
			// if we hid the hud, show it again
			if (bHidHUD)
			{
				ViewportOwner.Actor.MyHUD.bHideHUD = false;
				bHidHUD = false;
			}

			// show the weapon
//			ViewportOwner.Actor.SetHand(iRestoreHandedness);

			StopMusic();
			GUITexturePool.Flush();

			if (bIsConsole)
			{
				ConsoleCommand("FULLSCREENVIEWPORT -1");
			}
		}
	}

	bActive = On;
	bVisible = On;
	bRequiresTick=On;

	// Attempt to Pause as well as show the windows mouse cursor.

//	ViewportOwner.Actor.Level.Game.SetPause(On, ViewportOwner.Actor);
	ViewportOwner.bShowWindowsMouse=On;

	// Add code to pause/unpause/hide/etc the game here.

	if (On)
		bIgnoreUntilPress = true;
	else
		ViewportOwner.Actor.ConsoleCommand("toggleime 0");
}

function WantMusicNow()
{
	if (fWantMusicTime == 0.0)
		fWantMusicTime = ViewportOwner.Actor.Level.UniversalTimeSeconds + 1.0;
}

event CloseAll(bool bCancel, optional bool bLeaveTopMost)
{
	local int i;

	log("GUIController::CloseAll(" $bCancel $", " $bLeaveTopMost $")", 'guilog');
	if (!bLeaveTopMost)
	{
		// Close the current menu manually before we clean up the stack.
		if( MenuStack.Length >= 0 )
		{
			if ( !CloseMenu(bCancel) )
				return;
		}

		for (i=0;i<MenuStack.Length;i++)
		{
			// notify them that they're being closed...
			MenuStack[i].Closed(None,bCancel);

			MenuStack[i].CheckResolution(true);
			MenuStack[i].ParentPage = None;

    		if (!MenuStack[i].bPersistent)
        		MenuStack[i].Free();

			MenuStack[i] = None;
		}

		MenuStack.Remove(0,MenuStack.Length);
	}
	else
	{
		CloseAllNonTopMost();
	}

	if (MenuStack.Length == 0)
	{
		if (GameResolution!="")
		{
			ViewportOwner.Actor.ConsoleCommand("SETRES"@GameResolution);
			GameResolution="";
		}

		ActivePage=None;
		SetControllerStatus(false);
	}
}

event InitializeController()
{
	local int i, c1, c2;
	local class<GUIStyles> NewStyleClass;

	for (i=0;i<StyleNames.Length;i++)
	{
		NewStyleClass = class<GUIStyles>(DynamicLoadObject(StyleNames[i],class'class'));

		if (NewStyleClass != None)
			if (!RegisterStyle(NewStyleClass))
				log("Could not create requested style"@StyleNames[i]);

	}

	GetUsedControllersFromCmdLine(c1, c2);

	LiveFunc = new(None) LiveFuncClass;
	LiveFunc.Controller = self;

	GUITexturePool = new(None)class'Engine.TexturePool';
	GUITexturePool.Init(None, 1024*1024*2);

	CacheSounds();
}

function bool RegisterStyle(class<GUIStyles> StyleClass)
{
local GUIStyles NewStyle;

	if (StyleClass != None && !StyleClass.default.bRegistered)
	{
		NewStyle = new(None) StyleClass;

		// Check for errors

		if (NewStyle != None)
		{
			// Dynamic Array Auto Sizes StyleStack.
			StyleStack[StyleStack.Length] = NewStyle;
			NewStyle.Controller = self;
			NewStyle.Initialize();
			return true;
		}
	}
	return false;
}

event ChangeFocus(GUIComponent Who)
{
	return;
}

function ResetFocus()
{
	local int i;

	if (ActiveControl!=None)
	{
		ActiveControl.MenuStateChange(MSAT_Blurry);
		ActiveControl=None;
	}

    for (i=0;i<4;i++)
    {
		RepeatKey[i]=0;
		RepeatTime[i]=0;
    }
}

event MoveFocused(GUIComponent MoveCtrl, int bmLeft, int bmTop, int bmWidth, int bmHeight, float ClipX, float ClipY)
{
	local float val;


	if (AltPressed)
		val = 5;
	else
		val = 1;

	if (bmLeft!=0)
	{
		if (MoveCtrl.WinLeft<1)
			MoveCtrl.WinLeft = MoveCtrl.WinLeft + ( (Val/ClipX) * bmLeft);
		else
			MoveCtrl.WinLeft += (Val*bmLeft);
	}

	if (bmTop!=0)
	{
		if (MoveCtrl.WinTop<1)
			MoveCtrl.WinTop = MoveCtrl.WinTop + ( (Val/ClipY) * bmTop);
		else
			MoveCtrl.WinTop+= (Val*bmTop);
	}

	if (bmWidth!=0)
	{
		if (MoveCtrl.WinWidth<1)
			MoveCtrl.WinWidth = MoveCtrl.WinWidth + ( (Val/ClipX) * bmWidth);
		else
			MoveCtrl.WinWidth += (Val*bmWidth);
	}

	if (bmHeight!=0)
	{
		if (MoveCtrl.WinHeight<1)
			MoveCtrl.WinHeight = MoveCtrl.WinHeight + ( (Val/ClipX) * bmHeight);
		else
			MoveCtrl.WinHeight += (Val*bmHeight);
	}
}

function bool HasMouseMoved()
{
	if (MouseX==LastMouseX && MouseY==LastMouseY)
		return false;
	else
		return true;
}

event bool NeedsMenuResolution()
{

	if ( (ActivePage!=None) && (ActivePage.bRequire640x480) )
		return true;
	else
		return false;
}

event SetRequiredGameResolution(string GameRes)
{
	GameResolution = GameRes;
}

event NotifyLevelChange()
{
	local int i;

    for (i=0;i<MenuStack.Length;i++)
    	MenuStack[i].NotifyLevelChange();
}

function bool WantsMergedInput()
{
	return bActive && ViewportOwner.Actor.Level.IsMenuMap();
}

function CanvasIconSize(out Canvas.CanvasIcon icon, out float XL, out float YL, float ScaleX, float ScaleY)
{
	class'Engine.Canvas'.Static.CanvasIconSize(icon, XL, YL, ScaleX*CanvasAspectScale, ScaleY*CanvasScaleY);
}

function gbx_ScreenTextEntry LaunchTextEntry(string prompt, optional string defaultText, optional string verify, optional int MaxLen)
{
	local gbx_ScreenTextEntry dlg;

	OpenMenu(MenuTextEntry, "\"" $defaultText $"\"" @ String(MaxLen), verify);
	dlg = gbx_ScreenTextEntry(ActivePage);
	dlg.SetCaption(prompt);

	return dlg;
}

event int GetControllerIndexForPlayer(int inPlayerIndex)
{
	if ((inPlayerIndex < 0) || (inPlayerIndex > 1))
	{
		return -1;
	}

	return CurrentControllers[inPlayerIndex];
}

function int FindPlayerForControllerIndex(int inControllerID)
{
	if (CurrentControllers[0] == inControllerID)
		return 0;
	if (CurrentControllers[1] == inControllerID)
		return 1;

	return -1;
}

function BindPlayerToController(int inPlayerIndex, int inControllerID)
{
	if ((inPlayerIndex < 0) || (inPlayerIndex > 1))
	{
		log("WARNING: invalid player index to BindPlayerToController", 'guilog');
		return;
	}

	log("BINDING player=" $inPlayerIndex $ " to controller=" $inControllerID, 'guilog');
	CurrentControllers[inPlayerIndex] = inControllerID;
}

native function LoadPlayerControllerBindings(optional bool bLoadInMainMenu);
native function ApplyControllersToViewports();
native function PlayerController GetPlayerControllerForPlayer(int inPlayerIndex);
native function GetUsedControllersFromCmdLine(out int c1, out int c2);
native function GetUsedProfilesFromCmdLine(out string prof1, out string prof2);	// controllers must be port-locked before calling

simulated function PreloadMenu(string Menu)
{
	local class<GUIPage> MenuClass;

	if (Menu != "")
	{
		MenuClass = class<GUIPage>(DynamicLoadObject(Menu,class'class'));
		if (MenuClass != None)
			MenuClass.static.PreloadMenu(self);
	}
	else
	{
		PreloadMenu(default.MenuTextEntry);
		PreloadMenu("GUI.gbx_DlgCorruptContent");
		PreloadMenu("GUI.gbx_DlgMissingMap");
		PreloadMenu("GUI.gbx_DlgLowStorage");
		PreloadMenu("GUI.gbx_DlgFileLimit");

		PreloadMenu("GUI.gbx_MenuDebug");
		PreloadMenu("GUI.gbx_ScreenExtendedWork");
		PreloadMenu("GUI.gbx_ScreenQuestion");

		if (bIsConsole)
		{
			PreloadMenu("GUI.gbx_LiveDlgUserHasMessage");
			PreloadMenu("GUI.gbx_LiveErrorMessage");
			PreloadMenu("GUI.gbx_LiveDlgAcceptCrossTitle");
			PreloadMenu("GUI.gbx_LiveDlgJoinServerFull");
			PreloadMenu("GUI.gbx_DlgLinkLost");
			PreloadMenu("GUI.gbx_DlgControllerLost");
			PreloadMenu("GUI.gbx_DlgConnectError");
			PreloadMenu("GUI.gbx_LiveDlgJoinConnecting");
		}
	}
}

function DebouncePlayerControllers()
{
	local PlayerController PC;
	
	PC = GetPlayerControllerForPlayer(0);
	if (PC != None)
		PC.DebounceFireKeys();

	PC = GetPlayerControllerForPlayer(1);
	if (PC != None)
		PC.DebounceFireKeys();
}

native function int GetGamers(array<Gamer> GamerList, int User, bool bGetPlayers);
native function SortGamers(array<Gamer> GamerList);

function MarkForDestruction(GUIComponent comp)
{
	DestroyComps.Length = DestroyComps.Length + 1;
	DestroyComps[DestroyComps.Length-1] = comp;

	if (FocusedControl == comp) FocusedControl = None;
	if (ActiveControl == comp) ActiveControl = None;
	if (SkipControl == comp) SkipControl = None;
	if (MoveControl == comp) MoveControl = None;
}

function ChatMessageReceived(PlayerReplicationInfo ChattingPRI, string Message)
{
	local int i;

	for (i=0;i<MenuStack.Length;i++)
	{
		MenuStack[i].OnChat(ChattingPRI, Message);
	}
}

defaultproperties
{
	Begin Object Class=fntMenuFont Name=GUIMenuFont
		bFixedSize=false
	End Object
	FontStack(0)=GUIMenuFont

	Begin Object Class=fntDefaultFont Name=GUIDefaultFont
		bFixedSize=true
	End Object
	FontStack(1)=GUIDefaultFont

	Begin Object Class=fntLargeFont Name=GUILargeFont
		bFixedSize=false
	End Object
	FontStack(2)=GUILargeFont

	Begin Object Class=fntHeaderFont Name=GUIHeaderFont
		bFixedSize=false
	End Object
	FontStack(3)=GUIHeaderFont

	Begin Object Class=fntSmallFont Name=GUISmallFont
		bFixedSize=false
	End Object
	FontStack(4)=GUISmallFont

	Begin Object Class=fntSmallHeaderFont Name=GUISmallHeaderFont
		bFixedSize=false
	End Object
	FontStack(5)=GUISmallHeaderFont

	Begin Object Class=gbx_fntMainButton Name=GUIGBXFontMainButton
	End Object
	FontStack(6)=GUIGBXFontMainButton

	Begin Object Class=gbx_fntHelpButton Name=GUIGBXFontHelpButton
	End Object
	FontStack(7)=GUIGBXFontHelpButton

	Begin Object Class=gbx_fntCaption Name=GUIGBXFontCaption
	End Object
	FontStack(8)=GUIGBXFontCaption

	StyleNames(0)="GUI.STY_RoundButton"
	StyleNames(1)="GUI.STY_RoundScaledButton"
	StyleNames(2)="GUI.STY_SquareButton"
	StyleNames(3)="GUI.STY_ListBox"
	StyleNames(4)="GUI.STY_ScrollZone"
	StyleNames(5)="GUI.STY_TextButton"
	StyleNames(6)="GUI.STY_Header"
	StyleNames(7)="GUI.STY_Footer"
	StyleNames(8)="GUI.STY_TabButton"
	StyleNames(9)="GUI.STY_NoBackground"
	StyleNames(10)="GUI.STY_SliderCaption"
	StyleNames(11)="GUI.STY_SquareBar"
	StyleNames(12)="GUI.STY_TextLabel"
	StyleNames(13)="GUI.STY_ComboListBox"
	StyleNames(14)="GUI.STY_DefButton"
	StyleNames(15)="GUI.STY_MainButton"
	StyleNames(16)="GUI.STY_HelpButton"
	StyleNames(17)="GUI.STY_MenuOptionLabel"
	StyleNames(18)="GUI.STY_MenuOptionCaption"
	StyleNames(19)="GUI.STY_LargeButton"

	// See Player.uc IDC_ definitions
	MouseCursors(0)=Texture't_interface_mb.hud.cursor'
	MouseCursors(1)=Texture't_interface_mb.hud.cursor'
	MouseCursors(2)=Texture't_interface_mb.hud.cursor'
	MouseCursors(3)=Texture't_interface_mb.hud.cursor'
	MouseCursors(4)=Texture't_interface_mb.hud.cursor'
	MouseCursors(5)=Texture't_interface_mb.hud.cursor'
	MouseCursors(6)=Texture't_interface_mb.hud.cursor'

	MouseCursorOffset(0)=(X=0,Y=0,Z=0)
	MouseCursorOffset(1)=(X=0,Y=0,Z=0)
	MouseCursorOffset(2)=(X=0,Y=0,Z=0)
	MouseCursorOffset(3)=(X=0,Y=0,Z=0)
	MouseCursorOffset(4)=(X=0,Y=0,Z=0)
	MouseCursorOffset(5)=(X=0,Y=0,Z=0)
	MouseCursorOffset(6)=(X=0,Y=0,Z=0)

	ButtonRepeatDelay=0.15
	CursorStep=1
	CursorFadeRate=384
	FastCursorStep=1
	FastCursorFadeRate=8192
	// Design Mode stuff
	WhiteBorder=Texture't_interface_mb.gui.small_white_border'

 	DblClickWindow=0.5

	MenuMouseSens=1.0
	MenuMouseAccel=8
	bHighlightCurrent=true

    ControllerMask=255
	bEmulatedJoypad=false
	bJoyMouse=false
    bHideMouseCursor=false
    JoyDeadZone=0.3
	bGotEscapeDown=false

	LiveFuncClass=class'GUI.gbx_LiveFunc'

	CurrentProfiles(0)=""
	CurrentProfiles(1)=""
	CurrentControllers(0)=-1
	CurrentControllers(1)=-1

	ScreenSafeBorderX=0.035
	ScreenSafeBorderY=0.075
	fWideScreenCompensateScale=1.0

	RedLineColor=(R=160,G=23,B=23,A=255)
	BackgroundBoxColor=(R=13,G=5,B=8,A=220)

	MenuTextEntry="GUI.gbx_ScreenTextEntryXbox"
	iMusicHandle=-1

	LastXControllerId=-1
	ControllerIdInUse=(0,0,0,0)
}// ====================================================================
//  Class:  GUI.GUIEditBox
//
//	GUIEditBox - The basic text edit control.  I've merged Normal
//  edit, restricted edit, numeric edit and password edit in to 1 control.
//
//  Written by Joe Wilcox
//  (c) 2002, Epic Games, Inc.  All Rights Reserved
// ====================================================================

class GUIEditBox extends GUIButton
		Native;

// GBX:CEK: 3/16/2004 - TEMP GUI REINTEGRATION
//#exec OBJ LOAD FILE=GUIContent.utx

cpptext
{
		void Draw(UCanvas* Canvas);
}

var(Menu)		string		TextStr;			// Holds the current string
var(Menu)		string		AllowedCharSet;		// Only Allow these characters
var(Menu)		bool		bMaskText;			// Displays the text as a *
var(Menu)		bool		bIntOnly;			// Only Allow Interger Numeric entry
var(Menu)		bool		bFloatOnly;			// Only Allow Float Numeric entry
var(Menu)		bool		bIncludeSign;		// Do we need to allow a -/+ sign
var(Menu)		bool		bConvertSpaces;		// Do we want to convert Spaces to "_"
var(Menu)		int			MaxWidth;			// Holds the maximum width (in chars) of the string - 0 = No Max
var(Menu)		eTextCase	TextCase;			// Controls forcing case, etc
var(Menu)		int			BorderOffsets[4];	// How far in from the edit is the edit area
var(Menu)		bool		bReadOnly;			// Can't actually edit this box
var(Menu)		bool		bAlwaysShowCursor;	// shows cursor even when not focused
var(Menu)		bool		bSilent;			// don't play a click sound when the contents are changed

var int 	CaretPos;		// Where is the cursor within the string
var	int		FirstVis;		// Position of the first visible character;
var int 	LastSizeX;		// Used to detect resolution changes
var int		LastCaret,LastLength;	// Used to make things quick

var bool	bAllSelected;
var byte	LastKey;
var float	DelayTime;

delegate bool VerifyInput(string currentString, string newChar) {return true;}

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	OnKeyType = InternalOnKeyType;
	OnKeyEvent = InternalOnKeyEvent;

	if ( (bIntOnly) || (bFloatOnly) )
	{
		AllowedCharSet = "0123456789";
		if (bFloatOnly)
			AllowedCharSet=AllowedCharSet$".";

	}

	bAllSelected=true;
}

function DoChanged()
{
	if (!bSilent)
		Controller.PlayClickSound(EClickSound.CS_Change);

	OnChange(self);
}

event SetText(string NewText)
{
	TextStr = NewText;
	CaretPos=len(TextStr);
	OnChange(self);

	bAllSelected=true;
}

function DeleteChar()
{
	if (CaretPos==len(TextStr))
		return;
	else if (CaretPos==Len(TextStr)-1)
	{
		TextStr = left(TextStr,CaretPos);
		CaretPos=len(TextStr);
	}
	else
		TextStr = left(TextStr,CaretPos)$Mid(TextStr,CaretPos+1);

	DoChanged();

}

function bool InternalOnKeyType(out byte Key, optional string Unicode)
{
	local string temp,st;

	if (bReadOnly)
		return false;

	if (UniCode!="")
		st = Unicode;
	else
		st = chr(Key);

	// Handle cut/paste/copy keys
	if (key<32)
    {
		if (!Controller.CtrlPressed)
			return true;  // old code captured any keys under 32

		switch (key)
		{
		case 3:   // ctrl-c, copy to console
			PlayerOwner().CopyToClipboard(TextStr);
			bAllSelected=true;
			break;
		case 22: // ctrl-v, paste at position
			if ( (TextStr=="") || ( CaretPos==len(TextStr) ) )	// At the end of the string, just add
			{
				if (bAllSelected)
					TextStr="";
				TextStr = ConvertIllegal(TextStr$PlayerOwner().PasteFromClipboard());
				CaretPos=len(TextStr);
			}
			else
			{
				// We are somewhere inside the string, insert.
				temp    = ConvertIllegal(left(TextStr,CaretPos)$PlayerOwner().PasteFromClipboard()$Mid(TextStr,CaretPos));
				TextStr = temp;
			}
			break;
		case 24:  // ctrl-x, clear and copy
			PlayerOwner().CopyToClipboard(TextStr);
			TextStr="";
			CaretPos=0;
		}
		OnChange(self);
		return true;
	}

	AddChar(st);

	return false;
}

function bool AddChar(string st)
{
	local string temp;
	local bool bResult;

	if(bAllSelected)
	{
		TextStr="";
		CaretPos=0;
		bAllSelected=false;
		OnChange(self);
	}

	if ( VerifyInput(TextStr, st) && 
		 ( (AllowedCharSet=="") || ( (bIncludeSign) && ( (st=="-") || (st=="+") ) && (TextStr=="") ) || (InStr(AllowedCharSet,St)>=0) ))
	{
		if ( (MaxWidth==0) || (Len(TextStr)<MaxWidth) )
		{
			if ( (bConvertSpaces) && ((st==" ") || (st=="?") || (st=="\\")) )
				st = "_";

			if ( (TextStr=="") || ( CaretPos==len(TextStr) ) )	// At the end of the string, just add
			{
				TextStr = TextStr$st;
				CaretPos=len(TextStr);
			}
			else
			{
				// We are somewhere inside the string, insert it.

				temp    = left(TextStr,CaretPos)$st$Mid(TextStr,CaretPos);
				TextStr = temp;
				CaretPos++;
			}

			DoChanged();
			bResult = true;
		}
	}

	return bResult;
}

function DoBackspace()
{
	if(bAllSelected)
	{
		TextStr="";
		CaretPos = 0;
		bAllSelected=false;
		DoChanged();
	}
	else if (CaretPos>0)
	{
		CaretPos--;
		DeleteChar();
	}
}

function DoDelete()
{
	if(bAllSelected)
	{
		TextStr="";
		CaretPos = 0;
		bAllSelected=false;
		DoChanged();
	}
	else
		DeleteChar();
}

function DoCursorLeft()
{
	if(bAllSelected)
	{
		CaretPos = 0;
		bAllSelected=false;
	}
	else if (CaretPos>0)
		CaretPos--;
}

function DoCursorRight()
{
	if(bAllSelected)
	{
		CaretPos = len(TextStr);
		bAllSelected=false;
	}
	else if ( CaretPos<Len(TextStr) )
		CaretPos++;
}

function DoCursorHome()
{
	CaretPos=0;
	bAllSelected=false;
}

function DoCursorEnd()
{
	CaretPos=len(TextStr);
	bAllSelected=false;
}

function bool InternalOnKeyEvent(out byte Key, out byte State, float delta)
{
	if (bReadOnly)
		return false;

	if( (Key==8) && (State==1) ) // Process Backspace
	{
		DoBackspace();
		return true;
	}

	if ( (Key==0x2E) && (State==1) ) // Delete key
	{
		DoDelete();
		return true;
	}

	//if ( (Key==0x64 || Key==0x25) && (State==1) )	// Left Arrow
	if ( (Key==0x25) && (State==1) )	// Left Arrow
	{
		DoCursorLeft();
		return true;
	}

	//if ( (Key==0x66 || Key==0x27) && (State==1) ) // Right Arrow
	if ( (Key==0x27) && (State==1) ) // Right Arrow
	{
		DoCursorRight();
		return true;
	}

	//if ( (Key==0x24 || Key==0x67) && (State==1) ) // Home
	if ( (Key==0x24) && (State==1) ) // Home
	{
		DoCursorHome();
		return true;
	}

	//if ( (Key==0x23 || Key==0x61) && (State==1) ) // End
	if ( (Key==0x23) && (State==1) ) // End
	{
		DoCursorEnd();
		return true;
	}

	return false;
}

// converts space-characters and chars not in the allowed char array
// ensure string stays within max bounds
function string ConvertIllegal(string inputstr)
{
	local int i, max;
	local string retval;
	local string c;

	i = 0;
	max = Len(inputstr);
	while ( i < max )
	{
		c = Mid(inputstr,i,1);
		if ( AllowedCharSet != "" && InStr(AllowedCharSet,c) < 0 )
		{
			c = "";
		}
		if ( bConvertSpaces &&
			((c == " ") || (c =="?") || (c=="\\") ))
		{
			c = "_";
		}
		retval = retval $ c;
		i++;
	}

	if (MaxWidth > 0)
		return Left(retval,MaxWidth);
	else
		return retval;
}

function string LoadINI()
{
	local string s;

	s = Super.LoadINI();

	if (S!="")
		SetText(s);

	return s;
}

function SaveINI(string Value)
{
	Super.SaveINI(TextStr);
}

function string GetText()
{
	return TextStr;
}


defaultproperties
{
	StyleName="SquareButton"
	MaxWidth=0
	TextCase=TXTC_None
	LastCaret=-1
	LastLength=-1
	WinHeight=0.06
	bCaptureMouse=False
	OnClickSound=CS_Edit
	BorderOffsets(0)=8
	BorderOffsets(2)=8
	bSilent=false
}// ====================================================================
// (C) 2002, Epic Games
// ====================================================================

class GUIFloatEdit extends GUIMultiComponent
	Native;


cpptext
{
		void Draw(UCanvas* Canvas);
}

var Automated GUIEditBox MyEditBox;
var Automated GUISpinnerButton MyPlus;
var Automated GUISpinnerButton MyMinus;

var(Menu)	string				Value;
var(Menu)	bool				bLeftJustified;
var(Menu)	float				MinValue;
var(Menu)	float				MaxValue;
var(Menu)	float				Step;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{

	Super.Initcomponent(MyController, MyOwner);

	MyEditBox.OnChange = EditOnChange;
	MyEditBox.SetText(Value);
	MyEditBox.OnKeyEvent = EditKeyEvent;

	MyEditBox.INIOption  = INIOption;
	MyEditBox.INIDefault = INIDefault;

	CalcMaxLen();

	MyPlus.OnClick = SpinnerPlusClick;
	MyPlus.FocusInstead = MyEditBox;
	MyMinus.OnClick = SpinnerMinusClick;
	MyMinus.FocusInstead = MyEditBox;

    SetHint(Hint);

}

function SetHint(string NewHint)
{
	local int i;
	Super.SetHint(NewHint);

    for (i=0;i<Controls.Length;i++)
    	Controls[i].SetHint(NewHint);
}

function CalcMaxLen()
{
	local int digitcount,x;

	digitcount=1;
	x=10;
	while (x<MaxValue)
	{
		digitcount++;
		x*=10;
	}

	MyEditBox.MaxWidth = DigitCount+4;
}
function SetValue(float V)
{
	if (v<MinValue)
		v=MinValue;

	if (v>MaxValue)
		v=MaxValue;

	MyEditBox.SetText(""$v);
}

function bool SpinnerPlusClick(GUIComponent Sender)
{
	local float v;

	v = float(Value) + Step;
    SetValue(v);
	return true;
}

function bool SpinnerMinusClick(GUIComponent Sender)
{
	local float v;

	v = float(Value) - Step;
	SetValue(v);
	return true;
}

function bool EditKeyEvent(out byte Key, out byte State, float delta)
{
	if ( (key==0xEC) && (State==3) )
	{
		SpinnerPlusClick(none);
		return true;
	}

	if ( (key==0xED) && (State==3) )
	{
		SpinnerMinusClick(none);
		return true;
	}

	return MyEditBox.InternalOnKeyEvent(Key,State,Delta);


}

function EditOnChange(GUIComponent Sender)
{
	Value = MyEditBox.TextStr;
    OnChange(Sender);
}

defaultproperties
{
	Begin Object Class=GUIEditBox Name=cMyEditBox
		TextStr=""
		bFloatOnly=true
	End Object

	Begin Object Class=GUISpinnerButton Name=cMyPlus
		PlusButton=true
	End Object

	Begin Object Class=GUISpinnerButton Name=cMyMinus
		PlusButton=false
	End Object

	MyEditBox=cMyEditBox
	MyPlus=cMyPlus
	MyMinus=cMyMinus

	Value="0.0"
	Step=1.0
	bAcceptsInput=true;
	bLeftJustified=false;
	WinHeight=0.06

	PropagateVisibility=true

}// ====================================================================
//  Class:  GUI.GUIFont
// 
//  GUIFont is used to give a single pipeline for handling fonts at
//	multiple resolutions while at the same time supporting resolution
//	independant fonts (for browsers, etc). 
//
//  Written by Joe Wilcox
//  (c) 2002, Epic Games, Inc.  All Rights Reserved
// ====================================================================

class GUIFont extends GUI
	Native;

var(Menu) string		KeyName;
var(Menu) bool			bFixedSize;		// If true, only FontArray[0] is used
var(Menu) localized array<String>	FontArrayNames;	// Holds all of the names of the fonts 		
var(Menu) array<Font>	FontArrayFonts;	// Holds all of the fonts
var(Menu) float			ScaleX, ScaleY;

var(Menu) localized String			FontBlurName;	// A font that may be used as a glow/shadow for this font
var(Menu) Font						FontBlur;

var(Menu) float						ShadowOfsX, ShadowOfsY;	// offset to use if drawing the blur as a shadow


native event Font GetFont(int XRes);			// Returns the font for the current resolution
native event Font GetBlurFont(int XRes);		// Returns the blur font for the current resolution

// Dynamically load font.
static function Font LoadFontStatic(int i)
{
	if( i>=default.FontArrayFonts.Length || default.FontArrayFonts[i] == None )
	{
		default.FontArrayFonts[i] = Font(DynamicLoadObject(default.FontArrayNames[i], class'Font'));
		if( default.FontArrayFonts[i] == None )
			Log("Warning: "$default.Class$" Couldn't dynamically load font "$default.FontArrayNames[i]);
	}

	return default.FontArrayFonts[i];
}

function Font LoadFont(int i)
{
	if( i>=FontArrayFonts.Length || FontArrayFonts[i] == None )
	{
		FontArrayFonts[i] = Font(DynamicLoadObject(FontArrayNames[i], class'Font'));
		if( FontArrayFonts[i] == None )
			Log("Warning: "$Self$" Couldn't dynamically load font "$FontArrayNames[i]);
	}
	return FontArrayFonts[i];
}

defaultproperties
{
	ScaleX=1.0
	ScaleY=1.0

	FontBlurName=""
	ShadowOfsX=0.0
	ShadowOfsY=0.0
}
// ====================================================================
//  Class:  GUI.GUIButton
//
//	GUIGFXButton - The basic button class.  It can be used for icon buttons
//  or Checkboxes
//
//  Written by Joe Wilcox
//  (c) 2002, Epic Games, Inc.  All Rights Reserved
// ====================================================================

class GUIGFXButton extends GUIButton
	Native;

// GBX:CEK: 3/16/2004 - TEMP GUI REINTEGRATION
//#exec OBJ LOAD FILE=GUIContent.utx

cpptext
{
		void Draw(UCanvas* Canvas);
}

var(Menu)	Material 		Graphic;		// The graphic to display
var(Menu)	int				U,V,UL,VL;		// texture coords
var(Menu)	eIconPosition	Position;		// How do we draw the Icon
var(Menu)	Color			StateColors[5];
var(Menu)	bool			bCheckBox;		// Is this a check box button (ie: supports 2 states)
var(Menu)	bool			bClientBound;	// Graphic is drawn using clientbounds if true

var(Menu)	bool			bChecked;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.Initcomponent(MyController, MyOwner);

	if (bCheckBox)
		OnCLick = InternalOnClick;
}

function SetChecked(bool bNewChecked)
{
	if (bCheckBox)
	{
		bChecked = bNewChecked;
		OnChange(Self);
	}
}

function bool InternalOnClick(GUIComponent Sender)
{
	if (bCheckBox)
		bChecked = !bChecked;

	OnChange(Self);
	return true;
}

defaultproperties
{
	Position=ICP_Normal
	bCheckBox=false
	bRepeatClick=true
	bChecked=false
    bTabStop=false
	U=0
	V=0
	UL=0
	VL=0
	StateColors(0)=(R=111,G=111,B=83,A=255)
	StateColors(1)=(R=221,G=221,B=193,A=255)
	StateColors(2)=(R=221,G=221,B=193,A=255)
	StateColors(3)=(R=241,G=241,B=213,A=255)
	StateColors(4)=(R=70,G=70,B=53,A=255)
}class GUIHelpAButton extends GUIHelpButton;


defaultproperties
{
	U=128
	V=216
	UL=39
	VL=39
}class GUIHelpBButton extends GUIHelpButton;


defaultproperties
{
	U=167
	V=216
	UL=39
	VL=39
}class GUIHelpBlButton extends GUIHelpLRWBButton;


defaultproperties
{
	U=224
	V=40
	UL=32
	VL=32
	IconSize=0.50
}// ====================================================================
//  Class:  GUI.GUIHelpButton
//
//	GUIHelpButton - Special icon button that provides help only on xbox
//	but is a clickable button on PC.
// ====================================================================

class GUIHelpButton extends GUIIconButton;

var(Menu)	string			PCStyleName;
var(Menu)	string			ConsoleStyleName;
var(Menu)	bool			bAppendColonToCaption;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	if (!MyController.bIsConsole)
	{
		StyleName = PCStyleName;
		Align = TXTA_Center;
		Layout = IBL_ICON_LEFT;
		Icon = None;
		bNeverFocus = false;
		bTabStop = true;
		bAppendColonToCaption = false;
		bFocusOnWatch = true;
		bTransparent = true;
	}
	else
	{
		StyleName = ConsoleStyleName;
		bNeverFocus = true;
		bTabStop = false;
	}

	Super.Initcomponent(MyController, MyOwner);

	GetTexCoords(self, U, V, UL, VL);
}

function SetCaption(optional string s)
{
	if (bAppendColonToCaption && (s != ""))
	{
		if (Layout == IBL_ICON_LEFT)
			s = ":" @ s;
		else if (Layout == IBL_ICON_RIGHT)
			s = s @ ":";
	}

	Super.SetCaption(s);
}

static function GetTexCoords(GUIComponent me, out int tU, out int tV, out int tUL, out int tVL)
{
	tU = default.U;
	tV = default.V;
	tUL = default.UL;
	tVL = default.VL;
}

defaultproperties
{
	StyleName=""
	PCStyleName="TextLabel"
	ConsoleStyleName="HelpButton"
	Icon=Material't_interface_mb.hud.interface_comp'
	//DS-BEGIN/END: Don't use colons for our buttons. Used to be on, 
	//              but no one ever used LEFT/RIGHT help buttons on a Console before.
	//              This makes things easier to fit on the Leaderboard window
	bAppendColonToCaption=false
	bNoArrowNavigation=true  //reverting; this screws stuff up.  I handle this manually now.
	bForceCaps=true

	WinWidth=0.23125
	WinHeight=0.085000
	WinTop=0.850000
	IconSize=0.65
}class GUIHelpLButton extends GUIHelpLRWBButton;

static function GetTexCoords(GUIComponent me, out int tU, out int tV, out int tUL, out int tVL)
{
	local string S;

	S = me.PlayerOwner().GetLanguage();

	if (S ~= "frt")
	{
		tU = 0;
		tV = 37;
		tUL = 51;
		tVL = 37;
	}
	else if (S ~= "itt")
	{
		tU = 0;
		tV = 74;
		tUL = 51;
		tVL = 37;
	}
	else if (S ~= "est")
	{
		tU = 0;
		tV = 185;
		tUL = 51;
		tVL = 37;
	}
	else
	{
		Super.GetTexCoords(me, tU, tV, tUL, tVL);
	}
}

defaultproperties
{
	U=0
	V=0
	UL=51
	VL=37
}class GUIHelpLRWBButton extends GUIHelpButton;

defaultproperties
{
	Layout=IBL_ICON_LEFT
	Icon=Material't_interface_mb.hud.xbox_button_art'
	WinWidth=0.23125
	WinHeight=0.08000
	IconSize=0.60
}
class GUIHelpRButton extends GUIHelpLRWBButton;

static function GetTexCoords(GUIComponent me, out int tU, out int tV, out int tUL, out int tVL)
{
	local string S;

	S = me.PlayerOwner().GetLanguage();

	if (S ~= "frt")
	{
		tU = 51;
		tV = 37;
		tUL = 51;
		tVL = 37;
	}
	else if (S ~= "itt")
	{
		tU = 51;
		tV = 74;
		tUL = 51;
		tVL = 37;
	}
	else if (S ~= "est")
	{
		tU = 51;
		tV = 37;
		tUL = 51;
		tVL = 37;
	}
	else
	{
		Super.GetTexCoords(me, tU, tV, tUL, tVL);
	}
}

defaultproperties
{
	U=51
	V=0
	UL=51
	VL=37
}class GUIHelpWhButton extends GUIHelpLRWBButton;


defaultproperties
{
	U=192
	V=40
	UL=32
	VL=32
	IconSize=0.50
}class GUIHelpXButton extends GUIHelpButton;


defaultproperties
{
	U=128
	V=177
	UL=39
	VL=39
}class GUIHelpYButton extends GUIHelpButton;


defaultproperties
{
	U=167
	V=177
	UL=39
	VL=39
}// ====================================================================
//  Class:  GUI.GUIHorzGripButton
//  Parent: GUI.GUIGFXButton
//
//  <Enter a description here>
// ====================================================================

class GUIHorzGripButton extends GUIGFXButton
		Native;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.Initcomponent(MyController, MyOwner);
// GBX:CEK: 3/16/2004 - TEMP GUI REINTEGRATION
	Graphic = Texture'WhiteTexture';
//	Graphic = Material'GUIContent.Menu.ButGrip';
}


defaultproperties
{
	StyleName="RoundButton"
	Position=ICP_Bound
	bNeverFocus=true
	bCaptureMouse=true	
}

defaultproperties
{

}
// ====================================================================
//  Class:  GUI.GUIHorzList
//  Parent: GUI.GUIListBase
//
//  <Enter a description here>
// ====================================================================

class GUIHorzList extends GUIListBase
		Native;

cpptext
{
	void Draw(UCanvas* Canvas);	
}
		
function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.Initcomponent(MyController, MyOwner);

	OnKeyType=InternalOnKeyType;
	OnKeyEvent=InternalOnKeyEvent;
	OnXControllerEvent=InternalOnXControllerEvent;
	OnClick=InternalOnClick;
}	
		
function bool InternalOnClick(GUIComponent Sender)
{
	local int NewIndex, Col;

	if ( ( !IsInClientBounds() ) || (ItemsPerPage==0) )
		return false;
		
	// Get the Col
	
	Col = Controller.MouseX - ClientBounds[0];
	NewIndex = Top + (Col / ItemWidth);
	
	if (NewIndex >= ItemCount)
		return false;
		
	SetIndex(NewIndex);
	return true;
}

function bool InternalOnKeyType(out byte Key, optional string Unicode)
{
	// Add code to jump to next line with Char	
		
	return true;
}

function bool InternalOnKeyEvent(out byte Key, out byte State, float delta)
{

	if (ItemsPerPage==0) return false;

	
	if ( (Key==0x25 || Key==0x64) && (State==1) )	// Left Arrow
	{
		ScrollLeft();
		return true;
	}
	
	if ( (Key==0x27 || Key==0x66) && (State==1) ) // Left Arrow
	{
		ScrollRight();
		return true;
	}
	
	if ( (Key==0x24 || Key==0x67) && (State==1) ) // Home
	{
		Home();
		return true;
	}
	
	if ( (Key==0x23 || Key==0x61) && (State==1) ) // End
	{
		End();
		return true;
	}
	
	if ( (Key==0x21 || Key==0x69) && (State==1) ) // PgUp
	{
		PgUp();
		return true;
	}
	
	if ( (Key==0x22 || Key==0x63) && (State==1) ) // PgDn
	{
		PgDn();
		return true;
	}
	
	if ( (key==0xEC) && (State==3) )
	{
	
		WheelUp();
		return true;
	}
	
	if ( (key==0xED) && (State==3) )
	{
	
		WheelDown();
		return true;
	}
	
	
	return false;
}


function WheelUp()
{
	if (MyScrollBar!=None)
		GUIHorzScrollBar(MyScrollBar).WheelUp();
	else
	{
		if (!Controller.CtrlPressed)
			ScrollLeft();
		else
			PgUp();
	}
}

function bool InternalOnXControllerEvent(byte Id, eXControllerCodes iCode)
{

	if (ItemsPerPage==0) return false;

	if (iCode==XC_Left || iCode==XC_PadLeft)
    {
    	ScrollLeft();
        return true;
    }
    else if (iCode==XC_Right || iCode==XC_PadRight)
    {
    	ScrollRight();
        return true;
    }

    else if (iCode==XC_Black)
    {
    	Home();
        return true;
    }

    else if (iCode==XC_White)
    {
    	End();
        return true;
    }

    else if (iCode==XC_X)
    {
    	PgDn();
        return true;
    }

    else if (iCode==XC_Y)
    {
    	PgUp();
        return true;
    }

	else if (iCode==XC_Start)
    {
    	OnClick(self);
        return true;
    }
    return false;
}


function WheelDown()
{
	if (MyScrollBar!=None)
		GUIHorzScrollBar(MyScrollBar).WheelDown();
	else
	{
		if (!Controller.CtrlPressed)
			ScrollRight();
		else
			PgDn();
	}
}
	
function ScrollLeft()
{
	if ( (ItemCount<2) || (Index==0) ) return;

	Index = max(0,Index-1);

	if ( (Index<Top) || (Index>Top+ItemsPerPage) )
	{
		Top = Index;
		MyScrollBar.AlignThumb();
	}
}

function ScrollRight()
{
	if ( (ItemCount<2) || (Index==ItemCount-1) )	return;
	
	Index = min(Index+1,ItemCount-1);
	if (Index<Top)
	{
		Top = Index;
		MyScrollBar.AlignThumb();
	}
	else if (Index>=Top+ItemsPerPage)
	{
		Top = Index-ItemsPerPage+1;
		MyScrollBar.AlignThumb();
	}
	
}
	
function Home()
{
	if (ItemCount<2)	return;	

	SetIndex(0);
	Top = 0;
	MyScrollBar.AlignThumb();
	
}

function End()
{
	if (ItemCount<2)	return;	

	Top = ItemCount - ItemsPerPage;
	if (Top<0)
		Top = 0;
		
	SetIndex(ItemCount-1);
	MyScrollBar.AlignThumb();
}	

function PgUp()
{

	if (ItemCount<2)	return;

	Index -= ItemsPerPage;

	// Adjust to bounds
	if (Index < 0)
		Index = 0;

	// If new index 
	if (Top + ItemsPerPage <= Index)		// If index is forward but not visible, jump to it
		Top = Index;
	else if (Index + ItemsPerPage < Top)	// Item is way too far
		Top = Index;
	else if (Index < Top)	// Item is 1 page or less away
		SetTopItem(Top - ItemsPerPage);

	SetIndex(Index);
	MyScrollBar.AlignThumb();
}

function PgDn()
{

	if (ItemCount<2)	return;

	// Select item 1 page away from current selection
	Index += ItemsPerPage;

	// Adjust to bounds
	if (Index >= ItemCount)
		Index = ItemCount-1;

	
	if (Index < Top)  // If item is still before Top Item, go to it
		Top = Index;
	else if (Index - Top - ItemsPerPage >= ItemsPerPage)	// Too far away
		SetTopItem(Index);
	else if (Index - Top >= ItemsPerPage) // Just 1 page away
		SetTopItem(Top + ItemsPerPage);

	SetIndex(Index);
	MyScrollBar.AlignThumb();
}	

		

defaultproperties
{
}
// ====================================================================
//  Class:  GUI.GUIHorzScrollBar
//  Parent: GUI.GUIMultiComponent
//
//  <Enter a description here>
// ====================================================================

class GUIHorzScrollBar extends GUIScrollBarBase
		Native;

cpptext
{
		void PreDraw(UCanvas* Canvas);
}

var Automated GUIHorzScrollZone MyScrollZone;
var Automated GUIHorzScrollButton MyLeftButton;
var Automated GUIHorzScrollButton MyRightButton;
var Automated GUIHorzGripButton MyGripButton;

var		float			GripLeft;		// Where in the ScrollZone is the grip	- Set Natively
var		float			GripWidth;		// How big is the grip - Set Natively

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	MyScrollZone.OnScrollZoneClick = ZoneClick;
	MyLeftButton.OnClick = LeftTickClick;
	MyRightButton.OnClick = RightTickClick;
	MyGripButton.OnCapturedMouseMove = GripMouseMove;

    Refocus(MyList);

}

function UpdateGripPosition(float NewPos)
{
	MyList.MakeVisible(NewPos);
	GripLeft = NewPos;
}

function bool GripMouseMove(float deltaX, float deltaY)
{
	local float NewPerc,NewLeft;

	if (deltaX==0)	// Don't care about horz movement
		return true;


	deltaX*=-1;

	// Calculate the new Grip Left using the mouse cursor location.

	NewPerc = abs(deltaX) / (MyScrollZone.ActualWidth()-GripWidth);

	if (deltaX<0)
		NewPerc*=-1;

	NewLeft = FClamp(GripLeft+NewPerc,0.0,1.0);

	UpdateGripPosition(NewLeft);

	return true;
}

function ZoneClick(float Delta)
{
	if ( Controller.MouseX < MyGripButton.Bounds[0] )
		MoveGripBy(-MyList.ItemsPerPage);
	else if ( Controller.MouseX > MyGripButton.Bounds[2] )
		MoveGripBy(MyList.ItemsPerPage);

	return;
}

function MoveGripBy(int items)
{
	local int LeftItem;

	LeftItem = MyList.Top + items;
	if (MyList.ItemCount > 0)
	{
		MyList.SetTopItem(LeftItem);
		AlignThumb();
	}
}

function bool LeftTickClick(GUIComponent Sender)
{
	WheelUp();
	return true;
}

function bool RightTickClick(GUIComponent Sender)
{
	WheelDown();
	return true;
}

function WheelUp()
{
	if (!Controller.CtrlPressed)
		MoveGripBy(-1);
	else
		MoveGripBy(-MyList.ItemsPerPage);
}

function WheelDown()
{
	if (!Controller.CtrlPressed)
		MoveGripBy(1);
	else
		MoveGripBy(MyList.ItemsPerPage);
}

function AlignThumb()
{
	local float NewLeft;

	if (MyList.ItemCount==0)
		NewLeft = 0;
	else
	{
		NewLeft = Float(MyList.Top) / Float(MyList.ItemCount-MyList.ItemsPerPage );
		NewLeft = FClamp(NewLeft,0.0,1.0);
	}

	GripLeft = NewLeft;
}


// NOTE:  Add graphics for no-man's land about and below the scrollzone, and the Scroll nub.

defaultproperties
{
	Begin Object Class=GUIHorzScrollZone Name=HScrollZone
	End Object

	Begin Object Class=GUIHorzScrollButton Name=HLeftBut
		LeftButton=true
	End Object

	Begin Object Class=GUIHorzScrollButton Name=HRightBut
		LeftButton=false
	End Object

	Begin Object Class=GUIHorzGripButton Name=HGrip
	End Object

	MyScrollZone=HScrollZone
	MyLeftButton=HLeftBut
	MyRightButton=HRightBut
	MyGripButton=HGrip

	bAcceptsInput=true;
	WinWidth=0.0375
}// ====================================================================
//  Class:  GUI.GUIHorzScrollButton
//  Parent: GUI.GUIGFXButton
//
//  <Enter a description here>
// ====================================================================

class GUIHorzScrollButton extends GUIGFXButton
		Native;

var(Menu)	bool	LeftButton;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.Initcomponent(MyController, MyOwner);

	if (!LeftButton)
	{
		U=324;
		V=144;
		UL=23;
		VL=31;
	}
	else
	{
		U=324;
		V=113;
		UL=23;
		VL=31;
	}

	OnPreDraw = InternalOnPreDraw;
}

function bool InternalOnPreDraw(Canvas C)
{
	if (Controller.bIsConsole && (FocusInstead != None))
	{
		if (FocusInstead.MenuState == MSAT_Focused)
			pulseStyle=CPS_Slow;
		else
			pulseStyle=CPS_None;
	}

	return true;
}

defaultproperties
{
	Graphic=Material't_interface_mb.hud.chapters_comp'
	StyleName="MenuOptionLabel"
	LeftButton=false
	Position=ICP_ScaledClip
	bNeverFocus=true
	bCaptureMouse=true
	bClientBound=true
	pulseStyle=CPS_None
}
// ====================================================================
//  Class:  GUI.GUIHorzScrollZone
//  Parent: GUI.GUIComponent
//
//  <Enter a description here>
// ====================================================================

class GUIHorzScrollZone extends GUIComponent
		Native;

cpptext
{
		void Draw(UCanvas* Canvas);
}

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.Initcomponent(MyController, MyOwner);

	OnClick = InternalOnClick;
}

function bool InternalOnClick(GUIComponent Sender)
{
	local float perc;

	if (!IsInBounds())
		return false;

	perc = ( Controller.MouseX - ActualLeft() ) / ActualWidth();
	OnScrollZoneClick(perc);

	return true;

}


delegate OnScrollZoneClick(float Delta)		// Should be overridden
{
}

defaultproperties
{
	StyleName="ScrollZone"
	bNeverFocus=true
	bAcceptsInput=true
	bCaptureMouse=true
	bRepeatClick=true
}// ====================================================================
//  Class:  GUI.GUIIconButton
//
//	GUIIconButton - Combines a text button with an icon.
// ====================================================================

class GUIIconButton extends GUIButton
	Native;

// GBX:CEK: 3/16/2004 - TEMP GUI REINTEGRATION
//#exec OBJ LOAD FILE=GUIContent.utx

cpptext
{
		void Draw(UCanvas* Canvas);
}

enum EIconButtonLayout
{
	IBL_ICON_LEFT,		// icon to left, text to right
	IBL_ICON_RIGHT,		// icon to right, text to left
	IBL_ICON_TOP,		// icon on top, text below, behind
	IBL_ICON_BOTTOM,	// icon on bottom, text above, behind
};

var(Menu)	Material 		Icon;			// The graphic to display
var(Menu)	float			IconSize;		// The Icon W,H are taken from this fraction of the button's height (use 0 for real-size)
var(Menu)	int				U,V,UL,VL;		// subimage coords if non-zero UL,VL
var(Menu)	Color			IconColors[5];	// This array holds 1 image color for each state
var(Menu)	bool			bClientBound;
var(Menu)	bool			bPreserveAspect;

var(Menu)	EIconButtonLayout	Layout;
var(Menu)	eTextAlign			Align;		// specifies horizontal alignment

/*
function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.Initcomponent(MyController, MyOwner);
}
*/

defaultproperties
{
	IconSize=0.0
    bTabStop=true
    bClientBound=true
	bPreserveAspect=true

	Layout=IBL_ICON_LEFT
	Align=TXTA_Left
	U=0
	V=0
	UL=0
	VL=0
	IconColors(0)=(R=255,G=255,B=255,A=255)
	IconColors(1)=(R=255,G=255,B=255,A=255)
	IconColors(2)=(R=255,G=255,B=255,A=255)
	IconColors(3)=(R=255,G=255,B=255,A=255)
	IconColors(4)=(R=64,G=64,B=64,A=255)
}// ====================================================================
//  Class:  GUI.GUIImage
//
//	GUIImage - A graphic image used by the menu system.  It encapsulates
//	Material.
//
//  Written by Joe Wilcox
//  (c) 2002, Epic Games, Inc.  All Rights Reserved
// ====================================================================

class GUIImage extends GUIComponent
	Native;

cpptext
{
		void Draw(UCanvas* Canvas);
}

var(Menu) Material 			Image;				// The Material to Render
var(Menu) color				ImageColor;			// What color should we set
var(Menu) eImgStyle			ImageStyle;			// How should the image be displayed
var(Menu) EMenuRenderStyle	ImageRenderStyle;	// How should we display this image
var(Menu) eImgAlign			ImageAlign;			// If ISTY_Justified, how should image be aligned
var(Menu) int				X1,Y1,X2,Y2;		// If set, it will pull a subimage from inside the image

function SetColor(byte R, byte G, byte B, byte A)
{
	ImageColor.R = R;
	ImageColor.G = G;
	ImageColor.B = B;
	ImageColor.A = A;
}

function SetColorFromColor(color newColor)
{
	ImageColor	= newColor;
}

function SetFromIcon(out Canvas.CanvasIcon icon)
{
	Image		= icon.Icon;
	ImageColor	= icon.DrawColor;
	X1 			= icon.U;
	Y1 			= icon.V;
	X2 			= icon.U+icon.UL;
	Y2 			= icon.V+icon.VL;
}

defaultproperties
{
	ImageColor=(R=255,G=255,B=255,A=255)
	ImageStyle=ISTY_Normal
	ImageRenderStyle=MSTY_Alpha
	ImageAlign=IMGA_TopLeft
	X1=-1
	X2=-1
	Y1=-1
	Y2=-1
    RenderWeight=0.1
}// GUIImageList is simply a GUIImage that has its current image selected from an array
// It rotates using mouse wheel/arrow keys

class GUIImageList extends GUIImage;
//	Native;

var array<string> MatNames;
var array<Material> Materials;
var int CurIndex;
var bool bWrap;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.Initcomponent(MyController, MyOwner);
	OnKeyEvent=internalKeyEvent;
}

function AddMaterial(string MatName, out Material Mat)
{
local int i;

	if (Mat != None)
	{
		i = Materials.Length;
		Materials[i]=Mat;
		MatNames[i]=MatName;
	}
}

function string GetCurMatName()
{
	if (CurIndex >= 0 && CurIndex < Materials.Length)
		return MatNames[CurIndex];

	return "";
}

function SetIndex(int index)
{
	if (index >= 0 && index < Materials.Length)
	{
		CurIndex = index;
		Image = Materials[index];
	}
	else
	{
		Image = None;
		CurIndex = -1;
	}
}

function bool internalKeyEvent(out byte Key, out byte State, float delta)
{
	if ( ((Key==0x26 || Key==0x68 || Key==0x25 || Key==0x64) && (State==1)) || (key==0xEC && State==3) )	// Up/Left/MouseWheelUp
	{
		PrevImage();
		return true;
	}
	
	if ( ((Key==0x28 || Key==0x62 || Key==0x27 || Key==0x66) && (State==1)) || (key==0xED && State==3) )  // Down/Right/MouseWheelDn
	{
		NextImage();
		return true;
	}
	
	if ( (Key==0x24 || Key==0x67) && (State==1) ) // Home
	{
		FirstImage();
		return true;
	}
	
	if ( (Key==0x23 || Key==0x61) && (State==1) ) // End
	{
		LastImage();
		return true;
	}

	return false;
}

function PrevImage()
{
	if (CurIndex < 1)
	{
		if (bWrap)
			SetIndex(Materials.Length - 1);
	}
	else
		SetIndex(CurIndex - 1);
}

function NextImage()
{
	if (CurIndex < 0)
		SetIndex(0);
	else if ((CurIndex + 1) >= Materials.Length)
	{
		if (bWrap)
			SetIndex(0);
	}
	else
		SetIndex(CurIndex + 1);
}

function FirstImage()
{
	if (Materials.Length > 0)
		SetIndex(0);
}

function LastImage()
{
	if (Materials.Length > 0)
		SetIndex(Materials.Length - 1);
}

defaultproperties
{
	StyleName="NoBackground"
	bAcceptsInput=true
	bCaptureMouse=True
	bNeverFocus=false;
	bTabStop=true
}
// ====================================================================
//  Class:  GUI.GUIImage
//
//	GUILabel - A text label that get's displayed.  By default, it
//  uses the default font, however you can override it if you wish.
//
//  Written by Joe Wilcox
//  (c) 2002, Epic Games, Inc.  All Rights Reserved
// ====================================================================

class GUILabel extends GUIComponent
	Native;

cpptext
{
		void Draw(UCanvas* Canvas);
}

var(Menu)	localized 	string				Caption;			// The text to display
var(Menu)				string				TweenCaption;		// Tween to this string if fTweenChangeTime > 0
var(Menu)				eTextAlign			TextAlign;			// How is the text aligned in it's bounding box
var(Menu)				eTextAlign			TextAlignV;			// How is the text aligned in it's bounding box vertically (for multiline)
var(Menu)				color				TweenTextColor;		// This color is applied when the new string is swapped in if .A != 0
var(Menu)				color				TextColor;			// The Color to display this in.
var(Menu)				color				FocusedTextColor;	// The Color to display this in.
var(Menu)				EMenuRenderStyle	TextStyle;			// What canvas style to use
var(Menu)				string 				TextFont;			// The Font to display it in
var(Menu)				bool				bTransparent;		// Draw a Background for this label
var(Menu)				bool				bMultiLine;			// Will cut content to display on multiple lines when too long
var(Menu)				bool				bUseTextColorForStyle;	// override style color with TextColor
var(Menu)				bool				bClientBounded;		// bound text to client rather than the actual window
var(Menu)				bool				bDrawToFit;			// Use style's DrawTextToFit function to draw the text rescaled to fit
var(Menu)				bool				bForceCaps;			// Automatically call Caps() on contents of SetCaption()
var(Menu)				float				fTweenChangeTime;	// time to fade out and fade back in when changing the caption
var(Menu)				float				fTweenChangeFinish;	// The current tween should be done by this time
var(Menu)				color				BackColor;			// Background color for this label

var						int					DrawMenuState;		// override the menu style for drawing this item

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	if (!bMultiLine)
		bDrawToFit = true;
}


function SetCaption(optional string S)
{
	if (bForceCaps)
		S = CapsL(S);

	if ((Caption == "") || (S == ""))
	{
		Caption = S;
	}
	else if (fTweenChangeTime > 0.0)
	{
		if (TweenCaption != "")
		{
			TweenCaption = S;
		}
		else if ((S != Caption) && (S != TweenCaption))
		{
			TweenCaption = S;
			fTweenChangeFinish = PlayerOwner().Level.UniversalTimeSeconds + fTweenChangeTime;
		}
	}
	else
	{
		Caption = S;
	}
}

function int GetCaptionPos(Canvas C, bool bCaptionFront)
{
	local int XL, YL;
	local float fXL, fYL;

	if (Style != None)
	{
		Style.TextSize(C, MenuState, Caption, XL, YL);
	}
	else
	{
		C.TextSize(Caption, fXL, fYL);
		XL = fXL;
		YL = fYL;
	}

	XL = Min(XL, ActualWidth());
	if (bCaptionFront)
	{
		switch(TextAlign)
		{
		case TXTA_Left: return ActualLeft(); break;
		case TXTA_Center: return ActualLeft() + 0.5 * (ActualWidth() - XL); break;
		case TXTA_Right: return ActualLeft() + ActualWidth() - XL; break;
		}
	}
	else
	{
		switch(TextAlign)
		{
		case TXTA_Left: return ActualLeft() + XL; break;
		case TXTA_Center: return ActualLeft() + 0.5 * (ActualWidth() + XL); break;
		case TXTA_Right: return ActualLeft() + ActualWidth(); break;
		}
	}

	return ActualLeft();
}

defaultproperties
{
	TextAlign=TXTA_Left
	TextAlignV=TXTA_Left
	TweenTextColor=(R=0,G=0,B=0,A=0)
	TextColor=(R=255,G=255,B=255,A=255)
	FocusedTextColor=(R=255,G=255,B=0,A=255)
	TextStyle=MSTY_Normal
	TextFont="MenuFont"
	bTransparent=true
	bUseTextColorForStyle=false
	bClientBounded=true
	bDrawToFit=false
	bForceCaps=false
	BackColor=(R=0,G=0,B=0,A=255)
	RenderWeight=0.1
	fTweenChangeTime=0.0
	fTweenChangeFinish=0.0

	DrawMenuState=-1
	WinHeight=0.06
	WinWidth=0.15000
}// ====================================================================
//  Class:  GUI.GUIList
//
//  The GUIList is a basic list component.   
//
//  Written by Joe Wilcox
//  (c) 2002, Epic Games, Inc.  All Rights Reserved
// ====================================================================

class GUIList extends GUIVertList
		Native;

// GBX:CEK: 3/16/2004 - TEMP GUI REINTEGRATION
//#exec OBJ LOAD FILE=GUIContent.utx
	
cpptext
{
	void DrawItem(UCanvas* Canvas, INT Item, FLOAT X, FLOAT Y, FLOAT W, FLOAT H);
}

var		eTextAlign			TextAlign;			// How is text Aligned in the control

var	    array<GUIListElem>	Elements;

native final function SortList();

// Used by SortList.
delegate int CompareItem(GUIListElem ElemA, GUIListElem ElemB);

// Accessor function for the items.

function string SelectedText()
{
	if ( (Index >=0) && (Index <Elements.Length) )
		return Elements[Index].Item;
	else
		return "";
}

function Add(string NewItem, optional Object obj, optional string Str)
{
	Elements.Length = Elements.Length+1;
	
	Elements[Elements.Length-1].Item=NewItem;
	Elements[Elements.Length-1].ExtraData=obj;
	Elements[Elements.Length-1].ExtraStrData=Str;

	ItemCount=Elements.Length;
	
	if (Elements.Length == 1)
		SetIndex(0);
	else
		OnChange(self);

	MyScrollBar.AlignThumb();
}

function Replace(int index, string NewItem, optional Object obj, optional string Str)
{
	if ( (Index<0) || (Index>=Elements.Length) )
		Add(NewItem,Obj,Str);
	else
	{
		Elements[Index].Item = NewItem;
		Elements[Index].ExtraData = obj;
		Elements[Index].ExtraStrData = Str;
	}
}		

function Insert(int Index, string NewItem, optional Object obj, optional string Str)
{
	if ( (Index<0) || (Index>=Elements.Length) )
		Add(NewItem,Obj,Str);
	else
	{
		Elements.Insert(index,1);
		Elements[Index].Item=NewItem;
		Elements[Index].ExtraData=obj;
		Elements[Index].ExtraStrData=Str;

		ItemCount=Elements.Length;	

		OnChange(self);
		MyScrollBar.AlignThumb();
	}
}	

event Swap(int IndexA, int IndexB)
{
	local GUI.GUIListElem elem;

	if ( (IndexA<0) || (IndexA>=Elements.Length) || (IndexB<0) || (IndexB>=Elements.Length) )
		return;

	elem = Elements[IndexA];
	Elements[IndexA] = Elements[IndexB];
	Elements[IndexB] = elem;
}
	
function string GetItemAtIndex(int i)
{
	if ((i<0) || (i>Elements.Length))
		return "";
		
	return Elements[i].Item;
}

function SetItemAtIndex(int i, string NewItem)
{
	if ((i<0) || (i>Elements.Length))
		return;
		
	Elements[i].Item = NewItem;
}

function object GetObjectAtIndex(int i)
{
	if ((i<0) || (i>Elements.Length))
		return None;
		
	return Elements[i].ExtraData;
}

function string GetExtraAtIndex(int i)
{
	if ((i<0) || (i>Elements.Length))
		return "";
		
	return Elements[i].ExtraStrData;
}

function SetExtraAtIndex(int i, string NewExtra)
{
	if ((i<0) || (i>Elements.Length))
		return;
		
	Elements[i].ExtraStrData = NewExtra;
}

function GetAtIndex(int i, out string ItemStr, out object ExtraObj, out string ExtraStr)
{
	if ((i<0) || (i>Elements.Length))
		return;
		
	ItemStr = Elements[i].Item;
	ExtraObj = Elements[i].ExtraData;
	ExtraStr = Elements[i].ExtraStrData;
}  

function LoadFrom(GUIList Source, optional bool bClearFirst)
{
	local string t1,t2;
	local object t;
	local int i;

	if (bClearfirst)
		Clear();
	
	for (i=0;i<Source.Elements.Length;i++)
	{
		Source.GetAtIndex(i,t1,t,t2);
		Add(t1,t,t2);
	}
}

function Remove(int i, optional int Count)
{
	if (Count==0)
		Count=1;
		
	Elements.Remove(i, Count);

	ItemCount = Elements.Length;		
		
	SetIndex(-1);
	MyScrollBar.AlignThumb();
} 

function RemoveItem(string Item)
{
	local int i;

	// Work through array. If we find it, remove it (will reduce Elements.Length).
	// If we don't, move on to next one.
	i=0;
	while(i<Elements.Length)
	{
		if(Item ~= Elements[i].Item)
			Elements.Remove(i, 1);
		else
			i++;
	}

	ItemCount = Elements.Length;

	SetIndex(-1);
	MyScrollBar.AlignThumb();
}

function Clear()
{
	Elements.Remove(0,Elements.Length);

	Super.Clear();
	OnChange(self);
}	

function string Get()
{
	if ( (Index<0) || (Index>=ItemCount) )
		return "";
	else
		return Elements[Index].Item;
}

function object GetObject()
{
	if ( (Index<0) || (Index>=ItemCount) )
		return none;
	else
		return Elements[Index].ExtraData;
}	

function string GetExtra()
{
	if ( (Index<0) || (Index>=ItemCount) )
		return "";
	else
		return Elements[Index].ExtraStrData;
}
	
function string find(string Text, optional bool bExact)
{
	local int i;
	for (i=0;i<ItemCount;i++)
	{
		if (bExact)
		{
			if (Text == Elements[i].Item)
			{
				SetIndex(i);
				return  Elements[i].Item;
			}
		}
		else
		{
			if (Text ~=  Elements[i].Item)
			{
				SetIndex(i);
				return  Elements[i].Item;
			}
		}
	}
	return "";
}

// find an element by the 'extra' string
// only sets the index if it finds the string
// returns the string of the found item
function string FindExtra (string ExtraText, optional bool bExact )
{
	local int i;
	for (i=0;i<ItemCount;i++)
	{
		if (bExact)
		{
			if (ExtraText == Elements[i].ExtraStrData)
			{
				SetIndex(i);
				return Elements[i].Item;
			}
		}
		else
		{
			if (ExtraText ~=  Elements[i].ExtraStrData)
			{
				SetIndex(i);
				return Elements[i].Item;
			}
		}
	}
	return "";
}

defaultproperties
{
	TextAlign=TXTA_Center
}
// ====================================================================
//  Class:  GUI.GUIListBase
//
//  Abstract GUIList list box component.   
//
//  Written by Joe Wilcox
//  Made abstract by Jack Porter
//  (c) 2002, Epic Games, Inc.  All Rights Reserved
// ====================================================================

class GUIListBase extends GUIComponent
		Native
		Abstract;

// GBX:CEK: 3/16/2004 - TEMP GUI REINTEGRATION
//#exec OBJ LOAD FILE=GUIContent.utx
	
cpptext
{
	virtual void DrawItem(UCanvas* Canvas, INT Item, FLOAT X, FLOAT Y, FLOAT W, FLOAT H) {}
}
		
var		bool				bSorted;			// Should we sort this list
var		color				SelectedBKColor;	// Color for a selection background
var		Material			SelectedImage;		// Image to use when displaying
var		int 				Top,Index;			// Pointers in to the list
var		int					ItemsPerPage;		// # of items per Page.  Is set natively
var		int					ItemHeight;			// Size of each row.  Subclass should set in PreDraw.
var		int					ItemWidth;			// Width of each row.. Subclass should set in PreDraw.
var		int					ItemCount;			// # of items in this list
var		bool				bHotTrack;			// Use the Mouse X/Y to always hightlight something
var		bool				bVisibleWhenEmpty;	// List is still drawn when there are no items in it.
var		bool				bTransparent;		// don't draw the background

var		GUIScrollBarBase	MyScrollBar;


// Owner-draw.
delegate OnDrawItem(Canvas Canvas, int Item, float X, float Y, float W, float H, bool bSelected);
delegate OnPostDrawItem(Canvas Canvas, int Item, float X, float Y, float W, float H, bool bSelected);
delegate OnAdjustTop(GUIComponent Sender);

function Sort();	// Add in a bit

function int SetIndex(int NewIndex)
{
	if (NewIndex < 0 || NewIndex >= ItemCount)
		Index = -1;
	else
		Index = NewIndex;

	if ( (index>=0) && (ItemsPerPage>0) )
	{
		if (Index<top)
			SetTopItem(Index);
			
		if (ItemsPerPage != 0 && Index>=Top+ItemsPerPage)
			SetTopItem(Index-ItemsPerPage+1);
	}		
		
	MyScrollBar.AlignThumb();
	OnChange(self);
	return Index;
}

function Clear()
{
	Top = 0;
	ItemCount=0;
	SetIndex(-1);
	MyScrollBar.AlignThumb();
}

function MakeVisible(float Perc)
{
	SetTopItem(int((ItemCount-ItemsPerPage) * Perc));
}

function SetTopItem(int Item)
{
	Top = Item;
	if (Top+ItemsPerPage>=ItemCount)
		Top = ItemCount - ItemsPerPage; 	

	if (Top<0)
		Top=0;
		
	MyScrollBar.AlignThumb();
	OnAdjustTop(Self);		
}

defaultproperties
{
	bAcceptsInput=true
	StyleName="ListBox"
// GBX:CEK: 3/16/2004 - TEMP GUI REINTEGRATION
	SelectedImage=Texture'WhiteTexture'
//	SelectedImage=material'GUIContent.menus.PulseFill'
	SelectedBKColor=(R=255,G=255,B=255,A=255)
	Top=0
	Index=0	
	ItemsPerPage=0
	bTabStop=true	
	bVisibleWhenEmpty=false
	bTransparent=false
}
// ====================================================================
//  Class:  GUI.GUIListBox
//
//  The GUIListBoxBase is a wrapper for a GUIList and it's ScrollBar
//
//  Written by Joe Wilcox
//  (c) 2002, Epic Games, Inc.  All Rights Reserved
// ====================================================================
class GUIListBox extends GUIListBoxBase
	native;

var	Automated GUIList	List;		// For Quick Access;
var	eTextAlign			TextAlign;	// How is text Aligned in the control

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.Initcomponent(MyController, MyOwner);
    InitBaseList(List);
	List.OnClick=InternalOnClick;
	List.OnClickSound=CS_Click;
	List.OnChange=InternalOnChange;

	List.TextAlign = TextAlign;
}

function bool InternalOnClick(GUIComponent Sender)
{
	List.InternalOnClick(Sender);
	OnClick(Self);
	return true;
}

function InternalOnChange(GUIComponent Sender)
{
	OnChange(Self);
}

function int ItemCount()
{
	return List.ItemCount;
}

defaultproperties
{
	Begin Object Class=GUIList Name=TheList
		Name="TheList"
	End Object

	List=TheList

	TextAlign=TXTA_Center
}// ====================================================================
//  Class:  GUI.GUIListBoxBase
//
//  The GUIListBoxBase is a wrapper for a GUIList and it's ScrollBar
//
//  Written by Joe Wilcox
//  (c) 2002, Epic Games, Inc.  All Rights Reserved
// ====================================================================

class GUIListBoxBase extends GUIMultiComponent
		Native;

cpptext
{
	void PreDraw(UCanvas* Canvas);
	void Draw(UCanvas* Canvas);								// Handle drawing of the component natively
}

var Automated	GUIVertScrollBar	MyScrollBar;
var 			GUIListBase			MyList;
var				bool				bVisibleWhenEmpty;		// List box is visible when empty.
var				bool				bNoScrollbar;


function InitBaseList(GUIListBase LocalList)
{
	local int i;

    MyList = LocalList;

	LocalList.StyleName = StyleName;
	LocalList.bVisibleWhenEmpty = bVisibleWhenEmpty;
	LocalList.MyScrollBar = MyScrollBar;
	MyScrollBar.MyList = LocalList;

	MyScrollBar.FocusInstead = LocalList;

	for (i=0;i<MyScrollBar.Controls.Length;i++)
		MyScrollBar.Controls[i].FocusInstead = LocalList;

	SetVisibility(bVisible);
}

function SetHint(string NewHint)
{
	local int i;
	Super.SetHint(NewHint);

    for (i=0;i<Controls.Length;i++)
    	Controls[i].SetHint(NewHint);
}

defaultproperties
{
	Begin Object Class=GUIVertScrollBar Name=TheScrollbar
		bVisible=false
	End Object
    MyScrollBar=TheScrollbar

	bAcceptsInput=true;
	bVisibleWhenEmpty=False

	PropagateVisibility=true
	bNoScrollbar=false
}// ====================================================================
//  Class:  GUI.GUIMultiComponent
//
//	MenuOptions combine a label and any other component in to 1 single
//  control.  The Label is left justified, the control is right.
//
//  Written by Joe Wilcox
//  (c) 2002, Epic Games, Inc.  All Rights Reserved
// ====================================================================

class GUIMenuOption extends GUIMultiComponent
		Native;

cpptext
{
		void PreDraw(UCanvas* Canvas);
}

var(Menu)	string			ComponentClassName;		// Name of the component to spawn
var(Menu)	localized string	Caption;				// Caption for the label
var(Menu)	string			LabelFont;				// Name of the Font for the label
var(Menu)	string			LabelStyle;				// Name of the Font for the label
var(Menu)	string			CompStyle;				// Name of the style for the component
var(Menu)	Color			LabelColor;				// Color for the label
var(Menu)	bool			bHeightFromComponent;	// Get the Height of this component from the Component
var(Menu)	float			CaptionWidth;			// How big should the Caption be
var(Menu)	float			ComponentWidth;			// How big should the Component be (-1 = 1-CaptionWidth)
var(Menu)	bool			bFlipped;				// Draw the Component to the left of the caption
var(Menu)	eTextAlign		LabelJustification;		// How do we justify the label
var(Menu)	eTextAlign		ComponentJustification;	// How do we justify the label
var(Menu)	bool			bSquare;				// Use the Height for the Width
var(Menu)	bool			bVerticalLayout;		// Layout controls vertically

var			GUILabel		MyLabel;				// Holds the label
var			GUIComponent	MyComponent;			// Holds the component


function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.Initcomponent(MyController, MyOwner);

	// Create the two components

    MyLabel = GUILabel(AddComponent("GUI.GUILabel"));
	if (MyLabel==None)
	{
		log("Failed to create "@self@" due to problems creating GUILabel");
		return;
	}

	if (bFlipped)
	{
		if (LabelJustification==TXTA_Left)
			LabelJustification=TXTA_Right;

		else if (LabelJustification==TXTA_Right)
			LabelJustification=TXTA_Left;

		if (ComponentJustification==TXTA_Left)
			ComponentJustification=TXTA_Right;

		else if (ComponentJustification==TXTA_Right)
   			ComponentJustification=TXTA_Left;
	}

	MyLabel.SetCaption(Caption);
//	MyLabel.TextFont 	= LabelFont;
//	MyLabel.TextColor	= LabelColor;
	MyLabel.TextAlign   = LabelJustification;
//	MyLabel.StyleName 	= LabelStyle;
	MyLabel.SetStyle(LabelStyle);

    MyComponent = AddComponent(ComponentClassName);
	// Check for errors
	if (MyComponent == None)
	{
		log("Could not create requested menu component"@ComponentClassName);
		return;
	}

	MyComponent.SetHint(Hint);

	if (bHeightFromComponent && !bVerticalLayout)
		WinHeight = MyComponent.WinHeight;

	MyComponent.OnChange = InternalOnChange;
	MyComponent.SetFriendlyLabel(MyLabel);

	if (CompStyle != "")
	{
		MyComponent.SetStyle(CompStyle);
	}


    MyComponent.bTabStop = true;
    MyComponent.TabOrder = 1;
	MyLabel.FocusInstead = MyComponent;
}

function SetCaption(optional string S)
{
	MyLabel.SetCaption(s);
}

function int GetCaptionPos(Canvas C, bool bCaptionFront)
{
	if (bVerticalLayout)
	{
		if (bCaptionFront)
			return ActualLeft();
		else
			return ActualLeft() + ActualWidth();
	}
	else
	{
		return MyLabel.GetCaptionPos(C, bCaptionFront);
	}
}

function InternalOnChange(GUIComponent Sender)
{
	OnChange(self);
}

defaultproperties
{
	bHeightFromComponent=true
	CaptionWidth=0.5
	ComponentWidth=-1
	WinWidth=0.500000
	WinHeight=0.060000
	WinLeft=0.496094
	WinTop=0.347656
	LabelFont="MenuFont"
	LabelStyle="MenuOptionCaption"
	CompStyle=""
	LabelColor=(R=255,G=255,B=255,A=255)
	bFlipped=false
	LabelJustification=TXTA_Left
	ComponentJustification=TXTA_Right
	bSquare=false
    bTabStop=true
	PropagateVisibility=true

}class GUIMultiColumnList extends GUIVertList
	native;

struct native MultiColumnSortData
{
	var string SortString;
	var const int SortItem;
};

var array<MultiColumnSortData> SortData;
var array<int> InvSortData;
var localized string ColumnHeadings[8];  // counting on number of ColumnWidths to be <= # ColumnHeadings
var array<float> ColumnWidths;
var array<float> InitColumnPerc; // Used to initialize column width to screen-relative size (if desired)
var float CellSpacing;
var int SortColumn; // If -1 - dont sort
var bool SortDescending;
var bool ExpandLastColumn;
var bool bInitialised;

// sorting stuff
var bool NeedsSorting;
native final function SortList();
native final function ChangeSortOrder();
native final function AddedItem();			// must be called when we add an item to the end of the list.
native final function UpdatedItem(int i);	// should be called when we update an item's data
event string GetSortString( int i );

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);
	OnPreDraw = InternalOnPreDraw;
}

// notification
event OnColumnSized(int column);

event OnSortChanged()
{
	local int OldItem;

	// get the selection item
	if( Index >= 0 )
		OldItem = SortData[Index].SortItem;

	// recalculate SortData
	ChangeSortOrder();
	// resort list
	SortList();
	NeedsSorting = False;

	// remap the selection item back again to keep the same item selected
	if( Index >= 0 && OldItem < InvSortData.Length )
		Index = InvSortData[OldItem];
}

function Clear()
{
	SortData.Remove(0,SortData.Length);
	InvSortData.Remove(0,SortData.Length);
	Super.Clear();
}

function RemovedCurrent()
{
	if( Index >= 0 )
	{
		SortData.Remove(Index,1);
		InvSortData.Remove(Index,1);

		// Force updating of sort data
		OnSortChanged();
		Index = -1;
	}
}

event InitializeColumns(Canvas C)
{
	local int i;
	for(i=0; i<InitColumnPerc.Length; i++)
	{
		ColumnWidths[i] = ActualWidth() * InitColumnPerc[i];
	}
	bInitialised=true;
}

function bool InternalOnPreDraw(Canvas C)
{
	local float x;
	local int i;
	local int OldItem;

    if (!bInitialised)
    	return true;

	if( NeedsSorting )
	{
		// get the selection item
		if( Index >= 0 )
			OldItem = SortData[Index].SortItem;

		SortList();
		NeedsSorting = False;

		// remap the selection item back again to keep the same item selected
		if( Index >= 0 && OldItem < InvSortData.Length )
			Index = InvSortData[OldItem];
	}
	if( ExpandLastColumn )
	{
		for( i=0;i<ColumnWidths.Length-1;i++ )
			x += ColumnWidths[i];
        ColumnWidths[i] = ActualWidth() - x;
	}
	return true;
}

function GetCellLeftWidth( int Column, out float Left, out float Width, optional bool bIncludeStyleBorder )
{
	local int i;
	Left = 0;
	for( i=0;i<Column && i<ColumnWidths.Length;i++ )
		Left += ColumnWidths[i];
	if( i<ColumnWidths.Length )
		Width = ColumnWidths[i];
	else
		Width = 0;

	Left += CellSpacing;
	Width -= 2*CellSpacing;

	if (bIncludeStyleBorder)
	{
		// indent by the style border too
		Left += Style.BorderOffsets[0];
		Width -= Style.BorderOffsets[0];
		Width -= Style.BorderOffsets[3];
	}
}

defaultproperties
{
	CellSpacing=1.0
	SortColumn=-1
}class GUIMultiColumnListBox extends GUIListBoxBase
	native;

cpptext
{
	void PreDraw(UCanvas* Canvas);
}

var Automated GUIMultiColumnListHeader 	Header;

var GUIMultiColumnList	List;
var string				DefaultListClass;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.Initcomponent(MyController, MyOwner);

    if (DefaultListClass!="")
    {
    	List = GUIMultiColumnList(AddComponent(DefaultListClass));
        if (List==None)
        {
        	log("GUIMultiColumnListBox::InitComponent - Could not create default list ["$DefaultListClass$"]");
            return;
        }
    }

	Header.MyList = List;
    InitBaseList(List);
}

defaultproperties
{
	Begin Object Class=GUIMultiColumnListHeader Name=MyHeader
	End Object

	Header=MyHeader
}class GUIMultiColumnListHeader extends GUIComponent
	native;

cpptext
{
	UBOOL MousePressed(UBOOL IsRepeat);
	UBOOL MouseReleased();
	UBOOL MouseMove(INT XDelta, INT YDelta);
	UBOOL MouseHover();
	void Draw(UCanvas* Canvas);
	void PreDraw(UCanvas* Canvas);
}

var GUIMultiColumnList MyList;
var int SizingCol;
var int ClickingCol;

defaultproperties
{
	StyleName="SquareButton"
	bCaptureTabs=False
	bNeverFocus=False
	bTabStop=False
	bAcceptsInput=True
	SizingCol=-1
	ClickingCol=-1

}// ====================================================================
//  Class:  GUI.GUIMultiComponent
//
//	GUIMultiComponents are collections of components that work together.
//  When initialized, GUIMultiComponents transfer all of their components
//	to the to the GUIPage that owns them.
//
//  Written by Joe Wilcox
//  (c) 2002, Epic Games, Inc.  All Rights Reserved
// ====================================================================

class GUIMultiComponent extends GUIComponent
		Native;

cpptext
{
		void PreDraw(UCanvas* Canvas);		// Do any size/postitioning
		void PreDrawControls(UCanvas* Canvas);		// DS-BEGIN/END Do any size/postitioning of our controls
		void Draw(UCanvas* Canvas);			// Draw the component

		virtual void InitializeControls();	// Takes all GUIComponent members and assigns them to the controls array

		UGUIComponent* UnderCursor(FLOAT MouseX, FLOAT MouseY);

		UBOOL NativeKeyType(BYTE& iKey, TCHAR Unicode );					// A Key or Mouse button has pressed
		UBOOL NativeKeyEvent(BYTE& iKey, BYTE& State, FLOAT Delta );		// A Key/Mouse event occured

		void NativeInvalidate(UGUIComponent* Who);
		UBOOL SpecialHit();

		UBOOL PerformHitTest(INT MouseX, INT MouseY);

		UBOOL MousePressed(UBOOL IsRepeat);					// The left mouse button was pressed
		UBOOL RightMousePressed();							// The right mouse button was pressed
		UBOOL MouseReleased();								// The mouse button was released

		UBOOL XControllerEvent(int Id, eXControllerCodes iCode);

		void InitializeControl(UGUIComponent* Ptr);		// initialize a single element in InitializeControls
}

var		array<GUIComponent>		Controls;				// An Array of Components that make up this Control
var 	array<GUIComponent>		Components;				// An Array of Controls that can be tabbed to
var		GUIComponent			FocusedControl;			// Which component inside this one has focus
var		bool					PropagateVisibility;	// Does changes to visibility propagate down the line
var		bool					bPlayFocusSound;
var		bool					bHandleMouseRelease;	// specifies that MouseReleased() should call super's version


function native InitializeControls();

// Stub
function InternalOnShow();

event int FindComponentIndex(GUIComponent Who)
{
	local int i;

	if (Who != None && Components.Length > 0)
    {
		for (i=0;i<Components.Length;i++)
        {
			if (Who==Components[i])
				return i;
    	}
    }

	return -1;
}

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	local int i;

	Super.Initcomponent(MyController, MyOwner);

	// Set OnShow delegate - SetVisibility will be called in next step
	OnShow = InternalOnShow;

    InitializeControls();	// Build the Controls array
	for (i=0;i<Controls.Length;i++)
	{
		if (Controls[i] == None)
		{
			log("Invalid control found in"@string(Class)$"!! (Control"@i$")",'GUI ERROR');
			Controls.Remove(i--,1);
			continue;
		}
		Controls[i].InitComponent(MyController, Self);
	}

    // Propagate some defaults
    if (PropagateVisibility)
    	SetVisibility(bVisible);

    RemapComponents();

}

event GUIComponent AddComponent(string ComponentClass, optional string instanceName)
{
    local class<GUIComponent> NewCompClass;
    local GUIComponent NewComp;

    NewCompClass = class<GUIComponent>(DynamicLoadObject(ComponentClass,class'class'));
    if (NewCompClass != None)
    {

        NewComp = new(None,instanceName) NewCompClass;
        if (NewComp!=None)
        {
        	NewComp = AppendComponent(NewComp);
			return NewComp;
        }
    }

    log("GUIMultiComponent::AddComponent - Could not create component"@ComponentClass,'GUI');
	return none;
}

event GUIComponent InsertComponent(GUIComponent NewComp, int Index)
{
	if (Index < 0 || Index >= Controls.Length)
		return AppendComponent(NewComp);

	Controls.Insert(Index, 1);
	Controls[Index] = NewComp;
	RemapComponents();
	return NewComp;
}

event GUIComponent AppendComponent(GUIComponent NewComp)
{
	local int index;

    // Attempt to add it sorted in to the array.  The Controls array is sorted by
    // Render Weight.

    while (Index<Controls.Length)
    {
    	if (NewComp.RenderWeight <= Controls[Index].RenderWeight)	// We found our spot
        {
			Controls.Insert(Index,1);
			break;
        }
        Index++;
    }

    // Couldn't find a spot, add it at the end
    Controls[Index] = NewComp;
   	NewComp.InitComponent(Controller, Self);
	RemapComponents();
    return NewComp;
}

event bool RemoveComponent(GUIComponent comp, optional bool bRemap)
{
	local int i;
    for (i=0;i<Controls.Length;i++)
    {
		if (Controls[i] == comp)
        {
        	Controls.Remove(i,1);
        	if (bRemap)
	        	RemapComponents();
            return true;
        }
	}
    return false;
}

function FindCenterPoint(GUIComponent What, out float X, out float Y)
{
	X = What.ActualLeft() + (What.ActualWidth()/2);
    Y = What.ActualTop() + (What.ActualHeight()/2);
}

function float FindDist(GUIComponent Source, GUIComponent Target)
{
	local float a,b;
    local float x[2],y[2];

    FindCenterPoint(Source,x[0],y[0]);
    FindCenterPoint(Target,x[1],y[1]);

  	a = abs(x[0]-x[1]);
    a = square(a);
    b = abs(y[0]-y[1]);
    b = square(b);

    return sqrt(a+b);
}

function bool TestControls(int Mode, int SourceIndex, int TargetIndex)
{
	local float sX1,sY1,sX2,sY2;
    local float tX1,tY1,tX2,tY2;

	if (SourceIndex==TargetIndex)
    	return false;

    if (Controls[TargetIndex].bNeverFocus || !Controls[TargetIndex].bVisible)
    	return false;

	sX1 = Controls[SourceIndex].ActualLeft();
    sX2 = sX1 + Controls[SourceIndex].ActualWidth();
	sY1 = Controls[SourceIndex].ActualTop();
    sY2 = sY1 + Controls[SourceIndex].ActualHeight();

	tX1 = Controls[TargetIndex].ActualLeft();
    tX2 = tX1 + Controls[TargetIndex].ActualWidth();
	tY1 = Controls[TargetIndex].ActualTop();
    tY2 = tY1 + Controls[TargetIndex].ActualHeight();

    switch (mode)
    {
    	case 0 :	// Up
        	return (tY2 <= sY1);
            break;
        case 1 :	// Down
        	return (tY1 >= sY2);
            break;

        case 2 : 	// Left
        	return (tX2 <= sX1);
            break;
        case 3 :	// Right
        	return (tX1 >= sX2);
            break;
	}

    return false;
}


function MapControls()
{
	local int c,i,p;
    local float cd,dist;
    local GUIComponent Closest;

	// reset the link table first!
	for (c=0;c<Controls.Length;c++)
    {
	    for (p=0;p<4;p++)
	    {
	        Controls[c].Links[p] = None;
		}
	}

    for (c=0;c<Controls.Length;c++)
    {
    	if (!Controls[c].bNeverFocus || !Controls[c].bVisible)
        {

	        for (p=0;p<4;p++)
	        {
	            Closest = none;
	            if (Controls[c].LinkOverrides[p]!=None)
	                Controls[c].Links[p] = Controls[c].LinkOverrides[p];
	            else
	            {
	                for (i=0;i<Controls.Length;i++)
	                    if ( TestControls(p,c,i) )
	                    {
	                        dist = FindDist(Controls[c],Controls[i]);
	                        if ( (Closest == None) || (dist < cd) )
	                        {
	                            Closest = Controls[i];
	                            cd = dist;
	                        }
	                    }
	                Controls[c].Links[p] = Closest;
	            }
	        }
        }
    }
}


// RemapComponents - This sets the tab order for all the components on this page
event RemapComponents()
{
	local int i,j;

// Remove from 0 instead of 1, in case control was removed, and that control was components[0]
// Otherwise, get access nones
	if (Components.Length>0)
	 	Components.Remove(0,Components.Length);	// Clear the Component Array

	for (i=0;i<Controls.Length;i++)
    {
    	if (Controls[i].bTabStop)
        {
        	for (j=0;j<Components.Length;j++)
            	if ( Controls[i].TabOrder <= Components[j].TabOrder )
                    break;

			if (j < Components.Length)
				Components.Insert(j, 1);

			Components[j] = Controls[i];
         }
    }
}

event SetFocus(GUIComponent Who)
{
	if (Who==None)
	{
		FocusFirst(None);
		return;
	}
	else
	{
		FocusedControl = Who;
	}
	
	MenuStateChange(MSAT_Focused);

	if (MenuOwner!=None)
		MenuOwner.SetFocus(self);
}

event LoseFocus(GUIComponent Sender)
{
	FocusedControl = None;
	Super.LoseFocus(Sender);
}


event bool FocusFirst(GUIComponent Sender)
{
    local int i;

	if (Components.Length>0)
	{
    	for (i=0;i<Components.Length;i++)
        {
        	if (!Components[i].bNeverFocus && Components[i].bVisible && Components[i].MenuState != MSAT_Disabled)
            {
		  		Components[i].SetFocus(None);
				return true;
            }
        }
    }

	for (i=0;i<Controls.Length;i++)
    {
    	if ( Controls[i].FocusFirst(Sender) )
		{
        	return true;
		}
    }

    return false;
}


event bool FocusLast(GUIComponent Sender)
{
	local int i;

	if (Components.Length>0)
	{
    	for (i=Components.Length-1;i>=0;i--)
        {
        	if (!Components[i].bNeverFocus && Components[i].bVisible && Components[i].MenuState != MSAT_Disabled)
            {
				Components[i].SetFocus(None);
				return true;
            }
        }
	}

	for (i=Controls.Length-1;i>=0;i--)
    {
    	if ( Controls[i].FocusLast(Sender) )
        	return true;
    }

    return false;

}

event bool NextControl(GUIComponent Sender)
{
	local int Index;

	Index = FindComponentIndex(Sender);

    if (Index==-1)
    {
    	if ( Super.NextControl(Self) )
        	return true;
        else
	    	return FocusFirst(none);
    }

    Index++;
	if(!Components[Index].bVisible)
		Index++; //NAC: This component is not visible, so I should not move here!

    // Find the next possible component
    while (Index<Components.Length)
    {
    	if (Components[Index].MenuState!=MSAT_Disabled && Components[Index].bVisible)
    	{
        	Components[Index].SetFocus(None);
        	return true;
        }

    	Index++;
    }

   	if ( Super.NextControl(self) )
       	return true;
    else
       	return FocusFirst(none);
}

event bool PrevControl(GUIComponent Sender)
{

	local int Index;

	Index = FindComponentIndex(Sender);

    if (Index==-1)
    {
    	if ( Super.PRevControl(Self) )
        	return true;
        else
	    	return FocusLast(none);
	}

    Index--;

	if(!Components[Index].bVisible)
		Index--; //NAC: This component is not visible, so I should not move here!
	

    while (Index>=0)
    {
    	if (Components[Index].bVisible && (Components[Index].MenuState!=MSAT_Disabled))
        {
        	Components[Index].SetFocus(None);
            return true;
        }

        Index--;
    }

    if ( Super.PrevControl(self) )
       	return true;
    else
       	return FocusLast(none);

}

function string LoadINI()
{
	local int i;

	for (i=0;i<Controls.Length;i++)
		Controls[i].LoadINI();

	return Super.LoadINI();
}

function SaveINI(string Value)
{
	local int i;

	for (i=0;i<Controls.Length;i++)
		Controls[i].SaveINI("");

	Super.SaveINI(Value);

	return;
}

event MenuStateChange(eMenuState Newstate)
{
	local int i;

	// if we're disabled, force the state to disabled
	if (bDisabled)
		Newstate = MSAT_Disabled;

	if (NewState==MSAT_Disabled)
	{
		for (i=0;i<Controls.Length;i++)
			Controls[i].MenuStateChange(MSAT_Disabled);
	}
	else
	{
		for (i=0;i<Controls.Length;i++)
			if (Controls[i].MenuState==MSAT_Disabled)
				Controls[i].MenuStateChange(MSAT_Blurry);
	}

	Super.MenuStateChange(NewState);
}

event SetVisibility(bool bIsVisible)
{
	local int i;

	Super.SetVisibility(bIsVisible);

    if ( !PropagateVisibility )
    	return;

    for (i=0;i<Controls.Length;i++)
    	Controls[i].SetVisibility(bIsVisible);
}

event Opened(GUIComponent Sender)
{
	local int i;

    for (i=0;i<Controls.Length;i++)
    	Controls[i].Opened(Sender);
}

event Closed(GUIComponent Sender, bool bCancelled)
{
	local int i;

    for (i=0;i<Controls.Length;i++)
    	Controls[i].Closed(Sender, bCancelled);
}

event Free() 			// This control is no longer needed
{
	local int i;

    for (i=0;i<Controls.Length;i++)
    {
    	Controls[i].Free();
        Controls[i] = None;
    }

    for (i=0;i<Components.Length;i++)
    	Components[i] = None;

	Controls.Length = 0;
	Components.Length = 0;

	FocusedControl = None;
    Super.Free();
}

defaultproperties
{
	bTabStop=true
    PropagateVisibility=false;
	bPlayFocusSound=false
}// ====================================================================
//	Class: GUI. UT2NumericEdit
//
//  A Combination of an EditBox and 2 spinners
//
//  Written by Joe Wilcox
//  (c) 2002, Epic Games, Inc.  All Rights Reserved
// ====================================================================

class GUINumericEdit extends GUIMultiComponent
	Native;

cpptext
{
		void Draw(UCanvas* Canvas);
}

var Automated GUIEditBox MyEditBox;
var Automated GUISpinnerButton MyPlus;
var Automated GUISpinnerButton MyMinus;

var(Menu)	string				Value;
var(Menu)	bool				bLeftJustified;
var(Menu)	int					MinValue;
var(Menu)	int					MaxValue;
var(Menu)	int					Step;


function InitComponent(GUIController MyController, GUIComponent MyOwner)
{

	Super.Initcomponent(MyController, MyOwner);

	MyEditBox.OnChange = EditOnChange;
	MyEditBox.SetText(Value);
	MyEditBox.OnKeyEvent = EditKeyEvent;

	CalcMaxLen();

	MyPlus.OnClick = SpinnerPlusClick;
	MyPlus.FocusInstead = MyEditBox;
	MyMinus.OnClick = SpinnerMinusClick;
	MyMinus.FocusInstead = MyEditBox;

    SetHint(Hint);

}

function CalcMaxLen()
{
	local int digitcount,x;

	digitcount=1;
	x=10;
	while (x<MaxValue)
	{
		digitcount++;
		x*=10;
	}

	MyEditBox.MaxWidth = DigitCount;
}
function SetValue(int V)
{
	if (v<MinValue)
		v=MinValue;

	if (v>MaxValue)
		v=MaxValue;

	MyEditBox.SetText(""$v);
}

function bool SpinnerPlusClick(GUIComponent Sender)
{
	local int v;

	v = int(Value) + Step;
	if (v>MaxValue)
	  v = MaxValue;

	MyEditBox.SetText(""$v);
	return true;
}

function bool SpinnerMinusClick(GUIComponent Sender)
{
	local int v;

	v = int(Value) - Step;
	if (v<MinValue)
		v=MinValue;

	MyEditBox.SetText(""$v);
	return true;
}

function bool EditKeyEvent(out byte Key, out byte State, float delta)
{
	if ( (key==0xEC) && (State==3) )
	{
		SpinnerPlusClick(none);
		return true;
	}

	if ( (key==0xED) && (State==3) )
	{
		SpinnerMinusClick(none);
		return true;
	}

	return MyEditBox.InternalOnKeyEvent(Key,State,Delta);
}

function EditOnChange(GUIComponent Sender)
{
	Value = MyEditBox.TextStr;
    OnChange(Sender);
}

function SetHint(string NewHint)
{
	local int i;
	Super.SetHint(NewHint);

    for (i=0;i<Controls.Length;i++)
    	Controls[i].SetHint(NewHint);
}


defaultproperties
{
	Begin Object Class=GUIEditBox Name=cMyEditBox
		TextStr=""
		bIntOnly=true
	End Object
	Begin Object Class=GUISpinnerButton Name=cMyPlus
		PlusButton=true
	End Object
	Begin Object Class=GUISpinnerButton Name=cMyMinus
		PlusButton=false
	End Object

	MyEditBox=cMyEditBox
	MyPlus=cMyPlus
	MyMinus=cMyMinus

	Value="0"
	Step=1
	bAcceptsInput=true;
	bLeftJustified=false;
	WinHeight=0.06
	PropagateVisibility=true

}// ====================================================================
//  Class:  GUI.GUIPage
//
//	GUIPages are the base for a full page menu.  They contain the
//	Control stack for the page.
//
//  Written by Joe Wilcox
//  (c) 2002, Epic Games, Inc.  All Rights Reserved
// ====================================================================

class GUIPage extends GUIMultiComponent
	Native 	Abstract;

cpptext
{
		void Draw(UCanvas* Canvas);
		void PreDraw(UCanvas* Canvas);
		UBOOL NativeKeyEvent(BYTE& iKey, BYTE& State, FLOAT Delta );
		void UpdateTimers(float DeltaTime);
		UBOOL PerformHitTest(INT MouseX, INT MouseY);
		UBOOL MousePressed(UBOOL IsRepeat);					// The Mouse was pressed
		UBOOL MouseReleased();								// The Mouse was released

        UBOOL XControllerEvent(int Id, eXControllerCodes iCode);

}

// Variables

var(Menu)   					Material				Background;			// The background image for the menu
var(Menu)						Color					BackgroundColor;	// The color of the background
var(Menu)						Color					InactiveFadeColor;	// Color Modulation for Inactive Page
var(Menu)						EMenuRenderStyle		BackgroundRStyle;
var(Menu)						bool					bRenderWorld;		// Should this menu hide the world
var(Menu)						bool					bPauseIfPossible;	// Should this menu pause the game if possible
var(Menu)						bool					bCheckResolution;	// If true, the menu will be force to run at least 640x480
var(Menu)						bool					bHandledPreDraw;	// sanity check to make sure predraw was called before draw.

var								bool					bHideParent;		// When shown, hides/shows the topmost page when shown/hidden.
var								bool					bRequireFullScreen;	// toggles FULLSCREENVIEWPORT on entry/exit if bAllowedAsLast is set
var								bool					bRequire640x480;	// Does this menu require at least 640x480
var								bool					bPersistent;		// If set in defprops, page is saved across open/close/reopen.

var								GUIPage					ParentPage;			// The page that exists before this one
var	const						array<GUIComponent>		Timers;				// List of components with Active Timers
var 							bool					bAllowedAsLast;		// If this is true, closing this page will not bring up the main menu
																			// if last on the stack.

var								byte					bTopMost;			// before prerender, if there are non-topmost screens on top, this screen bubbles to the top higher = higher pri
var								bool					bCloseNonTopMost;	// close all non-topmost screens when this screen is opened
var								bool					bDisconnectOnOpen;	// Should this menu for a disconnect when opened.
var								bool					bMergeAStart;		// Should xbox input Start and A both result in Start?
var								bool					bMergeBBack;		// Should xbox input Back and B both result in Back?
var								bool					bMergeAxesToPads;	// Should xbox axial input generate pad messages?
var								bool					bPortLockedOnly;	// Only allow input from port-locked controllers?

// -1 for any controller
// -2 for automatic...once open, only responds to opening controller
// -3 inherit from previous page
// 0 = keyboard/controller0
// 1 = controller1 ...
var								int						PagePlayerIndex;

var								string					LParam1, LParam2;	// launch parameter strings

var								GUIComponent			ReturnComponent;	// component to return to after opening

native function InitExecution();

native function String GetTouLine(bool bReset);

// Delegates

delegate OnOpen()
{
	PageLoadINI();
}

delegate bool OnCanClose(optional Bool bCancelled)
{
	return true;
}

delegate OnClose(optional Bool bCancelled)
{
	if (!bCancelled)
		PageSaveINI();
}

function OnChat(PlayerReplicationInfo ChattingPRI, string Message);

event Opened(GUIComponent Sender)
{
	Super.Opened(Sender);
    OnOpen();
}

// a screen was opened above me!
function OpenedChild(GUIPage child);

event Closed(GUIComponent Sender, bool bCancelled)
{
	Super.Closed(Sender, bCancelled);
    OnClose(bCancelled);
}

function ResetFocus()
{
	bPlayFocusSound = false;

	if (ReturnComponent != None)
		ReturnComponent.SetFocus(None);
	else
		FocusFirst(None);

	bPlayFocusSound = true;
}

function PageLoadINI()
{
	local int i;

	for (i=0;i<Controls.Length;i++)
		Controls[i].LoadINI();

	return;
}

function PageSaveINI()
{
	local int i;

	for (i=0;i<Controls.Length;i++)
		Controls[i].SaveINI("");
}

//=================================================
// InitComponent is responsible for initializing all components on the page.

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.Initcomponent(MyController, MyOwner);

	MapControls();		// Figure out links

    FocusFirst(none);

	ReturnComponent = None;
}

//=================================================
// CheckResolution - Tests to see if this menu requires a resoltuion of at least 640x480 and if so, switches

function CheckResolution(bool Closing)
{
	local string CurrentRes;
	local int I,X,Y;

	if (!Closing)
	{
		CurrentRes = PlayerOwner().ConsoleCommand( "GETCURRENTRES" );
	    I = InStr( CurrentRes, "x" );
	    if( i > 0 )
	    {
			X = int( Left ( CurrentRes, i )  );
			Y = int( Mid( CurrentRes, i+1 ) );
	    }
		else
		{
			log("Couldn't parse GetCurrentRes call");
			return;
		}
		if ( ( (x<640) || (y<480) ) && (bRequire640x480) )
		{
			Controller.GameResolution = CurrentRes;
			PlayerOwner().ConsoleCommand("TEMPSETRES 640x480");
		}

		return;

	}

	if ( (bRequire640x480) || (Controller.GameResolution=="") )
		return;

	CurrentRes = PlayerOwner().ConsoleCommand( "GETCURRENTRES" );
	if (CurrentRes != Controller.GameResolution)
	{
		PlayerOwner().Player.Console.ConsoleCommand("SETRES"@Controller.GameResolution);
		Controller.GameResolution = "";
	}

}

event ChangeHint(string NewHint)
{
	Hint = NewHint;
}

event MenuStateChange(eMenuState Newstate)
{
	Super(GUIComponent).MenuStateChange(NewState);	// Skip the Multicomp's state change
}

event SetFocus(GUIComponent Who)
{
	if (Who==None)
	{
		return;
	}
	else
	{
		// don't play the click sound focusing the first control on the page...
		if (bPlayFocusSound && (FocusedControl != Who))
		{
			Controller.PlayClickSound(EClickSound.CS_Focus);
		}
	}

	bPlayFocusSound = true;
	ReturnComponent = Who;
	Super.SetFocus(Who);
}

event HandleParameters(string Param1, string Param2)	// Should be subclassed
{
	LParam1 = Param1;
	LParam2 = Param2;
}

event NotifyLevelChange();

event Free() 			// This control is no longer needed
{
	local int i;
    for (i=0;i<Timers.Length;i++)
    	Timers[i]=None;

// while correct, this is very bad if a screen kills itself while in its timer func...
//	Timers.Length = 0;

    Super.Free();
}

function bool IsTopMost()
{
	return bTopMost > 0;
}

function bool ShouldShowControllerInfo(int inPlayerIndex)
{
	return false;
}

function int GetControllerInfoIndex(int inPlayerIndex)
{
	return -1;
}

event int GetControllerIndex()
{
	if (PagePlayerIndex < 0)
		return -1;

	return Controller.GetControllerIndexForPlayer(PagePlayerIndex);
}

event bool AllowControllerInput(int inControllerIndex)
{
	if (PagePlayerIndex == -1)
	{
		if ( bPortLockedOnly && ((Controller.CurrentControllers[0] != -1) || (Controller.CurrentControllers[1] != -1)) )
			return Controller.FindPlayerForControllerIndex(inControllerIndex) != -1;

		return true;
	}
	else
	{
		return inControllerIndex == GetControllerIndex();
	}
}

static function PreloadMenu(GUIController C);

defaultproperties
{
	ReturnComponent=None
	bAcceptsInput=true
	InactiveFadeColor=(R=128,G=128,B=128,A=255)
	BackgroundColor=(R=255,G=255,B=255,A=255)
	BackgroundRStyle=MSTY_Normal
	bRequire640x480=false
	bPersistent=false
    bTabStop=false

	bRequireFullScreen=false
	PagePlayerIndex=-1
	bHideParent=false
	bHandledPreDraw=false

	bMergeAStart=true
	bMergeBBack=true
	bMergeAxesToPads=true
	bTopMost=0
	bCloseNonTopMost=false
	bPortLockedOnly=false
}// ====================================================================
//  Class:  GUI.GUIPanel
//
//  The GUI panel is a visual control that holds components.  All
//  components who are children of the GUIPanel are bound to the panel
//  by default.
//
//  Written by Joe Wilcox
//  (c) 2002, Epic Games, Inc.  All Rights Reserved
// ====================================================================

class GUIPanel extends GUIMultiComponent
	Native;

cpptext
{
		void Draw(UCanvas* Canvas);
		UBOOL PerformHitTest(INT MouseX, INT MouseY);

}

var(Menu)	Material	Background;

var			bool		bForceBindToParent;
var			bool		bForceScaleToParent;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	local int i;

	Super.Initcomponent(MyController, MyOwner);

	for (i=0;i<Controls.length;i++)
	{
		if (bForceBindToParent) Controls[i].bBoundToParent=true;
		if (bForceScaleToParent) Controls[i].bScaleToParent=true;
	}

    MapControls();

}

event MenuStateChange(eMenuState Newstate)
{
	Super(GUIComponent).MenuStateChange(NewState);	// Skip the Multicomp's state change
}


defaultproperties
{
	PropagateVisibility=True
	bTabStop=False
	bForceBindToParent=true
	bForceScaleToParent=true
}// ====================================================================
//  Class:  GUI.GUIPasswordBox
//
//	GUIPasswordBox - The basic text edit control.  I've merged Normal
//  edit, restricted edit, numeric edit and password edit in to 1 control.
//
//  Written by Joe Wilcox
//  (c) 2002, Epic Games, Inc.  All Rights Reserved
// ====================================================================

class GUIPasswordBox extends GUIEditBox
		Native;

cpptext
{
	virtual UBOOL NativeKeyType(BYTE& iKey, TCHAR Unicode );
	virtual UBOOL NativeKeyEvent(BYTE& iKey, BYTE& State, FLOAT Delta);
	TCHAR mPassword[17];
	int mPasswordLen;
}


native function Initialize();
native function HandleBackspace(bool allSelected);
native function string GetPassword();
native function SetPassword(string password);
native function bool IsPasswordValidLength(int minLen, int maxLen);
native function bool DoesPasswordContainUserName(string userName);
native function bool DoesPasswordContainLetterAndNumber();


function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Initialize();

	Super.InitComponent(MyController, MyOwner);
	bAllSelected = false;
}

function bool InternalOnKeyType(out byte Key, optional string Unicode)
{
	local string st;

	if (bReadOnly)
		return false;

	if (UniCode!="")
		st = Unicode;
	else
		st = chr(Key);

	// Handle cut/paste/copy keys
	if (key<32)
    {
		return true;
	}

	AddChar(st);

	return false;
}

function bool InternalOnKeyEvent(out byte Key, out byte State, float delta)
{
	if (bReadOnly)
		return false;

	if( (Key==8) && (State==1) ) // Process Backspace
	{
		HandleBackspace(bAllSelected);
		DoBackspace();
		return true;
	}

	return false;
}

event SetTextFromNative(string text)
{
	SetText(text);
	bAllSelected = false;
}

defaultproperties
{
}class GUIProgressBar extends GUIComponent
	Native;

cpptext
{
	void Draw(UCanvas* Canvas);
}

var Material	BarBack;		// The unselected portion of the bar
var Material	BarTop;			// The selected portion of the bar
var Color		BarColor;		// The Color of the Bar
var float		Low;			// The minimum value we should see
var float		High;			// The maximum value we should see
var float		Value;			// The current value (not clamped)

var float		CaptionWidth;	// The space reserved to the Caption
var eTextAlign	CaptionAlign;	// How align the text
var eTextAlign	ValueRightAlign;	//
var localized string Caption;	// The Caption itself
var string		FontName;		// Which font to use for display
var string		ValueFontName;	// Font to use for displaying values, use FontName if ValueFontName==""

var float	GraphicMargin;		// How Much margin to trim from graphic (X Margin only)
var float	ValueRightWidth;	// Space to leave free on right side
var bool	bShowLow;			// Show Low(Minimum) left of Bar
var bool	bShowHigh;			// Show High (Maximum) right of Bar
var bool	bShowValue;			// Show the value right of the Bar (like 75 or 75/100)
var int		NumDecimals;		// Number of decimals to display

defaultproperties
{
// GBX:CEK: 3/16/2004 - TEMP GUI REINTEGRATION
	BarBack=Texture'WhiteTexture'
	BarTop=Texture'WhiteTexture'
//	BarBack=Material'GUIContent.Menu.BorderBoxD'
//	BarTop=Material'GUIContent.Menu.StatusBarInner'
	BarColor=(R=255,G=203,B=0,A=255)
	Low=0.0
	High=100.0
	Value=0.0
	bShowLow=false
	bShowHigh=false
	bShowValue=true
	CaptionWidth=0.45
	ValueRightWidth=0.2
	ValueRightAlign=TXTA_Right
	NumDecimals=0
	FontName="SmallFont"
}// ====================================================================
//  Class:  GUI.GUIScrollBarBase
//  Parent: GUI.GUIMultiComponent
//
//  <Enter a description here>
// ====================================================================

class GUIScrollBarBase extends GUIMultiComponent
		Native;

var		GUIListBase		MyList;			// The list this Scrollbar is attached to

function UpdateGripPosition(float NewPos);
function MoveGripBy(int items);
event AlignThumb();

function Refocus(GUIComponent Who)
{
	local int i;
	
	if (Who != None && Controls.Length > 0)
		for (i=0;i<Controls.Length;i++)
	    {
	    	Controls[i].FocusInstead = Who;
	        Controls[i].bNeverFocus=true;
	    }
}

defaultproperties
{
	bTabStop=false
	PropagateVisibility=true

}class GUIScrollText extends GUIList
	native;

cpptext
{
	void PreDraw(UCanvas *Canvas);
	void Draw(UCanvas* Canvas);	
	void DrawItem(UCanvas* Canvas, INT Item, FLOAT X, FLOAT Y, FLOAT W, FLOAT H);
}

enum eScrollState
{
	STS_None,
	STS_Initial,
	STS_Char,
	STS_EOL,
	STS_Repeat,
};

// Private set of vars
var protected string	Content;		// This is the content to display in 1 single string
var string				Separator;		// Separator to use
var protected int		VisibleLines;	// This is the number of visible lines
var protected int		VisibleChars;	// How Many chars in the last displayed line are visible
var protected int		oldWidth;		// Last width of the diplay area
var protected eScrollState ScrollState;	// What was the last action we did
var protected bool		bNewContent;	// This is set when new text content has been set for the control
var protected bool		bStopped;		// Tells when the sequence has stopped animating (can be rushed by clicking ?)
//var protected bool		bForceHideSB;	// Force Hide the scrollbar

var int		MaxHistory;		// Maximum number of rows. Only used in conjunction with NewText. 0 indicates no limit.
var string	NewText;		// New text to add the end of 
var string	ClickedString;	// Filled in (if bSelectText is true) when user clicks on a word

// Public set of vars
var bool	bRepeat;		// Should the sequence be repeated ?
var bool	bNoRepeatIfUnfilled;	// if true, bRepeat will not function if the list is not scrollable.
var bool    bNoTeletype;	// Dont do the teletyping effect at all
var bool	bNoTeletypeCursor;	// Do teletype but do not draw the flashy cursor.
var bool	bAutoFill;		// automatically fill up the text box if teletyping but the text will fit entirely in the box without scrolling.
var bool	bClickText;	    // Upon clicking on this text box, fill in ClickedString field
var float	InitialDelay;	// Initial delay after new content was set
var float	CharDelay;		// This is the delay between each char
var float	EOLDelay;		// This is the delay to use when reaching end of line
var float	RepeatDelay;	// This is used after all the text has been displayed and bRepeat is true

native final function string GetWordUnderCursor();

delegate OnEndOfLine();

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.Initcomponent(MyController, MyOwner);
	OnKeyType=InternalOnKeyType;
	OnKeyEvent=InternalOnKeyEvent;
	OnClick=InternalOnClick;

	if(bNoTeletype)
		EndScrolling();
}	
		
function SetContent(string NewContent, optional string sep)
{
	if (sep == "")
		Separator = default.Separator;
	else
		Separator = sep;

	Content = NewContent;

	bNewContent = true;
	Top = 0;

	if(bNoTeletype)
		EndScrolling();
	else
		Restart();
}

function Stop()
{
	bStopped = true;
	ScrollState = STS_None;
	TimerInterval = 0;
}

function Restart()
{
	VisibleLines = 0;
	VisibleChars = 0;
	if (InitialDelay <= 0.0)
	{
		ScrollState = STS_None;
		SetTimer(0.001, true);
	}
	else
	{
		ScrollState = STS_Initial;
		SetTimer(InitialDelay, true);
	}
	bStopped = false;
}

function bool SkipChar()
{
	if (ItemCount > 0 && !bStopped && VisibleLines >= 0 && VisibleLines < ItemCount)
	{
		if (VisibleChars == Len(Elements[VisibleLines].Item))
		{
			if (VisibleLines+1 < ItemCount)
			{
				VisibleLines++;
				VisibleChars = 0;
				TimerInterval = EOLDelay;
				ScrollState = STS_EOL;
				OnEndOfLine();
				return true;
			}
		}
		else
		{
			VisibleChars++;
			TimerInterval = CharDelay;
			ScrollState = STS_Char;
			return true;
		}
	}
	return false;
}

event Timer()
{
	if (ItemCount == 0)
	{
		if (!bNewContent)
			TimerInterval=0;
		return;
	}

	if (ScrollState == STS_Repeat)
	{
		Restart();
	}
	else if (ScrollState == STS_EOL)
	{
		if (!SkipChar())
		{
			if (bRepeat && (!bNoRepeatIfUnfilled || (ItemCount > ItemsPerPage)))
			{
				if (RepeatDelay > 0)
				{
					TimerInterval = RepeatDelay;
					ScrollState = STS_Repeat;
				}
				else
					Restart();
			}
			else
			{
				bStopped = true;
				ScrollState = STS_None;
				TimerInterval = 0;
			}
		}
	}
	else if (ScrollState == STS_None)
	{
		ScrollState = STS_Initial;
		SetTimer(CharDelay, true);
	}
	else
	{
		if (bAutoFill && !bNoTeletype && (ItemCount <= ItemsPerPage))
		{
			EndScrolling();
		}
		else if (!SkipChar())
		{
			ScrollState=STS_EOL;
			TimerInterval=EOLDelay;
			OnEndOfLine();
		}
	}
}

function bool InternalOnClick(GUIComponent Sender)
{
	local bool retval;

	if(bClickText)
	{
		ClickedString = GetWordUnderCursor();
		return true;
	}

	retval = Super.InternalOnClick(Sender);
	if (retval)
		EndScrolling();

	return retval;
}

function bool InternalOnKeyType(out byte Key, optional string Unicode)
{
local bool retval;

	retval = Super.InternalOnKeyType(Key, Unicode);
	if (retval)
		EndScrolling();

	return retval;
}

function bool InternalOnKeyEvent(out byte Key, out byte State, float delta)
{
local bool retval;

	retval = Super.InternalOnKeyEvent(Key, State, delta);
	if (retval)
		EndScrolling();

	return retval;
}

function EndScrolling()
{
	bStopped = true;
	if(MyScrollBar != None)
		MyScrollBar.AlignThumb();
	KillTimer();
}

function Up()
{
	if( MyScrollBar!=None && MyScrollBar.bVisible )	{
		Controller.PlayClickSound(EClickSound.CS_Change);
		GUIVertScrollBar(MyScrollBar).MoveGripBy(-1);
	}
	else {
		Super.Up();
	}
}

function Down()
{
	if( MyScrollBar!=None && MyScrollBar.bVisible ) {
		Controller.PlayClickSound(EClickSound.CS_Change);
		GUIVertScrollBar(MyScrollBar).MoveGripBy(1);
	}
	else {
		Super.Down();
	}
}

function PgUp()
{
	if( MyScrollBar!=None && MyScrollBar.bVisible ) {
		Controller.PlayClickSound(EClickSound.CS_Change);
		GUIVertScrollBar(MyScrollBar).MoveGripBy(-ItemsPerPage);
	}
	else {
		Super.PgUp();
	}
}

function PgDn()
{
	if( MyScrollBar!=None && MyScrollBar.bVisible )	{
		Controller.PlayClickSound(EClickSound.CS_Change);
		GUIVertScrollBar(MyScrollBar).MoveGripBy(ItemsPerPage);
	}
	else {
		Super.PgDn();
	}
}

defaultproperties
{
	ScrollState=STS_None
	Separator="|"
	TextAlign=TXTA_Left
	InitialDelay=0.0
	CharDelay=0.25
	EOLDelay=0.75
	RepeatDelay=3.0
	VisibleLines=-1
}
class GUIScrollTextBox extends GUIListBoxBase
	native;

var Automated GUIScrollText MyScrollText;

var bool			bRepeat;		// Should the sequence be repeated ?
var bool			bNoRepeatIfUnfilled;	// if true, bRepeat will not function if the list is not scrollable.
var bool			bNoTeletype;	// Dont do the teletyping effect at all
var bool			bNoTeletypeCursor;	// Do teletype but do not draw the flashy cursor.
var bool			bAutoFill;		// automatically fill up the text box if teletyping but the text will fit entirely in the box without scrolling.
var bool			bStripColors;	// Strip out IRC-style colour characters (^C)
var float			InitialDelay;	// Initial delay after new content was set
var float			CharDelay;		// This is the delay between each char
var float			EOLDelay;		// This is the delay to use when reaching end of line
var float			RepeatDelay;	// This is used after all the text has been displayed and bRepeat is true
var	eTextAlign		TextAlign;			// How is text Aligned in the control

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.Initcomponent(MyController, MyOwner);

    InitBaseList(MyScrollText);

   	MyScrollText.InitialDelay = InitialDelay;
	MyScrollText.CharDelay = CharDelay;
	MyScrollText.EOLDelay = EOLDelay;
	MyScrollText.RepeatDelay = RepeatDelay;
	MyScrollText.TextAlign = TextAlign;
	MyScrollText.bRepeat = bRepeat;
	MyScrollText.bNoRepeatIfUnfilled = bNoRepeatIfUnfilled;
	MyScrollText.bNoTeletype = bNoTeletype;
	MyScrollText.bNoTeletypeCursor = bNoTeletypeCursor;
	MyScrollText.OnADjustTop  = InternalOnAdjustTop;
	MyScrollText.bAutoFill = bAutoFill;
}

function SetContent(string NewContent, optional string sep)
{
	MyScrollText.SetContent(NewContent, sep);
}

function Restart()
{
	MyScrollText.Restart();
}

function Stop()
{
	MyScrollText.Stop();
}

function InternalOnAdjustTop(GUIComponent Sender)
{
	MyScrollText.EndScrolling();

}

function bool IsNumber(string Num)
{
	if( Num == Chr(48) ) return true; // character '0' etc..
	if( Num == Chr(49) ) return true;
	if( Num == Chr(50) ) return true;
	if( Num == Chr(51) ) return true;
	if( Num == Chr(52) ) return true;
	if( Num == Chr(53) ) return true;
	if( Num == Chr(54) ) return true;
	if( Num == Chr(55) ) return true;
	if( Num == Chr(56) ) return true;
	if( Num == Chr(57) ) return true;

	return false;
}

function string StripColors(string MyString)
{
	local int EscapePos, RemCount, LenFromEscape;

	EscapePos = InStr(MyString, Chr(3)); // Chr(3) == ^C
	while(EscapePos != -1)
	{
		LenFromEscape = Len(MyString) - (EscapePos + 1); // how far after the escape character the string goes on for

		// Now we have to work out how many characters follow the ^C and should be removed. This is rather unpleasant..!

		RemCount = 1; // strip the ctrl-C regardless
		if( LenFromEscape >= 1 && IsNumber(Mid(MyString, EscapePos+1, 1)) ) // If a digit follows the ctrl-C, strip that
		{
			RemCount = 2; // #
			if( LenFromEscape >= 3 && Mid(MyString, EscapePos+2, 1) == Chr(44) && IsNumber(Mid(MyString, EscapePos+3, 1)) ) // If we have a comma and another digit, strip those
			{
				RemCount = 4; // #,#
				if( LenFromEscape >= 4 && IsNumber(Mid(MyString, EscapePos+4, 1)) ) // if there is another digit after that, strip it
					RemCount = 5; // #,##
			}
			else if( LenFromEscape >= 2 && IsNumber(Mid(MyString, EscapePos+2, 1)) )// if there is a second digit, strip that
			{
				RemCount = 3; // ##
				if( LenFromEscape >= 4 && Mid(MyString, EscapePos+3, 1) == Chr(44) && IsNumber(Mid(MyString, EscapePos+4, 1)) ) // If we have a comma and another digit, strip those
				{
					RemCount = 5; // ##,#
					if( LenFromEscape >= 5 && IsNumber(Mid(MyString, EscapePos+5, 1)) ) // if there is another digit after that, strip it
						RemCount = 6; // ##,##
				}
			}
		}

		MyString = Left(MyString, EscapePos)$Mid(MyString, EscapePos+RemCount);

		EscapePos = InStr(MyString, Chr(3));
	}

	return MyString;
}

function AddText(string NewText)
{
	local string StrippedText;

	if(NewText == "")
		return;

	if(bStripColors)
		StrippedText = StripColors(NewText);
	else
		StrippedText = NewText;

	if(MyScrollText.NewText == "")
		MyScrollText.NewText = StrippedText;
	else
		MyScrollText.NewText = MyScrollText.NewText$MyScrollText.Separator$StrippedText;
}

defaultproperties
{
	Begin Object Class=GUIScrollText Name=TheText
	End Object

	MyScrollText=TheText

	TextAlign=TXTA_Left
	InitialDelay=0.0
	CharDelay=0.25
	EOLDelay=0.75
	RepeatDelay=3.0
}// ====================================================================
//  Class:  GUI.GUISlider
//
//  Written by Joe Wilcox
//  (c) 2002, Epic Games, Inc.  All Rights Reserved
// ====================================================================

class GUISlider extends GUIComponent
		Native;

cpptext
{
		void Draw(UCanvas* Canvas);
}

var(Menu)	float 		MinValue, MaxValue;
var(Menu)	string		CaptionStyleName;
var			float		Value;
var			float		Step;
var			GUIStyles	CaptionStyle;
var			bool		bIntSlider;

delegate string OnDrawCaption()
{
	if (bIntSlider)
		return "("$int(Value)$")";
	else
		return "("$Value$")";
}

function SetValue(float NewValue)
{
	if (NewValue<MinValue) NewValue=MinValue;
	if (NewValue>MaxValue) NewValue=MaxValue;

	if (bIntSlider)
		Value = int(NewValue);
	else
		Value = NewValue;
}

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.Initcomponent(MyController, MyOwner);
	OnCapturedMouseMove=InternalCapturedMouseMove;
	OnKeyEvent=InternalOnKeyEvent;
	OnClick=InternalOnClick;
	OnMousePressed=InternalOnMousePressed;
	OnXControllerEvent = InternalOnXControllerEvent;

	CaptionStyle = Controller.GetStyle(CaptionStyleName);
}


function bool InternalCapturedMouseMove(float deltaX, float deltaY)
{
	local float Perc, OldValue;

	OldValue = Value;

	if ( (Controller.MouseX >= Bounds[0]) && (Controller.MouseX<=Bounds[2]) )
	{
		Perc = ( Controller.MouseX - ActualLeft()) / ActualWidth();
		Perc = FClamp(Perc,0.0,1.0);
		Value = ( (MaxValue - MinValue) * Perc) + MinValue;
		if (bIntSlider)
			Value = int(Value);
	}
	else if (Controller.MouseX < Bounds[0])
		Value = MinValue;
	else if (Controller.MouseX > Bounds[2])
		Value = MaxValue;

	Value = FClamp(Value,MinValue,MaxValue);

	return true;
}

function bool InternalOnKeyEvent(out byte Key, out byte State, float delta)
{
	if ( (Key==0x25 || Key==0x64) && (State==1) )	// Left
	{
		if (bIntSlider)
			Adjust(-1);
		else
			Adjust(-0.01);
		return true;
	}

	if ( (Key==0x27 || Key==0x66) && (State==1) ) // Right
	{
		if (bIntSlider)
			Adjust(1);
		else
			Adjust(0.01);
		return true;
	}


	return false;
}

function bool InternalOnXControllerEvent(byte Id, eXControllerCodes iCode)
{
 	if (iCode == XC_Left || iCode == XC_PadLeft || iCode == XC_X)
    {
    	Adjust(Step*-1);
        return true;
    }

    else if (iCode == XC_Right || iCode == XC_PadRight || iCode == XC_Y)
    {
    	Adjust(Step);
        return true;
    }

    return false;

}


function Adjust(float amount)
{
	local float Perc;
	Perc = (Value-MinValue) / (MaxValue-MinValue);
	Perc += amount;
	Perc = FClamp(Perc,0.0,1.0);
	Value = ( (MaxValue - MinValue) * Perc) + MinValue;
	FClamp(Value,MinValue, MaxValue);
	OnChange(self);
}

function string LoadINI()
{	local string s;

	s = Super.LoadINI();
	if (s!="")
		Value = float(s);

	return s;
}

function SaveINI(string V)
{
	Super.SaveINI(""$V);
}

function bool InternalOnClick(GUIComponent Sender)
{
	OnChange(self);
	return true;
}

function InternalOnMousePressed(GUIComponent Sender,bool RepeatClick)
{
	InternalCapturedMouseMove(0,0);
}

defaultproperties
{
	StyleName="RoundButton"
	bAcceptsInput=true
	bCaptureMouse=True
	bNeverFocus=false;
	bTabStop=true
	WinHeight=0.03
	bRequireReleaseClick=true
	CaptionStyleName="SliderCaption"
	bIntSlider=false;
	OnClickSound=CS_Click
    Step=1;
}

class GUISpinListControl extends GUIMultiComponent
	Native;

cpptext
{
		void PreDraw(UCanvas* Canvas);
}

var Automated GUILabel				MyLabel;
var Automated GUIHorzScrollButton	MyLeftButton;
var Automated GUIHorzScrollButton	MyRightButton;


var array<GUIListElem>				Elements;
var			int						nCurrentIndex;
var(Menu)	bool					bWrap;


function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.Initcomponent(MyController, MyOwner);

	OnKeyEvent=InternalOnKeyEvent;
	OnXControllerEvent=InternalOnXControllerEvent;

	MyRightButton.OnClick = RightClick;
	MyRightButton.FocusInstead = MyLabel;
	MyLeftButton.OnClick = LeftClick;
	MyLeftButton.FocusInstead = MyLabel;

	MyLabel.bDrawToFit = true;

//    SetHint(Hint);
	SetIndex(-1);
}

// =======================================================================================================================================================
// List entry management
// =======================================================================================================================================================
function Add(string NewItem, optional Object obj, optional string Str)
{
	Elements.Length = Elements.Length+1;
	
	Elements[Elements.Length-1].Item=NewItem;
	Elements[Elements.Length-1].ExtraData=obj;
	Elements[Elements.Length-1].ExtraStrData=Str;

	if (Elements.Length == 1)
		SetIndex(0);
	else
		OnChange(self);
}

function Replace(int Index, string NewItem, optional Object obj, optional string Str)
{
	if ( (Index<0) || (Index>=Elements.Length) )
		Add(NewItem,Obj,Str);
	else
	{
		Elements[Index].Item = NewItem;
		Elements[Index].ExtraData = obj;
		Elements[Index].ExtraStrData = Str;
	}
}		

function Insert(int Index, string NewItem, optional Object obj, optional string Str)
{
	if ( (Index<0) || (Index>=Elements.Length) )
		Add(NewItem,Obj,Str);
	else
	{
		Elements.Insert(index,1);
		Elements[Index].Item=NewItem;
		Elements[Index].ExtraData=obj;
		Elements[Index].ExtraStrData=Str;

		OnChange(self);
	}
}	

function AddFromList(out array<string> newItems)
{
	local int i;

	for (i=0; i<newItems.Length; i++)
	{
		Add(newItems[i]);
	}
}

function AddFromLists(out array<string> newItems, out array<string> newStrs)
{
	local int i;
	local string newStr;

	for (i=0; i<newItems.Length; i++)
	{
		if (i < newStrs.Length)
			newStr = newStrs[i];
		else
			newStr = "";

		Add(newItems[i],, newStr);
	}
}

function Remove(int i, optional int Count)
{
	if (Count==0) Count=1;
	Elements.Remove(i, Count);
	SetIndex(0);
} 

function RemoveItem(string Item)
{
	local int i;

	// Work through array. If we find it, remove it (will reduce Elements.Length).
	// If we don't, move on to next one.
	i=0;
	while(i<Elements.Length)
	{
		if(Item ~= Elements[i].Item)
			Elements.Remove(i, 1);
		else
			i++;
	}

	SetIndex(0);
}

function Clear()
{
	Remove(0,Elements.Length);
}	

event Swap(int IndexA, int IndexB)
{
	local GUI.GUIListElem elem;

	if ( (IndexA<0) || (IndexA>=Elements.Length) || (IndexB<0) || (IndexB>=Elements.Length) )
		return;

	elem = Elements[IndexA];
	Elements[IndexA] = Elements[IndexB];
	Elements[IndexB] = elem;
	OnChange(self);
}
	
function int Find(string strFind, optional bool bInExtra)
{
	local int i, result;

	result = -1;
	if (bInExtra)
	{
		for (i=0; i<Elements.Length; i++)
		{
			if (Elements[i].ExtraStrData ~= strFind)
			{
				result = i;
				break;
			}
		}
	}
	else
	{
		for (i=0; i<Elements.Length; i++)
		{
			if (Elements[i].Item ~= strFind)
			{
				result = i;
				break;
			}
		}
	}

	return result;
}

// =======================================================================================================================================================
// Data/value access
// =======================================================================================================================================================
function int ItemCount()
{
	return Elements.Length;
}

function SetIndex(int newIndex)
{
	if (Elements.Length > 0)
	{
		nCurrentIndex = Clamp(newIndex, 0, Elements.Length-1);
		MyLabel.Caption = Elements[nCurrentIndex].Item;
	}
	else
	{
		nCurrentIndex = -1;
		MyLabel.Caption = "";
	}

	OnChange(self);
}

function int GetIndex()
{
	return nCurrentIndex;
}

function string Get()
{
	return GetAt(nCurrentIndex);
}

function string GetAt(int index)
{
	if ( (index<0) || (index>=Elements.Length) )
		return "";
	else
		return Elements[nCurrentIndex].Item;
}

function object GetObject()
{
	if ( (nCurrentIndex<0) || (nCurrentIndex>=Elements.Length) )
		return none;
	else
		return Elements[nCurrentIndex].ExtraData;
}	

function string GetExtra()
{
	if ( (nCurrentIndex<0) || (nCurrentIndex>=Elements.Length) )
		return "";
	else
		return Elements[nCurrentIndex].ExtraStrData;
}

function string GetExtraAtIndex(int index)
{
	if ( (index<0) || (index>=Elements.Length) )
		return "";
	else
		return Elements[index].ExtraStrData;
}

// =======================================================================================================================================================
// Input handling
// =======================================================================================================================================================
function SpinNext()
{
	local int index, max;

	index = nCurrentIndex;
	max = Elements.Length;

	index++;
	if (index >= max)
	{
		if (bWrap)
			index = 0;
		else
			index = max - 1;
	}

	Controller.PlayClickSound(EClickSound.CS_Change);
	SetIndex(index);
}

function SpinPrev()
{
	local int index;

	index = nCurrentIndex;

	index--;
	if (index < 0)
	{
		if (bWrap)
			index = Elements.Length - 1;
		else
			index = 0;
	}

	Controller.PlayClickSound(EClickSound.CS_Change);
	SetIndex(index);
}

function bool LeftClick(GUIComponent Sender)
{
	SpinPrev();
	return true;
}

function bool RightClick(GUIComponent Sender)
{
	SpinNext();
	return true;
}

function bool InternalOnKeyEvent(out byte Key, out byte State, float delta)
{
	if (Elements.Length ==0) return false;

	if ( (Key==0x25 || Key==0x64) && (State==1) )	// Left Arrow
	{
		SpinPrev();
		return true;
	}
	else if ( (Key==0x27 || Key==0x66) && (State==1) ) // Right Arrow
	{
		SpinNext();
		return true;
	}
	else if ( (Key==0x24 || Key==0x67) && (State==1) ) // Home
	{
		Controller.PlayClickSound(EClickSound.CS_Change);
		SetIndex(0);
		return true;
	}
	
	if ( (Key==0x23 || Key==0x61) && (State==1) ) // End
	{
		SetIndex(Elements.Length - 1);
		return true;
	}

	if ( (key==0xEC) && (State==3) )	// Wheel Up
	{
		SpinNext();
		return true;
	}

	if ( (key==0xED) && (State==3) )	// Wheel Down
	{
		SpinPrev();
		return true;
	}

	return false;
}

function bool InternalOnXControllerEvent(byte Id, eXControllerCodes iCode)
{
	if (Elements.Length ==0) return false;

	if (iCode==XC_Left || iCode==XC_PadLeft)
    {
    	SpinPrev();
        return true;
    }
    else if (iCode==XC_Right || iCode==XC_PadRight)
    {
    	SpinNext();
        return true;
    }
    else if (iCode==XC_Black)
    {
		Controller.PlayClickSound(EClickSound.CS_Change);
		SetIndex(0);
        return true;
    }
    else if (iCode==XC_White)
    {
		Controller.PlayClickSound(EClickSound.CS_Change);
		SetIndex(Elements.Length - 1);
        return true;
    }

	return false;
}

function SetHint(string NewHint)
{
	local int i;
	Super.SetHint(NewHint);

    for (i=0;i<Controls.Length;i++)
    	Controls[i].SetHint(NewHint);
}

defaultproperties
{
	StyleName="SquareBar"

	Begin Object Class=GUILabel Name=cMySpinLabel
		TextAlign=TXTA_Center
		bTransparent=false
		StyleName="MenuOptionLabel"
		Caption=""
		bAcceptsInput=true
		bTabStop=true
	End Object
	Begin Object Class=GUIHorzScrollButton Name=cMyRight
		LeftButton=false
	End Object
	Begin Object Class=GUIHorzScrollButton Name=cMyLeft
		LeftButton=true
	End Object

	MyLabel=cMySpinLabel
	MyRightButton=cMyRight
	MyLeftButton=cMyLeft

	bAcceptsInput=true;
	WinHeight=0.06
	PropagateVisibility=true

	nCurrentIndex=-1
	bWrap=true
}// ====================================================================
//  Class:  GUI.UT2SpinnerButton
//
//  Written by Joe Wilcox
//  (c) 2002, Epic Games, Inc.  All Rights Reserved
// ====================================================================

class GUISpinnerButton extends GUIGFXButton
	Native;

var(Menu)	bool	PlusButton;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.Initcomponent(MyController, MyOwner);

	if (PlusButton)
	{
		U=334;
		V=144;
		UL=23;
		VL=31;
	}
	else
	{
		U=334;
		V=113;
		UL=23;
		VL=31;
	}
}


defaultproperties
{
	Graphic=Material't_interface_mb.hud.chapters_comp'
	StyleName="RoundScaledButton"
	PlusButton=false
	Position=ICP_Normal
	bNeverFocus=true
	bRepeatClick=true
	bCaptureMouse=true
}
// ====================================================================
//  Class:  GUI.GUISplitter
//
//	GUISplitters allow the user to size two other controls (usually Panels)
//
//  Written by Jack Porter
//  (c) 2002, Epic Games, Inc.  All Rights Reserved
// ====================================================================
class GUISplitter extends GUIPanel
	native;

cpptext
{
		void PreDraw(UCanvas* Canvas);
		void Draw(UCanvas* Canvas);
		UBOOL MouseMove(INT XDelta, INT YDelta);
		UBOOL MousePressed(UBOOL IsRepeat);
        UBOOL MouseReleased();
		UBOOL MouseHover();
		void SplitterUpdatePositions();
}

enum EGUISplitterType
{
	SPLIT_Vertical,
	SPLIT_Horizontal,
};

var(Menu)			EGUISplitterType	SplitOrientation;
var(Menu)			float				SplitPosition;			// 0.0 - 1.0
var					bool				bFixedSplitter;			// Can splitter be moved?
var					bool				bDrawSplitter;			// Draw the actual splitter bar
var					float				SplitAreaSize;			// size of splitter thing

var					string				DefaultPanels[2];		// Names of the default panels
var					GUIComponent		Panels[2];				// Quick Reference
var					float				MinPercentage;			// How big can any 1 panel get
var					float				MaxPercentage;			// How big can any 1 panel get

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	local float f;
	Super.Initcomponent(MyController, MyOwner);

    if (DefaultPanels[0]!="")
	{
		Panels[0] = AddComponent(DefaultPanels[0]);
		if (DefaultPanels[1]!="")
		    Panels[1] = Addcomponent(DefaultPanels[1]);
    }

	if (MaxPercentage < MinPercentage)
	{
		f = MaxPercentage;
		MaxPercentage = MinPercentage;
		MinPercentage = f;
	}

	if ((Maxpercentage > 0) && (MinPercentage <= 0))
	{
		MinPercentage = 1.0 - MaxPercentage;
	}
	else if ((MinPercentage > 0) && (MaxPercentage <= 0))
	{
		MaxPercentage = 1.0 - MinPercentage;
	}

	if (SplitPosition < MinPercentage) SplitPosition = MinPercentage;
	else if (SplitPosition > MaxPercentage) SplitPosition = MaxPercentage;

	SplitterUpdatePositions();
}

event GUIComponent AppendComponent(GUIComponent NewComp)
{
    Controls[Controls.Length] = NewComp;

    NewComp.InitComponent(Controller, Self);
	NewComp.bBoundToParent = true;
    NewComp.bScaleToParent = true;
    RemapComponents();
    return NewComp;
}

native function SplitterUpdatePositions();

defaultproperties
{
	StyleName="SquareButton"
	SplitOrientation=SPLIT_Vertical
	bCaptureTabs=False
	bNeverFocus=True
	bTabStop=False
	bAcceptsInput=True
	SplitPosition=0.5
	SplitAreaSize=8
	bDrawSplitter=True
	bBoundToParent=True
	bScaleToParent=True
	MaxPercentage=0.0
	MinPercentage=0.0
}// ====================================================================
//  Class:  GUI.GUIStyles
//
//	The GUIStyle is an object that is used to describe common visible
//  components of the interface.
//
//  Written by Joe Wilcox
//  (c) 2002, Epic Games, Inc.  All Rights Reserved
// ====================================================================

class GUIStyles extends GUI
	Native;

cpptext
{
		void Draw(UCanvas* Canvas, BYTE MenuState, FLOAT Left, FLOAT Top, FLOAT Width, FLOAT Height);
		void DrawText(UCanvas* Canvas, BYTE MenuState, FLOAT Left, FLOAT Top, FLOAT Width, FLOAT Height, BYTE Just, const TCHAR* Text, UBOOL bMultiLine=false, BYTE JustV=TXTA_Left, BYTE pulseStyle=CPS_None);
		void DrawTextToFit(UCanvas* Canvas, BYTE MenuState, FLOAT Left, FLOAT Top, FLOAT Width, FLOAT Height, BYTE Just, const TCHAR* Text, BYTE pulseStyle=CPS_None);
		void TextSize(UCanvas* Canvas, BYTE MenuState, const TCHAR* Test, INT& XL, INT& YL);
}

// note with ImageIcons:
// We're hijacking Pivot for the border edge size and Scale for the tile scaling when using ISTY_TileTiled

var		string				KeyName;			// This is the name of the style used for lookup
var		Canvas.CanvasIcon	ImageIcons[5];		// This array holds 1 material for each state (Blurry, Watched, Focused, Pressed, Disabled)
var		EMenuRenderStyle	RStyles[5];			// The render styles for each state
var		eImgStyle			ImgStyle[5];		// How should each image for each state be drawed
var		eImgAlign			ImageAlign[5];		// If ISTY_Justified or ISTY_Normal, how should image be aligned
var		Color				FontColors[5];		// This array holds 1 font color for each state
var		GUIFont				Fonts[5];			// Holds the fonts for each state
var		int					BorderOffsets[4];	// How thick is the border
var		string				FontNames[5];		// Holds the names of the 5 fonts to use

// dropshadow
var		Color				FontShadowColor;
var		EMenuRenderStyle	FontShadowRStyle;

// glowy thingy
var		Color				FontGlowColors[5];
var		EMenuRenderStyle	FontGlowRStyles[5];

// Set by Controller
var	bool					bRegistered;		// Used as Default only. Tells if Controller has this style registered.

// the OnDraw delegate Can be used to draw.  Return true to skip the default draw method

// a color used for the next draw.
var		bool				bUseColorOverride;
var		bool				bUseAlphaOverride;
var		Color				colOverride;
var		float				alphaOverride;

var float					fTextScaleX, fTextScaleY;

delegate bool OnDraw(Canvas Canvas, eMenuState MenuState, float left, float top, float width, float height);
delegate bool OnDrawText(Canvas Canvas, eMenuState MenuState, float left, float top, float width, float height, eTextAlign Align, string Text, optional eTextAlign AlignV);

native function Draw(Canvas Canvas, eMenuState MenuState, float left, float top, float width, float height);
native function DrawText(Canvas Canvas, eMenuState MenuState, float left, float top, float width, float height, eTextAlign Align, string Text, optional bool bMultiLine, optional eTextAlign AlignV, optional EComponentPulseStyle pulseStyle);
native function DrawTextToFit(Canvas Canvas, eMenuState MenuState, float left, float top, float width, float height, eTextAlign Align, string Text, optional EComponentPulseStyle pulseStyle);
native function TextSize(Canvas Canvas, byte MenuState, string Test, out int XL, out int YL);

event Initialize()
{
	local int i;

	// Preset all the data if needed

	for (i=0;i<5;i++)
	{
		Fonts[i] = Controller.GetMenuFont(FontNames[i]);
	}
}

// these provide overrides for drawing text
event SetOverrideColor(Color col)
{
	bUseColorOverride = true;
	colOverride = col;
}
event ClearOverrideColor()
{
	bUseColorOverride = false;
}

event SetOverrideAlpha(float newAlpha)
{
	bUseAlphaOverride = true;
	alphaOverride = newAlpha;
}
event ClearOverrideAlpha()
{
	bUseAlphaOverride = false;
}


defaultproperties
{
	ImageIcons(0)=(Icon=None,U=0,V=0,UL=0,VL=0,DrawColor=(R=255,G=255,B=255,A=255),ScaleX=0.0,ScaleY=0.0,PivotU=0.0,PivotV=0.0)
	ImageIcons(1)=(Icon=None,U=0,V=0,UL=0,VL=0,DrawColor=(R=255,G=255,B=255,A=255),ScaleX=0.0,ScaleY=0.0,PivotU=0.0,PivotV=0.0)
	ImageIcons(2)=(Icon=None,U=0,V=0,UL=0,VL=0,DrawColor=(R=255,G=255,B=255,A=255),ScaleX=0.0,ScaleY=0.0,PivotU=0.0,PivotV=0.0)
	ImageIcons(3)=(Icon=None,U=0,V=0,UL=0,VL=0,DrawColor=(R=255,G=255,B=255,A=255),ScaleX=0.0,ScaleY=0.0,PivotU=0.0,PivotV=0.0)
	ImageIcons(4)=(Icon=None,U=0,V=0,UL=0,VL=0,DrawColor=(R=255,G=255,B=255,A=255),ScaleX=0.0,ScaleY=0.0,PivotU=0.0,PivotV=0.0)

	RStyles(0)=MSTY_Normal;
	RStyles(1)=MSTY_Normal;
	RStyles(2)=MSTY_Normal;
	RStyles(3)=MSTY_Normal;
	RStyles(4)=MSTY_Normal;

	ImgStyle(0)=ISTY_Stretched
	ImgStyle(1)=ISTY_Stretched
	ImgStyle(2)=ISTY_Stretched
	ImgStyle(3)=ISTY_Stretched
	ImgStyle(4)=ISTY_Stretched

	ImageAlign(0)=IMGA_TopLeft
	ImageAlign(1)=IMGA_TopLeft
	ImageAlign(2)=IMGA_TopLeft
	ImageAlign(3)=IMGA_TopLeft
	ImageAlign(4)=IMGA_TopLeft

	//ImgColors(0)=(R=255,G=255,B=255,A=255)
	//ImgColors(1)=(R=255,G=255,B=255,A=255)
	//ImgColors(2)=(R=255,G=255,B=255,A=255)
	//ImgColors(3)=(R=255,G=255,B=255,A=255)
	//ImgColors(4)=(R=128,G=128,B=128,A=255)

//(Blurry, Watched, Focused, Pressed, Disabled)
	FontColors(0)=(R=181,G=181,B=153,A=255)
	FontColors(1)=(R=181,G=181,B=153,A=255)
	FontColors(2)=(R=181,G=181,B=153,A=255)
	FontColors(3)=(R=181,G=181,B=153,A=255)
	FontColors(4)=(R=100,G=100,B=100,A=255)

	FontNames(0)="MenuFont"
	FontNames(1)="MenuFont"
	FontNames(2)="MenuFont"
	FontNames(3)="MenuFont"
	FontNames(4)="MenuFont"

	BorderOffsets(0)=2
	BorderOffsets(1)=2
	BorderOffsets(2)=2
	BorderOffsets(3)=2

	FontShadowColor=(R=0,G=0,B=0,A=0)
	FontShadowRStyle=MSTY_None

	FontGlowColors(0)=(R=255,G=255,B=255,A=255)
	FontGlowColors(1)=(R=255,G=255,B=255,A=255)
	FontGlowColors(2)=(R=255,G=255,B=255,A=255)
	FontGlowColors(3)=(R=255,G=255,B=255,A=255)
	FontGlowColors(4)=(R=128,G=128,B=128,A=255)
	FontGlowRStyles(0)=MSTY_None
	FontGlowRStyles(1)=MSTY_None
	FontGlowRStyles(2)=MSTY_None
	FontGlowRStyles(3)=MSTY_None
	FontGlowRStyles(4)=MSTY_None

	fTextScaleX=1.0
	fTextScaleY=1.0
}// ====================================================================
//	GUITabButton - A Tab Button has an associated Tab Control, and
//  TabPanel.
//
//  Written by Joe Wilcox
//  (c) 2002, Epic Games, Inc.  All Rights Reserved
// ====================================================================

class GUITabButton extends GUIButton
		Native;

var				bool			bForceFlash;		// Lets you get a tab to flash even if its not focused
var				bool			bActive;			// Is this the active tab
var				GUITabPanel		MyPanel;			// This is the panel I control

cpptext
{
		UBOOL MousePressed(UBOOL IsRepeat);					// The Mouse was pressed
		UBOOL MouseReleased();								// The Mouse was released
		void  Draw(UCanvas* Canvas);
}

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{

	Super.Initcomponent(MyController, MyOwner);
}

event SetFocus(GUIComponent Who)
{
	return;
}

function ChangeActiveState(bool IsActive, bool bFocusPanel)
{
	bActive = IsActive;

	if (MyPanel==None) return;

	MyPanel.ShowPanel(IsActive);

	if (IsActive)
	{
		if (bFocusPanel)
			MyPanel.FocusFirst(None);

	}
}

function bool CanShowPanel()
{
	if (MyPanel != None)
		return MyPanel.CanShowPanel();

	return false;
}

defaultproperties
{
	StyleName="TabButton"
	bActive=false
	bBoundToParent=true
	bNeverFocus=true
	WinHeight=0.075
	OnClickSound=CS_Edit
}// ====================================================================
//	GUITabControl - This control has a number of tabs
//
//  Written by Joe Wilcox
//  (c) 2003, Epic Games, Inc.  All Rights Reserved
//
//	Modified by Ron Prestenback
// ====================================================================

class GUITabControl extends GUIMultiComponent
	Native;

cpptext
{
		void PreDraw(UCanvas* Canvas);
		void Draw(UCanvas* Canvas);

		UGUIComponent* UnderCursor(FLOAT MouseX, FLOAT MouseY);
		UBOOL SpecialHit();
		UBOOL MousePressed(UBOOL IsRepeat);					// The Mouse was pressed
		UBOOL MouseReleased();								// The Mouse was released

}

var(Menu)	bool				bDockPanels;		// If true, associated panels will dock vertically with this control

var			array<GUITabButton> TabStack;
var			GUITabButton		ActiveTab;

var			string				BackgroundStyleName;
var			GUIStyles			BackgroundStyle;
var			Material			BackgroundImage;
var			float 				TabHeight;
var			bool				bFillSpace;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{

	Super.InitComponent(MyController, MyOwner);

	if (BackgroundStyleName != "")
		BackgroundStyle = Controller.GetStyle(BackgroundStyleName);

	OnKeyEvent = InternalOnKeyEvent;
    OnXControllerEvent = InternalOnXControllerEvent;

}

function bool InternalOnKeyEvent(out byte Key, out byte State, float delta)
{
	local int i,aTabIndex, StartIndex;

	if ( (FocusedControl!=None) || (State!=3) || (TabStack.Length<=0) )
		return false;

	if (ActiveTab == None)
		return false;

    for(i=0;i<TabStack.Length;i++)
    {
        if (TabStack[i]==ActiveTab)
        {
            aTabIndex = i;
            break;
        }
    }

	if ( (Key==0x25) || (Key==0x64) )	// Left
	{
		StartIndex = aTabIndex;
		while (true)
		{
			if (aTabIndex==0)
				aTabIndex=TabStack.Length-1;
			else
				aTabIndex--;

			if (aTabIndex == StartIndex || ActivateTab(TabStack[aTabIndex],true))
				break;
		}
		return true;

	}

	if ( (Key==0x27) || (Key==0x66) )	// Right
	{
		StartIndex = aTabIndex;
		while (true)
		{
			aTabIndex++;
			if (aTabIndex==TabStack.Length)
				aTabIndex=0;

			if (StartIndex == aTabIndex || ActivateTab(TabStack[aTabIndex],true))
				break;
		}
		return true;
	}

	return false;
}

function bool InternalOnXControllerEvent(byte Id, eXControllerCodes iCode)
{

 	if (iCode == XC_LeftTrigger)
    {
    	NextPage();
        return true;
    }

    else if (iCode == XC_RightTrigger)
    {
		PrevPage();
        return true;
    }

    return false;

}


function GUITabPanel AddTab(string Caption, string PanelClass, optional GUITabPanel ExistingPanel, optional string Hint, optional bool bForceActive)
{
	local class<GUITabPanel> NewPanelClass;

	local GUITabButton NewTabButton;
	local GUITabPanel  NewTabPanel;

	local int i;

	// Make sure this doesn't exist first
	for (i=0;i<TabStack.Length;i++)
	{
		if (TabStack[i].Caption ~= Caption)
		{
			log("A Tab with the caption"@Caption@"already exists.");
			return none;
		}
	}

	if (ExistingPanel==None)
		NewPanelClass = class<GUITabPanel>(DynamicLoadObject(PanelClass,class'class'));

	if ( (ExistingPanel!=None) || (NewPanelClass != None) )
	{
		if (ExistingPanel != None)
	        NewTabPanel = GUITabPanel(AppendComponent(ExistingPanel));
	    else if (NewPanelClass != None)
			NewTabPanel = GUITabPanel(AddComponent(PanelClass));

		if (NewTabPanel == None)
		{
			log("Could not create panel for"@NewPanelClass);
			return None;
		}

		if (NewTabPanel.MyButton != None)
			NewTabButton = NewTabPanel.MyButton;
		else
		{
			NewTabButton = new(None) class'GUITabButton';
			if (NewTabButton==None)
			{
				log("Could not create tab for"@NewPanelClass);
				return None;
			}

			NewTabButton.InitComponent(Controller, Self);
			NewTabPanel.MyButton = NewTabButton;
		}

		NewTabPanel.MyButton .Hint			= Hint;
		NewTabPanel.MyButton .Caption		= Caption;
		NewTabPanel.MyButton .OnClick		= InternalTabClick;
		NewTabPanel.MyButton .MyPanel		= NewTabPanel;
		NewTabPanel.MyButton .FocusInstead	= self;
		NewTabPanel.MyButton .bNeverFocus	= true;

		NewTabPanel.InitPanel();
		NewTabPanel.Hide();

		// Add the tab to controls
		TabStack[TabStack.Length] = NewTabPanel.MyButton;
		if ( (TabStack.Length==1) || (bForceActive) )
        {
			ActivateTab(NewTabPanel.MyButton,true);
            NewTabPanel.FocusFirst(none);
        }

		Return NewTabPanel;

	}
	else
		return none;
}

function GUITabPanel InsertTab(int Pos, string Caption, string PanelClass, optional GUITabPanel ExistingPanel, optional string Hint, optional bool bForceActive)
{
	local class<GUITabPanel> NewPanelClass;
	local GUITabPanel NewTabPanel;
	local GUITabButton NewTabButton;

	if (ExistingPanel == None)
		NewPanelClass = class<GUITabPanel>(DynamicLoadObject(PanelClass,class'Class'));

	if ( ExistingPanel != None || NewPanelClass != None)
	{
		if (ExistingPanel != None)
	        NewTabPanel = GUITabPanel(AppendComponent(ExistingPanel));
	    else if (NewPanelClass != None)
			NewTabPanel = GUITabPanel(AddComponent(PanelClass));

		if (NewTabPanel == None)
		{
			log("Could not create panel for"@NewPanelClass);
			return None;
		}

		if (NewTabPanel.MyButton != None)
			NewTabButton = NewTabPanel.MyButton;

		else
		{
			NewTabButton = new(None) class'GUITabButton';
			if (NewTabButton==None)
			{
				log("Could not create tab for"@NewPanelClass);
				return None;
			}

			NewTabButton.InitComponent(Controller, Self);
			NewTabPanel.MyButton = NewTabButton;
		}


		NewTabPanel.MyButton.Caption = Caption;
		NewTabPanel.MyButton.Hint = Hint;

		NewTabPanel.MyButton.OnClick = InternalTabClick;
		NewTabPanel.MyButton.FocusInstead = self;
		NewTabPanel.MyButton.bNeverFocus = true;
		NewTabPanel.InitPanel();
		NewTabPanel.Hide();

		TabStack.Insert(Pos, 1);
		TabStack[Pos] = NewTabPanel.MyButton;
		if ( (TabStack.Length==1) || (bForceActive) )
        {
			ActivateTab(NewTabPanel.MyButton,true);
            NewTabPanel.FocusFirst(none);
        }

		Return NewTabPanel;
	}

	return None;
}

// At present, this function causes RemapComponents() to be called twice,
// once when the new component is added, once when the old is removed
function GUITabPanel ReplaceTab(GUITabButton Which, string Caption, string PanelClass, optional GUITabPanel ExistingPanel, optional string Hint, optional bool bForceActive)
{
	local class<GUITabPanel> NewPanelClass;

	local GUITabPanel  NewTabPanel, OldTabPanel;

	if (ExistingPanel==None)
		NewPanelClass = class<GUITabPanel>(DynamicLoadObject(PanelClass,class'class'));

	if ( (ExistingPanel!=None) || (NewPanelClass != None) )
	{

   		OldTabPanel = Which.MyPanel;

    	if (ExistingPanel==None)
	        NewTabPanel = GUITabPanel(AddComponent(PanelClass));
    	else
        	NewTabPanel = GUITabPanel(AppendComponent(ExistingPanel));

		if (NewTabPanel==None)
		{
			log("Could not create panel"@NewPanelClass);
			return none;
		}

		Which.Caption			= Caption;
		Which.Hint				= Hint;
		Which.MyPanel			= NewTabPanel;
		NewTabPanel.MyButton	= Which;

	    // Init new panel
    	NewTabPanel.InitPanel();
	    NewTabPanel.Hide();

		// Make sure to notify old tab - so use ActivateTab
		if ( bForceActive )
			ActivateTab(NewTabPanel.MyButton, True);

		// Notify old panel
	    OldTabPanel.OnDestroyPanel(True);
		RemoveComponent(OldTabPanel);

		return NewTabPanel;

	}
	else
		return none;
}

function RemoveTab(optional string Caption, optional GUITabButton who)
{
	local int i;

	if ( (caption=="") && (Who==None) )
		return;

	if (Who==None)
		i = TabIndex(Caption);
	else i = TabIndex(Who.Caption);

	if (i < 0)
		return;

	if (TabStack[i] == ActiveTab)
		LostActiveTab();

	TabStack[i].OnClick = None;
	TabStack[i].MyPanel.OnDestroyPanel(True);
	TabStack.Remove(i,1);
	RemoveComponent(TabStack[i].MyPanel);
}

function bool LostActiveTab()
{
	local int i;

	for (i = 0; i < TabStack.Length; i++)
		if (ActivateTab(TabStack[i],true))
			return true;

	return false;
}

function bool ActivateTab(GUITabButton Who, bool bFocusPanel)
{
	if (Who == none || !Who.CanShowPanel())		// null or not selectable
		return false;

	if (Who==ActiveTab)	// Same Tab, just accept
		return true;

	// Deactivate the Active tab
	if (ActiveTab != None)
	{
		ActiveTab.bActive = False;
		if (ActiveTab.MyPanel != None)
			ActiveTab.MyPanel.ShowPanel(False);
	}

	// Set the new active Tab
	ActiveTab = Who;
	Who.bActive = True;
	Who.MyPanel.ShowPanel(bFocusPanel);
	OnChange(Who);

	return true;
}

function bool ActivateTabByName(string tabname, bool bFocusPanel)
{
	local int i;

	i = TabIndex(TabName);
	if (i < 0 || i >= TabStack.Length) return false;
	else return ActivateTab(TabStack[i], bFocusPanel);
}

function bool InternalTabClick(GUIComponent Sender)
{
	local GUITabButton But;

	But = GUITabButton(Sender);
	if (But==None)
		return false;

	ActivateTab(But,true);
    if (ActiveTab!=None && ActiveTab.MyPanel!=None)
    	ActiveTab.MyPanel.FocusFirst(none);

	return true;
}

event bool NextPage()
{
	local int i;

	// If 1 or no tabs in the stack, then query parents
	if (TabStack.Length < 2)
		return Super.NextPage();

	if (ActiveTab == None)
		i = 0;
	else
	{
		i = TabIndex(ActiveTab.Caption) + 1;
		if ( i >= TabStack.Length )
			i = 0;
	}
	return ActivateTab(TabStack[i], true);
}

event bool PrevPage()
{
	local int i;

	if (TabStack.Length < 2)
		return Super.NextPage();

	if (ActiveTab == None)
		i = TabStack.Length - 1;
	else
	{
		i = TabIndex(ActiveTab.Caption) - 1;
		if ( i < 0 )
			i = TabStack.Length - 1;
	}
	return ActivateTab(TabStack[i], true);
}

event SetFocus(GUIComponent Who)
{
	if (Who==None)
	{
    	if (Controller.FocusedControl!=None && Controller.FocusedControl!=Self)
        {
        	Super(GUIComponent).SetFocus(Who);
            return;
        }
        else
        {
			FocusFirst(None);
        }

		return;
	}
    Super.SetFocus(Who);
}

event bool NextControl(GUIComponent Sender)
{

	if (Sender!=None && Sender.MenuOwner==self)
    	return Super(GUIComponent).NextControl(Sender);
    else
    	FocusFirst(None);

    return true;
}

event bool PrevControl(GUIComponent Sender)
{

	if (Sender!=None && Sender.MenuOwner==self)
    {
    	SetFocus(None);
        return true;
    }
    else if (Sender==None)
    	return Super(GUIComponent).PrevControl(Sender);
    else
    	FocusLast(None);

    return true;

}

function int TabIndex(string TabName)
{
	local int i;

	for (i = 0; i < TabStack.Length; i++)
		if (TabStack[i].Caption ~= TabName)
			return i;

	return -1;
}

defaultproperties
{
	TabHeight=48
	bFillSpace=false
	bTabStop=true
	bDockPanels=false
}// ====================================================================
//	GUITabButton - A Tab Button has an associated Tab Control, and
//  TabPanel.
//
//  Written by Joe Wilcox
//  (c) 2002, Epic Games, Inc.  All Rights Reserved
// ====================================================================

class GUITabPanel extends GUIPanel
		Native Abstract;

cpptext
{
		void PreDraw(UCanvas* Canvas);
}


var(Menu)	bool			bFillHeight;	// If true, the panel will set it's height = Top - ClipY
var			GUITabButton	MyButton;

function InitPanel();	// Should be Subclassed
function OnDestroyPanel(optional bool bCancelled)	// Always call Super.OnDestroyPanel()
{
	MyButton = None;
}

function ShowPanel(bool bShow)	// Show Panel should be subclassed if any special processing is needed
{
	SetVisibility(bShow);
}

function bool CanShowPanel()	// Subclass this function to change selection behavior of the tab
{
	return true;
}

defaultproperties
{
}// ====================================================================
//  Class:  GUI.GUITitleBar
//
//  Used for the Top and Bottom titles on a page
//
//  Written by Joe Wilcox
//  (c) 2002, Epic Games, Inc.  All Rights Reserved
// ====================================================================

class GUITitleBar extends GUIComponent
	Native;

cpptext
{
		void PreDraw(UCanvas* Canvas);
		void Draw(UCanvas* Canvas);	
}		
	
var localized	string 			Caption;		// The caption that get's displayed in here
var				eTextAlign		Justification;	// How to draw		
var				GUITabControl	DockedTabs;		// Set this to a Tab control and that control will be centered undeneath
var				bool			bDockTop;		// If True, dock the control ON TOP of this one
var				bool			bUseTextHeight;	// Should this control scale to the text height
var				material		Effect;			// Allows you to overlay a cool shader effect.					

defaultproperties
{
	bDockTop=false
	bUseTextHeight=true
	bTabStop=false
	bNeverFocus=true
	Justification=TXTA_Left;
	WinWidth=1.000000
	WinHeight=36.000000
	WinLeft=0.000000
	WinTop=0.005414
}
// ====================================================================
// (C) 2002, Epic Games
//
//
// The GUIUSerKeyBinding is a class tha allows mod authors to add keys
// to the control menu.  It works as follows:
//
// Mod authors subclass this actor in their package.  They then need
// to add the following line to their .INT file
//
// Object=(Class=class;MetaClass=GUI.GUIUserKeyBinding,Name=<classname>)
//
// The controller config menu will preload all of these on startup and
// add them to it's list.
//
// Alias is the actual alias you wish to bind.
// KeyLebel is the text description that will be displayed in the list
// bIzSection if set, will cause the menu to add it as a section label
//
// ====================================================================

class GUIUserKeyBinding extends GUI;

struct KeyInfo
{
	var	string Alias;					// The Alias used for this binding
	var string KeyLabel;				// The text label for this binding
    var bool   bIsSection;				// Is this a section label
};

var array<KeyInfo> KeyData;

defaultproperties
{
}// ====================================================================
//  Class:  GUI.GUIVertGripButton
//
//  Written by Joe Wilcox
//  (c) 2002, Epic Games, Inc.  All Rights Reserved
// ====================================================================

class GUIVertGripButton extends GUIGFXButton
		Native;


function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.Initcomponent(MyController, MyOwner);
	OnDrawPre = VertGripDrawPre;
}

function bool VertGripDrawPre(Canvas C)
{
	C.Style = 5;
	C.DrawColor = Controller.BackgroundBoxColor;
	DrawComponentBackground(C, 1.0, 2.0);

	C.SetDrawColor(120,120,100,220);
	DrawComponentBackground(C);

	return true;
}

defaultproperties
{
	StyleName="NoBackground"
	Position=ICP_Bound
	bNeverFocus=true
	bCaptureMouse=true	
	OnClickSound=CS_None
}
// ====================================================================
//  Class:  GUI.GUIVertList
//  Parent: GUI.GUIListBase
//
//  <Enter a description here>
// ====================================================================

class GUIVertList extends GUIListBase
		Native;

cpptext
{
	void PreDraw(UCanvas* Canvas);	
	void Draw(UCanvas* Canvas);	
}
		
delegate OnListItemDblClick(GUIComponent Sender, int Item);
		
function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.Initcomponent(MyController, MyOwner);
	OnKeyType=InternalOnKeyType;
	OnKeyEvent=InternalOnKeyEvent;
	OnClick=InternalOnClick;
	OnDblClick=InternalOnDblClick;
    OnXControllerEvent=InternalOnXControllerEvent;

}	
		
function bool InternalOnClick(GUIComponent Sender)
{
	local int NewIndex, row;

	if ( ( !IsInClientBounds() ) || (ItemsPerPage==0) )
		return false;
		
	// Get the Row..
	
	row = Controller.MouseY - ClientBounds[1];
	NewIndex = Top+ (row / ItemHeight);
	
	if (NewIndex >= ItemCount)
		return false;
		
	SetIndex(NewIndex);
	return true;
}

function bool InternalOnDblClick(GUIComponent Sender)
{
	local int NewIndex, row;

	if ( ( !IsInClientBounds() ) || (ItemsPerPage==0) )
		return false;
		
	// Get the Row..
	
	row = Controller.MouseY - ClientBounds[1];
	NewIndex = Top+ (row / ItemHeight);
	
	if (NewIndex >= ItemCount)
		return false;
		
	OnListItemDblClick(Sender, NewIndex);
	return true;
}

function bool InternalOnKeyType(out byte Key, optional string Unicode)
{
	// Add code to jump to next line with Char	
		
	return true;
}

function bool InternalOnKeyEvent(out byte Key, out byte State, float delta)
{

	if (ItemsPerPage==0) return false;

	
	if ( (Key==0x26 || Key==0x68) && (State==1) )	// Up Arrow
	{
		Up();
		return true;
	}
	
	if ( (Key==0x28 || Key==0x62) && (State==1) ) // Down Arrow
	{
		Down();
		return true;
	}
	
	if ( (Key==0x24 || Key==0x67) && (State==1) ) // Home
	{
		Home();
		return true;
	}
	
	if ( (Key==0x23 || Key==0x61) && (State==1) ) // End
	{
		End();
		return true;
	}
	
	if ( (Key==0x21 || Key==0x69) && (State==1) ) // PgUp
	{
		PgUp();
		return true;
	}
	
	if ( (Key==0x22 || Key==0x63) && (State==1) ) // PgDn
	{
		PgDn();
		return true;
	}
	
	if ( (key==0xEC) && (State==3) )
	{
	
		WheelUp();
		return true;
	}
	
	if ( (key==0xED) && (State==3) )
	{
	
		WheelDown();
		return true;
	}
	
	
	return false;
}

function bool InternalOnXControllerEvent(byte Id, eXControllerCodes iCode)
{

	if (ItemsPerPage==0) return false;

	if (iCode==XC_Up || iCode==XC_PadUp)
    {
    	Up();
        return true;
    }
    else if (iCode==XC_Down || iCode==XC_PadDown)
    {
    	Down();
        return true;
    }

    else if (iCode==XC_Black)
    {
    	Home();
        return true;
    }

    else if (iCode==XC_White)
    {
    	End();
        return true;
    }

    else if (iCode==XC_X)
    {
    	PgDn();
        return true;
    }

    else if (iCode==XC_Y)
    {
    	PgUp();
        return true;
    }

	else if (iCode==XC_Start)
    {
    	OnClick(self);
        return true;
    }
    return false;
}


function WheelUp()
{
	if (MyScrollBar!=None)
		GUIVertScrollBar(MyScrollBar).WheelUp();
	else
	{
		if (!Controller.CtrlPressed)
			Up();
		else
			PgUp();
	}
}

function WheelDown()
{
	if (MyScrollBar!=None)
		GUIVertScrollBar(MyScrollBar).WheelDown();
	else
	{
		if (!Controller.CtrlPressed)
			Down();
		else
			PgDn();
	}
}
	

function Up()
{
	if ( (ItemCount<2) || (Index==0) ) return;

	Index = max(0,Index-1);

	if ( (Index<Top) || (Index>Top+ItemsPerPage) )
	{
		Top = Index;
		MyScrollBar.AlignThumb();
	}
	
	Controller.PlayClickSound(EClickSound.CS_Change);

	OnChange(self);
}

function Down()
{
	if ( (ItemCount<2) || (Index==ItemCount-1) )	return;
	
	Index = min(Index+1,ItemCount-1);
	if (Index<Top)
	{
		Top = Index;
		MyScrollBar.AlignThumb();
	}
	else if (Index>=Top+ItemsPerPage)
	{
		Top = Index-ItemsPerPage+1;
		MyScrollBar.AlignThumb();
	}

	Controller.PlayClickSound(EClickSound.CS_Change);

	OnChange(self);
}
	
function Home()
{
	if (ItemCount<2)	return;	

	Controller.PlayClickSound(EClickSound.CS_Change);

	SetIndex(0);
	Top = 0;
	MyScrollBar.AlignThumb();
}

function End()
{
	if (ItemCount<2)	return;	

	Top = ItemCount - ItemsPerPage;
	if (Top<0)
		Top = 0;
		
	Controller.PlayClickSound(EClickSound.CS_Change);

	SetIndex(ItemCount-1);
	MyScrollBar.AlignThumb();
}	

function PgUp()
{

	if (ItemCount<2)	return;

	Index -= ItemsPerPage;

	// Adjust to bounds
	if (Index < 0)
		Index = 0;

	// If new index 
	if (Top + ItemsPerPage <= Index)		// If index is forward but not visible, jump to it
		Top = Index;
	else if (Index + ItemsPerPage < Top)	// Item is way too far
		Top = Index;
	else if (Index < Top)	// Item is 1 page or less away
		SetTopItem(Top - ItemsPerPage);

	Controller.PlayClickSound(EClickSound.CS_Change);

	SetIndex(Index);
	MyScrollBar.AlignThumb();
}

function PgDn()
{

	if (ItemCount<2)	return;

	// Select item 1 page away from current selection
	Index += ItemsPerPage;

	// Adjust to bounds
	if (Index >= ItemCount)
		Index = ItemCount-1;

	
	if (Index < Top)  // If item is still before Top Item, go to it
		Top = Index;
	else if (Index - Top - ItemsPerPage >= ItemsPerPage)	// Too far away
		SetTopItem(Index);
	else if (Index - Top >= ItemsPerPage) // Just 1 page away
		SetTopItem(Top + ItemsPerPage);

	Controller.PlayClickSound(EClickSound.CS_Change);

	SetIndex(Index);
	MyScrollBar.AlignThumb();
}	

		

defaultproperties
{
}
// ====================================================================
//  Class:  GUI.GUIVertScrollBar

// ====================================================================

class GUIVertScrollBar extends GUIScrollBarBase
		Native;

cpptext
{
		void PreDraw(UCanvas* Canvas);
}

var Automated GUIVertScrollZone MyScrollZone;
var Automated GUIVertScrollButton MyUpButton;
var Automated GUIVertScrollButton MyDownButton;
var Automated GUIVertGripButton MyGripButton;


var		float			GripTop;		// Where in the ScrollZone is the grip	- Set Natively
var		float			GripHeight;		// How big is the grip - Set Natively

var		float			GrabOffset; // distance from top of button that the user started their drag. Set natively.


function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	MyScrollZone.OnScrollZoneClick = ZoneClick;
	MyUpButton.OnClick = UpTickClick;
	MyDownButton.OnClick = DownTickClick;
	MyGripButton.OnCapturedMouseMove = GripMouseMove;
	MyGripButton.OnClick = GripClick;

    ReFocus(MyList);

}

function UpdateGripPosition(float NewPos)
{
	MyList.MakeVisible(NewPos);
	GripTop = NewPos;
}

// Record location you grabbed the grip
function bool GripClick(GUIComponent Sender)
{
	GrabOffset = Controller.MouseY - MyGripButton.ActualTop();

	return true;
}

function bool GripMouseMove(float deltaX, float deltaY)
{
	local float NewPerc,NewTop;

	// Calculate the new Grip Top using the mouse cursor location.
	NewPerc = (  Controller.MouseY - (GrabOffset + MyScrollZone.ActualTop()) )  /(MyScrollZone.ActualHeight()-GripHeight);
	NewTop = FClamp(NewPerc,0.0,1.0);

	UpdateGripPosition(Newtop);

	return true;
}

function ZoneClick(float Delta)
{
	if ( Controller.MouseY < MyGripButton.Bounds[1] )
		MoveGripBy(-MyList.ItemsPerPage);
	else if ( Controller.MouseY > MyGripButton.Bounds[3] )
		MoveGripBy(MyList.ItemsPerPage);

	return;
}

function MoveGripBy(int items)
{
	local int TopItem;

	TopItem = MyList.Top + items;
	if (MyList.ItemCount > 0)
	{
		MyList.SetTopItem(TopItem);
		AlignThumb();
	}
}

function bool UpTickClick(GUIComponent Sender)
{
	WheelUp();
	return true;
}

function bool DownTickClick(GUIComponent Sender)
{
	WheelDown();
	return true;
}

function WheelUp()
{
	if (!Controller.CtrlPressed)
		MoveGripBy(-1);
	else
		MoveGripBy(-MyList.ItemsPerPage);
}

function WheelDown()
{
	if (!Controller.CtrlPressed)
		MoveGripBy(1);
	else
		MoveGripBy(MyList.ItemsPerPage);
}

function AlignThumb()
{
	local float NewTop;

	if (MyList.ItemCount==0)
		NewTop = 0;
	else
	{
		NewTop = Float(MyList.Top) / Float(MyList.ItemCount-MyList.ItemsPerPage);
		NewTop = FClamp(NewTop,0.0,1.0);
	}

	GripTop = NewTop;
}


// NOTE:  Add graphics for no-man's land about and below the scrollzone, and the Scroll nub.

defaultproperties
{
	Begin Object Class=GUIVertScrollZone Name=ScrollZone
	End Object

	Begin Object Class=GUIVertScrollButton Name=UpBut
		UpButton=true
	End Object

	Begin Object Class=GUIVertScrollButton Name=DownBut
		UpButton=false
	End Object
	Begin Object Class=GUIVertGripButton Name=Grip
	End Object

	MyScrollZone=ScrollZone
	MyUpButton=UpBut
	MyDownButton=DownBut
	MyGripButton=Grip

	bAcceptsInput=true;
	WinWidth=0.0375
}// ====================================================================
//  Class:  GUI.GUIVertScrollButton
//
//  Written by Joe Wilcox
//  (c) 2002, Epic Games, Inc.  All Rights Reserved
// ====================================================================

class GUIVertScrollButton extends GUIGFXButton
		Native;

var(Menu)	bool	UpButton;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.Initcomponent(MyController, MyOwner);

	if (!UpButton)
	{
		U=273;
		V=166;
		UL=31;
		VL=23;
	}
	else
	{
		U=242;
		V=166;
		UL=31;
		VL=23;
	}
}

defaultproperties
{
	Graphic=Material't_interface_mb.hud.chapters_comp'
	StyleName="MenuOptionLabel"
	UpButton=false
	Position=ICP_ScaledClip
	bNeverFocus=true
    bCaptureMouse=True
	bClientBound=true
}// ====================================================================
//  Class:  GUI.GUIVertScrollZone
//
//  The VertScrollZone is the background zone for a vertical scrollbar.
//  When the user clicks on the zone, it caculates it's percentage.
//
//  Written by Joe Wilcox
//  (c) 2002, Epic Games, Inc.  All Rights Reserved
// ====================================================================

class GUIVertScrollZone extends GUIComponent
	Native;

cpptext
{
		void Draw(UCanvas* Canvas);
}

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.InitComponent(MyController, MyOwner);

	OnClick = InternalOnClick;
}

function bool InternalOnClick(GUIComponent Sender)
{
	local float perc;

	if (!IsInBounds())
		return false;

	perc = ( Controller.MouseY - ActualTop() ) / ActualHeight();
	OnScrollZoneClick(perc);

	return true;

}


delegate OnScrollZoneClick(float Delta)		// Should be overridden
{
}

defaultproperties
{
	StyleName="ScrollZone"
	bNeverFocus=true
	bAcceptsInput=true
	bCaptureMouse=true
	bRepeatClick=true
    RenderWeight=0.25
}// ====================================================================
//  Class:  GUI.moCheckBox
//  Parent: GUI.GUIMenuOption
//
//  <Enter a description here>
// ====================================================================

class moCheckBox extends GUIMenuOption;

var		GUICheckBoxButton 	MyCheckBox;
var		bool				bChecked;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.Initcomponent(MyController, MyOwner);

	MyCheckBox = GUICheckBoxButton(MyComponent);
}	

function bool IsChecked()
{
	return MyCheckBox.bChecked;
}

function bool Checked(bool C)
{
	MyCheckBox.bChecked = c;
	bChecked = c;
	OnChange(Self);
	return true;
}


defaultproperties
{
	ComponentClassName="GUI.GUICheckBoxButton"
	bChecked=false;
}
// ====================================================================
//  Class:  GUI.GUIMoComboBox
//
//  Written by Joe Wilcox
//  (c) 2002, Epic Games, Inc.  All Rights Reserved
// ====================================================================

class moComboBox extends GUIMenuOption;

var		GUIComboBox MyComboBox;
var		bool		bReadOnly;		// This Combobox is read only

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.Initcomponent(MyController, MyOwner);
	MyComboBox = GUIComboBox(MyComponent);

	ReadOnly(bReadOnly);

}


function int ItemCount()
{
	return MyComboBox.ItemCount();
}

function SetIndex(int I)
{
	MyComboBox.SetIndex(i);
}

function int GetIndex()
{
	return MyComboBox.GetIndex();
}


function string Find(string Test, bool bExact)
{
	return MyComboBox.Find(Test,bExact);
}

function AddItem(string Item, optional object Extra, optional string Str)
{
	MyComboBox.AddItem(Item,Extra,str);
}

function RemoveItem(int item, optional int Count)
{
	MyComboBox.RemoveItem(item, Count);
}

function string GetItem(int index)
{
	return MyComboBox.GetItem(index);
}

function object GetItemObject(int index)
{
	return MyComboBox.GetItemObject(index);
}

function string GetText()
{
	local string aaa;
	aaa = MyComboBox.Get();
	return aaa;
}

function object GetObject()
{
	return MyComboBox.GetObject();
}

function string GetExtra()
{
	return MyComboBox.GetExtra();
}


function SetText(string NewText)
{
	MyComboBox.SetText(NewText);
}

function ReadOnly(bool b)
{
	MyComboBox.ReadOnly(b);
}

defaultproperties
{
	ComponentClassName="GUI.GUIComboBox"
}// ====================================================================
//  Class:  GUI.moEditBox
//  Parent: GUI.GUIMenuOption
//
//  <Enter a description here>
// ====================================================================

class moEditBox extends GUIMenuOption;

var		GUIEditBox MyEditBox;
var		bool	   bReadOnly;		// This Combobox is read only

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.Initcomponent(MyController, MyOwner);
	MyEditBox = GUIEditBox(MyComponent);
	MyEditBox.bReadOnly = bReadOnly;
}

function string GetText()
{
	return MyEditBox.GetText();
}

function SetText(string NewText)
{
	MyEditBox.SetText(NewText);
}

function ReadOnly(bool b)
{
	MyEditBox.bReadOnly = b;
}

function IntOnly(bool b)
{
	MyEditBox.bIntOnly=b;
}

function FloatOnly(bool b)
{
	MyEditBox.bFloatOnly = b;
}

function MaskText(bool b)
{
	MyEditBox.bMaskText = b;
}

defaultproperties
{
	ComponentClassName="GUI.GUIEditBox"
}
// ====================================================================
// (C) 2002, Epic Games
// ====================================================================

class moFloatEdit extends GUIMenuOption;

var		GUIFloatEdit	MyNumericEdit;
var		float			MinValue, MaxValue, Step;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.Initcomponent(MyController, MyOwner);
	MyNumericEdit = GUIFloatEdit(MyComponent);
	MyNumericEdit.MinValue = MinValue;
	MyNumericEdit.MaxValue = MaxValue;
    MyNumericEdit.Step = Step;
	MyNumericEdit.CalcMaxLen();
	MyNumericEdit.OnChange = InternalOnChange;
}

function SetValue(float V)
{
	MyNumericEdit.SetValue(v);
}

function float GetValue()
{
	return float(MyNumericEdit.Value);
}

function InternalOnChange(GUIComponent Sender)
{
	OnChange(self);
}


defaultproperties
{
	ComponentClassName="GUI.GUIFloatEdit"
	OnClickSound=CS_Click
}class moLabel extends GUIMenuOption;

var		GUILabel 			MyLabel2;
var		bool				CompTransparent;
var		eTextAlign			CompTextAlign;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.Initcomponent(MyController, MyOwner);

	MyLabel2 = GUILabel(MyComponent);
	MyLabel2.TextAlign   = CompTextAlign;
	MyLabel2.bTransparent = CompTransparent;
	MyLabel2.bDrawToFit = true;
}	

function SetText(optional string s)
{
	MyLabel2.SetCaption(s);
}

defaultproperties
{
	CompTransparent=false
	CompTextAlign=TXTA_Center
	CompStyle="TextLabel"
	ComponentClassName="GUI.GUILabel"
}
// ====================================================================
//  Class:  GUI.moNumericEdit
//  Parent: GUI.GUIMenuOption
//
//  <Enter a description here>
// ====================================================================

class moNumericEdit extends GUIMenuOption;

var		GUINumericEdit	MyNumericEdit;
var		int				MinValue, MaxValue;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.Initcomponent(MyController, MyOwner);
	MyNumericEdit = GUINumericEdit(MyComponent);
	MyNumericEdit.MinValue = MinValue;
	MyNumericEdit.MaxValue = MaxValue;
	MyNumericEdit.CalcMaxLen();
	MyNumericEdit.OnChange = InternalOnChange;
}

function SetValue(int V)
{
	MyNumericEdit.SetValue(v);
}

function int GetValue()
{
	return int(MyNumericEdit.Value);
}

function InternalOnChange(GUIComponent Sender)
{
	OnChange(self);
}


defaultproperties
{
	ComponentClassName="GUI.GUINumericEdit"
	OnClickSound=CS_Click
}// ====================================================================
//  Class:  GUI.moPasswordBox
//  Parent: GUI.GUIMenuOption
//
//  <Enter a description here>
// ====================================================================

class moPasswordBox extends GUIMenuOption;

var		GUIPasswordBox MyEditBox;
var		bool	   bReadOnly;		// This Combobox is read only

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.Initcomponent(MyController, MyOwner);
	MyEditBox = GUIPasswordBox(MyComponent);
	MyEditBox.bReadOnly = bReadOnly;
}

function string GetText()
{
	return MyEditBox.GetPassword();
}

function SetText(string NewText)
{
	MyEditBox.SetPassword(NewText);
}

function ReadOnly(bool b)
{
	MyEditBox.bReadOnly = b;
}

function IntOnly(bool b)
{
	MyEditBox.bIntOnly=b;
}

function FloatOnly(bool b)
{
	MyEditBox.bFloatOnly = b;
}

function MaskText(bool b)
{
	MyEditBox.bMaskText = b;
}

defaultproperties
{
	ComponentClassName="GUI.GUIPasswordBox"
}
// ====================================================================
//  Class:  GUI.moSpinListControl
//  Parent: GUI.GUIMenuOption
//
//  <Enter a description here>
// ====================================================================

class moSpinListControl extends GUIMenuOption;

var			GUISpinListControl		MySpinListControl;
var(Menu)	bool					bWrap;

function InitComponent(GUIController MyController, GUIComponent MyOwner)
{
	Super.Initcomponent(MyController, MyOwner);

	MySpinListControl = GUISpinListControl(MyComponent);
	MySpinListControl.OnChange = InternalOnChange;
	MySpinListControl.bWrap = bWrap;
}

// =======================================================================================================================================================
// List entry management
// =======================================================================================================================================================
function Add(string NewItem, optional Object obj, optional string Str)
{
	MySpinListControl.Add(NewItem, obj, Str);
}
function Clear()
{
	MySpinListControl.Clear();
}
function AddFromList(out array<string> newItems)
{
	MySpinListControl.AddFromList(newItems);
}
function AddFromLists(out array<string> newItems, out array<string> newStrs)
{
	MySpinListControl.AddFromLists(newItems, newStrs);
}

// =======================================================================================================================================================
// Data/value access
// =======================================================================================================================================================
function int ItemCount()
{
	return MySpinListControl.ItemCount();
}
function SetIndex(int newIndex)
{
	MySpinListControl.SetIndex(newIndex);
}
function int GetIndex()
{
	return MySpinListControl.GetIndex();
}
function string Get()
{
	return MySpinListControl.Get();
}
function object GetObject()
{
	return MySpinListControl.GetObject();
}	
function string GetExtra()
{
	return MySpinListControl.GetExtra();
}

function SpinNext()
{
	MySpinListControl.SpinNext();
}
function SpinPrev()
{
	MySpinListControl.SpinPrev();
}


function InternalOnChange(GUIComponent Sender)
{
	OnChange(self);
}


defaultproperties
{
	ComponentClassName="GUI.GUISpinListControl"
	OnClickSound=CS_Click
	bWrap=true
}// ====================================================================
//  Class:  XInterface.STY_ListBox
//  Parent: XInterface.STY_SquareButton
//
//  Background style for the actual combo area of the listbox
//	i.e. when the menu is not expanded (I think ?)
// ====================================================================
class STY_ComboListBox extends STY_ListBox;

defaultproperties
{
	KeyName="ComboListBox"
// GBX:CEK: 3/16/2004 - TEMP GUI REINTEGRATION
//	Images(0)=Material'GUIContent.Menu.EditBoxDown'
//	Images(1)=Material'GUIContent.Menu.EditBoxDown'
//	Images(2)=Material'GUIContent.Menu.EditBoxDown'
//	Images(3)=Material'GUIContent.Menu.EditBoxDown'
}
class STY_DefButton extends GUIStyles;

#exec OBJ LOAD FILE=..\texture\t_interface_mb.utx

defaultproperties
{
	KeyName="DefButton"
	ImageIcons(0)=(Icon=Material't_interface_mb.gui.small_white_border',DrawColor=(R=128,G=128,B=128,A=255))
	ImageIcons(1)=(Icon=Material't_interface_mb.gui.small_white_border',DrawColor=(R=192,G=192,B=192,A=255))
	ImageIcons(2)=(Icon=Material't_interface_mb.gui.small_white_border',DrawColor=(R=192,G=192,B=192,A=255))
	ImageIcons(3)=(Icon=Material't_interface_mb.gui.small_white_border',DrawColor=(R=255,G=255,B=255,A=255))
	ImageIcons(4)=(Icon=Material't_interface_mb.gui.small_white_border',DrawColor=(R=64,G=64,B=64,A=255))
	
	ImgStyle(0)=ISTY_Stretched
	ImgStyle(1)=ISTY_Stretched
	ImgStyle(2)=ISTY_Stretched
	ImgStyle(3)=ISTY_Stretched
	ImgStyle(4)=ISTY_Stretched

	FontNames(0)="SmallHeaderFont"
	FontNames(1)="SmallHeaderFont"
	FontNames(2)="SmallHeaderFont"
	FontNames(3)="SmallHeaderFont"
	FontNames(4)="SmallHeaderFont"
	FontColors(0)=(R=128,G=128,B=128,A=255)
	FontColors(1)=(R=192,G=192,B=192,A=255)
	FontColors(2)=(R=255,G=255,B=255,A=255)
	FontColors(3)=(R=255,G=255,B=255,A=255)
	FontColors(4)=(R=32,G=32,B=32,A=255)

	BorderOffsets(0)=4
	BorderOffsets(1)=4
	BorderOffsets(2)=4
	BorderOffsets(3)=4
}
// ====================================================================
//  Written by Joe Wilcox
//  (c) 2002, Epic Games, Inc.  All Rights Reserved
//
//	Bottom bar in the primary browser GUI
// ====================================================================

class STY_Footer extends STY_SquareButton;

defaultproperties
{
	KeyName="Footer"
	
	FontColors(1)=(R=230,G=200,B=0,A=255)
}
// ====================================================================
//  Written by Joe Wilcox
//  (c) 2002, Epic Games, Inc.  All Rights Reserved
//
//	Top bar in the primary browser GUI (background for tab controls)
// ====================================================================

class STY_Header extends GUIStyles;

defaultproperties
{
	KeyName="Header"
	FontNames(0)="HeaderFont"
	FontNames(1)="HeaderFont"
	FontNames(2)="HeaderFont"
	FontNames(3)="HeaderFont"
	FontNames(4)="HeaderFont"

	BorderOffsets(0)=0
	BorderOffsets(1)=0
	BorderOffsets(2)=0
	BorderOffsets(3)=0

	FontShadowColor=(R=0,G=0,B=0,A=255)
	FontShadowRStyle=MSTY_Normal
}
class STY_HelpButton extends GUIStyles;

#exec OBJ LOAD FILE=..\texture\t_interface_mb.utx

defaultproperties
{
	KeyName="HelpButton"

	FontNames(0)="gbx_HelpButtonFont"
	FontNames(1)="gbx_HelpButtonFont"
	FontNames(2)="gbx_HelpButtonFont"
	FontNames(3)="gbx_HelpButtonFont"
	FontNames(4)="gbx_HelpButtonFont"
	FontColors(0)=(R=128,G=128,B=128,A=255)
	FontColors(1)=(R=128,G=128,B=128,A=255)
	FontColors(2)=(R=128,G=128,B=128,A=255)
	FontColors(3)=(R=128,G=128,B=128,A=255)
	FontColors(4)=(R=32,G=32,B=32,A=0)

	BorderOffsets(0)=0
	BorderOffsets(1)=0
	BorderOffsets(2)=0
	BorderOffsets(3)=0

	FontShadowColor=(R=0,G=0,B=0,A=255)
	FontShadowRStyle=MSTY_Normal

//	FontGlowRStyles(2)=MSTY_Additive
//	FontGlowColors(2)=(R=255,G=255,B=255,A=255)
}
class STY_LargeButton extends GUIStyles;

#exec OBJ LOAD FILE=..\texture\t_interface_mb.utx

defaultproperties
{
	KeyName="LargeButton"

	FontNames(0)="LargeFont"
	FontNames(1)="LargeFont"
	FontNames(2)="LargeFont"
	FontNames(3)="LargeFont"
	FontNames(4)="LargeFont"

	BorderOffsets(0)=0
	BorderOffsets(1)=0
	BorderOffsets(2)=0
	BorderOffsets(3)=0

	FontShadowColor=(R=13,G=5,B=8,A=255)
	FontShadowRStyle=MSTY_Normal

	FontGlowRStyles(2)=MSTY_Additive
	FontGlowColors(2)=(R=255,G=255,B=255,A=90)
}
// ====================================================================
//  Class:  XInterface.STY_ListBox
//  Parent: XInterface.STY_SquareButton
//
//  Background style for the actual "list" area of a listbox
// ====================================================================

class STY_ListBox extends STY_SquareButton;

defaultproperties
{
	KeyName="ListBox"

	FontNames(0)="SmallFont"
	FontNames(1)="SmallFont"
	FontNames(2)="SmallFont"
	FontNames(3)="SmallFont"
	FontNames(4)="SmallFont"

	FontColors(3)=(R=230,G=200,B=0,A=255)
	BorderOffsets(0)=6
	BorderOffsets(1)=6
	BorderOffsets(2)=6
	BorderOffsets(3)=6
}
class STY_MainButton extends GUIStyles;

#exec OBJ LOAD FILE=..\texture\t_interface_mb.utx

defaultproperties
{
	KeyName="MainButton"

	FontNames(0)="gbx_MainButtonFont"
	FontNames(1)="gbx_MainButtonFont"
	FontNames(2)="gbx_MainButtonFont"
	FontNames(3)="gbx_MainButtonFont"
	FontNames(4)="gbx_MainButtonFont"

	BorderOffsets(0)=0
	BorderOffsets(1)=0
	BorderOffsets(2)=0
	BorderOffsets(3)=0

	FontShadowColor=(R=13,G=5,B=8,A=255)
	FontShadowRStyle=MSTY_Normal

	FontGlowRStyles(2)=MSTY_Additive
	FontGlowColors(2)=(R=255,G=255,B=255,A=90)
}
class STY_MenuOptionCaption extends GUIStyles;

#exec OBJ LOAD FILE=..\texture\t_interface_mb.utx

defaultproperties
{
	KeyName="MenuOptionCaption"

	FontNames(0)="gbx_CaptionFont"
	FontNames(1)="gbx_CaptionFont"
	FontNames(2)="gbx_CaptionFont"
	FontNames(3)="gbx_CaptionFont"
	FontNames(4)="gbx_CaptionFont"

	BorderOffsets(0)=0
	BorderOffsets(1)=0
	BorderOffsets(2)=0
	BorderOffsets(3)=0

	FontShadowColor=(R=13,G=5,B=8,A=255)
	FontShadowRStyle=MSTY_Normal

	FontGlowRStyles(2)=MSTY_Additive
	FontGlowColors(2)=(R=255,G=255,B=255,A=90)
}
class STY_MenuOptionLabel extends GUIStyles;

#exec OBJ LOAD FILE=..\texture\t_interface_mb.utx

defaultproperties
{
	KeyName="MenuOptionLabel"

	FontNames(0)="SmallFont"
	FontNames(1)="SmallFont"
	FontNames(2)="SmallFont"
	FontNames(3)="SmallFont"
	FontNames(4)="SmallFont"

	BorderOffsets(0)=2
	BorderOffsets(1)=2
	BorderOffsets(2)=2
	BorderOffsets(3)=2

	FontShadowColor=(R=13,G=5,B=8,A=255)
	FontShadowRStyle=MSTY_Normal

	FontGlowRStyles(2)=MSTY_Additive
	FontGlowColors(2)=(R=255,G=255,B=255,A=90)
}
// ====================================================================
//  Class:  XInterface.STY_NoBackground
//  Parent: XInterface.GUIStyles
//
//  <Enter a description here>
// ====================================================================

class STY_NoBackground extends GUIStyles;

defaultproperties
{
	KeyName="NoBackground"
	RStyles(0)=MSTY_None;
	RStyles(1)=MSTY_None;
	RStyles(2)=MSTY_None;
	RStyles(3)=MSTY_None;
	RStyles(4)=MSTY_None;

	FontColors(0)=(R=255,G=255,B=255,A=255)
	FontColors(1)=(R=255,G=255,B=255,A=255)
	FontColors(2)=(R=255,G=255,B=255,A=255)
	FontColors(3)=(R=255,G=255,B=255,A=255)
	FontColors(4)=(R=255,G=255,B=255,A=255)

	FontNames(0)="MenuFont"
	FontNames(1)="MenuFont"
	FontNames(2)="MenuFont"
	FontNames(3)="MenuFont"
	FontNames(4)="MenuFont"

	BorderOffsets(0)=0
	BorderOffsets(1)=0
	BorderOffsets(2)=0
	BorderOffsets(3)=0


}// ====================================================================
//  Written by Joe Wilcox
//  (c) 2002, Epic Games, Inc.  All Rights Reserved
//
//	Normal push buttons (OK, Cancel, Apply)
// ====================================================================

class STY_RoundButton extends GUIStyles;

defaultproperties
{
	KeyName="RoundButton"
	ImageIcons(0)=(Icon=Material't_interface_mb.hud.interface_comp',U=284,V=128,UL=128,VL=128,DrawColor=(R=13,G=5,B=8,A=220),ScaleX=1.0,ScaleY=1.0,PivotU=32.0,PivotV=32.0)
	ImageIcons(1)=(Icon=Material't_interface_mb.hud.interface_comp',U=284,V=128,UL=128,VL=128,DrawColor=(R=13,G=5,B=8,A=220),ScaleX=1.0,ScaleY=1.0,PivotU=32.0,PivotV=32.0)
	ImageIcons(2)=(Icon=Material't_interface_mb.hud.interface_comp',U=284,V=128,UL=128,VL=128,DrawColor=(R=13,G=5,B=8,A=220),ScaleX=1.0,ScaleY=1.0,PivotU=32.0,PivotV=32.0)
	ImageIcons(3)=(Icon=Material't_interface_mb.hud.interface_comp',U=284,V=128,UL=128,VL=128,DrawColor=(R=13,G=5,B=8,A=220),ScaleX=1.0,ScaleY=1.0,PivotU=32.0,PivotV=32.0)
	ImageIcons(4)=(Icon=Material't_interface_mb.hud.interface_comp',U=284,V=128,UL=128,VL=128,DrawColor=(R=13,G=5,B=8,A=220),ScaleX=1.0,ScaleY=1.0,PivotU=32.0,PivotV=32.0)

	ImgStyle(0)=ISTY_TileTiled
	ImgStyle(1)=ISTY_TileTiled
	ImgStyle(2)=ISTY_TileTiled
	ImgStyle(3)=ISTY_TileTiled
	ImgStyle(4)=ISTY_TileTiled

	FontNames(0)="gbx_CaptionFont"
	FontNames(1)="gbx_CaptionFont"
	FontNames(2)="gbx_CaptionFont"
	FontNames(3)="gbx_CaptionFont"
	FontNames(4)="gbx_CaptionFont"
}// ====================================================================
//  Written by Joe Wilcox
//  (c) 2002, Epic Games, Inc.  All Rights Reserved
//
//	Used by scrollboxes and spinners (up/down, +/-)
// ====================================================================

class STY_RoundScaledButton extends STY_RoundButton;

defaultproperties
{
	KeyName="RoundScaledButton"
}
// ====================================================================
//  Written by Joe Wilcox
//  (c) 2002, Epic Games, Inc.  All Rights Reserved
//
//  What is looks like under the scrollgrab (ie: the % area)
//	TODO: WTF ^^^^^^
// ====================================================================

class STY_ScrollZone extends GUIStyles;

defaultproperties
{
	KeyName="ScrollZone"
	//ImageIcons(0)=(Icon=Material't_interface_mb.hud.interface_comp',U=284,V=128,UL=128,VL=128,DrawColor=(R=13,G=5,B=8,A=220),ScaleX=1.5,ScaleY=1.5,PivotU=32.0,PivotV=32.0)
	//ImageIcons(1)=(Icon=Material't_interface_mb.hud.interface_comp',U=284,V=128,UL=128,VL=128,DrawColor=(R=13,G=5,B=8,A=220),ScaleX=1.5,ScaleY=1.5,PivotU=32.0,PivotV=32.0)
	//ImageIcons(2)=(Icon=Material't_interface_mb.hud.interface_comp',U=284,V=128,UL=128,VL=128,DrawColor=(R=13,G=5,B=8,A=220),ScaleX=1.5,ScaleY=1.5,PivotU=32.0,PivotV=32.0)
	//ImageIcons(3)=(Icon=Material't_interface_mb.hud.interface_comp',U=284,V=128,UL=128,VL=128,DrawColor=(R=13,G=5,B=8,A=220),ScaleX=1.5,ScaleY=1.5,PivotU=32.0,PivotV=32.0)
	//ImageIcons(4)=(Icon=Material't_interface_mb.hud.interface_comp',U=284,V=128,UL=128,VL=128,DrawColor=(R=13,G=5,B=8,A=220),ScaleX=1.5,ScaleY=1.5,PivotU=32.0,PivotV=32.0)

	//ImgStyle(0)=ISTY_TileTiled
	//ImgStyle(1)=ISTY_TileTiled
	//ImgStyle(2)=ISTY_TileTiled
	//ImgStyle(3)=ISTY_TileTiled
	//ImgStyle(4)=ISTY_TileTiled

	FontColors(0)=(R=255,G=255,B=255,A=255)	
	FontColors(3)=(R=255,G=255,B=255,A=255)	

}
// ====================================================================
//  Class:  XInterface.STY_SliderCaption
//  Parent: XInterface.GUIStyles
//
//  <Enter a description here>
// ====================================================================

class STY_SliderCaption extends GUIStyles;


defaultproperties
{
	KeyName="SliderCaption"
	FontNames(0)="MenuFont"

}// ====================================================================
//  Written by Joe Wilcox
//  (c) 2002, Epic Games, Inc.  All Rights Reserved
//
//	Generic bar used to display most popup dialogs / menus
//	Background...  (Mid-Game Menu, for example)
// ====================================================================

class STY_SquareBar extends STY_RoundButton;

defaultproperties
{
	KeyName="SquareBar"
}
// ====================================================================
//  Written by Joe Wilcox
//  (c) 2002, Epic Games, Inc.  All Rights Reserved
//
//	Edit boxes...base class for all other boxes / buttons
// ====================================================================

class STY_SquareButton extends GUIStyles;

defaultproperties
{
	KeyName="SquareButton"
	ImageIcons(0)=(Icon=Material't_interface_mb.hud.interface_comp',U=284,V=128,UL=128,VL=128,DrawColor=(R=13,G=5,B=8,A=220),ScaleX=1.0,ScaleY=1.0,PivotU=32.0,PivotV=32.0)
	ImageIcons(1)=(Icon=Material't_interface_mb.hud.interface_comp',U=284,V=128,UL=128,VL=128,DrawColor=(R=13,G=5,B=8,A=220),ScaleX=1.0,ScaleY=1.0,PivotU=32.0,PivotV=32.0)
	ImageIcons(2)=(Icon=Material't_interface_mb.hud.interface_comp',U=284,V=128,UL=128,VL=128,DrawColor=(R=13,G=5,B=8,A=220),ScaleX=1.0,ScaleY=1.0,PivotU=32.0,PivotV=32.0)
	ImageIcons(3)=(Icon=Material't_interface_mb.hud.interface_comp',U=284,V=128,UL=128,VL=128,DrawColor=(R=13,G=5,B=8,A=220),ScaleX=1.0,ScaleY=1.0,PivotU=32.0,PivotV=32.0)
	ImageIcons(4)=(Icon=Material't_interface_mb.hud.interface_comp',U=284,V=128,UL=128,VL=128,DrawColor=(R=13,G=5,B=8,A=220),ScaleX=1.0,ScaleY=1.0,PivotU=32.0,PivotV=32.0)
	ImgStyle(0)=ISTY_TileTiled
	ImgStyle(1)=ISTY_TileTiled
	ImgStyle(2)=ISTY_TileTiled
	ImgStyle(3)=ISTY_TileTiled
	ImgStyle(4)=ISTY_TileTiled

	FontNames(0)="gbx_CaptionFont"
	FontNames(1)="gbx_CaptionFont"
	FontNames(2)="gbx_CaptionFont"
	FontNames(3)="gbx_CaptionFont"
	FontNames(4)="gbx_CaptionFont"

	FontShadowColor=(R=13,G=5,B=8,A=255)
	FontShadowRStyle=MSTY_Normal

	FontGlowRStyles(2)=MSTY_Additive
	FontGlowColors(2)=(R=255,G=255,B=255,A=90)
}
// ====================================================================
//  Written by Joe Wilcox
//  (c) 2002, Epic Games, Inc.  All Rights Reserved
//
//	Style content for all GUI tabs
// ====================================================================

class STY_TabButton extends GUIStyles;

defaultproperties
{
	KeyName="TabButton"
// GBX:CEK: 3/16/2004 - TEMP GUI REINTEGRATION
//	Images(0)=Material'GUIContent.Menu.BoxTab'
//	Images(1)=Material'GUIContent.Menu.BoxTabWatched'
//	Images(2)=Material'GUIContent.Menu.BoxTabPulse'
//	Images(3)=Material'GUIContent.Menu.BoxTab'

	FontNames(0)="SmallHeaderFont"
	FontNames(1)="SmallHeaderFont"
	FontNames(2)="SmallHeaderFont"
	FontNames(3)="SmallHeaderFont"
	FontNames(4)="SmallHeaderFont"

	FontColors(0)=(R=255,G=255,B=255,A=255)
	FontColors(1)=(R=255,G=255,B=255,A=255)
	FontColors(2)=(R=230,G=200,B=0,A=255)
	FontColors(3)=(R=230,G=200,B=0,A=255)
}// ====================================================================
//  Written by Joe Wilcox
//  (c) 2002, Epic Games, Inc.  All Rights Reserved
//
//	Plain old button
// ====================================================================

class STY_TextButton extends STY_MenuOptionCaption;

defaultproperties
{
	KeyName="TextButton"

	ImageIcons(0)=(Icon=Material't_interface_mb.hud.interface_comp',U=284,V=128,UL=128,VL=128,DrawColor=(R=13,G=5,B=8,A=220),ScaleX=1.0,ScaleY=1.0,PivotU=32.0,PivotV=32.0)
	ImageIcons(1)=(Icon=Material't_interface_mb.hud.interface_comp',U=284,V=128,UL=128,VL=128,DrawColor=(R=13,G=5,B=8,A=220),ScaleX=1.0,ScaleY=1.0,PivotU=32.0,PivotV=32.0)
	ImageIcons(2)=(Icon=Material't_interface_mb.hud.interface_comp',U=284,V=128,UL=128,VL=128,DrawColor=(R=13,G=5,B=8,A=220),ScaleX=1.0,ScaleY=1.0,PivotU=32.0,PivotV=32.0)
	ImageIcons(3)=(Icon=Material't_interface_mb.hud.interface_comp',U=284,V=128,UL=128,VL=128,DrawColor=(R=13,G=5,B=8,A=220),ScaleX=1.0,ScaleY=1.0,PivotU=32.0,PivotV=32.0)
	ImageIcons(4)=(Icon=Material't_interface_mb.hud.interface_comp',U=284,V=128,UL=128,VL=128,DrawColor=(R=13,G=5,B=8,A=220),ScaleX=1.0,ScaleY=1.0,PivotU=32.0,PivotV=32.0)
	ImgStyle(0)=ISTY_TileTiled
	ImgStyle(1)=ISTY_TileTiled
	ImgStyle(2)=ISTY_TileTiled
	ImgStyle(3)=ISTY_TileTiled
	ImgStyle(4)=ISTY_TileTiled

	BorderOffsets(0)=4
	BorderOffsets(1)=4
	BorderOffsets(2)=4
	BorderOffsets(3)=4
}// ====================================================================
//  Class:  XInterface.STY_TextLabel
//  Parent: XInterface.GUIStyles
//
//  Generic text label / box
// ====================================================================

class STY_TextLabel extends STY_MenuOptionLabel;

defaultproperties
{
	KeyName="TextLabel"

	FontNames(0)="MenuFont"
	FontNames(1)="MenuFont"
	FontNames(2)="MenuFont"
	FontNames(3)="MenuFont"
	FontNames(4)="MenuFont"
	ImageIcons(0)=(Icon=Material't_interface_mb.hud.interface_comp',U=284,V=128,UL=128,VL=128,DrawColor=(R=13,G=5,B=8,A=220),ScaleX=1.0,ScaleY=1.0,PivotU=32.0,PivotV=32.0)
	ImageIcons(1)=(Icon=Material't_interface_mb.hud.interface_comp',U=284,V=128,UL=128,VL=128,DrawColor=(R=13,G=5,B=8,A=220),ScaleX=1.0,ScaleY=1.0,PivotU=32.0,PivotV=32.0)
	ImageIcons(2)=(Icon=Material't_interface_mb.hud.interface_comp',U=284,V=128,UL=128,VL=128,DrawColor=(R=13,G=5,B=8,A=220),ScaleX=1.0,ScaleY=1.0,PivotU=32.0,PivotV=32.0)
	ImageIcons(3)=(Icon=Material't_interface_mb.hud.interface_comp',U=284,V=128,UL=128,VL=128,DrawColor=(R=13,G=5,B=8,A=220),ScaleX=1.0,ScaleY=1.0,PivotU=32.0,PivotV=32.0)
	ImageIcons(4)=(Icon=Material't_interface_mb.hud.interface_comp',U=284,V=128,UL=128,VL=128,DrawColor=(R=13,G=5,B=8,A=220),ScaleX=1.0,ScaleY=1.0,PivotU=32.0,PivotV=32.0)
	ImgStyle(0)=ISTY_TileTiled
	ImgStyle(1)=ISTY_TileTiled
	ImgStyle(2)=ISTY_TileTiled
	ImgStyle(3)=ISTY_TileTiled
	ImgStyle(4)=ISTY_TileTiled
	BorderOffsets(0)=2
	BorderOffsets(1)=2
	BorderOffsets(2)=2
	BorderOffsets(3)=2
}