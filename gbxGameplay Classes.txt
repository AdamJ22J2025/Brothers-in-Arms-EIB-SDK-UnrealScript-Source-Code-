class AnimNotify_PlayerBlurEffect extends AnimNotify_Scripted;

var() bool	bEnable;

event Notify( Actor Owner )
{
	local	gbxPawn	aPawn;
	
	aPawn = gbxPawn(Owner);
	if ((aPawn != None) && (aPawn.IsA('gbxPlayerPawn')))
	{
		if (bEnable)
		{
			aPawn.BeginTraumaCam();
		}
		else
		{
			aPawn.EndTraumaCam();
		}
	}
}
//********************************************************************
// AssaultPath
// used to specify alternate routes for attackers
//
//********************************************************************
class AssaultPath extends NavigationPoint
	placeable;



var		GameObjective	AssociatedObjective;
var		AssaultPath		NextPath;
var()	int				Position;	// specifies relative position in a chain of AssaultPaths with the same PathTag and the same ObjectiveTag
var()	name			ObjectiveTag;
var()	name			PathTag[4];		// paths that fan out from the same first AssaultPath share the same PathTag, more than one path can go through a given assaultpath

var()	bool			bEnabled;
var()	bool			bNoReturn;
var()	bool			bReturnOnly;
var		bool			bFirstPath;
var		bool			bLastPath;
var()	bool			bNoGrouping;	// bots won't wait to reform squads at this assault path

var()	float			Priority;	// 0 to 1, higher means heavier weighting when determining whether to use this path

event Trigger( Actor Other, Pawn EventInstigator )
{
	bEnabled = !bEnabled;
}

function ValidatePathTags()
{
	if ( PathTag[0] == '' )
		PathTag[0] = Name;
}

function AddTo(GameObjective O)
{
	local AssaultPath A;
	local int i;

	NextPath = None;
	AssociatedObjective = O;
	if ( O.AlternatePaths == None )
	{
		O.AlternatePaths = self;
		return;
	}
	ValidatePathTags();
	for ( A=O.AlternatePaths; A!=None; A=A.NextPath )
	{
		for ( i=0; i<4; i++ )
			if ( (PathTag[i] != '') && A.HasPathTag(PathTag[i]) )
			{
				if ( A.Position < Position )
				{
					A.bLastPath = false;
					bFirstPath = false;
				}
				else if ( A.Position > Position )
				{
					A.bFirstPath = false;
					bLastPath = false;
				}
			}
		if ( A.NextPath == None )
		{
			A.NextPath = self;
			return;
		}
	}
}

function name PickTag()
{
	local name Result;
	local int i, num;

	ValidatePathTags();
	Result = PathTag[0];

	for ( i=0; i<4; i++ )
		if ( PathTag[i] != 'None' )
		{
			num++;
			if ( FRand() < 1/num )
				Result = PathTag[i];
		}

	return Result;
}

function bool HasPathTag(name aPathTag)
{
	local int i;

	ValidatePathTags();
	for ( i=0; i<4; i++ )
		if ( PathTag[i] == aPathTag )
			return true;

	return false;
}

function AssaultPath FindNextPath(name AlternatePathTag)
{
	local AssaultPath A;
	local AssaultPath List[16];
	local int i,num;
	local float sum,r;

	for ( A=AssociatedObjective.AlternatePaths; A!=None; A=A.NextPath )
	{
		if ( A.bEnabled && (A.Position > Position) && !A.bReturnOnly
			&& A.HasPathTag(AlternatePathTag) )
		{
			if ( (List[0] == None) || (A.Position < List[0].Position) )
			{
				for ( i=0; i<num; i++ )
					List[i] = None;
				List[0] = A;
				num = 1;
			}
			else if ( A.Position == List[0].Position )
			{
				List[num] = A;
				num++;
				if ( num > 15 )
					break;
			}
		}
	}

	if ( num > 0 )
	{
		for ( i=0; i<num; i++ )
			sum += List[i].Priority;
		r = FRand() * sum;
		sum = 0;
		for ( i=0; i<num; i++ )
		{
			sum += List[i].Priority;
			if ( r <= sum )
				return List[i];
		}
		return List[0];
	}
	return none;
}

function AssaultPath FindPreviousPath(name AlternatePathTag)
{
	local AssaultPath A;
	local AssaultPath List[16];
	local int i,num;
	local float sum,r;

	for ( A=AssociatedObjective.AlternatePaths; A!=None; A=A.NextPath )
	{
		if ( A.bEnabled && (A.Position < Position) && A.HasPathTag(AlternatePathTag) && !A.bNoReturn )
		{
			if ( (List[0] == None) || (A.Position == List[0].Position) )
			{
				List[num] = A;
				num++;
				if ( num > 15 )
					break;
			}
			else if ( A.Position < List[0].Position )
				break;
		}
	}

	if ( num > 0 )
	{
		for ( i=0; i<num; i++ )
			sum += List[i].Priority;
		r = FRand() * sum;
		sum = 0;
		for ( i=0; i<num; i++ )
		{
			sum += List[i].Priority;
			if ( r <= sum )
				return List[i];
		}
		return List[0];
	}
	return none;
}

defaultproperties
{
	bLastPath=true
	bFirstPath=true
	bEnabled=true
	Priority=+1.0
}
//=============================================================================
// Object to facilitate loading a checkpoint state when the map is loaded
//
// << GBX/PAD:created -- entire file
//
//=============================================================================

class CheckpointManager extends Info
	placeable;



var()	export	editinline	array<name>				CheckpointEvents;		// A list of Events to fire depending on which checkpoint is loaded.

function PostLoadGame()
{
	SetTimer( 0.1, false );
}

function Timer()
{
	local int nIdx;
	
	if (Level.Game.IsA('WargameSkirmish'))
	{
		nIdx = Level.MissionManager.SkirmishGetCheckpointID();
	}
	else
	{
		nIdx = Level.MissionManager.GetCheckpointID();
	}
	
	log(self$".PostLoadGame() - "$nIdx$" - "$CheckpointEvents[ nIdx ]);
	TriggerEvent( CheckpointEvents[ nIdx ], self, None );
}

defaultproperties
{
     bStatic=False
     bHidden=True
	 Texture=Texture'Engine.S_Keypoint'
}
class GameObjective extends NavigationPoint
	abstract;



var bool bDisabled;		// true when objective has been destroyed
var bool bFirstObjective; // First objective in list of objectives defended by same team
var() bool bTeamControlled;	// disabling changes the objectives team rather than removing it
var() bool bAccruePoints;	// controlling team accrues points
var bool bHasShootSpots;

var() byte DefenderTeamIndex;	// 0 = defended by team 0
var byte StartTeam;
var() byte DefensePriority;	// Higher priority defended/attacked first
var() int Score;			// score given to player that completes this objective
var() localized string ObjectiveName;
var() localized string DestructionMessage;
var() localized string LocationPrefix, LocationPostfix;
var() Name DefenseScriptTags;	// tags of scripts that are defense scripts

var GameObjective NextObjective;	// list of objectives defended by the same team
var ScriptedSequence DefenseScripts;
var AssaultPath AlternatePaths;
var() name AreaVolumeTag;
var Volume MyBaseVolume;
var() float BaseExitTime;		// how long it takes to get entirely away from the base
var() float BaseRadius;			// radius of base

var localized string ObjectiveStringPrefix, ObjectiveStringSuffix;

function float GetDifficulty()
{
	return 0;
}

function bool CanDoubleJump(Pawn Other)
{
	return true;
}

function PostBeginPlay()
{
	local GameObjective O, CurrentObjective;
	local AssaultPath A;

	Super.PostBeginPlay();

	StartTeam = DefenderTeamIndex;

	// add to objective list
	if ( bFirstObjective )
	{
		CurrentObjective = self;
		ForEach AllActors(class'GameObjective',O)
			if ( O != CurrentObjective )
			{
				CurrentObjective.NextObjective = O;
				O.bFirstObjective = false;
				CurrentObjective = O;
			}
	}

	// set up AssaultPaths
	ForEach AllActors(class'AssaultPath', A)
		if ( A.ObjectiveTag == Tag )
			A.AddTo(self);

	// find AreaVolume
	ForEach AllActors(class'Volume', MyBaseVolume, AreaVolumeTag)
		break;

	if ( (MyBaseVolume != None) && (MyBaseVolume.LocationName ~= "unspecified") )
		MyBaseVolume.LocationName = LocationPrefix@GetHumanReadableName()@LocationPostfix;

	if ( bAccruePoints )
		SetTimer(1.0,true);
}

function PlayAlarm();

function Timer()
{
	if ( DefenderTeamIndex < 2 )
	{
		WargameTeamGame(Level.Game).Teams[DefenderTeamIndex].Score += Score;
		Level.Game.TeamScoreEvent(DefenderTeamIndex,Score,"game_objective_score");
	}
}

simulated function string GetHumanReadableName()
{
	if ( Default.ObjectiveName != "" )
		return Default.ObjectiveName;

	return ObjectiveStringPrefix$class'TeamInfo'.Default.ColorNames[DefenderTeamIndex]$ObjectiveStringSuffix;
}

function int GetNumDefenders()
{
	return 0;
}

function DisableObjective(Pawn Instigator)
{
	if ( DestructionMessage != "" )
	{
		if ( DestructionMessage == Default.DestructionMessage )
			DestructionMessage = WargameTeamGame(Level.Game).Teams[DefenderTeamIndex].TeamName@DestructionMessage;
		Level.Game.Broadcast(self,DestructionMessage,'CriticalEvent');
	}
	if ( bTeamControlled )
		DefenderTeamIndex = Instigator.PlayerReplicationInfo.Team.TeamIndex;
	else
		bDisabled = true;

	TriggerEvent(Event, self, Instigator);
	if ( bAccruePoints )
		Level.Game.ScoreObjective(Instigator.PlayerReplicationInfo, 0);
	else
		Level.Game.ScoreObjective(Instigator.PlayerReplicationInfo, Score);

	WargameTeamGame(Level.Game).FindNewObjectives(self);
}

function bool BetterObjectiveThan(GameObjective Best, byte DesiredTeamNum, byte RequesterTeamNum)
{
	if ( bDisabled || (DefenderTeamIndex != DesiredTeamNum) )
		return false;
	if ( (Best == None) || (Best.DefensePriority < DefensePriority) )
		return true;
	return false;
}

/* Reset()
reset actor to initial state - used when restarting level without reloading.
*/
function Reset()
{
	Super.Reset();
	bDisabled = false;
	DefenderTeamIndex = StartTeam;
}

defaultproperties
{
	ObjectiveStringPrefix=""
	ObjectiveStringSuffix=" Team Base"
	BaseExitTime=+8.0
	BaseRadius=+2000.0
	bReplicateMovement=false
	bOnlyDirtyReplication=true
	bMustBeReachable=true
	DestructionMessage="Objective Disabled!"
	bFirstObjective=true
	ObjectiveName=""
	LocationPrefix="Near"
	LocationPostfix=""
}
class gbxCheatManager extends Engine.CheatManager within WargamePlayerController;



exec function GiveGrenade( optional int amt )
{
	local int i;

	amt = Max( 1, amt );

	for( i = 0; i < amt; i++ )
		gbxPawn(Pawn).CreateInventory("gbxInventory.UsableUSHandGrenade");
}

// Overridden from parent class.
exec function KillAll(class<actor> aClass)
{
	local Actor A;

	if ( ClassIsChildOf(aClass, class'Pawn') )
	{
		KillAllPawns(class<Pawn>(aClass));
		return;
	}
	ForEach DynamicActors(class 'Actor', A)
		if ( ClassIsChildOf(A.class, aClass) )
			A.Destroy();
}

// Overridden from parent class.
// Kill non-player pawns and their controllers
function KillAllPawns(class<Pawn> aClass)
{
	local Pawn P;

	ForEach DynamicActors(class'Pawn', P)
		if ( ClassIsChildOf(P.Class, aClass)
			&& !P.IsHumanControlled() )
		{
			if ( P.Controller != None )
				P.Controller.Destroy();
			P.Destroy();
		}
}

exec function NoClip()
{
	if( bCheatFlying && ( !Pawn.bCollideActors || !Pawn.bCollideWorld || !Pawn.bBlockActors || !Pawn.bBlockPlayers ))
	{
		Walk();
	}
	else
	{
		Ghost();
	}
}

exec function PrintLoc()
{
	ClientMessage("Your location is "$Pawn.Location.X$" "$Pawn.Location.Y$" "$Pawn.Location.Z);
}

exec function WhoAreYou()
{
	local vector TraceStart, TraceEnd, HitLocation, HitNormal;
	local Actor HitActor;
	local Pawn ViewPawn;

	ViewPawn = Pawn(ViewTarget);

	if (ViewPawn != None)
	{
		TraceStart = ViewPawn.Location + ViewPawn.EyePosition();
		// USE THE CONTROLLER'S ROTATION, NOT THE PAWN'S ROTATION, THE PAWN'S ROTATION.PITCH IS ALWAYS 0 WHEN NOT IN GHOST MODE!!!
		TraceEnd = TraceStart + ( vect( 1,0,0 ) >> ViewPawn.Controller.Rotation ) * 1000000;

		HitActor = Trace(HitLocation, HitNormal, TraceEnd, TraceStart, true);

		if ((HitActor != None) && (!HitActor.IsA('LevelInfo')))
		{
			if (HitActor.DrawType == DT_Sprite)
				ClientMessage("You are looking at " $ HitActor.name $ "  Asset Name = " $ HitActor.Texture.name);
			else if (HitActor.DrawType == DT_Mesh)
				ClientMessage("You are looking at " $ HitActor.name $ "  Asset Name = " $ HitActor.Mesh.name);
			else if (HitActor.DrawType == DT_StaticMesh)
				ClientMessage("You are looking at " $ HitActor.name $ "  Asset Name = " $ HitActor.StaticMesh.name);
			else
				ClientMessage("You are looking at " $ HitActor.name);
		}
		else
			ClientMessage("You are not looking at anything");
	}
}

exec function Ver()
{
	Level.bShowBuildLabel = !Level.bShowBuildLabel;
}

class gbxConsole extends WindowConsole;


class gbxDebugBrightnessCW extends UWindowDialogClientWindow;


var gbxWindowListBox		CommandListCtrl;

var	int	m_nSelectedIdx;
var int ScrollPos;

function Created()
{
	CommandListCtrl = gbxWindowListBox(CreateWindow(class'gbxWindowListBox', 0, 0, WinWidth, WinHeight));

	Cursor = Root.NormalCursor;
}

function Resized()
{
	Super.Resized();

	CommandListCtrl.SetSize( WinWidth, WinHeight );
}

function ShowWindow()
{
	local gbxWindowListBoxItem	aSelected;
	local PlayerController		anOwner;

	Super.ShowWindow();

	anOwner = GetPlayerOwner();

	if (anOwner == None)
		return;

	CommandListCtrl.ClearList();

	aSelected = gbxWindowListBoxItem(CommandListCtrl.AddItem("Brightness +"));
	aSelected.HelpText = "Brightness +";
	CommandListCtrl.SetSelectedItem( aSelected );
	CommandListCtrl.VertSB.Show(0);
	m_nSelectedIdx = 0;

	ScrollPos = 0;

	aSelected = gbxWindowListBoxItem(CommandListCtrl.AddItem("Gamma +"));
	aSelected.HelpText = "Gamma +";
	aSelected = gbxWindowListBoxItem(CommandListCtrl.AddItem("Contrast +"));
	aSelected.HelpText = "Contrast +";
	aSelected = gbxWindowListBoxItem(CommandListCtrl.AddItem("Default Brightness/Gamma/Contrast"));
	aSelected.HelpText = "DefaultBrightness";
}

function NextListItem()
{
	local	int	nCount;
	local UWindowListBoxItem	aSelected;

	nCount = CommandListCtrl.Count();

	m_nSelectedIdx++;
	if (m_nSelectedIdx >= nCount)
		m_nSelectedIdx--;
	else
	{
		aSelected = CommandListCtrl.GetItemAtIdx( m_nSelectedIdx );
		CommandListCtrl.SetSelectedItem( aSelected );
		ScrollPos++;
		if ((CommandListCtrl.ItemHeight * ScrollPos) > (WinHeight - CommandListCtrl.ItemHeight))
		{
			ScrollPos--;
			CommandListCtrl.VertSB.Scroll(1);
		}
	}
}

function PrevListItem()
{
	local	int	nCount;
	local UWindowListBoxItem	aSelected;

	nCount = CommandListCtrl.Count();

	m_nSelectedIdx--;
	if (m_nSelectedIdx < 0)
		m_nSelectedIdx++;
	else
	{
		aSelected = CommandListCtrl.GetItemAtIdx( m_nSelectedIdx );
		CommandListCtrl.SetSelectedItem( aSelected );
		ScrollPos--;
		if ((CommandListCtrl.ItemHeight * ScrollPos) < 0)
		{
			ScrollPos++;
			CommandListCtrl.VertSB.Scroll(-1);
		}
	}
}

function ExecDebugCommand()
{
	local UWindowListBoxItem aSelected;

	aSelected = CommandListCtrl.GetItemAtIdx( m_nSelectedIdx );

	if (aSelected.HelpText == "DefaultBrightness")
	{
		if( !Root.ConsoleCommand( "Brightness 0.5" ) )
			Message( Localize("Errors","Exec","Core"), 6.0 );
		if( !Root.ConsoleCommand( "Contrast 0.5" ) )
			Message( Localize("Errors","Exec","Core"), 6.0 );
		if( !Root.ConsoleCommand( "Gamma 1.0" ) )
			Message( Localize("Errors","Exec","Core"), 6.0 );
	}
	else
	{
		if( !Root.ConsoleCommand( aSelected.HelpText ) )
			Message( Localize("Errors","Exec","Core"), 6.0 );
	}
}

function bool KeyEvent( out EInputKey Key, out EInputAction Action, FLOAT Delta )
{
	if (!bWindowVisible)
		return false;

	if (Action == IST_Press)
	{
		switch (Key)
		{
			case IK_Joy10:		// Down
			case IK_Down:
				NextListItem();
				break;
			case IK_Joy9:		// Up
			case IK_Up:
				PrevListItem();
				break;
			case IK_Joy11:		// Left
			case IK_Left:
				break;
			case IK_Joy12:		// Right
			case IK_Right:
				break;
			case IK_Joy8:		// Select
			case IK_Joy1:		// 'A'
			case IK_Enter:
				ExecDebugCommand();
				break;
		}
	}
	if (Action == IST_Axis)
	{
	}

	return Super.KeyEvent(Key,Action,Delta);
}

function WindowEvent(WinMessage Msg, Canvas C, float X, float Y, int Key)
{
	if ((Msg == WM_KeyUp) || (Msg == WM_KeyDown))
		return;

	Super.WindowEvent(Msg, C, X, Y, Key);
}

defaultproperties
{
}
class gbxDebugMapListBox extends gbxWindowListBox;



function Created()
{
	Super.Created();
}

function DrawItem(Canvas C, UWindowList Item, float X, float Y, float W, float H)
{
	if(UDebugMapList(Item).bSelected)
	{
		C.SetDrawColor(0,0,128);
		DrawStretchedTexture(C, X, Y, W, H-1, Texture'WhiteTexture');
		C.SetDrawColor(255,255,255);
	}
	else
	{
		C.SetDrawColor(0,0,0);
	}

	ClipText(C, X, Y, UDebugMapList(Item).DisplayName);
}


defaultproperties
{
	ListClass=class'UDebugMapList'
	ItemHeight=10
}
class gbxDebugMapListCW extends UWindowDialogClientWindow;



var gbxDebugMapListBox MapList;
var	int	m_nSelectedIdx;
var bool bStartListenServer;
var int ScrollPos;

function Created()
{
	WinWidth = Min(400, Root.WinWidth - 50);
	WinHeight = Min(210, Root.WinHeight - 50);

	Super.Created();

	MapList = gbxDebugMapListBox(CreateWindow(class'gbxDebugMapListBox', 0, 0, WinWidth, WinHeight, Self));
	LoadMapList();

	ScrollPos = 0;
}

function Resized()
{
	MapList.WinWidth = WinWidth;
	MapList.WinHeight = WinHeight;
	MapList.VertSB.WinLeft = MapList.WinWidth-MapList.VertSB.WinWidth;
	MapList.VertSB.WinHeight=MapList.WinHeight;
}

function LoadMapList()
{
	local string FirstMap, NextMap, TestMap;
	local UDebugMapList L;
	local bool bFirst;

	if (GetPlayerOwner() != None)
	{
		FirstMap = GetPlayerOwner().GetMapName("", "", 0);
		NextMap = FirstMap;
		bFirst = false;
		MapList.VertSB.Scroll(-200);
		MapList.ClearList();
		while (!(FirstMap ~= TestMap))
		{
			L = UDebugMapList(MapList.Items.Append(class'UDebugMapList'));
			L.MapName = NextMap;
			if(Right(NextMap, 4) ~= ".gbxmap")
				L.DisplayName = Left(NextMap, Len(NextMap) - 4);
			else
				L.DisplayName = NextMap;

			if (!bFirst)
			{
				MapList.SetSelectedItem( L );
				m_nSelectedIdx = 0;
				bFirst = true;
			}

			NextMap = GetPlayerOwner().GetMapName("", NextMap, 1);
			TestMap = NextMap;
		}

		MapList.Sort();

		L = UDebugMapList(MapList.GetItemAtIdx( 0 ));
		MapList.SetSelectedItem( L );
	}
}

function NextListItem()
{
	local	int	nCount;
	local	UWindowListBoxItem	aSelected;

	nCount = MapList.Count();

	m_nSelectedIdx++;
	if (m_nSelectedIdx >= nCount)
		m_nSelectedIdx--;
	else
	{
		aSelected = MapList.GetItemAtIdx( m_nSelectedIdx );
		MapList.SetSelectedItem( aSelected );
		ScrollPos++;
		if ((MapList.ItemHeight * ScrollPos) > (WinHeight - MapList.ItemHeight))
		{
			ScrollPos--;
			MapList.VertSB.Scroll(1);
		}
	}
}

function PrevListItem()
{
	local	int	nCount;
	local UWindowListBoxItem	aSelected;

	nCount = MapList.Count();

	m_nSelectedIdx--;
	if (m_nSelectedIdx < 0)
		m_nSelectedIdx++;
	else
	{
		aSelected = MapList.GetItemAtIdx( m_nSelectedIdx );
		MapList.SetSelectedItem( aSelected );
		ScrollPos--;
		if ((MapList.ItemHeight * ScrollPos) < 0)
		{
			ScrollPos++;
			MapList.VertSB.Scroll(-1);
		}
	}
}

function ExecDebugCommand()
{
	local UDebugMapList	aSelected;
	aSelected = UDebugMapList(MapList.GetItemAtIdx( m_nSelectedIdx ));
	if (!bStartListenServer)
	{
		if( !Root.ConsoleCommand( "open "$aSelected.MapName ) )
			Message( Localize("Errors","Exec","Core"), 6.0 );
	}
	else
	{
		//if( !Root.ConsoleCommand( "open "$aSelected.MapName$"?game=gbxGameplay.WargameMultiplayer?Listen -lanplay=1 -nocheat=0" ) )
		if( !Root.ConsoleCommand( "open "$aSelected.MapName$"?game=gbxGameplay.WargameMultiplayer?Listen" ) )
			Message( Localize("Errors","Exec","Core"), 6.0 );
	}
}

function bool KeyEvent( out EInputKey Key, out EInputAction Action, FLOAT Delta )
{
	if (!bWindowVisible)
		return false;

	if (Action == IST_Press)
	{
		switch (Key)
		{
			case IK_Joy10:		// Down
			case IK_Down:
				NextListItem();
				break;
			case IK_Joy9:		// Up
			case IK_Up:
				PrevListItem();
				break;
			case IK_Joy11:		// Left
			case IK_Left:
				break;
			case IK_Joy12:		// Right
			case IK_Right:
				break;
			case IK_Joy8:		// Select
			case IK_Joy1:		// 'A'
			case IK_Enter:
				if (Root.fDelayTime < 0.0f)
					ExecDebugCommand();
				break;
		}
	}
	if (Action == IST_Axis)
	{
	}

	return Super.KeyEvent(Key,Action,Delta);
}

function WindowEvent(WinMessage Msg, Canvas C, float X, float Y, int Key)
{
	if (Msg==WM_KeyDown)
	{
		if (Key==236)
			MapList.VertSB.Scroll(-1);
		else if (Key==237)
			MapList.VertSB.Scroll(+1);

		return;
	}

	Super.WindowEvent(MSg,C,X,Y,Key);
}

defaultproperties
{
	bStartListenServer=false
}
class gbxDebugServerEntry extends UWindowListBoxItem;



var string DisplayName;
var int BeaconIndex;
class gbxDebugServerListBox extends gbxWindowListBox;



function Created()
{
	Super.Created();
}

function DrawItem(Canvas C, UWindowList Item, float X, float Y, float W, float H)
{
	if(gbxDebugServerEntry(Item).bSelected)
	{
		C.SetDrawColor(0,0,128);
		DrawStretchedTexture(C, X, Y, W, H-1, Texture'WhiteTexture');
		C.SetDrawColor(255,255,255);
	}
	else
	{
		C.SetDrawColor(0,0,0);
	}

	ClipText(C, X, Y, gbxDebugServerEntry(Item).DisplayName);
}


defaultproperties
{
	ListClass=class'gbxDebugServerEntry'
	ItemHeight=12
}
class gbxDebugServerListCW extends UWindowDialogClientWindow;



var gbxDebugServerListBox ServerList;
var	int	m_nSelectedIdx;
var int ScrollPos;

var gbxDebugServerListQuery DebugServerListQuery;

function Created()
{
	WinWidth = Min(400, Root.WinWidth - 50);
	WinHeight = Min(210, Root.WinHeight - 50);

	Super.Created();

	ServerList = gbxDebugServerListBox(CreateWindow(class'gbxDebugServerListBox', 0, 0, WinWidth, WinHeight, Self));

	ScrollPos = 0;
}

function Resized()
{
	ServerList.WinWidth = WinWidth;
	ServerList.WinHeight = WinHeight;
	ServerList.VertSB.WinLeft = ServerList.WinWidth-ServerList.VertSB.WinWidth;
	ServerList.VertSB.WinHeight=ServerList.WinHeight;
}

function LoadServerList()
{
	local gbxDebugServerEntry L;

	ServerList.VertSB.Scroll(-200);
	ServerList.ClearList();

	L = gbxDebugServerEntry(ServerList.Items.Append(class'gbxDebugServerEntry'));
	L.BeaconIndex = -1;
	L.DisplayName = "Scanning for ListenServers (please wait)...";

	DebugServerListQuery = Root.ViewportOwner.Actor.Spawn(class'gbxDebugServerListQuery');
	DebugServerListQuery.ServerList = ServerList;
	DebugServerListQuery.ServerListCW = self;
}

function NextListItem()
{
	local	int	nCount;
	local	UWindowListBoxItem	aSelected;

	nCount = ServerList.Count();

	m_nSelectedIdx++;
	if (m_nSelectedIdx >= nCount)
		m_nSelectedIdx--;
	else
	{
		aSelected = ServerList.GetItemAtIdx( m_nSelectedIdx );
		ServerList.SetSelectedItem( aSelected );
		ScrollPos++;
		if ((ServerList.ItemHeight * ScrollPos) > (WinHeight - ServerList.ItemHeight))
		{
			ScrollPos--;
			ServerList.VertSB.Scroll(1);
		}
	}
}

function PrevListItem()
{
	local	int	nCount;
	local UWindowListBoxItem	aSelected;

	nCount = ServerList.Count();

	m_nSelectedIdx--;
	if (m_nSelectedIdx < 0)
		m_nSelectedIdx++;
	else
	{
		aSelected = ServerList.GetItemAtIdx( m_nSelectedIdx );
		ServerList.SetSelectedItem( aSelected );
		ScrollPos--;
		if ((ServerList.ItemHeight * ScrollPos) < 0)
		{
			ScrollPos++;
			ServerList.VertSB.Scroll(-1);
		}
	}
}

function HideWindow()
{
	if (DebugServerListQuery != None)
		DebugServerListQuery.Destroy();  // kill the broadcast socket object

	Super.HideWindow();
}

function ExecDebugCommand()
{
	local gbxDebugServerEntry	aSelected;
	local string serverConnectString;
	
	aSelected = gbxDebugServerEntry(ServerList.GetItemAtIdx( m_nSelectedIdx ));
	serverConnectString = DebugServerListQuery.GetBeaconAddress(aSelected.BeaconIndex);

	HideWindow();
	Root.CloseActiveWindow();
	GotoState('');
	
	if (aSelected.BeaconIndex != -1)
	{
		if( !Root.ConsoleCommand( "open "$ serverConnectString) )
			Message( Localize("Errors","Exec","Core"), 6.0 );
	}
}

function bool KeyEvent( out EInputKey Key, out EInputAction Action, FLOAT Delta )
{
	if (!bWindowVisible)
		return false;

	if (Action == IST_Press)
	{
		switch (Key)
		{
			case IK_Joy10:		// Down
			case IK_Down:
				NextListItem();
				break;
			case IK_Joy9:		// Up
			case IK_Up:
				PrevListItem();
				break;
			case IK_Joy11:		// Left
			case IK_Left:
				break;
			case IK_Joy12:		// Right
			case IK_Right:
				break;
			case IK_Joy8:		// Select
			case IK_Joy1:		// 'A'
			case IK_Enter:
				ExecDebugCommand();
				break;
		}
	}
	if (Action == IST_Axis)
	{
	}

	return Super.KeyEvent(Key,Action,Delta);
}

function WindowEvent(WinMessage Msg, Canvas C, float X, float Y, int Key)
{
	if (Msg==WM_KeyDown)
	{
		if (Key==236)
			ServerList.VertSB.Scroll(-1);
		else if (Key==237)
			ServerList.VertSB.Scroll(+1);

		return;
	}

	Super.WindowEvent(MSg,C,X,Y,Key);
}

defaultproperties
{
}
class gbxDebugServerListQuery extends ClientBeaconReceiver
	notplaceable;



var gbxDebugServerListBox ServerList;
var gbxDebugServerListCW ServerListCW;
var bool bInitialResponse;
var int server_count;

// Initialize.
function PreBeginPlay()
{
	//LinkMode = MODE_Text;
	//ReceiveMode = RMODE_Event;

	bInitialResponse = true;
	server_count = 0;
	
	SetTimer(5.0, false);
}

function BeginPlay()
{	
	Super.BeginPlay();
	
	BroadcastQuery();
}

// Received a response
event ReceivedText( IpAddr Addr, string Text )
{    
	local gbxDebugServerEntry L;
	local int usedCount;
	
	log(self $ " gbxDebugServerListQuery::ReceivedText(): Addr = " $ IpAddrToString(Addr) $ ", text = " $ text);
	
	Super.ReceivedText(Addr, Text);
	
	usedCount = GetUsedBeaconCount();
	
	if (usedCount > server_count)
	{
		if (bInitialResponse)
		{
			ServerList.VertSB.Scroll(-200);
			ServerList.ClearList();
		}

		L = gbxDebugServerEntry(ServerList.Items.Append(class'gbxDebugServerEntry'));
		L.BeaconIndex = usedCount - 1;
		L.DisplayName = GetBeaconText(usedCount - 1);
		
		log(self $ " gbxDebugServerListQuery::ReceivedText(): Adding index = " $ L.BeaconIndex $ ", text = " $ L.DisplayName);

		if (bInitialResponse)
		{
			ServerList.SetSelectedItem( L );
			ServerListCW.m_nSelectedIdx = 0;
			bInitialResponse = false;
		}

		server_count++;
	}
}

function Timer()
{
	local gbxDebugServerEntry L;

	if (server_count == 0)
	{
		ServerList.VertSB.Scroll(-200);
		ServerList.ClearList();

		L = gbxDebugServerEntry(ServerList.Items.Append(class'gbxDebugServerEntry'));
		L.BeaconIndex = -1;
		L.DisplayName = "No Listen Servers Found";
	}
}

function int GetUsedBeaconCount()
{
	local int x;
	local int usedCount;
	
	usedCount = 0;
	for (x = 0;x < GetBeaconCount();x++)
	{
		if (GetBeaconText(x) == "")
		{
			break;
		}
		
		usedCount++;
	}
    
    return usedCount;
}//======================================================================================================
// gbxFireTeamSpawnControllerSkirmish: Controls the spawning of player fire teams in skirmish matches.
//======================================================================================================
class gbxFireTeamSpawnControllerSkirmish extends gbxBaseFireTeamSpawnController;

var() Name SoloAssaultTeam;
var() Name CoopAssaultTeam;

var() Name SoloBaseOfFireTeam;
var() Name CoopBaseOfFireTeam;
var int	nTODAssaultMembers;
var int	nTODBaseMembers;

function Trigger(Actor Other, Pawn EventInstigator)
{
	local WargameSkirmish gi;
	local int teamSize;

	gi = WargameSkirmish(Level.Game);

	if (gi.GameType == SGT_TourOfDuty)
	{
		// Is this a solo or coop game?
		if ( gi.PlayerTeam == TEAM_German )
			teamSize = gi.GetTeam(TEAM_German).Size;
		else 
			teamSize = gi.GetTeam(TEAM_US).Size;

//		if (teamSize == 1)
//		{
			nTODAssaultMembers = gi.iFireTeams[0];
			nTODBaseMembers = gi.iFireTeams[1];
//		}
//		else
//		{
//			nTODBaseMembers = gi.iFireTeams[1];
//			nTODAssaultMembers = gi.iFireTeams[0];
//			if ((nTODBaseMembers == 0) && (nTODAssaultMembers >= 2))
//			{
//				nTODBaseMembers = nTODBaseMembers + 1;
//				nTODAssaultMembers = nTODAssaultMembers - 1;
//			}
//			else if ((nTODAssaultMembers == 0) && (nTODBaseMembers >= 2))
//			{
//				nTODAssaultMembers = nTODAssaultMembers + 1;
//				nTODBaseMembers = nTODBaseMembers - 1;
//			}
//		}
	}
	Super.Trigger( Other, EventInstigator );
}

function Name GetAppropriateFireTeamName(EUnitType UnitType)
{
	local Name result;
	local int teamSize;
	local WargameSkirmish gi;

	result = 'None';

	if ( Level.Game.IsA( 'WargameSkirmish' ) )
	{
		gi = WargameSkirmish(Level.Game);

		// Is this a solo or coop game?
		if ( gi.PlayerTeam == TEAM_German )
	        teamSize = gi.GetTeam(TEAM_German).Size;
		else 
			teamSize = gi.GetTeam(TEAM_US).Size;
				
		log( self$ " gbxFireTeamSpawnControllerSkirmish::GetAppropriateFireTeamName() teamSize: "$teamSize, 'MP' );

		if ( teamSize == 1 )			// solo
		{
			log( self$ " gbxFireTeamSpawnControllerSkirmish::GetAppropriateFireTeamName() teamSize == 1", 'MP' );
			if (UnitType == UnitType_Assault)
			{
				log( self$ " gbxFireTeamSpawnControllerSkirmish::GetAppropriateFireTeamName() result == HeadsUpAssaultTeam", 'MP' );
				result = SoloAssaultTeam;
			}
			else if (UnitType == UnitType_Base)
			{
				log( self$ " gbxFireTeamSpawnControllerSkirmish::GetAppropriateFireTeamName() result == HeadsUpBaseOfFireTeam", 'MP' );
				result = SoloBaseOfFireTeam;
			}
		}
		else if ( teamSize == 2 )		// co-op game
		{
			log( self$ " gbxFireTeamSpawnControllerSkirmish::GetAppropriateFireTeamName() teamSize == 2", 'MP' );
			if (UnitType == UnitType_Assault)
			{
				log( self$ " gbxFireTeamSpawnControllerSkirmish::GetAppropriateFireTeamName() result == PairedAssaultTeam", 'MP' );
				result = CoopAssaultTeam;
			}
			else if (UnitType == UnitType_Base)
			{
				log( self$ " gbxFireTeamSpawnControllerSkirmish::GetAppropriateFireTeamName() result == PairedBaseOfFireTeam", 'MP' );
				result = CoopBaseOfFireTeam;
			}
		}
	}
	else
	{
		log( self$ " gbxFireTeamSpawnControllerSkirmish::GetAppropriateFireTeamName() Level.Game is not a WargameSkirmish game!", 'MP' );
	}
	
	log( self$ " gbxFireTeamSpawnControllerSkirmish::GetAppropriateFireTeamName() Returning "$result$ " as the appropriate fire team name.", 'MP' );

	return result;
}

function TriggerTeamForMemoryReport()
{
	if (CoopAssaultTeam != 'None')
	{
		TriggerEvent(CoopAssaultTeam, self, None);
	}
	
	if (SoloAssaultTeam != 'None')
	{
		TriggerEvent(SoloAssaultTeam, self, None);
	}
}

function bool IsPlayerUnderdog(ETeamIdentifier Team)
{
	// Returning false for now.  What happens if we're playing a coop game and the client leaves?
	// Does the server keep playing at the coop difficulty?  
	return false;
}

function TriggerTeam(name fireTeam, PlayerController PC)
{	
	Log(self$ " gbxBaseFireTeamSpawnControllerSkirmish::TriggerTeam() fireTeamName: "$fireTeam$ " PC: "$PC$ " PC.PlayerReplicationInfo.NumLives: "$PC.PlayerReplicationInfo.NumLives, 'MP');
	
	if (fireTeam != 'None')
	{
		TriggerEvent(fireTeam, self, None);

		// Lame hack relying on the fact that this is None until the first spawn completes (See GameInfo.uc) 2005-01-19 JWS
		PC.PlayerReplicationInfo.bOutofLives = true;
	}
}

function TriggerAssaultTeam(PlayerController PC)
{
	local gbxCharacterSpawner	aSpawner;
	local Name FireTeamName;
	local WargameSkirmish gi;
	local int nCheckpointID, nIdx, nHealth;

	gi = WargameSkirmish(Level.Game);

	Log(self$ " gbxBaseFireTeamSpawnControllerSkirmish::TriggerAssaultTeam() PC: "$PC$" - "$gi.GameType$" - "$nTODAssaultMembers, 'MP');

	FireTeamName = GetAppropriateFireTeamName(UnitType_Assault);

	if ((gi.GameType == SGT_TourOfDuty) && (nTODAssaultMembers != -1))
	{
		foreach DynamicActors( class'gbxCharacterSpawner', aSpawner, FireTeamName )
		{
			if (nTODAssaultMembers > 0)
			{
				nTODAssaultMembers = nTODAssaultMembers - 1;
				continue;
			}
			aSpawner.bSpawnDisabled = true;
		}
	}
	else if (gi.GameType == SGT_Objective)
	{
		nCheckpointID = Level.MissionManager.SkirmishGetCheckpointID();
		if ((nCheckpointID > 0) && !(Level.MissionManager.SkirmishPawnRespawn()))
		{
			nIdx = 0;
			foreach DynamicActors( class'gbxCharacterSpawner', aSpawner, FireTeamName )
			{
				if (aSpawner.bSpawnDisabled)
				{
					continue;
				}
				// GBX:PAD: I hate enum's with a passion in this engine, so the "1" I'm passing in here is the second
				// enum for the unit types.
				if (Level.MissionManager.SkirmishGetCheckpointPawnHealth( AnimPawn(PC.Pawn), nIdx, 0, nHealth ))
				{
					aSpawner.nSpawnHealth = nHealth;
					if (nHealth <= 0)
					{
						aSpawner.bSpawnDisabled = true;
					}
				}
				else
				{
					aSpawner.bSpawnDisabled = true;
				}
				nIdx++;
			}
		}
	}
	TriggerTeam(FireTeamName, PC);
}

function TriggerBaseOfFireTeam(PlayerController PC)
{
	local gbxCharacterSpawner	aSpawner;
	local Name FireTeamName;
	local WargameSkirmish gi;
	local int nCheckpointID, nIdx, nHealth;

	gi = WargameSkirmish(Level.Game);
	
	Log(self$ " gbxBaseFireTeamSpawnControllerSkirmish::TriggerBaseOfFireTeam() PC: "$PC$" - "$gi.GameType$" - "$nTODAssaultMembers, 'MP');

	FireTeamName = GetAppropriateFireTeamName(UnitType_Base);

	if ((gi.GameType == SGT_TourOfDuty) && (nTODBaseMembers != -1))
	{
		foreach DynamicActors( class'gbxCharacterSpawner', aSpawner, FireTeamName )
		{
			if (nTODBaseMembers > 0)
			{
				nTODBaseMembers = nTODBaseMembers - 1;
				continue;
			}
			aSpawner.bSpawnDisabled = true;
		}
	}
	else if (gi.GameType == SGT_Objective)
	{
		nCheckpointID = Level.MissionManager.SkirmishGetCheckpointID();
		if ((nCheckpointID > 0) && !(Level.MissionManager.SkirmishPawnRespawn()))
		{
			nIdx = 0;
			foreach DynamicActors( class'gbxCharacterSpawner', aSpawner, FireTeamName )
			{
				if (aSpawner.bSpawnDisabled)
				{
					continue;
				}
				// GBX:PAD: I hate enum's with a passion in this engine, so the "1" I'm passing in here is the second
				// enum for the unit types.
				if (Level.MissionManager.SkirmishGetCheckpointPawnHealth( AnimPawn(PC.Pawn), nIdx, 1, nHealth ))
				{
					aSpawner.nSpawnHealth = nHealth;
					if (nHealth <= 0)
					{
						aSpawner.bSpawnDisabled = true;
					}
				}
				else
				{
					aSpawner.bSpawnDisabled = true;
				}
				nIdx++;
			}
		}
	}
	TriggerTeam(FireTeamName, PC);
}

defaultproperties
{
}
//=============================================================================
// gbxInspectorObjectiveList
// Display an objectivelist, dishing out the work to gbxInspectorObjective
//=============================================================================
class gbxInspectorObjectiveList extends gbxInspectorPanel;

const OBJECTIVE_LIST_SCALE = 0.80;
const OBJECTIVE_LIST_LONG_SCALE = 0.725;
const OBJECTIVE_LIST_HINT_SCALE = 0.725;
const OBJECTIVE_LIST_ITEM_HEIGHT = 24.0;
const OBJECTIVE_LIST_LONG_INDENT = 8.0;
const OBJECTIVE_LIST_BORDER = 4.0;

static function float DrawObjective( canvas Canvas, ObjectiveInfo drawObjective, gbxHUD Hud, float offsetX, float offsetY, int nPass, float alpha )
{
	local float result;
	local float x1, y1, w, h;
	result = 0;

	if (drawObjective != None)
	{
		Canvas.Font = Hud.WargameFont;

		// Short objective text

		Canvas.DrawColor = Hud.WhiteColor;
		Canvas.DrawColor.A = 255*alpha;

		x1 = offsetX * Hud.ScaleX;
		y1 = offsetY * Hud.ScaleY;
		w = (Default.myWidth - OBJECTIVE_LIST_BORDER) * Hud.ScaleX;
		h = 0.0f;
		
		Canvas.DrawTextBounded( drawObjective.m_szShortDesc, 0, 0, x1, y1, w, h,
								OBJECTIVE_LIST_SCALE * Hud.ScaleX, OBJECTIVE_LIST_SCALE * Hud.ScaleY );

		// Long objective text

		Canvas.SetDrawColor( 192, 192, 192, 192);

		x1 = ( offsetX + OBJECTIVE_LIST_LONG_INDENT ) * Hud.ScaleX;
		y1 = ( offsetY + 4.0 ) * Hud.ScaleY + h;
		w = ( Default.myWidth - OBJECTIVE_LIST_LONG_INDENT - OBJECTIVE_LIST_BORDER ) * Hud.ScaleX;
		h = 0.0f;

		Canvas.DrawTextBounded( drawObjective.m_szLongDesc, 0, 0, x1, y1, w, h,
								  OBJECTIVE_LIST_LONG_SCALE * Hud.ScaleX, OBJECTIVE_LIST_LONG_SCALE * Hud.ScaleY );
	}

	result = OBJECTIVE_LIST_ITEM_HEIGHT;

	return result;
}


static function DrawGBXHud( canvas Canvas, object drawObject, gbxInspectorMan mgr, float offsetX, float offsetY, int nPass, float alpha, float timeSinceShow )
{
	local PlayerController		anOwner;
	local ObjectiveList			anObjectiveList;
	local int					i;
	local float x1, y1, w, h;

	if ( nPass == 1)
	{
		// objectives
		anOwner = mgr.myHud.PlayerOwner;

		//DHW -- Changed to AllActors because the objective list is a static not dynamic actor
		ForEach anOwner.AllActors(class'ObjectiveList', anObjectiveList)
		{
			for (i=0; i<anObjectiveList.Objectives.Length; i++)
			{
				if ( anObjectiveList.Objectives[i].m_eComplete == OI_Active )
				{
					DrawObjective( Canvas, anObjectiveList.Objectives[i], mgr.myHud, offsetX+OBJECTIVE_LIST_BORDER, offsetY, nPass, alpha );
					break;
				}
			}
		}

		// Current hint

		if( mgr.myHud.m_szHintMessage != "" )
		{
			Canvas.DrawColor = mgr.myHud.WhiteColor;
			Canvas.DrawColor.A = 255*alpha;			

			x1 = offsetX * mgr.myHud.ScaleX;
			y1 = offsetY * mgr.myHud.ScaleY;
			w = Default.myWidth * mgr.myHud.ScaleX;
			h = 0.0f;

			// Determine the height
			Canvas.DrawTextBounded( mgr.myHud.m_szHintText$": "$mgr.myHud.m_szHintMessage, 0, 0, x1, y1, w, h,
								OBJECTIVE_LIST_HINT_SCALE * mgr.myHud.ScaleX, OBJECTIVE_LIST_HINT_SCALE * mgr.myHud.ScaleY, true );

			x1 = offsetX * mgr.myHud.ScaleX;
			y1 = ( offsetY + Default.myHeight - OBJECTIVE_LIST_BORDER * 2.0 ) * mgr.myHud.ScaleY  - h;
			w = Default.myWidth * mgr.myHud.ScaleX;
			h = 0.0f;

			// Draw hint justified to the bottom of the panel
			Canvas.DrawTextBounded( mgr.myHud.m_szHintText$": "$mgr.myHud.m_szHintMessage, 0, 0, x1, y1, w, h,
								OBJECTIVE_LIST_HINT_SCALE * mgr.myHud.ScaleX, OBJECTIVE_LIST_HINT_SCALE * mgr.myHud.ScaleY );
		}
	}
}

defaultproperties
{
	myWidth=204
	myHeight=275
}
//=============================================================================
// gbxInspectorPlayer
//=============================================================================
class gbxInspectorPlayer extends gbxInspectorInfantryUSA;

defaultproperties
{
	myNameScale=0.9
	myWidth=145
	myHeight=66
}
//=============================================================================
// Gearbox Multiplayer Player start location.
//=============================================================================
class gbxMPPlayerStart extends gbxPlayerStart
	placeable;

var() ETeamMemberID TeamMemberID;			// which team member can spawn at this start
var() bool RandomInsteadOfTeamMemberID;		// if true, the player start will have a random modifier so that the player doesn't always spawn
											// at the same location. This is used in lieu of normal TeamMemberID spawn rules.
var() bool bNotInObjective;
var() bool bNotInDefense;
var() bool bNotInTimed;

var() Name BriefingRoomViewActor;			// Tag name of an actor to take Location and Rotation from when in briefing room. Set to None to make this actor
											// invalid in the briefing room
var() Name AssignedPawnName;				// If set, this name will be given to the newly spawned player pawn

defaultproperties
{
	RandomInsteadOfTeamMemberID = false
	BriefingRoomViewActor = None
	CollisionHeight = 100.0f	// Fix Bug 5580: inaccuracy could lead to client players popping up and down on spawn. Making the collision height slightly
								// higher than it needs to be fixes this problem, since the players will now spawn just a hair in the air...
}
// Defines reinforcement rules on a per-map basis.
// Created 2004-09-14 JWS
class gbxMPReinforcementRules extends gbxReinforcementRules
	placeable;

// Properties
// The reinforcement rules are defined for each team in each of the following situations:
// Heads up (1v1)
// Paired (2v2)
// Advantaged (2v1)
// Underdog (1v2)

var(Reinforcements) int HeadsUpUS;
var(Reinforcements) int HeadsUpDE;
var(Reinforcements) int PairedUS;
var(Reinforcements) int PairedDE;
var(Reinforcements) int AdvantagedUS;
var(Reinforcements) int AdvantagedDE;
var(Reinforcements) int UnderdogUS;
var(Reinforcements) int UnderdogDE;

// Internal State

function int GetReinforcementsForTeam(ETeamIdentifier TeamID, int USTeamSize, int DETeamSize)
{
	local int result;

	result = 0;

	if (USTeamSize == 1 && DETeamSize == 1)
	{
		if (TeamID == TEAM_US)
		{
			result = HeadsUpUS;
		}
		else if (TeamID == TEAM_German)
		{
			result = HeadsUpDE;
		}
	}
	else if (USTeamSize == 2 && DETeamSize == 2)
	{
		if (TeamID == TEAM_US)
		{
			result = PairedUS;
		}
		else if (TeamID == TEAM_German)
		{
			result = PairedDE;
		}
	}
	else if (USTeamSize == 2 && DETeamSize == 1)
	{
		if (TeamID == TEAM_US)
		{
			result = AdvantagedUS;
		}
		else if (TeamID == TEAM_German)
		{
			result = UnderdogDE;
		}
	}
	else if (USTeamSize == 1 && DETeamSize == 2)
	{
		if (TeamID == TEAM_US)
		{
			result = UnderdogUS;
		}
		else if (TeamID == TEAM_German)
		{
			result = AdvantagedDE;
		}
	}
	else if ( (USTeamSize == 1 && DETeamSize == 0) || (USTeamSize == 0 && DETeamSize == 1) )
	{
		// This case is only supported for debugging purposes...1vs0 is not allowed in the shipping product
		result = 8;
	}

	return result;
}

defaultproperties
{
	HeadsUPUS = 8;
	HeadsUPDE = 8;
	PairedUS = 4;
	PairedDE = 4;
	AdvantagedUS = 4;
	AdvantagedDE = 4;
	UnderdogUS = 10;
	UnderdogDE = 10;
}// GEARBOX 2004-12-11 JWS created
// Used to display MP Training Messages
class gbxMPTrainingMessage extends LocalMessage;

var string GeneralMessageFile;
var string GeneralSkirmishMessageFile;

var string GeneralHintSection;
var string HintCaption;
var string USHintSection;
var string DEHintSection;

// Switch values: 0 = General Message, 1 = Mission Message
static simulated function ClientReceive( 
	PlayerController P,
	optional int Switch,
	optional PlayerReplicationInfo RelatedPRI_1, 
	optional PlayerReplicationInfo RelatedPRI_2,
	optional Object OptionalObject
	)
{
	local gbxHUD HUD;
	local string HintText;
	local string ButtonizedText;

	HUD = gbxHUD(P.MyHud);

	HintText = GetRandomHintText(P, Switch);
	ButtonizedText = HUD.ConvertToButtonizedMessage(HintText);

	if (Switch == 1)
	{
	        // Mission-specific messages are displayed in-game
		if (gbxPlayerController(P).bDisplayMPMissionHints)
		{
			HUD.SetTrainingText(ButtonizedText, default.Lifetime, true);
		}
	}
	else 
	{
		// General messages goto the PlayerController's ProgressMessages array for display during load
		P.SetProgressMessage(2, ButtonizedText, class'Canvas'.Static.MakeColor(255,255,255));
	}

}

static function GetHintFileAndSection(PlayerController P, int Type, out string File, out string HintSection)
{
	if (Type == 0)
	{
		File = default.GeneralMessageFile;
		HintSection = default.GeneralHintSection;
	}
	else if (Type == 1)
	{
		File = "";

		if (P.PlayerReplicationInfo.Team.TeamIndex == ETeamIdentifier.TEAM_US)
		{
			HintSection = default.USHintSection;
		}
		else if (P.PlayerReplicationInfo.Team.TeamIndex == ETeamIdentifier.TEAM_German)
		{
			HintSection = default.DEHintSection;
		}
	}
	else
	{
		File = default.GeneralSkirmishMessageFile;
		HintSection = default.GeneralHintSection;
	}
}

static function string GetRandomHintText(PlayerController P, int Type)
{
	local string File;
	local string HintSection;

	local LevelInfo TheLevel;
	local int Count;
	local int Index;

	local string HintName;
	local string Caption;
	local string Text;

	GetHintFileAndSection(P, Type, File, HintSection);

	TheLevel = P.Level;
	Count = int(TheLevel.S_Localize("HintCount", File, HintSection));
	Index = Rand(Count);

	//Log("MPTrainingMessage Select File = " $ File $ " Section = " $ HintSection $ " Count = " $ Count $ " Index = " $ Index, 'JWS');

	HintName = "Hint" $ Index;
	Caption = TheLevel.S_Localize(default.HintCaption, File, HintSection);
	Text = Caption $ TheLevel.S_Localize(HintName, File, HintSection);

	//Log("MPTrainingMessage Return HintName = " $ HintName $ " Text = " $ Text, 'JWS');

	return Text;
}

defaultproperties
{
	GeneralMessageFile="S_MP_HINTS"
	GeneralSkirmishMessageFile="S_SKR_HINTS"

	GeneralHintSection = "HINTS"
	HintCaption="HintCaption"
	USHintSection = "USHINTS"
	DEHintSection = "DEHINTS"

	Lifetime = 8
}// GEARBOX 2004-06-23 JWS created
//
// usage: handles the display of the victory message when the game ends
//
// * Switch is the packed victory reason

class gbxMPVictoryMessage extends LocalMessage;

var sound USVictorySound, GermanVictorySound;
var sound USFailureSound, GermanFailureSound;

static function ClientReceive(
	PlayerController P,
	optional int Switch,
	optional PlayerReplicationInfo RelatedPRI_1,
	optional PlayerReplicationInfo RelatedPRI_2,
	optional Object OptionalObject
	)
{
	local WargamePlayerController pc;
	local string msg;
	local int WinningTeam;
	local bool bPlayVictorySound;

	Log("gbxMPVictoryMessage::ClientReceive(" $ P $ ", " $ Switch $ ", " $ RelatedPRI_1 $ ", " $ RelatedPRI_2 $ ", " $ OptionalObject $ ") called", 'MP');

	bPlayVictorySound = true;

	pc = WargamePlayerController(P);
	WinningTeam = pc.UnpackVictoryReason(Switch, msg);

	// Skirmish guys don't want the victory text displayed
	if ( P.GameReplicationInfo.GameType != GT_SKIRMISH )
	{
		if ( P.myHud != None )
		{
			P.myHUD.LocalizedMessage( Default.Class, Switch, RelatedPRI_1, RelatedPRI_2, OptionalObject, msg );
		}
	}
	else
	{
		// Did the skirmish player's team win or lose?
		if ( P.PlayerReplicationInfo.Team.TeamIndex != WinningTeam )
		{
			bPlayVictorySound = false;
		}
	}

	// If we're playing a skirmish game, don't play the winning music for the AI's team.
	// Play the winning music only if the player wins, otherwise, play a failure sound.
	if ( bPlayVictorySound )
	{
		switch (WinningTeam)
		{
			case 1:
				P.PlayAnnouncement(default.USVictorySound,0, true);
				break;

			case 2:
				P.PlayAnnouncement(default.GermanVictorySound,0, true);
				break;
		}
	}
	else
	{
		switch (WinningTeam)
		{
			case 1:	// US won
				P.PlayAnnouncement(default.GermanFailureSound,0, true);
				break;

			case 2: // Germans won
				P.PlayAnnouncement(default.USFailureSound,0, true);
				break;
		}
	}
}

defaultproperties
{
	bBeep=false
	bFadeMessage=True
	bIsSpecial=True
	bIsUnique=True
	Lifetime=5

	DrawColor=(R=0,G=160,B=255,A=255)
	FontSize=4

	YPos=240

	USVictorySound=Sound'MP_MISC.US_FANFARE'
	GermanVictorySound=Sound'MP_MISC.GERMAN_FANFARE'
	USFailureSound=Sound'MP_MISC.US_DROP'
	GermanFailureSound=Sound'MP_MISC.GER_DROP'
}class gbxPlayerPawn extends InfantryUSA;


///// DeathCamVariables //////
var(DeathCam) float			DeathColorStartTime;
var(DeathCam) float			DeathColorEndTime;
var(DeathCam) float			DeathBlurStartTime;
var(DeathCam) float			DeathBlurEndTime;
var(DeathCam) float			DeathSlowStartTime;
var(DeathCam) float			DeathSlowEndTime;
var(DeathCam) float			DeathFadeStartTime;

var(DeathCam) float			FinalDeathSlow;
var(DeathCam) byte			FinalDeathBlur;
var(DeathCam) Color			FinalDeathColor;
var(DeathCam) Color			DeathColorStart;
var(DeathCam) float			DeathFadeRate;

var(DeathCam) float			DeathCamZOffset;

var(DeathCam) bool			bDeathFadeStarted;
var(DeathCam) float			DeathTime;
var(DeathCam) float			DeathFadePct;
var(DeathCam) Color			DeathFadeStartColor;
var(DeathCam) Color			ColorBlack;

var(TraumaCam) color        TraumaColorSrc;
var(TraumaCam) color        TraumaColorDst;
var(TraumaCam) color        TraumaColorFlash;
var(TraumaCam) float        TraumaTimeScale;
var(TraumaCam) float        TraumaFadeRate;
var(TraumaCam) float		TraumaDurationMelee;
var(TraumaCam) byte         TraumaBlur;

var float			StopMeleeTraumaTime;

var name		m_szBlownDownAnimOverride;
var TNTTrigger	LastTNTTrigger;

var bool		bDoingHeavyTrauma;			// GBX:naj - to fix bug 11782.

//// Warning shot vars
var Cue WarningShotCue;
var float NextWarningShotEffectTime;
var float WarningShotEffectInterval;
var Color WarningShotEdgeEffectColor;
var eRenderStyle WarningShotRenderStyle;

var Color TakeDamageEdgeEffectColor;
var eRenderStyle TakeDamageRenderStyle;

var Range BloodEffectParticleCount;

// Buzz view vars
var float BuzzViewTime;
var float BuzzViewMaxTime;
var int BuzzViewAngle;
var int BuzzViewMaxAngle;
var bool bBuzzViewRotationCenterSaved;
var bool bBuzzViewDirBool;
var int BuzzViewRotationCenter;


///// TNT Variables /////
var Vector TNTCameraStart;
var Vector TNTCameraMiddle;
var Vector TNTCameraEnd;
var Vector TNTTeleportOffset;
var Vector TNTDesiredCameraLoc;
var Vector TNTLastCameraLoc;
var int TNTDesiredCameraPitch;
var int TNTLastCameraPitch;
var float TNTCameraSpeed;
var float TNTCameraRotSpeed, TNTCameraRotSpeedIn, TNTCameraRotSpeedOut;
var float TNTTimestamp;

var Tank	TankGrenadeTank;
var bool	bTankGrenadeCameraNeedsToPause;
var bool	bTankGrenadeCameraIsPaused;
var float	TankGrenadeCameraPausedTime;
var float	TankGrenadeMountStartStamp;
var float	TankGrenadeCameraZoomTime;				// how long the camera takes to move from CameraSweepStartOffset to CameraSweepEndOffset
var	vector	TankGrenadeCameraSweepStartOffset;		// relative to the tank's Location
var vector	TankGrenadeCameraSweepEndOffset;		// relative to the tank's Location
var float	TankGrenadeCameraStartPitch;
var float	TankGrenadeCameraEndPitch;
var vector	TankGrenadeRootBoneDelta;
var float	TankGrenadePawnCollisionHeight;
var float	TankGrenadePawnCollisionRadius;

var name	TankGrenadePlayerAnim;					// MUST be initialized by Tank
var string	TankGrenadeMeshAnimName;				// MUST be initialized by Tank
var vector	TankGrenadeMountAnimStartOffset;		// MUST be initialized by Tank
var vector	TankGrenadeCameraStartOffset;			// MUST be initialized by Tank
var vector	TankGrenadeCameraEndOffset;				// MUST be initialized by Tank
var vector	TankGrenadeHeadZoomInOffset;			// MUST be initialized by Tank
var int		TankGrenadeYawSet;						// MUST be initialized by Tank
var vector	TankGrenadeTeleportOffset;				// MUST be initialized by Tank

var bool PreviousGodMode;
var Weapon StowedWeapon;	// Stow away this weapon while playing animation sequence.

// PSV: 6/4/2004 Multiplayer HUD stuff
const HALF_PLAYER_HEIGHT = 92.5f;

replication
{
	unreliable if (ROLE==ROLE_Authority)
		ClientDoWarningShotEffect;
}

simulated function PostNetBeginPlay()
{
	local ExtendedAttachmentInfo	anEAInfo;
	local MeshAnimation	aMeshAnim;
	local string CharFacialPkg;
	local string portraitName;
	local int		j, nHealth;

	Super.PostNetBeginPlay();

	if (GetCharacterHead() != '')
	{
		anEAInfo = new( Level.Outer ) class'ExtendedAttachmentInfo'; // GBX:naj - modified 3/11/04
		anEAInfo.m_nmSocketName = 'Head';
		anEAInfo.m_nmPartName = GetCharacterHead();

		ExtendedAttachments[0] = anEAInfo;
		if (ExtendedAttachments[0].m_AttachedPart == None)
			ExtendedAttachments[0].m_AttachedPart = Spawn( class'AttachedPart' );
		if (ExtendedSkins.Length > 0)
		{
			for (j = 0; j < ExtendedSkins.Length; j++)
			{
				if (ExtendedSkins[j] != None)
				{
					ExtendedAttachments[0].m_AttachedPart.Skins[j] = ExtendedSkins[j];
				}
			}
		}
		if (ExtendedAttachments[0].m_szGroupName != "")
			ExtendedAttachmentNamedGroup( ExtendedAttachments[0].m_AttachedPart, ExtendedAttachments[0].m_szGroupName );
		else
			ExtendedAttachment( ExtendedAttachments[0].m_AttachedPart, ExtendedAttachments[0].m_nmSocketName, ExtendedAttachments[0].m_nmPartName );
	}
		
	CharacterName = GetCharacterName();
	portraitName = GetCharacterPortrait();
	if ( portraitName != "" )
	{
		Portrait = Texture( DynamicLoadObject( portraitName, class'Texture' ));
	}

	CharFacialPkg = GetCharacterFacialPackage();
	if (CharFacialPkg != "")
	{
		aMeshAnim = MeshAnimation( DynamicLoadObject(CharFacialPkg, class'MeshAnimation') );
		if (aMeshAnim != None)
		{
			LinkSkelAnim(aMeshAnim);
		}
	}

	SetVoiceType( GetCharacterVoiceType( Level.IsDemoBuild() ) );
	if (m_flLegScale == 1.0f)
	{
		m_flLegScale = GetCharacterScale();
		if (m_flLegScale != 1.0f)
		{
			ChangeCharacterHeight();
		}
	}

	if( WarningShotCue == None )
	{
		WarningShotCue = LoadSound( "IMPACTS.BULLET_PASSBY_SUPER" );
	}
	
	// This is very slow, and has no meaning for MP anyways. So only do this stuff in SP games. 2004-12-02 JWS
	if (Level.NetMode == NM_Standalone)
	{
		nHealth = -1;
		if (Level.MissionManager.GetCheckpointPlayerHealth( nHealth ))
		{
			if (nHealth > 0)
			{
				Health = nHealth;
			}
		}
	}

	// This is used to preload the battle dialogue so QA can get a proper list for the preload files.
	//log( "gbxPlayerPawn::ConfigurePawn() - Level.bPreloadBattleDialogue=" $ Level.bPreloadBattleDialogue, 'RSC' );
	if( Voicetype != None )
	{
		Voicetype.SortSpeeches();
		if( Level.bPreloadBattleDialogue )
	{
		//log( "CharacterSpawnerGermany::ConfigurePawn() - Preloading Battle Dialogue for Voicetype " $ VoiceType, 'RSC' );
			Voicetype.Preload();
		}
	}
}

simulated function ResetPlayerCharacter()
{
	local ExtendedAttachmentInfo	anEAInfo;
	local MeshAnimation	aMeshAnim;
	local string CharFacialPkg;
	local string portraitName;
	local int		j;

	if (Level.NetMode != NM_StandAlone)
	{
		return;
	}
	// GBX:PAD: Putting a 41 in here is a hack, but I was having trouble figuring out how to get the enumeration to work,
	// so this takes care of the problem.
//	SetCharacterType( EUSCharacterTypes.USCharHartsockSgt );
	CharacterSetupClass = class'CharacterSetupUSA';
	if (gbxPlayerStart(LastStartSpot) != None)
	{
		if (gbxPlayerStart(LastStartSpot).m_eCharacterType > 0)
		{
			SetCharacterType( gbxPlayerStart(LastStartSpot).m_eCharacterType );
		}
		else
		{
			SetCharacterType( 41 );
		}
		m_fFingerMissing = gbxPlayerStart(LastStartSpot).m_fFingerMissing || Level.bHartsockWounded;
	}
	else
	{
		SetCharacterType( 41 );
	}
	m_flRank = GetCharacterRank();

	Super.PostNetBeginPlay();

	if (GetCharacterHead() != '')
	{
		anEAInfo = new( Level.Outer ) class'ExtendedAttachmentInfo'; // GBX:naj - modified 3/11/04
		anEAInfo.m_nmSocketName = 'Head';
		anEAInfo.m_nmPartName = GetCharacterHead();

		ExtendedAttachments[0] = anEAInfo;
		if (ExtendedAttachments[0].m_AttachedPart == None)
			ExtendedAttachments[0].m_AttachedPart = Spawn( class'AttachedPart' );
		if (ExtendedSkins.Length > 0)
		{
			for (j = 0; j < ExtendedSkins.Length; j++)
			{
				if (ExtendedSkins[j] != None)
				{
					ExtendedAttachments[0].m_AttachedPart.Skins[j] = ExtendedSkins[j];
				}
			}
		}
		if (ExtendedAttachments[0].m_szGroupName != "")
			ExtendedAttachmentNamedGroup( ExtendedAttachments[0].m_AttachedPart, ExtendedAttachments[0].m_szGroupName );
		else
			ExtendedAttachment( ExtendedAttachments[0].m_AttachedPart, ExtendedAttachments[0].m_nmSocketName, ExtendedAttachments[0].m_nmPartName );
	}
		
	CharacterName = GetCharacterName();
	portraitName = GetCharacterPortrait();
	if ( portraitName != "" )
	{
		Portrait = Texture( DynamicLoadObject( portraitName, class'Texture' ));
	}

	CharFacialPkg = GetCharacterFacialPackage();
	if (CharFacialPkg != "")
	{
		aMeshAnim = MeshAnimation( DynamicLoadObject(CharFacialPkg, class'MeshAnimation') );
		if (aMeshAnim != None)
		{
			LinkSkelAnim(aMeshAnim);
		}
	}

	SetVoiceType( GetCharacterVoiceType( Level.IsDemoBuild() ) );
	if (m_flLegScale == 1.0f)
	{
		m_flLegScale = GetCharacterScale();
		if (m_flLegScale != 1.0f)
		{
			ChangeCharacterHeight();
		}
	}

	MenuName=GetCharacterRankName();
	Level.MissionManager.PlayerRankName = MenuName;
}

// Used to remove buff given to reinforced player in multiplayer
function Timer()
{
	Log( self$ " gbxPlayerPawn::Timer() Removing health bonus because bonus duration has expired!", 'PSV' );

	if ( Health > 100 )
		Health = 100;
}

simulated function vector EyePosition()
{
	bOwnerNoSee = true;
	return EyeHeight * vect(0,0,1) + WalkBob;
}

function Fire( optional float F )
{
	local gbxHUD	aMyHud;

	if ((WargamePlayerController(Controller) != None) && (gbxHUD( PlayerController(Controller).MyHUD ) != None))
	{
		aMyHud = gbxHUD( PlayerController(Controller).MyHUD );
		if (aMyHud.m_eHudMode != HudModeNormal)
		{
			aMyHud.UseKey();
			return;
		}
	}

    if( Weapon!=None )
	{
        Weapon.Fire(F);
	}
}

function FireSecondary( optional float F )
{
    if( SecondaryWeapon!=None )
    {
		if (gbxWeapon( SecondaryWeapon ) != None)
			gbxWeapon( SecondaryWeapon ).Fire(F);
		else if (gbxUsableItem( SecondaryWeapon ) != None)
			SecondaryWeapon.Use(F);
	}
}

// Just changed to pendingSecondaryWeapon
function ChangedSecondaryWeapon()
{
	if (PendingSecondaryWeapon == None)
		return;

    ServerChangedSecondaryWeapon(SecondaryWeapon, PendingSecondaryWeapon);
    if (Role < ROLE_Authority)
	{
		SecondaryWeapon = PendingSecondaryWeapon;
		PendingSecondaryWeapon = None;
	}
	SecondaryWeapon.Instigator = self;

	if ( SecondaryWeapon != None )
	{
		//log("ServerChangedWeapon: Attaching Weapon to actor bone.");
		SecondaryWeapon.AttachToPawn(self);
	}
}

function Tick( float DeltaTime )
{
	Super.Tick(DeltaTime);

	if ((Level == None) || (Level.Game == None))
		return;

	if (bPlayHeavyTraumaSound && (flHeavyTraumaSoundTime < Level.TimeSeconds))
	{
		PlayHeavyTraumaSound();
		bPlayHeavyTraumaSound = false;
	}

	if ( StopMeleeTraumaTime > 0.000001f && Level.TimeSeconds > StopMeleeTraumaTime )
	{
		StopMeleeTrauma();
	}
}

// Disabled in favor of the new enhanced showbros tech 2005-01-16 JWS
/*
// Allow each class to draw something to the hud if needed
simulated function DrawGBXHud(canvas Canvas, gbxHud Hud, FontInfo Fonts, int nPass)
{
	local PlayerController P;
	local int i, j;
	local gbxPlayerPawn remotePawn, localPawn;
	local Vector pawnPos, screenPos, lookVector, myVector, remotePawnVector, tempScreenPos;
	local String pawnName;
	local float trashWidth, trashHeight, lookTargetDot;
	local Unit subUnit;
	local gbxPawn aiPawn;
	//local EUnitType myUnitType, remoteUnitType;

	Super.DrawGBXHud( Canvas, Hud, Fonts, nPass );

	//----------------------------------------------
	// PSV: 6/4/2004 Draw multiplayer specific stuff
	//----------------------------------------------
	P = Canvas.Viewport.Actor;
	if ( (P.GameReplicationInfo != None) && (P.GameReplicationInfo.GameType == GT_SKIRMISH) )
	{
		return;
	}
	if ( Level.NetMode == NM_LISTENSERVER || Level.NetMode == NM_CLIENT )
	{
		//----------------------------------------
		// PSV: 6/4/2004 Draw friendly player name
		//----------------------------------------
		
		// TODO: Talk to Zoner about which is more efficient, draw text and icons in single
		//		 pass because of the time it takes to find all necessary actors OR
		//       split the icon/text drawing into its own pass doing the foreach for both.

		if ( nPass == 0 )
		{
			localPawn = gbxPlayerPawn(P.Pawn);
			lookVector = Vector( localPawn.Rotation );
			myVector = localPawn.Location + localPawn.EyePosition();

			Canvas.Style = ERenderStyle.STY_Normal;
			Canvas.SetDrawColor(255,255,128);
			Canvas.Font = Hud.WargameFont;

			trashWidth = 0.0;
			trashHeight = 0.0;

			// iterate over gbxplayerpawn
			// use their playerreplicationinfo
			// then traverse their MyUnit's list and draw icons over their members' heads.
			foreach DynamicActors( class'gbxPlayerPawn', remotePawn )
			{
				//log(self$ "WargameHUD::MultiplayerDrawHUD() localPawn " $localPawn$ " remotePawn " $remotePawn, 'PSV');

				if ( localPawn != None && remotePawn != None && localPawn.PawnTeam == remotePawn.PawnTeam )
				{
					// Only draw the player's name for the remote player
					if ( !remotePawn.IsDead() && localPawn != remotePawn )
					{
						//-----------------
						// Draw player name
						//-----------------
						pawnName = remotePawn.GetHumanReadableName();

						pawnPos = remotePawn.Location;
						
						tempScreenPos = Canvas.ScreenProject( pawnPos );

						pawnPos.z += (HALF_PLAYER_HEIGHT + 10.0f);

						remotePawnVector = Normal( (remotePawn.Location + remotePawn.EyePosition()) - MyVector );
						lookTargetDot = lookVector dot remotePawnVector;

						// Looks like we found somebody we want to draw, let's make sure it's actually on our screen.
						if ( lookTargetDot > 0.0 )
						{
							// Now draw the player's name
							screenPos = Canvas.ScreenProject( pawnPos );
							//Log(self$ " WargameHUD::MultiplayerDrawHUD() Drawing name at ("$screenPos.X$","$screenPos.Y$","$screenPos.Z$ ")", 'PSV');
							Canvas.DrawTextBounded( pawnName, 1, 1, screenPos.X, screenPos.Y, trashWidth, trashHeight, 0.9, 0.9, false );

							//---------------
							// Draw team icon
							//---------------
							if ( remotePawn.MyUnit != None )
							{
								// Update position to draw above player name
								screenPos.X = tempScreenPos.X - (((46.0f * 0.5f) / 2 ) * Hud.ScaleX); 
								screenPos.Y -= (46.0f * 0.5f) * Hud.ScaleY;
								
								//Log(self$ " WargameHUD::MultiplayerDrawHUD() Drawing squad icon " $remotePawn.MyUnit.UnitType$ " at ("$screenPos.X$","$screenPos.Y$","$screenPos.Z$ ") trashHeight= " $trashHeight, 'PSV');

								Canvas.SetDrawColor(228,220,197,128);
								DrawUnitTile( Canvas, Hud, screenPos.X, screenPos.Y, remotePawn.MyUnit );
							}
						}
						
						// Have to reset these because they are out parameters for DrawTextBounded function
						trashWidth = 0.0;
						trashHeight = 0.0;
					}

					// Now traverse player's subunits looking for AI pawns
					if( remotePawn.MyUnit != None )
					{
						//log(self$ "WargameHUD::MultiplayerDrawHUD() MyUnit " $remotePawn.MyUnit, 'PSV');
						for( i = 0; i < remotePawn.MyUnit.MAX_SUBUNITS; ++i )
						{
							subUnit = remotePawn.MyUnit.SubUnits[i];
							if( subUnit != None )
							{
								//log(self$ "WargameHUD::MultiplayerDrawHUD() subUnit " $subUnit$ " NumMembers " $subUnit.NumMembers, 'PSV');
								for( j = 0; j < subUnit.NumMembers; j++ )
								{
									if( subUnit.Members[j] != None && !subUnit.Members[j].IsDead() )
									{
										// Ok, we have an aiPawn that we "might" want to draw an icon over
										aiPawn = subUnit.Members[j];

										if ( !aiPawn.IsDead() && aiPawn != remotePawn )
										{
											//Log(self$ " WargameHUD::MultiplayerDrawHUD() Processing aiPawn " $aiPawn, 'PSV');
											
											// Is he visible?
											pawnPos = aiPawn.Location;
											pawnPos.z += (HALF_PLAYER_HEIGHT + 10.0f);

											remotePawnVector = Normal( (aiPawn.Location + aiPawn.EyePosition()) - MyVector );
											lookTargetDot = lookVector dot remotePawnVector;

											// Looks like we found somebody we want to draw, let's make sure it's actually on our screen.
											if ( lookTargetDot > 0.0 )
											{
												// Now draw the player's AI unit icons
												screenPos = Canvas.ScreenProject( pawnPos );
												screenPos.X -= (((46.0f * 0.5f) / 2 ) * Hud.ScaleX); 
												screenPos.Y -= (((46.0f * 0.5f) / 2 ) * Hud.ScaleY); 
												
												//Log(self$ " WargameHUD::MultiplayerDrawHUD() Drawing AI icon " $aiPawn.MyUnit.UnitType$ " at ("$screenPos.X$","$screenPos.Y$","$screenPos.Z$ ")", 'PSV');

												Canvas.SetDrawColor(228,220,197,128);
												DrawUnitTile( Canvas, Hud, screenPos.X, screenPos.Y, subUnit );
											}
										}
										else
										{
											//Log(self$ "WargameHUD::MultiplayerDrawHUD() aiPawn == remotePawn", 'PSV');
										}
									}
								}
							}
						}
					}
				}
			}
		}	// end nPass == 0
	}
}
*/

// Special calc-view for vehicles
simulated function bool SpecialCalcView(out actor ViewActor, out vector CameraLocation, out rotator CameraRotation )
{
	local WargamePlayerController pc;
	local	Coords		aBoneCoord;
	local	Rotator		aBoneRotation;

	pc = WargamePlayerController(Controller);

	if (bInBodyDeathCam || bAttachCamToHead || bScriptedCamInHead)
	{
		aBoneCoord = GetBoneCoords( ScriptedViewBoneName );
		aBoneRotation = GetBoneRotation( ScriptedViewBoneName );
		CameraLocation = aBoneCoord.Origin + ( vect(0,0,1) * DeathCamZOffset );
//		CameraRotation = Rotator(-aBoneCoord.YAxis);
		if (pc != None)
			CameraRotation = aBoneRotation + pc.ScriptViewOffset;
		else
			CameraRotation = aBoneRotation;
		ViewActor = self;
		bOwnerNoSee = false;
		return true;
	}

	if (pc == None)
		return false;
		
	// skip if the player is not looking at us
	if(pc.ViewTarget != self)
		return false;

	if ( Turret != None && (bIsManningTurret || bHasStartedMountAnim) )
	{
		Turret.SpecialCalcView( Self, ViewActor, CameraLocation, CameraRotation );
		ViewActor=self;
		return true;
	}
	
	if (pc.bBehindView)
	{
		if (Super.SpecialCalcView( ViewActor, CameraLocation, CameraRotation ))
			return true;
	}

	if (m_ViewSource != None)
	{
		ViewActor = m_ViewSource;
		CameraRotation = rotator(m_ViewTarget.Location - ViewActor.Location);
		CameraLocation = ViewActor.Location;
		SetViewRotation( CameraRotation );
		return true;
	}

	return Super.SpecialCalcView( ViewActor, CameraLocation, CameraRotation );
//	ViewActor = self;
//	CameraRotation = rotator(pc.m_aLockedTarget.Location - Location);
//	CameraLocation = Location + EyePosition();
//	SetViewRotation( CameraRotation );

//	return true;
}

function int AdjustHitLocDamage( Pawn instigatedBy, int Damage, EHitArea aHitArea )
{
	local	int	nAdjustedDamage;

	nAdjustedDamage = Damage;

	if (PlayerController(Controller) == None)
	{
		switch (aHitArea)
		{
			case HitHead:
				nAdjustedDamage = Health;
				break;

			case HitChest:
			case HitBack:
				nAdjustedDamage = 50;
				break;

			case HitLegs:
			case HitArms:
				nAdjustedDamage = 20;
				break;

			case HitOther:
				nAdjustedDamage = 5;
				break;
		}
	}

	return nAdjustedDamage;
}

function bool IsAPlayerPawn()
{
	return true;
}

simulated event PlayDying(class<DamageType> DamageType, vector HitLoc)
{
	local Actor		aScript;
	local int		nCheckpointID;
	
	if( Level.NetMode == NM_Standalone )
	{
		InitDeathView();
		Level.m_flDoSaveGame = -1;	// GBX:PAD: Reset this so that any pending save game does not succeed since it's bad to save while the player is dying.

		// GBX:PAD When the player dies, try to kill all current triggered scripts that might be running.
		foreach AllActors(class'Actor', aScript)
		{
			if (aScript.IsA('TriggeredScript'))
			{
				aScript.GotoState( '' );
			}
		}
	}
	else if ( Level.NetMode == NM_LISTENSERVER || Level.NetMode == NM_CLIENT )
	{
		// Clear the particle effects from the screen
		if( WargamePlayerController(Controller) != None )
		{
			WargamePlayerController(Controller).ClearAllHudEffects();
		}
	}
	
	if ( (Level.NetMode != NM_StandAlone) && (Level.NetMode != NM_CLIENT) && (PlayerController(Controller).GameReplicationInfo.GameType == GT_SKIRMISH))
	{
		if (WargameSkirmish(Level.Game).GameType != SGT_TourOfDuty)
		{
			nCheckpointID = Level.MissionManager.SkirmishGetCheckpointID();
			BroadcastLocalizedMessage(class'gbxPlayerDeadMessage', nCheckpointID, PlayerController(Controller).PlayerReplicationInfo, None);
		}
		else
		{
			BroadcastLocalizedMessage(class'gbxPlayerDeadMessage', 255, PlayerController(Controller).PlayerReplicationInfo, None);
		}
	}

	Super.PlayDying(DamageType, HitLoc);
}

state Dying
{
	function Tick( float DeltaTime )
	{
		Super.Tick(DeltaTime);

		if( (Level != None) && (Level.Game != None) && Level.Game.IsA('WargameSinglePlayer') )
		{
			UpdateDeathView();
		}
	}
}

function float PlayKnockDownAnim()
{
	local	name	szAnimName;
	local	float	flAnimLength;
	
	if (m_szBlownDownAnimOverride != '')
	{
		szAnimName = m_szBlownDownAnimOverride;
	}
	else
	{
		szAnimName = PawnAnimInfoClass.Static.PlayerBlownDownAnim();
	}
	AddAnimToQueue( szAnimName, QUEUE_DEATH_PRIORITY, true, false, false, 1.0, 0.0, class'PlayerKnockDownCallback',,,,,,true);
	flAnimLength = AnimLength( szAnimName );
	
	return flAnimLength;
}

function InitDeathView()
{
	local PlayerController PC;
    local int playerindex;
    
	PC = Level.GetLocalPlayerController();
    playerindex = PC.Player.SplitIndex;
    
	Level.CameraEffectManager[playerindex].SetCameraEffect(CAM_MotionBlur);
	Level.CameraEffectManager[playerindex].CamMotionBlurEffect.bDoClear = false;
	Level.CameraEffectManager[playerindex].CamMotionBlurEffect.RenderColor = DeathColorStart; // Beginning color
	Level.CameraEffectManager[playerindex].CamMotionBlurEffect.BlurAlpha = 255;	// No blur
	Level.CameraEffectManager[playerindex].CamMotionBlurEffect.bFade = false;
	
	DeathTime = Level.UniversalTimeSeconds;
	bDeathFadeStarted = false;
	DeathFadePct = 0.0;
}

function UpdateDeathView()
{
	local float DeathColorPct;
	local float DeathBlurPct;
	local float NewDeathSlowPct;
	local PlayerController PC;
    local int playerindex;
    
	PC = Level.GetLocalPlayerController();
    playerindex = PC.Player.SplitIndex;
    
    // Fade to black at the appropriate time
    if( Level.UniversalTimeSeconds - DeathTime > DeathFadeStartTime )
    {
        if( !bDeathFadeStarted )
        {
            DeathFadeStartColor = Level.CameraEffectManager[playerindex].CamMotionBlurEffect.RenderColor;
            bDeathFadeStarted = true;
        }

        DeathFadePct = (Level.UniversalTimeSeconds - DeathTime - DeathFadeStartTime) * DeathFadeRate;

        if( DeathFadePct < 1.0f )
            Level.CameraEffectManager[playerindex].CamMotionBlurEffect.RenderColor = InterpolateColor( DeathFadePct, DeathFadeStartColor, ColorBlack );
    }
    else
    {
        // Lerp slow motion
        if( Level.UniversalTimeSeconds - DeathTime > DeathSlowStartTime )
        {
            NewDeathSlowPct = (Level.UniversalTimeSeconds - DeathTime - DeathSlowStartTime)/(DeathSlowEndTime - DeathSlowStartTime);

            if( NewDeathSlowPct < 1.0f )
                Level.Game.SetGameSpeed( Lerp( NewDeathSlowPct, 1.0f, FinalDeathSlow ) );
        }

        // Lerp color change
        if( Level.UniversalTimeSeconds - DeathTime > DeathColorStartTime )
        {
            DeathColorPct = (Level.UniversalTimeSeconds - DeathTime - DeathColorStartTime)/(DeathColorEndTime - DeathColorStartTime);

            if( DeathColorPct < 1.0f )
            {
                Level.CameraEffectManager[playerindex].CamMotionBlurEffect.RenderColor = InterpolateColor( DeathColorPct, DeathColorStart, FinalDeathColor );
                Level.CameraEffectManager[playerindex].CamMotionBlurEffect.RenderColor.A = Lerp( DeathColorPct, 0, 255 ); // saturation
            }
        }

        // Lerp motion blur
        if( Level.UniversalTimeSeconds - DeathTime > DeathBlurStartTime )
        {
            DeathBlurPct = (Level.UniversalTimeSeconds - DeathTime - DeathBlurStartTime)/(DeathBlurEndTime - DeathBlurStartTime);

            if( DeathBlurPct < 1.0f )
                Level.CameraEffectManager[playerindex].CamMotionBlurEffect.BlurAlpha = Lerp( DeathBlurPct, 255, FinalDeathBlur );
        }
    }
}

function DisableDeathView()
{
	local PlayerController PC;
    local int playerindex;
    
	// This is now handled in gbxPlayerController::ClientPawnDied() 2004-11-09 JWS
	if (Level.NetMode == NM_Standalone)
	{
		PC = Level.GetLocalPlayerController();
		playerindex = PC.Player.SplitIndex;

		Level.CameraEffectManager[playerindex].RestoreDefaultEffect();
	}
}

function bool IsDoingHeavyTrauma() 
{
	return bDoingHeavyTrauma;
}

function DoMeleeTrauma()
{
	BeginTraumaCam();
	StartTraumaSound();
	StopMeleeTraumaTime = Level.TimeSeconds + TraumaDurationMelee;
	SetScriptedAudioEffect( "Gameplay.EFFECT_Trauma", 1.0, 0.15, 0.5 );
}

function StopMeleeTrauma()
{
	local PlayerController PC;
    local int playerindex;
    
	PC = Level.GetLocalPlayerController();
    playerindex = PC.Player.SplitIndex;
    
	Level.CameraEffectManager[playerindex].RestoreDefaultEffect();
	Level.Game.SetGameSpeed( 1.0f );
	StopMeleeTraumaTime = 0.0f;

	bDoingHeavyTrauma = false;
}

function BeginTraumaCam()
{
	local PlayerController PC;
    local int playerindex;
    
	PC = Level.GetLocalPlayerController();
    playerindex = PC.Player.SplitIndex;
   
	/// Flash the camera with white
	Level.CameraEffectManager[playerindex].CamMotionBlurEffect.bDoClear = true;
        //NAC: If we are using old movie cheat then we need to use the colors defined for it's camera effect here...
	if (Level.CameraEffectManager[playerindex].CurrentCameraMode == CAM_OldMovie)
	{
		Level.CameraEffectManager[playerindex].CamMotionBlurEffect.RenderColor = Level.CameraEffectManager[playerindex].CamOldMovie.GlobalColor;//TraumaColorSrc;
		Level.CameraEffectManager[playerindex].CamMotionBlurEffect.TargetSrcColor = Level.CameraEffectManager[playerindex].CamOldMovie.GlobalColor;//TraumaColorSrc;
	}
	else
	{
	Level.CameraEffectManager[playerindex].CamMotionBlurEffect.RenderColor = TraumaColorSrc;
	Level.CameraEffectManager[playerindex].CamMotionBlurEffect.TargetSrcColor = TraumaColorSrc;
	}

	Level.CameraEffectManager[playerindex].SetCameraEffect( CAM_MotionBlur );
	Level.CameraEffectManager[playerindex].CamMotionBlurEffect.ClearColor = TraumaColorFlash;
	
	Level.CameraEffectManager[playerindex].CamMotionBlurEffect.TargetDstColor = TraumaColorDst;
	Level.CameraEffectManager[playerindex].CamMotionBlurEffect.TimeScale = TraumaTimeScale;
	Level.CameraEffectManager[playerindex].CamMotionBlurEffect.FadeRate = TraumaFadeRate;
	Level.CameraEffectManager[playerindex].CamMotionBlurEffect.Blur = TraumaBlur;

	Level.Game.SetGameSpeed( TraumaTimeScale );

	bDoingHeavyTrauma = true;
}

function EndTraumaCam()
{
	local PlayerController PC;
    local int playerindex;
    
	PC = Level.GetLocalPlayerController();
    playerindex = PC.Player.SplitIndex;
    //NAC: If we are using old movie cheat then we need to use the colors defined for it's camera effect here...
    if (Level.CameraEffectManager[playerindex].DefaultCameraMode != Cam_OldMovie )
	{
           	Level.CameraEffectManager[playerindex].CamMotionBlurEffect.bFade = true;
         	Level.CameraEffectManager[playerindex].CamMotionBlurEffect.FadeStartTime = Level.UniversalTimeSeconds;
	}
    else
	{
		Level.CameraEffectManager[playerindex].RestoreDefaultEffect(); //NAC+
		Level.Game.SetGameSpeed( 1.0f );
	}

	bDoingHeavyTrauma = false;
}

function StartTraumaSound()
{
	SetScriptedAudioEffect( "Gameplay.EFFECT_Trauma", 11.0, 0.15, 0.75 );
}

function TakeDamage( int Damage, Pawn instigatedBy, Vector hitlocation,
						Vector momentum, class<DamageType> damageType, optional name HitBoxName)
{
	local int	OrigHealth;
	local bool	bShowDamage;
	local gbxPlayerController gbxPC;
	local float DamagePct;
	local Vector KickAdjust;

	OrigHealth = Health;
	Super.TakeDamage( Damage, instigatedBy, hitlocation, momentum, damageType );

	if ( MyUnit != None )
	{
		MyUnit.SpawnPerceptionPlayerHit( Self );
	}

	gbxPC = gbxPlayerController(Controller);

	// Kick the player's view.
	if (damageType.Name != 'DamageRunOver')
	{
		if ( ClassIsChildOf(damageType, class 'gbxDamageType') )
		{
			DamagePct = (OrigHealth - Health) / Damage;
			m_eLastHitLoc = CalcHitAdjust(DamagePct, damageType, HitLocation, KickAdjust);
			
			if ( Level.Game.GameReplicationInfo.GameType != GT_MULTIPLAYER )
			{
				ClientKickView( KickAdjust, 2.0 );
			}
			else
			{
				ClientKickView( KickAdjust, 5.0 );
			}

			if (gbxPC != None)
			{
				// if the OrderIcon sticky time hasn't been updated for at least 1.0 seconds, then update it to make it sticky
				// (we don't want to continuously make the order icon sticky when being shot because if you get shot 3 or 4 times in
				// a row by several different guys, this will prevent you from being able to move the order icon when you want to)
				if ((gbxPC.fStickyOrderIconTime + 1.0) < Level.UniversalTimeSeconds)
				{
					gbxPC.fStickyOrderIconTime = Level.UniversalTimeSeconds;
					gbxPC.fUpdateOrderIconTime = Level.UniversalTimeSeconds + 0.7;  // keep order icon "sticky" for another 0.7 seconds
				}
			}

			Damage = AdjustHitLocDamage( instigatedBy, Damage, m_eLastHitLoc ); // SJP
		}
	}

	if (Health<OrigHealth)
	{
		bShowDamage = true;
	}
	
	if (bShowDamage)
	{
		if (gbxPC != None)
		{
			gbxPC.FlashScale=vect(1.5,0,0);
			gbxPC.FlashFog=vect(255,0,0);

			ClientTookDamage( momentum, instigatedBy );

			if (IsLocallyControlled())
			{
				DoDamageShotEffect( instigatedBy );
			}
		}
	}
}

simulated function ClientTookDamage( Vector hitdir, Pawn instigatedBy )
{
	Super.ClientTookDamage(hitdir, instigatedBy);

	if (Level.NetMode == NM_Client)
	{
		DoDamageShotEffect( instigatedBy );
	}
}

function float GetIdealGroundSpeed()
{
	return Default.GroundSpeed;
}

function float GetIdealBaseMovementRate()
{
	return Default.BaseMovementRate;
}

function bool RestockWeapons( WeaponLoadoutInfo WeaponInfo, int MaxWeaponPickupsCreated )
{
	local Inventory	aWeapon;
	local Weapon myWeapon;
	local Actor curWeapon, oldestWeapon;
	local Vector TossVel;
	local int nCount, nGlobalCount;
	
	// Make sure we're not in the middle of switching weapons/reloading/etc.
	if( Weapon != None && Weapon.ClientState != WS_ReadyToFire )
	{
		Log( self$" cannot restock "$Weapon$": ClientState is "$myWeapon.ClientState$" (Not WS_ReadyToFire)", 'SJP' );
		return false;
	}

	log(self$".RestockWeapons()");

	if (WeaponInfo == None)
	{
		aWeapon = Inventory;
		while( aWeapon != None )
		{
			if (aWeapon.IsA('gbxWeapon'))
			{
				gbxWeapon(aWeapon).RestockWeapon();
			}
			aWeapon = aWeapon.Inventory;
		}
		return true;
	}
	
	nCount = 0;
	aWeapon = Inventory;
	while( aWeapon != None )
	{
		if (aWeapon.IsA('gbxWeapon'))
		{
			if (WeaponInfo != None)
			{
				if (aWeapon.Class == WeaponInfo.m_WeaponClass)
				{
					gbxWeapon(aWeapon).RestockWeapon();
					ReceiveLocalizedMessage(class'gbxWeaponRestockMessage', -1);
					WargamePlayerController(Controller).LookingAtTarget = None;
					return true;
				}
			}
			nCount++;
		}

		aWeapon = aWeapon.Inventory;
	}

	// We need to kill the oldest pickup that exists in the world, in case the user is trying to spawn infinite pickup items
	if( MaxWeaponPickupsCreated > 0 )
	{
		foreach DynamicActors( WeaponInfo.m_WeaponClass.default.PickupClass, curWeapon )
		{
			nGlobalCount++;

			if( nGlobalCount == 1 )
			{
				oldestWeapon = curWeapon;
			}

			if( nGlobalCount == MaxWeaponPickupsCreated )
			{
				if( oldestWeapon != None )
				{
					oldestWeapon.Destroy();	
				}

				break;
			}
		}
	}

	if ((nCount > 1) && CanThrowWeapon())
	{
		TossVel = Vector(Controller.GetViewRotation());
		TossVel = TossVel * ((Velocity Dot TossVel) + 500) + Vect(0,0,200);
		TossWeapon(TossVel);
	}
	CreateInventoryClass( WeaponInfo.m_WeaponClass );
	
	if (nCount == 1)
	{
		WargamePlayerController(Controller).ToggleWeapon();
	}
	
	ReceiveLocalizedMessage(class'gbxWeaponPickupMessage', -1);
	WargamePlayerController(Controller).LookingAtTarget = None;

	return true;
}

function bool RestockUsables( UsableLoadoutInfo UsableInfo )
{
	local int		i;
	local Inventory	aUsable;
	
	log(self$".RestockUsables()");
	if (UsableInfo == None)
	{
		return false;
	}
	
	for( i = 0; i < 4; i++ )
	{
		aUsable = SecondaryInventory[i];
		while( aUsable != None )
		{
			if (aUsable.IsA('gbxUsableItem'))
			{
				if (UsableInfo != None)
				{
					if (aUsable.Class == UsableInfo.m_UsableClass)
					{
						if (aUsable.IsA('gbxUsableItem'))
						{
							if (gbxUsableItem(aUsable).NumCopies < UsableInfo.m_nMaxCharQuantity)
							{
								gbxUsableItem(aUsable).NumCopies = UsableInfo.m_nMaxCharQuantity;
							}
							return true;
						}
						return false;
					}
				}
			}
			aUsable = aUsable.Inventory;
		}
	}

	aUsable = CreateInventoryClass( UsableInfo.m_UsableClass );
	if ((aUsable != None) && aUsable.IsA('gbxUsableItem'))
	{
		if (gbxUsableItem(aUsable).NumCopies < UsableInfo.m_nMaxCharQuantity)
		{
			gbxUsableItem(aUsable).NumCopies = UsableInfo.m_nMaxCharQuantity;
		}
	}
}

event IShotAtYou( gbxPawn Instigator, bool bIsWarningShot )
{
	if( bIsWarningShot && Level.TimeSeconds > NextWarningShotEffectTime )
	{
		NextWarningShotEffectTime = Level.TimeSeconds + WarningShotEffectInterval;		

		if( IsLocallyControlled() )
		{
			DoWarningShotEffect( Instigator );
		}
		else
		{
			ServerDoWarningShotEffect( Instigator );
			ClientDoWarningShotEffect( Instigator );
		}

		// Spawn a perception message to let the player's teammates know he was almost hit.
		if ( bIsWarningShot && MyUnit != None )
		{
			MyUnit.SpawnPerceptionPlayerWarningShot( Self );
		}
	}
}

function ServerDoWarningShotEffect( gbxPawn Instigator )
{
	// Fatigue
	Controller.JogFatigue( FatigueJog_PlayerWarningShot );	
}

function ClientDoWarningShotEffect( gbxPawn Instigator )
{
	DoWarningShotEffect( Instigator );
}

simulated function DoBuzzView()
{
	BuzzViewTime = BuzzViewMaxTime;
}

simulated function DoDamageShotEffect( Pawn Instigator )
{
	local float InstigatorAngle;
	local gbxHUD aMyHud;
	local WargamePlayerController MyPC;
	local Vector BloodEffectVector;
	local Vector FacingVector;

	MyPC = WargamePlayerController(Controller);

	MyPC.PlayPainSound();

	// Hud effects
	if ((MyPC != None) && (gbxHUD( MyPC.MyHUD ) != None))
	{
		FacingVector = Vector( GetViewRotation() );
		InstigatorAngle = GetFacingAngleToLocation( Instigator.Location );
		aMyHud = gbxHUD( MyPC.MyHUD );
		
		if( InstigatorAngle > (360.0 - MyPC.DesiredFOV / 2) || InstigatorAngle < (MyPC.DesiredFOV / 2) )
		{
			BloodEffectVector = FacingVector >> Rot(0,32768,0);

			aMyHud.DoEdgeEffect( Top, TakeDamageEdgeEffectColor, TakeDamageRenderStyle, true );
			OptionallyDoForceFeedback( "DamageM" );
		}
		else if( InstigatorAngle < 135.0 )
		{
			BloodEffectVector = FacingVector >> Rot(0,49162,0);

			aMyHud.DoEdgeEffect( Right, TakeDamageEdgeEffectColor, TakeDamageRenderStyle, true );
			OptionallyDoForceFeedback( "DamageR" );
		}
		else if( InstigatorAngle < 225.0 )
		{
			BloodEffectVector = FacingVector;

			aMyHud.DoEdgeEffect( Bottom, TakeDamageEdgeEffectColor, TakeDamageRenderStyle, true );
			OptionallyDoForceFeedback( "DamageM" );
		}
		else
		{
			BloodEffectVector = FacingVector >> Rot(0,16384,0);

			aMyHud.DoEdgeEffect( Left, TakeDamageEdgeEffectColor, TakeDamageRenderStyle, true );
			OptionallyDoForceFeedback( "DamageL" );
		}

		MyPC.CreateHudBloodEffect( BloodEffectVector, RandRange( BloodEffectParticleCount.Min, BloodEffectParticleCount.Max ) );
	}
}

simulated function OptionallyDoForceFeedback( string EffectName )
{
	local PlayerController P;

	if ( (Level.NetMode != NM_DedicatedServer) && IsLocallyControlled() )
	{
		P = PlayerController(Controller);
		if ( P != None && P.bEnableDamageForceFeedback )
		{
			P.ClientPlayForceFeedback( EffectName );
		}
	}
}

simulated function DoWarningShotEffect( gbxPawn Instigator )
{
	local gbxHUD aMyHud;
	local float InstigatorAngle;

	// Fatigue
	Controller.JogFatigue( FatigueJog_PlayerWarningShot );

	// Sound

	if( WarningShotCue != None )
	{
		PlaySoundCue( WarningShotCue, SLOT_None,,,,, );
	}

	// View buzz
	DoBuzzView();

	// Hud effects and rumble.
	if ((WargamePlayerController(Controller) != None) && (gbxHUD( PlayerController(Controller).MyHUD ) != None))
	{
		aMyHud = gbxHUD( WargamePlayerController(Controller).MyHUD );
		
		InstigatorAngle = GetFacingAngleToLocation( Instigator.Location );
		Log( "Warning shot received from angle "$InstigatorAngle, 'SJP' );

		if( InstigatorAngle > (360.0 - PlayerController(Controller).DesiredFOV / 2) || InstigatorAngle < (PlayerController(Controller).DesiredFOV / 2) )
		{
			aMyHud.DoEdgeEffect( Top, WarningShotEdgeEffectColor, WarningShotRenderStyle, false );
			OptionallyDoForceFeedback( "WarningShotM" );
		}
		else if( InstigatorAngle < 135.0 )
		{
			aMyHud.DoEdgeEffect( Right, WarningShotEdgeEffectColor, WarningShotRenderStyle, false );
			OptionallyDoForceFeedback( "WarningShotR" );
		}
		else if( InstigatorAngle < 225.0 )
		{
			aMyHud.DoEdgeEffect( Bottom, WarningShotEdgeEffectColor, WarningShotRenderStyle, false );
			OptionallyDoForceFeedback( "WarningShotM" );
		}
		else
		{
			aMyHud.DoEdgeEffect( Left, WarningShotEdgeEffectColor, WarningShotRenderStyle, false );
			OptionallyDoForceFeedback( "WarningShotL" );
		}
	}	
}

function TNTPlantAnimFinished() {}
function TNTMountAnimFinished() {}
function TNTDismountAnimFinished() {}

function bool CanPlaceTNT() 
{ 
	// Can't mount when in oracle cam mode.
	if( gbxPlayerController( Controller ).IsInOracleCamMode() )
		return false;	
	
	// Can't mount while reloading.
	if ( Weapon != None && Weapon.IsReloading() )
		return false;

	// Can't mount while manning a turret.
	if ( bIsManningTurret )
		return false;

	return true;
}

function PlaceTNT( Actor Target, TNTTrigger TheTNTTrigger )
{
	local Rotator NewFacingRot;	

	TNTTimestamp = 0.0;
	TNTLastCameraLoc = Location;

	LastTNTTrigger = TheTNTTrigger;

	if ( Controller != None )
	{
		PreviousGodMode = Controller.bGodMode;
		Controller.bGodMode = true;
		gbxPlayerController( Controller ).EnableHeavyTrauma( false );
		gbxPlayerController( Controller ).LimitPlayerInput( true );
	}

	// Force a rotate to face the actor target.
	if ( Target != None && Controller != None )
	{
		NewFacingRot = Rotator( Target.Location - Location );
		NewFacingRot.Pitch = 0;
		SetRotation( NewFacingRot );
		Controller.SetRotation( NewFacingRot );
	}

	GotoState( 'CrouchingToPlaceTNT' );
}

state TNTBaseState
{
	function bool CanPlaceTNT() { return false; }
	function PlaceTNT( Actor Target, TNTTrigger TheTNTTrigger ) {}

	simulated function bool SpecialCalcView(out actor ViewActor, out vector CameraLocation, out rotator CameraRotation )
	{
		local Vector X,Y,Z, TravelDir, NewCameraLoc;
		local float TimeDelta, DeltaLoc, DeltaRot;
		
		GetAxes( Rotation, X,Y,Z );

		if ( TNTTimestamp > 0 )
		{	
			TimeDelta = Level.TimeSeconds - TNTTimeStamp;
			DeltaLoc = TimeDelta * TNTCameraSpeed;			
			DeltaRot = TimeDelta * TNTCameraRotSpeed;

			TravelDir = TNTDesiredCameraLoc - TNTLastCameraLoc;
			NewCameraLoc = TNTLastCameraLoc + DeltaLoc*TravelDir;

			if ( DeltaLoc > VSize( TravelDir ) )
				CameraLocation = TNTDesiredCameraLoc;
			else
				CameraLocation = NewCameraLoc;
						
			if ( DeltaRot > abs( TNTDesiredCameraPitch - TNTLastCameraPitch ) )
				CameraRotation.Pitch = TNTDesiredCameraPitch;
			else
				CameraRotation.Pitch = TNTLastCameraPitch + DeltaRot * ( TNTDesiredCameraPitch - TNTLastCameraPitch );
		}
		else
		{
			CameraLocation = Location + TNTCameraStart.X*X + TNTCameraStart.Y*Y + TNTCameraStart.Z*Z;
			CameraRotation.Pitch = Rotation.Pitch;
		}

		TNTLastCameraLoc = CameraLocation;
		TNTLastCameraPitch = CameraRotation.Pitch;
		TNTTimeStamp = Level.TimeSeconds;
		return true;
	}
}

state CrouchingToPlaceTNT extends TNTBaseState
{
	function BeginState()
	{
		local Vector X,Y,Z;

		GetAxes( Rotation, X,Y,Z );

		// Make sure current weapon is not zoomed-in.
		if ( Weapon != None && Weapon.IsA( 'gbxWeapon' ) )
		{
			gbxWeapon( Weapon ).ForceUnzoom();
		}					

		StowedWeapon = Weapon;
		if (Weapon != None)
		{
			if (Weapon.ThirdPersonActor != None)
				Weapon.ThirdPersonActor.bHidden = true;  // hide the weapon quickly
		}
		Weapon.PutDown();

		bHasStartedMountAnim = true;
		StartGoingToCrouch( true );

		Velocity=Vect(0,0,0);
		FlushAnimQueueChannel( 0,, true );
		StopAnimating(true);

		gbxPlayerController( Controller ).bBehindView = true;
		bSpecialCalcView = true;

		bInterpolating = true;
		TNTDesiredCameraLoc = Location + TNTCameraMiddle.X*X + TNTCameraMiddle.Y*Y + TNTCameraMiddle.Z*Z;
		TNTDesiredCameraPitch = -8192;
		TNTCameraRotSpeed = TNTCameraRotSpeedIn;
	}

	function TNTMountAnimFinished()
	{	
		local Rotator FlattenedRot;
		local Vector X,Y,Z;

		FlattenedRot = Rotation;
		FlattenedRot.Pitch = 0;
		GetAxes( FlattenedRot, X,Y,Z );
		GotoState( 'PlantingTNT' );
	}

Begin:
	FlushAnimQueueChannel( 0 );		
	AddAnimToQueue( PawnAnimInfoClass.Static.PawnTNTMountAnim(), QUEUE_TURRET_MOUNT_PRIORITY, true, false, false, 1.0, 0.05, class'TNTMountCallback' );
}

state PlantingTNT extends TNTBaseState
{
	function BeginState()
	{
		local Vector FloorLocation, HitNorm;
		local Rotator NewRotation;
		local Actor HitActor;

		Super.BeginState();

		FloorLocation = Location + 10.0 * Vector( Rotation );
		
		// Now, trace straight down to the floor.
		HitActor = Trace( FloorLocation, HitNorm, FloorLocation + Vect(0,0,-500.0), FloorLocation,, Vect(20,20,20) );

		NewRotation = Rotation;
		NewRotation.Pitch = 0;

		FloorLocation.Z += 30;
		LastTNTTrigger.PlantTNT( FloorLocation, NewRotation, Self );		
	}

	function TNTPlantAnimFinished()
	{	
		GotoState( 'UnCrouchingTNT' );
	}

Begin:
	FlushAnimQueueChannel( 0 );		
	AddAnimToQueue( PawnAnimInfoClass.Static.PawnTNTPlantingAnim(), QUEUE_TURRET_MOUNT_PRIORITY, true, false, false, 1.0, 0.0, class'TNTPlantCallback' );
}

state UnCrouchingTNT extends TNTBaseState
{
	function BeginState()
	{
		local Vector X,Y,Z;

		GetAxes( Rotation, X,Y,Z );
		StartGoingToStand( true );
		TNTDesiredCameraLoc = Location + TNTCameraEnd.X*X + TNTCameraEnd.Y*Y + TNTCameraEnd.Z*Z;
		TNTDesiredCameraPitch = 0;
		TNTCameraRotSpeed = TNTCameraRotSpeedOut;
	}

	function EndState()
	{
		bDoTorsoTwist = true;
		bHasStartedMountAnim = false;		

		LastTNTTrigger.SetTNTVisible();

		StopLookAt(true, false, true);
		ResetLookAtImmediate(true, false, true);

		bInterpolating = false;

		PlayWaiting( true );

		if ( Controller.IsA( 'gbxPlayerController' ) )
		{
			gbxPlayerController( Controller ).bBehindView = false;			
		}
		
		bSpecialCalcView = false;
	}

	function TNTDismountAnimFinished()
	{
		if ( Controller != None )
		{
			Controller.bGodMode = PreviousGodMode;  // restore previous god mode setting when exiting trauma cam
			gbxPlayerController( Controller ).EnableHeavyTrauma( true );
			gbxPlayerController( Controller ).LimitPlayerInput( false );
		}		
		
		//SetWeapon( StowedWeapon );
		if (StowedWeapon != None)
		{
			if (StowedWeapon.ThirdPersonActor != None)
				StowedWeapon.ThirdPersonActor.bHidden = false;
		}
		GotoState( '' );
	}


Begin:
	FlushAnimQueueChannel( 0 );
	AddAnimToQueue( PawnAnimInfoClass.Static.PawnTNTDismountAnim(), QUEUE_TURRET_MOUNT_PRIORITY, true, false, false, 1.0, 0.05, class'TNTDismountCallback' );
}

function TankGrenadeAnimZoomIn()
{	
}

function bool CanGrenadeTank() 
{
	// Can't when in oracle cam mode.
	if( gbxPlayerController( Controller ).IsInOracleCamMode() )
		return false;	
	
	// Can't while reloading.
	if ( Weapon != None && Weapon.IsReloading() )
		return false;

	// Can't while manning a turret.
	if ( bIsManningTurret )
		return false;

	if (SecondaryWeapon == None)  // does the player not have any grenades?
		return false;

	if (gbxUsableItem(SecondaryWeapon).bCanHaveMultipleCopies)
	{
		if (gbxUsableItem(SecondaryWeapon).NumCopies <= 0)  // does the player not have any grenades?
			return false;
	}

	return true;
}

function GrenadeTank( gbxPawn Target )
{
	local MeshAnimation	aMeshAnim;

	if (Target == None)
		return;

	TankGrenadeTank = Tank(Target);

	if (TankGrenadeTank == None)
		return;

	if ( Controller != None )
	{
		PreviousGodMode = Controller.bGodMode;
		Controller.bGodMode = true;
		bBlockZeroExtentTraces = false;
		gbxPlayerController( Controller ).EnableHeavyTrauma( false );
		gbxPlayerController( Controller ).LimitPlayerInput( true );
	}

	TankGrenadePlayerAnim = TankGrenadeTank.TankGrenadePlayerAnim;
	TankGrenadeMeshAnimName = TankGrenadeTank.TankGrenadeMeshAnimName;
	TankGrenadeMountAnimStartOffset = TankGrenadeTank.TankGrenadeMountAnimStartOffset;
	TankGrenadeCameraStartOffset = TankGrenadeTank.TankGrenadeCameraStartOffset;
	TankGrenadeCameraEndOffset = TankGrenadeTank.TankGrenadeCameraEndOffset;
	TankGrenadeHeadZoomInOffset = TankGrenadeTank.TankGrenadeHeadZoomInOffset;
	TankGrenadeYawSet = TankGrenadeTank.TankGrenadeYawSet;
	TankGrenadeTeleportOffset = TankGrenadeTank.TankGrenadeTeleportOffset;

	aMeshAnim = MeshAnimation( DynamicLoadObject( TankGrenadeMeshAnimName,class'MeshAnimation' ) );
	if ( aMeshAnim != None )
	{
		if (LinkSkelAnim( aMeshAnim ))
		{
			MeshAnim = aMeshAnim;
			CurMeshAnimName = TankGrenadeMeshAnimName;
		}
		bInitializeAnimation = false;
	}

	if (gbxPlayerController(Controller) != None)
		gbxPlayerController(Controller).bDisableCrosshair = true;  // temporarily turn crosshair off

	GotoState( 'GrenadeTankClimbingOn' );
}

state GrenadeTankClimbingOn
{
	function bool CanGrenadeTank() { return false; }
	function GrenadeTank( gbxPawn Target ) {}

	simulated function bool SpecialCalcView(out actor ViewActor, out vector CameraLocation, out rotator CameraRotation )
	{
		local vector TankRotX, TankRotY, TankRotZ;
		local float T;
		local vector v1, v2;

		GetAxes( TankGrenadeTank.Rotation, TankRotX, TankRotY, TankRotZ );

		if (bTankGrenadeCameraIsPaused)
			T = FClamp( ( TankGrenadeCameraPausedTime - TankGrenadeMountStartStamp ) / TankGrenadeCameraZoomTime, 0.0, 1.0 );
		else
			T = FClamp( ( Level.TimeSeconds - TankGrenadeMountStartStamp ) / TankGrenadeCameraZoomTime, 0.0, 1.0 );

		v1 = TankGrenadeTank.Location + (TankGrenadeCameraSweepStartOffset.X * TankRotX + TankGrenadeCameraSweepStartOffset.Y * TankRotY + TankGrenadeCameraSweepStartOffset.Z * TankRotZ);
		v2 = TankGrenadeTank.Location + (TankGrenadeCameraSweepEndOffset.X * TankRotX + TankGrenadeCameraSweepEndOffset.Y * TankRotY + TankGrenadeCameraSweepEndOffset.Z * TankRotZ);
		CameraLocation = v1 + T*(v2 - v1);

		CameraRotation.Pitch = (TankGrenadeCameraStartPitch + T*(TankGrenadeCameraEndPitch - TankGrenadeCameraStartPitch)) & 65535;
		CameraRotation.Yaw = (TankGrenadeTank.Rotation.Yaw - 16384) & 65535;

		if (bTankGrenadeCameraNeedsToPause)
		{
			bTankGrenadeCameraIsPaused = true;
			bTankGrenadeCameraNeedsToPause = false;

			TankGrenadeCameraPausedTime = Level.TimeSeconds;
		}

		return true;
	}

	function InitializePlayer()
	{
		local vector RotX, RotY, RotZ;
		local vector MountPoint;
		local vector v1, v2;
		local vector TankLocation;

		// Make sure current weapon is not zoomed-in.
		if ( Weapon != None && Weapon.IsA( 'gbxWeapon' ) )
		{
			gbxWeapon( Weapon ).ForceUnzoom();
		}					

		StowedWeapon = Weapon;
		if (Weapon != None)
		{
			if (Weapon.ThirdPersonActor != None)
				Weapon.ThirdPersonActor.bHidden = true;  // hide the weapon quickly
		}
		Weapon.PutDown();

		bHasStartedMountAnim = true;

		Acceleration = vect(0,0,0);
		Velocity = vect(0,0,0);

		FlushAnimQueueChannel( 0,, true );
		StopAnimating(true);

		gbxPlayerController( Controller ).bBehindView = true;
		bSpecialCalcView = true;

		bInterpolating = true;

		GetAxes(TankGrenadeTank.Rotation, RotX, RotY, RotZ);

		SetPhysics(PHYS_None);
		SetCollision(false, false, false);  // jlb-hack for collision during pawn placement for mount animation

		// save the CollisionRadius and CollisionHeight (so we can restore it later)...
		TankGrenadePawnCollisionRadius = CollisionRadius;
		TankGrenadePawnCollisionHeight = CollisionHeight;
		SetCollisionSize(1.0, 1.0);  // tiny cylinder, just in case, so we don't collide with world

		TankLocation = TankGrenadeTank.GetBoneCoords('chassis').origin;
		MountPoint = TankLocation + (TankGrenadeMountAnimStartOffset.X * RotX + TankGrenadeMountAnimStartOffset.Y * RotY + TankGrenadeMountAnimStartOffset.Z * RotZ);

		SetLocation( MountPoint );

		SetRotation( TankGrenadeTank.Rotation );
		if (Controller != None)
			Controller.SetRotation( TankGrenadeTank.Rotation );

		// hard attach player pawn to tank so that animation plays properly if tank is moving...
		bHardAttach = true;
		SetBase(TankGrenadeTank);

		bTankGrenadeCameraIsPaused = false;
		bTankGrenadeCameraNeedsToPause = false;

		TankGrenadeMountStartStamp = Level.TimeSeconds;
		TankGrenadeCameraZoomTime = 3.0;

		TankGrenadeCameraSweepStartOffset = MountPoint +
							(TankGrenadeCameraStartOffset.X * RotX + TankGrenadeCameraStartOffset.Y * RotY + TankGrenadeCameraStartOffset.Z * RotZ) -
							TankGrenadeTank.Location;

		// convert the offset vector from world space to local space (relative to the tank's location)
		TankGrenadeCameraSweepStartOffset = TankGrenadeCameraSweepStartOffset << TankGrenadeTank.Rotation;

		v1 = TankGrenadeTank.Location;
		TankGrenadeCameraSweepEndOffset = v1 + (TankGrenadeCameraEndOffset.X * RotX + TankGrenadeCameraEndOffset.Y * RotY + TankGrenadeCameraEndOffset.Z * RotZ) - TankGrenadeTank.Location;
		TankGrenadeCameraSweepEndOffset = TankGrenadeCameraSweepEndOffset << TankGrenadeTank.Rotation;

		v1 = TankGrenadeTank.Location + (TankGrenadeCameraSweepStartOffset.X * RotX + TankGrenadeCameraSweepStartOffset.Y * RotY + TankGrenadeCameraSweepStartOffset.Z * RotZ);
		v2 = MountPoint + vect(0,0,79);  // offset by eye height
		TankGrenadeCameraStartPitch = rotator(v2 - v1).Pitch;
		TankGrenadeCameraEndPitch = -2000;
	}

	function TankGrenadeAnimZoomIn()
	{
		GotoState( 'GrenadeTankZoomingBack' );
	}

Begin:
	if (bIsCrouched)
		ForceUnCrouch();

	InitializePlayer();

	TankGrenadeTank.FlushAnimQueueChannel( 0,, true );
	TankGrenadeTank.StopAnimating(true);

	// THIS DOESN'T WORK WHEN THE PLAYER IS CROUCHING (because animation is wrong), JUST HARDCODE THIS FOR NOW...
//	TankGrenadeRootBoneDelta = GetBoneCoords(RootBone).origin - Location;
	TankGrenadeRootBoneDelta.X = 0;
	TankGrenadeRootBoneDelta.Y = 0;
	TankGrenadeRootBoneDelta.Z = 11;

	FlushAnimQueueChannel( 0 );
	AddAnimToQueue( TankGrenadePlayerAnim, QUEUE_TURRET_MOUNT_PRIORITY, true, false, false, 1.0, 0.05, class'TankGrenadeCallback' );
}


state GrenadeTankZoomingBack
{
	function bool CanGrenadeTank() { return false; }
	function GrenadeTank( gbxPawn Target ) {}

	simulated function bool SpecialCalcView(out actor ViewActor, out vector CameraLocation, out rotator CameraRotation )
	{
		local vector TankRotX, TankRotY, TankRotZ;
		local float T;
		local vector v1, v2;

		GetAxes( TankGrenadeTank.Rotation, TankRotX, TankRotY, TankRotZ );

		if (bTankGrenadeCameraIsPaused)
			T = FClamp( ( TankGrenadeCameraPausedTime - TankGrenadeMountStartStamp ) / TankGrenadeCameraZoomTime, 0.0, 1.0 );
		else
			T = FClamp( ( Level.TimeSeconds - TankGrenadeMountStartStamp ) / TankGrenadeCameraZoomTime, 0.0, 1.0 );

		v1 = TankGrenadeTank.Location + (TankGrenadeCameraSweepStartOffset.X * TankRotX + TankGrenadeCameraSweepStartOffset.Y * TankRotY + TankGrenadeCameraSweepStartOffset.Z * TankRotZ);
		v2 = TankGrenadeTank.Location + (TankGrenadeCameraSweepEndOffset.X * TankRotX + TankGrenadeCameraSweepEndOffset.Y * TankRotY + TankGrenadeCameraSweepEndOffset.Z * TankRotZ);
		CameraLocation = v1 + T*(v2 - v1);

		CameraRotation.Pitch = (TankGrenadeCameraStartPitch + T*(TankGrenadeCameraEndPitch - TankGrenadeCameraStartPitch)) & 65535;
		CameraRotation.Yaw = (TankGrenadeTank.Rotation.Yaw - 16384) & 65535;

		if (bTankGrenadeCameraNeedsToPause)
		{
			bTankGrenadeCameraIsPaused = true;
			bTankGrenadeCameraNeedsToPause = false;

			TankGrenadeCameraPausedTime = Level.TimeSeconds;
		}

		if ((Level.TimeSeconds - TankGrenadeMountStartStamp) > (TankGrenadeCameraZoomTime * 0.85))
		{
			GotoState( '' );
			return true;
		}

		return true;
	}

	function BeginState()
	{
		local vector MountPoint;
		local vector RotX, RotY, RotZ;
		local vector v1;
		local vector TankLocation;

		bDontFrustumCull = true;

		GetAxes(TankGrenadeTank.Rotation, RotX, RotY, RotZ);

		TankGrenadeMountStartStamp = Level.TimeSeconds;
		TankGrenadeCameraZoomTime = 1.0;

		TankLocation = TankGrenadeTank.GetBoneCoords('chassis').origin;
		MountPoint = TankLocation + (TankGrenadeHeadZoomInOffset.X * RotX + TankGrenadeHeadZoomInOffset.Y * RotY + TankGrenadeHeadZoomInOffset.Z * RotZ);

		TankGrenadeCameraSweepEndOffset = MountPoint -	TankGrenadeTank.Location;
		// convert the offset vector from world space to local space (relative to the tank's location)
		TankGrenadeCameraSweepEndOffset = TankGrenadeCameraSweepEndOffset << TankGrenadeTank.Rotation;

		v1 = TankGrenadeTank.Location;
		TankGrenadeCameraSweepStartOffset = v1 + (TankGrenadeCameraEndOffset.X * RotX + TankGrenadeCameraEndOffset.Y * RotY + TankGrenadeCameraEndOffset.Z * RotZ) - TankGrenadeTank.Location;
		TankGrenadeCameraSweepStartOffset = TankGrenadeCameraSweepStartOffset << TankGrenadeTank.Rotation;

		TankGrenadeCameraEndPitch = 0;
		TankGrenadeCameraStartPitch = -2000;
	}

	function EndState()
	{
		local int count;
		local vector NewLoc, OffsetVec;
		local rotator NewRot;
		local bool result;
		local Vector RotX, RotY, RotZ;

		bDontFrustumCull = false;

		bHardAttach = false;
		SetBase(None);

		GetAxes(TankGrenadeTank.Rotation, RotX, RotY, RotZ);

		// restore the CollisionRadius and CollisionHeight...
		SetCollisionSize(TankGrenadePawnCollisionRadius, TankGrenadePawnCollisionHeight);

		SetCollision(true, true, true);
		SetPhysics(PHYS_Walking);

		// if the tank is not Karma simulating, wake it up (this MUST be done otherwise the SetLocation test below
		// will use the Collision Cylinder of the tank and the player will collide when placing)...
		if (TankGrenadeTank.Physics != PHYS_Karma)
		{
			TankGrenadeTank.SetPhysics(PHYS_Karma);
			TankGrenadeTank.KWake();  // wake it up

			TankGrenadeTank.KarmaSleepTime = Level.TimeSeconds + 1.0f;
		}

		count = 0;
		NewLoc= TankGrenadeTank.Location + (TankGrenadeTeleportOffset.X * RotX + TankGrenadeTeleportOffset.Y * RotY + TankGrenadeTeleportOffset.Z * RotZ);
		OffsetVec = vect(0,0,1) - RotX;  // up and back
		result = SetLocation(NewLoc);
		while ((!result) && (count < 20))
		{
			// keep pushing the player up and out slightly until they don't collide!!!
			count++;
			NewLoc = NewLoc + OffsetVec;
			result = SetLocation(NewLoc);
		}

		NewRot = TankGrenadeTank.Rotation;
		NewRot.Pitch = 0;
		NewRot.Yaw = (NewRot.Yaw - TankGrenadeYawSet) & 65535;
		NewRot.Roll = 0;
		SetRotation(NewRot);
		Controller.SetRotation( NewRot );

		if ( Controller != None )
		{
			Controller.bGodMode = PreviousGodMode;  // restore previous god mode setting when exiting trauma cam
			bBlockZeroExtentTraces = true;
			gbxPlayerController( Controller ).EnableHeavyTrauma( true );
			gbxPlayerController( Controller ).LimitPlayerInput( false );
		}
		
		if (StowedWeapon != None)
		{
			if (StowedWeapon.ThirdPersonActor != None)
				StowedWeapon.ThirdPersonActor.bHidden = false;  // un-hide the weapon quickly
		}
		SetWeapon( StowedWeapon );

		if (gbxPlayerController(Controller) != None)
			gbxPlayerController(Controller).bDisableCrosshair = false;

		PlayWaiting( true );

		bDoTorsoTwist = true;
		bHasStartedMountAnim = false;		

		StopLookAt(true, false, true);
		ResetLookAtImmediate(true, false, true);

		bInterpolating = false;

		if ( Controller.IsA( 'gbxPlayerController' ) )
		{
			gbxPlayerController( Controller ).bBehindView = false;			
		}
		
		bSpecialCalcView = false;
	}

Begin:

}

function AddDefaultInventory()
{
	// This is very slow, and has no meaning for MP anyways. So only do this stuff in SP games. 2004-12-02 JWS
	if (Level.NetMode == NM_Standalone)
	{
		// GBX:PAD: This is a hack to clear out the grenade count before adding the inventory, since this code is called
		// multiple times in character setup.
		ClearInventory();

		if (!(Level.MissionManager.EquipCheckpointPlayerInventory( self )))
		{
			Super.AddDefaultInventory();
		}
		else
		{
			if (Weapon == None)
			{
				SetWeaponAnims( PawnAnimInfoClass, false );
			}
		}
	}
	else if (Level.Game.CanUseCheckpoints(-1))
	{
		log(self$".AddDefaultInventory()");
		// GBX:PAD: This is a hack to clear out the grenade count before adding the inventory, since this code is called
		// multiple times in character setup.
		ClearInventory();

		if (!(Level.MissionManager.SkirmishEquipCheckpointPlayerInventory( self )))
		{
			Super.AddDefaultInventory();
		}
		else
		{
			if (Weapon == None)
			{
				SetWeaponAnims( PawnAnimInfoClass, false );
			}
		}
	}
	else
	{
		Super.AddDefaultInventory();
	}
}

// Override Pawn implementation
function TossWeapon(Vector TossVel)
{
	local WargamePlayerController pc;  //NAC added
	pc = WargamePlayerController(Controller); //NAC added

	//NAC: if we tossed this weapon while zoomed in we need to make sure that all 'zoomed in' variables are reset
	if ( pc.isZoomed() )
	{
		gbxWeapon( Weapon ).ForceUnZoom();
	}

	Weapon.Velocity = TossVel;
	Weapon.RotationRate.Pitch = 0;
	Weapon.RotationRate.Yaw = 16000 + (Rand(32000) - 16000);
	Weapon.RotationRate.Roll = 0;
	Weapon.DropFrom( Weapon.GetChamberLocationWorld() );
}

defaultProperties
{
	CharacterSetupClass=Engine.CharacterSetupUSA
	ControllerClass=gbxGameplay.WargamePlayerController
	// GBX:PAD: Added this in to turn on viewing the player body by default.
	bAlwaysTick=false;
	bOwnerNoSee=false;
	
	Health=100

	MinSecsBeforeDisappear=5

	bCanWalkOffLedges = true
	DecelRate=+192.000000
	AccelRate=+02048.000000

	MinCrouchToggleInterval=0.5

	FatigueRate_Walking=0.25
	FatigueRate_Running=1.0			// SJP: Increasing per Marc Blondeau's suggestion
	//FatigueRate_Running=0.1

	DeathSlowStartTime=0.0
	DeathSlowEndTime=1.0
	DeathColorStartTime=1.0
	DeathColorEndTime=2.0
	DeathBlurStartTime=0.0
	DeathBlurEndTime=1.0
	DeathFadeStartTime=3.0
	DeathFadeRate=0.25
	FinalDeathSlow=0.3
	FinalDeathBlur=25
	FinalDeathColor=(R=96,G=0,B=0,A=255)
	DeathColorStart=(R=127,G=127,B=127,A=0)
	ColorBlack=(R=0,G=0,B=0,A=255)
	
	TraumaColorSrc=(R=127,G=127,B=127,A=127)
	TraumaColorDst=(R=0,G=0,B=0,A=127)
	TraumaColorFlash=(R=255,G=255,B=255,A=255)
	TraumaFadeRate=0.25
	TraumaTimeScale=0.5
	TraumaBlur=127
	TraumaDurationMelee=1.0

	DeathCamZOffset=16.0
	

	bCanPickupInventory=True

	eWeaponAimedState=WAS_Sighted

	myInspectorClass=class'gbxGameplay.gbxInspectorPlayer'

	MenuName="Sgt. Joe Hartsock"
	MenuNameBaker="Sgt. Matt Baker"
	MenuNameHans="Theodor Luether"
	MenuNameFrans="Lukas Wilhelm"

	WarningShotEffectInterval = 1.0;

	TNTCameraStart=(X=-30.0,Y=0.0,Z=110.0)
	TNTCameraMiddle=(X=-150.0,Y=0,Z=150.0)
	TNTCameraEnd=(X=-100.0,Y=20.0,Z=90.0)
	TNTTeleportOffset=(X=23.5,Y=-8.5,Z=0)
	TNTCameraSpeed=1.0
	TNTCameraRotSpeedIn=5.0
	TNTCameraRotSpeedOut=1.0

	WarningShotEdgeEffectColor = (R=100,G=100,B=100,A=255)
	WarningShotRenderStyle = STY_Additive
	TakeDamageEdgeEffectColor = (R=60,G=20,B=20,A=255)
	TakeDamageRenderStyle = STY_Alpha

	BuzzViewMaxTime = 0.25
	BuzzViewMaxAngle = 150

	BloodEffectParticleCount = (Min=75,Max=100)
	CharacterName="Hartsock"
}
//=============================================================================
// Gearbox Player start location.
//=============================================================================
class gbxPlayerStart extends PlayerStart
	placeable;



var() name		TriggerOnDeath;
var() bool		m_fStartWithNoWeapons;
var() bool		m_fFingerMissing;
var() string	RequiredEquipment[16];	// allow L.D. to modify
var() CharacterSetup.EUSCharacterTypes	m_eCharacterType;

function AddDefaultInventory( Pawn aPlayerPawn )
{
	local int i;

	log( self$".AddDefaultInventory( "$aPlayerPawn$" )");
	if ((RequiredEquipment[0] == "") || (gbxPawn(aPlayerPawn) == None))
		return;

	for( i = 0; i < 16; i++ )
	{
		gbxPawn(aPlayerPawn).RequiredEquipment[i] = RequiredEquipment[i];
	}
	if (!Level.Game.IsA('WargameDeathMatch'))
		gbxPawn(aPlayerPawn).AddDefaultInventory();
}

defaultproperties
{
	RequiredEquipment[0]="gbxInventory.WeapUSM1_"
	RequiredEquipment[1]="gbxInventory.UsableUSHandGrenade"
    m_fStartWithNoWeapons=false
    m_eCharacterType=41
}
// GEARBOX 2004-10-06 JWS created
//
// base class of the primary victory conditions for MP missions.
// These victory conditions can take priority over the secondary victory conditions at
// key moments.
class gbxPrimaryVictoryCondition extends gbxVictoryCondition
	abstract
	native;

function PauseSecondaryVictoryConditions()
{
	local gbxSecondaryVictoryCondition vc;
	local bool pauseResult;

	foreach DynamicActors(class'gbxSecondaryVictoryCondition', vc)
	{
		pauseResult = vc.Pause(self);

		if (pauseResult)
		{
			Log(self $ " gbxPrimaryVictoryCondition::PauseSecondaryVictoryConditions() paused " $ vc, 'JWS');
		}
		else
		{
			Log(self $ " WARNING! gbxPrimaryVictoryCondition::PauseSecondaryVictoryConditions() failed to pause " $ vc, 'JWS');
		}
	}
}

function UnPauseSecondaryVictoryConditions()
{
	local gbxSecondaryVictoryCondition vc;
	local bool unpauseResult;

	foreach DynamicActors(class'gbxSecondaryVictoryCondition', vc)
	{
		unpauseResult = vc.UnPause(self);

		if (unpauseResult)
		{
			Log(self $ " gbxPrimaryVictoryCondition::UnPauseSecondaryVictoryConditions() unpaused " $ vc, 'JWS');
		}
		else
		{
			Log(self $ " WARNING! gbxPrimaryVictoryCondition::UnPauseSecondaryVictoryConditions() failed to unpause " $ vc, 'JWS');
		}
	}
}

// Base class that defines reinforcement rules on a per-map basis.
// PSV 4/12/2005
class gbxReinforcementRules extends Info
	abstract;

function int GetReinforcementsForTeam(ETeamIdentifier TeamID, int USTeamSize, int DETeamSize)
{
	return 0;
}

defaultproperties
{
}// GEARBOX 2004-10-06 JWS created
//
// base class of the secondary victory conditions for MP missions.
// These victory conditions specify the rules for the secondary objectives, and
// can be paused (meaning they can be turned on and off) when primary objectives
// deem it necessary.
class gbxSecondaryVictoryCondition extends gbxVictoryCondition
	abstract;

var private gbxPrimaryVictoryCondition PausedBy;

// Can't use states for this stuff because the derived classes make use of states and that conflicts with this
function bool Pause(gbxPrimaryVictoryCondition pauser)
{
	local bool result;

	assert(pauser != None);

	if (PausedBy == None)
	{
		Log(self $ " Victory Condition has been paused by " $ pauser, 'JWS');

		PausedBy = pauser;

		result = true;
	}
	else
	{
		result = false;
	}

	return result;
}

function bool UnPause(gbxPrimaryVictoryCondition unpauser)
{
	local bool result;

	assert(unpauser != None);

	if (PausedBy == unpauser)
	{
		Log(self $ " Victory Condition has been UNpaused by " $ unpauser, 'JWS');

		PausedBy = None;

		result = true;
	}
	else
	{
		result = false;
	}

	return result;
}

function bool CheckForVictory(out ETeamIdentifier WinningTeam, out int reason)
{
	//Log( " gbxSecondaryVictoryCondition::CheckForVictory()", 'MP' );
	if (PausedBy == None)
	{
		return Super.CheckForVictory(WinningTeam, reason);
	}
	else
	{
		return false;
	}
}// Class that defines reinforcement rules on a per-map basis in skirmish mode.
// PSV 4/12/2005
class gbxSkirmishReinforcementRules extends gbxReinforcementRules
	placeable;

// Properties
// The reinforcement rules are defined for each team in each of the following situations:
// Solo - playing with yourself (pervert!)
// Coop - playing with a homie

var(Reinforcements) int Solo;
var(Reinforcements) int Coop;

// Internal State

function int GetReinforcementsForTeam(ETeamIdentifier TeamID, int USTeamSize, int DETeamSize)
{
	local int result;

	result = 0;

	if (USTeamSize == 1)
	{
		result = Solo;
	}
	else if (USTeamSize == 2)
	{
		result = Coop;
	}

	return result;
}

defaultproperties
{
	Solo = 1
	Coop = 1
}// ====================================================
// gbxStaticView
// ====================================================

class gbxStaticView extends Interaction;



//#exec OBJ LOAD FILE=..\Sounds\weaponsounds.uax

var float CrossHairX, CrossHairY, CenterX, CenterY;
var bool ResetCrossHair;
var WargamePlayerController Controller;
var vector AimTarget;
var pawn PointingAt;


function Activate()
{
	bActive = true;
	bVisible = true;
	AimTarget = vect(0,0,0);
	PointingAt = none;
	ResetCrossHair = true;

}

function DeActivate()
{
	bActive = false;
	bVisible = false;
	controller.Pawn.AmbientSound = none;
}

function bool KeyEvent( EInputKey Key, EInputAction Action, FLOAT Delta )
{
	local byte k;
	local float OldCrossHair;
	k = Key;

	switch (Action)
	{
		case IST_Axis:
			switch (Key)
			{
				case IK_MouseX:
					OldCrossHair = CrossHairX;
					CrossHairX = CrossHairX + (1 * Delta);
					CalcAimSpot();
					return true;
					break;

				case IK_MouseY:
					CrossHairY = CrossHairY - (1 * Delta);
					CalcAimSpot();
					return true;
					break;
			}
		default:
			break;
	}
	return false;
}

function PostRender( canvas Canvas )
{
	local float perc;

	// Reset the CrossHair if needed

	if (ResetCrossHair)
	{
		ResetCrossHair = false;
		CrossHairX = Canvas.ClipX /2;
		CrossHairY = Canvas.ClipY /2;
	}
	else // Bounds Check the Crosshair
	{
		if (CrossHairX<0)
			CrossHairX=0;
		else if (CrossHairX>Canvas.ClipX)
			CrossHairX=Canvas.ClipX;

		if (CrossHairY<0)
			CrossHairY=0;
		else if (CrossHairY>Canvas.ClipY)
			CrossHairY=Canvas.ClipY;
	}

	CenterX = Canvas.ClipX / 2;
	CenterY = Canvas.ClipY / 2;

	CalcAimSpot();



	Canvas.bNoSmooth = False;
	Canvas.SetPos(CrossHairX-32, CrossHairY-32);
	Canvas.Style = 3;
	Canvas.SetDrawColor(255,255,255);

// GBX:PAD: Get rid o
/*
	if (PointingAt==None)
	{
		Canvas.DrawTile(texture 'LockCHair', 64,64,0,0,84,84); //84,84);
		controller.Pawn.AmbientSound = none;
	}
	else
	{
		Canvas.DrawTile(texture 'LockCHair2',64,64,0,0,84,84); //84,84);
//		Controller.Pawn.AmbientSound = sound 'WeaponSounds.HeavyLock';
	}
*/

	Canvas.bNoSmooth = True;
	Canvas.Style = 1;

    // Calc the view adjustment

	if ( int(CrossHairX) != int(Canvas.ClipX/2) )
	{
		Perc = CrossHairX / Canvas.ClipX;
		Controller.ViewChange.Yaw = (4096 * Perc) - 2048;
	}
	else
	  Controller.Viewchange.Yaw = 0;

	if ( int(CrossHairY) != int(Canvas.ClipY/2) )
	{
		Perc = 1-(CrossHairY / Canvas.ClipY);
		Controller.ViewChange.Pitch = (4096 * Perc) - 2048;
	}
	else
		Controller.ViewChange.Pitch = 0;

}

function CalcAimSpot()
{
	local vector StartTrace, X,Y,Z, Project, Direction;
	local actor Other;

	if ( (Controller==None) || (Controller.Pawn==None) || (Controller.Pawn.Weapon==None) )
		return;

	GetAxes(Controller.Pawn.GetViewRotation(),X,Y,Z);
	StartTrace = Controller.Pawn.Weapon.GetFireStart(X,Y,Z);

	Project.X = CrossHairX;
	Project.Y = CrossHairY;

	Direction  = ScreenToWorld(Project);
	AimTarget = StartTrace + Controller.Pawn.Weapon.TraceDist * Normal(Direction);

	Other = Controller.Pawn.Trace(x,y,AimTarget,StartTrace,True);
	PointingAt = pawn(Other);

	if (Other!=None && ( (Other.IsInState('Dying') || Other.bHidden || Other.bDeleteMe)) )
		PointingAt = None;

}

defaultproperties
{
	bActive=false
	bVisible=false
	bRequiresTick=false
}
class gbxStatsManager extends Info;


//#if XLIVE_STATS_WEEKLY
//const TOTAL_LEADERBOARDS_PER_GAMETYPE = 3;
//const TOTAL_LEADERBOARDS = 6; //TOTAL_LEADERBOARDS_PER_GAMETYPE * 2;
//#else
const TOTAL_LEADERBOARDS_PER_GAMETYPE = 2;
const TOTAL_LEADERBOARDS = 4; //TOTAL_LEADERBOARDS_PER_GAMETYPE * 2;
//#endif

struct StatsState
{
	var int TotalGames;
	var int TotalWins;
	var int ELORating;
	var int XBLRating;
	var bool SPCompleted;
	var bool BogusData; // This is an emergency catch that any stats-related function is allowed to set to true in the event something
						// goes terribly wrong during the calculations. This will prevent uploads from occuring, will assert-fail in 
						// debug builds and will dump messages to the log explaining the problem
};

struct GPlayer
{
	var PlayerReplicationInfo PRI; //for matchup during the initialization loop
	var string xuid;

	// -1 for non-local players, 0 for main player, 1 if the split-screen "extra" player
	// Can be used (as long as it isn't -1) to index into the Game array for storing stats
	var int SplitIndex;

	//these are updated after the initial pass, based on data from the server
	var StatsState State[TOTAL_LEADERBOARDS];
};


/* Basic Overview

After the user clicks to join, spawn this actor.
SetInitialState gets information about players, and sends everything to state AwaitingQuery.
AwaitingQuery waits for stats information, and then calls GameBegin
GameBegin figures out Win/Loss stats, and writes out Loss states at the beginning of the game.

At end of game, this actor calls GameEnd, which optionally writes out precalculated Win stats
*/

var array<GPlayer> GPlayers;

struct LocalPlayerData
{
	var PlayerController PC;
	var StatsState WinStats[TOTAL_LEADERBOARDS], LossStats[TOTAL_LEADERBOARDS];
};

const LOCAL_PLAYERS = 2; // Should only have at max 2 local players with splitscreen
var LocalPlayerData LocalPlayers[LOCAL_PLAYERS];


var bool bGameEnded;

var bool bShouldWriteStats; // did we accumulate any stats that we need to write out?

var int LocalPlayerCount; // total number of local players playing


static function StatLog(coerce string Str)
{
// Uncomment to get debugging statistics for stats retrieval and uploading. Very useful when debugging.
//	Log(Str,'Stats');
}

function SetInitialState()
{
	Super.SetInitialState();
	StatLog("PostBeginPlay");
	// Figure out who is playing today and setup the GPlayers array
	BuildGPlayersArray();
	// Query for these players' statistics
	QueryGPlayerStats();
}

function BuildGPlayersArray()
{
	local PlayerReplicationInfo PRI;
	local PlayerController PC;
	local GPlayer GPlayer;
	local int i;
	
	StatLog("  BuildGPlayersArray - PlayerReplicationInfos");
	
	LocalPlayerCount = 0;
	// foreach player in the game
	foreach DynamicActors(class'PlayerReplicationInfo',PRI)
	{
		StatLog("    PRI is "$PRI);
		// Setup the relevant info if they aren't a guest player
		if( !PRI.bIsGuest )
		{
			GPlayer.PRI = PRI;
			GPlayer.xuid = PRI.xuid;
			GPlayer.SplitIndex = -1;
			StatLog("      Non-Guest, xuid is "$PRI.xuid$", Team "$GPlayer.PRI.Team);
			GPlayers[GPlayers.Length] = GPlayer;
		}
	}
	
	StatLog("  BuildGPlayersArray - Local PlayerControllers");
	// foreach local player in the game
	for( PC = Level.PlayerControllerList; PC != None; PC = PC.nextPlayerController )
	{
		StatLog("    PC is "$PC$", Player is "$PC.Player);
		// if they are a local player
		if( Viewport(PC.Player) != None )
		{
			PRI = PC.PlayerReplicationInfo;
			StatLog("      PRI is "$PRI);
			assert( PRI != None );
	
			if( !PRI.bIsGuest )
			{
				for( i=0; i<GPlayers.Length; i++ )
				{
					if( GPlayers[i].PRI == PRI )
					{
						GPlayers[i].SplitIndex = PC.Player.SplitIndex;
						StatLog("      Player "$i$" Non-Guest, xuid is "$PRI.xuid$", SplitIndex is "$GPlayers[i].SplitIndex);
					}
				}
				LocalPlayerCount++;
				LocalPlayers[PC.Player.SplitIndex].PC = PC;
			}
		}
	}

	StatLog("    LocalPlayerCount is "$LocalPlayerCount);
}

function int GetMapLeaderboardID()
{
	local int MapIndex, MapNumber;
	// Find the map leaderboard number for this game
	MapIndex = class'gbxMPMissionList'.static.FindMapIndex(Level.GetLevelFileName());
	MapNumber = class'gbxMPMissionList'.static.GetMissionID(MapIndex);
	
	return MapNumber;
}

function QueryGPlayerStats()
{
	local int i;
	local string List;
	local int MapLeaderboardID;

	StatLog("  QueryGPlayerStats");

	MapLeaderboardID = GetMapLeaderboardID();
	
	// Foreach player we're playing against, add them to the string
	for(i=0;i<GPlayers.Length;i++)
	{
		List = List @ GPlayers[i].xuid;
	}
	StatLog("    List of xuids is "$List);

	// Tell the native code to query for these players
	StatLog("CC: "$"XLIVE STAT_PLAYER_QUERY"@MapLeaderboardID@List);
	Level.ConsoleCommand("XLIVE STAT_PLAYER_QUERY"@MapLeaderboardID@List);
	StatLog("    Called console command, going to AwaitingQuery");
	GotoState('AwaitingQuery');
}


function GameEnd()
{
	// Can't process the winner here, because GRI.Winner hasn't been set yet.
	// Normally we just need to wait a tick to let GRI.Winner get set correctly
	// (ClientGameEnded->GameEnd is called before CheckEndGame sets GRI.Winner)
	// But in the case of multiplayer where things get replicated, wait some time
	// before processing. 0.5 seconds should be enough to allow GRI.Winner 
	// to be replicated from the server.. Since this is called from ClientGameEnded,
	// which also needs to be replicated, theoretically they'd arrive the same tick.
	// The 0.5 seconds is a just-in-case to allow for packet variability and such.
	// Welcome to the world of fudge factors in MP :)
	
	StatLog("GameEnd(), setting bGameEnded, currently "$bGameEnded$", to true");
	bGameEnded = true;
	SetTimer(0.5, false);
}

function Timer()
{
	if( bGameEnded )
	{
		RealGameEnded();
		bGameEnded = false;
	}
}

// This function is called at the game end, and figures out who won.
// Then it uploads the winning stats if they are needed.
function RealGameEnded()
{
	local PlayerController PC;
	local int Iterations;
	
	StatLog("RealGameEnded()");

	foreach dynamicActors(class'PlayerController',PC)
	{
		if( Viewport(PC.Player) != None && !PC.PlayerReplicationInfo.bIsGuest)
		{
			MaybeWriteWinStats(PC);
			Iterations++;
		}
	}
	assert( Iterations == LocalPlayerCount );
	WriteStats();
}

function MaybeWriteWinStats( PlayerController PC )
{
	local int TeamID;
	local TeamInfo TeamWinner;
	local PlayerReplicationInfo priWinner;

	assert( PC.PlayerReplicationInfo.Team != None );

	// Grab the players team
	TeamID = PC.PlayerReplicationInfo.Team.TeamIndex;
	StatLog("  Player's Team is "$TeamID);
		
	// Get the winning team
	TeamWinner = TeamInfo(PC.GameReplicationInfo.Winner);
	priWinner = PlayerReplicationInfo(PC.GameReplicationInfo.Winner);
	StatLog("  GRI.Winner is "$PC.GameReplicationInfo.Winner$", TeamWinner is "$TeamWinner$", priWinner is "$priWinner);
	if( priWinner != None )
		TeamWinner = priWinner.Team;
	StatLog("  Winning Team is "$TeamWinner);
	if( TeamWinner != None )
	{
		if( TeamWinner.TeamIndex == TeamID )
		{
			StatLog("  Player Won");
			// write out the winning values
			PreWriteStats(PC,true);
		}
		else
		{
			StatLog("  Player Lost: not writing stats");
		}
	}
	else
	{
		Log("Stats: Winner wasn't set, so stats were not uploaded, and both players lose.");
		Log("Stats: This should only happen with End Mission.");
	}
}

function GameBegin()
{
	local int i, j;
	StatLog("GameBegin");
	
	// when the game begins, for each leaderboard
	for(i=0;i<TOTAL_LEADERBOARDS;i++)
	{
		StatLog("  Leaderboard "$i);
		// load up their stats
		GetResults(i);
	}

	for( j=0; j<LocalPlayerCount; j++ )
	{
		assert( Viewport( LocalPlayers[j].PC.Player ) != None );
		StatLog("  Calculating Stats for Player "$j$" of "$LocalPlayerCount$": "$LocalPlayers[j].PC);
		CalcAllStats(LocalPlayers[j].PC);
	}
	WriteStats();
}

function CalcAllStats( PlayerController PC )
{
	local int i;
	
	for(i=0;i<TOTAL_LEADERBOARDS;i++)
	{
		StatLog("    Calculating Stats for Leaderboard "$i$" of "$TOTAL_LEADERBOARDS);
		// calculate the win/loss resulting values
		CalculateNewValues(i,PC);
	}

	// write out "losing" values for the pregame
	PreWriteStats(PC,false);
}

function GetResults(int Leaderboard)
{
	local string Results;
	local int i;
	
	StatLog("    GetResults:");
	StatLog("CC: "$"XLIVE STAT_PLAYER_RESULTS"@Leaderboard);
	Results = Level.GetLocalPlayerController().ConsoleCommand("XLIVE STAT_PLAYER_RESULTS"@Leaderboard);
	StatLog(Results);
	
	i = 0;
	while( Len(Results)>1 )
	{
		assert(GPlayers[i].xuid == ParseToken(Results));
		GPlayers[i].State[Leaderboard].TotalGames = int(ParseToken(Results));
		GPlayers[i].State[Leaderboard].TotalWins = int(ParseToken(Results));
		GPlayers[i].State[Leaderboard].ELORating = int(ParseToken(Results));
		if( GPlayers[i].State[Leaderboard].ELORating < 500 )
			GPlayers[i].State[Leaderboard].ELORating = 1000;
		GPlayers[i].State[Leaderboard].XBLRating = int(ParseToken(Results));
		GPlayers[i].State[Leaderboard].SPCompleted = bool(ParseToken(Results));
		ParseToken(Results); // rating, unneeded here

		StatLog("      Added player "$i$" with xuid "$GPlayers[i].xuid);
		StatLog("        TotalGames is "$GPlayers[i].State[Leaderboard].TotalGames);
		StatLog("        TotalWins is "$GPlayers[i].State[Leaderboard].TotalWins);
		StatLog("        ELORating is "$GPlayers[i].State[Leaderboard].ELORating);
		StatLog("        XBLRating is "$GPlayers[i].State[Leaderboard].XBLRating);
		StatLog("        SPCompleted is "$GPlayers[i].State[Leaderboard].SPCompleted);
		i++;
	}
}

// Copied from GUIComponent.uc. Needed for consolecommand parsing.
static simulated function String ParseToken(out String Str)
{
    local String Ret;
    local int len;

    Ret = "";
    len = 0;

	// Skip spaces and tabs.
	while( Left(Str,1)==" " || Asc(Left(Str,1))==9 )
		Str = Mid(Str, 1);

	if( Asc(Left(Str,1)) == 34 )
	{
		// Get quoted String.
		Str = Mid(Str, 1);
		while( Str!="" && Asc(Left(Str,1))!=34 )
		{
			Ret = Ret $ Mid(Str,0,1);
            Str = Mid(Str, 1);
		}
		if( Asc(Left(Str,1))==34 )
			Str = Mid(Str, 1);
	}
	else
	{
		// Get unquoted String.
		for( len=0; (Str!="" && Left(Str,1)!=" " && Asc(Left(Str,1))!=9); Str = Mid(Str, 1) )
            Ret = Ret $ Mid(Str,0,1);
	}

	return Ret;
}

function CalculateNewValues(int Leaderboard, PlayerController PC )
{
	local array<int> LocalTeamRatings;
	local array<int> EnemyTeamRatings;
	local int LocalPlayerIndex;
	local int LocalTeamPlayerIndex;
	local int i;
	local int ExperienceFactor;
	local bool bTeammate;
	
	StatLog("      CalculateNewValues");
	LocalPlayerIndex = -1;
	LocalTeamPlayerIndex = -1;
	for(i=0;i<GPlayers.Length;i++)
	{
		bTeammate = ( GPlayers[i].PRI.Team == PC.PlayerReplicationInfo.Team );
		StatLog("        Player "$i$", elo rating? "$GPlayers[i].State[Leaderboard].ELORating$", Teammate? "$bTeammate);
		StatLog("        Player "$i$", team: "$GPlayers[i].PRI.Team$" PC.PRI.Team: "$ PC.PlayerReplicationInfo.Team);
		if( bTeammate )
			LocalTeamRatings[LocalTeamRatings.Length] = GPlayers[i].State[Leaderboard].ELORating;
		else
			EnemyTeamRatings[EnemyTeamRatings.Length] = GPlayers[i].State[Leaderboard].ELORating;
			
		StatLog("        GPlayers[i].SplitIndex:"@GPlayers[i].SplitIndex@"PC.Player.SplitIndex:"@PC.Player.SplitIndex);
			
		if( GPlayers[i].SplitIndex == PC.Player.SplitIndex )
		{
			LocalPlayerIndex = i;
			LocalTeamPlayerIndex = LocalTeamRatings.Length-1;
		}
	}
	assert(LocalPlayerIndex >= 0);
	assert(LocalTeamPlayerIndex >= 0);

	StatLog("        LocalPlayer is "$LocalPlayerIndex$", LocalTeamPlayer is "$LocalTeamPlayerIndex);
	
	//TODO: Choose these factors appropriately
	switch( Leaderboard % TOTAL_LEADERBOARDS_PER_GAMETYPE )
	{
	case 0: //total
		ExperienceFactor = 50;
		break;
	case 1: //monthly
		ExperienceFactor = 10;
		break;
	case 2: //weekly
		ExperienceFactor = 100;
		break;
	default:
		warn("Didn't set ExperienceFactor, Leaderboard = "$Leaderboard$", Mod is "$TOTAL_LEADERBOARDS_PER_GAMETYPE$", Result is "$(Leaderboard % TOTAL_LEADERBOARDS_PER_GAMETYPE));
		break;
	}
	assert(ExperienceFactor > 0);
	StatLog("        ExperienceFactor is "$ExperienceFactor);

	//TODO: SETUP SPCOMPLETED??
	
	//LOSS SCENARIO
	StatLog("        Loss Scenario...");

	GPlayers[LocalPlayerIndex].State[Leaderboard].TotalGames++;

	// Copy the sent game state over, and update necessary values
	LocalPlayers[PC.Player.SplitIndex].LossStats[Leaderboard] = GPlayers[LocalPlayerIndex].State[Leaderboard];
	
	// Update Rating and ELORating
	CalculateNewRating(LocalTeamRatings,LocalTeamPlayerIndex,EnemyTeamRatings, 
			false, GPlayers[LocalPlayerIndex].State[Leaderboard].TotalGames, ExperienceFactor,
			LocalPlayers[PC.Player.SplitIndex].LossStats[Leaderboard].XBLRating,
			LocalPlayers[PC.Player.SplitIndex].LossStats[Leaderboard].ELORating);

	//WIN SCENARIO
	StatLog("        Win Scenario...");
	// Copy the sent game state over, and update necessary values
	LocalPlayers[PC.Player.SplitIndex].WinStats[Leaderboard] = GPlayers[LocalPlayerIndex].State[Leaderboard];
	LocalPlayers[PC.Player.SplitIndex].WinStats[Leaderboard].TotalWins++;
	
	// Update Rating and ELORating
	CalculateNewRating(LocalTeamRatings,LocalTeamPlayerIndex,EnemyTeamRatings, 
			true, GPlayers[LocalPlayerIndex].State[Leaderboard].TotalGames, ExperienceFactor, 
			LocalPlayers[PC.Player.SplitIndex].WinStats[Leaderboard].XBLRating, 
			LocalPlayers[PC.Player.SplitIndex].WinStats[Leaderboard].ELORating);
			
	// Sanity checking
	if(LocalTeamPlayerIndex < 0 ||
		LocalPlayerIndex < 0)
	{
		LocalPlayers[PC.Player.SplitIndex].WinStats[Leaderboard].BogusData = true;
		LocalPlayers[PC.Player.SplitIndex].LossStats[Leaderboard].BogusData = true;
	}
}


function PreWriteStats( PlayerController PC, bool bWinStats )
{
	local StatsState WriteState;
	local int i;
	local int PlayerIndex;
	local string xuid;
	
	StatLog("  PreWriteStats, Win? "$bWinStats);

	xuid = PC.PlayerReplicationInfo.xuid;
	for(i=0; i<TOTAL_LEADERBOARDS; i++)
	{
		// figure out which state we want to write to the leaderboard
		if( bWinStats )
			WriteState = LocalPlayers[PC.Player.SplitIndex].WinStats[i];
		else
			WriteState = LocalPlayers[PC.Player.SplitIndex].LossStats[i];
		
		// Do some sanity checking before uploading stats. Assert-fail in debug builds.	
		if(	WriteState.TotalWins >= 0 &&
			WriteState.TotalGames >= WriteState.TotalWins &&
			WriteState.ELORating > 0 &&
			WriteState.XBLRating > 0 &&
			!WriteState.BogusData)
		{
			// prepare to write the state
			StatLog("XLIVE STAT_DATA_LOAD"@i@xuid@WriteState.TotalGames@WriteState.TotalWins@WriteState.ELORating@WriteState.XBLRating@WriteState.SPCompleted);
			Level.ConsoleCommand("XLIVE STAT_DATA_LOAD"@i@xuid@WriteState.TotalGames@WriteState.TotalWins@WriteState.ELORating@WriteState.XBLRating@WriteState.SPCompleted);
		}
		else
		{
			log("BOGUS STATS, NOT UPLOADING -- CATASTROPHIC FAILURE!!!");
			Log("NOT DOING XLIVE STAT_DATA_LOAD"@i@xuid@WriteState.TotalGames@WriteState.TotalWins@WriteState.ELORating@WriteState.XBLRating@WriteState.SPCompleted);
			log("Bogus Data = "$WriteState.BogusData);
			for(PlayerIndex = 0; PlayerIndex < GPlayers.Length; PlayerIndex++)
			{
				log("GPlayer "@PlayerIndex@GPlayers[PlayerIndex].PRI@GPlayers[PlayerIndex].xuid@GPlayers[PlayerIndex].SplitIndex@GPlayers[PlayerIndex].PRI.Team);
			}
			assert(false);
		}
	}

	bShouldWriteStats = true;
}

function WriteStats()
{
	local int MapLeaderboardID;

	if( bShouldWriteStats )
	{
		// now actually write all those states we loaded
		MapLeaderboardID = GetMapLeaderboardID();
		StatLog("CC: "$"XLIVE STAT_DATA_WRITE"@MapLeaderboardID);
		Level.ConsoleCommand("XLIVE STAT_DATA_WRITE"@MapLeaderboardID);

		bShouldWriteStats = false;
	}
}


function StatsError()
{
	warn("Error reading GPlayer stats!");
}

// While we wait for data to come back from the server
state AwaitingQuery
{
	// Use the timer while in this state
	simulated function BeginState()
	{
		StatLog("AwaitingQuery.BeginState");
		SetTimer( 0.1, true );
	}
	
	simulated function EndState()
	{
		StatLog("AwaitingQuery.EndState");
		SetTimer( 0, false );
	}

	simulated function Timer()
	{
		local String s;
		StatLog("AwaitingQuery Timer");

		s = ConsoleCommand("XLIVE STAT_GET_STATE");
		StatLog("  State is "$s);
		// ...while we're still reading stats
		if( s == "READING_STATS" )
			return;
		else if ( s == "DONE" )
		{
			// Exit the state, and kickstart the begin game stats stuff
			StatLog("  Leaving State");
			GotoState('');
			GameBegin();
		}
		else if ( s == "ERROR" || s == "BAD_STATE" )
		{
			StatsError();
		}
	}
}

//
// Calculates the new rating for the local player
// Won't work for guests, don't use it for them. 
//
// LocalPlayerTeamEloRatings - the Elo (Not total!) ratings for the local player's team. DO NOT INCLUDE GUESTS.
// LocalPlayerIndex - an index into LocalPlayerTeamRatings that indicates which player who's new rating you would like
//	to calculate
// OpposingTeamEloRatings - the Elo (Not total!) ratings for the opposing team memebers. DO NOT INCLUDE GUESTS.
// LocalPlayerWon - True if the local player won, false if they lost (or if you would just like to know what would 
//	happen IF they lost)
// ExperienceFactor - a factor used in calcuating how much each game should be worth. Should always be positive
// outNewRating - The final total rating for the local player (Elo + Experience)
// outNewEloRating - The final Elo rating for the local player
// 
function CalculateNewRating(array<int> LocalPlayerTeamEloRatings, int LocalPlayerIndex, 
			  array<int> OpposingTeamEloRatings, bool LocalPlayerWon,
			  int LocalPlayerGamesPlayed, int ExperienceFactor, 
			  out int outNewRating, out int outNewEloRating)
{
	local int LocalPlayerStartingRating, LocalPlayerNewExperience;
	local int i, Inc;
	local float LocalTeamAverageRating, OpposingTeamAverageRating;
	local float EloWeightingFactor, ExpectedRating, Score;
	StatLog("        CalculateNewRating");
	
	LocalPlayerStartingRating = LocalPlayerTeamEloRatings[LocalPlayerIndex];
	
	// Calculate the local player's experience
	LocalPlayerNewExperience = 0;

	// We looked up how to do this in a non-iterative way -- it's frighteningly complex. This works better since we're
	// only dealing with ints.
	// Experience = Sum from 1 to LocalPlayerGamesPlayed of ExperienceFactor/i
	assert(ExperienceFactor > 0);
	for(i = 1; i <= LocalPlayerGamesPlayed; i++)
	{
		// Constantly decreasing function
		Inc = ExperienceFactor/i;
		StatLog("          ExperienceFactor is "$ExperienceFactor$", i is "$i$", Inc is "$Inc);
		if(Inc == 0)
		{
			break;
		}
		LocalPlayerNewExperience += Inc;
		StatLog("          New LocalPlayerNewExperience is "$LocalPlayerNewExperience);
	}
	
	// Perform the Elo calculation
	
	// If the opposing team is composed entirely of guests, no change except for experience
	if(OpposingTeamEloRatings.Length == 0)
	{
		outNewEloRating = LocalPlayerTeamEloRatings[LocalPlayerIndex];
	}
	// Oposing team has some non-guests
	else
	{
		// Calculate team averages
		LocalTeamAverageRating = 0;
		OpposingTeamAverageRating = 0;

		for(i = 0; i < LocalPlayerTeamEloRatings.Length; i++)
		{
			LocalTeamAverageRating += LocalPlayerTeamEloRatings[i];
		}
		LocalTeamAverageRating /= LocalPlayerTeamEloRatings.Length;

		for(i = 0; i < OpposingTeamEloRatings.Length; i++)
		{
			OpposingTeamAverageRating += OpposingTeamEloRatings[i];
		}
		OpposingTeamAverageRating /= OpposingTeamEloRatings.Length;

		// Calculate the weighting factor used by Elo
		EloWeightingFactor = 0;
		if(LocalPlayerStartingRating < 3000)
			EloWeightingFactor = 60.0 - LocalPlayerStartingRating/50.0;
		EloWeightingFactor += 10.0;

		// ExpectedRating = 1 / (1 + 10^((Ra - Rb)/400))
		ExpectedRating = 1.0 / (1.0 + 10 ** ((OpposingTeamAverageRating - LocalTeamAverageRating)/400.0));

		// Calculate score which varies from 0.0 - 1.0
		// For BiA we're suing a simple system. Win, you get 1.0, lose you get 0.0. 
		// This could be changed to reflect how much you helped your team, or whatever.
		if(LocalPlayerWon)
			Score = 1.0;
		else
			Score = 0.0;

		// Final rating calculation. K * (S - Se)
		outNewEloRating = LocalPlayerStartingRating + int(EloWeightingFactor * (Score - ExpectedRating));
	}

	outNewRating = outNewEloRating + LocalPlayerNewExperience;
	StatLog("          InELORating "$LocalPlayerStartingRating$", OutELORating "$outNewEloRating$", OutRating "$outNewRating);
}

defaultproperties
{
     RemoteRole=ROLE_SimulatedProxy
     bStatic=False
     bNoDelete=False
}// usage: place this in a map to allow skirmish players to be defeated when a player, all players or any AI are killed
class gbxSurvivalVictoryCondition extends gbxSecondaryVictoryCondition
	placeable;

// properties
var() bool FailureOnAICasualty;				// If true, victory condition will trigger on any ally AI casualty
var() bool FailureOnPlayerCasualty;			// If true, victory condition will trigger when any player dies
var() bool FailureOnAllPlayersDead;			// If true, victory condition will trigger when all players are dead

// internal state
var ETeamIdentifier PlayerTeam;				// The team the player is on
var bool bAICasualty;						// If true, then a friendly AI has been killed
var bool bPlayerCasualty;					// If true, then a player has been killed

function PostNetBeginPlay()
{
	local gbxFireTeamSpawnControllerSkirmish spawner;
	//Log( " gbxSurvivalVictoryCondition::PostNetBeginPlay()", 'MP' );

	Super.PostNetBeginPlay();

	// Find out what team the players are on and stash for use later
	foreach DynamicActors( class'gbxFireTeamSpawnControllerSkirmish', spawner )
	
	if ( spawner != None )
	{
		PlayerTeam = spawner.PlayerTeam;
	}

	//Log( " gbxSurvivalVictoryCondition::PostNetBeginPlay() PlayerTeam set to: "$PlayerTeam, 'MP' );

	// Register for killed notify with game info
	if ( Level.Game.IsA('WargameSkirmish') )
	{
		//Log( " gbxSurvivalVictoryCondition::PostNetBeginPlay() Registering self with WargameSkirmish for killed notify.", 'MP' );
		WargameSkirmish(Level.Game).RegisterForKilledNotify( self );
	}
}

// In case we ever support this...
/*function Reset()
{
	bAICasualty = false;
	bPlayerCasualty = false;

	// If PostNetBeginPlay() doesn't get called again, we need to get player's team again
}*/

// Returning false since we never want this VC to be paused
function bool Pause(gbxPrimaryVictoryCondition pauser)
{
	Log( " gbxSurvivalVictoryCondition::Pause() Returning false since we never want this VC to be paused!", 'MP' );
	
	return false;
}

function NotifyAICasualty( Pawn AIPawn, Pawn Killer )
{
	//Log( " gbxSurvivalVictoryCondition::NotifyAICasualty() AIPawn: "$AIPawn, 'MP' );

	if ( AIPawn.PawnTeam == PlayerTeam )
	{
		bAICasualty = true;
	}
}

function NotifyPlayerCasualty( Pawn PlayerPawn )
{
	//Log( " gbxSurvivalVictoryCondition::NotifyPlayerCasualty() PlayerPawn: "$PlayerPawn, 'MP' );

	if ( PlayerPawn.PawnTeam == PlayerTeam )
	{
		bPlayerCasualty = true;
	}
}

function bool HasATeamWon(out ETeamIdentifier WinningTeam, out int reason)
{
	local PlayerController PC;
	local bool hasSomeoneWon;
	//Log( " gbxSurvivalVictoryCondition::HasATeamWon()", 'MP' );

	if ( bAICasualty && FailureOnAICasualty )
	{
		hasSomeoneWon = true;
	}
	else if ( bPlayerCasualty )
	{
		if (FailureOnPlayerCasualty)
		{
			hasSomeoneWon = true;
		}
		else if (Level.Game.IsA('WargameSkirmish') && (WargameSkirmish(Level.Game).GameType == SGT_TourOfDuty))
		{
			hasSomeoneWon = true;
		}
	}
	
	if ( !hasSomeoneWon && FailureOnAllPlayersDead )
	{
		for ( PC=Level.PlayerControllerList; PC!=None; PC=PC.nextPlayerController )
		{
			//Log( " gbxSurvivalVictoryCondition::HasATeamWon() gbxPlayerController(PC).IsDead(): "$gbxPlayerController(PC).IsDead(), 'MP' );

			if ( PC.PlayerReplicationInfo.bBot )
				continue;
				
			if ( PC.IsDead() || PC.IsSpectating() )
			{
				hasSomeoneWon = true;		
			}
			else
			{
				hasSomeoneWon = false;
				break;
			}
		}
	}

	//Log( " gbxSurvivalVictoryCondition::HasATeamWon() hasSomeoneWon: "$hasSomeoneWon, 'MP' );

	if ( hasSomeoneWon )
	{
		reason = GetVictoryReason();

		if ( PlayerTeam == TEAM_US )
			WinningTeam = TEAM_German;
		else if ( PlayerTeam == TEAM_German )
			WinningTeam = TEAM_US;

		//Log( " gbxSurvivalVictoryCondition::HasATeamWon() WinningTeam: "$WinningTeam$ " reason: "$reason, 'MP' );
	}

	return hasSomeoneWon;
}

defaultproperties
{
	FailureOnAICasualty = false
	FailureOnPlayerCasualty = false
	FailureOnAllPlayersDead = true

	VictoryReason=500;
	MessageSectionName="SurvivalVictoryCondition"

	bDelayedVictory = false
}class gbxTeamAllies extends TeamInfo;



defaultproperties
{
	TeamName="Americans"
	TeamIndex=0
	TeamColor=(R=102,G=90,B=64,A=255)
	AltTeamColor=(R=200,G=0,B=0,A=255)
	ColorNames(0)="Red"
	ColorNames(1)="Blue"
	ColorNames(2)="Green"
	ColorNames(3)="Gold"
}
class gbxTeamAxis extends TeamInfo;



defaultproperties
{
	TeamName="Germans"
	TeamIndex=1
	TeamColor=(R=61,G=63,B=56,A=255)
	AltTeamColor=(R=200,G=0,B=0,A=255)
	ColorNames(0)="Red"
	ColorNames(1)="Blue"
	ColorNames(2)="Green"
	ColorNames(3)="Gold"
}
// GEARBOX 2004-03-17 JWS created
//
// this is the base of all victory conditions in the map

class gbxVictoryCondition extends gbxBaseVictoryCondition
	abstract placeable
	native;

const VICTORY_DELAY = 5.0f;

// properties

var() ETeamIdentifier WinsWhenTimerExpires; // which team wins automatically at the end of the mission timer if no other victory condition is satisfied.
											// this defines the burden of victory; the team NOT specified has the burden of victory

var() bool bDelayedVictory;					// If true, the game will end a short time after victory is achieved

var() bool bVictoryDisabled;				// If true, then the game will not end until this has been set back to false;

// internal variables
var bool gameEnded;
var bool IsGameOn;
var string VictoryMessageTags[3];	// victory Message tags for TEAM_None, TEAM_US, and TEAM_German. These tags correspond to entries in an int file
var string MessageSectionName;				// the name of the section in the int file which contains the messages for this VC

var const int VictoryReason; // derived classes should define a value for this, but should never reference it directly. Instead use GetVictoryReason()

// Delayed Victory Support
var float TimeToEndTheGame; // when Level.TimeSeconds >= this time, the victory condition will end the game
var ETeamIdentifier DelayedVictoryWinningTeam;
var int DelayedVictoryReason;

// returns which team is currently ahead, used to determine a winner when the mission timer expires
function ETeamIdentifier WhoIsAhead();

function bool DoesTeamHaveReinforcementsLeft(ETeamIdentifier team)
{
	local bool rslt;
	local PlayerController PC;
	
	rslt = false;

	for ( PC = Level.PlayerControllerList; PC != None; PC = PC.nextPlayerController )
	{
		if (PC.PlayerReplicationInfo.Team != None &&
			PC.PlayerReplicationInfo.Team.TeamIndex == team &&
			PC.PlayerReplicationInfo.NumLives > 0)
		{
			rslt = true;
			break;
		}
	}
	
	return rslt;
}

// returns true if a team has won, and if so, sets WinningTeam to be that winner. This function is called every tick by the GameInfo to see
// if the victory condition was won in this tick. Note that the mission timer compeletion victor is not determined here.
// base class version does nothing.
function bool HasATeamWon(out ETeamIdentifier WinningTeam, out int reason)
{
	return false;
}

function bool CheckForVictory(out ETeamIdentifier WinningTeam, out int reason)
{
	local bool result;
	local WargameMultiplayer mpgi;
	local gbxVictoryCondition vc;

	//Log( " gbxVictoryCondition::CheckForVictory()", 'MP' );

	if ( !bVictoryDisabled )		// Victory can be temporarily disabled
	{
	if (TimeToEndTheGame == 0.0f)
	{
		result = HasATeamWon(WinningTeam, reason);

		if (result)
		{
			//08/11/2005 LAS:If there is a winning team, we should stop any gbxTimerVictoryConditions so that they don't 
			//Accidentally trigger a different winning team... See BUG 19295.
			foreach DynamicActors( class'gbxVictoryCondition', vc )
			{
				if(vc.IsA('gbxTimerVictoryCondition'))
				{
					vc.GotoState('TimerDisabled');
				}
			}
			
			if (bDelayedVictory)
			{
					//Log( " gbxVictoryCondition::CheckForVictory() bDelayedVictory is TRUE!", 'MP' );
					
				TimeToEndTheGame = Level.TimeSeconds + VICTORY_DELAY;

				result = false;
				DelayedVictoryWinningTeam = WinningTeam;
				DelayedVictoryReason = reason;

				mpgi = WargameMultiplayer(Level.Game);
				mpgi.bGameEndingTime = true;
			}
			else
			{
				TimeToEndTheGame = Level.TimeSeconds;
			}
		}
	}
	else
	{
		if (Level.TimeSeconds >= TimeToEndTheGame)
		{
				//Log( " gbxVictoryCondition::CheckForVictory() Level.TimeSeconds >= TimeToEndTheGame", 'MP' );
			result = true;
			WinningTeam = DelayedVictoryWinningTeam;
			reason = DelayedVictoryReason;
		}
		else
		{
			result = false;
		}
	}
	}

	return result;
}

function Tick(float DeltaSeconds)
{
	local ETeamIdentifier WinningTeam;
	local int reason;
	//Log( self$ " gbxVictoryCondition::Tick() IsGameOn: "$IsGameOn, 'MP' );
	
	// see if a team definitively won the victory condition
	if (IsGameOn && !gameEnded && CheckForVictory(WinningTeam, reason))
	{
		EndGame(WinningTeam, reason);
	}

	Super.Tick(DeltaSeconds);
}

// make the game end, declaring the given team as the winner
function EndGame(ETeamIdentifier WinningTeam, int reason)
{
	local PlayerReplicationInfo pri;
	local int i;
	
	for (i = 0; i < Level.Game.GameReplicationInfo.PRIArray.Length; i++)
	{
		pri = Level.Game.GameReplicationInfo.PRIArray[i];

		if (pri.Team != None && pri.Team.TeamIndex == WinningTeam)
		{
			break;
		}
	}

	//Log(self $ "WargameMultiplayer::EndGame() Declaring " $ pri $ " to be the nominal winner for team " $ WinningTeam $ " reason = " $ reason, 'MP');

	Level.Game.GameReplicationInfo.WinningTeam = WinningTeam;
	Level.Game.EndGame(pri, string(reason));

	BroadcastLocalizedMessage(class'gbxMPVictoryMessage', PackVictoryReason(WinningTeam, reason));

	gameEnded = true;
}

function SetGameOn(bool gameOn)
{
	IsGameOn = gameOn;
}

simulated function String FormatTime( int Seconds )
{
    local int Minutes, Hours;
    local String Time;

    if( Seconds > 3600 )
    {
        Hours = Seconds / 3600;
        Seconds -= Hours * 3600;

        Time = Hours$":";
	}
	Minutes = Seconds / 60;
    Seconds -= Minutes * 60;

    if( Minutes >= 10 )
        Time = Time $ Minutes $ ":";
    else
        Time = Time $ "0" $ Minutes $ ":";

    if( Seconds >= 10 )
        Time = Time $ Seconds;
    else
        Time = Time $ "0" $ Seconds;

    return Time;
}

simulated function int GetVictoryReason()
{
	return VictoryReason;
}

function int PackVictoryReason(int winningTeamIndex, int reason)
{
	return reason + winningTeamIndex + 1;
}

// translates a victory reason into a localized victory message. returns true if the victory condition handled it, false if not.
simulated function bool UnpackVictoryReason(int reason, out int WinningTeamIndex, out string message)
{
	local bool result;
	local string key;
	local int OurVictoryReason;
	local int comparison;

	result = false;

	Log(self $ " UnpackVictoryReason() reason = " $ reason, 'JWS');

	OurVictoryReason = GetVictoryReason();
	WinningTeamIndex = ((reason % OurVictoryReason) - 1) % 100;
	comparison = reason - WinningTeamIndex - 1;

	if (comparison == OurVictoryReason)
	{
		key = VictoryMessageTags[Clamp(WinningTeamIndex, 0, 2)];
		message = Level.S_Localize(key, , MessageSectionName);
		
		result = true;

		Log(self $ " UnpackVictoryReason() WinningTeamIndex = " $ WinningTeamIndex $ " message = " $ message, 'JWS');
	}

	return result;
}

function EmitBattleDialogToTeamUnits(ETeamIdentifier Team, Name SpeechGroupName)
{
	local MultiplayerUnit Unit;

	if( IsGameOn && Level.Game.GameReplicationInfo.GameType != GT_SKIRMISH )
	{
		Log(self $ " EmitBattleDialogToTeamUnits(Team = " $ Team $ ", " $ SpeechGroupName $ ")", 'MPBattleDialogue');

		if (Team != TEAM_None)
		{
			foreach DynamicActors(class'MultiplayerUnit', Unit)
			{
				if (Team == Unit.Team)
				{
					Log(self $ " EmitBattleDialogToTeamUnits() speaking to Unit " $ Unit $ " Unit Team " $ Unit.Team, 'MPBattleDialogue');

					Unit.SpeakAbout(SpeechGroupName);
				}
			}
		}

		Log(self $ " EmitBattleDialogToTeamUnits() done", 'JWS');
	}
}

function EmitBattleDialogToUnits(Pawn EventInstigator, Name YouSpeechGroupName, Name AllySpeechGroupName, Name EnemySpeechGroupName)
{
	local MultiplayerUnit Unit;
	local PlayerReplicationInfo PRI;

	if( IsGameOn && Level.Game.GameReplicationInfo.GameType != GT_SKIRMISH )
	{
		PRI = EventInstigator.Controller.PlayerReplicationInfo;

		Log(self $ " EmitBattleDialogToUnits(" $ EventInstigator $ " PRI.Team = " $ PRI.Team.TeamIndex $ " PRI.TeamID = " $ PRI.TeamID $ ", " $ YouSpeechGroupName $ ", " $ AllySpeechGroupName $ ", " $ EnemySpeechGroupName $ ")", 'MPBattleDialogue');

		if (PRI.Team != None)
		{
			foreach DynamicActors(class'MultiplayerUnit', Unit)
			{
				if (PRI.Team.TeamIndex == Unit.Team)
				{
					if (PRI.TeamID == Unit.TeamMemberID)
					{
						if (YouSpeechGroupName != '')
						{
							Log(self $ " EmitBattleDialogToUnits() speaking You to Unit " $ Unit $ " Unit Team " $ Unit.Team $ " Unit TeamID " $ Unit.TeamMemberID, 'MPBattleDialogue');

							Unit.SpeakAbout(YouSpeechGroupName);
						}
					}
					else
					{
						if (AllySpeechGroupName != '')
						{
							Log(self $ " EmitBattleDialogToUnits() speaking Ally to Unit " $ Unit $ " Unit Team " $ Unit.Team $ " Unit TeamID " $ Unit.TeamMemberID, 'MPBattleDialogue');

							Unit.SpeakAbout(AllySpeechGroupName);
						}
					}
				}
				else
				{
					if (EnemySpeechGroupName != '')
					{
						Log(self $ " EmitBattleDialogToUnits() speaking Enemy to Unit " $ Unit $ " Unit Team " $ Unit.Team $ " Unit TeamID " $ Unit.TeamMemberID, 'MPBattleDialogue');

						Unit.SpeakAbout(EnemySpeechGroupName);
					}
				}
			}
		}

		Log(self $ " EmitBattleDialogToUnits() done", 'MPBattleDialogue');
	}
}

// Callback functions called from WargameMultiplayer/WargameSkirmish Killed() function if VC is registered for killed notify
function NotifyAICasualty( Pawn AIPawn, Pawn Killer );
function NotifyPlayerCasualty( Pawn PlayerPawn );

defaultproperties
{
	WinsWhenTimerExpires = TEAM_German

	VictoryMessageTags(0)="NOVICTORY"
	VictoryMessageTags(1)="USVICTORY"
	VictoryMessageTags(2)="DEVICTORY"
	MessageSectionName="VictoryCondition"

	gameEnded = false
	IsGameOn = false

	TimeToEndTheGame = 0.0f
	bDelayedVictory = false
	bVictoryDisabled = false

	bAlwaysRelevant = true
	RemoteRole = ROLE_DumbProxy
}class gbxWeaponPickupMessage extends gbxContextUseHUDMessage;

var localized string WeaponPickupMessage;

static function string GetString(
	optional int Switch,
	optional PlayerReplicationInfo RelatedPRI_1,
	optional PlayerReplicationInfo RelatedPRI_2,
	optional Object OptionalObject ) {

		
	local EWeaponName NameSwitch;

	NameSwitch = EWeaponName( Switch );

	switch( NameSwitch )
	{
		case WN_USM1:
			return default.WeaponPickupMessage$class'gbxInventory.WeapUSM1_'.Default.ItemName;
			break;

		case WN_USM1Carbine:
			return default.WeaponPickupMessage$class'WeapUSM1Carbine'.Default.ItemName;
			break;
	
		case WN_USBAR:
			return default.WeaponPickupMessage$class'WeapUSBAR'.Default.ItemName;
			break;
		
		case WN_USThompson:
			return default.WeaponPickupMessage$class'WeapUSThompson'.Default.ItemName;
			break;

		case WN_USColt1911:
			return default.WeaponPickupMessage$class'WeapUSColt1911_'.Default.ItemName;
			break;

		case WN_USBazooka:
			return default.WeaponPickupMessage$class'WeapUSBazooka'.Default.ItemName;
			break;

		case WN_USSpringfield:
			return default.WeaponPickupMessage$class'WeapUSSpringfield'.Default.ItemName;
			break;
	
		case WN_DEK98:
			return default.WeaponPickupMessage$class'WeapDEK98_'.Default.ItemName;
			break;
	
		case WN_DEK98Sniper:
			return default.WeaponPickupMessage$class'WeapDEK98Sniper'.Default.ItemName;
			break;

		case WN_DEMP40:
			return default.WeaponPickupMessage$class'WeapDEMP40_'.Default.ItemName;
			break;

		case WN_DEMG42:
			return default.WeaponPickupMessage$class'WeapDEMG42_'.Default.ItemName;
			break;

		case WN_DEP38:
			return default.WeaponPickupMessage$class'WeapDEP38_'.Default.ItemName;
			break;

		case WN_DESTG44:
			return default.WeaponPickupMessage$class'WeapDESTG44_'.Default.ItemName;
			break;

		case WN_DEFG42:
			return default.WeaponPickupMessage$class'WeapDEFG42_'.Default.ItemName;
			break;

		case WN_DEFG42SNIPER:
			return default.WeaponPickupMessage$class'WeapDEFG42SNIPER'.Default.ItemName;
			break;

		case WN_DEPanzerfaust:
			return default.WeaponPickupMessage$class'WeapDEPanzerfaust'.Default.ItemName;
			break;
	}
}

defaultproperties
{
	WeaponPickupMessage="%action_use% %icon_use% to pick up "
}

class gbxWeaponRestockMessage extends gbxContextUseHUDMessage;

var localized string WeaponRestockMessage;

static function string GetString(
	optional int Switch,
	optional PlayerReplicationInfo RelatedPRI_1,
	optional PlayerReplicationInfo RelatedPRI_2,
	optional Object OptionalObject ) {

		
	local EWeaponName NameSwitch;

	NameSwitch = EWeaponName( Switch );

	switch( NameSwitch )
	{
		case WN_USM1:
			return default.WeaponRestockMessage$class'gbxInventory.WeapUSM1_'.Default.ItemName;
			break;

		case WN_USM1Carbine:
			return default.WeaponRestockMessage$class'WeapUSM1Carbine'.Default.ItemName;
			break;
	
		case WN_USBAR:
			return default.WeaponRestockMessage$class'WeapUSBAR'.Default.ItemName;
			break;
		
		case WN_USThompson:
			return default.WeaponRestockMessage$class'WeapUSThompson'.Default.ItemName;
			break;

		case WN_USColt1911:
			return default.WeaponRestockMessage$class'WeapUSColt1911_'.Default.ItemName;
			break;

		case WN_USBazooka:
			return default.WeaponRestockMessage$class'WeapUSBazooka'.Default.ItemName;
			break;

		case WN_USSpringfield:
			return default.WeaponRestockMessage$class'WeapUSSpringfield'.Default.ItemName;
			break;
	
		case WN_DEK98:
			return default.WeaponRestockMessage$class'WeapDEK98_'.Default.ItemName;
			break;
	
		case WN_DEK98Sniper:
			return default.WeaponRestockMessage$class'WeapDEK98Sniper'.Default.ItemName;
			break;

		case WN_DEMP40:
			return default.WeaponRestockMessage$class'WeapDEMP40_'.Default.ItemName;
			break;

		case WN_DEMG42:
			return default.WeaponRestockMessage$class'WeapDEMG42_'.Default.ItemName;
			break;

		case WN_DEP38:
			return default.WeaponRestockMessage$class'WeapDEP38_'.Default.ItemName;
			break;

		case WN_DESTG44:
			return default.WeaponRestockMessage$class'WeapDESTG44_'.Default.ItemName;

		case WN_DEPanzerfaust:
			return default.WeaponRestockMessage$class'WeapDEPanzerfaust'.Default.ItemName;
			break;
	}
}

defaultproperties
{
	WeaponRestockMessage="%action_use% %icon_use% to restock your "
}

class gbxWindowDebugClient extends UWindowDialogClientWindow;


var gbxWindowListBox			CommandListControl;
var gbxDebugMapListCW			MapListControl;
var gbxDebugServerListCW		ServerListControl;
var gbxDebugBrightnessCW		BrightnessControl;

var int m_nSelectedIdx;
var int ScrollPos;
var bool bIgnoreNextEscape;
var int splitscreen_index;


function Created()
{
	CommandListControl = gbxWindowListBox(CreateWindow(class'gbxWindowListBox', 0, 0, WinWidth, WinHeight));

	MapListControl = gbxDebugMapListCW(CreateWindow(class'gbxDebugMapListCW', 0, 0, WinWidth, WinHeight));
	MapListControl.HideWindow();

	ServerListControl = gbxDebugServerListCW(CreateWindow(class'gbxDebugServerListCW', 0, 0, WinWidth, WinHeight));
	ServerListControl.HideWindow();

	BrightnessControl = gbxDebugBrightnessCW(CreateWindow(class'gbxDebugBrightnessCW', 0, 0, WinWidth, WinHeight));
	BrightnessControl.HideWindow();

	Cursor = Root.NormalCursor;
	bIgnoreNextEscape = false;

	splitscreen_index = -1;  // set to invalid value at first
}

function ShowWindow()
{
	local gbxWindowListBoxItem	aSelected;
	local PlayerController		anOwner;

	Super.ShowWindow();

	anOwner = GetPlayerOwner();

	if (anOwner == None)
		return;

	CommandListControl.ClearList();

	aSelected = gbxWindowListBoxItem(CommandListControl.AddItem("Select Map"));
	aSelected.HelpText = "Map";
	CommandListControl.SetSelectedItem( aSelected );
	CommandListControl.VertSB.Show(0);
	m_nSelectedIdx = 0;

	ScrollPos = 0;

	aSelected = gbxWindowListBoxItem(CommandListControl.AddItem("god"));
	aSelected.HelpText = "god";
	aSelected = gbxWindowListBoxItem(CommandListControl.AddItem("ghost"));
	aSelected.HelpText = "ghost";
	aSelected = gbxWindowListBoxItem(CommandListControl.AddItem("walk"));
	aSelected.HelpText = "walk";
	aSelected = gbxWindowListBoxItem(CommandListControl.AddItem("ver"));
	aSelected.HelpText = "ver";
	aSelected = gbxWindowListBoxItem(CommandListControl.AddItem("slomo 4"));
	aSelected.HelpText = "slomo 4";
	aSelected = gbxWindowListBoxItem(CommandListControl.AddItem("slomo 1"));
	aSelected.HelpText = "slomo 1";
	aSelected = gbxWindowListBoxItem(CommandListControl.AddItem("slomo 0.2"));
	aSelected.HelpText = "slomo 0.2";
	aSelected = gbxWindowListBoxItem(CommandListControl.AddItem("loaded"));
	aSelected.HelpText = "loaded";
	aSelected = gbxWindowListBoxItem(CommandListControl.AddItem("Assault Interface"));
	aSelected.HelpText = "ToggleAssaultInterface";
	aSelected = gbxWindowListBoxItem(CommandListControl.AddItem("Suppression Icons"));
	aSelected.HelpText = "ToggleSuppressionIcons";
	aSelected = gbxWindowListBoxItem(CommandListControl.AddItem("Aim Assist"));
	aSelected.HelpText = "ToggleAimAssist";	
	aSelected = gbxWindowListBoxItem(CommandListControl.AddItem("Crosshair"));
	aSelected.HelpText = "ToggleCrosshair";	
	aSelected = gbxWindowListBoxItem(CommandListControl.AddItem("Show/Hide HUD"));
	aSelected.HelpText = "ToggleShowHUD";	
	aSelected = gbxWindowListBoxItem(CommandListControl.AddItem("Command Ring Style"));
	aSelected.HelpText = "ToggleCommandRing";
	aSelected = gbxWindowListBoxItem(CommandListControl.AddItem("Reconnect"));
	aSelected.HelpText = "open "$GetPlayerOwner().GetURLMap();
	aSelected = gbxWindowListBoxItem(CommandListControl.AddItem("Invert YAxis True"));
	aSelected.HelpText = "set input JoyV Axis aLookup SpeedBase=1.0 DeadZone=0.25 MaxSpeedThreshold=1.0 SmoothingExponent=2.5 Invert=-1";
	aSelected = gbxWindowListBoxItem(CommandListControl.AddItem("Invert YAxis False"));
	aSelected.HelpText = "set input JoyV Axis aLookup SpeedBase=1.0 DeadZone=0.25 MaxSpeedThreshold=1.0 SmoothingExponent=2.5 Invert=1";
	aSelected = gbxWindowListBoxItem(CommandListControl.AddItem("Stat FPS"));
	aSelected.HelpText = "stat fps";
	aSelected = gbxWindowListBoxItem(CommandListControl.AddItem("Stat Audio"));
	aSelected.HelpText = "stat audio";
	aSelected = gbxWindowListBoxItem(CommandListControl.AddItem("Stat Player"));
	aSelected.HelpText = "stat player";
	aSelected = gbxWindowListBoxItem(CommandListControl.AddItem("Stat None"));
	aSelected.HelpText = "stat none";
	aSelected = gbxWindowListBoxItem(CommandListControl.AddItem("Toggle Client Msgs"));
	aSelected.HelpText = "ToggleClientMessages";
	aSelected = gbxWindowListBoxItem(CommandListControl.AddItem("ShowPathNodes"));
	aSelected.HelpText = "showpathnodes";
	aSelected = gbxWindowListBoxItem(CommandListControl.AddItem("Adjust Brightness/Gamma/Contrast"));
	aSelected.HelpText = "AdjustBrightness";
	aSelected = gbxWindowListBoxItem(CommandListControl.AddItem("Toggle Defense Difficulty"));
	aSelected.HelpText = "ToggleDefenseDifficulty";
	if (Root.bIsConsole)
	{
		aSelected = gbxWindowListBoxItem(CommandListControl.AddItem("Add Splitscreen"));
		aSelected.HelpText = "addsplit";
	}
	aSelected = gbxWindowListBoxItem(CommandListControl.AddItem("Create ListenServer"));
	aSelected.HelpText = "ListenServerMap";
	aSelected = gbxWindowListBoxItem(CommandListControl.AddItem("Connect to ListenServer"));
	aSelected.HelpText = "ConnectListenServer";
}

function NextListItem()
{
	local	int	nCount;
	local UWindowListBoxItem	aSelected;

	nCount = CommandListControl.Count();

	m_nSelectedIdx++;
	if (m_nSelectedIdx >= nCount)
		m_nSelectedIdx--;
	else
	{
		aSelected = CommandListControl.GetItemAtIdx( m_nSelectedIdx );
		CommandListControl.SetSelectedItem( aSelected );
		ScrollPos++;
		if ((CommandListControl.ItemHeight * ScrollPos) > (WinHeight - CommandListControl.ItemHeight))
		{
			ScrollPos--;
			CommandListControl.VertSB.Scroll(1);
		}
	}
}

function PrevListItem()
{
	local	int	nCount;
	local UWindowListBoxItem	aSelected;

	nCount = CommandListControl.Count();

	m_nSelectedIdx--;
	if (m_nSelectedIdx < 0)
		m_nSelectedIdx++;
	else
	{
		aSelected = CommandListControl.GetItemAtIdx( m_nSelectedIdx );
		CommandListControl.SetSelectedItem( aSelected );
		ScrollPos--;
		if ((CommandListControl.ItemHeight * ScrollPos) < 0)
		{
			ScrollPos++;
			CommandListControl.VertSB.Scroll(-1);
		}
	}
}

function ExecDebugCommand()
{
	local UWindowListBoxItem aSelected;
	local string command;

	aSelected = CommandListControl.GetItemAtIdx( m_nSelectedIdx );

	if (aSelected.HelpText == "Map")
	{
		Root.fDelayTime = 0.5f;  // don't allow 'enter' key for a short amount of time (debounce)
		Root.fAutoRepeatTime = 1.0f;
		CommandListControl.HideWindow();
		MapListControl.LoadMapList();
		MapListControl.ShowWindow();
		MapListControl.BringToFront();
	}
	else if (aSelected.HelpText == "ListenServerMap")
	{
		Root.fDelayTime = 0.5f;  // don't allow 'enter' key for a short amount of time (debounce)
		Root.fAutoRepeatTime = 1.0f;
		CommandListControl.HideWindow();
		MapListControl.bStartListenServer = true;
		MapListControl.LoadMapList();
		MapListControl.ShowWindow();
		MapListControl.BringToFront();
	}
	else if (aSelected.HelpText == "ConnectListenServer")
	{
		CommandListControl.HideWindow();
		ServerListControl.LoadServerList();
		ServerListControl.ShowWindow();
		ServerListControl.BringToFront();
	}
	else if (aSelected.HelpText == "AdjustBrightness")
	{
		CommandListControl.HideWindow();
		BrightnessControl.ShowWindow();
		BrightnessControl.BringToFront();
	}
	else if (aSelected.HelpText == "addsplit")
	{
		HideWindow();
		Root.CloseActiveWindow();
		GotoState('');

		if (splitscreen_index < 4)
		{
			command = "addsplit index=" $ splitscreen_index;
			splitscreen_index++;

			if( !Root.ConsoleCommand( command ) )
				Message( Localize("Errors","Exec","Core"), 6.0 );
		}
	}
	else
	{
		HideWindow();
		Root.CloseActiveWindow();
		GotoState('');

		if( !Root.ConsoleCommand( aSelected.HelpText ) )
			Message( Localize("Errors","Exec","Core"), 6.0 );
	}
}

function bool KeyEvent( out EInputKey Key, out EInputAction Action, FLOAT Delta )
{
	local bool	fReturn;

	if (bIgnoreNextEscape)
	{
		bIgnoreNextEscape = false;
		Action = IST_None;
	}

	if (MapListControl.bWindowVisible)
	{
		fReturn = MapListControl.KeyEvent( Key, Action, Delta );

		// check if key is controller 'A' or controller 'Right Trigger' or keyboard Enter key
		if ((Action == IST_Press) && ((Key == IK_Joy1) || (Key == IK_Joy8) || (Key == IK_Enter)))
		{
			MapListControl.HideWindow();
			CommandListControl.ShowWindow();
			CommandListControl.BringToFront();
		}
		else if ((Action == IST_Press) && ((Key == IK_Escape) || (Key == IK_Joy13)))
		{
			MapListControl.HideWindow();
			CommandListControl.ShowWindow();
			CommandListControl.BringToFront();
			Action = IST_None;  // prevent parent window from acting on this key
			bIgnoreNextEscape = true;
		}

		return fReturn;
	}
	else if (ServerListControl.bWindowVisible)
	{
		fReturn = ServerListControl.KeyEvent( Key, Action, Delta );

		// check if key is controller 'A' or controller 'Right Trigger' or keyboard Enter key
		if ((Action == IST_Press) && ((Key == IK_Joy1) || (Key == IK_Joy8) || (Key == IK_Enter)))
		{
			ServerListControl.HideWindow();
			CommandListControl.ShowWindow();
			CommandListControl.BringToFront();
		}
		else if ((Action == IST_Press) && ((Key == IK_Escape) || (Key == IK_Joy13)))
		{
			ServerListControl.HideWindow();
			CommandListControl.ShowWindow();
			CommandListControl.BringToFront();
			Action = IST_None;  // prevent parent window from acting on this key
			bIgnoreNextEscape = true;
		}

		return fReturn;
	}
	else if (BrightnessControl.bWindowVisible)
	{
		fReturn = BrightnessControl.KeyEvent( Key, Action, Delta );

		if ((Action == IST_Press) && ((Key == IK_Escape) || (Key == IK_Joy13)))
		{
			BrightnessControl.HideWindow();
			CommandListControl.ShowWindow();
			CommandListControl.BringToFront();
			Action = IST_None;  // prevent parent window from acting on this key
			bIgnoreNextEscape = true;
		}

		return fReturn;
	}
	else
	{
		if (Action == IST_Press)
		{
			switch (Key)
			{
				case IK_Joy10:		// Down
				case IK_Down:
					NextListItem();
					return true;
				case IK_Joy9:		// Up
				case IK_Up:
					PrevListItem();
					return true;
				case IK_Joy11:		// Left
				case IK_Left:
					break;
				case IK_Joy12:		// Right
				case IK_Right:
					break;
				case IK_Joy8:		// Select
				case IK_Joy1:		// 'A'
				case IK_Enter:
					ExecDebugCommand();
					return true;
			}
		}
		if (Action == IST_Axis)
		{
		}
	}
	return Super.KeyEvent(Key,Action,Delta);
}

function Resized()
{
	Super.Resized();

	CommandListControl.SetSize( WinWidth, WinHeight );

	MapListControl.SetSize( WinWidth, WinHeight );
	MapListControl.Resized();

	ServerListControl.SetSize( WinWidth, WinHeight );
	ServerListControl.Resized();

	BrightnessControl.SetSize( WinWidth, WinHeight );
	BrightnessControl.Resized();
}

defaultproperties
{
}

class gbxWindowDebugWindow extends UWindowFramedWindow;



var float OldParentWidth, OldParentHeight;
var bool bIsResizing;


function ShowWindow()
{
	local PlayerController		anOwner;

	Super.ShowWindow();

	if (gbxWindowDebugClient(ClientArea).splitscreen_index == -1)
	{
		anOwner = GetPlayerOwner();
		if (anOwner.Level.Game.IsA('WargameDeathMatch'))
			gbxWindowDebugClient(ClientArea).splitscreen_index = 2;  // start with second controller
		else
			gbxWindowDebugClient(ClientArea).splitscreen_index = 1;  // start with second controller
	}

	if (ClientArea != None)
		ClientArea.ShowWindow();

	if(ParentWindow.WinWidth != OldParentWidth || ParentWindow.WinHeight != OldParentHeight)
	{
		SetDimensions();
		if (ClientArea != None)
			ClientArea.ResolutionChanged(ParentWindow.WinWidth, ParentWindow.WinHeight);
		OldParentWidth = ParentWindow.WinWidth;
		OldParentHeight = ParentWindow.WinHeight;
	}

	bIsResizing = false;
}

function bool KeyEvent( out EInputKey Key, out EInputAction Action, FLOAT Delta )
{
	if (ClientArea != None)
		ClientArea.KeyEvent( Key, Action, Delta );

	return Super.KeyEvent(Key,Action,Delta);
}

function ResolutionChanged(float W, float H)
{
	SetDimensions();
}

function SetDimensions()
{
	if (bIsResizing)
		return;

	bIsResizing = true;  // prevent recursion crashing problem

	if (Root.bIsConsole)
	{
		SetSize(250, 183);

		// switch to smaller fonts if in split screen mode
//		if ((Root.RealWidth < 640) || (Root.RealHeight < 480))
//			Root.SetScale(1);
	}
	else
		SetSize(410, 310);

	WinLeft = ParentWindow.WinWidth/2 - WinWidth/2;
	WinTop = ParentWindow.WinHeight/2 - WinHeight/2;

	bIsResizing = false;
}

function Close(optional bool bByParent)
{
	ClientArea.Close(True);
	Root.GotoState('');
}

defaultproperties
{
	WindowTitle="Debug Menu";
	ClientClass=class'gbxWindowDebugClient'
}
//=============================================================================
// gbxWindowListBox - a listbox
//=============================================================================
class gbxWindowListBox extends UWindowListBox;



function Created()
{
	Super.Created();
}


function DrawItem(Canvas C, UWindowList Item, float X, float Y, float W, float H)
{
	local float TX,XL,YL;

// @@Joe - Fixed this to use the TextColor and fonts.  Much nicer :)
//   FIXME: Update to auto-set the item height

	if(UWindowListBoxItem(Item).bSelected)
	{
		if (!bNoSelectionBox)
		{
			C.DrawColor = SelectionBkgColor;
			DrawStretchedTexture(C, X, Y, W, H-1, Texture'WhiteTexture');
		}
		C.DrawColor = SelectionColor;
	}
	else
	{
		C.DrawColor = TextColor;
	}

	C.Font = Root.Fonts[Font];
	C.StrLen(UWindowListBoxItem(Item).Caption,XL,YL);

	switch (gbxWindowListBoxItem(Item).ItemAlign)
	{
		case TA_Left:
			TX = X+2;
			break;
		case TA_Center:
			TX = (W-4 - XL)/2;
			break;
		case TA_Right:
			TX = W-XL - W-2;
			break;
	}

	ClipText(C, TX, Y, UWindowListBoxItem(Item).Caption);
}


defaultproperties
{
	ListClass=class'gbxWindowListBoxItem'
	TextColor=(R=0,G=0,B=0,A=255)
}
class gbxWindowListBoxItem extends UWindowListBoxItem;



var TextAlign			ItemAlign;
//var Color				ItemBkgColor;
var Color				ItemColor;

defaultproperties
{
	ItemAlign=TA_Left
	//ItemBkgColor=(R=0,G=0,B=192,A=255)
	ItemColor=(R=0,G=0,B=0,A=255)
}
class gbxWindowWrappedTextArea extends UWindowTextAreaControl;



function Paint( Canvas C, float X, float Y )
{
	local int i, Line;
	local int TempHead, TempTail;
	local float XL, YL;

	C.Font = Root.Fonts[Font];
	C.SetDrawColor(0,0,0);

	TextSize(C, "TEST", XL, YL);
	VisibleRows = WinHeight / YL;

	if (bScrollable)
	{
		VertSB.SetRange(0, Lines, VisibleRows);
	}

	TempHead = Head;
	TempTail = Tail;
	Line = TempHead;
	TextArea[Line] = Prompt;
	if (bScrollable)
	{
		if (VertSB.MaxPos - VertSB.Pos > 0)
		{
			Line -= VertSB.MaxPos - VertSB.Pos;
			TempTail -= VertSB.MaxPos - VertSB.Pos;
		}
	}
	for (i=0; i<VisibleRows; i++)
	{
		WrapClipText(C, 2, YL*i, TextArea[i]);
		Line--;
		if (TempTail == Line)
			break;
		if (Line < 0)
			Line = BufSize-1;
	}
}

class HoldSpot extends WargameScriptedSequence
	notplaceable;



function FreeScript()
{
	Destroy();
}

defaultproperties
{
	bCollideWhenPlacing=false
	bStatic=false
	bNoDelete=false
}
class LevelGameRules extends Info;



// allows level designers to override game settings

function PreBeginPlay()
{
}

function UpdateGame(GameInfo G);

defaultproperties
{
}
//=============================================================================
// MissionBoundaryVolume:  a bounding volume
// used to block certain classes of actors
// primary use is to provide collision for non-zero extent traces around static meshes

//=============================================================================

class MissionBoundaryVolume extends BlockingVolume;
class MissionBoundaryWarning extends Volume;
//=============================================================================
// Object to facilitate storing an item with active objective information
//
// << GBX/PAD:created -- entire file
//
//=============================================================================

class ObjectiveInfo extends Object
	editinlinenew;



var	()	localized string	m_szShortDesc;		// A short description of the objective to be used in a list
var	()	localized string	m_szLongDesc;		// A long description to be used in a display box
var	()	EObjectiveComplete	m_eComplete;		// The status of the objective (inactive, active, complete, or failed)
var () name					m_szActivateEvent;	// The tag of Actors to trigger when this objective is activated.
var () name					m_szCompleteEvent;	// The tag of Actors to trigger when this objective is complete.
var () name					m_szFailedEvent;	// The tag of Actors to trigger when this objective fails.
var () bool					m_fCritical;		// If true, then this objective failing will end the game.
var	() bool					m_fPrimary;			// If true, this is a primary objective that must be completed to succeed in the mission

defaultproperties
{
}
//=============================================================================
// Object to facilitate storing a list with active objective information
//
// << GBX/PAD:created -- entire file
//
//=============================================================================

class ObjectiveList extends Info
	placeable;



var()	export	editinline	array<ObjectiveInfo>	Objectives;		// A list of objective info structures.
var()	name										m_szSuccess;	// A tag for actors to trigger when all objectives are successful
var()	name										m_szFailure;	// A tag for actors to trigger when a critical objective fails.

// GBX:PAD: Well, it turns out that objects don't quite get their localized strings properly from the map file.
// Instead they get them from the code package .int file.  So, in order to localize these objective strings, I'm
// going to manually take care of this.
simulated function PostLoadGame()
{
	local int i;
	
	Super.PostLoadGame();
	
	for (i = 0; i < Objectives.Length; i++)
	{
		if (Level.LocalizationFileName == "")
		{
			Objectives[i].m_szShortDesc = Localize( ""$Objectives[i].Name , "m_szShortDesc", Level.GetLevelFileName() );
			Objectives[i].m_szLongDesc = Localize( ""$Objectives[i].Name , "m_szLongDesc", Level.GetLevelFileName() );
		}
		else
		{
			Objectives[i].m_szShortDesc = Localize( ""$Objectives[i].Name , "m_szShortDesc", Level.LocalizationFileName );
			Objectives[i].m_szLongDesc = Localize( ""$Objectives[i].Name , "m_szLongDesc", Level.LocalizationFileName );
		}
	}
}

simulated function SetStatus( int nIdx, EObjectiveComplete eComplete, Controller C )
{
	if (Objectives[ nIdx ].m_eComplete != eComplete)
	{
		Objectives[ nIdx ].m_eComplete = eComplete;

		switch (eComplete)
		{
			case OI_Active:
				if ((C.Pawn == None) || (C.Pawn.Health > 0))
				{
					C.TriggerEvent(Objectives[ nIdx ].m_szActivateEvent, self, C.Pawn);
				}
				break;
			case OI_Complete:
				if ((C.Pawn == None) || (C.Pawn.Health > 0))
				{
					C.TriggerEvent(Objectives[ nIdx ].m_szCompleteEvent, self, C.Pawn);
				}
				break;
			case OI_Failed:
				C.TriggerEvent(Objectives[ nIdx ].m_szFailedEvent, self, C.Pawn);
				break;
		}
	}
}

simulated function TestStatus(Controller C)
{
	local	int		i;
	local	bool	fSuccess;
	local	bool    fFailure;

	fSuccess = true;
	fFailure = false;

	for( i = 0; i < Objectives.Length; i++ )
	{
		if (Objectives[i] != None)
		{
			if ((Objectives[i].m_eComplete != OI_Complete) && Objectives[i].m_fPrimary)
				fSuccess = false;
			if ((Objectives[i].m_eComplete == OI_Failed) && Objectives[i].m_fCritical)
				fFailure = true;
		}
	}

	if (fSuccess && !fFailure)
	{
		C.TriggerEvent(m_szSuccess, self, C.Pawn);
	}

	if (fFailure)
	{
		C.TriggerEvent(m_szFailure, self, C.Pawn);
	}
}

static function ClientReceiveObjective(
	PlayerController P,
	Name szObjectiveTag,
	EObjectiveComplete nStatus,
	int nObjectiveIdx,
	bool bDisplayMessage,
	float flLifeTime,
	optional PlayerReplicationInfo RelatedPRI_1,
	optional PlayerReplicationInfo RelatedPRI_2
	)
{
	local	ObjectiveList	anObjectiveList;
	local	gbxHUD			myHud;
	
	myHUD = gbxHUD(P.MyHud);
	
	if (nObjectiveIdx == -1)
	{
		myHud.ClearObjectiveOverlay();
	}
	else
	{
		foreach P.AllActors( class'ObjectiveList', anObjectiveList, szObjectiveTag )
		{
			if( anObjectiveList.Objectives[ nObjectiveIdx ] != None)
			{
				if (anObjectiveList.Objectives[ nObjectiveIdx ].m_eComplete != nStatus)
				{
					anObjectiveList.SetStatus( nObjectiveIdx, nStatus, P );
				}
				
				if (bDisplayMessage)
				{
					myHud.SetObjectiveString( anObjectiveList.Objectives[ nObjectiveIdx ].m_szShortDesc, anObjectiveList.Objectives[ nObjectiveIdx ].m_eComplete, flLifeTime, anObjectiveList.Objectives[ nObjectiveIdx ].m_fPrimary, false );
				}
			}
		}
	}
}

defaultproperties
{
	RemoteRole=ROLE_AutonomousProxy
	bStatic=True
	bHidden=True
	Texture=Texture'Engine.S_Keypoint'
}
//=============================================================================
// Basically a way for the level designers to preload some objects dynamically while a level is running.
//=============================================================================
class ObjectPreloader extends Actor
	placeable;

struct native export PreloadObject
{
	var() string		  ObjectPath;
	var() class<Object>   ObjectClass;
};

var(Preload) editinline array<PreloadObject>	PreloadObjects;

function Trigger(actor Other, pawn EventInstigator)
{
	local int i;
	
	super.Trigger(Other,EventInstigator);

	for( i = 0; i < PreloadObjects.Length; ++i )
	{
		DynamicLoadObject( PreloadObjects[ i ].ObjectPath, PreloadObjects[ i ].ObjectClass );
	}
	PreloadObjects.Length = 0;
}

defaultproperties
{
}
//=============================================================================
// TeamPlayerReplicationInfo.
//=============================================================================
class TeamPlayerReplicationInfo extends PlayerReplicationInfo;


//DS-BEGIN/END: stats uploading
var bool bLiveStatsPosted; // used by Xbox Live to make sure we only update stats once

var class<Scoreboard> LocalStatsScreenClass;
var bool bHolding;

// following properties are used for server-side local stats gathering and not replicated (except through replicated functions)

var bool bFirstBlood;

struct WeaponStats
{
	var class<Weapon> WeaponClass;
	var int kills;
	var int deaths;
	var int deathsholding;
};

var array<WeaponStats> WeaponStatsArray;
var int FlagTouches, FlagReturns;
var byte Spree[6];
var int Suicides;
var int flakcount,combocount,headcount;
var byte Combos[5];

replication
{
	reliable if ( bNetInitial && (Role == ROLE_Authority) )
		LocalStatsScreenClass;
	reliable if ( Role == ROLE_Authority )
		bHolding;
}

simulated function PostBeginPlay()
{
	Super.PostBeginPlay();

	if ( WargameMPGameInfo(Level.Game) != None )
		LocalStatsScreenClass = WargameMPGameInfo(Level.Game).LocalStatsScreenClass;
}

simulated function UpdateWeaponStats(TeamPlayerReplicationInfo PRI, class<Weapon> W, int newKills, int newDeaths, int newDeathsHolding)
{
	local int i;
	local WeaponStats NewWeaponStats;

	for ( i=0; i<WeaponStatsArray.Length; i++ )
	{
		if ( WeaponStatsArray[i].WeaponClass == W )
		{
			WeaponStatsArray[i].Kills = newKills;
			WeaponStatsArray[i].Deaths = newDeaths;
			WeaponStatsArray[i].DeathsHolding = newDeathsHolding;
			return;
		}
	}

	NewWeaponStats.WeaponClass = W;
	NewWeaponStats.Kills = newKills;
	NewWeaponStats.Deaths = newDeaths;
	NewWeaponStats.DeathsHolding = newDeathsHolding;
	WeaponStatsArray[WeaponStatsArray.Length] = NewWeaponStats;
}

function AddWeaponKill(class<DamageType> D)
{
	local class<Weapon> W;
	local int i;
	local WeaponStats NewWeaponStats;

	if ( class<WeaponDamageType>(D) == None )
		return;

	W = class<WeaponDamageType>(D).default.WeaponClass;

	for ( i=0; i<WeaponStatsArray.Length; i++ )
	{
		if ( WeaponStatsArray[i].WeaponClass == W )
		{
			WeaponStatsArray[i].Kills++;
			return;
		}
	}

	NewWeaponStats.WeaponClass = W;
	NewWeaponStats.Kills = 1;
	WeaponStatsArray[WeaponStatsArray.Length] = NewWeaponStats;
}

function AddWeaponDeath(class<DamageType> D)
{
	local class<Weapon> W, LastWeapon;
	local int i;
	local WeaponStats NewWeaponStats;

	LastWeapon = Controller(Owner).GetLastWeapon();

	if ( LastWeapon != None )
		AddWeaponDeathHolding(LastWeapon);

	if ( class<WeaponDamageType>(D) == None )
		return;

	W = class<WeaponDamageType>(D).default.WeaponClass;

	for ( i=0; i<WeaponStatsArray.Length; i++ )
	{
		if ( WeaponStatsArray[i].WeaponClass == W )
		{
			WeaponStatsArray[i].Deaths++;
			return;
		}
	}

	NewWeaponStats.WeaponClass = W;
	NewWeaponStats.Deaths = 1;
	WeaponStatsArray[WeaponStatsArray.Length] = NewWeaponStats;
}

function AddWeaponDeathHolding(class<Weapon> W)
{
	local int i;
	local WeaponStats NewWeaponStats;

	for ( i=0; i<WeaponStatsArray.Length; i++ )
	{
		if ( WeaponStatsArray[i].WeaponClass == W )
		{
			WeaponStatsArray[i].DeathsHolding++;
			return;
		}
	}

	NewWeaponStats.WeaponClass = W;
	NewWeaponStats.DeathsHolding = 1;
	WeaponStatsArray[WeaponStatsArray.Length] = NewWeaponStats;
}

simulated function string GetHumanReadableName()
{
	if (UbicomName != "???" && UbicomName != "" && Level.AuthMode != AM_SystemLink)
	{
		return UbicomName;
	}
	else
	{
		return Super.GetHumanReadableName();
	}
}
//=============================================================================
// WargameDeathMatch
//=============================================================================
class WargameDeathMatch extends WargameGameInfo
    config;



var	bool bAddSplitPending;
/*
function PostBeginPlay()
{
	local string szReturn;

	szReturn = ConsoleCommand( "addsplit INDEX=1" );
	log(self$".PostBeginPlay() - "$szReturn);
}
*/
function Timer()
{
	local string szReturn;

	Super.Timer();

	if (bAddSplitPending)
	{
		szReturn = ConsoleCommand( "addsplit INDEX=1" );
		log(self$".PostBeginPlay() - "$szReturn);
//		if (szReturn == "")
			bAddSplitPending = false;
	}
}

//
// Restart a player.
//
function RestartPlayer( Controller aPlayer )
{
	Super.RestartPlayer( aPlayer );

	if (gbxPlayerStart(aPlayer.Pawn.LastStartSpot) != None)
		gbxPlayerStart(aPlayer.Pawn.LastStartSpot).AddDefaultInventory( aPlayer.Pawn );
	else
	{
		log(self$".RestartPlayer( "$aPlayer$" ) - "$gbxPawn(aPlayer.Pawn));
		gbxPawn(aPlayer.Pawn).RequiredEquipment[0] = "gbxInventory.WeapUSM1_";
	}
}

defaultproperties
{
	bAddSplitPending=false
}
class WargameGame extends GameInfo;



var TeamInfo Teams[2];

function PreBeginPlay()
{
	Super.PreBeginPlay();
	Teams[0] = Spawn( class'gbxTeamAllies' );
	Teams[1] = Spawn( class'gbxTeamAxis' );
}

event InitGame( string Options, out string Error )
{
	Super.InitGame( Options, Error );

	// Create the Suppression Cache and attach it to the interface pointer.
	CSSCache = new( None ) class'SeeAndSuppressCache'; // GBX:naj - modified 3/11/04
	SeeAndSuppressCache(CSSCache).Initialize();
}

/* StartMatch()
Start the game - inform all actors that the match is starting, and spawn player pawns
*/
function StartMatch()
{
	local Controller P;
	local Actor A;

	if (GameStats!=None)
		GameStats.StartGame();

	// tell all actors the game is starting
	ForEach AllActors(class'Actor', A)
		A.MatchStarting();

	// start human players first
	for ( P = Level.ControllerList; P!=None; P=P.nextController )
		if ( P.IsA('PlayerController') && (P.Pawn == None) )
		{
            if ( bGameEnded )
                return; // telefrag ended the game with ridiculous frag limit
            else if ( PlayerController(P).CanRestartPlayer()  )
				RestartPlayer(P);
		}

	// start AI players
/*
	for ( P = Level.ControllerList; P!=None; P=P.nextController )
		if ( P.bIsPlayer && !P.IsA('PlayerController') )
        {
			if ( Level.NetMode == NM_Standalone )
			RestartPlayer(P);
        	else
				P.GotoState('Dead','MPStart');
		}
*/

	bWaitingToStartMatch = false;
	GameReplicationInfo.bMatchHasBegun = true;
}

//
// Restart a player.
//
function RestartPlayer( Controller aPlayer )
{
	//local float			cX, cY, cX2, cY2;

	Super.RestartPlayer( aPlayer );

	if ( (gbxPlayerStart(aPlayer.Pawn.LastStartSpot) != None) && (Infantry(aPlayer.Pawn).TriggerOnDeath == '') )
		Infantry(aPlayer.Pawn).TriggerOnDeath = gbxPlayerStart(aPlayer.Pawn.LastStartSpot).TriggerOnDeath;

	// GBX:PAD: It kinda sucks to have to do it this way, but the way the code is laid out now there's not a particularly
	// practical alternative.  Basically, if the player start spot is flagged to not have weapons, then strip the weapons
	// off the already created player pawn.
/*
	if ((gbxPlayerStart(aPlayer.Pawn.LastStartSpot) != None) && gbxPlayerStart(aPlayer.Pawn.LastStartSpot).m_fStartWithNoWeapons)
	{
		Infantry(aPlayer.Pawn).bNoDefaultInventory = true;
		while ( aPlayer.Pawn.Inventory != None )
			aPlayer.Pawn.Inventory.Destroy();

		aPlayer.Pawn.Weapon = None;
	}
*/
	// DANGER: Do not reference aPlayer.Pawn after this line, because it may be a WeaponTurret,
	// not an Infantry.
}

/* Called when pawn has a chance to pick Item up (i.e. when
   the pawn touches a weapon pickup). Should return true if
   he wants to pick it up, false if he does not want it.
*/
function bool PickupQuery( Pawn Other, Pickup item )
{
	local byte bAllowPickup;
	local int i;
	local bool fReturn;

	if ( (GameRulesModifiers != None) && GameRulesModifiers.OverridePickupQuery(Other, item, bAllowPickup) )
		return (bAllowPickup == 1);

	if (gbxWeaponPickup(item) != None)
		if (!gbxWeaponPickup(item).CheckIfPickupValid( Other ))
			return false;

	if ( Other.Inventory == None )
	{
		return true;
	}
	else if ( bWeaponStay && Weapon(Other.FindInventoryType(item.InventoryType) ) != none) // SJP: Don't allow a second pickup if you've already got the weapon and weapon stay is on
	{
		return false;
	}
	else
	{
		fReturn = Other.Inventory.HandlePickupQuery(Item);
		if (!fReturn && (gbxPawn(Other) != None))
		{
			for( i = 0; (i < 4) && !fReturn; i++ )
			{
				if (gbxPawn(Other).SecondaryInventory[i] != None)
					fReturn = gbxPawn(Other).SecondaryInventory[i].HandlePickupQuery(Item);
			}
		}

		return !fReturn;
	}
}

event AcceptInventory(pawn PlayerPawn, bool bAccept)
{
	if (!bAccept)
	{
		return;
	}
	
    while ( PlayerPawn.Inventory != None )
        PlayerPawn.Inventory.Destroy();

    PlayerPawn.Weapon = None;
    PlayerPawn.SelectedItem = None;
    AddDefaultInventory( PlayerPawn );
}

function AddDefaultInventory( pawn PlayerPawn )
{
    if ( gbxPawn(PlayerPawn) != None )
        gbxPawn(PlayerPawn).AddDefaultInventory();
    SetPlayerDefaults(PlayerPawn);
}

defaultproperties
{
	bDelayedStart=false		// TODO testing xbox
	GameName="Gearbox Game"
	PlayerControllerClassName="gbxGameplay.WargamePlayerController"
    HUDType="gbxHUD.WargameHUD"
	MutatorClass="Engine.Mutator"
}
//=============================================================================
// WargameGameInfo
// GBX:PAD: FIX ME: This is currently a confusing mess and needs to be revised.
//=============================================================================
class WargameGameInfo extends WargameMPGameInfo
    config;



//#exec OBJ LOAD FILE=teamsymbols_ut2003.utx
//#exec OBJ LOAD File=announcermain.uax

var int NumRounds;
var globalconfig int NetWait;       // time to wait for players in netgames w/ bNetReady (typically team games)
var globalconfig int MinNetPlayers; // how many players must join before net game will start
var globalconfig int RestartWait;

// client game rendering options
var globalconfig bool bNoCoronas;					// don't display team coronas on player shoulders
var globalconfig bool bForceDefaultCharacter;		// all characters shown using default (jugg male) mesh

var globalconfig bool bTournament;  // number of players must equal maxplayers for game to start
var config bool bPlayersMustBeReady;// players must confirm ready for game to start
var config bool bForceRespawn;
var config bool bAdjustSkill;
var bool	bAllowTrans;
var bool    bWaitForNetPlayers;     // wait until more than MinNetPlayers players have joined before starting match
var bool    bMustJoinBeforeStart;   // players can only spectate if they join after the game starts
var bool	bFirstBlood;
var bool	bQuickStart;
var bool	bStartedCountDown;
var bool	bFinalStartup;
var bool	bOverTimeBroadcast;
var bool	bKillBots;
var bool    bCustomBots;

var byte StartupStage;              // what startup message to display
var int RemainingTime, ElapsedTime;
var int CountDown;
var float AdjustedDifficulty;
var int PlayerKills, PlayerDeaths;
var class<LevelGameRules> LevelRulesClass;
var LevelGameRules LevelRules;		// level designer overriding of game settings (hook for mod authors)
var config float SpawnProtectionTime;
var WargameTeamInfo EnemyRoster;
var string EnemyRosterName;
var string DefaultEnemyRosterClass;

var config float	FriendlyFireScale; //scale friendly fire damage by this value

// Bot related info
var     int         RemainingBots;
var     int         InitialBots;

var NavigationPoint LastPlayerStartSpot;    // last place player looking for start spot started from
var NavigationPoint LastStartSpot;          // last place any player started from

var     int         NameNumber;             // append to ensure unique name if duplicate player name change requested

var int             EndMessageWait;         // wait before playing which team won the match
var transient int   EndMessageCounter;      // end message counter
//DHW+ No longer used
//var Sound           EndGameSound[2];        // end game sounds
//var Sound AltEndGameSound[2];
//DHW-
var int             SinglePlayerWait;       // single-player wait delay before auto-returning to menus

var globalconfig string NamePrefixes[10];		// for bots with same name
var globalconfig string NameSuffixes[10];		// for bots with same name

var actor EndGameFocus;
var PlayerController StandalonePlayer;
var config int DefaultMaxLives;
var config int LateEntryLives;	// defines how many lives in a player can still join

var array<gbxPlayerController>		m_aPlayersNeedingUbiComValidation;

// mc - localized PlayInfo descriptions & extra info
var private localized string DMPropsDisplayText[10];

var() float ADR_Kill;
var() float ADR_MajorKill;
var() float ADR_MinorError;
var() float ADR_MinorBonus;
var() float ADR_KillTeamMate;

function PostBeginPlay()
{
	NameNumber = rand(10);

    Super.PostBeginPlay();
    GameReplicationInfo.RemainingTime = RemainingTime;
    InitTeamSymbols();
//    GetBotTeam(InitialBots);
//    if ( FIXME LoadingSinglePlayerLadderMatch )
//		OverrideInitialBots();

	if (m_aPlayersNeedingUbiComValidation.Length > 0 )
	{
		m_aPlayersNeedingUbiComValidation.Remove( 0, m_aPlayersNeedingUbiComValidation.Length);
	}
}

function OverrideInitialBots()
{
	InitialBots = GetBotTeam().OverrideInitialBots(InitialBots,None);
}

event PreLogin
(
    string Options,
    string Address,
    out string Error,
    out string FailCode
)
{
	local controller C;

	Super.PreLogin(Options,Address,Error,FailCode);
	if ( (Error == "") && (FailCode == "") && (MaxLives > 0) )
	{
		// check that game isn't too far along
		for ( C=Level.ControllerList; C!=None; C=C.NextController )
		{
			if ( (C.PlayerReplicationInfo != None) && (C.PlayerReplicationInfo.NumLives > 1) )
			{
				Error = "LastManStanding game already in progress";
				FailCode = "GAMESTARTED";
				return;
			}
		}
	}
}

/* Reset()
reset actor to initial state - used when restarting level without reloading.
*/
function Reset()
{
    Super.Reset();
    ElapsedTime = NetWait - 3;
    bWaitForNetPlayers = ( Level.NetMode != NM_StandAlone );
	bStartedCountDown = false;
	bFinalStartup = false;
    CountDown = Default.Countdown;
    RemainingTime = 60 * TimeLimit;
    GotoState('PendingMatch');
}

/* CheckReady()
If tournament game, make sure that there is a valid game winning criterion
*/
function CheckReady()
{
    if ( (GoalScore == 0) && (TimeLimit == 0) )
    {
        TimeLimit = 20;
        RemainingTime = 60 * TimeLimit;
    }
}

// Monitor killed messages for fraglimit
function Killed( Controller Killer, Controller Killed, Pawn KilledPawn, class<DamageType> damageType )
{
	local bool bEnemyKill;

	bEnemyKill = ( !bTeamGame || ((Killer != None) && (Killer != Killed) && (Killed != None)
								&& (Killer.PlayerReplicationInfo != None) && (Killed.PlayerReplicationInfo != None)
								&& (Killer.PlayerReplicationInfo.Team != Killed.PlayerReplicationInfo.Team)) );

	if ( (gbxPawn(KilledPawn) != None) && (gbxPawn(KilledPawn).Spree > 4) )
	{
		EndSpree(Killer, Killed);
	}
	if ( (Killer != None) && Killer.bIsPlayer && (Killed != None) && Killed.bIsPlayer )
	{
		DamageType.static.IncrementKills(Killer);

		if ( !bFirstBlood && (Killer != Killed) && bEnemyKill )
		{
			bFirstBlood = True;
			// GBX:PAD: Getting rid of the FirstBloodMessage script
//			BroadcastLocalizedMessage( class'FirstBloodMessage', 0, Killer.PlayerReplicationInfo );
			SpecialEvent(Killer.PlayerReplicationInfo,"first_blood");
		}
		if ( (Killer != Killed)
			&& (!bTeamGame || (Killed.PlayerReplicationInfo.Team != Killer.PlayerReplicationInfo.Team))
			&& (gbxPawn(Killer.Pawn) != None) )
		{
			gbxPawn(Killer.Pawn).Spree++;
			if ( gbxPawn(Killer.Pawn).Spree > 4 )
				NotifySpree(Killer, gbxPawn(Killer.Pawn).Spree);
		}
	}
    Super.Killed(Killer, Killed, KilledPawn, damageType);
}

function AddGameSpecificInventory(Pawn p)
{
    // FIXME_MERGE if ( bAllowTrans )
    // FIXME_MERGE     p.CreateInventory("Weapons.TransLauncher");
    Super.AddGameSpecificInventory(p);
}

// Parse options for this game...
event InitGame( string Options, out string Error )
{
    local string InOpt;
    local bool bAutoNumBots;

    // find Level's LevelGameRules actor if it exists
    ForEach AllActors(class'LevelGameRules', LevelRules)
        break;
    if ( LevelRules != None )
		LevelRules.UpdateGame(self);

    Super.InitGame(Options, Error);

    SetGameSpeed(GameSpeed);
    MaxLives = Max(0,GetIntOption( Options, "MaxLives", MaxLives ));
    if ( MaxLives > 0 )
		bForceRespawn = true;
	else if ( DefaultMaxLives > 0 )
	{
		bForceRespawn = true;
		MaxLives = DefaultMaxLives;
	}
    GoalScore = Max(0,GetIntOption( Options, "GoalScore", GoalScore ));
    TimeLimit = Max(0,GetIntOption( Options, "TimeLimit", TimeLimit ));
    TimeLimit = 0; //SDJ 05/18/2004: No legacy time limit management please.
	if ( DefaultMaxLives > 0 )
		TimeLimit = 0;
	InOpt = ParseOption( Options, "Translocator");
    // For instant action, use map defaults
    if ( InOpt != "" )
    {
        log("Translocators: "$bool(InOpt));
        bAllowTrans = bool(InOpt);
    }
    InOpt = ParseOption( Options, "bAutoNumBots");
    if ( InOpt != "" )
    {
        log("bAutoNumBots: "$bool(InOpt));
        bAutoNumBots = bool(InOpt);
    }
    InOpt = ParseOption( Options, "AutoAdjust");
    if ( InOpt != "" )
    {
        bAdjustSkill = bool(InOpt);
        log("Adjust skill "$bAdjustSkill);
    }
    InOpt = ParseOption( Options, "PlayersMustBeReady");
    if ( InOpt != "" )
    {
    	log("PlayerMustBeReady: "$Bool(InOpt));
        bPlayersMustBeReady = bool(InOpt);
    }


	EnemyRosterName = ParseOption( Options, "DMTeam");

    if (bAutoNumBots)
    {
        MaxPlayers = Level.RecommendedNumPlayers;
        MinPlayers = Level.RecommendedNumPlayers;

        if ((MinPlayers & 1) == 1)
            MinPlayers++;

        if( MinPlayers < 2 )
            MinPlayers = 2;

		if ( bTeamgame && (MinPlayers < 4) )
			MinPlayers = 4;

        InitialBots = Max(0,MinPlayers - 1);
    }
    else
    {
        MinPlayers = Clamp(GetIntOption( Options, "MinPlayers", MinPlayers ),0,32);
        InitialBots = Clamp(GetIntOption( Options, "NumBots", InitialBots ),0,32);
    }

    RemainingTime = 60 * TimeLimit;

    InOpt = ParseOption( Options, "WeaponStay");
    if ( InOpt != "" )
    {
        log("WeaponStay: "$bool(InOpt));
        bWeaponStay = bool(InOpt);
    }

    bTournament = (GetIntOption( Options, "Tournament", 0 ) > 0);
    if ( bTournament )
        CheckReady();
    bWaitForNetPlayers = ( Level.NetMode != NM_StandAlone );

    InOpt = ParseOption(Options,"QuickStart");
    if ( InOpt != "" )
		bQuickStart = true;

    AdjustedDifficulty = GameDifficulty;
}

function Texture GetRandomTeamSymbol(int base)
{
    local string SymbolName;
    local int SymbolIndex;

    SymbolIndex = base + Rand(9);

// ZONER: TODO: Replace reference to TeamSymbtols_UT2003 texture to a wargame specific texture set
    if (SymbolIndex < 9)
        SymbolName = "TeamSymbols_UT2003.Sym0" $ SymbolIndex+1;
    else
        SymbolName = "TeamSymbols_UT2003.Sym" $ SymbolIndex+1;

    return Texture(DynamicLoadObject(SymbolName, class'Texture'));
}

/* AcceptInventory()
Examine the passed player's inventory, and accept or discard each item
* AcceptInventory needs to gracefully handle the case of some inventory
being accepted but other inventory not being accepted (such as the default
weapon).  There are several things that can go wrong: A weapon's
AmmoType not being accepted but the weapon being accepted -- the weapon
should be killed off. Or the player's selected inventory item, active
weapon, etc. not being accepted, leaving the player weaponless or leaving
the HUD inventory rendering messed up (AcceptInventory should pick another
applicable weapon/item as current).
*/
event AcceptInventory(pawn PlayerPawn, bool bAccept)
{
	if (!bAccept)
	{
		return;
	}

    while ( PlayerPawn.Inventory != None )
        PlayerPawn.Inventory.Destroy();

    PlayerPawn.Weapon = None;
    PlayerPawn.SelectedItem = None;
    AddDefaultInventory( PlayerPawn );
}

function bool CheckEndGame(PlayerReplicationInfo Winner, string Reason)
{
	local bool result;
	
	result = Super.CheckEndGame(Winner, Reason);

	if (result)
	{
		EndTime = Level.TimeSeconds + EndTimeDelay;
		GameReplicationInfo.Winner = Winner;
		GameReplicationInfo.WinReason = Reason;
	}

	return result;
}

event PlayerController Login
(
    string Portal,
    string Options,
    out string Error
)
{
    local PlayerController NewPlayer;
	local Controller C;

	if ( MaxLives > 0 )
	{
		// check that game isn't too far along
		for ( C=Level.ControllerList; C!=None; C=C.NextController )
		{
			if ( (C.PlayerReplicationInfo != None) && (C.PlayerReplicationInfo.NumLives > LateEntryLives) )
			{
				Options = "?SpectatorOnly=true"$Options;
				break;
			}
		}
	}

    NewPlayer = Super.Login(Portal,Options,Error);
    if ( bMustJoinBeforeStart && GameReplicationInfo.bMatchHasBegun )
        WargamePlayerController(NewPlayer).bLatecomer = true;

	if ( DefaultMaxLives == 1 )
	{
	    for ( C=Level.ControllerList; C!=None; C=C.NextController )
			if ( C.PlayerReplicationInfo.bOutOfLives )
			{
				NewPlayer.PlayerReplicationInfo.bOutOfLives = true;
				NewPlayer.PlayerReplicationInfo.NumLives = 1;
			}
	}

	if ( Level.NetMode == NM_Standalone )
	{
		if( NewPlayer.PlayerReplicationInfo.bOnlySpectator )
		{
			// Compensate for the space left for the player
			if ( !bCustomBots )
			InitialBots++;
		}
		else
			StandalonePlayer = NewPlayer;
	}

    return NewPlayer;
}

event PostLogin( playercontroller NewPlayer )
{
	local int iPlayerIndex;
	local bool bIsDedicatedInternetServer;

    Super.PostLogin(NewPlayer);
    WargamePlayerController(NewPlayer).PlayStartUpMessage(StartupStage);

	//log("LAPSUSX : Postlogin for " $ NewPlayer @ NewPlayer!=Level.GetLocalPlayerController());

	if (NewPlayer.IsA('gbxPlayerController'))
	{
		bIsDedicatedInternetServer = (Level.AuthMode != AM_SystemLink) && (Level.NetMode == NM_DedicatedServer);

		if ((class'GameService.GameService'.static.IsInLobby() || bIsDedicatedInternetServer) && NewPlayer!=Level.GetLocalPlayerController())
		{
			iPlayerIndex = m_aPlayersNeedingUbiComValidation.Length;
			m_aPlayersNeedingUbiComValidation[iPlayerIndex] = gbxPlayerController(NewPlayer);
			gbxPlayerController(NewPlayer).TimeOfUbiComValidationRequest = Level.TimeSeconds;
			gbxPlayerController(NewPlayer).RequestAuthIdFromClient();
			//log("LAPSUSX : Player added to the 'NEED AUTH' list | List.lenght " $ m_aPlayersNeedingUbiComValidation.Length );
		}
		else
		{
			gbxPlayerController(NewPlayer).TimeOfUbiComValidationRequest = 0;
		}
		
		if (NewPlayer == Level.GetLocalPlayerController())
		{
		    class'GameService.GameService'.static.GetUserName(NewPlayer.PlayerReplicationInfo.ubicomname);
		    //log("PUTAIN ! " $ NewPlayer.PlayerReplicationInfo.role @ NewPlayer.PlayerReplicationInfo.ubicomname);
        }
		    
	}
}

simulated event Tick(float Delta)
{
	local int i;
	local GameService.PLAYER_STATUS ePlayerStatus;
	local int iErrorType, iErrorNumber;
	local gbxPlayerController Ctrl;
	
	Super.Tick(Delta);
	

	
	for(i=0; i < m_aPlayersNeedingUbiComValidation.Length; i++)
	{
		if (m_aPlayersNeedingUbiComValidation[i] == None)
			continue;
		
		if (m_aPlayersNeedingUbiComValidation[i].TimeOfUbiComValidationRequest == -1)	
		{
			//Response from client has been received, ask ubi.com to validate his authorisation
			class'GameService.GameService'.static.MemberJoinServer(m_aPlayersNeedingUbiComValidation[i].StoredUbiComUserName,m_aPlayersNeedingUbiComValidation[i].StoredAutorizationID);
			m_aPlayersNeedingUbiComValidation[i].TimeOfUbiComValidationRequest = -2;
			//log("LAPSUSX : Player response received " $ m_aPlayersNeedingUbiComValidation[i]);
		}
		else if (m_aPlayersNeedingUbiComValidation[i].TimeOfUbiComValidationRequest == -2)	
		{
			//Waiting from reply from ubi.com about this player
			if (class'GameService.GameService'.static.MemberJoinServerIsFinished(m_aPlayersNeedingUbiComValidation[i].StoredAutorizationID))
			{
				//log("LAPSUSX : Ubi.com response received for " $ m_aPlayersNeedingUbiComValidation[i]);
				m_aPlayersNeedingUbiComValidation[i].TimeOfUbiComValidationRequest = -3;
				class'GameService.GameService'.static.MemberJoinServerGetResult(m_aPlayersNeedingUbiComValidation[i].StoredAutorizationID, ePlayerStatus, iErrorType, iErrorNumber);
				
				if (ePlayerStatus == E_GS_PLAYER_VALID)
				{
					//log("LAPSUSX : Ubi.com VALIDATED " $ m_aPlayersNeedingUbiComValidation[i]);
					//Player successfully validated, remove him from the need auth list
					m_aPlayersNeedingUbiComValidation[i].TimeOfUbiComValidationRequest = -4;
					m_aPlayersNeedingUbiComValidation.Remove(i,1);
				}
				else
				{
					/*
					//log("LAPSUSX : Ubi.com did NOT validate " $ m_aPlayersNeedingUbiComValidation[i]);
					log("          ePlayerStatus = " $ ePlayerStatus);
					log("          iErrorType    = " $ iErrorType);
					log("          iErrorNumber  = " $ iErrorNumber);
					*/
				}
			}
		}
		else if (m_aPlayersNeedingUbiComValidation[i].TimeOfUbiComValidationRequest == -3)	
		{
			//Response from ubi.com has been received and was negative
			//or the guy never sent his info
			//either way, kick this guy out

			Ctrl = m_aPlayersNeedingUbiComValidation[i];
			m_aPlayersNeedingUbiComValidation.Remove(i,1);
			Ctrl.NotifyClientOfKickout();
			if (NetConnection(Ctrl.Player) != None)
				Ctrl.Destroy();
		}
		else if (m_aPlayersNeedingUbiComValidation[i].TimeOfUbiComValidationRequest >=0 && 
		         m_aPlayersNeedingUbiComValidation[i].TimeOfUbiComValidationRequest + 90 < Level.TimeSeconds)
		{
			//Delay expired, flag him for kickout
			m_aPlayersNeedingUbiComValidation[i].TimeOfUbiComValidationRequest = -3;
		}
	}
}

function ChangeLoadOut(PlayerController P, string LoadoutName)
{
    local class<gbxPawn> NewLoadout;

    NewLoadout = class<gbxPawn>(DynamicLoadObject(LoadoutName,class'Class'));
    if ( (NewLoadout != None)
        && ((WargameTeamInfo(P.PlayerReplicationInfo.Team) == None) || WargameTeamInfo(P.PlayerReplicationInfo.Team).BelongsOnTeam(NewLoadout)) )
    {
        P.PawnClass = NewLoadout;
        if (P.Pawn!=None)
            P.ClientMessage("Your next class is "$P.PawnClass.Default.MenuName);
    }
}

function RestartPlayer( Controller aPlayer )
{
	//local float			cX, cY, cX2, cY2;

	log( self$ " WargameGameInfo::RestartPlayer() aPlayer: "$aPlayer, 'MP');

    if ( bMustJoinBeforeStart && (WargamePlayerController(aPlayer) != None)
        && WargamePlayerController(aPlayer).bLatecomer )
	{
        log( self$ " WargameGameInfo::RestartPlayer() return 1", 'MP');       
		return;
	}

    if ( aPlayer.PlayerReplicationInfo.bOutOfLives )
	{
        log( self$ " WargameGameInfo::RestartPlayer() return 2", 'MP');       
		return;
	}

    if ( aPlayer.IsA('Bot') && TooManyBots(aPlayer) )
    {
		log( self$ " WargameGameInfo::RestartPlayer() return 3", 'MP');       
		aPlayer.Destroy();
        return;
    }


	Super.RestartPlayer(aPlayer);

	// remove the deathcam effect on respawn
	if( aPlayer.Pawn.IsHumanControlled() && gbxPlayerPawn(aPlayer.Pawn) != None )
	{
		gbxPlayerPawn(aPlayer.Pawn).DisableDeathView();
	}

	if ( (aPlayer.Pawn != None) && (gbxPlayerStart(aPlayer.Pawn.LastStartSpot) != None) && (Infantry(aPlayer.Pawn).TriggerOnDeath == '') )
		Infantry(aPlayer.Pawn).TriggerOnDeath = gbxPlayerStart(aPlayer.Pawn.LastStartSpot).TriggerOnDeath;
}

function ForceAddBot()
{
    // add bot during gameplay
    if ( Level.NetMode != NM_Standalone )
        MinPlayers = Max(MinPlayers+1, NumPlayers + NumBots + 1);
    AddBot();
}

function bool AddBot(optional string botName)
{
    return true;
}

function AddDefaultInventory( pawn PlayerPawn )
{
    if ( gbxPawn(PlayerPawn) != None )
        gbxPawn(PlayerPawn).AddDefaultInventory();
    SetPlayerDefaults(PlayerPawn);
}

function bool CanSpectate( PlayerController Viewer, bool bOnlySpectator, actor ViewTarget )
{
    if ( ViewTarget == None )
        return false;
	if ( Controller(ViewTarget) != None )
		return ( (Controller(ViewTarget).PlayerReplicationInfo != None)
				&& !Controller(ViewTarget).PlayerReplicationInfo.bOnlySpectator );
    return ( (Level.NetMode == NM_Standalone) || bOnlySpectator );
}

function bool ShouldRespawn(Pickup Other)
{
//	return false;
// GBX:PAD: For now I don't see Wargame having weapon respawn and announcers, but just in case this code is still
// here but commented out
   return ( Other.ReSpawnTime!=0.0 );
}

function string GetUniquePlayerName(Controller Other, string inName)
{
	local int index;
	local string result;
    local Controller APlayer;
	local bool bChanged;

	index = 1;
	result = inName;

	do
	{
		bChanged = false;

		for( APlayer=Level.ControllerList; APlayer!=None; APlayer=APlayer.nextController )
		{
			if ( APlayer.bIsPlayer && (Other != APlayer) && (APlayer.PlayerReplicationInfo.playername ~= result) )
			{
				bChanged = true;
				result = "(" $index $")";
				result = Left(inName, 15-Len(result)) $ result;
				index++;
				break;
			}
		}

		log("result=" $result);
	} until(!bChanged);

	return result;
}

function ChangeName(Controller Other, string S, bool bNameChange)
{
    local Controller APlayer,C;

    if ( S == "" )
        return;

	log("ChangeName" @other @S);
    if (Other.PlayerReplicationInfo.playername~=S)
        return;

	S = Left(S,20);
    ReplaceText(S, " ", "_");

    for( APlayer=Level.ControllerList; APlayer!=None; APlayer=APlayer.nextController )
        if ( APlayer.bIsPlayer && (Other != APlayer) && (APlayer.PlayerReplicationInfo.playername~=S) )
        {
            if ( Other.IsA('PlayerController') )
            {
				S = GetUniquePlayerName(Other, S);
				log("ChangeName duplicate name changed to" @S);
//                PlayerController(Other).ReceiveLocalizedMessage( GameMessageClass, 8 );
				break;
			}
            else
            {
                S = NamePrefixes[NameNumber%10]$S$NameSuffixes[NameNumber%10];
                NameNumber++;
                break;
            }
        }

	if( bNameChange )
		GameEvent("NameChange",s,Other.PlayerReplicationInfo);

    Other.PlayerReplicationInfo.SetPlayerName(S);
    // notify local players
    if  ( bNameChange )
		for ( C=Level.ControllerList; C!=None; C=C.NextController )
			if ( (PlayerController(C) != None) && (Viewport(PlayerController(C).Player) != None) )
				PlayerController(C).ReceiveLocalizedMessage( class'GameMessage', 2, Other.PlayerReplicationInfo );
}

function Logout(controller Exiting)
{
    Super.Logout(Exiting);
    if ( Exiting.IsA('Bot') )
        NumBots--;
    if ( !bKillBots )
		RemainingBots++;
    if ( !NeedPlayers() || AddBot() )
        RemainingBots--;
    if ( MaxLives > 0 )
         CheckMaxLives(none);
	
	if(Exiting.IsA('gbxPlayerController') && gbxPlayerController(Exiting).TimeOfUbiComValidationRequest < 0 && Exiting != Level.GetLocalPlayerController())
	{
		//If we wanted to check that player actually successfully validated, just check TimeOfUbiComValidationRequest == -4
		//log("LAPSUSX : Logout for " $ Exiting);
		class'GameService.GameService'.static.MemberLeaveServer(gbxPlayerController(Exiting).StoredUbiComUserName, gbxPlayerController(Exiting).StoredAutorizationID);
	}
}

function bool NeedPlayers()
{
    if ( Level.NetMode == NM_Standalone )
        return ( RemainingBots > 0 );
    if ( bMustJoinBeforeStart )
        return false;
    return (NumPlayers + NumBots < MinPlayers);
}

//------------------------------------------------------------------------------
// Game Querying.

function GetServerDetails( out ServerResponseLine ServerState )
{
	local int i;

	Super.GetServerDetails( ServerState );

	i = ServerState.ServerInfo.Length;

	// goalscore
	ServerState.ServerInfo.Length = i+1;
	ServerState.ServerInfo[i].Key = "goalscore";
	ServerState.ServerInfo[i++].Value = string(GoalScore);

	// timelimit
	ServerState.ServerInfo.Length = i+1;
	ServerState.ServerInfo[i].Key = "timelimit";
	ServerState.ServerInfo[i++].Value = string(TimeLimit);

	// minplayers
	ServerState.ServerInfo.Length = i+1;
	ServerState.ServerInfo[i].Key = "minplayers";
	ServerState.ServerInfo[i++].Value = string(MinPlayers);

	// translocator
	ServerState.ServerInfo.Length = i+1;
	ServerState.ServerInfo[i].Key = "translocator";
	if( bAllowTrans )
		ServerState.ServerInfo[i++].Value = "true";
	else
		ServerState.ServerInfo[i++].Value = "false";

	// weaponstay
	ServerState.ServerInfo.Length = i+1;
	ServerState.ServerInfo[i].Key = "weaponstay";
	if( bWeaponStay )
		ServerState.ServerInfo[i++].Value = "true";
	else
		ServerState.ServerInfo[i++].Value = "false";
}

function InitGameReplicationInfo()
{
    Super.InitGameReplicationInfo();
    GameReplicationInfo.GoalScore = GoalScore;
    GameReplicationInfo.TimeLimit = TimeLimit;
}

function InitTeamSymbols()
{
    // default team textures (for banners, etc.)
//    if ( GameReplicationInfo.Teams[0].TeamIcon == None )
//		GameReplicationInfo.Teams[0].TeamIcon = GetRandomTeamSymbol(1);
//    if ( GameReplicationInfo.Teams[1].TeamIcon == None )
//		GameReplicationInfo.Teams[1].TeamIcon = GetRandomTeamSymbol(10);
	GameReplicationInfo.TeamSymbolNotify();
}

//------------------------------------------------------------------------------

function WargameTeamInfo GetBotTeam(optional int TeamBots)
{
	local class<WargameTeamInfo> RosterClass;

	if ( EnemyRoster != None )
		return EnemyRoster;

	if ( EnemyRosterName != "" )
	{
		RosterClass = class<WargameTeamInfo>(DynamicLoadObject(EnemyRosterName,class'Class'));
		if ( RosterClass != None)
			EnemyRoster = spawn(RosterClass);
	}
    if ( EnemyRoster == None )
    {
		RosterClass = class<WargameTeamInfo>(DynamicLoadObject(DefaultEnemyRosterClass,class'Class'));
		if ( RosterClass != None)
			EnemyRoster = spawn(RosterClass);
	}
	EnemyRoster.Initialize(TeamBots);
	return EnemyRoster;
}

function PreLoadNamedBot(string BotName)
{
	EnemyRoster.AddNamedBot(BotName);
}

function PreLoadBot()
{
	EnemyRoster.AddRandomPlayer();
}

/* initialize a bot which is associated with a pawn placed in the level
*/
function InitPlacedBot(Controller C, WargameRosterEntry R)
{
}

function WargameTeamInfo FindTeamFor(Controller C)
{
    return GetBotTeam();
}

simulated function PostLoadGame()
{
	Super.PostLoadGame();

	if ( CSSCache == None )
	{
		CSSCache = new( None ) class'SeeAndSuppressCache';
		SeeAndSuppressCache( CSSCache ).Initialize();
	}
}

//------------------------------------------------------------------------------
// Game States

function StartMatch()
{
    local bool bTemp;
	local int Num;

	if( CSSCache == None )
	{
		// Create the Suppression Cache and attach it to the interface pointer.
		CSSCache = new( None ) class'SeeAndSuppressCache'; // GBX:naj - modified 3/11/04
		SeeAndSuppressCache(CSSCache).Initialize();
	}

    GotoState('MatchInProgress');
    if ( Level.NetMode == NM_Standalone )
        RemainingBots = InitialBots;
    else
        RemainingBots = 0;
    GameReplicationInfo.RemainingMinute = RemainingTime;
    Super.StartMatch();
    bTemp = bMustJoinBeforeStart;
    bMustJoinBeforeStart = false;
    while ( NeedPlayers() && (Num<16) )
    {
		if ( AddBot() )
			RemainingBots--;
		Num++;
    }
    bMustJoinBeforeStart = bTemp;
    log("START MATCH");
}

function EndGame(PlayerReplicationInfo Winner, string Reason )
{
    Super.EndGame(Winner, Reason);
    if ( bGameEnded )
        GotoState('MatchOver');
}

/* FindPlayerStart()
returns the 'best' player start for this player to start from.
*/
function NavigationPoint FindPlayerStart(Controller Player, optional byte InTeam, optional string incomingName)
{
    local NavigationPoint Best;

    if ( (Player != None) && (Player.StartSpot != None) )
        LastPlayerStartSpot = Player.StartSpot;

    Best = Super.FindPlayerStart(Player, InTeam, incomingName );
    if ( Best != None )
        LastStartSpot = Best;
    return Best;
}

function PlayEndOfMatchMessage()
{
	//DHW + No longer used
	//local controller C;

 //   if ( (PlayerReplicationInfo(GameReplicationInfo.Winner).Deaths == 0)
	//	&& (PlayerReplicationInfo(GameReplicationInfo.Winner).Score >= 5) )
 //   {
	//	for ( C = Level.ControllerList; C != None; C = C.NextController )
	//	{
	//		if ( C.IsA('PlayerController') )
	//		{
	//			if ( (C.PlayerReplicationInfo == GameReplicationInfo.Winner) || C.PlayerReplicationInfo.bOnlySpectator )
	//				PlayerController(C).PlayAnnouncement(AltEndGameSound[0],1,true);
	//			else
	//				PlayerController(C).PlayAnnouncement(AltEndGameSound[1],1,true);
	//		}
	//	}
	//}
 //   else
 //   {
	//	for ( C = Level.ControllerList; C != None; C = C.NextController )
	//	{
	//		if ( C.IsA('PlayerController') && !C.PlayerReplicationInfo.bOnlySpectator )
	//		{
	//			if (C.PlayerReplicationInfo == GameReplicationInfo.Winner)
	//				PlayerController(C).PlayAnnouncement(EndGameSound[0],1,true);
	//			else
	//				PlayerController(C).PlayAnnouncement(EndGameSound[1],1,true);
	//		}
	//	}
	//}
	//DHW -
}

function PlayStartupMessage()
{
	local Controller P;

    // keep message displayed for waiting players
    for (P=Level.ControllerList; P!=None; P=P.NextController )
        if ( WargamePlayerController(P) != None )
            WargamePlayerController(P).PlayStartUpMessage(StartupStage);
}

auto State PendingMatch
{
	function RestartPlayer( Controller aPlayer )
	{
		if ( CountDown <= 0 )
			Super.RestartPlayer(aPlayer);
	}

    function bool AddBot(optional string botName)
    {
        if ( Level.NetMode == NM_Standalone )
            InitialBots++;
        if ( botName != "" )
			PreLoadNamedBot(botName);
		else
        PreLoadBot();
        return true;
    }

    function Timer()
    {
        local Controller P;
        local bool bReady;

        Global.Timer();

        // first check if there are enough net players, and enough time has elapsed to give people
        // a chance to join
        if ( NumPlayers == 0 )
			bWaitForNetPlayers = true;
        if ( bWaitForNetPlayers && (Level.NetMode != NM_Standalone) )
        {
             if ( NumPlayers > 0 )
                ElapsedTime++;
            else
                ElapsedTime = 0;
            if ( (NumPlayers == MaxPlayers)
                || ((ElapsedTime > NetWait) && (NumPlayers >= MinNetPlayers)) )
            {
                bWaitForNetPlayers = false;
                CountDown = Default.CountDown;
            }
        }

        if ( (Level.NetMode != NM_Standalone) && (bWaitForNetPlayers || (bTournament && (NumPlayers < MaxPlayers))) )
        {
       		PlayStartupMessage();
            return;
		}

		// check if players are ready
        bReady = true;
        StartupStage = 1;
        if ( !bStartedCountDown && (bTournament || bPlayersMustBeReady || (Level.NetMode == NM_Standalone)) )
        {
            for (P=Level.ControllerList; P!=None; P=P.NextController )
                if ( P.IsA('PlayerController') && (P.PlayerReplicationInfo != None)
                    && P.bIsPlayer && P.PlayerReplicationInfo.bWaitingPlayer
                    && !P.PlayerReplicationInfo.bReadyToPlay )
                    bReady = false;
        }
        if ( bReady )
        {
			bStartedCountDown = true;
            CountDown--;
            if ( CountDown <= 0 )
                StartMatch();
            else
                StartupStage = 5 - CountDown;
        }
		PlayStartupMessage();
    }

    function beginstate()
    {
		bWaitingToStartMatch = true;
        StartupStage = 0;
    }

Begin:
	if ( bQuickStart )
		StartMatch();
}

State MatchInProgress
{
    function Timer()
    {
        local Controller P;

        Global.Timer();
		if ( !bFinalStartup )
		{
			bFinalStartup = true;
			PlayStartupMessage();
		}
        if ( bForceRespawn )
            For ( P=Level.ControllerList; P!=None; P=P.NextController )
            {
                if ( (P.Pawn == None) && P.IsA('PlayerController') && !P.PlayerReplicationInfo.bOnlySpectator )
                    PlayerController(P).ServerReStartPlayer();
            }
        if ( NeedPlayers() && AddBot() && (RemainingBots > 0) )
			RemainingBots--;

        if ( bOverTime )
			EndGame(None,"TimeLimit");
        else if ( TimeLimit > 0 )
        {
            GameReplicationInfo.bStopCountDown = false;
            RemainingTime--;
            GameReplicationInfo.RemainingTime = RemainingTime;
            if ( RemainingTime % 60 == 0 )
                GameReplicationInfo.RemainingMinute = RemainingTime;
            if ( RemainingTime <= 0 )
                EndGame(None,"TimeLimit");
        }
        else if ( (MaxLives > 0) && (NumPlayers + NumBots != 1) )
			CheckMaxLives(none);

        ElapsedTime++;
        GameReplicationInfo.ElapsedTime = ElapsedTime;
    }

    function beginstate()
    {
		local PlayerReplicationInfo PRI;

		ForEach DynamicActors(class'PlayerReplicationInfo',PRI)
			PRI.StartTime = 0;
		ElapsedTime = 0;
		bWaitingToStartMatch = false;
        StartupStage = 5;
        PlayStartupMessage();
        StartupStage = 6;
    }
}

State MatchOver
{
	function RestartPlayer( Controller aPlayer ) {}
	function ScoreKill(Controller Killer, Controller Other) {}
	function int ReduceDamage( int Damage, pawn injured, pawn instigatedBy, vector HitLocation, out vector Momentum, class<DamageType> DamageType )
	{
		return 0;
	}

	function bool ChangeTeam(Controller Other, int num, bool bNewTeam)
	{
		return false;
	}

    function Timer()
    {
        Global.Timer();

        if ( !bGameRestarted && (Level.TimeSeconds > EndTime + RestartWait) )
            RestartGame();

         // play end-of-match message for winner/losers (for single and muli-player)
        EndMessageCounter++;
        if ( EndMessageCounter == EndMessageWait )
	         PlayEndOfMatchMessage();
	}


    function bool NeedPlayers()
    {
        return false;
    }

    function BeginState()
    {
		GameReplicationInfo.bStopCountDown = true;
	}
}

/* Rate whether player should choose this NavigationPoint as its start
*/
function float RatePlayerStart(NavigationPoint N, byte Team, Controller Player, int nCheckpointID)
{
    local PlayerStart P;
    local float Score, NextDist;
    local Controller OtherPlayer;

    P = PlayerStart(N);

    if ( (P == None) || !P.bEnabled || P.PhysicsVolume.bWaterVolume )
        return -10000000;

    //assess candidate
    if ( P.bPrimaryStart )
		Score = 10000000;
	else
		Score = 5000000;
    if ( (N == LastStartSpot) || (N == LastPlayerStartSpot) )
        Score -= 10000.0;
    else
        Score += 3000 * FRand(); //randomize

	if ( Level.TimeSeconds - P.LastSpawnCampTime < 30 )
		Score = Score - (30 - P.LastSpawnCampTime + Level.TimeSeconds) * 1000;

    for ( OtherPlayer=Level.ControllerList; OtherPlayer!=None; OtherPlayer=OtherPlayer.NextController)
        if ( OtherPlayer.bIsPlayer && (OtherPlayer.Pawn != None) )
        {
            if ( OtherPlayer.Pawn.Region.Zone == N.Region.Zone )
                Score -= 1500;
            NextDist = VSize(OtherPlayer.Pawn.Location - N.Location);
            if ( NextDist < OtherPlayer.Pawn.CollisionRadius + OtherPlayer.Pawn.CollisionHeight )
                Score -= 1000000.0;
            else if ( (NextDist < 3000) && FastTrace(N.Location, OtherPlayer.Pawn.Location) )
                Score -= (10000.0 - NextDist);
            else if ( NumPlayers + NumBots == 2 )
            {
                Score += 2 * VSize(OtherPlayer.Pawn.Location - N.Location);
                if ( FastTrace(N.Location, OtherPlayer.Pawn.Location) )
                    Score -= 10000;
            }
        }
    return FMax(Score, 5);
}

// check if all other players are out
function bool CheckMaxLives(PlayerReplicationInfo Scorer)
{
    local Controller C;
    local PlayerReplicationInfo Living;
    local bool bNoneLeft;

    if ( MaxLives > 0 )
    {
		if ( (Scorer != None) && !Scorer.bOutOfLives )
			Living = Scorer;
        bNoneLeft = true;
        for ( C=Level.ControllerList; C!=None; C=C.NextController )
            if ( (C.PlayerReplicationInfo != None) && C.bIsPlayer
                && !C.PlayerReplicationInfo.bOutOfLives
                && !C.PlayerReplicationInfo.bOnlySpectator )
            {
				if ( Living == None )
					Living = C.PlayerReplicationInfo;
				else if (C.PlayerReplicationInfo != Living)
			   	{
    	        	bNoneLeft = false;
	            	break;
				}
            }
        if ( bNoneLeft )
        {
			if ( Living != None )
				EndGame(Living,"LastMan");
			else
				EndGame(Scorer,"LastMan");
			return true;
		}
    }
    return false;
}

/* CheckScore()
see if this score means the game ends
*/
function CheckScore(PlayerReplicationInfo Scorer)
{
	local controller C;

	if ( CheckMaxLives(Scorer) )
		return;

    if ( (GameRulesModifiers != None) && GameRulesModifiers.CheckScore(Scorer) )
        return;

	if ( Scorer != None )
	{
		if ( (GoalScore > 0) && (Scorer.Score >= GoalScore) )
        EndGame(Scorer,"fraglimit");
		else if ( bOverTime )
		{
			// end game only if scorer has highest score
			for ( C=Level.ControllerList; C!=None; C=C.NextController )
				if ( (C.PlayerReplicationInfo != None)
					&& (C.PlayerReplicationInfo != Scorer)
					&& (C.PlayerReplicationInfo.Score >= Scorer.Score) )
					return;
        	EndGame(Scorer,"fraglimit");
		}
	}
}

function ScoreObjective(PlayerReplicationInfo Scorer, Int Score)
{
    if ( Scorer != None )
    {
        Scorer.Score += Score;
		ScoreEvent(Scorer,Score,"ObjectiveScore");
    }

    if ( GameRulesModifiers != None )
        GameRulesModifiers.ScoreObjective(Scorer,Score);
    CheckScore(Scorer);
}

function ScoreKill(Controller Killer, Controller Other)
{
	local PlayerReplicationInfo OtherPRI;

	OtherPRI = Other.PlayerReplicationInfo;
    if ( OtherPRI != None )
    {
        //OtherPRI.NumLives++; //SDJ 05/18/2004: We don't want this behavior.
        if ( (MaxLives > 0) && (OtherPRI.NumLives >=MaxLives) )
            OtherPRI.bOutOfLives = true;
    }

    Super.ScoreKill(Killer,Other);

    if ( (killer == None) || (Other == None) )
        return;

    if ( bAdjustSkill && (killer.IsA('PlayerController') || Other.IsA('PlayerController')) )
    {
        if ( killer.IsA('AIController') )
            AdjustSkill(AIController(killer), PlayerController(Other),true);
        if ( Other.IsA('AIController') )
            AdjustSkill(AIController(Other), PlayerController(Killer),false);
    }
}

function AdjustSkill(AIController B, PlayerController P, bool bWinner)
{
    if ( bWinner )
    {
        PlayerKills += 1;
        AdjustedDifficulty = FMax(0, AdjustedDifficulty - 2.0/FMin(PlayerKills, 10.0));
        if ( B.Skill > AdjustedDifficulty )
        {
            B.Skill = AdjustedDifficulty;
        }
    }
    else
    {
        PlayerDeaths += 1;
        AdjustedDifficulty = FMin(7.0,AdjustedDifficulty + 2.0/FMin(PlayerDeaths, 10.0));
        if ( B.Skill < AdjustedDifficulty )
            B.Skill = AdjustedDifficulty;
    }
    if ( abs(AdjustedDifficulty - GameDifficulty) >= 1 )
    {
        GameDifficulty = AdjustedDifficulty;
        SaveConfig();
    }
}

// GBX:naj - This function replaces a much larger behemoth from the original Unreal code.  The motivation for replacing it was 
// to force the game to work with our homegrown difficulty and skill systems.
function int ReduceDamage( int Damage, pawn injured, pawn instigatedBy, vector HitLocation, out vector Momentum, class<DamageType> DamageType )
{
	if ( injured.InGodMode() ) // God mode
		return 0;

	if( injured.InDemigodMode() )
	{
		// A pawn in Demigod mode can take damage, but never enough to kill him.
		Damage = Min( Damage, injured.Health - 1 );
	}

	// rss: hook to allow mod authors to have their GameRules take affect
	if ( GameRulesModifiers != None )
		return GameRulesModifiers.NetDamage( Damage, Damage,injured,instigatedBy,HitLocation,Momentum,DamageType );

	// If we are using urban cover, then the guy is at a 3/4 height when "standing" from behind cover, so lop off
	// any collision with the top of the cylinder in this case.
	if ((Level.BaseUnitSkillLevel > SKILL_Intermediate) && gbxPawn(injured).m_bUsingCrouchedCover && !injured.bIsCrouched)
	{
		if (Level.NetMode == NM_StandAlone)
		{
			if (HitLocation.Z > ((injured.CollisionHeight / 4) * 3))
			{
				Damage = 0;
			}
		}
	}
	
	return Level.DifficultyManager.AdjustDamage( Damage, injured, DamageType );
}

// Add one or num bots
function AddNamedBot(string botname)
{
    if (Level.NetMode != NM_Standalone)
        MinPlayers = Max(MinPlayers + 1, NumPlayers + NumBots + 1);
    AddBot(botName);
}

function AddBots(int num)
{
    num = Clamp(num, 0, 32 - (NumPlayers + NumBots));

    while (--num >= 0)
    {
        if ( Level.NetMode != NM_Standalone )
            MinPlayers = Max(MinPlayers + 1, NumPlayers + NumBots + 1);
        AddBot();
    }
}

// Kill all or num bots
function KillBots(int num)
{
    local Controller c, nextC;

    if (num == 0)
        num = NumBots;

    c = Level.ControllerList;
    if ( Level.NetMode != NM_Standalone )
		MinPlayers = 0;
    bKillBots = true;
    while (c != None && num > 0)
    {
        nextC = c.NextController;
        if (KillBot(c))
            --num;
        c = nextC;
    }
    bKillBots = false;
}

function bool KillBot(Controller c)
{
    return true;
}

function ReviewJumpSpots(name TestLabel)
{
}

function NotifySpree(Controller Other, int num)
{
//	local Controller C;

	if ( num == 5 )
		num = 0;
	else if ( num == 10 )
		num = 1;
	else if ( num == 15 )
		num = 2;
	else if ( num == 20 )
		num = 3;
	else if ( num == 25 )
		num = 4;
	else if ( num == 30 )
		num = 5;
	else
		return;

	SpecialEvent(Other.PlayerReplicationInfo,"spree_"$(num+1));

// GBX:PAD: Getting rid of the KillingSpreeMessage script
//	for ( C=Level.ControllerList; C!=None; C=C.NextController )
//		if ( PlayerController(C) != None )
//			PlayerController(C).ReceiveLocalizedMessage( class'KillingSpreeMessage', Num, Other.PlayerReplicationInfo );
}

function EndSpree(Controller Killer, Controller Other)
{
//	local Controller C;

	if ( (Other == None) || !Other.bIsPlayer )
		return;
// GBX:PAD: Getting rid of the KillingSpreeMessage script
//	for ( C=Level.ControllerList; C!=None; C=C.NextController )
//		if ( PlayerController(C) != None )
//		{
//			if ( (Killer == Other) || (Killer == None) || !Killer.bIsPlayer )
//				PlayerController(C).ReceiveLocalizedMessage( class'KillingSpreeMessage', 1, None, Other.PlayerReplicationInfo );
//			else
//				PlayerController(C).ReceiveLocalizedMessage( class'KillingSpreeMessage', 0, Other.PlayerReplicationInfo, Killer.PlayerReplicationInfo );
//		}
}

// This was added to help with clean integration of new skirmish mode.
// This function replaces Pawn.IsA('InfantryUSA') thus the strange condition.
function bool IsPawnOnSameTeamAsPlayer(Pawn p)
{
	local bool bSame;
	//Log( " WargameMultiplayer::IsPawnOnSameTeamAsPlayer()", 'MP' );

	if ( p != None )
	{
		if ( p.IsA( 'InfantryUSA' ) )
			bSame = true;
	}

	//Log( " WargameMultiplayer::IsPawnOnSameTeamAsPlayer() bSame="$bSame, 'MP' );

	return bSame;
}

function bool IsPawnOnSameTeamAsPlayerByEnum(ETeamIdentifier team)
{
	local bool bSame;
	//Log( " WargameGameInfo::IsPawnOnSameTeamAsPlayerByEnum()", 'MP' );

	if ( team == TEAM_US )
		bSame = true;

	//Log( " WargameGameInfo::IsPawnOnSameTeamAsPlayerByEnum() bSame="$bSame, 'MP' );

	return bSame;
}

defaultproperties
{
	bWeaponStay=false
    NumRounds=1
    GoalScore=25
    bLoggingGame=true
    bTournament=false
    CountDown=4
    GameName="WargameGameInfo"
    InitialBots=0
    bRestartLevel=False
    bPauseable=False
    bPlayersMustBeReady=false
    AutoAim=1.000000
    MapPrefix="DM"
    BeaconName="DM"
    MaxPlayers=32
    NetWait=2
    RestartWait=30
    bDelayedStart=false
    // GBX:PAD: Getting rid of this class, so lets make it more generic for now.
//    MutatorClass="UnrealGame.DMMutator"
	MutatorClass="Engine.Mutator"
    MinNetPlayers=1
    bWaitForNetPlayers=true
    SpawnProtectionTime=+2.0
    DefaultPlayerClassName="gbxGameplay.gbxPlayerPawn"
    PlayerControllerClassName="gbxGameplay.WargamePlayerController"
    EndMessageWait=2

    HUDType="gbxHUD.WargameHUD"
    ScoreBoardType="gbxGameplay.WargameScoreboard"

    NamePrefixes(0)="Mr_"
    NamePrefixes(1)=""
    NamePrefixes(2)="The_Real_"
    NamePrefixes(3)="Evil_"
    NamePrefixes(4)=""
    NamePrefixes(5)="Owns_"
    NamePrefixes(6)=""
    NamePrefixes(7)="Evil_"

    NameSuffixes(0)=""
    NameSuffixes(1)="_is_lame"
    NameSuffixes(2)=""
    NameSuffixes(3)=""
    NameSuffixes(4)="_sucks"
    NameSuffixes(5)=""
    NameSuffixes(6)="_OwnsYou"
    NameSuffixes(7)=""
	NameSuffixes(8)="_jr"
	NameSuffixes(9)="'s_clone"

    DMPropsDisplayText(0)="Net Start Delay"
    DMPropsDisplayText(1)="Min. Net Players"
    DMPropsDisplayText(2)="Restart Delay"
    DMPropsDisplayText(3)="Tournament Game"
    DMPropsDisplayText(4)="Players Must Be Ready"
    DMPropsDisplayText(5)="Force Respawn"
    DMPropsDisplayText(6)="Adjust Bots Skill"
    DMPropsDisplayText(8)="Spawn Protection Time"
    DMPropsDisplayText(9)="Allow Translocator"

//    EndGameSound[0]=Sound'AnnouncerMain.You_Have_Won_the_Match'
//    EndGameSound[1]=Sound'AnnouncerMain.You_Have_Lost_the_Match'
//    AltEndGameSound[0]=Sound'AnnouncerMain.Flawless_victory'
//    AltEndGameSound[1]=Sound'AnnouncerMain.Humiliating_defeat'

    ADR_Kill=5.0
    ADR_MajorKill=10.0
    ADR_MinorError=-2.0
    ADR_MinorBonus=5.0
    ADR_KillTeamMate=-5.0

    LateEntryLives=1

	DestroyDeadBodyTimer = 10;
	bDestroyVisibleDeadBodies = true;

	FriendlyFireScale=1.0
}

//=============================================================================
// WargameMPGameInfo.
//
//
//=============================================================================
class WargameMPGameInfo extends GameInfo
	config;



var globalconfig int  MinPlayers;		// bots fill in to guarantee this level in net game

var config bool bTeamScoreRounds;
var bool	bSoaking;

var float EndTime;
var globalconfig float EndTimeDelay;
var class<Scoreboard> LocalStatsScreenClass;

// mc - localized PlayInfo descriptions & extra info
var private localized string MPGIPropsDisplayText[3];

function SpecialEvent(PlayerReplicationInfo Who, string Desc)
{
	if ( GameStats != None )
		GameStats.SpecialEvent(Who,Desc);
}

function KillEvent(string Killtype, PlayerReplicationInfo Killer, PlayerReplicationInfo Victim, class<DamageType> Damage)
{
	local TeamPlayerReplicationInfo TPRI;

	if ( (Killer == None) || (Killer == Victim) )
		TeamPlayerReplicationInfo(Victim).Suicides++;

	TPRI = TeamPlayerReplicationInfo(Killer);

	if ( TPRI != None )
	{
		if ( TPRI != Victim )
			TPRI.AddWeaponKill(Damage);
		TeamPlayerReplicationInfo(Victim).AddWeaponDeath(Damage);
	}

	if ( GameStats != None )
		GameStats.KillEvent(KillType, Killer, Victim, Damage);
}

function GameEvent(string GEvent, string Desc, PlayerReplicationInfo Who)
{
	local TeamPlayerReplicationInfo TPRI;

	if ( GameStats != None )
		GameStats.GameEvent(GEvent, Desc, Who);

	TPRI = TeamPlayerReplicationInfo(Who);

	if ( TPRI == None )
		return;

	if ( (GEvent ~= "flag_taken") || (GEvent ~= "flag_pickup")
		|| (GEvent ~= "bomb_taken") || (GEvent ~= "Bomb_pickup") )
	{
		TPRI.FlagTouches++;
		return;
	}

	if ( GEvent ~= "flag_returned" )
	{
		TPRI.FlagReturns++;
		return;
	}
}

function ScoreEvent(PlayerReplicationInfo Who, float Points, string Desc)
{
	if ( (GameStats != None) && (Who != None) )
		GameStats.ScoreEvent(Who,Points,Desc);
}

function TeamScoreEvent(int Team, float Points, string Desc)
{
	if ( GameStats != None )
		GameStats.TeamScoreEvent(Team,Points,Desc);
}

function int GetNumPlayers()
{
	if ( NumPlayers > 0 )
		return (NumPlayers+NumBots);
	return Min(MinPlayers,MaxPlayers/2);
}

function bool ShouldRespawn(Pickup Other)
{
	return false;
}

function float SpawnWait(AIController B)
{
	if ( B.PlayerReplicationInfo.bOutOfLives )
		return 999;
	if ( Level.NetMode == NM_Standalone )
		return ( 0.5 * FMax(2,NumBots-4) * FRand() );
	return FRand();
}

function bool TooManyBots(Controller botToRemove)
{
	return ( (Level.NetMode != NM_Standalone) && (NumBots + NumPlayers > MinPlayers) );
}

function RestartGame()
{
	if ( EndTime > Level.TimeSeconds ) // still showing end screen
		return;

	Super.RestartGame();
}

function ChangeLoadOut(PlayerController P, string LoadoutName);
function ForceAddBot();

/* only allow pickups if they are in the pawns loadout
*/
function bool PickupQuery( Pawn Other, Pickup item )
{
	local byte bAllowPickup;
	local int i;
	local bool fReturn;

	if ( (GameRulesModifiers != None) && GameRulesModifiers.OverridePickupQuery(Other, item, bAllowPickup) )
		return (bAllowPickup == 1);

	// GBX:PAD: If we're in limited mode, don't show a weapon or pick one up.
	if (WargamePlayerController(Other.Controller) != None)
		if (WargamePlayerController(Other.Controller).bLimitedMode)
			return false;

	if (gbxWeaponPickup(item) != None)
		if (!gbxWeaponPickup(item).CheckIfPickupValid( Other ))
			return false;

	if ( Other.Inventory == None )
	{
		return true;
	}
	else if ( bWeaponStay && Weapon(Other.FindInventoryType(item.InventoryType) ) != none) // SJP: Don't allow a second pickup if you've already got the weapon and weapon stay is on
	{
		return false;
	}
	else
	{
		fReturn = Other.Inventory.HandlePickupQuery(Item);
		if (!fReturn && (gbxPawn(Other) != None))
		{
			for( i = 0; (i < 4) && !fReturn; i++ )
			{
				if (gbxPawn(Other).SecondaryInventory[i] != None)
					fReturn = gbxPawn(Other).SecondaryInventory[i].HandlePickupQuery(Item);
			}
		}

		return !fReturn;
	}
}

//
// Restart a player.
//
function RestartPlayer( Controller aPlayer )
{
	log( self$ " WargameMPGameInfo::RestartPlayer() aPlayer: "$aPlayer$ " aPlayer.Pawn.LastStartSpot: " $aPlayer.Pawn.LastStartSpot, 'MP');
	
	Super.RestartPlayer( aPlayer );

	if (gbxPlayerStart(aPlayer.Pawn.LastStartSpot) != None)
		gbxPlayerStart(aPlayer.Pawn.LastStartSpot).AddDefaultInventory( aPlayer.Pawn );
	else
	{
		gbxPawn(aPlayer.Pawn).RequiredEquipment[0] = "gbxInventory.WeapUSM1_";
//		gbxPawn(aPlayer.Pawn).AddDefaultInventory();
	}
}

function InitPlacedBot(Controller C, WargameRosterEntry R);

defaultproperties
{
	PlayerControllerClassName="gbxGameplay.WargamePlayerController"
	bTeamScoreRounds=false

    MPGIPropsDisplayText(0)="Min Players"
    MPGIPropsDisplayText(1)="Team Score Rounds"
    MPGIPropsDisplayText(2)="Delay at End of Game"
    LocalStatsScreenClass=class'Scoreboard'
    EndTimeDelay=+4.0
}
//=============================================================================
// WargameMultiplayer
//=============================================================================
class WargameMultiplayer extends WargameGameInfo
    config;
    
enum EPlayerCreationMode
{
	PlayerCreationMode_FromScratch,
	PlayerCreationMode_JustThePawn
};

enum EFieldPromotionResult
{
	FieldPromotionResult_Promoted,		// Player can and will promote into requested soldier
	FieldPromotionResult_TargetDead,	// Player cannot promote because specified soldier has died, but there are other AI soldiers remaining
	FieldPromotionResult_AllAlliesDead,	// Player cannot promote because no soldiers are alive
};

var bool ForMemoryReport;
var bool bGameEndingTime; // the time after victory is declared before we go to oracle cam

var int MaxTeams;
var int MaxTeamSize;
var	WargameTeamInfo Teams[2];
var float GameOnTime;
var int next_map_index;

var array<gbxVictoryCondition> VictoryConditionsToNotifyOnKilledEvent;

function InitGameReplicationInfo()
{
	Super.InitGameReplicationInfo();
	
	GameReplicationInfo.GameType = GT_MULTIPLAYER;
}

event InitGame( string Options, out string Error )
{
	log(self $ " WargameMultiplayer::InitGame(): Options = " $ Options, 'MP');

	if (HasOption(Options, "MEMORYREPORT" ))
	{
		ForMemoryReport = true;
	}
	log(self $ " WargameMultiplayer::InitGame(): ForMemoryReport = " $ ForMemoryReport, 'MP');

	// Set the MP fatigue style flag
	Level.m_bMPStyleFatigue = true;
	Level.m_bMPStyleWeapons = true;
	log(self $ " WargameMultiplayer::InitGame(): Level.m_bMPStyleFatigue: "$Level.m_bMPStyleFatigue$ " Level.m_bMPStyleWeapons: " $Level.m_bMPStyleWeapons, 'MP');


	Super.InitGame(Options, Error);
}

function PostBeginPlay()
{
	local int x;

	log(self $ " WargameMultiplayer::PostBeginPlay(): MaxTeams = " $ MaxTeams $ ", MaxTeamSize = " $ MaxTeamSize, 'MP' );

	GameReplicationInfo.bAllowTextChat = true;

	for (x = 0;x < MaxTeams;x++)
	{
		Teams[x] = spawn(class'WargameTeamInfo');
        // PSV: 5/12/2004 TEAM_None == 0 so start at index of 1		
        Teams[x].TeamIndex = x+1;  
		GameReplicationInfo.Teams[x] = Teams[x];

		if (ETeamIdentifier(Teams[x].TeamIndex) == TEAM_US)
		{
			Teams[x].TeamToGetNameFrom = class'gbxTeamAllies';
		}
		if (ETeamIdentifier(Teams[x].TeamIndex) == TEAM_German)
		{
			Teams[x].TeamToGetNameFrom = class'gbxTeamAxis';
		}
	}

	Super.PostBeginPlay();
}

event PlayerController Login
(
    string Portal,
    string Options,
    out string Error
)
{
    local PlayerController NewPlayer;

	// Fix bug 5239: Spectators shouldn't be part of teams; this option keeps them from becoming a member of a team
	if (GameReplicationInfo.bMatchHasBegun)
	{
		Options = "?SpectatorOnly=true"$Options;
	}

	NewPlayer = Super.Login(Portal,Options,Error);
	
	NewPlayer.PlayerReplicationInfo.NumLives = 0; // The default is 0 if no gbxMPReinforcementRules Actor exists in the map...

	return NewPlayer;
}

function Logout(controller Exiting)
{
	local gbxPlayerController exitingPC;
	local gbxPlayerController remainingPC;

	//Log(self $ " WargameMultiplayer::Logout() Controller " $ Exiting $ " is leaving", 'JWS');

	// When a player exits, give his teammate leftover reinforcements and kill his AI guys
	// since it is too difficult to transfer control of the AI guys
	exitingPC = gbxPlayerController(Exiting);
	
	if (exitingPC != None)
	{
		remainingPC = GetNonSpectatingTeammatePlayerController(exitingPC);

		//Log(self $ " WargameMultiplayer::Logout() found teammate " $ remainingPC, 'JWS');

		exitingPC.LastPlayerUnit.KillMembers(true);

		exitingPC.PlayerReplicationInfo.Team.RemoveFromTeam(exitingPC);

		if (remainingPC != None)
		{
			//Log(self $ " WargameMultiplayer::Logout() teammate had " $ remainingPC.PlayerReplicationInfo.NumLives $ " reinforcements, leaving had " $ exitingPC.PlayerReplicationInfo.NumLives, 'JWS');
			remainingPC.PlayerReplicationInfo.NumLives += exitingPC.PlayerReplicationInfo.NumLives;
			exitingPC.PlayerReplicationInfo.NumLives = 0;
			//Log(self $ " WargameMultiplayer::Logout() teammate now has " $ remainingPC.PlayerReplicationInfo.NumLives $ " reinforcements", 'JWS');
		}
	}

    Super.Logout(Exiting);
}

function gbxPlayerController GetNonSpectatingTeammatePlayerController(PlayerController PC)
{
	local gbxPlayerController teammate;

	//Log(self $ "WargameMultiplayer::GetTeammatePlayerController() looking for teammate for " $ PC $ " on team " $ PC.PlayerReplicationInfo.Team.TeamIndex, 'JWS');

	foreach DynamicActors(class'gbxPlayerController', teammate)
	{
		//Log(self $ "WargameMultiplayer::GetTeammatePlayerController() checking " $ teammate $ " on team " $ teammate.PlayerReplicationInfo.Team.TeamIndex, 'JWS');

		if (teammate.PlayerReplicationInfo.Team.TeamIndex == PC.PlayerReplicationInfo.Team.TeamIndex &&
			teammate != PC &&
			!teammate.IsSpectating())
		{
			//Log(self $ "WargameMultiplayer::GetTeammatePlayerController() matched!", 'JWS');

			break;
		}
		else
		{
			//Log(self $ "WargameMultiplayer::GetTeammatePlayerController() wrong team or same guy, moving on", 'JWS');
			teammate = None;
		}
	}

	return teammate;
}

function int GetNumPlayers()
{
	return NumPlayers + NumSpectators;
}

function StartMatch()
{
	BroadcastLocalizedMessage(class'gbxMPTrainingMessage', 1);

	Super.StartMatch();
}

function bool SlowMotionDeath()
{
	return true;
}

function bool ShouldRespawn(Pickup Other)
{
	// GBX:PAD: Single player wargame should not respawn weapons.
	return false;
}

function AddDefaultInventory( pawn PlayerPawn )
{
}

function RestartGame()
{
	local string nextmap;
	local string hostName;
	local string authMode;

//	Level.GetLocalPlayerController().ConsoleCommand("open "$GetURLMap());

	if ( Level.NetMode == NM_DedicatedServer )
	{
		hostName = ServerName;   //JER: Changed to make dedicated servers show correct name on game switch

		if (Level.AuthMode == AM_SystemLink)
		{
			authMode = "?SystemLink";
		}
		else if (Level.AuthMode == AM_SplitScreen)
		{
			authMode = "?SplitScreen";
		}
		else
		{
			hostName = class'GameService.GameService'.static.GetServerName();
		}

		ReplaceText(hostName, " ", "_");
		nextmap = class'Gameplay.gbxMPMissionList'.static.GetMap(next_map_index) $ "?wascycle=1" $ authMode $ "?HostName=" $ hostName;

		class'GameService.GameService'.static.UpdateGameData(class'Gameplay.gbxMPMissionList'.static.GetMap(next_map_index));

		Level.ServerTravel(nextmap, false);

		return;
	}

	if (gbxHUD(Level.GetLocalPlayerController().MyHUD) != None)
	{
		gbxHUD(Level.GetLocalPlayerController().MyHUD).m_eHudMode = HudModeDead;
	}
}

function bool ChangeTeam(Controller Other, int num, bool bNewTeam)
{
	return ChangeTeamMP(other, num, bNewTeam, 0);
}

function bool ChangeTeamMP(Controller Other, int num, bool bNewTeam, int desiredTeamId)
{
	local WargameTeamInfo NewTeam;

	log(self $ " WargameMultiplayer::ChangeTeamMP() Requested change to team = " $ num $ ", desiredTeamId = " $ desiredTeamId $ ", bNewTeam = " $ bNewTeam, 'MP');

	/*
	if ( bMustJoinBeforeStart && GameReplicationInfo.bMatchHasBegun )
		return false;	// only allow team changes before match starts
	*/

	if ( Other.IsA('PlayerController') && Other.PlayerReplicationInfo.bOnlySpectator )
	{
		Other.PlayerReplicationInfo.Team = None;
		return true;
	}

	NewTeam = GetTeam(ETeamIdentifier(num));

	if ( NewTeam.Size >= MaxTeamSize )
		return false;	// no room on either team

	// check if already on this team
	if ( Other.PlayerReplicationInfo.Team == NewTeam )
		return false;

	Other.StartSpot = None;

	if ( Other.PlayerReplicationInfo.Team != None )
	{
		Other.PlayerReplicationInfo.Team.RemoveFromTeam(Other);
	}

	if ( NewTeam.AddToTeam(Other, desiredTeamId) )
	{
		BroadcastLocalizedMessage( GameMessageClass, 3, Other.PlayerReplicationInfo, None, NewTeam );

		if ( bNewTeam && PlayerController(Other)!=None )
			GameEvent("TeamChange",""$num,Other.PlayerReplicationInfo);
	}

	return true;
}

function WargameTeamInfo GetTeam( ETeamIdentifier team )
{
	local WargameTeamInfo result;
	
	if ( team == TEAM_US )
		result = Teams[0];
	else if ( team == TEAM_German )
		result = Teams[1];
	else
		result = None;
	
	return result;
}

function ETeamIdentifier GetTeamByIndex( int index )
{
	local ETeamIdentifier result;

	if ( index == 1 )
		result = TEAM_US;
	else if ( index == 2 )
		result = TEAM_German;
	else 
		result = TEAM_None;

	return result;
}

function int GetTeamIndex( ETeamIdentifier team )
{
	local int result;
	
	if ( team == TEAM_US )
		result = 0;
	else //if ( team == TEAM_German )
		result = 1;
    	
	return result;
}


/* Return a picked team number if none was specified
*/
function byte PickTeam(byte num, Controller C)
{
	local int rslt;
	local ETeamIdentifier thisTeam;
	local ETeamIdentifier otherTeam;

	thisTeam = GetTeamByIndex(num);

	if ( thisTeam == TEAM_None )
		thisTeam = TEAM_US;

	log(self $ " WargameMultiplayer::PickTeam() begin: Requested team = " $ num, 'MP' );

	if ((thisTeam != TEAM_US) && (thisTeam != TEAM_German))
	{
		thisTeam = TEAM_US;
	}	

	if (thisTeam == TEAM_US)
		otherTeam = TEAM_German;
	else
		otherTeam = TEAM_US;

	if (GetTeam(thisTeam).Size > GetTeam(otherTeam).Size)
	{
		rslt = otherTeam;
	}
	else
	{
		rslt = thisTeam;
	}

	log(self $ " WargameMultiplayer::PickTeam() end: Assigned team = " $ rslt, 'MP' );
	return rslt;
}

/* Rate whether player should choose this NavigationPoint as its start
*/
function float RatePlayerStart(NavigationPoint N, byte Team, Controller Player, int nCheckpointID)
{
	local float rslt;
	local gbxMPPlayerStart P;

	P = gbxMPPlayerStart(N);
	
	if ( P == None )
	{
		rslt = -10000000;
	}
	else
	{
		log(self $ " WargameMultiplayer::RatePlayerStart() start: Team = " $ Team, 'MP' );
		
		//When Player is None go ahead and pick any spot.
		if (Player == None)
		{
			rslt = Super.RatePlayerStart(N,Team,Player,nCheckpointID);
		}
		else
		{
			if ( Player.PlayerReplicationInfo != None )
			{
				if ( (Team == P.TeamNumber) )
				{
					if (P.RandomInsteadOfTeamMemberID)
					{
						rslt = 100000.0f + FRand() * 1000.0f;			
					}
					else if ( Player.PlayerReplicationInfo.TeamID == P.TeamMemberID )
					{
						rslt = 100000.0f;
					}
					else
					{
						rslt = -9000000;
					}
				}
				else
				{
					rslt = -9000000;
				}
			}
			else
			{
				rslt = -9000000;
			}
		}

		log(self $ " WargameMultiplayer::RatePlayerStart() end: rslt = " $ rslt, 'MP' );
	}

	return rslt;
}

function CheckScore(PlayerReplicationInfo Scorer)
{
}

// Similar logic as what is found in the base classes without all the crap that we don't need
// Also adds support for scoring units, and keeping the team score in the TeamInfo
function ScoreKill(Controller Killer, Controller Other)
{
	local PlayerReplicationInfo OtherPRI;
	local PlayerReplicationInfo KillerPRI;

	if (!bGameEndingTime)
	{
		OtherPRI = Other.PlayerReplicationInfo;
		KillerPRI = Killer.PlayerReplicationInfo;

		if ( OtherPRI != None )
		{
			if ( (MaxLives > 0) && (OtherPRI.NumLives >=MaxLives) )
				OtherPRI.bOutOfLives = true;
		}

		if( (killer == Other) || (killer == None) )
		{
			// we don't want to score suicides, so do nothing
		}
		else if ( KillerPRI != None )
		{
			KillerPRI.Score += 1;
			KillerPRI.Kills++;

			if (KillerPRI.Team != None)
			{
				KillerPRI.Team.Score += 1;
			}
			else if (KillerPRI.Unit != None)
			{
				KillerPRI.Unit.Team.Score += 1;
			}

			if (KillerPRI.Unit != None)
			{
				KillerPRI.Unit.Score += 1;
			}

			ScoreEvent(KillerPRI,1,"frag");
		}

		if ( GameRulesModifiers != None )
		{
			GameRulesModifiers.ScoreKill(Killer, Other);
		}

		if ( (Killer != None) || (MaxLives > 0) )
		{
			CheckScore(Killer.PlayerReplicationInfo);
		}
	}
}

//
// Restart a player.
//
function RestartPlayer( Controller aPlayer )
{
	local gbxPlayerController pController;
	local EFieldPromotionResult result;
	local int OriginalNumLives;
	
	log(self $ " WargameMultiplayer::RestartPlayer(): aPlayer = " $ aPlayer $ ", aPlayer.PreviousPawnClass = " $ aPlayer.PreviousPawnClass, 'MP');

	//If this is our first restart then spawn the player normally, otherwise this is a field promotion.
	if (aPlayer.PreviousPawnClass == NONE)
	{
		log(self $ " WargameMultiplayer::RestartPlayer(): First restart, spawning player normally.", 'MP');
		CreatePlayer(aPlayer, PlayerCreationMode_FromScratch);
	}
	else
	{
		result = FieldPromotion(aPlayer);
		if ( result != FieldPromotionResult_Promoted )
		{
			if (result == FieldPromotionResult_TargetDead)
			{
				pController = gbxPlayerController(aPlayer);
				pController.bFieldPromoteAutochoose = true;

				result = FieldPromotion(aPlayer);
				Log( self$ " WargameMultiplayer::RestartPlayer(): Requested promotion target failed.  Retry result =" $ result, 'MP');
			}

			// Why did field promotion fail?
			if ( result == FieldPromotionResult_AllAlliesDead )
			{
				//Let's try and send in the reinforcements.
				if (aPlayer.PlayerReplicationInfo.NumLives > 0)
				{
					log(self $ " WargameMultiplayer::RestartPlayer(): Sending in reinforcements! NumLives = " $ aPlayer.PlayerReplicationInfo.NumLives, 'MP');

					// Fix Bug 9754: On some maps, the player has no fireteams, and so the FireteamSpawnController won't decrement NumLives
					// in that case, ensure at least one life is lost when restarting.
					OriginalNumLives = aPlayer.PlayerReplicationInfo.NumLives;
					
					CreatePlayer(aPlayer, PlayerCreationMode_FromScratch);

					if (aPlayer.PlayerReplicationInfo.NumLives == OriginalNumLives)
					{
						aPlayer.PlayerReplicationInfo.NumLives -= 1;

						if ( aPlayer.PlayerReplicationInfo.NumLives <= 0 )
						{	
							aPlayer.PlayerReplicationInfo.bOutofLives = true;
						}	
					}
				}
				else
				{
					log(self $ " WargameMultiplayer::RestartPlayer(): No reinforcements. NumLives = " $ aPlayer.PlayerReplicationInfo.NumLives$ " Going to spectating state!", 'MP');
					WargamePlayerController(aPlayer).ServerSpectate();
				}
			}
			else
			{
				Log( self$ " WargameMultiplayer::RestartPlayer(): Failed promotion, result =" $ result, 'MP');
			}
		}
	}
	
	log(self $ " WargameMultiplayer::RestartPlayer() end: aPlayer.Pawn = " $ aPlayer.Pawn, 'MP');
}

function EFieldPromotionResult FieldPromotion( Controller aPlayer )
{
	local EFieldPromotionResult result;
	local InfantryUSA aiGuy;
	local gbxPlayerController pController;
	local bool bLivingAISoldiers;

	log(self $ " WargameMultiplayer::FieldPromotion()", 'MP');

	result = FieldPromotionResult_TargetDead;
	bLivingAISoldiers = false;

	pController = gbxPlayerController(aPlayer);

	if ( pController != None )
	{
		//Log("ViewTarget: " $ pController.ViewTarget $ " bFieldPromoteAutochoose " $pController.bFieldPromoteAutochoose, 'PSV');

		// PSV: 5/17/2004 After coming out of Field Promoting state, check for ViewTarget
		if ( pController.bFieldPromoteAutochoose || pController.ViewTarget == None )
		{
			//Log("WargameMultiplayer::FieldPromotion No ViewTarget so automatically choosing one.", 'PSV');
			
			//Search all InfantryUSA looking for a friendly aiGuy to possess.
			foreach DynamicActors( class'InfantryUSA', aiGuy )
			{
				if (FieldPromotionCanPromote( aPlayer, aiGuy ) == true)
				{
					log(self $ " WargameMultiplayer::FieldPromotion(): Possessing " $ aiGuy, 'MP');
					
					FieldPromotionRemoveAIAddPlayer(aiGuy, aPlayer);
					result = FieldPromotionResult_Promoted;
					break;
				}
			}
		}
		else
		{
			//Log("WargameMultiplayer::FieldPromotion Yes!  We have a viewTarget.", 'PSV');
			
			aiGuy = InfantryUSA(pController.ViewTarget);
			if (FieldPromotionCanPromote( aPlayer, aiGuy ) == true)
			{
				//Log("WargameMultiplayer::FieldPromotion Field Promoting now!", 'PSV');
																
				FieldPromotionRemoveAIAddPlayer(aiGuy, aPlayer);
				result = FieldPromotionResult_Promoted;
			}
		}
	}

	if (result != FieldPromotionResult_Promoted)
	{
		if ( aiGuy.IsDead() )
		{
			//log(self $ " WargameMultiplayer::FieldPromotion(): Requested AI guy has died. ", 'PSV');
			result = FieldPromotionResult_TargetDead;
		}
		
		//Search all InfantryUSA to see this player has any living AI soldiers
		foreach DynamicActors( class'InfantryUSA', aiGuy )
		{
			if (FieldPromotionCanPromote( aPlayer, aiGuy ) == true)
			{
				//log(self$ " WargameMultiplayer::FieldPromotion() Found a living AI soldier. ", 'PSV');
				bLivingAISoldiers = true;
				break;
			}
		}

		if ( !bLivingAISoldiers )
		{
			log(self $ " WargameMultiplayer::FieldPromotion(): No available AI guys. ", 'MP');
			result = FieldPromotionResult_AllAlliesDead;
		}
	}
	
	return result;
}

function bool FieldPromotionCanPromote( Controller aPlayer, InfantryUSA aiGuy )
{
	local bool rslt;
	local MultiplayerUnit aiGuysUnit;
	
	rslt = false;
	
	if ((aPlayer != None) && (aiGuy != None))
	{
		if (!aiGuy.IsAPlayerPawn())
		{
			log(self $ " WargameMultiplayer::FieldPromotion(): Considering aiGuy = " $ aiGuy, 'MP');
			if ((!aiGuy.IsDead()) && (aiGuy.MyUnit != None))
			{
				aiGuysUnit = MultiplayerUnit(aiGuy.MyUnit);
				
				if ((aiGuysUnit.Team == aPlayer.PlayerReplicationInfo.Team.TeamIndex) && (aiGuysUnit.TeamMemberId == aPlayer.PlayerReplicationInfo.TeamID))
				{
					rslt = true;
				}
			}
		}
	}
	
	return rslt;
}

function FieldPromotionRemoveAIAddPlayer( InfantryUSA aiGuy, Controller aPlayer )
{
	local MultiplayerUnit aiGuysUnit;
	local Controller aiGuysController;
	local Pawn newPawn;
	local gbxPlayerPawn newPlayerPawn;	
	local vector   startLocation;
	local rotator  startRotation;
	local string RequiredEquipment[16];
	local int i;
	local int m;
	
    // Uncomment for distance based health bonus
	//local InfantryUSA Soldier;
	//local float ClosestEnemyDistance, EnemyDistance, MaximumEnemyDistance;
    //local int MaxHealthBonus;        
    local float HealthBonusLength;
	
	
	log(self $ " WargameMultiplayer::FieldPromotion(): Promoting " $ aiGuy, 'MP');
	
	aiGuysUnit = MultiplayerUnit(aiGuy.MyUnit);
	aiGuysController = aiGuy.Controller;
	
	//Stop any looping firing sounds that the AI might have been playing
	log("FieldPromotionRemoveAIAddPlayer("$aiGuy$","$aPlayer$") About to iterate through fire modes on weapon: "$aiGuy.Weapon, 'DevSound');
	for ( m = 0; m < aiGuy.Weapon.NUM_FIRE_MODES; m++)
    {
        if (aiGuy.Weapon.FireModeClass[m] != None)
        {
			if (aiGuy.Weapon.FireMode[m].bIsFiring)
			{
                log("FieldPromotionRemoveAIAddPlayer() aiGuy.Weapon: "$aiGuy.Weapon$ " aiGuy.Weapon.FireModeClass[$m$]: "$aiGuy.Weapon.FireModeClass[m]$ " is currently firing, so calling StopFire().", 'DevSound');
                aiGuy.Weapon.StopFire(m);
            }
        }
    }
		
	//Remember important data from this aiGuy.
	startLocation = aiGuy.Location;
	startRotation = aiGuy.Rotation;
	startRotation.Pitch = 0;	// PSV: 8/12/2004 Center the pitch because the aiGuy's like to look in weird directions.
	for ( i=0; i<16; i++ )
	{
		RequiredEquipment[i] = aiGuy.RequiredEquipment[i];
	}
						
	//Remove this guy from his unit.
	aiGuysUnit.RemoveMember(aiGuy);

	//Disconnect aiGuy from its AI Controller.
	aiGuysController.Unpossess();
	
	// Unclaim aiGuy's nav points
	aiGuy.IAmDying();

	//Destroy this aiGuy and his controller.
	aiGuy.destroy();
	aiGuysController.destroy();
		
	newPawn = CreatePlayer(aPlayer, PlayerCreationMode_JustThePawn, startLocation, startRotation);
	log(self $ " WargameMultiplayer::FieldPromotion(): newPawn = " $ newPawn, 'MP');
	
	newPlayerPawn = gbxPlayerPawn(newPawn);
	
	//Set this pawn to be player controlled.
	aPlayer.Possess(newPlayerPawn);
	
	//Setup the promoted player's weapons.
	for ( i=0; i<16; i++ )
	{
		newPlayerPawn.RequiredEquipment[i] = RequiredEquipment[i];
		log(self $ " WargameMultiplayer::FieldPromotion(): RequiredEquipment[" $ i $ "] = " $ newPlayerPawn.RequiredEquipment[i], 'MP');
	}
	newPlayerPawn.AddDefaultInventory();
	
	// PSV: 8/12/2004 Testing out health bonus for reinforcing player
	HealthBonusLength = 3.0;

	// One size fits all health bonus
	newPlayerPawn.Health = 175;
	Log( self$ " WargameMultiplayer::FieldPromotionRemoveAIAddPlayer() Adding health reinforcement bonus: newPlayerPawn.Health = " $newPlayerPawn.Health, 'PSV' );
	
	// Set a timer to remove extra health (If the player fires, it will be remove instantly)
	newPlayerPawn.SetTimer( HealthBonusLength, false );

	/* 
	// Distance based health bonus
	MaxHealthBonus = 50;
	MaximumEnemyDistance = 5000.0;
	ClosestEnemyDistance = MaximumEnemyDistance;

	// Find the closest enemy to the player's new location
	ForEach DynamicActors(class'InfantryUSA', Soldier)
	{
		Log( self$ " Soldier.PawnTeam = " $Soldier.PawnTeam$ " newPlayerPawn.PawnTeam = " $newPlayerPawn.PawnTeam, 'PSV' );
		if ( Soldier.PawnTeam != newPlayerPawn.PawnTeam )
		{
			EnemyDistance = VSize(Soldier.Location - newPlayerPawn.Location);
			Log( self$ " Found an enemy!  EnemyDistance = " $EnemyDistance, 'PSV' );
			if ( EnemyDistance < ClosestEnemyDistance )
				ClosestEnemyDistance = EnemyDistance;
		}
	}

	Log( self$ " ClosestEnemyDistance = " $ClosestEnemyDistance, 'PSV' );

	if ( ClosestEnemyDistance < MaximumEnemyDistance )
	{
		// Scale extra health by distance to closest enemy
		newPlayerPawn.Health = 150 + ( ClosestEnemyDistance / MaximumEnemyDistance ) * MaxHealthBonus;

		Log( self$ " newPlayerPawn.Health = " $newPlayerPawn.Health, 'PSV' );

		// Set a timer to remove extra health (If the player fires, it will be remove instantly)
		newPlayerPawn.SetTimer( HealthBonusLength, false );
	}*/

	//Set the promoted player's orientation.
	aPlayer.ClientSetRotation( startRotation );
}

function Pawn CreatePlayer( Controller aPlayer, EPlayerCreationMode creationMode, optional Vector location, optional Rotator rotation )
{
	local Pawn rslt;
	// Configure the new player to look right 2004-04-13 JWS
	local CharacterSetup.EMPCharacterTypes	charType;

	local class<CharacterSetup> CharacterSetupClass;
	local Mesh defaultMesh;
	local Mesh newMesh;
	local int defaultCharacterType;
	local class<CharacterSetup> defaultCharacterSetupClass;
	local class<gbxPawn> gbxpClass;
	local ETeamIdentifier defaultTeam;
//	local string		newMenuName, defaultMenuName;
	local int		nHealth, nScore;

	log(self $ " WargameMultiplayer::CreatePlayer(): aPlayer: "$aPlayer$ " creationMode: "$creationMode$ " aPlayer.PlayerReplicationInfo.Team.TeamIndex: "$aPlayer.PlayerReplicationInfo.Team.TeamIndex$" - "$charType, 'MP');

	CharacterSetupClass = class'CharacterSetupMP';
	charType = GetCharacterType( aPlayer );
	
	if (aPlayer.PlayerReplicationInfo.Team.TeamIndex == 1)
	{
		//if (IsA('WargameSkirmish'))
		//{
			switch(charType)
			{
			case SKHartsock:
			case MPPlayer2US:
				newMesh = Mesh(DynamicLoadObject("mp_k_character_us.us_para_mp_hartsock", class'Mesh'));
				break;
			case SKBaker:
			case MPPlayer1US:
				newMesh = Mesh(DynamicLoadObject("mp_k_character_us.us_para_mp_baker", class'Mesh'));
				break;
			case SKCharUSA:
			case SKCharUSB:
			case SKCharUSC:
			case SKCharUSD:
			case MPCharUSA:
			case MPCharUSB:
			case MPCharUSC:
			default:
				newMesh = Mesh(DynamicLoadObject("mp_k_character_us.us_para_mp_doe", class'Mesh'));
				break;
			}
		//}
		//else
		//{
		//	switch(charType)
		//	{
		//	case MPPlayer1US:
		//		newMesh = Mesh(DynamicLoadObject("mp_k_character_us.us_para_mp_hartsock", class'Mesh'));
		//		break;
		//	case MPPlayer2US:
		//		newMesh = Mesh(DynamicLoadObject("mp_k_character_us.us_para_mp_baker", class'Mesh'));
		//		break;
		//	case MPCharUSA:
		//	case MPCharUSB:
		//	case MPCharUSC:
		//	default:
		//		newMesh = Mesh(DynamicLoadObject("mp_k_character_us.us_para_mp_doe", class'Mesh'));
		//		break;
		//	}
		//}
		}
		else
		{
		//if (IsA('WargameSkirmish'))
		//{
			switch(charType)
			{
				//case SKHansEG:
				case SKHansDE:
				case MPPlayer1DE:
				//case MPPlayer1EG:
					newMesh = Mesh(DynamicLoadObject("mp_k_character_de.de_infantry_mp_hans", class'Mesh'));
					break;
				//case SKFransEG:
				case SKFransDE:
				case MPPlayer2DE:
				//case MPPlayer2EG:
					newMesh = Mesh(DynamicLoadObject("mp_k_character_de.de_infantry_mp_heinrick", class'Mesh'));
					break;
				//case SKCharEGA:
				//case SKCharEGB:
				//case SKCharEGC:
				//case SKCharEGD:
				case SKCharDEA:
				case SKCharDEB:
				case SKCharDEC:
				case SKCharDED:
				case MPCharDEA:
				case MPCharDEB:
				case MPCharDEC:
				//case MPCharEGA:
				//case MPCharEGB:
				//case MPCharEGC:
				default:
					newMesh = Mesh(DynamicLoadObject("mp_k_character_de.de_infantry_gunter", class'Mesh'));
					break;
			}
		//}
		//else
		//{
		//	switch(charType)
		//	{
		//		case MPPlayer1DE:
		//		case MPPlayer1EG:
		//			newMesh = Mesh(DynamicLoadObject("mp_k_character_de.de_infantry_mp_hans", class'Mesh'));
		//			break;
		//		case MPPlayer2DE:
		//		case MPPlayer2EG:
		//			newMesh = Mesh(DynamicLoadObject("mp_k_character_de.de_infantry_mp_heinrick", class'Mesh'));
		//			break;
		//		case MPCharDEA:
		//		case MPCharDEB:
		//		case MPCharDEC:
		//		case MPCharEGA:
		//		case MPCharEGB:
		//		case MPCharEGC:
		//		default:
		//			newMesh = Mesh(DynamicLoadObject("mp_k_character_de.de_infantry_gunter", class'Mesh'));
		//			break;
		//	}
		//}
	}

	log(self $ " WargameMultiplayer::CreatePlayer(): aPlayer.PawnClass: "$aPlayer.PawnClass, 'MP');

	if ( aPlayer.PawnClass != None )
	{
		gbxpClass = class<gbxPawn>(aPlayer.PawnClass);
	}
	else
	{
		gbxpClass = class<gbxPawn>(GetDefaultPlayerClass(aPlayer));
	}
/*
	switch (charType)
	{
		case SKCharUSA:
			newMenuName = gbxpClass.Default.MenuName;
			break;
		case SKCharUSB:
			newMenuName = gbxpClass.Default.MenuNameBaker;
			break;
		case SKCharDEA:
			newMenuName = gbxpClass.Default.MenuNameFrans;
			break;
		case SKCharDEB:
			newMenuName = gbxpClass.Default.MenuNameHans;
			break;
	}
*/
	defaultCharacterType = gbxpClass.default.m_nCharType;
	defaultCharacterSetupClass = gbxpClass.default.CharacterSetupClass;
	defaultMesh = gbxpClass.default.Mesh;
	defaultTeam = gbxpClass.default.PawnTeam;
//	defaultMenuName = gbxpClass.default.MenuName;

	// Now make the player look right, call baseclass functionality to spawn him, then reset everything 2004-04-13 JWS
	gbxpClass.default.m_nCharType		  = charType;
	gbxpClass.default.m_nNewCharType      = charType;
	gbxpClass.default.CharacterSetupClass = CharacterSetupClass;
	gbxpClass.default.Mesh				  = newMesh;
	gbxpClass.default.bNoRepMesh		  = false;
	gbxpClass.default.PawnTeam            = ETeamIdentifier(aPlayer.PlayerReplicationInfo.Team.TeamIndex);
/*
	if (newMenuName != "")
	{
		gbxpClass.default.MenuName = newMenuName;
		log(self$".CreatePlayer() - "$gbxpClass.default.MenuName$" - "$defaultMenuName);
	}
*/			
			switch (creationMode)
			{
				case PlayerCreationMode_FromScratch:
					Super.RestartPlayer( aPlayer );
					if (gbxPlayerStart(aPlayer.Pawn.LastStartSpot) != None)
						gbxPlayerStart(aPlayer.Pawn.LastStartSpot).AddDefaultInventory( aPlayer.Pawn );
						
					rslt = aPlayer.Pawn;
					break;
					
				case PlayerCreationMode_JustThePawn:
					rslt = Spawn(gbxpClass,,,location,rotation);
					// PSV: 6/10/2004 The player's original playerstart is stashed in its controller.
					rslt.LastStartSpot = aPlayer.LastStartSpot;
					break;
					
				default:
					rslt = None;
					break;
			}			
			
			if (rslt != None)
			{
				if ( rslt.PawnTeam == TEAM_US )
					gbxPawn(rslt).CreateTeamLogoShadow("t_interface_mb.shadow_us_star");
				else if ( rslt.PawnTeam == TEAM_German )
					gbxPawn(rslt).CreateTeamLogoShadow("t_interface_mb.shadow_de_cross");
			}
			
	gbxpClass.default.PawnTeam            = defaultTeam;
	gbxpClass.default.m_nNewCharType	  = 0;
	gbxpClass.default.m_nCharType		  = defaultCharacterType;
	gbxpClass.default.CharacterSetupClass = defaultCharacterSetupClass;
	gbxpClass.default.Mesh				  = defaultMesh;
	gbxpClass.default.bNoRepMesh		  = true;
//	gbxpClass.default.MenuName            = defaultMenuName;
	
	gbxPawn(rslt).bPawnBlinks = false;

	// Set the pawn's tag name
	if ( aPlayer.LastStartSpot != None && gbxMPPlayerStart(rslt.LastStartSpot).AssignedPawnName != '' )
	{
		//log( self$ " CreatePlayer() assigning pawn new tag name: "$gbxMPPlayerStart(rslt.LastStartSpot).AssignedPawnName, 'MP' );
		rslt.tag = gbxMPPlayerStart(rslt.LastStartSpot).AssignedPawnName;
	}
		
	if ((Level.NetMode != NM_Client) && Level.Game.CanUseCheckpoints(-1))
	{
		nHealth = -1;
		if (Level.MissionManager.SkirmishGetCheckpointPlayerHealth( AnimPawn(rslt), nHealth, nScore ))
		{
			if (nHealth > 0)
			{
				rslt.Health = nHealth;
			}
			
			if ((aPlayer.PlayerReplicationInfo != None) && (nScore > 0))
			{
				aPlayer.PlayerReplicationInfo.Score = nScore;
			}
		}
	}
	
	return rslt;
}

//-------------------------------------------------------------------------------------
// Level gameplay modification

// This function is called by the game engine to determine if an Actor can be spectated upon
// when the player is in the FieldPromoting state.
function bool CanSpectate( PlayerController Viewer, bool bOnlySpectator, actor ViewTarget )
{
	local bool rslt;
	local InfantryUSA aiGuy;
	local Controller C;

	if ( ViewTarget == None || Controller(ViewTarget) == None)
	{
		Log("WargameMultiplayer::CanSpectate ViewTarget == None!!", 'PSV');
		return false;
	}

	rslt = false;

	C = Controller(ViewTarget);
	if (C.bIsPlayer && C.Pawn != None)
	{
		if ( Viewer.IsFieldPromoting() )
		{
			aiGuy = InfantryUSA(C.Pawn);

			if ( FieldPromotionCanPromote( Viewer, aiGuy) )
			{
				rslt = true;
			}
			else
			{
				rslt = false;
			}
		}
		else if ( Viewer.IsSpectating() )
		{
			// Make sure the target is alive...
			if ( C.Pawn.IsDead() )
			{
				rslt = false;
			}
			else
			{
				rslt = true;
			}
		}

		// Bug 4147: Only allow players to spectate pawns on the same team
		if (Viewer.PlayerReplicationInfo.Team != None && (Viewer.PlayerReplicationInfo.Team.TeamIndex != C.Pawn.PawnTeam) )
		{
			rslt = false;
		}
	}

	return rslt;
}

function ActivateVictoryConditions(bool gameOn)
{
	local gbxVictoryCondition vc;
	
	foreach DynamicActors(class'gbxVictoryCondition', vc)
	{
		vc.SetGameOn(gameOn);
	}
}

function TriggerMapEvent(bool gameOn)
{
	local Name EventName;
	local PlayerController PC;
	local string MemTag;

	if (gameOn)
	{
		EventName = 'EventGameOn';
	}
	else
	{
		EventName = 'EventGameOff';
	}

	for (PC = Level.PlayerControllerList; PC != None; PC = PC.nextPlayerController)
	{
		if (PC != None && PC.Player.SplitIndex != 1)
		{
		 	PC.ClientTriggerEvent(EventName, None, None);
		}
	}

	PC = Level.GetLocalPlayerController();
	
	if (WargamePlayerController(PC).bCheckpointMemLog)
	{
		if (gameOn)
		{
			MemTag = Level.GetLevelFileName() $ "_Start";
		}
		else
		{
			MemTag = Level.GetLevelFileName() $ "_End";
		}

		PC.ConsoleCommand("STAT REPORTALL " $ MemTag);
		PC.ConsoleCommand("MEM DETAILED " $ MemTag);
		PC.ConsoleCommand("DUMPTIMERS " $ MemTag);
		PC.ConsoleCommand("CLEARTIMERS");
	}
}

function CallInReinforcements( Controller C )
{
	local MultiplayerUnit mpUnit;
	local int iMaxNumberFireTeams;
	local gbxPlayerController PC;
	local gbxPawn pawn;
	local Unit mySubUnit;
	local int iReinforcementType;
	local int iReinforcementIndex;

	//Log( self$ " WargameMultiplayer::CallInReinforcements()", 'PSV');

	// Default to not allowing reinforcements unless told otherwise
	iMaxNumberFireTeams = 0;

	PC = gbxPlayerController( C );

	// Check to see if we think we can call in reinforcements
	if ( PC != None && PC.PlayerReplicationInfo != None )
	{
		// Do we have any soldiers left to reinforce with?
		if ( PC.PlayerReplicationInfo.NumLives > 0 )
		{
			//Log( self$ " WargameMultiplayer::CallInReinforcements() PlayerReplicationInfo.NumLives:" $PC.PlayerReplicationInfo.NumLives, 'PSV');		

			pawn = gbxPawn( PC.Pawn );
			mpUnit = MultiplayerUnit( pawn.MyUnit );
			if ( mpUnit != None )
			{
				//Log( self$ " WargameMultiplayer::CallInReinforcements() mpUnit:" $mpUnit$ " PC.StartSpot: " $pawn.LastStartSpot, 'PSV');
				
				if ( PC.SpawnController != None )
				{
					iMaxNumberFireTeams = GetMaxFireteamsForPlayer(PC);

					// Verify that the player has an empty fireteam
					if ( mpUnit.NumSubUnits < iMaxNumberFireTeams )
					{
						//Log( self$ " WargameMultiplayer::CallInReinforcements() mpUnit.NumSubUnits: " $mpUnit.NumSubUnits$ " iMaxNumberFireTeams:" $iMaxNumberFireTeams, 'PSV');				

						// Figure out which fireteam is still alive
						// There could be none remaining...
						if ( mpUnit.NumSubUnits > 0 )
						{
							if ( mpUnit.SubUnits[0] != None )
							{
								mySubUnit = mpUnit.SubUnits[0];
								iReinforcementIndex = 1;
							}
                            else
							{
								mySubUnit = mpUnit.SubUnits[1];
								iReinforcementIndex = 0;
							}
							
							if ( mySubUnit.UnitType == 0 )
								iReinforcementType = 1;
							else
								iReinforcementType = 0;

							//Log( self$ " WargameMultiplayer::CallInReinforcements() We have 1/2 fireteams, sending reinforcements!", 'PSV');	
							PC.SpawnController.TriggerTeamByUnitType( iReinforcementType, PC );
						}
						else
						{
							if ( iMaxNumberFireTeams == 1 )
							{
								// If we're only allowed one fireteam, trigger the spawn controller so we get the type of fireteam we were assigned by the level designer
								//Log( self$ " WargameMultiplayer::CallInReinforcements() We have 0/1 fireteams, sending reinforcements!", 'PSV');	
								TriggerEvent( pawn.LastStartSpot.Event, self, pawn );
								iReinforcementIndex = 0;
							}
							else
							{
								// Otherwise, just trigger the assault team since both teams are dead
								//Log( self$ " WargameMultiplayer::CallInReinforcements() We have 0/2 fireteams, sending reinforcements!", 'PSV');	
								PC.SpawnController.TriggerTeamByUnitType( 0, PC );
								iReinforcementIndex = 0;
							}
						}
						
						// Notify player that reinforcements have arrived.
						if ( mpUnit.SubUnits[iReinforcementIndex] != None )
						{							
							//Log( self$ " WargameMultiplayer::CallInReinforcements() Incrementing iReplicatedReinforcements variable of Unit so effect happens on client.", 'PSV');	
							mpUnit.SubUnits[iReinforcementIndex].iReplicatedReinforcements++;
						}
						else
						{
							Log( self$ " WargameMultiplayer::CallInReinforcements() ###ERROR!!! Unit just reinforced is not at index " $iReinforcementIndex$ " like it should be!");	
						}
					}
				}
			}
		}
	}
}

// Returns the number of fireteams a player can have depending on team and number of players
function int GetMaxFireteamsForPlayer(gbxPlayerController PC)
{
	local int maxFireteams;

	maxFireteams = 0;

	if (PC.SpawnController != None)
	{
		maxFireteams = PC.SpawnController.GetMaxFireteamsForPlayer(PC);
	}

	return maxFireteams;
}

function int GetNumberofPlayersOnTeam(ETeamIdentifier team)
{
	local int count;
	local WargameTeamInfo teamInfo;

	teamInfo = GetTeam(team);

	log( self$ " GetNumberofPlayersOnTeam() team: " $team$ " teamInfo: "$teamInfo, 'MP' );

	if (teamInfo != None)
	{
		count = teamInfo.Size;
		log( self$ " GetNumberofPlayersOnTeam() count: "$count, 'MP' );
	}

	return count;
}

function int GetNumberOfActualPlayers()
{
	local int count;

	count = GetNumberofPlayersOnTeam(TEAM_US) + GetNumberofPlayersOnTeam(TEAM_German);

	return count;
}

function bool IsPlayerUnderdog( ETeamIdentifier team )
{
	local WargameTeamInfo teamInfo, otherTeamInfo;	
	
	teamInfo = GetTeam( team );

	if ( team == TEAM_US )
	{
		otherTeamInfo = GetTeam(TEAM_German);
	}
	else
	{
		otherTeamInfo = GetTeam(TEAM_US);
	}

	return ( otherTeamInfo.Size > teamInfo.Size );
}

exec function SetGameOn(bool gameOn)
{
	//log( "WargameMultiplayer::SetGameOn("$gameOn$")", 'MP' );
	
	GotoState('PendingMatch');
}


auto state PreMatch
{
	function PutPlayerInLobby( PlayerController NewPlayer )
	{
		// assign a lobby team selection for the new player
		if (NewPlayer.PlayerReplicationInfo.Team.TeamIndex == ETeamIdentifier.TEAM_US)
		{
			log("WargameMultiplayer:PreMatch::PostLogin - " $NewPlayer @"Using current USA team choice.", 'MP');
			NewPlayer.PlayerReplicationInfo.InitializeTeam(ETeamIdentifier.TEAM_US);
		}
		else if (NewPlayer.PlayerReplicationInfo.Team.TeamIndex == ETeamIdentifier.TEAM_German)
		{
			log("WargameMultiplayer:PreMatch::PostLogin - " $NewPlayer @"Using current German team choice.", 'MP');
			NewPlayer.PlayerReplicationInfo.InitializeTeam(ETeamIdentifier.TEAM_German);
		}
		else
		{
			if (NewPlayer.PlayerReplicationInfo.GetLobbyTeamCount(ETeamIdentifier.TEAM_US) <= NewPlayer.PlayerReplicationInfo.GetLobbyTeamCount(ETeamIdentifier.TEAM_German))
			{
				log("WargameMultiplayer:PreMatch::PostLogin - " $NewPlayer @"Choosing USA team.", 'MP');
				NewPlayer.PlayerReplicationInfo.InitializeTeam(ETeamIdentifier.TEAM_US);
			}
			else
			{
				log("WargameMultiplayer:PreMatch::PostLogin - " $NewPlayer @"Choosing German team.", 'MP');
				NewPlayer.PlayerReplicationInfo.InitializeTeam(ETeamIdentifier.TEAM_German);
			}
		}

		// put them in the (correct) lobby state
		if (Level.Game.IsA('WargameSkirmish'))
		{
			if (Level.Game.bNoLobby)
				NewPlayer.GotoState('Lobby_Skirmish_Wait');
			else
				NewPlayer.GotoState('Lobby_Skirmish');
		}
		else
		{
			NewPlayer.GotoState('Lobby');
		}
	}

	event PostLogin( PlayerController NewPlayer )
	{
		Super.PostLogin( NewPlayer );

		PutPlayerInLobby(NewPlayer);
	}

    function BeginState()
    {
        local Controller P;
		local gbxBaseFireTeamSpawnController memoryFireTeamSpawnController;
        
		Super.BeginState();
		log("WargameMultiplayer:PreMatch::BeginState");

		// put all existing players in the lobby
        for (P=Level.ControllerList; P!=None; P=P.NextController )
		{
            if ( P.IsA('PlayerController') && (P.PlayerReplicationInfo != None))
			{
				PutPlayerInLobby(PlayerController(P));
			}
		}

		if (ForMemoryReport == true)
		{
			foreach DynamicActors( class'gbxBaseFireTeamSpawnController', memoryFireTeamSpawnController )
			{
				log(self $ " WargameMultiplayer::PreMatch BeginState(): Triggering " $ memoryFireTeamSpawnController, 'MP');
				memoryFireTeamSpawnController.TriggerTeamForMemoryReport();
			}

			ForMemoryReport = false; //Only do this once.
		}
	}

	function EndState()
	{
		//DS-BEGIN: Force players to tell Xbox Live stats about their joining the game. Pregame call
		local Controller P;
		for (P=Level.ControllerList; P!=None; P=P.NextController )
		{
			if ( P.IsA('PlayerController') && (P.PlayerReplicationInfo != None))
			{
				WargamePlayerController(P).ClientGameStarted();
			}
		}
		//DS-END
		TeamsClearAllPreviousSettings();
		TeamsAssignPlayersBasedOnLobbySettings();
		TeamsAssignReinforcements();
	}
	
	function Tick(float delta)
	{
		local PlayerReplicationInfo pri;
		local int usa_ready_count;
		local int german_ready_count;

		global.Tick(delta);

		usa_ready_count = 0;
		german_ready_count = 0;

		if ( Level.NetMode == NM_DedicatedServer )
		{
			ForEach DynamicActors(class'PlayerReplicationInfo', pri)
			{
				if ( pri.IsTeamUSA() )  // is this USA player ready?
					usa_ready_count++;
				if ( pri.IsTeamGerman() )  // is this German player ready?
					german_ready_count++;
			}

			// see if total number of ready players == MaxPlayers...
			if ((usa_ready_count + german_ready_count) >= Level.Game.MaxPlayers)
			{
				if (abs(usa_ready_count - german_ready_count) <= 1)  // even teams (or only 1 player difference between them)?
				{
					if (GameReplicationInfo.LobbyCountdownTime < 0)
					{
						GameOnTime = Level.UniversalTimeSeconds + 5.0f;  // start in 5 seconds
					}

					GameReplicationInfo.LobbyCountdownTime = Ceil(GameOnTime - Level.UniversalTimeSeconds);

					if (GameOnTime <= Level.UniversalTimeSeconds)
						SetGameOn(true);  // game on dude!

					return;
				}
			}

			GameReplicationInfo.LobbyCountdownTime = -1;  // not all players ready yet
		}
	}
	
	function TeamsClearAllPreviousSettings()
	{
		local Controller P;
		local TeamInfo team;

        for (P=Level.ControllerList; P!=None; P=P.NextController )
		{
            if ( P.IsA('PlayerController') && (P.PlayerReplicationInfo != None))
			{
				team = P.PlayerReplicationInfo.Team;
				if (team != None)
				{
					team.RemoveFromTeam(P);
				}
			}
		}
	}
	
	function TeamsAssignPlayersBasedOnLobbySettings()
	{
		local XBoxAddr EmptyAddr;
		local Controller P;
		local PlayerController PC;
		local ETeamIdentifier desiredTeam;
        local int desiredTeamId;
		local int voiceChannel;
		
		// set up the teams
		log(self $ " WargameMultiplayer::TeamsAssignPlayersBasedOnLobbySettings(): Setting up teams.", 'MP');
        for (P=Level.ControllerList; P!=None; P=P.NextController )
		{
            if ( P.IsA('PlayerController') && (P.PlayerReplicationInfo != None) )
			{
				if (!P.PlayerReplicationInfo.bOnlySpectator)
				{
					//Get the desired team and desiredTeamId
					if (P.PlayerReplicationInfo.IsTeamUSA())
					{
						desiredTeam = ETeamIdentifier.TEAM_US;
					}
					else
					{
						desiredTeam = ETeamIdentifier.TEAM_German;
					}
					desiredTeamId = P.PlayerReplicationInfo.LobbyGetPlayerTeamRole();

					//Enforce the team selection.
					log("     Player = " $ P $ ", requesting team = " $ desiredTeam $ ", teamRole = " $ desiredTeamId, 'MP');
					ChangeTeamMP(P, desiredTeam, false, desiredTeamId);
				}
					
				// close their lobby
				PlayerController(P).ClientCloseMenu(true,,true);

				if (!P.PlayerReplicationInfo.bOnlySpectator)
				{
					//Set voice chat for in game play.
					if (NumPlayers <= 2)
					{
						//With two or less players everyone can still talk to everyone else.
						voiceChannel = VoiceChannelAllPlayers;
					}
					else
					{
						//With more than two players in the game players can only chat with their teammates.
						if (desiredTeam == ETeamIdentifier.TEAM_US)
						{
							voiceChannel = VoiceChannelUS;
						}
						else
						{
							voiceChannel = VoiceChannelGerman;
						}
					}

					PC = PlayerController(P);
					PC.ServerChangeChannel(PC, EmptyAddr, 0, -VoiceChannel - 4);
				}
			}
		}
	}

	function TeamsAssignReinforcements()
	{
		local Controller P;
		local TeamInfo team;
		local ETeamIdentifier teamid;
		local int USSize, DESize;
		local gbxReinforcementRules rules;

		USSize = GetTeam(TEAM_US).Size;
		DESize = GetTeam(TEAM_German).Size;

		foreach DynamicActors(class'gbxReinforcementRules', rules)
		{
			break;
		}

		if (rules != None)
		{
			for (P=Level.ControllerList; P!=None; P=P.NextController )
			{
				if ( P.IsA('PlayerController') && (P.PlayerReplicationInfo != None) && (!P.PlayerReplicationInfo.bOnlySpectator) )
				{
					team = P.PlayerReplicationInfo.Team;
					if (team != None)
					{
						teamid = GetTeambyIndex(team.TeamIndex);

						P.PlayerReplicationInfo.NumLives = rules.GetReinforcementsForTeam(teamid, USSize, DESize);
					}
				}
			}
		}
	}

	function bool GetModifiedPlayerStartView( NavigationPoint Start, out vector Loc, out rotator Rot )
	{
		local gbxMPPlayerStart ps;
		local Actor viewActor;
		local bool result;

		ps = gbxMPPlayerStart(Start);

		if (ps != None)
		{
			if (ps.BriefingRoomViewActor != 'None')
			{
				foreach AllActors(class'Actor', viewActor, ps.BriefingRoomViewActor)
				{
					break;
				}
			}

			if (viewActor != None)
			{
				Loc = viewActor.Location;
				Rot = viewActor.Rotation;

				result = true;
			}
		}

		return result;
	}

	// In the briefing room we only want to use start points that are marked for use here, since they have the associated actor for Location and Rotation
	function float RatePlayerStart(NavigationPoint N, byte Team, Controller Player, int nCheckpointID)
	{
		local float rslt;
		local gbxMPPlayerStart P;

		P = gbxMPPlayerStart(N);
		
		if ( P == None )
		{
			rslt = -10000000;
		}
		else
		{
			if ( P.BriefingRoomViewActor == 'None' )
			{
				rslt = 1.0f + FRand() * 1000.0f; // use a small positive number so that if there isn't a briefing room start, the map won't crash.
			}
			else
			{
				rslt = 100000.0f + FRand() * 1000.0f;
			}
		}

		return rslt;
	}
}

State MatchInProgress
{
	event PostLogin( PlayerController NewPlayer )
	{
		Super.PostLogin( NewPlayer );

		Log( self$ " WargameMultiplayer:state MatchInProgress::PostLogin() going to state 'Spectating'", 'MP' );

		// put them in the spectator state
		NewPlayer.GotoState('Spectating');
	}

    function BeginState()
    {
		Super.BeginState();

		ActivateVictoryConditions(true);
		TriggerMapEvent(true);

		Level.MissionStartTime = Level.TimeSeconds;
	}

	exec function SetGameOn(bool gameOn)
	{
		//log( "WargameMultiplayer::MatchInProgress::SetGameOn("$gameOn$")", 'MP' );
		
		ActivateVictoryConditions(gameOn);
	}
}

State MatchOver
{
	function ScoreKill(Controller Killer, Controller Other) {}

	event PostLogin( PlayerController NewPlayer )
	{
		Super.PostLogin( NewPlayer );

		MoveToDebriefing(NewPlayer);
	}

	function MoveToDebriefing(PlayerController PC)
	{
		PC.ClientLateJoinToDebrefing('LateJoinToDebrefing');
	}
    function BeginState()
    {
		Super.BeginState();

		ActivateVictoryConditions(false);
		TriggerMapEvent(false);
	}

	exec function SetGameOn(bool gameOn);
}

function EndGame(PlayerReplicationInfo Winner, string Reason )
{
	local XBoxAddr EmptyAddr;
	local PlayerController PC;
	local int map_index;

	Super.EndGame(Winner, Reason);

	//The game is over, everyone can talk to each other now.
	foreach DynamicActors( class'PlayerController', PC )
	{
		PC.ServerChangeChannel(PC, EmptyAddr, 0, -VoiceChannelAllPlayers - 4);
	}

//	Level.GetLocalPlayerController().ConsoleCommand("open "$GetURLMap());

	if ( Level.NetMode == NM_DedicatedServer )
	{
		map_index = class'Gameplay.gbxMPMissionList'.static.FindMapIndex( Level.GetLevelFileName() );

		if (map_index == -1)  // not found?
		{
			// select another map at random...
			map_index = Rand( class'Gameplay.gbxMPMissionList'.static.GetMissionCount() );
		}
		else
		{
			map_index++;  // switch to the next map in the list
			if (map_index >= class'Gameplay.gbxMPMissionList'.static.GetMissionCount())
				map_index = 0;
		}

		next_map_index = map_index;

		GameReplicationInfo.NextMapName = class'Gameplay.gbxMPMissionList'.static.GetMap(next_map_index);
	}
}

function RegisterForKilledNotify( gbxVictoryCondition VC )
{
	// Make sure Victory Condition is not already registered...not that *ANYBODY* would do something like that :p
	local int i, currentLength;
	local bool bAlreadyRegistered;
	Log( " WargameMultiplayer::RegisterForKilledNotify()", 'MP' );

	if ( VC == None )
		return;

	currentLength = VictoryConditionsToNotifyOnKilledEvent.Length;

	for( i = 0; i < currentLength; ++i )
	{
		if(	( VictoryConditionsToNotifyOnKilledEvent[i] == VC ) )
		{
			Log( " WargameMultiplayer::RegisterForKilledNotify() VC: "$VC$ " already registered for killed notify.", 'MP' );		
			bAlreadyRegistered = true;
			break;
		}		
	}

	if ( !bAlreadyRegistered )
	{
		Log( " WargameMultiplayer::RegisterForKilledNotify() VC: "$VC$ " is now registered for killed notify.", 'MP' );		
		VictoryConditionsToNotifyOnKilledEvent.Insert( currentLength, 1 );
		VictoryConditionsToNotifyOnKilledEvent[currentLength] = VC;
	}
}

function UnregisterForKilledNotify( gbxVictoryCondition VC )
{
	local int i;
	Log( " WargameMultiplayer::UnregisterForKilledNotify()", 'MP' );

	if ( VC == None )
		return;

	for( i = 0; i < VictoryConditionsToNotifyOnKilledEvent.Length; ++i )
	{
		if(	( VictoryConditionsToNotifyOnKilledEvent[i] == VC ) )
		{
			Log( " WargameMultiplayer::UnregisterForKilledNotify() Found VC: "$VC$ " and unregistered for killed notify.", 'MP' );
			VictoryConditionsToNotifyOnKilledEvent.Remove( i, 1 );
			break;
		}		
	}
}

simulated function CharacterSetup.EMPCharacterTypes GetCharacterType( Controller aPlayer )
{
	local gbxPlayerController gbxPC;

	log( "WargameSkirmish::GetCharacterType() - aPlayer=" $ aPlayer, 'RSC' );

	gbxPC=gbxPlayerController(Level.GetLocalPlayerController());
	
	//log( "WargameSkirmish::GetCharacterType() - gbxPC=" $ gbxPC, 'RSC' );
	//log( "WargameSkirmish::GetCharacterType() - gbxPC.bUseGermanAccent=" $ gbxPC.bUseGermanAccent, 'RSC' );

	if (!(aPlayer.bIsPlayer) || gbxPC == None )
	{
		log( "WargameMulitplayer::GetCharacterType() - returned MPCharUSC, gbxPC=" $ gbxPC, 'RSC' );
		return MPCharUSC;
	}
	else
	{
		aPlayer.LastStartSpot = PlayerStart(FindPlayerStart( aPlayer ));
		if ((aPlayer.LastStartSpot != None) && aPlayer.LastStartSpot.IsA('gbxMPPlayerStart'))
		{
			if (gbxMPPlayerStart(aPlayer.LastStartSpot).TeamMemberID == 0)
			{
				if (aPlayer.PlayerReplicationInfo.Team.TeamIndex == 1)
				{
					log( "WargameMulitplayer::GetCharacterType() - returned MPPlayer1US", 'RSC' );
					return MPPlayer1US;
				}
				else
				{
					if( gbxPC.bUseGermanAccent )
					{
						//log( "WargameMulitplayer::GetCharacterType() - returned MPPlayer1EG", 'RSC' );
						return MPPlayer1DE;	// removing German Accents
						//return MPPlayer1EG;
					}
					else
					{
						//log( "WargameMulitplayer::GetCharacterType() - returned MPPlayer1DE", 'RSC' );
					return MPPlayer1DE;
				}
			}
			}
			else
			{
	if (aPlayer.PlayerReplicationInfo.Team.TeamIndex == 1)
	{
					log( "WargameMulitplayer::GetCharacterType() - returned MPPlayer2US", 'RSC' );
					return MPPlayer2US;
	}
	else
	{
					if( gbxPC.bUseGermanAccent )
					{
						//log( "WargameMulitplayer::GetCharacterType() - returned MPPlayer2EG", 'RSC' );
						return MPPlayer2DE;	// removing German Accents
						//return MPPlayer2EG;
					}
					else
					{
						//log( "WargameMulitplayer::GetCharacterType() - returned MPPlayer2DE", 'RSC' );
					return MPPlayer2DE;
				}
			}
		}
	}
	}

	log( "WargameMulitplayer::GetCharacterType() - returned MPCharUSC", 'RSC' );
	return MPCharUSC;
}

function bool CanUseCheckpoints( int nCheckpointID )
{
	return false;
}

defaultproperties
{
    bDelayedStart=true
    GameName="Airborne Operations"
    ScoreBoardType="gbxMP.WargameMultiplayerScoreboard"
    //ScoreBoardType="gbxGameplay.WargameScoreboard"
    bRestartLevel=True
    bPauseable=False
	FriendlyFireScale=0.0
	MaxTeams = 2
	MaxTeamSize = 2
	BeaconName="Wargame MP"
	MaxPlayers=4
	TimeLimit = 10
	CountDown=0
	NetWait=0
	ForMemoryReport=false
	bTeamGame=true
}class WargamePlayerController extends gbxPlayerController
	config(user);


const MAX_FIRE_PITCH=1536;	// Maximum amount of additive pitch you can give
const HEAVY_TRAUMA_SOUND_DELAY=0.5f;
const GAMMON_BOMB_USE_DIST=400;
const GAMMON_BOMB_MESSAGE_TIME_LIMIT=1.0f;

var gbxStaticView		AimControl;
var Vector				AlternateAim;
var float				YawAdjust, FirePitchAdjust, FirePitchSpeed;
var rotator				ViewChange;
var	Actor				m_aLockedTarget;
var globalconfig bool   NoBodyView;
var float				SprintFovMod;
var float				SprintFovModRate;
var float				AccumulatedSprintFov;

// Variables for use in drawing the crosshair for turreted weapons.
var Vector				CameraLoc;
var Rotator				CameraRot;

var globalconfig float zoom_threshold_speed;  // how fast should the player be moving before zooming out?
var float average_speed;
var float average_speed_time;
var float average_speed_array[10];  // 0.1 seconds per array slot
var int average_speed_oldest;

// Sound variables
var String	ZoomInSoundName;
var String  ZoomOutSoundName;
var Sound	ZoomInSound;
var Sound	ZoomOutSound;

var float	m_flNextStrafeHit;
var float	m_flLastFireTime;

// High Dynamic Range camera config
var globalconfig	Color	HDRGlobalColor;
var globalconfig	float	HDRFilterScalePass1;
var globalconfig	float	HDRFilterScalePass2;
var globalconfig	float	HDRFilterScalePass3;
var globalconfig	bool	bFullTimeHDR;
var globalconfig	bool	bNoHeavyTrauma;
var globalconfig	bool	bDoNotSave;
var globalconfig	float	UseKeyDelay;

var globalconfig bool bCheckpointMemLog;  // how fast should the player be moving before zooming out?

/// Rain control
var bool bIsRaining;				// DON'T SET DIRECTLY! use StartRaining() and StopRaining()
var bool bSuppressRainSounds;
var float NextRainEffect;
var float NextRainExposureUpdate;
var float RainPitchFactor;
var float BaseRainFrequency;
var float RainFrequencyVariance;
var float RainExposureTraceLength;
var float RainExposure;
var float RainExposureUpdateInterval;
var float RainIntensity;
var int RainExposureTestPitch;
var int NumRainExposureTests;
var Range RainParticleCount;

// Rain sound control
const MAX_RAIN_LOOPS = 5;
var float RainLoopVolume;
var int RainLoopHandle[MAX_RAIN_LOOPS];
var Sound RainLoopSound[MAX_RAIN_LOOPS];
var String RainLoopSoundName[MAX_RAIN_LOOPS];
var transient EmitterRain InWorldRainEmitter;

enum BreatheState
{
	Inhaling,
	Exhaling,
	Holding
};

enum RelativeDirection
{
	Left,
	Right,
	Up,
	Down,
	NoDir
};

var string BreatheInhaleSoundName;
var string BreatheExhaleSoundName;
var Sound  BreatheInhaleSound;
var Sound  BreatheExhaleSound;

/////// Breathe vars
// Input variables; all are lerped from Min to Max based on fatigue
var Range BreatheLength;
var Range BreatheHoldLength;
var Range BreatheLengthConsistency;		// 0 - 1 percentage that mucks with the consistency of the breathe pitch
var Range BreatheCrouchModifier;		// Applied to some input variables when crouched in order to decrease breathe effect while crouched

var Range BreatheStandModifierMP;		// Multiplayer wants to tone down breathing when players are standing

// API variables
var float CurrentBreatheStateCounter;	// Total time spent in current breathe state
var float CurrentBreatheStateLength;	// Length of time to spend in the current breathing state
var float PitchAdjustBuffer;		// Keeps track of cumulative pitch adjustments for fine accel/decel
var float YawAdjustBuffer;		// Keeps track of cumulative pitch adjustments for fine accel/decel
var BreatheState CurrentBreatheState;	// Current breathing action
var BreatheState PreviousBreatheState;	// Previous breathing action
var Rotator LastViewRotationCenter;		// Rotator that holds the current view rotation center.
var int BreatheYawTarget;				// Current target yaw of breathing.  This is changed randomly as the view yaw approaches this value.
var RelativeDirection LastYawAdjustDir;		// Keeps track of which way we were traveling the last tick, to see if we pass our mark
var bool bBreatheYawTargetSet;
var vector DeltaBreathe;
var Rotator NewViewRotation;
var int BreatheYawDiff;
var int BreatheYawTargetDist;
var float BreathePitchAttenuation;
var float BreatheYawAttenuation;
///////////

// Bug 8009: Context use message problems for explosives in MP
var gbxGammonBomb	MPExplosive;
var bool			bMPExplosiveMessageActive;

var bool			bLatecomer;		// entered multiplayer game after game started
var bool			bUseDeathCam;
var bool			bAimAssistStickToTargetWhenZoomed;
var bool			bShakeOnDamage;
var bool			bAdjustSprintFov;
var bool			bWaitingForPlayerBreak;
var bool			m_fViewOffsetAbs;
var bool			m_fDisplayUseMessage;
var bool			m_fUseZoomShake;
var bool			bOracleCameraDisabled;

var Rotator			ScriptViewOffset;
var Rotator			ScriptViewRestriction;

var Actor			LookingAtTarget;
var Vector			LookingAtTargetLocation;
var float			m_flBombMessageTime;
var gbxGammonBomb	m_aBombTarget;

var float			m_flUseKeyTimer;

var gbxStatsManager	StatsManager;

// Force the player to look at a particular actor, with a given range of motion
var Actor			ForcedFaceActor;
var float			ForcedFaceViewDiff;
var float			ForcedFaceViewDiffInit;
var float			ForcedFaceTurnRate;
var float			ForcedFaceViewDecelThreshold;
var bool			ForcedFaceAtDest;
var vector			PlayerCamLocation;
var vector			TargetLocation;
var vector			ForcedFaceDeltaTurn;
var rotator			ForcedFaceViewRestriction;

var float			m_flStartDeathCheck;
const DEATH_CHECK_LIMIT = 3.0f;

replication
{
	reliable if ( Role==ROLE_Authority )	// Client Side functions
		ChangeAim, ClientChangeView;

	reliable if ( Role<ROLE_Authority)
		ServerAltAim, ServerSloMo, PlayStartupMessage, ClientSendStats, ClientSendWeapon;

	reliable if ( Role<ROLE_Authority)
		ServerUnStick, ServerChangeLoadout, ServerUpdateStats, ServerGetNextWeaponStats, ServerChangeView;

	// Things the server should send to the client.
	unreliable if( Role==ROLE_Authority )
		ClientPlayTakeHit;
	
	//DS-BEGIN: Notify to the client, so it can force an update to xbox live stats
	reliable if( Role==ROLE_Authority )
		ClientGameStarted;
	//DS-END
}

function ClientMatchStarting()
{
	Super.ClientMatchStarting();

	if (bFullTimeHDR && Level.NetMode != NM_Standalone && !IsSplitScreen())
	{
		MakeHDRHappen();
	}
}

simulated function MakeHDRHappen()
{
	local PlayerController PC;
    local int playerindex;
    
	PC = Level.GetLocalPlayerController();

	Playerindex = 0;
	if ((PC != None) && (PC.Player != None))
	    playerindex = PC.Player.SplitIndex;

	EnableHighDynamicRange( true );

	if( Level.CameraEffectManager[playerindex].CamHighDynamicRangeEffect != None )
	{
		Level.CameraEffectManager[playerindex].CamHighDynamicRangeEffect.LateColor = HDRGlobalColor;
		Level.CameraEffectManager[playerindex].CamHighDynamicRangeEffect.FilterScale[0] = HDRFilterScalePass1;
		Level.CameraEffectManager[playerindex].CamHighDynamicRangeEffect.FilterScale[1] = HDRFilterScalePass2;
		Level.CameraEffectManager[playerindex].CamHighDynamicRangeEffect.FilterScale[2] = HDRFilterScalePass3;
	}
}

simulated function PostBeginPlay()
{
	Super.PostBeginPlay();
	
	EnableCamRendertarget( true );
	
	if( bFullTimeHDR && Level.NetMode == NM_Standalone)
	{
		MakeHDRHappen();
	}

	LastViewRotationCenter = Rotation;
}

simulated function PostNetBeginPlay()
{
	local int i;

	Super.PostNetBeginPlay();

	// Init rain sounds
	for( i = 0; i < MAX_RAIN_LOOPS; i++ )
	{
		if( RainLoopSoundName[ i ] != "" )
		{
			RainLoopSound[ i ] = Sound( DynamicLoadObject( RainLoopSoundName[ i ], class'Sound' ) );
		}
	}
}

// Local stats related functions

function ServerUpdateStats(TeamPlayerReplicationInfo PRI)
{
	ClientSendStats(PRI,PRI.GoalsScored,PRI.bFirstBlood, PRI.kills,PRI.suicides,PRI.FlagTouches,PRI.FlagReturns,PRI.FlakCount,PRI.ComboCount,PRI.HeadCount);
}

function ServerGetNextWeaponStats(TeamPlayerReplicationInfo PRI, int i)
{
	if ( i >= PRI.WeaponStatsArray.Length )
		return;

	ClientSendWeapon(PRI, PRI.WeaponStatsArray[i].WeaponClass, PRI.WeaponStatsArray[i].kills, PRI.WeaponStatsArray[i].deaths,PRI.WeaponStatsArray[i].deathsholding,i);
}

function ClientSendWeapon(TeamPlayerReplicationInfo PRI, class<Weapon> W, int kills, int deaths, int deathsholding, int i)
{
	PRI.UpdateWeaponStats(PRI,W,Kills,Deaths,DeathsHolding);
	ServerGetNextWeaponStats(PRI,i+1);
}

simulated function ClientSendStats(TeamPlayerReplicationInfo PRI, int newgoals, bool bNewFirstBlood, int newkills, int newsuicides, int newFlagTouches, int newFlagReturns, int newFlakCount, int newComboCount, int newHeadCount)
{
	PRI.GoalsScored = newGoals;
	PRI.bFirstBlood = bNewFirstBlood;
	PRI.Kills = NewKills;
	PRI.Suicides = NewSuicides;
	PRI.FlagTouches = NewFlagTouches;
	PRI.FlagReturns = NewFlagReturns;
	PRI.FlakCount = NewFlakCount;
	PRI.ComboCount = NewComboCount;
	PRI.HeadCount = NewHeadCount;
}

//////// ============= These are just for debugging
/*
simulated exec function SetAdjustStep(float NewStep)
{
	if ( (Pawn!=None) && (gbxWeapon(Pawn.Weapon)!=None) )
		gbxWeapon(Pawn.Weapon).SetAdjustStep(newstep);
}

simulated exec function IncAdjustStep()
{
	if ( (Pawn!=None) && (gbxWeapon(Pawn.Weapon)!=None) )
		gbxWeapon(Pawn.Weapon).IncAdjustStep();
}

simulated exec function DecAdjustStep()
{
	if ( (Pawn!=None) && (gbxWeapon(Pawn.Weapon)!=None) )
		gbxWeapon(Pawn.Weapon).DecAdjustStep();
}

simulated exec function SetAdjustPerson(int NewPerson)
{
	if ( (Pawn!=None) && (gbxWeapon(Pawn.Weapon)!=None) )
		gbxWeapon(Pawn.Weapon).SetAdjustPerson(newPerson);
}

simulated exec function AdjustX(int dir)
{
	if ( (Pawn!=None) && (gbxWeapon(Pawn.Weapon)!=None) )
		gbxWeapon(Pawn.Weapon).AdjustX(dir);
}

simulated exec function AdjustY(int dir)
{
	if ( (Pawn!=None) && (gbxWeapon(Pawn.Weapon)!=None) )
		gbxWeapon(Pawn.Weapon).AdjustY(dir);
}

simulated exec function AdjustZ(int dir)
{
	if ( (Pawn!=None) && (gbxWeapon(Pawn.Weapon)!=None) )
		gbxWeapon(Pawn.Weapon).AdjustZ(dir);
}
*/

/////// ======================================

exec notinship function ShowBeacons()
{
	local gbxBeacons B;

	foreach DynamicActors(class'gbxBeacons',b)
	{

		if ( ( (B.bOptional) && (!b.bEnabled) ) && (b.Team == PlayerReplicationInfo.Team.TeamIndex) )
			B.MakeVisible();
	}
}

exec notinship function UnStick()
{
	ServerUnStick();
}

function ServerUnStick()
{
	local PlayerStart P;


	foreach AllActors(class'PlayerStart',P)
	{
		if (P.TeamNumber == PlayerReplicationInfo.Team.TeamIndex)
		{
			Pawn.Setlocation(P.Location);
			Pawn.SetRotation(P.Rotation);
		}
	}
}

exec notinship function SetServerSloMo(float t)
{
	ServerSloMo(t);
}

function ServerSloMo( float T )
{
	Level.Game.SetGameSpeed(T);
	Level.Game.SaveConfig();
	Level.Game.GameReplicationInfo.SaveConfig();
	log("#### Adjusting GameSpeed to :"$T);
}


exec function lognote(string x)
{
	log(x);
}

function SetRelevantMPExplosive(gbxGammonBomb Explosive)
{
	if (MPExplosive != None && Explosive == None)
	{
		if (bMPExplosiveMessageActive)
		{
			MPExplosive.ClearContextMessage(self);
			bMPExplosiveMessageActive = false;
		}
	}

	MPExplosive = Explosive;
}

function MPExplosiveUsed()
{
	if (!MPExplosive.DisplayContextMessage(self))
	{
		MPExplosive.ClearContextMessage(self);
		bMPExplosiveMessageActive = false;
	}
}

event ServerPlayerTick( float DeltaTime )
{
	local WargamePawn P;

	Super.ServerPlayerTick(DeltaTime);

	P = WargamePawn(Pawn);

	// Need to do fatigue recovery here since the server uses fatigue for everyone
	// However locally controlled controllers will have fatigue recovered in PlayerTick()
	// SJP: Modified to only recover if there is no controller input
	if (P != None && !P.IsLocallyControlled() && ( aForward < 0.01 || aForward > -0.01 || aStrafe < 0.01 || aStrafe > -0.01 ) )
	{
		DoFatigueRecovery( P.FatigueRecovery_Player, DeltaTime );
	}

	if (MPExplosive != None && P != None)
	{
		if (MPExplosive.bBlowingUp)
		{
			SetRelevantMPExplosive(None);
		}
		else if (GameReplicationInfo.GameType != GT_SKIRMISH && !P.IsPawnLookingAtActor(MPExplosive, 0.65f))
		{
			if (bMPExplosiveMessageActive)
			{
				MPExplosive.ClearContextMessage(self);
				bMPExplosiveMessageActive = false;
			}
		}
		else if (!bMPExplosiveMessageActive)
		{
			if (MPExplosive.DisplayContextMessage(self))
			{
				bMPExplosiveMessageActive = true;
			}
		}
	}
}

event PlayerTick(float Delta)
{
	local WargamePawn P;
	local bool ChangeBreatheState, bIsNegative, bDidSubtract;
	local Rotator NewViewRotation;
	//local float BreathePitchAttenuation, BreatheYawAttenuation;
	local float SprintFovDelta;
	local int Random, i;
	local float CurrentBreatheAttenAccel, CurrentBreatheAttenDecel;
	local float ModFatigue, WorkingCrouchMod, cFloat, CalcRainIntensity;
	local RelativeDirection NewYawAdjustDir;
	local gbxWeapon myWeapon;
	local Vector X, Y, Z;

	//	local float flRunRate, flRunPct;

	//local float speed;
	//local int index;
	//local float total_speed;

	// If the Pawn is a player Pawn... Adjust the controller's Rotation

	P = WargamePawn(Pawn);

	if (P!=None)
		P.RestoreViews(Delta);

	Super.PlayerTick(Delta);

	// GBX:naj - added 4/16/03 - to get rid of 'Accessed None's during Matinee.
	if (Pawn == None)
		return;
	// GBX:naj - end added 4/16/03

	if (P != None)
	{
		if( P.bIsSprinting && bAdjustSprintFov )
		{
			if( AccumulatedSprintFov < SprintFovMod )
			{
				SprintFovDelta = Delta * SprintFovModRate;
				AccumulatedSprintFov = FMin( AccumulatedSprintFov + SprintFovDelta, SprintFovMod );
        	    DesiredFOV += SprintFovDelta;
			}
		}
		else if( AccumulatedSprintFov > 0.0 )
		{
			SprintFovDelta = Delta * SprintFovModRate * 2;
			AccumulatedSprintFov = FMax( AccumulatedSprintFov - SprintFovDelta, 0.0 );
			DesiredFOV -= SprintFovDelta;
		}
	}

	////// SJP: Handle rain
	if( bIsRaining )
	{
		//log( self$"::PlayerTick() bIsRaining is true!  Level.TimeSeconds="$Level.TimeSeconds$" NextRainExposureUpdate="$NextRainExposureUpdate );
		
		// No rain in splitscreen!
		if( IsSplitScreen() )
		{
			StopRaining();
		}
		else if( Level.TimeSeconds >= NextRainExposureUpdate )
		{
			//log( self$"::PlayerTick() Time to update rain exposure!" );
			
			NextRainExposureUpdate = Level.TimeSeconds + RainExposureUpdateInterval;
			RainExposure = CalculateRainExposure();
			CalcRainIntensity = RainExposure * RainIntensity;

			//log( self$"::PlayerTick() CalcRainIntensity="$CalcRainIntensity );

			// In world effect
			if( InWorldRainEmitter != None )
			{
				InWorldRainEmitter.SetLocation( Pawn.Location );
			}

			// Sound.  Overlap loops depending on exposure to rain.

			if( !bSuppressRainSounds )
			{
				cFloat = float( MAX_RAIN_LOOPS );

				for( i = 0; i < MAX_RAIN_LOOPS; i++ )
				{
					//log( self$"::PlayerTick() RainLoopHandle[ i ]="$RainLoopHandle[ i ]$" cFloat="$cFloat );
					
					// Too bad zero doesn't actually equal zero
					if( CalcRainIntensity > 0.001 && CalcRainIntensity > ( float( i ) / cFloat ) )
					{
						//log( self$"::PlayerTick() Might play a sound!" );
						if( RainLoopHandle[ i ] < 0 )
						{
							if( RainLoopSound[ i ] != None )
							{
								//log( self$"::PlayerTick() Playing sound "$RainLoopSound[i] );
								RainLoopHandle[ i ] = PlaySound( RainLoopSound[ i ], SLOT_NONE, RainLoopVolume,,,,false );
							}
						}
					}
					else
					{
						//log( self$"::PlayerTick() Might stop a sound!" );
						if( RainLoopHandle[ i ] > 0 )
						{
							//log( self$"::PlayerTick() Stopping sound handle "$RainLoopHandle[i] );
							StopSound( RainLoopHandle[ i ] );
							RainLoopHandle[ i ] = -1;
						}
					}
				}
			}
		}

		// HUD
		GetAxes( GetViewRotation(), X, Y, Z );
		NextRainEffect = NextRainEffect - X.Z * Delta * RainPitchFactor; // Rain frequency varies depending on the player's view pitch
    
		if( RainExposure > 0.0 && Level.TimeSeconds > NextRainEffect )
		{
			NextRainEffect = Level.TimeSeconds + RandRange( 0, RainFrequencyVariance / RainIntensity ) + BaseRainFrequency / RainIntensity;
			CreateHudRainEffect( RandRange( RainParticleCount.Min, RainParticleCount.Max ) * RainExposure );
		}
	}

	////// SJP: Handle delayed actions
	if( PendingDelayedAction != NoAction )
	{
		switch( PendingDelayedAction )
		{
			case ToggleWeaponAfterZoomOut :

				if( !IsZoomed() )
				{
					ToggleWeapon();
					PendingDelayedAction = ZoomInAfterWeaponSwitch;
				}

			break;

			case ToggleWeaponAfterZoomOutAfterFire :
			
				if (!gbxWeapon(Pawn.Weapon).m_fPlayingFire && !gbxWeapon(Pawn.Weapon).IsWeaponFiring())
				{
					ChangeView(0);
					PendingDelayedAction = ToggleWeaponAfterZoomOut;
				}
			
			break;

			case ZoomInAfterWeaponSwitch :

				if( Pawn.Weapon.ClientState == WS_ReadyToFire )
				{
					ChangeView(1);
					PendingDelayedAction = NoAction;
				}

			break;

			case ReloadAfterZoomOut :

				if( !IsZoomed() )
				{
					gbxWeapon(Pawn.Weapon).ReloadWeapon();
					PendingDelayedAction = ZoomInAfterReload;
				}

			break;

			case ZoomInAfterReload :

				if( !Pawn.Weapon.IsReloading() )
				{
					ChangeView(1);
					PendingDelayedAction = NoAction;
				}

			break;

			case PutDownWeaponAfterZoomOut :

				if( !IsZoomed() )
				{
					Pawn.Weapon.PutDown();
					PendingDelayedAction = NoAction;
				}

			break;

			case PutDownWeaponAfterReload :

				if( !Pawn.Weapon.IsReloading() )
				{
					Pawn.Weapon.PutDown();
					PendingDelayedAction = NoAction;
				}

			break;
			
			case PutDownWeaponAfterMelee :
						
				if( !gbxWeapon(Pawn.Weapon).m_fPlayingMelee )
				{
					Pawn.Weapon.PutDown();
					PendingDelayedAction = NoAction;
				}	
			
			break;
		}
	}

	if( gbxWeapon(Pawn.Weapon) != None )
		myWeapon = gbxWeapon(Pawn.Weapon);

	////// SJP: Breathing while zoomed in
	if( DesiredFOV < DefaultFOV && myWeapon != None )
	{
		// Update the current view center
		if( !(aTurn == 0.0 && aLookUp == 0.0) )
		{
			LastViewRotationCenter = Rotation;
		}

		if( CurrentBreatheStateCounter >= CurrentBreatheStateLength )
		{
			ChangeBreatheState = true;
			CurrentBreatheStateCounter = 0.0;
		}
		else
		{
			ChangeBreatheState = false;
		}

		ModFatigue = Cos( (PI / 2.0) * ( 1 - m_flFatigue ) );
		BreatheYawAttenuation = 0;
		BreathePitchAttenuation = 0;
		DeltaBreathe.X = 0;
		DeltaBreathe.z = 0;

		if( Pawn.bIsCrouched )
		{
			WorkingCrouchMod = Lerp( ModFatigue, BreatheCrouchModifier.Min, BreatheCrouchModifier.Max );
		}
		else
		{
			if (Level.NetMode == NM_Standalone)
			{
				WorkingCrouchMod = 1.0;
			}
			else
			{
				WorkingCrouchMod = Lerp( ModFatigue, BreatheStandModifierMP.Min, BreatheStandModifierMP.Max );
			}
		}

		if( CurrentBreatheState == BreatheState.Inhaling || CurrentBreatheState == BreatheState.Exhaling )
		{				
			if( ChangeBreatheState )
			{
				PreviousBreatheState = CurrentBreatheState;
				CurrentBreatheState = BreatheState.Holding;

				if( ModFatigue == 0.0 )
					CurrentBreatheStateLength = BreatheHoldLength.Max;
				else
					CurrentBreatheStateLength = BreatheHoldLength.Min;

			}
			else
			{
				NewViewRotation = Rotation;

				// Add acceleration and deceleration to the motion
				CurrentBreatheAttenAccel = Lerp( 1 - ModFatigue, myWeapon.BreatheProfileClass.default.BreatheAttenAccel.Min, myWeapon.BreatheProfileClass.default.BreatheAttenAccel.Max );
				CurrentBreatheAttenDecel = Lerp( 1 - ModFatigue, myWeapon.BreatheProfileClass.default.BreatheAttenDecel.Min, myWeapon.BreatheProfileClass.default.BreatheAttenDecel.Max );

				if( CurrentBreatheStateCounter / CurrentBreatheStateLength <= CurrentBreatheAttenAccel )
				{
					BreathePitchAttenuation = ComputeAttenuation( CurrentBreatheAttenAccel, CurrentBreatheStateCounter, CurrentBreatheStateLength, true );
				}
				else
				{
					BreathePitchAttenuation = ComputeAttenuation( CurrentBreatheAttenDecel, CurrentBreatheStateCounter, CurrentBreatheStateLength );
				}

				// Pick a random point within the yaw threshold to move the yaw toward, only if the view is still
				if( !bBreatheYawTargetSet )
				{
					Random = rand( Lerp( ModFatigue, myWeapon.BreatheProfileClass.default.BreatheYawLimit.Min, myWeapon.BreatheProfileClass.default.BreatheYawLimit.Max ) * WorkingCrouchMod );
					
					if(  rand( 100 ) > 50 )
						Random *= -1;

					BreatheYawTargetDist = Random;

					if( Abs( BreatheYawTargetDist ) > 0 )
						bBreatheYawTargetSet = true;
				}
				else
				{
					BreatheYawTarget = LastViewRotationCenter.yaw + BreatheYawTargetDist;
					BreatheYawAttenuation = FMax( 0.25, ComputeAttenuation( 1.0 - CurrentBreatheAttenDecel, BreatheYawDiff, Abs(BreatheYawTargetDist), true ) );

					// Determine if we're at the yaw threshold for this breathe
					bDidSubtract = false;
					BreatheYawDiff = NewViewRotation.yaw - BreatheYawTarget;
					if( BreatheYawDiff < 0 ) bIsNegative = true;
					BreatheYawDiff = Abs(BreatheYawDiff);

					if( BreatheYawDiff > 32768 )
					{
						BreatheYawDiff = 65536 - BreatheYawDiff;
						bDidSubtract = true;
					}

					if ( ( bDidSubtract && bIsNegative ) || ( !bDidSubtract && !bIsNegative ) )
					{
						NewYawAdjustDir = RelativeDirection.Left;
					}
					else
					{
						NewYawAdjustDir = RelativeDirection.Right;
					}

					if( LastYawAdjustDir != NewYawAdjustDir )
					{
						bBreatheYawTargetSet = false;
					}
					
					LastYawAdjustDir = NewYawAdjustDir;
				}

				DeltaBreathe.X = WorkingCrouchMod * Delta * Lerp( ModFatigue, myWeapon.BreatheProfileClass.default.BreatheYawAdjustRate.Min, myWeapon.BreatheProfileClass.default.BreatheYawAdjustRate.Max ) * BreatheYawAttenuation;
				DeltaBreathe.Z = WorkingCrouchMod * Delta * Lerp( ModFatigue, myWeapon.BreatheProfileClass.default.BreathePitchAdjustRate.Min, myWeapon.BreatheProfileClass.default.BreathePitchAdjustRate.Max ) * BreathePitchAttenuation;

				// These buffers ensure a smooth rotation as the breathe motion slows down.
				if( DeltaBreathe.X < 1.0 )
				{
					YawAdjustBuffer += DeltaBreathe.X;
					
					if( YawAdjustBuffer >= 1 )
					{
						DeltaBreathe.X = 1;
						YawAdjustBuffer = 0.0;
					}
					else
						DeltaBreathe.X = 0;
				}

				if( DeltaBreathe.Z < 1.0 )
				{
					PitchAdjustBuffer += DeltaBreathe.Z;

					if( PitchAdjustBuffer >= 1 )
					{
						DeltaBreathe.Z = 1;
						PitchAdjustBuffer = 0.0;
					}
					else
						DeltaBreathe.Z = 0;
				}

				if( NewYawAdjustDir == RelativeDirection.Left )
					NewViewRotation.yaw -= DeltaBreathe.X;
				else
					NewViewRotation.yaw += DeltaBreathe.X;

				if( CurrentBreatheState == BreatheState.Inhaling )
				{
					if( ( NewViewRotation.pitch <= 18000 && NewViewRotation.pitch + DeltaBreathe.z <= 18000 ) || 
						( NewViewRotation.pitch >= 49152 && NewViewRotation.pitch + DeltaBreathe.z >= 49152 ) )
					{
						NewViewRotation.pitch += DeltaBreathe.Z;
					}
				}
				else
				{
					if( ( NewViewRotation.pitch <= 18000 && NewViewRotation.pitch - DeltaBreathe.z <= 18000 ) || 
						( NewViewRotation.pitch >= 49152 && NewViewRotation.pitch - DeltaBreathe.z >= 49152 ) )
					{
						NewViewRotation.pitch -= DeltaBreathe.Z;
					}
				}

				SetRotation(NewViewRotation);
			}
		}
		else
		{
			if( ChangeBreatheState )
			{
				if( BreatheExhaleSound == None && BreatheInhaleSound == None && BreatheExhaleSoundName != "" && BreatheInhaleSoundName != "" )
				{
					BreatheExhaleSound = Sound( DynamicLoadObject(BreatheExhaleSoundName, class'Sound') );
					BreatheInhaleSound = Sound( DynamicLoadObject(BreatheInhaleSoundName, class'Sound') );
				}

				if( PreviousBreatheState == BreatheState.Inhaling )
				{
					CurrentBreatheStateLength = Lerp( 1 - ModFatigue, BreatheLength.Min, BreatheLength.Max ) 
						* (1 - FRand() * ( 1 - Lerp( 1 - ModFatigue, BreatheLengthConsistency.Min, BreatheLengthConsistency.Max ) ));

					CurrentBreatheState = BreatheState.Exhaling;

					if( BreatheExhaleSound != None )
						Pawn.PlaySound( BreatheExhaleSound, SLOT_Talk );
				}
				else
				{
					CurrentBreatheStateLength = Lerp( 1 - ModFatigue, BreatheLength.Min, BreatheLength.Max ) 
						* (1 - FRand() * ( 1 - Lerp( 1 - ModFatigue, BreatheLengthConsistency.Min, BreatheLengthConsistency.Max ) ));

					CurrentBreatheState = BreatheState.Inhaling;
					
					if( BreatheInhaleSound != None )
						Pawn.PlaySound( BreatheInhaleSound, SLOT_Talk );
				}

				PreviousBreatheState = BreatheState.Holding;
			}
		}

		CurrentBreatheStateCounter += Delta;
	}
	else
	{
		if( aTurn != 0 || aLookUp != 0 )
		{
			PreviousBreatheState = BreatheState.Exhaling;
			CurrentBreatheState = BreatheState.Holding;
			
			if( ModFatigue == 0.0 )
				CurrentBreatheStateLength = BreatheHoldLength.Max;
			else
				CurrentBreatheStateLength = BreatheHoldLength.Min;

			CurrentBreatheStateCounter = 0.0;
		}
	}

	if (P != None)
	{
		if ( aForward > 0.0 || aForward < 0.0 || aStrafe > 0.0 || aStrafe < 0.0 )
		{
			if (Pawn.bIsSprinting)
			{
				IncreaseFatigue( P.FatigueRate_Sprinting, Delta );
			}
			else if ( VSize( P.Velocity ) > 0.01 )
			{
				if ( P.bIsCrouched )
				{
					IncreaseFatigue( P.FatigueRate_Walking, Delta );
				}
				else
				{
					IncreaseFatigue( P.FatigueRate_Running, Delta );
				}
			}
		}
		else
		{
			DoFatigueRecovery( P.FatigueRecovery_Player, Delta );
		}
	}

// GBX:PAD: This retracts the weapon when running.  I'm taking it out for now since we might want to find a better
// looking way to do things.
/*
	if ((gbxWeapon(P.Weapon) != None) && !P.bIsSprinting)
	{
		speed = VSizeIgnoreZ(Pawn.Velocity);
		
		flRunRate = speed - (P.GroundSpeed * P.WalkingThreshold);
		if (flRunRate > 0)
		{
			flRunPct = flRunRate / (P.GroundSpeed - (P.GroundSpeed * P.WalkingThreshold));
			gbxWeapon(P.Weapon).m_flBaseOffset = flRunPct * P.RUN_WEAPON_RETRACT;
//			log(self$".PlayerTick() - "$speed$" - "$flRunRate$" - "$flRunPct$" - "$P.GroundSpeed$" - "$P.WalkingThreshold);
		}
		else
		{
			gbxWeapon(P.Weapon).m_flBaseOffset = 0.0f;
		}
	}
*/
	// GBX:PAD: We don't want the view to automatically zoom out when the player moves any more.  If we ever do put
	// this back in, note that the current code doesn't check to see if one is in a zoomed out state, so it constantly
	// tries to zoom out and messes up firing the weapon.
/*
	average_speed += speed * Delta;

	if (average_speed_time < Level.TimeSeconds)  // time to store the average velocity?
	{
		average_speed_time = Level.TimeSeconds + 0.1;
		average_speed_array[average_speed_oldest] = average_speed;
		average_speed_oldest = (average_speed_oldest + 1) % 10;
		average_speed = 0.0f;

		total_speed = 0.0f;
		for (index = 0; index < 10; index++)
			total_speed += average_speed_array[index];

		if ((total_speed > zoom_threshold_speed) && P.bWeaponDrawn)
		{
			// automatically zoom out of down-the-sight mode if moving too fast
			ChangeView(0);
		}
	}
*/
	if (!(Level.m_fIsDemo))
	{
		// GBX:naj - Activate the AI Debug Camera.
		if ( (bXButton == 1) && (bAButton == 1 ))
		{
			ConsoleCommand( "ActivateAIDebugCam" );
		}
	}

	if (LookingAtTarget != None)
	{
		if ((Level.TimeSeconds - m_flBombMessageTime) > GAMMON_BOMB_MESSAGE_TIME_LIMIT)
		{
			Pawn.ReceiveLocalizedMessage(class'gbxWeaponPickupMessage', -1);
			Pawn.ReceiveLocalizedMessage(class'gbxWeaponRestockMessage', -1);
			Pawn.ReceiveLocalizedMessage(class'gbxContextUseHUDMessage', -1);  // remove the message from the HUD
			LookingAtTarget = None;
		}
	}
	
	if ((bXButton == 1) && gbxPawn(Pawn).m_fPrimaryWeaponSelect)
	{
		if ((Level.TimeSeconds - m_flUseKeyTimer) > UseKeyDelay)
		{
			UseKeyUp();
		}
	}
}

exec function RefreshHealth()
{
	if( Level.NetMode == NM_Standalone )
	{
		Pawn.Health = Pawn.default.Health;
	}
}

function ClampFatigueSpecial()
{
	if ( GameReplicationInfo.GameType != GT_MULTIPLAYER )
	{
		m_flFatigue = FClamp( m_flFatigue, 0.1, 1.0 );
	}
	else
	{
		m_flFatigue = FClamp( m_flFatigue, 0.0, 1.0 );
	}
}

simulated function StartRaining( optional float Intensity, optional bool bNoSound )
{
	//log( self$"::StartRaining("$Intensity$","$bNoSound$")" );
	
	if( bIsRaining )
	{
		//log( self$"::StartRaining("$Intensity$","$bNoSound$") Bailing since bIsRaining is already true!" );
		
		return;
	}

	if( Intensity > 0.0 )
	{
		AdjustRainIntensity( Intensity );
	}

	//log( self$"::StartRaining("$Intensity$","$bNoSound$") InWorldRainEmitter="$InWorldRainEmitter );

	if( InWorldRainEmitter == None )
	{
		//log( self$"::StartRaining("$Intensity$","$bNoSound$") Spawned rain emitter: InWorldRainEmitter="$InWorldRainEmitter );
		InWorldRainEmitter = Spawn( class'EmitterRain', self );
		InWorldRainEmitter.SetLocation( Pawn.Location );
		Log( "*****SJP: "$self$" spawned "$InWorldRainEmitter, 'SJP' );
	}

	ResetRainSounds();	
	bIsRaining = true;
	bSuppressRainSounds = bNoSound;
}

// Adjust the rain effect frequency
// 1.0 = MAX
simulated function AdjustRainIntensity( float Intensity )
{
	RainIntensity = FClamp( Intensity, 0.0, 1.0 );
	InWorldRainEmitter.AdjustRainIntensity( Intensity );
	NextRainEffect = 0.0;
}

simulated function StopRaining()
{
	ResetRainSounds();
	InWorldRainEmitter.Destroy();
	InWorldRainEmitter = None;
	bIsRaining = false;
	bSuppressRainSounds = default.bSuppressRainSounds;
}

simulated function ResetRainSounds()
{
	local int i;
	
	//log( self$"::ResetRainSounds()" );

	for( i = 0; i < MAX_RAIN_LOOPS; i++ )
	{
		if( RainLoopHandle[ i ] > 0 )
		{
			//log( self$"::ResetRainSounds() Stopping sound handle "$RainLoopHandle[i] );
			StopSound( RainLoopHandle[ i ] );
		}

		RainLoopHandle[ i ] = -1;
	}
}

function UpdateRotation(float DeltaTime, float maxPitch)
{
	local rotator newRotation, ViewRotation, IdealRotation;
	local Actor ViewActor;
	local Vector CrossVector, NewTargetVector;
	local float Atten;
	local int YawDist, PitchDist;
	local int DistToUp, DistToDown;
//	local WargamePawn	P;

	if (gbxPawn(Pawn) != None)
	{
		if( gbxPawn(Pawn).bAttachCamToHead )
			return;
	}

	if ( bInterpolating || ((Pawn != None) && Pawn.bInterpolating) )
	{
		ViewShake(deltaTime);
		return;
	}

	if (m_fUseZoomShake)
	{
		return;
	}
	
	if ((gbxPawn(Pawn) != None) && gbxPawn(Pawn).bScriptedCamInHead)
	{
		ViewRotation = ScriptViewOffset;

		TurnTarget = None;
		bRotateToDesired = false;
		bSetTurnRot = false;
		ViewRotation.Yaw += DeltaTime * aTurn;
		ViewRotation.Pitch += DeltaTime * aLookUp;
		
		if (ViewRotation.Pitch > ScriptViewRestriction.Pitch)	// Roughly 30 degrees
			ViewRotation.Pitch = ScriptViewRestriction.Pitch;
		else if (ViewRotation.Pitch < -ScriptViewRestriction.Pitch)
			ViewRotation.Pitch = -ScriptViewRestriction.Pitch;

		if (ViewRotation.Yaw > ScriptViewRestriction.Yaw)	// Roughly 30 degrees
			ViewRotation.Yaw = ScriptViewRestriction.Yaw;
		else if (ViewRotation.Yaw < -ScriptViewRestriction.Yaw)
			ViewRotation.Yaw = -ScriptViewRestriction.Yaw;

		ScriptViewOffset = ViewRotation;
		if (m_MatineeScript != None)
			m_MatineeScript.ScriptViewOffset = ScriptViewOffset;
	}
	else if( ForcedFaceActor != None )
	{
		PlayerCalcView( ViewActor, PlayerCamLocation, ViewRotation );

		// SJP: Forced Facing Actor
		TurnTarget = None;
		bRotateToDesired = false;
		bSetTurnRot = false;

		TargetLocation = ForcedFaceActor.Location;

		if( ForcedFaceActor.IsA('Pawn') )
		{
			 TargetLocation += Pawn(ForcedFaceActor).EyePosition();
		}

		if( !ForcedFaceAtDest )
		{
			// Vector from target to player's aim vector; shortest distance
			CrossVector = ( PlayerCamLocation + Vector( ViewRotation ) * VSize( TargetLocation - PlayerCamLocation ) ) - TargetLocation;

			// shortest distance
			ForcedFaceViewDiff = VSize( CrossVector );

			if( ForcedFaceViewDiffInit == 0.0 )
			{
				ForcedFaceViewDiffInit = ForcedFaceViewDiff;
			}

			if( ForcedFaceViewDiff > 1.0 )
			{
				// Slow down the rotation as it approaches the target
				Atten = ComputeAttenuation( ForcedFaceViewDecelThreshold, ForcedFaceViewDiffInit - ForcedFaceViewDiff, ForcedFaceViewDiffInit );

				ForcedFaceDeltaTurn = Normal( CrossVector ) * ( ForcedFaceViewDiff - DeltaTime * ForcedFaceTurnRate * Atten );

				// New aim target is a point toward the TargetLocation along CrossVector
				NewTargetVector = TargetLocation + ForcedFaceDeltaTurn;

				// New view rotation is the line from the player's camera location to NewTargetVector
				ViewRotation = Rotator( NewTargetVector - PlayerCamLocation );
			}
			else
			{
				ForcedFaceAtDest = true;
			}
		}
		else
		{
			IdealRotation = Rotator( TargetLocation - PlayerCamLocation );

			YawDist = abs( AngleDiff( IdealRotation.yaw, ViewRotation.yaw ) );
			PitchDist = abs( AngleDiff( IdealRotation.pitch, ViewRotation.pitch ) );

			// Don't attenuate look speed if we're moving toward the ideal rotation
			if( abs( AngleDiff( IdealRotation.yaw, ViewRotation.yaw + DeltaTime * aTurn ) ) < YawDist )
				YawDist = 0;

			if( abs( AngleDiff( IdealRotation.pitch, ViewRotation.pitch + DeltaTime * aLookUp ) ) < PitchDist )
				PitchDist = 0;

			// Attenuate look speed based on how close we are to the limits
			ViewRotation.yaw += DeltaTime * aTurn * ComputeAttenuation( 0.75, YawDist, ForcedFaceViewRestriction.yaw ); 
			ViewRotation.pitch += DeltaTime * aLookUp * ComputeAttenuation( 0.75, PitchDist, ForcedFaceViewRestriction.pitch );
			
			// Normal view clamping stuff
			ViewRotation.Pitch = ViewRotation.Pitch & 65535;

			If ((ViewRotation.Pitch > 18000) && (ViewRotation.Pitch < 49152))
			{
				DistToUp = ViewRotation.Pitch - 18000;
				DistToDown = 49152 - ViewRotation.Pitch;

				if( DistToUp < DistToDown )
					ViewRotation.Pitch = 18000;
				else
					ViewRotation.Pitch = 49152;
			}
		}

		SetRotation( ViewRotation );
	}
	else
	{
		ViewRotation = Rotation;
		DesiredRotation = ViewRotation; //save old rotation

		TurnTarget = None;
		bRotateToDesired = false;
		bSetTurnRot = false;
//		if (Level.m_bFadeScreen == 0)
		// GBX:PAD: If the map is in fade start black mode, then go ahead and pre-empt mouse input so that they
		// will hopefully not be looking at their feet when the map starts.
//		if (!(Level.IsMenuMap()) && ((Level.NetMode != NM_StandAlone) || (Level.m_bFadeScreen != 3)))
		if ((Level.NetMode != NM_StandAlone) || (Level.m_bFadeScreen != 3))
		{
			ViewRotation.Yaw += DeltaTime * aTurn;
			ViewRotation.Pitch += DeltaTime * aLookUp;
		}
		
		ViewRotation.Pitch = ViewRotation.Pitch & 65535;

		if ((ViewRotation.Pitch > 18000) && (ViewRotation.Pitch < 49152))
		{
			DistToUp = ViewRotation.Pitch - 18000;
			DistToDown = 49152 - ViewRotation.Pitch;

			if( DistToUp < DistToDown )
				ViewRotation.Pitch = 18000;
			else
				ViewRotation.Pitch = 49152;
		}


		SetRotation(ViewRotation);
	}

	ViewShake(deltaTime);
	ViewFlash(deltaTime);

	if ( !bRotateToDesired && (Pawn != None) && (!bFreeCamera || !bBehindView) && !gbxPawn(Pawn).bScriptedCamInHead )
	{
		NewRotation = ViewRotation;
		NewRotation.Roll = Rotation.Roll;

		Pawn.FaceRotation(NewRotation, deltatime);
	}
}

event bool IsZoomed()
{
	local gbxPawn gbxP;

	if( gbxPawn(Pawn) != None )
	{
		gbxP = gbxPawn(Pawn);
		if ( gbxP.bIsManningTurret )
		{
			return gbxP.Turret.IsZoomed();
		}
		else
		{
			// GBX:PAD: I've changed this since the WAS_Sighted aim state is not necessarily valid for player pawns just
			// yet.  For now, lets just check the weapons aimed state.
//			return gbxP.TestWeaponAimedState( WAS_Sighted );
			if (gbxWeapon(gbxP.Weapon) != None)
			{
				//SDJ 06/26/2004: HACK! The weapon zoom system isn't at all MP friendly.  For remote clients the server doesn't have real
				//                Weapon.m_fZoomed values so it has to guess that a client is zoomed by comparing desiredFOV to defaultFOV,
				//                which are replicated correctly.  This is a quick fix to help players feel better about MP weapon accuracy.
				//                If we ever have time to redo the weapon system for MP then be sure to fix this.
				if (Pawn.IsLocallyControlled())
				{
					return gbxWeapon(gbxP.Weapon).m_fZoomed;
				}
				else
				{
					if (DesiredFov < DefaultFOV)
					{
						return true;
					}
					else
					{
						return false;
					}
				}
			}
		}
	}
	else
	{
		return Super.IsZoomed();
	}
}
function EndZoom()
{
	if( Pawn != None && Pawn.IsHumanControlled() )
		ChangeView(0);
}

event Destroyed()
{
    local gbxVehicle gbxDrivenVehicle;
	local Pawn Driver;

	// Remove the aim control when this controller is destroyed

	if (AimControl!=None)
	{
		Aimcontrol.bActive = false;
		AimControl.Controller = None;
		AimControl.PointingAt = none;
		AimControl.Master.RemoveInteraction(AimControl);
	}

    if ( Pawn != None )
    {
		// If its a vehicle, just destroy the driver, otherwise do the normal.
        gbxDrivenVehicle = gbxVehicle(Pawn);
		if( gbxDrivenVehicle != None )
		{
			Driver = gbxDrivenVehicle.Driver;
			gbxDrivenVehicle.KDriverLeave(true); // Force the driver out of the car
			if ( Driver != None )
			{
				Driver.Health = 0;
				Driver.Died( self, class'Suicided', Driver.Location );
			}
		}
		else
		{
			Pawn.Health = 0;
			Pawn.Died( self, class'Suicided', Pawn.Location );
        }
    }

	Super.Destroyed();
}

// Turns on/off the interaction for dealing with the new aiming system

function ServerAltAim(vector NewAim)
{
	AlternateAim = NewAim;
}

function ChangeAim(bool On)
{
	local Interaction Intr;

	if (AimControl==None)
	{
		intr = Player.InteractionMaster.AddInteraction("gbxBase.gbxStaticView",Player);
		AimControl = gbxStaticView(intr);
		AimControl.Controller = self;
	}

	if (!On)
	{
		log("#### Changing State to Player Walking");

		GotoState('PlayerWalking');
		AimControl.DeActivate();
		ViewChange = rotator(vect(0,0,0));
	}
	else
	{
		AimControl.Activate();
	}
}

function Deploy()
{
	GotoState('Deployed');
}

// ====================================================================
// When Deployed, the player is locked in a given location.  The Crosshair is unlocked
// and can be used to target anything on the screen.
// ====================================================================

state Deployed
{
	function Deploy();

	function ProcessMove(float DeltaTime, vector NewAccel, eDoubleClickDir DoubleClickMove, rotator DeltaRot)
	{
		local gbxPawn WP;

		Pawn.Acceleration = Vect(0,0,0);
		WP = gbxPawn(Pawn);
		if (WP!=None)
		{
			if (bDuck==1)
			{
				WP.ShouldUnCrouch();
			}
		}
	}

	function PlayerMove( float DeltaTime )
	{
		local vector X,Y,Z, NewAccel;
		local eDoubleClickDir DoubleClickMove;
		local rotator OldRotation;

		if (bWaitingForPlayerBreak || ((gbxHUD(MyHUD) != None) && (gbxHUD(MyHUD).m_eHudMode != 0)))
			return;
			
		GetAxes(Pawn.Rotation,X,Y,Z);

		// Update acceleration.

		NewAccel = vect(0,0,0);
		OldRotation = Rotation;

		if (AimControl!=None)
		{
			ServerAltAim(AimControl.AimTarget);
		}

 		if ( Role < ROLE_Authority ) // then save this move and replicate it
 			ReplicateMove(DeltaTime, NewAccel, DoubleClickMove, OldRotation - Rotation);
 		else
			ProcessMove(DeltaTime, NewAccel, DoubleClickMove, OldRotation - Rotation);

	}

	function BeginState()
	{
		YawAdjust = 0;
	}

	function EndState()
	{
		YawAdjust = 0;
	}

	function CalcFirstPersonView( out vector CameraLocation, out rotator CameraRotation )
	{
		Super.CalcFirstPersonView(CameraLocation, CameraRotation);
		CameraRotation += ViewChange;
	}
}

//*********************************************************
//	GetCameraLoc
//*********************************************************
function Vector GetCameraLoc() {
	return vect(0,0,0);
}

//*********************************************************
//	ResetCameraOrientation
//*********************************************************
function ResetCameraOrientation(Vector GunPosition, Rotator GunRot, bool bDirectView) {}

exec notinship function NextSkill()
{
	if (WargamePawn(Pawn) != None)
		WargamePawn(Pawn).NextSkill();
}

exec notinship function PrevSkill()
{
	if (WargamePawn(Pawn) != None)
		WargamePawn(Pawn).PrevSkill();
}

function ServerUse()
{
	local Actor A;
	local InfantryUSA	P, ClosestPawn;
	local int	nTouched;
	local float flDistance, flShortestDistance;
	local Vector			EyeLoc;
	local Vehicle DrivenVehicle, EntryVehicle, V;
	local gbxVehicle gbxDrivenVehicle, gbxEntryVehicle, gbxV;
	local bool bDrivingVehicle;

	if ( Role < ROLE_Authority )
		return;

	if ( Level.Pauser == PlayerReplicationInfo )
	{
		SetPause(false);
		return;
	}

	if (Pawn == None)
		return;

	if( OracleCam != None && OracleCam.IsActive() )
		return;

	bDrivingVehicle = false;
	if ( (gbxVehicle(Pawn) != None) || (Vehicle(Pawn) != None) )
		bDrivingVehicle = true;

	nTouched = 0;

	if (!bDrivingVehicle)  // skip use check on other items if driving a vehicle...
	{
		// Send the 'DoUse' event to each actor player is touching.
		ForEach Pawn.TouchingActors(class'Actor', A)
		{
			//Log( A $ " used by " $ Pawn.name );
			if (A.UsedBy(Pawn))
			{
				//Log( A $ " was used by " $ Pawn.name );
				nTouched++;
			}
		}

		if ((gbxWeapon(Pawn.Weapon) != None) && (Viewport(Player) == None))
		{
			gbxWeapon(Pawn.Weapon).CalcOffsetWeaponCollision();
		}
		if (LookingAtTarget != None)
		{
			if (LookingAtTarget.IsA('gbxRestockWeaponsCrate') || LookingAtTarget.IsA('gbxRestockUsableCrate') || Pawn.IsPawnFacingActor(LookingAtTarget, 0.5))
			{
				LookingAtTarget.UsedBy(Pawn);
				nTouched++;
			}
		}

/*
//CRG - Moved Reloading to own key.
		// Check for reloading before use of friendlys, but after actor uses -BB 
		if (Pawn.Weapon != None)
		{	
			if((Pawn.Weapon.ClipAmt != Pawn.Weapon.AmmoClipSize) && (Pawn.Weapon.Ammo[0].AmmoAmount!=0) && nTouched==0)
			{
				if ( (Pawn != None) && (Pawn.Weapon != None) )
				{
					Pawn.Weapon.ClientForceReload();
					return;
				}
			}
		}
*/
		//SDJ 07/03/2004: Disable context use of friendly soldiers in MP.
		if (Level.Game.IsA('WargameSinglePlayer'))
		{
			flShortestDistance = 250;
			ForEach AllActors(class'InfantryUSA', P)
			{
				EyeLoc = P.Location + P.EyePosition();
				flDistance = VSize((Pawn.Location + Pawn.EyePosition()) - EyeLoc);
				if (Pawn.IsPawnFacingActor(P, 0.5) && (flDistance <= flShortestDistance) )  // about 60 degrees from straight ahead
				{
					ClosestPawn = P;
					flShortestDistance = flDistance;
				}
			}
			if (ClosestPawn != None)
				if (ClosestPawn.UsedBy(Pawn))
					nTouched++;
		}
	}

	if (nTouched == 0)
	{
		DrivenVehicle = Vehicle(Pawn);
		if( DrivenVehicle != None )
		{
			DrivenVehicle.KDriverLeave(false);
			return;
		}

	    // Check for nearby vehicles
    	ForEach Pawn.VisibleCollidingActors(class'Vehicle', V, VehicleCheckRadius)
	    {
    	    // Found a vehicle within radius
        	EntryVehicle = V.FindEntryVehicle(Pawn);
	        if (EntryVehicle != None && EntryVehicle.TryToDrive(Pawn))
    	        return;
	    }

		gbxDrivenVehicle = gbxVehicle(Pawn);
		if( gbxDrivenVehicle != None )
		{
			gbxDrivenVehicle.KDriverLeave(false);
			return;
		}

	    // Check for nearby gbxVehicles
    	ForEach Pawn.VisibleCollidingActors(class'gbxVehicle', gbxV, VehicleCheckRadius)
	    {
    	    // Found a vehicle within radius
        	gbxEntryVehicle = gbxV.FindEntryVehicle(Pawn);
    	    if (gbxEntryVehicle != None && gbxEntryVehicle.TryToDrive(Pawn))
	            return;
	    }
	}

	if (nTouched == 0)
	{
		if (gbxPawn(Pawn).m_fTrophySelect)
			PickupItem();
			
// Reload moved to own key - CRG			
//		else if ( (Pawn != None) && (Pawn.Weapon != None) ) 
//			Pawn.Weapon.ClientForceReload();
	}

//	Jump();
}


function serverReload()
{
	// Do not need to check for ammo here, that is done in force reload.
	if((Pawn != None) && (Pawn.Weapon != None))
		Pawn.Weapon.ClientForceReload();
}


/* UseKey()
- The player has hit the use key
*/
exec function UseKey()
{
//	if ((Pawn.Health <= 0) && !MyHUD.bHideHUD)
//	{
//		ConsoleCommand( "reconnect" );
//		return;
//	}

	if (gbxHUD(MyHud) != None)
	{
		if (gbxHUD(MyHud).m_eHudMode != HudModeNormal)
			gbxHUD(MyHud).UseKey();
		else if (!bLockedMovement)
			if (gbxPawn(Pawn).m_fPrimaryWeaponSelect)
				ThrowWeapon();
			else
				ServerUse();
	}
	else
		ServerUse();
}

/* UseKeyDown()
- The player has pressed down the use key
*/
exec function UseKeyDown()
{
	if ( IsOrdering() )  // is order command ring currently shown?
	{
		CancelOrderIcon();    // user want to cancel the order
		return;
	}

	m_flUseKeyTimer = Level.TimeSeconds;
}

exec function UseKeyUp()
{
	// GBX:PAD: Prevent calling this function again if we let the timout handle the use key up event.
	if (m_flUseKeyTimer < 0.0f)
	{
		return;
	}
	
	if (((Level.TimeSeconds - m_flUseKeyTimer) > UseKeyDelay) && gbxPawn(Pawn).m_fPrimaryWeaponSelect)
	{
		ThrowWeapon();
	}
	else
	{
		if (gbxHUD(MyHud) != None)
		{
			if (gbxHUD(MyHud).m_eHudMode != HudModeNormal)	
				gbxHUD(MyHud).UseKey();
			else if (!bLockedMovement)
				ServerUse();
		}
		else
			ServerUse();		
	}
	m_flUseKeyTimer = -1.0f;
}



exec function ReloadKey()
{
	if ( IsOrdering() )  // is order command ring currently shown?
	{
		CancelOrderIcon();    // user want to cancel the order
		return;
	}
	ServerReload();
}


// The player wants to fire weapon.
exec function Fire( optional float F )
{
//	if (Pawn.Health <= 0)
//	{
//		ConsoleCommand( "reconnect" );
//		return;
//	}

	if (gbxHUD( MyHUD ) != None)
	{
		if (gbxHUD( MyHUD ).m_eHudMode != HudModeNormal)
		{
			UseKey();
			return;
		}
	}

	// This code is kinda whacky, basically in singleplayer we want to return 
	// immediatley if bLockedMovement is true.  But in multiplayer we need to
	// call PlayerController's Fire function first, then we can return.
	if ( Level.NetMode != NM_LISTENSERVER && Level.NetMode != NM_CLIENT )
	{
		if (bLockedMovement)
		{
			return;
		}
	}

	Super.Fire( F );

	if ( Level.NetMode == NM_LISTENSERVER || Level.NetMode == NM_CLIENT )
	{
		if (bLockedMovement)
		{
			return;
		}
	}

	m_flLastFireTime = Level.TimeSeconds;

	if (WargamePawn(Pawn) != None && !IsZoomed() )
	{
		WargamePawn(Pawn).SetWeaponAimedState( WAS_Sighted ); // GBX:naj - 3/24/04
		Pawn.flLastAimedStateChange = Level.TimeSeconds;
	}
}

// The player wants to fire secondary item.
exec function FireSecondary( optional float F )
{
	if (bLockedMovement)
		return;

	if ( Level.Pauser == PlayerReplicationInfo )
	{
		SetPause(false);
		return;
	}
	if (WargamePawn( Pawn ) != None)
		WargamePawn( Pawn ).FireSecondary( F );
}

// Player movement.
// Player Standing, walking, running, falling.
state PlayerWalking
{
	function PlayerMove( float DeltaTime )
	{
		if (bWaitingForPlayerBreak || ((gbxHUD(MyHUD) != None) && (gbxHUD(MyHUD).m_eHudMode != 0)))
			return;
			
		Super.PlayerMove( DeltaTime );
	}
/*
	function PlayerMove( float DeltaTime )
	{
		if (gbxHUD(MyHud) != None)
		{
			if ((gbxHUD(MyHud).m_eHudMode != HudModeNormal) && (m_flNextStrafeHit < Level.TimeSeconds))
			{
				if (aStrafe > 500)
					gbxHUD(MyHud).MoveSelectRight();
				else if (aStrafe < -500)
					gbxHUD(MyHud).MoveSelectLeft();
				if (aForward > 200)
					gbxHUD(MyHud).MoveSelectUp();
				else if (aForward < -200)
					gbxHUD(MyHud).MoveSelectDown();
				m_flNextStrafeHit = Level.TimeSeconds + 0.250000;
			}
		}

		Super.PlayerMove( DeltaTime );
	}
*/
	function BeginState()
	{
       	DoubleClickDir = DCLICK_None;
       	bPressedJump = false;
       	GroundPitch = 0;
		if ( Pawn != None )
		{
			if ( Pawn.Mesh == None )
				Pawn.SetMesh();
			Pawn.ShouldCrouch(false);
			if (Pawn.Physics != PHYS_Falling && Pawn.Physics != PHYS_Karma) // FIXME HACK!!!
			{
//				Pawn.SetPhysics(PHYS_RootMotion);
//				Pawn.LockRootMotion(1);
				Pawn.SetPhysics(PHYS_Walking);
			}
		}
	}

	function ProcessMove(float DeltaTime, vector NewAccel, eDoubleClickDir DoubleClickMove, rotator DeltaRot)
	{
		//// SJP - Double Run-Click Sprinting
		// Enable sprinting on double click
		// Update: 11/14/03 - boo hoo, nobody likes this
		//if( DoubleClickMove == eDoubleClickDir.DCLICK_Forward && WargamePawn(Pawn) != None )
		//	WargamePawn(Pawn).SetSprinting(true);

		// Disable sprinting when releasing run
		//if( Pawn.bIsSprinting && VSize(NewAccel) < Pawn.GroundSpeed * 0.95 && WargamePawn(Pawn) != None )
		//	WargamePawn(Pawn).SetSprinting(false);
		////

		if (bLockedMovement)
			Super.ProcessMove( DeltaTime, vect( 0, 0, 0 ), DCLICK_None, DeltaRot );
		else
			Super.ProcessMove( DeltaTime, NewAccel, DoubleClickMove, DeltaRot );
	}
}

// Player movement.
// Player Driving a Karma vehicle.
state PlayerDriving
{
ignores SeePlayer, HearNoise, Bump;

    function ProcessMove(float DeltaTime, vector NewAccel, eDoubleClickDir DoubleClickMove, rotator DeltaRot)
    {

    }

	// Set the throttle, steering etc. for the vehicle based on the input provided
	function ProcessDrive(float InForward, float InStrafe, float InUp, bool InJump)
	{
		local gbxVehicle gbxCurrentVehicle;

	    gbxCurrentVehicle = gbxVehicle(Pawn);

        if(gbxCurrentVehicle == None)
            return;

		//log("Forward:"@InForward@" Strafe:"@InStrafe@" Up:"@InUp);

		gbxCurrentVehicle.Throttle = FClamp( InForward/5000.0, -1.0, 1.0 );
		gbxCurrentVehicle.Steering = FClamp( -InStrafe/5000.0, -1.0, 1.0 );
		gbxCurrentVehicle.Rise = FClamp( InUp/5000.0, -1.0, 1.0 );
	}

    function PlayerMove( float DeltaTime )
    {
		local gbxVehicle gbxCurrentVehicle;
		local float NewPing;

		gbxCurrentVehicle = gbxVehicle(Pawn);

		// update 'looking' rotation
        UpdateRotation(DeltaTime, 2);

        // TODO: Don't send things like aForward and aStrafe for gunners who don't need it
		// Only servers can actually do the driving logic.
        if (Role < ROLE_Authority )
        {
			if ( (Level.TimeSeconds - LastPingUpdate > 4) && (PlayerReplicationInfo != None) && !bDemoOwner )
			{
				LastPingUpdate = Level.TimeSeconds;
				NewPing = float(ConsoleCommand("GETPING"));
				if ( ExactPing < 0.006 )
					ExactPing = FMin(0.1,0.001 * NewPing);
				else
					ExactPing = 0.99 * ExactPing + 0.0001 * NewPing;
				PlayerReplicationInfo.Ping = Min(250.0 * ExactPing, 255);
				PlayerReplicationInfo.bReceivedPing = true;
				OldPing = ExactPing;
				ServerUpdatePing(1000 * ExactPing);
			}
            if (!bSkippedLastUpdate &&                              // in order to skip this update we must not have skipped the last one
                (Player.CurrentNetSpeed < 10000) &&                 // and netspeed must be low
                (Level.TimeSeconds - ClientUpdateTime < 0.0222) &&  // and time since last update must be short
                bPressedJump == bLastPressedJump &&                 // and update must not contain major changes
                aUp - aLastUp < 0.01 &&                             // "
                aForward - aLastForward < 0.01 &&                   // "
                aStrafe - aLastStrafe < 0.01                        // "
               )
            {
//                log("!bSkippedLastUpdate: "$!bSkippedLastUpdate);
//                log("(Player.CurrentNetSpeed < 10000): "$(Player.CurrentNetSpeed < 10000));
//                log("(Level.TimeSeconds - ClientUpdateTime < 0.0222): "$(Level.TimeSeconds - ClientUpdateTime < 0.0222)$"  - "$Level.TimeSeconds - ClientUpdateTime);
//                log("bPressedJump == bLastPressedJump: "$bPressedJump == bLastPressedJump);
//                log("aUp - aLastUp < 0.01: "$aUp - aLastUp < 0.01);
//                log("aForward - aLastForward < 0.01: "$aForward - aLastForward < 0.01);
//                log("aStrafe - aLastStrafe < 0.01: "$aStrafe - aLastStrafe < 0.01);

                bSkippedLastUpdate = True;
                return;
            }
            else
            {
                bSkippedLastUpdate = False;
                ClientUpdateTime = Level.TimeSeconds;

                // Save Move
                bLastPressedJump = bPressedJump;
                aLastUp = aUp;
                aLastForward = aForward;
                aLastStrafe = aStrafe;

                if (gbxCurrentVehicle != None)
                {
                    gbxCurrentVehicle.Throttle = FClamp( aForward/5000.0, -1.0, 1.0 );
                    gbxCurrentVehicle.Steering = FClamp( -aStrafe/5000.0, -1.0, 1.0 );
                    gbxCurrentVehicle.Rise = FClamp( aUp/5000.0, -1.0, 1.0 );
                }

                ServerDrive(aForward, aStrafe, aUp, bPressedJump, (32767 & (Rotation.Pitch/2)) * 32768 + (32767 & (Rotation.Yaw/2)));
            }
        }
		else
			ProcessDrive(aForward, aStrafe, aUp, bPressedJump);

		// If the vehicle is being controlled here - set replicated variables.
		if (gbxCurrentVehicle != None)
		{
			if(bFire == 0 && gbxCurrentVehicle.bWeaponIsFiring)
				gbxCurrentVehicle.ClientVehicleCeaseFire(False);

			if(bAltFire == 0 && gbxCurrentVehicle.bWeaponIsAltFiring)
				gbxCurrentVehicle.ClientVehicleCeaseFire(True);
		}
    }

	function BeginState()
	{
		PlayerReplicationInfo.bReceivedPing = false;
		CleanOutSavedMoves();
	}

	function EndState()
	{
		CleanOutSavedMoves();
	}
}

function ServerChangeView( bool bFirstPerson )
{
	local int index;
	local float ZoomFOV;

	if ( bLockedMovement )
		return;

	if ((WargamePawn(Pawn) != None) && (gbxWeapon(Pawn.Weapon) != None))
	{
		if ( PendingDelayedAction != ReloadAfterZoomOut && (gbxWeapon(Pawn.Weapon).IsWeaponFiring() || gbxWeapon(Pawn.Weapon).IsReloading()) )
			return;
		if (!gbxWeapon(Pawn.Weapon).CanZoom())
			return;

		ZoomFOV = DefaultFOV - gbxWeapon(Pawn.Weapon).ZoomFovMod;
	}
	else
	{
		return;
	}

	if(Pawn.bIsSprinting && bFirstPerson)
	{
		ToggleSprinting();
	}

	// clear the auto-zoom out average speed array...
	for (index = 0; index < 10; index++)
		average_speed_array[index] = 0.0f;

	if (bBehindView)
	{
		if (bFirstPerson)
		{
			if (WargamePawn(Pawn) != None)
			{
				WargamePawn(Pawn).SetWeaponAimedState( WAS_Sighted );
				Pawn.flLastAimedStateChange = Level.TimeSeconds;
			}
		}
		else
		{
			if (WargamePawn(Pawn) != None)
			{
				WargamePawn(Pawn).SetWeaponAimedState( WAS_Sighted ); // GBX:naj - 3/24/04
				Pawn.flLastAimedStateChange = Level.TimeSeconds;
			}
		}
	}
	else
	{
		if (bFirstPerson)
		{
			DesiredFOV = ZoomFOV;
			gbxWeapon(Pawn.Weapon).DisplayFOV = gbxWeapon(Pawn.Weapon).Default.DisplayFOV - gbxWeapon(Pawn.Weapon).ZoomDisplayFovMod;
		}
		else
		{
			DesiredFOV = DefaultFOV;
			gbxWeapon(Pawn.Weapon).DisplayFOV = gbxWeapon(Pawn.Weapon).Default.DisplayFOV;
		}
	}
}

simulated function ClientChangeView( int nFirstPerson )
{
	local bool bFirstPerson;
	local int index;
	local float ZoomFOV;

	if ( bLockedMovement )
		return;

	if ( Level.Pauser == PlayerReplicationInfo ) // Dont change view while paused.
		return;
		
	if ((WargamePawn(Pawn) != None) && (gbxWeapon(Pawn.Weapon) != None))
	{
		if( gbxWeapon(Pawn.Weapon).m_fPlayingFire )	// RSC: added to prevent player from zooming to skip fire animation - BUG #1135
			return;

		if (!gbxWeapon(Pawn.Weapon).m_fCanZoom )
		{
			return;
		}
		if ( PendingDelayedAction != ReloadAfterZoomOut && (gbxWeapon(Pawn.Weapon).IsWeaponFiring() || gbxWeapon(Pawn.Weapon).IsReloading()) )
		{
			return;
		}
		if (!gbxWeapon(Pawn.Weapon).CanZoom())
		{
			return;
		}

		ZoomFOV = DefaultFOV - gbxWeapon(Pawn.Weapon).ZoomFovMod;
		gbxWeapon(Pawn.Weapon).DisplayFOV = gbxWeapon(Pawn.Weapon).Default.DisplayFOV - gbxWeapon(Pawn.Weapon).ZoomDisplayFovMod;
	}
	else
	{
//		ZoomFOV = 35.000;
		//SDJ 05/26/2004: In MP we want to ensure the player is not zoomed in when he doesn't have a weapon, like when he is dead.
		if (Level.NetMode != NM_Standalone)
		{
			DesiredFOV = DefaultFOV;
			gbxWeapon(Pawn.Weapon).DisplayFOV = gbxWeapon(Pawn.Weapon).Default.DisplayFOV;
		}
		return;
	}

	if(Pawn.bIsSprinting && nFirstPerson > 0)
	{
		ToggleSprinting();
	}

	// clear the auto-zoom out average speed array...
	for (index = 0; index < 10; index++)
		average_speed_array[index] = 0.0f;

	if (nFirstPerson == 2)
	{
		if ( DesiredFOV > ZoomFOV )
			bFirstPerson = true;
		else
			bFirstPerson = false;
	}
	else if (nFirstPerson == 0)
		bFirstPerson = false;
	else
		bFirstPerson = true;

	if ( Pawn.IsA( 'gbxPawn' ) && Pawn.bIsManningTurret )
	{
		if ( !gbxPawn( Pawn ).Turret.IsZoomed() )
			gbxPawn( Pawn ).Turret.PlayZoomIn();
		else
			gbxPawn( Pawn ).Turret.PlayZoomOut();
		
		return;
	}
	if (bBehindView)
	{
		if (bFirstPerson)
		{
			if (WargamePawn(Pawn) != None)
			{
				WargamePawn(Pawn).SetWeaponAimedState( WAS_Sighted );
				Pawn.flLastAimedStateChange = Level.TimeSeconds;
			}
		}
		else
		{
			if (WargamePawn(Pawn) != None)
			{
				WargamePawn(Pawn).SetWeaponAimedState( WAS_Sighted ); // GBX:naj - 3/24/04
				Pawn.flLastAimedStateChange = Level.TimeSeconds;
			}
		}
	}
	else
	{
		if (bFirstPerson)
		{
			//DHW + -- Added to avoid the player zooming while busy (i.e. swapping weapons) bug #1833
			if (Pawn.Weapon.ClientState != WS_ReadyToFire)
				return;
			//DHW -

			SetHand(0);

			DesiredFOV = ZoomFOV;
			gbxWeapon(Pawn.Weapon).DisplayFOV = gbxWeapon(Pawn.Weapon).Default.DisplayFOV - gbxWeapon(Pawn.Weapon).ZoomDisplayFovMod;
			LastViewRotationCenter = Rotation;

			if (WargamePawn(Pawn) != None)
			{
				//WargamePawn(Pawn).SetWeaponAimedState( WAS_Sighted );
				//Pawn.flLastAimedStateChange = Level.TimeSeconds;
				if (gbxWeapon(Pawn.Weapon) != None)
				{
//					gbxWeapon(Pawn.Weapon).SwitchZoomView( true );
//					Pawn.Weapon.GotoState('ZoomWeapon');

					/// SJP: Dynamically load and play zoom in sound
					if( ZoomInSound == None && ZoomInSoundName !="" )
					{
						ZoomInSound = Sound( DynamicLoadObject( ZoomInSoundName, class'Sound' ) );
					}

					if( ZoomInSound != None )
					{
						Pawn.PlayOwnedSound( ZoomInSound, SLOT_Interact,,false );
					}

					Pawn.Weapon.PlayZoomIn();
				}
			}
		}
		else
		{
			DesiredFOV = DefaultFOV;
			gbxWeapon(Pawn.Weapon).DisplayFOV = gbxWeapon(Pawn.Weapon).Default.DisplayFOV;

			if (WargamePawn(Pawn) != None)
			{
				WargamePawn(Pawn).SetWeaponAimedState( WAS_Sighted );
				Pawn.flLastAimedStateChange = Level.TimeSeconds;
				if (gbxWeapon(Pawn.Weapon) != None)
				{
//					gbxWeapon(Pawn.Weapon).SwitchZoomView( false );
//					Pawn.Weapon.GotoState('UnZoomWeapon');

					/// SJP: Dynamically load and play zoom out sound
					if( ZoomOutSound == None && ZoomOutSoundName !="" )
					{
						ZoomOutSound = Sound( DynamicLoadObject( ZoomOutSoundName, class'Sound' ) );
					}

					if( ZoomOutSound != None )
					{
						Pawn.PlayOwnedSound( ZoomOutSound, SLOT_Interact,,false );
					}

					Pawn.Weapon.PlayZoomOut();
				}
			}
		}
	}
	ServerChangeView( bFirstPerson );
}

simulated function ResetClientView()
{
	if( Pawn.IsHumanControlled() && IsZoomed() && (PendingDelayedAction == NoAction) )
	{
		ChangeView(0);
		PendingDelayedAction = PutDownWeaponAfterZoomOut;
	}
}

simulated exec function ChangeView( int nFirstPerson )
{
	if ( !IsInAIDebugMode() )
		ClientChangeView( nFirstPerson );
}

function PickupItem()
{
/*
	local	PickupUsableTrophy	aTrophy;

	ForEach DynamicActors(class'PickupUsableTrophy', aTrophy)
	{
		if (aTrophy.m_fTouched)
			aTrophy.PickupItem( Pawn );
	}
*/
}

simulated exec function ToggleShowHUD()
{
	gbxHUD(MyHUD).bHideHUD = !gbxHUD(MyHUD).bHideHUD;
}

exec function ForceReload()
{
	if (bLockedMovement)
		return;

	if ( (Pawn != None) && (Pawn.Weapon != None) )
		Pawn.Weapon.ClientForceReload();
}

exec function Jump( optional float F )
{
	if( OracleCam != None && OracleCam.IsActive() )
	{
		return;
	}

	if ( IsOrdering() )  // is order command ring currently shown?
	{
		CancelOrderIcon();    // user want to cancel the order
		return;
	}

	if (gbxHUD( MyHUD ) != None)
	{
		if (gbxHUD( MyHUD ).m_eHudMode != HudModeNormal)
		{
//			UseKey();
			return;
		}
	}

	if (bLockedMovement)
		return;

	if (WargamePawn(Pawn) != None)
	{
		JogFatigue( WargamePawn( Pawn ).FatigueJog_PlayerJump );
	}

	Super.Jump( F );
}

exec notinship function ShowAI()
{
	myHUD.ShowDebug();
	if ( gbxPawn(ViewTarget) != None )
		gbxPawn(ViewTarget).bSoakDebug = myHUD.bShowDebugInfo;
}

function Possess(Pawn aPawn)
{
/*	if ( gbxPawn(aPawn) != None )
	{
		if ( gbxPawn(aPawn).Default.VoiceType != "" )
			VoiceType = gbxPawn(aPawn).Default.VoiceType;
		if ( VoiceType != "" )
        {
			PlayerReplicationInfo.VoiceType = class<VoicePack>(DynamicLoadObject(VoiceType,class'Class'));
        }
	}
*/
	Super.Possess(aPawn);
}

function SoakPause(Pawn P)
{
	log("Soak pause by "$P);
	SetViewTarget(P);
	SetPause(true);
	bBehindView = true;
	myHud.bShowDebugInfo = true;
	if ( gbxPawn(P) != None )
		gbxPawn(P).bSoakDebug = true;
}

function byte GetMessageIndex(name PhraseName)
{
	if ( PlayerReplicationInfo.VoiceType == None )
		return 0;
	return PlayerReplicationInfo.Voicetype.Static.GetMessageIndex(PhraseName);
}

function PlayStartupMessage(byte StartupStage)
{
	// Removed to kill "The match has begun!" message in Brothers in Arms single player game.
	//ReceiveLocalizedMessage( class'StartupMessage', StartupStage, PlayerReplicationInfo );
}

exec notinship function CycleLoadout()
{
	if ( WargameTeamInfo(PlayerReplicationInfo.Team) != None )
		ServerChangeLoadout(string(WargameTeamInfo(PlayerReplicationInfo.Team).NextLoadOut(PawnClass)));
}

exec notinship function ChangeLoadout(string LoadoutName)
{
	ServerChangeLoadout(LoadoutName);
}

function ServerChangeLoadout(string LoadoutName)
{
	WargameMPGameInfo(Level.Game).ChangeLoadout(self, LoadoutName);
}

function CreateHudBloodEffect( Vector VecDamage, int numParticles )
{
	if( myHudEffects[ BloodEffectIndex ] != None )
	{
		HudEffectBlood( myHudEffects[ BloodEffectIndex ] ).DamageVector = -VecDamage;
		HudEffectBlood( myHudEffects[ BloodEffectIndex ] ).LookAtVector = Vector( GetViewRotation() );

		myHudEffects[ BloodEffectIndex ].CreateParticles( numParticles );
	}
}

function CreateHudDirtEffect( int numParticles )
{
	if ( myHudEffects[ DirtEffectIndex ] != None )
	{
		HudEffectDirt( myHudEffects[ DirtEffectIndex ] ).DamageVector = Vector( GetViewRotation() );
		HudEffectDirt( myHudEffects[ DirtEffectIndex ] ).LookAtVector = Vector( GetViewRotation() );

		myHudEffects[ DirtEffectIndex ].CreateParticles( numParticles );
	}
}

function CreateHudRainEffect( int numParticles )
{
	if ( myHudEffects[ RainEffectIndex ] != None )
	{
		HudEffectRain( myHudEffects[ RainEffectIndex ] ).LookAtVector = Vector( GetViewRotation() );

		myHudEffects[ RainEffectIndex ].CreateParticles( numParticles );
	}
}

simulated function ClearAllHudEffects()
{
	local int i;

	for( i = 0; i < MAX_HUD_EFFECTS; i++ )
	{
		if( myHudEffects[ i ] != None )
		{
			myHudEffects[ i ].ClearParticles();
		}
	}
}

simulated function float CalculateRainExposure()
{
	local vector TestVector, HitLocation, HitNormal, StartLocation;
	local rotator TestRot;
	local int i;
	local float Exposure;
	local Actor HitActor;

	TestRot.pitch = 16383 - RainExposureTestPitch;
	TestRot.yaw = rand( 65535 );

	TestVector = Vector( TestRot );
	StartLocation = Pawn.Location;
	StartLocation.Z = Pawn.CollisionHeight;

	Exposure = 1.0;

	for( i = 1; i <= NumRainExposureTests; i++ )
	{
		HitActor = Trace( HitLocation, HitNormal, StartLocation + TestVector * RainExposureTraceLength, StartLocation );

		if( HitActor != None )
		{
			Exposure -= 1.0 / NumRainExposureTests;
		}

		TestRot.yaw = Abs(65535 / NumRainExposureTests);
		TestRot.pitch = 0;
		TestRot.roll = 0;

		TestVector = TestVector >> TestRot;
	}

	return Exposure;
}

function NotifyTakeHit(pawn InstigatedBy, vector HitLocation, int Damage, class<DamageType> damageType, vector Momentum)
{
	local int iDam;
//	local Vector	X, Y, Z, DamageDir;

	Super.NotifyTakeHit(InstigatedBy,HitLocation,Damage,DamageType,Momentum);

	// FIXME_MERGE if ( (Pawn != None) && (Pawn.ShieldStrength > 0) )
	// FIXME_MERGE 	ClientFlash(0.5,vect(700,700,0));
	// FIXME_MERGE else
	// GBX:PAD: Remove the screen flash for now since it and the blood don't appear to run at the same time, so it would
	// be too inconsistent.
//	if ( Damage > 1 )
//	{
//		ClientFlash(DamageType.Default.FlashScale,DamageType.Default.FlashFog);
//	}

	// GBX:PAD: This doesn't appear to do very much, and in fact causes a bad view drift with bad values into the ShakeView code.
/*
	if( bShakeOnDamage )
	{
		GetAxes(Rotation, X, Y, Z);
//		ShakeView(0.15 + 0.005 * Damage, Damage * 30, Damage * vect(0,0,0.03), 120000, vect(1,1,1), 0.2);
		DamageDir = Normal(X Cross Normal(Momentum));
		ShakeView(0.15 + 0.005 * Damage, Damage * 30, Damage * DamageDir, 120000, vect(1,1,1), 0.2);
	}
*/
	iDam = Clamp(Damage,0,250);
	if ( (Level.NetMode == NM_DedicatedServer) || (Level.NetMode == NM_ListenServer) )
		ClientPlayTakeHit(hitLocation - Pawn.Location, iDam, damageType);
}

function ClientPlayTakeHit(vector HitLoc, byte Damage, class<DamageType> damageType)
{
	HitLoc += Pawn.Location;
	Pawn.PlayTakeHit(HitLoc, Damage, damageType);
}

simulated state Dead
{
ignores SeePlayer, HearNoise, KilledBy, SwitchWeapon;

	function BeginState()
	{
		Super.BeginState();

		m_flStartDeathCheck = Level.TimeSeconds;
	}
	
	exec function Fire( optional float F )
	{
		if ( bFrozen )
		{
			if ( (TimerRate <= 0.0) || (TimerRate > 1.0) )
				bFrozen = false;
			return;
		}
		if ( PlayerReplicationInfo.bOutOfLives )
			ServerSpectate();
		else
			Super.Fire(F);
	}

Begin:
    Sleep(0.5);
	if ( (ViewTarget == None) || (ViewTarget == self) || (VSize(ViewTarget.Velocity) < 25.0) || ((m_flStartDeathCheck + DEATH_CHECK_LIMIT) < Level.TimeSeconds))
	{
		if (Level.Game.IsA('WargameSinglePlayer') && (gbxHUD(myHUD).m_eHudMode != HudModeDead))
		{
			gbxHUD(myHUD).m_eHudMode = HudModeDead;
			DisplayMissionFinished(false);
		}
	}
	else
		Goto('Begin');
}

exec function ToggleWeapon()
{
	if (bLimitedMode || Pawn.bIsManningTurret || IsInOracleCamMode() )
		return;

	if ( IsOrdering() )  // is order command ring currently shown?
	{
		CancelOrderIcon();    // user want to cancel the order
		return;
	}

	if (!Pawn.CanToggleWeapon())
		return;
		
	if (gbxPawn(Pawn) != None)
	{
		if( Pawn.IsHumanControlled() && IsZoomed())
		{
			if ((PendingDelayedAction == NoAction))
			{
				if (gbxWeapon(Pawn.Weapon).m_fPlayingFire)
				{
					PendingDelayedAction = ToggleWeaponAfterZoomOutAfterFire;
					return;			
				}
				ChangeView(0);
				PendingDelayedAction = ToggleWeaponAfterZoomOut;
				return;
			}
			return;
		}
		

		gbxPawn(Pawn).ToggleWeapon();
	}
}

function ServerThrowWeapon()
{
    local Vector TossVel;

    if (Pawn.CanThrowWeapon())
    {
		//SJP - Destroy the effect emitters on the weapon attachment
		if( gbxWeaponAttachment(Pawn.Weapon.ThirdPersonActor) != None )
			gbxWeaponAttachment(Pawn.Weapon.ThirdPersonActor).DestroyEffectEmitters();

        TossVel = Vector(GetViewRotation());
        TossVel = TossVel * ((Pawn.Velocity Dot TossVel) + 500) + Vect(0,0,200);
        Pawn.TossWeapon(TossVel);
    }
}

function Prone()
{
	Pawn.bWantsToGoProne = !Pawn.bWantsToGoProne;
}

// GBX:naj - modified 11/25/03 - No sprint while manning MG42.
function ToggleSprinting()
{
	if ( Pawn != None )
	{
		if ( Pawn.bIsManningTurret || gbxPawn( Pawn ).bHasStartedMountAnim )
		{
			if ( Pawn.bIsSprinting )
				Pawn.SetSprinting( false );
			return;
		}

		Pawn.SetSprinting( !Pawn.bIsSprinting );
	}
}

exec function AltFire( optional float F )
{
	if ( IsOrdering() )  // is order command ring currently shown?
	{
		CancelOrderIcon();    // user want to cancel the order
		return;
	}

	Super.AltFire( F );
}


simulated function LimitPlayerInput( bool bLimited )
{
	if (bLimited == bLimitedMode)
		return;

	if (bLimited)
	{
		CancelOrderIcon();
//		MyHud.bHideHud = true;
		gbxHUD(MyHud).bLimitedPlayerHUD = true;
		if (Pawn.Weapon != None)
		{
			if (gbxPawn(Pawn) != None)
				gbxPawn(Pawn).LastWeapon = Pawn.Weapon;
			if (IsZoomed())
			{
				ResetClientView();
			}
			else
			{
				if( Pawn.Weapon.IsReloading() )
				{
					PendingDelayedAction = PutDownWeaponAfterReload;
				}
				else if( gbxWeapon(Pawn.Weapon).m_fPlayingMelee )
				{
					PendingDelayedAction = PutDownWeaponAfterMelee;
				}
				else
				{
					Pawn.Weapon.PutDown();
				}
			}
		}
	}
	else
	{
//		MyHud.bHideHud = false;
		gbxHUD(MyHud).bLimitedPlayerHUD = false;
		if ((gbxPawn(Pawn) != None) && (gbxPawn(Pawn).LastWeapon != None))
		{
			if( gbxPawn( Pawn ).LastWeapon != None && !gbxPawn( Pawn ).LastWeapon.bDeleteMe )
			{
				Pawn.PendingWeapon = gbxPawn(Pawn).LastWeapon;
				Pawn.ChangedWeapon();
			}
		}
	}
	bLimitedMode = bLimited;
}

// SJP - Modifies bullet trajectories for human players
function rotator AdjustAimNew(Ammunition FiredAmmunition, vector projStart, Rotator AimRotator, optional out int bSkipDoTrace)
{
	local int ConeOfFire, FinalError;

	FinalError = CalculateHumanWeaponError( IsZoomed(), Pawn.Weapon, ConeOfFire );

	// TBD: Adjust the accuracy.
	ApplyAccuracy( AimRotator, FinalError );

	return AimRotator;
}

function bool GetAutoAimTarget( out AimAssistParameters Params )
{
	if ( IsZoomed() && bAimAssistStickToTargetWhenZoomed )
	{
		Params.AimStyle = AimAssistStyle.StickToTarget;

		// Conditions where we will not adjust aim with this method
		if( VSize( gbxPawn(Pawn).ViewKickAdjustment ) > 0 )
			return false;
	}
	else
	{
		Params.AimStyle = AimAssistStyle.LeadTarget;
	}

	if( Super.GetAutoAimTarget(Params) )
	{
		if( Pawn.SameTeamAs(Params.FoundTarget) )
		{
			Params.FoundTarget = None;
			return false;
		}

		return true;
	}

	return false;
}

function DoHeavyTrauma()
{
	local float	flAnimTime;

	if (bNoHeavyTrauma)
		return;

	if ((m_MatineeScript != None) || (Pawn == None))
	{
		return;
	}
	
	if (!Pawn.bIsManningTurret)
	{
		flAnimTime = WargamePawn(Pawn).PlayKnockDownAnim();
		WargamePawn(Pawn).bPlayHeavyTraumaSound = true;
		WargamePawn(Pawn).flHeavyTraumaSoundTime = Level.TimeSeconds + HEAVY_TRAUMA_SOUND_DELAY;
	}
}

simulated function EnableHeavyTrauma( bool bEnabled )
{
	bNoHeavyTrauma = !bEnabled;
}

exec function HideHud( bool bHide )
{
	MyHUD.bHideHud = bHide;
}

/*
function NotifyKilled(Controller Killer, Controller Killed, Pawn Other)
{
	Super.NotifyKilled( Killer, Killed, Other );

	if ((Killed == self) && (Level.Game.bRestartLevel))
	{
		if (gbxHUD(MyHUD) != None)
		{
			gbxHUD(MyHUD).m_eHudMode = HudModeDead;
		}
	}
}
*/

exec function ActivateOracle()
{
	local WargamePawn WGPawn;

	if( bLimitedMode || Pawn.Health <= 0 || bOracleCameraDisabled )
	{
		return;
	}

	WGPawn = WargamePawn( Pawn );

	// No oracle camera while in heavy trauma mode.
	if (gbxPlayerPawn(Pawn) != None && gbxPlayerPawn(Pawn).IsDoingHeavyTrauma())
	{
		return;
	}

	// Allow toggling if already active, or if not mounting a weapon or something.
	if(( OracleCam != None && OracleCam.IsActive() ) || ( WGPawn != None && !WGPawn.bAttachCamToHead && !WGPawn.bHasStartedMountAnim ))
	{
		if( !OracleCam.IsActive() )
		{
			ClearAllHudEffects();
		}

		super.ActivateOracle();
	}
}

function UpdateScriptedRotation(float DeltaTime, float maxPitch)
{
	local rotator ViewRotation;
	local float	  flYawRatio, flPitchRatio;
	local int	  nDiff;

	ViewRotation = ScriptViewOffset;

	if (m_fViewOffsetAbs)
	{
		ViewRotation.Yaw += DeltaTime * aTurn;
		ViewRotation.Pitch += DeltaTime * aLookUp;
		
		if (ViewRotation.Pitch > ScriptViewRestriction.Pitch)	// Roughly 30 degrees
			ViewRotation.Pitch = ScriptViewRestriction.Pitch;
		else if (ViewRotation.Pitch < -ScriptViewRestriction.Pitch)
			ViewRotation.Pitch = -ScriptViewRestriction.Pitch;

		if (ViewRotation.Yaw > ScriptViewRestriction.Yaw)	// Roughly 30 degrees
			ViewRotation.Yaw = ScriptViewRestriction.Yaw;
		else if (ViewRotation.Yaw < -ScriptViewRestriction.Yaw)
			ViewRotation.Yaw = -ScriptViewRestriction.Yaw;
	}
	else
	{
		flYawRatio = ScriptViewRestriction.Yaw / 49152.0f;
		flPitchRatio = ScriptViewRestriction.Pitch / 8192.0f;

		nDiff = (aTurn * flYawRatio) - ViewRotation.Yaw;
		if (nDiff > 0)
		{
			ViewRotation.Yaw += min( nDiff, 650 );
		}
		else
		{
			ViewRotation.Yaw += max( nDiff, -650 );
		}
				
		nDiff = (aLookUp * flPitchRatio) - ViewRotation.Pitch;
		if (nDiff > 0)
		{
			ViewRotation.Pitch += min( nDiff, 650 );
		}
		else
		{
			ViewRotation.Pitch += max( nDiff, -650 );
		}
	}

	ScriptViewOffset = ViewRotation;
	if (m_MatineeScript != None)
		m_MatineeScript.ScriptViewOffset = ScriptViewOffset;
}

function PlayerMove( float DeltaTime )
{
	if (m_MatineeScript != None)
	{
		UpdateScriptedRotation( DeltaTime, 1 );
	}
}

exec function ShowMenu()
{
	log("WargamePlayerController::ShowMenu");
	if (!bWaitingForPlayerBreak)
		Super.ShowMenu();
}

simulated function bool TestForUseTargetHit( Actor TestTarget, Vector TestHitLoc, Vector TestHitNormal )
{
	/*local gbxRestockWeaponsCrate gbxwCrate;
	local gbxWeapon theWeapon;
	local string weaponName;

	if (TestTarget.IsA('gbxRestockWeaponsCrate'))
	{
		//if ((LookingAtTarget == None) || !(LookingAtTarget.IsA( 'gbxRestockWeaponsCrate' )))
		//{
			// If you don't have the weapon this crate provides, display the same pickup message as if you were standing on the pickup object.
			// Otherwise, display a message indicating to press use to restock the weapon in question.  In either case, we need to get the
			// name of the weapon this crate provides.
			gbxwCrate = gbxRestockWeaponsCrate( TestTarget );
			
			if( gbxwCrate.Weapon != None && gbxwCrate.Weapon.m_WeaponClass != None )
			{
				weaponName = gbxwCrate.Weapon.m_WeaponClass.default.ItemName;
			}

			if( weaponName != "" )
			{
				// see if we already have this weapon
				theWeapon = gbxWeapon( Pawn.FindInventoryType( gbxwCrate.Weapon.m_WeaponClass ) );

				if(  theWeapon != None )
				{
					if( theWeapon.ClientState == WS_ReadyToFire )
					{
						Pawn.ReceiveLocalizedMessage(class'gbxWeaponRestockMessage', gbxwCrate.Weapon.m_WeaponClass.default.WeaponName);  // display the USE message
					}
				}
				else
				{
					Pawn.ReceiveLocalizedMessage(class'gbxWeaponPickupMessage', gbxwCrate.Weapon.m_WeaponClass.default.WeaponName);  // display the USE message
				}
			}
			else
			{
				Pawn.ReceiveLocalizedMessage(class'gbxContextUseHUDMessage', EContextUseType.RestockWeapons);  // display the USE message
			}
		//}
		LookingAtTarget = TestTarget;
		LookingAtTargetLocation = TestHitLoc;
		m_flBombMessageTime = Level.TimeSeconds;
		return true;
	}
	else*/ if (TestTarget.IsA('gbxRestockUsableCrate'))
	{
		if ((LookingAtTarget == None) || !(LookingAtTarget.IsA( 'gbxRestockUsableCrate' )))
		{
			Pawn.ReceiveLocalizedMessage(class'gbxContextUseHUDMessage', EContextUseType.RestockUsable);  // display the USE message
		}
		LookingAtTarget = TestTarget;
		LookingAtTargetLocation = TestHitLoc;
		m_flBombMessageTime = Level.TimeSeconds;
		return true;
	}
	else if ((Level.NetMode == NM_StandAlone) && TestTarget.IsA('InfantryUSA'))
	{
		if ((InfantryUSA(TestTarget).Controller.Enemy == None) && InfantryUSA(TestTarget).Controller.IsA('Mind'))
		{
			LookingAtTarget = TestTarget;
			LookingAtTargetLocation = TestHitLoc;
			m_flBombMessageTime = Level.TimeSeconds;
			
			if (Pawn.Weapon.IsAmmoFull() || !(Pawn.Weapon.AmmoMatches( InfantryUSA( LookingAtTarget ).Weapon )))
			{
				if ( !InfantryUSA(LookingAtTarget).IsDead() && !gbxPawn(LookingAtTarget).VoiceType.IsA('VoiceTypeDefault') && !gbxPawn(LookingAtTarget).SupressTalkToMessage)	// GBX:RSC added check for voicetypedefault so this message doesn't appear for those that can't speak.
				{
					// display the "Press 'Use' to speak to character message"
					Pawn.ReceiveLocalizedMessage(class'gbxTalkToSoldierMessage', InfantryUSA(LookingAtTarget).m_nCharType, PlayerReplicationInfo);
				}
			}
			else
			{
				if( !gbxPawn(LookingAtTarget).SupressTalkToMessage )
				{
				// display the "Press 'Use' to get ammo from character message"
				Pawn.ReceiveLocalizedMessage(class'gbxAmmoFromSoldierMessage', InfantryUSA(LookingAtTarget).m_nCharType, PlayerReplicationInfo);
			}
		}
	}
	}
	else if (LookingAtTarget != None)
	{
		Pawn.ReceiveLocalizedMessage(class'gbxWeaponPickupMessage', -1);
		Pawn.ReceiveLocalizedMessage(class'gbxWeaponRestockMessage', -1);
		Pawn.ReceiveLocalizedMessage(class'gbxContextUseHUDMessage', -1);  // remove the message from the HUD
		LookingAtTarget = None;
	}
//	else
//		LookingAtTarget = None;

	return false;
}

function bool AttachBombToTarget(Pawn User)
{
	local bool		fReturn;
	local float		flDistance;
	//Log( " WargamePlayerController::AttachBombToTarget()", 'MP' );

	if (m_aBombTarget != None)
	{
		if ( GameReplicationInfo.GameType != GT_SKIRMISH )
		{
			flDistance = VSize((Pawn.Location + Pawn.EyePosition()) - m_aBombTarget.Location);
			if ((flDistance < (200.0f + Pawn.CollisionRadius)) && Pawn.IsPawnLookingAtActor(m_aBombTarget, 0.5))
			{
				fReturn = m_aBombTarget.ActivateBomb( User );
				m_aBombTarget = None;
				//Log( " WargamePlayerController::AttachBombToTarget() returning fReturn: "$fReturn, 'MP' );
				return fReturn;
			}
			else
			{
				//Log( " WargamePlayerController::AttachBombToTarget() returning false 1", 'MP' );
				return false;
			}
		}
		else
		{
			fReturn = m_aBombTarget.ActivateBomb( User );
			m_aBombTarget = None;
			//Log( " WargamePlayerController::AttachBombToTarget() returning fReturn: "$fReturn, 'MP' );
			return fReturn;
		}
	}
	else
	{
		//Log( " WargamePlayerController::AttachBombToTarget() returning false 2", 'MP' );
		return false;
	}
}

simulated function PlantBombOnTarget( gbxExplosive aBomb )
{
	//Log( " WargamePlayerController::PlantBombOnTarget()", 'MP' );

	m_aBombTarget = gbxGammonBomb(aBomb);
	if (gbxWeapon(Pawn.Weapon) != None)
		gbxWeapon(Pawn.Weapon).PlantGammonBombOnTarget();
}

// For MP end of game: Ask every victory condition for a message, stopping at the first one to handle it successfully 2004-06-24 JWS
simulated function int UnpackVictoryReason(int reason, out string message)
{
	local gbxVictoryCondition vc;
	local int WinningTeam;

	Log(self $ " WargamePlayerController::UnpackVictoryReason() reason = " $ reason, 'JWS');

	foreach DynamicActors(class'gbxVictoryCondition', vc)
	{
		WinningTeam = 0;

		if (vc.UnpackVictoryReason(reason, WinningTeam, message))
		{
			break;
		}
	}

	Log(self $ " WargamePlayerController::UnpackVictoryReason() found WinningTeam = " $ WinningTeam $ " message = " $ message, 'JWS');

	return WinningTeam;
}

function bool StatsIsInLiveGame()
{
	local bool rslt;

	rslt = false;

	if ( ConsoleCommand("XLIVE GETAUTHSTATE") == "ONLINE" 
        && ConsoleCommand("XLIVE INDEX_IS_GUEST"@Player.SplitIndex) == "FALSE" 
		&& Level.AuthMode == AM_Live)
	{
		rslt = true;
	}

	return rslt;
}

//DS-BEGIN: stats uploading
function ClientGameStarted()
{
	local gbxStatsManager DummyStatsManager;

	// Spectators shouldn't get docked for being in the game, see Bug 8848 2005-01-20 JWS
	if ( StatsIsInLiveGame() && !PlayerReplicationInfo.bOnlySpectator )
	{
		// find the stats manager if we have one already
		foreach allactors(class'gbxStatsManager',DummyStatsManager)
		{
			StatsManager = DummyStatsManager;
			break;
		}
		// otherwise create a new one
		if( StatsManager == None )
			StatsManager = Spawn(class'gbxStatsManager');
	}
	else
	{
		Log(Self$" did not save pregame stats to Xbox Live because we weren't online, weren't in a live game (or we are a guest)");
	}
	
}

function ClientGameEnded()
{
	// Spectators shouldn't get docked for being in the game, see Bug 8848 2005-01-20 JWS
	if ( StatsIsInLiveGame() && !PlayerReplicationInfo.bOnlySpectator )
	{
		if (StatsManager != None);
			StatsManager.GameEnd();
	}
	else
	{
		Log(Self$" did not save pregame stats to Xbox Live because we weren't online, weren't in a live game (or we are a guest)");
	}

	Super.ClientGameEnded();
}
//DS-END: stats uploading

exec notinship function DumpMissionInfo()
{
	log(self$".DumpMissionInfo() - "$(Level.TimeSeconds - Level.MissionStartTime)$" - "$(Level.TotalSquadMembersInMap - Level.SquadMembersKilled)$" - "$Level.NumShotsHit$" - "$Level.NumShotsFired$" - "$Level.NumShotsSuppression$" - "$((Level.NumShotsHit / Level.NumShotsFired) * 100.0f)$" - "$Level.NumAIShotsHit$" - "$Level.NumAIShotsFired$" - "$Level.NumAIShotsSuppression$" - "$((Level.NumAIShotsHit / Level.NumAIShotsFired) * 100.0f)$" - "$Level.NumKills$" - "$Level.NumAIKills);
}

exec notinship simulated function DumpUSInfantryTags()
{
	local InfantryUSA		aPawn;
	
	foreach AllActors( class'InfantryUSA', aPawn )
	{
		log("DumpUSInfantryTags: "$aPawn.Tag);
	}
}

exec notinship function CheckpointMemLog( bool bLog )
{
	bCheckpointMemLog=bLog;
}

exec notinship function DoHudDirtEffect( int numParticles )
{
	CreateHudDirtEffect( numParticles );
}

exec notinship function DoHudRainEffect( int numParticles )
{
	CreateHudRainEffect( numParticles );
}

exec function ClearCheckpointData()
{
	local GameProfile	gProfile;
	
	gProfile = class'GameProfile'.Static.LoadCurrentGameProfile( Level );
	if (gProfile != None)
	{
		Level.MissionManager.ClearCheckpointData( gProfile );
		class'GameProfile'.Static.UnloadProfile( Level, gProfile, true );
	}
}

// GBX:PAD: I'm putting this here so that some player operations (e.g. command ring mode) can disable the crosshair.
simulated function bool DisableCrosshair()
{
	if( OrderIcon != None )
	{
		return true;
	}

	return super.DisableCrosshair();
}

state FieldPromoting
{
	function BeginState()
    {
		// Clear off the screen
		ClearAllHudEffects();

		Super.BeginState();
	}
}

defaultproperties
{
	bHidden=true
    FovAngle=+00070.000000
	LocalMessageClass=class'LocalMessage'
	PlayerReplicationInfoClass=Class'gbxGameplay.TeamPlayerReplicationInfo'

	CheatClass=class'gbxGameplay.gbxCheatManager'

	zoom_threshold_speed=200.0f
	average_speed=0.0f
	average_speed_time=0.0f
	average_speed_oldest=0

	ZoomInSoundName="PLAYER.ZOOM_IN"
	ZoomOutSoundName="PLAYER.ZOOM_OUT"

	PawnClass=class'gbxCharacters.InfantryUSA'
	DebugManagerClassname="gbxUI.DebugManager"

	// Default values for aim assistance
	AimAssistParams=(TargetBaseClass=class'WargamePawn',SearchRadius=0.0,AimAlignmentThreshold=125.0,AimAdjustSpeed=6.0,LeadTargetRate=1.0,LeadTargetRange=6144.0,LeadTargetMaxAngle=12.0)

	//// Breathe variables
	BreatheLength =				(Min=0.5,Max=2.5)		// fatigue shortens breathe cycles (Max @ 0 fatigue)
	BreatheHoldLength =			(Min=0.0,Max=0.25)		// breathe is held at Max only with no fatigue (Max @ 0 fatigue)
	BreatheLengthConsistency =	(Min=0.8,Max=1.0)		// fatigue decreases breathe consistency (Max @ 0 fatigue)
	BreatheCrouchModifier =		(Min=0.3,Max=1.0)		// fatigue greatly reduces crouch benefit (Min @ 0 fatigue)
	BreatheStandModifierMP =    (Min=0.2,Max=1.0)
	// see gbxWeapon class for weapon specific breathe variables
	/////

	BreatheYawTarget = 0
	bBreatheYawTargetSet = false
	LastYawAdjustDir = NoDir
//	BreatheInhaleSoundName = "PLAYER.BREATHE_IN"
//	BreatheExhaleSoundName = "PLAYER.BREATHE_OUT"

	bAimAssistStickToTargetWhenZoomed=false

	bShakeOnDamage=true

	SprintFovMod=+005.000
	SprintFovModRate=15.000
	bAdjustSprintFov=false

	HDRGlobalColor=(R=192,G=192,B=128)
	HDRFilterScalePass1=1.12
	HDRFilterScalePass2=1.12
	HDRFilterScalePass3=1.12
	bFullTimeHDR=false
	bCheckpointMemLog=false
	
	ScriptViewRestriction=rot(5461,8191,0)

	m_fViewOffsetAbs=true
	bNoHeavyTrauma=false

	bIsRaining = false
	bSuppressRainSounds = false
	NextRainEffect = 0.0
	NextRainExposureUpdate = 0.0
	RainExposureUpdateInterval = 0.5
	RainPitchFactor = 1.5
	RainParticleCount = (Min=2,Max=8)
	BaseRainFrequency = 0.05
	RainFrequencyVariance = 0.1
	RainExposure = 0.0
	RainExposureTestPitch = 1820 // ~ 10 degrees
	NumRainExposureTests = 5
	RainExposureTraceLength = 3096
	RainIntensity = 0.5
	RainLoopSoundName[0] = "RAIN.INHEAD_A"
	RainLoopSoundName[1] = "RAIN.INHEAD_B"
	RainLoopSoundName[2] = "RAIN.INHEAD_D"
	RainLoopSoundName[3] = "RAIN.INHEAD_E"
	RainLoopHandle[0] = -1
	RainLoopHandle[1] = -1
	RainLoopHandle[2] = -1
	RainLoopHandle[3] = -1
	RainLoopVolume = 0.04

	ForcedFaceViewDecelThreshold = 0.65
	ForcedFaceViewRestriction = (yaw=5461,pitch=4551,roll=0)
	bOracleCameraDisabled = false
}
//=============================================================================
// WargamePlayerInput
// Object within PlayerController that manages player input.
// only spawned on client
//=============================================================================

class WargamePlayerInput extends PlayerInput within PlayerController
	config(User)
	transient;



const JOY_PEG_THRESHOLD = 0.90;					// Input value where input is considered at maximum extents
const LOOK_ACCELERATION_RATE_COUNT = 5;			// number of sensitivity settings for the UI

var bool bIsPegged;

var float NextTargetUpdateTime;

var Rotator LookAxisAcceleration;						// for accelerating the look axis.  Keeps track of output velocity.
var globalconfig int LookYawAcceleration;				// set by the Options UI
var globalconfig int LookPitchAcceleration;				// set by the Options UI
var globalconfig Range LookYawAccelerationRate[LOOK_ACCELERATION_RATE_COUNT];
var globalconfig Range LookPitchAccelerationRate[LOOK_ACCELERATION_RATE_COUNT];
var globalconfig float LookYawMaxSpeed[LOOK_ACCELERATION_RATE_COUNT];
var globalconfig float LookYawPegSpeed[LOOK_ACCELERATION_RATE_COUNT];
var globalconfig float LookPitchMaxSpeed[LOOK_ACCELERATION_RATE_COUNT];

var globalconfig float LeadAdhesionFactor;				// Modifies the strength of the adhesion effect
var globalconfig float LeadFrictionFactorYaw;			// Modifies the strength of the friction effect (yaw)
var globalconfig float LeadFrictionFactorPitch;			// Modifies the strength of the friction effect (pitch)
var globalconfig float JoyPegMinThreshold;				// Minimum input required to maintain pegged state
var globalconfig float StrafeLookYawDampen;				// Look yaw is slowed by up to this much percentage based on strafe left/right input
var globalconfig float AimAssistTargetUpdateInterval;	// How often to recalculate the best target
var globalconfig bool  bAimAssistRequiresInput;			// Boolean indicated whether or not aim assistance requires some joystick input to be activated

simulated exec notinship function ToggleAimAssist()
{
	bUseAimAssist = !bUseAimAssist;
	if( bUseAimAssist )
	{
		ClientMessage("Aim assist enabled");
	}
	else
	{
		ClientMessage("Aim assist disabled");
	}

}

// Postprocess the player's input.
event PlayerInput( float DeltaTime )
{
	local float AxisAccelerationRate, absaBaseX, absaLookUp, AimCorrectionAmount, LeadFrictionYaw, LeadFrictionPitch, LeadAdhesion, LeadFraction, FOVScale, FOVScaleYaw, FOVScalePitch, TimeScale;
	local Rotator AngularVelocity;

	// Ignore input if we're playing back a client-side demo.
	if( Outer.bDemoOwner && !Outer.default.bDemoOwner )
		return;

	// Check for Double click move
	// flag transitions
	// DS-BEGIN
	// Clean up some accessed none's
	if( Pawn != None )
	{
		bEdgeForward = (bWasForward ^^ (aBaseY > (Pawn.GroundSpeed * JOY_PEG_THRESHOLD) ));
		bEdgeBack = (bWasBack ^^ (aBaseY < 0));
		bEdgeLeft = (bWasLeft ^^ (aStrafe < 0));
		bEdgeRight = (bWasRight ^^ (aStrafe > 0));
		bWasForward = (aBaseY > (Pawn.GroundSpeed * JOY_PEG_THRESHOLD) );
		bWasBack = (aBaseY < 0);
		bWasLeft = (aStrafe < 0);
		bWasRight = (aStrafe > 0);
	}
	// DS-END

	absaBaseX = abs(aBaseX);

	if ( !bInvertMouse )
		aLookUp = -aLookUp;

	LookYawAcceleration = Clamp(LookYawAcceleration, 0, LOOK_ACCELERATION_RATE_COUNT-1);
	LookPitchAcceleration = Clamp(LookPitchAcceleration, 0, LOOK_ACCELERATION_RATE_COUNT-1);

	
	if( absaBaseX > 0.0 )
	{
		if( absaBaseX > JOY_PEG_THRESHOLD || bIsPegged )
		{
			bIsPegged = true;

			if( absaBaseX <= JoyPegMinThreshold )
			{
				bIsPegged = false;
			}

			AxisAccelerationRate = Lerp( 1.0 - abs((aBaseX * LookYawPegSpeed[LookYawAcceleration]) - LookAxisAcceleration.yaw) / ( LookYawPegSpeed[LookYawAcceleration] * 2 ), LookYawAccelerationRate[LookYawAcceleration].Min, LookYawAccelerationRate[LookYawAcceleration].Max );
			AngularVelocity.yaw = AccelerateAxis( LookAxisAcceleration.yaw, ( aBaseX/absaBaseX ) * LookYawPegSpeed[LookYawAcceleration], AxisAccelerationRate, DeltaTime );
		}
		else
		{
			AxisAccelerationRate = Lerp( 1.0 - abs((aBaseX * LookYawMaxSpeed[LookYawAcceleration]) - LookAxisAcceleration.yaw) / ( LookYawMaxSpeed[LookYawAcceleration] * 2 ), LookYawAccelerationRate[LookYawAcceleration].Min, LookYawAccelerationRate[LookYawAcceleration].Max );
			AngularVelocity.yaw = AccelerateAxis( LookAxisAcceleration.yaw, aBaseX * LookYawMaxSpeed[LookYawAcceleration], AxisAccelerationRate, DeltaTime );
		}

		// Save the old velocity
		LookAxisAcceleration.yaw = AngularVelocity.yaw;
	}
	else
	{
		AngularVelocity.yaw = 0.0;
		LookAxisAcceleration.yaw = 0.0;
	}

	absaLookUp = abs(aLookUp);

	if( absaLookUp > 0.0 )
	{
		AxisAccelerationRate = Lerp( 1.0 - abs((aLookUp * LookPitchMaxSpeed[LookPitchAcceleration]) - LookAxisAcceleration.yaw) / ( LookPitchMaxSpeed[LookPitchAcceleration] * 2 ), LookPitchAccelerationRate[LookPitchAcceleration].Min, LookPitchAccelerationRate[LookPitchAcceleration].Max );
		AngularVelocity.pitch = AccelerateAxis( LookAxisAcceleration.pitch, aLookUp * LookPitchMaxSpeed[LookPitchAcceleration], AxisAccelerationRate, DeltaTime );
		LookAxisAcceleration.pitch = AngularVelocity.pitch;
	}
	else
	{
		AngularVelocity.pitch = 0.0;
		LookAxisAcceleration.pitch = 0.0;
	}

	// Adjust for zooming
	FOVScale = DesiredFOV / DefaultFOV;

	//// GEARBOX: SJP - Aim correction. Calls GetAutoAimTarget, implemented in PlayerController.uc.
	//// parses and applies all of the values in PlayerController.AimAssistParams.
	if( bUseAimAssist )
	{
		// Only update the current target at the specified interval
		if( NextTargetUpdateTime < Level.TimeSeconds )
		{
			NextTargetUpdateTime = Level.TimeSeconds + AimAssistTargetUpdateInterval;
			GetAutoAimTarget( AimAssistParams );
		}

		if( AimAssistParams.FoundTarget != None )
		{
			// Always calculate the target angular velocity
			CalculateTargetAngularVelocity( AimAssistParams );

			if( AimAssistParams.AimStyle == AimAssistStyle.StickToTarget )
			{
				// Correct aim only if the player is not moving and the yaw look input is zero
				if( aBaseX == 0 && aStrafe == 0 && aBaseY == 0 )
				{
					// Only correct yaw axis
					AimCorrectionAmount = AngularVelocity.yaw + AimAssistParams.AimToTargetVector.Z * AimAssistParams.AimAdjustSpeed;

					// Make sure we only move toward the target, not away from it
					if( abs(AimCorrectionAmount) > abs(AngularVelocity.yaw ) )
						AngularVelocity.yaw  = AimCorrectionAmount;
				}
			}
			else if( AimAssistParams.AimStyle == AimAssistStyle.LeadTarget )
			{
				// Modify range for zoom
				AimAssistParams.LeadTargetRange /= FOVScale;
				AimAssistParams.LeadTargetMaxAngle *= FOVScale;

				// Attenuate effect of lead adhesion and friction based on player's angle to target and distance from target
				LeadFraction = ComputeCompositeAttenuation( AimAssistParams.AimToTargetAngle, AimAssistParams.LeadTargetMaxAngle, AimAssistParams.DistanceToTarget, AimAssistParams.LeadTargetRange );

				if( LeadFraction > 0 && ((AngularVelocity.yaw != 0 || AngularVelocity.pitch != 0 || aStrafe != 0 || aBaseY != 0) || !bAimAssistRequiresInput) )
				{
					// 'Adhesion' makes the player's aim adhere to (track) the target
					LeadAdhesion = FClamp( LeadAdhesionFactor * LeadFraction, 0.0, 1.0 );

					// 'Friction' is applied to the player's aim input while he has a target, to slow down his look input
					LeadFrictionYaw = FClamp( 1 - LeadFrictionFactorYaw * LeadFraction, 0.0, 1.0 );
					LeadFrictionPitch = FClamp( 1 - LeadFrictionFactorPitch * LeadFraction, 0.0, 1.0 );

					AngularVelocity.yaw   = LeadAdhesion * AimAssistParams.TargetAngularVelocity.yaw   + LeadFrictionYaw * AngularVelocity.yaw;
					AngularVelocity.pitch = LeadAdhesion * AimAssistParams.TargetAngularVelocity.pitch + LeadFrictionPitch * AngularVelocity.pitch;

					//log("*** SJP: Leading target. LeadLevel: "$LeadFraction$" TAV.yaw: "$AimAssistParams.TargetAngularVelocity.yaw$" TAV.pitch: "$AimAssistParams.TargetAngularVelocity.pitch);
				}
			}
		}
	}

	if( Level.Game != None )
		TimeScale = 1 / Level.Game.GameSpeed;
	else
		TimeScale = 1.0f;

	// These variables are actually used to make the adjustments to the look rotation.  Scaled based on time
	FOVScaleYaw = FOVScale;
	FOVScalePitch = FOVScale;

	if( FOVScale < 0.98 )
	{
		// If zoomed in at all, attenuate yaw rotation substantially.
		FOVScaleYaw = FClamp( FOVScale * FOVScale, 0.1, 0.7 );	// Exponent it and clamp it.
	}

	aTurn = AngularVelocity.yaw * TimeScale * FOVScaleYaw * Lerp( FClamp( (Pawn.GroundSpeed - abs(aStrafe))/ Pawn.GroundSpeed, 0.0, Pawn.GroundSpeed ), StrafeLookYawDampen, 1.0 );
	aLookUp	= AngularVelocity.pitch * TimeScale * FOVScalePitch;
	aForward += aBaseY;

	// Set the max look speed in PlayerController
	Outer.MaxLookYawSpeed = FOVScaleYaw * LookYawMaxSpeed[LookYawAcceleration];
	Outer.MaxLookPitchSpeed = FOVScalePitch * LookPitchMaxSpeed[LookPitchAcceleration];

	// Handle walking.
	HandleWalking();
}

function float AccelerateAxis( float OldAxisVelocity, float CurrentAxisVelocity, float Rate, float DeltaTime )
{
	local float NewVelocity;
	local float NewVelocityDirection;

	// Immediately stop if the input velocity is zero
	if( abs(CurrentAxisVelocity) < 0.00001 )
	{
		return 0.0;
	}
	else
	{
		Rate = Rate * Abs(CurrentAxisVelocity);	// Rate of acceleration increases in conjunction with input velocity
		NewVelocityDirection = CurrentAxisVelocity / Abs(CurrentAxisVelocity);
		NewVelocity = NewVelocityDirection * FMin( Abs(CurrentAxisVelocity), Abs(OldAxisVelocity) + (Rate * DeltaTime) );
	}

	return NewVelocity;
}

defaultproperties
{
     DoubleClickTime=0.280000
	 LookAxisAcceleration = (yaw=0,pitch=0,roll=0)
	 JoyPegMinThreshold=0.9
	 bAimAssistRequiresInput = true
	 LeadAdhesionFactor = 0.7
	 LeadFrictionFactorYaw = 0.6
	 LeadFrictionFactorPitch = 0.6
	 StrafeLookYawDampen = 1.0
	 AimAssistTargetUpdateInterval = 0.25

	 LookYawAcceleration=2
	 LookPitchAcceleration=2

	 LookYawPegSpeed(0) = 40960
	 LookYawPegSpeed(1) = 45056
	 LookYawPegSpeed(2) = 49152
	 LookYawPegSpeed(3) = 53248
	 LookYawPegSpeed(4) = 57344

	 LookYawMaxSpeed(0) = 20480
	 LookYawMaxSpeed(1) = 22528
	 LookYawMaxSpeed(2) = 24576
	 LookYawMaxSpeed(3) = 26624
	 LookYawMaxSpeed(4) = 28672

	 LookPitchMaxSpeed(0) = 6144
	 LookPitchMaxSpeed(1) = 7168
	 LookPitchMaxSpeed(2) = 8192
	 LookPitchMaxSpeed(3) = 9216
	 LookPitchMaxSpeed(4) = 10240

	 LookYawAccelerationRate(0) = (Min=0.2,Max=1.5)
	 LookYawAccelerationRate(1) = (Min=0.5,Max=2.0)
	 LookYawAccelerationRate(2) = (Min=0.9,Max=2.8)
	 LookYawAccelerationRate(3) = (Min=2.0,Max=3.2)
	 LookYawAccelerationRate(4) = (Min=3.0,Max=3.6)

	 LookPitchAccelerationRate(0) = (Min=1.7,Max=2.2)
	 LookPitchAccelerationRate(1) = (Min=2.1,Max=2.6)
	 LookPitchAccelerationRate(2) = (Min=2.5,Max=3.0)
	 LookPitchAccelerationRate(3) = (Min=2.9,Max=3.4)
	 LookPitchAccelerationRate(4) = (Min=3.3,Max=3.8)
}
class WargameRosterEntry extends Object
		editinlinenew;



var() class<gbxPawn> PawnClass;
var() string PawnClassName;
var() string PlayerName;
var() string ModifiedPlayerName;
var() enum EOrders
{
	ORDERS_None,
	ORDERS_Attack,
	ORDERS_Defend,
	ORDERS_Freelance,
	ORDERS_Support,
	ORDERS_Roam
} Orders;
var() bool bTaken;

var() class<Weapon> FavoriteWeapon;
var() float Aggressiveness;		// 0 to 1 (0.3 default, higher is more aggressive)
var() float Accuracy;			// -1 to 1 (0 is default, higher is more accurate)
var() float CombatStyle;		// 0 to 1 (0= stay back more, 1 = charge more)
var() float StrafingAbility;	// -1 to 1 (higher uses strafing more)
var() float Tactics;			// -1 to 1 (higher uses better team tactics)
var() float ReactionTime;
var bool bJumpy;

function Init() //amb
{
    if( PawnClassName != "" )
        PawnClass = class<gbxPawn>(DynamicLoadObject(PawnClassName, class'class'));
    //log(self$" PawnClass="$PawnClass);
}

function PrecacheRosterFor(WargameTeamInfo T);

function bool RecommendSupport()
{
	return ( Orders == ORDERS_Support );
}

function bool NoRecommendation()
{
	return ( Orders == ORDERS_None );
}

function bool RecommendDefense()
{
	return ( Orders == ORDERS_Defend );
}

function bool RecommendFreelance()
{
	return ( Orders == ORDERS_Freelance );
}

function bool RecommendAttack()
{
	return ( Orders == ORDERS_Attack );
}

defaultproperties
{
	Aggressiveness=+0.3
	Accuracy=+0.0
	CombatStyle=+0.2
}
class WargameScoreboard extends ScoreBoard;

//#exec OBJ LOAD FILE=..\textures\T_WarfareToRemove.utx


const MAXPLAYERS=32;
var() localized string      RankText;
var() localized string      PlayerText;
var() localized string      PointsText;
var() localized string      TimeText;
var() localized string      PingText;
var() localized string		DeathsText;
var() localized string		AdminText;
var() localized string		NetText;
var() localized string      FooterText;
var localized string MatchIDText;
var localized string		OutText;
var localized string ReadyText,NotReadyText;
var localized string		SkillLevel[8];  // all accesses are clamped (0,7)
var localized string YouveLostTheMatch,YouveWonTheMatch;
var PlayerReplicationInfo PRIArray[MAXPLAYERS];

// gamestats
var() localized String		MaxLives, FragLimit, FPH, GameType,MapName, Restart, Continue, Ended, TimeLimit, Spacer;

var() Material BoxMaterial;

simulated function UpdatePrecacheMaterials()
{
    UpdatePrecacheFonts();
}

function UpdatePrecacheFonts();

function DrawTitle(Canvas Canvas, float HeaderOffsetY, float PlayerAreaY)
{
	local string titlestring,scoreinfostring;
	local float TitleXL,ScoreInfoXL,YL;

	if ( Canvas.ClipX < 512 )
		return;
	if ( Level.NetMode == NM_Standalone )
		titlestring = SkillLevel[Clamp(Level.Game.GameDifficulty,0,7)];

	titlestring = titlestring@GRI.GameName$MapName$Level.Title;
	Canvas.StrLen(TitleString,TitleXL,YL);

	if ( GRI.MaxLives != 0 )
		ScoreInfoString = MaxLives@GRI.MaxLives;
	else if ( GRI.GoalScore != 0 )
		ScoreInfoString = FragLimit@GRI.GoalScore;
	if ( GRI.TimeLimit != 0 )
		ScoreInfoString = ScoreInfoString@spacer@TimeLimit$FormatTime(GRI.RemainingTime);
	else
		ScoreInfoString = ScoreInfoString@spacer@FooterText@FormatTime(GRI.ElapsedTime);

	Canvas.DrawColor = class'Canvas'.static.MakeColor(255,255,0);
	if ( PlayerController(Owner).IsDead() )
	{
		if ( Canvas.ClipY - HeaderOffsetY - PlayerAreaY >= 2.5 * YL )
		{
			Canvas.StrLen(Restart,ScoreInfoXL,YL);
			Canvas.SetPos(0.5*(Canvas.ClipX-ScoreInfoXL), Canvas.ClipY - 2.5 * YL);
			Canvas.DrawText(Restart,true);
		}
		else
			ScoreInfoString = Restart;
	}
	Canvas.StrLen(ScoreInfoString,ScoreInfoXL,YL);

	Canvas.SetPos(0.5*(Canvas.ClipX-TitleXL), 0.5*YL);
	Canvas.DrawText(TitleString,true);
	Canvas.SetPos(0.5*(Canvas.ClipX-ScoreInfoXL), Canvas.ClipY - 1.5 * YL);
	Canvas.DrawText(ScoreInfoString,true);
}

simulated event UpdateScoreBoard(Canvas Canvas, float ScaleX, float ScaleY, optional bool bSimplified)
{
	local PlayerReplicationInfo PRI, OwnerPRI;
	local int i, FontReduction, OwnerPos, NetXPos, PlayerCount,HeaderOffsetY,HeadFoot, MessageFoot, PlayerBoxSizeY, BoxSpaceY, NameXPos, BoxTextOffsetY, OwnerOffset, ScoreXPos, DeathsXPos, BoxXPos, TitleYPos, BoxWidth;
	local float XL,YL, MaxScaling;
	local float deathsXL, scoreXL, netXL;
	local string playername[MAXPLAYERS];
	local color WhiteColor;

	OwnerPRI = PlayerController(Owner).PlayerReplicationInfo;
    for (i=0; i<GRI.PRIArray.Length; i++)
	{
		PRI = GRI.PRIArray[i];
		if ( !PRI.bIsSpectator || PRI.bWaitingPlayer )
		{
			if ( PRI == OwnerPRI )
				OwnerOffset = i;
			PlayerCount++;
		}
	}
	PlayerCount = Min(PlayerCount,MAXPLAYERS);

	// Select best font size and box size to fit as many players as possible on screen
	Canvas.Font = Font'Engine.DefaultFont';
	Canvas.StrLen("Test", XL, YL);
	BoxSpaceY = 0.25 * YL;
	PlayerBoxSizeY = 1.5 * YL;
	HeadFoot = 5*YL;
	MessageFoot = 1.5 * HeadFoot;
	if ( PlayerCount > (Canvas.ClipY - 1.5 * HeadFoot)/(PlayerBoxSizeY + BoxSpaceY) )
	{
		BoxSpaceY = 0.125 * YL;
		PlayerBoxSizeY = 1.25 * YL;
		if ( PlayerCount > (Canvas.ClipY - 1.5 * HeadFoot)/(PlayerBoxSizeY + BoxSpaceY) )
		{
			if ( PlayerCount > (Canvas.ClipY - 1.5 * HeadFoot)/(PlayerBoxSizeY + BoxSpaceY) )
				PlayerBoxSizeY = 1.125 * YL;
			if ( PlayerCount > (Canvas.ClipY - 1.5 * HeadFoot)/(PlayerBoxSizeY + BoxSpaceY) )
			{
				FontReduction++;
				Canvas.Font = GetSmallerFontFor(Canvas,FontReduction);
				Canvas.StrLen("Test", XL, YL);
				BoxSpaceY = 0.125 * YL;
				PlayerBoxSizeY = 1.125 * YL;
				HeadFoot = 5*YL;
				if ( PlayerCount > (Canvas.ClipY - HeadFoot)/(PlayerBoxSizeY + BoxSpaceY) )
				{
					FontReduction++;
					Canvas.Font = GetSmallerFontFor(Canvas,FontReduction);
					Canvas.StrLen("Test", XL, YL);
					BoxSpaceY = 0.125 * YL;
					PlayerBoxSizeY = 1.125 * YL;
					HeadFoot = 5*YL;
					if ( (Canvas.ClipY >= 768) && (PlayerCount > (Canvas.ClipY - HeadFoot)/(PlayerBoxSizeY + BoxSpaceY)) )
					{
						FontReduction++;
						Canvas.Font = GetSmallerFontFor(Canvas,FontReduction);
						Canvas.StrLen("Test", XL, YL);
						BoxSpaceY = 0.125 * YL;
						PlayerBoxSizeY = 1.125 * YL;
						HeadFoot = 5*YL;
					}
				}
			}
		}
	}
	if ( Canvas.ClipX < 512 )
		PlayerCount = Min(PlayerCount, 1+(Canvas.ClipY - HeadFoot)/(PlayerBoxSizeY + BoxSpaceY) );
	else
		PlayerCount = Min(PlayerCount, (Canvas.ClipY - HeadFoot)/(PlayerBoxSizeY + BoxSpaceY) );
	if ( OwnerOffset >= PlayerCount )
		PlayerCount -= 1;

	if ( FontReduction > 2 )
		MaxScaling = 3;
	else
		MaxScaling = 2.125;
	PlayerBoxSizeY = FClamp((1+(Canvas.ClipY - 0.67 * MessageFoot))/PlayerCount - BoxSpaceY, PlayerBoxSizeY, MaxScaling * YL);

	bDisplayMessages = (PlayerCount <= (Canvas.ClipY - MessageFoot)/(PlayerBoxSizeY + BoxSpaceY));
	HeaderOffsetY = 3 * YL;
	BoxWidth = 0.9375 * Canvas.ClipX;
	BoxXPos = 0.5 * (Canvas.ClipX - BoxWidth);
	BoxWidth = Canvas.ClipX - 2*BoxXPos;
	NameXPos = BoxXPos + 0.0625 * BoxWidth;
	ScoreXPos = BoxXPos + 0.5 * BoxWidth;
	DeathsXPos = BoxXPos + 0.6875 * BoxWidth;
	NetXPos = BoxXPos + 0.8125 * BoxWidth;

	// draw background boxes
	Canvas.Style = ERenderStyle.STY_Alpha;
	WhiteColor = class'Canvas'.Static.MakeColor(255,255,255);
	Canvas.DrawColor = WhiteColor * 0.5;
	for ( i=0; i<PlayerCount; i++ )
	{
		Canvas.SetPos(BoxXPos, HeaderOffsetY + (PlayerBoxSizeY + BoxSpaceY)*i);
		Canvas.DrawTileStretched( BoxMaterial, BoxWidth, PlayerBoxSizeY);
	}
	Canvas.Style = ERenderStyle.STY_Translucent;

	// draw title
	Canvas.Style = ERenderStyle.STY_Normal;
	DrawTitle(Canvas,HeaderOffsetY,(PlayerCount+1)*(PlayerBoxSizeY + BoxSpaceY));

	// Draw headers
	TitleYPos = HeaderOffsetY - 1.25*YL;
	Canvas.StrLen(PointsText, ScoreXL, YL);
	Canvas.StrLen(DeathsText, DeathsXL, YL);

	Canvas.DrawColor = WhiteColor;
	Canvas.SetPos(NameXPos, TitleYPos);
	Canvas.DrawText(PlayerText,true);
	Canvas.SetPos(ScoreXPos - 0.5*ScoreXL, TitleYPos);
	Canvas.DrawText(PointsText,true);
	Canvas.SetPos(DeathsXPos - 0.5*DeathsXL, TitleYPos);
	Canvas.DrawText(DeathsText,true);

	// draw player names
	for ( i=0; i<PlayerCount; i++ )
	{
		playername[i] = GRI.PRIArray[i].PlayerName;
		Canvas.StrLen(playername[i], XL, YL);
		if ( XL > 0.9 * (ScoreXPos - NameXPos) )
			playername[i] = left(playername[i], 0.9 * (ScoreXPos-NameXPos)/XL * len(PlayerName[i]));
	}
	if ( OwnerOffset >= PlayerCount )
	{
		playername[OwnerOffset] = GRI.PRIArray[OwnerOffset].PlayerName;
		Canvas.StrLen(playername[OwnerOffset], XL, YL);
		if ( XL > 0.9 * (ScoreXPos - NameXPos) )
			playername[OwnerOffset] = left(playername[OwnerOffset], 0.9 * (ScoreXPos-NameXPos)/XL * len(PlayerName[OwnerOffset]));
	}

	Canvas.Style = ERenderStyle.STY_Normal;
	Canvas.DrawColor = WhiteColor;
	Canvas.SetPos(0.5 * Canvas.ClipX, HeaderOffsetY + 4);
	BoxTextOffsetY = HeaderOffsetY + 0.5 * (PlayerBoxSizeY - YL);

	Canvas.DrawColor = WhiteColor;
	for ( i=0; i<PlayerCount; i++ )
		if ( i != OwnerOffset )
		{
			Canvas.SetPos(NameXPos, (PlayerBoxSizeY + BoxSpaceY)*i + BoxTextOffsetY);
			Canvas.DrawText(playername[i],true);
		}

	// draw scores
	Canvas.DrawColor = WhiteColor;
	for ( i=0; i<PlayerCount; i++ )
		if ( i != OwnerOffset )
		{
			Canvas.SetPos(ScoreXPos, (PlayerBoxSizeY + BoxSpaceY)*i + BoxTextOffsetY);
			if ( GRI.PRIArray[i].bOutOfLives )
				Canvas.DrawText(OutText,true);
			else
				Canvas.DrawText(int(GRI.PRIArray[i].Score),true);
		}

	// draw deaths
	Canvas.DrawColor = WhiteColor;
	for ( i=0; i<PlayerCount; i++ )
		if ( i != OwnerOffset )
		{
			Canvas.SetPos(DeathsXPos, (PlayerBoxSizeY + BoxSpaceY)*i + BoxTextOffsetY);
			Canvas.DrawText(int(GRI.PRIArray[i].Deaths),true);
		}

	// draw owner line
	if ( OwnerOffset >= PlayerCount )
	{
		OwnerPos = (PlayerBoxSizeY + BoxSpaceY)*PlayerCount + BoxTextOffsetY;
		// draw extra box
		Canvas.Style = ERenderStyle.STY_Alpha;
		Canvas.DrawColor = class'Canvas'.static.MakeColor(0,255,255) * 0.5;
		Canvas.SetPos(BoxXPos, HeaderOffsetY + (PlayerBoxSizeY + BoxSpaceY)*PlayerCount);
		Canvas.DrawTileStretched( BoxMaterial, BoxWidth, PlayerBoxSizeY);
		Canvas.Style = ERenderStyle.STY_Normal;
	}
	else
		OwnerPos = (PlayerBoxSizeY + BoxSpaceY)*OwnerOffset + BoxTextOffsetY;

	Canvas.DrawColor = class'Canvas'.static.MakeColor(255,255,0);
	Canvas.SetPos(NameXPos, OwnerPos);
	Canvas.DrawText(playername[OwnerOffset],true);
	Canvas.SetPos(ScoreXPos, OwnerPos);
	if ( GRI.PRIArray[OwnerOffset].bOutOfLives )
		Canvas.DrawText(OutText,true);
	else
		Canvas.DrawText(int(GRI.PRIArray[OwnerOffset].Score),true);
	Canvas.SetPos(DeathsXPos, OwnerPos);
	Canvas.DrawText(int(GRI.PRIArray[OwnerOffset].Deaths),true);

	if ( Level.NetMode == NM_Standalone )
		return;

	Canvas.StrLen(NetText, NetXL, YL);
	Canvas.DrawColor = WhiteColor;
	Canvas.SetPos(NetXPos + 0.5*NetXL, TitleYPos);
	Canvas.DrawText(NetText,true);

	for ( i=0; i<GRI.PRIArray.Length; i++ )
		PRIArray[i] = GRI.PRIArray[i];
	DrawNetInfo(Canvas,FontReduction,HeaderOffsetY,PlayerBoxSizeY,BoxSpaceY,BoxTextOffsetY,OwnerOffset,PlayerCount,NetXPos);
	DrawMatchID(Canvas,FontReduction);
}

function DrawMatchID(Canvas Canvas,int FontReduction)
{
	local float XL,YL;

	if ( GRI.MatchID != 0 )
	{
		Canvas.Font = Font'Engine.DefaultFont';
		Canvas.StrLen(MatchIDText@GRI.MatchID, XL, YL);
		Canvas.SetPos(Canvas.ClipX - XL - 4, 4);
		Canvas.DrawText(MatchIDText@GRI.MatchID,true);
	}
}

function DrawNetInfo(Canvas Canvas,int FontReduction,int HeaderOffsetY,int PlayerBoxSizeY,int BoxSpaceY,int BoxTextOffsetY,int OwnerOffset,int PlayerCount, int NetXPos)
{
	local float XL,YL;
	local int i;
	local bool bHaveHalfFont;

	// draw admins
	if ( GRI.bMatchHasBegun )
	{
		Canvas.DrawColor = class'Canvas'.static.MakeColor(255,0,0);
		for ( i=0; i<PlayerCount; i++ )
			if ( PRIArray[i].bAdmin )
				{
					Canvas.SetPos(NetXPos, (PlayerBoxSizeY + BoxSpaceY)*i + BoxTextOffsetY);
					Canvas.DrawText(AdminText,true);
				}
		if ( (OwnerOffset >= PlayerCount) && PRIArray[OwnerOffset].bAdmin )
		{
			Canvas.SetPos(NetXPos, (PlayerBoxSizeY + BoxSpaceY)*PlayerCount + BoxTextOffsetY);
			Canvas.DrawText(AdminText,true);
		}
	}

	Canvas.DrawColor = class'Canvas'.static.MakeColor(0,255,255);
	Canvas.Font = Font'Engine.DefaultFont';
	Canvas.StrLen("Test", XL, YL);
	BoxTextOffsetY = HeaderOffsetY + 0.5*PlayerBoxSizeY;
	bHaveHalfFont = ( YL < 0.5 * PlayerBoxSizeY);

	// if game hasn't begun, draw ready or not ready
	if ( !GRI.bMatchHasBegun )
	{
		for ( i=0; i<PlayerCount; i++ )
		{
			if ( bHaveHalfFont )
			{
				Canvas.SetPos(NetXPos, (PlayerBoxSizeY + BoxSpaceY)*i + BoxTextOffsetY - YL);
				Canvas.DrawText(PingText@Min(999,PRIArray[i].Ping),true);
				Canvas.SetPos(NetXPos, (PlayerBoxSizeY + BoxSpaceY)*i + BoxTextOffsetY);
				if ( PRIArray[i].bReadyToPlay )
					Canvas.DrawText(ReadyText,true);
				else
					Canvas.DrawText(NotReadyText,true);
			}
			else
			{
				Canvas.SetPos(NetXPos, (PlayerBoxSizeY + BoxSpaceY)*i + BoxTextOffsetY - 0.5*YL);
				if ( PRIArray[i].bReadyToPlay )
					Canvas.DrawText(ReadyText,true);
				else
					Canvas.DrawText(NotReadyText,true);
			}
		}
		return;
	}

	// draw time and ping
	if ( Canvas.ClipX < 512 )
		PingText = "";
	else
		PingText = Default.PingText;
	for ( i=0; i<PlayerCount; i++ )
		if ( !PRIArray[i].bAdmin && !PRIArray[i].bOutOfLives )
 			{
				if ( bHaveHalfFont )
				{
					Canvas.SetPos(NetXPos, (PlayerBoxSizeY + BoxSpaceY)*i + BoxTextOffsetY - YL);
					Canvas.DrawText(PingText@Min(999,PRIArray[i].Ping),true);
					Canvas.SetPos(NetXPos, (PlayerBoxSizeY + BoxSpaceY)*i + BoxTextOffsetY);
					Canvas.DrawText(FormatTime(Max(0,GRI.ElapsedTime - PRIArray[i].StartTime)),true);
				}
				else
				{
					Canvas.SetPos(NetXPos, (PlayerBoxSizeY + BoxSpaceY)*i + BoxTextOffsetY - 0.5*YL);
					Canvas.DrawText(PingText@Min(999,PRIArray[i].Ping),true);
				}
			}
	if ( (OwnerOffset >= PlayerCount) && !PRIArray[OwnerOffset].bAdmin && !PRIArray[OwnerOffset].bOutOfLives )
	{
		if ( bHaveHalfFont )
		{
			Canvas.SetPos(NetXPos, (PlayerBoxSizeY + BoxSpaceY)*i + BoxTextOffsetY - YL);
			Canvas.DrawText(PingText@Min(999,PRIArray[OwnerOffset].Ping),true);
			Canvas.SetPos(NetXPos, (PlayerBoxSizeY + BoxSpaceY)*i + BoxTextOffsetY);
			Canvas.DrawText(FormatTime(Max(0,GRI.ElapsedTime - PRIArray[OwnerOffset].StartTime)),true);
		}
		else
		{
			Canvas.SetPos(NetXPos, (PlayerBoxSizeY + BoxSpaceY)*i + BoxTextOffsetY - 0.5*YL);
			Canvas.DrawText(PingText@Min(999,PRIArray[OwnerOffset].Ping),true);
		}
	}
}

defaultproperties
{
	MaxLives="MAX LIVES:"
    RankText="RANK"
    PlayerText="PLAYER"
    PointsText="SCORE"
    TimeText="TIME:"
    PingText="PING:"
    DeathsText="DEATHS"
	AdminText="ADMIN"
	NetText="NET"
	FPH="FPH"
	Spacer=" "
	MapName=" in "
	GameType="GAME"
	Restart="You were killed.  Press [Fire] to respawn!"
	Ended="The match has ended."
	Continue=" Press [Fire] to continue!"
	FragLimit="FRAG LIMIT:"
	TimeLimit="REMAINING TIME:"
    FooterText="Elapsed Time:"
	ReadyText="READY"
	NotReadyText="NOT RDY"
//	BoxMaterial=Material'T_WarfareToRemove.InterfaceContent.ScoreBoxA'
	OutText="OUT"
	MatchIDText="UT2003 Stats Match ID"
	YouveLostTheMatch="You've lost the match"
	YouveWonTheMatch="You've won the match"

	skillLevel[0]="NOVICE"
	skillLevel[1]="AVERAGE"
	skillLevel[2]="EXPERIENCED"
	skillLevel[3]="SKILLED"
	skillLevel[4]="ADEPT"
	skillLevel[5]="MASTERFUL"
	skillLevel[6]="INHUMAN"
	skillLevel[7]="GODLIKE"

	HUDClass=class'gbxHUD'
}
class WargameScriptedSequence extends ScriptedSequence;



var WargameScriptedSequence EnemyAcquisitionScript;
var Controller CurrentUser;
var WargameScriptedSequence NextScript;	// list of scripts with same tag
var bool bFirstScript;				// first script in list of scripts
var() bool bSniping;				// bots should snipe when using this script as a defense point
var() bool bDontChangeScripts;		// bot should go back to this script, not look for other compatible scripts
var bool  bFreelance;					// true if not claimed by any game objective
var() bool bRoamingScript;				// if true, roam after reaching
var() byte priority;				// used when several scripts available (e.g. defense scripts for an objective)
var() name EnemyAcquisitionScriptTag;	// script to go to after leaving this script for an acquisition
var() float EnemyAcquisitionScriptProbability;	// likelihood that bot will use acquisitionscript
// GBX:PAD: Removed the SnipingVolume script
//var() name SnipingVolumeTag;		// area defined by volume in which to look for (distant) sniping targets
var() class<Weapon> WeaponPreference;	// bots using this defense point will preferentially use this weapon

var float NumChecked;
var bool bAvoid;

/* Reset()
reset actor to initial state - used when restarting level without reloading.
*/
function Reset()
{
	FreeScript();
}

function FreeScript()
{
	CurrentUser = None;
}

function BeginPlay()
{
	local WargameScriptedSequence S;
//	local SnipingVolume V;

	Super.BeginPlay();

	if ( EnemyAcquisitionScriptTag != '' )
	{
		ForEach AllActors(class'WargameScriptedSequence',EnemyAcquisitionScript,EnemyAcquisitionScriptTag)
			break;
	}

	if ( bFirstScript )
	{
		// first one initialized - create script list
		ForEach AllActors(class'WargameScriptedSequence',S,Tag)
			if ( S != self )
			{
				NextScript = S;
				NextScript.bFirstScript = false;
				break;
			}
	}

// GBX:PAD: Removed the SnipingVolume script
//	if ( SnipingVolumeTag != 'None' )
//		ForEach AllActors(class'SnipingVolume',V,SnipingVolumeTag)
//			V.AddDefensePoint(self);
}

defaultproperties
{
	bFirstScript=true
	bFreelance=true
	EnemyAcquisitionScriptProbability=+1.0
//    Actions(0)=ScriptedAction'DefensePointDefaultAction1'
//    Actions(1)=ScriptedAction'DefensePointDefaultAction2'
	ScriptControllerClass=class'Gameplay.ScriptedController'
}
//=============================================================================
// WargameSinglePlayer
//=============================================================================
class WargameSinglePlayer extends WargameGameInfo
    config;

function InitGameReplicationInfo()
{
	Super.InitGameReplicationInfo();
	
	GameReplicationInfo.GameType = GT_SINGLEPLAYER;
}

event InitGame( string Options, out string Error )
{
	log(self $ " WargameSinglePlayer::InitGame(): Options = " $ Options, 'MP');

	super.InitGame( Options, Error );

	// Set the MP fatigue style flag
	Level.m_bMPStyleFatigue = false;
	Level.m_bMPStyleWeapons = false;
	log(self $ " WargameSinglePlayer::InitGame(): Level.m_bMPStyleFatigue: "$Level.m_bMPStyleFatigue$ " Level.m_bMPStyleWeapons: " $Level.m_bMPStyleWeapons, 'MP');
}

function bool SlowMotionDeath()
{
	return true;
}

function bool ShouldRespawn(Pickup Other)
{
	// GBX:PAD: Single player wargame should not respawn weapons.
	return false;
}

function RestartGame()
{
//	Level.GetLocalPlayerController().ConsoleCommand("open "$GetURLMap());
//	if (gbxHUD(Level.GetLocalPlayerController().MyHUD) != None)
//	{
//		gbxHUD(Level.GetLocalPlayerController().MyHUD).m_eHudMode = HudModeDead;
//	}
}

function CheckScore(PlayerReplicationInfo Scorer)
{
}

//
// Restart a player.
//
function RestartPlayer( Controller aPlayer )
{
	aPlayer.PawnClass.default.Mesh = Mesh(DynamicLoadObject("K_character_us.us_para_body", class'Mesh'));

	Super.RestartPlayer( aPlayer );

	// GBX:PAD: It kinda sucks to have to do it this way, but the way the code is laid out now there's not a particularly
	// practical alternative.  Basically, if the player start spot is flagged to not have weapons, then strip the weapons
	// off the already created player pawn.
	if ((gbxPlayerStart(aPlayer.Pawn.LastStartSpot) != None) && gbxPlayerStart(aPlayer.Pawn.LastStartSpot).m_fStartWithNoWeapons)
	{
		Infantry(aPlayer.Pawn).bNoDefaultInventory = true;
		while ( aPlayer.Pawn.Inventory != None )
			aPlayer.Pawn.Inventory.Destroy();

		aPlayer.Pawn.Weapon = None;
	}
	
	if ((Level.NetMode == NM_StandAlone) && (gbxPlayerPawn(aPlayer.Pawn) != None))
	{
		gbxPlayerPawn(aPlayer.Pawn).ResetPlayerCharacter();
	}
	
	if (gbxPlayerStart(aPlayer.Pawn.LastStartSpot) != None)
		gbxPlayerStart(aPlayer.Pawn.LastStartSpot).AddDefaultInventory( aPlayer.Pawn );

	gbxPawn(aPlayer.Pawn).CreateTeamLogoShadow("t_interface_mb.shadow_us_star");
}

/* Rate whether player should choose this NavigationPoint as its start
*/
function float RatePlayerStart(NavigationPoint N, byte Team, Controller Player, int nCheckpointID)
{
    local PlayerStart P;

    P = PlayerStart(N);

    if ( (P == None) || !P.bEnabled || P.PhysicsVolume.bWaterVolume )
        return -10000000;

	if ( P.m_nCheckpointID == nCheckpointID )
		return 10000001;

	return Super.RatePlayerStart( N, Team, Player, nCheckpointID );
}

function bool CanUseCheckpoints( int nCheckpointID )
{
	if (nCheckpointID == -1)
	{
		return true;
	}
	else
	{
		return (!((Level.DifficultyLevel == DIFF_Authentic) && (nCheckpointID > 1)));
	}
}

function SaveCheckpointID( int nCheckpointID )
{
	Level.MissionManager.SaveCheckpointID( nCheckpointID );
}

function SaveCheckpointIDCustom( int nCheckpointID, string szCustomMapName )
{
	Level.MissionManager.SaveCheckpointID( nCheckpointID );
}

function ClearCachedValues()
{
	Level.MissionManager.ClearCachedValues();
}

function bool GetCachedValue( name szValueName, out int nValue )
{
	return Level.MissionManager.GetCachedValue( szValueName, nValue );
}

defaultproperties
{
    ScoreBoardType=""
    bRestartLevel=True
    bPauseable=True
	FriendlyFireScale=0.0
}

//=============================================================================
// WargameSkirmish - New co-op game mode for BIA 1.5
//=============================================================================
class WargameSkirmish extends WargameMultiplayer
    config;

// constants
const NUM_SKILLSETS	= 3;
const MAX_SKILL_LEVEL = 9;
const NUM_DIFFICULTY_LEVELS = 4;
var string SKILLSET_NAMES[NUM_SKILLSETS];

enum SKILLSET
{
	SK_ACCURACY,					// Passed over as SDiff1
	SK_TACTICS,					// Passed over as SDiff2
	SK_SUPPRESSION,					// Passed over as SDiff3
};

enum ESkirmishGameType
{
	SGT_Objective,
	SGT_TimeChallenge,
	SGT_Defense,
	SGT_TourOfDuty,
	SGT_None,
};

// internal state
var ETeamIdentifier		PlayerTeam;		// This keeps track of which team the human players are on
var int					iSkillSets[NUM_SKILLSETS];
var int					iSkillChoice;	// one of the skill levels or custom
var int					iSkillToD;		// tour of duty tier level
var ESkirmishGameType	GameType;
var EUnitType			PlayerRoleChoice[2];
var int					iFireTeams[2];
var int					iFireTeamsCurrent[2];

var int					TimeRemaining;	// victory condition dumps this value here, placed into gri.finalscore when the game is over.

var	array<string>							ToDMapsUS,ToDMapsDE;

function PostBeginPlay()
{
	//log(self $ " WargameSkirmish::PostBeginPlay(): MaxTeams = " $ MaxTeams $ ", MaxTeamSize = " $ MaxTeamSize, 'MP');

	Super.PostBeginPlay();
}

function InitGameReplicationInfo()
{
	Super.InitGameReplicationInfo();
	
	GameReplicationInfo.GameType = GT_SKIRMISH;
}

function int GetSkillLevel()
{
	return iSkillSets[SKILLSET.SK_TACTICS];
}

event InitGame( string Options, out string Error )
{
	local string InOpt;
	local int tempInt;
	//local int test[NUM_SKILLSETS];

	//log(self $ " WargameSkirmish::InitGame(): Options = " $ Options, 'MP');

	super.InitGame( Options, Error );

	if (MaxPlayers == 1)
	{
		bPauseable=True;
	}
    
	// Set the MP fatigue style flag
	Level.m_bMPStyleFatigue = false;
	Level.m_bMPStyleWeapons = false;
	//log(self $ " WargameSkirmish::InitGame(): Level.m_bMPStyleFatigue: "$Level.m_bMPStyleFatigue$ " Level.m_bMPStyleWeapons: " $Level.m_bMPStyleWeapons, 'MP');

	// TODO:  Not passed to us ATM...maybe this turns into a setting to override SkillLevel defined in the LevelInfo?
	InOpt = ParseOption( Options, "Difficulty");
	if( InOpt != "" )
	{
		GameDifficulty = FClamp(int(InOpt), EDifficulty.DIFF_Easy, EDifficulty.DIFF_Authentic);

		Level.DifficultyLevel = EDifficulty(GameDifficulty);
		//log( "WargameSkirmish::InitGame() Applied difficulty=" $ Level.DifficultyLevel );
	}

	GameType = SGT_None;
	InOpt = ParseOption( Options, "SMode" );
	if ( InOpt != "" )
	{
		switch(int(InOpt))
		{
		case 0:
		case 1:
		case 2:
		case 3:
			GameType = ESkirmishGameType(int(InOpt));
			break;
		}
	}
	if ( GameType == SGT_None )
	{
		log( "WargameSkirmish::InitGame() WARNING... INVALID OR MISSING GAME TYPE", 'MP' );
	}
	else
	{
		log( "WargameSkirmish::InitGame() GameType=" $GameType, 'MP' );
	}

	InOpt = ParseOption( Options, "SSkill" );
	if ( InOpt != "" )
		iSkillChoice = int(InOpt);		

	// Save the skill values passed to us (passed over as 0-9 values)
	InOpt = ParseOption( Options, "SDiff1" );
	if (GameType == SGT_TourOfDuty)
	{
		if ( InOpt != "" )
			iSkillToD = int(InOpt);		

		log( "WargameSkirmish::InitGame() Tour of Duty: Tour #"$iSkillToD, 'MP' );
					
		// setup the skills based on what tour the player is on
		switch ( iSkillToD )
		{
			case 1:
				iSkillSets[SKILLSET.SK_ACCURACY] = 0;				
				iSkillSets[SKILLSET.SK_TACTICS] = 0;
				iSkillSets[SKILLSET.SK_SUPPRESSION] = 0;
				break;
			case 2:
				iSkillSets[SKILLSET.SK_ACCURACY] = 2;				
				iSkillSets[SKILLSET.SK_TACTICS] = 1;
				iSkillSets[SKILLSET.SK_SUPPRESSION] = 2;
				break;
			case 3:
				iSkillSets[SKILLSET.SK_ACCURACY] = 4;				
				iSkillSets[SKILLSET.SK_TACTICS] = 2;
				iSkillSets[SKILLSET.SK_SUPPRESSION] = 4;
				break;
			case 4:
				iSkillSets[SKILLSET.SK_ACCURACY] = 6;				
				iSkillSets[SKILLSET.SK_TACTICS] = 3;
				iSkillSets[SKILLSET.SK_SUPPRESSION] = 6;
				break;
			default:
				// Subtract 4 from iSkillToD to figure out how many levels we should add to each skill
				tempInt = iSkillToD - NUM_DIFFICULTY_LEVELS;
				iSkillSets[SKILLSET.SK_ACCURACY] = min( 6 + tempInt, 9/*max accuracy*/ );				
				iSkillSets[SKILLSET.SK_TACTICS] = min( 3 + tempInt, 3/*max tactics*/ );
				iSkillSets[SKILLSET.SK_SUPPRESSION] = min( 6 + tempInt, 9/*max suppression*/ );
				break;
		}
	}
	else
	{
		if ( InOpt != "" )
			iSkillSets[SKILLSET.SK_ACCURACY] = int(InOpt);		

		InOpt = ParseOption( Options, "SDiff2" );
		if ( InOpt != "" )
			iSkillSets[SKILLSET.SK_TACTICS] = int(InOpt);		

		InOpt = ParseOption( Options, "SDiff3" );
		if ( InOpt != "" )
			iSkillSets[SKILLSET.SK_SUPPRESSION] = int(InOpt);		
	}

	InOpt = ParseOption( Options, "ft1" );
	if ( InOpt != "" )
		iFireTeams[0] = int(InOpt);
		
	InOpt = ParseOption( Options, "ft2" );
	if ( InOpt != "" )
		iFireTeams[1] = int(InOpt);
		
	InOpt = ParseOption( Options, "SRole" );
	if ( InOpt != "" )
	{
		if (int(InOpt) == 1)
		{
			log( "WargameSkirmish::InitGame() Roles are Fire/Assault", 'MP' );
			PlayerRoleChoice[0] = UnitType_Base;
			PlayerRoleChoice[1] = UnitType_Assault;
		}
		else
		{
			log( "WargameSkirmish::InitGame() Roles are Assault/Fire", 'MP' );
			PlayerRoleChoice[0] = UnitType_Assault;
			PlayerRoleChoice[1] = UnitType_Base;
		}
	}
	else
	{
		log( "WargameSkirmish::InitGame() WARNING... NO ROLE SPECIFIED", 'MP' );
	}

	log( "WargameSkirmish::InitGame() SkillAccuracy=" $iSkillSets[SKILLSET.SK_ACCURACY]$ " SkillTactics="$iSkillSets[SKILLSET.SK_TACTICS]$" SkillSuppression: "$iSkillSets[SKILLSET.SK_SUPPRESSION], 'MP' );

	//IncrementRandomSkillSet(test);

	// Setup difficulty manager now that we have the skill sets
	Level.DifficultyManager.SetDifficulty(DIFF_Easy);
}

event PlayerController Login
(
    string Portal,
    string Options,
    out string Error
)
{
    local PlayerController NewPlayer;

	NewPlayer = Super.Login(Portal,Options,Error);
	
	NewPlayer.PlayerReplicationInfo.NumLives = 0; 
	
	// set the player's lobby client number if we're a spectator as this is skipped for spectators
    if ( NewPlayer.PlayerReplicationInfo.bOnlySpectator )
		NewPlayer.PlayerReplicationInfo.LobbyClientNum = GetLobbyClientNum();
	
	return NewPlayer;
}

function Logout(controller Exiting)
{
	//Log(self $ " WargameSkirmish::Logout() Controller " $ Exiting $ " is leaving", 'MP');

    Super.Logout(Exiting);
}

function Killed( Controller Killer, Controller Killed, Pawn KilledPawn, class<DamageType> damageType )
{
	local int x;
	local gbxPlayerController CoopPC;
	local gbxPawn gbxKilledPawn, gbxCoopPawn;
	local MultiplayerUnit KilledMPUnit, CoopMPUnit;
	local Unit KilledSubUnit;
	local int KilledNumLivingMembers, CoopNumLivingMembers;
	local int OpenSubUnitIndex;

	//Log( " WargameSkirmish::Killed() Killed: "$Killed$ " KilldedPawn: "$KilledPawn, 'MP' );
	Super.Killed( Killer, Killed, KilledPawn, damageType );

	// Check to see if this was a player that died...if so, reassign any AI guys he has remaining in his unit
	if ( Killed.bIsHumanPlayer )
	{
		//Log( " WargameSkirmish::Killed() Killed controller is a human player!", 'MP' );

		gbxKilledPawn = gbxPawn(KilledPawn);
		KilledMPUnit = MultiplayerUnit(gbxKilledPawn.MyUnit);

		CoopPC = GetNonSpectatingTeammatePlayerController( PlayerController(Killed) );

		if ( CoopPC != None && !CoopPC.IsDead() )
		{
			gbxCoopPawn = gbxPawn(CoopPC.Pawn);
			CoopMPUnit = MultiplayerUnit(gbxCoopPawn.MyUnit);

			KilledNumLivingMembers = KilledMPUnit.GetNumLivingMembers( true );
			CoopNumLivingMembers = CoopMPUnit.GetNumLivingMembers( true );

			//Log( " WargameSkirmish::Killed() CoopPC: "$CoopPC$ " gbxCoopPawn: "$gbxCoopPawn$ " CoopMPUnit: "$CoopMPUnit, 'MP' );
			//Log( " WargameSkirmish::Killed() KilledNumLivingMembers: "$KilledNumLivingMembers$ " CoopNumLivingMembers: " $CoopNumLivingMembers, 'MP' );

			// Are there any AI guys left alive?
			if ( KilledNumLivingMembers > 0 )
			{
				// There are so figure out which sub unit is free under the alive coop player
				if ( CoopNumLivingMembers > 0 )
				{
					if ( CoopMPUnit.SubUnits[0] == None )
						OpenSubUnitIndex = 0;
					else if ( CoopMPUnit.SubUnits[1] == None )
						OpenSubUnitIndex = 1;
					else
						OpenSubUnitIndex = -1;	// What in da hizell?

					//OpenSubUnitIndex
				}

				//log( "WargameSkirmish::Killed() OpenSubUnitIndex: "$OpenSubUnitIndex, 'MP' );

				if ( OpenSubUnitIndex != -1 )
				{
					// attach new doods
					//log( "WargameSkirmish::Killed() KilledMPUnit.NumSubUnits: "$KilledMPUnit.NumSubUnits, 'MP' );

					// Check to see if killed player has any guys remaining
					for ( x = 0; x < KilledMPUnit.NumSubUnits; x++ )
					{
						KilledSubUnit = KilledMPUnit.SubUnits[x];

						//log( "WargameSkirmish::Killed() KilledSubUnit: " $KilledSubUnit, 'MP' );

						if ( KilledSubUnit != None )
						{
							// Remove sub unit and add to coop player
							//log( "WargameSkirmish::Killed() KilledMPUnit.NumSubUnits before removal: " $KilledMPUnit.NumSubUnits, 'MP' );
							KilledMPUnit.RemoveSubUnit( KilledSubUnit );
							//log( "WargameSkirmish::Killed() KilledMPUnit.NumSubUnits after removal: " $KilledMPUnit.NumSubUnits, 'MP' );
							//log( "WargameSkirmish::Killed() CoopMPUnit.NumSubUnits before removal: " $CoopMPUnit.NumSubUnits, 'MP' );
							CoopMPUnit.AddSubUnit( KilledSubUnit );
							//log( "WargameSkirmish::Killed() CoopMPUnit.NumSubUnits before removal: " $CoopMPUnit.NumSubUnits, 'MP' );
							break;
						}
					}

					//Log( self$ " WargameSkirmish::Killed() Incrementing iReplicatedReinforcements variable of Unit so effect happens on client.", 'MP');	
					CoopMPUnit.SubUnits[OpenSubUnitIndex].iReplicatedReinforcements++;
				}
			}
			/*else
			{
				log( "WargameSkirmish::Killed() KillPawn doesn't have any living members in his unit!", 'MP' );
			}*/
		}

		// Human player was killed
		// Notify registered victory conditions 
		for( x = 0; x < VictoryConditionsToNotifyOnKilledEvent.Length; ++x )
		{
			//log( "WargameSkirmish::Killed() About to notify VC: "$VictoryConditionsToNotifyOnKilledEvent[x], 'MP' );
			VictoryConditionsToNotifyOnKilledEvent[x].NotifyPlayerCasualty( KilledPawn );		
		}
	}	
	else
	{
		// AI player was killed
		//log( "WargameSkirmish::Killed() Killed controller is an AI player!", 'MP' );

		// Notify registered victory conditions
		for( x = 0; x < VictoryConditionsToNotifyOnKilledEvent.Length; ++x )
		{
			//log( "WargameSkirmish::Killed() About to notify VC: "$VictoryConditionsToNotifyOnKilledEvent[x], 'MP' );
			VictoryConditionsToNotifyOnKilledEvent[x].NotifyAICasualty( KilledPawn, Killer.Pawn );
		}
	}
}

function int GetWavesScore()
{
	local PlayerController PC;
    local int score;
	
    for (PC=Level.PlayerControllerList; PC!=None; PC=PC.NextPlayerController )
	{
        if ( PC.PlayerReplicationInfo != None )
		{
			if (!PC.PlayerReplicationInfo.bOnlySpectator)
			{
				if (PC.PlayerReplicationInfo.PlayerID == 0)
				{
					score = PC.PlayerReplicationInfo.WavesScore;
					break;
				}
			}
		}
	}

	return Max(0,score-1);
}

function int GetTotalKills()
{
	local PlayerController PC;
    local int score, i;
	
    for (PC=Level.PlayerControllerList; PC!=None; PC=PC.NextPlayerController )
	{
        if ( PC.PlayerReplicationInfo != None )
		{
			if (!PC.PlayerReplicationInfo.bOnlySpectator)
			{
				score += PC.PlayerReplicationInfo.Score;
				for (i=0; i<GameReplicationInfo.URIArray.Length; i++)
				{
					if (GameReplicationInfo.URIArray[i].BelongsToPlayer(PC.PlayerReplicationInfo))
					{
						score += GameReplicationInfo.URIArray[i].Score;
					}
				}
			}
		}
	}

	return score;
}

function EndGame(PlayerReplicationInfo Winner, string Reason )
{
//	local	PlayerController	aPlayer;
	
	// GBX:PAD: If the game is paused, we need to make sure to unpause it here or it will hose down the ending game
	// logic.
	if (bPauseable && (Level.Pauser != None))
	{
		Level.GetLocalPlayerController().SetPause( false );
	}
	
	Super.EndGame(Winner, Reason);

	// clear from sentinel
	GameReplicationInfo.FinalScore = 0;
	GameReplicationInfo.TotalKills = GetTotalKills();
	GameReplicationInfo.Skirmish_Mode = GameType;
	GameReplicationInfo.Skirmish_Skill = iSkillChoice;

	switch(int(GameType))
	{
	case 0:	// SGT_Objective
		break;
	case 1:	// SGT_TimeChallenge
		GameReplicationInfo.FinalScore = TimeRemaining;
		break;
	case 2:	// SGT_Defense
		GameReplicationInfo.FinalScore = GetWavesScore();
		break;
	case 3:	// SGT_TourOfDuty
		GameReplicationInfo.NextMapName = FindNextToDMap();
		GameReplicationInfo.FinalScore = iSkillToD;
		break;
	}

// GBX:PAD: The skirmish end game fade is a "potential" TCR violation, so lets remove it and not take the chance.
//	for(aPlayer = Level.PlayerControllerList; aPlayer != None; aPlayer = aPlayer.NextPlayerController)
//	{
//		aPlayer.FadePlayerScreen( 1, 2.0, true );
//	}
}

//
// Restart a player.
// Overridden because they don't want the ability to field promote in skirmish
//
function RestartPlayer( Controller aPlayer )
{
	//log(self $ " WargameSkirmish::RestartPlayer(): aPlayer = " $ aPlayer $ ", aPlayer.PreviousPawnClass = " $ aPlayer.PreviousPawnClass, 'MP');

	//If this is our first restart then spawn the player normally, otherwise the game is over
	if (aPlayer.PreviousPawnClass == NONE)
	{
		//log(self $ " WargameSkirmish::RestartPlayer(): First restart, spawning player normally.", 'MP');
		CreatePlayer(aPlayer, PlayerCreationMode_FromScratch);
	}
	else
	{
		//log(self$ " WargameSkirmish::RestartPlayer() moving to spectating state.");
		WargamePlayerController(aPlayer).ServerSpectate();
		
	}
	
	//log(self $ " WargameSkirmish::RestartPlayer() end: aPlayer.Pawn = " $ aPlayer.Pawn, 'MP');
}

auto state PreMatch
{
	function TeamsAssignPlayersBasedOnLobbySettings()
	{
		local XBoxAddr EmptyAddr;
		local PlayerController PC;
		local ETeamIdentifier desiredTeam;
        local int desiredTeamId;
		local int voiceChannel;
		local int index, playerindex;
		local gbxDisplayList.EMissionGameType GameType;
		
		// set up the teams
		log(self $ " WargameSkirmish::TeamsAssignPlayersBasedOnLobbySettings(): Setting up teams. NumPlayers: "$NumPlayers, 'MP');
        for (PC=Level.PlayerControllerList; PC!=None; PC=PC.NextPlayerController )
		{
            if ( PC.PlayerReplicationInfo != None )
			{
				if (!PC.PlayerReplicationInfo.bOnlySpectator)
				{
					//Get the desired team and desiredTeamId
					
					// set team 
					index = class'Gameplay.gbxMPMissionList'.static.FindMapIndex(PC.Level.GetLevelFileName());
					GameType = class'Gameplay.gbxMPMissionList'.static.GetGameType(index);
					
					if ( GameType == MGT_Skirmish_DE )
						desiredTeam = ETeamIdentifier.TEAM_German;
					else
						desiredTeam = ETeamIdentifier.TEAM_US;
						
					// TODO: Remove hardcoded roles
//					desiredTeamId = PC.PlayerReplicationInfo.LobbyGetPlayerTeamRole();
					playerindex = PC.PlayerReplicationInfo.PlayerID;
					if (playerindex > 1)
					{
						playerindex = 1;
					}
					desiredTeamId = PlayerRoleChoice[playerindex];

					//Enforce the team selection.
					log("     Player = " $ PC $ ", requesting team = " $ desiredTeam $ ", teamRole = " $ desiredTeamId, 'MP');
					ChangeTeamMP(PC, desiredTeam, false, desiredTeamId);
				}
					
				// close their lobby
				PC.ClientCloseMenu(true,,true);

				if (!PC.PlayerReplicationInfo.bOnlySpectator)
				{
					//Set voice chat for in game play.
					if (NumPlayers <= 2)
					{
						//With two or less players everyone can still talk to everyone else.
						voiceChannel = VoiceChannelAllPlayers;
					}
					else
					{
						//With more than two players in the game players can only chat with their teammates.
						if (desiredTeam == ETeamIdentifier.TEAM_US)
						{
							voiceChannel = VoiceChannelUS;
						}
						else
						{
							voiceChannel = VoiceChannelGerman;
						}
					}

					PC.ServerChangeChannel(PC, EmptyAddr, 0, -VoiceChannel - 4);
				}
			}
		}

		PlayerTeam = desiredTeam;
	}
}

State MatchOver
{
	function MoveToDebriefing(PlayerController PC)
	{
		PC.ClientLateJoinToDebrefing('LateJoinToDebrefing_Skirmish');
	}
}

State MatchOver_Lobby extends MatchOver
{
	function BeginState()
	{
		local PlayerController PC;
		log("PlayerController" @self @"entering MatchOver_Lobby state", 'guilog');

		Super.BeginState();

		// move existing players
        for (PC=Level.PlayerControllerList; PC!=None; PC=PC.NextPlayerController )
		{
            if ( PC.PlayerReplicationInfo != None )
			{
				MoveToDebriefing(PC);
			}
		}
	}
	function MoveToDebriefing(PlayerController PC)
	{
		PC.ClientLateJoinToDebrefing('LateJoinToDebrefing_SkirmishLobby');
	}
}

// Returns skill values zero based (0-9)
function int GetSkillValue(int skill)
{
	//Log( " WargameSkirmish::GetSkillValue()", 'MP' );

	return iSkillSets[SKILLSET(skill)];
}

// Returns skill values zero based (0-9)
function GetSkillValues(out int skillSets[NUM_SKILLSETS])
{
	local int i;
	//Log( " WargameSkirmish::GetSkillValues()", 'MP' );

	for(i=0; i<NUM_SKILLSETS; i++)
	{
		skillSets[i] = iSkillSets[i];
	}
}

function DoIncrement( int iRand )
{
	local int i;
	
	for( i=0; i<NUM_SKILLSETS; i++ )
	{
		if ( iSkillSets[i] != MAX_SKILL_LEVEL )
		{
			if ( GameType != SGT_Defense || i != SKILLSET.SK_TACTICS )
			{
				if ( iRand == 0 )
				{
					// This is the skill we're bumping up
					Log( " WargameSkirmish::DoIncrement() Incrementing "$SKILLSET_NAMES[i]$" skill by 1.", 'MP' );
					iSkillSets[i]++;
					break;
				}
				--iRand;
			}
		}
	}
}

// For the time being, this function works by randomly adding 1 skill to one of the non-maxed out skillsets
function IncrementRandomSkillSet()
{
	local int i, iRand, iTweakableSkillSets;
	local PlayerController PC;
	Log( " WargameSkirmish::IncrementRandomSkillSet()", 'MP' );

	// Are we in defense mode?  If so,w e don't increment tactical skill because it has no use in defense gametype.
	if ( GameType == SGT_Defense )
	{
/*
		// hard mode increments all skill by one for each wave, easy mode only does one skill
		if ( Level.bDefenseDiffHard )	
		{
			Log( " WargameSkirmish::IncrementRandomSkillSet() HARD DEFENSE MODE.", 'MP' );			
			for( i=0; i<NUM_SKILLSETS; i++ )
			{
				if ( iSkillSets[i] != MAX_SKILL_LEVEL && i != SKILLSET.SK_TACTICS )
				{
					// This is the skill we're bumping up
					Log( " WargameSkirmish::IncrementRandomSkillSet() Incrementing "$SKILLSET_NAMES[i]$" skill by 1.", 'MP' );
					iSkillSets[i]++;
				}
			}
			
			// Skip the condition down below
			iTweakableSkillSets = 0;
		}
		else
		{
*/
			Log( " WargameSkirmish::IncrementRandomSkillSet() EASY DEFENSE MODE.", 'MP' );			
			// How many skillsets are *not* maxed out?
			for( i=0; i<NUM_SKILLSETS; i++ )
			{
				if ( iSkillSets[i] != MAX_SKILL_LEVEL && i != SKILLSET.SK_TACTICS )
					iTweakableSkillSets++;
			}
//		}
	}
	else
	{
		// How many skillsets are *not* maxed out?
		for( i=0; i<NUM_SKILLSETS; i++ )
		{
			if ( iSkillSets[i] < MAX_SKILL_LEVEL )
				iTweakableSkillSets++;
		}
	}

	Log( " WargameSkirmish::IncrementRandomSkillSet() iTweakableSkillSets="$iTweakableSkillSets, 'MP' );

	if ( iTweakableSkillSets > 0 )
	{
		// Randomly picking one to modify is a little weird because the array could be out of order as far as which skillsets are maxed out
		// Ex. array[0] = 8, array[1] = 10, array[2] = 8  The number returned from Rand() will be used to count through the array skipping skillsets
		// that are maxed out along the way.
		iRand = Rand( iTweakableSkillSets );

		DoIncrement( iRand );

		//Log( " WargameSkirmish::IncrementRandomSkillSet() New skill sets are: accuracy="$iSkillSets[0]$" tactics="$iSkillSets[1]$" suppression="$iSkillSets[2], 'MP' );
	}
	else
	{
		// TODO:  What's the plan when a player has reached maximum?  Select a new skill level for LevelInfo.SkillLevel and reset skillsets back to predefined values?
		//Log( " WargameSkirmish::IncrementRandomSkillSet() All skillsets have reached their maximum!", 'MP' );
	}

	Log( " WargameSkirmish::IncrementRandomSkillSet() New skill sets are: accuracy="$iSkillSets[0]$" tactics="$iSkillSets[1]$" suppression="$iSkillSets[2], 'MP' );

	PC = Level.GetLocalPlayerController();

	if ( PC != None )
	{
		PC.GameReplicationInfo.Skirmish_Skills[0] = iSkillSets[0];
		PC.GameReplicationInfo.Skirmish_Skills[1] = iSkillSets[1];
		PC.GameReplicationInfo.Skirmish_Skills[2] = iSkillSets[2];
	}

	// Notify the difficulty manager
	Level.DifficultyManager.SetDifficulty(DIFF_Easy);
}

function bool IsPawnOnSameTeamAsPlayer(Pawn p)
{
	local bool bSame;
	//Log( " WargameSkirmish::IsPawnOnSameTeamAsPlayer() p.PawnTeam="$p.PawnTeam, 'MP' );
	
	if ( p != None )
	{
		if ( p.PawnTeam == PlayerTeam )
			bSame = true;
	}

	//Log( " WargameSkirmish::IsPawnOnSameTeamAsPlayer() bSame="$bSame, 'MP' );

	return bSame;
}

function bool IsPawnOnSameTeamAsPlayerByEnum(ETeamIdentifier team)
{
	local bool bSame;
	//Log( " WargameSkirmish::IsPawnOnSameTeamAsPlayerByEnum() team="$team, 'MP' );

	if ( team == PlayerTeam )
		bSame = true;

	//Log( " WargameSkirmish::IsPawnOnSameTeamAsPlayerByEnum() bSame="$bSame, 'MP' );

	return bSame;
}

/* Rate whether player should choose this NavigationPoint as its start
default implementation is for single player game
*/
function float RatePlayerStart(NavigationPoint N, byte Team, Controller Player, int nCheckpointID)
{
    local gbxMPPlayerStart P;
    local int playerindex, desiredTeamId;

	P = gbxMPPlayerStart(N);
	if ( P != None )
	{
		if ((GameType == SGT_Defense) && P.bNotInDefense)
		{
			return 0;
		}
		if (((GameType == SGT_Objective) || (GameType == SGT_TourOfDuty)) && P.bNotInObjective)
		{
			return 0;
		}
		if ((GameType == SGT_TimeChallenge) && P.bNotInTimed)
		{
			return 0;
		}
		playerindex = Player.PlayerReplicationInfo.PlayerID;
		if (playerindex > 1)
		{
			playerindex = 1;
		}
		desiredTeamId = PlayerRoleChoice[playerindex];
		if ((desiredTeamId == 0) &&
			(P.TeamMemberID == MEMBER_One) &&
			(P.m_nCheckpointID == nCheckpointID))
		{
			// GBX:PAD: This is a hack to not make the spawn points screw up for now when running timed mode.
			if ((GameType == SGT_TimeChallenge) && P.bNotInDefense)
			{
				return 1001;
			}
			return 1000;
		}
		if ((desiredTeamId == 1) &&
			(P.TeamMemberID == MEMBER_Two) &&
			(P.m_nCheckpointID == nCheckpointID))
		{
			// GBX:PAD: This is a hack to not make the spawn points screw up for now when running timed mode.
			if ((GameType == SGT_TimeChallenge) && P.bNotInDefense)
			{
				return 1001;
			}
			return 1000;
		}
	}
	return 0;
}

function UpdateFireTeamCount()
{
	local PlayerController	PC;
	local InfantryUSA		aPawn;
	local Unit ledUnit, tempUnit;
	local int	nIdx, nIdx2;
	local int	playerindex, teamSize;
	
	iFireTeamsCurrent[0] = 0;
	iFireTeamsCurrent[1] = 0;
	
	if ( PlayerTeam == TEAM_German )
	    teamSize = GetTeam(TEAM_German).Size;
	else 
	    teamSize = GetTeam(TEAM_US).Size;
	    
    for (PC=Level.PlayerControllerList; PC!=None; PC=PC.NextPlayerController )
	{
		playerindex = PC.PlayerReplicationInfo.PlayerID;
		if (playerindex > 1)
		{
			playerindex = 1;
		}
		foreach DynamicActors( class'InfantryUSA', aPawn )
		{
			if (aPawn.Controller.IsA('PlayerController'))
			{
				continue;
			}
			if (aPawn.IsDead())
			{
				continue;
			}
			if (aPawn.SameTeamAs( PC.Pawn ))
			{
				ledUnit = gbxPlayerController(PC).GetPlayerLedUnit();
				if (ledUnit==None)
					return;

				for(nIdx = 0; nIdx < ledUnit.MAX_SUBUNITS; nIdx++)
				{
					tempUnit = ledUnit.SubUnits[ nIdx ];
					if (tempUnit == None)
					{
						continue;
					}
					if (tempUnit.NumMembers == 0)
						continue;
					for(nIdx2 = 0; nIdx2 < tempUnit.MAX_MEMBERS; nIdx2++)
					{
						if (tempUnit.Members[nIdx2] == aPawn)
						{
//							if (NumPlayers == 1)
//							{
								if (tempUnit.UnitType == UnitType_Assault)
								{
									iFireTeamsCurrent[0] = iFireTeamsCurrent[0] + 1;
								}
								else
								{
									iFireTeamsCurrent[1] = iFireTeamsCurrent[1] + 1;
								}
//							}
//							else
//							{
//								iFireTeamsCurrent[playerindex] = iFireTeamsCurrent[playerindex] + 1;
//							}
						}
					}
				}	
			}
		}
	}
}

function string GetRulesString(optional bool bContinue)
{
	local string result;
	local int    nCheckpointID;
	local GameProfile gProfile;

	result = "?SMode=" $String(int(GameType));

	if (PlayerRoleChoice[0] == UnitType_Base)
		result = result $ "?SRole=1";
	else
		result = result $ "?SRole=0";

	result = result $ "?SSkill=" $iSkillChoice;

	if (GameType == SGT_TourOfDuty)
	{
		result = result $ "?SDiff1=" $iSkillToD;

		if (bContinue)
			result = result $ "?" $BuildFireTeamString();
	}
	else
	{
		if (GameType != SGT_Defense)
		{
			result = result
				$ "?SDiff1=" $iSkillSets[SKILLSET.SK_ACCURACY]
				$ "?SDiff2=" $iSkillSets[SKILLSET.SK_TACTICS]
				$ "?SDiff3=" $iSkillSets[SKILLSET.SK_SUPPRESSION];
		}
		else
		{
			result = result
				$ "?SDiff1=0"
				$ "?SDiff2=0"
				$ "?SDiff3=0";
		}
	}
	
	nCheckpointID = Level.MissionManager.SkirmishLastSavedCheckpointID();
	if ((GameType == SGT_Objective) && (nCheckpointID > 0))
	{
		// increment the reload count
		gProfile = class'GameProfile'.Static.LoadCurrentGameProfile( Level );
		Level.MissionManager.CachedGameProfile.SkirmishIncrementCheckpointReload();
		if (gProfile != None)
		{
			Level.MissionManager.UncacheGameProfile( gProfile );
		}
		class'GameProfile'.Static.UnloadProfile( Level, gProfile, true );

		result = result $ "?Checkpoint=" $nCheckpointID;
	}

	return result;
}

function string BuildFireTeamString()
{
	local string szStr;

	if (GameType == SGT_TourOfDuty)
	{
		UpdateFireTeamCount();
		
		szStr = "ft1="$iFireTeamsCurrent[0]$"?ft2="$iFireTeamsCurrent[1];

		return szStr;
	}
	return "";
}

simulated function CharacterSetup.EMPCharacterTypes GetCharacterType( Controller aPlayer )
{
	local gbxPlayerController gbxPC;

	log( "WargameSkirmish::GetCharacterType() - aPlayer=" $ aPlayer, 'RSC' );

	gbxPC=gbxPlayerController(Level.GetLocalPlayerController());
	
	//log( "WargameSkirmish::GetCharacterType() - gbxPC=" $ gbxPC, 'RSC' );
	//log( "WargameSkirmish::GetCharacterType() - gbxPC.bUseGermanAccent=" $ gbxPC.bUseGermanAccent, 'RSC' );

	if (!(aPlayer.bIsPlayer) || gbxPC == None )
	{
		log( "WargameSkirmish::GetCharacterType() - returned SKCharUSC, gbxPC=" $ gbxPC, 'RSC' );
		return SKCharUSC;
	}
	else
	{
			if (aPlayer.PlayerReplicationInfo.TeamID == 0)
			{
				if (aPlayer.PlayerReplicationInfo.Team.TeamIndex == 1)
				{
				log( "WargameSkirmish::GetCharacterType() - returned SKHartsock", 'RSC' );
				return SKBaker;
			}
			else
			{
				if( gbxPC.bUseGermanAccent )
				{
					//log( "WargameSkirmish::GetCharacterType() - returned SKHansEG", 'RSC' );
					return SKHansDE;	// removing German Accents
					//return SKHansEG;
				}
				else
				{
					//log( "WargameSkirmish::GetCharacterType() - returned SKHansDE", 'RSC' );
					return SKHansDE;
				}
				}
			}
			else
			{
				if (aPlayer.PlayerReplicationInfo.Team.TeamIndex == 1)
				{
				log( "WargameSkirmish::GetCharacterType() - returned SKBaker", 'RSC' );
				return SKHartsock;
			}
			else
			{
				if( gbxPC.bUseGermanAccent )
				{
					//log( "WargameSkirmish::GetCharacterType() - returned SKFransEG", 'RSC' );
					return SKFransDE;	// removing German Accents
					//return SKFransEG;
				}
				else
				{
					//log( "WargameSkirmish::GetCharacterType() - returned SKFransDE", 'RSC' );
					return SKFransDE;
				}
				}
			}
	}

	log( "WargameSkirmish::GetCharacterType() - returned SKCharUSC", 'RSC' );
	return SKCharUSC;
}

function string FindNextToDMap(optional bool bGetFirstMission)
{
	local int i;
	local gbxMPMissionList.EMissionGameType GameType;

	i = class'Gameplay.gbxMPMissionList'.static.FindMapIndex(Level.GetLevelFileName());
	GameType = class'Gameplay.gbxMPMissionList'.static.GetGameType(i);

	if (bGetFirstMission)
		return GetNextToDMap( GameType != MGT_Skirmish_DE);
	else
		return GetNextToDMap( GameType != MGT_Skirmish_DE, Level.GetLevelFileName() );
}

static function string GetNextToDMap(bool bWantUS, optional string currentMap)
{
	local array<string> list;
	local string result;
	local int i;

	if (bWantUS)
		list = default.ToDMapsUS;
	else
		list = default.ToDMapsDE;

	if (currentMap == "")
	{
		result = list[0];
	}
	else
	{
		for (i=0; i<list.Length; i++)
		{
			if (currentMap ~= list[i])
				break;
		}

		i++;
		if (i < list.Length)
			result = list[i];
	}

	return result;
}

function bool CanUseCheckpoints( int nCheckpointID )
{
	return (GameType == SGT_Objective);
}

function SaveCheckpointID( int nCheckpointID )
{
	Level.MissionManager.SkirmishSaveCheckpointID( nCheckpointID );
}

function ClearCachedValues()
{
	Level.MissionManager.SkirmishClearCachedValues();
}

function bool GetCachedValue( name szValueName, out int nValue )
{
	return Level.MissionManager.SkirmishGetCachedValue( szValueName, nValue );
}

function LoadCheckpointInLevel( int nCheckpointID, optional name szPreSaveTrigger, optional name szPostSaveTrigger )
{
	local PlayerController		aPlayer, aServerPlayer;
	local gbxPlayerController	agbxPlayer;
	local NavigationPoint		startSpot;
	local int					debugcheckpoint, i, j;
	local gbxCharacterSpawner	anAIStart;
	local gbxMPPlayerStart		aPlayerStart;
	local gbxFireTeamSpawnControllerSkirmish	aTeamSpawner;
	local gbxPawn				aPawn, livePawn, deadPawn;
	local MultiplayerUnit		aUnit, aSubUnit;
	local Pickup				aMcGuffin;

	debugcheckpoint = Level.SkirmishDebugCheckpointID;
	Level.SkirmishDebugCheckpointID = nCheckpointID;
	for( aPlayer = Level.PlayerControllerList; aPlayer != None; aPlayer = aPlayer.NextPlayerController )
	{
		agbxPlayer = gbxPlayerController(aPlayer);
		if ( Viewport(aPlayer.Player) != None )
		{
			aServerPlayer = aPlayer;
		}
		if (aPlayer.PlayerReplicationInfo.bIsSpectator || (aPlayer.Pawn == None) || aPlayer.Pawn.IsDead())
		{
		    aPlayer.PlayerReplicationInfo.bOutOfLives = false;
		    aPlayer.PlayerReplicationInfo.NumLives = 1;
		    aPlayer.PlayerReplicationInfo.bIsSpectator = false;
		    aPlayer.PlayerReplicationInfo.bOnlySpectator = false;
			agbxPlayer.SkirmishEndFieldPromotion();
			CreatePlayer(aPlayer, PlayerCreationMode_FromScratch);
			aPlayer.ServerReStartPlayer();
			aPawn = gbxPawn(aPlayer.Pawn);
			if ((aUnit != None) && (aPawn != None) && (livePawn != None))
			{
				livePawn.MyUnit.RemoveSubUnit( aUnit );
				aPawn.MyUnit.AddSubUnit( aUnit );
			}
			else
			{
				deadPawn = gbxPawn(aPlayer.Pawn);
			}
			foreach DynamicActors( class'Pickup', aMcGuffin )
			{
				if (aMcGuffin.IsA('gbxMcGuffinPickup') && (aMcGuffin.Instigator == None))
				{
					aMcGuffin.SetLocation( aPawn.Location );
				}
			}
		}
		else
		{
			startSpot = FindPlayerStart(aPlayer, aPlayer.PlayerReplicationInfo.Team.TeamIndex);
			aPlayer.Pawn.SetLocation(startSpot.Location);
			aPlayer.Pawn.SetRotation(startSpot.Rotation);
			livePawn = gbxPawn(aPlayer.Pawn);
			for( i = 0; i < livePawn.MyUnit.NumSubUnits; i++ )
			{
				aSubUnit = MultiplayerUnit(livePawn.MyUnit.SubUnits[i]);
				if (aSubUnit != None)
				{
					if (!(livePawn.IsSameFireTeamType( aSubUnit )))
					{
						aUnit = aSubUnit;
					}
					for( j = 0; j < aSubUnit.NumMembers; j++ )
					{
						aPawn = aSubUnit.Members[j];
						if (aPawn != None)
						{
							aPlayerStart = gbxMPPlayerStart(startSpot);
							if (aPlayerStart != None)
							{
								foreach DynamicActors( class'gbxFireTeamSpawnControllerSkirmish', aTeamSpawner, startSpot.event )
								{
									if (aPawn.GetFireTeamType() == EUnitType.UnitType_Assault)
									{
										foreach DynamicActors( class'gbxCharacterSpawner', anAIStart, aTeamSpawner.SoloAssaultTeam )
										{
											if (anAIStart.bSpawnDisabled)
											{
												continue;
											}
											aPawn.SetLocation( anAIStart.Location );
											aPawn.SetRotation( anAIStart.Rotation );
											aPawn.SetPhysics( PHYS_Falling );
											anAIStart.bSpawnDisabled = true;
											break;
										}
									}
									else if (aPawn.GetFireTeamType() == EUnitType.UnitType_Base)
									{
										foreach DynamicActors( class'gbxCharacterSpawner', anAIStart, aTeamSpawner.SoloBaseOfFireTeam )
										{
											if (anAIStart.bSpawnDisabled)
											{
												continue;
											}
											aPawn.SetLocation( anAIStart.Location );
											aPawn.SetRotation( anAIStart.Rotation );
											aPawn.SetPhysics( PHYS_Falling );
											anAIStart.bSpawnDisabled = true;
											break;
										}
									}
								}
							}
						}
					}
				}
			}
			if ((aUnit != None) && (deadPawn != None) && (livePawn != None))
			{
				livePawn.MyUnit.RemoveSubUnit( aUnit );
				deadPawn.MyUnit.AddSubUnit( aUnit );
			}
		}
	}
	
	Level.SkirmishDebugCheckpointID = debugcheckpoint;
}

function Pawn CreatePlayer( Controller aPlayer, EPlayerCreationMode creationMode, optional Vector location, optional Rotator rotation )
{
	local	Pawn	aPawn;
	
	aPawn = Super.CreatePlayer( aPlayer, creationMode, location, rotation );
	if ((aPawn != None) && (PlayerController(aPlayer) != None))
	{
		PlayerController(aPlayer).FadePlayerScreen( 2, 2.0, false );
	}
	
	return aPawn;
}
/*
// This function is called by the game engine to determine if an Actor can be spectated upon
// when the player is in the Spectating state.
function bool CanSpectate( PlayerController Viewer, bool bOnlySpectator, actor ViewTarget )
{
	local bool rslt;
	local InfantryUSA aiGuy;
	local Controller C;

	if ( ViewTarget == None || Controller(ViewTarget) == None)
	{
		Log("WargameMultiplayer::CanSpectate ViewTarget == None!!", 'PSV');
		return false;
	}

	rslt = false;

	C = Controller(ViewTarget);
	if (C.Pawn != None)
	{
		if ( Viewer.IsSpectating() )
		{
			// Make sure the target is alive...
			if ( C.Pawn.IsDead() )
			{
				rslt = false;
			}
			else
			{
				rslt = true;
			}
		}

		// Bug 4147: Only allow players to spectate pawns on the same team
		if (Viewer.PlayerReplicationInfo.Team != None && (Viewer.PlayerReplicationInfo.Team.TeamIndex != C.Pawn.PawnTeam) )
		{
			rslt = false;
		}
	}

	return rslt;
}
*/
defaultproperties
{
    SKILLSET_NAMES[0] = "Accuracy"
	SKILLSET_NAMES[1] = "Tactics"
	SKILLSET_NAMES[2] = "Suppression"
	
	iFireTeams[0]=-1
	iFireTeams[1]=-1
 
	ScoreBoardType="gbxMP.WargameSkirmishScoreboard"

	ToDMapsUS=("SKR_US_Bunker","SKR_US_BrokenTanks","SKR_US_SniperHill","SKR_US_Railyard","SKR_US_TakingTheHill")
	ToDMapsDE=("SKR_DE_DDayDrop","SKR_DE_Hamlet","SKR_DE_Warehouse","SKR_DE_HoldingTheLine","SKR_DE_CityFighting")
}//=============================================================================
// WargameTeamGame.
//=============================================================================
class WargameTeamGame extends WargameGameInfo
	config;



var	WargameTeamInfo Teams[2];
var string BlueTeamName, RedTeamName;		// when specific pre-designed teams are specified on the URL

var 				bool	bScoreTeamKills;
var globalconfig	bool	bBalanceTeams;	// bots balance teams
var globalconfig	bool	bPlayersBalanceTeams;	// players balance teams
var bool bSpawnInTeamArea;	// players spawn in marked team playerstarts
var bool			bScoreVictimsTarget;	// Should we check a victims target for bonuses

var config int		MaxTeamSize;
var localized string NearString;

//DHW + No longer used
//var sound CaptureSound[2];
//var sound TakeLead[2];
//var sound IncreaseLead[2];
//var sound HatTrickSound;
//DHW -

// localized PlayInfo descriptions & extra info
var private localized string TGPropsDisplayText[4];

var() float ADR_Goal;
var() float ADR_Return;
var() float ADR_Control;

var texture TempSymbols[2];

function PostBeginPlay()
{
	local int i;

	if ( InitialBots > 0 )
	{
	Teams[0] = GetRedTeam(0.5 * InitialBots + 1);
	Teams[1] = GetBlueTeam(0.5 * InitialBots + 1);
	}
	else
	{
		Teams[0] = GetRedTeam(0);
		Teams[1] = GetBlueTeam(0);
	}
	for (i=0;i<2;i++)
	{
		Teams[i].TeamIndex = i;
		GameReplicationInfo.Teams[i] = Teams[i];
	}
	Super.PostBeginPlay();
}

// check if all other players are out
function bool CheckMaxLives(PlayerReplicationInfo Scorer)
{
    local Controller C;
    local PlayerReplicationInfo Living;
    local bool bNoneLeft;

    if ( MaxLives > 0 )
    {
		if ( (Scorer != None) && !Scorer.bOutOfLives )
			Living = Scorer;
        bNoneLeft = true;
        for ( C=Level.ControllerList; C!=None; C=C.NextController )
            if ( (C.PlayerReplicationInfo != None) && C.bIsPlayer
                && !C.PlayerReplicationInfo.bOutOfLives )
            {
				if ( Living == None )
					Living = C.PlayerReplicationInfo;
				else if ( (C.PlayerReplicationInfo != Living) && (C.PlayerReplicationInfo.Team != Living.Team) )
			   	{
    	        	bNoneLeft = false;
	            	break;
				}
            }
        if ( bNoneLeft )
        {
			if ( Living != None )
				EndGame(Living,"LastMan");
			else
				EndGame(Scorer,"LastMan");
			return true;
		}
    }
    return false;
}

function TeamInfo OtherTeam(TeamInfo Requester)
{
	if ( Requester == Teams[0] )
		return Teams[1];
	return Teams[0];
}

function OverrideInitialBots()
{
	InitialBots = Teams[0].OverrideInitialBots(InitialBots,Teams[1]);
}

function PreLoadNamedBot(string BotName)
{
	local int first, second;

	second = 1;
	// always imbalance teams in favor of bot team in single player
	if ( (StandalonePlayer != None ) && (StandalonePlayer.PlayerReplicationInfo.Team.TeamIndex == 1) )
	{
		first = 1;
		second = 0;
	}
	if ( 1 + Teams[first].Roster.Length < Teams[second].Roster.Length )
		Teams[first].AddNamedBot(BotName);
	else
		Teams[second].AddNamedBot(BotName);
}

function PreLoadBot()
{
	if ( Teams[0].Roster.Length < 0.5 * InitialBots + 1 )
		Teams[0].AddRandomPlayer();
	if ( Teams[1].Roster.Length < 0.5 * InitialBots + 1 )
		Teams[1].AddRandomPlayer();
}

/* create a player team, and fill from the team roster
*/
function WargameTeamInfo GetBlueTeam(int TeamBots)
{
	local class<WargameTeamInfo> RosterClass;
	local WargameTeamInfo Roster;

	if ( BlueTeamName != "" )
		RosterClass = class<WargameTeamInfo>(DynamicLoadObject(BlueTeamName,class'Class'));
	else
		RosterClass = class<WargameTeamInfo>(DynamicLoadObject(DefaultEnemyRosterClass,class'Class'));
	Roster = spawn(RosterClass);
	Roster.Initialize(TeamBots);
	return Roster;
}

function WargameTeamInfo GetRedTeam(int TeamBots)
{
	EnemyRosterName = RedTeamName;
	return Super.GetBotTeam(TeamBots);
}

// Parse options for this game...
event InitGame( string Options, out string Error )
{
	local string InOpt;
	local string RedSymbolName,BlueSymbolName;
	local texture NewSymbol;

	Super.InitGame(Options, Error);
	MaxTeamSize = Max(MaxTeamSize, 1 + MaxPlayers/2);
	InOpt = ParseOption( Options, "RedTeamAI");
	if ( InOpt != "" )
	{
		log("RedTeamAI: "$InOpt);
	}

	InOpt = ParseOption( Options, "BlueTeamAI");
	if ( InOpt != "" )
	{
		log("BlueTeamAI: "$InOpt);
	}

	// get passed in teams
	RedTeamName = ParseOption( Options, "RedTeam");
	BlueTeamName = ParseOption( Options, "BlueTeam");

	if ( RedTeamName != "" )
	{
		bCustomBots = true;
		if ( BlueTeamName == "" )
			BlueTeamName = "xGame.TeamBlueConfigured";
	}
	else if ( BlueTeamName != "" )
	{
		bCustomBots = true;
		RedTeamName = "xGame.TeamRedConfigured";
	}

	// set teamsymbols (optional)
	RedSymbolName = ParseOption( Options, "RedTeamSymbol");
	BlueSymbolName = ParseOption( Options, "BlueTeamSymbol");
	if ( RedSymbolName != "" )
	{
		NewSymbol = Texture(DynamicLoadObject(RedSymbolName,class'Texture'));
		if ( NewSymbol != None )
			TempSymbols[0] = NewSymbol;
	}
	if ( BlueSymbolName != "" )
	{
		NewSymbol = Texture(DynamicLoadObject(BlueSymbolName,class'Texture'));
		if ( NewSymbol != None )
			TempSymbols[1] = NewSymbol;
	}
	InOpt = ParseOption( Options, "FF");
	if ( InOpt != "" )
		FriendlyFireScale = float(InOpt);

	InOpt = ParseOption(Options, "BalanceTeams");
	if ( InOpt != "")
	{
		bBalanceTeams = bool(InOpt);
		bPlayersBalanceTeams = bBalanceTeams;
	}
	log("TeamGame::InitGame : bBalanceTeams"@bBalanceTeams);


}

function InitTeamSymbols()
{
	if ( (TempSymbols[0] == None) && (Teams[0].TeamSymbolName != "") )
		TempSymbols[0] = Texture(DynamicLoadObject(Teams[0].TeamSymbolName,class'Texture'));
	if ( (TempSymbols[1] == None) && (Teams[1].TeamSymbolName != "") )
		TempSymbols[1] = Texture(DynamicLoadObject(Teams[1].TeamSymbolName,class'Texture'));

	GameReplicationInfo.Teams[0].TeamIcon = TempSymbols[0];
	GameReplicationInfo.Teams[1].TeamIcon = TempSymbols[1];
	Super.InitTeamSymbols();
}

function bool CanShowPathTo(PlayerController P, int TeamNum)
{
	return true;
}

/* For TeamGame, tell teams about kills rather than each individual bot
*/
function NotifyKilled(Controller Killer, Controller Killed, Pawn KilledPawn)
{
}

function IncrementGoalsScored(PlayerReplicationInfo PRI)
{
	PRI.GoalsScored += 1;
}

function bool CheckEndGame(PlayerReplicationInfo Winner, string Reason)
{
	local Controller P;
	local PlayerController player;
    local bool bLastMan;

	if ( bOverTime )
	{
		if ( Numbots + NumPlayers == 0 )
			return true;
		bLastMan = true;
		for ( P=Level.ControllerList; P!=None; P=P.nextController )
			if ( (P.PlayerReplicationInfo != None) && !P.PlayerReplicationInfo.bOutOfLives )
			{
				bLastMan = false;
				break;
			}
		if ( bLastMan )
			return true;
	}

    bLastMan = ( Reason ~= "LastMan" );

	if ( !bLastMan && (GameRulesModifiers != None) && !GameRulesModifiers.CheckEndGame(Winner, Reason) )
		return false;

	if ( bTeamScoreRounds )
	{
		if ( Winner != None )
			Winner.Team.Score += 1;
	}
	else if ( !bLastMan && (Teams[1].Score == Teams[0].Score) )
	{
		// tie
		if ( !bOverTimeBroadcast )
		{
			StartupStage = 7;
			PlayStartupMessage();
			bOverTimeBroadcast = true;
		}
		return false;
	}
	if ( bLastMan )
		GameReplicationInfo.Winner = Winner.Team;
	else if ( Teams[1].Score > Teams[0].Score )
		GameReplicationInfo.Winner = Teams[1];
	else
		GameReplicationInfo.Winner = Teams[0];

	if ( Winner == None )
	{
		for ( P=Level.ControllerList; P!=None; P=P.nextController )
			if ( (P.PlayerReplicationInfo != None) && (P.PlayerReplicationInfo.Team == GameReplicationInfo.Winner)
				&& ((Winner == None) || (P.PlayerReplicationInfo.Score > Winner.Score)) )
			{
				Winner = P.PlayerReplicationInfo;
			}
	}

	EndTime = Level.TimeSeconds + EndTimeDelay;

	if ( Winner != None )
		EndGameFocus = Controller(Winner.Owner).Pawn;
	if ( EndGameFocus != None )
		EndGameFocus.bAlwaysRelevant = true;

	for ( P=Level.ControllerList; P!=None; P=P.nextController )
	{
		player = PlayerController(P);
		if ( Player != None )
		{
			player.ClientSetBehindView(true);
			if ( EndGameFocus != None )
            {
				Player.ClientSetViewTarget(EndGameFocus);
                Player.SetViewTarget(EndGameFocus);
            }
			player.ClientGameEnded();
		}
		P.GameHasEnded();
	}
	return true;
}

//-------------------------------------------------------------------------------------
// Level gameplay modification


function bool CanSpectate( PlayerController Viewer, bool bOnlySpectator, actor ViewTarget )
{
	if ( ViewTarget == None )
		return false;
	if ( bOnlySpectator )
	{
		if ( Controller(ViewTarget) != None )
			return ( (Controller(ViewTarget).PlayerReplicationInfo != None)
				&& !Controller(ViewTarget).PlayerReplicationInfo.bOnlySpectator );
		return true;
	}
	if ( Controller(ViewTarget) != None )
		return ( (Controller(ViewTarget).PlayerReplicationInfo != None)
				&& !Controller(ViewTarget).PlayerReplicationInfo.bOnlySpectator
				&& (Controller(ViewTarget).PlayerReplicationInfo.Team == Viewer.PlayerReplicationInfo.Team) );
	return ( (Pawn(ViewTarget) != None) && Pawn(ViewTarget).IsPlayerPawn()
		&& (Pawn(ViewTarget).PlayerReplicationInfo.Team == Viewer.PlayerReplicationInfo.Team) );
}

//------------------------------------------------------------------------------
// Game Querying.
function GetServerDetails( out ServerResponseLine ServerState )
{
	local int i;

	Super.GetServerDetails( ServerState );

	i = ServerState.ServerInfo.Length;

	// balance teams
	ServerState.ServerInfo.Length = i+1;
	ServerState.ServerInfo[i].Key = "balanceteams";
	if( bBalanceTeams )
		ServerState.ServerInfo[i++].Value = "True";
	else
		ServerState.ServerInfo[i++].Value = "False";

	// playersbalanceteams
	ServerState.ServerInfo.Length = i+1;
	ServerState.ServerInfo[i].Key = "playersbalanceteams";
	if( bPlayersBalanceTeams )
		ServerState.ServerInfo[i++].Value = "True";
	else
		ServerState.ServerInfo[i++].Value = "False";

	// friendly fire
	ServerState.ServerInfo.Length = i+1;
	ServerState.ServerInfo[i].Key = "friendlyfire";
	ServerState.ServerInfo[i++].Value = string(int(FriendlyFireScale*100))$"%";
}


//------------------------------------------------------------------------------
function WargameTeamInfo GetBotTeam(optional int TeamBots)
{
	local int first, second;

	if ( (Level.NetMode == NM_Standalone) || !bBalanceTeams )
	{
	    if ( Teams[0].AllBotsSpawned() )
	    {
			bBalanceTeams = false;
		    if ( !Teams[1].AllBotsSpawned() )
			    return Teams[1];
	    }
	    else if ( Teams[1].AllBotsSpawned() )
	    {
			bBalanceTeams = false;
		    return Teams[0];
		}
	}

	second = 1;

	// always imbalance teams in favor of bot team in single player
	if ( (StandalonePlayer != None ) && (StandalonePlayer.PlayerReplicationInfo.Team.TeamIndex == 1) )
	{
		first = 1;
		second = 0;
	}
	if ( Teams[first].Size < Teams[second].Size )
		return Teams[first];
	else
		return Teams[second];
}

function WargameTeamInfo FindTeamFor(Controller C)
{
	if ( Teams[0].BelongsOnTeam(C.Pawn.Class) )
		return Teams[0];
	if ( Teams[1].BelongsOnTeam(C.Pawn.Class) )
		return Teams[1];
	return GetBotTeam();
}

/* Return a picked team number if none was specified
*/
function byte PickTeam(byte num, Controller C)
{
	local WargameTeamInfo SmallTeam, BigTeam, NewTeam;
	local Controller B;
	local bool bForceSmall;

	SmallTeam = Teams[0];
	BigTeam = Teams[1];

	if ( SmallTeam.Size > BigTeam.Size )
	{
		SmallTeam = Teams[1];
		BigTeam = Teams[0];
	}

	if ( num < 2 )
		NewTeam = Teams[num];

	if ( bPlayersBalanceTeams && (SmallTeam.Size < BigTeam.Size) && ((Level.NetMode != NM_Standalone) || (PlayerController(C) == None)) )
	{
		bForceSmall = true;
		// if any bots on big team, no need to go on small team
		for ( B=Level.ControllerList; B!=None; B=B.NextController )
		{
			if ( (B.PlayerReplicationInfo != None) && B.PlayerReplicationInfo.bBot && (B.PlayerReplicationInfo.Team == BigTeam) )
			{
				bForceSmall = false;
				break;
			}
		}
		if ( bForceSmall )
		NewTeam = SmallTeam;
	}

	if ( (NewTeam == None) || (NewTeam.Size >= MaxTeamSize) )
		NewTeam = SmallTeam;

	return NewTeam.TeamIndex;
}

/* ChangeTeam()
*/
function bool ChangeTeam(Controller Other, int num, bool bNewTeam)
{
	local WargameTeamInfo NewTeam;

	if ( bMustJoinBeforeStart && GameReplicationInfo.bMatchHasBegun )
		return false;	// only allow team changes before match starts

	if ( Other.IsA('PlayerController') && Other.PlayerReplicationInfo.bOnlySpectator )
	{
		Other.PlayerReplicationInfo.Team = None;
		return true;
	}

	NewTeam = Teams[PickTeam(num,Other)];

	if ( NewTeam.Size >= MaxTeamSize )
		return false;	// no room on either team

	// check if already on this team
	if ( Other.PlayerReplicationInfo.Team == NewTeam )
		return false;

	Other.StartSpot = None;

	if ( Other.PlayerReplicationInfo.Team != None )
		Other.PlayerReplicationInfo.Team.RemoveFromTeam(Other);

	if ( NewTeam.AddToTeam(Other) )
	{
		BroadcastLocalizedMessage( GameMessageClass, 3, Other.PlayerReplicationInfo, None, NewTeam );

		if ( bNewTeam && PlayerController(Other)!=None )
			GameEvent("TeamChange",""$num,Other.PlayerReplicationInfo);
	}
	return true;
}

/* Rate whether player should choose this NavigationPoint as its start
*/
function float RatePlayerStart(NavigationPoint N, byte Team, Controller Player, int nCheckpointID)
{
	local PlayerStart P;

	P = PlayerStart(N);
	if ( P == None )
		return -10000000;
	if ( bSpawnInTeamArea && (Team != P.TeamNumber) )
		return -9000000;

	return Super.RatePlayerStart(N,Team,Player,nCheckpointID);
}

/* CheckScore()
see if this score means the game ends
*/
function CheckScore(PlayerReplicationInfo Scorer)
{
	if ( CheckMaxLives(Scorer) )
		return;

    if ( (GameRulesModifiers != None) && GameRulesModifiers.CheckScore(Scorer) )
		return;

    if (  !bOverTime && (GoalScore == 0) )
		return;
    if ( (Scorer != None) && (Scorer.Team != None) && (Scorer.Team.Score >= GoalScore) )
		EndGame(Scorer,"teamscorelimit");

    if ( (Scorer != None) && bOverTime )
		EndGame(Scorer,"timelimit");
}

function bool CriticalPlayer(Controller Other)
{
	if ( (GameRulesModifiers != None) && (GameRulesModifiers.CriticalPlayer(Other)) )
		return true;
	if ( Other.PlayerReplicationInfo.HasFlag != None )
		return true;

	return false;
}

// ==========================================================================
// FindVictimsTarget - Tries to determine who the victim was aiming at
// ==========================================================================

function Pawn FindVictimsTarget(Controller Other)
{

	local Vector Start,X,Y,Z;
	local float Dist,Aim;
	local Actor Target;

	if (Other==None || Other.Pawn==None || Other.Pawn.Weapon==None)	// If they have no weapon, they can't be targetting someone
		return None;

	GetAxes(Other.Pawn.GetViewRotation(),X,Y,Z);
	Start = Other.Pawn.Location + Other.Pawn.CalcDrawOffset(Other.Pawn.Weapon);
	Aim = 0.97;
	Target = Other.PickTarget(aim,dist,X,Start,4000.f); //amb

	return Pawn(Target);

}

function ScoreKill(Controller Killer, Controller Other)
{
	local Pawn Target;

	if ( GameRulesModifiers != None )
		GameRulesModifiers.ScoreKill(Killer, Other);

	if ( (Killer == None) || (Killer == Other) || !Other.bIsPlayer || !Killer.bIsPlayer
		|| (Killer.PlayerReplicationInfo.Team != Other.PlayerReplicationInfo.Team) )
	{
		if ( (Killer!=None) && (Killer.PlayerReplicationInfo.Team != Other.PlayerReplicationInfo.Team) )
		{
			// Kill Bonuses work as follows (in additional to the default 1 point
			//	+1 Point for killing an enemy targetting an important player on your team
			//	+2 Points for killing an enemy important player

			if ( CriticalPlayer(Other) )
			{
				Killer.PlayerReplicationInfo.Score+= 1;
				ScoreEvent(Killer.PlayerReplicationInfo,1,"critical_frag");
			}

			if (bScoreVictimsTarget)
			{
				Target = FindVictimsTarget(Other);
				if ( (Target!=None) && (Target.PlayerReplicationInfo!=None) &&
				       (Target.PlayerReplicationInfo.Team == Killer.PlayerReplicationInfo.Team) && CriticalPlayer(Other) )
				{
					Killer.PlayerReplicationInfo.Score+=1;
					ScoreEvent(Killer.PlayerReplicationInfo,1,"team_protect_frag");
				}
			}

		}
		Super.ScoreKill(Killer, Other);
	}

	if ( !bScoreTeamKills )
	{
		if ( Other.bIsPlayer && (Killer != None) && Killer.bIsPlayer && (Killer != Other)
			&& (Killer.PlayerReplicationInfo.Team == Other.PlayerReplicationInfo.Team) )
		{
			Killer.PlayerReplicationInfo.Score -= 1;
			ScoreEvent(Killer.PlayerReplicationInfo, -1, "team_frag");
		}
		if ( MaxLives > 0 )
			CheckScore(Killer.PlayerReplicationInfo);
		return;
	}
	if ( Other.bIsPlayer )
	{
		if ( (Killer == None) || (Killer == Other) )
		{
			Other.PlayerReplicationInfo.Team.Score -= 1;
			TeamScoreEvent(Killer.PlayerReplicationInfo.Team.TeamIndex, 1, "team_frag");
		}
		else if ( Killer.PlayerReplicationInfo.Team != Other.PlayerReplicationInfo.Team )
		{
			Killer.PlayerReplicationInfo.Team.Score += 1;
			TeamScoreEvent(Killer.PlayerReplicationInfo.Team.TeamIndex, 1, "tdm_frag");
		}
		else if ( FriendlyFireScale > 0 )
		{
			Killer.PlayerReplicationInfo.Score -= 1;
			Killer.PlayerReplicationInfo.Team.Score -= 1;
			TeamScoreEvent(Killer.PlayerReplicationInfo.Team.TeamIndex, 1, "team_frag");
		}
	}

	// check score again to see if team won
    if ( (Killer != None) && bScoreTeamKills )
		CheckScore(Killer.PlayerReplicationInfo);
}

function int ReduceDamage( int Damage, pawn injured, pawn instigatedBy, vector HitLocation, out vector Momentum, class<DamageType> DamageType )
{
	//local TeamInfo InjuredTeam, InstigatorTeam;

	if ( instigatedBy == None )
		return Super.ReduceDamage( Damage,injured,instigatedBy,HitLocation,Momentum,DamageType );

	if ( instigatedBy != injured )
	{
		if ( !injured.IsHumanControlled() && (injured.Controller != None)
				&& (injured.PlayerReplicationInfo != None) && (injured.PlayerReplicationInfo.HasFlag != None) )
			injured.Controller.SendMessage(None, 'OTHER', injured.Controller.GetMessageIndex('INJURED'), 15, 'TEAM');
	}
	return Super.ReduceDamage( Damage,injured,instigatedBy,HitLocation,Momentum,DamageType );
}

function bool SameTeam(Controller a, Controller b)
{
    if(( a == None ) || ( b == None ))
        return( false );

    return (a.PlayerReplicationInfo.Team.TeamIndex == b.PlayerReplicationInfo.Team.TeamIndex);
}

function bool TooManyBots(Controller botToRemove)
{
	if ( (botToRemove.PlayerReplicationInfo != None)
		&& (botToRemove.PlayerReplicationInfo.Team != None) )
	{
		if ( botToRemove.PlayerReplicationInfo.Team == Teams[0] )
		{
			if ( Teams[0].Size < Teams[1].Size )
				return false;
		}
		else if ( Teams[1].Size < Teams[0].Size )
			return false;
	}
    return Super.TooManyBots(botToRemove);
}

function PlayEndOfMatchMessage()
{
	//DHW + No longer used
	//local controller C;

 //   if ( ((Teams[0].Score == 0) || (Teams[1].Score == 0))
	//	&& (Teams[0].Score + Teams[1].Score >= 3) )
	//{
	//	for ( C = Level.ControllerList; C != None; C = C.NextController )
	//	{
	//		if ( C.IsA('PlayerController') )
	//		{
	//			if ( Teams[0].Score > Teams[1].Score )
	//			{
	//				if ( (C.PlayerReplicationInfo.Team == Teams[0]) || C.PlayerReplicationInfo.bOnlySpectator )
	//					PlayerController(C).PlayAnnouncement(AltEndGameSound[0],1,true);
	//				else
	//					PlayerController(C).PlayAnnouncement(AltEndGameSound[1],1,true);
	//			}
	//			else
	//			{
	//				if ( (C.PlayerReplicationInfo.Team == Teams[1]) || C.PlayerReplicationInfo.bOnlySpectator )
	//					PlayerController(C).PlayAnnouncement(AltEndGameSound[0],1,true);
	//				else
	//					PlayerController(C).PlayAnnouncement(AltEndGameSound[1],1,true);
	//			}
	//		}
	//	}
	//}
 //   else
 //   {
	//	for ( C = Level.ControllerList; C != None; C = C.NextController )
	//	{
	//		if ( C.IsA('PlayerController') )
	//		{
	//			if (Teams[0].Score > Teams[1].Score)
	//				PlayerController(C).PlayAnnouncement(EndGameSound[0],1,true);
	//			else
	//				PlayerController(C).PlayAnnouncement(EndGameSound[1],1,true);
	//		}
	//	}
	//}
	//DHW -
}

static function string FindTeamDesignation(GameReplicationInfo GRI, actor A)
{
	if ( (GRI == None) || (GRI.Teams[0].HomeBase == None) || (GRI.Teams[1].HomeBase == None) )
		return "";

	if (vsize(A.location - GRI.Teams[0].HomeBase.Location) < vsize(A.location - GRI.Teams[1].HomeBase.Location))
		return GRI.Teams[0].GetHumanReadableName()$" ";
	else
		return GRI.Teams[1].GetHumanReadableName()$" ";
}

static function string ParseMessageString(Mutator BaseMutator, Controller Who, String Message)
{
	local string OutMsg;
	local string cmd;
	local int pos,i;

	OutMsg = "";
	pos = InStr(Message,"%");
	while (pos>-1)
	{
		if (pos>0)
		{
		  OutMsg = OutMsg$Left(Message,pos);
		  Message = Mid(Message,pos);
		  pos = 0;
	    }

		i = len(Message);
		cmd = mid(Message,pos,2);
		if (i-2 > 0)
			Message = right(Message,i-2);
		else
			Message = "";

		// FIXME_MERGE OutMsg = OutMsg$ParseChatPercVar(BaseMutator, Who,Cmd);
		pos = InStr(Message,"%");
	}

	if (Message!="")
		OutMsg=OutMsg$Message;

	return OutMsg;
}

function FindNewObjectives(GameObjective DisabledObjective)
{
}

//DHW + No longer used
//function AnnounceScore(int ScoringTeam)
//{
//	local Controller C;
//	local sound ScoreSound;
//	local int OtherTeam;
//
//	if ( ScoringTeam == 1 )
//		OtherTeam = 0;
//	else
//		OtherTeam = 1;
//
//	if ( Teams[ScoringTeam].Score == Teams[OtherTeam].Score + 1 )
//		ScoreSound = TakeLead[ScoringTeam];
//	else if ( Teams[ScoringTeam].Score == Teams[OtherTeam].Score + 2 )
//		ScoreSound = IncreaseLead[ScoringTeam];
//	else
//		ScoreSound = CaptureSound[ScoringTeam];
//
//	for ( C=Level.ControllerList; C!=None; C=C.NextController )
//	{
//		if ( C.IsA('PlayerController') )
//			PlayerController(C).PlayAnnouncement(ScoreSound,1,true);
//	}
//}
//DHW -

event PostLogin( PlayerController NewPlayer )
{
	Super.PostLogin( NewPlayer );
	if ( NewPlayer.PlayerReplicationInfo.Team != None )
		GameEvent("TeamChange",""$NewPlayer.PlayerReplicationInfo.Team.TeamIndex,NewPlayer.PlayerReplicationInfo);
}

defaultproperties
{
    GoalScore=60
	bPlayersBalanceTeams=true
    bWeaponStay=true
    bScoreTeamKills=true
    bBalanceTeams=true
    bMustJoinBeforeStart=false
    MaxTeamSize=16
    bCanChangeSkin=False
    bTeamGame=True
    BeaconName="Team"
    GameName="Team Deathmatch"
    NetWait=2
	MaxLives=0
    NumRounds=5
    SinglePlayerWait=2
    EndMessageWait=3

    TGPropsDisplayText(0)="Bots Balance Teams"
    TGPropsDisplayText(1)="Players Balance Teams"
    TGPropsDisplayText(2)="Max Team Size"
    TGPropsDisplayText(3)="Friendly Fire Scale"

//    EndGameSound[0]=Sound'AnnouncerMain.red_team_is_the_winner'
//    EndGameSound[1]=Sound'AnnouncerMain.blue_team_is_the_winner'

//    CaptureSound(0)=Sound'AnnouncerMain.Red_Team_Scores'
//    CaptureSound(1)=Sound'AnnouncerMain.Blue_Team_Scores'
//    IncreaseLead(0)=Sound'AnnouncerMain.Red_Team_increases_their_lead'
//    IncreaseLead(1)=Sound'AnnouncerMain.Blue_Team_increases_their_lead'
//    TakeLead(0)=Sound'AnnouncerMain.Red_Team_takes_the_lead'
//    TakeLead(1)=Sound'AnnouncerMain.Blue_Team_takes_the_lead'
//	  HatTrickSound=sound'AnnouncerMain.HatTrick'
    ADR_Goal=25.0
    ADR_Return=5.0
    ADR_Control=2.0

	ScoreBoardType="gbxGameplay.WargameTeamScoreboard"
	NearString="Near the"
}
//=============================================================================
// WargameTeamInfo.
// includes list of bots on team for multiplayer games
//
//=============================================================================

class WargameTeamInfo extends TeamInfo
	placeable;



var() WargameRosterEntry DefaultRosterEntry;
var() export editinline array<WargameRosterEntry> Roster;
var() class<gbxPawn> AllowedTeamMembers[32];
var() byte TeamAlliance;
var int DesiredTeamSize;
var Color HudTeamColor;
var string TeamSymbolName;
var class<TeamInfo> TeamToGetNameFrom;

var array<string> RosterNames;  // promoted from Team/DM rosters

replication
{
	reliable if (bNetDirty && Role == ROLE_Authority)
		TeamToGetNameFrom;
}

/* Reset()
reset actor to initial state - used when restarting level without reloading.
*/
function Reset()
{
	Super.Reset();
	if ( !WargameMPGameInfo(Level.Game).bTeamScoreRounds )
		Score = 0;
}

function int OverrideInitialBots(int N, WargameTeamInfo T)
{
	return N;
}

function bool AllBotsSpawned()
{
	return false;
}

function Initialize(int TeamBots);

simulated function class<Pawn> NextLoadOut(class<Pawn> CurrentLoadout)
{
	local int i;
	local class<Pawn> Result;

	Result = AllowedTeamMembers[0];

	for ( i=0; i<ArrayCount(AllowedTeamMembers) - 1; i++ )
	{
		if ( AllowedTeamMembers[i] == CurrentLoadout )
		{
			if ( AllowedTeamMembers[i+1] != None )
				Result = AllowedTeamMembers[i+1];
			break;
		}
		else if ( AllowedTeamMembers[i] == None )
			break;
	}

	return Result;
}

function bool NeedsBotMoreThan(WargameTeamInfo T)
{
	return ( (DesiredTeamSize - Size) > (T.DesiredTeamSize - T.Size) );
}

function WargameRosterEntry ChooseBotClass(optional string botName)
{
    if (botName == "")
        return GetNextBot();

    return GetNamedBot(botName);
}

function WargameRosterEntry GetRandomPlayer();

function bool AlreadyExistsEntry(string CharacterName, bool bNoRecursion)
{
	return false;
}

function AddRandomPlayer()
{
	local int j;

	j = Roster.Length;
	Roster.Length = Roster.Length + 1;
	Roster[j] = GetRandomPlayer();
	Roster[j].PrecacheRosterFor(self);
}

function AddNamedBot(string BotName)
{
	local int j;

	j = Roster.Length;
	Roster.Length = Roster.Length + 1;
	Roster[j] = GetNamedBot(BotName);
	Roster[j].PrecacheRosterFor(self);
}

function WargameRosterEntry GetNextBot()
{
	local int i;

	for ( i=0; i<Roster.Length; i++ )
		if ( !Roster[i].bTaken )
		{
			Roster[i].bTaken = true;
			return Roster[i];
		}
	i = Roster.Length;
	Roster.Length = Roster.Length + 1;
	Roster[i] = GetRandomPlayer();
	Roster[i].bTaken = true;
	return Roster[i];
}

function WargameRosterEntry GetNamedBot(string botName)
{
    return GetNextBot();
}

function bool AddToTeam( Controller Other, optional int desiredTeamId )
{
	local bool bResult;

	bResult = Super.AddToTeam(Other, desiredTeamId);

	//SDJ 03/11/2004: Ignore this for now.
	//if ( bResult && (Other.PawnClass != None) && !BelongsOnTeam(Other.PawnClass) )
	//	Other.PawnClass = DefaultPlayerClass;

	return bResult;
}

/* BelongsOnTeam()
returns true if PawnClass is allowed to be on this team
*/
function bool BelongsOnTeam(class<Pawn> PawnClass)
{
	local int i;

	for ( i=0; i<ArrayCount(AllowedTeamMembers); i++ )
		if ( PawnClass == AllowedTeamMembers[i] )
			return true;

	return false;
}

simulated function string GetHumanReadableName()
{
	if ( TeamToGetNameFrom != None)
		return TeamToGetNameFrom.default.TeamName;
	else
		return Super.GetHumanReadableName();
}

defaultproperties
{
	HudTeamColor=(R=255,G=255,B=255,A=255)
	DesiredTeamSize=8
}
class WargameTeamScoreboard extends WargameScoreboard;

//#exec OBJ LOAD FILE=..\textures\T_WarfareToRemove.utx

// DS-BEGIN/END wouldn't compile without this. 
//#exec Texture Import File=..\UPreview\Textures\UTechLogo.tga Name=ULogo Flags=2  COMPRESS=DXT1 //fixme temp placeholder

var Material TeamBoxMaterial[2];
var Material FlagIcon, ScoreboardU;
var Color TeamColors[2];
var Material ScoreBack;

simulated function UpdatePrecacheMaterials()
{
    Level.AddPrecacheMaterial(TeamBoxMaterial[0]);
    Level.AddPrecacheMaterial(TeamBoxMaterial[1]);
    UpdatePrecacheFonts();
}

simulated event UpdateScoreBoard(Canvas Canvas, float ScaleX, float ScaleY, optional bool bSimplified)
{
	local PlayerReplicationInfo PRI, OwnerPRI;
	local int i, FontReduction,HeaderOffsetY,HeadFoot,PlayerBoxSizeY, BoxSpaceY;
	local float XL,YL, IconSize, ScoreBackScale, MaxScaling, MessageFoot;
	local int BluePlayerCount, RedPlayerCount, RedOwnerOffset, BlueOwnerOffset, MaxPlayerCount;
	local PlayerReplicationInfo RedPRI[MAXPLAYERS], BluePRI[MaxPlayers];
	local font MainFont;

	OwnerPRI = PlayerController(Owner).PlayerReplicationInfo;
	RedOwnerOffset = -1;
	BlueOwnerOffset = -1;
    for (i=0; i<GRI.PRIArray.Length; i++)
	{
		PRI = GRI.PRIArray[i];
		if ( (PRI.Team != None) && (!PRI.bIsSpectator || PRI.bWaitingPlayer) )
		{
			if ( PRI.Team.TeamIndex == 0 )
			{
				if ( RedPlayerCount < MAXPLAYERS )
				{
					RedPRI[RedPlayerCount] = PRI;
					if ( PRI == OwnerPRI )
						RedOwnerOffset = RedPlayerCount;
					RedPlayerCount++;
				}
			}
			else if ( BluePlayerCount < MAXPLAYERS )
			{
				BluePRI[BluePlayerCount] = PRI;
				if ( PRI == OwnerPRI )
					BlueOwnerOffset = BluePlayerCount;
				BluePlayerCount++;
			}
		}
	}
	MaxPlayerCount = Max(RedPlayerCount,BluePlayerCount);
	IconSize = FMax(2 * YL, 128 * Canvas.ClipX/1024);

	// Select best font size and box size to fit as many players as possible on screen
	Canvas.Font = Font'Engine.DefaultFont';
	Canvas.StrLen("Test", XL, YL);
	BoxSpaceY = 0.25 * YL;
	if ( HaveHalfFont(Canvas, FontReduction) )
		PlayerBoxSizeY = 2.125 * YL;
	else
		PlayerBoxSizeY = 1.75 * YL;
	HeadFoot = 4*YL + IconSize;
	MessageFoot = 1.5 * HeadFoot;
	if ( MaxPlayerCount > (Canvas.ClipY - 1.5 * HeadFoot)/(PlayerBoxSizeY + BoxSpaceY) )
	{
		BoxSpaceY = 0.125 * YL;
		if ( MaxPlayerCount > (Canvas.ClipY - 1.5 * HeadFoot)/(PlayerBoxSizeY + BoxSpaceY) )
		{
			if ( MaxPlayerCount > (Canvas.ClipY - 1.5 * HeadFoot)/(PlayerBoxSizeY + BoxSpaceY) )
			{
				FontReduction++;
				Canvas.Font = GetSmallerFontFor(Canvas,FontReduction);
				Canvas.StrLen("Test", XL, YL);
				BoxSpaceY = 0.125 * YL;
				if ( HaveHalfFont(Canvas, FontReduction) )
					PlayerBoxSizeY = 2.125 * YL;
				else
					PlayerBoxSizeY = 1.75 * YL;
				HeadFoot = 4*YL + IconSize;
				if ( MaxPlayerCount > (Canvas.ClipY - 1.5 * HeadFoot)/(PlayerBoxSizeY + BoxSpaceY) )
				{
					FontReduction++;
					Canvas.Font = GetSmallerFontFor(Canvas,FontReduction);
					Canvas.StrLen("Test", XL, YL);
					BoxSpaceY = 0.125 * YL;
					if ( HaveHalfFont(Canvas, FontReduction) )
						PlayerBoxSizeY = 2.125 * YL;
					else
						PlayerBoxSizeY = 1.75 * YL;
					HeadFoot = 4*YL + IconSize;
					if ( (Canvas.ClipY >= 600) && (MaxPlayerCount > (Canvas.ClipY - HeadFoot)/(PlayerBoxSizeY + BoxSpaceY)) )
					{
						FontReduction++;
						Canvas.Font = GetSmallerFontFor(Canvas,FontReduction);
						Canvas.StrLen("Test", XL, YL);
						BoxSpaceY = 0.125 * YL;
						if ( HaveHalfFont(Canvas, FontReduction) )
							PlayerBoxSizeY = 2.125 * YL;
						else
							PlayerBoxSizeY = 1.75 * YL;
						HeadFoot = 4*YL + IconSize;
						if ( MaxPlayerCount > (Canvas.ClipY - HeadFoot)/(PlayerBoxSizeY + BoxSpaceY) )
						{
							FontReduction++;
							Canvas.Font = GetSmallerFontFor(Canvas,FontReduction);
							Canvas.StrLen("Test", XL, YL);
							BoxSpaceY = 0.125 * YL;
							if ( HaveHalfFont(Canvas, FontReduction) )
								PlayerBoxSizeY = 2.125 * YL;
							else
								PlayerBoxSizeY = 1.75 * YL;
							HeadFoot = 4*YL + IconSize;
						}
					}
				}
			}
		}
	}

	MaxPlayerCount = Min(MaxPlayerCount, 1+(Canvas.ClipY - HeadFoot)/(PlayerBoxSizeY + BoxSpaceY) );
	if ( FontReduction > 2 )
		MaxScaling = 3;
	else
		MaxScaling = 2.125;
	PlayerBoxSizeY = FClamp((1+(Canvas.ClipY - 0.67 * MessageFoot))/MaxPlayerCount - BoxSpaceY, PlayerBoxSizeY, MaxScaling * YL);
	bDisplayMessages = (MaxPlayerCount < (Canvas.ClipY - MessageFoot)/(PlayerBoxSizeY + BoxSpaceY));
	RedPlayerCount = Min(RedPlayerCount,MaxPlayerCount);
	BluePlayerCount = Min(BluePlayerCount,MaxPlayerCount);
	if ( RedOwnerOffset >= RedPlayerCount )
		RedPlayerCount -= 1;
	if ( BlueOwnerOffset >= BluePlayerCount )
		BluePlayerCount -= 1;
	HeaderOffsetY = 1.5*YL + IconSize;

	// draw center U
	if ( Canvas.ClipX >= 512 )
	{
		Canvas.DrawColor = 0.75 * class'Canvas'.static.MakeColor(255,255,255);
		ScoreBackScale = Canvas.ClipX/1024;
		Canvas.SetPos(0.5 * Canvas.ClipX - 128 * ScoreBackScale, HeaderOffsetY - 128 * ScoreBackScale);
		Canvas.DrawTile( ScoreboardU, 256*ScoreBackScale, 128*ScoreBackScale, 0, 0, 256, 128);
	}

	// draw title
	Canvas.Style = ERenderStyle.STY_Normal;
	DrawTitle(Canvas,HeaderOffsetY,(MaxPlayerCount+1)*(PlayerBoxSizeY + BoxSpaceY));

	// draw red team
	MainFont = Canvas.Font;
	for (i=0; i<32; i++ )
		PRIArray[i] = RedPRI[i];
	DrawTeam(0,RedPlayerCount,RedOwnerOffset,Canvas, FontReduction,BoxSpaceY,PlayerBoxSizeY,HeaderOffsetY);

	// draw blue team
	Canvas.Font = MainFont;
	for (i=0; i<32; i++ )
		PRIArray[i] = BluePRI[i];
	DrawTeam(1,BluePlayerCount,BlueOwnerOffset,Canvas, FontReduction,BoxSpaceY,PlayerBoxSizeY,HeaderOffsetY);

	if ( Level.NetMode != NM_Standalone )
		DrawMatchID(Canvas,FontReduction);
}

function DrawTeam(int TeamNum, int PlayerCount, int OwnerOffset, Canvas Canvas, int FontReduction, int BoxSpaceY, int PlayerBoxSizeY, int HeaderOffsetY)
{
	local int i, OwnerPos, NetXPos, NameXPos, BoxTextOffsetY, ScoreXPos, ScoreYPos, BoxXPos, BoxWidth, LineCount,NameY;
	local float XL,YL,IconScale,ScoreBackScale,ScoreYL;
	local string PlayerName[MAXPLAYERS];
	local font MainFont;
	local bool bHaveHalfFont;
	local int SymbolUSize, SymbolVSize;
	local color WhiteColor;

	BoxWidth = 0.47 * Canvas.ClipX;
	BoxXPos = 0.5 * (0.5 * Canvas.ClipX - BoxWidth);
	BoxWidth = 0.5 * Canvas.ClipX - 2*BoxXPos;
	BoxXPos = BoxXPos + TeamNum * 0.5 * Canvas.ClipX;
	NameXPos = BoxXPos + 0.05 * BoxWidth;
	ScoreXPos = BoxXPos + 0.6 * BoxWidth;
	NetXPos = BoxXPos + 0.72 * BoxWidth;
	bHaveHalfFont = HaveHalfFont(Canvas, FontReduction);

	// draw background boxes
	Canvas.Style = ERenderStyle.STY_Alpha;
	WhiteColor = class'Canvas'.Static.MakeColor(255,255,255);
	Canvas.DrawColor = WhiteColor;
	for ( i=0; i<PlayerCount; i++ )
	{
		Canvas.SetPos(BoxXPos, HeaderOffsetY + (PlayerBoxSizeY + BoxSpaceY)*i);
		Canvas.DrawTileStretched( TeamBoxMaterial[TeamNum], BoxWidth, PlayerBoxSizeY);
	}
	Canvas.Style = ERenderStyle.STY_Translucent;

	// draw team header
	Canvas.DrawColor = 0.75 * WhiteColor;
	IconScale = Canvas.ClipX/4096;
	ScoreBackScale = Canvas.ClipX/1024;
	ScoreYPos = HeaderOffsetY - 128 * ScoreBackScale;
	Canvas.SetPos((0.25 + 0.5*TeamNum) * Canvas.ClipX - 128 * ScoreBackScale, ScoreYPos);
	Canvas.DrawTile( ScoreBack, 256*ScoreBackScale, 128*ScoreBackScale, 0, 0, 256, 128);

	Canvas.Style = ERenderStyle.STY_Normal;
	Canvas.DrawColor = TeamColors[TeamNum];
	SymbolUSize = 256;
	SymbolVSize = 256;

	ScoreYPos = ScoreYPos + 64 * ScoreBackScale - 0.5 * SymbolVSize * IconScale;
	Canvas.SetPos((0.25 + 0.5*TeamNum) * Canvas.ClipX - SymbolUSize * IconScale, ScoreYPos);
	if ( GRI.Teams[TeamNum].TeamIcon != None )
		Canvas.DrawTile(GRI.Teams[TeamNum].TeamIcon, 256*IconScale, 256*IconScale,0,0,256,256);
	MainFont = Canvas.Font;
	Canvas.Font = HUDClass.static.LargerFontThan(MainFont);
	Canvas.StrLen("TEST",XL,ScoreYL);
	if ( ScoreYPos == 0 )
		ScoreYPos = HeaderOffsetY - ScoreYL;
	else
		ScoreYPos = ScoreYPos + 0.5 * SymbolVSize * IconScale - 0.5 * ScoreYL;
	Canvas.SetPos((0.25 + 0.5*TeamNum) * Canvas.ClipX + 4*IconScale,ScoreYPos);
	Canvas.DrawText(int(GRI.Teams[TeamNum].Score));
	Canvas.Font = MainFont;
	Canvas.DrawColor = WhiteColor;

	IconScale = Canvas.ClipX/1024;
	// draw player names
	for ( i=0; i<PlayerCount; i++ )
	{
		playername[i] = PRIArray[i].PlayerName;
		Canvas.StrLen(playername[i], XL, YL);
		if ( XL > 0.9 * (ScoreXPos - NameXPos) )
			playername[i] = left(playername[i], 0.9 * (ScoreXPos-NameXPos)/XL * len(PlayerName[i]));
	}
	if ( OwnerOffset >= PlayerCount )
	{
		playername[OwnerOffset] = PRIArray[OwnerOffset].PlayerName;
		Canvas.StrLen(playername[OwnerOffset], XL, YL);
		if ( XL > 0.9 * (ScoreXPos - NameXPos) )
			playername[OwnerOffset] = left(playername[OwnerOffset], 0.9 * (ScoreXPos-NameXPos)/XL * len(PlayerName[OwnerOffset]));
	}

	if ( Canvas.ClipX < 512 )
		NameY = 0.5 * YL;
	else if ( !bHaveHalfFont )
		NameY = 0.125 * YL;
	Canvas.Style = ERenderStyle.STY_Normal;
	Canvas.DrawColor = WhiteColor;
	Canvas.SetPos(0.5 * Canvas.ClipX, HeaderOffsetY + 4);
	BoxTextOffsetY = HeaderOffsetY + 0.5 * PlayerBoxSizeY - 0.5 * YL;
	for ( i=0; i<PlayerCount; i++ )
		if ( i != OwnerOffset )
		{
			Canvas.SetPos(NameXPos, (PlayerBoxSizeY + BoxSpaceY)*i + BoxTextOffsetY - 0.5 * YL + NameY);
			Canvas.DrawText(playername[i],true);
		}

	// draw scores
	Canvas.DrawColor = WhiteColor;
	for ( i=0; i<PlayerCount; i++ )
		if ( i != OwnerOffset )
		{
			Canvas.SetPos(ScoreXPos, (PlayerBoxSizeY + BoxSpaceY)*i + BoxTextOffsetY);
			if ( PRIArray[i].bOutOfLives )
				Canvas.DrawText(OutText,true);
			else
				Canvas.DrawText(int(PRIArray[i].Score),true);
		}

	// draw owner line
	if ( OwnerOffset >= 0 )
	{
		if ( OwnerOffset >= PlayerCount )
		{
			OwnerPos = (PlayerBoxSizeY + BoxSpaceY)*PlayerCount + BoxTextOffsetY;
			// draw extra box
			Canvas.Style = ERenderStyle.STY_Alpha;
			Canvas.SetPos(BoxXPos, HeaderOffsetY + (PlayerBoxSizeY + BoxSpaceY)*PlayerCount);
			Canvas.DrawTileStretched( TeamBoxMaterial[TeamNum], BoxWidth, PlayerBoxSizeY);
			Canvas.Style = ERenderStyle.STY_Normal;
			if ( PRIArray[OwnerOffset].bHasFlag )
			{
				Canvas.DrawColor = WhiteColor;
				Canvas.SetPos(NameXPos - 48*IconScale, OwnerPos - 16*IconScale);
				Canvas.DrawTile( FlagIcon, 64*IconScale, 32*IconScale, 0, 0, 256, 128);
			}
		}
		else
			OwnerPos = (PlayerBoxSizeY + BoxSpaceY)*OwnerOffset + BoxTextOffsetY;

		Canvas.DrawColor = class'Canvas'.static.MakeColor(255,255,0);
		Canvas.SetPos(NameXPos, OwnerPos-0.5*YL+NameY);
		Canvas.DrawText(playername[OwnerOffset],true);
		Canvas.SetPos(ScoreXPos, OwnerPos);
		if ( PRIArray[OwnerOffset].bOutOfLives )
			Canvas.DrawText(OutText,true);
		else
			Canvas.DrawText(int(PRIArray[OwnerOffset].Score),true);
	}

	// draw flag icons
	Canvas.DrawColor = WhiteColor;
	for ( i=0; i<PlayerCount; i++ )
		if ( PRIArray[i].bHasFlag )
		{
			Canvas.SetPos(NameXPos - 48*IconScale, (PlayerBoxSizeY + BoxSpaceY)*i + BoxTextOffsetY - 16*IconScale);
			Canvas.DrawTile( FlagIcon, 64*IconScale, 32*IconScale, 0, 0, 256, 128);
		}

	// draw location and/or orders
	if ( (OwnerOffset >= 0) && (Canvas.ClipX >= 512) )
	{
		BoxTextOffsetY = HeaderOffsetY + 0.5*PlayerBoxSizeY + NameY;
		Canvas.DrawColor = class'Canvas'.static.MakeColor(0,255,255);
		if ( FontReduction > 3 )
			bHaveHalfFont = false;
		Canvas.Font = Font'Engine.DefaultFont';
		Canvas.StrLen("Test", XL, YL);
		for ( i=0; i<PlayerCount; i++ )
		{
			LineCount = 0;
			if ( bHaveHalfFont || !PRIArray[i].bBot )
			{
				Canvas.SetPos(NameXPos, (PlayerBoxSizeY + BoxSpaceY)*i + BoxTextOffsetY + LineCount*YL);
				Canvas.DrawText(PRIArray[i].GetLocationName(),true);
			}
		}
		if ( OwnerOffset >= PlayerCount )
		{
			Canvas.SetPos(NameXPos, (PlayerBoxSizeY + BoxSpaceY)*i + BoxTextOffsetY);
			Canvas.DrawText(PRIArray[OwnerOffset].GetLocationName(),true);
		}
	}

	if ( Level.NetMode == NM_Standalone )
		return;
	Canvas.Font = MainFont;
	Canvas.StrLen("Test",XL,YL);
	BoxTextOffsetY = HeaderOffsetY + 0.5 * PlayerBoxSizeY - 0.5 * YL;
	DrawNetInfo(Canvas,FontReduction,HeaderOffsetY,PlayerBoxSizeY,BoxSpaceY,BoxTextOffsetY,OwnerOffset,PlayerCount,NetXPos);
}

defaultproperties
{
//	ScoreBack=Material'MenuEffects.ScoreIcon_FB'
//	ScoreBoardU=Material'ULogo'
//	FlagIcon=Material'ULogo'
//	TeamBoxMaterial(0)=Material'T_WarfareToRemove.InterfaceContent.ScoreBoxC'
//	TeamBoxMaterial(1)=Material'T_WarfareToRemove.InterfaceContent.ScoreBoxB'
	TeamColors(0)=(R=255,G=0,B=0,A=255)
	TeamColors(1)=(R=0,G=0,B=255,A=255)
	FragLimit="SCORE LIMIT:"
}
class WeaponDamageType extends DamageType
	abstract;



var() class<Weapon>         WeaponClass;

static function string GetWeaponClass()
{
	return string(Default.WeaponClass);
}


