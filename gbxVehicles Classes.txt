class AnimNotify_TankGrenadedZoomIn extends AnimNotify_Scripted;


event Notify( Actor Owner )
{
	if (Owner.IsA('gbxPawn'))
	{
		gbxPawn( Owner ).TankGrenadeAnimZoomIn();
	}
}
class AnimNotify_TankPlayerMountPause extends AnimNotify_Scripted;


event Notify( Actor Owner )
{
	local TankStuart MyTankStuart;
	local TankSherman MyTankSherman;

	if (Owner.IsA('gbxPawn'))
	{
		if (Owner.Base.IsA('gbxSVehicle'))
		{
			if (Owner.Base.IsA('TankStuart'))
			{
				MyTankStuart = TankStuart(Owner.Base);

				if ((MyTankStuart.TurretYaw != 0) && (MyTankStuart.Controller != None))
				{
					Owner.PauseAnim();  // pause the animation until the turret rotates to 0 degrees

					if (MyTankStuart.WeapUSStuart30calMachineGun != None)
					{
						MyTankStuart.WeapUSStuart30calMachineGun.bCameraNeedsToPause = true;
					}
				}
			}
			else if (Owner.Base.IsA('TankSherman'))
			{
				MyTankSherman = TankSherman(Owner.Base);

				if ((MyTankSherman.TurretYaw != 0) && (MyTankSherman.Controller != None))
				{
					Owner.PauseAnim();  // pause the animation until the turret rotates to 0 degrees

					if (MyTankSherman.WeapUSSherman50calMachineGun != None)
					{
						MyTankSherman.WeapUSSherman50calMachineGun.bCameraNeedsToPause = true;
					}
				}
			}
		}
	}
}
class gbxInspectorTankGermany extends gbxInspectorPawn;

var float TankPortraitOffset;
var float TankPortraitOffsetNoCommander;
var float myNameScaleNoCommander;

simulated static function DrawGBXHud( canvas Canvas, object drawObject, gbxInspectorMan mgr, float offsetX, float offsetY, int nPass, float alpha, float timeSinceShow )
{
	local gbxPawn drawPawn;
	local Tank drawTank;
	local float tankOffset;

	if( drawObject.IsA('Unit') )
	{
		drawTank = Tank( Unit(drawObject).Members[0] );
	}
	else
	{
		drawTank = Tank(drawObject);
	}

	if( drawTank == None )
		return;

	drawPawn = drawTank.CommanderPawn;

	//Log( "********* Tank Inspector Status *********", 'SJP' );
	//Log( "Tank           = "$drawTank, 'SJP' );
	//Log( "Tank Portrait  = "$drawTank.Portrait, 'SJP' );
	//Log( "Tank Name      = "$drawTank.CharacterName, 'SJP' );
	//Log( "Cmdr           = "$drawPawn, 'SJP' );
	//Log( "Cmdr Portrait  = "$drawPawn.Portrait, 'SJP' );
	//Log( "Cmdr Name      = "$drawPawn.CharacterName, 'SJP' );

	// Don't draw this panel if there is no portrait
	if( drawTank == None || drawTank.Portrait == None )
	{
		return;
	}

	tankOffset = default.TankPortraitOffset;

	if (nPass == 0)
	{
		DrawStylizedBackground(Canvas, mgr.myHud, offsetX, offsetY, alpha);

		// First draw the tank commander

		if( drawPawn != None && drawPawn.Portrait != None )
		{
			// DrawPawnHealthBar( Canvas, drawPawn, mgr.myHud, offsetX + 4, offsetY + 2, alpha, 62, 20, true );

			Canvas.SetDrawColor(255,255,255,255 * alpha);
			Canvas.SetPos((offsetX+8)*mgr.myHud.ScaleX, (offsetY-25)*mgr.myHud.ScaleY);
			Canvas.DrawTile(drawPawn.Portrait, 64*mgr.myHud.ScaleX, 64*mgr.myHud.ScaleY, 0, 0, 64, 64);
		}
		else
		{
			tankOffset = default.TankPortraitOffsetNoCommander;
		}

		// Now draw the tank
		Canvas.SetPos( ( offsetX + tankOffset ) * mgr.myHud.ScaleX, ( offsetY - 17 ) * mgr.myHud.ScaleY );

		Canvas.SetDrawColor(255,255,255,255 * alpha);
		Canvas.DrawTile( drawTank.Portrait, 64 * mgr.myHud.ScaleX, 64 * mgr.myHud.ScaleY, 0, 0, 64, 64 );
	}
	else if (nPass == 1 && mgr.myHud.Level.NetMode == NM_Standalone )
	{
		Canvas.DrawColor = mgr.myHud.WhiteColor;
		Canvas.DrawColor.A = 255 * alpha;
		Canvas.Font = mgr.myHud.WargameFont;

		DrawGenericText(Canvas, mgr.myHud, drawTank.CharacterName,
						offsetX+6, offsetY+Default.myHeight-24, Default.myNameScaleNoCommander * 0.85f,, TJ_LEFT_TOP);
	}
}

defaultproperties
{
	TankPortraitOffset=58.0
	TankPortraitOffsetNoCommander=30.0
	myNameScale=0.5
	myNameScaleNoCommander=0.9
}class gbxInspectorTankUS extends gbxInspectorPawn;

var float DeathSymbolAppearDuration;
var float DeathSymbolScaleMax;
var float DeathSymbolScaleMin;
var float TankPortraitOffset;
var float TankPortraitOffsetNoCommander;
var float myNameScaleNoCommander;

simulated static function DrawGBXHud( canvas Canvas, object drawObject, gbxInspectorMan mgr, float offsetX, float offsetY, int nPass, float alpha, float timeSinceShow )
{
	local gbxPawn drawPawn;
	local Tank drawTank;
	local float deathSymbolScale, deathSymbolAlpha, appearTimeProportion, tankOffset, tankAppearTimeProportion, tankDeathSymbolScale, tankDeathSymbolAlpha;


	if( drawObject.IsA('Unit') )
	{
		drawTank = Tank( Unit(drawObject).Members[0] );
	}
	else
	{
		drawTank = Tank(drawObject);
	}

	if( drawTank == None )
		return;

	drawPawn = drawTank.CommanderPawn;

	// Don't draw this panel if there is no portrait
	if( drawTank == None || drawTank.Portrait == None )
	{
		return;
	}

	tankOffset = default.TankPortraitOffset;

	if (nPass == 0)
	{
		DrawStylizedBackground(Canvas, mgr.myHud, offsetX, offsetY, alpha);

		// is there a tank commander pawn for this tank?...
		if( drawPawn != None && drawPawn.Portrait != None )
		{
			DrawPawnHealthBar( Canvas, drawPawn, mgr.myHud, offsetX + 4, offsetY + 2, alpha, 62, 20, true );

			Canvas.SetDrawColor(255,255,255,255 * alpha);
			Canvas.SetPos((offsetX+26)*mgr.myHud.ScaleX, (offsetY-25)*mgr.myHud.ScaleY);
			Canvas.DrawTile(drawPawn.Portrait, 64*mgr.myHud.ScaleX, 64*mgr.myHud.ScaleY, 0, 0, 64, 64);

			// Damage overlay for commander
			DrawPortraitDamageOverlay( Canvas, drawPawn, mgr.myHud, offsetX+26, offsetY-25, alpha );

			DrawPawnHealthBar( Canvas, drawTank, mgr.myHud, offsetX + tankOffset + 60, offsetY + 2, alpha, 62, 20, true );

			// Set the offset for the tank icon
			Canvas.SetDrawColor(255,255,255,255 * alpha);
			Canvas.SetPos( ( offsetX + tankOffset ) * mgr.myHud.ScaleX, ( offsetY - 17 ) * mgr.myHud.ScaleY );
			Canvas.DrawTile( drawTank.Portrait, 64 * mgr.myHud.ScaleX, 64 * mgr.myHud.ScaleY, 0, 0, 64, 64 );

			if( drawTank.Health <= 0)  // draw 'X' just over the tank?
			{
				// Animated offset/scale/alpha death symbol

				if( timeSinceShow > 0 )
				{
					appearTimeProportion = FClamp( timeSinceShow / default.DeathSymbolAppearDuration, 0.0, 1.0 );
					deathSymbolScale = default.DeathSymbolScaleMax - appearTimeProportion * ( default.DeathSymbolScaleMax - default.DeathSymbolScaleMin );
					deathSymbolAlpha = appearTimeProportion;

					if( deathSymbolAlpha * alpha > 1.0 / 255.0 )
					{
						DrawDeathSymbol( Canvas, drawPawn, mgr.myHud, offsetX + tankOffset, offsetY - 17, deathSymbolScale, deathSymbolAlpha * alpha );
					}
				}
			}

			if ( drawPawn.Health <= 0 )  // draw 'X' just over tank commander?...
			{
				// Animated offset/scale/alpha death symbol

				if( timeSinceShow > 0 )
				{
					tankAppearTimeProportion = FClamp( timeSinceShow / default.DeathSymbolAppearDuration, 0.0, 1.0 );
					tankDeathSymbolScale = default.DeathSymbolScaleMax - tankAppearTimeProportion * ( default.DeathSymbolScaleMax - default.DeathSymbolScaleMin );
					tankDeathSymbolAlpha = tankAppearTimeProportion;

					if( tankDeathSymbolAlpha * alpha > 1.0 / 255.0 )
					{
						DrawDeathSymbol( Canvas, drawTank, mgr.myHud, offsetX+26, offsetY-25, tankDeathSymbolScale, tankDeathSymbolAlpha * alpha );
					}
				}
			}
		}
		else  // just draw the tank by itself...
		{
			DrawPawnHealthBar( Canvas, drawTank, mgr.myHud, offsetX + 4, offsetY + 2, alpha, 62, 20, true );
			
			// Set the offset for the tank icon
			Canvas.SetPos((offsetX+30)*mgr.myHud.ScaleX, (offsetY-17)*mgr.myHud.ScaleY);

			Canvas.SetDrawColor(255,255,255,255 * alpha);
			Canvas.DrawTile( drawTank.Portrait, 64 * mgr.myHud.ScaleX, 64 * mgr.myHud.ScaleY, 0, 0, 64, 64 );

			if( drawTank.Health <= 0 )
			{
				// Animated offset/scale/alpha death symbol

				if( timeSinceShow > 0 )
				{
					tankAppearTimeProportion = FClamp( timeSinceShow / default.DeathSymbolAppearDuration, 0.0, 1.0 );
					tankDeathSymbolScale = default.DeathSymbolScaleMax - tankAppearTimeProportion * ( default.DeathSymbolScaleMax - default.DeathSymbolScaleMin );
					tankDeathSymbolAlpha = tankAppearTimeProportion;

					if( tankDeathSymbolAlpha * alpha > 1.0 / 255.0 )
					{
						DrawDeathSymbol( Canvas, drawTank, mgr.myHud, offsetX+30, offsetY-25, tankDeathSymbolScale, tankDeathSymbolAlpha * alpha );
					}
				}
			}
		}
	}
	else if (nPass == 1 && mgr.myHud.Level.NetMode == NM_Standalone )
	{
		Canvas.DrawColor = mgr.myHud.WhiteColor;
		Canvas.DrawColor.A = 255 * alpha;
		Canvas.Font = mgr.myHud.WargameFont;

		if( drawPawn != None && drawPawn.CharacterName != "" )
		{
			DrawGenericText(Canvas, mgr.myHud, drawPawn.CharacterName,
							offsetX+30, offsetY+Default.myHeight-24, Default.myNameScaleNoCommander,, TJ_LEFT_TOP);
		}
		else
		{
			DrawGenericText(Canvas, mgr.myHud, drawTank.CharacterName,
							offsetX+30, offsetY+Default.myHeight-24, Default.myNameScaleNoCommander,, TJ_LEFT_TOP);
		}
	}
}

defaultproperties
{
	DeathSymbolAppearDuration=0.75
	DeathSymbolScaleMax=1.5
	DeathSymbolScaleMin=1.0
	TankPortraitOffset=64.0
	TankPortraitOffsetNoCommander=30.0
	myNameScale=0.5
	myNameScaleNoCommander=0.9
	myWidth=165
}class gbxJeep extends gbxWheeledCraft;


defaultproperties
{
	Mesh=Mesh'k_vehicle_de.de_opel_blitz'
	VehiclePositionString="in an Opel Blitz"
	VehicleNameString="OpelBlitz"
	bReplicateAnimations=True

	Health=300
	CollisionHeight=+40.0
	CollisionRadius=+100.0
	DriverDamageMult=0.80
//	bHasAltFire=false
//	bSeparateTurretFocus=true
	RanOverDamageType=class'Crushed'
	CrushedDamageType=class'Crushed'

	DrawScale=1.0
	DrawScale3D=(X=1.0,Y=1.0,Z=1.0)

	FPCamPos=(X=15,Y=0,Z=25)
	TPCamLookat=(X=0,Y=0,Z=0)
	TPCamWorldOffset=(X=0,Y=0,Z=100)
//	TPCamDistance=375
	TPCamDistance=800

	bDoStuntInfo=true
	DaredevilThreshInAirSpin=180.0
	DaredevilThreshInAirPitch=300.0
	DaredevilThreshInAirRoll=300.0
	DaredevilThreshInAirTime=1.7
	DaredevilThreshInAirDistance=21.0

	AirTurnTorque=35.0
	AirPitchTorque=55.0
	AirPitchDamping=35.0
	AirRollTorque=35.0
	AirRollDamping=35.0

	bDrawDriverInTP=True
	bDrawMeshInFP=True
	bHasHandbrake=true
	bAllowBigWheels=true

//	DrivePos=(X=2.0,Y=0.0,Z=38.0)
	DrivePos=(X=2.0,Y=0.0,Z=120.0)

	MaxViewYaw=16000
	MaxViewPitch=16000

//	IdleSound=sound'ONSVehicleSounds-S.RV.RVEng01'
//	StartUpSound=sound'ONSVehicleSounds-S.RV.RVStart01'
//	ShutDownSound=sound'ONSVehicleSounds-S.RV.RVStop01'
	EngineRPMSoundRange=9000
	SoundVolume=180
	IdleRPM=500
	RevMeterScale=4000

//	SteerBoneName="SteeringWheel"
//	SteerBoneAxis=AXIS_Z
//	SteerBoneMaxAngle=90

	EntryPosition=(X=0,Y=0,Z=-200)
//	EntryRadius=300.0
	EntryRadius=500.0

	ExitPositions(0)=(X=0,Y=-400,Z=100)
	ExitPositions(1)=(X=0,Y=400,Z=100)
	ExitPositions(2)=(X=0,Y=-400,Z=-100)
	ExitPositions(3)=(X=0,Y=400,Z=-100)

	WheelPenScale=1.2
	WheelPenOffset=0.01
	WheelSoftness=0.025
	WheelRestitution=0.1
	WheelAdhesion=0.0
	WheelLongFrictionFunc=(Points=((InVal=0,OutVal=0.0),(InVal=100.0,OutVal=1.0),(InVal=200.0,OutVal=0.9),(InVal=10000000000.0,OutVal=0.9)))
	WheelLongFrictionScale=1.1
	WheelLatFrictionScale=1.35
	WheelLongSlip=0.001
	WheelLatSlipFunc=(Points=((InVal=0.0,OutVal=0.0),(InVal=30.0,OutVal=0.009),(InVal=45.0,OutVal=0.00),(InVal=10000000000.0,OutVal=0.00)))
	WheelHandbrakeSlip=0.01
	WheelHandbrakeFriction=0.1
	WheelSuspensionTravel=15.0
	WheelSuspensionOffset=0.0
	WheelSuspensionMaxRenderTravel=15.0
	TurnDamping=35

	HandbrakeThresh=200
	FTScale=0.03
	ChassisTorqueScale=0.4

	MinBrakeFriction=4.0
	MaxBrakeTorque=20.0
	MaxSteerAngleCurve=(Points=((InVal=0,OutVal=25.0),(InVal=1500.0,OutVal=11.0),(InVal=1000000000.0,OutVal=11.0)))
	SteerSpeed=160
	StopThreshold=100
	TorqueCurve=(Points=((InVal=0,OutVal=9.0),(InVal=200,OutVal=10.0),(InVal=1500,OutVal=11.0),(InVal=2800,OutVal=0.0)))
	EngineBrakeFactor=0.0001
	EngineBrakeRPMScale=0.1
	EngineInertia=0.1
	WheelInertia=0.1

	TransRatio=0.15
	GearRatios[0]=-0.5
	GearRatios[1]=0.4
	GearRatios[2]=0.65
	GearRatios[3]=0.85
	GearRatios[4]=1.1
	ChangeUpPoint=2000
	ChangeDownPoint=1000
	LSDFactor=1.0

	VehicleMass=3.5

    Begin Object Class=KarmaParamsRBFull Name=KParams0
		KStartEnabled=True
		KFriction=0.5
		KLinearDamping=0.05
		KAngularDamping=0.05
		KImpactThreshold=700
		bKNonSphericalInertia=True
        bHighDetailOnly=False
        bClientOnly=False
		bKDoubleTickRate=True
		KInertiaTensor(0)=1.0
		KInertiaTensor(1)=0.0
		KInertiaTensor(2)=0.0
		KInertiaTensor(3)=3.0
		KInertiaTensor(4)=0.0
		KInertiaTensor(5)=3.0
		KCOMOffset=(X=-0.25,Y=0.0,Z=-1.0)
		bDestroyOnWorldPenetrate=True
		bDoSafetime=True
        Name="KParams0"
    End Object
    KParams=KarmaParams'KParams0'

	Begin Object Class=SVehicleWheel Name=RRWheel
		BoneName="tire_rear_right"
		BoneRollAxis=AXIS_Z
		bInvertRollDirection=True
		BoneSteerAxis=AXIS_Z
		BoneOffset=(X=0.0,Y=0.0,Z=0.0)
		WheelRadius=47
		bPoweredWheel=True
		bHandbrakeWheel=True
		SteerType=VST_Fixed
		SupportBoneAxis=AXIS_X
//		SupportBoneName="chassis"
	End Object
	Wheels(0)=SVehicleWheel'RRWheel'

	Begin Object Class=SVehicleWheel Name=LRWheel
		BoneName="tire_rear_left"
		BoneRollAxis=AXIS_Z
		bInvertRollDirection=True
		BoneSteerAxis=AXIS_Z
		BoneOffset=(X=0.0,Y=0.0,Z=0.0)
		WheelRadius=47
		bPoweredWheel=True
		bHandbrakeWheel=True
		SteerType=VST_Fixed
		SupportBoneAxis=AXIS_X
//		SupportBoneName="chassis"
	End Object
	Wheels(1)=SVehicleWheel'LRWheel'

	Begin Object Class=SVehicleWheel Name=RFWheel
		BoneName="tire_front_right"
		BoneRollAxis=AXIS_Z
		bInvertRollDirection=True
		BoneSteerAxis=AXIS_Y
		BoneOffset=(X=0.0,Y=0.0,Z=0.0)
		WheelRadius=47
		bPoweredWheel=True
		SteerType=VST_Steered
		SupportBoneAxis=AXIS_X
//		SupportBoneName="chassis"
	End Object
	Wheels(2)=SVehicleWheel'RFWheel'

	Begin Object Class=SVehicleWheel Name=LFWheel
		BoneName="tire_front_left"
		BoneRollAxis=AXIS_Z
		bInvertRollDirection=True
		BoneSteerAxis=AXIS_Y
		BoneOffset=(X=0.0,Y=0.0,Z=0.0)
		WheelRadius=47
		bPoweredWheel=True
		SteerType=VST_Steered
		SupportBoneAxis=AXIS_X
//		SupportBoneName="chassis"
	End Object
	Wheels(3)=SVehicleWheel'LFWheel'

	GroundSpeed=940

	MaxDesireability=0.4
	ObjectiveGetOutDist=1500.0
}
class gbxJeepSteeringWheel extends StaticMeshActor;

// This staticmesh package is no longer with us.
//#exec OBJ LOAD FILE=..\staticmesh\S_Mattv.usx



defaultproperties
{
	// This staticmesh package is no longer with us.
	//StaticMesh=StaticMesh'S_Mattv.jeep_steeringwheel'
	bHidden=False
	bStatic=False
	bStaticLighting=False
    bHardAttach=True
	bShadowCast=False
	bCollideActors=False
	bBlockActors=False
	bBlockPlayers=False
	bBlockKarma=False
}

class Halftrack extends Tank;


var WeapDEHalftrackMG42_ MyMG;
var vector WeapMGOffset;

var InfantryGermany MyGunner;
var() bool	bHasAttachedGunner;
var() name GunnerTag;
var() bool bGunnerDismountsWhenFlanked;

var InfantryGermany MyPassengerOne;
var() bool	bHasAttachedPassengerOne;
var() name		PassengerOneTag;
var vector		PassengerOneOffset;
var InfantryGermany MyPassengerTwo;
var() bool	bHasAttachedPassengerTwo;
var() name		PassengerTwoTag;
var vector		PassengerTwoOffset;

var() bool			bIgnoreSuppression;
var() bool			bUseShotProtection;
var() float			Zone1OuterRadius,				// Distances defining three 'kill zones' for the turret.
					Zone2OuterRadius,				// (Zone 1 == closest to turret; Zone 3 == farthest).
					Zone3OuterRadius;
var() float			NoShotProtectionDist;			// Distance outside of which attackers cannot hit the gunner.
var() float			ShotProtectionCosTheta;
var() float			EnemyTooCloseDist;

var	bool	bDismountPassengers;
var bool	bGunnerDismounted;
var float	GunnerDismountTime;
var bool	bPassengerOneDismounted;
var float	PassengerOneDismountTime;
var bool	bPassengerTwoDismounted;
var float	PassengerTwoDismountTime;


const HT_NINEPOINT_CHANNEL0 = 0;
const HT_NINEPOINT_CHANNEL1 = 1;
const HT_NINEPOINT_CHANNEL2 = 2;


simulated function PreBeginPlay()
{
	Mesh = Mesh( DynamicLoadObject( "k_vehicle_de.de_halftrack", class'Mesh' ) );

	super.PreBeginPlay();
}

simulated function SetupTracks()
{
	// this property in the wheels doesn't seem to get set properly from the defaultproperties section.  WHY???
	Wheels[0].bInvertRollDirection=false;
	Wheels[1].bInvertRollDirection=false;

	Skins.Length = 5;
	Skins[0] = GbxShaderMaterial( DynamicLoadObject( "t_military_de.Vehicle.de_halftrack_gbx", class'GbxShaderMaterial' ) );
	Skins[1] = GbxShaderMaterial( DynamicLoadObject( "t_military_de.Vehicle.de_halftrack_alpha_rev_gbx", class'GbxShaderMaterial' ) );
	Skins[2] = Texture( DynamicLoadObject( "t_military_de.Weapon.Mg42", class'Texture' ) );
	Skins[3] = GbxShaderMaterial( DynamicLoadObject( "t_military_de.Vehicle.de_halftrack_track_left", class'GbxShaderMaterial' ) );
	Skins[4] = GbxShaderMaterial( DynamicLoadObject( "t_military_de.Vehicle.de_halftrack_track_right", class'GbxShaderMaterial' ) );

	LeftTrackTextureIndex = 3;
	RightTrackTextureIndex = 4;

	super.SetupTracks();
}

simulated function BeginPlay()
{
	SetPhysics(PHYS_Karma);

	PlayAnim('Idle');

	SetTimer(0.1, true);
}

simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();

	if ( EngineIdleSoundName != "" )
		EngineIdleSound = Sound( DynamicLoadObject( EngineIdleSoundName, class'Sound' ) );
	if ( DrivingSoundName != "" )
		DrivingSound = Sound( DynamicLoadObject( DrivingSoundName, class'Sound' ) );
}

simulated function Destroyed()
{
	if (MyGunner != None)
	{
		MyGunner.Destroy();
		MyGunner = None;
	}
	if (MyPassengerOne != None)
	{
		MyPassengerOne.Destroy();
		MyPassengerOne = None;
	}
	if (MyPassengerTwo != None)
	{
		MyPassengerTwo.Destroy();
		MyPassengerTwo = None;
	}
}

function bool TryToSetLocation(InfantryGermany SomePawn, vector SomeLoc)
{
	local int count;  // number of attempts to set the location
	local bool result;

	count = 0;

	result = SomePawn.SetLocation(SomeLoc);

	while ((!result) && (count < 20))
	{
		// keep pushing the pawn up until they don't collide!!!
		count++;
		SomeLoc = SomeLoc + vect(0,0,1);
		result = SomePawn.SetLocation(SomeLoc);
	}

	return result;
}

function Timer()
{
	local vector X, Y, Z;
	local vector PawnLoc;
	local class<gbxAIController> MindClass;
	local gbxAIController NewMind;
	local MeshAnimation	aMeshAnim;
	local int Num_Passengers, Num_Dead_Passengers;

	GetAxes(Rotation, X, Y, Z);

	if ((MyGunner == None) && (GunnerTag != '') && !bHasAttachedGunner)
	{
		ForEach DynamicActors(class'InfantryGermany', MyGunner, GunnerTag)
			break;

		if (MyGunner != None)
		{
			bHasAttachedGunner = true;

			AttachGunner();

			MyGunner.bUseCustomDeathAnim = true;
			MyGunner.CustomDeathAnims.Length = 1;
			MyGunner.CustomDeathAnims[0] = 'de_halftrack_death_mg42';

			MyGunner.bDontDropWeapon = true;  // dropped weapons interfere with the Karma vehicle, don't drop them
			MyGunner.bIsHalftrackRider = true;
		}
	}

	if ((MyPassengerOne == None) && (PassengerOneTag != '') && !bHasAttachedPassengerOne)
	{
		ForEach DynamicActors(class'InfantryGermany', MyPassengerOne, PassengerOneTag)
			break;

		if (MyPassengerOne != None)
		{
			bHasAttachedPassengerOne = true;

			MyPassengerOne.bDontDropWeapon = true;  // dropped weapons interfere with the Karma vehicle, don't drop them
			MyPassengerOne.bIsHalftrackRider = true;

			MyPassengerOne.SetCollisionSize( MyPassengerOne.Default.CollisionRadius * 0.8, MyPassengerOne.Default.CollisionHeight );	

			PawnLoc = Location + PassengerOneOffset.X*X + PassengerOneOffset.Y*Y + PassengerOneOffset.Z*Z;

			TryToSetLocation(MyPassengerOne, PawnLoc);
			MyPassengerOne.SetRotation( Rotation );

			MyPassengerOne.SetBase(None);
			MyPassengerOne.bHardAttach = true;
			MyPassengerOne.SetBase(self);

			// switch to a MindHalftrackPassenger so that the Pawns won't try to navigate anywhere (or run from grenades)
			MindClass = class<gbxAIController>( DynamicLoadObject( "gbxAI.MindHalftrackPassenger", class'Class' ) );

			NewMind = gbxAIController( MyPassengerOne.Controller ).ChangeMind( MindClass );

			NewMind.SetVehicle( self );

			MyPassengerOne.bUseCustomDeathAnim = true;
			MyPassengerOne.CustomDeathAnims.Length = 2;
			MyPassengerOne.CustomDeathAnims[0] = 'de_halftrack_death_1';
			MyPassengerOne.CustomDeathAnims[1] = 'de_halftrack_death_2';

			aMeshAnim = MeshAnimation( DynamicLoadObject( "a_hold_misc.Halftrack", class'MeshAnimation' ) );
			if ( aMeshAnim != None )
			{
				if (MyPassengerOne.LinkSkelAnim( aMeshAnim ))
				{
					MyPassengerOne.MeshAnim = aMeshAnim;
					MyPassengerOne.CurMeshAnimName = "a_hold_misc.Halftrack";
				}
				MyPassengerOne.bInitializeAnimation = false;
			}
		}
	}

	if ((MyPassengerTwo == None) && (PassengerTwoTag != '') && !bHasAttachedPassengerTwo)
	{
		ForEach DynamicActors(class'InfantryGermany', MyPassengerTwo, PassengerTwoTag)
			break;

		if (MyPassengerTwo != None)
		{
			bHasAttachedPassengerTwo = true;

			MyPassengerTwo.bDontDropWeapon = true;  // dropped weapons interfere with the Karma vehicle, don't drop them
			MyPassengerTwo.bIsHalftrackRider = true;

			MyPassengerTwo.SetCollisionSize( MyPassengerTwo.Default.CollisionRadius * 0.8, MyPassengerTwo.Default.CollisionHeight );	

			PawnLoc = Location + PassengerTwoOffset.X*X + PassengerTwoOffset.Y*Y + PassengerTwoOffset.Z*Z;

			TryToSetLocation(MyPassengerTwo, PawnLoc);
			MyPassengerTwo.SetRotation( Rotation );

			MyPassengerTwo.SetBase(None);
			MyPassengerTwo.bHardAttach = true;
			MyPassengerTwo.SetBase(self);

			// switch to a MindHalftrackPassenger so that the Pawns won't try to navigate anywhere (or run from grenades)
			MindClass = class<gbxAIController>( DynamicLoadObject( "gbxAI.MindHalftrackPassenger", class'Class' ) );

			NewMind = gbxAIController( MyPassengerTwo.Controller ).ChangeMind( MindClass );

			NewMind.SetVehicle( self );

			MyPassengerTwo.bUseCustomDeathAnim = true;
			MyPassengerTwo.CustomDeathAnims.Length = 2;
			MyPassengerTwo.CustomDeathAnims[0] = 'de_halftrack_death_1';
			MyPassengerTwo.CustomDeathAnims[1] = 'de_halftrack_death_2';

			aMeshAnim = MeshAnimation( DynamicLoadObject( "a_hold_misc.Halftrack", class'MeshAnimation' ) );
			if ( aMeshAnim != None )
			{
				if (MyPassengerTwo.LinkSkelAnim( aMeshAnim ))
				{
					MyPassengerTwo.MeshAnim = aMeshAnim;
					MyPassengerTwo.CurMeshAnimName = "a_hold_misc.Halftrack";
				}
				MyPassengerTwo.bInitializeAnimation = false;
			}
		}
	}

	if (Driver == self)  // is this Halftrack driven by AI?
	{
		Num_Passengers = 0;
		Num_Dead_Passengers = 0;

		if (MyGunner != None)
		{
			Num_Passengers++;
			if (MyGunner.Health <= 0)
				Num_Dead_Passengers++;
		}

		if (MyPassengerOne != None)
		{
			Num_Passengers++;
			if (MyPassengerOne.Health <= 0)
				Num_Dead_Passengers++;
		}

		if (MyPassengerTwo != None)
		{
			Num_Passengers++;
			if (MyPassengerTwo.Health <= 0)
				Num_Dead_Passengers++;
		}

		if (Num_Passengers == 0)  // no passengers? (everybody has dismounted)...
		{
			Throttle = 0.0f;
			Steering = 0.0f;
			Driver = None;  // stop the Halftrack from driving...

			AmbientSound = None;  // kill any engine idle or driving sounds...
			if (MyBulletListener != None)
				MyBulletListener.AmbientSound = None;
		}
		else if (Num_Passengers == Num_Dead_Passengers)  // all passengers are dead?
		{
			Throttle = 0.0f;
			Steering = 0.0f;
			Driver = None;  // stop the Halftrack from driving...

			AmbientSound = None;  // kill any engine idle or driving sounds...
			if (MyBulletListener != None)
				MyBulletListener.AmbientSound = None;
		}
	}
}

function AttachGunner()
{
	local vector RotX, RotY, RotZ;
	local vector BoneLoc;
	local class<gbxAIController> MindClass;
	local gbxAIController NewMind;
	local MeshAnimation	aMeshAnim;

	if (MyGunner == None)
		return;

    GetAxes(Rotation,RotX,RotY,RotZ);

	BoneLoc = GetBoneCoords('mg42_vertical').origin;

	// spawn the MG42 weapon (hidden) that will actually fire the bullets...
	MyMG = spawn(class'WeapDEHalftrackMG42_', self,, BoneLoc + WeapMGOffset.X * RotX + WeapMGOffset.Y * RotY + WeapMGOffset.Z * RotZ);

	if (MyMG == None)
	{
		Log(name $ ".AttachGunner() - Failed to spawn WeapDEHalftrackMG42_ weapon!!!");
		return;
	}

	MyMG.SetBase(self);

	MyMG.bIgnoreSuppression = bIgnoreSuppression;
	MyMG.bUseShotProtection = bUseShotProtection;
	MyMG.Zone1OuterRadius = Zone1OuterRadius;
	MyMG.Zone2OuterRadius = Zone2OuterRadius;
	MyMG.Zone3OuterRadius = Zone3OuterRadius;
	MyMG.NoShotProtectionDist = NoShotProtectionDist;
	MyMG.ShotProtectionCosTheta = ShotProtectionCosTheta;
	MyMG.EnemyTooCloseDist = EnemyTooCloseDist;

	// unlike the MG42Factory code, you HAVE to spawn the Mind first, THEN manually attach the weapon since
	// the Mind will try to switch to the "best" weapon in the Inventory (which is usually only the K98)...
	MindClass = class<gbxAIController>( DynamicLoadObject( "gbxAI.MindHalftrackMG42Gunner", class'Class' ) );

	NewMind = gbxAIController( MyGunner.Controller ).ChangeMind( MindClass );

	NewMind.StartJob( Job_MG42_Gunner );

	NewMind.SetVehicle( self );

	aMeshAnim = MeshAnimation( DynamicLoadObject( "a_hold_misc.Halftrack", class'MeshAnimation' ) );
	if ( aMeshAnim != None )
	{
		if (MyGunner.LinkSkelAnim( aMeshAnim ))
		{
			MyGunner.MeshAnim = aMeshAnim;
			MyGunner.CurMeshAnimName = "a_hold_misc.Halftrack";
		}
		MyGunner.bInitializeAnimation = false;
	}

	MyGunner.PrepareToMount();

	MyGunner.bIsManningTurret = true;	

	MyMG.CompleteMount( MyGunner );

	MyGunner.StopLookAt(true, false, true);
	MyGunner.ResetLookAtImmediate(true, false, true);

	MyGunner.StopTransitioning();

	MyGunner.Velocity = Vect(0,0,0);
	MyGunner.Acceleration = Vect(0,0,0);
		
	MyGunner.bInterpolating = false;	

	MyGunner.Turret = MyMG;
}

function TakeDamage(int Damage, Pawn instigatedBy, Vector Hitlocation, Vector Momentum, class<DamageType> DamageType, optional name HitBoxName)
{
	// don't take any damage
}

function KDriverEnter(Pawn P)
{
    Super.KDriverEnter(P);

	AmbientSound = EngineIdleSound;
}

function bool KDriverLeave(bool bForceLeave)
{
	local bool result;

	result = Super.KDriverLeave(bForceLeave);

	AmbientSound = None;
	if (MyBulletListener != None)
		MyBulletListener.AmbientSound = None;

	return result;
}

function bool IsTank() 
{ 
	return false; 
}

simulated function Tick(float DeltaTime)
{
	local float LinTurnSpeed;
    local KRigidBodyState BodyState;
	local vector ground_velocity;
	local float ground_speed;

	Super(gbxTreadCraft).Tick(DeltaTime);

	if ( !bTracksSetUp && (Level.NetMode != NM_DedicatedServer) )
	{
		SetupTracks();
		bTracksSetUp = true;
	}

	ground_velocity = Velocity;
	ground_velocity.Z = 0.0f;  // ignore Z velocity
	ground_speed = VSize(ground_velocity);

    KGetRigidBodyState(BodyState);
	LinTurnSpeed = abs(0.5 * BodyState.AngVel.Z);

	if ((Driver != None) && (Health > 0) && (!bNoSound))
	{
		if (MyBulletListener != None)
		{
			MyBulletListener.m_fAmbientSoundFadeInTime = m_fAmbientSoundFadeInTime;
			MyBulletListener.m_fAmbientSoundFadeOutTime = m_fAmbientSoundFadeOutTime;
		}

		if ((ground_speed < 20.0f) && (LinTurnSpeed < 0.02f))
		{
			if (AmbientSound == None)
			{
				AmbientSound = EngineIdleSound;
				DrivingSoundStopTime = Level.TimeSeconds + 0.5f;
			}
		}
		else
		{
			if ((MyBulletListener != None) && (MyBulletListener.AmbientSound == None))
			{
				MyBulletListener.AmbientSound = DrivingSound;
				EngineIdleSoundStopTime = Level.TimeSeconds + 0.5f;
			}
		}

	}

	if ((EngineIdleSoundStopTime > 0.0f) && (EngineIdleSoundStopTime <= Level.TimeSeconds))
	{
		EngineIdleSoundStopTime = -1.0f;
		AmbientSound = None;
	}

	if ((DrivingSoundStopTime > 0.0f) && (DrivingSoundStopTime <= Level.TimeSeconds))
	{
		DrivingSoundStopTime = -1.0f;
		if (MyBulletListener != None)
			MyBulletListener.AmbientSound = None;
	}

	UpdateWheels(DeltaTime);

	if ( LeftTrackPanner != None )
		LeftTrackPanner.PanRate = TrackAvgVel[0] / TrackVelocityScale;

	if ( RightTrackPanner != None )
		RightTrackPanner.PanRate = TrackAvgVel[1] / TrackVelocityScale;

	if ((TrackDustEmitterClass != None) && (fMakeDustTime < Level.TimeSeconds))
	{
		if (VSize(ground_velocity) > 100.0f)
		{
			fMakeDustTime = Level.TimeSeconds + 0.3f + (FRand() * 0.4f);

			spawn(TrackDustEmitterClass, self,, Location, Rotation);
		}
	}

	if (bDismountPassengers)
	{
		if ((MyGunner != None) && (MyGunner.Health > 0) && (MyGunner.Controller != None) && (!bGunnerDismounted) && (GunnerDismountTime <= Level.TimeSeconds))
		{
			bGunnerDismounted = true;
			MyGunner.Controller.Trigger(self, None);  // start dismount, then change Minds
			MyGunner = None;
		}

		if ((MyPassengerOne != None) && (MyPassengerOne.Health > 0) && (MyPassengerOne.Controller != None) && (!bPassengerOneDismounted) && (PassengerOneDismountTime <= Level.TimeSeconds))
		{
			bPassengerOneDismounted = true;
			MyPassengerOne.Controller.Trigger(self, None);  // start dismount, then change Minds
			MyPassengerOne = None;
		}

		if ((MyPassengerTwo != None) && (MyPassengerTwo.Health > 0) && (MyPassengerTwo.Controller != None) && (!bPassengerTwoDismounted) && (PassengerTwoDismountTime <= Level.TimeSeconds))
		{
			bPassengerTwoDismounted = true;
			MyPassengerTwo.Controller.Trigger(self, None);  // start dismount, then change Minds
			MyPassengerTwo = None;
		}
	}
}

event bool CanBeAttackedBy( Weapon aWeapon )
{
	if (gbxWeapon(aWeapon) != None)
	{
		return gbxWeapon(aWeapon).bDamagesVehicles;
	}

	return false;
}

event bool CanBeMeleed()
{
	// Although I'd like to see them try!
	return false;
}

//---------------------------------------------------------
//	DoNinePointBlending
//---------------------------------------------------------
function DoNinePointBlending( NinePointDir Dir1, float BlendAlpha1, NinePointDir Dir2, float BlendAlpha2, optional bool fTorsoOnly )
{
	local Name Dir1Anim, Dir2Anim;

	if (BlendAlpha2 > 0.01) {
		AnimBlendParams(HT_NINEPOINT_CHANNEL2, BlendAlpha2, 0.0f, 0);
	}
	if (BlendAlpha1 > 0.01) {
		AnimBlendParams(HT_NINEPOINT_CHANNEL1, BlendAlpha1, 0.0f, 0);
	}

	// Dir1 denotes the first animation to blend.  The first animation
	// should be an "edge animation" (aligned with one of the cardinal
	// directions of up, down, left, or right).
	//
	// Dir2 denotes the second animation to blend.
	// It represents a "diagonal animation" (aligned with one
	// of the diagonal directions: e.g. up-left, down-right, etc.
	//
	switch(Dir1) {
		case NPD_UpLeft:
			Dir1Anim = LeftUpAnim;
			break;
		case NPD_UpCenter:
			Dir1Anim = ForwardUpAnim;
			break;
		case NPD_UpRight:
			Dir1Anim = RightUpAnim;
			break;
		//--------------
		case NPD_MidLeft:
			Dir1Anim = LeftLevelAnim;
			break;
		case NPD_MidCenter:
			Dir1Anim = ForwardLevelAnim;
			break;
		case NPD_MidRight:
			Dir1Anim = RightLevelAnim;
			break;
		//--------------
		case NPD_LowLeft:
			Dir1Anim = LeftDownAnim;
			break;
		case NPD_LowCenter:
			Dir1Anim = ForwardDownAnim;
			break;
		case NPD_LowRight:
			Dir1Anim = RightDownAnim;
			break;
	}

	switch(Dir2) {
		case NPD_UpLeft:
			Dir2Anim = LeftUpAnim;
			break;
		case NPD_UpCenter:
			Dir2Anim = ForwardUpAnim;
			break;
		case NPD_UpRight:
			Dir2Anim = RightUpAnim;
			break;
		//--------------
		case NPD_MidLeft:
			Dir2Anim = LeftLevelAnim;
			break;
		case NPD_MidCenter:
			Dir2Anim = ForwardLevelAnim;
			break;
		case NPD_MidRight:
			Dir2Anim = RightLevelAnim;
			break;
		//--------------
		case NPD_LowLeft:
			Dir2Anim = LeftDownAnim;
			break;
		case NPD_LowCenter:
			Dir2Anim = ForwardDownAnim;
			break;
		case NPD_LowRight:
			Dir2Anim = RightDownAnim;
			break;
	}

	// Play the new Dir1 animation if it has changed.
	if (Dir1Anim != CurNinePointAnim1) {
		CurNinePointAnim1 = Dir1Anim;
		LoopAnim(CurNinePointAnim1, 1.0, 0.1, HT_NINEPOINT_CHANNEL1);
	}

	// Play the new Dir2 animation if it has changed.
	if (Dir2Anim != CurNinePointAnim2) {
		CurNinePointAnim2 = Dir2Anim;
		LoopAnim(CurNinePointAnim2, 1.0, 0.1, HT_NINEPOINT_CHANNEL2);
	}
}

simulated event bool TargetFriendly( Vector aHitLoc, Pawn SourcePawn, bool bFiring )
{
	// anyone can shoot us!
	return false;
}

function Trigger( actor Other, Pawn EventInstigator )
{
	local float delay;

	bDismountPassengers = true;

	GunnerDismountTime = Level.TimeSeconds;
	delay = FRand() * 1.0f;
	PassengerOneDismountTime = Level.TimeSeconds + delay;
	PassengerTwoDismountTime = Level.TimeSeconds + (1.0f - delay);
}


defaultproperties
{
	DrawType=DT_Mesh
	Mesh=None  // use DymamicLoadObject instead
	EditorMeshName="k_vehicle_de.de_halftrack"
    Physics=PHYS_None

	Health=4
	CollisionHeight=2.0
	CollisionRadius=2.0
	VehicleCollisionHeight=100.0
	VehicleCollisionRadius=280.0
	bTurnInPlace=false
	bCanStrafe=false

	MinDamageAmount=300
	HitPointsFront=2
	HitPointsSide=2
	HitPointsRear=3
	HitPointsTurret=2

	FPCamPos=(X=-10,Y=-30,Z=140)
	TPCamLookat=(X=-100,Y=0,Z=100)
	TPCamDistance=1200

	bDrawDriverInTP=true
	bDrawMeshInFP=true

	MaxViewYaw=16000
	MaxViewPitch=16000

	DrivePos=(X=105,Y=-50,Z=85)
	DriveRot=(Pitch=0,Yaw=0,Roll=0)

	ExitPositions(0)=(Y=-415.000000,Z=100.000000)
	ExitPositions(1)=(Y=415.000000,Z=100.000000)

	EngineIdleSoundName="V_TANK_STUART.IDLE"
	DrivingSoundName="V_TANK_STUART.DRIVING_LOOP"

	// tank driving max pitch speed
	MaxPitchSpeed=200.0

	Begin Object Class=SVehicleWheel Name=HT_LFWheel
		BoneName="tire_left"
		BoneRollAxis=AXIS_Z
		BoneSteerAxis=AXIS_Y
		BoneOffset=(X=0.0,Y=0.0,Z=0.0)
		WheelRadius=35
		bPoweredWheel=False
		bInvertRollDirection=False
		SteerType=VST_Steered
		SupportBoneAxis=AXIS_X
		SupportBoneName="left_strut"
		SuspensionTravel=0.0
		SuspensionOffset=0.0
		SuspensionMaxRenderTravel=0.0
		PenScale=0.3
		PenOffset=0.01
		Softness=0.01
		Restitution=0.1
		Adhesion=0.0
		LongFriction=0.9
		LatFriction=0.9
		LongSlip=0.001
		LatSlip=0.005
	End Object
	Wheels(0)=SVehicleWheel'HT_LFWheel'

	Begin Object Class=SVehicleWheel Name=HT_RFWheel
		BoneName="tire_right"
		BoneRollAxis=AXIS_Z
		BoneSteerAxis=AXIS_Y
		BoneOffset=(X=0.0,Y=0.0,Z=0.0)
		WheelRadius=35
		bPoweredWheel=False
		bInvertRollDirection=False
		SteerType=VST_Steered
		SupportBoneAxis=AXIS_X
		SupportBoneName="right_strut"
		SuspensionTravel=0.0
		SuspensionOffset=0.0
		SuspensionMaxRenderTravel=0.0
		PenScale=0.3
		PenOffset=0.01
		Softness=0.01
		Restitution=0.1
		Adhesion=0.0
		LongFriction=0.9
		LatFriction=0.9
		LongSlip=0.001
		LatSlip=0.005
	End Object
	Wheels(1)=SVehicleWheel'HT_RFWheel'

	// thruster positions left to right, front to back...
	Thrusters(0)=(BoneName="left_track_1",ThrusterOffset=42.0,bHasSuspension=true,SuspensionTravel=5.0,SuspensionTravelRate=80.0,NumWheels=3,WheelIndexes[0]=0,WheelIndexes[1]=2,WheelIndexes[2]=4)
	Thrusters(1)=(BoneName="right_track_1",ThrusterOffset=42.0,bHasSuspension=true,SuspensionTravel=5.0,SuspensionTravelRate=80.0,NumWheels=3,WheelIndexes[0]=1,WheelIndexes[1]=3,WheelIndexes[2]=5)
	Thrusters(2)=(BoneName="left_track_2",ThrusterOffset=42.0,bHasSuspension=true,SuspensionTravel=5.0,SuspensionTravelRate=80.0,NumWheels=2,WheelIndexes[0]=6,WheelIndexes[1]=8)
	Thrusters(3)=(BoneName="right_track_2",ThrusterOffset=42.0,bHasSuspension=true,SuspensionTravel=5.0,SuspensionTravelRate=80.0,NumWheels=2,WheelIndexes[0]=7,WheelIndexes[1]=9)
	Thrusters(4)=(BoneName="left_track_3",ThrusterOffset=42.0,bHasSuspension=true,SuspensionTravel=5.0,SuspensionTravelRate=80.0,NumWheels=2,WheelIndexes[0]=10,WheelIndexes[1]=12)
	Thrusters(5)=(BoneName="right_track_3",ThrusterOffset=42.0,bHasSuspension=true,SuspensionTravel=5.0,SuspensionTravelRate=80.0,NumWheels=2,WheelIndexes[0]=11,WheelIndexes[1]=13)
	Thrusters(6)=(BoneName="left_track_4",ThrusterOffset=42.0,bHasSuspension=false,NumWheels=1,WheelIndexes[0]=14)
	Thrusters(7)=(BoneName="right_track_4",ThrusterOffset=42.0,bHasSuspension=false,NumWheels=1,WheelIndexes[0]=15)

	// wheels left then right, front to back...
	TrackWheels(0)=(TrackIndex=0,WheelRadius=30.0,WheelBoneName="left_wheel_1",bHasSuspension=false)
	TrackWheels(1)=(TrackIndex=1,WheelRadius=30.0,WheelBoneName="right_wheel_1",bHasSuspension=false)
	TrackWheels(2)=(TrackIndex=0,WheelRadius=30.0,WheelBoneName="left_wheel_2",bHasSuspension=true)
	TrackWheels(3)=(TrackIndex=1,WheelRadius=30.0,WheelBoneName="right_wheel_2",bHasSuspension=true)
	TrackWheels(4)=(TrackIndex=0,WheelRadius=30.0,WheelBoneName="left_wheel_3",bHasSuspension=true)
	TrackWheels(5)=(TrackIndex=1,WheelRadius=30.0,WheelBoneName="right_wheel_3",bHasSuspension=true)
	TrackWheels(6)=(TrackIndex=0,WheelRadius=30.0,WheelBoneName="left_wheel_4",bHasSuspension=true)
	TrackWheels(7)=(TrackIndex=1,WheelRadius=30.0,WheelBoneName="right_wheel_4",bHasSuspension=true)
	TrackWheels(8)=(TrackIndex=0,WheelRadius=30.0,WheelBoneName="left_wheel_5",bHasSuspension=true)
	TrackWheels(9)=(TrackIndex=1,WheelRadius=30.0,WheelBoneName="right_wheel_5",bHasSuspension=true)
	TrackWheels(10)=(TrackIndex=0,WheelRadius=30.0,WheelBoneName="left_wheel_6",bHasSuspension=true)
	TrackWheels(11)=(TrackIndex=1,WheelRadius=30.0,WheelBoneName="right_wheel_6",bHasSuspension=true)
	TrackWheels(12)=(TrackIndex=0,WheelRadius=30.0,WheelBoneName="left_wheel_7",bHasSuspension=true)
	TrackWheels(13)=(TrackIndex=1,WheelRadius=30.0,WheelBoneName="right_wheel_7",bHasSuspension=true)
	TrackWheels(14)=(TrackIndex=0,WheelRadius=30.0,WheelBoneName="left_wheel_8",bHasSuspension=false)
	TrackWheels(15)=(TrackIndex=1,WheelRadius=30.0,WheelBoneName="right_wheel_8",bHasSuspension=false)

	HoverSoftness=0.05
	HoverPenScale=1.5
	HoverCheckDist=65

	UprightStiffness=500
	UprightDamping=300

	MaxThrust=75.0	// max speed in decimeters per second (0.1 * centimeters per second)

	SteerSpeed=160.0
	MaxSteerAngle=25.0
	FTScale=100.0

//	MaxSteerTorque=100.0
	MaxSteerTorque=200.0
	ForwardDampFactor=0.1
	LateralDampFactor=10.0
	ParkingDampFactor=0.8
//	SteerDampFactor=100.0
	SteerDampFactor=300.0
	PitchTorqueFactor=0.0
	PitchDampFactor=0.0
	BankTorqueFactor=0.0
	BankDampFactor=0.0
	TurnDampFactor=0.0
	DecelerateDampFactor=0.7
	SteerDecayDampFactor=400.0

	InvertSteeringThrottleThreshold=-0.1
	VehicleMass=12.0

	TrackVelocityScale=-153


	Begin Object Class=KarmaParamsRBFull Name=KParamsTank
		KStartEnabled=True
		KFriction=0.5
		KLinearDamping=0
		KAngularDamping=0
		bKNonSphericalInertia=False
		bHighDetailOnly=False
		bClientOnly=False
		bKDoubleTickRate=True
		bKStayUpright=True
		bKAllowRotate=True
		KInertiaTensor(0)=1.3
		KInertiaTensor(1)=0.0
		KInertiaTensor(2)=0.0
		KInertiaTensor(3)=4.0
		KInertiaTensor(4)=0.0
		KInertiaTensor(5)=4.5
		KCOMOffset=(X=0.0,Y=0.0,Z=0.0)
		Name="KParamsTank"
	End Object
	KParams=KarmaParams'KParamsTank'

	PawnTeam=TEAM_Germany

	TrackDustEmitterClass=class'TankStuartTrackDust'

	VehicleShadowDrawScale = 5

	bFriendlyFireListen=true
	ScriptedViewBoneName="chassis"
	ScriptedViewOffset=(X=0,Y=0,Z=180.0f)

	WeapMGOffset=(X=-20,Y=0,Z=10)

	// Nine-point blending animations.
	ForwardDownAnim=mg42_forward_down
	ForwardLevelAnim=mg42_forward_level
	ForwardUpAnim=mg42_forward_up
	LeftDownAnim=mg42_left_down
	LeftLevelAnim=mg42_left_level
	LeftUpAnim=mg42_left_up
	RightDownAnim=mg42_right_down
	RightLevelAnim=mg42_right_level
	RightUpAnim=mg42_right_up

	bIgnoreSuppression=true;
	bUseShotProtection=true;
	Zone1OuterRadius=2000.0
	Zone2OuterRadius=2500.0
	Zone3OuterRadius=3000.0
	NoShotProtectionDist=1000.0
	ShotProtectionCosTheta=0.7071
	EnemyTooCloseDist=1000.0

	bGunnerDismountsWhenFlanked=true

	PassengerOneOffset=(X=-127,Y=0,Z=30)
	PassengerTwoOffset=(X=-195,Y=0,Z=30)
}
class Tank extends gbxTreadCraft
	abstract
	native;


struct native Thruster
{
	var		name	BoneName;					// bone name for this thruster
	var		float	ThrusterOffset;				// amount to offset thruster (repulsor) from origin of track bone
	var		bool	bHasSuspension;				// this track moves up and down based on repulsor contact
	var		bool	bIsSuspensionChanging;
	var		float	SuspensionTravel;			// Z amount suspension will move for this thruster
	var		float	SuspensionTravelRate;		// how fast the suspension changes height in Unreal rotators per second
	var		int		LastThrusterContactState;	// save the previous ThrusterContact state
	var		float	SuspensionPosition;			// current suspension position while changing height
	var		int		NumWheels;					// number of wheels tied to this suspension
	var		int		WheelIndexes[4];			// wheel indexes of wheels which are tied to this suspension
	var		bool	bChecksForWater;			// does this thruster check for WaterVolume?
	var		float	fMakeSplashTime;			// time last splash was made for this thruster
};

struct native TrackWheel
{
	// stuff set in defaultproperties...
	var		int		TrackIndex;		// which track this wheel belongs to
	var		float	WheelRadius;	// radius of this wheel
	var		name	WheelBoneName;	// skeletal mesh bone name for this wheel
	var		bool	bHasSuspension; // this wheel moves up and down based on repulsor contact
	var		bool	bReverseWheelRotation;  // true if wheel rotation needs to be backwards (based on 3DMax bone orientation)

	// stuff calculated while moving...
	var		vector	PreviousLoc;	// previous wheel worldspace location
	var		rotator	CurrentRotation;
};

var array<Thruster>		Thrusters;
var array<TrackWheel>	TrackWheels;
var int NumWheels[2];  // number of wheels on each track

var GbxShaderMaterial LeftTrackMaterial, RightTrackMaterial;
var VariableTexPanner LeftTrackPanner, RightTrackPanner;
var int LeftTrackTextureIndex, RightTrackTextureIndex;

var class<Emitter> TrackDustEmitterClass;
var class<Emitter> TrackSplashEmitterClass;
var float fMakeDustTime;
var float fIsInWaterTime;
var TankSmoke SmokeEmitter;
var vector	SmokeEmitterOffset;
var int		SmokeEmitterDecayIndex;
var float	SmokeEmitterDisableTime;
var float	SmokeEmitterDecayTime;

var TankDeath TankDeathEmitter;
var float fTankDeathTime;  // time when TankDeathEmitter should be destroy and TankBlowedUpEmitter should be spawned
var vector TankDeathEmitterOffset;
var float TankDeathEmitterLifetime;
var float TankDeadSmokeEndDecayTime;

var TankBlowedUp BlowedUpEmitter;
var vector BlowedUpEmitterOffset;
var float fBlowedUpFireDecayTime;
var()	float	FireDecayStartTime;
var()	float	FireDecayRate;
var()	float	FireBurningSoundDecayStart;
var Cue		FireBurningSound;
var string	FireBurningSoundName;
var int		FireBurningSoundHandle;

var()	TNTTrigger	MyTNTTrigger;

var()	float	MaxPitchSpeed;
var()	float	TrackVelocityScale;
var()	float	TrackAvgVel[2];  // average velocity for each track

var Sound	EngineIdleSound;  // engine idle sound is looped
var string	EngineIdleSoundName;
var float	EngineIdleSoundStopTime;  // hack-hack, engine idle sound is played on the Tank actor
var Sound	DrivingSound;  // driving sound is looped
var string	DrivingSoundName;
var float	DrivingSoundStopTime;  // hack-hack, engine driving sound is played on the bullet listener (MyBulletListener)
var bool	bNoSound;  // turn off engine driving/idle sound?
var bool	bForceHatchOpen;  // tank will force the commander hatch open after 50% damage

// main gun damage stuff...
var()	float	DamageMax;
var()	float	DamageRadius;
var()	float	MomentumTransfer;
var()	class<DamageType>	CannonDamageType;
var()	float	AirBurstThreshold;		// Distance from ground where explosion is considered to be exploding in air
var()	float	ShakeRadius;			// radius within which to shake player views
var()	float	ViewRollTime;			// how long to roll the instigator's view
var()	float	RollMag;				// how far to roll view
var()	float	RollRate;				// how fast to roll view
var()	float	OffsetMagVertical;		// max view offset vertically
var()	float	OffsetRateVertical;		// how fast to offset view vertically
var()	float	OffsetMagHorizontal;	// max view offset horizontally
var()	float	OffsetRateHorizontal;	// how fast to offset view horizontally
var()	float	OffsetIterations;		// how many iterations to offset view
var()	float	HeavyTraumaRadius;		// Play 'Heavy Trauma' effect on player if he's within this radius of the grenade

var()	float	BlowupDamageMax;		// Max damage done when the tank explodes

var()	bool	bTriggerOnDeathFired;
var()	name	TriggerOnDeath;
var()	bool	bCrushFriendlyPawns;

// main gun firing animations...
const MAINGUN_ANIM_CHAN1 = 3;
const MAINGUN_ANIM_CHAN2 = 4;
var()	name	MainFireFrontHatchOpen;
var()	name	MainFireFrontHatchClosed;
var()	name	MainFireLeftHatchOpen;
var()	name	MainFireLeftHatchClosed;
var()	name	MainFireRightHatchOpen;
var()	name	MainFireRightHatchClosed;
var()	name	MainFireRearHatchOpen;
var()	name	MainFireRearHatchClosed;

// Nine point blending stuff (for firing mounted machine gun)...
var name	CurNinePointAnim1, CurNinePointAnim2;
var name	ForwardDownAnim, ForwardLevelAnim, ForwardUpAnim,
			LeftDownAnim, LeftLevelAnim, LeftUpAnim,
			RightDownAnim, RightLevelAnim, RightUpAnim;

// Channels used in nine-point blending.
var name NinePointBlendBone;
const NINEPOINT_CHANNEL1 = 17;
const NINEPOINT_CHANNEL2 = 18;

var() TankCommanderPawn CommanderPawn;
var() name TankCommanderTag;
var() CharacterSetup.EUSCharacterTypes	CommanderUSCharType;
var() CharacterSetup.EDECharacterTypes	CommanderDECharType;
var() vector TankCommanderPawnOffset;
var() rotator TankCommanderPawnRotation;
var() vector TankCommanderPawnHitCylinderOffset;
var() rotator TankCommanderPawnHitCylinderRotation;
var() bool bSpawnCommander;
var() bool bTankCommaderInvulnerable;
var   bool bInitCommander;  // has commander been initialized yet?
var   bool bTracksSetUp;

var		bool	bDisablePlayerUseableTriggers;

var()	name	TankHatchOpenIdleAnim;
var()	name	TankHatchClosedIdleAnim;

var()	string	CommanderAnimPkg;
var() array<name> CommanderIdleAnims;
var()	name	CommanderHitPulledInAnim;
var()	name	CommanderFlinchCloseAnim;
var()	name	CommanderOpenHatchAnim;
var()	name	CommanderCloseHatchAnim;
var()	name	CommanderMoveOutAnim;
var()	name	CommanderTankBlownupAnim;

var()	name	TankCommanderHitAnim;
var()	name	TankCommanderFlinchAnim;
var()	name	TankCommanderOpenHatchAnim;
var()	name	TankCommanderCloseHatchAnim;
var()	name	TankCommanderTankBlownupAnim;

// automatically generated corner point stuff...
var vector	CornerPointOffset[8];  // 8 corner points, 2 at front, 2 on left, 2 at rear and 2 on right (in that order)
var int		CornerPointYawRotation[8];
var byte	CornerPointIsLeftCorner[8];  // is this a 'left' corner point?
var byte	CornerPointIsStandingCorner[8];  // does this point provide standing cover?

var int		MinDamageAmount;	// minimum amount of TakeDamage damage to cause Health loss
var int		HitPointsFront;		// how much Health is removed when hit in the front
var int		HitPointsSide;		// how much Health is removed when hit in the side
var int		HitPointsRear;		// how much Health is removed when hit in the rear
var int		HitPointsTurret;	// how much Health is removed when hit in the turret

var() float	PushForce;

var name	TankGrenadePlayerAnim;
var string	TankGrenadeMeshAnimName;
var vector	TankGrenadeMountAnimStartOffset;
var vector	TankGrenadeCameraStartOffset;
var vector	TankGrenadeCameraEndOffset;
var vector	TankGrenadeHeadZoomInOffset;
var int		TankGrenadeYawSet;
var vector	TankGrenadeTeleportOffset;

var()	TankCornerPoint	MyCornerPoints[8];  // two at the front, two on the left, two at the rear and two one the right (in that order)

var() ETankType	TankType;


function bool IsTank() 
{ 
	return true; 
}

function bool IsTankCommanderButtonedUp()
{
	if (CommanderPawn == None)
		return true;  // no commander = hatch closed

	return CommanderPawn.bHatchClosing;
}

// special case if player manages to jump on top of the tank while the commander is still out
function MakeTankCommanderGoInQuick()
{
	Log(name $ ".MakeTankCommanderGoInQuick()", 'Tank');
	if (CommanderPawn != None)
	{
		// do the same sort of stuff that the Idle to Combat state does except don't play the hatch closing animation...
		CommanderPawn.bAllowDamage = false;
		CommanderPawn.bHidden = true;
		CommanderPawn.AddAnimToQueue(CommanderCloseHatchAnim, 90, false, false, false, 1.0, 0.15);
		CommanderPawn.bHatchClosing = true;
		if (CommanderPawn.HitCylinder != None)
			CommanderPawn.HitCylinder.bHidden = true;
		CommanderPawn.GotoState('Combat');

		PlayAnim(TankHatchClosedIdleAnim);
	}
}

simulated function PostNetBeginPlay()
{
	local int index;
	local vector BoneLoc, WheelLoc;
	local vector Offset;

	NumWheels[0] = 0;
	NumWheels[1] = 0;

	// make sure the bone positions are calculated...
	BoneRefresh();

	// create all the thrusters based on bone positions...
	for (index = 0; index < Thrusters.Length; index++)
	{
		BoneLoc = GetBoneCoords(Thrusters[index].BoneName).origin;
		Offset = BoneLoc - Location;

		Thrusters[index].LastThrusterContactState = -1;  // unknown
		Thrusters[index].SuspensionPosition = 0.0f;  // suspension starts at offset of 0 rotation units

		Offset = Offset << Rotation;
		Offset.Z -= (Thrusters[index].ThrusterOffset - HoverCheckDist);

		ThrusterOffsets.Length = ThrusterOffsets.Length + 1;
		ThrusterOffsets[ThrusterOffsets.Length-1] = Offset;

		Thrusters[index].fMakeSplashTime = 0.0f;
	}

	// initialize all the wheel variables...
	for (index = 0; index < TrackWheels.Length; index++)
	{
		NumWheels[TrackWheels[index].TrackIndex]++;

		WheelLoc = GetBoneCoords(TrackWheels[index].WheelBoneName).origin;
		Offset = WheelLoc - Location;

		TrackWheels[index].PreviousLoc = WheelLoc;
		TrackWheels[index].CurrentRotation = rot(0,0,0);
	}

	fMakeDustTime = 0.0f;
	fIsInWaterTime = 0.0f;

	fTankDeathTime = -1.0f;
	SmokeEmitterDisableTime = -1.0f;
	SmokeEmitterDecayIndex = -1;
	TankDeadSmokeEndDecayTime = -1.0f;
	FireBurningSoundDecayStart = -1.0f;

	EngineIdleSoundStopTime = -1.0f;
	DrivingSoundStopTime = -1.0f;

	KarmaSleepTime = -1.0f;

	Super.PostNetBeginPlay();
}

function InitCommander()
{
	local TankCommanderPawnHitCylinder TCPHC;
	local int nHealth;

	if (bSpawnCommander)
	{
		CommanderPawn = spawn(class'TankCommanderPawn', self, TankCommanderTag);

		if (CommanderPawn != None)
		{
			CommanderPawn.PawnTeam = self.PawnTeam;  // commander is on same team as tank

			// Set up the commander's character type, which is used to determine his VoiceType for battle dialogue.
			if (IsA('TankStuart') || IsA('TankSherman'))
			{
				if ( CommanderUSCharType != USCharNone )
				{
					CommanderPawn.CharacterSetupClass = class'CharacterSetupUSA';
					CommanderPawn.SetCharacterType( CommanderUSCharType );

					SetCharacterType( CommanderUSCharType );
				}
			}
			else if ( CommanderDECharType != DECharNone )
			{
				CommanderPawn.CharacterSetupClass = class'CharacterSetupGermany';
				CommanderPawn.SetCharacterType( CommanderDECharType );
			}

			CommanderPawn.SetVoiceType( CommanderPawn.GetCharacterVoiceType() );

			AttachToBone( CommanderPawn, 'Commander' );

			CommanderPawn.SetRelativeRotation( TankCommanderPawnRotation );
			CommanderPawn.SetRelativeLocation( TankCommanderPawnOffset );

			CommanderPawn.SetCommanderAnims(CommanderAnimPkg, CommanderIdleAnims, CommanderHitPulledInAnim, CommanderFlinchCloseAnim,
											CommanderOpenHatchAnim,	CommanderCloseHatchAnim, CommanderMoveOutAnim, CommanderTankBlownupAnim);
			CommanderPawn.SetTankAnims(TankCommanderHitAnim, TankCommanderFlinchAnim, TankCommanderOpenHatchAnim,
									   TankCommanderCloseHatchAnim, TankCommanderTankBlownupAnim);

			PlayAnim(TankHatchOpenIdleAnim);  // play the open hatch animation on the tank

			if (!bTankCommaderInvulnerable)
			{
				TCPHC = spawn(class'TankCommanderPawnHitCylinder', self);

				AttachToBone( TCPHC, 'Commander' );

				TCPHC.SetRelativeRotation( TankCommanderPawnHitCylinderRotation );
				TCPHC.SetRelativeLocation( TankCommanderPawnHitCylinderOffset );
			}
			else
			{
				TCPHC = None;  // no hit cylinder, commander can't be hit
				CommanderPawn.bTankCommaderInvulnerable = true;
			}

			CommanderPawn.SetTankPawn(self, TCPHC);

			CommanderPawn.SetMainGunAnimChannels(MAINGUN_ANIM_CHAN1, MAINGUN_ANIM_CHAN2);

			// set the proper tank commander pawn health based on checkpoint value...
			nHealth = CommanderPawn.default.Health;

			// This is very slow, and has no meaning for MP anyways. So only do this stuff in SP games. 2004-12-02 JWS
			if (Level.NetMode == NM_Standalone)
			{
				if (Level.MissionManager.GetCheckpointPawnHealth(TankCommanderTag, nHealth))
				{
					if (nHealth <= 0)  // commander dead?
					{
						// since we know the tank is still alive (dead tanks don't reload at checkpoints), very quickly play the death animations...
						CommanderPawn.AddAnimToQueue(CommanderHitPulledInAnim, 9999, true, false, false, 10.0 /*FAST*/, 0.15);
						CommanderPawn.bHatchClosing = true;
						CommanderPawn.bHidePawn = true;  // hide pawn when animation is done playing
						CommanderPawn.GotoState('Dying');

						FlushAnimQueueChannel( 0,, true );
						StopAnimating(true);
						AddAnimToQueue(TankCommanderHitAnim, 99, true, false, false, 10.0 /*FAST*/, 0.15);
					}

					CommanderPawn.Health = nHealth;
				}
			}
		}
	}
	else
	{
		PlayAnim(TankHatchClosedIdleAnim);
	}
}

simulated function string GetCharacterPortrait()
{
	return CharacterSetupClass.Static.GetTankPortrait(TankType);
}

simulated function string GetCharacterName()
{
	return CharacterSetupClass.Static.GetTankName(TankType);
}


function CreateTriggers()
{
}

function bool IsHatchClosed()
{
	if (bForceHatchOpen)
		return false;

	if (CommanderPawn != None)
		return CommanderPawn.bHatchClosing;

	return true;
}

function bool IsPlayerOnTank()
{
	local Controller PC;
	local float distance;

	PC = Level.GetLocalPlayerController();

	if ((PC != None) && (PC.Pawn != None))
	{
		distance = VSizeIgnoreZ(PC.Pawn.Location - Location);

		if ((distance < (VehicleCollisionRadius * 1.5f)) && (PC.Pawn.Location.Z > Location.Z))
			return true;
	}

	return false;
}

simulated function float PlaySpeech(Name speechName, optional Name keyName, optional out int SoundHandle )
{
	// tanks don't speak, the commander speaks...
	if (CommanderPawn != None)
	{
		return CommanderPawn.PlaySpeech(speechName, keyName, SoundHandle);
	}

	// else, do nothing...
	SoundHandle = -1;

	return 0.0f;
}

simulated function FireMainGun()
{
	// Implementation dependant
}

function TakeDamage(int Damage, Pawn instigatedBy, Vector Hitlocation, Vector Momentum, class<DamageType> DamageType, optional name HitBoxName)
{
	local int actualDamage;
	local Controller Killer;
	local vector v_push, PushAngVel;
	local vector RotX, RotY, RotZ;

	if ( Role < ROLE_Authority )
	{
		return;
	}

	if ( Controller != None )
	{
		Controller.NotifyTakeHit(instigatedBy, HitLocation, actualDamage, DamageType, Momentum);

		if (Controller.bGodMode)
			return;
	}

	if (Health <= 0)  // dead already?
	{
		// is this an exploding type damage or hand grenade?
		if ((damageType.Default.m_bDamagesArmor) || (ClassIsChildOf(damageType, class'DamageGrenade')))
		{
			SetPhysics(PHYS_Karma);
			KWake();  // make sure we're awake

			KarmaSleepTime = Level.TimeSeconds + 3.0;  // put back to sleep again in 3.0 seconds

			// push the tank around some based on the Momentum vector
			v_push = Momentum * PushForce;
			Log(name $ ".TakeDamage - Momentum = " $ Momentum $ "  v_push = " $ v_push, 'Tank');

			PushAngVel = Normal(v_push) Cross ( Normal(v_push) * vect(1,1,0)) * PushForce;
			KSetSkelVel( v_push, PushAngVel );
			KAddImpulse(v_push, Location);
		}

		return;  // already dead, can't damage it any more
	}

	MakeNoise(1.0);

	if (!damageType.Default.m_bDamagesArmor)
	{
		Log(name $ ".TakeDamage - instigatedBy = " $ instigatedBy.name $ ", DamageType.name = " $ DamageType.name $ " (being ignored)", 'Tank');
		return;  // tanks are ONLY damaged by exploding things (but NOT by grenades)
	}

	if ((instigatedBy != None) && (SameTeamAs(instigatedBy)))
	{
		Log(name $ ".TakeDamage - instigatedBy = " $ instigatedBy.name $ ", DamageType.name = " $ DamageType.name $ " (friendly fire ignored)", 'Tank');
		return;  // friendly fire doesn't do damage
	}

	if (damageType == class'DamageGammonBomb')
	{
		Health -= (Health + 1);  // make sure tank is dead
	}
	else
	{
		if (Damage < MinDamageAmount)
		{
			Log(name $ ".TakeDamage - instigatedBy = " $ instigatedBy.name $ ", DamageType.name = " $ DamageType.name $ " (Damage less than MinDamageAmount)", 'Tank');
			return;  // not enough damage to cause loss in Health
		}

		actualDamage = 1;

		if (HitBoxName == 'front')
			actualDamage = HitPointsFront;
		else if ((HitBoxName == 'body') || (HitBoxName == 'base'))
			actualDamage = HitPointsSide;
		else if (HitBoxName == 'rear')
			actualDamage = HitPointsRear;
		else if (HitBoxName == 'turret')
			actualDamage = HitPointsTurret;

		Health -= actualDamage;
	}

	// Don't notify too often.
	if( Health > 0 && Level.TimeSeconds - LastTakeDamageNotifyTime > MIN_TAKEDAMAGE_NOTIFY_TIME )
	{
		NotifyPlayersImTakingDamage();
	}

	if ((SmokeEmitter == None) && (Health < default.Health))  // no smoke yet?
	{
	    GetAxes(Rotation,RotX,RotY,RotZ);

		// spawn some smoke coming out of the tank...
		SmokeEmitter = spawn(class'TankSmoke', self,, Location + SmokeEmitterOffset.X * RotX + SmokeEmitterOffset.Y * RotY + SmokeEmitterOffset.Z * RotZ, Rotation);
		SmokeEmitter.SetBase(self);

		if (Health >= ((2 * Default.Health) / 3))
			SmokeEmitter.Emitters[0].Disabled = false;
		else if (Health >= ((1 * Default.Health) / 3))
			SmokeEmitter.Emitters[1].Disabled = false;
		else
			SmokeEmitter.Emitters[2].Disabled = false;
	}
	else
	{
		if (Health >= ((1 * Default.Health) / 3))
		{
			if (!SmokeEmitter.Emitters[0].Disabled)
			{
				SmokeEmitterDecayIndex = 0;
				SmokeEmitterDecayTime = Level.TimeSeconds + 0.1;
				SmokeEmitterDisableTime = Level.TimeSeconds + 5.0;
			}

			if (SmokeEmitter.Emitters[1].Disabled)
				SmokeEmitter.Emitters[1].Disabled = false;
		}
		else
		{
			if (!SmokeEmitter.Emitters[0].Disabled)
			{
				SmokeEmitterDecayIndex = 0;
				SmokeEmitterDecayTime = Level.TimeSeconds + 0.1;
				SmokeEmitterDisableTime = Level.TimeSeconds + 5.0;
			}
			else if (!SmokeEmitter.Emitters[1].Disabled)
			{
				SmokeEmitterDecayIndex = 1;
				SmokeEmitterDecayTime = Level.TimeSeconds + 0.1;
				SmokeEmitterDisableTime = Level.TimeSeconds + 5.0;
			}

			if (SmokeEmitter.Emitters[2].Disabled)
				SmokeEmitter.Emitters[2].Disabled = false;
		}

	}

	if (Health <= 0)
	{
		if (instigatedBy != None)
			Killer = instigatedBy.Controller;

		NotifyPlayersIDied(); // this MUST come before the Died() function is called

		Died(Killer, damageType, HitLocation);

		if (CommanderPawn != None)
			CommanderPawn.KillCommander(instigatedBy, DamageType);

		if (SmokeEmitter != None)
		{
			SmokeEmitter.Destroy();
			SmokeEmitter = None;
		}

		// spawn the TankDeath emitter...
		TankDeathEmitter = spawn(class'TankDeath', self,, Location + TankDeathEmitterOffset, Rotation);
		if (TankDeathEmitter != None)
		{
			TankDeathEmitter.SetBase(self);
			fTankDeathTime = Level.TimeSeconds + TankDeathEmitterLifetime;

			FireBurningSound = LoadSound( FireBurningSoundName );
			FireBurningSoundHandle = PlaySoundCue(FireBurningSound);
			FireBurningSoundDecayStart = fTankDeathTime + 30.0f;
		}

		// make dead tanks easier to push around...
		ParkingDampFactor = 0.1;
		LateralDampFactor = 0.3;
		DecelerateDampFactor = 0.2;
		UprightDamping = UprightDamping * 0.1;

		Momentum = Normal(Momentum) * 20000.0;

		if (Momentum.Z > 10000)
			Momentum.Z = 10000;

		v_push = Momentum * PushForce;

		PushAngVel = Normal(v_push) Cross ( Normal(v_push) * vect(1,1,0)) * PushForce;
		KSetSkelVel( v_push, PushAngVel );
		KAddImpulse(v_push, Location);

		if (!bTriggerOnDeathFired)
		{
			bTriggerOnDeathFired = true;  // prevent from being called twice
			TriggerEvent(TriggerOnDeath, Controller, Self);
		}
	}
}

simulated function Died(Controller Killer, class<DamageType> damageType, vector HitLocation)
{
	local int i;
	local Pawn NavPointClaimant;
	local float distance;

	Log( name $ ".(Tank).Died()", 'Tank' );

	// unclaim any claimed navigation points that are outside the VehilceCollisionRadius of the tank...
	// (the tank still claims the navigation points that sit directly underneath it)
	for (i = MyClaimedNavPoints.Length-1; i >= 0; i--)
	{
		NavPointClaimant = None;
		if (MyClaimedNavPoints[i].bIsNavigationPoint)
			NavPointClaimant = NavigationPoint(MyClaimedNavPoints[i]).Claimant;
		else if (MyClaimedNavPoints[i].bIsNavigationPointLite)
			NavPointClaimant = NavigationPointLite(MyClaimedNavPoints[i]).Claimant;

		if (NavPointClaimant == self)
		{
			if (MyClaimedNavPoints[i].bIsNavigationPoint)
				distance = VSize(NavigationPoint(MyClaimedNavPoints[i]).Location - Location);
			else if (MyClaimedNavPoints[i].bIsNavigationPointLite)
				distance = VSize(NavigationPointLite(MyClaimedNavPoints[i]).Location - Location);

			if (distance > (VehicleCollisionRadius * 1.2f))  // add a 20% fudge factor to VehicleCollisionRadius
			{
				if (MyClaimedNavPoints[i].bIsNavigationPoint)
					NavigationPoint(MyClaimedNavPoints[i]).Claimant = None;
				else if (MyClaimedNavPoints[i].bIsNavigationPointLite)
					NavigationPointLite(MyClaimedNavPoints[i]).Claimant = None;

				MyClaimedNavPoints.Remove(i, 1);
			}
		}
	}

	if ( Controller != None )
		Controller.PawnDied(self);
}

simulated event Destroyed()
{
	local int i;

	Log( name $ ".(Tank).Destroyed()", 'Tank' );

	// if the tank drives itself...
	if (Driver == self)
		Driver = None;  // "remove" the driver

	DestroyTracks();

	if (TankDeathEmitter != None)
		TankDeathEmitter.Destroy();

	if (BlowedUpEmitter != None)
		BlowedUpEmitter.Destroy();

	if (SmokeEmitter != None)
		SmokeEmitter.Destroy();

	if (MyTNTTrigger != None)
		MyTNTTrigger.Destroy();

	if (CommanderPawn != None)
	{
		if (CommanderPawn.HitCylinder != None)
			CommanderPawn.HitCylinder.Destroy();

		CommanderPawn.Destroy();
	}

	RemoveCornerPointsFromNavPointCaches();

	// remove any corner points...
	for (i = 0; i < 8; i++)
	{
		if (MyCornerPoints[i] != None)
			MyCornerPoints[i].Destroy();
	}

	if (Controller != None)
		Controller.Destroy();

	super.Destroyed();
}

simulated function SetupTracks()
{
	local GbxShaderMaterial SrcMaterial;

	LeftTrackMaterial = GbxShaderMaterial(Level.ObjectPool.AllocateObject(class'GbxShaderMaterial', Level.Outer ));
	if (LeftTrackMaterial != None)
	{
		LeftTrackPanner = VariableTexPanner(Level.ObjectPool.AllocateObject(class'VariableTexPanner', Level.Outer ));
		if ( LeftTrackPanner != None )
		{
			SrcMaterial = GbxShaderMaterial(Skins[LeftTrackTextureIndex]);
			LeftTrackPanner.Material = SrcMaterial.Textures[0].T[0];
			LeftTrackPanner.PanDirection = rot(0, 0, 16384);
			LeftTrackPanner.PanRate = 0.0;
			LeftTrackMaterial.Textures = SrcMaterial.Textures;
			LeftTrackMaterial.Textures[0].T[0] = LeftTrackPanner;
			LeftTrackMaterial.Shader = SrcMaterial.Shader;
			LeftTrackMaterial.VertexShaderValues = SrcMaterial.VertexShaderValues;
			LeftTrackMaterial.PixelShaderValues = SrcMaterial.PixelShaderValues;
			Skins[LeftTrackTextureIndex] = LeftTrackMaterial;
		}
	}

	RightTrackMaterial = GbxShaderMaterial(Level.ObjectPool.AllocateObject(class'GbxShaderMaterial', Level.Outer ));
	if (RightTrackMaterial != None)
	{
		RightTrackPanner = VariableTexPanner(Level.ObjectPool.AllocateObject(class'VariableTexPanner', Level.Outer ));
		if ( RightTrackPanner != None )
		{
			SrcMaterial = GbxShaderMaterial(Skins[RightTrackTextureIndex]);
			RightTrackPanner.Material = SrcMaterial.Textures[0].T[0];
			RightTrackPanner.PanDirection = rot(0, 0, 16384);
			RightTrackPanner.PanRate = 0.0;
			RightTrackMaterial.Textures = SrcMaterial.Textures;
			RightTrackMaterial.Textures[0].T[0] = RightTrackPanner;
			RightTrackMaterial.Shader = SrcMaterial.Shader;
			RightTrackMaterial.VertexShaderValues = SrcMaterial.VertexShaderValues;
			RightTrackMaterial.PixelShaderValues = SrcMaterial.PixelShaderValues;
			Skins[RightTrackTextureIndex] = RightTrackMaterial;
		}
	}
}

simulated function DestroyTracks()
{
	if (LeftTrackMaterial != None)
	{
		Level.ObjectPool.FreeObject(LeftTrackMaterial);
		LeftTrackMaterial = None;
	}
	if (RightTrackMaterial != None)
	{
		Level.ObjectPool.FreeObject(RightTrackMaterial);
		RightTrackMaterial = None;
	}
	if ( LeftTrackPanner != None )
	{
		Level.ObjectPool.FreeObject(LeftTrackPanner);
		LeftTrackPanner = None;
	}
	if ( RightTrackPanner != None )
	{
		Level.ObjectPool.FreeObject(RightTrackPanner);
		RightTrackPanner = None;
	}
}

simulated function UpdateWheels(float DeltaTime)
{
	local int index, index2, wheel_index;
	local rotator CurrentRotation;
	local float RotationalVelocity;
	local vector V;

	for (index = 0; index < Thrusters.Length; index++)
	{
		if (Thrusters[index].bHasSuspension)  // does this suspension move up and down?
		{
			if (index < ThrusterContacts.Length)
			{
				// check if thruster contact state has changed (was contacting, now not contacting, or vice versa)...
				if (Thrusters[index].LastThrusterContactState != ThrusterContacts[index])
				{
					Thrusters[index].LastThrusterContactState = ThrusterContacts[index];

					// this suspension needs to start moving upwards or downwards (based on contact state)
					Thrusters[index].bIsSuspensionChanging = true;
				}

				if (Thrusters[index].bIsSuspensionChanging)  // is suspension moving up or down?
				{
					// suspension moves up and down based on whether contacting anything...
					if (ThrusterContacts[index] > 0)  // is this thruster resting on something?
					{
						// suspension is moving upwards...

						if (abs(Thrusters[index].SuspensionPosition) < 0.01)
						{
							Thrusters[index].bIsSuspensionChanging = false;  // suspension is at maximum height
						}
						else
						{
							Thrusters[index].SuspensionPosition += Thrusters[index].SuspensionTravelRate * DeltaTime;  // move upwards
							Thrusters[index].SuspensionPosition = FClamp(Thrusters[index].SuspensionPosition, -Thrusters[index].SuspensionTravel, 0.0);
						}
					}
					else
					{
						// suspension is moving downwards...

						if (abs(Thrusters[index].SuspensionPosition - Thrusters[index].SuspensionTravel) < 0.01)
						{
							Thrusters[index].bIsSuspensionChanging = false;  // suspension is at maximum lowered position
						}
						else
						{
							Thrusters[index].SuspensionPosition -= Thrusters[index].SuspensionTravelRate * DeltaTime;  // move upwards
							Thrusters[index].SuspensionPosition = FClamp(Thrusters[index].SuspensionPosition, -Thrusters[index].SuspensionTravel, 0.0);
						}
					}

					if (Thrusters[index].BoneName != '')
					{
						V.X = 0.0f;
						V.Y = 0.0f;
						V.Z = Thrusters[index].SuspensionPosition;

						SetBoneDirection(Thrusters[index].BoneName, rot(0,0,0), V, 1.0, 0);
					}
				}
			}
		}

		// update the bone rotation and location for each wheel...
		for (index2 = 0; index2 < Thrusters[index].NumWheels; index2++)
		{
			wheel_index = Thrusters[index].WheelIndexes[index2];

			CurrentRotation = TrackWheels[wheel_index].CurrentRotation;

			RotationalVelocity = (TrackAvgVel[TrackWheels[wheel_index].TrackIndex] * DeltaTime * 65536/(2*PI)) / TrackWheels[wheel_index].WheelRadius;

			if (TrackWheels[wheel_index].bReverseWheelRotation)
				RotationalVelocity *= -1;

			CurrentRotation.Yaw = (CurrentRotation.Yaw + RotationalVelocity) & 65535;
			TrackWheels[wheel_index].CurrentRotation = CurrentRotation;

			// tires rotate as track moves...
			SetBoneRotation(TrackWheels[wheel_index].WheelBoneName, CurrentRotation, 0, 1.0);

			if (TrackWheels[wheel_index].bHasSuspension)  // does this wheel move up and down on a suspension?
			{
				if (Thrusters[index].bIsSuspensionChanging)  // is suspension moving up or down?
				{
					V.X = 0.0f;
					V.Y = 0.0f;
					V.Z = Thrusters[index].SuspensionPosition;

					SetBoneDirection(TrackWheels[wheel_index].WheelBoneName, rot(0,0,0), V, 1.0, 0);
				}
			}
		}
	}
}

simulated function Tick(float DeltaTime)
{
	local float LinTurnSpeed;
    local KRigidBodyState BodyState;
	local vector ground_velocity;
	local float ground_speed;
	local int index;
	local float decay;
	local vector Momentum, v_push, PushAngVel;

	super.Tick( DeltaTime );

	if ( !bTracksSetUp && (Level.NetMode != NM_DedicatedServer) )
	{
		SetupTracks();
		bTracksSetUp = true;
	}

	if (!bInitCommander)
	{
		InitCommander();
		bInitCommander = true;  // commander has been initialized
	}

	ground_velocity = Velocity;
	ground_velocity.Z = 0.0f;  // ignore Z velocity
	ground_speed = VSize(ground_velocity);

    KGetRigidBodyState(BodyState);
	LinTurnSpeed = abs(0.5 * BodyState.AngVel.Z);

	if ((Driver != None) && (Health > 0) && (!bNoSound))
	{
		if (MyBulletListener != None)
		{
			MyBulletListener.m_fAmbientSoundFadeInTime = m_fAmbientSoundFadeInTime;
			MyBulletListener.m_fAmbientSoundFadeOutTime = m_fAmbientSoundFadeOutTime;
		}

		if ((ground_speed < 20.0f) && (LinTurnSpeed < 0.02f))
		{
			if (AmbientSound == None)
			{
				AmbientSound = EngineIdleSound;
				DrivingSoundStopTime = Level.TimeSeconds + 0.5f;
			}
		}
		else
		{
			if ((MyBulletListener != None) && (MyBulletListener.AmbientSound == None))
			{
				MyBulletListener.AmbientSound = DrivingSound;
				EngineIdleSoundStopTime = Level.TimeSeconds + 0.5f;
			}
		}

	}

	if ((EngineIdleSoundStopTime > 0.0f) && (EngineIdleSoundStopTime <= Level.TimeSeconds))
	{
		EngineIdleSoundStopTime = -1.0f;
		AmbientSound = None;
	}

	if ((DrivingSoundStopTime > 0.0f) && (DrivingSoundStopTime <= Level.TimeSeconds))
	{
		DrivingSoundStopTime = -1.0f;
		if (MyBulletListener != None)
			MyBulletListener.AmbientSound = None;
	}

	if (Physics == PHYS_Karma)  // don't update wheel positions if Karma isn't simulating (i.e. vehicle asleep)
	UpdateWheels(DeltaTime);

	if ( LeftTrackPanner != None )
		LeftTrackPanner.PanRate = TrackAvgVel[0] / TrackVelocityScale;

	if ( RightTrackPanner != None )
		RightTrackPanner.PanRate = TrackAvgVel[1] / TrackVelocityScale;

	if ((TrackDustEmitterClass != None) && (ground_speed > 100.0f) && (fMakeDustTime < Level.TimeSeconds) && (fIsInWaterTime < (Level.TimeSeconds - 1.0f)))
	{
		fMakeDustTime = Level.TimeSeconds + 0.3f + (FRand() * 0.4f);

		spawn(TrackDustEmitterClass, self,, Location, Rotation);
	}

	if ((SmokeEmitterDisableTime > 0) && (SmokeEmitter != None))
	{
		if ((SmokeEmitterDecayIndex >= 0) && (SmokeEmitterDecayTime < Level.TimeSeconds))
		{
			SmokeEmitterDecayTime = Level.TimeSeconds + 0.1;
			SmokeEmitter.Emitters[SmokeEmitterDecayIndex].Opacity *= 0.9;
		}

		if (SmokeEmitterDisableTime < Level.TimeSeconds)
		{
			SmokeEmitterDisableTime = -1.0f;

			if (SmokeEmitterDecayIndex == 0)
				SmokeEmitter.Emitters[0].Disabled = true;
			else if (SmokeEmitterDecayIndex == 1)
				SmokeEmitter.Emitters[1].Disabled = true;
		}
	}

	if ((fTankDeathTime > 0.0) && (fTankDeathTime < Level.TimeSeconds))
	{
		if (TankDeathEmitter != None)
		{
			TankDeathEmitter.Destroy();
			TankDeathEmitter = None;
		}

		fTankDeathTime = -1.0f;

		// spawn the TankBlowedUp emitter...
		BlowedUpEmitter = spawn(class'TankBlowedUp', self,, Location + BlowedUpEmitterOffset, Rotation);
		if (BlowedUpEmitter != None)
		{
			BlowedUpEmitter.SetBase(self);
			fBlowedUpFireDecayTime = Level.TimeSeconds + FireDecayStartTime;
		}

		// make up some crazy vector
		Momentum.X = 0.1 + FRand() * 0.5;
		Momentum.Y = 0.1 + FRand() * 0.5;
		Momentum.Z = 1.0;

		Momentum = Normal(Momentum) * 20000.0;

		v_push = Momentum * PushForce;

		PushAngVel = Normal(v_push) Cross ( Normal(v_push) * vect(1,1,0)) * PushForce;
		KSetSkelVel( v_push, PushAngVel );
		KAddImpulse(v_push, Location);

		// Hurt stuff around me
		HurtRadius( BlowupDamageMax, DamageRadius, CannonDamageType, MomentumTransfer, Location );
	}

	if (BlowedUpEmitter != None)
	{
		if ((FireBurningSoundDecayStart > 0.0f) && (FireBurningSoundDecayStart < Level.TimeSeconds))
		{
			FireBurningSoundDecayStart = -1.0f;
			StopSound(FireBurningSoundHandle, 15.0f);  // fade out over 15 seconds
		}

		if (fBlowedUpFireDecayTime < Level.TimeSeconds)
		{
			fBlowedUpFireDecayTime += 0.2;

			index = BlowedUpEmitter.FireIndexStartSizeRange;
			BlowedUpEmitter.Emitters[index].StartSizeRange.X.Min *= FireDecayRate;
			BlowedUpEmitter.Emitters[index].StartSizeRange.X.Max *= FireDecayRate;
			BlowedUpEmitter.Emitters[index].StartSizeRange.Y.Min *= FireDecayRate;
			BlowedUpEmitter.Emitters[index].StartSizeRange.Y.Max *= FireDecayRate;
			BlowedUpEmitter.Emitters[index].StartSizeRange.Z.Min *= FireDecayRate;
			BlowedUpEmitter.Emitters[index].StartSizeRange.Z.Max *= FireDecayRate;

			index = BlowedUpEmitter.FireIndexOpacity;
			BlowedUpEmitter.Emitters[index].Opacity *= FireDecayRate;

			// if the blowed up emitter fire is almost out, start fading out the smoke
			if ((BlowedUpEmitter.Emitters[index].Opacity < 0.05) && (TankDeadSmokeEndDecayTime < 0.0f))
				TankDeadSmokeEndDecayTime = Level.TimeSeconds + 60.0f;  // fade out and destroy in 60 seconds
		}

		if (TankDeadSmokeEndDecayTime > 0.0f)
		{
			if (TankDeadSmokeEndDecayTime < Level.TimeSeconds)  // destroy the smoke emitter
			{
				BlowedUpEmitter.Destroy();
				BlowedUpEmitter = None;
			}
			else
			{
				index = BlowedUpEmitter.SmokeIndexOpacity;
				decay = (TankDeadSmokeEndDecayTime - Level.TimeSeconds) / 60.0f;  // percent of the way done
				BlowedUpEmitter.Emitters[index].Opacity = class'TankBlowedUp'.Default.Emitters[index].Opacity * decay;
			}
		}
	}
}


// This will get called if we couldn't move a Pawn out of the way ('Crushed' instead of 'DamageRunOver')
function bool EncroachingOn( actor Other )
{
	local vector v1, v2;
	local float dotproduct;
	local vector Momentum;
	local vector ground_velocity;
	local float LinTurnSpeed;
    local KRigidBodyState BodyState;

	if ( Other == None )
		return false;

	// If its a non-vehicle Pawn, do lots of damage.
	if( Pawn(Other) != None && gbxSVehicle(Other) == None )
	{
		ground_velocity = Velocity;
		ground_velocity.Z = 0.0f;  // ignore Z velocity

	    KGetRigidBodyState(BodyState);
		LinTurnSpeed = abs(0.5 * BodyState.AngVel.Z);

		if ((VSize(ground_velocity) < 80) && (LinTurnSpeed < 0.018))
			return false;

		// don't damage this Pawn if the Pawn and the vehicle are on the same team...
		if (!SameTeamAs(Pawn(Other)) || bCrushFriendlyPawns)
		{
			// do a dot product check to see if the Pawn is in front of the tank...
			v1 = Other.Location - Location;
			v2 = Vector(Rotation);
			dotproduct = v1 dot v2;

			if (dotproduct < 0.8660)  // beyond +/- 30 degrees?
			{
				// do no damage to Pawns that aren't at the front of the tank
				return false;
			}

			Momentum = Normal(Other.Location - Location);
			Momentum = ((Momentum * 500) / Other.Mass) + (Velocity * 0.25);

			Other.TakeDamage(10000, Instigator, Other.Location, Momentum, class'DamageRunOver');
		}

		return false;
	}

	return true;  // don't allow this vehicle to encroach on Other
}

// RanInto() called for encroaching actors which successfully moved the other actor out of the way
event RanInto(Actor Other)
{
	local vector v1, v2;
	local float dotproduct;
	local float Speed;
	local vector Momentum;

	if (Pawn(Other) == None || gbxSVehicle(Other) != None || Other == Instigator || Other.Role != ROLE_Authority)
		return;

	if ( (Pawn(Other) != None) && SameTeamAs(Pawn(Other)) && !bCrushFriendlyPawns)
	{
		// do no damage to Pawns on our team, push them instead, EncroachingOn will crush them if they can't be pushed away
		return;
	}

	// do a dot product check to see if the Pawn is in front of the tank...
	v1 = Other.Location - Location;
	v2 = Vector(Rotation);
	dotproduct = v1 dot v2;

	if (dotproduct < 0.8660)  // beyond +/- 30 degrees?
	{
		// do no damage to Pawns that aren't at the front of the tank
		return;
	}

	Speed = VSize(Velocity);

	if (Speed > MinRunOverSpeed)
	{
		Momentum = Normal(Other.Location - Location);
		Momentum = ((Momentum * 500) / Other.Mass) + (Velocity * 0.25);

		Other.TakeDamage(10000, Instigator, Other.Location, Momentum, class'DamageRunOver');
	}
}


function KDriverEnter(Pawn P)
{
    Super.KDriverEnter(P);

	Driver.bHidden = true;

    SVehicleUpdateParams();
}

function bool KDriverLeave(bool bForceLeave)
{
	local bool result;

	Driver.bHidden = false;

	result = Super.KDriverLeave(bForceLeave);

	return result;
}

function ClientKDriverLeave(PlayerController PC)
{
	Super.ClientKDriverLeave(PC);
}

function VehicleFire(bool bWasAltFire)
{
	Super.VehicleFire(bWasAltFire);
}

function VehicleCeaseFire(bool bWasAltFire)
{
	Super.VehicleCeaseFire(bWasAltFire);
}

simulated function PlayMainGunFiringAnim(int TankTurretYaw)
{
	local int TurretYawBlend;
	local float percent;

	TurretYawBlend = TankTurretYaw & 65535;

	if (TurretYawBlend < 16384)
	{
		// front and left
		AnimBlendParams(MAINGUN_ANIM_CHAN1, 1.0);

		if (IsHatchClosed())
			PlayAnim(MainFireFrontHatchClosed, 1.0, 0.0, MAINGUN_ANIM_CHAN1);
		else
			PlayAnim(MainFireFrontHatchOpen, 1.0, 0.0, MAINGUN_ANIM_CHAN1);

		percent = float(TurretYawBlend) / 16384.0f;

		AnimBlendParams(MAINGUN_ANIM_CHAN2, percent);

		if (IsHatchClosed())
			PlayAnim(MainFireLeftHatchClosed, 1.0, 0.0, MAINGUN_ANIM_CHAN2);
		else
			PlayAnim(MainFireLeftHatchOpen, 1.0, 0.0, MAINGUN_ANIM_CHAN2);
	}
	else if (TurretYawBlend < 32768)
	{
		// left and rear
		AnimBlendParams(MAINGUN_ANIM_CHAN1, 1.0);

		if (IsHatchClosed())
			PlayAnim(MainFireLeftHatchClosed, 1.0, 0.0, MAINGUN_ANIM_CHAN1);
		else
			PlayAnim(MainFireLeftHatchOpen, 1.0, 0.0, MAINGUN_ANIM_CHAN1);

		percent = float(TurretYawBlend - 16384) / 16384.0f;

		AnimBlendParams(MAINGUN_ANIM_CHAN2, percent);

		if (IsHatchClosed())
			PlayAnim(MainFireRearHatchClosed, 1.0, 0.0, MAINGUN_ANIM_CHAN2);
		else
			PlayAnim(MainFireRearHatchOpen, 1.0, 0.0, MAINGUN_ANIM_CHAN2);
	}
	else if (TurretYawBlend < 49152)
	{
		// right and rear
		AnimBlendParams(MAINGUN_ANIM_CHAN1, 1.0);

		if (IsHatchClosed())
			PlayAnim(MainFireRearHatchClosed, 1.0, 0.0, MAINGUN_ANIM_CHAN1);
		else
			PlayAnim(MainFireRearHatchOpen, 1.0, 0.0, MAINGUN_ANIM_CHAN1);

		percent = float(TurretYawBlend - 32768) / 16384.0f;

		AnimBlendParams(MAINGUN_ANIM_CHAN2, percent);

		if (IsHatchClosed())
			PlayAnim(MainFireRightHatchClosed, 1.0, 0.0, MAINGUN_ANIM_CHAN2);
		else
			PlayAnim(MainFireRightHatchOpen, 1.0, 0.0, MAINGUN_ANIM_CHAN2);
	}
	else
	{
		// front and right
		AnimBlendParams(MAINGUN_ANIM_CHAN1, 1.0);

		if (IsHatchClosed())
			PlayAnim(MainFireRightHatchClosed, 1.0, 0.0, MAINGUN_ANIM_CHAN1);
		else
			PlayAnim(MainFireRightHatchOpen, 1.0, 0.0, MAINGUN_ANIM_CHAN1);

		percent = float(TurretYawBlend - 49152) / 16384.0f;

		AnimBlendParams(MAINGUN_ANIM_CHAN2, percent);

		if (IsHatchClosed())
			PlayAnim(MainFireFrontHatchClosed, 1.0, 0.0, MAINGUN_ANIM_CHAN2);
		else
			PlayAnim(MainFireFrontHatchOpen, 1.0, 0.0, MAINGUN_ANIM_CHAN2);
	}
}

simulated function BlowUp(vector HitLocation, optional bool bDoNoDamage)
{
	if (bDoNoDamage)
	{
		HurtRadius(0, 0, CannonDamageType, 0, HitLocation );
	}
	else
	{
		HurtRadius(DamageMax, DamageRadius, CannonDamageType, MomentumTransfer, HitLocation );
	}

	if ( Role == ROLE_Authority )
		MakeNoise(1.0);
}

function PrepareToMount()
{
	//turn off all blending of firing animations (otherwise it interferes with machine gun 9 point blending
	AnimBlendParams(MAINGUN_ANIM_CHAN1, 0.0);
	AnimBlendParams(MAINGUN_ANIM_CHAN2, 0.0);
}

function CompleteMount()
{
}

simulated function Explosion(vector HitLocation, optional bool bDoNoDamage)
{
	local Controller C;
	local vector OffsetMag, OffsetRate;
	local IImpactManager ImpactMgr;
	local Material FloorMat;
	local Vector HitLoc, HitNormal;
	local gbxMessage ExplosionMsg;

	local float AirBurstDistance, BurstDist;

	if ( Level.NetMode != NM_DedicatedServer )
	{
		Trace( HitLoc, HitNormal, HitLocation - Vect(0, 0, 4096), HitLocation, false,, FloorMat );

		AirBurstDistance = VSize(HitLocation - HitLoc);

		// Clear the floor material so the impact manager will understand the explosion as an air burst
		if( AirBurstDistance > AirBurstThreshold )
			FloorMat = None;

		ImpactMgr = class'ImpactManager'.static.GetInstance( Level.Outer, self );
		if (ImpactMgr != None)
			ImpactMgr.HandleExplosionImpact(self, FloorMat,	WC_Grenade, HitLocation, rotator( HitNormal ));

		// Suppress any units in the vicinity.
		ExplosionMsg = new( None ) class<gbxMessage>( DynamicLoadObject( "gbxAI.PerceptionGrenadeExplosion", class'Class' ));
		ExplosionMsg.bUseSenderLocation = false;
		ExplosionMsg.bHasLocation = true;
		ExplosionMsg.aLocation = None;
		ExplosionMsg.vLocation = HitLocation;
		ExplosionMsg.bBroadcastLOSBlocked = true;
		ExplosionMsg.bBroadcastRadially = true;
		ExplosionMsg.BroadcastRadius = 8.0 * DamageRadius;
		PostGBXMessage( ExplosionMsg );

		// shake the players a bit...
		OffsetMag = OffsetMagHorizontal * vect(1,1,0) + OffsetMagVertical * vect(0,0,1);
		OffsetRate = OffsetRateHorizontal * vect(1,1,0) + OffsetRateVertical * vect(0,0,1);
		for ( C=Level.ControllerList; C!=None; C=C.NextController )
		{
			if ( PlayerController(C) != None )
			{
				BurstDist = VSize(Location - PlayerController(C).ViewTarget.Location);

				if( BurstDist < ShakeRadius && BurstDist > HeavyTraumaRadius )
					C.ShakeView(ViewRollTime,RollMag,OffsetMag,RollRate,OffsetRate,OffsetIterations);
			}
		}
	}
	
	BlowUp( HitLocation, bDoNoDamage );
}

event bool CanBeAttackedBy( Weapon aWeapon )
{
	if (gbxWeapon(aWeapon) != None)
	{
		return gbxWeapon(aWeapon).bDamagesVehicles;
	}

	return false;
}

event bool CanBeMeleed()
{
	// Although I'd like to see them try!
	return false;
}

//---------------------------------------------------------
//	DoNinePointBlending
//---------------------------------------------------------
function DoNinePointBlending( NinePointDir Dir1, float BlendAlpha1, NinePointDir Dir2, float BlendAlpha2, optional bool fTorsoOnly )
{
	local Name Dir1Anim, Dir2Anim;

	if (BlendAlpha2 > 0.01) {
		AnimBlendParams(NINEPOINT_CHANNEL2, BlendAlpha2, 0.0f, 0, NinePointBlendBone);
	}
	if (BlendAlpha1 > 0.01) {
		AnimBlendParams(NINEPOINT_CHANNEL1, BlendAlpha1, 0.0f, 0, NinePointBlendBone);
	}
	
	// Dir1 denotes the first animation to blend.  The first animation
	// should be an "edge animation" (aligned with one of the cardinal
	// directions of up, down, left, or right).
	//
	// Dir2 denotes the second animation to blend.
	// It represents a "diagonal animation" (aligned with one
	// of the diagonal directions: e.g. up-left, down-right, etc.
	//
	switch(Dir1) {
		case NPD_UpLeft:
			Dir1Anim = LeftUpAnim;
			break;
		case NPD_UpCenter:
			Dir1Anim = ForwardUpAnim;
			break;
		case NPD_UpRight:
			Dir1Anim = RightUpAnim;
			break;
		//--------------
		case NPD_MidLeft:
			Dir1Anim = LeftLevelAnim;
			break;
		case NPD_MidCenter:
			Dir1Anim = ForwardLevelAnim;
			break;
		case NPD_MidRight:
			Dir1Anim = RightLevelAnim;
			break;
		//--------------
		case NPD_LowLeft:
			Dir1Anim = LeftDownAnim;
			break;
		case NPD_LowCenter:
			Dir1Anim = ForwardDownAnim;
			break;
		case NPD_LowRight:
			Dir1Anim = RightDownAnim;
			break;
	}

	switch(Dir2) {
		case NPD_UpLeft:
			Dir2Anim = LeftUpAnim;
			break;
		case NPD_UpCenter:
			Dir2Anim = ForwardUpAnim;
			break;
		case NPD_UpRight:
			Dir2Anim = RightUpAnim;
			break;
		//--------------
		case NPD_MidLeft:
			Dir2Anim = LeftLevelAnim;
			break;
		case NPD_MidCenter:
			Dir2Anim = ForwardLevelAnim;
			break;
		case NPD_MidRight:
			Dir2Anim = RightLevelAnim;
			break;
		//--------------
		case NPD_LowLeft:
			Dir2Anim = LeftDownAnim;
			break;
		case NPD_LowCenter:
			Dir2Anim = ForwardDownAnim;
			break;
		case NPD_LowRight:
			Dir2Anim = RightDownAnim;
			break;
	}

	// Play the new Dir1 animation if it has changed.
	if (Dir1Anim != CurNinePointAnim1) {
		CurNinePointAnim1 = Dir1Anim;
		LoopAnim(CurNinePointAnim1, 1.0, 0.1, NINEPOINT_CHANNEL1);
	}

	// Play the new Dir2 animation if it has changed.
	if (Dir2Anim != CurNinePointAnim2) {
		CurNinePointAnim2 = Dir2Anim;
		LoopAnim(CurNinePointAnim2, 1.0, 0.1, NINEPOINT_CHANNEL2);
	}
}

function Cue GetCuePlayerSayingMyName()
{
	if ( CommanderPawn != None )
		return CommanderPawn.GetCuePlayerSayingMyName();
	else
		return None;
}

function RemoveCornerPointsFromNavPointCaches()
{
	local UnitController UC;
	local int index, my_index;

	// loop through all UnitControllerAI actors and add this tanks TankCornerPoints to the cache...
	ForEach DynamicActors(class'UnitController', UC)
	{
		for (my_index = 0; my_index < 8; my_index++)
		{
			// go from the last array elements downwards since we are removing elements from the array (and they will be at the tail end)
			index = UC.FormationNavPointCache.Length - 1;
			while (index >= 0)
			{
				if (UC.FormationNavPointCache[index].NavPoint == MyCornerPoints[my_index])
				{
					UC.FormationNavPointCache.Remove( index, 1 );

					break;  // break out of while loop
				}

				index--;
			}
		}
	}
}

simulated event bool TargetFriendly( Vector aHitLoc, Pawn SourcePawn, bool bFiring )
{
	// anyone can shoot us!
	return false;
}

// GBX:PAD: If we are modifying this tanks health directly rather than through take damage, set up the smoke to
// emit if necessary.
simulated function RespawnSmoke()
{
	local vector RotX, RotY, RotZ;
	
	if (SmokeEmitter == None)  // no smoke yet?
	{
	    GetAxes(Rotation,RotX,RotY,RotZ);

		// spawn some smoke coming out of the tank...
		SmokeEmitter = spawn(class'TankSmoke', self,, Location + SmokeEmitterOffset.X * RotX + SmokeEmitterOffset.Y * RotY + SmokeEmitterOffset.Z * RotZ, Rotation);
		SmokeEmitter.SetBase(self);

		if (Health >= ((2 * Default.Health) / 3))
			SmokeEmitter.Emitters[0].Disabled = false;
		else if (Health >= ((1 * Default.Health) / 3))
			SmokeEmitter.Emitters[1].Disabled = false;
		else
			SmokeEmitter.Emitters[2].Disabled = false;
	}
	else
	{
		if (Health >= ((1 * Default.Health) / 3))
		{
			if (!SmokeEmitter.Emitters[0].Disabled)
			{
				SmokeEmitterDecayIndex = 0;
				SmokeEmitterDecayTime = Level.TimeSeconds + 0.1;
				SmokeEmitterDisableTime = Level.TimeSeconds + 5.0;
			}

			if (SmokeEmitter.Emitters[1].Disabled)
				SmokeEmitter.Emitters[1].Disabled = false;
		}
		else
		{
			if (!SmokeEmitter.Emitters[0].Disabled)
			{
				SmokeEmitterDecayIndex = 0;
				SmokeEmitterDecayTime = Level.TimeSeconds + 0.1;
				SmokeEmitterDisableTime = Level.TimeSeconds + 5.0;
			}
			else if (!SmokeEmitter.Emitters[1].Disabled)
			{
				SmokeEmitterDecayIndex = 1;
				SmokeEmitterDecayTime = Level.TimeSeconds + 0.1;
				SmokeEmitterDisableTime = Level.TimeSeconds + 5.0;
			}

			if (SmokeEmitter.Emitters[2].Disabled)
				SmokeEmitter.Emitters[2].Disabled = false;
		}

	}
}

simulated function bool ContainsPawn(gbxPawn SomeOtherPawn)
{
	// does this pawn contain some other pawn (like tank commanders riding in tanks?)...
	if (SomeOtherPawn == CommanderPawn)
		return true;

	return false;
}


defaultproperties
{
	bDrawVehicleShadow=true

	bTurnInPlace=true
	bCanStrafe=true

	EntryPosition=(X=0,Y=0,Z=-200)
	EntryRadius=500.0

	FPCamPos=(X=-10,Y=-30,Z=140)
	TPCamLookat=(X=-100,Y=0,Z=100)
	TPCamDistance=900

	bDrawDriverInTP=true
	bDrawMeshInFP=true

	MaxViewYaw=16000
	MaxViewPitch=16000

	HoverSoftness=0.05
	HoverPenScale=1.5
	HoverCheckDist=65

	UprightStiffness=500
	UprightDamping=300

	MaxThrust=65.0
	MaxSteerTorque=100.0
	ForwardDampFactor=0.1
	LateralDampFactor=10.0
	ParkingDampFactor=0.8
	SteerDampFactor=100.0
	PitchTorqueFactor=0.0
	PitchDampFactor=0.0
	BankTorqueFactor=0.0
	BankDampFactor=0.0
	TurnDampFactor=0.0
	DecelerateDampFactor=0.7
	SteerDecayDampFactor=400.0

	InvertSteeringThrottleThreshold=-0.1
	VehicleMass=12.0

	GroundSpeed=520
	TrackVelocityScale=153

	Begin Object Class=KarmaParamsRBFull Name=KParamsTank
		KStartEnabled=True
		KFriction=0.5
		KLinearDamping=0
		KAngularDamping=0
		bKNonSphericalInertia=False
		bHighDetailOnly=False
		bClientOnly=False
		bKDoubleTickRate=True
		bKStayUpright=True
		bKAllowRotate=True
		KInertiaTensor(0)=1.3
		KInertiaTensor(1)=0.0
		KInertiaTensor(2)=0.0
		KInertiaTensor(3)=4.0
		KInertiaTensor(4)=0.0
		KInertiaTensor(5)=4.5
		KCOMOffset=(X=0.0,Y=0.0,Z=0.0)
		Name="KParamsTank"
	End Object
	KParams=KarmaParams'KParamsTank'

	DamageMax=1000.0
	DamageRadius=500.0
	MomentumTransfer=100000.0
	CannonDamageType=class'DamageTankCannon'

	AirBurstThreshold=150
    ShakeRadius=2000.000000
	ViewRollTime=0.200000
	RollMag=20.000000
	RollRate=100.000000
	OffsetMagVertical=20.000000
	OffsetRateVertical=800.000000
	OffsetMagHorizontal=20.000000
	OffsetRateHorizontal=800.000000
	OffsetIterations=10.000000
	HeavyTraumaRadius=384.0

	bTriggerOnDeathFired=false
	bInitCommander=false

	bCrushFriendlyPawns=false

	PushForce=10.0
	bNoSound=false

	TankDeathEmitterLifetime=5.0

	FireDecayStartTime=30.0
	FireDecayRate=0.95

	BlowupDamageMax=200.0

	FireBurningSoundName="FIRES.Vehicle"

	m_fAmbientSoundFadeInTime=0.5f
	m_fAmbientSoundFadeOutTime=0.5f

	TrackSplashEmitterClass=class'WaterSplashLarge'
}
class TankM10_ extends Tank;


var	int		TurretYaw;
var	int		PreviousTurretYaw;
var	int		OldTurretYaw;  // to decide if turret rotating sounds need to be played
var	int		MainGunPitch;

var	name	TurretBoneName;
var	name	MainGunBoneName;
var	name	MainGunMuzzleBoneName;

var float 		MainGunTraceAccuracy;
var class<Projector> ExplosionDecal;
var float		ExploWallOut;	// distance to move explosions out from wall

var class<InstantFire> MainGunFireModeClass;
var InstantFire		MainGunFireMode;
var Ammunition 		MainGunAmmo;
var class<Emitter>	MainGunFlashEmitterClass;
var class<Emitter>	MainGunSmokeEmitterClass;
var vector		MainGunEmitterOffset;

var		float	fMainGunReFireTime;
var		float	fMainGunReFireDelay;

var		float	TurretRotationSpeed;	// degrees per second
var		float	MainGunRotationSpeed;	// degrees per second
var		float	MainGunUpwardFireArc;	// in degrees
var		float	MainGunDownwardFireArc;	// in degrees

var Cue		MainGunFireSound;
var string	MainGunFireSoundName;

var Cue		TurretRotatingSound;  // turret rotating sound is looped
var string	TurretRotatingSoundName;
var int		TurretRotatingSoundHandle;
var Cue		TurretStopSound;
var string	TurretStopSoundName;
var float	TurretStartTime;
var float	TurretStopTime;

// player usable 50 cal. machine gun...
var WeapUSM10_50cal WeapUSM10_50calMachineGun;
var vector Weap50calOffset;
var AttachedPart ExtendedAttachment_50cal;
var string ExtendedAttachmentMeshName;

var bool 	bHasCreatedTriggers;
var gbxContextUseTrigger MachineGunRearTrigger;	// Trigger to allow the player to mount the machine gun.
var vector	MachineGunRearTriggerOffset;
var float	MachineGunRearTriggerRadius;
var gbxContextUseTrigger MachineGunTurretTrigger;	// Trigger to allow the player to mount the machine gun.
var vector	MachineGunTurretTriggerOffset;
var float	MachineGunTurretTriggerRadius;

var array<name> CommanderStandingIdleAnims;
var array<name> CommanderSittingIdleAnims;
var name CommanderStandingToSittingAnim;
var name CommanderSittingToStandingAnim;

var TankM10LoaderPawn M10LoaderPawn;
var vector TankLoaderPawnOffset;
var rotator TankLoaderPawnRotation;

var() CharacterSetup.EUSCharacterTypes	LoaderUSCharType;
var string LoaderAnimPkg;
var array<name> LoaderIdleAnims;
var name LoaderFireAnim;
var name LoaderReloadAnim;
var name LoaderDeathAnim;

var TankM10GunnerPawn TankGunnerPawn;
var vector TankGunnerPawnOffset;
var rotator TankGunnerPawnRotation;

var() CharacterSetup.EUSCharacterTypes	GunnerUSCharType;
var string GunnerAnimPkg;
var name GunnerIdleAnim;


simulated function PreBeginPlay()
{
	Mesh = Mesh( DynamicLoadObject( "k_vehicle_us.m10_tank", class'Mesh' ) );

	super.PreBeginPlay();
}

simulated function SetupTracks()
{
	Skins.Length = 4;
	Skins[0] = GbxShaderMaterial( DynamicLoadObject( "t_military_us.Vehicle.us_m10_gbx", class'GbxShaderMaterial' ) );
	Skins[1] = GbxShaderMaterial( DynamicLoadObject( "t_military_us.Vehicle.us_m10_alpha_gbx", class'GbxShaderMaterial' ) );
	Skins[2] = GbxShaderMaterial( DynamicLoadObject( "t_military_us.Vehicle.us_m10_trackleft_gbx", class'GbxShaderMaterial' ) );
	Skins[3] = GbxShaderMaterial( DynamicLoadObject( "t_military_us.Vehicle.us_m10_trackright_gbx", class'GbxShaderMaterial' ) );

	LeftTrackTextureIndex = 2;
	RightTrackTextureIndex = 3;

	super.SetupTracks();
}

simulated function BeginPlay()
{
	SetPhysics(PHYS_Karma);
}

simulated function PostNetBeginPlay()
{
	local vector RotX, RotY, RotZ;
	local vector BoneLoc;

	Super.PostNetBeginPlay();

	MainGunFireMode = Spawn(MainGunFireModeClass, self);
	if (MainGunFireMode == None)
		Log(name $ ".PostNetBeginPlay() - Couldn't spawn MainGunFireMode!!!");
	else
	{
		MainGunAmmo = Spawn(MainGunFireMode.AmmoClass, MainGunFireMode);
	}

	ExtendedAttachment_50cal = Spawn( class'AttachedPart', self );
	ExtendedAttachment( ExtendedAttachment_50cal, 'mounted_mg', '50cal' );

    GetAxes(Rotation,RotX,RotY,RotZ);

	BoneLoc = GetBoneCoords(NinePointBlendBone).origin;
	WeapUSM10_50calMachineGun = spawn(class'WeapUSM10_50cal', self,, BoneLoc + Weap50calOffset.X * RotX + Weap50calOffset.Y * RotY + Weap50calOffset.Z * RotZ);
	WeapUSM10_50calMachineGun.SetBase(self);
	WeapUSM10_50calMachineGun.Tag = WeapUSM10_50calMachineGun.name;
	WeapUSM10_50calMachineGun.bHidden = true;

	WeapUSM10_50calMachineGun.SetMount(self);
	WeapUSM10_50calMachineGun.SetExtendedAttachment(ExtendedAttachment_50cal);
	WeapUSM10_50calMachineGun.SetAnims(ForwardLevelAnim, TankHatchClosedIdleAnim);

	CreateSounds();
}

function InitCommander()
{
	local TankCommanderPawnHitCylinder TCPHC;
	local int nHealth;

	if (bSpawnCommander)
	{
		CommanderPawn = spawn(class'TankM10CommanderPawn', self, TankCommanderTag);

		// Set up the commander's character type, which is used to determine his VoiceType for battle dialogue.
		if ( CommanderUSCharType != USCharNone )
		{
			CommanderPawn.CharacterSetupClass = class'CharacterSetupUSA';
			CommanderPawn.SetCharacterType( CommanderUSCharType );

			SetCharacterType( CommanderUSCharType );
		}

		CommanderPawn.SetVoiceType( CommanderPawn.GetCharacterVoiceType() );

		if (CommanderPawn != None)
		{
			AttachToBone( CommanderPawn, 'Commander' );

			CommanderPawn.SetRelativeRotation( TankCommanderPawnRotation );
			CommanderPawn.SetRelativeLocation( TankCommanderPawnOffset );

			CommanderPawn.SetM10CommanderAnims(CommanderAnimPkg, CommanderStandingIdleAnims, CommanderSittingIdleAnims,
											CommanderHitPulledInAnim, CommanderStandingToSittingAnim, CommanderSittingToStandingAnim,
											CommanderMoveOutAnim, CommanderTankBlownupAnim);

			PlayAnim(TankHatchOpenIdleAnim);  // play the open hatch animation on the tank

			if (!bTankCommaderInvulnerable)
			{
				TCPHC = spawn(class'TankCommanderPawnHitCylinder', self);

				AttachToBone( TCPHC, 'Commander' );

				TCPHC.SetRelativeRotation( TankCommanderPawnHitCylinderRotation );
				TCPHC.SetRelativeLocation( TankCommanderPawnHitCylinderOffset );
			}
			else
			{
				TCPHC = None;  // no hit cylinder, commander can't be hit
				CommanderPawn.bTankCommaderInvulnerable = true;
			}

			CommanderPawn.SetTankPawn(self, TCPHC);

			CommanderPawn.SetMainGunAnimChannels(MAINGUN_ANIM_CHAN1, MAINGUN_ANIM_CHAN2);

			// set the proper tank commander pawn health based on checkpoint value...
			nHealth = CommanderPawn.default.Health;

			// This is very slow, and has no meaning for MP anyways. So only do this stuff in SP games. 2004-12-02 JWS
			if (Level.NetMode == NM_Standalone)
			{
				if (Level.MissionManager.GetCheckpointPawnHealth(TankCommanderTag, nHealth))
				{
					if (nHealth <= 0)  // commander dead?
					{
						// since we know the tank is still alive (dead tanks don't reload at checkpoints), very quickly play the death animations...
						CommanderPawn.AddAnimToQueue(CommanderHitPulledInAnim, 9999, true, false, false, 10.0 /*FAST*/, 0.15);
						CommanderPawn.bHatchClosing = true;
						CommanderPawn.bHidePawn = false;  // don't hide the pawn when animation is done playing
						CommanderPawn.GotoState('Dying');
					}

					CommanderPawn.Health = nHealth;
				}
			}

		}

		M10LoaderPawn = spawn(class'TankM10LoaderPawn', self);

		// Set up the loader's character type, which is used to determine his VoiceType for battle dialogue.
		if ( LoaderUSCharType != USCharNone )
		{
			M10LoaderPawn.CharacterSetupClass = class'CharacterSetupUSA';
			M10LoaderPawn.SetCharacterType( LoaderUSCharType );
		}

		M10LoaderPawn.SetVoiceType( M10LoaderPawn.GetCharacterVoiceType() );

		if (M10LoaderPawn != None)
		{
			AttachToBone( M10LoaderPawn, 'Loader' );

			M10LoaderPawn.SetRelativeRotation( TankLoaderPawnRotation );
			M10LoaderPawn.SetRelativeLocation( TankLoaderPawnOffset );

			M10LoaderPawn.SetM10LoaderAnims(LoaderAnimPkg, LoaderIdleAnims, LoaderFireAnim, LoaderReloadAnim, LoaderDeathAnim);
		}

		TankGunnerPawn = spawn(class'TankM10GunnerPawn', self);

		// Set up the loader's character type, which is used to determine his VoiceType for battle dialogue.
		if ( GunnerUSCharType != USCharNone )
		{
			TankGunnerPawn.CharacterSetupClass = class'CharacterSetupUSA';
			TankGunnerPawn.SetCharacterType( GunnerUSCharType );
		}

		TankGunnerPawn.SetVoiceType( TankGunnerPawn.GetCharacterVoiceType() );

		if (TankGunnerPawn != None)
		{
			AttachToBone( TankGunnerPawn, 'Gunner' );

			TankGunnerPawn.SetRelativeRotation( TankGunnerPawnRotation );
			TankGunnerPawn.SetRelativeLocation( TankGunnerPawnOffset );

			TankGunnerPawn.SetM10GunnerAnim(GunnerAnimPkg, GunnerIdleAnim);
		}
	}
	else
	{
		PlayAnim(TankHatchClosedIdleAnim);
	}
}

simulated function CreateSounds()
{
	if ( MainGunFireSoundName != "" )
		MainGunFireSound = LoadSound( MainGunFireSoundName );
	if ( EngineIdleSoundName != "" )
		EngineIdleSound = Sound( DynamicLoadObject( EngineIdleSoundName, class'Sound' ) );
	if ( DrivingSoundName != "" )
		DrivingSound = Sound( DynamicLoadObject( DrivingSoundName, class'Sound' ) );

	if ( TurretRotatingSoundName != "" )
		TurretRotatingSound = LoadSound( TurretRotatingSoundName );
	if ( TurretStopSoundName != "" )
		TurretStopSound = LoadSound( TurretStopSoundName );
}

function CreateTriggers()
{
	local vector RotX, RotY, RotZ;
	local vector Offset;

    GetAxes(Rotation,RotX,RotY,RotZ);

	Offset = MachineGunRearTriggerOffset.X * RotX + MachineGunRearTriggerOffset.Y * RotY + MachineGunRearTriggerOffset.Z * RotZ;
	MachineGunRearTrigger = spawn(class'gbxContextUseTrigger', self,, Location + Offset);
	MachineGunRearTrigger.SetBase(self);
	MachineGunRearTrigger.SetCollisionSize(MachineGunRearTriggerRadius, 50 );
	MachineGunRearTrigger.SetCollision(true, false, false);
	MachineGunRearTrigger.m_eUseType=UseTankMachineGun;
	MachineGunRearTrigger.Event = WeapUSM10_50calMachineGun.Tag;
	MachineGunRearTrigger.bHidden = true;
	if (bDisablePlayerUseableTriggers)
		MachineGunRearTrigger.bDisabled = true;

	Offset = MachineGunTurretTriggerOffset.X * RotX + MachineGunTurretTriggerOffset.Y * RotY + MachineGunTurretTriggerOffset.Z * RotZ;
	MachineGunTurretTrigger = spawn(class'gbxContextUseTrigger', self,, Location + Offset);
	MachineGunTurretTrigger.SetBase(self);
	MachineGunTurretTrigger.SetCollisionSize(MachineGunTurretTriggerRadius, 50);
	MachineGunTurretTrigger.SetCollision(true, false, false);
	MachineGunTurretTrigger.m_eUseType=UseTankMachineGun;
	MachineGunTurretTrigger.Event = WeapUSM10_50calMachineGun.Tag;
	MachineGunTurretTrigger.bHidden = true;
	if (bDisablePlayerUseableTriggers)
		MachineGunTurretTrigger.bDisabled = true;

	WeapUSM10_50calMachineGun.SetTriggers(MachineGunRearTrigger, MachineGunTurretTrigger);
}

function MatchStarting()
{
	local MeshAnimation	aMeshAnim;

	Super.MatchStarting();

	ExtendedAttachment( ExtendedAttachment_50cal, 'mounted_mg', '50cal' );

	aMeshAnim = MeshAnimation( DynamicLoadObject( ExtendedAttachmentMeshName, class'MeshAnimation' ) );
	if ( aMeshAnim != None )
	{
		if ( MeshAnim != None )
			UnlinkSkelAnim( MeshAnim, false );
		if (LinkSkelAnim( aMeshAnim ))
		{
			MeshAnim = aMeshAnim;
		}
		bInitializeAnimation = false;
	}

	RestartAnimQueue();
}

simulated function Destroyed()
{
	Log( name $ ".(TankM10_).Destroyed()", 'Tank' );

	if (MainGunFireMode != None)
		MainGunFireMode.Destroy();

	if (MainGunAmmo != None)
		MainGunAmmo.Destroy();

	if (WeapUSM10_50calMachineGun != None)
		WeapUSM10_50calMachineGun.Destroy();

	if (MachineGunRearTrigger != None)
		MachineGunRearTrigger.Destroy();
	if (MachineGunTurretTrigger != None)
		MachineGunTurretTrigger.Destroy();

	if (ExtendedAttachment_50cal != None)
		ExtendedAttachment_50cal.Destroy();

	if (M10LoaderPawn != None)
		M10LoaderPawn.Destroy();

	if (TankGunnerPawn != None)
		TankGunnerPawn.Destroy();

	super.Destroyed();
}

simulated function Tick(float DeltaTime)
{
	super.Tick( DeltaTime );

	if (!bHasCreatedTriggers)
	{
		CreateTriggers();
		bHasCreatedTriggers = true;
	}

	if (Health <= 0)  // died?
	{
		bNoSound = false;  // make sure sounds aren't played anymore on this tank

		AmbientSound = None;
		if (MyBulletListener != None)
			MyBulletListener.AmbientSound = None;

		if (TurretRotatingSoundHandle != 0)
		{
			StopSound( TurretRotatingSoundHandle, 0.1 );
			TurretRotatingSoundHandle = 0;
		}

		return;
	}

//	if (Rise > 0)
//		TurretRotate(DeltaTime, true);  // counter-clockwise
//	else if (Rise < 0)
//		TurretRotate(DeltaTime, false);  // clockwise

	if (Rise > 0)
		MainGunRotate(DeltaTime, true);  // up
	else if (Rise < 0)
		MainGunRotate(DeltaTime, false);  // down

//	if (bVehicleIsAltFiring && (fCoaxGunReFireTime < Level.Timeseconds))
//	{
//		FireCoaxGun();
//	}

	if (abs(TurretYaw - OldTurretYaw) > 500)  // has turret moved a large amount?
	{
		if (TurretStartTime < 0)  // has start time not been set yet?
		{
			TurretStartTime = Level.TimeSeconds;  // set it
		}
		else if (TurretStartTime + 0.1 < Level.TimeSeconds)  // has it been going for at least 1/10th a second?
		{
			if (TurretRotatingSoundHandle == 0)
			{
				TurretRotatingSoundHandle = PlaySoundCue( TurretRotatingSound, SLOT_NONE, TransientSoundVolume,,,,false);
			}
			OldTurretYaw = TurretYaw;
			TurretStopTime = -1.0f;  // hasn't stopped yet
		}
	}
	else if ((TurretRotatingSoundHandle != 0) && (TurretYaw == PreviousTurretYaw))  // turret is rotating and turret might have stopped...
	{
		if (TurretStopTime < 0)  // has stop time not been set yet?
		{
			TurretStopTime = Level.TimeSeconds;
		}
		else if (TurretStopTime + 0.1 < Level.TimeSeconds)  // has it been stopped at least 1/10th of a second?
		{
			if (TurretRotatingSoundHandle != 0)
			{
				StopSound( TurretRotatingSoundHandle );
				TurretRotatingSoundHandle = 0;

				PlaySoundCue( TurretStopSound, SLOT_NONE, TransientSoundVolume,,,,false);
				TurretStartTime = -1.0f;  // hasn't started yet
			}
		}
	}

	PreviousTurretYaw = TurretYaw;
}


function TakeDamage(int Damage, Pawn instigatedBy, Vector Hitlocation, Vector Momentum, class<DamageType> DamageType, optional name HitBoxName)
{
	local int InitialHealth;
	local WargamePawn WP;

	InitialHealth = Health;

//	Log(name $ ".TakeDamage - Damage = " $ Damage $ "  instigatedBy = " $ instigatedBy.name $ ", DamageType.name = " $ DamageType.name, 'Tank');

	super.TakeDamage(Damage, instigatedBy, Hitlocation, Momentum, DamageType, HitBoxName);

	if ((InitialHealth > 0) && (Health <= 0))  // did we just now die?
	{
		// swap the skins out for the damaged versions...
		Skins[0] = GbxShaderMaterial( DynamicLoadObject( "t_military_us.Vehicle.us_m10_dmg_gbx", class'GbxShaderMaterial' ) );
		Skins[1] = GbxShaderMaterial( DynamicLoadObject( "t_military_us.Vehicle.us_m10_alpha_dmg_gbx", class'GbxShaderMaterial' ) );
		Skins[2] = GbxShaderMaterial( DynamicLoadObject( "t_military_us.Vehicle.us_m10_trackleft_dmg_gbx", class'GbxShaderMaterial' ) );
		Skins[3] = GbxShaderMaterial( DynamicLoadObject( "t_military_us.Vehicle.us_m10_trackright_dmg_gbx", class'GbxShaderMaterial' ) );

		if (M10LoaderPawn != None)
			M10LoaderPawn.KillLoader(instigatedBy, DamageType);

		// if the player is using the machine gun, kick them off before removing the triggers...
		WP = WargamePawn( Level.GetLocalPlayerController().Pawn );

		if ((WP != None) && (WP.bIsManningTurret))
		{
			WP.PrepareTurretDismount();
			WP.CompleteTurretDismount();
			WP.StartGoingToStand(true);  // don't play the animation
		}

		if (MachineGunRearTrigger != None)
		{
			MachineGunRearTrigger.Destroy();
			MachineGunRearTrigger = None;
		}
		if (MachineGunTurretTrigger != None)
		{
			MachineGunTurretTrigger.Destroy();
			MachineGunTurretTrigger = None;
		}
	}
}

simulated function rotator AdjustAimMainGun()
{
	local rotator MainGunRot;

	MainGunRot.Pitch = (Rotation.Pitch + MainGunPitch) & 65535;
	MainGunRot.Yaw = (Rotation.Yaw - TurretYaw) & 65535;
	MainGunRot.Roll = 0;

	return MainGunRot;
}

simulated function FireMainGun()
{
	local vector MainGunLoc;
	local rotator MainGunRot;
	local vector RotX, RotY, RotZ;
	local float YOffset, ZOffset;
	local vector EndTrace, X;
	local int AimError;
	local rotator AdjustedAim;
	local gbxTankShell TankShell;

	MainGunLoc = GetTagCoords( MainGunMuzzleBoneName ).origin;

	MainGunRot.Pitch = MainGunPitch;
	MainGunRot.Yaw = -TurretYaw;
	MainGunRot.Roll = 0;

	MainGunRot = Rotation + MainGunRot;

    GetAxes(MainGunRot,RotX,RotY,RotZ);

	MainGunLoc = MainGunLoc + MainGunEmitterOffset.X * RotX + MainGunEmitterOffset.Y * RotY + MainGunEmitterOffset.Z * RotZ;

	// spawn main gun muzzle flash emitter...
	spawn(MainGunFlashEmitterClass, None,, MainGunLoc, MainGunRot);

	MainGunRot.Pitch = 0;  // ignore main gun pitch for main gun smoke and dust emitter
	MainGunRot.Yaw = -TurretYaw;
	MainGunRot.Roll = 0;

	MainGunRot = Rotation + MainGunRot;

	// spawn main gun smoke and dust emitter...
	spawn(MainGunSmokeEmitterClass, None,, MainGunLoc, MainGunRot);

	YOffset = 0.0f;
	ZOffset = 0.0f;

	AimError = 10;

	AdjustedAim = AdjustAimMainGun();
	EndTrace = MainGunLoc + (YOffset + MainGunTraceAccuracy * (FRand() - 0.5 ) ) * RotY * 1000
		+ (ZOffset + MainGunTraceAccuracy * (FRand() - 0.5 )) * RotZ * 1000;
	X = vector(AdjustedAim);
	EndTrace += (10000 * X);

	AdjustedAim = rotator(EndTrace - MainGunLoc);

	TankShell = Spawn( class'gbxTankShell', self,, MainGunLoc, AdjustedAim );
	TankShell.Instigator = self;

	PlaySoundCue( MainGunFireSound, SLOT_NONE, TransientSoundVolume,,,,false);

	PlayMainGunFiringAnim(TurretYaw);

	if (M10LoaderPawn != None)
		M10LoaderPawn.GotoState('FireThenReload');
}

function KDriverEnter(Pawn P)
{
    Super.KDriverEnter(P);

	AmbientSound = EngineIdleSound;
}

function bool KDriverLeave(bool bForceLeave)
{
	local bool result;

	result = Super.KDriverLeave(bForceLeave);

	AmbientSound = None;
	if (MyBulletListener != None)
		MyBulletListener.AmbientSound = None;

	return result;
}

simulated function VehicleFire(bool bWasAltFire)
{
	super.VehicleFire( bWasAltFire );

	if (!bWasAltFire)  // fire the main gun
	{
		if (fMainGunReFireTime < Level.TimeSeconds)
		{
			fMainGunReFireTime = Level.TimeSeconds + fMainGunReFireDelay;

			FireMainGun();
		}
	}

//	if (bWasAltFire)  // fire the machine gun
//	{
//		CoaxGunSoundHandle = PlaySound( CoaxGunFireLoopSound, SLOT_NONE, TransientSoundVolume,,,,false);
//
//		MuzzleFlash = CoaxFireMode.GetMuzzleFlash();
//
//		if ( MuzzleFlash.IsA( 'gbxMuzzleFlash' ) )
//			gbxMuzzleFlash(MuzzleFlash).FireButtonPressed();
//
//		FireCoaxGun();
//	}
}

simulated function VehicleCeaseFire(bool bWasAltFire)
{
	super.VehicleCeaseFire( bWasAltFire );

	if (bWasAltFire)  // stop the machine gun
	{
	}

//	if (bWasAltFire)  // stop the machine gun
//	{
//		StopSound( CoaxGunSoundHandle );
//		PlaySound( CoaxGunFireOnceSound, SLOT_NONE, TransientSoundVolume,,,,false);
//
//		MuzzleFlash = CoaxGunFireMode.GetMuzzleFlash();
//
//		if ( MuzzleFlash.IsA( 'gbxMuzzleFlash' ) )
//			gbxMuzzleFlash(MuzzleFlash).FireButtonReleased();
//	}
}


simulated function TurretRotate(float DeltaTime, bool bCounterClockwise)
{
	local float YawOffset;
	local rotator TurretRot;

	// Rotate CW or CCW...
	YawOffset = (TurretRotationSpeed * DeltaTime / 360.0) * 65536;

	if (bCounterClockwise)
		TurretYaw = (TurretYaw + int(YawOffset)) & 65535;
	else
		TurretYaw = (TurretYaw - int(YawOffset)) & 65535;

	TurretRot.Pitch = TurretYaw;
	TurretRot.Yaw = 0;
	TurretRot.Roll = 0;

	SetBoneRotation(TurretBoneName, TurretRot, 0, 1.0);
}

simulated function MainGunRotate(float DeltaTime, bool bUp)
{
	local float MaxPitchUp, MaxPitchDown;
	local float PitchOffset;
	local rotator MainGunRot;

	MaxPitchUp = (MainGunUpwardFireArc / 360.0) * 65536;
	MaxPitchDown = (MainGunDownwardFireArc / 360.0) * 65536;
	PitchOffset = (MainGunRotationSpeed * DeltaTime / 360.0) * 65536;

	if (bUp)
		MainGunPitch = MainGunPitch + int(PitchOffset);
	else
		MainGunPitch = MainGunPitch - int(PitchOffset);

	MainGunPitch = Clamp(MainGunPitch, -MaxPitchDown, MaxPitchUp);

	MainGunRot.Pitch = 0;
	MainGunRot.Yaw = -MainGunPitch;
	MainGunRot.Roll = 0;

	SetBoneRotation(MainGunBoneName, MainGunRot, 0, 1.0);
}

// do stuff necessary to allow player to mount this tank...
function PrepareToMount()
{
	if (Controller == None)  // if no controller...
	{
		// reset the turret and main gun to straight forward...
		TurretYaw = 0;
		SetBoneRotation(TurretBoneName, rot(0,0,0), 0, 1.0);

		MainGunPitch = 0;
		SetBoneRotation(MainGunBoneName, rot(0,0,0), 0, 1.0);
	}

	if (CommanderPawn != None)
		CommanderPawn.PrepareToMount();

	Super.PrepareToMount();
}

function CompleteMount()
{
	if (CommanderPawn != None)
		CommanderPawn.CompleteMount();
}

simulated function PlayMainGunFiringAnim(int TankTurretYaw)
{
	if (WeapUSM10_50calMachineGun.IsInUse())
		return;  // don't play firing animation if player is using the machine gun

	Super.PlayMainGunFiringAnim(TankTurretYaw);
}


defaultproperties
{
	DrawType=DT_Mesh
	Mesh=None  // use DymamicLoadObject instead
	EditorMeshName="k_vehicle_us.m10_tank"
    Physics=PHYS_None

	Health=4
	CollisionHeight=2.0
	CollisionRadius=2.0
	VehicleCollisionHeight=128.0
	VehicleCollisionRadius=310.0
	BaseEyeHeight=180
	EyeHeight=180
	bTurnInPlace=true
	bCanStrafe=true

	MinDamageAmount=300
	HitPointsFront=1
	HitPointsSide=2
	HitPointsRear=3
	HitPointsTurret=2

	FPCamPos=(X=-10,Y=-30,Z=140)
	TPCamLookat=(X=-100,Y=0,Z=100)
	TPCamDistance=1200

	bDrawDriverInTP=true
	bDrawMeshInFP=true

	MaxViewYaw=16000
	MaxViewPitch=16000

	DrivePos=(X=105,Y=-50,Z=85)
	DriveRot=(Pitch=0,Yaw=0,Roll=0)

	ExitPositions(0)=(Y=-415.000000,Z=100.000000)
	ExitPositions(1)=(Y=415.000000,Z=100.000000)

	TurretBoneName="Turret"
	MainGunBoneName="main_gun"
	MainGunMuzzleBoneName="main_gun_muzzle"

	MainGunFireModeClass=class'gbxInventory.FireM10_MainGun'
	MainGunTraceAccuracy=+0.1

	MainGunFlashEmitterClass=class'gbxEffects.MuzzleFlashStuartTankMainGun'
	MainGunSmokeEmitterClass=class'gbxEffects.TankStuartMainGunSmokeAndDust'

	MainGunEmitterOffset=(X=10,Y=0,Z=0)

	//GBX:PAD: This sound file is bad, so until it gets fixed, it is messing up the creating of linear load files.
//	ImpactSound=Sound'explosions.close_artillery_d'
	ExplosionDecal=class'TankProjectileScorch'
	ExploWallOut=1.0

	// sounds
	MainGunFireSoundName="V_TANK_SHERMAN.turret_fire"

	EngineIdleSoundName="V_TANK_STUART.IDLE"
	DrivingSoundName="V_TANK_STUART.DRIVING_LOOP"

	TurretRotatingSoundName="V_TANK_SHERMAN.turret_loop"
	TurretStopSoundName="V_TANK_SHERMAN.turret_stop"

	// tank driving max pitch speed
	MaxPitchSpeed=200.0

	fMainGunReFireDelay=6.0

	TurretRotationSpeed=45.0

	MainGunRotationSpeed=36.0
	MainGunUpwardFireArc=30.0
	MainGunDownwardFireArc=10.0

	// thruster positions left to right, front to back...
	Thrusters(0)=(BoneName="front_left",ThrusterOffset=63.0,bHasSuspension=false,NumWheels=1,WheelIndexes[0]=0,bChecksForWater=true)
	Thrusters(1)=(BoneName="front_right",ThrusterOffset=63.0,bHasSuspension=false,NumWheels=1,WheelIndexes[0]=1,bChecksForWater=true)
	Thrusters(2)=(BoneName="track_left_1",ThrusterOffset=45.0,bHasSuspension=true,SuspensionTravel=15.0,SuspensionTravelRate=100.0,NumWheels=1,WheelIndexes[0]=2)
	Thrusters(3)=(BoneName="track_right_1",ThrusterOffset=45.0,bHasSuspension=true,SuspensionTravel=15.0,SuspensionTravelRate=100.0,NumWheels=1,WheelIndexes[0]=3)
	Thrusters(4)=(BoneName="track_left_2",ThrusterOffset=45.0,bHasSuspension=true,SuspensionTravel=15.0,SuspensionTravelRate=100.0,NumWheels=1,WheelIndexes[0]=4)
	Thrusters(5)=(BoneName="track_right_2",ThrusterOffset=45.0,bHasSuspension=true,SuspensionTravel=15.0,SuspensionTravelRate=100.0,NumWheels=1,WheelIndexes[0]=5)
	Thrusters(6)=(BoneName="track_left_3",ThrusterOffset=45.0,bHasSuspension=true,SuspensionTravel=15.0,SuspensionTravelRate=100.0,NumWheels=1,WheelIndexes[0]=6)
	Thrusters(7)=(BoneName="track_right_3",ThrusterOffset=45.0,bHasSuspension=true,SuspensionTravel=15.0,SuspensionTravelRate=100.0,NumWheels=1,WheelIndexes[0]=7)
	Thrusters(8)=(BoneName="track_left_4",ThrusterOffset=45.0,bHasSuspension=true,SuspensionTravel=15.0,SuspensionTravelRate=100.0,NumWheels=1,WheelIndexes[0]=8)
	Thrusters(9)=(BoneName="track_right_4",ThrusterOffset=45.0,bHasSuspension=true,SuspensionTravel=15.0,SuspensionTravelRate=100.0,NumWheels=1,WheelIndexes[0]=9)
	Thrusters(10)=(BoneName="track_left_5",ThrusterOffset=45.0,bHasSuspension=true,SuspensionTravel=15.0,SuspensionTravelRate=100.0,NumWheels=1,WheelIndexes[0]=10)
	Thrusters(11)=(BoneName="track_right_5",ThrusterOffset=45.0,bHasSuspension=true,SuspensionTravel=15.0,SuspensionTravelRate=100.0,NumWheels=1,WheelIndexes[0]=11)
	Thrusters(12)=(BoneName="track_left_6",ThrusterOffset=45.0,bHasSuspension=true,SuspensionTravel=15.0,SuspensionTravelRate=100.0,NumWheels=1,WheelIndexes[0]=12)
	Thrusters(13)=(BoneName="track_right_6",ThrusterOffset=45.0,bHasSuspension=true,SuspensionTravel=15.0,SuspensionTravelRate=100.0,NumWheels=1,WheelIndexes[0]=13)
	Thrusters(14)=(BoneName="rear_left",ThrusterOffset=63.0,bHasSuspension=false,NumWheels=1,WheelIndexes[0]=14,bChecksForWater=true)
	Thrusters(15)=(BoneName="rear_right",ThrusterOffset=63.0,bHasSuspension=false,NumWheels=1,WheelIndexes[0]=15,bChecksForWater=true)

	// wheels left then right, front to back...
	TrackWheels(0)=(TrackIndex=0,WheelRadius=39.0,WheelBoneName="front_left",bHasSuspension=false)
	TrackWheels(1)=(TrackIndex=1,WheelRadius=39.0,WheelBoneName="front_right",bHasSuspension=false)
	TrackWheels(2)=(TrackIndex=0,WheelRadius=27.0,WheelBoneName="wheel_left_1",bHasSuspension=true)
	TrackWheels(3)=(TrackIndex=1,WheelRadius=27.0,WheelBoneName="wheel_right_1",bHasSuspension=true)
	TrackWheels(4)=(TrackIndex=0,WheelRadius=27.0,WheelBoneName="wheel_left_2",bHasSuspension=true)
	TrackWheels(5)=(TrackIndex=1,WheelRadius=27.0,WheelBoneName="wheel_right_2",bHasSuspension=true)
	TrackWheels(6)=(TrackIndex=0,WheelRadius=27.0,WheelBoneName="wheel_left_3",bHasSuspension=true)
	TrackWheels(7)=(TrackIndex=1,WheelRadius=27.0,WheelBoneName="wheel_right_3",bHasSuspension=true)
	TrackWheels(8)=(TrackIndex=0,WheelRadius=27.0,WheelBoneName="wheel_left_4",bHasSuspension=true)
	TrackWheels(9)=(TrackIndex=1,WheelRadius=27.0,WheelBoneName="wheel_right_4",bHasSuspension=true)
	TrackWheels(10)=(TrackIndex=0,WheelRadius=27.0,WheelBoneName="wheel_left_5",bHasSuspension=true)
	TrackWheels(11)=(TrackIndex=1,WheelRadius=27.0,WheelBoneName="wheel_right_5",bHasSuspension=true)
	TrackWheels(12)=(TrackIndex=0,WheelRadius=27.0,WheelBoneName="wheel_left_6",bHasSuspension=true)
	TrackWheels(13)=(TrackIndex=1,WheelRadius=27.0,WheelBoneName="wheel_right_6",bHasSuspension=true)
	TrackWheels(14)=(TrackIndex=0,WheelRadius=29.0,WheelBoneName="rear_left",bHasSuspension=false)
	TrackWheels(15)=(TrackIndex=1,WheelRadius=29.0,WheelBoneName="rear_right",bHasSuspension=false)

	HoverSoftness=0.05
	HoverPenScale=1.5
	HoverCheckDist=65

	UprightStiffness=500
	UprightDamping=300

	MaxThrust=56.64		// max speed in decimeters per second (0.1 * centimeters per second)

//	MaxSteerTorque=100.0
	MaxSteerTorque=200.0
	ForwardDampFactor=0.1
	LateralDampFactor=10.0
	ParkingDampFactor=0.8
//	SteerDampFactor=100.0
	SteerDampFactor=300.0
	PitchTorqueFactor=0.0
	PitchDampFactor=0.0
	BankTorqueFactor=0.0
	BankDampFactor=0.0
	TurnDampFactor=0.0
	DecelerateDampFactor=0.7
	SteerDecayDampFactor=400.0

	InvertSteeringThrottleThreshold=-0.1
	VehicleMass=12.0

	TrackVelocityScale=-153


	Begin Object Class=KarmaParamsRBFull Name=KParamsTank
		KStartEnabled=True
		KFriction=0.5
		KLinearDamping=0
		KAngularDamping=0
		bKNonSphericalInertia=False
		bHighDetailOnly=False
		bClientOnly=False
		bKDoubleTickRate=True
		bKStayUpright=True
		bKAllowRotate=True
		KInertiaTensor(0)=1.3
		KInertiaTensor(1)=0.0
		KInertiaTensor(2)=0.0
		KInertiaTensor(3)=4.0
		KInertiaTensor(4)=0.0
		KInertiaTensor(5)=4.5
		KCOMOffset=(X=0.0,Y=0.0,Z=0.0)
		Name="KParamsTank"
	End Object
	KParams=KarmaParams'KParamsTank'

	PawnTeam=TEAM_US
	TrackDustEmitterClass=class'TankStuartTrackDust'

	// Nine-point blending animations.
	ForwardDownAnim="forward_down"
	ForwardLevelAnim="forward_level"
	ForwardUpAnim="forward_up"
	LeftDownAnim="left_down"
	LeftLevelAnim="left_level"
	LeftUpAnim="left_up"
	RightDownAnim="right_down"
	RightLevelAnim="right_level"
	RightUpAnim="right_up"

	NinePointBlendBone="50cal_horizontal"
	Weap50calOffset=(X=20,Y=0,Z=52)

	bHasCreatedTriggers=false
	MachineGunRearTriggerOffset=(X=-280,Y=0,Z=-50)
	MachineGunRearTriggerRadius=120;
	MachineGunTurretTriggerOffset=(X=-160,Y=0,Z=100)
	MachineGunTurretTriggerRadius=100;

	bSpawnCommander=true
	TankCommanderPawnOffset=(X=14,Y=-33,Z=10)
	TankCommanderPawnRotation=(Pitch=49152,Yaw=0,Roll=49152)  // pitch changes yaw of mesh
	TankCommanderPawnHitCylinderOffset=(X=0,Y=-100,Z=0)  // Pawn + 60
	TankCommanderPawnHitCylinderRotation=(Pitch=0,Yaw=0,Roll=0)

	TankLoaderPawnOffset=(X=0,Y=-40,Z=0)
	TankLoaderPawnRotation=(Pitch=49152,Yaw=0,Roll=49152)

	TankGunnerPawnOffset=(X=22,Y=-3,Z=30)
	TankGunnerPawnRotation=(Pitch=0,Yaw=49152,Roll=0)

	// animations...
	MainFireFrontHatchOpen="fire_forward"
	MainFireFrontHatchClosed="fire_forward"
	MainFireLeftHatchOpen="fire_left"
	MainFireLeftHatchClosed="fire_left"
	MainFireRightHatchOpen="fire_right"
	MainFireRightHatchClosed="fire_right"
	MainFireRearHatchOpen="fire_back"
	MainFireRearHatchClosed="fire_back"

	TankHatchOpenIdleAnim="idle"
	TankHatchClosedIdleAnim="idle"

	CommanderAnimPkg="a_hold_misc.m10"
	ExtendedAttachmentMeshName="k_vehicle_us.m10_tank"

	CommanderStandingIdleAnims(0)="m10_commander_standing_idle_1"
	CommanderStandingIdleAnims(1)="m10_commander_standing_idle_2"
	CommanderStandingIdleAnims(2)="m10_commander_looking_thru_binocs"

	CommanderSittingIdleAnims(0)="m10_commander_sitting_idle_1"
	CommanderSittingIdleAnims(1)="m10_commander_sitting_idle_2"

	CommanderHitPulledInAnim="m10_commander_death_standing"
	CommanderStandingToSittingAnim="m10_commander_duck_to_sitting"
	CommanderSittingToStandingAnim="m10_commander_sitting_to_standing"
	CommanderMoveOutAnim="m10_commander_gesture_forward"
	CommanderTankBlownupAnim="m10_commander_death"

	LoaderUSCharType=USCharTankCommanderB
	LoaderAnimPkg="a_hold_misc.m10"
	LoaderIdleAnims(0)="m10_loader_idle_1"
	LoaderIdleAnims(1)="m10_loader_idle_2"
	LoaderFireAnim="m10_loader_react_to_fire"
	LoaderReloadAnim="m10_loader_reload"
	LoaderDeathAnim="m10_loader_death"

	GunnerUSCharType=USCharTankCommanderB
	GunnerAnimPkg="a_hold_misc.m10"
	GunnerIdleAnim="m10_gunner_idle"

	CornerPointOffset(0)=(X=340,Y=115,Z=-50)	// front
	CornerPointOffset(1)=(X=340,Y=-115,Z=-50)	// front
	CornerPointOffset(2)=(X=275,Y=-205,Z=-50)	// left
	CornerPointOffset(3)=(X=-250,Y=-205,Z=-50)	// left
	CornerPointOffset(4)=(X=-325,Y=-115,Z=-50)	// rear
	CornerPointOffset(5)=(X=-325,Y=115,Z=-50)	// rear
	CornerPointOffset(6)=(X=-250,Y=205,Z=-50)	// right
	CornerPointOffset(7)=(X=275,Y=205,Z=-50)	// right

	CornerPointYawRotation(0)=0			// front - out away from the tank
	CornerPointYawRotation(1)=0			// front
	CornerPointYawRotation(2)=-16384	// left
	CornerPointYawRotation(3)=-16384	// left
	CornerPointYawRotation(4)=32768		// rear
	CornerPointYawRotation(5)=32768		// rear
	CornerPointYawRotation(6)=16384		// right
	CornerPointYawRotation(7)=16384		// right

	CornerPointIsLeftCorner(0)=1;	// front
	CornerPointIsLeftCorner(1)=0;	// front
	CornerPointIsLeftCorner(2)=1;	// left
	CornerPointIsLeftCorner(3)=0;	// left
	CornerPointIsLeftCorner(4)=1;	// rear
	CornerPointIsLeftCorner(5)=0;	// rear
	CornerPointIsLeftCorner(6)=1;	// right
	CornerPointIsLeftCorner(7)=0;	// right

	CornerPointIsStandingCorner(0)=0;	// front
	CornerPointIsStandingCorner(1)=0;	// front
	CornerPointIsStandingCorner(2)=0;	// left
	CornerPointIsStandingCorner(3)=1;	// left
	CornerPointIsStandingCorner(4)=1;	// rear
	CornerPointIsStandingCorner(5)=1;	// rear
	CornerPointIsStandingCorner(6)=1;	// right
	CornerPointIsStandingCorner(7)=0;	// right

	VehicleShadowDrawScale = 5

	SmokeEmitterOffset=(X=-160.0,Y=0.0,Z=0.0)
	TankDeathEmitterOffset=(X=0.0,Y=0.0,Z=64.0)
	BlowedUpEmitterOffset=(X=0.0,Y=0.0,Z=64.0)

	bFriendlyFireListen=true
	ScriptedViewBoneName="Base"
	ScriptedViewOffset=(X=0,Y=0,Z=230.0f)

	CharacterSetupClass=class'CharacterSetupUSA'
	m_eCharacterType=USCharTankCommanderC
}
class TankMarder extends Tank;


var()	int		MainGunPitch;

var()	name	MainGunBoneName;
var()	name	MainGunMuzzleBoneName;

var bool 	bHasCreatedTriggers;
var TankGrenadeTrigger MyTankGrenadeTrigger;
var vector	TankGrenadeTriggerOffset;
var float	TankGrenadeTriggerRadius;

var float 		MainGunTraceAccuracy;
var class<Projector> ExplosionDecal;
var float		ExploWallOut;	// distance to move explosions out from wall

var class<InstantFire> MainGunFireModeClass;
var InstantFire		MainGunFireMode;
var Ammunition 		MainGunAmmo;
var class<Emitter>	MainGunFlashEmitterClass;
var class<Emitter>	MainGunSmokeEmitterClass;
var() vector		MainGunEmitterOffset;

var		float	fMainGunReFireTime;
var()	float	fMainGunReFireDelay;

var()	float	MainGunRotationSpeed;	// degrees per second
var()	float	MainGunUpwardFireArc;	// in degrees
var()	float	MainGunDownwardFireArc;	// in degrees

var Cue		MainGunFireSound;
var string	MainGunFireSoundName;

var int		AimErrorAI;

var bool	bWasCommanderAlive;


simulated function PreBeginPlay()
{
	Mesh = Mesh( DynamicLoadObject( "k_vehicle_de.de_marder_III", class'Mesh' ) );

	super.PreBeginPlay();
}

simulated function SetupTracks()
{
}

simulated function BeginPlay()
{
	SetPhysics(PHYS_Karma);
}

simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();

	MainGunFireMode = Spawn(MainGunFireModeClass, self);
	if (MainGunFireMode == None)
		Log(name $ ".PostNetBeginPlay() - Couldn't spawn MainGunFireMode!!!");
	else
	{
		MainGunAmmo = Spawn(MainGunFireMode.AmmoClass, MainGunFireMode);
	}

	CreateSounds();

	bWasCommanderAlive = true;
}

simulated function CreateSounds()
{
	if ( MainGunFireSoundName != "" )
		MainGunFireSound = LoadSound( MainGunFireSoundName );
	if ( EngineIdleSoundName != "" )
		EngineIdleSound = Sound( DynamicLoadObject( EngineIdleSoundName, class'Sound' ) );
	if ( DrivingSoundName != "" )
		DrivingSound = Sound( DynamicLoadObject( DrivingSoundName, class'Sound' ) );
}

function CreateTriggers()
{
	local vector RotX, RotY, RotZ;
	local vector Offset;

    GetAxes(Rotation,RotX,RotY,RotZ);

	Offset = TankGrenadeTriggerOffset.X * RotX + TankGrenadeTriggerOffset.Y * RotY + TankGrenadeTriggerOffset.Z * RotZ;
	MyTankGrenadeTrigger = spawn(class'TankGrenadeTrigger', self,, Location + Offset);
	MyTankGrenadeTrigger.SetBase(self);
	MyTankGrenadeTrigger.SetCollisionSize(TankGrenadeTriggerRadius, 50 );
	MyTankGrenadeTrigger.SetCollision(true, false, false);
	MyTankGrenadeTrigger.m_aUseTarget = self;
	MyTankGrenadeTrigger.bHidden = true;

	MyTankGrenadeTrigger.bDisabled = true;
}

function Destroyed()
{
	Log( name $ ".(TankMarder).Destroyed()", 'Tank' );

	if (MainGunFireMode != None)
		MainGunFireMode.Destroy();
	if (MainGunAmmo != None)
		MainGunAmmo.Destroy();

	if (MyTankGrenadeTrigger != None)
		MyTankGrenadeTrigger.Destroy();

	super.Destroyed();
}

function bool CheckIfCommanderDied()
{
	if (CommanderPawn != None)
	{
		if (bWasCommanderAlive)
		{
			if (CommanderPawn.Health <= 0)
			{
				bWasCommanderAlive = false;
				return true;
			}

			bWasCommanderAlive = true;
		}
	}

	return false;
}

simulated function Tick(float DeltaTime)
{
	super.Tick( DeltaTime );

	if (!bHasCreatedTriggers)
	{
		CreateTriggers();
		bHasCreatedTriggers = true;
	}

	if (Health <= 0)  // died?
	{
		bNoSound = false;  // make sure sounds aren't played anymore on this tank

		AmbientSound = None;
		if (MyBulletListener != None)
			MyBulletListener.AmbientSound = None;

		return;
	}

	if ( !bDisablePlayerUseableTriggers && CheckIfCommanderDied() )
	{
		MyTankGrenadeTrigger.bDisabled = false;  // enable the tank grenaded trigger
	}

	if (Rise > 0)
		MainGunRotate(DeltaTime, true);  // up
	else if (Rise < 0)
		MainGunRotate(DeltaTime, false);  // down
}


function TakeDamage(int Damage, Pawn instigatedBy, Vector Hitlocation, Vector Momentum, class<DamageType> DamageType, optional name HitBoxName)
{
	local int InitialHealth;

	InitialHealth = Health;

	Super.TakeDamage(Damage, instigatedBy, Hitlocation, Momentum, DamageType, HitBoxName);

	if ((InitialHealth > 0) && (Health <= 0))  // did we just now die?
	{
		// swap the skins out for the damaged versions...

		if (MyTankGrenadeTrigger != None)
		{
			MyTankGrenadeTrigger.Destroy();
			MyTankGrenadeTrigger = None;
		}
	}
}

simulated function rotator AdjustAimMainGun()
{
	local rotator MainGunRot;

	MainGunRot.Pitch = (Rotation.Pitch + MainGunPitch) & 65535;
	MainGunRot.Yaw = Rotation.Yaw & 65535;
	MainGunRot.Roll = 0;

	return MainGunRot;
}

simulated function FireMainGun()
{
	local vector MainGunLoc;
	local rotator MainGunRot;
	local vector RotX, RotY, RotZ;
	local float YOffset, ZOffset;
	local vector EndTrace, X;
	local int AimError;
	local rotator AdjustedAim;
	local gbxTankShell TankShell;
//	local vector HitLocation, HitNormal;
//	local Actor HitActor;

	MainGunLoc = GetTagCoords( MainGunMuzzleBoneName ).origin;

	MainGunRot.Pitch = MainGunPitch;
	MainGunRot.Yaw = 0;
	MainGunRot.Roll = 0;

	MainGunRot = Rotation + MainGunRot;

    GetAxes(MainGunRot,RotX,RotY,RotZ);

	MainGunLoc = MainGunLoc + MainGunEmitterOffset.X * RotX + MainGunEmitterOffset.Y * RotY + MainGunEmitterOffset.Z * RotZ;

	// spawn main gun muzzle flash emitter...
	spawn(MainGunFlashEmitterClass, None,, MainGunLoc, MainGunRot);

	MainGunRot.Pitch = 0;  // ignore main gun pitch for main gun smoke and dust emitter
	MainGunRot.Yaw = 0;
	MainGunRot.Roll = 0;

	MainGunRot = Rotation + MainGunRot;

	// spawn main gun smoke and dust emitter...
	spawn(MainGunSmokeEmitterClass, None,, MainGunLoc, MainGunRot);

	YOffset = 0.0f;
	ZOffset = 0.0f;

	AimError = 10;

	AdjustedAim = AdjustAimMainGun();
	EndTrace = MainGunLoc + (YOffset + MainGunTraceAccuracy * (FRand() - 0.5 ) ) * RotY * 1000
		+ (ZOffset + MainGunTraceAccuracy * (FRand() - 0.5 )) * RotZ * 1000;
	X = vector(AdjustedAim);
	EndTrace += (10000 * X);

	AdjustedAim = rotator(EndTrace - MainGunLoc);

/*
	HitActor = Trace(HitLocation, HitNormal, EndTrace, MainGunLoc, true);

	if (HitActor != None)
	{
		Explosion(HitLocation + ExploWallOut * HitNormal);

		if ( (ExplosionDecal != None) && (Level.NetMode != NM_DedicatedServer) )
			Spawn(ExplosionDecal,self,,HitLocation, rotator(-HitNormal));
	}
*/

	TankShell = Spawn( class'gbxTankShell', self,, MainGunLoc, AdjustedAim );
	TankShell.Instigator = self;

	PlaySoundCue( MainGunFireSound, SLOT_NONE, TransientSoundVolume,,,,false);

	PlayMainGunFiringAnim(0);
}

function KDriverEnter(Pawn P)
{
    Super.KDriverEnter(P);

	AmbientSound = EngineIdleSound;
}

function bool KDriverLeave(bool bForceLeave)
{
	local bool result;

	result = Super.KDriverLeave(bForceLeave);

	AmbientSound = None;
	if (MyBulletListener != None)
		MyBulletListener.AmbientSound = None;

	return result;
}

simulated function VehicleFire(bool bWasAltFire)
{
	super.VehicleFire( bWasAltFire );

	if (!bWasAltFire)  // fire the main gun
	{
		if (fMainGunReFireTime < Level.TimeSeconds)
		{
			fMainGunReFireTime = Level.TimeSeconds + fMainGunReFireDelay;

			FireMainGun();
		}
	}
}

simulated function VehicleCeaseFire(bool bWasAltFire)
{
	super.VehicleCeaseFire( bWasAltFire );
}

simulated function PlayMainGunFiringAnim(int TankTurretYaw)
{
	// Marder III tanks can't rotate the turret, so no blending required...

	if (IsHatchClosed())
		PlayAnim(MainFireFrontHatchClosed, 1.0, 0.0, MAINGUN_ANIM_CHAN1);
	else
		PlayAnim(MainFireFrontHatchOpen, 1.0, 0.0, MAINGUN_ANIM_CHAN1);
}

simulated function MainGunRotate(float DeltaTime, bool bUp)
{
	local float MaxPitchUp, MaxPitchDown;
	local float PitchOffset;
	local rotator MainGunRot;

	MaxPitchUp = (MainGunUpwardFireArc / 360.0) * 65536;
	MaxPitchDown = (MainGunDownwardFireArc / 360.0) * 65536;
	PitchOffset = (MainGunRotationSpeed * DeltaTime / 360.0) * 65536;

	if (bUp)
		MainGunPitch = MainGunPitch + int(PitchOffset);
	else
		MainGunPitch = MainGunPitch - int(PitchOffset);

	MainGunPitch = Clamp(MainGunPitch, -MaxPitchDown, MaxPitchUp);

	MainGunRot.Pitch = 0;
	MainGunRot.Yaw = MainGunPitch;
	MainGunRot.Roll = 0;

	SetBoneRotation(MainGunBoneName, MainGunRot, 0, 1.0);
}

function GrenadeHasBeenPlanted(Pawn GrenadePlanter)
{
	local TankGrenade MyTankGrenade;

	Log(name $ ".(TankMarder).GrenadeHasBeenPlanted() - planter = " $ GrenadePlanter.name, 'Tank');

	if (CommanderPawn != None)
	{
		CommanderPawn.bAllowDamage = false;
		CommanderPawn.bHidden = true;

		CommanderPawn.bHatchClosing = true;
		CommanderPawn.bHatchFullyClosed = true;

		if (CommanderPawn.HitCylinder != None)
			CommanderPawn.HitCylinder.bHidden = true;

		CommanderPawn.GotoState('GrenadePlanted');
	}

	PlayAnim(TankHatchClosedIdleAnim);

	MyTankGrenade = spawn(class'TankGrenade', GrenadePlanter,, Location, Rotation);
	MyTankGrenade.Instigator = GrenadePlanter;
	MyTankGrenade.bActivated = true;

	Super.GrenadeHasBeenPlanted( GrenadePlanter );
}


defaultproperties
{
	DrawType=DT_Mesh
	Mesh=None  // use DymamicLoadObject instead
	EditorMeshName="k_vehicle_de.de_marder_III"
    Physics=PHYS_None

	Health=2
	CollisionHeight=2.0
	CollisionRadius=2.0
	VehicleCollisionHeight=128.0
	VehicleCollisionRadius=270.0
	BaseEyeHeight=140
	EyeHeight=140
	bTurnInPlace=true
	bCanStrafe=true

	MinDamageAmount=300
	HitPointsFront=1
	HitPointsSide=2
	HitPointsRear=2
	HitPointsTurret=1
	StopMovingHealth=1

	FPCamPos=(X=-10,Y=-30,Z=140)
	TPCamLookat=(X=-100,Y=0,Z=100)
	TPCamDistance=1200

	bDrawDriverInTP=true
	bDrawMeshInFP=true

	MaxViewYaw=16000
	MaxViewPitch=16000

	DrivePos=(X=105,Y=-50,Z=85)
	DriveRot=(Pitch=0,Yaw=0,Roll=0)

	ExitPositions(0)=(Y=-415.000000,Z=100.000000)
	ExitPositions(1)=(Y=415.000000,Z=100.000000)
	ExitPositions(2)=(Y=0.000000,Z=-400.000000)
	ExitPositions(3)=(Y=0.000000,Z=400.000000)

	MainGunBoneName="main_gun"
	MainGunMuzzleBoneName="main_gun_muzzle"

	MainGunFireModeClass=class'gbxInventory.FireStugMainGun'
	MainGunTraceAccuracy=+0.1

	MainGunFlashEmitterClass=class'gbxEffects.MuzzleFlashStuartTankMainGun'
	MainGunSmokeEmitterClass=class'gbxEffects.TankStuartMainGunSmokeAndDust'

	MainGunEmitterOffset=(X=10,Y=0,Z=0)

	// GBX:naj - bug 11544: this sound no longer exists, and anyway 'ImpactSound' appears not to be used.
	//ImpactSound=Sound'explosions.close_artillery_d'		
	ExplosionDecal=class'TankProjectileScorch'
	ExploWallOut=1.0

	// sounds
	MainGunFireSoundName="V_TANK_MARK_IV.turret_fire"

	EngineIdleSoundName="V_TANK_STUG.IDLE"
	DrivingSoundName="V_TANK_STUG.DRIVING_LOOP"

	// tank driving max pitch speed
	MaxPitchSpeed=200.0

	fMainGunReFireDelay=8.0

	MainGunRotationSpeed=36.0
	MainGunUpwardFireArc=7.0
	MainGunDownwardFireArc=2.0

	// thruster positions left to right, front to back...
	Thrusters(0)=(BoneName="left_front",ThrusterOffset=80.0,bHasSuspension=false,NumWheels=1,WheelIndexes[0]=0)
	Thrusters(1)=(BoneName="right_front",ThrusterOffset=80.0,bHasSuspension=false,NumWheels=1,WheelIndexes[0]=1)
	Thrusters(2)=(BoneName="left_track_1",ThrusterOffset=62.0,bHasSuspension=true,SuspensionTravel=15.0,SuspensionTravelRate=100.0,NumWheels=1,WheelIndexes[0]=2)
	Thrusters(3)=(BoneName="right_track_1",ThrusterOffset=62.0,bHasSuspension=true,SuspensionTravel=15.0,SuspensionTravelRate=100.0,NumWheels=1,WheelIndexes[0]=3)
	Thrusters(4)=(BoneName="left_track_2",ThrusterOffset=62.0,bHasSuspension=true,SuspensionTravel=15.0,SuspensionTravelRate=100.0,NumWheels=1,WheelIndexes[0]=4)
	Thrusters(5)=(BoneName="right_track_2",ThrusterOffset=62.0,bHasSuspension=true,SuspensionTravel=15.0,SuspensionTravelRate=100.0,NumWheels=1,WheelIndexes[0]=5)
	Thrusters(6)=(BoneName="left_track_3",ThrusterOffset=62.0,bHasSuspension=true,SuspensionTravel=15.0,SuspensionTravelRate=100.0,NumWheels=1,WheelIndexes[0]=6)
	Thrusters(7)=(BoneName="right_track_3",ThrusterOffset=62.0,bHasSuspension=true,SuspensionTravel=15.0,SuspensionTravelRate=100.0,NumWheels=1,WheelIndexes[0]=7)
	Thrusters(8)=(BoneName="left_track_4",ThrusterOffset=62.0,bHasSuspension=true,SuspensionTravel=15.0,SuspensionTravelRate=100.0,NumWheels=1,WheelIndexes[0]=8)
	Thrusters(9)=(BoneName="right_track_4",ThrusterOffset=62.0,bHasSuspension=true,SuspensionTravel=15.0,SuspensionTravelRate=100.0,NumWheels=1,WheelIndexes[0]=9)
	Thrusters(10)=(BoneName="left_rear",ThrusterOffset=68.0,bHasSuspension=false,NumWheels=1,WheelIndexes[0]=10)
	Thrusters(11)=(BoneName="right_rear",ThrusterOffset=68.0,bHasSuspension=false,NumWheels=1,WheelIndexes[0]=11)

	// wheels left then right, front to back...
	TrackWheels(0)=(TrackIndex=0,WheelRadius=34.0,WheelBoneName="left_front",bHasSuspension=false)
	TrackWheels(1)=(TrackIndex=1,WheelRadius=34.0,WheelBoneName="right_front",bHasSuspension=false,bReverseWheelRotation=true)
	TrackWheels(2)=(TrackIndex=0,WheelRadius=39.0,WheelBoneName="left_wheel_1",bHasSuspension=true,bReverseWheelRotation=true)
	TrackWheels(3)=(TrackIndex=1,WheelRadius=39.0,WheelBoneName="right_wheel_1",bHasSuspension=true,bReverseWheelRotation=true)
	TrackWheels(4)=(TrackIndex=0,WheelRadius=39.0,WheelBoneName="left_wheel_2",bHasSuspension=true,bReverseWheelRotation=true)
	TrackWheels(5)=(TrackIndex=1,WheelRadius=39.0,WheelBoneName="right_wheel_2",bHasSuspension=true,bReverseWheelRotation=true)
	TrackWheels(6)=(TrackIndex=0,WheelRadius=39.0,WheelBoneName="left_wheel_3",bHasSuspension=true,bReverseWheelRotation=true)
	TrackWheels(7)=(TrackIndex=1,WheelRadius=39.0,WheelBoneName="right_wheel_3",bHasSuspension=true,bReverseWheelRotation=true)
	TrackWheels(8)=(TrackIndex=0,WheelRadius=39.0,WheelBoneName="left_wheel_4",bHasSuspension=true,bReverseWheelRotation=true)
	TrackWheels(9)=(TrackIndex=1,WheelRadius=39.0,WheelBoneName="right_wheel_4",bHasSuspension=true,bReverseWheelRotation=true)
	TrackWheels(10)=(TrackIndex=0,WheelRadius=29.0,WheelBoneName="left_rear",bHasSuspension=false)
	TrackWheels(11)=(TrackIndex=1,WheelRadius=29.0,WheelBoneName="right_rear",bHasSuspension=false,bReverseWheelRotation=true)

	HoverSoftness=0.05
	HoverPenScale=1.5
	HoverCheckDist=65

	UprightStiffness=500
	UprightDamping=300

	MaxThrust=56.64		// max speed in decimeters per second (0.1 * centimeters per second)

//	MaxSteerTorque=100.0
	MaxSteerTorque=200.0
	ForwardDampFactor=0.1
	LateralDampFactor=10.0
	ParkingDampFactor=0.8
//	SteerDampFactor=100.0
	SteerDampFactor=250.0
	PitchTorqueFactor=0.0
	PitchDampFactor=0.0
	BankTorqueFactor=0.0
	BankDampFactor=0.0
	TurnDampFactor=0.0
	DecelerateDampFactor=0.7
	SteerDecayDampFactor=400.0

	InvertSteeringThrottleThreshold=-0.1
	VehicleMass=12.0

	TrackVelocityScale=-153


	Begin Object Class=KarmaParamsRBFull Name=KParamsTank
		KStartEnabled=True
		KFriction=0.5
		KLinearDamping=0
		KAngularDamping=0
		bKNonSphericalInertia=False
		bHighDetailOnly=False
		bClientOnly=False
		bKDoubleTickRate=True
		bKStayUpright=True
		bKAllowRotate=True
		KInertiaTensor(0)=1.3
		KInertiaTensor(1)=0.0
		KInertiaTensor(2)=0.0
		KInertiaTensor(3)=4.0
		KInertiaTensor(4)=0.0
		KInertiaTensor(5)=4.5
		KCOMOffset=(X=0.0,Y=0.0,Z=0.0)
		Name="KParamsTank"
	End Object
	KParams=KarmaParams'KParamsTank'

	PawnTeam=TEAM_German
	TrackDustEmitterClass=class'TankStuartTrackDust'

	bSpawnCommander=true
	TankCommanderPawnOffset=(X=6,Y=-22,Z=0)
	TankCommanderPawnRotation=(Pitch=49152,Yaw=32768,Roll=16384)
	TankCommanderPawnHitCylinderOffset=(X=0,Y=-80,Z=0)
	TankCommanderPawnHitCylinderRotation=(Pitch=0,Yaw=0,Roll=0)

	// animations...
	MainFireFrontHatchOpen="fire_open_hatch"
	MainFireFrontHatchClosed="fire_closed_hatch"

	TankHatchOpenIdleAnim="hatch_open"
	TankHatchClosedIdleAnim="hatch_closed"

	CommanderAnimPkg="a_hold_misc.marder"

	CommanderIdleAnims(0)="marder_commander_idle_1"
	CommanderIdleAnims(1)="marder_commander_idle_2"
	CommanderIdleAnims(2)="marder_commander_idle_3"
	CommanderIdleAnims(3)="marder_looking_thru_binocs"

	CommanderHitPulledInAnim="marder_commander_hit_pulled_in"
	CommanderFlinchCloseAnim="marder_flinch_close_hatch"
	CommanderOpenHatchAnim="marder_open_hatch"
	CommanderCloseHatchAnim="marder_close_hatch"
	CommanderMoveOutAnim="marder_gesture_forward"
	CommanderTankBlownupAnim="marder_expires"

	TankCommanderHitAnim="com_hit_pulled_in"
	TankCommanderFlinchAnim="flinch_close_hatch"
	TankCommanderOpenHatchAnim="open_hatch"
	TankCommanderCloseHatchAnim="close_hatch"
	TankCommanderTankBlownupAnim="expires"

	AimErrorAI=50

	CornerPointOffset(0)=(X=320,Y=90,Z=-50)		// front
	CornerPointOffset(1)=(X=320,Y=-90,Z=-50)	// front
	CornerPointOffset(2)=(X=175,Y=-215,Z=-50)	// left
	CornerPointOffset(3)=(X=-170,Y=-215,Z=-50)	// left
	CornerPointOffset(4)=(X=-320,Y=-90,Z=-50)	// rear
	CornerPointOffset(5)=(X=-320,Y=90,Z=-50)	// rear
	CornerPointOffset(6)=(X=-170,Y=215,Z=-50)	// right
	CornerPointOffset(7)=(X=175,Y=215,Z=-50)	// right

	CornerPointYawRotation(0)=0			// front - out away from the tank
	CornerPointYawRotation(1)=0			// front
	CornerPointYawRotation(2)=-16384	// left
	CornerPointYawRotation(3)=-16384	// left
	CornerPointYawRotation(4)=32768		// rear
	CornerPointYawRotation(5)=32768		// rear
	CornerPointYawRotation(6)=16384		// right
	CornerPointYawRotation(7)=16384		// right

	CornerPointIsLeftCorner(0)=1;	// front
	CornerPointIsLeftCorner(1)=0;	// front
	CornerPointIsLeftCorner(2)=1;	// left
	CornerPointIsLeftCorner(3)=0;	// left
	CornerPointIsLeftCorner(4)=1;	// rear
	CornerPointIsLeftCorner(5)=0;	// rear
	CornerPointIsLeftCorner(6)=1;	// right
	CornerPointIsLeftCorner(7)=0;	// right

	CornerPointIsStandingCorner(0)=0;	// front
	CornerPointIsStandingCorner(1)=0;	// front
	CornerPointIsStandingCorner(2)=0;	// left
	CornerPointIsStandingCorner(3)=1;	// left
	CornerPointIsStandingCorner(4)=1;	// rear
	CornerPointIsStandingCorner(5)=1;	// rear
	CornerPointIsStandingCorner(6)=1;	// right
	CornerPointIsStandingCorner(7)=0;	// right

	VehicleShadowDrawScale = 6

	bHasCreatedTriggers=false
	TankGrenadeTriggerOffset=(X=-240,Y=0,Z=-50)
	TankGrenadeTriggerRadius=180;

	TankGrenadePlayerAnim="marder_grenaded"  // in a_hold_misc.panzer
	TankGrenadeMeshAnimName="a_hold_misc.marder"
	TankGrenadeMountAnimStartOffset=(X=-186.0,Y=204.0,Z=-48.0)
	TankGrenadeCameraStartOffset=(X=-50.0,Y=400.0,Z=300.0)
	TankGrenadeCameraEndOffset=(X=-50.0,Y=500.0,Z=200.0)
	TankGrenadeHeadZoomInOffset=(X=-117.3,Y=-46.8,Z=186.8)
	TankGrenadeYawSet=0
	TankGrenadeTeleportOffset=(X=0.0,Y=0.0,Z=0.0)

	SmokeEmitterOffset=(X=-160.0,Y=0.0,Z=0.0)
	TankDeathEmitterOffset=(X=0.0,Y=0.0,Z=32.0)
	BlowedUpEmitterOffset=(X=0.0,Y=0.0,Z=32.0)

	CharacterSetupClass=class'CharacterSetupGermany'
}
class TankPanzerIV extends Tank;


var()	int		TurretYaw;
var()	int		PreviousTurretYaw;
var()	int		OldTurretYaw;  // to decide if turret rotating sounds need to be played
var()	int		MainGunPitch;
var()	rotator	BowGunRotation;

var()	name	TurretBoneName;
var()	name	MainGunBoneName;
var()	name	MainGunMuzzleBoneName;
var()	name	BowGunBoneName;
var()	name	BowGunMuzzleBoneName;

var bool 	bHasCreatedTriggers;
var TankGrenadeTrigger MyTankGrenadeTrigger;
var vector	TankGrenadeTriggerOffset;
var float	TankGrenadeTriggerRadius;

var float 		MainGunTraceAccuracy;
var class<Projector> ExplosionDecal;
var float		ExploWallOut;	// distance to move explosions out from wall

var class<InstantFire> MainGunFireModeClass;
var InstantFire		MainGunFireMode;
var Ammunition 		MainGunAmmo;
var class<Emitter>	MainGunFlashEmitterClass;
var class<Emitter>	MainGunSmokeEmitterClass;
var() vector		MainGunEmitterOffset;

var class<InstantFire> BowGunFireModeClass;
var InstantFire		BowGunFireMode;
var Ammunition 		BowGunAmmo;
var float 			BowGunTraceAccuracy;
var transient gbxBulletTracer	BowGunTracerEmitter;
var() int			BowGunTracerFrequency;
var int				BowGunTracerCount;
var() vector		BowGunEmitterOffset;

var		float	fMainGunReFireTime;
var()	float	fMainGunReFireDelay;
var		float	fBowGunReFireTime;
var()	float	fBowGunReFireDelay;

var()	float	TurretRotationSpeed;	// degrees per second
var()	float	MainGunRotationSpeed;	// degrees per second
var()	float	MainGunUpwardFireArc;	// in degrees
var()	float	MainGunDownwardFireArc;	// in degrees
var()	float	BowGunRotationSpeed;	// degrees per second
var()	float	BowGunRotateMax;		// in degrees (min/max bow machine gun rotation in all directions)

var Cue		MainGunFireSound;
var string	MainGunFireSoundName;
var Cue		BowGunFireLoopSound;
var string	BowGunFireLoopSoundName;
var int		BowGunSoundHandle;
var Cue		BowGunFireOnceSound;
var string	BowGunFireOnceSoundName;

var Cue		TurretRotatingSound;  // turret rotating sound is looped
var string	TurretRotatingSoundName;
var int		TurretRotatingSoundHandle;
var Cue		TurretStopSound;
var string	TurretStopSoundName;
var float	TurretStartTime;
var float	TurretStopTime;
var int		AimErrorAI;

var bool	bWasCommanderAlive;
var bool	bWaitingHatchOpenAnimEnd;


simulated function PreBeginPlay()
{
	Mesh = Mesh( DynamicLoadObject( "k_vehicle_de.de_tank_panzer_IV", class'Mesh' ) );

	super.PreBeginPlay();
}

simulated function SetupTracks()
{
	Skins.Length = 4;
	Skins[0] = GbxShaderMaterial( DynamicLoadObject( "t_military_de.Vehicle.de_panzer_IV_gbx", class'GbxShaderMaterial' ) );
	Skins[1] = GbxShaderMaterial( DynamicLoadObject( "t_military_de.Vehicle.de_panzer_IV_alpha_gbx", class'GbxShaderMaterial' ) );
	Skins[2] = GbxShaderMaterial( DynamicLoadObject( "t_military_de.Vehicle.de_panzerIV_track_left", class'GbxShaderMaterial' ) );
	Skins[3] = GbxShaderMaterial( DynamicLoadObject( "t_military_de.Vehicle.de_panzerIV_track_right", class'GbxShaderMaterial' ) );

	LeftTrackTextureIndex = 2;
	RightTrackTextureIndex = 3;

	super.SetupTracks();
}

simulated function BeginPlay()
{
	SetPhysics(PHYS_Karma);
}

simulated simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();

	MainGunFireMode = Spawn(MainGunFireModeClass, self);
	if (MainGunFireMode == None)
		Log(name $ ".PostNetBeginPlay() - Couldn't spawn MainGunFireMode!!!");
	else
	{
		MainGunAmmo = Spawn(MainGunFireMode.AmmoClass, MainGunFireMode);
	}

	BowGunFireMode = Spawn(BowGunFireModeClass, self);
	if (BowGunFireMode == None)
		Log(name $ ".PostNetBeginPlay() - Couldn't spawn BowGunFireMode!!!");
	else
	{
		BowGunAmmo = Spawn(BowGunFireMode.AmmoClass, BowGunFireMode);
		BowGunTracerEmitter = Spawn(gbxAmmo(BowGunAmmo).Default.BulletTracerClass, self);
	}

	SpawnMuzzleFlashEmitters();

	CreateSounds();

	BowGunTracerCount = 0;
	PreviousTurretYaw = TurretYaw;
	TurretStartTime = -1.0f;
	TurretStopTime = -1.0f;

	bWasCommanderAlive = true;
	bWaitingHatchOpenAnimEnd = false;
}

simulated function CreateSounds()
{
	if ( MainGunFireSoundName != "" )
		MainGunFireSound = LoadSound( MainGunFireSoundName );
	if ( BowGunFireLoopSoundName != "" )
		BowGunFireLoopSound = LoadSound( BowGunFireLoopSoundName );
	if ( BowGunFireOnceSoundName != "" )
		BowGunFireOnceSound = LoadSound( BowGunFireOnceSoundName );
	if ( EngineIdleSoundName != "" )
		EngineIdleSound = Sound( DynamicLoadObject( EngineIdleSoundName, class'Sound' ) );
	if ( DrivingSoundName != "" )
		DrivingSound = Sound( DynamicLoadObject( DrivingSoundName, class'Sound' ) );

	if ( TurretRotatingSoundName != "" )
		TurretRotatingSound = LoadSound( TurretRotatingSoundName );
	if ( TurretStopSoundName != "" )
		TurretStopSound = LoadSound( TurretStopSoundName );
}

function CreateTriggers()
{
	local vector RotX, RotY, RotZ;
	local vector Offset;

    GetAxes(Rotation,RotX,RotY,RotZ);

	Offset = TankGrenadeTriggerOffset.X * RotX + TankGrenadeTriggerOffset.Y * RotY + TankGrenadeTriggerOffset.Z * RotZ;
	MyTankGrenadeTrigger = spawn(class'TankGrenadeTrigger', self,, Location + Offset);
	MyTankGrenadeTrigger.SetBase(self);
	MyTankGrenadeTrigger.SetCollisionSize(TankGrenadeTriggerRadius, 50 );
	MyTankGrenadeTrigger.SetCollision(true, false, false);
	MyTankGrenadeTrigger.m_aUseTarget = self;
	MyTankGrenadeTrigger.bHidden = true;

	MyTankGrenadeTrigger.bDisabled = true;
}

function Destroyed()
{
	Log( name $ ".(TankPanzerIV).Destroyed()", 'Tank' );

	if (MainGunFireMode != None)
		MainGunFireMode.Destroy();
	if (MainGunAmmo != None)
		MainGunAmmo.Destroy();

	if (BowGunFireMode != None)
		BowGunFireMode.Destroy();
	if (BowGunAmmo != None)
		BowGunAmmo.Destroy();
	if (BowGunTracerEmitter != None)
		BowGunTracerEmitter.Destroy();

	if (MyTankGrenadeTrigger != None)
		MyTankGrenadeTrigger.Destroy();

	super.Destroyed();
}

simulated event AnimEnd(int Channel)
{
	local rotator TurretRot;
	local rotator MainGunRot;

	if (bWaitingHatchOpenAnimEnd)
	{
		bWaitingHatchOpenAnimEnd = false;

		TurretRot.Pitch = 0;
		TurretRot.Yaw = TurretYaw;
		TurretRot.Roll = 0;

		SetBoneRotation(TurretBoneName, TurretRot, 0, 1.0);

		MainGunRot.Pitch = 0;
		MainGunRot.Yaw = 0;
		MainGunRot.Roll = MainGunPitch;

		SetBoneRotation(MainGunBoneName, MainGunRot, 0, 1.0);
	}
}

function bool CheckIfCommanderDied()
{
	if (CommanderPawn != None)
	{
		if (bWasCommanderAlive)
		{
			if (CommanderPawn.Health <= 0)
			{
				bWasCommanderAlive = false;
				return true;
			}

			bWasCommanderAlive = true;
		}
	}

	return false;
}

simulated function Tick(float DeltaTime)
{
	super.Tick( DeltaTime );

	if (!bHasCreatedTriggers)
	{
		CreateTriggers();
		bHasCreatedTriggers = true;
	}

	if (Health <= 0)  // died?
	{
		bNoSound = false;  // make sure sounds aren't played anymore on this tank

		AmbientSound = None;
		if (MyBulletListener != None)
			MyBulletListener.AmbientSound = None;

		if (BowGunSoundHandle != 0)
		{
			StopSound( BowGunSoundHandle, 0.1 );
			BowGunSoundHandle = 0;
		}
		if (TurretRotatingSoundHandle != 0)
		{
			StopSound( TurretRotatingSoundHandle, 0.1 );
			TurretRotatingSoundHandle = 0;
		}
		return;
	}

	if ( !bDisablePlayerUseableTriggers && CheckIfCommanderDied() )
	{
		MyTankGrenadeTrigger.bDisabled = false;  // enable the tank grenaded trigger
	}

//	if (Rise > 0)
//		TurretRotate(DeltaTime, true);  // counter-clockwise
//	else if (Rise < 0)
//		TurretRotate(DeltaTime, false);  // clockwise

	if (Rise > 0)
		MainGunRotate(DeltaTime, true);  // up
	else if (Rise < 0)
		MainGunRotate(DeltaTime, false);  // down

//	if (Rise > 0)
//		BowGunPitchChange(DeltaTime, true);  // up
//	else if (Rise < 0)
//		BowGunPitchChange(DeltaTime, false);  // down

//	if (Rise > 0)
//		BowGunYawChange(DeltaTime, true);  // to the left
//	else if (Rise < 0)
//		BowGunYawChange(DeltaTime, false);  // to the right

	if (bWeaponIsAltFiring && (fBowGunReFireTime < Level.Timeseconds))
	{
		FireBowGun();
	}

	if (abs(TurretYaw - OldTurretYaw) > 500)  // has turret moved a large amount?
	{
		if (TurretStartTime < 0)  // has start time not been set yet?
		{
			TurretStartTime = Level.TimeSeconds;  // set it
		}
		else if (TurretStartTime + 0.1 < Level.TimeSeconds)  // has it been going for at least 1/10th a second?
		{
			if (TurretRotatingSoundHandle == 0)
			{
				TurretRotatingSoundHandle = PlaySoundCue( TurretRotatingSound, SLOT_NONE, TransientSoundVolume,,,,false);
			}
			OldTurretYaw = TurretYaw;
			TurretStopTime = -1.0f;  // hasn't stopped yet
		}
	}
	else if ((TurretRotatingSoundHandle != 0) && (TurretYaw == PreviousTurretYaw))  // turret is rotating and turret might have stopped...
	{
		if (TurretStopTime < 0)  // has stop time not been set yet?
		{
			TurretStopTime = Level.TimeSeconds;
		}
		else if (TurretStopTime + 0.1 < Level.TimeSeconds)  // has it been stopped at least 1/10th of a second?
		{
			if (TurretRotatingSoundHandle != 0)
			{
				StopSound( TurretRotatingSoundHandle );
				TurretRotatingSoundHandle = 0;

				PlaySoundCue( TurretStopSound, SLOT_NONE, TransientSoundVolume,,,,false);
				TurretStartTime = -1.0f;  // hasn't started yet
			}
		}
	}

	PreviousTurretYaw = TurretYaw;
}


function TakeDamage(int Damage, Pawn instigatedBy, Vector Hitlocation, Vector Momentum, class<DamageType> DamageType, optional name HitBoxName)
{
	local int InitialHealth;

	InitialHealth = Health;

	Super.TakeDamage(Damage, instigatedBy, Hitlocation, Momentum, DamageType, HitBoxName);

	if ((InitialHealth > 0) && (Health <= 0))  // did we just now die?
	{
		// swap the skins out for the damaged versions...
		Skins[0] = GbxShaderMaterial( DynamicLoadObject( "t_military_de.Vehicle.de_panzer_dmg_gbx", class'GbxShaderMaterial' ) );
		Skins[1] = GbxShaderMaterial( DynamicLoadObject( "t_military_de.Vehicle.de_panzer_dmg_alpha_gbx", class'GbxShaderMaterial' ) );
		Skins[2] = GbxShaderMaterial( DynamicLoadObject( "t_military_de.Vehicle.de_panzerIV_dmg_track_left", class'GbxShaderMaterial' ) );
		Skins[3] = GbxShaderMaterial( DynamicLoadObject( "t_military_de.Vehicle.de_panzerIV_dmg_track_right", class'GbxShaderMaterial' ) );

		if (MyTankGrenadeTrigger != None)
		{
			MyTankGrenadeTrigger.Destroy();
			MyTankGrenadeTrigger = None;
		}
	}
	else if (float(Health) <= (float(default.Health) * 0.5f))  // tank more than 50% dead
	{
		if (!bForceHatchOpen && !bDisablePlayerUseableTriggers)
		{
			MyTankGrenadeTrigger.bDisabled = false;  // enable the tank grenaded trigger

			bForceHatchOpen = true;

			StopAnimating(true);  // clear all the animation channels (since the firing animation can mess up the blending of the hatch)

			bWaitingHatchOpenAnimEnd = true;

			if (CommanderPawn != None)
			{
				if (CommanderPawn.Health > 0)  // still alive?
					CommanderPawn.KillCommander(instigatedBy, DamageType);
				else
					PlayAnim(TankHatchOpenIdleAnim, 10.0f);  // open the hatch
			}
			else
			{
				PlayAnim(TankHatchOpenIdleAnim, 10.0f);  // open the hatch
			}
		}
	}
}

simulated function SpawnMuzzleFlashEmitters()
{
	local Emitter MuzzleFlash;

	MuzzleFlash = BowGunFireMode.GetMuzzleFlash();
	if (gbxMuzzleFlash(MuzzleFlash) != None)
		gbxMuzzleFlash(MuzzleFlash).InitializeMuzzleFlash();
}

simulated function rotator AdjustAimMainGun()
{
	local rotator MainGunRot;

	MainGunRot.Pitch = (Rotation.Pitch + MainGunPitch) & 65535;
	MainGunRot.Yaw = (Rotation.Yaw - TurretYaw) & 65535;
	MainGunRot.Roll = 0;

	return MainGunRot;
}

simulated function FireMainGun()
{
	local vector MainGunLoc;
	local rotator MainGunRot;
	local vector RotX, RotY, RotZ;
	local float YOffset, ZOffset;
	local vector EndTrace, X;
	local int AimError;
	local rotator AdjustedAim;
	local gbxTankShell TankShell;
//	local vector HitLocation, HitNormal;
//	local Actor HitActor;

	MainGunLoc = GetTagCoords( MainGunMuzzleBoneName ).origin;

	MainGunRot.Pitch = MainGunPitch;
	MainGunRot.Yaw = -TurretYaw;
	MainGunRot.Roll = 0;

	MainGunRot = Rotation + MainGunRot;

    GetAxes(MainGunRot,RotX,RotY,RotZ);

	MainGunLoc = MainGunLoc + MainGunEmitterOffset.X * RotX + MainGunEmitterOffset.Y * RotY + MainGunEmitterOffset.Z * RotZ;

	// spawn main gun muzzle flash emitter...
	spawn(MainGunFlashEmitterClass, None,, MainGunLoc, MainGunRot);

	MainGunRot.Pitch = 0;  // ignore main gun pitch for main gun smoke and dust emitter
	MainGunRot.Yaw = -TurretYaw;
	MainGunRot.Roll = 0;

	MainGunRot = Rotation + MainGunRot;

	// spawn main gun smoke and dust emitter...
	spawn(MainGunSmokeEmitterClass, None,, MainGunLoc, MainGunRot);

	YOffset = 0.0f;
	ZOffset = 0.0f;

	AimError = 10;

	AdjustedAim = AdjustAimMainGun();
	EndTrace = MainGunLoc + (YOffset + MainGunTraceAccuracy * (FRand() - 0.5 ) ) * RotY * 1000
		+ (ZOffset + MainGunTraceAccuracy * (FRand() - 0.5 )) * RotZ * 1000;
	X = vector(AdjustedAim);
	EndTrace += (10000 * X);

	AdjustedAim = rotator(EndTrace - MainGunLoc);

/*
	HitActor = Trace(HitLocation, HitNormal, EndTrace, MainGunLoc, true);

	if (HitActor != None)
	{
		Explosion(HitLocation + ExploWallOut * HitNormal);

		if ( (ExplosionDecal != None) && (Level.NetMode != NM_DedicatedServer) )
			Spawn(ExplosionDecal,self,,HitLocation, rotator(-HitNormal));
	}
*/

	TankShell = Spawn( class'gbxTankShell', self,, MainGunLoc, AdjustedAim );
	TankShell.Instigator = self;

	PlaySoundCue( MainGunFireSound, SLOT_NONE, TransientSoundVolume,,,,false);

	PlayMainGunFiringAnim(TurretYaw);
}

simulated function rotator AdjustAimBowGun()
{
	return Rotation - BowGunRotation;
}

simulated function FireBowGun()
{
	local vector BowGunLoc;
	local rotator BowGunRot;
	local vector RotX, RotY, RotZ;
	local float YOffset, ZOffset;
	local vector EndTrace, X;
	local int AimError;
	local rotator AdjustedAim;
	local Emitter MuzzleFlash;

	YOffset = 0.0f;
	ZOffset = 0.0f;

	if (BowGunFireMode != None)
	{
		fBowGunReFireTime = Level.TimeSeconds + fBowGunReFireDelay;

		BowGunLoc = GetTagCoords( BowGunMuzzleBoneName ).origin;

		BowGunRot = Rotation - BowGunRotation;

	    GetAxes(BowGunRot,RotX,RotY,RotZ);

		BowGunLoc = BowGunLoc + BowGunEmitterOffset.X * RotX + BowGunEmitterOffset.Y * RotY + BowGunEmitterOffset.Z * RotZ;

		Owner.MakeNoise(1.0);

		//AimError = BowGunFireMode.AimErrorAI;
		AimError = AimErrorAI;

		AdjustedAim = AdjustAimBowGun();
		EndTrace = BowGunLoc + (YOffset + BowGunTraceAccuracy * (FRand() - 0.5 ) ) * RotY * 1000
			+ (ZOffset + BowGunTraceAccuracy * (FRand() - 0.5 )) * RotZ * 1000;
		X = vector(AdjustedAim);
		EndTrace += (10000 * X);

		AdjustedAim = rotator(EndTrace - BowGunLoc);

		BowGunFireMode.DoTrace(BowGunLoc, AdjustedAim);

		BowGunTracerCount++;

		if ( BowGunTracerCount >= BowGunTracerFrequency )
		{
			BowGunTracerCount = 0;

			// Emit a tracer
			// GBX:PAD: Added this because it is now transient, so it won't be recreated in PostNetBeginPlay, so doing
			// this guarantees it will be created if not there.
			if (BowGunTracerEmitter == None)
			{
				BowGunTracerEmitter = Spawn(gbxAmmo(BowGunAmmo).Default.BulletTracerClass, self);
			}
			if( (BowGunTracerEmitter != None) )
				BowGunTracerEmitter.TriggerEmitters( BowGunLoc, AdjustedAim );
		}

		MuzzleFlash = BowGunFireMode.GetMuzzleFlash();

		MuzzleFlash.SetLocation(BowGunLoc);
		MuzzleFlash.SetRotation(BowGunRot);

		if ( MuzzleFlash.IsA( 'gbxMuzzleFlash' ) )
			gbxMuzzleFlash(MuzzleFlash).ShowMuzzleFlash();
	}
}

function KDriverEnter(Pawn P)
{
    Super.KDriverEnter(P);

	AmbientSound = EngineIdleSound;
}

function bool KDriverLeave(bool bForceLeave)
{
	local bool result;

	result = Super.KDriverLeave(bForceLeave);

	AmbientSound = None;
	if (MyBulletListener != None)
		MyBulletListener.AmbientSound = None;

	return result;
}

simulated function VehicleFire(bool bWasAltFire)
{
	local Emitter MuzzleFlash;

	super.VehicleFire( bWasAltFire );

	if (!bWasAltFire)  // fire the main gun
	{
		if (fMainGunReFireTime < Level.TimeSeconds)
		{
			fMainGunReFireTime = Level.TimeSeconds + fMainGunReFireDelay;

			FireMainGun();
		}
	}

	if (bWasAltFire)  // fire the machine gun
	{
		BowGunSoundHandle = PlaySoundCue( BowGunFireLoopSound, SLOT_NONE, TransientSoundVolume,,,,false);

		MuzzleFlash = BowGunFireMode.GetMuzzleFlash();

		if ( MuzzleFlash.IsA( 'gbxMuzzleFlash' ) )
			gbxMuzzleFlash(MuzzleFlash).FireButtonPressed();

		FireBowGun();
	}
}

simulated function VehicleCeaseFire(bool bWasAltFire)
{
	local Emitter MuzzleFlash;

	super.VehicleCeaseFire( bWasAltFire );

	if (bWasAltFire)  // stop the machine gun
	{
		StopSound( BowGunSoundHandle );
		PlaySoundCue( BowGunFireOnceSound, SLOT_NONE, TransientSoundVolume,,,,false);

		if ( MuzzleFlash.IsA( 'gbxMuzzleFlash' ) )
			gbxMuzzleFlash(MuzzleFlash).FireButtonReleased();
	}
}


simulated function TurretRotate(float DeltaTime, bool bCounterClockwise)
{
	local float YawOffset;
	local rotator TurretRot;

	// Rotate CW or CCW...
	YawOffset = (TurretRotationSpeed * DeltaTime / 360.0) * 65536;

	if (bCounterClockwise)
		TurretYaw = (TurretYaw + int(YawOffset)) & 65535;
	else
		TurretYaw = (TurretYaw - int(YawOffset)) & 65535;

	TurretRot.Pitch = 0;
	TurretRot.Yaw = TurretYaw;
	TurretRot.Roll = 0;

	SetBoneRotation(TurretBoneName, TurretRot, 0, 1.0);
}

simulated function MainGunRotate(float DeltaTime, bool bUp)
{
	local float MaxPitchUp, MaxPitchDown;
	local float PitchOffset;
	local rotator MainGunRot;

	MaxPitchUp = (MainGunUpwardFireArc / 360.0) * 65536;
	MaxPitchDown = (MainGunDownwardFireArc / 360.0) * 65536;
	PitchOffset = (MainGunRotationSpeed * DeltaTime / 360.0) * 65536;

	if (bUp)
		MainGunPitch = MainGunPitch + int(PitchOffset);
	else
		MainGunPitch = MainGunPitch - int(PitchOffset);

	MainGunPitch = Clamp(MainGunPitch, -MaxPitchDown, MaxPitchUp);

	MainGunRot.Pitch = 0;
	MainGunRot.Yaw = 0;
	MainGunRot.Roll = MainGunPitch;

	SetBoneRotation(MainGunBoneName, MainGunRot, 0, 1.0);
}

simulated function BowGunPitchChange(float DeltaTime, bool bUp)
{
	local float MaxPitch, MinPitch;
	local float PitchOffset;
	local rotator BowGunRot;

	MaxPitch = (BowGunRotateMax / 360.0) * 65536;
	MinPitch = (-BowGunRotateMax / 360.0) * 65536;
	PitchOffset = (BowGunRotationSpeed * DeltaTime / 360.0) * 65536;

	if (bUp)
		BowGunRotation.Pitch = BowGunRotation.Pitch - PitchOffset;
	else
		BowGunRotation.Pitch = BowGunRotation.Pitch + PitchOffset;

	BowGunRotation.Pitch = Clamp(BowGunRotation.Pitch, MinPitch, MaxPitch);

	BowGunRot.Pitch = BowGunRotation.Yaw;
	BowGunRot.Yaw = BowGunRotation.Pitch;
	BowGunRot.Roll = 0;

	SetBoneRotation(BowGunBoneName, BowGunRot, 0, 1.0);
}

simulated function BowGunYawChange(float DeltaTime, bool bLeft)
{
	local float MaxYaw, MinYaw;
	local float YawOffset;
	local rotator BowGunRot;

	MaxYaw = (BowGunRotateMax / 360.0) * 65536;
	MinYaw = (-BowGunRotateMax / 360.0) * 65536;
	YawOffset = (BowGunRotationSpeed * DeltaTime / 360.0) * 65536;

	if (bLeft)
		BowGunRotation.Yaw = BowGunRotation.Yaw + YawOffset;
	else
		BowGunRotation.Yaw = BowGunRotation.Yaw - YawOffset;

	BowGunRotation.Yaw = Clamp(BowGunRotation.Yaw, MinYaw, MaxYaw);

	BowGunRot.Pitch = BowGunRotation.Yaw;
	BowGunRot.Yaw = BowGunRotation.Pitch;
	BowGunRot.Roll = 0;

	SetBoneRotation(BowGunBoneName, BowGunRot, 0, 1.0);
}

function GrenadeHasBeenPlanted(Pawn GrenadePlanter)
{
	local rotator TurretRot;
	local TankGrenade MyTankGrenade;

	Log(name $ ".(TankPanzerIV).GrenadeHasBeenPlanted() - planter = " $ GrenadePlanter.name, 'Tank');

	TurretYaw = 0;

	TurretRot.Pitch = 0;
	TurretRot.Yaw = TurretYaw;
	TurretRot.Roll = 0;

	SetBoneRotation(TurretBoneName, TurretRot, 0, 1.0);

	if (CommanderPawn != None)
	{
		CommanderPawn.bAllowDamage = false;

		if (CommanderPawn.HitCylinder != None)
			CommanderPawn.HitCylinder.bHidden = true;

		CommanderPawn.GotoState('GrenadePlanted');
	}

	MyTankGrenade = spawn(class'TankGrenade', GrenadePlanter,, Location, Rotation);
	MyTankGrenade.Instigator = GrenadePlanter;
	MyTankGrenade.bActivated = true;

	Super.GrenadeHasBeenPlanted( GrenadePlanter );
}


defaultproperties
{
	DrawType=DT_Mesh
	Mesh=None  // use DymamicLoadObject instead
	EditorMeshName="k_vehicle_de.de_tank_panzer_IV"
    Physics=PHYS_None

	Health=4
	CollisionHeight=2.0
	CollisionRadius=2.0
	VehicleCollisionHeight=128.0
	VehicleCollisionRadius=300.0
	BaseEyeHeight=180
	EyeHeight=180
	bTurnInPlace=true
	bCanStrafe=true

	MinDamageAmount=300
	HitPointsFront=1
	HitPointsSide=2
	HitPointsRear=3
	HitPointsTurret=2
	StopMovingHealth=1

	FPCamPos=(X=-10,Y=-30,Z=140)
	TPCamLookat=(X=-100,Y=0,Z=100)
	TPCamDistance=1200

	bDrawDriverInTP=true
	bDrawMeshInFP=true

	MaxViewYaw=16000
	MaxViewPitch=16000

	DrivePos=(X=105,Y=-50,Z=85)
	DriveRot=(Pitch=0,Yaw=0,Roll=0)

	ExitPositions(0)=(Y=-415.000000,Z=100.000000)
	ExitPositions(1)=(Y=415.000000,Z=100.000000)
	ExitPositions(2)=(Y=0.000000,Z=-400.000000)
	ExitPositions(3)=(Y=0.000000,Z=400.000000)

	TurretBoneName="Turret"
	MainGunBoneName="main_gun"
	MainGunMuzzleBoneName="main_gun_muzzle"
	BowGunBoneName="bow_mg"
	BowGunMuzzleBoneName="bow_mg_muzzle"

	MainGunFireModeClass=class'gbxInventory.FirePanzerMainGun'
	MainGunTraceAccuracy=+0.1
	BowGunFireModeClass=class'gbxInventory.FirePanzerBowGun'
	BowGunTraceAccuracy=+0.4
	BowGunTracerFrequency=3

	MainGunFlashEmitterClass=class'gbxEffects.MuzzleFlashStuartTankMainGun'
	MainGunSmokeEmitterClass=class'gbxEffects.TankStuartMainGunSmokeAndDust'

	MainGunEmitterOffset=(X=10,Y=0,Z=0)
	BowGunEmitterOffset=(X=5,Y=0,Z=0)

	ExplosionDecal=class'TankProjectileScorch'
	ExploWallOut=1.0

	// sounds
	MainGunFireSoundName="V_TANK_MARK_IV.turret_fire"
	BowGunFireLoopSoundName="V_TANK_MARK_IV.MACHINEGUN_LOOP_A"
	BowGunFireOnceSoundName="V_TANK_MARK_IV.MACHINEGUN_SHOT_A"

	EngineIdleSoundName="V_TANK_MARK_IV.idle"
	DrivingSoundName="V_TANK_MARK_IV.driving_loop"

	TurretRotatingSoundName="V_TANK_MARK_IV.turret_loop"
	TurretStopSoundName="V_TANK_MARK_IV.turret_stop"

	// tank driving max pitch speed
	MaxPitchSpeed=200.0

	fMainGunReFireDelay=10.0
	fBowGunReFireDelay=0.07

	TurretRotationSpeed=18.0

	MainGunRotationSpeed=36.0
	MainGunUpwardFireArc=20.0
	MainGunDownwardFireArc=12.0

	BowGunRotationSpeed=90.0
	BowGunRotateMax=15.0

	// thruster positions left to right, front to back...
	Thrusters(0)=(BoneName="spokewheel_left",ThrusterOffset=60.0,bHasSuspension=false,NumWheels=1,WheelIndexes[0]=0,bChecksForWater=true)
	Thrusters(1)=(BoneName="spokewheel_right",ThrusterOffset=60.0,bHasSuspension=false,NumWheels=1,WheelIndexes[0]=1,bChecksForWater=true)
	Thrusters(2)=(BoneName="track_left_1",ThrusterOffset=45.0,bHasSuspension=true,SuspensionTravel=15.0,SuspensionTravelRate=100.0,NumWheels=2,WheelIndexes[0]=2,WheelIndexes[1]=4)
	Thrusters(3)=(BoneName="track_right_1",ThrusterOffset=45.0,bHasSuspension=true,SuspensionTravel=15.0,SuspensionTravelRate=100.0,NumWheels=2,WheelIndexes[0]=3,WheelIndexes[1]=5)
	Thrusters(4)=(BoneName="track_left_2",ThrusterOffset=45.0,bHasSuspension=true,SuspensionTravel=15.0,SuspensionTravelRate=100.0,NumWheels=2,WheelIndexes[0]=6,WheelIndexes[1]=8)
	Thrusters(5)=(BoneName="track_right_2",ThrusterOffset=45.0,bHasSuspension=true,SuspensionTravel=15.0,SuspensionTravelRate=100.0,NumWheels=2,WheelIndexes[0]=7,WheelIndexes[1]=9)
	Thrusters(6)=(BoneName="track_left_3",ThrusterOffset=45.0,bHasSuspension=true,SuspensionTravel=15.0,SuspensionTravelRate=100.0,NumWheels=2,WheelIndexes[0]=10,WheelIndexes[1]=12)
	Thrusters(7)=(BoneName="track_right_3",ThrusterOffset=45.0,bHasSuspension=true,SuspensionTravel=15.0,SuspensionTravelRate=100.0,NumWheels=2,WheelIndexes[0]=11,WheelIndexes[1]=13)
	Thrusters(8)=(BoneName="track_left_4",ThrusterOffset=45.0,bHasSuspension=true,SuspensionTravel=15.0,SuspensionTravelRate=100.0,NumWheels=2,WheelIndexes[0]=14,WheelIndexes[1]=16)
	Thrusters(9)=(BoneName="track_right_4",ThrusterOffset=45.0,bHasSuspension=true,SuspensionTravel=15.0,SuspensionTravelRate=100.0,NumWheels=2,WheelIndexes[0]=15,WheelIndexes[1]=17)
	Thrusters(10)=(BoneName="wheel_left_9",ThrusterOffset=60.0,bHasSuspension=false,NumWheels=1,WheelIndexes[0]=18,bChecksForWater=true)
	Thrusters(11)=(BoneName="wheel_right_9",ThrusterOffset=60.0,bHasSuspension=false,NumWheels=1,WheelIndexes[0]=19,bChecksForWater=true)

	// wheels left then right, front to back...
	TrackWheels(0)=(TrackIndex=0,WheelRadius=40.0,WheelBoneName="spokewheel_left",bHasSuspension=false)
	TrackWheels(1)=(TrackIndex=1,WheelRadius=40.0,WheelBoneName="spokewheel_right",bHasSuspension=false)
	TrackWheels(2)=(TrackIndex=0,WheelRadius=23.0,WheelBoneName="wheel_left_1",bHasSuspension=true)
	TrackWheels(3)=(TrackIndex=1,WheelRadius=23.0,WheelBoneName="wheel_right_1",bHasSuspension=true)
	TrackWheels(4)=(TrackIndex=0,WheelRadius=23.0,WheelBoneName="wheel_left_2",bHasSuspension=true)
	TrackWheels(5)=(TrackIndex=1,WheelRadius=23.0,WheelBoneName="wheel_right_2",bHasSuspension=true)
	TrackWheels(6)=(TrackIndex=0,WheelRadius=23.0,WheelBoneName="wheel_left_3",bHasSuspension=true)
	TrackWheels(7)=(TrackIndex=1,WheelRadius=23.0,WheelBoneName="wheel_right_3",bHasSuspension=true)
	TrackWheels(8)=(TrackIndex=0,WheelRadius=23.0,WheelBoneName="wheel_left_4",bHasSuspension=true)
	TrackWheels(9)=(TrackIndex=1,WheelRadius=23.0,WheelBoneName="wheel_right_4",bHasSuspension=true)
	TrackWheels(10)=(TrackIndex=0,WheelRadius=23.0,WheelBoneName="wheel_left_5",bHasSuspension=true)
	TrackWheels(11)=(TrackIndex=1,WheelRadius=23.0,WheelBoneName="wheel_right_5",bHasSuspension=true)
	TrackWheels(12)=(TrackIndex=0,WheelRadius=23.0,WheelBoneName="wheel_left_6",bHasSuspension=true)
	TrackWheels(13)=(TrackIndex=1,WheelRadius=23.0,WheelBoneName="wheel_right_6",bHasSuspension=true)
	TrackWheels(14)=(TrackIndex=0,WheelRadius=23.0,WheelBoneName="wheel_left_7",bHasSuspension=true)
	TrackWheels(15)=(TrackIndex=1,WheelRadius=23.0,WheelBoneName="wheel_right_7",bHasSuspension=true)
	TrackWheels(16)=(TrackIndex=0,WheelRadius=23.0,WheelBoneName="wheel_left_8",bHasSuspension=true)
	TrackWheels(17)=(TrackIndex=1,WheelRadius=23.0,WheelBoneName="wheel_right_8",bHasSuspension=true)
	TrackWheels(18)=(TrackIndex=0,WheelRadius=37.0,WheelBoneName="wheel_left_9",bHasSuspension=false)
	TrackWheels(19)=(TrackIndex=1,WheelRadius=37.0,WheelBoneName="wheel_right_9",bHasSuspension=false)

	HoverSoftness=0.05
	HoverPenScale=1.5
	HoverCheckDist=65

	UprightStiffness=500
	UprightDamping=300

	MaxThrust=33.3		// max speed in decimeters per second (0.1 * centimeters per second)

//	MaxSteerTorque=100.0
	MaxSteerTorque=200.0
	ForwardDampFactor=0.1
	LateralDampFactor=10.0
	ParkingDampFactor=0.8
//	SteerDampFactor=100.0
	SteerDampFactor=600.0
	PitchTorqueFactor=0.0
	PitchDampFactor=0.0
	BankTorqueFactor=0.0
	BankDampFactor=0.0
	TurnDampFactor=0.0
	DecelerateDampFactor=0.7
	SteerDecayDampFactor=400.0

	InvertSteeringThrottleThreshold=-0.1
	VehicleMass=12.0

	TrackVelocityScale=-153


	Begin Object Class=KarmaParamsRBFull Name=KParamsTank
		KStartEnabled=True
		KFriction=0.5
		KLinearDamping=0
		KAngularDamping=0
		bKNonSphericalInertia=False
		bHighDetailOnly=False
		bClientOnly=False
		bKDoubleTickRate=True
		bKStayUpright=True
		bKAllowRotate=True
		KInertiaTensor(0)=1.3
		KInertiaTensor(1)=0.0
		KInertiaTensor(2)=0.0
		KInertiaTensor(3)=4.0
		KInertiaTensor(4)=0.0
		KInertiaTensor(5)=4.5
		KCOMOffset=(X=0.0,Y=0.0,Z=0.0)
		Name="KParamsTank"
	End Object
	KParams=KarmaParams'KParamsTank'

	PawnTeam=TEAM_German
	TrackDustEmitterClass=class'TankStuartTrackDust'

	bSpawnCommander=true
	TankCommanderPawnOffset=(X=0,Y=2,Z=79)
	TankCommanderPawnRotation=(Pitch=0,Yaw=32768,Roll=0)
	TankCommanderPawnHitCylinderOffset=(X=0,Y=4,Z=129)
	TankCommanderPawnHitCylinderRotation=(Pitch=0,Yaw=0,Roll=0)

	// animations...
	MainFireFrontHatchOpen="fire_forward_open"
	MainFireFrontHatchClosed="fire_forward_closed"
	MainFireLeftHatchOpen="fire_left_open"
	MainFireLeftHatchClosed="fire_left_closed"
	MainFireRightHatchOpen="fire_right_open"
	MainFireRightHatchClosed="fire_right_closed"
	MainFireRearHatchOpen="fire_backward_open"
	MainFireRearHatchClosed="fire_backward_closed"

	TankHatchOpenIdleAnim="hatch_open"
	TankHatchClosedIdleAnim="hatch_closed"

	CommanderAnimPkg="a_hold_misc.panzer"

	CommanderIdleAnims(0)="panzer_commander_idle_1"
	CommanderIdleAnims(1)="panzer_commander_idle_2"
	CommanderIdleAnims(2)="panzer_commander_idle_3"
	CommanderIdleAnims(3)="panzer_looking_thru_binocs"

	CommanderHitPulledInAnim="panzer_commander_hit_pulled_in"
	CommanderFlinchCloseAnim="panzer_flinch_close_hatch"
	CommanderOpenHatchAnim="panzer_open_hatch"
	CommanderCloseHatchAnim="panzer_close_hatch"
	CommanderMoveOutAnim="panzer_gesture_forward"
	CommanderTankBlownupAnim="panzer_expires"

	TankCommanderHitAnim="commander_hit"
	TankCommanderFlinchAnim="flinch"
	TankCommanderOpenHatchAnim="open_hatch"
	TankCommanderCloseHatchAnim="close_hatch"
	TankCommanderTankBlownupAnim="expires"

	AimErrorAI=50

	CornerPointOffset(0)=(X=350,Y=90,Z=-50)		// front
	CornerPointOffset(1)=(X=350,Y=-90,Z=-50)	// front
	CornerPointOffset(2)=(X=195,Y=-215,Z=-50)	// left
	CornerPointOffset(3)=(X=-210,Y=-215,Z=-50)	// left
	CornerPointOffset(4)=(X=-350,Y=-90,Z=-50)	// rear
	CornerPointOffset(5)=(X=-350,Y=90,Z=-50)	// rear
	CornerPointOffset(6)=(X=-210,Y=215,Z=-50)	// right
	CornerPointOffset(7)=(X=195,Y=215,Z=-50)	// right

	CornerPointYawRotation(0)=0			// front - out away from the tank
	CornerPointYawRotation(1)=0			// front
	CornerPointYawRotation(2)=-16384	// left
	CornerPointYawRotation(3)=-16384	// left
	CornerPointYawRotation(4)=32768		// rear
	CornerPointYawRotation(5)=32768		// rear
	CornerPointYawRotation(6)=16384		// right
	CornerPointYawRotation(7)=16384		// right

	CornerPointIsLeftCorner(0)=1;	// front
	CornerPointIsLeftCorner(1)=0;	// front
	CornerPointIsLeftCorner(2)=1;	// left
	CornerPointIsLeftCorner(3)=0;	// left
	CornerPointIsLeftCorner(4)=1;	// rear
	CornerPointIsLeftCorner(5)=0;	// rear
	CornerPointIsLeftCorner(6)=1;	// right
	CornerPointIsLeftCorner(7)=0;	// right

	CornerPointIsStandingCorner(0)=0;	// front
	CornerPointIsStandingCorner(1)=0;	// front
	CornerPointIsStandingCorner(2)=0;	// left
	CornerPointIsStandingCorner(3)=1;	// left
	CornerPointIsStandingCorner(4)=1;	// rear
	CornerPointIsStandingCorner(5)=1;	// rear
	CornerPointIsStandingCorner(6)=1;	// right
	CornerPointIsStandingCorner(7)=0;	// right

	VehicleShadowDrawScale=6

	bHasCreatedTriggers=false
	TankGrenadeTriggerOffset=(X=-250,Y=0,Z=-50)
	TankGrenadeTriggerRadius=180;

	TankGrenadePlayerAnim="panzer_grenaded"  // in a_hold_misc.panzer
	TankGrenadeMeshAnimName="a_hold_misc.panzer"
	TankGrenadeMountAnimStartOffset=(X=-207.0,Y=186.0,Z=-50.0)
	TankGrenadeCameraStartOffset=(X=-50.0,Y=400.0,Z=300.0)
	TankGrenadeCameraEndOffset=(X=-50.0,Y=500.0,Z=200.0)
	TankGrenadeHeadZoomInOffset=(X=-112.0,Y=93.6,Z=195.7)
	TankGrenadeYawSet=1820
	TankGrenadeTeleportOffset=(X=-152.0,Y=40.0,Z=134.0)

	SmokeEmitterOffset=(X=-180.0,Y=0.0,Z=0.0)
	TankDeathEmitterOffset=(X=0.0,Y=0.0,Z=64.0)
	BlowedUpEmitterOffset=(X=0.0,Y=0.0,Z=64.0)

	CharacterSetupClass=class'CharacterSetupGermany'
}

class TankPanzerIVLongGun extends TankPanzerIV;


simulated function PreBeginPlay()
{
	Mesh = Mesh( DynamicLoadObject( "k_vehicle_de.de_tank_panzer_IV_long_gun", class'Mesh' ) );

	super(Tank).PreBeginPlay();
}

simulated function SetupTracks()
{
	Skins.Length = 4;
	Skins[0] = GbxShaderMaterial( DynamicLoadObject( "t_military_de.Vehicle.de_panzer_IV_gbx", class'GbxShaderMaterial' ) );
	Skins[1] = GbxShaderMaterial( DynamicLoadObject( "t_military_de.Vehicle.de_panzer_IV_alpha_gbx", class'GbxShaderMaterial' ) );
	Skins[2] = GbxShaderMaterial( DynamicLoadObject( "t_military_de.Vehicle.de_panzerIV_track_left", class'GbxShaderMaterial' ) );
	Skins[3] = GbxShaderMaterial( DynamicLoadObject( "t_military_de.Vehicle.de_panzerIV_track_right", class'GbxShaderMaterial' ) );

	LeftTrackTextureIndex = 2;
	RightTrackTextureIndex = 3;

	super(Tank).SetupTracks();
}

simulated function BeginPlay()
{
	SetPhysics(PHYS_Karma);
}

function TakeDamage(int Damage, Pawn instigatedBy, Vector Hitlocation, Vector Momentum, class<DamageType> DamageType, optional name HitBoxName)
{
	local int InitialHealth;

	InitialHealth = Health;

	Super.TakeDamage(Damage, instigatedBy, Hitlocation, Momentum, DamageType, HitBoxName);

	if ((InitialHealth > 0) && (Health <= 0))  // did we just now die?
	{
		// swap the skins out for the damaged versions...
		Skins[0] = GbxShaderMaterial( DynamicLoadObject( "t_military_de.Vehicle.de_panzer_dmg_gbx", class'GbxShaderMaterial' ) );
		Skins[1] = GbxShaderMaterial( DynamicLoadObject( "t_military_de.Vehicle.de_panzer_dmg_alpha_gbx", class'GbxShaderMaterial' ) );
		Skins[2] = GbxShaderMaterial( DynamicLoadObject( "t_military_de.Vehicle.de_panzerIV_dmg_track_left", class'GbxShaderMaterial' ) );
		Skins[3] = GbxShaderMaterial( DynamicLoadObject( "t_military_de.Vehicle.de_panzerIV_dmg_track_right", class'GbxShaderMaterial' ) );
	}
	else if (float(Health) <= (float(default.Health) * 0.5f))  // tank more than 50% dead
	{
		if (!bForceHatchOpen && !bDisablePlayerUseableTriggers)
		{
			MyTankGrenadeTrigger.bDisabled = false;  // enable the tank grenaded trigger

			bForceHatchOpen = true;

			StopAnimating(true);  // clear all the animation channels (since the firing animation can mess up the blending of the hatch)

			bWaitingHatchOpenAnimEnd = true;

			if (CommanderPawn != None)
			{
				if (CommanderPawn.Health > 0)  // still alive?
					CommanderPawn.KillCommander(instigatedBy, DamageType);
				else
					PlayAnim(TankHatchOpenIdleAnim, 10.0f);  // open the hatch
			}
			else
			{
				PlayAnim(TankHatchOpenIdleAnim, 10.0f);  // open the hatch
			}
		}
	}
}


defaultproperties
{
	DrawType=DT_Mesh
	Mesh=None  // use DymamicLoadObject instead
	EditorMeshName="k_vehicle_de.de_tank_panzer_IV_long_gun"
    Physics=PHYS_None

	Health=5

	CharacterSetupClass=class'CharacterSetupGermany'

	MainGunEmitterOffset=(X=10,Y=0,Z=0)
}
class TankSherman extends Tank;


var()	int		TurretYaw;
var()	int		PreviousTurretYaw;
var()	int		OldTurretYaw;  // to decide if turret rotating sounds need to be played
var()	int		MainGunPitch;
var()	rotator	BowGunRotation;

var()	name	TurretBoneName;
var()	name	MainGunBoneName;
var()	name	MainGunMuzzleBoneName;
var()	name	CoaxGunBoneName;
var()	name	CoaxGunMuzzleBoneName;
var()	name	BowGunBoneName;
var()	name	BowGunMuzzleBoneName;

var float 		MainGunTraceAccuracy;
var class<Projector> ExplosionDecal;
var float		ExploWallOut;	// distance to move explosions out from wall

var class<InstantFire> MainGunFireModeClass;
var InstantFire		MainGunFireMode;
var Ammunition 		MainGunAmmo;
var class<Emitter>	MainGunFlashEmitterClass;
var class<Emitter>	MainGunSmokeEmitterClass;
var() vector		MainGunEmitterOffset;

var class<InstantFire> CoaxGunFireModeClass;
var InstantFire		CoaxGunFireMode;
var Ammunition 		CoaxGunAmmo;
var float 			CoaxGunTraceAccuracy;
var transient gbxBulletTracer	CoaxGunTracerEmitter;
var() int			CoaxGunTracerFrequency;
var int				CoaxGunTracerCount;
var() vector		CoaxGunEmitterOffset;

var class<InstantFire> BowGunFireModeClass;
var InstantFire		BowGunFireMode;
var Ammunition 		BowGunAmmo;
var float 			BowGunTraceAccuracy;
var transient gbxBulletTracer	BowGunTracerEmitter;
var() int			BowGunTracerFrequency;
var int				BowGunTracerCount;
var() vector		BowGunEmitterOffset;

var		float	fMainGunReFireTime;
var()	float	fMainGunReFireDelay;
var		float	fCoaxGunReFireTime;
var()	float	fCoaxGunReFireDelay;
var		float	fBowGunReFireTime;
var()	float	fBowGunReFireDelay;

var()	float	TurretRotationSpeed;	// degrees per second
var()	float	MainGunRotationSpeed;	// degrees per second
var()	float	MainGunUpwardFireArc;	// in degrees
var()	float	MainGunDownwardFireArc;	// in degrees
var()	float	BowGunRotationSpeed;	// degrees per second
var()	float	BowGunRotateMax;		// in degrees (min/max bow machine gun rotation in all directions)

var Cue		MainGunFireSound;
var string	MainGunFireSoundName;
var Cue		CoaxGunFireLoopSound;
var string	CoaxGunFireLoopSoundName;
var int		CoaxGunSoundHandle;
var Cue		CoaxGunFireOnceSound;
var string	CoaxGunFireOnceSoundName;
var Cue		BowGunFireLoopSound;
var string	BowGunFireLoopSoundName;
var int		BowGunSoundHandle;
var Cue		BowGunFireOnceSound;
var string	BowGunFireOnceSoundName;

var Cue		TurretRotatingSound;  // turret rotating sound is looped
var string	TurretRotatingSoundName;
var int		TurretRotatingSoundHandle;
var Cue		TurretStopSound;
var string	TurretStopSoundName;
var float	TurretStartTime;
var float	TurretStopTime;
var int		AimErrorAICoax, AimErrorAIBow;

// player usable 50 cal. machine gun...
var WeapUSSherman50cal WeapUSSherman50calMachineGun;
var vector Weap50calOffset;
var AttachedPart ExtendedAttachment_50cal;
var string ExtendedAttachmentMeshName;

var bool 	bHasCreatedTriggers;
var gbxContextUseTrigger MachineGunRearTrigger;	// Trigger to allow the player to mount the machine gun.
var vector	MachineGunRearTriggerOffset;
var float	MachineGunRearTriggerRadius;
var gbxContextUseTrigger MachineGunTurretTrigger;	// Trigger to allow the player to mount the machine gun.
var vector	MachineGunTurretTriggerOffset;
var float	MachineGunTurretTriggerRadius;

simulated function PreBeginPlay()
{
	Mesh = Mesh( DynamicLoadObject( "k_vehicle_us.us_tank_sherman", class'Mesh' ) );

	super.PreBeginPlay();
}

simulated function SetupTracks()
{
	Skins.Length = 4;
	Skins[0] = GbxShaderMaterial( DynamicLoadObject( "t_military_us.Vehicle.us_sherman_gbx", class'GbxShaderMaterial' ) );
	Skins[1] = GbxShaderMaterial( DynamicLoadObject( "t_military_us.Vehicle.us_sherman_alpha_gbx", class'GbxShaderMaterial' ) );
	Skins[2] = GbxShaderMaterial( DynamicLoadObject( "t_military_us.Vehicle.us_sherman_t_left", class'GbxShaderMaterial' ) );
	Skins[3] = GbxShaderMaterial( DynamicLoadObject( "t_military_us.Vehicle.us_sherman_t_right", class'GbxShaderMaterial' ) );

	LeftTrackTextureIndex = 2;
	RightTrackTextureIndex = 3;

	super.SetupTracks();
}

simulated function BeginPlay()
{
	SetPhysics(PHYS_Karma);
}

simulated simulated function PostNetBeginPlay()
{
	local vector RotX, RotY, RotZ;
	local vector BoneLoc;

	Super.PostNetBeginPlay();

	MainGunFireMode = Spawn(MainGunFireModeClass, self);
	if (MainGunFireMode == None)
		Log(name $ ".PostNetBeginPlay() - Couldn't spawn MainGunFireMode!!!");
	else
	{
		MainGunAmmo = Spawn(MainGunFireMode.AmmoClass, MainGunFireMode);
	}

	CoaxGunFireMode = Spawn(CoaxGunFireModeClass, self);
	if (CoaxGunFireMode == None)
		Log(name $ ".PostNetBeginPlay() - Couldn't spawn CoaxGunFireMode!!!");
	else
	{
		CoaxGunAmmo = Spawn(CoaxGunFireMode.AmmoClass, CoaxGunFireMode);
		CoaxGunTracerEmitter = Spawn(gbxAmmo(CoaxGunAmmo).Default.BulletTracerClass, self);
	}

	BowGunFireMode = Spawn(BowGunFireModeClass, self);
	if (BowGunFireMode == None)
		Log(name $ ".PostNetBeginPlay() - Couldn't spawn BowGunFireMode!!!");
	else
	{
		BowGunAmmo = Spawn(BowGunFireMode.AmmoClass, BowGunFireMode);
		BowGunTracerEmitter = Spawn(gbxAmmo(BowGunAmmo).Default.BulletTracerClass, self);
	}

	ExtendedAttachment_50cal = Spawn( class'AttachedPart', self );
	ExtendedAttachment( ExtendedAttachment_50cal, '50cal', '50cal' );

    GetAxes(Rotation,RotX,RotY,RotZ);

	BoneLoc = GetBoneCoords(NinePointBlendBone).origin;
	WeapUSSherman50calMachineGun = spawn(class'WeapUSSherman50cal', self,, BoneLoc + Weap50calOffset.X * RotX + Weap50calOffset.Y * RotY + Weap50calOffset.Z * RotZ);
	WeapUSSherman50calMachineGun.SetBase(self);
	WeapUSSherman50calMachineGun.Tag = WeapUSSherman50calMachineGun.name;
	WeapUSSherman50calMachineGun.bHidden = true;

	WeapUSSherman50calMachineGun.SetMount(self);
	WeapUSSherman50calMachineGun.SetExtendedAttachment(ExtendedAttachment_50cal);
	WeapUSSherman50calMachineGun.SetAnims(ForwardLevelAnim, TankHatchClosedIdleAnim);

	SpawnMuzzleFlashEmitters();

	CreateSounds();

	CoaxGunTracerCount = 0;
	BowGunTracerCount = 0;
}

simulated function CreateSounds()
{
	if ( MainGunFireSoundName != "" )
		MainGunFireSound = LoadSound( MainGunFireSoundName );
	if ( CoaxGunFireLoopSoundName != "" )
		CoaxGunFireLoopSound = LoadSound( CoaxGunFireLoopSoundName );
	if ( CoaxGunFireOnceSoundName != "" )
		CoaxGunFireOnceSound = LoadSound( CoaxGunFireOnceSoundName );
	if ( BowGunFireLoopSoundName != "" )
		BowGunFireLoopSound = LoadSound( BowGunFireLoopSoundName );
	if ( BowGunFireOnceSoundName != "" )
		BowGunFireOnceSound = LoadSound( BowGunFireOnceSoundName );
	if ( EngineIdleSoundName != "" )
		EngineIdleSound = Sound( DynamicLoadObject( EngineIdleSoundName, class'Sound' ) );
	if ( DrivingSoundName != "" )
		DrivingSound = Sound( DynamicLoadObject( DrivingSoundName, class'Sound' ) );

	if ( TurretRotatingSoundName != "" )
		TurretRotatingSound = LoadSound( TurretRotatingSoundName );
	if ( TurretStopSoundName != "" )
		TurretStopSound = LoadSound( TurretStopSoundName );
}

function CreateTriggers()
{
	local vector RotX, RotY, RotZ;
	local vector Offset;

    GetAxes(Rotation,RotX,RotY,RotZ);

	Offset = MachineGunRearTriggerOffset.X * RotX + MachineGunRearTriggerOffset.Y * RotY + MachineGunRearTriggerOffset.Z * RotZ;
	MachineGunRearTrigger = spawn(class'gbxContextUseTrigger', self,, Location + Offset);
	MachineGunRearTrigger.SetBase(self);
	MachineGunRearTrigger.SetCollisionSize(MachineGunRearTriggerRadius, 50 );
	MachineGunRearTrigger.SetCollision(true, false, false);
	MachineGunRearTrigger.m_eUseType=UseTankMachineGun;
	MachineGunRearTrigger.Event = WeapUSSherman50calMachineGun.Tag;
	MachineGunRearTrigger.bHidden = true;
	if (bDisablePlayerUseableTriggers)
		MachineGunRearTrigger.bDisabled = true;

	Offset = MachineGunTurretTriggerOffset.X * RotX + MachineGunTurretTriggerOffset.Y * RotY + MachineGunTurretTriggerOffset.Z * RotZ;
	MachineGunTurretTrigger = spawn(class'gbxContextUseTrigger', self,, Location + Offset);
	MachineGunTurretTrigger.SetBase(self);
	MachineGunTurretTrigger.SetCollisionSize(MachineGunTurretTriggerRadius, 50);
	MachineGunTurretTrigger.SetCollision(true, false, false);
	MachineGunTurretTrigger.m_eUseType=UseTankMachineGun;
	MachineGunTurretTrigger.Event = WeapUSSherman50calMachineGun.Tag;
	MachineGunTurretTrigger.bHidden = true;
	if (bDisablePlayerUseableTriggers)
		MachineGunTurretTrigger.bDisabled = true;

	WeapUSSherman50calMachineGun.SetTriggers(MachineGunRearTrigger, MachineGunTurretTrigger);
}

function MatchStarting()
{
	local MeshAnimation	aMeshAnim;

	Super.MatchStarting();

	ExtendedAttachment( ExtendedAttachment_50cal, '50cal', '50cal' );

	aMeshAnim = MeshAnimation( DynamicLoadObject( ExtendedAttachmentMeshName, class'MeshAnimation' ) );
	if ( aMeshAnim != None )
	{
		if ( MeshAnim != None )
			UnlinkSkelAnim( MeshAnim, false );
		if (LinkSkelAnim( aMeshAnim ))
		{
			MeshAnim = aMeshAnim;
		}
		bInitializeAnimation = false;
	}

	RestartAnimQueue();
}

simulated function Destroyed()
{
	Log( name $ ".(TankSherman).Destroyed()", 'Tank' );

	if (MainGunFireMode != None)
		MainGunFireMode.Destroy();
	if (MainGunAmmo != None)
		MainGunAmmo.Destroy();

	if (CoaxGunFireMode != None)
		CoaxGunFireMode.Destroy();
	if (CoaxGunAmmo != None)
		CoaxGunAmmo.Destroy();
	if (CoaxGunTracerEmitter != None)
		CoaxGunTracerEmitter.Destroy();

	if (BowGunFireMode != None)
		BowGunFireMode.Destroy();
	if (BowGunAmmo != None)
		BowGunAmmo.Destroy();
	if (BowGunTracerEmitter != None)
		BowGunTracerEmitter.Destroy();

	if (WeapUSSherman50calMachineGun != None)
		WeapUSSherman50calMachineGun.Destroy();

	if (MachineGunRearTrigger != None)
		MachineGunRearTrigger.Destroy();
	if (MachineGunTurretTrigger != None)
		MachineGunTurretTrigger.Destroy();

	if (ExtendedAttachment_50cal != None)
		ExtendedAttachment_50cal.Destroy();

	super.Destroyed();
}

simulated function Tick(float DeltaTime)
{
	super.Tick( DeltaTime );

	if (!bHasCreatedTriggers)
	{
		CreateTriggers();
		bHasCreatedTriggers = true;
	}

	if (Health <= 0)  // died?
	{
		bNoSound = false;  // make sure sounds aren't played anymore on this tank

		AmbientSound = None;
		if (MyBulletListener != None)
			MyBulletListener.AmbientSound = None;

		if (CoaxGunSoundHandle != 0)
		{
			StopSound( CoaxGunSoundHandle, 0.1 );
			CoaxGunSoundHandle = 0;
		}
		if (BowGunSoundHandle != 0)
		{
			StopSound( BowGunSoundHandle, 0.1 );
			BowGunSoundHandle = 0;
		}
		if (TurretRotatingSoundHandle != 0)
		{
			StopSound( TurretRotatingSoundHandle, 0.1 );
			TurretRotatingSoundHandle = 0;
		}

		return;
	}

//	if (Rise > 0)
//		TurretRotate(DeltaTime, true);  // counter-clockwise
//	else if (Rise < 0)
//		TurretRotate(DeltaTime, false);  // clockwise

	if (Rise > 0)
		MainGunRotate(DeltaTime, true);  // up
	else if (Rise < 0)
		MainGunRotate(DeltaTime, false);  // down

//	if (Rise > 0)
//		BowGunPitchChange(DeltaTime, true);  // up
//	else if (Rise < 0)
//		BowGunPitchChange(DeltaTime, false);  // down

//	if (Rise > 0)
//		BowGunYawChange(DeltaTime, true);  // to the left
//	else if (Rise < 0)
//		BowGunYawChange(DeltaTime, false);  // to the right

	if (bWeaponIsAltFiring && (fBowGunReFireTime < Level.Timeseconds))
	{
		FireBowGun();
	}

//	if (bVehicleIsAltFiring && (fCoaxGunReFireTime < Level.Timeseconds))
//	{
//		FireCoaxGun();
//	}

	if (abs(TurretYaw - OldTurretYaw) > 500)  // has turret moved a large amount?
	{
		if (TurretStartTime < 0)  // has start time not been set yet?
		{
			TurretStartTime = Level.TimeSeconds;  // set it
		}
		else if (TurretStartTime + 0.1 < Level.TimeSeconds)  // has it been going for at least 1/10th a second?
		{
			if (TurretRotatingSoundHandle == 0)
			{
				TurretRotatingSoundHandle = PlaySoundCue( TurretRotatingSound, SLOT_NONE, TransientSoundVolume,,,,false);
			}
			OldTurretYaw = TurretYaw;
			TurretStopTime = -1.0f;  // hasn't stopped yet
		}
	}
	else if ((TurretRotatingSoundHandle != 0) && (TurretYaw == PreviousTurretYaw))  // turret is rotating and turret might have stopped...
	{
		if (TurretStopTime < 0)  // has stop time not been set yet?
		{
			TurretStopTime = Level.TimeSeconds;
		}
		else if (TurretStopTime + 0.1 < Level.TimeSeconds)  // has it been stopped at least 1/10th of a second?
		{
			if (TurretRotatingSoundHandle != 0)
			{
				StopSound( TurretRotatingSoundHandle );
				TurretRotatingSoundHandle = 0;

				PlaySoundCue( TurretStopSound, SLOT_NONE, TransientSoundVolume,,,,false);
				TurretStartTime = -1.0f;  // hasn't started yet
			}
		}
	}

	PreviousTurretYaw = TurretYaw;
}


function TakeDamage(int Damage, Pawn instigatedBy, Vector Hitlocation, Vector Momentum, class<DamageType> DamageType, optional name HitBoxName)
{
	local int InitialHealth;
	local WargamePawn WP;

	InitialHealth = Health;

	Super.TakeDamage(Damage, instigatedBy, Hitlocation, Momentum, DamageType, HitBoxName);

	if ((InitialHealth > 0) && (Health <= 0))  // did we just now die?
	{
		// swap the skins out for the damaged versions...
		Skins[0] = GbxShaderMaterial( DynamicLoadObject( "t_military_us.Vehicle.us_sherman_dmg_gbx", class'GbxShaderMaterial' ) );
		Skins[1] = GbxShaderMaterial( DynamicLoadObject( "t_military_us.Vehicle.us_sherman_dmg_alpha_gbx", class'GbxShaderMaterial' ) );
		Skins[2] = GbxShaderMaterial( DynamicLoadObject( "t_military_us.Vehicle.us_sherman_dmg_track_left", class'GbxShaderMaterial' ) );
		Skins[3] = GbxShaderMaterial( DynamicLoadObject( "t_military_us.Vehicle.us_sherman_dmg_track_right", class'GbxShaderMaterial' ) );

		// if the player is using the machine gun, kick them off before removing the triggers...
		WP = WargamePawn( Level.GetLocalPlayerController().Pawn );

		if ((WP != None) && (WP.bIsManningTurret))
		{
			WP.PrepareTurretDismount();
			WP.CompleteTurretDismount();
			WP.StartGoingToStand(true);  // don't play the animation
		}

		if (MachineGunRearTrigger != None)
		{
			MachineGunRearTrigger.Destroy();
			MachineGunRearTrigger = None;
		}
		if (MachineGunTurretTrigger != None)
		{
			MachineGunTurretTrigger.Destroy();
			MachineGunTurretTrigger = None;
		}
	}
}

simulated function SpawnMuzzleFlashEmitters()
{
	local Emitter MuzzleFlash;

	MuzzleFlash = CoaxGunFireMode.GetMuzzleFlash();
	if (gbxMuzzleFlash(MuzzleFlash) != None)
		gbxMuzzleFlash(MuzzleFlash).InitializeMuzzleFlash();

	MuzzleFlash = BowGunFireMode.GetMuzzleFlash();
	if (gbxMuzzleFlash(MuzzleFlash) != None)
		gbxMuzzleFlash(MuzzleFlash).InitializeMuzzleFlash();
}

simulated function rotator AdjustAimMainGun()
{
	local rotator MainGunRot;

	MainGunRot.Pitch = (Rotation.Pitch + MainGunPitch) & 65535;
	MainGunRot.Yaw = (Rotation.Yaw - TurretYaw) & 65535;
	MainGunRot.Roll = 0;

	return MainGunRot;
}

simulated function FireMainGun()
{
	local vector MainGunLoc;
	local rotator MainGunRot;
	local vector RotX, RotY, RotZ;
	local float YOffset, ZOffset;
	local vector EndTrace, X;
	local int AimError;
	local rotator AdjustedAim;
	local gbxTankShell TankShell;
//	local vector HitLocation, HitNormal;
//	local Actor HitActor;

	MainGunLoc = GetTagCoords( MainGunMuzzleBoneName ).origin;

	MainGunRot.Pitch = MainGunPitch;
	MainGunRot.Yaw = -TurretYaw;
	MainGunRot.Roll = 0;

	MainGunRot = Rotation + MainGunRot;

    GetAxes(MainGunRot,RotX,RotY,RotZ);

	MainGunLoc = MainGunLoc + MainGunEmitterOffset.X * RotX + MainGunEmitterOffset.Y * RotY + MainGunEmitterOffset.Z * RotZ;

	// spawn main gun muzzle flash emitter...
	spawn(MainGunFlashEmitterClass, None,, MainGunLoc, MainGunRot);

	MainGunRot.Pitch = 0;  // ignore main gun pitch for main gun smoke and dust emitter
	MainGunRot.Yaw = -TurretYaw;
	MainGunRot.Roll = 0;

	MainGunRot = Rotation + MainGunRot;

	// spawn main gun smoke and dust emitter...
	spawn(MainGunSmokeEmitterClass, None,, MainGunLoc, MainGunRot);

	YOffset = 0.0f;
	ZOffset = 0.0f;

	AimError = 10;

	AdjustedAim = AdjustAimMainGun();
	EndTrace = MainGunLoc + (YOffset + MainGunTraceAccuracy * (FRand() - 0.5 ) ) * RotY * 1000
		+ (ZOffset + MainGunTraceAccuracy * (FRand() - 0.5 )) * RotZ * 1000;
	X = vector(AdjustedAim);
	EndTrace += (10000 * X);

	AdjustedAim = rotator(EndTrace - MainGunLoc);

/*
	HitActor = Trace(HitLocation, HitNormal, EndTrace, MainGunLoc, true);

	if (HitActor != None)
	{
		Explosion(HitLocation + ExploWallOut * HitNormal);

		if ( (ExplosionDecal != None) && (Level.NetMode != NM_DedicatedServer) )
			Spawn(ExplosionDecal,self,,HitLocation, rotator(-HitNormal));
	}
*/

	TankShell = Spawn( class'gbxTankShell', self,, MainGunLoc, AdjustedAim );
	TankShell.Instigator = self;

	PlaySoundCue( MainGunFireSound, SLOT_NONE, TransientSoundVolume,,,,false);

	PlayMainGunFiringAnim(TurretYaw);
}

simulated function rotator AdjustAimCoaxGun()
{
	local rotator CoaxGunRot;

	CoaxGunRot.Pitch = (Rotation.Pitch + MainGunPitch) & 65535;
	CoaxGunRot.Yaw = (Rotation.Yaw - TurretYaw) & 65535;
	CoaxGunRot.Roll = 0;

	return CoaxGunRot;
}

simulated function FireCoaxGun()
{
	local vector CoaxGunLoc;
	local rotator CoaxGunRot;
	local vector RotX, RotY, RotZ;
	local float YOffset, ZOffset;
	local vector EndTrace, X;
	local int AimError;
	local rotator AdjustedAim;
	local Emitter MuzzleFlash;

	YOffset = 0.0f;
	ZOffset = 0.0f;

	if (CoaxGunFireMode != None)
	{
		fCoaxGunReFireTime = Level.TimeSeconds + fCoaxGunReFireDelay;

		CoaxGunLoc = GetTagCoords( CoaxGunMuzzleBoneName ).origin;

		CoaxGunRot.Pitch = Rotation.Pitch + MainGunPitch;
		CoaxGunRot.Yaw = Rotation.Yaw - TurretYaw;
		CoaxGunRot.Roll = 0;

	    GetAxes(CoaxGunRot,RotX,RotY,RotZ);

		CoaxGunLoc = CoaxGunLoc + CoaxGunEmitterOffset.X * RotX + CoaxGunEmitterOffset.Y * RotY + CoaxGunEmitterOffset.Z * RotZ;

		Owner.MakeNoise(1.0);

		//AimError = CoaxGunFireMode.AimErrorAI;
		AimError = AimErrorAICoax;

		AdjustedAim = AdjustAimCoaxGun();
		EndTrace = CoaxGunLoc + (YOffset + CoaxGunTraceAccuracy * (FRand() - 0.5 ) ) * RotY * 1000
			+ (ZOffset + CoaxGunTraceAccuracy * (FRand() - 0.5 )) * RotZ * 1000;
		X = vector(AdjustedAim);
		EndTrace += (10000 * X);

		AdjustedAim = rotator(EndTrace - CoaxGunLoc);

		CoaxGunFireMode.DoTrace(CoaxGunLoc, AdjustedAim);

		CoaxGunTracerCount++;

		if ( CoaxGunTracerCount >= CoaxGunTracerFrequency )
		{
			CoaxGunTracerCount = 0;

			// Emit a tracer
			// GBX:PAD: Added this because it is now transient, so it won't be recreated in PostNetBeginPlay, so doing
			// this guarantees it will be created if not there.
			if ( CoaxGunTracerEmitter == None )
			{
				CoaxGunTracerEmitter = Spawn(gbxAmmo(CoaxGunAmmo).Default.BulletTracerClass, self);
			}
			if( (CoaxGunTracerEmitter != None) )
				CoaxGunTracerEmitter.TriggerEmitters( CoaxGunLoc, AdjustedAim );
		}

		MuzzleFlash = CoaxGunFireMode.GetMuzzleFlash();

		MuzzleFlash.SetLocation(CoaxGunLoc);
		MuzzleFlash.SetRotation(CoaxGunRot);

		if ( MuzzleFlash.IsA( 'gbxMuzzleFlash' ) )
			gbxMuzzleFlash(MuzzleFlash).ShowMuzzleFlash();
	}
}

simulated function rotator AdjustAimBowGun()
{
	return Rotation - BowGunRotation;
}

simulated function FireBowGun()
{
	local vector BowGunLoc;
	local rotator BowGunRot;
	local vector RotX, RotY, RotZ;
	local float YOffset, ZOffset;
	local vector EndTrace, X;
	local int AimError;
	local rotator AdjustedAim;
	local Emitter MuzzleFlash;

	YOffset = 0.0f;
	ZOffset = 0.0f;

	if (BowGunFireMode != None)
	{
		fBowGunReFireTime = Level.TimeSeconds + fBowGunReFireDelay;

		BowGunLoc = GetTagCoords( BowGunMuzzleBoneName ).origin;

		BowGunRot = Rotation - BowGunRotation;

	    GetAxes(BowGunRot,RotX,RotY,RotZ);

		BowGunLoc = BowGunLoc + BowGunEmitterOffset.X * RotX + BowGunEmitterOffset.Y * RotY + BowGunEmitterOffset.Z * RotZ;

		Owner.MakeNoise(1.0);

		//AimError = BowGunFireMode.AimErrorAI;
		AimError = AimErrorAIBow;

		AdjustedAim = AdjustAimBowGun();
		EndTrace = BowGunLoc + (YOffset + BowGunTraceAccuracy * (FRand() - 0.5 ) ) * RotY * 1000
			+ (ZOffset + BowGunTraceAccuracy * (FRand() - 0.5 )) * RotZ * 1000;
		X = vector(AdjustedAim);
		EndTrace += (10000 * X);

		AdjustedAim = rotator(EndTrace - BowGunLoc);

		BowGunFireMode.DoTrace(BowGunLoc, AdjustedAim);

		BowGunTracerCount++;

		if ( BowGunTracerCount >= BowGunTracerFrequency )
		{
			BowGunTracerCount = 0;

			// Emit a tracer
			// GBX:PAD: Added this because it is now transient, so it won't be recreated in PostNetBeginPlay, so doing
			// this guarantees it will be created if not there.
			if ( BowGunTracerEmitter == None )
			{
				BowGunTracerEmitter = Spawn(gbxAmmo(BowGunAmmo).Default.BulletTracerClass, self);
			}
			if( (BowGunTracerEmitter != None) )
				BowGunTracerEmitter.TriggerEmitters( BowGunLoc, AdjustedAim );
		}

		MuzzleFlash = BowGunFireMode.GetMuzzleFlash();

		MuzzleFlash.SetLocation(BowGunLoc);
		MuzzleFlash.SetRotation(BowGunRot);

		if ( MuzzleFlash.IsA( 'gbxMuzzleFlash' ) )
			gbxMuzzleFlash(MuzzleFlash).ShowMuzzleFlash();
	}
}

function KDriverEnter(Pawn P)
{
    Super.KDriverEnter(P);

	AmbientSound = EngineIdleSound;
}

function bool KDriverLeave(bool bForceLeave)
{
	local bool result;

	result = Super.KDriverLeave(bForceLeave);

	AmbientSound = None;
	if (MyBulletListener != None)
		MyBulletListener.AmbientSound = None;

	return result;
}

simulated function VehicleFire(bool bWasAltFire)
{
	local Emitter MuzzleFlash;

	super.VehicleFire( bWasAltFire );

	if (!bWasAltFire)  // fire the main gun
	{
		if (fMainGunReFireTime < Level.TimeSeconds)
		{
			fMainGunReFireTime = Level.TimeSeconds + fMainGunReFireDelay;

			FireMainGun();
		}
	}

	if (bWasAltFire)  // fire the machine gun
	{
		BowGunSoundHandle = PlaySoundCue( BowGunFireLoopSound, SLOT_NONE, TransientSoundVolume,,,,false);

		MuzzleFlash = BowGunFireMode.GetMuzzleFlash();

		if ( MuzzleFlash.IsA( 'gbxMuzzleFlash' ) )
			gbxMuzzleFlash(MuzzleFlash).FireButtonPressed();

		FireBowGun();
	}

//	if (bWasAltFire)  // fire the machine gun
//	{
//		CoaxGunSoundHandle = PlaySound( CoaxGunFireLoopSound, SLOT_NONE, TransientSoundVolume,,,,false);
//
//		MuzzleFlash = CoaxFireMode.GetMuzzleFlash();
//
//		if ( MuzzleFlash.IsA( 'gbxMuzzleFlash' ) )
//			gbxMuzzleFlash(MuzzleFlash).FireButtonPressed();
//
//		FireCoaxGun();
//	}
}

simulated function VehicleCeaseFire(bool bWasAltFire)
{
	local Emitter MuzzleFlash;

	super.VehicleCeaseFire( bWasAltFire );

	if (bWasAltFire)  // stop the machine gun
	{
		StopSound( BowGunSoundHandle );
		PlaySoundCue( BowGunFireOnceSound, SLOT_NONE, TransientSoundVolume,,,,false);

		MuzzleFlash = BowGunFireMode.GetMuzzleFlash();

		if ( MuzzleFlash.IsA( 'gbxMuzzleFlash' ) )
			gbxMuzzleFlash(MuzzleFlash).FireButtonReleased();
	}

//	if (bWasAltFire)  // stop the machine gun
//	{
//		StopSound( CoaxGunSoundHandle );
//		PlaySound( CoaxGunFireOnceSound, SLOT_NONE, TransientSoundVolume,,,,false);
//
//		MuzzleFlash = CoaxGunFireMode.GetMuzzleFlash();
//
//		if ( MuzzleFlash.IsA( 'gbxMuzzleFlash' ) )
//			gbxMuzzleFlash(MuzzleFlash).FireButtonReleased();
//	}
}


simulated function TurretRotate(float DeltaTime, bool bCounterClockwise)
{
	local float YawOffset;
	local rotator TurretRot;

	// Rotate CW or CCW...
	YawOffset = (TurretRotationSpeed * DeltaTime / 360.0) * 65536;

	if (bCounterClockwise)
		TurretYaw = (TurretYaw + int(YawOffset)) & 65535;
	else
		TurretYaw = (TurretYaw - int(YawOffset)) & 65535;

	TurretRot.Pitch = TurretYaw;
	TurretRot.Yaw = 0;
	TurretRot.Roll = 0;

	SetBoneRotation(TurretBoneName, TurretRot, 0, 1.0);
}

simulated function MainGunRotate(float DeltaTime, bool bUp)
{
	local float MaxPitchUp, MaxPitchDown;
	local float PitchOffset;
	local rotator MainGunRot;

	MaxPitchUp = (MainGunUpwardFireArc / 360.0) * 65536;
	MaxPitchDown = (MainGunDownwardFireArc / 360.0) * 65536;
	PitchOffset = (MainGunRotationSpeed * DeltaTime / 360.0) * 65536;

	if (bUp)
		MainGunPitch = MainGunPitch + int(PitchOffset);
	else
		MainGunPitch = MainGunPitch - int(PitchOffset);

	MainGunPitch = Clamp(MainGunPitch, -MaxPitchDown, MaxPitchUp);

	MainGunRot.Pitch = 0;
	MainGunRot.Yaw = -MainGunPitch;
	MainGunRot.Roll = 0;

	SetBoneRotation(MainGunBoneName, MainGunRot, 0, 1.0);
}

simulated function BowGunPitchChange(float DeltaTime, bool bUp)
{
	local float MaxPitch, MinPitch;
	local float PitchOffset;
	local rotator BowGunRot;

	MaxPitch = (BowGunRotateMax / 360.0) * 65536;
	MinPitch = (-BowGunRotateMax / 360.0) * 65536;
	PitchOffset = (BowGunRotationSpeed * DeltaTime / 360.0) * 65536;

	if (bUp)
		BowGunRotation.Pitch = BowGunRotation.Pitch - PitchOffset;
	else
		BowGunRotation.Pitch = BowGunRotation.Pitch + PitchOffset;

	BowGunRotation.Pitch = Clamp(BowGunRotation.Pitch, MinPitch, MaxPitch);

	BowGunRot.Pitch = BowGunRotation.Yaw;
	BowGunRot.Yaw = BowGunRotation.Pitch;
	BowGunRot.Roll = 0;

	SetBoneRotation(BowGunBoneName, BowGunRot, 0, 1.0);
}

simulated function BowGunYawChange(float DeltaTime, bool bLeft)
{
	local float MaxYaw, MinYaw;
	local float YawOffset;
	local rotator BowGunRot;

	MaxYaw = (BowGunRotateMax / 360.0) * 65536;
	MinYaw = (-BowGunRotateMax / 360.0) * 65536;
	YawOffset = (BowGunRotationSpeed * DeltaTime / 360.0) * 65536;

	if (bLeft)
		BowGunRotation.Yaw = BowGunRotation.Yaw + YawOffset;
	else
		BowGunRotation.Yaw = BowGunRotation.Yaw - YawOffset;

	BowGunRotation.Yaw = Clamp(BowGunRotation.Yaw, MinYaw, MaxYaw);

	BowGunRot.Pitch = BowGunRotation.Yaw;
	BowGunRot.Yaw = BowGunRotation.Pitch;
	BowGunRot.Roll = 0;

	SetBoneRotation(BowGunBoneName, BowGunRot, 0, 1.0);
}

// do stuff necessary to allow player to mount this tank...
function PrepareToMount()
{
	if (Controller == None)  // if no controller...
	{
		// reset the turret and main gun to straight forward...
		TurretYaw = 0;
		SetBoneRotation(TurretBoneName, rot(0,0,0), 0, 1.0);

		MainGunPitch = 0;
		SetBoneRotation(MainGunBoneName, rot(0,0,0), 0, 1.0);
	}

	if (CommanderPawn != None)
		CommanderPawn.PrepareToMount();

	Super.PrepareToMount();
}

function CompleteMount()
{
	if (CommanderPawn != None)
		CommanderPawn.CompleteMount();
}

simulated function PlayMainGunFiringAnim(int TankTurretYaw)
{
	if (WeapUSSherman50calMachineGun.IsInUse())
		return;  // don't play firing animation if player is using the machine gun

	Super.PlayMainGunFiringAnim(TankTurretYaw);
}

defaultproperties
{
	DrawType=DT_Mesh
	Mesh=None  // use DymamicLoadObject instead
	EditorMeshName="k_vehicle_us.us_tank_sherman"
    Physics=PHYS_None

	Health=4
	CollisionHeight=2.0
	CollisionRadius=2.0
	VehicleCollisionHeight=128.0
	VehicleCollisionRadius=300.0
	BaseEyeHeight=180
	EyeHeight=180
	bTurnInPlace=true
	bCanStrafe=true

	MinDamageAmount=300
	HitPointsFront=1
	HitPointsSide=2
	HitPointsRear=3
	HitPointsTurret=2

	FPCamPos=(X=-10,Y=-30,Z=140)
	TPCamLookat=(X=-100,Y=0,Z=100)
	TPCamDistance=1200

	bDrawDriverInTP=true
	bDrawMeshInFP=true

	MaxViewYaw=16000
	MaxViewPitch=16000

	DrivePos=(X=105,Y=-50,Z=85)
	DriveRot=(Pitch=0,Yaw=0,Roll=0)

	ExitPositions(0)=(Y=-400.000000,Z=100.000000)
	ExitPositions(1)=(Y=400.000000,Z=100.000000)

	TurretBoneName="Turret"
	MainGunBoneName="main_gun"
	MainGunMuzzleBoneName="main_gun_muzzle"
	CoaxGunBoneName="coax_base"
	CoaxGunMuzzleBoneName="coax_mg_muzzle"
	BowGunBoneName="bow_mg"
	BowGunMuzzleBoneName="bow_mg_muzzle"

	MainGunFireModeClass=class'gbxInventory.FireShermanMainGun'
	MainGunTraceAccuracy=+0.1
	CoaxGunFireModeClass=class'gbxInventory.FireShermanCoaxGun'
	CoaxGunTraceAccuracy=+0.4
	CoaxGunTracerFrequency=3
	BowGunFireModeClass=class'gbxInventory.FireShermanBowGun'
	BowGunTraceAccuracy=+0.4
	BowGunTracerFrequency=3

	MainGunFlashEmitterClass=class'gbxEffects.MuzzleFlashShermanTankMainGun'
	MainGunSmokeEmitterClass=class'gbxEffects.TankShermanMainGunSmokeAndDust'

	MainGunEmitterOffset=(X=10,Y=0,Z=0)
	CoaxGunEmitterOffset=(X=5,Y=0,Z=0)
	BowGunEmitterOffset=(X=5,Y=0,Z=0)

	//GBX:PAD: This sound file is bad, so until it gets fixed, it is messing up the creating of linear load files.
//	ImpactSound=Sound'explosions.close_artillery_d'
	ExplosionDecal=class'TankProjectileScorch'
	ExploWallOut=1.0

	// sounds
	MainGunFireSoundName="V_TANK_SHERMAN.turret_fire"
	BowGunFireLoopSoundName="V_TANK_SHERMAN.MACHINEGUN_LOOP_A"
	BowGunFireOnceSoundName="V_TANK_SHERMAN.MACHINEGUN_SHOT_A"
	CoaxGunFireLoopSoundName="V_TANK_SHERMAN.MACHINEGUN_LOOP_B"
	CoaxGunFireOnceSoundName="V_TANK_SHERMAN.MACHINEGUN_SHOT_B"

	EngineIdleSoundName="V_TANK_SHERMAN.idle"
	DrivingSoundName="V_TANK_SHERMAN.driving_loop"

	TurretRotatingSoundName="V_TANK_SHERMAN.turret_loop"
	TurretStopSoundName="V_TANK_SHERMAN.turret_stop"

	// tank driving max pitch speed
	MaxPitchSpeed=200.0

	fMainGunReFireDelay=8.0
	fCoaxGunReFireDelay=0.07
	fBowGunReFireDelay=0.07

	TurretRotationSpeed=24.0

	MainGunRotationSpeed=36.0
	MainGunUpwardFireArc=20.0
	MainGunDownwardFireArc=12.0

	BowGunRotationSpeed=90.0
	BowGunRotateMax=15.0

	// thruster positions left to right, front to back...
	Thrusters(0)=(BoneName="spokewheel_left",ThrusterOffset=60.0,bHasSuspension=false,NumWheels=1,WheelIndexes[0]=0,bChecksForWater=true)
	Thrusters(1)=(BoneName="spokewheel_right",ThrusterOffset=60.0,bHasSuspension=false,NumWheels=1,WheelIndexes[0]=1,bChecksForWater=true)
	Thrusters(2)=(BoneName="track_left_1",ThrusterOffset=45.0,bHasSuspension=true,SuspensionTravel=15.0,SuspensionTravelRate=100.0,NumWheels=1,WheelIndexes[0]=2)
	Thrusters(3)=(BoneName="track_right_1",ThrusterOffset=45.0,bHasSuspension=true,SuspensionTravel=15.0,SuspensionTravelRate=100.0,NumWheels=1,WheelIndexes[0]=3)
	Thrusters(4)=(BoneName="track_left_2",ThrusterOffset=45.0,bHasSuspension=true,SuspensionTravel=15.0,SuspensionTravelRate=100.0,NumWheels=1,WheelIndexes[0]=4)
	Thrusters(5)=(BoneName="track_right_2",ThrusterOffset=45.0,bHasSuspension=true,SuspensionTravel=15.0,SuspensionTravelRate=100.0,NumWheels=1,WheelIndexes[0]=5)
	Thrusters(6)=(BoneName="track_left_3",ThrusterOffset=45.0,bHasSuspension=true,SuspensionTravel=15.0,SuspensionTravelRate=100.0,NumWheels=1,WheelIndexes[0]=6)
	Thrusters(7)=(BoneName="track_right_3",ThrusterOffset=45.0,bHasSuspension=true,SuspensionTravel=15.0,SuspensionTravelRate=100.0,NumWheels=1,WheelIndexes[0]=7)
	Thrusters(8)=(BoneName="track_left_4",ThrusterOffset=45.0,bHasSuspension=true,SuspensionTravel=15.0,SuspensionTravelRate=100.0,NumWheels=1,WheelIndexes[0]=8)
	Thrusters(9)=(BoneName="track_right_4",ThrusterOffset=45.0,bHasSuspension=true,SuspensionTravel=15.0,SuspensionTravelRate=100.0,NumWheels=1,WheelIndexes[0]=9)
	Thrusters(10)=(BoneName="track_left_5",ThrusterOffset=45.0,bHasSuspension=true,SuspensionTravel=15.0,SuspensionTravelRate=100.0,NumWheels=1,WheelIndexes[0]=10)
	Thrusters(11)=(BoneName="track_right_5",ThrusterOffset=45.0,bHasSuspension=true,SuspensionTravel=15.0,SuspensionTravelRate=100.0,NumWheels=1,WheelIndexes[0]=11)
	Thrusters(12)=(BoneName="track_left_6",ThrusterOffset=45.0,bHasSuspension=true,SuspensionTravel=15.0,SuspensionTravelRate=100.0,NumWheels=1,WheelIndexes[0]=12)
	Thrusters(13)=(BoneName="track_right_6",ThrusterOffset=45.0,bHasSuspension=true,SuspensionTravel=15.0,SuspensionTravelRate=100.0,NumWheels=1,WheelIndexes[0]=13)
	Thrusters(14)=(BoneName="wheel_left_7",ThrusterOffset=70.0,bHasSuspension=false,NumWheels=1,WheelIndexes[0]=14,bChecksForWater=true)
	Thrusters(15)=(BoneName="wheel_right_7",ThrusterOffset=70.0,bHasSuspension=false,NumWheels=1,WheelIndexes[0]=15,bChecksForWater=true)

	// wheels left then right, front to back...
	TrackWheels(0)=(TrackIndex=0,WheelRadius=53.0,WheelBoneName="spokewheel_left",bHasSuspension=false)
	TrackWheels(1)=(TrackIndex=1,WheelRadius=53.0,WheelBoneName="spokewheel_right",bHasSuspension=false)
	TrackWheels(2)=(TrackIndex=0,WheelRadius=35.0,WheelBoneName="wheel_left_1",bHasSuspension=true)
	TrackWheels(3)=(TrackIndex=1,WheelRadius=35.0,WheelBoneName="wheel_right_1",bHasSuspension=true)
	TrackWheels(4)=(TrackIndex=0,WheelRadius=35.0,WheelBoneName="wheel_left_2",bHasSuspension=true)
	TrackWheels(5)=(TrackIndex=1,WheelRadius=35.0,WheelBoneName="wheel_right_2",bHasSuspension=true)
	TrackWheels(6)=(TrackIndex=0,WheelRadius=35.0,WheelBoneName="wheel_left_3",bHasSuspension=true)
	TrackWheels(7)=(TrackIndex=1,WheelRadius=35.0,WheelBoneName="wheel_right_3",bHasSuspension=true)
	TrackWheels(8)=(TrackIndex=0,WheelRadius=35.0,WheelBoneName="wheel_left_4",bHasSuspension=true)
	TrackWheels(9)=(TrackIndex=1,WheelRadius=35.0,WheelBoneName="wheel_right_4",bHasSuspension=true)
	TrackWheels(10)=(TrackIndex=0,WheelRadius=35.0,WheelBoneName="wheel_left_5",bHasSuspension=true)
	TrackWheels(11)=(TrackIndex=1,WheelRadius=35.0,WheelBoneName="wheel_right_5",bHasSuspension=true)
	TrackWheels(12)=(TrackIndex=0,WheelRadius=35.0,WheelBoneName="wheel_left_6",bHasSuspension=true)
	TrackWheels(13)=(TrackIndex=1,WheelRadius=35.0,WheelBoneName="wheel_right_6",bHasSuspension=true)
	TrackWheels(14)=(TrackIndex=0,WheelRadius=38.0,WheelBoneName="wheel_left_7",bHasSuspension=true)
	TrackWheels(15)=(TrackIndex=1,WheelRadius=38.0,WheelBoneName="wheel_right_7",bHasSuspension=true)

	HoverSoftness=0.05
	HoverPenScale=1.5
	HoverCheckDist=65

	UprightStiffness=500
	UprightDamping=300

	MaxThrust=56.64		// max speed in decimeters per second (0.1 * centimeters per second)

//	MaxSteerTorque=100.0
	MaxSteerTorque=200.0
	ForwardDampFactor=0.1
	LateralDampFactor=10.0
	ParkingDampFactor=0.8
//	SteerDampFactor=100.0
	SteerDampFactor=500.0
	PitchTorqueFactor=0.0
	PitchDampFactor=0.0
	BankTorqueFactor=0.0
	BankDampFactor=0.0
	TurnDampFactor=0.0
	DecelerateDampFactor=0.7
	SteerDecayDampFactor=400.0

	InvertSteeringThrottleThreshold=-0.1
	VehicleMass=12.0

	TrackVelocityScale=-153


	Begin Object Class=KarmaParamsRBFull Name=KParamsTank
		KStartEnabled=True
		KFriction=0.5
		KLinearDamping=0
		KAngularDamping=0
		bKNonSphericalInertia=False
		bHighDetailOnly=False
		bClientOnly=False
		bKDoubleTickRate=True
		bKStayUpright=True
		bKAllowRotate=True
		KInertiaTensor(0)=1.3
		KInertiaTensor(1)=0.0
		KInertiaTensor(2)=0.0
		KInertiaTensor(3)=4.0
		KInertiaTensor(4)=0.0
		KInertiaTensor(5)=4.5
		KCOMOffset=(X=0.0,Y=0.0,Z=0.0)
		Name="KParamsTank"
	End Object
	KParams=KarmaParams'KParamsTank'

	PawnTeam=TEAM_US
	TrackDustEmitterClass=class'TankShermanTrackDust'

	// Nine-point blending animations.
	ForwardDownAnim="50cal_forward_down"
	ForwardLevelAnim="50cal_forward_level"
	ForwardUpAnim="50cal_forward_up"
	LeftDownAnim="50cal_left_down"
	LeftLevelAnim="50cal_left_level"
	LeftUpAnim="50cal_left_up"
	RightDownAnim="50cal_right_down"
	RightLevelAnim="50cal_right_level"
	RightUpAnim="50cal_right_up"

	NinePointBlendBone="50cal_lateral"
	Weap50calOffset=(X=20,Y=0,Z=30)

	bHasCreatedTriggers=false
	MachineGunRearTriggerOffset=(X=-260,Y=0,Z=-50)
	MachineGunRearTriggerRadius=110;
	MachineGunTurretTriggerOffset=(X=-100,Y=0,Z=100)
	MachineGunTurretTriggerRadius=90;

	bSpawnCommander=true
	TankCommanderPawnOffset=(X=2,Y=-53,Z=0)
	TankCommanderPawnRotation=(Pitch=49152,Yaw=32768,Roll=16384)
	TankCommanderPawnHitCylinderOffset=(X=2,Y=-109,Z=0)
	TankCommanderPawnHitCylinderRotation=(Pitch=0,Yaw=0,Roll=0)

	// animations...
	MainFireFrontHatchOpen="fire_forward_hatch_open"
	MainFireFrontHatchClosed="fire_forward_hatch_closed"
	MainFireLeftHatchOpen="fire_left_hatch_open"
	MainFireLeftHatchClosed="fire_left_hatch_closed"
	MainFireRightHatchOpen="fire_right_hatch_open"
	MainFireRightHatchClosed="fire_right_hatch_closed"
	MainFireRearHatchOpen="fire_back_hatch_open"
	MainFireRearHatchClosed="fire_back_hatch_closed"

	TankHatchOpenIdleAnim="hatch_open"
	TankHatchClosedIdleAnim="hatch_closed"

	CommanderAnimPkg="a_hold_misc.sherman"
	ExtendedAttachmentMeshName="k_vehicle_us.us_tank_sherman"

	CommanderIdleAnims(0)="sherman_commander_idle_1"
	CommanderIdleAnims(1)="sherman_commander_idle_2"
	CommanderIdleAnims(2)="sherman_commander_idle_3"
	CommanderIdleAnims(3)="sherman_looking_thru_binocs"

	CommanderHitPulledInAnim="sherman_commander_hit_pulled_in"
	CommanderFlinchCloseAnim="sherman_flinch_close_hatch"
	CommanderOpenHatchAnim="sherman_open_hatch"
	CommanderCloseHatchAnim="sherman_close_hatch"
	CommanderMoveOutAnim="sherman_gesture_forward"
	CommanderTankBlownupAnim="sherman_expires"

	TankCommanderHitAnim="sherman_commander_hit_pulled_in"
	TankCommanderFlinchAnim="sherman_flinch"
	TankCommanderOpenHatchAnim="sherman_open_hatch"
	TankCommanderCloseHatchAnim="sherman_close_hatch"
	TankCommanderTankBlownUpAnim="sherman_expires"

	AimErrorAICoax=50
	AimErrorAIBow=50

	CornerPointOffset(0)=(X=360,Y=90,Z=-50)		// front
	CornerPointOffset(1)=(X=360,Y=-90,Z=-50)	// front
	CornerPointOffset(2)=(X=205,Y=-215,Z=-50)	// left
	CornerPointOffset(3)=(X=-230,Y=-215,Z=-50)	// left
	CornerPointOffset(4)=(X=-350,Y=-90,Z=-50)	// rear
	CornerPointOffset(5)=(X=-350,Y=90,Z=-50)	// rear
	CornerPointOffset(6)=(X=-230,Y=215,Z=-50)	// right
	CornerPointOffset(7)=(X=205,Y=215,Z=-50)	// right

	CornerPointYawRotation(0)=0			// front - out away from the tank
	CornerPointYawRotation(1)=0			// front
	CornerPointYawRotation(2)=-16384	// left
	CornerPointYawRotation(3)=-16384	// left
	CornerPointYawRotation(4)=32768		// rear
	CornerPointYawRotation(5)=32768		// rear
	CornerPointYawRotation(6)=16384		// right
	CornerPointYawRotation(7)=16384		// right

	CornerPointIsLeftCorner(0)=1;	// front
	CornerPointIsLeftCorner(1)=0;	// front
	CornerPointIsLeftCorner(2)=1;	// left
	CornerPointIsLeftCorner(3)=0;	// left
	CornerPointIsLeftCorner(4)=1;	// rear
	CornerPointIsLeftCorner(5)=0;	// rear
	CornerPointIsLeftCorner(6)=1;	// right
	CornerPointIsLeftCorner(7)=0;	// right

	CornerPointIsStandingCorner(0)=0;	// front
	CornerPointIsStandingCorner(1)=0;	// front
	CornerPointIsStandingCorner(2)=0;	// left
	CornerPointIsStandingCorner(3)=1;	// left
	CornerPointIsStandingCorner(4)=1;	// rear
	CornerPointIsStandingCorner(5)=1;	// rear
	CornerPointIsStandingCorner(6)=1;	// right
	CornerPointIsStandingCorner(7)=0;	// right

	VehicleShadowDrawScale=5

	SmokeEmitterOffset=(X=-180.0,Y=0.0,Z=0.0)
	TankDeathEmitterOffset=(X=0.0,Y=0.0,Z=64.0)
	BlowedUpEmitterOffset=(X=0.0,Y=0.0,Z=64.0)

	bFriendlyFireListen=true
	ScriptedViewBoneName="chassis"
	ScriptedViewOffset=(X=0,Y=0,Z=230.0f)

	CharacterSetupClass=class'CharacterSetupUSA'
	m_eCharacterType=USCharTankCommanderB
}
class TankStuart extends Tank;


var()	int		TurretYaw;
var()	int		PreviousTurretYaw;
var()	int		OldTurretYaw;  // to decide if turret rotating sounds need to be played
var()	int		MainGunPitch;
var()	rotator	BowGunRotation;

var()	name	TurretBoneName;
var()	name	MainGunBoneName;
var()	name	MainGunMuzzleBoneName;
var()	name	CoaxGunBoneName;
var()	name	CoaxGunMuzzleBoneName;
var()	name	BowGunBoneName;
var()	name	BowGunMuzzleBoneName;

var float 		MainGunTraceAccuracy;
var class<Projector> ExplosionDecal;
var float		ExploWallOut;	// distance to move explosions out from wall

var class<InstantFire> MainGunFireModeClass;
var InstantFire		MainGunFireMode;
var Ammunition 		MainGunAmmo;
var class<Emitter>	MainGunFlashEmitterClass;
var class<Emitter>	MainGunSmokeEmitterClass;
var() vector		MainGunEmitterOffset;

var class<InstantFire> CoaxGunFireModeClass;
var InstantFire		CoaxGunFireMode;
var Ammunition 		CoaxGunAmmo;
var float 			CoaxGunTraceAccuracy;
var transient gbxBulletTracer	CoaxGunTracerEmitter;
var() int			CoaxGunTracerFrequency;
var int				CoaxGunTracerCount;
var() vector		CoaxGunEmitterOffset;

var class<InstantFire> BowGunFireModeClass;
var InstantFire		BowGunFireMode;
var Ammunition 		BowGunAmmo;
var float 			BowGunTraceAccuracy;
var transient gbxBulletTracer	BowGunTracerEmitter;
var() int			BowGunTracerFrequency;
var int				BowGunTracerCount;
var() vector		BowGunEmitterOffset;

var		float	fMainGunReFireTime;
var()	float	fMainGunReFireDelay;
var		float	fCoaxGunReFireTime;
var()	float	fCoaxGunReFireDelay;
var		float	fBowGunReFireTime;
var()	float	fBowGunReFireDelay;

var()	float	TurretRotationSpeed;	// degrees per second
var()	float	MainGunRotationSpeed;	// degrees per second
var()	float	MainGunUpwardFireArc;	// in degrees
var()	float	MainGunDownwardFireArc;	// in degrees
var()	float	BowGunRotationSpeed;	// degrees per second
var()	float	BowGunRotateMax;		// in degrees (min/max bow machine gun rotation in all directions)

var Cue		MainGunFireSound;
var string	MainGunFireSoundName;
var Cue		CoaxGunFireLoopSound;
var string	CoaxGunFireLoopSoundName;
var int		CoaxGunSoundHandle;
var Cue		CoaxGunFireOnceSound;
var string	CoaxGunFireOnceSoundName;
var Cue		BowGunFireLoopSound;
var string	BowGunFireLoopSoundName;
var int		BowGunSoundHandle;
var Cue		BowGunFireOnceSound;
var string	BowGunFireOnceSoundName;

var Cue		TurretRotatingSound;  // turret rotating sound is looped
var string	TurretRotatingSoundName;
var int		TurretRotatingSoundHandle;
var Cue		TurretStopSound;
var string	TurretStopSoundName;
var float	TurretStartTime;
var float	TurretStopTime;

// player usable 30 cal. machine gun...
var WeapUSStuart30cal WeapUSStuart30calMachineGun;
var vector Weap30calOffset;
var AttachedPart ExtendedAttachment_30cal;
var string ExtendedAttachmentMeshName;

var bool 	bHasCreatedTriggers;
var gbxContextUseTrigger MachineGunRearTrigger;	// Trigger to allow the player to mount the machine gun.
var vector	MachineGunRearTriggerOffset;
var float	MachineGunRearTriggerRadius;
var gbxContextUseTrigger MachineGunTurretTrigger;	// Trigger to allow the player to mount the machine gun.
var vector	MachineGunTurretTriggerOffset;
var float	MachineGunTurretTriggerRadius;

var int		AimErrorAICoax, AimErrorAIBow;

simulated function PreBeginPlay()
{
	Mesh = Mesh( DynamicLoadObject( "k_vehicle_us.us_tank_stuart", class'Mesh' ) );

	super.PreBeginPlay();
}

simulated function SetupTracks()
{
	Skins.Length = 4;
	Skins[0] = GbxShaderMaterial( DynamicLoadObject( "t_military_us.Vehicle.us_stuart_f_gbx", class'GbxShaderMaterial' ) );
	Skins[1] = GbxShaderMaterial( DynamicLoadObject( "t_military_us.Vehicle.us_stuart_alpha_f_gbx", class'GbxShaderMaterial' ) );
	Skins[2] = GbxShaderMaterial( DynamicLoadObject( "t_military_us.Vehicle.us_stuart_t_left_f", class'GbxShaderMaterial' ) );
	Skins[3] = GbxShaderMaterial( DynamicLoadObject( "t_military_us.Vehicle.us_stuart_t_right_f", class'GbxShaderMaterial' ) );

	LeftTrackTextureIndex = 2;
	RightTrackTextureIndex = 3;

	super.SetupTracks();
}

simulated function BeginPlay()
{
	SetPhysics(PHYS_Karma);
}

simulated function PostNetBeginPlay()
{
	local vector RotX, RotY, RotZ;
	local vector BoneLoc;

	Super.PostNetBeginPlay();

	MainGunFireMode = Spawn(MainGunFireModeClass, self);
	if (MainGunFireMode == None)
		Log(name $ ".PostNetBeginPlay() - Couldn't spawn MainGunFireMode!!!");
	else
	{
		MainGunAmmo = Spawn(MainGunFireMode.AmmoClass, MainGunFireMode);
	}

	CoaxGunFireMode = Spawn(CoaxGunFireModeClass, self);
	if (CoaxGunFireMode == None)
		Log(name $ ".PostNetBeginPlay() - Couldn't spawn CoaxGunFireMode!!!");
	else
	{
		CoaxGunAmmo = Spawn(CoaxGunFireMode.AmmoClass, CoaxGunFireMode);
		CoaxGunTracerEmitter = Spawn(gbxAmmo(CoaxGunAmmo).Default.BulletTracerClass, self);
	}

	BowGunFireMode = Spawn(BowGunFireModeClass, self);
	if (BowGunFireMode == None)
		Log(name $ ".PostNetBeginPlay() - Couldn't spawn BowGunFireMode!!!");
	else
	{
		BowGunAmmo = Spawn(BowGunFireMode.AmmoClass, BowGunFireMode);
		BowGunTracerEmitter = Spawn(gbxAmmo(BowGunAmmo).Default.BulletTracerClass, self);
	}

	ExtendedAttachment_30cal = Spawn( class'AttachedPart', self );
	ExtendedAttachment( ExtendedAttachment_30cal, '30cal', '30cal' );

    GetAxes(Rotation,RotX,RotY,RotZ);

	BoneLoc = GetBoneCoords('30cal').origin;
	WeapUSStuart30calMachineGun = spawn(class'WeapUSStuart30cal', self,, BoneLoc + Weap30calOffset.X * RotX + Weap30calOffset.Y * RotY + Weap30calOffset.Z * RotZ);
	WeapUSStuart30calMachineGun.SetBase(self);
	WeapUSStuart30calMachineGun.Tag = WeapUSStuart30calMachineGun.name;
	WeapUSStuart30calMachineGun.bHidden = true;

	WeapUSStuart30calMachineGun.SetMount(self);
	WeapUSStuart30calMachineGun.SetExtendedAttachment(ExtendedAttachment_30cal);
	WeapUSStuart30calMachineGun.SetAnims(ForwardLevelAnim, TankHatchClosedIdleAnim);

	SpawnMuzzleFlashEmitters();

	CreateSounds();

	CoaxGunTracerCount = 0;
	BowGunTracerCount = 0;
}

simulated function CreateSounds()
{
	if ( MainGunFireSoundName != "" )
		MainGunFireSound = LoadSound( MainGunFireSoundName );
	if ( CoaxGunFireLoopSoundName != "" )
		CoaxGunFireLoopSound = LoadSound( CoaxGunFireLoopSoundName );
	if ( CoaxGunFireOnceSoundName != "" )
		CoaxGunFireOnceSound = LoadSound( CoaxGunFireOnceSoundName );
	if ( BowGunFireLoopSoundName != "" )
		BowGunFireLoopSound = LoadSound( BowGunFireLoopSoundName );
	if ( BowGunFireOnceSoundName != "" )
		BowGunFireOnceSound = LoadSound( BowGunFireOnceSoundName );
	if ( EngineIdleSoundName != "" )
		EngineIdleSound = Sound( DynamicLoadObject( EngineIdleSoundName, class'Sound' ) );
	if ( DrivingSoundName != "" )
		DrivingSound = Sound( DynamicLoadObject( DrivingSoundName, class'Sound' ) );

	if ( TurretRotatingSoundName != "" )
		TurretRotatingSound = LoadSound( TurretRotatingSoundName );
	if ( TurretStopSoundName != "" )
		TurretStopSound = LoadSound( TurretStopSoundName );
}

function CreateTriggers()
{
	local vector RotX, RotY, RotZ;
	local vector Offset;

    GetAxes(Rotation,RotX,RotY,RotZ);

	Offset = MachineGunRearTriggerOffset.X * RotX + MachineGunRearTriggerOffset.Y * RotY + MachineGunRearTriggerOffset.Z * RotZ;
	MachineGunRearTrigger = spawn(class'gbxContextUseTrigger', self,, Location + Offset);
	MachineGunRearTrigger.SetBase(self);
	MachineGunRearTrigger.SetCollisionSize(MachineGunRearTriggerRadius, 50 );
	MachineGunRearTrigger.SetCollision(true, false, false);
	MachineGunRearTrigger.m_eUseType=UseTankMachineGun;
	MachineGunRearTrigger.Event = WeapUSStuart30calMachineGun.Tag;
	MachineGunRearTrigger.bHidden = true;
	if (bDisablePlayerUseableTriggers)
		MachineGunRearTrigger.bDisabled = true;

	Offset = MachineGunTurretTriggerOffset.X * RotX + MachineGunTurretTriggerOffset.Y * RotY + MachineGunTurretTriggerOffset.Z * RotZ;
	MachineGunTurretTrigger = spawn(class'gbxContextUseTrigger', self,, Location + Offset);
	MachineGunTurretTrigger.SetBase(self);
	MachineGunTurretTrigger.SetCollisionSize(MachineGunTurretTriggerRadius, 50);
	MachineGunTurretTrigger.SetCollision(true, false, false);
	MachineGunTurretTrigger.m_eUseType=UseTankMachineGun;
	MachineGunTurretTrigger.Event = WeapUSStuart30calMachineGun.Tag;
	MachineGunTurretTrigger.bHidden = true;
	if (bDisablePlayerUseableTriggers)
		MachineGunTurretTrigger.bDisabled = true;

	WeapUSStuart30calMachineGun.SetTriggers(MachineGunRearTrigger, MachineGunTurretTrigger);
}

function MatchStarting()
{
	local MeshAnimation	aMeshAnim;

	Super.MatchStarting();

	ExtendedAttachment( ExtendedAttachment_30cal, '30cal', '30cal' );

	aMeshAnim = MeshAnimation( DynamicLoadObject( ExtendedAttachmentMeshName, class'MeshAnimation' ) );
	if ( aMeshAnim != None )
	{
		if ( MeshAnim != None )
			UnlinkSkelAnim( MeshAnim, false );
		if (LinkSkelAnim( aMeshAnim ))
		{
			MeshAnim = aMeshAnim;
		}
		bInitializeAnimation = false;
	}

	RestartAnimQueue();
}

simulated function Destroyed()
{
	Log( name $ ".(TankStuart).Destroyed()", 'Tank' );

	if (MainGunFireMode != None)
		MainGunFireMode.Destroy();

	if (MainGunAmmo != None)
		MainGunAmmo.Destroy();
	if (CoaxGunFireMode != None)
		CoaxGunFireMode.Destroy();
	if (CoaxGunAmmo != None)
		CoaxGunAmmo.Destroy();
	if (CoaxGunTracerEmitter != None)
		CoaxGunTracerEmitter.Destroy();

	if (BowGunFireMode != None)
		BowGunFireMode.Destroy();
	if (BowGunAmmo != None)
		BowGunAmmo.Destroy();
	if (BowGunTracerEmitter != None)
		BowGunTracerEmitter.Destroy();

	if (WeapUSStuart30calMachineGun != None)
		WeapUSStuart30calMachineGun.Destroy();

	if (MachineGunRearTrigger != None)
		MachineGunRearTrigger.Destroy();
	if (MachineGunTurretTrigger != None)
		MachineGunTurretTrigger.Destroy();

	if (ExtendedAttachment_30cal != None)
		ExtendedAttachment_30cal.Destroy();

	super.Destroyed();
}

simulated function Tick(float DeltaTime)
{
	super.Tick( DeltaTime );

	if (!bHasCreatedTriggers)
	{
		CreateTriggers();
		bHasCreatedTriggers = true;
	}

	if (Health <= 0)  // died?
	{
		bNoSound = false;  // make sure sounds aren't played anymore on this tank

		AmbientSound = None;
		if (MyBulletListener != None)
			MyBulletListener.AmbientSound = None;

		if (CoaxGunSoundHandle != 0)
		{
			StopSound( CoaxGunSoundHandle, 0.1 );
			CoaxGunSoundHandle = 0;
		}
		if (BowGunSoundHandle != 0)
		{
			StopSound( BowGunSoundHandle, 0.1 );
			BowGunSoundHandle = 0;
		}
		if (TurretRotatingSoundHandle != 0)
		{
			StopSound( TurretRotatingSoundHandle, 0.1 );
			TurretRotatingSoundHandle = 0;
		}

		return;
	}

	if (Rise > 0)
		TurretRotate(DeltaTime, true);  // counter-clockwise
	else if (Rise < 0)
		TurretRotate(DeltaTime, false);  // clockwise

//	if (Rise > 0)
//		MainGunRotate(DeltaTime, true);  // up
//	else if (Rise < 0)
//		MainGunRotate(DeltaTime, false);  // down

//	if (Rise > 0)
//		BowGunPitchChange(DeltaTime, true);  // up
//	else if (Rise < 0)
//		BowGunPitchChange(DeltaTime, false);  // down

//	if (Rise > 0)
//		BowGunYawChange(DeltaTime, true);  // to the left
//	else if (Rise < 0)
//		BowGunYawChange(DeltaTime, false);  // to the right

	if (bWeaponIsAltFiring && (fBowGunReFireTime < Level.Timeseconds))
	{
		FireBowGun();
	}

//	if (bVehicleIsAltFiring && (fCoaxGunReFireTime < Level.Timeseconds))
//	{
//		FireCoaxGun();
//	}

	if (abs(TurretYaw - OldTurretYaw) > 500)  // has turret moved a large amount?
	{
		if (TurretStartTime < 0)  // has start time not been set yet?
		{
			TurretStartTime = Level.TimeSeconds;  // set it
		}
		else if (TurretStartTime + 0.1 < Level.TimeSeconds)  // has it been going for at least 1/10th a second?
		{
			if (TurretRotatingSoundHandle == 0)
			{
				TurretRotatingSoundHandle = PlaySoundCue( TurretRotatingSound, SLOT_NONE, TransientSoundVolume,,,,false);
			}
			OldTurretYaw = TurretYaw;
			TurretStopTime = -1.0f;  // hasn't stopped yet
		}
	}
	else if ((TurretRotatingSoundHandle != 0) && (TurretYaw == PreviousTurretYaw))  // turret is rotating and turret might have stopped...
	{
		if (TurretStopTime < 0)  // has stop time not been set yet?
		{
			TurretStopTime = Level.TimeSeconds;
		}
		else if (TurretStopTime + 0.1 < Level.TimeSeconds)  // has it been stopped at least 1/10th of a second?
		{
			if (TurretRotatingSoundHandle != 0)
			{
				StopSound( TurretRotatingSoundHandle );
				TurretRotatingSoundHandle = 0;

				PlaySoundCue( TurretStopSound, SLOT_NONE, TransientSoundVolume,,,,false);
				TurretStartTime = -1.0f;  // hasn't started yet
			}
		}
	}

	PreviousTurretYaw = TurretYaw;
}


function TakeDamage(int Damage, Pawn instigatedBy, Vector Hitlocation, Vector Momentum, class<DamageType> DamageType, optional name HitBoxName)
{
	local int InitialHealth;
	local WargamePawn WP;

	InitialHealth = Health;

	Super.TakeDamage(Damage, instigatedBy, Hitlocation, Momentum, DamageType, HitBoxName);

	if ((InitialHealth > 0) && (Health <= 0))  // did we just now die?
	{
		// swap the skins out for the damaged versions...
		Skins[0] = GbxShaderMaterial( DynamicLoadObject( "t_military_us.Vehicle.us_stuart_dmg_gbx", class'GbxShaderMaterial' ) );
		Skins[1] = GbxShaderMaterial( DynamicLoadObject( "t_military_us.Vehicle.us_stuart_dmg_alpha_gbx", class'GbxShaderMaterial' ) );
		Skins[2] = GbxShaderMaterial( DynamicLoadObject( "t_military_us.Vehicle.us_stuart_dmg_track_left", class'GbxShaderMaterial' ) );
		Skins[3] = GbxShaderMaterial( DynamicLoadObject( "t_military_us.Vehicle.us_stuart_dmg_track_right", class'GbxShaderMaterial' ) );

		// if the player is using the machine gun, kick them off before removing the triggers...
		WP = WargamePawn( Level.GetLocalPlayerController().Pawn );

		if ((WP != None) && (WP.bIsManningTurret))
		{
			WP.PrepareTurretDismount();
			WP.CompleteTurretDismount();
			WP.StartGoingToStand(true);  // don't play the animation
		}

		if (MachineGunRearTrigger != None)
		{
			MachineGunRearTrigger.Destroy();
			MachineGunRearTrigger = None;
		}
		if (MachineGunTurretTrigger != None)
		{
			MachineGunTurretTrigger.Destroy();
			MachineGunTurretTrigger = None;
		}
	}
}

simulated function SpawnMuzzleFlashEmitters()
{
	local Emitter MuzzleFlash;

	MuzzleFlash = CoaxGunFireMode.GetMuzzleFlash();
	if (gbxMuzzleFlash(MuzzleFlash) != None)
		gbxMuzzleFlash(MuzzleFlash).InitializeMuzzleFlash();

	MuzzleFlash = BowGunFireMode.GetMuzzleFlash();
	if (gbxMuzzleFlash(MuzzleFlash) != None)
		gbxMuzzleFlash(MuzzleFlash).InitializeMuzzleFlash();
}

simulated function rotator AdjustAimMainGun()
{
	local rotator MainGunRot;

	MainGunRot.Pitch = (Rotation.Pitch + MainGunPitch) & 65535;
	MainGunRot.Yaw = (Rotation.Yaw - TurretYaw) & 65535;
	MainGunRot.Roll = 0;

	return MainGunRot;
}

simulated function FireMainGun()
{
	local vector MainGunLoc;
	local rotator MainGunRot;
	local vector RotX, RotY, RotZ;
	local float YOffset, ZOffset;
	local vector EndTrace, X;
	local int AimError;
	local rotator AdjustedAim;
	local gbxTankShell TankShell;

	MainGunLoc = GetTagCoords( MainGunMuzzleBoneName ).origin;

	MainGunRot.Pitch = MainGunPitch;
	MainGunRot.Yaw = -TurretYaw;
	MainGunRot.Roll = 0;

	MainGunRot = Rotation + MainGunRot;

    GetAxes(MainGunRot,RotX,RotY,RotZ);

	MainGunLoc = MainGunLoc + MainGunEmitterOffset.X * RotX + MainGunEmitterOffset.Y * RotY + MainGunEmitterOffset.Z * RotZ;

	// spawn main gun muzzle flash emitter...
	spawn(MainGunFlashEmitterClass, None,, MainGunLoc, MainGunRot);

	MainGunRot.Pitch = 0;  // ignore main gun pitch for main gun smoke and dust emitter
	MainGunRot.Yaw = -TurretYaw;
	MainGunRot.Roll = 0;

	MainGunRot = Rotation + MainGunRot;

	// spawn main gun smoke and dust emitter...
	spawn(MainGunSmokeEmitterClass, None,, MainGunLoc, MainGunRot);

	YOffset = 0.0f;
	ZOffset = 0.0f;

	AimError = 10;

	AdjustedAim = AdjustAimMainGun();
	EndTrace = MainGunLoc + (YOffset + MainGunTraceAccuracy * (FRand() - 0.5 ) ) * RotY * 1000
		+ (ZOffset + MainGunTraceAccuracy * (FRand() - 0.5 )) * RotZ * 1000;
	X = vector(AdjustedAim);
	EndTrace += (10000 * X);

	AdjustedAim = rotator(EndTrace - MainGunLoc);

	TankShell = Spawn( class'gbxTankShell', self,, MainGunLoc, AdjustedAim );
	TankShell.Instigator = self;

	PlaySoundCue( MainGunFireSound, SLOT_NONE, TransientSoundVolume,,,,false);

	PlayMainGunFiringAnim(TurretYaw);
}

simulated function rotator AdjustAimCoaxGun()
{
	local rotator CoaxGunRot;

	CoaxGunRot.Pitch = (Rotation.Pitch + MainGunPitch) & 65535;
	CoaxGunRot.Yaw = (Rotation.Yaw - TurretYaw) & 65535;
	CoaxGunRot.Roll = 0;

	return CoaxGunRot;
}

simulated function FireCoaxGun()
{
	local vector CoaxGunLoc;
	local rotator CoaxGunRot;
	local vector RotX, RotY, RotZ;
	local float YOffset, ZOffset;
	local vector EndTrace, X;
	local int AimError;
	local rotator AdjustedAim;
	local Emitter MuzzleFlash;

	YOffset = 0.0f;
	ZOffset = 0.0f;

	if (CoaxGunFireMode != None)
	{
		fCoaxGunReFireTime = Level.TimeSeconds + fCoaxGunReFireDelay;

		CoaxGunLoc = GetTagCoords( CoaxGunMuzzleBoneName ).origin;

		CoaxGunRot.Pitch = Rotation.Pitch + MainGunPitch;
		CoaxGunRot.Yaw = Rotation.Yaw - TurretYaw;
		CoaxGunRot.Roll = 0;

	    GetAxes(CoaxGunRot,RotX,RotY,RotZ);

		CoaxGunLoc = CoaxGunLoc + CoaxGunEmitterOffset.X * RotX + CoaxGunEmitterOffset.Y * RotY + CoaxGunEmitterOffset.Z * RotZ;

		Owner.MakeNoise(1.0);

		//AimError = CoaxGunFireMode.AimErrorAI;
		AimError = AimErrorAICoax;

		AdjustedAim = AdjustAimCoaxGun();
		EndTrace = CoaxGunLoc + (YOffset + CoaxGunTraceAccuracy * (FRand() - 0.5 ) ) * RotY * 1000
			+ (ZOffset + CoaxGunTraceAccuracy * (FRand() - 0.5 )) * RotZ * 1000;
		X = vector(AdjustedAim);
		EndTrace += (10000 * X);

		AdjustedAim = rotator(EndTrace - CoaxGunLoc);

		CoaxGunFireMode.DoTrace(CoaxGunLoc, AdjustedAim);

		CoaxGunTracerCount++;

		if ( CoaxGunTracerCount >= CoaxGunTracerFrequency )
		{
			CoaxGunTracerCount = 0;

			// Emit a tracer
			// GBX:PAD: Added this because it is now transient, so it won't be recreated in PostNetBeginPlay, so doing
			// this guarantees it will be created if not there.
			if ( CoaxGunTracerEmitter == None )
			{
				CoaxGunTracerEmitter = Spawn(gbxAmmo(CoaxGunAmmo).Default.BulletTracerClass, self);
			}
			if( (CoaxGunTracerEmitter != None) )
				CoaxGunTracerEmitter.TriggerEmitters( CoaxGunLoc, AdjustedAim );
		}

		MuzzleFlash = CoaxGunFireMode.GetMuzzleFlash();

		MuzzleFlash.SetLocation(CoaxGunLoc);
		MuzzleFlash.SetRotation(CoaxGunRot);

		if ( MuzzleFlash.IsA( 'gbxMuzzleFlash' ) )
			gbxMuzzleFlash(MuzzleFlash).ShowMuzzleFlash();
	}
}

simulated function rotator AdjustAimBowGun()
{
	return Rotation - BowGunRotation;
}

simulated function FireBowGun()
{
	local vector BowGunLoc;
	local rotator BowGunRot;
	local vector RotX, RotY, RotZ;
	local float YOffset, ZOffset;
	local vector EndTrace, X;
	local int AimError;
	local rotator AdjustedAim;
	local Emitter MuzzleFlash;

	YOffset = 0.0f;
	ZOffset = 0.0f;

	if (BowGunFireMode != None)
	{
		fBowGunReFireTime = Level.TimeSeconds + fBowGunReFireDelay;

		BowGunLoc = GetTagCoords( BowGunMuzzleBoneName ).origin;

		BowGunRot = Rotation - BowGunRotation;

	    GetAxes(BowGunRot,RotX,RotY,RotZ);

		BowGunLoc = BowGunLoc + BowGunEmitterOffset.X * RotX + BowGunEmitterOffset.Y * RotY + BowGunEmitterOffset.Z * RotZ;

		Owner.MakeNoise(1.0);

		//AimError = BowGunFireMode.AimErrorAI;
		AimError = AimErrorAIBow;

		AdjustedAim = AdjustAimBowGun();
		EndTrace = BowGunLoc + (YOffset + BowGunTraceAccuracy * (FRand() - 0.5 ) ) * RotY * 1000
			+ (ZOffset + BowGunTraceAccuracy * (FRand() - 0.5 )) * RotZ * 1000;
		X = vector(AdjustedAim);
		EndTrace += (10000 * X);

		AdjustedAim = rotator(EndTrace - BowGunLoc);

		BowGunFireMode.DoTrace(BowGunLoc, AdjustedAim);

		BowGunTracerCount++;

		if ( BowGunTracerCount >= BowGunTracerFrequency )
		{
			BowGunTracerCount = 0;

			// Emit a tracer
			// GBX:PAD: Added this because it is now transient, so it won't be recreated in PostNetBeginPlay, so doing
			// this guarantees it will be created if not there.
			if ( BowGunTracerEmitter == None )
			{
				BowGunTracerEmitter = Spawn(gbxAmmo(BowGunAmmo).Default.BulletTracerClass, self);
			}
			if( (BowGunTracerEmitter != None) )
				BowGunTracerEmitter.TriggerEmitters( BowGunLoc, AdjustedAim );
		}

		MuzzleFlash = BowGunFireMode.GetMuzzleFlash();

		MuzzleFlash.SetLocation(BowGunLoc);
		MuzzleFlash.SetRotation(BowGunRot);

		if ( MuzzleFlash.IsA( 'gbxMuzzleFlash' ) )
			gbxMuzzleFlash(MuzzleFlash).ShowMuzzleFlash();
	}
}

function KDriverEnter(Pawn P)
{
    Super.KDriverEnter(P);

	AmbientSound = EngineIdleSound;
}

function bool KDriverLeave(bool bForceLeave)
{
	local bool result;

	result = Super.KDriverLeave(bForceLeave);

	AmbientSound = None;
	if (MyBulletListener != None)
		MyBulletListener.AmbientSound = None;

	return result;
}

simulated function VehicleFire(bool bWasAltFire)
{
	local Emitter MuzzleFlash;

	super.VehicleFire( bWasAltFire );

	if (!bWasAltFire)  // fire the main gun
	{
		if (fMainGunReFireTime < Level.TimeSeconds)
		{
			fMainGunReFireTime = Level.TimeSeconds + fMainGunReFireDelay;

			FireMainGun();
		}
	}

	if (bWasAltFire)  // fire the machine gun
	{
		BowGunSoundHandle = PlaySoundCue( BowGunFireLoopSound, SLOT_NONE, TransientSoundVolume,,,,false);

		MuzzleFlash = BowGunFireMode.GetMuzzleFlash();

		if ( MuzzleFlash.IsA( 'gbxMuzzleFlash' ) )
			gbxMuzzleFlash(MuzzleFlash).FireButtonPressed();

		FireBowGun();
	}

//	if (bWasAltFire)  // fire the machine gun
//	{
//		CoaxGunSoundHandle = PlaySound( CoaxGunFireLoopSound, SLOT_NONE, TransientSoundVolume,,,,false);
//
//		MuzzleFlash = CoaxFireMode.GetMuzzleFlash();
//
//		if ( MuzzleFlash.IsA( 'gbxMuzzleFlash' ) )
//			gbxMuzzleFlash(MuzzleFlash).FireButtonPressed();
//
//		FireCoaxGun();
//	}
}

simulated function VehicleCeaseFire(bool bWasAltFire)
{
	local Emitter MuzzleFlash;

	super.VehicleCeaseFire( bWasAltFire );

	if (bWasAltFire)  // stop the machine gun
	{
		StopSound( BowGunSoundHandle );
		PlaySoundCue( BowGunFireOnceSound, SLOT_NONE, TransientSoundVolume,,,,false);

		MuzzleFlash = BowGunFireMode.GetMuzzleFlash();

		if ( MuzzleFlash.IsA( 'gbxMuzzleFlash' ) )
			gbxMuzzleFlash(MuzzleFlash).FireButtonReleased();
	}

//	if (bWasAltFire)  // stop the machine gun
//	{
//		StopSound( CoaxGunSoundHandle );
//		PlaySound( CoaxGunFireOnceSound, SLOT_NONE, TransientSoundVolume,,,,false);
//
//		MuzzleFlash = CoaxGunFireMode.GetMuzzleFlash();
//
//		if ( MuzzleFlash.IsA( 'gbxMuzzleFlash' ) )
//			gbxMuzzleFlash(MuzzleFlash).FireButtonReleased();
//	}
}


simulated function TurretRotate(float DeltaTime, bool bCounterClockwise)
{
	local float YawOffset;
	local rotator TurretRot;

	// Rotate CW or CCW...
	YawOffset = (TurretRotationSpeed * DeltaTime / 360.0) * 65536;

	if (bCounterClockwise)
		TurretYaw = (TurretYaw + int(YawOffset)) & 65535;
	else
		TurretYaw = (TurretYaw - int(YawOffset)) & 65535;

	TurretRot.Pitch = 0;
	TurretRot.Yaw = TurretYaw;
	TurretRot.Roll = 0;

	SetBoneRotation(TurretBoneName, TurretRot, 0, 1.0);
}

simulated function MainGunRotate(float DeltaTime, bool bUp)
{
	local float MaxPitchUp, MaxPitchDown;
	local float PitchOffset;
	local rotator MainGunRot;

	MaxPitchUp = (MainGunUpwardFireArc / 360.0) * 65536;
	MaxPitchDown = (MainGunDownwardFireArc / 360.0) * 65536;
	PitchOffset = (MainGunRotationSpeed * DeltaTime / 360.0) * 65536;

	if (bUp)
		MainGunPitch = MainGunPitch + int(PitchOffset);
	else
		MainGunPitch = MainGunPitch - int(PitchOffset);

	MainGunPitch = Clamp(MainGunPitch, -MaxPitchDown, MaxPitchUp);

	MainGunRot.Pitch = 0;
	MainGunRot.Yaw = 0;
	MainGunRot.Roll = MainGunPitch;

	SetBoneRotation(MainGunBoneName, MainGunRot, 0, 1.0);
}

simulated function BowGunPitchChange(float DeltaTime, bool bUp)
{
	local float MaxPitch, MinPitch;
	local float PitchOffset;
	local rotator BowGunRot;

	MaxPitch = (BowGunRotateMax / 360.0) * 65536;
	MinPitch = (-BowGunRotateMax / 360.0) * 65536;
	PitchOffset = (BowGunRotationSpeed * DeltaTime / 360.0) * 65536;

	if (bUp)
		BowGunRotation.Pitch = BowGunRotation.Pitch - PitchOffset;
	else
		BowGunRotation.Pitch = BowGunRotation.Pitch + PitchOffset;

	BowGunRotation.Pitch = Clamp(BowGunRotation.Pitch, MinPitch, MaxPitch);

	BowGunRot.Pitch = BowGunRotation.Yaw;
	BowGunRot.Yaw = BowGunRotation.Pitch;
	BowGunRot.Roll = 0;

	SetBoneRotation(BowGunBoneName, BowGunRot, 0, 1.0);
}

simulated function BowGunYawChange(float DeltaTime, bool bLeft)
{
	local float MaxYaw, MinYaw;
	local float YawOffset;
	local rotator BowGunRot;

	MaxYaw = (BowGunRotateMax / 360.0) * 65536;
	MinYaw = (-BowGunRotateMax / 360.0) * 65536;
	YawOffset = (BowGunRotationSpeed * DeltaTime / 360.0) * 65536;

	if (bLeft)
		BowGunRotation.Yaw = BowGunRotation.Yaw + YawOffset;
	else
		BowGunRotation.Yaw = BowGunRotation.Yaw - YawOffset;

	BowGunRotation.Yaw = Clamp(BowGunRotation.Yaw, MinYaw, MaxYaw);

	BowGunRot.Pitch = BowGunRotation.Yaw;
	BowGunRot.Yaw = BowGunRotation.Pitch;
	BowGunRot.Roll = 0;

	SetBoneRotation(BowGunBoneName, BowGunRot, 0, 1.0);
}

// do stuff necessary to allow player to mount this tank...
function PrepareToMount()
{
	if (Controller == None)  // if no controller...
	{
		// reset the turret and main gun to straight forward...
		TurretYaw = 0;
		SetBoneRotation(TurretBoneName, rot(0,0,0), 0, 1.0);

		MainGunPitch = 0;
		SetBoneRotation(MainGunBoneName, rot(0,0,0), 0, 1.0);
	}

	if (CommanderPawn != None)
		CommanderPawn.PrepareToMount();

	Super.PrepareToMount();
}

function CompleteMount()
{
	if (CommanderPawn != None)
		CommanderPawn.CompleteMount();
}

simulated function PlayMainGunFiringAnim(int TankTurretYaw)
{
	if (WeapUSStuart30calMachineGun.IsInUse())
		return;  // don't play firing animation if player is using the machine gun

	Super.PlayMainGunFiringAnim(TankTurretYaw);
}


defaultproperties
{
	DrawType=DT_Mesh
	Mesh=None  // use DymamicLoadObject instead
	EditorMeshName="k_vehicle_us.us_tank_stuart"
    Physics=PHYS_None

	Health=4
	CollisionHeight=2.0
	CollisionRadius=2.0
	VehicleCollisionHeight=128.0
	VehicleCollisionRadius=210.0
	BaseEyeHeight=140
	EyeHeight=140
	bTurnInPlace=true
	bCanStrafe=true

	MinDamageAmount=300
	HitPointsFront=2
	HitPointsSide=2
	HitPointsRear=3
	HitPointsTurret=2

	FPCamPos=(X=-10,Y=-30,Z=140)
	TPCamLookat=(X=-100,Y=0,Z=100)
	TPCamDistance=1200

	bDrawDriverInTP=true
	bDrawMeshInFP=true

	MaxViewYaw=16000
	MaxViewPitch=16000

	DrivePos=(X=105,Y=-50,Z=85)
	DriveRot=(Pitch=0,Yaw=0,Roll=0)

	ExitPositions(0)=(Y=-415.000000,Z=100.000000)
	ExitPositions(1)=(Y=415.000000,Z=100.000000)

	TurretBoneName="Turret"
	MainGunBoneName="main_gun"
	MainGunMuzzleBoneName="main_gun_muzzle"
	CoaxGunBoneName="coax_base"
	CoaxGunMuzzleBoneName="coax_mg_muzzle"
	BowGunBoneName="bow_mg"
	BowGunMuzzleBoneName="bow_mg_muzzle"

	MainGunFireModeClass=class'gbxInventory.FireStuartMainGun'
	MainGunTraceAccuracy=+0.1
	CoaxGunFireModeClass=class'gbxInventory.FireStuartCoaxGun'
	CoaxGunTraceAccuracy=+0.4
	CoaxGunTracerFrequency=3
	BowGunFireModeClass=class'gbxInventory.FireStuartBowGun'
	BowGunTraceAccuracy=+0.4
	BowGunTracerFrequency=3

	MainGunFlashEmitterClass=class'gbxEffects.MuzzleFlashStuartTankMainGun'
	MainGunSmokeEmitterClass=class'gbxEffects.TankStuartMainGunSmokeAndDust'

	MainGunEmitterOffset=(X=10,Y=0,Z=0)
	CoaxGunEmitterOffset=(X=7,Y=0,Z=0)
	BowGunEmitterOffset=(X=9,Y=0,Z=0)

	//GBX:PAD: This sound file is bad, so until it gets fixed, it is messing up the creating of linear load files.
//	ImpactSound=Sound'explosions.close_artillery_d'
	ExplosionDecal=class'TankProjectileScorch'
	ExploWallOut=1.0

	// sounds
	MainGunFireSoundName="V_TANK_SHERMAN.turret_fire"
	BowGunFireLoopSoundName="V_TANK_SHERMAN.MACHINEGUN_LOOP_A"
	BowGunFireOnceSoundName="V_TANK_SHERMAN.MACHINEGUN_SHOT_A"
	CoaxGunFireLoopSoundName="V_TANK_SHERMAN.MACHINEGUN_LOOP_B"
	CoaxGunFireOnceSoundName="V_TANK_SHERMAN.MACHINEGUN_SHOT_B"

	EngineIdleSoundName="V_TANK_STUART.IDLE"
	DrivingSoundName="V_TANK_STUART.DRIVING_LOOP"

	TurretRotatingSoundName="V_TANK_SHERMAN.turret_loop"
	TurretStopSoundName="V_TANK_SHERMAN.turret_stop"

	// tank driving max pitch speed
	MaxPitchSpeed=200.0

	fMainGunReFireDelay=6.0
	fCoaxGunReFireDelay=0.07
	fBowGunReFireDelay=0.07

	TurretRotationSpeed=45.0

	MainGunRotationSpeed=36.0
	MainGunUpwardFireArc=20.0
	MainGunDownwardFireArc=12.0

	BowGunRotationSpeed=90.0
	BowGunRotateMax=15.0

	// thruster positions left to right, front to back...
	Thrusters(0)=(BoneName="spokewheel_left",ThrusterOffset=60.0,bHasSuspension=false,NumWheels=1,WheelIndexes[0]=0,bChecksForWater=true)
	Thrusters(1)=(BoneName="spokewheel_right",ThrusterOffset=60.0,bHasSuspension=false,NumWheels=1,WheelIndexes[0]=1,bChecksForWater=true)
	Thrusters(2)=(BoneName="track_left_1",ThrusterOffset=45.0,bHasSuspension=true,SuspensionTravel=15.0,SuspensionTravelRate=100.0,NumWheels=1,WheelIndexes[0]=2)
	Thrusters(3)=(BoneName="track_right_1",ThrusterOffset=45.0,bHasSuspension=true,SuspensionTravel=15.0,SuspensionTravelRate=100.0,NumWheels=1,WheelIndexes[0]=3)
	Thrusters(4)=(BoneName="track_left_2",ThrusterOffset=45.0,bHasSuspension=true,SuspensionTravel=15.0,SuspensionTravelRate=100.0,NumWheels=1,WheelIndexes[0]=4)
	Thrusters(5)=(BoneName="track_right_2",ThrusterOffset=45.0,bHasSuspension=true,SuspensionTravel=15.0,SuspensionTravelRate=100.0,NumWheels=1,WheelIndexes[0]=5)
	Thrusters(6)=(BoneName="track_left_3",ThrusterOffset=45.0,bHasSuspension=true,SuspensionTravel=15.0,SuspensionTravelRate=100.0,NumWheels=1,WheelIndexes[0]=6)
	Thrusters(7)=(BoneName="track_right_3",ThrusterOffset=45.0,bHasSuspension=true,SuspensionTravel=15.0,SuspensionTravelRate=100.0,NumWheels=1,WheelIndexes[0]=7)
	Thrusters(8)=(BoneName="track_left_4",ThrusterOffset=45.0,bHasSuspension=true,SuspensionTravel=15.0,SuspensionTravelRate=100.0,NumWheels=1,WheelIndexes[0]=8)
	Thrusters(9)=(BoneName="track_right_4",ThrusterOffset=45.0,bHasSuspension=true,SuspensionTravel=15.0,SuspensionTravelRate=100.0,NumWheels=1,WheelIndexes[0]=9)
	Thrusters(10)=(BoneName="track_left_5",ThrusterOffset=60.0,bHasSuspension=true,SuspensionTravel=10.0,SuspensionTravelRate=75.0,NumWheels=1,WheelIndexes[0]=10,bChecksForWater=true)
	Thrusters(11)=(BoneName="track_right_5",ThrusterOffset=60.0,bHasSuspension=true,SuspensionTravel=10.0,SuspensionTravelRate=75.0,NumWheels=1,WheelIndexes[0]=11,bChecksForWater=true)

	// wheels left then right, front to back...
	TrackWheels(0)=(TrackIndex=0,WheelRadius=38.0,WheelBoneName="spokewheel_left",bHasSuspension=false)
	TrackWheels(1)=(TrackIndex=1,WheelRadius=38.0,WheelBoneName="spokewheel_right",bHasSuspension=false)
	TrackWheels(2)=(TrackIndex=0,WheelRadius=35.0,WheelBoneName="wheel_left_1",bHasSuspension=true)
	TrackWheels(3)=(TrackIndex=1,WheelRadius=35.0,WheelBoneName="wheel_right_1",bHasSuspension=true)
	TrackWheels(4)=(TrackIndex=0,WheelRadius=35.0,WheelBoneName="wheel_left_2",bHasSuspension=true)
	TrackWheels(5)=(TrackIndex=1,WheelRadius=35.0,WheelBoneName="wheel_right_2",bHasSuspension=true)
	TrackWheels(6)=(TrackIndex=0,WheelRadius=35.0,WheelBoneName="wheel_left_3",bHasSuspension=true)
	TrackWheels(7)=(TrackIndex=1,WheelRadius=35.0,WheelBoneName="wheel_right_3",bHasSuspension=true)
	TrackWheels(8)=(TrackIndex=0,WheelRadius=35.0,WheelBoneName="wheel_left_4",bHasSuspension=true)
	TrackWheels(9)=(TrackIndex=1,WheelRadius=35.0,WheelBoneName="wheel_right_4",bHasSuspension=true)
	TrackWheels(10)=(TrackIndex=0,WheelRadius=53.0,WheelBoneName="wheel_left_5",bHasSuspension=true)
	TrackWheels(11)=(TrackIndex=1,WheelRadius=53.0,WheelBoneName="wheel_right_5",bHasSuspension=true)

	HoverSoftness=0.05
	HoverPenScale=1.5
	HoverCheckDist=65

	UprightStiffness=500
	UprightDamping=300

	MaxThrust=96.66		// max speed in decimeters per second (0.1 * centimeters per second)

//	MaxSteerTorque=100.0
	MaxSteerTorque=200.0
	ForwardDampFactor=0.1
	LateralDampFactor=10.0
	ParkingDampFactor=0.8
//	SteerDampFactor=100.0
	SteerDampFactor=300.0
	PitchTorqueFactor=0.0
	PitchDampFactor=0.0
	BankTorqueFactor=0.0
	BankDampFactor=0.0
	TurnDampFactor=0.0
	DecelerateDampFactor=0.7
	SteerDecayDampFactor=400.0

	InvertSteeringThrottleThreshold=-0.1
	VehicleMass=12.0

	TrackVelocityScale=-153


	Begin Object Class=KarmaParamsRBFull Name=KParamsTank
		KStartEnabled=True
		KFriction=0.5
		KLinearDamping=0
		KAngularDamping=0
		bKNonSphericalInertia=False
		bHighDetailOnly=False
		bClientOnly=False
		bKDoubleTickRate=True
		bKStayUpright=True
		bKAllowRotate=True
		KInertiaTensor(0)=1.3
		KInertiaTensor(1)=0.0
		KInertiaTensor(2)=0.0
		KInertiaTensor(3)=4.0
		KInertiaTensor(4)=0.0
		KInertiaTensor(5)=4.5
		KCOMOffset=(X=0.0,Y=0.0,Z=0.0)
		Name="KParamsTank"
	End Object
	KParams=KarmaParams'KParamsTank'

	PawnTeam=TEAM_US
	TrackDustEmitterClass=class'TankStuartTrackDust'

	// Nine-point blending animations.
	ForwardDownAnim="30_forward_down"
	ForwardLevelAnim="30_forward_level"
	ForwardUpAnim="30_forward_up"
	LeftDownAnim="30_left_down"
	LeftLevelAnim="30_left_level"
	LeftUpAnim="30_left_up"
	RightDownAnim="30_right_down"
	RightLevelAnim="30_right_level"
	RightUpAnim="30_right_up"

	NinePointBlendBone="30cal_lateral"
	Weap30calOffset=(X=60,Y=0,Z=10)

	bHasCreatedTriggers=false
	MachineGunRearTriggerOffset=(X=-200,Y=0,Z=-50)
	MachineGunRearTriggerRadius=80;
	MachineGunTurretTriggerOffset=(X=0,Y=0,Z=100)
	MachineGunTurretTriggerRadius=100;

	bSpawnCommander=true
	TankCommanderPawnOffset=(X=-4,Y=-2,Z=37)
	TankCommanderPawnRotation=(Pitch=0,Yaw=32768,Roll=0)
	TankCommanderPawnHitCylinderOffset=(X=-4,Y=-2,Z=96)
	TankCommanderPawnHitCylinderRotation=(Pitch=0,Yaw=0,Roll=0)

	// animations...
	MainFireFrontHatchOpen="fire_front_open_hatch"
	MainFireFrontHatchClosed="fire_front_closed_hatch"
	MainFireLeftHatchOpen="fire_left_open_hatch"
	MainFireLeftHatchClosed="fire_left_closed_hatch"
	MainFireRightHatchOpen="fire_right_open_hatch"
	MainFireRightHatchClosed="fire_right_closed_hatch"
	MainFireRearHatchOpen="fire_back_open_hatch"
	MainFireRearHatchClosed="fire_back_closed_hatch"

	TankHatchOpenIdleAnim="hatch_open_idle"
	TankHatchClosedIdleAnim="hatch_closed_idle"

	CommanderAnimPkg="a_hold_misc.stuart"
	ExtendedAttachmentMeshName="k_vehicle_us.us_tank_stuart"

	CommanderIdleAnims(0)="stuart_commander_idle_1"
	CommanderIdleAnims(1)="stuart_commander_idle_2"
	CommanderIdleAnims(2)="stuart_commander_idle_3"
	CommanderIdleAnims(3)="stuart_looking_thru_binocs"

	CommanderHitPulledInAnim="stuart_commander_hit_pulled_in"
	CommanderFlinchCloseAnim="stuart_flinch_close_hatch"
	CommanderOpenHatchAnim="stuart_open_hatch"
	CommanderCloseHatchAnim="stuart_close_hatch"
	CommanderMoveOutAnim="stuart_gesture_forward"
	CommanderTankBlownupAnim="stuart_expires"

	TankCommanderHitAnim="stuart_commander_hit_pulled_in"
	TankCommanderFlinchAnim="stuart_flinch"
	TankCommanderOpenHatchAnim="stuart_open_hatch"
	TankCommanderCloseHatchAnim="stuart_close_hatch"
	TankCommanderTankBlownupAnim="stuart_expires"

	AimErrorAICoax=50
	AimErrorAIBow=50

	CornerPointOffset(0)=(X=280,Y=70,Z=-50)		// front
	CornerPointOffset(1)=(X=280,Y=-70,Z=-50)	// front
	CornerPointOffset(2)=(X=165,Y=-185,Z=-50)	// left
	CornerPointOffset(3)=(X=-150,Y=-185,Z=-50)	// left
	CornerPointOffset(4)=(X=-260,Y=-70,Z=-50)	// rear
	CornerPointOffset(5)=(X=-260,Y=70,Z=-50)	// rear
	CornerPointOffset(6)=(X=-150,Y=185,Z=-50)	// right
	CornerPointOffset(7)=(X=165,Y=185,Z=-50)	// right

	CornerPointYawRotation(0)=0			// front - out away from the tank
	CornerPointYawRotation(1)=0			// front
	CornerPointYawRotation(2)=-16384	// left
	CornerPointYawRotation(3)=-16384	// left
	CornerPointYawRotation(4)=32768		// rear
	CornerPointYawRotation(5)=32768		// rear
	CornerPointYawRotation(6)=16384		// right
	CornerPointYawRotation(7)=16384		// right

	CornerPointIsLeftCorner(0)=1;	// front
	CornerPointIsLeftCorner(1)=0;	// front
	CornerPointIsLeftCorner(2)=1;	// left
	CornerPointIsLeftCorner(3)=0;	// left
	CornerPointIsLeftCorner(4)=1;	// rear
	CornerPointIsLeftCorner(5)=0;	// rear
	CornerPointIsLeftCorner(6)=1;	// right
	CornerPointIsLeftCorner(7)=0;	// right

	CornerPointIsStandingCorner(0)=0;	// front
	CornerPointIsStandingCorner(1)=0;	// front
	CornerPointIsStandingCorner(2)=0;	// left
	CornerPointIsStandingCorner(3)=1;	// left
	CornerPointIsStandingCorner(4)=1;	// rear
	CornerPointIsStandingCorner(5)=1;	// rear
	CornerPointIsStandingCorner(6)=1;	// right
	CornerPointIsStandingCorner(7)=0;	// right

	VehicleShadowDrawScale = 5

	SmokeEmitterOffset=(X=-160.0,Y=0.0,Z=0.0)
	TankDeathEmitterOffset=(X=0.0,Y=0.0,Z=64.0)
	BlowedUpEmitterOffset=(X=0.0,Y=0.0,Z=64.0)

	bFriendlyFireListen=true
	ScriptedViewBoneName="chassis"
	ScriptedViewOffset=(X=0,Y=0,Z=180.0f)

	CharacterSetupClass=class'CharacterSetupUSA'
	m_eCharacterType=USCharTankCommanderA
}
class TankStug extends Tank;


var()	int		MainGunPitch;

var()	name	MainGunBoneName;
var()	name	MainGunMuzzleBoneName;

var bool 	bHasCreatedTriggers;
var TankGrenadeTrigger MyTankGrenadeTrigger;
var vector	TankGrenadeTriggerOffset;
var float	TankGrenadeTriggerRadius;

var float 		MainGunTraceAccuracy;
var class<Projector> ExplosionDecal;
var float		ExploWallOut;	// distance to move explosions out from wall

var class<InstantFire> MainGunFireModeClass;
var InstantFire		MainGunFireMode;
var Ammunition 		MainGunAmmo;
var class<Emitter>	MainGunFlashEmitterClass;
var class<Emitter>	MainGunSmokeEmitterClass;
var() vector		MainGunEmitterOffset;

var		float	fMainGunReFireTime;
var()	float	fMainGunReFireDelay;

var()	float	MainGunRotationSpeed;	// degrees per second
var()	float	MainGunUpwardFireArc;	// in degrees
var()	float	MainGunDownwardFireArc;	// in degrees

var Cue		MainGunFireSound;
var string	MainGunFireSoundName;

var int		AimErrorAI;

var bool	bWasCommanderAlive;


simulated function PreBeginPlay()
{
	Mesh = Mesh( DynamicLoadObject( "k_vehicle_de.de_tank_stug", class'Mesh' ) );

	super.PreBeginPlay();
}

simulated function SetupTracks()
{
	Skins.Length = 4;
	Skins[0] = GbxShaderMaterial( DynamicLoadObject( "t_military_de.Vehicle.de_stug_gbx", class'GbxShaderMaterial' ) );
	Skins[1] = GbxShaderMaterial( DynamicLoadObject( "t_military_de.Vehicle.de_stug_track_left_gbx", class'GbxShaderMaterial' ) );
	Skins[2] = GbxShaderMaterial( DynamicLoadObject( "t_military_de.Vehicle.de_stug_track_right_gbx", class'GbxShaderMaterial' ) );
	Skins[3] = GbxShaderMaterial( DynamicLoadObject( "t_military_de.Vehicle.de_stug_alpha_gbx", class'GbxShaderMaterial' ) );

	LeftTrackTextureIndex = 1;
	RightTrackTextureIndex = 2;

	super.SetupTracks();
}

simulated function BeginPlay()
{
	SetPhysics(PHYS_Karma);
}

simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();

	MainGunFireMode = Spawn(MainGunFireModeClass, self);
	if (MainGunFireMode == None)
		Log(name $ ".PostNetBeginPlay() - Couldn't spawn MainGunFireMode!!!");
	else
	{
		MainGunAmmo = Spawn(MainGunFireMode.AmmoClass, MainGunFireMode);
	}

	CreateSounds();

	bWasCommanderAlive = true;
}

simulated function CreateSounds()
{
	if ( MainGunFireSoundName != "" )
		MainGunFireSound = LoadSound( MainGunFireSoundName );
	if ( EngineIdleSoundName != "" )
		EngineIdleSound = Sound( DynamicLoadObject( EngineIdleSoundName, class'Sound' ) );
	if ( DrivingSoundName != "" )
		DrivingSound = Sound( DynamicLoadObject( DrivingSoundName, class'Sound' ) );
}

function CreateTriggers()
{
	local vector RotX, RotY, RotZ;
	local vector Offset;

    GetAxes(Rotation,RotX,RotY,RotZ);

	Offset = TankGrenadeTriggerOffset.X * RotX + TankGrenadeTriggerOffset.Y * RotY + TankGrenadeTriggerOffset.Z * RotZ;
	MyTankGrenadeTrigger = spawn(class'TankGrenadeTrigger', self,, Location + Offset);
	MyTankGrenadeTrigger.SetBase(self);
	MyTankGrenadeTrigger.SetCollisionSize(TankGrenadeTriggerRadius, 50 );
	MyTankGrenadeTrigger.SetCollision(true, false, false);
	MyTankGrenadeTrigger.m_aUseTarget = self;
	MyTankGrenadeTrigger.bHidden = true;

	MyTankGrenadeTrigger.bDisabled = true;
}

function Destroyed()
{
	Log( name $ ".(TankStug).Destroyed()", 'Tank' );

	if (MainGunFireMode != None)
		MainGunFireMode.Destroy();
	if (MainGunAmmo != None)
		MainGunAmmo.Destroy();

	if (MyTankGrenadeTrigger != None)
		MyTankGrenadeTrigger.Destroy();

	super.Destroyed();
}

function bool CheckIfCommanderDied()
{
	if (CommanderPawn != None)
	{
		if (bWasCommanderAlive)
		{
			if (CommanderPawn.Health <= 0)
			{
				bWasCommanderAlive = false;
				return true;
			}

			bWasCommanderAlive = true;
		}
	}

	return false;
}

simulated function Tick(float DeltaTime)
{
	super.Tick( DeltaTime );

	if (!bHasCreatedTriggers)
	{
		CreateTriggers();
		bHasCreatedTriggers = true;
	}

	if (Health <= 0)  // died?
	{
		bNoSound = false;  // make sure sounds aren't played anymore on this tank

		AmbientSound = None;
		if (MyBulletListener != None)
			MyBulletListener.AmbientSound = None;

		return;
	}

	if ( !bDisablePlayerUseableTriggers && CheckIfCommanderDied() )
	{
		MyTankGrenadeTrigger.bDisabled = false;  // enable the tank grenaded trigger
	}

	if (Rise > 0)
		MainGunRotate(DeltaTime, true);  // up
	else if (Rise < 0)
		MainGunRotate(DeltaTime, false);  // down
}


function TakeDamage(int Damage, Pawn instigatedBy, Vector Hitlocation, Vector Momentum, class<DamageType> DamageType, optional name HitBoxName)
{
	local int InitialHealth;

	InitialHealth = Health;

	Super.TakeDamage(Damage, instigatedBy, Hitlocation, Momentum, DamageType, HitBoxName);

	if ((InitialHealth > 0) && (Health <= 0))  // did we just now die?
	{
		// swap the skins out for the damaged versions...
		Skins[0] = GbxShaderMaterial( DynamicLoadObject( "t_military_de.Vehicle.de_stug_dmg_gbx", class'GbxShaderMaterial' ) );
		Skins[1] = GbxShaderMaterial( DynamicLoadObject( "t_military_de.Vehicle.de_stug_dmg_track_left", class'GbxShaderMaterial' ) );
		Skins[2] = GbxShaderMaterial( DynamicLoadObject( "t_military_de.Vehicle.de_stug_dmg_track_right", class'GbxShaderMaterial' ) );
		Skins[3] = GbxShaderMaterial( DynamicLoadObject( "t_military_de.Vehicle.de_stug_dmg_alpha_gbx", class'GbxShaderMaterial' ) );

		if (MyTankGrenadeTrigger != None)
		{
			MyTankGrenadeTrigger.Destroy();
			MyTankGrenadeTrigger = None;
		}
	}
	else if (float(Health) <= (float(default.Health) * 0.5f))  // tank more than 50% dead
	{
		if (!bForceHatchOpen && !bDisablePlayerUseableTriggers)
		{
			MyTankGrenadeTrigger.bDisabled = false;  // enable the tank grenaded trigger

			bForceHatchOpen = true;

			StopAnimating(true);  // clear all the animation channels (since the firing animation can mess up the blending of the hatch)

			if (CommanderPawn != None)
			{
				if (CommanderPawn.Health > 0)  // still alive?
					CommanderPawn.KillCommander(instigatedBy, DamageType);
				else
					PlayAnim(TankHatchOpenIdleAnim, 10.0f);  // open the hatch
			}
			else
			{
				PlayAnim(TankHatchOpenIdleAnim, 10.0f);  // open the hatch
			}
		}
	}
}

simulated function rotator AdjustAimMainGun()
{
	local rotator MainGunRot;

	MainGunRot.Pitch = (Rotation.Pitch + MainGunPitch) & 65535;
	MainGunRot.Yaw = Rotation.Yaw & 65535;
	MainGunRot.Roll = 0;

	return MainGunRot;
}

simulated function FireMainGun()
{
	local vector MainGunLoc;
	local rotator MainGunRot;
	local vector RotX, RotY, RotZ;
	local float YOffset, ZOffset;
	local vector EndTrace, X;
	local int AimError;
	local rotator AdjustedAim;
	local gbxTankShell TankShell;
//	local vector HitLocation, HitNormal;
//	local Actor HitActor;

	MainGunLoc = GetTagCoords( MainGunMuzzleBoneName ).origin;

	MainGunRot.Pitch = MainGunPitch;
	MainGunRot.Yaw = 0;
	MainGunRot.Roll = 0;

	MainGunRot = Rotation + MainGunRot;

    GetAxes(MainGunRot,RotX,RotY,RotZ);

	MainGunLoc = MainGunLoc + MainGunEmitterOffset.X * RotX + MainGunEmitterOffset.Y * RotY + MainGunEmitterOffset.Z * RotZ;

	// spawn main gun muzzle flash emitter...
	spawn(MainGunFlashEmitterClass, None,, MainGunLoc, MainGunRot);

	MainGunRot.Pitch = 0;  // ignore main gun pitch for main gun smoke and dust emitter
	MainGunRot.Yaw = 0;
	MainGunRot.Roll = 0;

	MainGunRot = Rotation + MainGunRot;

	// spawn main gun smoke and dust emitter...
	spawn(MainGunSmokeEmitterClass, None,, MainGunLoc, MainGunRot);

	YOffset = 0.0f;
	ZOffset = 0.0f;

	AimError = 10;

	AdjustedAim = AdjustAimMainGun();
	EndTrace = MainGunLoc + (YOffset + MainGunTraceAccuracy * (FRand() - 0.5 ) ) * RotY * 1000
		+ (ZOffset + MainGunTraceAccuracy * (FRand() - 0.5 )) * RotZ * 1000;
	X = vector(AdjustedAim);
	EndTrace += (10000 * X);

	AdjustedAim = rotator(EndTrace - MainGunLoc);

/*
	HitActor = Trace(HitLocation, HitNormal, EndTrace, MainGunLoc, true);

	if (HitActor != None)
	{
		Explosion(HitLocation + ExploWallOut * HitNormal);

		if ( (ExplosionDecal != None) && (Level.NetMode != NM_DedicatedServer) )
			Spawn(ExplosionDecal,self,,HitLocation, rotator(-HitNormal));
	}
*/

	TankShell = Spawn( class'gbxTankShell', self,, MainGunLoc, AdjustedAim );
	TankShell.Instigator = self;

	PlaySoundCue( MainGunFireSound, SLOT_NONE, TransientSoundVolume,,,,false);

	PlayMainGunFiringAnim(0);
}

function KDriverEnter(Pawn P)
{
    Super.KDriverEnter(P);

	AmbientSound = EngineIdleSound;
}

function bool KDriverLeave(bool bForceLeave)
{
	local bool result;

	result = Super.KDriverLeave(bForceLeave);

	AmbientSound = None;
	if (MyBulletListener != None)
		MyBulletListener.AmbientSound = None;

	return result;
}

simulated function VehicleFire(bool bWasAltFire)
{
	super.VehicleFire( bWasAltFire );

	if (!bWasAltFire)  // fire the main gun
	{
		if (fMainGunReFireTime < Level.TimeSeconds)
		{
			fMainGunReFireTime = Level.TimeSeconds + fMainGunReFireDelay;

			FireMainGun();
		}
	}
}

simulated function VehicleCeaseFire(bool bWasAltFire)
{
	super.VehicleCeaseFire( bWasAltFire );
}

simulated function PlayMainGunFiringAnim(int TankTurretYaw)
{
	// StuG III tanks can't rotate the turret, so no blending required...

	if (IsHatchClosed())
		PlayAnim(MainFireFrontHatchClosed, 1.0, 0.0, MAINGUN_ANIM_CHAN1);
	else
		PlayAnim(MainFireFrontHatchOpen, 1.0, 0.0, MAINGUN_ANIM_CHAN1);
}

simulated function MainGunRotate(float DeltaTime, bool bUp)
{
	local float MaxPitchUp, MaxPitchDown;
	local float PitchOffset;
	local rotator MainGunRot;

	MaxPitchUp = (MainGunUpwardFireArc / 360.0) * 65536;
	MaxPitchDown = (MainGunDownwardFireArc / 360.0) * 65536;
	PitchOffset = (MainGunRotationSpeed * DeltaTime / 360.0) * 65536;

	if (bUp)
		MainGunPitch = MainGunPitch + int(PitchOffset);
	else
		MainGunPitch = MainGunPitch - int(PitchOffset);

	MainGunPitch = Clamp(MainGunPitch, -MaxPitchDown, MaxPitchUp);

	MainGunRot.Pitch = 0;
	MainGunRot.Yaw = 0;
	MainGunRot.Roll = MainGunPitch;

	SetBoneRotation(MainGunBoneName, MainGunRot, 0, 1.0);
}

function GrenadeHasBeenPlanted(Pawn GrenadePlanter)
{
	local TankGrenade MyTankGrenade;

	Log(name $ ".(TankStug).GrenadeHasBeenPlanted() - planter = " $ GrenadePlanter.name, 'Tank');

	if (CommanderPawn != None)
	{
		CommanderPawn.bAllowDamage = false;

		if (CommanderPawn.HitCylinder != None)
			CommanderPawn.HitCylinder.bHidden = true;

		CommanderPawn.GotoState('GrenadePlanted');
	}

	MyTankGrenade = spawn(class'TankGrenade', GrenadePlanter,, Location, Rotation);
	MyTankGrenade.Instigator = GrenadePlanter;
	MyTankGrenade.bActivated = true;

	Super.GrenadeHasBeenPlanted( GrenadePlanter );
}


defaultproperties
{
	DrawType=DT_Mesh
	Mesh=None  // use DymamicLoadObject instead
	EditorMeshName="k_vehicle_de.de_tank_stug"
    Physics=PHYS_None

	Health=4
	CollisionHeight=2.0
	CollisionRadius=2.0
	VehicleCollisionHeight=128.0
	VehicleCollisionRadius=290.0
	BaseEyeHeight=140
	EyeHeight=140
	bTurnInPlace=true
	bCanStrafe=true

	MinDamageAmount=300
	HitPointsFront=1
	HitPointsSide=2
	HitPointsRear=3
	HitPointsTurret=2
	StopMovingHealth=1

	FPCamPos=(X=-10,Y=-30,Z=140)
	TPCamLookat=(X=-100,Y=0,Z=100)
	TPCamDistance=1200

	bDrawDriverInTP=true
	bDrawMeshInFP=true

	MaxViewYaw=16000
	MaxViewPitch=16000

	DrivePos=(X=105,Y=-50,Z=85)
	DriveRot=(Pitch=0,Yaw=0,Roll=0)

	ExitPositions(0)=(Y=-415.000000,Z=100.000000)
	ExitPositions(1)=(Y=415.000000,Z=100.000000)
	ExitPositions(2)=(Y=0.000000,Z=-400.000000)
	ExitPositions(3)=(Y=0.000000,Z=400.000000)

	MainGunBoneName="main_gun"
	MainGunMuzzleBoneName="main_gun_muzzle"

	MainGunFireModeClass=class'gbxInventory.FireStugMainGun'
	MainGunTraceAccuracy=+0.1

	MainGunFlashEmitterClass=class'gbxEffects.MuzzleFlashStuartTankMainGun'
	MainGunSmokeEmitterClass=class'gbxEffects.TankStuartMainGunSmokeAndDust'

	MainGunEmitterOffset=(X=10,Y=0,Z=0)

	// GBX:naj - bug 11544: this sound no longer exists, and anyway 'ImpactSound' appears not to be used.
	//ImpactSound=Sound'explosions.close_artillery_d'		
	ExplosionDecal=class'TankProjectileScorch'
	ExploWallOut=1.0

	// sounds
	MainGunFireSoundName="V_TANK_MARK_IV.turret_fire"

	EngineIdleSoundName="V_TANK_STUG.IDLE"
	DrivingSoundName="V_TANK_STUG.DRIVING_LOOP"

	// tank driving max pitch speed
	MaxPitchSpeed=200.0

	fMainGunReFireDelay=8.0

	MainGunRotationSpeed=36.0
	MainGunUpwardFireArc=20.0
	MainGunDownwardFireArc=12.0

	// thruster positions left to right, front to back...
	Thrusters(0)=(BoneName="spokewheel_left",ThrusterOffset=56.0,bHasSuspension=false,NumWheels=1,WheelIndexes[0]=0,bChecksForWater=true)
	Thrusters(1)=(BoneName="spokewheel_right",ThrusterOffset=56.0,bHasSuspension=false,NumWheels=1,WheelIndexes[0]=1,bChecksForWater=true)
	Thrusters(2)=(BoneName="track_left_1",ThrusterOffset=42.0,bHasSuspension=true,SuspensionTravel=15.0,SuspensionTravelRate=100.0,NumWheels=1,WheelIndexes[0]=2)
	Thrusters(3)=(BoneName="track_right_1",ThrusterOffset=42.0,bHasSuspension=true,SuspensionTravel=15.0,SuspensionTravelRate=100.0,NumWheels=1,WheelIndexes[0]=3)
	Thrusters(4)=(BoneName="track_left_2",ThrusterOffset=42.0,bHasSuspension=true,SuspensionTravel=15.0,SuspensionTravelRate=100.0,NumWheels=1,WheelIndexes[0]=4)
	Thrusters(5)=(BoneName="track_right_2",ThrusterOffset=42.0,bHasSuspension=true,SuspensionTravel=15.0,SuspensionTravelRate=100.0,NumWheels=1,WheelIndexes[0]=5)
	Thrusters(6)=(BoneName="track_left_3",ThrusterOffset=42.0,bHasSuspension=true,SuspensionTravel=15.0,SuspensionTravelRate=100.0,NumWheels=1,WheelIndexes[0]=6)
	Thrusters(7)=(BoneName="track_right_3",ThrusterOffset=42.0,bHasSuspension=true,SuspensionTravel=15.0,SuspensionTravelRate=100.0,NumWheels=1,WheelIndexes[0]=7)
	Thrusters(8)=(BoneName="track_left_4",ThrusterOffset=42.0,bHasSuspension=true,SuspensionTravel=15.0,SuspensionTravelRate=100.0,NumWheels=1,WheelIndexes[0]=8)
	Thrusters(9)=(BoneName="track_right_4",ThrusterOffset=42.0,bHasSuspension=true,SuspensionTravel=15.0,SuspensionTravelRate=100.0,NumWheels=1,WheelIndexes[0]=9)
	Thrusters(10)=(BoneName="track_left_5",ThrusterOffset=42.0,bHasSuspension=true,SuspensionTravel=15.0,SuspensionTravelRate=100.0,NumWheels=1,WheelIndexes[0]=10)
	Thrusters(11)=(BoneName="track_right_5",ThrusterOffset=42.0,bHasSuspension=true,SuspensionTravel=15.0,SuspensionTravelRate=100.0,NumWheels=1,WheelIndexes[0]=11)
	Thrusters(12)=(BoneName="track_left_6",ThrusterOffset=42.0,bHasSuspension=true,SuspensionTravel=15.0,SuspensionTravelRate=100.0,NumWheels=1,WheelIndexes[0]=12)
	Thrusters(13)=(BoneName="track_right_6",ThrusterOffset=42.0,bHasSuspension=true,SuspensionTravel=15.0,SuspensionTravelRate=100.0,NumWheels=1,WheelIndexes[0]=13)
	Thrusters(14)=(BoneName="wheel_left_7",ThrusterOffset=66.0,bHasSuspension=false,NumWheels=1,WheelIndexes[0]=14,bChecksForWater=true)
	Thrusters(15)=(BoneName="wheel_right_7",ThrusterOffset=66.0,bHasSuspension=false,NumWheels=1,WheelIndexes[0]=15,bChecksForWater=true)

	// wheels left then right, front to back...
	TrackWheels(0)=(TrackIndex=0,WheelRadius=40.0,WheelBoneName="spokewheel_left",bHasSuspension=false)
	TrackWheels(1)=(TrackIndex=1,WheelRadius=40.0,WheelBoneName="spokewheel_right",bHasSuspension=false)
	TrackWheels(2)=(TrackIndex=0,WheelRadius=23.0,WheelBoneName="wheel_left_1",bHasSuspension=true)
	TrackWheels(3)=(TrackIndex=1,WheelRadius=23.0,WheelBoneName="wheel_right_1",bHasSuspension=true)
	TrackWheels(4)=(TrackIndex=0,WheelRadius=23.0,WheelBoneName="wheel_left_2",bHasSuspension=true)
	TrackWheels(5)=(TrackIndex=1,WheelRadius=23.0,WheelBoneName="wheel_right_2",bHasSuspension=true)
	TrackWheels(6)=(TrackIndex=0,WheelRadius=23.0,WheelBoneName="wheel_left_3",bHasSuspension=true)
	TrackWheels(7)=(TrackIndex=1,WheelRadius=23.0,WheelBoneName="wheel_right_3",bHasSuspension=true)
	TrackWheels(8)=(TrackIndex=0,WheelRadius=23.0,WheelBoneName="wheel_left_4",bHasSuspension=true)
	TrackWheels(9)=(TrackIndex=1,WheelRadius=23.0,WheelBoneName="wheel_right_4",bHasSuspension=true)
	TrackWheels(10)=(TrackIndex=0,WheelRadius=23.0,WheelBoneName="wheel_left_5",bHasSuspension=true)
	TrackWheels(11)=(TrackIndex=1,WheelRadius=23.0,WheelBoneName="wheel_right_5",bHasSuspension=true)
	TrackWheels(12)=(TrackIndex=0,WheelRadius=23.0,WheelBoneName="wheel_left_6",bHasSuspension=true)
	TrackWheels(13)=(TrackIndex=1,WheelRadius=23.0,WheelBoneName="wheel_right_6",bHasSuspension=true)
	TrackWheels(14)=(TrackIndex=0,WheelRadius=37.0,WheelBoneName="wheel_left_7",bHasSuspension=false)
	TrackWheels(15)=(TrackIndex=1,WheelRadius=37.0,WheelBoneName="wheel_right_7",bHasSuspension=false)

	HoverSoftness=0.05
	HoverPenScale=1.5
	HoverCheckDist=65

	UprightStiffness=500
	UprightDamping=300

	MaxThrust=56.64		// max speed in decimeters per second (0.1 * centimeters per second)

//	MaxSteerTorque=100.0
	MaxSteerTorque=200.0
	ForwardDampFactor=0.1
	LateralDampFactor=10.0
	ParkingDampFactor=0.8
//	SteerDampFactor=100.0
	SteerDampFactor=250.0
	PitchTorqueFactor=0.0
	PitchDampFactor=0.0
	BankTorqueFactor=0.0
	BankDampFactor=0.0
	TurnDampFactor=0.0
	DecelerateDampFactor=0.7
	SteerDecayDampFactor=400.0

	InvertSteeringThrottleThreshold=-0.1
	VehicleMass=12.0

	TrackVelocityScale=-153


	Begin Object Class=KarmaParamsRBFull Name=KParamsTank
		KStartEnabled=True
		KFriction=0.5
		KLinearDamping=0
		KAngularDamping=0
		bKNonSphericalInertia=False
		bHighDetailOnly=False
		bClientOnly=False
		bKDoubleTickRate=True
		bKStayUpright=True
		bKAllowRotate=True
		KInertiaTensor(0)=1.3
		KInertiaTensor(1)=0.0
		KInertiaTensor(2)=0.0
		KInertiaTensor(3)=4.0
		KInertiaTensor(4)=0.0
		KInertiaTensor(5)=4.5
		KCOMOffset=(X=0.0,Y=0.0,Z=0.0)
		Name="KParamsTank"
	End Object
	KParams=KarmaParams'KParamsTank'

	PawnTeam=TEAM_German
	TrackDustEmitterClass=class'TankStuartTrackDust'

	bSpawnCommander=true
	TankCommanderPawnOffset=(X=6,Y=-22,Z=0)
	TankCommanderPawnRotation=(Pitch=49152,Yaw=32768,Roll=16384)
	TankCommanderPawnHitCylinderOffset=(X=0,Y=-80,Z=0)
	TankCommanderPawnHitCylinderRotation=(Pitch=0,Yaw=0,Roll=0)

	// animations...
	MainFireFrontHatchOpen="fire_open_hatch"
	MainFireFrontHatchClosed="fire_closed_hatch"

	TankHatchOpenIdleAnim="hatch_open"
	TankHatchClosedIdleAnim="hatch_closed"

	CommanderAnimPkg="a_hold_misc.stug"

	CommanderIdleAnims(0)="stug_commander_idle_1"
	CommanderIdleAnims(1)="stug_commander_idle_2"
	CommanderIdleAnims(2)="stug_commander_idle_3"
	CommanderIdleAnims(3)="stug_looking_thru_binocs"

	CommanderHitPulledInAnim="stug_commander_hit_pulled_in"
	CommanderFlinchCloseAnim="stug_flinch_close_hatch"
	CommanderOpenHatchAnim="stug_open_hatch"
	CommanderCloseHatchAnim="stug_close_hatch"
	CommanderMoveOutAnim="stug_gesture_forward"
	CommanderTankBlownupAnim="stug_expires"

	TankCommanderHitAnim="com_hit_pulled_in"
	TankCommanderFlinchAnim="flinch_close_hatch"
	TankCommanderOpenHatchAnim="open_hatch"
	TankCommanderCloseHatchAnim="close_hatch"
	TankCommanderTankBlownupAnim="expires"

	AimErrorAI=50

	CornerPointOffset(0)=(X=320,Y=90,Z=-50)		// front
	CornerPointOffset(1)=(X=320,Y=-90,Z=-50)	// front
	CornerPointOffset(2)=(X=175,Y=-215,Z=-50)	// left
	CornerPointOffset(3)=(X=-170,Y=-215,Z=-50)	// left
	CornerPointOffset(4)=(X=-320,Y=-90,Z=-50)	// rear
	CornerPointOffset(5)=(X=-320,Y=90,Z=-50)	// rear
	CornerPointOffset(6)=(X=-170,Y=215,Z=-50)	// right
	CornerPointOffset(7)=(X=175,Y=215,Z=-50)	// right

	CornerPointYawRotation(0)=0			// front - out away from the tank
	CornerPointYawRotation(1)=0			// front
	CornerPointYawRotation(2)=-16384	// left
	CornerPointYawRotation(3)=-16384	// left
	CornerPointYawRotation(4)=32768		// rear
	CornerPointYawRotation(5)=32768		// rear
	CornerPointYawRotation(6)=16384		// right
	CornerPointYawRotation(7)=16384		// right

	CornerPointIsLeftCorner(0)=1;	// front
	CornerPointIsLeftCorner(1)=0;	// front
	CornerPointIsLeftCorner(2)=1;	// left
	CornerPointIsLeftCorner(3)=0;	// left
	CornerPointIsLeftCorner(4)=1;	// rear
	CornerPointIsLeftCorner(5)=0;	// rear
	CornerPointIsLeftCorner(6)=1;	// right
	CornerPointIsLeftCorner(7)=0;	// right

	CornerPointIsStandingCorner(0)=0;	// front
	CornerPointIsStandingCorner(1)=0;	// front
	CornerPointIsStandingCorner(2)=0;	// left
	CornerPointIsStandingCorner(3)=1;	// left
	CornerPointIsStandingCorner(4)=1;	// rear
	CornerPointIsStandingCorner(5)=1;	// rear
	CornerPointIsStandingCorner(6)=1;	// right
	CornerPointIsStandingCorner(7)=0;	// right

	VehicleShadowDrawScale = 6

	bHasCreatedTriggers=false
	TankGrenadeTriggerOffset=(X=-240,Y=0,Z=-50)
	TankGrenadeTriggerRadius=180;

	TankGrenadePlayerAnim="stug_grenaded"  // in a_hold_misc.panzer
	TankGrenadeMeshAnimName="a_hold_misc.stug"
	TankGrenadeMountAnimStartOffset=(X=-186.0,Y=204.0,Z=-48.0)
	TankGrenadeCameraStartOffset=(X=-50.0,Y=400.0,Z=300.0)
	TankGrenadeCameraEndOffset=(X=-50.0,Y=500.0,Z=200.0)
	TankGrenadeHeadZoomInOffset=(X=-117.3,Y=-46.8,Z=186.8)
	TankGrenadeYawSet=0
	TankGrenadeTeleportOffset=(X=-130.0,Y=-40.0,Z=100.0)

	SmokeEmitterOffset=(X=-160.0,Y=0.0,Z=0.0)
	TankDeathEmitterOffset=(X=0.0,Y=0.0,Z=32.0)
	BlowedUpEmitterOffset=(X=0.0,Y=0.0,Z=32.0)

	CharacterSetupClass=class'CharacterSetupGermany'
}
class TankStugLongGun extends TankStug;


simulated function PreBeginPlay()
{
	Mesh = Mesh( DynamicLoadObject( "k_vehicle_de.de_tank_stug_long_gun", class'Mesh' ) );

	super(Tank).PreBeginPlay();
}

simulated function SetupTracks()
{
	Skins.Length = 6;
	Skins[0] = GbxShaderMaterial( DynamicLoadObject( "t_military_de.Vehicle.de_stug_gbx", class'GbxShaderMaterial' ) );
	Skins[1] = GbxShaderMaterial( DynamicLoadObject( "t_military_de.Vehicle.de_stug_track_left_gbx", class'GbxShaderMaterial' ) );
	Skins[2] = GbxShaderMaterial( DynamicLoadObject( "t_military_de.Vehicle.de_stug_track_right_gbx", class'GbxShaderMaterial' ) );
	Skins[3] = GbxShaderMaterial( DynamicLoadObject( "t_military_de.Vehicle.de_stug_alpha_gbx", class'GbxShaderMaterial' ) );
	Skins[4] = GbxShaderMaterial( DynamicLoadObject( "t_military_de.Vehicle.de_stug_gun_misc_gbx", class'GbxShaderMaterial' ) );
	Skins[5] = GbxShaderMaterial( DynamicLoadObject( "t_military_de.Vehicle.de_stug_gun_gbx", class'GbxShaderMaterial' ) );

	LeftTrackTextureIndex = 1;
	RightTrackTextureIndex = 2;

	super(Tank).SetupTracks();
}

simulated function BeginPlay()
{
	SetPhysics(PHYS_Karma);
}

function TakeDamage(int Damage, Pawn instigatedBy, Vector Hitlocation, Vector Momentum, class<DamageType> DamageType, optional name HitBoxName)
{
	local int InitialHealth;

	InitialHealth = Health;

	Super.TakeDamage(Damage, instigatedBy, Hitlocation, Momentum, DamageType, HitBoxName);

	if ((InitialHealth > 0) && (Health <= 0))  // did we just now die?
	{
		// swap the skins out for the damaged versions...
		Skins[0] = GbxShaderMaterial( DynamicLoadObject( "t_military_de.Vehicle.de_stug_dmg_gbx", class'GbxShaderMaterial' ) );
		Skins[1] = GbxShaderMaterial( DynamicLoadObject( "t_military_de.Vehicle.de_stug_dmg_track_left", class'GbxShaderMaterial' ) );
		Skins[2] = GbxShaderMaterial( DynamicLoadObject( "t_military_de.Vehicle.de_stug_dmg_track_right", class'GbxShaderMaterial' ) );
		Skins[3] = GbxShaderMaterial( DynamicLoadObject( "t_military_de.Vehicle.de_stug_dmg_alpha_gbx", class'GbxShaderMaterial' ) );
	}
	else if (float(Health) <= (float(default.Health) * 0.5f))  // tank more than 50% dead
	{
		if (!bForceHatchOpen && !bDisablePlayerUseableTriggers)
		{
			MyTankGrenadeTrigger.bDisabled = false;  // enable the tank grenaded trigger

			bForceHatchOpen = true;

			StopAnimating(true);  // clear all the animation channels (since the firing animation can mess up the blending of the hatch)

			if (CommanderPawn != None)
			{
				if (CommanderPawn.Health > 0)  // still alive?
					CommanderPawn.KillCommander(instigatedBy, DamageType);
				else
					PlayAnim(TankHatchOpenIdleAnim, 10.0f);  // open the hatch
			}
			else
			{
				PlayAnim(TankHatchOpenIdleAnim, 10.0f);  // open the hatch
			}
		}
	}
}


defaultproperties
{
	DrawType=DT_Mesh
	Mesh=None  // use DymamicLoadObject instead
	EditorMeshName="k_vehicle_de.de_tank_stug_long_gun"
    Physics=PHYS_None

	CharacterSetupClass=class'CharacterSetupGermany'
}
class TruckOpelBlitz extends gbxWheeledCraft;


var TruckDriverPawn MyDriver;
var vector		DriverOffset;
var() name		DriverTag;
var string		DriverAnimPackage;
var name		DriverIdleAnim;
var array<name> DriverDismountAnims;
var () name		DriverUnitToJoin;
var () CharacterSetup.EDECharacterTypes	DriverCharacterType;

var gbxCharacterSpawner DriverSpawner;  // this gets set by the TruckOpelBlitzSpawner in gbxScripted
var vector		DriverSpawnerOffset;  // this is OUTSIDE the truck

var() int		NumberOfPassengersToSpawn;

var bool		bSpawningPassengers;  // this includes the driver
var string		PassengerAnimPackage;
var array<name>	PassengerDismountAnims;

var gbxCharacterSpawner PassengerSpawner;  // this gets set by the TruckOpelBlitzSpawner in gbxScripted
var vector		PassengerSpawnerOffset;  // this is OUTSIDE the truck

var bool		bTriggerOnDeathFired;
var() name		TriggerOnDeath;

var() float		PushForce;
var vector		X, Y, Z;

var() bool		bHasDriver;


simulated function PreBeginPlay()
{
	Mesh = Mesh( DynamicLoadObject( "k_vehicle_de.de_opel_blitz", class'Mesh' ) );

	super.PreBeginPlay();
}

simulated function BeginPlay()
{
	SetPhysics(PHYS_Karma);

	super.BeginPlay();

	GetAxes(Rotation, X, Y, Z);

	bSpawningPassengers = false;
}

function SpawnDriver()
{
	local ExtendedAttachmentInfo anEAInfo;
	local MeshAnimation	aMeshAnim;
	local int j;

	if (bHasDriver)
	{
		MyDriver = spawn(class'TruckDriverPawn', self);

		MyDriver.SetLocation(Location + DriverOffset.X * X + DriverOffset.Y * Y + DriverOffset.Z * Z);
		MyDriver.SetBase(self);

		anEAInfo = new( Level.Outer ) class'ExtendedAttachmentInfo';

		MyDriver.Mesh = Mesh(DynamicLoadObject("K_character_de.de_conscript_body", class'Mesh'));

		anEAInfo.m_nmSocketName = 'Head';
		anEAInfo.m_nmPartName = 'hans';

		MyDriver.ExtendedAttachments.Length = MyDriver.ExtendedAttachments.Length + 1;
		MyDriver.ExtendedAttachments[0] = anEAInfo;
		MyDriver.ExtendedAttachments[0].m_AttachedPart = Spawn( class'AttachedPart', self );
		if (MyDriver.ExtendedSkins.Length > 0)
		{
			for (j = 0; j < MyDriver.ExtendedSkins.Length; j++)
			{
				if (MyDriver.ExtendedSkins[j] != None)
				{
					MyDriver.ExtendedAttachments[0].m_AttachedPart.Skins[j] = MyDriver.ExtendedSkins[j];
				}
			}
		}

		MyDriver.ExtendedAttachment( MyDriver.ExtendedAttachments[0].m_AttachedPart, MyDriver.ExtendedAttachments[0].m_nmSocketName, MyDriver.ExtendedAttachments[0].m_nmPartName );

		aMeshAnim = MeshAnimation(DynamicLoadObject("a_ev_all.a_ev_corrion", class'MeshAnimation'));
		if (aMeshAnim != None)
		{
			MyDriver.LinkSkelAnim(aMeshAnim);
		}

		aMeshAnim = MeshAnimation( DynamicLoadObject( DriverAnimPackage, class'MeshAnimation' ) );
		if ( aMeshAnim != None )
		{
			if ( MyDriver.MeshAnim != None )
				MyDriver.UnlinkSkelAnim( MyDriver.MeshAnim, false );
			if (MyDriver.LinkSkelAnim( aMeshAnim ))
			{
				MyDriver.MeshAnim = aMeshAnim;
			}
			MyDriver.bInitializeAnimation = false;
		}

		MyDriver.LoopAnim(DriverIdleAnim);
	}
}

function MatchStarting()
{
	local MeshAnimation	aMeshAnim;

	Super.MatchStarting();

	if (MyDriver != None)
	{
		MyDriver.ExtendedAttachment( MyDriver.ExtendedAttachments[0].m_AttachedPart, MyDriver.ExtendedAttachments[0].m_nmSocketName, MyDriver.ExtendedAttachments[0].m_nmPartName );

		aMeshAnim = MeshAnimation(DynamicLoadObject("a_ev_all.a_ev_corrion", class'MeshAnimation'));
		if (aMeshAnim != None)
		{
			MyDriver.LinkSkelAnim(aMeshAnim);
		}

		aMeshAnim = MeshAnimation( DynamicLoadObject( DriverAnimPackage, class'MeshAnimation' ) );
		if ( aMeshAnim != None )
		{
			if ( MyDriver.MeshAnim != None )
				MyDriver.UnlinkSkelAnim( MyDriver.MeshAnim, false );
			if (MyDriver.LinkSkelAnim( aMeshAnim ))
			{
				MyDriver.MeshAnim = aMeshAnim;
			}
			MyDriver.bInitializeAnimation = false;
		}

		MyDriver.RestartAnimQueue();
	}

	MyDriver.LoopAnim(DriverIdleAnim);
}

simulated function Destroyed()
{
	if (MyDriver != None)
	{
		MyDriver.Destroy();
		MyDriver = None;
	}
	if (DriverSpawner != None)
	{
		DriverSpawner.Destroy();
		DriverSpawner = None;
	}
	if (PassengerSpawner != None)
	{
		PassengerSpawner.Destroy();
		PassengerSpawner = None;
	}
}

function TakeDamage(int Damage, Pawn instigatedBy, Vector Hitlocation, Vector Momentum, class<DamageType> DamageType, optional name HitBoxName)
{
	local int actualDamage;
	local vector v_push, PushAngVel;

	if ( Role < ROLE_Authority )
	{
		return;
	}

	if ( Controller != None )
	{
		Controller.NotifyTakeHit(instigatedBy, HitLocation, actualDamage, DamageType, Momentum);

		if (Controller.bGodMode)
			return;
	}

	if (Health <= 0)  // dead already?
	{
		// is this an exploding type damage or hand grenade?
		if ((damageType.Default.m_bDamagesArmor) || (ClassIsChildOf(damageType, class'DamageGrenade')))
		{
			SetPhysics(PHYS_Karma);
			KWake();  // make sure we're awake

			KarmaSleepTime = Level.TimeSeconds + 3.0;  // put back to sleep again in 3.0 seconds

			// push the tank around some based on the Momentum vector
			v_push = Momentum * PushForce;
			Log(name $ ".TakeDamage - Momentum = " $ Momentum $ "  v_push = " $ v_push, 'Tank');

			PushAngVel = Normal(v_push) Cross ( Normal(v_push) * vect(1,1,0)) * PushForce;
			KSetSkelVel( v_push, PushAngVel );
			KAddImpulse(v_push, Location);
		}

		return;  // already dead, can't damage it any more
	}

	MakeNoise(1.0);

	// don't take any damage - HACKHACK
	return;

	if (!bTriggerOnDeathFired)
	{
		bTriggerOnDeathFired = true;  // prevent from being called twice
		TriggerEvent(TriggerOnDeath, Controller, Self);
	}
}

function Trigger( actor Other, Pawn EventInstigator )
{
	if (!bSpawningPassengers)
	{
		bSpawningPassengers = true;

		GotoState('SpawningPassengers');
	}
}

function ChooseFireAt(Actor A)
{
	if (Pawn(A) != None && Vehicle(A) == None && VSize(A.Location - Location) < 1500 && Controller.LineOfSightTo(A))
	{
		if (!bWeaponIsAltFiring)
			AltFire(0);
	}
	else if (bWeaponIsAltFiring)
		VehicleCeaseFire(true);

	Fire(0);
}

function AltFire(optional float F)
{
	//avoid sending altfire to weapon
	Super(Vehicle).AltFire(F);
}

function ClientVehicleCeaseFire(bool bWasAltFire)
{
	//avoid sending altfire to weapon
	if (bWasAltFire)
		Super(Vehicle).ClientVehicleCeaseFire(bWasAltFire);
	else
		Super.ClientVehicleCeaseFire(bWasAltFire);
}

function VehicleFire(bool bWasAltFire)
{
	if (bWasAltFire)
	{
		bWeaponIsAltFiring = True;
    }
	else
		Super.VehicleFire(bWasAltFire);
}

function VehicleCeaseFire(bool bWasAltFire)
{
	if (bWasAltFire)
    {
		bWeaponIsAltFiring = False;
	}
	else
		Super.VehicleCeaseFire(bWasAltFire);
}

function bool IsRoomToSpawnPawn(gbxCharacterSpawner Spawner)
{
	local Pawn P;
	local float distance;

	ForEach DynamicActors(class'Pawn', P)
	{
		distance = VSize(P.Location - Spawner.Location);

		if (distance < 50.0)  // Pawn too close to spawner, no room to spawn new pawn
		{
			return false;
		}
	}

	return true;
}


auto state Idle
{
Begin:

	if (bHasDriver)
		SpawnDriver();
}

state SpawningPassengers
{

Begin:

	// make sure the truck is stopped...
	while (VSize(velocity) > 10.0f)
	{
		Sleep(0.1);
	}

	GetAxes(Rotation, X, Y, Z);

	// sometimes the CharacterSpawners aren't at the proper offsets from the vehicle (WHY???), reset their locations...
	DriverSpawner.SetLocation(Location + DriverSpawnerOffset.X * X + DriverSpawnerOffset.Y * Y + DriverSpawnerOffset.Z * Z);
	DriverSpawner.SetRotation(Rotation + rot(0,49152,0));  // face away from the truck

	PassengerSpawner.SetLocation(Location + PassengerSpawnerOffset.X * X + PassengerSpawnerOffset.Y * Y + PassengerSpawnerOffset.Z * Z);
	PassengerSpawner.SetRotation(Rotation + rot(0,32768,0));  // face away from the truck

	MyDriver.bHidden = true;  // hide the driver
	DriverSpawner.Trigger(None, self);
	PlayAnim('driver_dismount', 1.0);

	if (NumberOfPassengersToSpawn > 0)
	{
		NumberOfPassengersToSpawn--;
		PassengerSpawner.Trigger(None, self);

		Sleep(1.0);  // pause a bit between each passenger

		while (NumberOfPassengersToSpawn > 0)
		{
			while ( !IsRoomToSpawnPawn(PassengerSpawner) )
			{
				Sleep(0.2);
			}

			NumberOfPassengersToSpawn--;
			PassengerSpawner.Trigger(None, self);

			Sleep(1.0);  // pause a bit between each passenger
		}
	}
}


defaultproperties
{
	DrawType=DT_Mesh
	Mesh=None  // use DymamicLoadObject instead
	EditorMeshName="k_vehicle_de.de_opel_blitz"
    Physics=PHYS_None

	VehiclePositionString="in an Opel Blitz"
	VehicleNameString="OpelBlitz"
	bReplicateAnimations=True

	Health=300
	CollisionHeight=2.0
	CollisionRadius=2.0
	VehicleCollisionHeight=128.0
	VehicleCollisionRadius=300.0

	DriverDamageMult=0.80
//	bHasAltFire=false
//	bSeparateTurretFocus=true
	RanOverDamageType=class'Crushed'
	CrushedDamageType=class'Crushed'

	DrawScale=1.0
	DrawScale3D=(X=1.0,Y=1.0,Z=1.0)

	FPCamPos=(X=15,Y=0,Z=25)
	TPCamLookat=(X=0,Y=0,Z=0)
	TPCamWorldOffset=(X=0,Y=0,Z=100)
//	TPCamDistance=375
	TPCamDistance=800

	bDrawDriverInTP=True
	bDrawMeshInFP=True
	bHasHandbrake=true
	bAllowBigWheels=false

	DrivePos=(X=20.0,Y=0.0,Z=100.0)

	MaxViewYaw=16000
	MaxViewPitch=16000

//	IdleSound=sound'ONSVehicleSounds-S.RV.RVEng01'
//	StartUpSound=sound'ONSVehicleSounds-S.RV.RVStart01'
//	ShutDownSound=sound'ONSVehicleSounds-S.RV.RVStop01'
	EngineRPMSoundRange=9000
	SoundVolume=180
	IdleRPM=500
	RevMeterScale=4000

//	SteerBoneName="SteeringWheel"
//	SteerBoneAxis=AXIS_Z
//	SteerBoneMaxAngle=90

	EntryPosition=(X=0,Y=0,Z=-200)
//	EntryRadius=300.0
	EntryRadius=500.0

	ExitPositions(0)=(X=0,Y=-400,Z=100)
	ExitPositions(1)=(X=0,Y=400,Z=100)
	ExitPositions(2)=(X=0,Y=-400,Z=-100)
	ExitPositions(3)=(X=0,Y=400,Z=-100)

	WheelPenScale=0.7
	WheelPenOffset=0.01
	WheelSoftness=0.01
	WheelRestitution=0.1
	WheelAdhesion=0.0
	WheelLongFrictionFunc=(Points=((InVal=0,OutVal=0.0),(InVal=100.0,OutVal=1.0),(InVal=200.0,OutVal=0.9),(InVal=10000000000.0,OutVal=0.9)))
//	WheelLongFrictionScale=1.1
	WheelLongFrictionScale=2.5
//	WheelLatFrictionScale=1.35
	WheelLatFrictionScale=3.0
	WheelLongSlip=0.001
	WheelLatSlipFunc=(Points=((InVal=0.0,OutVal=0.0),(InVal=30.0,OutVal=0.009),(InVal=45.0,OutVal=0.00),(InVal=10000000000.0,OutVal=0.00)))
	WheelHandbrakeSlip=0.01
	WheelHandbrakeFriction=0.1
	WheelSuspensionTravel=2.0
	WheelSuspensionOffset=0.0
	WheelSuspensionMaxRenderTravel=2.0
	TurnDamping=35

	HandbrakeThresh=200
	FTScale=0.03
	ChassisTorqueScale=0.4

	MinBrakeFriction=4.0
	MaxBrakeTorque=20.0
	MaxSteerAngleCurve=(Points=((InVal=0,OutVal=25.0),(InVal=1500.0,OutVal=11.0),(InVal=1000000000.0,OutVal=11.0)))
	SteerSpeed=160
	StopThreshold=100
	TorqueCurve=(Points=((InVal=0,OutVal=9.0),(InVal=200,OutVal=10.0),(InVal=1500,OutVal=11.0),(InVal=2800,OutVal=0.0)))
	EngineBrakeFactor=0.0001
	EngineBrakeRPMScale=0.1
	EngineInertia=0.1
//	WheelInertia=0.1
	WheelInertia=0.02

	TransRatio=0.15
	GearRatios[0]=-0.5
	GearRatios[1]=0.4
	GearRatios[2]=0.65
	GearRatios[3]=0.85
	GearRatios[4]=1.1
	ChangeUpPoint=2000
	ChangeDownPoint=1000
	LSDFactor=1.0

	VehicleMass=10.0

    Begin Object Class=KarmaParamsRBFull Name=KParams0
		KStartEnabled=True
		KFriction=0.5
		KLinearDamping=0.05
		KAngularDamping=0.05
		KImpactThreshold=700
		bKNonSphericalInertia=True
        bHighDetailOnly=False
        bClientOnly=False
		bKDoubleTickRate=True
		KInertiaTensor(0)=1.0  // roll stiffness
		KInertiaTensor(1)=0.0
		KInertiaTensor(2)=0.0
		KInertiaTensor(3)=3.0  // pitch stiffness
		KInertiaTensor(4)=0.0
		KInertiaTensor(5)=3.0  // yaw stiffness
		KCOMOffset=(X=-0.25,Y=0.0,Z=-3.0)
		bDestroyOnWorldPenetrate=True
		bDoSafetime=True
        Name="KParams0"
    End Object
    KParams=KarmaParams'KParams0'

	Begin Object Class=SVehicleWheel Name=RRWheel
		BoneName="tire_rear_right"
		BoneRollAxis=AXIS_Z
		bInvertRollDirection=True
		BoneSteerAxis=AXIS_Z
		BoneOffset=(X=0.0,Y=0.0,Z=0.0)
		WheelRadius=47
		bPoweredWheel=True
		bHandbrakeWheel=True
		SteerType=VST_Fixed
		SupportBoneAxis=AXIS_X
		SupportBoneName="strut_rear_right"
	End Object
	Wheels(0)=SVehicleWheel'RRWheel'

	Begin Object Class=SVehicleWheel Name=LRWheel
		BoneName="tire_rear_left"
		BoneRollAxis=AXIS_Z
		bInvertRollDirection=True
		BoneSteerAxis=AXIS_Z
		BoneOffset=(X=0.0,Y=0.0,Z=0.0)
		WheelRadius=47
		bPoweredWheel=True
		bHandbrakeWheel=True
		SteerType=VST_Fixed
		SupportBoneAxis=AXIS_X
		SupportBoneName="strut_rear_left"
	End Object
	Wheels(1)=SVehicleWheel'LRWheel'

	Begin Object Class=SVehicleWheel Name=OB_RFWheel
		BoneName="tire_front_right"
		BoneRollAxis=AXIS_Z
		bInvertRollDirection=True
		BoneSteerAxis=AXIS_Y
		BoneOffset=(X=0.0,Y=0.0,Z=0.0)
		WheelRadius=47
		bPoweredWheel=True
		SteerType=VST_Steered
		SupportBoneAxis=AXIS_X
		SupportBoneName="strut_front_right"
	End Object
	Wheels(2)=SVehicleWheel'OB_RFWheel'

	Begin Object Class=SVehicleWheel Name=OB_LFWheel
		BoneName="tire_front_left"
		BoneRollAxis=AXIS_Z
		bInvertRollDirection=True
		BoneSteerAxis=AXIS_Y
		BoneOffset=(X=0.0,Y=0.0,Z=0.0)
		WheelRadius=47
		bPoweredWheel=True
		SteerType=VST_Steered
		SupportBoneAxis=AXIS_X
		SupportBoneName="strut_front_left"
	End Object
	Wheels(3)=SVehicleWheel'OB_LFWheel'

	GroundSpeed=320

	MaxDesireability=0.4
	ObjectiveGetOutDist=1500.0

//	bUseHeadlights=true

//	HeadlightCoronaOffset(0)=(X=300,Y=80,Z=-40)
//	HeadlightCoronaOffset(1)=(X=300,Y=-80,Z=-40)
//	HeadlightCoronaMaterial=Texture't_effect.test.headlight_corona'
//	HeadlightCoronaMaxSize=65

//	HeadlightProjectorOffset=(X=320,Y=0,Z=-40)
//	HeadlightProjectorRotation=(Yaw=0,Pitch=-1000,Roll=0)
//	HeadlightProjectorMaterial=Texture't_effect.test.headlight'
//	HeadlightProjectorScale=0.3

	PushForce=10.0

	DriverOffset=(X=107,Y=-45,Z=33)
	DriverAnimPackage="a_hold_misc.opel"
	DriverIdleAnim="opel_driver_idle"
	DriverDismountAnims(0)="opel_driver_dismount"

	DriverSpawnerOffset=(X=107,Y=-148,Z=-25)

	PassengerAnimPackage="a_hold_misc.opel"
	PassengerDismountAnims(0)="opel_back_passenger_dismount_1"
	PassengerDismountAnims(1)="opel_back_passenger_dismount_2"
	PassengerDismountAnims(2)="opel_back_passenger_dismount_3"

	PassengerSpawnerOffset=(X=-352,Y=0,Z=-25)

	bHasDriver=true
}
