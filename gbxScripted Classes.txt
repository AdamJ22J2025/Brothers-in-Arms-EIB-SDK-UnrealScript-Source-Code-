class ACTION_AttachStaticMesh extends ScriptedAction;



var(Action) StaticMesh	StaticMesh;
var(Action) name		BoneName;

simulated function AttachToPawn(AnimPawn P)
{
	if (P != None)
	{
		P.AttachScriptedAttachment( StaticMesh, BoneName );
	}
}

function bool InitActionFor(ScriptedController C)
{
	if( C.Pawn == None )
	{
		Log( "WARNING: " $ class $ ".InitActionFor( " $ C $ " ) no pawn set, or pawn lacks controller." );
		return false;
	}

	if (C.Pawn.IsA('AnimPawn'))
	{
		AttachToPawn( AnimPawn(C.Pawn) );
	}

	return false;
}

defaultproperties
{
}
class ACTION_ChangeController extends ScriptedAction;

var (Action) class<Controller>  NewControllerClass;
var (Action) bool bDontTransitionToCombat;

function bool InitActionFor(ScriptedController C)
{
	local Controller NewC;
	local AnimPawn gbxP;
	
	gbxP = AnimPawn(C.Pawn);
	if( gbxP != None && !gbxP.IsDead() )
	{		
		NewC = C.Spawn( NewControllerClass );

		if( NewC == None )
		{
			log( NewC $ ".ACTION_ChangeController( '" $ NewControllerClass $ "  ): could not spawn controller of that class."  );
		}
		else
		{
			// Make the prior controller unpossess the pawn.
			if( gbxP.Controller != None )
			{
				if (gbxP.Controller.IsA('ScriptedController'))
				{
					gbxP.m_bDisableAnimQueue = false;
					gbxP.FlushAnimQueueChannel( 0, true );
					gbxP.ClearIdleQueue();
					gbxP.m_fRunNextQueueIdle = false;
					gbxP.bDoHeadTurn = true;
					gbxP.SetLookAtTarget( None );
					if (gbxPawn(gbxP) != None)
					{
						gbxPawn(gbxP).bDontLookAtPlayers = false;
					}
				}
				
				// GBX:RSC - copy the old controller's destination to the new controller
				NewC.Destination = gbxP.Controller.Destination;

				gbxP.Controller.UnPossess();
				if ( C != None )
				{
					C.Destroy();
				}
				log("gbxP.ACTION_ChangeController() - 1 - "$C);
			}

			if (gbxPawn(gbxP) != None)
			{
				gbxPawn(gbxP).bDontTransitionToCombat = bDontTransitionToCombat;
			}
			NewC.Possess( gbxP );
		}
	}
	
	return true;
}

function string GetActionString()
{
	return ActionString@NewControllerClass;
}

defaultproperties
{
	ActionString="Change to controller "
}
class ACTION_Crouch extends ScriptedAction;



function bool InitActionFor(ScriptedController C)
{
	C.Pawn.ShouldCrouch(true);
	return false;
}

defaultproperties
{
	ActionString="crouch"
	bValidForTrigger=false
}
class ACTION_DestroyActor extends ScriptedAction;



var(Action)		name			DestroyTag;

function bool InitActionFor(ScriptedController C)
{
	local Actor a;

	if(DestroyTag != 'None')
	{
		ForEach C.AllActors(class'Actor', a, DestroyTag)
		{
			if (a.IsA('TerrainInfo'))
			{
				TerrainInfo(a).m_fTerrainDisabled=true;
			}
			else
				a.Destroy();
		}
	}

	return false;
}

function string GetActionString()
{
	return ActionString;
}

defaultproperties
{
	ActionString="Destroy actor"
}
class ACTION_DestroyPawn extends ScriptedAction;



function bool InitActionFor(ScriptedController C)
{
	C.DestroyPawn();
	return true;
}

defaultproperties
{
	ActionString="destroy pawn"
	bValidForTrigger=false
}
class ACTION_DestroyStaticActor extends ScriptedAction;



var(Action)		name			DestroyTag;

function bool InitActionFor(ScriptedController C)
{
	local Actor a;

	if(DestroyTag != 'None')
	{
		ForEach C.AllActors(class'Actor', a, DestroyTag)
		{
			if (a.bStatic)
				a.bStatic = false;
			a.Destroy();
		}
	}

	return false;
}

function string GetActionString()
{
	return ActionString;
}

defaultproperties
{
	ActionString="Destroy static actor"
}
class ACTION_DetachStaticMesh extends ScriptedAction;



var(Action) StaticMesh	StaticMesh;
var(Action) name		BoneName;

simulated function DetachFromPawn(AnimPawn P)
{
	if (P != None)
	{
		P.DetachScriptedAttachment( StaticMesh, BoneName );
	}
}

function bool InitActionFor(ScriptedController C)
{
	if (C.Pawn.IsA('AnimPawn'))
	{
		DetachFromPawn( AnimPawn(C.Pawn) );
	}

	return false;
}

defaultproperties
{
}
class ACTION_DetachWeapon extends ScriptedAction;



var(Action) name		BoneName;

simulated function DetachWeaponFromPawn(AnimPawn P)
{
	if (P != None)
	{
		P.DetachWeapon( BoneName );
	}
}

function bool InitActionFor(ScriptedController C)
{
	if (C.Pawn.IsA('AnimPawn'))
	{
		DetachWeaponFromPawn( AnimPawn(C.Pawn) );
	}

	return false;
}

defaultproperties
{
}
class ACTION_Freeze extends LatentScriptedAction;



function bool InitActionFor(ScriptedController C)
{
	if ( C.Pawn != None )
	{
		C.Pawn.bPhysicsAnimUpdate = false;
		C.Pawn.StopAnimating();
		C.Pawn.SetPhysics(PHYS_None);
	}
	C.CurrentAction = self;
	return true;
}


defaultproperties
{
	ActionString="Freeze"
}
class ACTION_FreezeOnAnimEnd extends Action_PLAYANIM;



function bool InitActionFor(ScriptedController C)
{
	C.CurrentAnimation = self;
	return true;
}

function SetCurrentAnimationFor(ScriptedController C)
{
	C.CurrentAnimation = self;
}

function bool PawnPlayBaseAnim(ScriptedController C, bool bFirstPlay)
{
	if ( C.Pawn != None )
	{
		C.Pawn.bPhysicsAnimUpdate = false;
		C.Pawn.StopAnimating();
		C.Pawn.SetPhysics(PHYS_None);
	}
	return true;
}
class ACTION_GotoAction extends ScriptedAction;



var(Action) int ActionNumber;

function ProceedToNextAction(ScriptedController C)
{
	C.ActionNum = Max(0,ActionNumber);
}

function string GetActionString()
{
	return ActionString@ActionNumber;
}

defaultproperties
{
	ActionString="go to action"
}
class ACTION_IfCondition extends ScriptedAction;



var(Action) name TriggeredConditionTag;
var TriggeredCondition T;

function ProceedToNextAction(ScriptedController C)
{
	if ( (T == None) && (TriggeredConditionTag != 'None') )
		ForEach C.AllActors(class'TriggeredCondition',T,TriggeredConditionTag)
			break;

	C.ActionNum += 1;
	if ( !T.bEnabled )
		ProceedToSectionEnd(C);
}

function bool StartsSection()
{
	return true;
}

function string GetActionString()
{
	return ActionString@T@TriggeredConditionTag;
}

defaultproperties
{
	ActionString="If condition"
}
class ACTION_IfRandomPct extends ScriptedAction;



var(Action) float Probability;

function ProceedToNextAction(ScriptedController C)
{
	C.ActionNum += 1;
	if ( FRand() > Probability )
		ProceedToSectionEnd(C);
}

function bool StartsSection()
{
	return true;
}

defaultproperties
{
}
class ACTION_LeaveSequence extends ScriptedAction;



function ScriptedSequence GetScript(ScriptedSequence S)
{
	return None;
}

defaultproperties
{
	ActionString="leave sequence"
}
class ACTION_PlayLocalSound extends ScriptedAction;



var(Action)		sound	Sound;

function bool InitActionFor(ScriptedController C)
{
	local PlayerController P;

	// play appropriate sound
		ForEach C.DynamicActors(class'PlayerController', P)
			P.ClientPlaySound(Sound);
	return false;
}

function string GetActionString()
{
	return ActionString@Sound;
}

defaultproperties
{
	ActionString="play sound"
}
class ACTION_ReattachWeapon extends ScriptedAction;



var(Action) name		BoneName;

simulated function ReattachWeaponFromPawn(AnimPawn P)
{
	if (P != None)
	{
		P.ReattachWeapon( BoneName );
	}
}

function bool InitActionFor(ScriptedController C)
{
	if (C.Pawn.IsA('AnimPawn'))
	{
		ReattachWeaponFromPawn( AnimPawn(C.Pawn) );
	}

	return false;
}

defaultproperties
{
	BoneName="rifle_hold"
}
class ACTION_Reload extends ScriptedAction;



function bool InitActionFor(ScriptedController C)
{
	if ((C.Pawn == None) || (C.Pawn.Weapon == None))
		return false;

	if ( (C.Pawn != None) && (C.Pawn.Weapon != None) )
		C.Pawn.Weapon.ClientForceReload();
	return false;
}

defaultproperties
{
}

class ACTION_Run extends ScriptedAction;



function bool InitActionFor(ScriptedController C)
{
	C.Pawn.ShouldCrouch(false);
//	if (WargamePawn(C.Pawn) != None)
//		WargamePawn(C.Pawn).SetCreeping(false);
	C.Pawn.SetWalking(false);
	return false;
}

defaultproperties
{
	ActionString="Run"
	bValidForTrigger=false
}
class ACTION_SetHidden extends ScriptedAction;



var(Action) bool bHidden;
var(Action) name HideActorTag;

function bool InitActionFor(ScriptedController C)
{
	local Actor A;
	if ( HideActorTag != '' )
	{
		ForEach C.AllActors(class'Actor',A,HideActorTag)
			A.bHidden = bHidden;
	}
	else
	C.GetInstigator().bHidden = bHidden;
	return false;
}
class ACTION_SetRootMotion extends ScriptedAction;



var(Action)	bool	fRootMotion;	// Root motion on or off?

function bool InitActionFor(ScriptedController C)
{
	if( C.Pawn == None )
	{
		Log( "WARNING: " $ class $ ".InitActionFor( " $ C $ " ) no pawn set, or pawn lacks controller." );
		return false;
	}

	if (fRootMotion)
	{
		C.Pawn.SetPhysics(PHYS_RootMotion);
		C.Pawn.LockRootMotion(1);
	}
	else
	{
		C.Pawn.LockRootMotion(1);
        C.Pawn.SetPhysics( PHYS_Walking );
		C.Pawn.LockRootMotion(0);
	}

	return false;
}

defaultproperties
{
	fRootMotion=false
}
class ACTION_StopAnimation extends ScriptedAction;



function bool InitActionFor(ScriptedController C)
{
	C.ClearAnimation();
	return false;
}

defaultproperties
{
	ActionString="stop animation"
	bValidForTrigger=false
}
class ACTION_TeleportToPoint extends LatentScriptedAction;



var(Action) name DestinationTag;	// tag of destination - if none, then use the ScriptedSequence
var(Action) bool bPlaySpawnEffect;
var(Action) bool bTeleportPlayer;

var ActorLite Dest;

function bool InitActionFor(ScriptedController C)
{
	local Pawn P;
	local ActorLite AL;

	Dest = C.SequenceScript.GetMoveTarget();

	if ( DestinationTag != '' )
	{
		for (AL=C.Level.NavigationPointList; AL!=None; AL=AL.nextNavigationPoint)
		{
			if (AL.bIsNavigationPoint)
			{
				if (NavigationPoint(AL).Tag == DestinationTag)
					break;
			}
			else if (AL.bIsNavigationPointLite)
			{
				if (NavigationPointLite(AL).Tag == DestinationTag)
					break;
			}
		}

		Dest = AL;
	}

	if( bTeleportPlayer )
	{
		P = C.Level.GetLocalPlayerController().Pawn;
	}
	else
	{
		P = C.GetInstigator();
	}

	if (!Dest.bIsNavigationPointLite)
	{
		P.SetLocation(Actor(Dest).Location);
		P.SetRotation(Actor(Dest).Rotation);
	}
	else
	{
		P.SetLocation(NavigationPointLite(Dest).Location);
		P.SetRotation(NavigationPointLite(Dest).Rotation);
	}

	P.OldRotYaw = P.Rotation.Yaw;
	if ( bPlaySpawnEffect )
		P.PlayTeleportEffect(false,true);
	return false;
}
class ACTION_TeleportToRoot extends LatentScriptedAction;

enum ERootTeleportMode
{
	TELEPORT_None,
	TELEPORT_AtEndRotate,
	TELEPORT_AtEndNoRotate,
	TELEPORT_AtBeginRotate,
	TELEPORT_AtBeginNoRotate,
};

var(Action) ERootTeleportMode bTeleportAtAnimEnd;

function bool InitActionFor(ScriptedController C)
{
	local AnimPawn P;

	P = AnimPawn(C.GetInstigator());
	
	if (P != None)
	{
		P.m_bTeleportAtAnimEnd = bTeleportAtAnimEnd;
	}
	
	return false;
}
class ACTION_TriggerEvent extends ScriptedAction;



var(Action) name Event;

function bool InitActionFor(ScriptedController C)
{
	// trigger event associated with action
	C.TriggerEvent(Event,C.SequenceScript,C.GetInstigator());
	return false;
}

function string GetActionString()
{
	return ActionString@Event;
}

defaultproperties
{
	ActionString="trigger event"
}
class ACTION_UnSetAnimSet extends ScriptedAction;



var(Action) name MeshAnimName;

function bool InitActionFor(ScriptedController C)
{
	local MeshAnimation	aMeshAnim;
	local Pawn			thePawn, aPawn;

	thePawn = C.Pawn;	
	if( thePawn != None )
	{
		aMeshAnim = MeshAnimation(thePawn.UnlinkSkelAnimByName( ""$MeshAnimName, false ));
		if (aMeshAnim != None)
		{
			foreach C.AllActors( class'Pawn', aPawn )
			{
				if (MeshAnimation(aPawn.GetSkelAnimByName( ""$MeshAnimName )) == aMeshAnim)
				{
					Log("ACTION_UnsetAnimSet( "$thePawn$", "$MeshAnimName$" ) - "$aMeshAnim$" - Not Deleted");
					return false;
				}
			}
			
			Log("ACTION_UnsetAnimSet( "$thePawn$", "$MeshAnimName$" ) - "$aMeshAnim$" - Deleted");
//			delete(aMeshAnim);
		}
	}
	return false;
}

function string GetActionString()
{
	return ActionString@MeshAnimName;
}

defaultproperties
{
	ActionString="UnSetAnimSet"
}
class ACTION_WaitForAnimEnd extends LatentScriptedAction;



var(Action) int Channel;

function bool CompleteOnAnim(ScriptedController C, int Num)
{
	return (Channel == Num);
}

defaultproperties
{
	ActionString="Wait for animend"
	bValidForTrigger=false
}
class ACTION_WaitForEvent extends LatentScriptedAction;



var(Action) name ExternalEvent;	//tag to give controller (to affect triggering)
var TriggeredCondition T;

function bool InitActionFor(ScriptedController C)
{
	if ( T == None )
		ForEach C.AllActors(class'TriggeredCondition',T,ExternalEvent)
			break;

	if ( (T != None) && T.bEnabled )
		return false;

	C.CurrentAction = self;
	C.Tag = ExternalEvent;
	return true;
}

function bool CompleteWhenTriggered()
{
	return true;
}

function string GetActionString()
{
	return ActionString@ExternalEvent;
}

defaultproperties
{
	ActionString="Wait for external event"
}
class ACTION_WaitForPlayer extends LatentScriptedAction;



var(Action) float Distance;

function bool InitActionFor(ScriptedController C)
{
	if ( C.CheckIfNearPlayer(Distance) )
		return false;
	C.CurrentAction = self;
	C.SetTimer(0.1,true);
	return true;
}

function float GetDistance()
{
	return Distance;
}

function bool WaitForPlayer()
{
	return true;
}

defaultproperties
{
	Distance=150
	ActionString="Wait for player"
	bValidForTrigger=false
}
class ACTION_WaitForSubTitle extends ACTION_WaitForEvent;



function bool InitActionFor(ScriptedController C)
{
	local PlayerController	aPlayer;

	ForEach C.DynamicActors(class'PlayerController', aPlayer)
	{
		if ((WargamePlayerController(aPlayer) != None) && (WargameHUD(aPlayer.MyHUD) != None))
		{
			WargameHUD(aPlayer.MyHUD).m_eHudMode = HudModeWaitForKey;
			WargameHUD(aPlayer.MyHUD).m_szWaitTag = ExternalEvent;
			WargamePlayerController(aPlayer).bLockedMovement = true;
//			WargameHUD(aPlayer.MyHUD).bHideWargameHUD = true;
			gbxWeapon(aPlayer.Pawn.Weapon).ForceUnzoom();
			aPlayer.SetHand( 2 );
		}
	}

	return Super.InitActionFor( C );
}

defaultproperties
{
	ActionString="WaitForSubTitle"
}
class ACTION_WaitForTimer extends LatentScriptedAction;



var(Action) float PauseTime;

function bool InitActionFor(ScriptedController C)
{
	C.CurrentAction = self;
	C.SetTimer(PauseTime, false);
	return true;
}

function bool CompleteWhenTriggered()
{
	return true;
}

function bool CompleteWhenTimer()
{
	return true;
}

function string GetActionString()
{
	return ActionString@PauseTime;
}

defaultproperties
{
	ActionString="Wait for timer"
}
class ACTION_Walk extends ScriptedAction;



function bool InitActionFor(ScriptedController C)
{
	C.Pawn.ShouldCrouch(false);
//	if (WargamePawn(C.Pawn) != None)
//		WargamePawn(C.Pawn).SetCreeping(false);
	C.Pawn.SetWalking(true);
	return false;
}

defaultproperties
{
	ActionString="walk"
	bValidForTrigger=false
}
class BlockingVolumeToggleable extends BlockingVolume;

function Trigger( Actor Other, Pawn EventInstigator )
{
	//Log( " BlockingVolumeToggleable::Trigger() bCollideActors="$bCollideActors$" bBlockActors="$bBlockActors$" bBlockPlayers="$bBlockPlayers );

	// Toggle between blocking and not blocking.
	SetCollision( !bCollideActors, !bBlockActors, !bBlockPlayers );
    //KSetBlockKarma( !bBlockKarma );
}

defaultproperties
{
	bStatic=false
	bSkipActorPropertyReplication=false
	RemoteRole=ROLE_AutonomousProxy
}class CharacterSpawner extends gbxCharacterSpawner
	placeable;



var(CharPawn) name					UnitToJoin;
var(CharPawn) bool					bLeader;
var			  bool					bMeshPrecached;
var(CharPawn) bool					bUseSmirkFacialExpressions;
var(CharPawn) bool					bUseScowlFacialExpressions;
var(CharPawn) bool					bCanTakeDamage;
var(CharPawn) bool					bDontDropWeapon;

var(CharPawn) string				VoiceTypeName;
var(CharPawn) bool					bPreloadBattleDialogue;	// set this to FALSE to exclude this cahracter from preloading Battle Dialogue

// GBX:PAD: This is used to define an array of extended attachments to an Actor (e.g. swapped out heads, arms, wheels, etc)
var(CharPawn)	export editinline	array<ExtendedAttachmentInfo>	ExtendedAttachments;	// A list of extended attachments to this mesh
var(CharPawn)	string	RequiredEquipment[16];	// allow L.D. to modify for single player
var(CharPawn)	name	TriggerOnDeath;
var(CharPawn)	string	MeshAnimName;

var(CharPawn)	string	CharacterName;

var(CharPawn)	name	m_szUsedByTrigger;			// Fire this trigger when this guy is used by the player
var Name defaultPrecachedHeadMeshName; // created to make the UpdateDefaultPrecachedMeshes() parametric 2004-04-07 JWS

var(CharPawn)	float	m_flLegScale;

var(Display) array<Material> ExtendedSkins;				// Skins to be copied over to extended attachments

// This code was moved here since it was identical in *USA and *Germany derived classes. 2004-04-07 JWS
function SetDefaultExtendedAttachments( WargamePawn WGPawn )
{
	local ExtendedAttachmentInfo	anEAInfo;
	local int						j;

	// GBX:PAD: If a StaticMesh is set, then this guy is a StaticPawn for now, so don't do the extended attachments just yet
	if (StaticMesh != None)
		return;

	if (WGPawn.GetCharacterHead() != '')
	{
		anEAInfo = new( Level.Outer ) class'ExtendedAttachmentInfo';
		anEAInfo.m_nmSocketName = 'Head';
		anEAInfo.m_nmPartName = WGPawn.GetCharacterHead();

		WGPawn.ExtendedAttachments[0] = anEAInfo;
		WGPawn.ExtendedAttachments[0].m_AttachedPart = Spawn( class'AttachedPart' );
		if (ExtendedSkins.Length > 0)
		{
			for (j = 0; j < ExtendedSkins.Length; j++)
			{
				if (ExtendedSkins[j] != None)
				{
					WGPawn.ExtendedSkins[j] = ExtendedSkins[j];
					WGPawn.ExtendedAttachments[0].m_AttachedPart.Skins[j] = ExtendedSkins[j];
				}
			}
		}
		if (WGPawn.ExtendedAttachments[0].m_szGroupName != "")
			WGPawn.ExtendedAttachmentNamedGroup( WGPawn.ExtendedAttachments[0].m_AttachedPart, WGPawn.ExtendedAttachments[0].m_szGroupName );
		else
			WGPawn.ExtendedAttachment( WGPawn.ExtendedAttachments[0].m_AttachedPart, WGPawn.ExtendedAttachments[0].m_nmSocketName, WGPawn.ExtendedAttachments[0].m_nmPartName );
	}
}

// This code was moved here since it was practically identical in *USA and *Germany derived classes. The only difference was the data for the head mesh
// to precache, so that was made a class property instead
simulated function UpdateDefaultPrecachedMeshes()
{
	local Mesh	aMesh;

	aMesh = GetExtendedAttachment( 'Head', defaultPrecachedHeadMeshName );
	if (aMesh != None)
	{
		Level.AddPrecacheMesh(aMesh);
	}
}

function DeadPawnJoinUnit()
{
	local Unit			U;
	
	// GBX:PAD: This is a bit of a hack, but basically deal with a previous unit member respawning as
	// "dead", but making sure the unit count remains what it should be.
	if( (UnitToJoin != 'None') && (UnitToJoin != '') )
	{
		foreach DynamicActors( class'Unit', U, UnitToJoin )
		{
			U.AddDeadMember();
		}
	}
}
				
function ConfigurePawn( Pawn newPawn )
{
	local int			i, j;
	local WargamePawn   WGPawn;
	local string		portraitName;
	//Log( self$" CharacterSpawner::ConfigurePawn() UnitToJoin="$UnitToJoin, 'MP' );

	Super.ConfigurePawn( newPawn );

	WGPawn = WargamePawn(newPawn);

	if (WGPawn != None)
	{
		if( (UnitToJoin != 'None') && (UnitToJoin != '') )
		{
			WGPawn.JoinUnit( UnitToJoin, bLeader );
		}

		SetCustomBodyMesh( WGPawn );
		
		for( i = 0; i < 16; i++ )
		{
			WGPawn.RequiredEquipment[i] = RequiredEquipment[i];
		}
		WGPawn.AddDefaultInventory();

		if (ExtendedSkins.Length > 0)
		{
			for (j = 0; j < ExtendedSkins.Length; j++)
			{
				if (ExtendedSkins[j] != None)
				{
					WGPawn.ExtendedSkins[j] = ExtendedSkins[j];
				}
			}
		}
						
		log("Setting extended attachments", 'pad');
		if (ExtendedAttachments.Length == 0)
		{
			SetDefaultExtendedAttachments( WGPawn );
		}
		else
		{
			// GBX:PAD: If a StaticMesh is set, then this guy is a StaticPawn for now, so don't do the extended attachments just yet
			if (DrawType != DT_StaticMesh)
			{
				for( i = 0; i < ExtendedAttachments.Length; i++ )
				{
					if (ExtendedAttachments[i] != None)
					{
						WGPawn.ExtendedAttachments[i] = ExtendedAttachments[i];
						WGPawn.ExtendedAttachments[i].m_AttachedPart = Spawn( class'AttachedPart', WGPawn );
						if (ExtendedSkins.Length > 0)
						{
							for (j = 0; j < ExtendedSkins.Length; j++)
							{
								if (ExtendedSkins[j] != None)
								{
									WGPawn.ExtendedAttachments[i].m_AttachedPart.Skins[j] = ExtendedSkins[j];
								}
							}
						}
						if (ExtendedAttachments[i].m_szGroupName != "")
							WGPawn.ExtendedAttachmentNamedGroup( ExtendedAttachments[i].m_AttachedPart, ExtendedAttachments[i].m_szGroupName );
						else
							WGPawn.ExtendedAttachment( ExtendedAttachments[i].m_AttachedPart, ExtendedAttachments[i].m_nmSocketName, ExtendedAttachments[i].m_nmPartName );
					}
				}
			}
		}

		WGPawn.bUseSmirkFacialExpressions = bUseSmirkFacialExpressions;
		WGPawn.bUseScowlFacialExpressions = bUseScowlFacialExpressions;
		
		WGPawn.TriggerOnDeath = TriggerOnDeath;
		if (MeshAnimName != "")
		{
			if (WGPawn.MeshAnim == None)
			{
				WGPawn.MeshAnimName = MeshAnimName;
				WGPawn.MeshAnim = MeshAnimation(DynamicLoadObject(WGPawn.MeshAnimName,class'MeshAnimation'));
			}

			if (WGPawn.MeshAnim != None)
			{
				WGPawn.LinkSkelAnim(WGPawn.MeshAnim);
				WGPawn.bInitializeAnimation = false;
			}
		}
	}
	
	if (Level.m_flSightRadius > 0)
		WGPawn.SightRadius = Level.m_flSightRadius;

	WGPawn.m_szUsedByTrigger = m_szUsedByTrigger;
	
	if (WGPawn.DrawType == DT_StaticMesh)
	{
		if (!bCanTakeDamage)
			WGPawn.SetCollision( false, false, false );
		WGPawn.fCanTakeDamage = bCanTakeDamage;
	}
	WGPawn.SetPhysics( PHYS_Walking );

	if (m_flLegScale != 1.0f)
	{
		WGPawn.m_flLegScale = m_flLegScale;
		WGPawn.ChangeCharacterHeight();
	}

	WGPawn.CharacterName = WGPawn.GetCharacterName();
	portraitName = WGPawn.GetCharacterPortrait();
	if ( portraitName != "" )
	{
		WGPawn.Portrait = Texture( DynamicLoadObject( portraitName, class'Texture' ));
	}
	
	// GBX:PAD: If the pawn hasn't had the animation set changed to that of a weapon they are carrying, they are
	// most likely unarmed, so change them over to the default animation set.
	if ((WGPawn.Default.PawnAnimInfoClass != None) && (WGPawn.Default.PawnAnimInfoClass == WGPawn.PawnAnimInfoClass))
	{
		WGPawn.SetWeaponAnims( WGPawn.Default.PawnAnimInfoClass, true );
	}
	
	WGPawn.bDontDropWeapon = bDontDropWeapon;

	WGPawn.bDontFrustumCull = bDontFrustumCull;
	WGPawn.bIgnoreFarPlane = bIgnoreFarPlane;
}

simulated function UpdatePrecacheMeshes()
{
	local	int		i;
	local	Mesh		aMesh;
	local	Inventory	aWeapon;
	local class<Inventory> aWeaponClass;

	if (bMeshPrecached)
		return;

	if (Mesh != None)
	{
		Level.AddPrecacheMesh(Mesh);
	}

	if (ExtendedAttachments.Length > 0)
	{
		for (i = 0; i < ExtendedAttachments.Length; i++)
		{
			aMesh = GetExtendedAttachment( ExtendedAttachments[i].m_nmSocketName, ExtendedAttachments[i].m_nmPartName );
			if (aMesh != None)
			{
				Level.AddPrecacheMesh(aMesh);
			}
		}
	}
	else
	{
		UpdateDefaultPrecachedMeshes();
	}

	for ( i=0; i<16; i++ )
	{
		if ( RequiredEquipment[i] != "" )
		{
			aWeaponClass = Level.Game.BaseMutator.GetInventoryClass(RequiredEquipment[i]);
			if( aWeaponClass!=None )
			{
				aWeapon = Spawn(aWeaponClass);
				if (aWeapon != None)
				{
					aWeapon.Destroy();
				}
			}
		}
	}

	bMeshPrecached = true;
}

defaultproperties
{
	bLeader=false
	bMeshPrecached=false
	MeshAnimName=""

	bUseSmirkFacialExpressions = true;
	bUseScowlFacialExpressions = true;

	m_flLegScale=1.0f

	bPreloadBattleDialogue=true
}
class CharacterSpawnerGermany extends CharacterSpawner
	placeable;

var (CharPawn)  CharacterSetup.EDECharacterTypes	m_eCharacterType;

function Pawn GetRespawnedPawn()
{
	local	Pawn	aPawn;
	local IGbxPawnList PawnList;

	PawnList = Level.GetPawnList();
	aPawn = gbxPawnList(PawnList).GetGermanSpawn();
	return aPawn;
}

function ConfigurePawn( Pawn newPawn )
{
	local WargamePawn   WGPawn;
	local bool bIsDemoBuild;

	// GBX:naj - moving this down so that the ControllerClass can get set before spawning.
	//Super.ConfigurePawn( newPawn );
	
	WGPawn = WargamePawn(newPawn);

	WGPawn.SetCharacterType( m_eCharacterType );
	WGPawn.CharacterSetupClass = class'CharacterSetupGermany';	

	WGPawn.CreateTeamLogoShadow("t_interface_mb.shadow_de_cross");

	Super.ConfigurePawn( newPawn );

	bIsDemoBuild = Level.IsDemoBuild();
	//log( "CharacterSpawnerGermany::ConfigurePawn() - bIsDemoBuild=" $ bIsDemoBuild, 'RSC' );
	WGPawn.SetVoiceType( WGPawn.GetCharacterVoiceType( bIsDemoBuild ) );

	WGPawn.MyUnit.MyUnitController.ResetSuppressionLevelAnalog();  //NAC: reset the suppression level of this pawn's unit

	if (WGPawn.m_flLegScale == 1.0f)
	{
		WGPawn.m_flLegScale = WGPawn.GetCharacterScale();
		if (WGPawn.m_flLegScale != 1.0f)
		{
			WGPawn.ChangeCharacterHeight();
		}
	}

	// This is used to preload the battle dialogue so QA can get a proper list for the preload files.
	//log( "CharacterSpawnerGermany::ConfigurePawn() - Level.bPreloadBattleDialogue=" $ Level.bPreloadBattleDialogue, 'RSC' );
	if( WGPawn.Voicetype != None )
	{
		WGPawn.Voicetype.SortSpeeches();
		if( Level.bPreloadBattleDialogue && self.bPreloadBattleDialogue )
	{
		//log( "CharacterSpawnerGermany::ConfigurePawn() - Preloading Battle Dialogue for Voicetype " $ WGPawn.VoiceType, 'RSC' );
		WGPawn.VoiceType.Preload();
	}
}
}

function SetDefaultExtendedAttachments( WargamePawn WGPawn )
{
	local ExtendedAttachmentInfo	anEAInfo;
	local int						j;

	// GBX:PAD: If a StaticMesh is set, then this guy is a StaticPawn for now, so don't do the extended attachments just yet
	if (StaticMesh != None)
		return;

	if (WGPawn.GetCharacterHead() != '')
	{
		anEAInfo = new( Level.Outer ) class'ExtendedAttachmentInfo';
		anEAInfo.m_nmSocketName = 'Head';
		anEAInfo.m_nmPartName = WGPawn.GetCharacterHead();

		WGPawn.ExtendedAttachments[0] = anEAInfo;
		WGPawn.ExtendedAttachments[0].m_AttachedPart = Spawn( class'AttachedPart', WGPawn );
		if (ExtendedSkins.Length > 0)
		{
			for (j = 0; j < ExtendedSkins.Length; j++)
			{
				if (ExtendedSkins[j] != None)
				{
					WGPawn.ExtendedSkins[j] = ExtendedSkins[j];
					WGPawn.ExtendedAttachments[0].m_AttachedPart.Skins[j] = ExtendedSkins[j];
				}
			}
		}
		if (WGPawn.ExtendedAttachments[0].m_szGroupName != "")
			WGPawn.ExtendedAttachmentNamedGroup( WGPawn.ExtendedAttachments[0].m_AttachedPart, WGPawn.ExtendedAttachments[0].m_szGroupName );
		else
			WGPawn.ExtendedAttachment( WGPawn.ExtendedAttachments[0].m_AttachedPart, WGPawn.ExtendedAttachments[0].m_nmSocketName, WGPawn.ExtendedAttachments[0].m_nmPartName );
	}
}

simulated function UpdateDefaultPrecachedMeshes()
{
	local Mesh	aMesh;

	aMesh = GetExtendedAttachment( 'Head', 'de_infantry_gunter' );
	if (aMesh != None)
	{
		Level.AddPrecacheMesh(aMesh);
	}
}

function SetCustomBodyMesh( Pawn newPawn )
{
	local WargamePawn   WGPawn;
	
	WGPawn = WargamePawn(newPawn);
//	if (Level.IsXbox())
//	{
		switch( Level.BaseUnitSkillLevel )
		{
			case SKILL_Novice:
				WGPawn.Mesh = Mesh(DynamicLoadObject("K_character_de.de_conscript_body", class'Mesh'));
				WGPawn.LinkMesh( WGPawn.Mesh );
				break;
			case SKILL_Intermediate:
				WGPawn.Mesh = Mesh(DynamicLoadObject("K_character_de.de_infantry_body", class'Mesh'));
				WGPawn.LinkMesh( WGPawn.Mesh );
				break;
			case SKILL_Advanced:
				WGPawn.Mesh = Mesh(DynamicLoadObject("K_character_de.de_para_body", class'Mesh'));
				WGPawn.LinkMesh( WGPawn.Mesh );
				break;
			case SKILL_Veteran:
				WGPawn.Mesh = Mesh(DynamicLoadObject("K_character_de.de_panzer_body", class'Mesh'));
				WGPawn.LinkMesh( WGPawn.Mesh );
				break;
			default:
				WGPawn.Mesh = Mesh(DynamicLoadObject("K_character_de.de_infantry_body", class'Mesh'));
				WGPawn.LinkMesh( WGPawn.Mesh );
				break;
		}
//	}
//	else
//	{
//		if (WGPawn.MyUnit != None)
//		{
//			switch( WGPawn.MyUnit.BaseSkillLevel )
//			{
//				case SKILL_Novice:
//					WGPawn.Mesh = Mesh(DynamicLoadObject("K_character_de.de_conscript_body", class'Mesh'));
//					WGPawn.LinkMesh( WGPawn.Mesh );
//					break;
//				case SKILL_Intermediate:
//					WGPawn.Mesh = Mesh(DynamicLoadObject("K_character_de.de_infantry_body", class'Mesh'));
//					WGPawn.LinkMesh( WGPawn.Mesh );
//					break;
//				case SKILL_Advanced:
//					WGPawn.Mesh = Mesh(DynamicLoadObject("K_character_de.de_para_body", class'Mesh'));
//					WGPawn.LinkMesh( WGPawn.Mesh );
//					break;
//				case SKILL_Veteran:
//					WGPawn.Mesh = Mesh(DynamicLoadObject("K_character_de.de_panzer_body", class'Mesh'));
//					WGPawn.LinkMesh( WGPawn.Mesh );
//					break;
//			}
//		}
//		else
//		{
//			WGPawn.Mesh = Mesh(DynamicLoadObject("K_character_de.de_conscript_body", class'Mesh'));
//			WGPawn.LinkMesh( WGPawn.Mesh );
//		}
//	}
}

defaultproperties
{
	defaultPrecachedHeadMeshName='de_inf_head_gunter'
//	Mesh=Mesh'K_character_de.de_conscript_body' //SJP: Temp fix until body groups work
	Mesh=None
	Texture=Texture'Engine.S_CharacterSpawnerGerman'
	PawnClass=class'gbxCharacters.InfantryGermany'
	ControllerClass=class'gbxAI.Mind'

	UnitToJoin=SquadGermanyDefault

	RequiredEquipment[0]="gbxInventory.WeapDEK98_"
	RequiredEquipment[1]="gbxInventory.UsableGermanHandGrenade"
	
	m_eCharacterType=CharacterSetup.EDECharacterTypes.DECharMikey;
}
// Created 2004-04-07 JWS
// give the multiplayer guys a way to have German or USA models
class CharacterSpawnerMP extends CharacterSpawner
	placeable;


var() ETeamIdentifier team;
var CharacterSetup.EMPCharacterTypes m_eCharacterType;

var class<CharacterSetup> CharacterSetupClass;

var byte CharacterSelector;
var int iNumCharacters;

function PostBeginPlay()
{
	Super.PostBeginPlay();

	if( Level.Game.GameReplicationInfo.GameType == GT_SKIRMISH )
		iNumCharacters=4;
	else
		iNumCharacters=3;

	CharacterSelector = default.CharacterSelector % iNumCharacters;

	default.CharacterSelector++;
	if (default.CharacterSelector == iNumCharacters)
	{
		default.CharacterSelector = 0;
	}
}

function LoadDefaults()
{
	switch (team)
	{
		case TEAM_US:
//			if (Level.Game.IsA('WargameSkirmish'))
//			{
				Mesh = Mesh(DynamicLoadObject("mp_k_character_us.us_para_mp_doe", class'Mesh'));
//			}
//			else
//			{
//				Mesh = Mesh(DynamicLoadObject("mp_k_character_us.us_para_mp", class'Mesh'));
//			}
			break;

		case TEAM_German:
//			if (Level.Game.IsA('WargameSkirmish'))
//			{
				Mesh = Mesh(DynamicLoadObject("mp_k_character_de.de_infantry_mp_gunter", class'Mesh'));
//			}
//			else
//			{
//				Mesh = Mesh(DynamicLoadObject("mp_k_character_de.de_infantry_mp", class'Mesh'));
//			}
			break;
	}
}

function Unit GetActualUnitToJoin()
{
	local Unit U;

	foreach DynamicActors( class'Unit', U, UnitToJoin ) break;

	return U;
}

function SetCharacterType(gbxPlayerController PC)
{
	local PlayerController aPlayer;
	local gbxPlayerController gbxPC;

	log( "CharacterSpawnerMP::SetCharacterType() - PC=" $ PC, 'RSC' );

	gbxPC=gbxPlayerController( Level.GetLocalPlayerController() );
	if( gbxPC == None || gbxPC == PC )
		gbxPC=PC;

	//log( "CharacterSpawnerMP::SetCharacterType() - gbxPC=" $ gbxPC, 'RSC' );
	//log( "CharacterSpawnerMP::SetCharacterType() - PC.bUseGermanAccent=" $ PC.bUseGermanAccent, 'RSC' );
	switch (team)
	{
		case TEAM_US:
			aPlayer = Level.PlayerControllerList;
			if ( ((aPlayer.GameReplicationInfo != None) && (aPlayer.GameReplicationInfo.GameType == GT_SKIRMISH)) || Level.Game.IsA('WargameSkirmish') )
			{
				switch (CharacterSelector)
				{
					case 0:
						//log( "CharacterSpawnerMP::SetCharacterType() - m_eCharacterType = SKCharUSA", 'RSC' );
						m_eCharacterType = SKCharUSA;
					break;

					case 1:
						//log( "CharacterSpawnerMP::SetCharacterType() - m_eCharacterType = SKCharUSB", 'RSC' );
						m_eCharacterType = SKCharUSB;
					break;

					case 2:
					default:
						//log( "CharacterSpawnerMP::SetCharacterType() - m_eCharacterType = SKCharUSC", 'RSC' );
						m_eCharacterType = SKCharUSC;
					break;
				}
			}
			else
			{
				switch (CharacterSelector)
				{
					case 0:
						//log( "CharacterSpawnerMP::SetCharacterType() - m_eCharacterType = MPCharUSA", 'RSC' );
						m_eCharacterType = MPCharUSA;
					break;

					case 1:
						//log( "CharacterSpawnerMP::SetCharacterType() - m_eCharacterType = MPCharUSB", 'RSC' );
						m_eCharacterType = MPCharUSB;
					break;

					case 2:
					default:
						//log( "CharacterSpawnerMP::SetCharacterType() - m_eCharacterType = MPCharUSC", 'RSC' );
						m_eCharacterType = MPCharUSC;
					break;
				}
			}
		break;

		case TEAM_German:
			if ( ((aPlayer.GameReplicationInfo != None) && (aPlayer.GameReplicationInfo.GameType == GT_SKIRMISH)) || Level.Game.IsA('WargameSkirmish') )
			{
				switch (CharacterSelector)
				{
				case 0:
					if( gbxPC.bUseGermanAccent )
					{
						//log( "CharacterSpawnerMP::SetCharacterType() - m_eCharacterType = SKCharEGA", 'RSC' );
						m_eCharacterType = SKCharDEA;	// removing German Accents
						//m_eCharacterType = SKCharEGA;
					}
					else
					{
						//log( "CharacterSpawnerMP::SetCharacterType() - m_eCharacterType = SKCharDEA", 'RSC' );
						m_eCharacterType = SKCharDEA;
					}
				break;

				case 1:
					if( gbxPC.bUseGermanAccent )
					{
						//log( "CharacterSpawnerMP::SetCharacterType() - m_eCharacterType = SKCharEGB", 'RSC' );
						m_eCharacterType = SKCharDEB;	// remving German Accents
						//m_eCharacterType = SKCharEGB;
					}
					else
					{
						//log( "CharacterSpawnerMP::SetCharacterType() - m_eCharacterType = SKCharDEB", 'RSC' );
						m_eCharacterType = SKCharDEB;
					}
				break;

				case 2:
					if( gbxPC.bUseGermanAccent )
					{
						//log( "CharacterSpawnerMP::SetCharacterType() - m_eCharacterType = SKCharEGC", 'RSC' );
						m_eCharacterType = SKCharDEC;	// removing German Accents	
						//m_eCharacterType = SKCharEGC;
					}
					else
					{
						//log( "CharacterSpawnerMP::SetCharacterType() - m_eCharacterType = SKCharDEC", 'RSC' );
						m_eCharacterType = SKCharDEC;
					}
				break;

				case 3:
				default:
					if( gbxPC.bUseGermanAccent )
					{
						//log( "CharacterSpawnerMP::SetCharacterType() - m_eCharacterType = SKCharEGD", 'RSC' );
						m_eCharacterType = SKCharDED;	// removing German Accents	
						//m_eCharacterType = SKCharEGD;
					}
					else
					{
						//log( "CharacterSpawnerMP::SetCharacterType() - m_eCharacterType = SKCharDED", 'RSC' );
						m_eCharacterType = SKCharDED;
					}
				break;
				}
			}
			else
			{
				switch (CharacterSelector)
				{
				case 0:
					if( gbxPC.bUseGermanAccent )
					{
						//log( "CharacterSpawnerMP::SetCharacterType() - m_eCharacterType = MPCharEGA", 'RSC' );
						m_eCharacterType = MPCharDEA;	// removing German Accents
						//m_eCharacterType = MPCharEGA;
					}
					else
					{
						//log( "CharacterSpawnerMP::SetCharacterType() - m_eCharacterType = MPCharDEA", 'RSC' );
						m_eCharacterType = MPCharDEA;
					}
				break;

				case 1:
					if( gbxPC.bUseGermanAccent )
					{
						//log( "CharacterSpawnerMP::SetCharacterType() - m_eCharacterType = MPCharEGB", 'RSC' );
						m_eCharacterType = MPCharDEB;	// removing German Accents
						//m_eCharacterType = MPCharEGB;
					}
					else
					{
						//log( "CharacterSpawnerMP::SetCharacterType() - m_eCharacterType = MPCharDEB", 'RSC' );
						m_eCharacterType = MPCharDEB;
					}
				break;

				case 2:
				default:
					if( gbxPC.bUseGermanAccent )
					{
						//log( "CharacterSpawnerMP::SetCharacterType() - m_eCharacterType = MPCharEGC", 'RSC' );
						m_eCharacterType = MPCharDEC;	// removing German Accents
						//m_eCharacterType = MPCharEGC;
					}
					else
					{
						//log( "CharacterSpawnerMP::SetCharacterType() - m_eCharacterType = MPCharDEC", 'RSC' );
						m_eCharacterType = MPCharDEC;
					}
				break;
				}
			}
		break;
	}
}

simulated function UpdateDefaultPrecachedMeshes()
{
	// Don't need heads anymore in MP...
}

function ConfigurePawn( Pawn newPawn )
{
	local WargamePawn   WGPawn;
	local gbxPlayerController PC;
	local Unit U;
	local bool bIsDemoBuild;

	WGPawn = WargamePawn(newPawn);

	LoadDefaults();
	
	WGPawn.PawnTeam = team;

	// be sure that the character ends up with the proper mesh on the client
	WGPawn.bNoRepMesh = false;
	WGPawn.LinkMesh(Mesh, true);

	// The pawn's character type depends on the player controller he is commanded by
	// this allows the pawn's voice type to change languages according to the player's preference
	U = GetActualUnitToJoin();
	PC = U.GetControllingPlayerController();
	SetCharacterType(PC);

	WGPawn.SetCharacterType(m_eCharacterType);
	WGPawn.CharacterSetupClass = CharacterSetupClass;

	if ( team == TEAM_US )
		WGPawn.CreateTeamLogoShadow("t_interface_mb.shadow_us_star");
	else if ( team == TEAM_German )
		WGPawn.CreateTeamLogoShadow("t_interface_mb.shadow_de_cross");

	Super.ConfigurePawn( newPawn );

	WGPawn.bPawnBlinks = false;

	WGPawn.Controller.PlayerReplicationInfo.Unit = WGPawn.MyUnit.GetUnitReplicationInfo();
	
	bIsDemoBuild = Level.IsDemoBuild();
	//log( "CharacterSpawnerMP::ConfigurePawn() - bIsDemoBuild=" $ bIsDemoBuild, 'RSC' );
	WGPawn.SetVoiceType( WGPawn.GetCharacterVoiceType( bIsDemoBuild ) );

	if (Level.Game.IsA('WargameSkirmish'))
	{
		WGPawn.MyUnit.MyUnitController.ResetSuppressionLevelAnalog();  //NAC: reset the suppression level of this pawn's unit
	}
	
	if (nSpawnHealth > 0)
	{
		WGPawn.Health = nSpawnHealth;
	}
	
	// This is used to preload the battle dialogue so QA can get a proper list for the preload files.
	//log( "CharacterSpawnerMP::ConfigurePawn() - Level.bPreloadBattleDialogue=" $ Level.bPreloadBattleDialogue, 'RSC' );
	if( WGPawn.Voicetype != None )
	{
		WGPawn.Voicetype.SortSpeeches();
		if( Level.bPreloadBattleDialogue && self.bPreloadBattleDialogue )
	{
		//log( "CharacterSpawnerMP::ConfigurePawn() - Preloading Battle Dialogue for Voicetype " $ WGPawn.VoiceType, 'RSC' );
		WGPawn.VoiceType.Preload();
	}
	}
	
	Log(self $ " Configuring Pawn " $ WGPawn $ " on Team " $ WGPawn.PawnTeam $ " with voice " $ CharacterSelector $ " character type " $ WGPawn.m_eCharacterType, 'JWS');
}

defaultproperties
{
	PawnClass=class'gbxCharacters.InfantryUSA'
	ControllerClass=class'gbxAI.Mind'
	CharacterSetupClass=class'CharacterSetupMP'
	Mesh=None

	RemoteRole=ROLE_None

	iNumCharacters=3
}class CharacterSpawnerStaticGermany extends CharacterSpawnerGermany
	placeable;

#exec OBJ LOAD FILE=..\StaticMesh\s_military_de.usx

var (CharController) Name  MyNavPointName;

simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();
	
	SetStaticMesh(StaticMesh(DynamicLoadObject("s_military_de.static_pawn.static_pawn_de_standing_rifle", class'StaticMesh')));
}

function ConfigurePawn( Pawn newPawn )
{
	local gbxPawn gbxP;
	local ActorLite AL;
	local Name NodeTag;

	Super.ConfigurePawn( newPawn );

	if ( newPawn.IsA( 'gbxPawn' ) && MyNavPointName != '' )
	{
		gbxP = gbxPawn( newPawn );

		for (AL=Level.NavigationPointList; AL!=None; AL=AL.nextNavigationPoint)
		{
			if ( AL.bIsNavigationPointLite )
				NodeTag = NavigationPointLite( AL ).Tag;
			else
				NodeTag = NavigationPoint( AL ).Tag;

			if ( NodeTag == MyNavPointName )
			{
				gbxP.ClaimNavPoint( AL );
				break;
			}
		}
	}
}

defaultproperties
{
//	StaticMesh=StaticMesh's_military_de.static_pawn.static_pawn_de_standing_rifle'
	ControllerClass=class'gbxAI.StaticMind'
}
class CharacterSpawnerStaticUSA extends CharacterSpawnerUSA
	placeable;

#exec OBJ LOAD FILE=..\StaticMesh\s_military_us.usx

simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();
	
	SetStaticMesh(StaticMesh(DynamicLoadObject("s_military_us.static_pawn.static_pawn_us_standing_rifle", class'StaticMesh')));
}

defaultproperties
{
//	StaticMesh=StaticMesh's_military_us.static_pawn.static_pawn_us_standing_rifle'
	ControllerClass=class'gbxAI.StaticMind'
}
class CharacterSpawnerUSA extends CharacterSpawner
	placeable;

var (CharPawn)	bool	m_bDisableFacialExpressions;
var (CharPawn)  CharacterSetup.EUSCharacterTypes	m_eCharacterType;
var() bool bFriendlyExplosiveDamage; // If true, friendly grenades will damage this pawn

function SetDefaultExtendedAttachments( WargamePawn WGPawn)
{
	local ExtendedAttachmentInfo	anEAInfo;
	local int						j;

	// GBX:PAD: If a StaticMesh is set, then this guy is a StaticPawn for now, so don't do the extended attachments just yet
	if (StaticMesh != None)
		return;

	if (WGPawn.GetCharacterHead() != '')
	{
		anEAInfo = new( Level.Outer ) class'ExtendedAttachmentInfo';
		anEAInfo.m_nmSocketName = 'Head';
		anEAInfo.m_nmPartName = WGPawn.GetCharacterHead();

		WGPawn.ExtendedAttachments[0] = anEAInfo;
		WGPawn.ExtendedAttachments[0].m_AttachedPart = Spawn( class'AttachedPart', WGPawn );
		if (ExtendedSkins.Length > 0)
		{
			for (j = 0; j < ExtendedSkins.Length; j++)
			{
				if (ExtendedSkins[j] != None)
				{
					WGPawn.ExtendedAttachments[0].m_AttachedPart.Skins[j] = ExtendedSkins[j];
				}
			}
		}
		if (WGPawn.ExtendedAttachments[0].m_szGroupName != "")
			WGPawn.ExtendedAttachmentNamedGroup( WGPawn.ExtendedAttachments[0].m_AttachedPart, WGPawn.ExtendedAttachments[0].m_szGroupName );
		else
			WGPawn.ExtendedAttachment( WGPawn.ExtendedAttachments[0].m_AttachedPart, WGPawn.ExtendedAttachments[0].m_nmSocketName, WGPawn.ExtendedAttachments[0].m_nmPartName );
	}
}

simulated function UpdateDefaultPrecachedMeshes()
{
	local Mesh	aMesh;

	aMesh = GetExtendedAttachment( 'Head', 'us_para_head_allen' );
	if (aMesh != None)
	{
		Level.AddPrecacheMesh(aMesh);
	}
}

function Pawn GetRespawnedPawn()
{
	local	Pawn	aPawn;
	local IGbxPawnList PawnList;

	PawnList = Level.GetPawnList();
	aPawn = gbxPawnList(PawnList).GetAmericanSpawn();
	return aPawn;
}

function Pawn SpawnPawn( bool bSpawnNow )
{
	if (PawnClass.default.Mesh == None)
	{
		PawnClass.default.Mesh = Mesh(DynamicLoadObject("K_character_us.us_para_body", class'Mesh'));
	}

	return Super.SpawnPawn(bSpawnNow);
}

function ConfigurePawn( Pawn newPawn )
{
	local WargamePawn   WGPawn;
	local bool bIsDemoBuild;

	WGPawn = WargamePawn(newPawn);
	
	WGPawn.SetCharacterType( m_eCharacterType );
	WGPawn.CharacterSetupClass = class'CharacterSetupUSA';
	
	WGPawn.CreateTeamLogoShadow("t_interface_mb.shadow_us_star");

	WGPawn.bFriendlyExplosiveDamage = bFriendlyExplosiveDamage;

	Super.ConfigurePawn( newPawn );

	if (InfantryUSA( newPawn ) != None)
	{
		InfantryUSA( newPawn ).bDisableFacialExpressions = m_bDisableFacialExpressions;
	}
	
	bIsDemoBuild = Level.IsDemoBuild();
	//log( "CharacterSpawnerUSA::ConfigurePawn() - bIsDemoBuild=" $ bIsDemoBuild, 'RSC' );
	WGPawn.SetVoiceType( WGPawn.GetCharacterVoiceType( bIsDemoBuild ) );
	if (WGPawn.m_flLegScale == 1.0f)
	{
		WGPawn.m_flLegScale = WGPawn.GetCharacterScale();
		if (WGPawn.m_flLegScale != 1.0f)
		{
			WGPawn.ChangeCharacterHeight();
		}
	}
	WGPawn.m_flRank = WGPawn.GetCharacterRank();

	// This is used to preload the battle dialogue so QA can get a proper list for the preload files.
	//log( "CharacterSpawnerUSA::ConfigurePawn() - Level.bPreloadBattleDialogue=" $ Level.bPreloadBattleDialogue, 'RSC' );
	if( WGPawn.Voicetype != None )
	{
		WGPawn.Voicetype.SortSpeeches();
		if( Level.bPreloadBattleDialogue && self.bPreloadBattleDialogue )
	{
		//log( "CharacterSpawnerUSA::ConfigurePawn() - Preloading Battle Dialogue for Voicetype " $ WGPawn.VoiceType, 'RSC' );
		WGPawn.VoiceType.Preload();
	}
}
}

defaultproperties
{
	defaultPrecachedHeadMeshName='us_paratrooper_jasko'
	//Mesh=Mesh'K_character_us.us_para_body' //SJP: Temp fix until body groups work
	Mesh=None
	PawnClass=class'gbxCharacters.InfantryUSA'
	Texture=Texture'Engine.S_CharacterSpawnerUS'
	ControllerClass=class'gbxAI.Mind'

	UnitToJoin=SquadUSADefault

	RequiredEquipment[0]="gbxInventory.WeapUSM1_"
	RequiredEquipment[1]="gbxInventory.UsableUSHandGrenade"
	
	m_eCharacterType=CharacterSetup.EUSCharacterTypes.USCharAllen;
	bFriendlyExplosiveDamage=false
}

class HalftrackSpawner extends Actor
	hidecategories(Collision,Lighting,LightColor,Karma,Force)
	placeable;


var() bool bWaitForTrigger;			// If false, Halftrack is spawned when level loaded. Otherwise, the Halftrack is spawned when this actor is triggered.
var() bool bDestroyAfterSpawn;		// If true, this actor self-destructs after spawning its Halftrack. Otherwise, it stays around and can spawn additional HAlftracks when triggered again.

var() bool		bPlayerDrivable;
var() name		HalftrackPawnTag;
var() name		HalftrackControllerTag;

var() name		TriggerOnDeath;

var() class<AIController>	ControllerClass;

var() name		GunnerTag;
var() bool		bGunnerDismountsWhenFlanked;
var() name		PassengerOneTag;
var() name		PassengerTwoTag;

var() bool		bIgnoreSuppression;
var() bool		bUseShotProtection;
var() float		Zone1OuterRadius,				// Distances defining three 'kill zones' for the turret.
				Zone2OuterRadius,				// (Zone 1 == closest to turret; Zone 3 == farthest).
				Zone3OuterRadius;
var() float		NoShotProtectionDist;			// Distance outside of which attackers cannot hit the gunner.
var() float		ShotProtectionCosTheta;
var() float		EnemyTooCloseDist;


function PostLinearize()
{
	Super.PostLinearize();

	if( !bWaitForTrigger )
	{
		SpawnHalftrack();
	}
}

function Trigger( actor Other, Pawn EventInstigator )
{
	Super.Trigger( Other, EventInstigator );
	SpawnHalftrack();
}

function SpawnHalftrack()
{
	local Halftrack newHalftrack;
	local int			nHealth;

	nHealth = -1;

	// This is very slow, and has no meaning for MP anyways. So only do this stuff in SP games. 2004-12-02 JWS
	if (Level.NetMode == NM_Standalone)
	{
		if (Level.MissionManager.GetCheckpointPawnHealth( HalftrackPawnTag, nHealth))
		{
			if (nHealth <= 0)
			{
				Log( "Vehicle "$HalftrackPawnTag$" not created because it is dead according to the checkpoint." );
				return;
			}
		}
	}
	
	newHalftrack = Spawn( class'Halftrack',,, Location, Rotation );

	if( newHalftrack == None )
	{
		Log( "WARNING: " $ class $ ".SpawnHalftrack() unable to spawn Halftrack." );
	}
	else
	{
		ConfigureHalftrack( newHalftrack );

		// give derived class a chance to be returned to...
		if (bDestroyAfterSpawn)
			SetTimer(0.1, false);
	}

	if (nHealth > 0)
	{
		newHalftrack.Health = nHealth;
		if (nHealth < newHalftrack.Default.Health)
		{
			newHalftrack.RespawnSmoke();
		}
	}
		
	log(self$".SpawnHalftrack() - "$HalftrackPawnTag$" - "$newHalftrack$" - "$newHalftrack.Health$" - "$nHealth);
	
	return;
}

function Timer()
{
	Destroy();
}

function ConfigureHalftrack( Halftrack newHalftrack )
{
	local AIController C;

	newHalftrack.GunnerTag = GunnerTag;
	newHalftrack.bGunnerDismountsWhenFlanked = bGunnerDismountsWhenFlanked;
	newHalftrack.PassengerOneTag = PassengerOneTag;
	newHalftrack.PassengerTwoTag = PassengerTwoTag;

	newHalftrack.bIgnoreSuppression = bIgnoreSuppression;
	newHalftrack.bUseShotProtection = bUseShotProtection;
	newHalftrack.Zone1OuterRadius = Zone1OuterRadius;
	newHalftrack.Zone2OuterRadius = Zone2OuterRadius;
	newHalftrack.Zone3OuterRadius = Zone3OuterRadius;
	newHalftrack.NoShotProtectionDist = NoShotProtectionDist;
	newHalftrack.ShotProtectionCosTheta = ShotProtectionCosTheta;
	newHalftrack.EnemyTooCloseDist = EnemyTooCloseDist;

	if (bPlayerDrivable)
	{
		ControllerClass = None;  // no controller for player drivable vehicles
		newHalftrack.bNonHumanControl = false;
	}
	else if (ControllerClass == None)
	{
		ControllerClass = class'AIController';
	}

	if ( ControllerClass != None )
	{
		C = Spawn( ControllerClass );

		if ( C == None )
		{
			Log( "WARNING: " $ class $ ".ConfigureHalftrack() unable to spawn controller of class '" $ ControllerClass $ "'." );
		}
		else
		{
			C.Possess( newHalftrack );
			ConfigureController( C );

			newHalftrack.bNonHumanControl = true;

			if( HalftrackPawnTag != 'None' )
			{
				newHalftrack.Tag = HalftrackPawnTag;
			}

			newHalftrack.TriggerOnDeath = TriggerOnDeath;
		}
	}
}

function ConfigureController( AIController C )
{
	if( HalftrackControllerTag != 'None' )
	{
		C.Tag = HalftrackControllerTag;
	}
}

defaultproperties
{
	DrawType=DT_Mesh
	EditorMeshName="k_vehicle_de.de_halftrack"

	bHidden=true
	bStatic=false
	bDirectional=true
	CollisionHeight=128.0
	CollisionRadius=200.0

	bWaitForTrigger=false
	bDestroyAfterSpawn=true

	bPlayerDrivable=false

	bGunnerDismountsWhenFlanked=false

	bIgnoreSuppression=true;
	bUseShotProtection=true;
	Zone1OuterRadius=2000.0
	Zone2OuterRadius=2500.0
	Zone3OuterRadius=3000.0
	NoShotProtectionDist=1000.0
	ShotProtectionCosTheta=0.7071
	EnemyTooCloseDist=1000.0
}
class ScarecrowDummy extends Infantry
	placeable;

//#exec OBJ LOAD FILE=..\animation\K_prop.ukx


var name			IdleAnim;
var array<name>		FlinchAnims;
var name			DeathAnim;


function PreBeginPlay()
{
	super.PreBeginPlay();

	Mesh = Mesh( DynamicLoadObject( "k_prop.scarecrow", class'Mesh' ) );
}

function BeginPlay()
{
	m_fDispositionAnimPlaying = true;  // don't play the movement animations

	AddAnimToQueue(IdleAnim, QUEUE_IDLE_PRIORITY, true, true, false, 1.0, 0.15);  // looping animation
}

function PlayFlinch()
{
	local int index;

	index = Rand(FlinchAnims.Length);

	AddAnimToQueue(FlinchAnims[index], QUEUE_FLINCH_PRIORITY, false, false, false, 1.0, 0.15);
}

function TakeDamage(int Damage, Pawn instigatedBy, Vector Hitlocation, Vector Momentum, class<DamageType> DamageType, optional name HitBoxName)
{
	local vector HitNormal;
	local rotator DeathRot;
	local vector v1, v2;

	if (Health <= 0)
		return;

	v1 = HitLocation;
	v2 = Location;
	v2.Z = HitLocation.Z;

	HitNormal = Normal(v1 - v2);

	spawn(class'ImpactEmitterHay',,, Hitlocation+HitNormal, Rotator(HitNormal));

	if ((Controller != None) && (!Controller.bGodMode))
	{
		if (DamageType == class'DamageUSGunButtMelee')  // can only be killed by melee damage
			Health=0;
	}

	if (Health > 0)
	{
		PlayFlinch();
	}
	else
	{
		Mind(Controller).SetFacingPolicy(FACE_NoChange);

		TriggerEvent(TriggerOnDeath, Controller, self);

//		HitNormal = Normal(Momentum);
		DeathRot = Rotator(HitNormal);
		DeathRot.Pitch = 0;
//		DeathRot.Yaw = (DeathRot.Yaw + 32768) & 65535;
		DeathRot.Yaw = (DeathRot.Yaw + 16384) & 65535;
		DeathRot.Roll = 0;

		SetRotation(DeathRot);
		SetCollision(false, false, false);

		FlushAnimQueueChannel( 0, false, true );  // remove the looping idle animation from queue
		AddAnimToQueue(DeathAnim, QUEUE_DEATH_PRIORITY, true, false, false, 1.0, 0.15);

		if (MyUnit != None)
			MyUnit.RemoveMember( self );

		if (Controller != None)
		{
			Controller.Destroy();
			Controller = None;
		}
	}
}

defaultproperties
{
	Mesh=None
	ControllerClass=class'gbxAI.DumbMind'

	Health=100
	bPawnBlinks=false
	bPawnLooksAtTargets=false

	PawnAnimInfoClass=None

	myInspectorClass=class'gbxCharacters.gbxInspectorInfantryGermany'

	IdleAnim="idle"
	FlinchAnims(0)="flinch_a"
	FlinchAnims(1)="flinch_b"
	FlinchAnims(2)="flinch_c"
	DeathAnim="hit"
	PawnTeam=TEAM_None
}
class ScarecrowDummySpawner extends CharacterSpawner
	placeable;



defaultproperties
{
	Texture=Texture'Engine.S_CharacterSpawnerGerman'
	PawnClass=class'gbxScripted.ScarecrowDummy'
	ControllerClass=class'gbxAI.DumbMind'

	UnitToJoin=None
}
//=============================================================================
// StochasticTrigger.
//=============================================================================
class StochasticTrigger extends Triggers;



var() name Events[10];			// What events to call (must be at least one event)
var() float triggerProbability; // The chance of the event occuring effect playing
var() float minReCheckTime;		// Try to re-trigger the event after (min amount)
var() float maxReCheckTime;		// Try to re-trigger the event after (max amount)

var bool bIsActive;				// This trigger dispacher is activated/deactivated
var float reTriggerTime;
var int numEvents;				// The number of events available
var actor triggerInstigator;	// Who enabled this actor to dispach?

function BeginPlay()
{
	local int i;

	// Calculate how many events the user specified
	numEvents=10;
	for (i=0; i<10; i++)
	{
		if (Events[i] == '')
		{
			numEvents=i;
			break;
		}
	}

	reTriggerTime = (maxReCheckTime-minReCheckTime)*FRand() + minReCheckTime;
	SetTimer(reTriggerTime, false);
}

auto state() TriggeredActive
{
	function BeginState()
	{
		bIsActive = false; // initially the trigger dispacher is inactive
	}

	function Trigger( actor Other, pawn EventInstigator )
	{
		Log( class $ "<" $ GetStateName() $ ">.Trigger( " $ Other $ ", " $ EventInstigator $ " )" );

		// StochasticTrigger is active
		if ( triggerInstigator == None )
			triggerInstigator = EventInstigator;
		else
			triggerInstigator = Other;
		Instigator = EventInstigator;
		bIsActive = !bIsActive;
	}
}

state() AlwaysActive
{
Begin:
	bIsActive = true;
}

function Timer()
{
	local int i;
	local actor A;

	if( numEvents > 0 && FRand() <= triggerProbability && bIsActive == true)
	{
		// Trigger an event
		// Which event should be initiated?
		i = Rand(numEvents);

		// Broadcast the Trigger message to all matching actors.
		if( Events[i] != '' )
		{
			foreach AllActors( class 'Actor', A, Events[i] )
			{
				A.Trigger( triggerInstigator, Instigator );
			}
		}
	}

	reTriggerTime = (maxReCheckTime-minReCheckTime)*FRand() + minReCheckTime;
	SetTimer(reTriggerTime, false);
}


defaultproperties
{
	Texture=Texture'Engine.S_TriggerRandom'
	triggerProbability=1.0
	minReCheckTime=0.1
	maxReCheckTime=0.1
}
class TankSpawner extends Actor
	hidecategories(Collision,Lighting,LightColor,Karma,Force)
	placeable
	native;

cpptext
{
	void PostEditChange();
}

var() bool bWaitForTrigger;			// If false, Tank is spawned when level loaded. Otherwise, the Tank is spawned when this actor is triggered.
var() bool bDestroyAfterSpawn;		// If true, this actor self-destructs after spawning its Tank. Otherwise, it stays around and can spawn additional Tanks when triggered again.

var() bool		bPlayerDrivable;
var() ETankType TankType;
var() name		TankPawnTag;
var() name		TankCommanderTag;
var() name		TankControllerTag;
var(AI) name 	AIScriptTag;

var() name		UnitToJoin;
var() bool		bLeader;
var() name		TriggerOnDeath;
var() bool		bSpawnTankCommander;
var() bool		bTankCommaderInvulnerable;  // tank commander can't be shot
var() bool		bDisablePlayerUseableTriggers;
var() bool		bGermanTanksDontStopAtOneHealth;

// allow level designers to override the tank gun controller values for these...
var() bool		TargetForgetTimeOverride;
var() float		TargetForgetTime;

var() class<AIController>	ControllerClass;

var() CharacterSetup.EUSCharacterTypes	CommanderUSCharType;
var() CharacterSetup.EDECharacterTypes	CommanderDECharType;

function PostLinearize()
{
	Super.PostLinearize();

	if( !bWaitForTrigger )
	{
		SpawnTank();
	}
}

function Trigger( actor Other, Pawn EventInstigator )
{
	Super.Trigger( Other, EventInstigator );
	SpawnTank();
}

function SpawnTank()
{
	local Tank newTank;
	local class<Tank> TankClass;
	local int			nHealth;
	local bool bBroken;
	local Pawn aPawn;

	// first verify that TankPawnTag and TankCommaderTag are unique (for checkpoint load/save health stuff)...
	if (TankPawnTag == '')
	{
		Log("*** ERROR ***: In TankSpawner = " $ name $ " TankPawnTag is 'None'.  This is NOT ALLOWED.  Give the TankPawn a unique tag!");
		// BETA-FIXME (jlbzz) return;  // Don't spawn the tank if things aren't configured right
	}

	if (bSpawnTankCommander)
	{
		if (TankCommanderTag == '')
		{
			Log("*** ERROR ***: In TankSpawner = " $ name $ " TankCommanderTag is 'None'.  This is NOT ALLOWED.  Give the TankCommander a unique tag!");
			// BETA-FIXME (jlbzz) return;  // Don't spawn the tank if things aren't configured right
		}
	}

	bBroken = false;
	foreach DynamicActors( class'Pawn', aPawn )
	{
		if (aPawn.Tag == TankPawnTag)
		{
			Log("*** ERROR ***: In TankSpawner = " $ name $ " TankPawnTag is NOT UNIQUE (has same tag as " $ aPawn.name $ ").  Give the TankPawn a unique tag!");
			// BETA-FIXME (jlbzz) bBroken = true;  // things aren't set up right
		}

		if (bSpawnTankCommander)
		{
			if (aPawn.Tag == TankCommanderTag)
			{
				Log("*** ERROR ***: In TankSpawner = " $ name $ " TankCommanderTag is NOT UNIQUE (has same tag as " $ aPawn.name $ ").  Give the TankCommanderTag a unique tag!");
				// BETA-FIXME (jlbzz) bBroken = true;  // things aren't set up right
			}
		}
	}

	if (bBroken)
		return;  // Don't spawn the tank if things aren't configured right

	nHealth = -1;

	// This is very slow, and has no meaning for MP anyways. So only do this stuff in SP games. 2004-12-02 JWS
	if (Level.NetMode == NM_Standalone)
	{
		if (Level.MissionManager.GetCheckpointPawnHealth( TankPawnTag, nHealth))
		{
			if (nHealth <= 0)
			{
				Log( "Vehicle "$TankPawnTag$" not created because it is dead according to the checkpoint." );
				return;
			}
		}
	}
	
	switch (TankType)
	{
		case US_StuartTank:
			TankClass = class'TankStuart';
			break;
		case German_PanzerIV:
			TankClass = class'TankPanzerIV';
			break;
		case US_ShermanTank:
			TankClass = class'TankSherman';
			break;
		case German_Stug:
			TankClass = class'TankStug';
			break;
		case German_StugLongGun:
			TankClass = class'TankStugLongGun';
			break;
		case US_M10:
			TankClass = class'TankM10_';
			break;
		case German_MarderIII:
			TankClass = class'TankMarder';
			break;
		case German_PanzerIVLongGun:
			TankClass = class'TankPanzerIVLongGun';
			break;
	}

	newTank = Spawn( TankClass,,, Location, Rotation );

	if( newTank == None )
	{
		Log( "WARNING: " $ class $ ".SpawnTank() unable to spawn Tank of class '" $ TankClass $ "'." );
	}
	else
	{
		ConfigureTank( newTank );

		// give derived class a chance to be returned to...
		if (bDestroyAfterSpawn)
			SetTimer(0.1, false);
	}

	if (nHealth > 0)
	{
		newTank.Health = nHealth;
		if (nHealth < newTank.Default.Health)
		{
			newTank.RespawnSmoke();
		}
	}
		
	log(self$".SpawnTank() - "$TankPawnTag$" - "$newTank$" - "$newTank.Health$" - "$nHealth);
	
	return;
}

function Timer()
{
	Destroy();
}

function ConfigureTank( Tank newTank )
{
	local AIScript A;
	local AIController C;

	newTank.bSpawnCommander = bSpawnTankCommander;
	newTank.bTankCommaderInvulnerable = bTankCommaderInvulnerable;
	newTank.bDisablePlayerUseableTriggers = bDisablePlayerUseableTriggers;

	newTank.CommanderUSCharType = CommanderUSCharType;
	newTank.CommanderDECharType = CommanderDECharType;

	newTank.TankType = TankType;
	
	if( newTank.GetCharacterPortrait() != "" )
	{
		newTank.Portrait = Texture( DynamicLoadObject( newTank.GetCharacterPortrait(), class'Texture' ));
	}

	if( newTank.PawnTeam == TEAM_US )
	{
		newTank.myInspectorClass=class'gbxVehicles.gbxInspectorTankUS';
	}
	else if( newTank.PawnTeam == TEAM_German )
	{
		newTank.myInspectorClass=class'gbxVehicles.gbxInspectorTankGermany';
	}

	newTank.CharacterName = newtank.GetCharacterName();

	if (bPlayerDrivable)
	{
		ControllerClass = None;  // no controller for player drivable tanks
		newTank.bNonHumanControl = false;
	}
	else if (ControllerClass == None)
	{
		switch (TankType)
		{
			case US_StuartTank:
				ControllerClass = class'TankStuartController';
				break;
			case German_PanzerIV:
				ControllerClass = class'TankPanzerIVController';
				break;
			case US_ShermanTank:
				ControllerClass = class'TankShermanController';
				break;
			case German_Stug:
				ControllerClass = class'TankStugController';
				break;
			case German_StugLongGun:
				ControllerClass = class'TankStugController';
				break;
			case US_M10:
				ControllerClass = class'TankM10Controller';
				break;
			case German_MarderIII:
				ControllerClass = class'TankMarderController';
				break;
			case German_PanzerIVLongGun:
				ControllerClass = class'TankPanzerIVController';
				break;
		}
	}

	if ( ControllerClass != None )
	{
		C = Spawn( ControllerClass );

		if ( C == None )
		{
			Log( "WARNING: " $ class $ ".ConfigureTank() unable to spawn controller of class '" $ ControllerClass $ "'." );
		}
		else
		{
			ConfigureController( C );

			C.Possess( newTank );

			newTank.bNonHumanControl = true;

			newTank.Tag = TankPawnTag;
			newTank.TankCommanderTag = TankCommanderTag;
			newTank.bGermanTanksDontStopAtOneHealth = bGermanTanksDontStopAtOneHealth;

			if (UnitToJoin != '')
			{
				newTank.JoinUnit( UnitToJoin, bLeader );
			}
		}
	}

	newTank.TriggerOnDeath = TriggerOnDeath;

	if (Mesh != None)
	{
		newTank.Mesh = Mesh;
	}

	if ( AIScriptTag != '' )
	{
		newTank.AIScriptTag = AIScriptTag;
		ForEach AllActors(class'AIScript',A,newTank.AIScriptTag)
			break;
		// let the AIScript spawn and init my controller
		if ( A != None )
		{
			A.SpawnControllerFor(newTank);
			if ( newTank.Controller != None )
				return;
		}
	}
}

function ConfigureController( AIController C )
{
	if( TankControllerTag != 'None' )
	{
		C.Tag = TankControllerTag;
	}

	if ((TankController(C) != None) && (TargetForgetTimeOverride))
	{
		TankController(C).bTargetForgetTimeOverride = TargetForgetTimeOverride;
		TankController(C).TargetForgetTime = TargetForgetTime;
	}
}

defaultproperties
{
	Texture=Texture'Engine.S_VehicleSpawner'

	bHidden=true
	bStatic=false
	bDirectional=true
	CollisionHeight=90

	bWaitForTrigger=false
	bDestroyAfterSpawn=true

	bPlayerDrivable=false
	TankType=US_StuartTank

	UnitToJoin=TankSquadUSADefault
	bLeader=false
	bSpawnTankCommander=true
	bTankCommaderInvulnerable=false
	bDisablePlayerUseableTriggers=false

	CommanderUSCharType=USCharTankCommanderA
	CommanderDECharType=DECharTankCommander

	TargetForgetTimeOverride=false
	TargetForgetTime=10.0

	bGermanTanksDontStopAtOneHealth=false
}
class ThreatDummy extends InfantryGermany
	placeable;



function bool InGodMode()
{
	return true;
}

defaultproperties
{
	ControllerClass=class'gbxAI.DumbMind'
}
// GEARBOX 2004-05-28 JWS created
//
// Used to do MP level testing
class ThreatDummyMP extends InfantryUSA
	placeable;

function bool InGodMode()
{
	return true;
}

defaultproperties
{
	ControllerClass=class'gbxAI.DumbMind'
}
// GEARBOX 2004-05-28 JWS created
//
// Used to do MP level testing
class ThreatDummyMPGermanSpawner extends CharacterSpawnerMP
	placeable;

defaultproperties
{
	PawnClass=class'gbxScripted.ThreatDummyMP'
	ControllerClass=class'gbxAI.DumbMind'

	UnitToJoin=ThreatDummyGermanUnit
	Team=TEAM_German
}
// GEARBOX 2004-05-28 JWS created
//
// Used to do MP level testing
class ThreatDummyMPUSSpawner extends CharacterSpawnerMP
	placeable;

defaultproperties
{
	PawnClass=class'gbxScripted.ThreatDummyMP'
	ControllerClass=class'gbxAI.DumbMind'

	UnitToJoin=ThreatDummyUSUnit
	Team=TEAM_US
}
class ThreatDummySpawner extends CharacterSpawner
	placeable;



defaultproperties
{
	Texture=Texture'Engine.S_CharacterSpawnerGerman'
	PawnClass=class'gbxScripted.ThreatDummy'
	ControllerClass=class'gbxAI.DumbMind'

	UnitToJoin=None

	//Job=Job_None

	RequiredEquipment[0]="gbxInventory.WeapDEK98_"
}
class TriggeredScript extends Actor
	placeable
	native;


var float	flBreakTime;
var float	flBreakStartTime;

// BOOLS
var() bool bTriggeredStateEnabled;

var bool Succeeded;
var bool Failed;

var bool bEnablePlayerBreak;  // allows players to interrupt script code during execution

// actions bound to keys that you can block and/or wait for being pressed...
// NOTE: These MUST be exactly the same as in Engine/Classes/PlayerController.uc
const KEY_ACTION_JUMP 			= 0x00000001;  // jump
const KEY_ACTION_MELEE 			= 0x00000002;  // melee attack
const KEY_ACTION_USE 			= 0x00000004;  // Use/activate
const KEY_ACTION_THROW_GRENADE	= 0x00000008;  // throw grenade
const KEY_ACTION_CYCLE_WEAPON 	= 0x00000010;  // throw grenade
const KEY_ACTION_TEAMSELECT 	= 0x00000020;  // toggle between fire and assault team
const KEY_ACTION_ORDER 			= 0x00000040;  // command mode
const KEY_ACTION_FIRE 			= 0x00000080;  // weapon fire
const KEY_ACTION_FALL_OUT 		= 0x00000100;  // issue an fall_out command
const KEY_ACTION_FALL_IN 		= 0x00000200;  // issue an fall_in command
const KEY_ACTION_FIRE_TEAM		= 0x00000400;  // select fire team
const KEY_ACTION_ASSAULT_TEAM	= 0x00000800;  // select the assault team
const KEY_ACTION_SHOW_MENU		= 0x00001000;  // show the UI menu (start button on Xbox controller)
const KEY_ACTION_SA_VIEW 		= 0x00002000;  // enter/exit situational awareness view
const KEY_ACTION_CROUCH 		= 0x00004000;  // crouch
const KEY_ACTION_ZOOM 			= 0x00008000;  // weapon zoom
const KEY_ACTION_MOVE			= 0x00010000;  // left thumbstick on Xbox, W,A,S,D keys on PC
const KEY_ACTION_LOOK			= 0x00020000;  // right thumbstick on Xbox, mouse movement on PC
const KEY_ACTION_RELOAD 		= 0x00040000;  // weapon reload
const KEY_ACTION_SA_LEFT 		= 0x00080000;  // select previous SA view item
const KEY_ACTION_SA_RIGHT 		= 0x00100000;  // select next SA view item
const KEY_ACTION_CONTINUE 		= 0x00200000;  // "continue" key (always bound to the same key/button, SPACE on PC, 'A' on Xbox)
const KEY_ACTION_CANCEL 		= 0x00400000;  // "cancel" key (always bound to the same button)
const KEY_ACTION_SA_UP			= 0x00800000;  // select SA view objective
const KEY_ACTION_SA_DOWN 		= 0x01000000;  // select SA view player

var float fWaitForActionKeyTime;
var int LatentActionKeyArray[32];  // allow room for all KEY_ACTION_ bits plus a few more for complex stuff (KEY_ACTION_MOVE, etc.)

// these only apply to the Xbox controller (on the PC they do nothing)...
// NOTE: These MUST be exactly the same as in Engine/Classes/PlayerController.uc
const KEY_BUTTON_A 						= 0x00000001;
const KEY_BUTTON_B						= 0x00000002;
const KEY_BUTTON_X						= 0x00000004;
const KEY_BUTTON_Y						= 0x00000008;
const KEY_BUTTON_BLACK					= 0x00000010;
const KEY_BUTTON_WHITE					= 0x00000020;
const KEY_BUTTON_L_TRIGGER				= 0x00000040;
const KEY_BUTTON_R_TRIGGER				= 0x00000080;
const KEY_BUTTON_DPAD_UP				= 0x00000100;
const KEY_BUTTON_DPAD_DOWN				= 0x00000200;
const KEY_BUTTON_DPAD_LEFT				= 0x00000400;
const KEY_BUTTON_DPAD_RIGHT				= 0x00000800;
const KEY_BUTTON_START					= 0x00001000;
const KEY_BUTTON_BACK					= 0x00002000;
const KEY_BUTTON_L_STICK_PRESS			= 0x00004000;
const KEY_BUTTON_R_STICK_PRESS			= 0x00008000;
const KEY_BUTTON_L_STICK_LEFT_RIGHT		= 0x00010000;
const KEY_BUTTON_L_STICK_FORWARD_BACK	= 0x00020000;
const KEY_BUTTON_R_STICK_LEFT_RIGHT		= 0x00040000;
const KEY_BUTTON_R_STICK_FORWARD_BACK	= 0x00080000;

var float fWaitForButtonTime;
var int LatentButtonMask;

var bool bWaitForSaveGame;
var bool m_fSaveCustom;

// Absolute Time support. Do not manipulate these directly.
var protected bool  bAbsoluteTimeStopped;		// Is the AbsoluteTime clock paused?

// END BOOLS

struct native ActorCacheEntry
{
	var name			ActorTag;
	var Actor			MyActor;			// If None, ArrActors is used instead.
	var array< Actor >	ArrActors;
	var float			LastAccessTime;
};

const ACTOR_CACHE_LENGTH = 16;
var transient ActorCacheEntry		ActorCache[ ACTOR_CACHE_LENGTH ];

const CHECKPOINT_SAVE_DELAY = 0.1f;
var float flDoSaveGame;

const DEFEND_WAVE_MESSAGE_DELAY = 3.0f;
var float flDoDefendWaveMessage;

// Internal variables.
var name SavedTag;
var Pawn LatentPawn;	// needed by ACTION_WaitForPawnMoveTo() function
var int m_nUnitMembers;	// needed by ACTION_WaitForUnitMoveTo() function
var Unit LatentUnit;	// needed by ACTION_WaitForUnitMoveTo() function
var PlayerController LatentController;

// Absolute Time support. Do not manipulate these directly.
var protected float AbsoluteTimeBegin;			// The time in Level.TimeSeconds considered to be time "0" by the AbsoluteTime clock.
var protected float AbsoluteTimeStopBegin;		// The time at which the AbsoluteTime clock became paused.
var protected float AbsoluteWakeUpTime;			// When a WaitForAbsoluteTime() latent function is in progress, this is the absolute time when the wait will finish.

var localized string m_szCheckpointMessage1;  //DLEVY
//var localized string m_szCheckpointMessage2;  //DLEVY removed post checkpoint message
var string VictoryMovieFile;

var int	m_nCheckpointID;
var name m_szPreSaveTrigger;
var name m_szPostSaveTrigger;
var string m_szCustomMapName;

var Sound ButtonBeepSound;  // sound that goes "boooop!" when you press a button/key
var string ButtonBeepSoundString;
var bool bDontBeep;

native latent function WaitForAbsoluteTime( float absoluteTime );
native final latent function ACTION_WaitForEvent( name event );
native final latent function ACTION_WaitForPawnMoveTo( Pawn MyPawn, vector Destination, optional Actor viewfocus );
native final latent function ACTION_WaitForPawnRotateToward( Pawn MyPawn );
native final latent function ACTION_WaitForTankMoveTo( Pawn MyTank, ActorLite MoveDest );
native final latent function ACTION_WaitForTankRotateToward( Pawn MyTank );
native final latent function ACTION_WaitForAnimEnd( Pawn aPawn, int iChannel );
native final latent function ACTION_WaitForUnitMoveTo( Unit MyUnit );
native final latent function ACTION_WaitForAnyKey( float timeout, bool boolDontBeep );
native final function ACTION_MoveToward(Pawn MyPawn, ActorLite MyDest, optional bool bSteerAroundPawns, optional Actor MyViewFocus);
native final function ACTION_MoveTowardTag(name PawnTag, name DestTag, optional bool bSteerAroundPawns, optional name ViewFocusTag);
native final function bool PawnIsAtDestination(Pawn MyPawn, ActorLite MyDest);
native final function ACTION_VehicleFollowPath(gbxSVehicle MyVehicle, array<name> VehiclePathTags);
native final function bool VehicleIsAtDestination(gbxSVehicle MyVehicle);

native final function CleanupDestroyedActors();
native function ActorLite GetNavigationPointMatchesTag( name actorTag );
native function BlockNavigationPointMatchesTag( name NavPointTag );
native function UnBlockNavigationPointMatchesTag( name NavPointTag );

native final function ACTION_BlockActionKeys( int keymask );  // -1 will block all action keys (use the KEY_ACTION_ mask items above)
native final function ACTION_UnblockActionKeys( int keymask );  // -1 will unblock all action keys (use the KEY_ACTION_ mask items above)
native final function ACTION_ClearInterceptedActionKeys();
native final function bool ACTION_CheckForInterceptedActionKeys( int keymask );
native final latent function ACTION_WaitForInterceptedActionKeys( int keymask, optional bool bDontClearInterceptedKeys, optional float timeout, optional bool bDontBeep );
native final latent function ACTION_WaitForInterceptedActionKeysHeld( int keymask, float holdtime, optional bool bDontClearInterceptedKeys, optional float timeout, optional bool bDontBeep );

native final function ACTION_BlockXboxButtons( int buttonmask );  // -1 will block all buttons (use the KEY_BUTTON_ mask items above)
native final function ACTION_UnblockXboxButtons( int buttonmask );  // -1 will unblock all buttons (use the KEY_BUTTON_ mask items above)
native final function ACTION_ClearXboxInterceptedButtons();
native final function bool ACTION_CheckForXboxInterceptedButton( int buttonmask );
native final latent function ACTION_WaitForXboxInterceptedButton( int buttonmask, optional float timeout, optional bool bDontBeep );
native final latent function ACTION_WaitForXboxInterceptedButtonHeld( int keymask, float holdtime, optional float timeout, optional bool bDontBeep );

native final function ACTION_SetAlwaysTick(bool bAlwaysTick);


const SCRIPTED_ANIM_QUEUE_PRIORITY = 8888;
const SCRIPTED_ANIM_QUEUE_LOOP_PRIORITY = 8887;

function PostBeginPlay()
{
	Super.PostBeginPlay();

	Level.MessageManager.AddListener( Self );
}

function PostLoadGame()
{
	Super.PostLoadGame();

	OnStart();
}

event Destroyed()
{
	Level.MessageManager.RemoveListener( Self );

	OnDestroyed();

	Super.Destroyed();
}

function Trigger( Actor Other, Pawn EventInstigator )
{
	Super.Trigger( Other, EventInstigator );

	if( SavedTag != 'None' && SavedTag != Tag )
	{
		// We've been waiting for an event, and now it has come. Stop waiting.

		Tag = SavedTag;
	}
	else	// Don't call OnTrigger() if we've been waiting for an event.
	{
		
		OnTrigger();
	}
}

function SetSucceeded( bool didSucceed )
{
	Failed = !didSucceed;
	Succeeded = didSucceed;
}

////////////////////////////////////////////////////////////////////////////
// Internals for this class ////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////

function int FindLRUCacheEntry()
{
	local int i, EarliestEntry;
	local float EarliestLastAccessTime;

	EarliestLastAccessTime = Level.TimeSeconds + 10;	// In the future.
	EarliestEntry = -1;

	for( i = 0; i < ACTOR_CACHE_LENGTH; ++i )
	{
		if( ActorCache[ i ].ActorTag == 'None' )
		{
			return i;
		}
		else
		{
			if( ActorCache[ i ].LastAccessTime < EarliestLastAccessTime )
			{
				EarliestLastAccessTime = ActorCache[ i ].LastAccessTime;
				EarliestEntry = i;
			}
		}
	}

	return EarliestEntry;
}

function AddActorToCache( Actor A, name actorTag )
{
	local int i;

	i = FindLRUCacheEntry();

	ActorCache[ i ].ActorTag = actorTag;
	ActorCache[ i ].ArrActors.Remove( 0, ActorCache[ i ].ArrActors.Length );
	ActorCache[ i ].MyActor = A;

	ActorCache[ i ].LastAccessTime = Level.TimeSeconds;
}

function AddActorsToCache( array< Actor > arrActors, name actorTag )
{
	local int i;

	i = FindLRUCacheEntry();

	ActorCache[ i ].ActorTag = actorTag;
	ActorCache[ i ].ArrActors = arrActors;
	ActorCache[ i ].MyActor = None;

	ActorCache[ i ].LastAccessTime = Level.TimeSeconds;
}

function Actor GetCacheActor( name actorTag )
{
	local int i;

	for( i = 0; i < ACTOR_CACHE_LENGTH; ++i )
	{
		if( ActorCache[ i ].ActorTag == actorTag )
		{
			if( ActorCache[ i ].MyActor != None )
			{
				ActorCache[ i ].LastAccessTime = Level.TimeSeconds;
				return ActorCache[ i ].MyActor;
			}
			else if( ActorCache[ i ].ArrActors.Length > 0 )
			{
				ActorCache[ i ].LastAccessTime = Level.TimeSeconds;
				return ActorCache[ i ].ArrActors[ 0 ];
			}
			else
			{
				return None;
			}
		}
	}

	return None;
}

function bool GetCacheActors( name actorTag, out array< Actor > arrActors )
{
	local int i;

	for( i = 0; i < ACTOR_CACHE_LENGTH; ++i )
	{
		if( ActorCache[ i ].ActorTag == actorTag )
		{
			if( ActorCache[ i ].MyActor != None )
			{
				ActorCache[ i ].LastAccessTime = Level.TimeSeconds;
				arrActors.Length = arrActors.Length + 1;
				arrActors[ arrActors.Length - 1 ] = ActorCache[ i ].MyActor;
				return true;
			}
			else
			{
				ActorCache[ i ].LastAccessTime = Level.TimeSeconds;
				arrActors = ActorCache[ i ].ArrActors;
				return true;
			}
		}
	}

	return false;
}

////////////////////////////////////////////////////////////////////////////
// Tick ////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
function Tick( float DeltaTime )
{
	local float flDiff;
	local WargamePlayerController	aPlayer;

	if(bEnablePlayerBreak && !IsInState('PlayerBreak'))
	{
		if ((GetLocalPlayerController().bPlayerBreak != 0))
		{
			GotoState('PlayerBreak');
		}
	}

	if (bWaitForSaveGame)
	{
		if (Level.m_flDoSaveGame < 0)
		{
			if (m_szPostSaveTrigger != '')
			{
				aPlayer = GetLocalPlayerController();
				aPlayer.TriggerEvent( m_szPostSaveTrigger, self, aPlayer.Pawn );
			}
			bWaitForSaveGame = false;
		}
	}
	
	if (flDoSaveGame > 0)
	{
		flDiff = Level.TimeSeconds - flDoSaveGame;
		
		if (flDiff >= CHECKPOINT_SAVE_DELAY)
		{
			ACTION_CheckPointSavePart2( m_nCheckpointID, m_szPreSaveTrigger, m_szPostSaveTrigger );
		}
	}

	if ((flDoDefendWaveMessage > 0.0f) && (flDoDefendWaveMessage < Level.TimeSeconds))
	{
		if (aPlayer == None)
		{
			aPlayer = GetLocalPlayerController();
		}
		BroadcastLocalizedMessage(class'gbxDefendWaveNextMessage', aPlayer.PlayerReplicationInfo.WavesScore, aPlayer.PlayerReplicationInfo, None);
		flDoDefendWaveMessage = 0.0f;
	}
}


////////////////////////////////////////////////////////////////////////////
// API for this class //////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////

// Utility functions ///////////////////////////////////////////////////////

function SLog( coerce string str, optional name logID )
{
	if( logID == '' )
		Log( name $ "<" $ GetStateName() $ ">: " $ str, 'TriggeredScript'  );
	else
		Log( name $ "<" $ GetStateName() $ ">: " $ str, logID );

}

function bool IsRandomlyTrue( float percentageChanceTrue )
{
	return FRand() < percentageChanceTrue / 100.0;
}

function WargamePlayerController GetLocalPlayerController()
{
	return WargamePlayerController( Level.GetLocalPlayerController() );
}

function WargamePawn GetLocalPlayerPawn()
{
	return WargamePawn( GetLocalPlayerController().Pawn );
}

function Actor GetFirstActor( name actorTag )
{
	local Actor A;

	if( actorTag == '' )
	{
		return None;
	}

	A = GetCacheActor( actorTag );

	if( A == None )
	{
		foreach AllActors( class'Actor', A, actorTag )
			break;

		if( A != None )
		{
			// Add to the cache.
			AddActorToCache( A, actorTag );		// TODO what if multiple actors match this tag? We're only caching the first.
		}
	}

	return A;
}

function ActorLite GetNavigationPoint( name actorTag )
{
	if( actorTag == '' )
	{
		return None;
	}

	return GetNavigationPointMatchesTag( actorTag );
}

function vector GetNavigationPointLocation( name actorTag )
{
	local ActorLite AL;
	local vector Loc;

	if( actorTag == '' )
	{
		return Loc;
	}

	AL = GetNavigationPointMatchesTag( actorTag );

	if (AL != None)
	{
		return GetLocation(AL);
	}
	else
	{
		return vect(0,0,0);
	}
}

function Pawn GetPawn( name actorTag )
{
	local Pawn A;

	if( actorTag == '' )
	{
		return None;
	}

	A = Pawn( GetCacheActor( actorTag ));

	if( A == None )
	{
		foreach AllActors( class'Pawn', A, actorTag )
			break;

		if( A != None )
		{
			// Add to the cache.
			AddActorToCache( A, actorTag );		// TODO what if multiple actors match this tag? We're only caching the first.
		}
	}

	return A;
}

function Unit GetUnit( name actorTag )
{
	local Unit A;

	A = Unit( GetCacheActor( actorTag ));

	if( A == None )
	{
		foreach AllActors( class'Unit', A, actorTag )
			break;

		if( A != None )
		{
			// Add to the cache.
			AddActorToCache( A, actorTag );		// TODO what if multiple actors match this tag? We're only caching the first.
		}
	}

	return A;
}

function Mind GetMind( name actorTag )
{
	local Mind A;

	A = Mind( GetCacheActor( actorTag ));

	if( A == None )
	{
		foreach AllActors( class'Mind', A, actorTag )
			break;

		if( A != None )
		{
			// Add to the cache.
			AddActorToCache( A, actorTag );		// TODO what if multiple actors match this tag? We're only caching the first.
		}
	}

	return A;
}

function GetAllActors( name actorTag, out array< Actor > arrActors )
{
	local bool foundInCache;
	local Actor A;

	foundInCache = GetCacheActors( actorTag, arrActors );

	if( !foundInCache )
	{
		foreach AllActors( class'Actor', A, actorTag )
		{
			arrActors.Length = arrActors.Length + 1;
			arrActors[ arrActors.Length - 1 ] = A;
		}

		// Add even a 0-length array.
		// TODO is that the right thing to do?
		AddActorsToCache( arrActors, actorTag );
	}
}

event float GetAbsoluteTime()
{
	return Level.TimeSeconds - AbsoluteTimeBegin;
}

function ResetAbsoluteTime()
{
	AbsoluteTimeBegin = Level.TimeSeconds;

	if( bAbsoluteTimeStopped )
	{
		AbsoluteTimeStopBegin = Level.TimeSeconds;
	}
}

function StartAbsoluteTime()
{
	if( bAbsoluteTimeStopped )
	{
		// Offset time by the amount of time we were paused.
		OffsetAbsoluteTime( AbsoluteTimeStopBegin - Level.TimeSeconds );
		
		bAbsoluteTimeStopped = false;
	}
}

function StopAbsoluteTime()
{
	if( !bAbsoluteTimeStopped )
	{
		AbsoluteTimeStopBegin = Level.TimeSeconds;
		bAbsoluteTimeStopped = true;
	}
}

function OffsetAbsoluteTime( float deltaTime )
{
	AbsoluteTimeBegin -= deltaTime;
}


// ACTION_ functions ///////////////////////////////////////////////////////

function ACTION_ConsoleCommand( coerce string command )
{
	if (GetLocalPlayerPawn() != None)
		GetLocalPlayerPawn().ConsoleCommand( command );
	else if (GetLocalPlayerController() != None)
		GetLocalPlayerController().ConsoleCommand( command );
	else
		ConsoleCommand( command );

	SetSucceeded( true );
}

function ACTION_DestroyActor( name actorTag )
{
	local Actor A;
	local bool	fDestroyed;

	fDestroyed = false;
	
	foreach AllActors( class'Actor', A, actorTag )
	{
		if( A.IsA('TriggeredScript') )
		{
			SLog( name $ ".ACTION_DestroyActor( '" $ actorTag $ "' ): Destroying TriggeredScript is NOT a good idea!!!" );
			fDestroyed = true;
			continue;
		}

		if( A.IsA('NavigationPoint') )
		{
			SLog( name $ ".ACTION_DestroyActor( '" $ actorTag $ "' ): Destroying NavigationPoint is NOT a good idea!!!" );
			fDestroyed = true;
			continue;
		}

		if( Level.bPoolPawns && (A.IsA('InfantryGermany') || (A.IsA('InfantryUSA') && !A.IsA('gbxPlayerPawn'))) )
		{
			SLog( name $ ".ACTION_DestroyActor( '" $ actorTag $ "' ): AI pawns are taken care of another way!!!" );
			fDestroyed = true;
			// GBX:PAD: Set these so that the recache system will interpret them as dead and invisible
			A.bHidden = true;
			Pawn(A).Health = 0;
			A.SetCollision( false, false, false );
			A.SetPhysics( PHYS_None );
			continue;
		}

		if(A != None)
		{
			if (A.bStatic || A.bNoDelete)
			{
				SLog( name $ ".ACTION_DestroyActor( '" $ actorTag $ "' ): actor " $ A.name $ " is static or marked nodelete.  It is not being destroyed."  );
			}
			else
			{
				SLog( name $ ".ACTION_DestroyActor( '" $ actorTag $ "' ): actor " $ A.name $ " is being destroyed."  );

				A.Destroy();
				fDestroyed = true;
			}
		}
		else
		{
			SLog( name $ ".ACTION_DestroyActor( '" $ actorTag $ "' ): actor tag not found."  );
		}
	}

	if (fDestroyed)
		SetSucceeded( true );
	else
		SetSucceeded( false );
}

function ACTION_TeleportPlayerToActor( name DestinationTag )
{
	local Actor Dest;
	local gbxPlayerPawn	aPawn;
	
	aPawn = gbxPlayerPawn(GetLocalPlayerPawn());
	if (aPawn != None)
	{
		Dest = GetFirstActor( DestinationTag );
		if ( Dest != None )
		{
			aPawn.SetLocation( Dest.Location );
			aPawn.SetRotation( Dest.Rotation );			
			if ( aPawn.Controller != None )
			{
				aPawn.Controller.SetRotation( Dest.Rotation );
			}
		}
	}
}

function ACTION_TeleportPawnToActor( AnimPawn aPawn, name DestinationTag )
{
	local Actor Dest;
	
	if (aPawn != None)
	{
		Dest = GetFirstActor( DestinationTag );
		if ( Dest != None )
		{
			aPawn.SetLocation( Dest.Location );
			aPawn.SetRotation( Dest.Rotation );			
			if ( aPawn.Controller != None )
			{
				aPawn.Controller.SetRotation( Dest.Rotation );
			}
		}
	}
}

function ACTION_TeleportToActor( name ActorToMoveTag, name DestinationTag )
{
	local Actor ActorToMove, Dest;
	local bool bIsKarma;
	local Controller aController;

	Dest = GetFirstActor( DestinationTag );
//	ActorToMove = GetFirstActor( ActorToMoveTag );

	// GBX:PAD: This does introduce the possibility that two pawns can be teleported in on top of each other, but
	// we'll have to leave it up to the level designers to make sure that doesn't happen.  Unfortunately, GetFirstActor
	// is not a reliable way to make sure the actor you really care about is dealt with when spawning guys in since their
	// destroyed or dead body has the same label.
	foreach AllActors( class'Actor', ActorToMove, ActorToMoveTag )
	{
		if( ActorToMove != None && Dest != None )
		{
			if (ActorToMove.Physics == PHYS_Karma)
				bIsKarma = true;
			else
				bIsKarma = false;

			if (bIsKarma)
			{
				ActorToMove.SetPhysics(PHYS_None);
				ActorToMove.KSetBlockKarma(False);
			}

			SLog( "ACTION_TeleportToActor() - "$Location$" - "$Dest.Location );
			ActorToMove.SetLocation( Dest.Location );
			ActorToMove.SetRotation( Dest.Rotation );
			
			if ( ActorToMove.IsA( 'Pawn' ) )
			{
				aController = Pawn( ActorToMove ).Controller;
				if ( aController != None )
					aController.SetRotation( Dest.Rotation );
			}

			if (bIsKarma)
			{
				ActorToMove.KSetBlockKarma(True);
				ActorToMove.SetPhysics(PHYS_Karma);
			}

			SetSucceeded( true );
		}
		else
		{
			SLog( name $ ".ACTION_TeleportToActor( '" $ ActorToMoveTag $ "', '" $ DestinationTag $ "' ): tag not found."  );

			SetSucceeded( false );
		}
	}
}

function ACTION_Freeze( name PawnTag )
{
	local Pawn P;

	P = Pawn( GetFirstActor( PawnTag ) );		// TODO specify class to GetFirstActor()

	ACTION_FreezeDirect( P );
}

function ACTION_FreezeDirect( Pawn P )
{
	if( P != None )
	{
		P.bPhysicsAnimUpdate = false;
		P.StopAnimating();
		P.SetPhysics(PHYS_None);

		SetSucceeded( true );
	}
	else
	{
		SLog( name $ ".ACTION_Freeze( '" $ P.name $ "' ): pawn tag not found."  );

		SetSucceeded( false );
	}
}

function Actor ACTION_SpawnActor( coerce string ClassName, optional name TagName )
{
	local Actor A;
	A = Spawn( class<Actor>( DynamicLoadObject( ClassName, class'Class' )),, TagName );

	SetSucceeded( true );

	if( A == None )
	{
		SLog( name $ ".ACTION_Freeze( '" $ ClassName $ "', '" $ TagName $ "' ): unable to spawn actor of that class."  );
		SetSucceeded( false );
	}

	return A;
}

function ACTION_PlayAmbientSound( name actorTag, string soundName, byte volume, byte pitch, float radius )
{
	local Actor A;

	A = GetFirstActor( actorTag );

	ACTION_PlayAmbientSoundDirect( A, soundName, volume, pitch, radius );
}

function ACTION_PlayAmbientSoundDirect( Actor A, string soundName, byte volume, byte pitch, float radius )
{
	local Sound S;

	if( A == None )
	{
		SLog( name $ ".ACTION_PlayAmbientSound( '" $ A.name $ "', '" $ soundName $ "', " $ volume $ ", " $ pitch $ ", " $ radius $ " ): could not find actor with that tag."  );
		SetSucceeded( false );
	}
	else if( soundName != "" )
	{
		S = Sound( DynamicLoadObject( soundName, class'Sound' ));

		if( S == None )
		{
			SLog( name $ ".ACTION_PlayAmbientSound( '" $ A.name $ "', '" $ soundName $ "', " $ volume $ ", " $ pitch $ ", " $ radius $ " ): could not find sound with that name."  );
			SetSucceeded( false );
		}
		else
		{
			A.AmbientSound	= S;
			A.SoundVolume	= volume;
			A.SoundPitch	= pitch;
			A.SoundRadius	= radius;

			SetSucceeded( true );
		}
	}
}

/** 
 * Stop the specified sound cue playing with this sound HANDLE.
 *
 * @param actorTag The name of the Actor the sound was played from originally.
 * @param soundHandle The sound handle that was returned from PlaySound.
 * @param fadeRuation The length of time the sound should fade out (0.0 will stop abrubtly with no fade).
 */
function ACTION_StopSound( name actorTag, int soundHandle, float fadeDuration )
{
	local Actor A;

	A = GetFirstActor( actorTag );

	ACTION_StopSoundDirect( A, soundHandle, fadeDuration );
}
function ACTION_StopSoundDirect( Actor A, int soundHandle, float fadeDuration )
{
	if ( A != None )
	{
		A.StopSound( soundHandle, fadeDuration );
	}
}

/**
 * Play a sound cue on the specified Actor.
 * 
 * @param actorTag The name of the Actor to play the sound from.  If the sound is 3D, the sound will use this Actor for its position.
 * @param soundName The name of the sound to play.
 * @param volume The volume to play the sound at.					(DEPRECATED)  This is now overridden with what is saved in the Everything.ucx Cue package.
 * @param pitch The pitch to play the sound at.						(DEPRECATED)  This is now overridden with what is saved in the Everything.ucx Cue package.
 * @param radius The radius that this sound should be heard from.   (DEPRECATED)  This is now overridden with what is saved in the Everything.ucx Cue package.
 * @return Returns the sound's duration in seconds.
 */
function float ACTION_PlaySound( name actorTag, string soundName, float volume, float pitch, float radius )
{
	local Actor A;

	A = GetFirstActor( actorTag );

	return ACTION_PlaySoundDirect( A, soundName, volume, pitch, radius );
}

function float ACTION_PlaySoundDirect( Actor A, string soundName, float volume, float pitch, float radius )
{
	local Sound S;
	local float flDuration;

	if( A == None )
	{
		SLog( name $ ".ACTION_PlaySound( '" $ A.name $ "', '" $ soundName $ "', " $ volume $ ", " $ pitch $ ", " $ radius $ " ): could not find actor with that tag."  );
		SetSucceeded( false );
		flDuration = 0.0f;
	}
	else if( soundName != "" )
	{
		S = Sound( DynamicLoadObject( soundName, class'Sound' ));

		if( S == None )
		{
			SLog( name $ ".ACTION_PlaySound( '" $ A.name $ "', '" $ soundName $ "', " $ volume $ ", " $ pitch $ ", " $ radius $ " ): could not find sound with that name."  );
			flDuration = 0.0f;
			SetSucceeded( false );
		}
		else
		{
			A.PlaySound( S, SLOT_Interact, volume, false, radius, pitch, true );
			flDuration = A.GetSoundDuration( S );
			SetSucceeded( true );
		}
	}
	
	return flDuration;
}

/**
 * Play a sound cue on the specified Actor.
 * 
 * @param actorTag The name of the Actor to play the sound from.  If the sound is 3D, the sound will use this Actor for its position.
 * @param soundName The name of the sound to play.
 * @param volume The volume to play the sound at.					(DEPRECATED)  This is now overridden with what is saved in the Everything.ucx Cue package.
 * @param pitch The pitch to play the sound at.						(DEPRECATED)  This is now overridden with what is saved in the Everything.ucx Cue package.
 * @param radius The radius that this sound should be heard from.   (DEPRECATED)  This is now overridden with what is saved in the Everything.ucx Cue package.
 * @return Returns the sound handle associated with this sound which can be used later to stop the sound.
 */
function int ACTION_PlaySoundReturnHandle( name actorTag, string soundName, float volume, float pitch, float radius )
{
	local Actor A;

    A = GetFirstActor( actorTag );

	return ACTION_PlaySoundReturnHandleDirect( A, soundName, volume, pitch, radius );
}

function int ACTION_PlaySoundReturnHandleDirect( Actor A, string soundName, float volume, float pitch, float radius )
{
	local Sound S;
	local int SoundHandle;

	SoundHandle = -1;

	if( A == None )
	{
		SLog( name $ ".ACTION_PlaySoundReturnHandle( '" $ A.name $ "', '" $ soundName $ "', " $ volume $ ", " $ pitch $ ", " $ radius $ " ): could not find actor with that tag."  );
		SetSucceeded( false );
	}
	else if( soundName != "" )
	{
		S = Sound( DynamicLoadObject( soundName, class'Sound' ));

		if( S == None )
		{
			SLog( name $ ".ACTION_PlaySoundReturnHandle( '" $ A.name $ "', '" $ soundName $ "', " $ volume $ ", " $ pitch $ ", " $ radius $ " ): could not find sound with that name."  );
			SetSucceeded( false );
		}
		else
		{
			SoundHandle = A.PlaySound( S, SLOT_Interact, volume, false, radius, pitch, true );
			SetSucceeded( true );
		}
	}
	
	return SoundHandle;
}

function float ACTION_PlayLipSyncSound( name actorTag, string soundName, float volume, float pitch, float radius, optional bool bAttenuate, optional name BoneForLocation )
{
	local Actor A;

	A = GetFirstActor( actorTag );

	return ACTION_PlayLipSyncSoundDirect( A, soundName, volume, pitch, radius, bAttenuate, BoneForLocation );
}

function float ACTION_PlayLipSyncSoundDirect( Actor A, string soundName, float volume, float pitch, float radius, optional bool bAttenuate, optional name BoneForLocation )
{
	local Sound S;
	local float flDuration;

	if( A == None )
	{
		SLog( name $ ".ACTION_PlayLipSyncSound( '" $ A.name $ "', '" $ soundName $ "', " $ volume $ ", " $ pitch $ ", " $ radius $ " ): could not find actor with that tag."  );
		SetSucceeded( false );
		flDuration = 0.0f;
	}
	else if( soundName != "" )
	{
		S = Sound( DynamicLoadObject( soundName, class'Sound' ));

		if( S == None )
		{
			SLog( name $ ".ACTION_PlayLipSyncSound( '" $ A.name $ "', '" $ soundName $ "', " $ volume $ ", " $ pitch $ ", " $ radius $ " ): could not find sound with that name."  );
			flDuration = 0.0f;
			SetSucceeded( false );
		}
		else
		{
			SLog( name $ ".ACTION_PlayLipSyncSound( '" $ A.name $ "', '" $ soundName $ "', " $ volume $ ", " $ pitch $ ", " $ radius $ " ): sound played."  );
			A.PlaySound( S, SLOT_Talk, volume, false, radius, pitch, bAttenuate, true, BoneForLocation );
			flDuration = A.GetSoundDuration( S );
			SetSucceeded( true );
		}

//		SLog(self$".GetSoundDuration( "$S$" ) - "$flDuration);
	}

	return flDuration;
}

function float ACTION_PlayLocalSound( string soundName )
{
	local Sound S;
	local float flDuration;

	if( soundName != "" )
	{
		S = Sound( DynamicLoadObject( soundName, class'Sound' ));

		if( S == None )
		{
			SLog( name $ ".ACTION_PlayLocalSound( '" $ soundName $ "' ): could not find sound with that name."  );
			flDuration = 0.0f;
			SetSucceeded( false );
		}
		else
		{
			GetLocalPlayerController().ClientPlaySound( S );
			flDuration = GetLocalPlayerController().GetSoundDuration( S );
			SetSucceeded( true );
		}
	}

	return flDuration;
}

function ACTION_StopCurrentStereoAmbientSound( name actorTag )
{
	local Actor A;

	A = GetFirstActor( actorTag );

	ACTION_StopCurrentStereoAmbientSoundDirect( A );
}

function ACTION_StopCurrentStereoAmbientSoundDirect( Actor A )
{
	if( A == None )
	{
		SLog( self $ ".ACTION_StopCurrentStereoAmbientSound(" $ A.name $ ") Failed to find supplied Actor." );
		SetSucceeded( false );
	}
	else
	{
		SLog( self $ ".ACTION_StopCurrentStereoAmbientSound(" $ A.name $ ") Calling audio function to stop the current stereo ambient sound." );
		A.StopCurrentStereoAmbientSound();
		SetSucceeded( true );
	}
}

function ACTION_Run( name pawnTag )
{
	local Pawn P;

	P = Pawn( GetFirstActor( pawnTag ));		// TODO specify class to GetFirstActor()

	ACTION_RunDirect( P );
}

function ACTION_RunDirect( Pawn P )
{
	if( P != None )
	{
		P.ShouldCrouch(false);
		P.SetWalking(false);

		SetSucceeded( true );
	}
	else
	{
		SLog( name $ ".ACTION_Run( '" $ P.name $ "' ): pawn tag not found."  );

		SetSucceeded( false );
	}
}

function ACTION_Crouch( name pawnTag )
{
	local Pawn P;

	P = Pawn( GetFirstActor( pawnTag ));		// TODO specify class to GetFirstActor()

	ACTION_CrouchDirect( P );
}

function ACTION_CrouchDirect( Pawn P )
{
	if( P != None )
	{
		P.ShouldCrouch(true);

		SetSucceeded( true );
	}
	else
	{
		SLog( name $ ".ACTION_Crouch( '" $ P.name $ "' ): pawn tag not found."  );

		SetSucceeded( false );
	}
}

function ACTION_Walk( name pawnTag )
{
	local Pawn P;

	P = Pawn( GetFirstActor( pawnTag ));		// TODO specify class to GetFirstActor()

	ACTION_WalkDirect( P );
}

function ACTION_WalkDirect( Pawn P )
{
	if( P != None )
	{
		P.ShouldCrouch(false);
		P.SetWalking(true);

		SetSucceeded( true );
	}
	else
	{
		SLog( name $ ".ACTION_Walk( '" $ P.name $ "' ): pawn tag not found."  );
		SetSucceeded( false );
	}
}

function ACTION_ChangeLevel( coerce string URL )
{
	ACTION_ConsoleCommand( "open " $ URL );
	SetSucceeded( true );
}

function ACTION_SetPhysics( name actorTag, Actor.EPhysics newPhysicsMode )
{
	local Actor A;

	A = GetFirstActor( actorTag );

	ACTION_SetPhysicsDirect( A, newPhysicsMode );
}

function ACTION_SetPhysicsDirect( Actor A, Actor.EPhysics newPhysicsMode )
{
	if( A != None )
	{
		A.SetPhysics( newPhysicsMode );
		SetSucceeded( true );
	}
	else
	{
		SLog( name $ ".ACTION_SetPhysics( '" $ A.name $ "', " $ newPhysicsMode $ " ): actor tag not found."  );
		SetSucceeded( false );
	}
}

function ACTION_SetHidden( name actorTag, bool bHide )
{
	local Actor A;

	A = GetFirstActor( actorTag );

	if( A != None )
	{
		A.bHidden = bHide;
		SetSucceeded( true );
	}
	else
	{
		SLog( name $ ".ACTION_SetHidden( '" $ actorTag $ "', " $ bHide $ " ): actor tag not found."  );
		SetSucceeded( false );
	}
}

function ACTION_SetHiddenDirect( Actor anActor, bool bHide )
{
	if( anActor != None )
	{
		anActor.bHidden = bHide;
		SetSucceeded( true );
	}
	else
	{
		SLog( name $ ".ACTION_SetHidden( " $ anActor $ "', " $ bHide $ " ): actor tag not found."  );
		SetSucceeded( false );
	}
}

// PSV: 6/13/2005  Can't rely on local player being alive in skirmish, so look for other player controllers if local player is dead.
function ACTION_TriggerEvent( name eventName )
{
	local WargamePawn P;
	local PlayerController PC;
	
	if ( Level.Game.GameReplicationInfo.GameType != GT_SKIRMISH )
	{

	// TODO Others and Instigators?
	GetLocalPlayerController().TriggerEvent( eventName, Self, GetLocalPlayerPawn() );
	}
	else
	{
		P = GetLocalPlayerPawn();

		if ( P == None )
		{
			// The server player is dead so find the client's pawn
			for( PC = Level.PlayerControllerList; PC != None; PC = PC.nextPlayerController )
			{
				if ( PC.Pawn != None)
				{
					P = WargamePawn(Pc.Pawn);
					break;
				}
			}	

			//log( "ACTION_TriggerEvent("$eventName$")  GetLocalPlayerPawn() was NULL, but found Pawn "$P, 'MP' );
		}

		/*if ( P == None )
		{
			log( "ACTION_TriggerEvent("$eventName$") Cannot find a player pawn, calling TriggerEvent with NULL pawn!", 'MP' );
		}*/

		// TODO Others and Instigators?
		GetLocalPlayerController().TriggerEvent( eventName, Self, P );
	}

	SetSucceeded( true );
}

function ACTION_OrderMove( name unitTag, name destinationTag, optional bool bAddtoQueue )
{
	local Unit UnitToOrder;
	local ActorLite Dest;

	Dest = GetNavigationPointMatchesTag( destinationTag );

	if (Dest == None)
	{
		SetSucceeded( false );
		return;
	}

	UnitToOrder = GetUnit( unitTag );

	if( Dest == None )
	{
		SLog( name $ ".ACTION_OrderMove( '" $ unitTag $ "', '" $ destinationTag $ "' ): no destination navigation point with tag " $ destinationTag $ " found."  );
		SetSucceeded( false );
	}
	else if( UnitToOrder == None )
	{
		SLog( name $ ".ACTION_OrderMove( '" $ unitTag $ "', '" $ destinationTag $ "' ): no unit with tag " $ unitTag $ " found."  );
		SetSucceeded( false );
	}
	else
	{
		UnitToOrder.OrderMove( Dest, bAddtoQueue );
		SetSucceeded( true );
	}
}

function ACTION_OrderTarget( name unitTag, name targetUnitTag )
{
	local Unit UnitToOrder, UnitToTarget;

	UnitToOrder = Unit( GetFirstActor( unitTag ));
	UnitToTarget = Unit( GetFirstActor( targetUnitTag ));

	ACTION_OrderTargetDirect( UnitToOrder, UnitToTarget );
}

function ACTION_OrderTargetDirect( Unit UnitToOrder, Unit UnitToTarget )
{
	if( UnitToTarget == None )
	{
		SLog( name $ ".ACTION_OrderTarget( '" $ UnitToOrder.name $ "', '" $ UnitToTarget.name $ "' ): no target unit with tag " $ UnitToTarget.name $ " found."  );
		SetSucceeded( false );
	}
	else if( UnitToOrder == None )
	{
		SLog( name $ ".ACTION_OrderTarget( '" $ UnitToOrder.name $ "', '" $ UnitToTarget.name $ "' ): no addressee unit with tag " $ UnitToOrder.name $ " found."  );
		SetSucceeded( false );
	}
	else
	{
		UnitToOrder.OrderTarget( UnitToTarget );
		SetSucceeded( true );
	}
}

function ACTION_OrderAssault( name unitTag, name targetUnitTag )
{
	local Unit UnitToOrder, UnitToTarget;

	UnitToOrder = Unit( GetFirstActor( unitTag ));
	UnitToTarget = Unit( GetFirstActor( targetUnitTag ));

	ACTION_OrderAssaultDirect( UnitToOrder, UnitToTarget );
}

function ACTION_OrderAssaultDirect( Unit UnitToOrder, Unit UnitToTarget )
{
	if( UnitToTarget == None )
	{
		SLog( name $ ".ACTION_OrderAssault( '" $ UnitToOrder.name $ "', '" $ UnitToTarget.name $ "' ): no target unit with tag " $ UnitToTarget.name $ " found."  );
		SetSucceeded( false );
	}
	else if( UnitToOrder == None )
	{
		SLog( name $ ".ACTION_OrderAssault( '" $ UnitToOrder.name $ "', '" $ UnitToTarget.name $ "' ): no addressee unit with tag " $ UnitToOrder.name $ " found."  );
		SetSucceeded( false );
	}
	else
	{
		UnitToOrder.OrderAssault( UnitToTarget );
		SetSucceeded( true );
	}
}

function ACTION_OrderFallIn( name unitTag )
{
	local Unit UnitToOrder;

	UnitToOrder = GetUnit( unitTag );

	if( UnitToOrder != None )
	{
		UnitToOrder.OrderFallIn();
		SetSucceeded( true );
	}
	else
	{
		SLog( name $ ".ACTION_OrderFallIn( '" $ unitTag $ "' ): no unit with tag " $ unitTag $ " found."  );
		SetSucceeded( false );
	}
}

function ACTION_OrderFallOut( name unitTag )
{
	local Unit UnitToOrder;

	UnitToOrder = GetUnit( unitTag );

	ACTION_OrderFallOutDirect( UnitToOrder );
}

function ACTION_OrderFallOutDirect( Unit UnitToOrder )
{
	if( UnitToOrder != None )
	{
		UnitToOrder.DetachFromSuperUnit();
		SetSucceeded( true );
	}
	else
	{
		SLog( name $ ".ACTION_OrderFallOut( '" $ UnitToOrder.name $ "' ): no unit with tag " $ UnitToOrder.name $ " found."  );
		SetSucceeded( false );
	}
}


function ACTION_AssignToUnit( name pawnTag, name unitTag )
{
	local gbxPawn Assignee;

	Assignee = gbxPawn( GetFirstActor( pawnTag ));

	ACTION_AssignToUnitDirect( Assignee, unitTag );
}

function ACTION_AssignToUnitDirect( gbxPawn Assignee, name unitTag )
{
	if( Assignee == None )
	{
		SLog( name $ ".ACTION_AssignToUnit( '" $ Assignee.name $ "', '" $ unitTag $ "' ): no pawn with that tag found."  );
		SetSucceeded( false );
	}
	else
	{
		Assignee.JoinUnit( unitTag );
		SetSucceeded( true );
	}
}


function ACTION_AttachUnitToSuperUnit( name unitTag, name unitTagSuper )
{
	local Unit	aUnit, aSuperUnit;
	
	aUnit = GetUnit( unitTag );
	aSuperUnit = GetUnit( unitTagSuper );
	
	if (aUnit == None)
	{
		SLog( name $ ".ACTION_AttachUnitToSuperUnit( '" $ unitTag $ "', " $ unitTagSuper $ "' ): no unit with tag " $ unitTag $ " found."  );
		SetSucceeded( false );
	}

	if (aSuperUnit == None)
	{
		SLog( name $ ".ACTION_AttachUnitToSuperUnit( '" $ unitTag $ "', " $ unitTagSuper $ "' ): no super unit with tag " $ unitTagSuper $ " found."  );
		SetSucceeded( false );
	}

	aUnit.AttachToSuperUnitComplete( aSuperUnit );
}


function ACTION_DetachUnitFromSuperUnit( name unitTag )
{
	local Unit	aUnit;
	
	aUnit = GetUnit( unitTag );
	
	if (aUnit == None)
	{
		SLog( name $ ".ACTION_AttachUnitToSuperUnit( '" $ unitTag $ "' ): no unit with tag " $ unitTag $ " found."  );
		SetSucceeded( false );
	}

	aUnit.DetachFromSuperUnitComplete();
}


function ACTION_DisplaySubTitleMessage( coerce string Message, float LifeTime, color TextColor, optional bool bCentered, optional bool bClearSubTitles )
{
	local WargameHUD myHud;
	myHud = WargameHUD( GetLocalPlayerController().MyHud );

	if( bClearSubTitles )
	{
		ACTION_DisplayObjectiveString(message, LifeTime);;
	}
	else
	{
		// concat this to the previously displaying message
		ACTION_DisplayObjectiveString(myHud.m_ObjString $ " " $ message, LifeTime);;
	}

/*	CEK: E3 HACK - Pipe this message through the new system for now
	if( bClearSubTitles )
	{
		myHud.ClearTextSubTitles();
	}
	myHud.AddTextSubTitle( Message, class'StringMessagePlus',
		GetLocalPlayerPawn().PlayerReplicationInfo, LifeTime, TextColor, bCentered );

*/
	SetSucceeded( true );
}

function ACTION_DisplaySubTitleMessage2(
	coerce string Message,
	float LifeTime,
	byte textColorR,
	byte textColorG,
	byte textColorB,
	optional bool bCentered,
	optional bool bClearSubTitles )
{
	local PlayerController PC;

	PC = GetLocalPlayerController();



	if (PC.bDisableSubtitles)
	{
		return;
	}

	
//	if( bClearSubTitles )
//	{
		ACTION_DisplayObjectiveString(message, LifeTime);
//	}
//	else
//	{
//		// concat this to the previously displaying message
//		ACTION_DisplayObjectiveString(myHud.m_ObjString $ " " $ message, LifeTime);;
//	}

/*	CEK: E3 HACK - Pipe this message through the new system for now
	if( bClearSubTitles )
	{
		myHud.ClearTextSubTitles();
	}

	TextColor.R = textColorR;
	TextColor.G = textColorG;
	TextColor.B = textColorB;

	myHud.AddTextSubTitle( Message, class'StringMessagePlus',
		GetLocalPlayerPawn().PlayerReplicationInfo, LifeTime, TextColor, bCentered );

*/
	SetSucceeded( true );
}

function ACTION_DisplayTrainingMessage(
	coerce string Message,
	float LifeTime)
{
	local string ButtonizedMessage;
	local WargameHUD myHud;

	myHud = WargameHUD( GetLocalPlayerController().MyHud );

	ButtonizedMessage = myHud.ConvertToButtonizedMessage(Message);

	ACTION_DisplayTrainingString(ButtonizedMessage, LifeTime);
	
	SetSucceeded( true );
}

function ACTION_WaitForSubTitle( name szEventToFire, bool bLockedMovement, bool bHideHud )
{
	local PlayerController	aPlayer;

	ForEach Level.GetLocalPlayerController().DynamicActors(class'PlayerController', aPlayer)
	{
		if ((WargamePlayerController(aPlayer) != None) && (WargameHUD(aPlayer.MyHUD) != None))
		{
			WargameHUD(aPlayer.MyHUD).m_eHudMode = HudModeWaitForKey;
			WargameHUD(aPlayer.MyHUD).m_szWaitTag = szEventToFire;
			WargamePlayerController(aPlayer).bLockedMovement = bLockedMovement;
			WargameHUD(aPlayer.MyHUD).bHideWargameHUD = bHideHud;
			gbxWeapon(aPlayer.Pawn.Weapon).ForceUnzoom();
			if (bHideHud)
				aPlayer.SetHand( 2 );
		}
	}

	SetSucceeded( true );
}

function ACTION_SetSubTitlePosition( int titleX, int titleY, optional bool bShowBackground )
{
	local WargameHUD myHud;
	myHud = WargameHUD( GetLocalPlayerController().MyHud );

	myHud.m_nSubTitleX = titleX;
	myHud.m_nSubTitleY = titleY;
	myHud.m_fShowSubTitleBackground = bShowBackground;
	SetSucceeded( true );
}

//	GBX:PAD: EObjectiveComplete can be:
//	OI_Inactive,
//	OI_Active,
//	OI_Complete,
//	OI_Failed

function ACTION_SetObjectiveStatus( int ndxObjective, EObjectiveComplete complete, name objectiveListTag )
{
	local ObjectiveList anObjectiveList;

	SLog(self$".ACTION_SetObjectiveStatus( "$ndxObjective$", "$complete$", "$objectiveListTag$" )" );
	//DHW -- Changed to AllActors because the objective list is a static not dynamic actor
	foreach AllActors( class'ObjectiveList', anObjectiveList, objectiveListTag )
	{
		if( anObjectiveList.Objectives[ ndxObjective ] != None)
		{
			anObjectiveList.SetStatus( ndxObjective, complete, GetLocalPlayerController() );
		}

		anObjectiveList.TestStatus(GetLocalPlayerController());

		break;
	}

	SetSucceeded( true );
}

function ACTION_SetObjectiveStatusSkirmish( int ndxObjective, EObjectiveComplete complete, name objectiveListTag )
{
	local ObjectiveList anObjectiveList;
	local PlayerController	PC;

	PC = GetLocalPlayerController();
	SLog(self$".ACTION_SetObjectiveStatus( "$ndxObjective$", "$complete$", "$objectiveListTag$" )");
	foreach AllActors( class'ObjectiveList', anObjectiveList, objectiveListTag )
	{
		if( anObjectiveList.Objectives[ ndxObjective ] != None)
		{
			BroadcastObjectiveUpdate(class'ObjectiveList', objectiveListTag, complete, ndxObjective, false, 0.0, PC.PlayerReplicationInfo);
		}

		break;
	}

	SetSucceeded( true );
}
		
function ACTION_SetObjectiveBeaconState( name objName, bool bArrowEnable, bool bDistanceEnable, bool bSAViewEnable )
{
	local gbxBeacons anObjective;

	SLog(self$".ACTION_SetObjectiveBeaconState( "$objName$", "$bArrowEnable$", "$bDistanceEnable$", "$bSAViewEnable$" )" );
	anObjective = gbxBeacons( GetFirstActor( objName ));
	if (anObjective != None)
	{
		ACTION_SetObjectiveBeaconStateDirect( anObjective, bArrowEnable, bDistanceEnable, bSAViewEnable );
	}
}

function ACTION_SetObjectiveBeaconStateDirect( gbxBeacons anObjective, bool bArrowEnable, bool bDistanceEnable, bool bSAViewEnable )
{
	SLog(self$".ACTION_SetObjectiveBeaconStateDirect( "$anObjective$", "$bArrowEnable$", "$bDistanceEnable$", "$bSAViewEnable$" )" );
	if (anObjective != None)
	{
		anObjective.bNoDirectionArrow = !bArrowEnable;
		anObjective.bNoDistanceArc = !bDistanceEnable;
		anObjective.bNotInSAView = !bSAViewEnable;
	}
}

function ACTION_DisplayObjective( int ndxObjective, name objectiveListTag, float flLifeTime )
{
	local ObjectiveList anObjectiveList;
	local WargameHUD myHud;
	myHud = WargameHUD( GetLocalPlayerController().MyHud );

	if (myHud.m_bCriticalMessage)  //DLEVY dont allow another objective, hint or training string to be displayed
	{							   // a critical message still on screen
		return;
	}

	if (ndxObjective == -1)
	{
		MyHud.ClearObjectiveOverlay();
	}
	else
	{
		foreach AllActors( class'ObjectiveList', anObjectiveList, objectiveListTag )
		{
			if( anObjectiveList.Objectives[ ndxObjective ] != None)
			{
				myHud.m_bObjComplete = anObjectiveList.Objectives[ ndxObjective ].m_eComplete;
				myHud.m_bObjPrimary = anObjectiveList.Objectives[ ndxObjective ].m_fPrimary;
				myHud.m_ObjString = anObjectiveList.Objectives[ ndxObjective ].m_szShortDesc;

				myHud.m_flObjStringTime = flLifeTime;

				if (flLifeTime > 0)
				{
					MyHud.m_flObjStringStartTime = Level.TimeSeconds;
				}
			}

			break;
		}
	}

	SetSucceeded( true );
}

function ACTION_DisplayObjectiveSkirmish( int ndxObjective, name objectiveListTag, float flLifeTime )
{
	local ObjectiveList anObjectiveList;
	local WargameHUD myHud;
	local PlayerController PC;
	
	myHud = WargameHUD( GetLocalPlayerController().MyHud );
	
	if (myHud.m_bCriticalMessage)  //DLEVY dont allow another objective, hint or training string to be displayed
	{							   // a critical message still on screen
		return;
	}
	
	PC = GetLocalPlayerController();
	
	if (ndxObjective == -1)
	{
		MyHud.ClearObjectiveOverlay();
	}
	else
	{
		foreach AllActors( class'ObjectiveList', anObjectiveList, objectiveListTag )
		{
			if( anObjectiveList.Objectives[ ndxObjective ] != None)
			{
				BroadcastObjectiveUpdate(class'ObjectiveList', objectiveListTag, anObjectiveList.Objectives[ ndxObjective ].m_eComplete, ndxObjective, true, flLifeTime, PC.PlayerReplicationInfo);
			}

			break;
		}
	}

	SetSucceeded( true );
}

function ACTION_DisplayObjectiveString( string objString, float flLifeTime ,optional bool bCriticalMsg)
{
	local WargameHUD myHud;
	myHud = WargameHUD( GetLocalPlayerController().MyHud );

	if (myHud.m_bCriticalMessage)  //DLEVY dont allow another objective, hint or training string to be displayed
	{							   // a critical message still on screen

		SLog("***DLEVY Attempt to display message while critical message onscreen, message not displayed",'dlevy');
		return;
	}

	MyHud.ClearObjectiveOverlay();

	if (objString != "")
	{
		myHud.m_ObjString = objString;
		myHud.m_bObjComplete = OI_Inactive;
		myHud.m_bObjPrimary = false;
		myHud.m_bCriticalMessage = bCriticalMsg; //DLEVY

		myHud.m_flObjStringTime = flLifeTime;
		if (flLifeTime > 0)
		{
			MyHud.m_flObjStringStartTime = Level.TimeSeconds;
		}
	}

	SetSucceeded( true );
}

function ACTION_DisplayObjectiveStringSkirmish( int nMessageIdx )
{
	local PlayerController PC;
	
	PC = GetLocalPlayerController();
	BroadcastLocalizedMessage(class'gbxObjectiveMessage', nMessageIdx, PC.PlayerReplicationInfo, None);
}

function ACTION_DisplayObjectiveHint( string objString, float LifeTime )
{
	local WargameHUD myHud;
	myHud = WargameHUD( GetLocalPlayerController().MyHud );

	if (myHud.m_bCriticalMessage)  //DLEVY dont allow another objective, hint or training string to be displayed
	{							   // a critical message still on screen
		return;
	}
	
	if (GetLocalPlayerController().bDisableHints)
		return;

	myHud.m_szHintMessage = objString;
	
	MyHud.ClearTrainingOverlay();
	if (objString != "")
		MyHud.SetTrainingText(myHud.m_szHintText$": "$objString, LifeTime, false);

	SetSucceeded( true );
}

function ACTION_DisplayHintStringSkirmish( int nMessageIdx )
{
	local PlayerController PC;
	
	PC = GetLocalPlayerController();
	BroadcastLocalizedMessage(class'gbxHintMessage', nMessageIdx, PC.PlayerReplicationInfo, None);
}

function bool ACTION_SuppressionIconsDisabled()
{
	return GetLocalPlayerController().GetbNoSuppressionIcons();
}

function bool ACTION_IsTrainingDisabled()
{
	return (GetLocalPlayerController().bDisableTraining || (Level.DifficultyLevel == DIFF_Authentic));
}

function ACTION_DisplayTrainingString( string trainingString, float flLifeTime )
{
	local WargameHUD myHud;
	myHud = WargameHUD( GetLocalPlayerController().MyHud );

	if (myHud.m_bCriticalMessage)  //DLEVY dont allow another objective, hint or training string to be displayed
	{							   // a critical message still on screen
		return;
	}

	MyHud.ClearTrainingOverlay();
	if (trainingString != "")
		MyHud.SetTrainingText(trainingString, flLifeTime, true);

	SetSucceeded( true );
}

function MeshAnimation ACTION_SetAnimSet( name pawnTag, string MeshAnimName )
{
	local AnimPawn thePawn;
	thePawn = AnimPawn( GetFirstActor( pawnTag ));

	if( thePawn != None && !thePawn.IsDead() )
	{
		return ACTION_SetAnimSetDirect( thePawn, MeshAnimName );
	}
}

function MeshAnimation ACTION_SetAnimSetDirect( AnimPawn thePawn, string MeshAnimName )
{
	local MeshAnimation	aMeshAnim;
	
	if( thePawn != None && !thePawn.IsDead() )
	{
		if (MeshAnimName != "")
		{
			aMeshAnim = MeshAnimation(DynamicLoadObject(MeshAnimName,class'MeshAnimation'));
			if (aMeshAnim != None)
			{
				SLog(self$".ACTION_SetAnimSet( "$thePawn.Tag$", "$MeshAnimName$" ) - "$aMeshAnim );
				thePawn.LinkSkelAnim(aMeshAnim);
			}
			return aMeshAnim;
		}
	}
}

function ACTION_UnsetAnimSet( name pawnTag, string MeshAnimName )
{
	local AnimPawn thePawn;
	thePawn = AnimPawn( GetFirstActor( pawnTag ));

	if( thePawn != None )
	{
		ACTION_UnsetAnimSetDirect( thePawn, MeshAnimName );
	}
}

// GBX:PAD: OK.  This is a little wild, but here goes.  We want to be able to unlink and free animation sets.  However,
// since more than one pawn can have the same animation set used, we can't just delete it from the first guy.  So, this
// code will now go through the pawn list and verify that no other pawn is using the animation set, before deleting it.
function ACTION_UnsetAnimSetDirect( AnimPawn thePawn, string MeshAnimName )
{
/*	
	local MeshAnimation	aMeshAnim;
	local Pawn			aPawn;
	
	if( thePawn != None )
	{
		aMeshAnim = MeshAnimation(thePawn.UnlinkSkelAnimByName( MeshAnimName, false ));
		if (aMeshAnim != None)
		{
			foreach AllActors( class'Pawn', aPawn )
			{
				if (MeshAnimation(aPawn.GetSkelAnimByName( MeshAnimName )) == aMeshAnim)
				{
					SLog(self$".ACTION_UnsetAnimSetDirect( "$thePawn$", "$MeshAnimName$" ) - "$aMeshAnim$" - Not Deleted");
					return;
				}
			}
			
			SLog(self$".ACTION_UnsetAnimSetDirect( "$thePawn$", "$MeshAnimName$" ) - "$aMeshAnim$" - Deleted");
//			delete(aMeshAnim);
		}
	}
*/
}

function ACTION_UnsetAnimSetAll( string MeshAnimName )
{
	local MeshAnimation	aMeshAnim;
	local Pawn			aPawn;
	
	foreach AllActors( class'Pawn', aPawn )
	{
		if (MeshAnimation(aPawn.GetSkelAnimByName( MeshAnimName )) != None)
		{
			aMeshAnim = MeshAnimation(aPawn.UnlinkSkelAnimByName( MeshAnimName, false ));
		}
	}
		
	SLog(self$".ACTION_UnsetAnimSetAll( "$MeshAnimName$" ) - "$aMeshAnim$" - Deleted");
	delete(aMeshAnim);
}

// GBX:PAD: Values for bTeleportAtAnimEnd:
// 0: No teleport
// 1: Teleport to relative offset of last animation
// 2: Teleport and rotate to relative offset of last animation
// 3: Teleport to relative offset between first and last frame of next animation
// 4: Teleport and rotate to relative offset between first and last frame of next animation

function ACTION_PlayAnim(
	name pawnTag,
	name BaseAnim,
	float BlendInTime,
	float AnimRate,
	optional bool bLoopAnim,
	optional float StartFrame,
	optional string MeshAnimName,
	optional byte bTeleportAtAnimEnd )
{
	local Pawn thePawn;
	local bool	bPlayed;

	if( pawnTag == '' )
	{
		return;
	}

//	thePawn = Pawn( GetFirstActor( pawnTag ));
	bPlayed = false;
	foreach AllActors( class'Pawn', thePawn, pawnTag )
	{
		if( thePawn != None )
		{
			ACTION_PlayAnimDirect( thePawn, BaseAnim, BlendInTime, AnimRate, bLoopAnim, StartFrame, MeshAnimName, bTeleportAtAnimEnd );
			bPlayed = true;
		}
//		else
//		{
//			SetSucceeded( false );
//		}
	}
	if (!bPlayed)
	{
		SetSucceeded( false );
	}
	else
	{
		SetSucceeded( true );
	}
}

function ACTION_PlayAnimDirect(
	Pawn thePawn,
	name BaseAnim,
	float BlendInTime,
	float AnimRate,
	optional bool bLoopAnim,
	optional float StartFrame,
	optional string MeshAnimName,
	optional byte bTeleportAtAnimEnd )
{
	local AnimPawn	APawn;
	local MeshAnimation	aMeshAnim;

	if( thePawn == None )
	{
		SLog( name $ ".ACTION_PlayAnim( '" $ thePawn.Tag $ "', ... ): no actor with that tag found."  );
		SetSucceeded( false );
	}
	else if( BaseAnim == '' )
	{
		SLog( name $ ".ACTION_PlayAnim( '" $ thePawn.Tag $ "', ... ): no animation specified."  );
		SetSucceeded( false );
	}
	else if( (ScriptedController( thePawn.Controller ) == None) && (PlayerController( thePawn.Controller ) == None) )
	{
		SLog( name $ ".ACTION_PlayAnim( '" $ thePawn.Tag $ "', ... ): found that pawn's controller is not a ScriptedController."  );
		SetSucceeded( false );
	}
	else
	{
		// TODO No support for looping.
		APawn = AnimPawn( thePawn );
		
		if (APawn != None)
		{
			if (MeshAnimName != "")
			{
				aMeshAnim = MeshAnimation(DynamicLoadObject(MeshAnimName,class'MeshAnimation'));
				if (aMeshAnim != None)
				{
					if (APawn.LinkSkelAnim(aMeshAnim))
					{
						APawn.MeshAnim = aMeshAnim;
						APawn.MeshAnimName = MeshAnimName;
						APawn.CurMeshAnimName = APawn.MeshAnimName;
					}
					APawn.bInitializeAnimation = false;
				}
			}
		}

		ScriptedController( thePawn.Controller ).bControlAnimations = true;

		if ((thePawn.m_bTeleportAtAnimEnd > 0)&& (bTeleportAtAnimEnd == 0))
			bTeleportAtAnimEnd = thePawn.m_bTeleportAtAnimEnd;
		if (bLoopAnim)
		{
			thePawn.LoopAnim( BaseAnim, AnimRate, BlendInTime,,, bTeleportAtAnimEnd );
		}
		else
		{
			thePawn.PlayAnim( BaseAnim, AnimRate, BlendInTime,,, bTeleportAtAnimEnd );
		}

		if( StartFrame > 0.0 )
		{
			thePawn.SetAnimFrame( StartFrame, 0, 1 );
		}

		SetSucceeded( true );
	}
}

function ACTION_PlayAnimWithQueue(
	name pawnTag,
	name BaseAnim,
	float BlendInTime,
	float AnimRate,
	optional bool bLoopAnim,
	optional float StartFrame,
	optional byte bTeleportToRoot )
{
	local AnimPawn thePawn;
	thePawn = AnimPawn( GetFirstActor( pawnTag ));

	if( thePawn != None )
	{
		ACTION_PlayAnimWithQueueDirect( thePawn, BaseAnim, BlendInTime, AnimRate, bLoopAnim, StartFrame, bTeleportToRoot );
	}
	else
	{
		SetSucceeded( false );
	}
}

function ACTION_PlayAnimWithQueueDirect(
	AnimPawn thePawn,
	name BaseAnim,
	float BlendInTime,
	float AnimRate,
	optional bool bLoopAnim,
	optional float StartFrame,
	optional byte bTeleportToRoot )
{
	if( thePawn == None )
	{
		SLog( name $ ".ACTION_PlayAnimWithQueue( '" $ thePawn.Tag $ "', ... ): no actor with that tag found."  );
		SetSucceeded( false );
	}
	else if( BaseAnim == '' )
	{
		SLog( name $ ".ACTION_PlayAnimWithQueue( '" $ thePawn.Tag $ "', ... ): no animation specified."  );
		SetSucceeded( false );
	}
	else if( (ScriptedController( thePawn.Controller ) == None) && (PlayerController( thePawn.Controller ) == None) )
	{
		SLog( name $ ".ACTION_PlayAnimWithQueue( '" $ thePawn.Tag $ "', ... ): found that pawn's controller is not a ScriptedController."  );
		SetSucceeded( false );
	}
	else
	{
		if ((thePawn.m_bTeleportAtAnimEnd > 0)&& (bTeleportToRoot == 0))
			bTeleportToRoot = thePawn.m_bTeleportAtAnimEnd;
		if (bLoopAnim)
		{
			thePawn.AddAnimToQueue( BaseAnim, SCRIPTED_ANIM_QUEUE_LOOP_PRIORITY, true, bLoopAnim, false, AnimRate, BlendInTime,,,,,,,, bTeleportToRoot );
		}
		else
		{
			thePawn.AddAnimToQueue( BaseAnim, SCRIPTED_ANIM_QUEUE_PRIORITY, true, bLoopAnim, false, AnimRate, BlendInTime,,,,,,,, bTeleportToRoot );
		}

		SetSucceeded( true );
	}
}

function ACTION_FlushAnimQueue( name pawnTag )
{
	local Pawn thePawn;
	thePawn = Pawn( GetFirstActor( pawnTag ));

	ACTION_FlushAnimQueueDirect( thePawn );
}

function ACTION_FlushAnimQueueDirect( Pawn thePawn )
{
	if( thePawn == None )
	{
		SLog( name $ ".ACTION_PlayAnimWithQueue( '" $ thePawn.name $ "', ... ): no actor with that tag found."  );
		SetSucceeded( false );
	}
	else if( ScriptedController( thePawn.Controller ) == None )
	{
		SLog( name $ ".ACTION_PlayAnimWithQueue( '" $ thePawn.name $ "', ... ): found that pawn's controller is not a ScriptedController."  );
		SetSucceeded( false );
	}
	else if( AnimPawn( thePawn ) == None )
	{
		SLog( name $ ".ACTION_PlayAnimWithQueue( '" $ thePawn.name $ "', ... ): found that pawn is not an AnimPawn."  );
		SetSucceeded( false );
	}
	else
	{
		AnimPawn(thePawn).FlushAnimQueueChannel( 0,,true );
		SetSucceeded( true );
	}
}

function ACTION_SetLookAtTarget( name actorTag, Actor LookAt, bool bFreeze, optional name LookAtBone )
{
	local Actor A;

	A = GetFirstActor( actorTag );

	ACTION_SetLookAtTargetDirect( A, LookAt, bFreeze, LookAtBone );
}

function ACTION_SetLookAtTargetDirect( Actor A, Actor LookAt, bool bFreeze, optional name LookAtBone )
{
	if( gbxPawn(A) != None )
	{
		SLog( name $ ".ACTION_SetLookAtTarget( '" $ A.name $ "', " $ LookAt.tag $ " )"  );
		gbxPawn(A).SetLookingAtTarget( LookAt );

		if( bFreeze )
			gbxPawn(A).bDontLookAtPlayers = true;

		gbxPawn(A).m_szLookBoneName = LookAtBone;

		SetSucceeded( true );
	}
	else
	{
		SLog( name $ ".ACTION_SetLookAtTarget( '" $ A.name $ "', " $ LookAt.name $ " ): actor tag not found."  );
		SetSucceeded( false );
	}
}

function ACTION_ClearLookAtTarget( name actorTag )
{
	local Actor A;

	A = GetFirstActor( actorTag );

	ACTION_ClearLookAtTargetDirect( A );
}

function ACTION_ClearLookAtTargetDirect( Actor A )
{
	if( gbxPawn(A) != None )
	{
		gbxPawn(A).bDontLookAtPlayers = false;
		gbxPawn(A).SetLookingAtTarget( None );
		SetSucceeded( true );
	}
	else
	{
		SetSucceeded( false );
	}
}

// SJP: 11/14/2003 Added PlayerBreak to allow player to interupt script with button input
function ACTION_EnablePlayerBreak()
{
	bEnablePlayerBreak = true;
	GetLocalPlayerController().bWaitingForPlayerBreak = true;
}

function ACTION_DisablePlayerBreak()
{
	bEnablePlayerBreak = false;
	GetLocalPlayerController().bWaitingForPlayerBreak = false;
}

// PSV: 11/12/2003	Added new utility functions

// Remove only the weapons...this will leave grenades, etc.
function ACTION_StripAllWeapons( Pawn pawnToStrip )
{
	local inventory Inv;
	local gbxPawn gbxPawnToStrip;
	local int x;

	// Don't assume this is a valid Pawn
	if ( pawnToStrip != NONE )
	{
		// Reset FOV to default
		GetLocalPlayerController().StopZoom();
		GetLocalPlayerController().ChangeView(0);

		// Strip weapons
		for ( Inv = pawnToStrip.Inventory; Inv != None; Inv = Inv.Inventory )
		{
			if ( Weapon( Inv ) != NONE )
			{
				SLog("Stripping " $Inv );
				pawnToStrip.DeleteInventory(Inv);
			}
		}

		// Strip items (grenades, etc)
		if ( gbxPawn(pawnToStrip) != NONE )
		{
			gbxPawnToStrip = gbxPawn(pawnToStrip);

			SLog("Stripping " $gbxPawnToStrip.Weapon.name );

			gbxPawnToStrip.PendingWeapon = NONE;
			gbxPawnToStrip.SetWeapon(None);

			for( x = 0; x < gbxPawnToStrip.MAX_SECONDARY_BUCKETS; x++ )
			{
				for( Inv = gbxPawnToStrip.SecondaryInventory[x]; Inv != None; Inv = Inv.Inventory )
				{
					if ( gbxWeapon( Inv ) != None )
					{
						gbxPawnToStrip.DeleteInventory( Inv );
					}
				}
			}

			gbxPawnToStrip.PendingSecondaryWeapon = NONE;
			gbxPawnToStrip.SecondaryWeapon = NONE;
		}

		gbxPawnToStrip.PawnAnimInfoClass=class'PawnAnimInfoFinalUnarmed';
	}
}

// Remove EVERYTHING from the pawn
function ACTION_StripAllWeaponsAndInventory( Pawn pawnToStrip )
{
	local inventory Inv;
	local gbxPawn gbxPawnToStrip;
	local int x;

	// Don't assume this is a valid Pawn
	if ( pawnToStrip != NONE )
	{
		// Reset FOV to default
		GetLocalPlayerController().StopZoom();
		GetLocalPlayerController().ChangeView(0);

		// Strip weapons
		for ( Inv = pawnToStrip.Inventory; Inv != None; Inv = Inv.Inventory )
		{
			if ( Weapon( Inv ) != NONE )
			{
				SLog("Stripping " $Inv );
				pawnToStrip.DeleteInventory(Inv);
			}
		}

		// Strip items (grenades, etc)
		if ( gbxPawn(pawnToStrip) != NONE )
		{
			gbxPawnToStrip = gbxPawn(pawnToStrip);

			gbxPawnToStrip.PendingWeapon = NONE;
			gbxPawnToStrip.SetWeapon(None);

			for( x = 0; x < gbxPawnToStrip.MAX_SECONDARY_BUCKETS; x++ )
			{
				for( Inv = gbxPawnToStrip.SecondaryInventory[x]; Inv != None; Inv = Inv.Inventory )
				{
					if (gbxWeapon( Inv ) != None || gbxUsableItem( Inv ) != None)
					{
						gbxPawnToStrip.DeleteInventory( Inv );
					}
				}
			}

			gbxPawnToStrip.PendingSecondaryWeapon = NONE;
			gbxPawnToStrip.SecondaryWeapon = NONE;
		}
	}
}

// Note: Syntax for weaponClassName is PackageName.ClassName
// All weapons, use this format: "gbxInventory.<Name>"
// WeapDEK98_
// WeapDEMP40_
// WeapUSBar
// WeapUSColt1911_
// WeapUSM1_
// WeapUSThompson
function ACTION_GivePlayerWeapon( Pawn playerPawn, string weaponClassName )
{
	local class<Weapon> weaponClass;
	local Weapon newWeapon;

	// Don't assume this is a valid Pawn
	if ( playerPawn != NONE )
	{
		playerPawn.GiveWeapon( weaponClassName );

		WeaponClass = class<Weapon>(DynamicLoadObject(weaponClassName, class'Class'));

		if( playerPawn.FindInventoryType(weaponClass) != None )
			SLog( "ACTION_GivePlayerWeapon: Error switching to " $weaponClassName  );

		newWeapon = Weapon(playerPawn.FindInventoryType(weaponClass));
		playerPawn.Controller.SwitchToBestWeapon();
	}
}

// Note: This will keep player from moving forward/back, but still allow them to look around
function ACTION_LockPlayerMovement( Pawn playerPawn )
{
	// Don't assume this is a valid Pawn
	if ( playerPawn != NONE )
	{
		playerPawn.accelRate = 0.0;
		playerPawn.bCanCrouch = false;
	}
}

// Give movement ability back to player
function ACTION_UnlockPlayerMovement( Pawn playerPawn )
{
	// Don't assume this is a valid Pawn
	if ( playerPawn != NONE )
	{
		playerPawn.accelRate = playerPawn.default.accelRate;
		playerPawn.bCanCrouch = playerPawn.default.bCanCrouch;
	}
}

function ACTION_WakeKarmaActor( name karmaActorTag )
{
	local Actor karmaActor;

	karmaActor = GetFirstActor( karmaActorTag );

	ACTION_WakeKarmaActorDirect( karmaActor );
}

function ACTION_WakeKarmaActorDirect( Actor karmaActor )
{
	if (karmaActor == None)
	{
		SLog( name $ ".ACTION_WakeKarmaActor( '" $ karmaActor.name $ "' ): no Karma Actor with that tag found."  );
		SetSucceeded( false );
	}

	karmaActor.KWake();

	SetSucceeded( true );
}

function ACTION_PushKarmaActor( name karmaActorTag, float pushForce, name targetActorTag, optional rotator pushRotation )
{
	local Actor karmaActor;
	local Actor targetActor;

	karmaActor = GetFirstActor( karmaActorTag );

	if (karmaActor == None)
	{
		SLog( name $ ".ACTION_PushKarmaActor( '" $ karmaActorTag $ "' ): no Karma Actor with that tag found."  );
		SetSucceeded( false );
	}

	if (targetActorTag != '')
	{
		targetActor = GetFirstActor( targetActorTag );

		if (targetActor == None)
		{
			SLog( name $ ".ACTION_PushKarmaActor( '" $ targetActorTag $ "' ): no Target Actor with that tag found."  );
			SetSucceeded( false );
		}

	}

	ACTION_PushKarmaActorDirect( karmaActor, pushForce, targetActor, pushRotation );
}

function ACTION_PushKarmaActorDirect( Actor karmaActor, float pushForce, Actor targetActor, optional rotator pushRotation )
{
	local vector v_push, PushAngVel;

	if (targetActor != None)
	{
		v_push = Normal(targetActor.Location - karmaActor.Location);
	}
	else  // use PushRotation as direction...
	{
		v_push = Vector(PushRotation);
	}

	v_push = v_push * PushForce;

	karmaActor.KWake();
	//karmaActor.KAddImpulse(v_push, karmaActor.Location);
	//PushAngVel = Normal(Normal(v_push) Cross vect(1, 0, 1)) * pushForce;
	PushAngVel = Normal(v_push) Cross ( Normal(v_push) * vect(1,1,0)) * pushForce;
	karmaActor.KSetSkelVel( v_push, PushAngVel );
	karmaActor.KAddImpulse(v_push, karmaActor.Location);

	//(hitLocRel Cross ( Normal(shotDir * vect(1,1,0)) * VSize(shotStrength) ));

	SetSucceeded( true );
}

function ACTION_AttachStaticMesh( Pawn aPawn, StaticMesh aMesh, name BoneName )
{
	// Don't assume this is a valid Pawn
	if ( AnimPawn(aPawn) != NONE )
	{
		AnimPawn(aPawn).AttachScriptedAttachment( aMesh, BoneName );
		SetSucceeded( true );
	}
	else
	{
		SLog( name $ ".ACTION_AttachStaticMesh(): Invalid pawn specified for attaching "$aMesh$"."  );
		SetSucceeded( false );
	}
}

function ACTION_DetachStaticMesh( Pawn aPawn, StaticMesh aMesh, name BoneName )
{
	// Don't assume this is a valid Pawn
	if ( AnimPawn(aPawn) != NONE )
	{
		AnimPawn(aPawn).DetachScriptedAttachment( aMesh, BoneName );
		SetSucceeded( true );
	}
	else
	{
		SLog( name $ ".ACTION_AttachStaticMesh(): Invalid pawn specified for attaching "$aMesh$"."  );
		SetSucceeded( false );
	}
}

function ACTION_DropStaticMesh( Pawn aPawn, StaticMesh aMesh, name BoneName )
{
	// Don't assume this is a valid Pawn
	if ( AnimPawn(aPawn) != NONE )
	{
		AnimPawn(aPawn).DropScriptedAttachment( aMesh, BoneName );
	}
}

function ACTION_DetachWeapon( Pawn aPawn, name BoneName )
{
	// Don't assume this is a valid Pawn
	if ( AnimPawn(aPawn) != NONE )
	{
		AnimPawn(aPawn).DetachWeapon( BoneName );
	}
}

function ACTION_ReattachWeapon( Pawn aPawn, name BoneName )
{
	// Don't assume this is a valid Pawn
	if ( AnimPawn(aPawn) != NONE )
	{
		AnimPawn(aPawn).ReattachWeapon( BoneName );
	}
}

function ACTION_SetFriendlyFireScale( float scale )
{
	if( WargameDeathMatch( Level.Game ) != None )
	{
		WargameDeathMatch( Level.Game ).FriendlyFireScale = scale;
	}
}

function ACTION_ChangeController( name pawnTag, class< Controller > aControllerClass )
{
	local Pawn P;
	
	P = Pawn( GetFirstActor( PawnTag ));

	ACTION_ChangeControllerDirect( P, aControllerClass );
}

function ACTION_ChangeControllerDirect( Pawn P, class< Controller > aControllerClass )
{
	local Controller C, OldC;
	local gbxPawn gbxP;
	
	if( P != None && !P.IsDead() )
	{		
		C = Spawn( aControllerClass );

		if( C == None )
		{
			SLog( name $ ".ACTION_ChangeController( '" $ P.name $ "', " $ aControllerClass $ "  ): could not spawn controller of that class."  );

			SetSucceeded( false );
		}
		else
		{
			// Make the prior controller unpossess the pawn.
			if( P.Controller != None )
			{
				if (P.Controller.IsA('ScriptedController'))
				{
					gbxP = gbxPawn( P );
					gbxP.m_bDisableAnimQueue = false;
					gbxP.FlushAnimQueueChannel( 0, true );
					gbxP.ClearIdleQueue();
					gbxP.m_fRunNextQueueIdle = false;
					gbxP.bDoHeadTurn = true;
					gbxP.SetLookAtTarget( None );
					gbxP.bDontLookAtPlayers = false;
					//GBX:PAD: I'm going to go ahead and reset these two values as well when the controller is changed
					// from being a scripted controller since, if they are accidentally left on, guys will glide instead of run.
					gbxP.bNoTurnBody = false;
					gbxP.m_fDispositionAnimPlaying = false;
				}
				
				OldC = P.Controller;

				// GBX:RSC - copy the old controller's destination to the new controller
				C.Destination = P.Controller.Destination;

				P.Controller.UnPossess();
				if ( OldC != None )
				{
					OldC.Destroy();
				}
			}

			C.Possess( P );

			SetSucceeded( true );
		}
	}
	else
	{
		SLog( name $ ".ACTION_ChangeController( '" $ P.name $ "', ... ): pawn tag not found or pawn is dead."  );

		SetSucceeded( false );
	}
}

function ACTION_LimitPlayerInput( WargamePlayerController playerController, bool bLimited )
{
	if (playerController != None)
		playerController.LimitPlayerInput( bLimited );
}

function ACTION_DesaturateCamera( optional byte DesaturationAmount )
{
	GetLocalPlayerController().BeginCamDesaturation( DesaturationAmount );
}

function ACTION_EndDesaturateCamera()
{
	GetLocalPlayerController().EndCamDesaturation();
}

// WIDESCREEN_SLIDE_TIME = 2.0f;
// NO_WIDESCREEN = 0;
// WIDESCREEN_SLIDE_ON = 1;
// WIDESCREEN_SLIDE_OFF = 2;
// WIDESCREEN_ON = 4;
function ACTION_WideScreenOverlay( WargamePlayerController playerController, byte bWideScreen )
{
	if (WargameHUD(playerController.MyHUD) != None)
	{
		Level.m_bWideScreen = bWideScreen;
		Level.m_flStartWideScreenTime = Level.TimeSeconds;
		SLog(self$".ACTION_WideScreenOverlay( "$playerController$", "$bWideScreen$" )" );
	}
}

function ACTION_CinematicBegin()
{
	Level.m_bInCinematic = true;
}

function ACTION_CinematicEnd()
{
	Level.m_bInCinematic = false;
}

// NO_FADE = 0;
// FADE_TO_BLACK = 1;
// FADE_FROM_BLACK = 2;
// FADE_START_BLACK = 3;
function ACTION_FadeOverlay( WargamePlayerController playerController, byte bFadeType, float flFadeTime, optional bool bDontAdjustSoundCategories )
{
	if (WargameHUD(playerController.MyHUD) != None)
	{
		Level.m_bFadeScreen = bFadeType;
		Level.m_flFadeTime = flFadeTime;
		Level.m_flStartFadeTime = Level.TimeSeconds;

		if ( !bDontAdjustSoundCategories )
		{
			if ( Level.m_bFadeScreen == 2 )
			{
				SLog( self$ " ACTION_FadeOverlay  FADE_FROM_BLACK", 'DevSound' );
				playerController.EnableSoundCategory( ESoundCategory.SC_AMBIENT,	true, 1.5 );	
				playerController.EnableSoundCategory( ESoundCategory.SC_CINEMATIC, true, 1.5 );
				playerController.EnableSoundCategory( ESoundCategory.SC_SOUNDFX,	true, 1.5 );	
			}
			else if ( Level.m_bFadeScreen == 3 )
			{
				SLog( self$ " ACTION_FadeOverlay  FADE_START_BLACK", 'DevSound' );
				playerController.EnableSoundCategory( ESoundCategory.SC_AMBIENT,	false, 0.0 );	
				playerController.EnableSoundCategory( ESoundCategory.SC_CINEMATIC, false, 0.0 );
				playerController.EnableSoundCategory( ESoundCategory.SC_SOUNDFX,	false, 0.0 );	
			}
			else if ( Level.m_bFadeScreen == 1 )
			{
				SLog( self$ " ACTION_FadeOverlay  FADE_TO_BLACK", 'DevSound' );
				playerController.EnableSoundCategory( ESoundCategory.SC_AMBIENT,	false, 1.5 );	
				playerController.EnableSoundCategory( ESoundCategory.SC_CINEMATIC, false, 1.5 );
				playerController.EnableSoundCategory( ESoundCategory.SC_SOUNDFX,	false, 1.5 );
			}
		}

		SLog(self$".ACTION_FadeOverlay( "$playerController$", "$bFadeType$", "$flFadeTime$" )" );
	}
}

function ACTION_ScreenOverlay( WargamePlayerController playerController, Material aScreenOverlay, optional float xPos, optional float yPos, optional byte bFadeType, optional float flFadeTime, optional float USize, optional float VSize, optional int nJustifyHorz, optional int nJustifyVert )
{
	Level.m_aScreenOverlay = aScreenOverlay;
	if (aScreenOverlay != None)
	{
		Level.m_flScreenOverlayX = xPos;
		Level.m_flScreenOverlayY = yPos;
		if ((USize == 0.0) || (VSize == 0.0))
		{
			Level.m_flScreenOverlayU = Texture(aScreenOverlay).USize;
			Level.m_flScreenOverlayV = Texture(aScreenOverlay).VSize;
		}
		else
		{
			Level.m_flScreenOverlayU = USize;
			Level.m_flScreenOverlayV = VSize;
		}
		Level.m_nJustifyOverlayHorz = nJustifyHorz;
		Level.m_nJustifyOverlayVert = nJustifyVert;
		Level.m_bFadeOverlay = bFadeType;
		Level.m_flFadeOverlayTime = flFadeTime;
		Level.m_flStartFadeOverlayTime = Level.TimeSeconds;
	}
}

function ACTION_ChangeMapIntroText( WargamePlayerController playerController, coerce string Title, coerce string TitleLocation, coerce string TitleDate, optional bool bSimpleIntro )
{
	if (WargameHUD(playerController.MyHUD) != None)
	{
		if (Title != "")
		{
			Level.Title = Title;
		}
		if (TitleLocation != "")
		{
			Level.TitleLocation = TitleLocation;
		}
		if (TitleDate != "")
		{
			Level.TitleDate = TitleDate;
		}
		Level.m_bSimpleIntro = bSimpleIntro;
	}
}

function ACTION_MapIntroText( WargamePlayerController playerController, byte bFadeType, float flFadeTime )
{
	if (WargameHUD(playerController.MyHUD) != None)
	{
		Level.m_bFadeMapIntro = bFadeType;
		Level.m_flMapIntroTime = flFadeTime;
		Level.m_flMapIntroStartTime = Level.TimeSeconds;
		SLog(self$".ACTION_MapIntroText( "$playerController$", "$bFadeType$", "$flFadeTime$" )" );
	}
}

function ACTION_MapIntroTextPos( WargamePlayerController playerController, int xPos, int yPos )
{
	SLog(self$".ACTION_MapIntroTextPos Disabled" );
/*	
	if (WargameHUD(playerController.MyHUD) != None)
	{
		Level.m_nMapIntroX = xPos;
		Level.m_nMapIntroY = yPos;
	}
*/
}

function ACTION_HeadLookAt( Pawn aPawn, bool bLookAt )
{
	if (AnimPawn( aPawn ) != None)
	{
		AnimPawn( aPawn ).bDoHeadTurn = bLookAt;
	}
}

function ACTION_SetHorizonTracerTarget( name TargetTagName, name HorizonTagName )
{
	local actor aTarget;

	local HorizonTracers HGun;
	local bool bUpdatedTarget;

	foreach AllActors( class'Actor', aTarget, TargetTagName )
	{
		break;
	}

	if( aTarget != None )
	{
		foreach AllActors( class'HorizonTracers', HGun, HorizonTagName )
		{
			HGun.UpdateTracerTarget( aTarget );
			bUpdatedTarget = true;
		}

		if( !bUpdatedTarget )
		{
			SLog( name $ ".ACTION_SetHorizonTracerTarget(" $ TargetTagName $ ", " $ HorizonTagName $ ") Could not find HorizonTracer actor with specified tagname."  );
		}
	}
	else
	{
		SLog( name $ ".ACTION_SetHorizonTracerTarget: Could not find specified Actor."  );
	}
}

function ACTION_RemoveHorizonTracerTarget( name TagName )
{
	local bool bFoundTag;
	local HorizonTracers HGun;

	foreach AllActors( class'HorizonTracers', HGun, TagName )
	{
		HGun.RemoveTracerTarget();
		bFoundTag = true;
	}

	if( !bFoundTag )
	{
		SLog( name $ ".ACTION_RemoveHorizonTracerTarget(" $ TagName $ ") Could not find HorizonTracer actor with specified tagname."  );
	}
}

function ACTION_MakeHorizonTracerFire( name TagName )
{
	local bool bFoundTag;
	local HorizonTracers HGun;

	foreach AllActors( class'HorizonTracers', HGun, TagName )
	{
		if( HGun.IsInState('Pausing') )
		{
			HGun.GotoState('Firing');
		}

		bFoundTag = true;
	}

	if( !bFoundTag )
	{
		SLog( name $ ".ACTION_RemoveHorizonTracerTarget(" $ TagName $ ") Could not find HorizonTracer actor with specified tagname."  );
	}
}

// GBX:RSC - add TNT polling
function bool IsTNTPlanted( name TurretTag )
{
	local TurretWeapon Turret;
	foreach DynamicActors( class'TurretWeapon', Turret, TurretTag )
	{
		return IsTNTPlantedDirect( Turret );
	}

	return false;
}

function bool IsTNTPlantedDirect( TurretWeapon Turret )
{
	return Turret.HasTNTBeenPlanted();
}

function ACTION_ForceTurretDismount( name TurretTag, optional bool bDoNothingIfHumanControlled )
{
	local Actor MaybeTurret;

	MaybeTurret = GetFirstActor( TurretTag );

	ACTION_ForceTurretDismountDirect( MaybeTurret, bDoNothingIfHumanControlled );
}

function ACTION_ForceTurretDismountDirect( Actor MaybeTurret, optional bool bDoNothingIfHumanControlled )
{
	local TurretWeapon Turret;

	// Argh, lots of casting going on here.  If I had made all 'turret factory' actors descendants
	// of a common class, this would be trivial--but I did not...
	if ( MaybeTurret.IsA( 'TurretWeapon' ) )
	{
		Turret = TurretWeapon( MaybeTurret );
	}
	else if ( MaybeTurret.IsA( 'MG42Factory' ) )
	{
		Turret = MG42Factory( MaybeTurret ).Gun;
	}
	else if ( MaybeTurret.IsA( 'MortarFactory' ) )
	{
		Turret = MortarFactory( MaybeTurret ).Gun;
	}
	else if ( MaybeTurret.IsA( 'Pak36Factory' ) )
	{
		Turret = Pak36Factory( MaybeTurret ).Gun;
	}
	else if ( MaybeTurret.IsA( 'FlakvierlingFactory' ) )
	{
		Turret = FlakvierlingFactory( MaybeTurret ).Gun;
	}

	else if ( MaybeTurret.IsA( 'PAK88Factory' ) )
	{
		Turret = PAK88Factory( MaybeTurret ).Gun;
	}

	Turret.NotifyForceDismount( bDoNothingIfHumanControlled );
}

function ACTION_DisableTurret( name TurretTag )
{
	local Actor MaybeTurret;

	MaybeTurret = GetFirstActor( TurretTag );

	ACTION_DisableTurretDirect( MaybeTurret );
}

function ACTION_DisableTurretDirect( Actor MaybeTurret )
{	
	local TurretWeapon Turret;

	if ( MaybeTurret.IsA( 'TurretWeapon' ) )
	{
		Turret = TurretWeapon( MaybeTurret );
	}
	else if ( MaybeTurret.IsA( 'MG42Factory' ) )
	{
		Turret = MG42Factory( MaybeTurret ).Gun;
	}

	Turret.EnableTurret( false );
}

function ACTION_EnableTurret( name TurretTag )
{
	local Actor MaybeTurret;

	MaybeTurret = GetFirstActor( TurretTag );

	ACTION_EnableTurretDirect( MaybeTurret );
}

function ACTION_EnableTurretDirect( Actor MaybeTurret )
{
	local TurretWeapon Turret;

	if ( MaybeTurret.IsA( 'TurretWeapon' ) )
	{
		Turret = TurretWeapon( MaybeTurret );
	}
	else if ( MaybeTurret.IsA( 'MG42Factory' ) )
	{
		Turret = MG42Factory( MaybeTurret ).Gun;
	}

	Turret.EnableTurret( true );
}

function ACTION_SetTurretDestroyed( name TurretTag )
{
	local TurretWeapon Turret;

	foreach AllActors( class'TurretWeapon', Turret, TurretTag )
	{
		Turret.SetBlownUp();
	}
	
}

function ACTION_CameraInPawnHead( name PawnTag, name SceneTag, bool bEnabled )
{
	local AnimPawn	aPawn;
	local WargamePlayerController aPlayer;
	local SceneManager aScene;
	
	aPlayer = GetLocalPlayerController();
	if (SceneTag == '')
		aPawn = AnimPawn(aPlayer.Pawn);
	else
		aPawn = AnimPawn(GetPawn( PawnTag ));
	if ((aPawn != None) && (aPlayer != None))
	{
		aPlayer.bBehindView = bEnabled;
		aPawn.bSpecialCalcView = bEnabled;
		if (WargamePawn(aPawn) != None)
			WargamePawn(aPawn).bScriptedCamInHead = bEnabled;
		if (bEnabled)
		{
			aPawn.accelRate = 0.0;
			aPlayer.ScriptViewRestriction = rot(5461, 8191, 0);
		}
		else
		{
			aPawn.accelRate = aPawn.default.accelRate;
		}

		if(SceneTag != '')
		{
			ForEach aPlayer.AllActors(class'SceneManager', aScene, SceneTag)
			{
				aScene.bCameraInPlayerHead = bEnabled;
				aScene.PlayerAttachBone = 'c_eyebrow';
				if (bEnabled)
				{
					aScene.PlayerBody = aPawn;
					aPlayer.m_MatineeScript = aScene;
					aScene.PlayerInput = aPlayer;
				}
				else
				{
					aScene.PlayerBody = None;
					aPlayer.m_MatineeScript = None;
					aScene.PlayerInput = None;
				}
			}
		}
	}
}

function ACTION_PlayerToCameraPawn( name PawnTag )
{
	local gbxPlayerPawn		aPlayerPawn;
	local AnimPawn	aPawn;
	local WargamePlayerController aPlayer;
	local Vector	VecViewOffset;
	local float		ViewOffset;
	local Rotator	aRotation;
	
	aPlayer = GetLocalPlayerController();
	aPlayerPawn = gbxPlayerPawn( aPlayer.Pawn );
	aPawn = AnimPawn(GetPawn( PawnTag ));
	
	if (aPlayerPawn == None)
	{
		foreach AllActors( class'gbxPlayerPawn', aPlayerPawn )
			break;
	}
	if ((aPawn != None) && (aPlayerPawn != None))
	{
		aPawn.GetBoneCoords( 'c_eyebrow' );
		aPawn.GetBoneRotation( 'c_eyebrow' );
		ViewOffset = aPlayerPawn.BaseEyeHeight - (aPlayerPawn.CollisionHeight / 2);
		VecViewOffset = aPlayer.m_MatineeScript.Viewer.Location;
		VecViewOffset.Z = VecViewOffset.Z - ViewOffset;
		aPlayerPawn.SetLocation( VecViewOffset );
		aPlayer.SetLocation( VecViewOffset );
		// GBX:PAD: This is a bit weird, but I'm setting the pawn with this full rotation instead of just yaw because
		// the matinee script is going to call Possess after it finishes, which sets the controller rotation to the
		// pawns angle.  If we throw away the pitch here, the view will pop a bunch, and we don't want that.
		aRotation.Yaw = aPlayer.Rotation.Yaw;
		aPlayerPawn.SetRotation( aRotation );
		aPlayerPawn.SetViewRotation(aPlayer.Rotation);
		aPlayer.ScriptViewOffset = rot(0.0, 0.0, 0.0);
		aPlayer.ResetShakeView();
		SLog(self$".ACTION_PlayerToCameraPawn( "$PawnTag$" ) - "$aPlayerPawn.Location);
	}
}

function ACTION_PauseScene( name SceneTag, bool bRunning )
{
	local SceneManager aScene;

	if(SceneTag != 'None')
	{
		ForEach AllActors(class'SceneManager', aScene, SceneTag)
		{
			aScene.bIsRunning = bRunning;
		}
	}
}

function ACTION_StopScene( name SceneTag, name NextSceneTag )
{
	local SceneManager aScene;

	if(SceneTag != 'None')
	{
		ForEach AllActors(class'SceneManager', aScene, SceneTag)
		{
//			aScene.PctSceneComplete = 1.0f;
			aScene.CurrentTime = aScene.TotalSceneTime;
			aScene.NextSceneTag = NextSceneTag;
			aScene.bLooping = false;
		}
	}
}

function ACTION_HideWargameHUD( bool bHide )
{
	local WargamePlayerController	aPlayer;
	local gbxHUD					aHUD;
	
	aPlayer = GetLocalPlayerController();

	if (aPlayer != None)
	{
		aHUD = gbxHUD(aPlayer.MyHUD);
		
		if (aHUD != None)
		{
			if (bHide)
			{
				aHUD.bHideWargameHUD = true;
				if (aPlayer.Pawn.Weapon != None)
					aPlayer.Handedness = 2;
			}
			else
			{
				aHUD.bHideWargameHUD = false;
				if (aPlayer.Pawn.Weapon != None)
					aPlayer.Handedness = 0;
			}
		}
	}
}

// flFadeOutTime of 0.0 will stop all sounds immediately,
// any positive amount will cause all sounds to fade out 
// by that time.
function ACTION_FadeAllSounds( float flFadeOutTime )
{
	StopAllSounds( flFadeOutTime );
}

// This controls how much time passes before all non-cinematic 
// sounds are fade back into their desired gain.(Default is 2.0)
function ACTION_SetCinematicFadeInTime( float flFadeInTime )
{
	SetCinematicFadeInTime( flFadeInTime );
}

// This controls how much time passes before all non-cinematic 
// sounds are playing at what is set by SetSoundGainDuringCinematic()
// (Default is 2.0)
function ACTION_SetCinematicFadeOutTime( float flFadeOutTime )
{
	SetCinematicFadeOutTime( flFadeOutTime );
}

// Default cinematic gain is 0.2, I exposed this in case 
// there is a circumstance where you want everything to go to 
// silence.  Otherwise, Dave says 0.2 should be the default.
function ACTION_SetSoundGainDuringCinematic( float flGain )
{
	SetSoundGainDuringCinematic( flGain );
}

function ACTION_SetPlayerBlownDownAnim( name szBlownDownAnimName )
{
	local gbxPlayerPawn	aPawn;
	
	aPawn = gbxPlayerPawn(GetLocalPlayerPawn());
	if (aPawn != None)
		aPawn.m_szBlownDownAnimOverride = szBlownDownAnimName;
}

function ACTION_EnablePlayerHeavyTrauma( bool bEnabled )
{
	local WargamePlayerController aPlayer;
	
	aPlayer = GetLocalPlayerController();
	if (aPlayer != None)
	{
		aPlayer.EnableHeavyTrauma( bEnabled );
	}
}

function ACTION_KillPawn( name victimTag, optional vector impactDirection, optional name impactBone, optional name whoToBlameTag )
{
	local Pawn victim, whoToBlame;
	local vector impactLocation;
	local int		i;

	i = 0;
	foreach AllActors( class'Pawn', victim, victimTag )
	{
		if( victim != None )
		{
			whoToBlame = GetPawn( whoToBlameTag );

			SLog( whoToBlame );

			impactLocation = victim.Location;

			if( impactBone != '' )
			{
				impactLocation = victim.GetBoneCoords( impactBone ).Origin;
			}

			victim.Health = 0;
			if ( victim.bPhysicsAnimUpdate )
				victim.TearOffMomentum = impactDirection * 5000;
			victim.Died(whoToBlame.Controller, class'DamageDEK98_', impactLocation);
			
			i++;
		}
		else
		{
			SLog( "Couldn't find victim '" $ victim $ "'." );
		}
	}
	if (i == 0)
	{
		SLog( "Couldn't find victim '" $ victim $ "'." );
	}
}

function bool ACTION_IsFirstRun()
{
	// going to assume first-run if no profiles exist!
	return class'Engine.GameProfile'.Static.GetProfileCount(Level, true) == 0;
}

function ACTION_DisplayVictory()
{
	ConsoleCommand("PLAYMOVIECAPTIONED" @VictoryMovieFile @"0 1 0 0 0 640 480");

	Level.MissionManager.MissionCompleted();
	ConsoleCommand("disconnect");
}

function ACTION_ChapterCompleteSilent()
{
	Level.MissionManager.MissionCompleted(true);
	Level.MissionManager.LoadSPMap(Level.MissionManager.GetNextMission(), int(Level.DifficultyManager.GetDifficulty()) );
}

function ACTION_DisplayMapStats(optional bool bSkipCompletedScreen)
{
	local WargamePlayerController	aPlayer;
	local string medalResult;
	
	aPlayer = GetLocalPlayerController();
	if (aPlayer != None)
	{
		if (!bSkipCompletedScreen)
		{
			// GBX:CEK: 10/16/2004 - only do the fade out if we're not already faded or fading
			if ((Level.m_bFadeScreen != 1) && (Level.m_bFadeScreen != 3))
				ACTION_FadeOverlay(aPlayer, 1, 2.0);

			// shut off widescreen mode, intro mode, cinematic mode
			ACTION_CinematicEnd();
			ACTION_MapIntroText( aPlayer, 0, 0.0 );

			if (Level.m_bFadeScreen == 3)
			{
				ACTION_WideScreenOverlay(aPlayer, 0);
				medalResult = Level.MissionManager.MissionCompleted();

				aPlayer.DisplayMissionFinished(true, "MEDALS=" $medalResult);
			}
			else
			{
				Level.m_bStatsAfterFade = true;
			}
		}
		else
		{
			medalResult = Level.MissionManager.MissionCompleted();

			Level.MissionManager.LoadSPMap("");
/*
// CEK:FIRSTBOOT
			// disconnect or launch the next map
			if (ACTION_IsFirstRun())
			{
				class'GameEngine'.default.DisconnectMenuClass = class'GameEngine'.default.InitialMenuClass;
				class'GameEngine'.static.StaticSaveConfig();
		        ConsoleCommand("disconnect");
			}
			else
			{
				Level.MissionManager.LoadSPMap("");
			}
*/
		}

		SetSucceeded( true );
	}
}

function ACTION_DisplayMissionFailed()
{
	local WargamePlayerController	aPlayer;
	
	aPlayer = GetLocalPlayerController();
	if (aPlayer != None  && (gbxHUD(aPlayer.myHUD).m_eHudMode != HudModeDead)) //DLEVY fix for bug 9045 check
	{																		  //if already displayed death or mission failed message
		aPlayer.DisplayMissionFinished(false, "NODEATH");
		gbxHUD(aPlayer.myHUD).m_eHudMode = HudModeDead;
		SetSucceeded( true );
	}
}

function ACTION_SetStaticCharacterTarget( name szCharName, name szTarget1, name szTarget2, optional bool fDisableAI, optional bool fTargetVisible )
{
	local Pawn			aChar;
	local Mind			aMind;
	local Actor			aTarget1, aTarget2;

	aChar = GetPawn( szCharName );
	if (aChar == None)
		return;
		
	aMind = Mind(aChar.Controller);
	if (aMind == None)
		return;

	aMind.m_fTargetVisible = fTargetVisible;
	
	if (szTarget1 == '')
	{
		aMind.SetScriptedTargets( None, None );
		aMind.SetTargetMode( aMind.ETargetModes.TargetMode_Normal );
	}
	else
	{
		aTarget1 = GetFirstActor( szTarget1 );
		if (aTarget1 == None)
			return;
			
		if (szTarget2 == '')
		{
			aMind.SetScriptedTargets( aTarget1, None );
			aMind.SetTargetMode( aMind.ETargetModes.TargetMode_SingleTarget );
		}
		else
		{
			aTarget2 = GetFirstActor( szTarget2 );
			if (aTarget2 == None)
				return;
			aMind.SetScriptedTargets( aTarget1, aTarget2 );
			aMind.SetTargetMode( aMind.ETargetModes.TargetMode_Sweep );
		}
	}
	aMind.m_fDisableAI = fDisableAI;
	if (fDisableAI)
		aMind.RemoveAllTargetsFromQueue();
}

function ACTION_SetStaticCharacterToMesh( name szCharName )
{
	local WargamePawn		aChar;
	local Controller C;
	local ExtendedAttachmentInfo	anEAInfo;
	local int						j;

	aChar = WargamePawn(GetPawn( szCharName ));
	if (aChar == None)
		return;
		
	aChar.SetDrawType( DT_MESH );
	aChar.SetPhysics( PHYS_Walking );

	C = Spawn( class'Mind' );

	if( C == None )
	{
		SLog( name $ ".ACTION_SetStaticCharacterToMesh( '" $ szCharName $ "', " $ class'Mind' $ "  ): could not spawn controller of that class."  );

		SetSucceeded( false );
	}
	else
	{
		// Make the prior controller unpossess the pawn.
		if( aChar.Controller != None )
		{
			aChar.Controller.UnPossess();
			aChar.Controller.Destroy();
		}

		C.Possess( aChar );

		SetSucceeded( true );
	}

	if (aChar.GetCharacterHead() != '')
	{
		anEAInfo = new( Level.Outer ) class'ExtendedAttachmentInfo';
		anEAInfo.m_nmSocketName = 'Head';
		anEAInfo.m_nmPartName = aChar.GetCharacterHead();

		aChar.ExtendedAttachments[0] = anEAInfo;
		aChar.ExtendedAttachments[0].m_AttachedPart = Spawn( class'AttachedPart', aChar );
		if (aChar.ExtendedSkins.Length > 0)
		{
			for (j = 0; j < aChar.ExtendedSkins.Length; j++)
			{
				if (aChar.ExtendedSkins[j] != None)
				{
					aChar.ExtendedAttachments[0].m_AttachedPart.Skins[j] = aChar.ExtendedSkins[j];
				}
			}
		}
		if (aChar.ExtendedAttachments[0].m_szGroupName != "")
			aChar.ExtendedAttachmentNamedGroup( aChar.ExtendedAttachments[0].m_AttachedPart, aChar.ExtendedAttachments[0].m_szGroupName );
		else
			aChar.ExtendedAttachment( aChar.ExtendedAttachments[0].m_AttachedPart, aChar.ExtendedAttachments[0].m_nmSocketName, aChar.ExtendedAttachments[0].m_nmPartName );
	}

	aChar.SetCollision( true, true, true );

	if (aChar.IsA('InfantryUSA') && (aChar.MyUnit != None))
		Level.TotalSquadMembersInMap += 1;
}

function ACTION_SetWeaponAccuracyOverride( name szCharName, bool bUseAimErrorOverride, optional int nAimError )
{
	local gbxPawn		aChar;

	aChar = gbxPawn(GetPawn( szCharName ));
	if (aChar == None)
		return;
		
	aChar.m_nAimErrorOverride = nAimError;
	aChar.m_bUseAimErrorOverride = bUseAimErrorOverride;
}

function ACTION_SetUnitImpactDistancePct( name szUnitName, float flDistancePct )
{
	local Unit aUnit;
	local UnitControllerAI aUnitController;

	foreach AllActors( class'Unit', aUnit, szUnitName )
	{
		aUnitController = UnitControllerAI(aUnit.MyUnitController);
		if (aUnitController != None)
		{
			if (flDistancePct == 0.0f)
				aUnitController.MaxImpactDistance = aUnitController.Default.MaxImpactDistance;
			else
				aUnitController.MaxImpactDistance = aUnitController.Default.MaxImpactDistance * flDistancePct;
		}
	}
}

function ACTION_SetUnitHiddenOnCompass( name szUnitName, bool bHidden )
{
	local Unit aUnit;

	foreach AllActors( class'Unit', aUnit, szUnitName )
	{
		aUnit.bDontDisplay = bHidden;
	}
}

function ACTION_ClearPawnIdleQueue( name szCharName )
{
	local	AnimPawn		aChar;
	
	aChar = AnimPawn(GetPawn( szCharName ));
	if (aChar == None || aChar.IsDead() )
		return;
		
	aChar.ClearIdleQueue();
}

function ACTION_AddAnimToPawnIdleQueue( name szCharName, name szAnimName )
{
	local	AnimPawn		aChar;
	
	aChar = AnimPawn(GetPawn( szCharName ));
	if (aChar == None)
		return;
		
	aChar.AddAnimToIdleQueue( szAnimName );
}

function ACTION_PlayAnimFromPawnIdleQueue( name szCharName, bool fRandom )
{
	local	AnimPawn		aChar;
	
	aChar = AnimPawn(GetPawn( szCharName ));
	if (aChar == None)
		return;
		
	aChar.PlayAnimFromIdleQueue( fRandom );
}

function ACTION_ChangePlayerFOV( float DesiredFOV, float FOVRate )
{
	local WargamePlayerController	aPlayer;
	
	aPlayer = GetLocalPlayerController();
	
	if (DesiredFOV == 0.0)
	{
		if ((aPlayer.Pawn != None) && (aPlayer.Pawn.Weapon != None) && aPlayer.Pawn.Weapon.m_fZoomed && aPlayer.Pawn.Weapon.IsA('gbxWeapon'))
		{
			gbxWeapon(aPlayer.Pawn.Weapon).ForceUnZoom();
		}
		else
		{
			aPlayer.DesiredFOV = aPlayer.Default.DefaultFOV;
		}
	}
	else
	{
		aPlayer.DesiredFOV = DesiredFOV;
	}
	if (FOVRate < 0.0)
		aPlayer.FOVRate = aPlayer.Default.FOVRate;
	else
		aPlayer.FOVRate = FOVRate;
}

function ACTION_SetMotionBlurEffect( bool fDoClear, byte bBlurR, byte bBlurG, byte bBlurB, float BlurAlpha )
{
	local WargamePlayerController PC;
    local int playerindex;
    
	local color BlurColor;
	
	BlurColor.R = bBlurR;
	BlurColor.G = bBlurG;
	BlurColor.B = bBlurB;
	BlurColor.A = 255;
	
	PC = GetLocalPlayerController();
    playerindex = PC.Player.SplitIndex;
    
	Level.CameraEffectManager[playerindex].SetCameraEffect( CAM_MotionBlur );
	/// Flash the camera with white
	Level.CameraEffectManager[playerindex].CamMotionBlurEffect.bDoClear = fDoClear;
	Level.CameraEffectManager[playerindex].CamMotionBlurEffect.RenderColor = BlurColor;
	Level.CameraEffectManager[playerindex].CamMotionBlurEffect.BlurAlpha = BlurAlpha;
	Level.CameraEffectManager[playerindex].CamMotionBlurEffect.bFade = false;
}

function ACTION_SetSaturationEffect( byte bSaturationAlpha )
{
	local WargamePlayerController PC;
    local int playerindex;
    
	PC = GetLocalPlayerController();
    playerindex = PC.Player.SplitIndex;
    
	Level.CameraEffectManager[playerindex].SetCameraEffect( CAM_Desaturation );
	// Initialize the saturation
	Level.CameraEffectManager[playerindex].CamDesaturationEffect.GlobalColor.A = bSaturationAlpha;
}

function ACTION_SetHighDynamicRangeEffect()
{
	local WargamePlayerController PC;
    local int playerindex;
    
	PC = GetLocalPlayerController();
    playerindex = PC.Player.SplitIndex;
    
	Level.CameraEffectManager[playerindex].SetCameraEffect( CAM_HighDynamicRange, false );
}

function ACTION_SetBlurEffect(  float flBlurOffset, byte bBlurR, byte bBlurG, byte bBlurB, byte bBlurAlpha, float flBlurAmount )
{
	local WargamePlayerController	aPlayer;
    local int playerindex;
	
	aPlayer = GetLocalPlayerController();
	playerindex = aPlayer.Player.SplitIndex;
	
	if (aPlayer != None)
	{
		aPlayer.EnableBlur( false );

		Level.CameraEffectManager[playerindex].CamBlurEffect.BlurOffset = flBlurOffset;
		Level.CameraEffectManager[playerindex].CamBlurEffect.BlurColor.R = bBlurR;
		Level.CameraEffectManager[playerindex].CamBlurEffect.BlurColor.G = bBlurG;
		Level.CameraEffectManager[playerindex].CamBlurEffect.BlurColor.B = bBlurB;
		Level.CameraEffectManager[playerindex].CamBlurEffect.BlurColor.A = bBlurAlpha;
		Level.CameraEffectManager[playerindex].CamBlurEffect.BlurAmount = flBlurAmount;
		//SLog(self$".ACTION_SetBlurEffect() - "$Level.CameraEffectManager.CamBlurEffect.BlurColor.A);
		
		if ((flBlurOffset == 0.0) && (flBlurAmount == 0.0))
		{
		    Level.CameraEffectManager[playerindex].RestoreDefaultEffect();
		}
	}
}

function ACTION_FadeBlurEffect(  float flBlurTime, float flTargetBlurOffset, float flTargetBlurAmount, byte bTargetBlurR, byte bTargetBlurG, byte bTargetBlurB, byte bTargetBlurAlpha )
{
	local WargamePlayerController	aPlayer;
	local CameraEffectManager       CameraEffectManager;
	local int playerindex;
	
	if (flBlurTime == 0.0)
	{
		ACTION_SetBlurEffect(  flTargetBlurOffset, bTargetBlurR, bTargetBlurG, bTargetBlurB, bTargetBlurAlpha, flTargetBlurAmount );
		return;
	}
		
	aPlayer = GetLocalPlayerController();
	if (aPlayer != None)
	{
	    playerindex = aPlayer.Player.SplitIndex;
	    CameraEffectManager = Level.CameraEffectManager[playerindex];
		aPlayer.EnableBlur( false );
		
		CameraEffectManager.CamBlurEffect.TargetBlurOffset = flTargetBlurOffset;
		if (CameraEffectManager.CamBlurEffect.BlurOffset == CameraEffectManager.CamBlurEffect.TargetBlurOffset)
		{
			CameraEffectManager.CamBlurEffect.BlurOffsetRate = 0.0f;
		}
		else
		{
			CameraEffectManager.CamBlurEffect.BlurOffsetRate = (flTargetBlurOffset - CameraEffectManager.CamBlurEffect.BlurOffset) / flBlurTime;
		}
		CameraEffectManager.CamBlurEffect.TargetBlurAmount = flTargetBlurAmount;
		if (CameraEffectManager.CamBlurEffect.BlurAmount == CameraEffectManager.CamBlurEffect.TargetBlurAmount)
		{
			CameraEffectManager.CamBlurEffect.BlurAmountRate = 0.0f;
		}
		else
		{
			CameraEffectManager.CamBlurEffect.BlurAmountRate = (flTargetBlurAmount - CameraEffectManager.CamBlurEffect.BlurAmount) / flBlurTime;
		}
		CameraEffectManager.CamBlurEffect.TargetBlurColor.R = bTargetBlurR;
		CameraEffectManager.CamBlurEffect.TargetBlurColor.G = bTargetBlurG;
		CameraEffectManager.CamBlurEffect.TargetBlurColor.B = bTargetBlurB;
		CameraEffectManager.CamBlurEffect.TargetBlurColor.A = bTargetBlurAlpha;
		CameraEffectManager.CamBlurEffect.CurBlurAlpha = CameraEffectManager.CamBlurEffect.BlurColor.A;
		if (CameraEffectManager.CamBlurEffect.BlurColor.A == CameraEffectManager.CamBlurEffect.TargetBlurColor.A)
		{
			CameraEffectManager.CamBlurEffect.BlurAlphaRate = 0.0f;
		}
		else
		{
			CameraEffectManager.CamBlurEffect.BlurAlphaRate = float(bTargetBlurAlpha - CameraEffectManager.CamBlurEffect.BlurColor.A) / flBlurTime;
		}
		
		CameraEffectManager.CamBlurEffect.BlurStartTime = Level.TimeSeconds;
		CameraEffectManager.CamBlurEffect.BlurTime = flBlurTime;
	}
}

function ACTION_SetBloodEffect( float flVecX, float flVecY, float flVecZ, int numParticles )
{
	local WargamePlayerController	aPlayer;
	local Vector					vecDamage;
	
	aPlayer = GetLocalPlayerController();
	
	if (aPlayer != None)
	{
		vecDamage.X = flVecX;
		vecDamage.Y = flVecY;
		vecDamage.Z = flVecZ;
		aPlayer.CreateHudBloodEffect( vecDamage, numParticles );
	}	
}

function ACTION_RemoveCameraEffect( bool fRestoreDefault )
{
	local WargamePlayerController PC;
    local int playerindex;
    
	PC = GetLocalPlayerController();
    playerindex = PC.Player.SplitIndex;
    
	Level.CameraEffectManager[playerindex].RestoreDefaultEffect();
}

function ACTION_HideHUD( WargamePlayerController playerController, bool bHide )
{
	local WargamePlayerController	aPlayer;
	
	aPlayer = GetLocalPlayerController();
	
	if (aPlayer != None)
	{
		WargameHUD(aPlayer.MyHUD).bHideHUD = bHide;
	}
}

function ACTION_SaveMemoryReport( optional string szMemTag )
{
	local WargamePlayerController	aPlayer;
	
	aPlayer = GetLocalPlayerController();
	
	if (aPlayer.bCheckpointMemLog)
	{
		aPlayer.ConsoleCommand("STAT REPORTALL "$szMemTag);
		aPlayer.ConsoleCommand("MEM DETAILED "$szMemTag);
		aPlayer.ConsoleCommand("DUMPTIMERS "$szMemTag);
		aPlayer.ConsoleCommand("CLEARTIMERS");
	}
}

function ACTION_CheckPoint( optional name szPreSaveTrigger, optional name szPostSaveTrigger )
{
/*
	local WargamePlayerController	aPlayer;
	
	aPlayer = GetLocalPlayerController();
	SLog(self$".ACTION_CheckPoint() - "$aPlayer.bCheckpointMemLog);
//	if (aPlayer.bCheckpointMemLog)
//	{
//		aPlayer.ConsoleCommand("STAT REPORTALL");
//		aPlayer.ConsoleCommand("MEM DETAILED");
//	}
	
	if (aPlayer.bDoNotSave)
	{
		return;
	}
	ACTION_DisplayObjectiveString( m_szCheckpointMessage1, 3.0f ); //DLEVY precheckpoint message
	
//	flDoSaveGame = Level.TimeSeconds;
	Level.m_flDoSaveGame = Level.TimeSeconds + CHECKPOINT_SAVE_DELAY;
	bWaitForSaveGame = true;
	m_szPreSaveTrigger = szPreSaveTrigger;
	m_szPostSaveTrigger = szPostSaveTrigger;


//	ACTION_LimitPlayerInput( aPlayer, true );
*/
}

function ACTION_CheckPointPart2( optional name szPreSaveTrigger, optional name szPostSaveTrigger )
{
/*
	local WargamePlayerController	aPlayer;
	
	aPlayer = GetLocalPlayerController();
	SLog(self$".ACTION_CheckPointPart2() - "$aPlayer.bCheckpointMemLog);
	
	flDoSaveGame = -1.0f;

	CleanupDestroyedActors();

	if (szPreSaveTrigger != '')
	{
		aPlayer.TriggerEvent( szPreSaveTrigger, self, aPlayer.Pawn );
	}
		
	if (aPlayer != None)
	{
		aPlayer.ConsoleCommand("SAVEGAME 1");

		// copy the savegame to the profile
		class'Engine.GameProfile'.Static.ProfileCheckpoints(Level, "SAVE");
	}

//	if (aPlayer.bCheckpointMemLog)
//	{
//		aPlayer.ConsoleCommand("STAT REPORTALL");
//		aPlayer.ConsoleCommand("MEM DETAILED");
//	}

	ACTION_DisplayObjectiveString( m_szCheckpointMessage2, 3.0f ); //DLEVY postcheckpoint message

	if (szPostSaveTrigger != '')
	{
		aPlayer.TriggerEvent( szPostSaveTrigger, self, aPlayer.Pawn );
	}
*/
}

function ACTION_ClearScriptValues()
{
	if (Level.NetMode == NM_StandAlone)
	{
		Level.MissionManager.ClearCachedValues();
	}
	else
	{
		Level.MissionManager.SkirmishClearCachedValues();
	}
}

function ACTION_SaveScriptValue( name szValueName, int nValue )
{
	Level.MissionManager.AddCachedValue( szValueName, nValue );
}

function ACTION_LoadSavedValues()
{
	Level.MissionManager.LoadSavedValues();
}

function bool ACTION_GetSavedValue( name szValueName, out int nValue )
{
	if (Level.NetMode == NM_StandAlone)
	{
		return Level.MissionManager.GetCachedValue( szValueName, nValue );
	}
	else
	{
		return Level.MissionManager.SkirmishGetCachedValue( szValueName, nValue );
	}
}

function ACTION_CheckPointSave( int nCheckpointID, optional name szPreSaveTrigger, optional name szPostSaveTrigger, optional bool fSaveCustom, optional string szCustomMapName )
{
	local WargamePlayerController	aPlayer;
	local PlayerController			aTestPlayer;
	local bool						bDontSave;
	local WargameHUD				myHud;

	aPlayer = GetLocalPlayerController();
	
	if (aPlayer.bDoNotSave)
	{
		return;
	}

	if (!(Level.Game.CanUseCheckpoints( nCheckpointID )))
	{
		ACTION_TriggerEvent( szPreSaveTrigger );
		ACTION_TriggerEvent( szPostSaveTrigger );
		return;
	}

//	ACTION_DisplayObjectiveString( m_szCheckpointMessage, 3.0f );  
	
	// Only do this if it's not standalone (e.g. should be skirmish), and if more than 1 player are in the game.
	if ((Level.NetMode != NM_StandAlone) && (Level.Game.NumPlayers > 1))
	{
		bDontSave = false;
		for( aTestPlayer = Level.PlayerControllerList; aTestPlayer != None; aTestPlayer = aTestPlayer.NextPlayerController)
		{
			if (aTestPlayer.Pawn.Health <= 0)
			{
				bDontSave = true;
			}
		}
		if (bDontSave)
		{
			myHUD = WargameHUD(aPlayer.MyHud);
			if (myHUD != None)
			{
				BroadcastLocalizedMessage(class'gbxGameMessage', 1, aPlayer.PlayerReplicationInfo, None);
//				Level.Game.LoadCheckpointInLevel( nCheckpointID, szPreSaveTrigger, szPostSaveTrigger );
				for( aTestPlayer = Level.PlayerControllerList; aTestPlayer != None; aTestPlayer = aTestPlayer.NextPlayerController)
				{
					// GBX:PAD: This is a bit of a hack for split screen because both screens share the fade state of the
					// level info, so this will cause the respawn to happen whenever the first screen finishes the fade.
					if (Viewport(aTestPlayer.Player) != None)
					{
						myHUD = WargameHUD(aTestPlayer.MyHud);
						if (myHUD != None)
						{
							myHUD.m_fRespawnDeadPlayer = true;
							myHUD.m_szPreSaveTrigger = szPreSaveTrigger;
							myHUD.m_szPostSaveTrigger = szPostSaveTrigger;
							myHUD.m_nCheckpointID = nCheckpointID;
						}
					}
				}
			}
			return;
		}
	}
	if (aPlayer.Pawn.Health > 0)
	{
		//DLEVY only display precheckpoint message if player health > 0. 
		//Set checkpoint message to be CriticalMessage so is not overwritten before time expired
		//for XBOX TCR compliance see bug #8837

		if (Level.NetMode == NM_StandAlone)
		{
			ACTION_DisplayObjectiveString( m_szCheckpointMessage1, 3.0f, true ); 
		}
		else
		{
			BroadcastLocalizedMessage(class'gbxGameMessage', 0, aPlayer.PlayerReplicationInfo, None);
		}
		flDoSaveGame = Level.TimeSeconds;
		bWaitForSaveGame = true;
		m_szPreSaveTrigger = szPreSaveTrigger;
		m_szPostSaveTrigger = szPostSaveTrigger;
		m_nCheckpointID = nCheckpointID;
		m_fSaveCustom = fSaveCustom;
		m_szCustomMapName = szCustomMapName;
	}
}
	
function ACTION_CheckPointSavePart2( int nCheckpointID, optional name szPreSaveTrigger, optional name szPostSaveTrigger )
{
	local WargamePlayerController	aPlayer;

	aPlayer = GetLocalPlayerController();
	
	flDoSaveGame = -1.0f;

	if (aPlayer.Pawn.Health > 0)
	{
		if (szPreSaveTrigger != '')
		{
			aPlayer.TriggerEvent( szPreSaveTrigger, self, aPlayer.Pawn );
		}
			
		CleanupDestroyedActors();
		if (GetLocalPlayerController().Pawn.Health > 0)
		{
			if (m_fSaveCustom)
			{
				Level.Game.SaveCheckpointIDCustom( nCheckpointID, m_szCustomMapName );
				log(self$".ACTION_CheckPointSavePart2() - "$m_szCustomMapName);
			}
			else
			{
				Level.Game.SaveCheckpointID( nCheckpointID );
				log(self$".ACTION_CheckPointSavePart2() - "$m_szCustomMapName);
			}
//			Level.MissionManager.SaveCheckpointID( nCheckpointID );
		}
		
//DLEVY got rid of post checkpoint save message for bug #8837
//		ACTION_DisplayObjectiveString( m_szCheckpointMessage2, 3.0f ); //DLEVY only display postcheckpoint message
																	     //if player health > 0 

		if (szPostSaveTrigger != '')
		{
			aPlayer.TriggerEvent( szPostSaveTrigger, self, aPlayer.Pawn );
		}


	}
	else
	{
		ACTION_DisplayObjectiveString( "", 0.0f );
	}
}

function ACTION_MakeEnemyKnown( name EnemyPawnTag )
{
	local gbxPawn EnemyPawn;
	local WargamePawn ThePlayer;

	EnemyPawn = gbxPawn( GetPawn( EnemyPawnTag ) );

	if ( EnemyPawn != None )
	{
		ThePlayer = GetLocalPlayerPawn();

		if ( ThePlayer != None && ThePlayer.MyUnit != None && ThePlayer.MyUnit.MyUnitController != None )
		{
			ThePlayer.MyUnit.MyUnitController.UnitMemberUpdatedTarget( EnemyPawn ); 
		}
	}
}

function ACTION_SetMortarTargetByName( name MortarName, name TargetName, EMortarFire FireType, int NumShots, float TimeBetweenShots, float OffsetFromTarget )
{
	local WeapDEMortar TheMortar;
	local Actor NewTarget;

	foreach DynamicActors( class'WeapDEMortar', TheMortar, MortarName ) { break; }
	foreach DynamicActors( class'Actor', NewTarget, TargetName ) { break; }

	if ( TheMortar == None )
	{
		SLog( name $ ".ACTION_SetMortarTarget( '" $ MortarName $ "' ): mortar tag not found."  );
		return;
	}
	if ( NewTarget == None )
	{
		SLog( name $ ".ACTION_SetMortarTarget( '" $ MortarName $ "' ): target tag not found."  );
		return;
	}

	TheMortar.SetFireParameters( NewTarget, FireType, NumShots, TimeBetweenShots, OffsetFromTarget );
}

function ACTION_SetMortarTargetByRef( name MortarName, Actor NewTarget, EMortarFire FireType, int NumShots, float TimeBetweenShots, float OffsetFromTarget )
{
	local WeapDEMortar TheMortar;

	if ( NewTarget == None )
	{
		SLog( name $ ".ACTION_SetMortarTarget( '" $ MortarName $ "' ): empty NewTarget tag."  );
		return;
	}

	foreach DynamicActors( class'WeapDEMortar', TheMortar, MortarName ) { break; }

	if ( TheMortar == None )
	{
		SLog( name $ ".ACTION_SetMortarTarget( '" $ MortarName $ "' ): mortar tag not found."  );
		return;
	}	

	TheMortar.SetFireParameters( NewTarget, FireType, NumShots, TimeBetweenShots, OffsetFromTarget );
}

function ACTION_SetMortarTargetPlayer( name MortarName, EMortarFire FireType, int NumShots, float TimeBetweenShots, float OffsetFromTarget )
{
	local WeapDEMortar TheMortar;
	local gbxPlayerPawn ThePlayer;

	foreach DynamicActors( class'WeapDEMortar', TheMortar, MortarName ) { break; }
	foreach DynamicActors( class'gbxPlayerPawn', ThePlayer ) { break; }

	if ( TheMortar == None )
	{
		SLog( name $ ".ACTION_SetMortarTarget( '" $ MortarName $ "' ): mortar tag not found."  );
		return;
	}
	if ( ThePlayer == None )
	{
		SLog( name $ ".ACTION_SetMortarTarget( '" $ MortarName $ "' ): Player Actor not found in the world."  );
		return;
	}

	TheMortar.SetFireParameters( ThePlayer, FireType, NumShots, TimeBetweenShots, OffsetFromTarget );
}

//NAC+

/////////////////////////////////////
// Pak88 Scripted Control Functions //
/////////////////////////////////////

function ACTION_Pak88EnterScriptedMode( name My88Gun )
{
	local WeapDEPAK88_ Pak88Gun;


	foreach DynamicActors( class'WeapDEPAK88_', Pak88Gun, My88Gun ) { break; }
	if (Pak88Gun == None)
	{
		SLog("ACTION_Pak88EnterScriptedMode() ERROR: My88Gun is None!");
		SetSucceeded( false );
		return;
	}

	//Pak88Gun = WeapDEPAK88_(My88Gun);
	if ( Pak88Gun.Gunner == None )
	{
		// lets recruit our crew
		Pak88Gun.DraftCrew();
		//now lets make sure we have a gunner...
		if (Pak88Gun.Gunner == None)
		{
			//there is no gunner...lets bail
			SLog("**************ACTION_Pak88EnterScriptedMode() ERROR: No Gunner!");
			SetSucceeded( false );
			return;
		}
	}

	Pak88Gun.Gunner.Controller.GotoState('Scripted');
	if (!Pak88Gun.bNoFuseSetter)
	Pak88Gun.FuseSetter.Controller.GotoState('Scripted');
	Pak88Gun.Loader.Controller.GotoState('Scripted');
	MindPAK88Gunner(Pak88Gun.Gunner.Controller).bIsInScriptedMode = true;

	SetSucceeded( true );
}

function ACTION_88LeaveScriptedMode(name My88Gun)
{
	local WeapDEPAK88_ Pak88Gun;
	foreach DynamicActors( class'WeapDEPAK88_', Pak88Gun, My88Gun ) { break; }


	
	MindPAK88Gunner(Pak88Gun.Gunner.Controller).ClearTargets();
	MindPAK88Gunner(Pak88Gun.Gunner.Controller).bIsInScriptedMode = false;
	if (!Pak88Gun.bNoFuseSetter)
	Pak88Gun.FuseSetter.Controller.GotoState('ManningPak88');
	Pak88Gun.Loader.Controller.GotoState('ManningPak88');

	SetSucceeded( true );
}

function ACTION_Set88TargetByName( name My88Gun, name TargetName, bool directShot )
{
	local WeapDEPAK88_ Pak88Gun;
	local Actor NewTarget;

	foreach DynamicActors( class'WeapDEPAK88_', Pak88Gun, My88Gun ) { break; }
	foreach DynamicActors( class'Actor', NewTarget, TargetName ) { break; }

	if ( Pak88Gun == None )
	{
		SLog( name $ ".ACTION_Set88Target( '" $ My88Gun $ "' ): 88 tag not found."  );
		return;
	}
	if ( NewTarget == None )
	{
		SLog( name $ ".ACTION_Set88Target( '" $ My88Gun $ "' ): target tag not found."  );
		return;
	}

	MindPAK88Gunner(Pak88Gun.Gunner.Controller).SetFireParameters( NewTarget, directShot );
}



function ACTION_Set88TargetPlayer( name My88Gun, bool directShot )
{
	local WeapDEPAK88_ Pak88Gun;
	local gbxPlayerPawn ThePlayer;

	foreach DynamicActors( class'gbxPlayerPawn', ThePlayer ) { break; }

	foreach DynamicActors( class'WeapDEPAK88_', Pak88Gun, My88Gun ) { break; }

	if ( Pak88Gun == None )
	{
		SLog( name $ ".ACTION_Set88Target( '" $ My88Gun $ "' ): 88 tag not found."  );
		return;
	}
	if ( ThePlayer == None )
	{
		SLog( name $ ".ACTION_Set88Target( '" $ My88Gun $ "' ): target tag not found."  );
		return;
	}

	MindPAK88Gunner(Pak88Gun.Gunner.Controller).SetFireParameters( ThePlayer, directShot );
}


function ACTION_FireAtTarget(name My88Gun, name TargetName)
{
	local WeapDEPAK88_ Pak88Gun;
	local Actor NewTarget;

	foreach DynamicActors( class'WeapDEPAK88_', Pak88Gun, My88Gun ) { break; }
	foreach DynamicActors( class'Actor', NewTarget, TargetName ) { break; }
	
	MindPAK88Gunner(Pak88Gun.Gunner.Controller).FireAtTarget(NewTarget);
	if (!Pak88Gun.bNoFuseSetter)
	MindPAK88FuseSetter(Pak88Gun.FuseSetter.Controller).NotifyBeginFiring();
	MindPAK88Loader(Pak88Gun.Loader.Controller).NotifyBeginFiring();

}

function ACTION_FireAtPlayer(name My88Gun)
{
	local WeapDEPAK88_ Pak88Gun;
	local gbxPlayerPawn ThePlayer;

	foreach DynamicActors( class'gbxPlayerPawn', ThePlayer ) { break; }
	foreach DynamicActors( class'WeapDEPAK88_', Pak88Gun, My88Gun ) { break; }

	
	MindPAK88Gunner(Pak88Gun.Gunner.Controller).FireAtTarget(ThePlayer);

}

function bool ACTION_88IsAimingAtEnemy(name My88Gun, name TargetName)
{
	local WeapDEPAK88_ Pak88Gun;
	local Actor NewTarget;

	foreach DynamicActors( class'WeapDEPAK88_', Pak88Gun, My88Gun ) { break; }
	foreach DynamicActors( class'Actor', NewTarget, TargetName ) { break; }
	
	return MindPAK88Gunner(Pak88Gun.Gunner.Controller).CheckOnTarget(NewTarget);

}

function bool ACTION_88IsAimingAtPlayer(name My88Gun)
{
	local WeapDEPAK88_ Pak88Gun;
	local gbxPlayerPawn ThePlayer;

	foreach DynamicActors( class'gbxPlayerPawn', ThePlayer ) { break; }
	foreach DynamicActors( class'WeapDEPAK88_', Pak88Gun, My88Gun ) { break; }
	
	return MindPAK88Gunner(Pak88Gun.Gunner.Controller).CheckOnTarget(ThePlayer);

}
//NAC-

function ACTION_SetPawnWeaponAmmo( Pawn ThePawn, Class<Weapon> WeaponClass, int NewAmmoAmount )
{
	local Weapon aWeapon;
	local gbxAmmo anAmmo;
	local Inventory Inv;

	if ( ThePawn == None || WeaponClass == None )
	{
		SLog( name $ ".ACTION_SetPawnWeaponAmmo( " $ ThePawn $ ", " $ WeaponClass $ " ): Null ThePawn or WeaponClass parameter."  );
		return;
	}

	for ( Inv = ThePawn.Inventory; Inv != None; Inv = Inv.Inventory )
	{
		if ( Inv.IsA( WeaponClass.Name ) )
		{
			aWeapon = Weapon( Inv );
			anAmmo = gbxAmmo( aWeapon.Ammo[0] );
			
			if ( anAmmo != None )
			{
				if ( !ThePawn.IsHumanControlled() )
				{
					anAmmo.bUnlimitedForAI = false;
				}

				anAmmo.AmmoAmount = NewAmmoAmount;
				aWeapon.ClipAmt = min( aWeapon.ClipAmt, NewAmmoAmount );
			}
		}
	}
}

// This function reverses the limiting-ammo effects of ACTION_SetPawnWeaponAmmo() for AI-controlled pawns.
function ACTION_RestoreUnlimitedAmmo( Pawn ThePawn, Class<Weapon> WeaponClass )
{
	local Weapon aWeapon;
	local gbxAmmo anAmmo;
	local Inventory Inv;

	if ( ThePawn == None || WeaponClass == None )
	{
		SLog( name $ ".ACTION_RestoreUnlimitedAmmo( " $ ThePawn $ ", " $ WeaponClass $ " ): Null ThePawn or WeaponClass parameter."  );
		return;
	}
	if ( ThePawn.IsHumanControlled() )
	{
		SLog( name $ ".ACTION_RestoreUnlimitedAmmo( " $ ThePawn $ ", " $ WeaponClass $ " ): Passed in human-controlled pawn to function."  );
		return;
	}

	for ( Inv = ThePawn.Inventory; Inv != None; Inv = Inv.Inventory )
	{
		if ( Inv.IsA( WeaponClass.Name ) )
		{
			aWeapon = Weapon( Inv );
			anAmmo = gbxAmmo( aWeapon.Ammo[0] );
			
			if ( anAmmo != None )
			{
				anAmmo.bUnlimitedForAI = true;
			}
		}
	}
}

function ACTION_EnableMortarRecruiting( name MortarName, bool bRecruit )
{
	local WeapDEMortar TheMortar;

	foreach AllActors( class'WeapDEMortar', TheMortar, MortarName )
	{
		TheMortar.bDontRecruit = !bRecruit;
		break;
	}
}

function ACTION_EnableMG42Recruiting( name MGName, bool bRecruit )
{
	local WeapDEMG42_ TheMG;

	foreach AllActors( class'WeapDEMG42_', TheMG, MGName )
	{
		TheMG.bDontRecruit = !bRecruit;
		break;
	}
}

function ACTION_EnableFlakvierlingRecruiting( name FlakVName, bool bRecruit )
{
	local WeapDEFlakvierling TheFlak;

	foreach AllActors( class'WeapDEFlakvierling', TheFlak, FlakVName )
	{
		TheFlak.bDontRecruit = !bRecruit;
		break;
	}
}

function ACTION_EnablePak36Recruiting( name PakName, bool bRecruit )
{
	local WeapDEPak36_ ThePak;

	foreach AllActors( class'WeapDEPak36_', ThePak, PakName )
	{
		ThePak.bDontRecruit = !bRecruit;
		break;
	}
}


function ACTION_SetFlakvierlingTarget( name FlakName, name TargetActorName )
{
	local WeapDEFlakvierling TheFlak;
	local Actor TargetActor;

	foreach allactors( class'WeapDEFlakvierling', TheFlak, FlakName )
	{
		TargetActor = GetFirstActor( TargetActorName );

		if ( TheFlak != None )
		{
			TheFlak.SetTargetActor( TargetActor );	// TargetActor may be None.
		}
		break;
	}
}

function bool PawnIsAtDestinationTag(name PawnTag, name DestTag)
{
	local Pawn MyPawn;
	local ActorLite MyDest;

	MyPawn = Pawn(GetFirstActor(PawnTag));
	MyDest = GetNavigationPointMatchesTag( DestTag );

	if ((MyPawn == None) || (MyDest == None))
	{
		SLog("PawnIsAtDestinationTag ERROR: MyPawn = " $ MyPawn $ "  MyDest = " $ MyDest);
		return false;
	}

	return PawnIsAtDestination(MyPawn, MyDest);
}

function ACTION_PawnFireAtTarget( name PawnTag, name TargetTag )
{
	local WargamePawn MyPawn;
	local Actor MyTarget;
	
	MyPawn = WargamePawn(GetFirstActor(PawnTag));
	MyTarget = GetFirstActor(TargetTag);

	ACTION_PawnFireAtTargetDirect( MyPawn, MyTarget );
}

function ACTION_PawnFireAtTargetDirect( WargamePawn MyPawn, Actor MyTarget )
{	
	MyPawn.FireAtTarget( MyTarget );
}

function ACTION_ClearPawnFireAtTarget( name PawnTag )
{
	local WargamePawn MyPawn;
	
	MyPawn = WargamePawn(GetFirstActor(PawnTag));
	
	ACTION_ClearPawnFireAtTargetDirect( MyPawn );
}

function ACTION_ClearPawnFireAtTargetDirect( WargamePawn MyPawn )
{	
	MyPawn.ClearFireAtTarget();
}

function ACTION_PawnSetHeadTurnMult( name PawnTag, float flMult )
{
	local WargamePawn MyPawn;
	MyPawn = WargamePawn(GetFirstActor(PawnTag));

	ACTION_PawnSetHeadTurnMultDirect( MyPawn, flMult );
}

function ACTION_PawnSetHeadTurnMultDirect( WargamePawn MyPawn, float flMult )
{
	MyPawn.HeadTurnRate = MyPawn.Default.HeadTurnRate / flMult;
}

function ACTION_DisablePawnTurn( name PawnTag, bool fDisable )
{
	local Pawn MyPawn;
	
	MyPawn = Pawn(GetFirstActor(PawnTag));
	ACTION_DisablePawnTurnDirect( MyPawn, fDisable );
}

function ACTION_DisablePawnTurnDirect( Pawn MyPawn, bool fDisable )
{
	MyPawn.bNoTurnBody = fDisable;
}

function ACTION_DisableAutoFacialExpression( name PawnTag, bool fDisable )
{
	local InfantryUSA MyPawn;
	
	MyPawn = InfantryUSA(GetFirstActor(PawnTag));

	ACTION_DisableAutoFacialExpressionDirect( MyPawn, fDisable );
}

function ACTION_DisableAutoFacialExpressionDirect( InfantryUSA MyPawn, bool fDisable )
{	
	MyPawn.bUseSmirkFacialExpressions = !fDisable;
	MyPawn.bUseScowlFacialExpressions = !fDisable;
	MyPawn.FacialExpressionBlendInDuration = MyPawn.Default.FacialExpressionBlendInDuration;
	MyPawn.FacialExpressionBlendOutDuration = MyPawn.Default.FacialExpressionBlendOutDuration;
	MyPawn.FacialExpressionHoldTime = MyPawn.Default.FacialExpressionHoldTime;
}

function ACTION_PawnSetFacialExpression( name PawnTag, name szAnimName, optional float ExpressionHoldTime, optional float BlendInDurationPct, optional float BlendOutDurationPct )
{
/*
	local InfantryUSA MyPawn;

	MyPawn = InfantryUSA(GetFirstActor(PawnTag));
	
	MyPawn.FacialExpressionAnim = szAnimName;
	MyPawn.FacialExpressionBlendingState = E_BlendingIn;
	// This is a bit of a hack, but it forces the facial animation to not start with a blend of 0 since that blend value will pop
	// the animation briefly.
	MyPawn.FacialExpressionBlendStartTime = Level.TimeSeconds - 0.001;
	if (BlendInDurationPct > 0.0)
		MyPawn.FacialExpressionBlendInDuration = MyPawn.Default.FacialExpressionBlendInDuration * BlendInDurationPct;
	else
		MyPawn.FacialExpressionBlendInDuration = MyPawn.Default.FacialExpressionBlendInDuration;
	if (BlendOutDurationPct > 0.0)
		MyPawn.FacialExpressionBlendOutDuration = MyPawn.Default.FacialExpressionBlendOutDuration * BlendOutDurationPct;
	else
		MyPawn.FacialExpressionBlendOutDuration = MyPawn.Default.FacialExpressionBlendOutDuration;
	if (ExpressionHoldTime > 0.0)
		MyPawn.FacialExpressionHoldTime = ExpressionHoldTime;
	else
		MyPawn.FacialExpressionHoldTime = MyPawn.Default.FacialExpressionHoldTime;
*/
}

function ACTION_StartRain( optional float Intensity, optional bool bNoSound )
{
	GetLocalPlayerController().StartRaining( Intensity, bNoSound );
}

function ACTION_StopRain()
{
	GetLocalPlayerController().StopRaining();
}

function ACTION_AdjustRain( float Intensity )
{
	GetLocalPlayerController().AdjustRainIntensity( Intensity );
}

function ACTION_GivePawnWeapon( name PawnTag, string szWeaponName )
{
	local InfantryUSA MyPawn;
	
	MyPawn = InfantryUSA(GetFirstActor(PawnTag));
	
	ACTION_GivePawnWeaponDirect( MyPawn, szWeaponName );
}

function ACTION_GivePawnWeaponDirect( InfantryUSA MyPawn, string szWeaponName )
{
	MyPawn.CreateInventory( szWeaponName );
}

function ACTION_DisableBattleDialogue() 
{
	if ( Level.TheAISpeechManager != None )
	{
		Level.TheAISpeechManager.DisableSpeech();
	}
	else
	{
		SLog( name $ ".ACTION_DisableBattleDialogue(): Speech Manager has not been created yet!" );
	}
}

function ACTION_EnableBattleDialogue() 
{
	if ( Level.TheAISpeechManager != None )
	{
		Level.TheAISpeechManager.EnableSpeech();
	}
	else
	{
		SLog( name $ ".ACTION_DisableBattleDialogue(): Speech Manager has not been created yet!" );
	}
}

function ACTION_DisableBattleDialogueForCharacter( name PawnTag )
{
	local Pawn P;

	P = GetPawn( PawnTag );

	if ( P != None )
	{
		if ( Level.TheAISpeechManager != None )
		{
			Level.TheAISpeechManager.DisableSpeechForCharacter( P );
		}
		else
		{
			SLog( name $ ".ACTION_DisableBattleDialogueForCharacter(): Speech Manager has not been created yet!" );
		}
		
		ACTION_DisableTalkToMessageForCharacter( PawnTag );
	}
}

function ACTION_EnableBattleDialogueForCharacter( name PawnTag )
{
	local Pawn P;

	P = GetPawn( PawnTag );

	if ( P != None )
	{
		if ( Level.TheAISpeechManager != None )
		{
			Level.TheAISpeechManager.EnableSpeechForCharacter( P );
		}
		else
		{
			SLog( name $ ".ACTION_EnableBattleDialogueForCharacter(): Speech Manager has not been created yet!" );
		}
		
		ACTION_EnableTalkToMessageForCharacter( PawnTag );
	}
}

function ACTION_DisableTalkToMessageForCharacter( name PawnTag )
{
	local gbxPawn thePawn;
	thePawn = gbxPawn( GetFirstActor( PawnTag ) );
	
	if ( thePawn != None )
	{
		thePawn.SupressTalkToMessage = true;
	}
}

function ACTION_EnableTalkToMessageForCharacter( name PawnTag )
{
	local gbxPawn thePawn;
	thePawn = gbxPawn( GetFirstActor( PawnTag ) );

	if ( thePawn != None )
	{
		thePawn.SupressTalkToMessage = false;
	}
}

function ACTION_DisableFlankingDialogue()
{
	if ( Level.TheAISpeechManager != None )
	{
		Level.TheAISpeechManager.EnableFlankingSpeeches( false );
	}
	else
	{
		SLog( name $ ".ACTION_DisableFlankingDialogue(): Speech Manager has not been created yet!" );
	}
}

function ACTION_EnableFlankingDialogue()
{
	if ( Level.TheAISpeechManager != None )
	{
		Level.TheAISpeechManager.EnableFlankingSpeeches( true );
	}
	else
	{
		SLog( name $ ".ACTION_EnableFlankingDialogue(): Speech Manager has not been created yet!" );
	}
}

function ACTION_BlockNavPoint( name NavPointTag )
{
	local ActorLite TheNavPoint;

	TheNavPoint = GetNavigationPointMatchesTag( NavPointTag );

	if ( TheNavPoint != None )
	{
		if ( TheNavPoint.bIsNavigationPointLite )
		{
			NavigationPointLite( TheNavPoint ).bLevelDesignBlocked = true;
		}
		else if ( TheNavPoint.bIsNavigationPoint )
		{
			NavigationPoint( TheNavPoint ).bLevelDesignBlocked = true;
		}
	}
}

// Just like above function, only for multiple points sharing same tag.
function ACTION_BlockNavPoints( name NavPointTag )
{
	if (NavPointTag == '')
		return;

	BlockNavigationPointMatchesTag( NavPointTag );
}

function ACTION_UnBlockNavPoint( name NavPointTag )
{
	local ActorLite TheNavPoint;

	TheNavPoint = GetNavigationPointMatchesTag( NavPointTag );

	if ( TheNavPoint != None )
	{
		if ( TheNavPoint.bIsNavigationPointLite )
		{
			NavigationPointLite( TheNavPoint ).bLevelDesignBlocked = false;
		}
		else if ( TheNavPoint.bIsNavigationPoint )
		{
			NavigationPoint( TheNavPoint ).bLevelDesignBlocked = false;
		}
	}
}

// Just like above function, only for multiple points sharing same tag.
function ACTION_UnBlockNavPoints( name NavPointTag )
{
	if (NavPointTag == '')
		return;

	UnBlockNavigationPointMatchesTag( NavPointTag );
}

function ACTION_SetDesiredSpeed( name PawnTag, float flDesiredSpeed )
{
	local WargamePawn MyPawn;
	
	MyPawn = WargamePawn(GetFirstActor(PawnTag));

	Action_SetDesiredSpeedDirect( MyPawn, flDesiredSpeed );
}

function ACTION_SetDesiredSpeedDirect( WargamePawn MyPawn, float flDesiredSpeed )
{
	MyPawn.MaxDesiredSpeed = flDesiredSpeed;
}


/////////////////////////////////////
// Tank Scripted Control Functions //
/////////////////////////////////////

function ACTION_TankEnterScriptedMode( Tank MyTank )
{
	local Controller C, OldC;
	local class<AIController> ControllerClass;
	local int size;
	local TankStuartController TStuartC;
	local TankShermanController TShermanC;
	local TankM10Controller TM10C;
	local TankPanzerIVController TPanzerIVC;
	local TankStugController TStugC;

	if (MyTank == None)
	{
		SLog("ACTION_TankEnterScriptedMode() ERROR: MyTank is None!");
		SetSucceeded( false );
		return;
	}

	if ((MyTank.Controller == None) || (TankController(MyTank.Controller) == None))
	{
		// create a TankController for this specific type of tank...
		if (MyTank.IsA('TankStuart'))
			ControllerClass = class'TankStuartController';
		if (MyTank.IsA('TankSherman'))
			ControllerClass = class'TankShermanController';
		if (MyTank.IsA('TankM10_'))
			ControllerClass = class'TankM10Controller';
		if (MyTank.IsA('TankPanzerIV'))
			ControllerClass = class'TankPanzerIVController';
		if (MyTank.IsA('TankStug'))
			ControllerClass = class'TankStugController';
		if (MyTank.IsA('TankStugLongGun'))
			ControllerClass = class'TankStugController';
		if (MyTank.IsA('TankPanzerIVLongGun'))
			ControllerClass = class'TankPanzerIVController';

		if (ControllerClass != None)
		{
			C = Spawn( ControllerClass );

			if( C == None )
			{
				SLog( name $ ".ACTION_TankEnterScriptedMode( '" $ MyTank.name $ "', " $ ControllerClass $ "  ): could not spawn controller of that class." );

				SetSucceeded( false );
			}
			else
			{
				if( MyTank.Controller != None )
				{
					// Make the prior controller unpossess the pawn.
					if (MyTank.Controller.IsA('ScriptedController'))
					{
						MyTank.FlushAnimQueueChannel( 0, true );
						MyTank.ClearIdleQueue();
						MyTank.m_fRunNextQueueIdle = false;
					}

					OldC = MyTank.Controller;

					MyTank.Controller.UnPossess();
					if ( OldC != None )
					{
						OldC.Destroy();
					}
				}

				C.Possess( MyTank );

			}
		}
	}

	TankController(MyTank.Controller).bIsInScriptedMode = true;

	TankController(MyTank.Controller).bKeepRotatingTowardsTarget = false;

	// stop moving and turning...
	TankController(MyTank.Controller).StopRotating();
	TankController(MyTank.Controller).StopNavigating();

	// remove all targets from the target queue...
	if (TankStuartController(MyTank.Controller) != None)
	{
		TStuartC = TankStuartController(MyTank.Controller);
		size = TStuartC.MyMainGunController.TargetQueue.Length;
		TStuartC.MyMainGunController.TargetQueue.Remove( 0, size );
		TStuartC.MyMainGunController.SetEnemy( None );
		TStuartC.MainGunTarget = None;
		TStuartC.CoaxGunTarget = None;
		size = TStuartC.MyBowGunController.TargetQueue.Length;
		TStuartC.MyBowGunController.TargetQueue.Remove( 0, size );
		TStuartC.MyBowGunController.SetEnemy( None );
		TStuartC.BowGunTarget = None;

		TStuartC.bRotateToFaceEnemy = false;
		TStuartC.EnemyRotateToFace = None;

		TStuartC.GotoState('Scripted');  // only Stuart, Sherman and M10 need to be forced into Scripted state
	}
	if (TankShermanController(MyTank.Controller) != None)
	{
		TShermanC = TankShermanController(MyTank.Controller);
		size = TShermanC.MyMainGunController.TargetQueue.Length;
		TShermanC.MyMainGunController.TargetQueue.Remove( 0, size );
		TShermanC.MyMainGunController.SetEnemy( None );
		TShermanC.MainGunTarget = None;
		TShermanC.CoaxGunTarget = None;
		size = TShermanC.MyBowGunController.TargetQueue.Length;
		TShermanC.MyBowGunController.TargetQueue.Remove( 0, size );
		TShermanC.MyBowGunController.SetEnemy( None );
		TShermanC.BowGunTarget = None;

		TShermanC.bRotateToFaceEnemy = false;
		TShermanC.EnemyRotateToFace = None;

		TShermanC.GotoState('Scripted');  // only Stuart, Sherman and M10 need to be forced into Scripted state
	}
	if (TankM10Controller(MyTank.Controller) != None)
	{
		TM10C = TankM10Controller(MyTank.Controller);
		size = TM10C.MyMainGunController.TargetQueue.Length;
		TM10C.MyMainGunController.TargetQueue.Remove( 0, size );
		TM10C.MyMainGunController.SetEnemy( None );
		TM10C.MainGunTarget = None;

		TM10C.bRotateToFaceEnemy = false;
		TM10C.EnemyRotateToFace = None;

		TM10C.GotoState('Scripted');  // only Stuart, Sherman and M10 need to be forced into Scripted state
	}
	if (TankPanzerIVController(MyTank.Controller) != None)
	{
		TPanzerIVC = TankPanzerIVController(MyTank.Controller);
		size = TPanzerIVC.MyMainGunController.TargetQueue.Length;
		TPanzerIVC.MyMainGunController.TargetQueue.Remove( 0, size );
		TPanzerIVC.MyMainGunController.SetEnemy( None );
		TPanzerIVC.MainGunTarget = None;
		size = TPanzerIVC.MyBowGunController.TargetQueue.Length;
		TPanzerIVC.MyBowGunController.TargetQueue.Remove( 0, size );
		TPanzerIVC.MyBowGunController.SetEnemy( None );
		TPanzerIVC.BowGunTarget = None;

		TPanzerIVC.bRotateToFaceEnemy = false;
		TPanzerIVC.EnemyRotateToFace = None;

		// PanzerIV states will automatically transition to Scripted state
	}
	if (TankStugController(MyTank.Controller) != None)
	{
		TStugC = TankStugController(MyTank.Controller);
		size = TStugC.MyMainGunController.TargetQueue.Length;
		TStugC.MyMainGunController.TargetQueue.Remove( 0, size );
		TStugC.MyMainGunController.SetEnemy( None );
		TStugC.MainGunTarget = None;

		TStugC.bRotateToFaceEnemy = false;
		TStugC.EnemyRotateToFace = None;

		// Stug states will automatically transition to Scripted state
	}

	if (MyTank.CommanderPawn != None)
	{
		MyTank.CommanderPawn.GotoState('Scripted');
	}

	SetSucceeded( true );
}

function ACTION_TankLeaveScriptedMode( Tank MyTank )
{
	local TankStuartController TStuartC;
	local TankShermanController TShermanC;
	local TankM10Controller TM10C;
	local TankPanzerIVController TPanzerIVC;
	local TankStugController TStugC;

	if (MyTank == None)
	{
		SLog("ACTION_TankLeaveScriptedMode() ERROR: MyTank is None!");
		SetSucceeded( false );
		return;
	}

	if ((MyTank.Controller == None) || (TankController(MyTank.Controller) == None))
	{
		SLog("ACTION_TankLeaveScriptedMode() ERROR: MyTank.Controller = " $ MyTank.Controller $ " is not a TankController!");
		SetSucceeded( false );
		return;
	}

	// remove any RotateToward target...
	TankController(MyTank.Controller).bKeepRotatingTowardsTarget = false;
	TankController(MyTank.Controller).RotateTowardTarget(None);

	// stop moving and turning...
	TankController(MyTank.Controller).StopRotating();
	TankController(MyTank.Controller).StopNavigating();

	// make sure player usable machine gun triggers are enabled...
	if (TankStuart(MyTank) != None)
	{
		if (!TankStuart(MyTank).bDisablePlayerUseableTriggers)
		{
			TankStuart(MyTank).MachineGunRearTrigger.bDisabled = false;
			TankStuart(MyTank).MachineGunTurretTrigger.bDisabled = false;
		}
	}
	if (TankSherman(MyTank) != None)
	{
		if (!TankSherman(MyTank).bDisablePlayerUseableTriggers)
		{
			TankSherman(MyTank).MachineGunRearTrigger.bDisabled = false;
			TankSherman(MyTank).MachineGunTurretTrigger.bDisabled = false;
		}
	}
	if (TankM10_(MyTank) != None)
	{
		if (!TankM10_(MyTank).bDisablePlayerUseableTriggers)
		{
			TankM10_(MyTank).MachineGunRearTrigger.bDisabled = false;
			TankM10_(MyTank).MachineGunTurretTrigger.bDisabled = false;
		}
	}

	// remove any enemy...
	if (TankStuartController(MyTank.Controller) != None)
	{
		TStuartC = TankStuartController(MyTank.Controller);
		TStuartC.MyMainGunController.SetEnemy( None );
		TStuartC.MainGunTarget = None;
		TStuartC.CoaxGunTarget = None;
		TStuartC.MyBowGunController.SetEnemy( None );
		TStuartC.BowGunTarget = None;

		TStuartC.MyMainGunController.ReactionTimeMin = TStuartC.MyMainGunController.Default.ReactionTimeMin;
		TStuartC.MyMainGunController.ReactionTimeMax = TStuartC.MyMainGunController.Default.ReactionTimeMax;
	}
	if (TankShermanController(MyTank.Controller) != None)
	{
		TShermanC = TankShermanController(MyTank.Controller);
		TShermanC.MyMainGunController.SetEnemy( None );
		TShermanC.MainGunTarget = None;
		TShermanC.CoaxGunTarget = None;
		TShermanC.MyBowGunController.SetEnemy( None );
		TShermanC.BowGunTarget = None;

		TShermanC.MyMainGunController.ReactionTimeMin = TShermanC.MyMainGunController.Default.ReactionTimeMin;
		TShermanC.MyMainGunController.ReactionTimeMax = TShermanC.MyMainGunController.Default.ReactionTimeMax;
	}
	if (TankM10Controller(MyTank.Controller) != None)
	{
		TM10C = TankM10Controller(MyTank.Controller);
		TM10C.MyMainGunController.SetEnemy( None );
		TM10C.MainGunTarget = None;

		TM10C.MyMainGunController.ReactionTimeMin = TM10C.MyMainGunController.Default.ReactionTimeMin;
		TM10C.MyMainGunController.ReactionTimeMax = TM10C.MyMainGunController.Default.ReactionTimeMax;
	}
	if (TankPanzerIVController(MyTank.Controller) != None)
	{
		TPanzerIVC = TankPanzerIVController(MyTank.Controller);
		TPanzerIVC.MyMainGunController.SetEnemy( None );
		TPanzerIVC.MainGunTarget = None;
		TPanzerIVC.MyBowGunController.SetEnemy( None );
		TPanzerIVC.BowGunTarget = None;

		TPanzerIVC.MyMainGunController.ReactionTimeMin = TPanzerIVC.MyMainGunController.Default.ReactionTimeMin;
		TPanzerIVC.MyMainGunController.ReactionTimeMax = TPanzerIVC.MyMainGunController.Default.ReactionTimeMax;
	}
	if (TankStugController(MyTank.Controller) != None)
	{
		TStugC = TankStugController(MyTank.Controller);
		TStugC.MyMainGunController.SetEnemy( None );
		TStugC.MainGunTarget = None;

		TStugC.MyMainGunController.ReactionTimeMin = TStugC.MyMainGunController.Default.ReactionTimeMin;
		TStugC.MyMainGunController.ReactionTimeMax = TStugC.MyMainGunController.Default.ReactionTimeMax;
	}

	// set tank speed back to normal speed...
	MyTank.MaxThrust = MyTank.Default.MaxThrust;

	// turn sounds back on
	MyTank.bNoSound = false;

	if ((MyTank.Health > 0) && MyTank.CommanderPawn != None)
	{
		MyTank.CommanderPawn.ResetLookAt(true, true);

		MyTank.CommanderPawn.FlushAnimQueueChannel( 0,, true );

		if (MyTank.CommanderPawn.bHatchClosing)
			MyTank.CommanderPawn.GotoState('Combat');
		else
			MyTank.CommanderPawn.GotoState('Idle');
	}

	TankController(MyTank.Controller).bIsInScriptedMode = false;

	SetSucceeded( true );
}

function ACTION_TankMoveTo( Tank MyTank, ActorLite MoveDest )
{
	if (MyTank == None)
	{
		SLog("ACTION_TankMoveTo() ERROR: MyTank is None!");
		SetSucceeded( false );
		return;
	}

	if ((MyTank.Controller == None) || (TankController(MyTank.Controller) == None))
	{
		SLog("ACTION_TankMoveTo() ERROR: MyTank.Controller = " $ MyTank.Controller $ " is not a TankController!");
		SetSucceeded( false );
		return;
	}

	TankController(MyTank.Controller).MoveToDestination(MoveDest);
	SetSucceeded( true );
}

function bool ACTION_TankIsAtDestination( Tank MyTank, ActorLite MoveDest )
{
	local bool bAtDest;

	if (MyTank == None)
	{
		SLog("ACTION_TankIsAtDestination() ERROR: MyTank is None!");
		SetSucceeded( false );
		return false;
	}

	if ((MyTank.Controller == None) || (TankController(MyTank.Controller) == None))
	{
		SLog("ACTION_TankIsAtDestination() ERROR: MyTank.Controller = " $ MyTank.Controller $ " is not a TankController!");
		SetSucceeded( false );
		return false;
	}

	bAtDest = MyTank.ReachedDestination(MoveDest);
	SetSucceeded( true );
	return bAtDest;
}

function ACTION_TankSetSpeed( Tank MyTank, float percent )
{
	local float actual_percent;

	if (MyTank == None)
	{
		SLog("ACTION_TankSetSpeed() ERROR: MyTank is None!");
		SetSucceeded( false );
		return;
	}

	if ((MyTank.Controller == None) || (TankController(MyTank.Controller) == None))
	{
		SLog("ACTION_TankSetSpeed() ERROR: MyTank.Controller = " $ MyTank.Controller $ " is not a TankController!");
		SetSucceeded( false );
		return;
	}

	actual_percent = FClamp(percent, 0.0, 1.0);

	MyTank.MaxThrust = MyTank.Default.MaxThrust * actual_percent;
	SetSucceeded( true );
}

function ACTION_TankRotateBodyToward( Tank MyTank, Actor FacingActor, optional bool bTrackTarget )
{
	if (MyTank == None)
	{
		SLog("ACTION_TankRotateBodyToward() ERROR: MyTank is None!");
		SetSucceeded( false );
		return;
	}

	if ((MyTank.Controller == None) || (TankController(MyTank.Controller) == None))
	{
		SLog("ACTION_TankRotateBodyToward() ERROR: MyTank.Controller = " $ MyTank.Controller $ " is not a TankController!");
		SetSucceeded( false );
		return;
	}

	if (TankController(MyTank.Controller).bIsNavigating)
		TankController(MyTank.Controller).StopNavigating();  // stop navigating

	if (FacingActor != None)
	{
		TankController(MyTank.Controller).bKeepRotatingTowardsTarget = bTrackTarget;
		TankController(MyTank.Controller).RotateTowardTarget(FacingActor);
	}
	else
	{
		TankController(MyTank.Controller).bKeepRotatingTowardsTarget = false;
		TankController(MyTank.Controller).RotateTowardTarget(None);
		TankController(MyTank.Controller).StopRotating();
	}

	SetSucceeded( true );
}

function ACTION_TankHalt( Tank MyTank )
{
	if (MyTank == None)
	{
		SLog("ACTION_TankHalt() ERROR: MyTank is None!");
		SetSucceeded( false );
		return;
	}

	if ((MyTank.Controller == None) || (TankController(MyTank.Controller) == None))
	{
		SLog("ACTION_TankHalt() ERROR: MyTank.Controller = " $ MyTank.Controller $ " is not a TankController!");
		SetSucceeded( false );
		return;
	}

	TankController(MyTank.Controller).StopRotating();
	TankController(MyTank.Controller).StopNavigating();

	SetSucceeded( true );
}

function ACTION_TankSetEnemy( Tank MyTank, Actor Enemy, optional bool bDontRotateBody )
{
	local TankStuartController TStuartC;
	local TankShermanController TShermanC;
	local TankM10Controller TM10C;
	local TankPanzerIVController TPanzerIVC;
	local TankStugController TStugC;

	if (MyTank == None)
	{
		SLog("ACTION_TankSetEnemy() ERROR: MyTank is None!");
		SetSucceeded( false );
		return;
	}

	if ((MyTank.Controller == None) || (TankController(MyTank.Controller) == None))
	{
		SLog("ACTION_TankSetEnemy() ERROR: MyTank.Controller = " $ MyTank.Controller $ " is not a TankController!");
		SetSucceeded( false );
		return;
	}

	if (Enemy == None)
	{
		SLog("ACTION_TankSetEnemy() ERROR: Enemy is None!");
		SetSucceeded( false );
		return;
	}

	if (TankStuartController(MyTank.Controller) != None)
	{
		TStuartC = TankStuartController(MyTank.Controller);
		TStuartC.MyMainGunController.ReactionTimeMin = 0.0f;
		TStuartC.MyMainGunController.ReactionTimeMax = 0.0f;

		TStuartC.MyMainGunController.SetEnemy( Enemy );
		TStuartC.MainGunTarget = Enemy;
		TStuartC.MyMainGunController.bIsOnTarget = false;
		if (bDontRotateBody)
		{
			TStuartC.bRotateToFaceEnemy = false;
			TStuartC.EnemyRotateToFace = None;
		}
		else
		{
			TStuartC.bRotateToFaceEnemy = true;
			TStuartC.EnemyRotateToFace = Enemy;
		}
	}
	if (TankShermanController(MyTank.Controller) != None)
	{
		TShermanC = TankShermanController(MyTank.Controller);
		TShermanC.MyMainGunController.ReactionTimeMin = 0.0f;
		TShermanC.MyMainGunController.ReactionTimeMax = 0.0f;

		TShermanC.MyMainGunController.SetEnemy( Enemy );
		TShermanC.MainGunTarget = Enemy;
		TShermanC.MyMainGunController.bIsOnTarget = false;
		if (bDontRotateBody)
		{
			TShermanC.bRotateToFaceEnemy = false;
			TShermanC.EnemyRotateToFace = None;
		}
		else
		{
			TShermanC.bRotateToFaceEnemy = true;
			TShermanC.EnemyRotateToFace = Enemy;
		}
	}
	if (TankM10Controller(MyTank.Controller) != None)
	{
		TM10C = TankM10Controller(MyTank.Controller);
		TM10C.MyMainGunController.ReactionTimeMin = 0.0f;
		TM10C.MyMainGunController.ReactionTimeMax = 0.0f;

		TM10C.MyMainGunController.SetEnemy( Enemy );
		TM10C.MainGunTarget = Enemy;
		TM10C.MyMainGunController.bIsOnTarget = false;
		if (bDontRotateBody)
		{
			TM10C.bRotateToFaceEnemy = false;
			TM10C.EnemyRotateToFace = None;
		}
		else
		{
			TM10C.bRotateToFaceEnemy = true;
			TM10C.EnemyRotateToFace = Enemy;
		}
	}
	if (TankPanzerIVController(MyTank.Controller) != None)
	{
		TPanzerIVC = TankPanzerIVController(MyTank.Controller);
		TPanzerIVC.MyMainGunController.ReactionTimeMin = 0.0f;
		TPanzerIVC.MyMainGunController.ReactionTimeMax = 0.0f;

		TPanzerIVC.MyMainGunController.SetEnemy( Enemy );
		TPanzerIVC.MainGunTarget = Enemy;
		TPanzerIVC.MyMainGunController.bIsOnTarget = false;
		if (bDontRotateBody)
		{
			TPanzerIVC.bRotateToFaceEnemy = false;
			TPanzerIVC.EnemyRotateToFace = None;
		}
		else
		{
			TPanzerIVC.bRotateToFaceEnemy = true;
			TPanzerIVC.EnemyRotateToFace = Enemy;
		}
	}
	if (TankStugController(MyTank.Controller) != None)
	{
		TStugC = TankStugController(MyTank.Controller);
		TStugC.MyMainGunController.ReactionTimeMin = 0.0f;
		TStugC.MyMainGunController.ReactionTimeMax = 0.0f;

		TStugC.MyMainGunController.SetEnemy( Enemy );
		TStugC.MainGunTarget = Enemy;
		TStugC.MyMainGunController.bIsOnTarget = false;
	}

	SetSucceeded( true );
}

function bool ACTION_TankIsAimingAtEnemy( Tank MyTank )
{
	if (MyTank == None)
	{
		SLog("ACTION_TankIsAimingAtEnemy() ERROR: MyTank is None!");
		SetSucceeded( false );
		return false;
	}

	if ((MyTank.Controller == None) || (TankController(MyTank.Controller) == None))
	{
		SLog("ACTION_TankIsAimingAtEnemy() ERROR: MyTank.Controller = " $ MyTank.Controller $ " is not a TankController!");
		SetSucceeded( false );
		return false;
	}

	if (TankStuartController(MyTank.Controller) != None)
	{
		if (TankStuartController(MyTank.Controller).MainGunTarget == None)
		{
			SLog("ACTION_TankIsAimingAtEnemy() ERROR: This Tank doesn't have an Enemy set yet!");
			SetSucceeded( false );
			return false;  // no enemy has been set
		}
		SetSucceeded( true );
		return TankStuartController(MyTank.Controller).MyMainGunController.bIsOnTarget;
	}
	if (TankShermanController(MyTank.Controller) != None)
	{
		if (TankShermanController(MyTank.Controller).MainGunTarget == None)
		{
			SLog("ACTION_TankIsAimingAtEnemy() ERROR: This Tank doesn't have an Enemy set yet!");
			SetSucceeded( false );
			return false;  // no enemy has been set
		}
		SetSucceeded( true );
		return TankShermanController(MyTank.Controller).MyMainGunController.bIsOnTarget;
	}
	if (TankM10Controller(MyTank.Controller) != None)
	{
		if (TankM10Controller(MyTank.Controller).MainGunTarget == None)
		{
			SLog("ACTION_TankIsAimingAtEnemy() ERROR: This Tank doesn't have an Enemy set yet!");
			SetSucceeded( false );
			return false;  // no enemy has been set
		}
		SetSucceeded( true );
		return TankM10Controller(MyTank.Controller).MyMainGunController.bIsOnTarget;
	}
	if (TankPanzerIVController(MyTank.Controller) != None)
	{
		if (TankPanzerIVController(MyTank.Controller).MainGunTarget == None)
		{
			SLog("ACTION_TankIsAimingAtEnemy() ERROR: This Tank doesn't have an Enemy set yet!");
			SetSucceeded( false );
			return false;  // no enemy has been set
		}
		SetSucceeded( true );
		return TankPanzerIVController(MyTank.Controller).MyMainGunController.bIsOnTarget;
	}
	if (TankStugController(MyTank.Controller) != None)
	{
		if (TankStugController(MyTank.Controller).MainGunTarget == None)
		{
			SLog("ACTION_TankIsAimingAtEnemy() ERROR: This Tank doesn't have an Enemy set yet!");
			SetSucceeded( false );
			return false;  // no enemy has been set
		}
		SetSucceeded( true );
		return TankStugController(MyTank.Controller).MyMainGunController.bIsOnTarget;
	}

	SetSucceeded( false );
	return false;
}

function ACTION_TankFireCannon( Tank MyTank, optional bool bDoNoDamage )
{
	local int PreviousAimError;

	if (MyTank == None)
	{
		SLog("ACTION_TankSetEnemy() ERROR: MyTank is None!");
		SetSucceeded( false );
		return;
	}

	if ((MyTank.Controller == None) || (TankController(MyTank.Controller) == None))
	{
		SLog("ACTION_TankSetEnemy() ERROR: MyTank.Controller = " $ MyTank.Controller $ " is not a TankController!");
		SetSucceeded( false );
		return;
	}

	if (TankStuartController(MyTank.Controller) != None)
	{
		PreviousAimError = TankStuartController(MyTank.Controller).MyMainGunController.AimErrorAIMain;
		TankStuartController(MyTank.Controller).MyMainGunController.AimErrorAIMain = 0;  // prefect accuracy
		TankStuartController(MyTank.Controller).MyMainGunController.FireMainGun(bDoNoDamage);
		TankStuartController(MyTank.Controller).MyMainGunController.AimErrorAIMain = PreviousAimError;
	}
	if (TankShermanController(MyTank.Controller) != None)
	{
		PreviousAimError = TankShermanController(MyTank.Controller).MyMainGunController.AimErrorAIMain;
		TankShermanController(MyTank.Controller).MyMainGunController.AimErrorAIMain = 0;  // prefect accuracy
		TankShermanController(MyTank.Controller).MyMainGunController.FireMainGun(bDoNoDamage);
		TankShermanController(MyTank.Controller).MyMainGunController.AimErrorAIMain = PreviousAimError;
	}
	if (TankM10Controller(MyTank.Controller) != None)
	{
		PreviousAimError = TankM10Controller(MyTank.Controller).MyMainGunController.AimErrorAIMain;
		TankM10Controller(MyTank.Controller).MyMainGunController.AimErrorAIMain = 0;  // prefect accuracy
		TankM10Controller(MyTank.Controller).MyMainGunController.FireMainGun(bDoNoDamage);
		TankM10Controller(MyTank.Controller).MyMainGunController.AimErrorAIMain = PreviousAimError;
	}
	if (TankPanzerIVController(MyTank.Controller) != None)
	{
		PreviousAimError = TankPanzerIVController(MyTank.Controller).MyMainGunController.AimErrorAI;
		TankPanzerIVController(MyTank.Controller).MyMainGunController.AimErrorAI = 0;  // prefect accuracy
		TankPanzerIVController(MyTank.Controller).MyMainGunController.FireMainGun(bDoNoDamage);
		TankPanzerIVController(MyTank.Controller).MyMainGunController.AimErrorAI = PreviousAimError;
	}
	if (TankStugController(MyTank.Controller) != None)
	{
		PreviousAimError = TankStugController(MyTank.Controller).MyMainGunController.AimErrorAI;
		TankStugController(MyTank.Controller).MyMainGunController.AimErrorAI = 0;  // prefect accuracy
		TankStugController(MyTank.Controller).MyMainGunController.FireMainGun(bDoNoDamage);
		TankStugController(MyTank.Controller).MyMainGunController.AimErrorAI = PreviousAimError;
	}

	SetSucceeded( true );
}

function ACTION_TankSetNoEnemy( Tank MyTank, optional bool bResetTurret )
{
	local TankStuartController TStuartC;
	local TankShermanController TShermanC;
	local TankM10Controller TM10C;
	local TankPanzerIVController TPanzerIVC;
	local TankStugController TStugC;

	if (MyTank == None)
	{
		SLog("ACTION_TankSetNoEnemy() ERROR: MyTank is None!");
		SetSucceeded( false );
		return;
	}

	if ((MyTank.Controller == None) || (TankController(MyTank.Controller) == None))
	{
		SLog("ACTION_TankSetNoEnemy() ERROR: MyTank.Controller = " $ MyTank.Controller $ " is not a TankController!");
		SetSucceeded( false );
		return;
	}

	// remove any enemy...
	if (TankStuartController(MyTank.Controller) != None)
	{
		TStuartC = TankStuartController(MyTank.Controller);
		TStuartC.MyMainGunController.SetEnemy( None );
		TStuartC.MainGunTarget = None;
		TStuartC.CoaxGunTarget = None;
		TStuartC.MyBowGunController.SetEnemy( None );
		TStuartC.BowGunTarget = None;
		TStuartC.bRotateToFaceEnemy = false;
		TStuartC.EnemyRotateToFace = None;
	}
	if (TankShermanController(MyTank.Controller) != None)
	{
		TShermanC = TankShermanController(MyTank.Controller);
		TShermanC.MyMainGunController.SetEnemy( None );
		TShermanC.MainGunTarget = None;
		TShermanC.CoaxGunTarget = None;
		TShermanC.MyBowGunController.SetEnemy( None );
		TShermanC.BowGunTarget = None;
		TShermanC.bRotateToFaceEnemy = false;
		TShermanC.EnemyRotateToFace = None;
	}
	if (TankM10Controller(MyTank.Controller) != None)
	{
		TM10C = TankM10Controller(MyTank.Controller);
		TM10C.MyMainGunController.SetEnemy( None );
		TM10C.MainGunTarget = None;
		TM10C.bRotateToFaceEnemy = false;
		TM10C.EnemyRotateToFace = None;
	}
	if (TankPanzerIVController(MyTank.Controller) != None)
	{
		TPanzerIVC = TankPanzerIVController(MyTank.Controller);
		TPanzerIVC.MyMainGunController.SetEnemy( None );
		TPanzerIVC.MainGunTarget = None;
		TPanzerIVC.MyBowGunController.SetEnemy( None );
		TPanzerIVC.BowGunTarget = None;
		TPanzerIVC.bRotateToFaceEnemy = false;
		TPanzerIVC.EnemyRotateToFace = None;
	}
	if (TankStugController(MyTank.Controller) != None)
	{
		TStugC = TankStugController(MyTank.Controller);
		TStugC.MyMainGunController.SetEnemy( None );
		TStugC.MainGunTarget = None;
		TStugC.bRotateToFaceEnemy = false;
		TStugC.EnemyRotateToFace = None;
	}

	SetSucceeded( true );
}

function ACTION_TankDisablePlayerUseTrigger( Tank MyTank )
{
	if (MyTank == None)
	{
		SLog("ACTION_TankDisablePlayerUseTrigger() ERROR: MyTank is None!");
		SetSucceeded( false );
		return;
	}

	if ((MyTank.Controller == None) || (TankController(MyTank.Controller) == None))
	{
		SLog("ACTION_TankDisablePlayerUseTrigger() ERROR: MyTank.Controller = " $ MyTank.Controller $ " is not a TankController!");
		SetSucceeded( false );
		return;
	}

	if (TankStuart(MyTank) != None)
	{
		TankStuart(MyTank).MachineGunRearTrigger.bDisabled = true;
		TankStuart(MyTank).MachineGunTurretTrigger.bDisabled = true;
	}
	if (TankSherman(MyTank) != None)
	{
		TankSherman(MyTank).MachineGunRearTrigger.bDisabled = true;
		TankSherman(MyTank).MachineGunTurretTrigger.bDisabled = true;
	}
	if (TankM10_(MyTank) != None)
	{
		TankM10_(MyTank).MachineGunRearTrigger.bDisabled = true;
		TankM10_(MyTank).MachineGunTurretTrigger.bDisabled = true;
	}
	if (TankPanzerIV(MyTank) != None)
	{
		TankPanzerIV(MyTank).MyTankGrenadeTrigger.bDisabled = true;
	}
	if (TankStug(MyTank) != None)
	{
		TankStug(MyTank).MyTankGrenadeTrigger.bDisabled = true;
	}
}

function ACTION_TankEnablePlayerUseTrigger( Tank MyTank )
{
	if (MyTank == None)
	{
		SLog("ACTION_TankEnablePlayerUseTrigger() ERROR: MyTank is None!");
		SetSucceeded( false );
		return;
	}

	if ((MyTank.Controller == None) || (TankController(MyTank.Controller) == None))
	{
		SLog("ACTION_TankEnablePlayerUseTrigger() ERROR: MyTank.Controller = " $ MyTank.Controller $ " is not a TankController!");
		SetSucceeded( false );
		return;
	}

	if (TankStuart(MyTank) != None)
	{
		TankStuart(MyTank).MachineGunRearTrigger.bDisabled = false;
		TankStuart(MyTank).MachineGunTurretTrigger.bDisabled = false;
	}
	if (TankSherman(MyTank) != None)
	{
		TankSherman(MyTank).MachineGunRearTrigger.bDisabled = false;
		TankSherman(MyTank).MachineGunTurretTrigger.bDisabled = false;
	}
	if (TankM10_(MyTank) != None)
	{
		TankM10_(MyTank).MachineGunRearTrigger.bDisabled = false;
		TankM10_(MyTank).MachineGunTurretTrigger.bDisabled = false;
	}
	if (TankPanzerIV(MyTank) != None)
	{
		TankPanzerIV(MyTank).MyTankGrenadeTrigger.bDisabled = false;
	}
	if (TankStug(MyTank) != None)
	{
		TankStug(MyTank).MyTankGrenadeTrigger.bDisabled = false;
	}
}

function ACTION_TankNoEngineSound( Tank MyTank )
{
	if (MyTank == None)
	{
		SLog("ACTION_TankNoEngineSound() ERROR: MyTank is None!");
		SetSucceeded( false );
		return;
	}

	if ((MyTank.Controller == None) || (TankController(MyTank.Controller) == None))
	{
		SLog("ACTION_TankNoEngineSound() ERROR: MyTank.Controller = " $ MyTank.Controller $ " is not a TankController!");
		SetSucceeded( false );
		return;
	}

	MyTank.bNoSound = true;

	MyTank.AmbientSound = None;
}

function ACTION_TankKill( Tank MyTank )
{
	if (MyTank == None)
	{
		SLog("ACTION_TankKill() ERROR: MyTank is None!");
		SetSucceeded( false );
		return;
	}

	if ((MyTank.Controller == None) || (TankController(MyTank.Controller) == None))
	{
		SLog("ACTION_TankKill() ERROR: MyTank.Controller = " $ MyTank.Controller $ " is not a TankController!");
		SetSucceeded( false );
		return;
	}

	if (MyTank.Health <= 0)  // already dead?
	{
		SetSucceeded( true );
		return;
	}

	MyTank.Controller.bGodMode = false;

	MyTank.TakeDamage(1, None, MyTank.Location, vect(0,0,0), class'DamageGammonBomb');

	SetSucceeded( true );
}


function bool ACTION_TankCommanderOpenHatch( Tank MyTank, optional name CommanderAnim, optional name TankAnim )
{
	if (MyTank == None)
	{
		SLog("ACTION_TankCommanderOpenHatch() ERROR: MyTank is None!");
		SetSucceeded( false );
		return false;
	}

	if ((MyTank.Controller == None) || (TankController(MyTank.Controller) == None))
	{
		SLog("ACTION_TankCommanderOpenHatch() ERROR: MyTank.Controller = " $ MyTank.Controller $ " is not a TankController!");
		SetSucceeded( false );
		return false;
	}

	if (MyTank.CommanderPawn != None)
	{
		if (!MyTank.CommanderPawn.bScriptedAnimDone)
		{
			SLog("ACTION_TankCommanderOpenHatch() ERROR: Previous animation is still in progress  Wait for it to finish first!");
			SetSucceeded( false );
			return false;
		}

		if (MyTank.CommanderPawn.bHatchClosing)
		{
			MyTank.CommanderPawn.bScriptedHatchOpenOrClose = true;

			if (MyTank.CommanderPawn.HitCylinder != None)
				MyTank.CommanderPawn.bAllowDamage = true;

			MyTank.CommanderPawn.bHidden = false;  // don't hide the pawn anymore
			MyTank.CommanderPawn.bHidePawn = false;

			MyTank.CommanderPawn.bHatchClosing = false;
			MyTank.CommanderPawn.bScriptedAnimDone = false;

			MyTank.CommanderPawn.DisableMainGunFiringAnims();  // turn off the blending of the main gun firing anims (since this messes up the hatch bones)

			if (CommanderAnim == '')
				MyTank.CommanderPawn.AddAnimToQueue(MyTank.CommanderPawn.CommanderOpenHatchAnim, 90, false, false, false, 1.0, 0.15);
			else
				MyTank.CommanderPawn.AddAnimToQueue(CommanderAnim, 90, false, false, false, 1.0, 0.15);

			if (TankAnim == '')
				MyTank.AddAnimToQueue(MyTank.CommanderPawn.TankCommanderOpenHatchAnim, 99, false, false, false, 1.0, 0.15);
			else
				MyTank.AddAnimToQueue(TankAnim, 99, false, false, false, 1.0, 0.15);

			SetSucceeded( true );
			return true;
		}
	}

	SetSucceeded( false );
	return false;
}

function bool ACTION_TankCommanderCloseHatch( Tank MyTank, optional name CommanderAnim, optional name TankAnim )
{
	if (MyTank == None)
	{
		SLog("ACTION_TankCommanderCloseHatch() ERROR: MyTank is None!");
		SetSucceeded( false );
		return false;
	}

	if ((MyTank.Controller == None) || (TankController(MyTank.Controller) == None))
	{
		SLog("ACTION_TankCommanderCloseHatch() ERROR: MyTank.Controller = " $ MyTank.Controller $ " is not a TankController!");
		SetSucceeded( false );
		return false;
	}

	if (MyTank.CommanderPawn != None)
	{
		if (!MyTank.CommanderPawn.bScriptedAnimDone)
		{
			SLog("ACTION_TankCommanderCloseHatch() ERROR: Previous animation is still in progress  Wait for it to finish first!");
			SetSucceeded( false );
			return false;
		}

		if ((!MyTank.CommanderPawn.bHatchClosing) && (!MyTank.CommanderPawn.bHatchFullyClosed))
		{
			MyTank.CommanderPawn.bScriptedHatchOpenOrClose = true;

			MyTank.CommanderPawn.bAllowDamage = false;
			MyTank.CommanderPawn.bHidePawn = true;  // hide the pawn after this animation is done...

			if (MyTank.CommanderPawn.HitCylinder != None)
				MyTank.CommanderPawn.HitCylinder.bHidden = true;

			MyTank.CommanderPawn.bHatchClosing = true;
			MyTank.CommanderPawn.bScriptedAnimDone = false;

			// play close hatch animation...
			if (CommanderAnim == '')
				MyTank.CommanderPawn.AddAnimToQueue(MyTank.CommanderPawn.CommanderCloseHatchAnim, 90, true, false, false, 1.0, 0.15);
			else
				MyTank.CommanderPawn.AddAnimToQueue(CommanderAnim, 90, true, false, false, 1.0, 0.15);

			if (TankAnim == '')
				MyTank.AddAnimToQueue(MyTank.CommanderPawn.TankCommanderCloseHatchAnim, 99, true, false, false, 1.0, 0.15);
			else
				MyTank.AddAnimToQueue(TankAnim, 99, true, false, false, 1.0, 0.15);

			SetSucceeded( true );
			return true;
		}
	}

	SetSucceeded( false );
	return false;
}

function ACTION_TankCommanderPlayAnim( Tank MyTank, name BaseAnim, float BlendInTime, float AnimRate,
										optional bool bLoopAnim, optional string MeshAnimName )
{
	local MeshAnimation	aMeshAnim;

	if (MyTank == None)
	{
		SLog("ACTION_TankCommanderPlayAnim() ERROR: MyTank is None!");
		SetSucceeded( false );
		return;
	}

	if ((MyTank.Controller == None) || (TankController(MyTank.Controller) == None))
	{
		SLog("ACTION_TankCommanderPlayAnim() ERROR: MyTank.Controller = " $ MyTank.Controller $ " is not a TankController!");
		SetSucceeded( false );
		return;
	}

	if (MyTank.CommanderPawn != None)
	{
		if (MeshAnimName != "")
		{
			aMeshAnim = MeshAnimation(DynamicLoadObject(MeshAnimName,class'MeshAnimation'));

			if (aMeshAnim != None)
			{
				if (MyTank.CommanderPawn.LinkSkelAnim(aMeshAnim))
				{
					MyTank.CommanderPawn.MeshAnim = aMeshAnim;
					MyTank.CommanderPawn.MeshAnimName = MeshAnimName;
					MyTank.CommanderPawn.CurMeshAnimName = MyTank.CommanderPawn.MeshAnimName;
				}

				MyTank.CommanderPawn.bInitializeAnimation = false;
			}
		}

		if (bLoopAnim)
			MyTank.CommanderPawn.AddAnimToQueue(BaseAnim, SCRIPTED_ANIM_QUEUE_LOOP_PRIORITY, true, bLoopAnim, false, AnimRate, BlendInTime);
		else
			MyTank.CommanderPawn.AddAnimToQueue(BaseAnim, SCRIPTED_ANIM_QUEUE_PRIORITY, true, bLoopAnim, false, AnimRate, BlendInTime);
	}

	SetSucceeded( true );
}

function float ACTION_TankCommanderPlayLipSyncSound( Tank MyTank, string soundName, float volume, float pitch, float radius, optional bool bAttenuate )
{
	local Sound S;
	local float flDuration;

	if (MyTank == None)
	{
		SLog("ACTION_TankCommanderPlayLipSyncSound() ERROR: MyTank is None!");
		SetSucceeded( false );
		return 0.0f;
	}

	if ((MyTank.Controller == None) || (TankController(MyTank.Controller) == None))
	{
		SLog("ACTION_TankCommanderPlayLipSyncSound() ERROR: MyTank.Controller = " $ MyTank.Controller $ " is not a TankController!");
		SetSucceeded( false );
		return 0.0f;
	}

	if (MyTank.CommanderPawn != None)
	{
		if( soundName != "" )
		{
			S = Sound( DynamicLoadObject( soundName, class'Sound' ));

			if( S == None )
			{
				SLog( name $ ".ACTION_TankCommanderPlayLipSyncSound( '" $ MyTank.name $ "', '" $ soundName $ "', " $ volume $ ", " $ pitch $ ", " $ radius $ " ): could not find sound with that name."  );
				flDuration = 0.0f;
				SetSucceeded( false );
			}
			else
			{
				MyTank.CommanderPawn.PlaySound( S, SLOT_Talk, volume, false, radius, pitch, bAttenuate, true );
				flDuration = MyTank.CommanderPawn.GetSoundDuration( S );
				SetSucceeded( true );
			}

			return flDuration;
		}
	}

	SetSucceeded( false );
	return 0.0f;
}

function ACTION_TankCommanderLookAt( Tank MyTank, Actor LookAtActor )
{
	if (MyTank == None)
	{
		SLog("ACTION_TankCommanderLookAt() ERROR: MyTank is None!");
		SetSucceeded( false );
		return;
	}

	if ((MyTank.Controller == None) || (TankController(MyTank.Controller) == None))
	{
		SLog("ACTION_TankCommanderLookAt() ERROR: MyTank.Controller = " $ MyTank.Controller $ " is not a TankController!");
		SetSucceeded( false );
		return;
	}

	if (MyTank.CommanderPawn != None)
	{
		MyTank.CommanderPawn.SetLookAtTarget(LookAtActor, true, true);
		SetSucceeded( true );

		return;
	}

	SetSucceeded( false );
}

function ACTION_TankCommanderResetLookAt( Tank MyTank )
{
	if (MyTank == None)
	{
		SLog("ACTION_TankCommanderResetLookAt() ERROR: MyTank is None!");
		SetSucceeded( false );
		return;
	}

	if ((MyTank.Controller == None) || (TankController(MyTank.Controller) == None))
	{
		SLog("ACTION_TankCommanderResetLookAt() ERROR: MyTank.Controller = " $ MyTank.Controller $ " is not a TankController!");
		SetSucceeded( false );
		return;
	}

	if (MyTank.CommanderPawn != None)
	{
		MyTank.CommanderPawn.ResetLookAt(true, true);
		SetSucceeded( true );

		return;
	}

	SetSucceeded( false );
}

function ACTION_KarmaWakeAllDeadTanks()
{
	local Tank SomeTank;

	foreach AllActors( class'Tank', SomeTank )
	{
		if (SomeTank.Health <= 0)  // dead?
		{
			SomeTank.SetPhysics(PHYS_Karma);
			SomeTank.KWake();  // make sure we're awake

			SomeTank.KarmaSleepTime = Level.TimeSeconds + 5.0;  // put back to sleep again in 5.0 seconds
		}
	}
}

/////////////////////////////////////////
// END Tank Scripted Control Functions //
/////////////////////////////////////////

function bool TankHasEnemy(Tank MyTank)
{
	local bool bHasEnemy;

	bHasEnemy = false;

	if (TankStuartController(MyTank.Controller) != None)
	{
		if ((TankStuartController(MyTank.Controller).MainGunTarget != None) ||
			(TankStuartController(MyTank.Controller).CoaxGunTarget != None) ||
			(TankStuartController(MyTank.Controller).BowGunTarget != None))
			bHasEnemy = true;
	}
	if (TankShermanController(MyTank.Controller) != None)
	{
		if ((TankShermanController(MyTank.Controller).MainGunTarget != None) ||
			(TankShermanController(MyTank.Controller).CoaxGunTarget != None) ||
			(TankShermanController(MyTank.Controller).BowGunTarget != None))
			bHasEnemy = true;
	}
	if (TankM10Controller(MyTank.Controller) != None)
	{
		if (TankM10Controller(MyTank.Controller).MainGunTarget != None)
			bHasEnemy = true;
	}
	if (TankPanzerIVController(MyTank.Controller) != None)
	{
		if ((TankPanzerIVController(MyTank.Controller).MainGunTarget != None) ||
			(TankPanzerIVController(MyTank.Controller).BowGunTarget != None))
			bHasEnemy = true;
	}
	if (TankStugController(MyTank.Controller) != None)
	{
		if (TankStugController(MyTank.Controller).MainGunTarget != None)
			bHasEnemy = true;
	}

	SetSucceeded( true );
	return bHasEnemy;
}

function bool IsPlayerRidingTank(Tank MyTank)
{
	if (MyTank == None)
	{
		SetSucceeded( false );
		return false;
	}

	SetSucceeded( true );
	return MyTank.IsPlayerOnTank();
}

function ACTION_SetRepelBullets( name pawnTag, bool bRepel, optional float CutoffDistance )
{
	local gbxPawn thePawn;
	thePawn = gbxPawn( GetFirstActor( pawnTag ) );

	if( thePawn != None )
	{
		ACTION_SetRepelBulletsDirect( thePawn, bRepel, CutoffDistance );
	}
}

function ACTION_SetRepelBulletsDirect( gbxPawn thePawn, bool bRepel, optional float CutoffDistance )
{
	thePawn.SetRepelBullets( bRepel, CutoffDistance );
}
function ACTION_SetForcedFaceActor( Actor FFA, float TurnRate )
{
	local WargamePlayerController PC;

	PC = GetLocalPlayerController();

	PC.ForcedFaceActor = FFA;
	PC.ForcedFaceTurnRate = TurnRate;
	PC.ForcedFaceViewDiffInit = 0.0;
	PC.ForcedFaceAtDest = false;
}

function ACTION_ClearForcedFaceActor()
{
	local WargamePlayerController PC;

	PC = GetLocalPlayerController();

	PC.ForcedFaceActor = None;
}

function ACTION_AllowLongDistanceAIShots( bool bAllow, optional float CutoffDist, optional float AccuracyScalar )
{
	Level.AllowLongDistanceAIShots = bAllow;
	
	if ( bAllow )
	{
		if ( CutoffDist > 0.0f )
			Level.LongDistanceShotCutoffDist = CutoffDist;
		else
			Level.LongDistanceShotCutoffDist = 0.0f;

		if ( AccuracyScalar > 0.0f )
			Level.LongDistanceAccuracyScalar = AccuracyScalar;
		else
			Level.LongDistanceAccuracyScalar = 0.0f;
	}
	else
	{
		Level.LongDistanceShotCutoffDist = 0.0f;
		Level.LongDistanceAccuracyScalar = 0.0f;
	}
}

function ACTION_SetPawnIgnoreFriendlyFire( name PawnTag, bool bIgnore )
{
	local WargamePawn ThePawn;

	ThePawn = WargamePawn( GetPawn( PawnTag ) );
	if ( ThePawn != None )
	{
		ThePawn.SetIgnoreFriendlyFire( bIgnore );
	}
}

function ACTION_InsertOracleCamTarget( gbxPlayerController gbxPC, OracleCamLookTarget TargetActor, optional string TextLabel )
{
	if ( gbxPC != None && gbxPC.OracleCam != None && TargetActor != None )
	{
		TargetActor.SetTextLabel( TextLabel );
		gbxPC.OracleCam.AddTarget( TargetActor );
		gbxPC.OracleCam.OnTargetChanged();
	}
}

function ACTION_ToggleSAView( bool bAllow )
{
	local WargamePlayerController pc;

	pc = GetLocalPlayerController();

	if( pc != None )
	{
		pc.bOracleCameraDisabled = !bAllow;

		if( bAllow )
		{
			SLog( "ACTION_ToggleSAView: Situational Awareness View for "$pc$" is ENABLED." );
		}
		else
		{
			SLog( "ACTION_ToggleSAView: Situational Awareness View for "$pc$" is DISABLED." );
		}
	}
	else
	{
		SLog( "ACTION_ToggleSAView: ERROR - Could not find local player controller." );
	}
}

function ACTION_ForcePlayerDismountTurret()
{
	local WargamePawn WP;

	WP = WargamePawn( Level.GetLocalPlayerController().Pawn );

	if ((WP != None) && (WP.bIsManningTurret))
	{
		WP.PrepareTurretDismount();
		WP.CompleteTurretDismount();
		WP.StartGoingToStand(true);  // don't play the animation
	}
}

function ACTION_DisableAnimQueue( name szPawnTag, bool bDisable )
{
	local AnimPawn	P;
	
	P = AnimPawn(GetFirstActor( szPawnTag ));
	
	if (P == None)
	{
		SLog("ACTION_DisableAnimQueue() ERROR: Pawn = " $ szPawnTag $ " was not found!");
		SetSucceeded( false );
		return;
	}

	ACTION_DisableAnimQueueDirect( P, bDisable );
}

function ACTION_DisableAnimQueueDirect( AnimPawn aPawn, bool bDisable )
{
	if (bDisable)
	{
		aPawn.m_bDisableAnimQueue = true;
		aPawn.FlushAnimQueueChannel( 0,, true );
	}
	else
	{
		aPawn.m_bDisableAnimQueue = false;
	}
}

function ACTION_ChangeScriptedSequence( name szPawnTag, name szAIScriptTag )
{
	local AnimPawn	P;
	
	foreach DynamicActors( class'AnimPawn', P, szPawnTag )
	{
		ACTION_ChangeScriptedSequenceDirect( P, szAIScriptTag );
	}
}

function ACTION_ChangeScriptedSequenceDirect( AnimPawn aPawn, name szAIScriptTag )
{
	local AIScript		A;
	
	if (aPawn == None)
	{
		return;
	}
	
	if ( szAIScriptTag != '' )
	{
		aPawn.AIScriptTag = szAIScriptTag;
		ForEach AllActors(class'AIScript', A, szAIScriptTag)
			break;
		// let the AIScript spawn and init my controller
		if ( A != None )
		{
			if (aPawn.Controller != None)
			{
				aPawn.Controller.UnPossess();
			}
			A.SpawnControllerFor(aPawn);
		}
	}
}

////////////////////////////////////////////////////////////////////////////
// Skirmish game functions
////////////////////////////////////////////////////////////////////////////
function ACTION_IncrementEnemyAISkillSet()
{
	local WargameSkirmish	skrGame;
	local PlayerController	LocalPC, PC;
	
	if ( Level.Game.GameReplicationInfo.GameType == GT_SKIRMISH )
	{
		LocalPC = GetLocalPlayerController();
	
		skrGame = WargameSkirmish(Level.Game);

		// For debugging purposes, this function will print out the values 
		// of the new skillsets when it's finished
		skrGame.IncrementRandomSkillSet();
		
		if (LocalPC.PlayerReplicationInfo.WavesScore == 0)
		{
			BroadcastLocalizedMessage(class'gbxDefendWaveMessage', LocalPC.PlayerReplicationInfo.WavesScore + 1, LocalPC.PlayerReplicationInfo, None);
		}
		else
		{
			BroadcastLocalizedMessage(class'gbxDefendWaveMessage', LocalPC.PlayerReplicationInfo.WavesScore, LocalPC.PlayerReplicationInfo, None);
		}
		
		for( PC = Level.PlayerControllerList; PC != None; PC = PC.nextPlayerController )
		{
			if (PC.PlayerReplicationInfo != None)
			{
				if (PC.PlayerReplicationInfo.WavesScore == 0)
				{
					PC.PlayerReplicationInfo.WavesScore = 2;
				}
				else
				{
					PC.PlayerReplicationInfo.WavesScore = PC.PlayerReplicationInfo.WavesScore + 1;
				}
			}
		}
	}

	flDoDefendWaveMessage = Level.TimeSeconds + DEFEND_WAVE_MESSAGE_DELAY;
}

function bool ACTION_IsTimedSkirmish()
{
	if (Level.Game.IsA('WargameSkirmish'))
	{
		if (WargameSkirmish(Level.Game).GameType == SGT_TimeChallenge)
		{
			return true;
		}
	}
	return false;
}

function int ACTION_NumPlayerWeapons()
{
	local PlayerController	aPlayer;
	local Weapon			anItem, nextItem;
	local int				nNumWeapons;
	local bool				bDone;
	
	aPlayer = GetLocalPlayerController();

	if ((aPlayer != None) && (aPlayer.Pawn != None))
	{
		anItem = aPlayer.Pawn.Weapon;
		nNumWeapons = 0;
		bDone = false;
		while ( !bDone )
		{
			if (gbxWeapon(anItem) != None)
			{
				if (gbxWeapon(anItem).m_eWeaponType == WeaponPrimary)
				{
					nNumWeapons = nNumWeapons + 1;
				}
			}
			nextItem = anItem.NextWeapon(None, anItem);
			if ((nextItem == None) || (nextItem == anItem))
				bDone = true;
			anItem = nextItem;
		}

		return nNumWeapons;
	}

	return 0;
}

////////////////////////////////////////////////////////////////////////////
// Localization helper functions ///////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////

// Copied to gbxGameplay/gbxVictoryCondition.uc	2004-09-28 JWS
function string S_Localize(string KeyString, optional string IntFileName, optional string SectionName)
{
	// Moved the contents to LevelInfo so that other parts of the code could use it easily 2004-09-28 JWS
	return Level.S_Localize(KeyString, IntFileName, SectionName);
}

////////////////////////////////////////////////////////////////////////////
// State Common Functions //////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////

function BeginState()
{
	Super.BeginState();
	SLog( name $ "<" $ GetStateName() $ ">.BeginState(): beginning state."  );
}

function EndState()
{
	Super.EndState();
	SLog( name $ "<" $ GetStateName() $ ">.EndState(): ending state."  );
}

////////////////////////////////////////////////////////////////////////////
// Overridables ////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////

function OnStart()
{
	SLog( name $ "<" $ GetStateName() $ ">.OnStart() called."  );
}

function OnTrigger()
{
	SLog( name $ "<" $ GetStateName() $ ">.OnTrigger() called."  );

	if( bTriggeredStateEnabled )
	{
		GotoState( 'Triggered' );
	}
}

function OnDestroyed()
{
	SLog( name $ "<" $ GetStateName() $ ">.OnDestroyed() called."  );
}


////////////////////////////////////////////////////////////////////////////
// States //////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////

auto state Start
{
Begin:

	// Your code here!

	GotoState( 'Default' );
}


state Default
{
Begin:

	// Your code here!

}


state Triggered
{
Begin:

	// Your code here!

	GotoState( 'Default' );
}


state PlayerBreak
{
Begin:

	// Your code here!

}


simulated event PreSaveCallback()
{
}

simulated event PostSaveCallback()
{
}

////////////////////////////////////////////////////////////////////////////
// Default Properties //////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////

defaultproperties
{
	bHidden=true
	bMessageListener=true

	Succeeded=true
	Failed=false

	bTriggeredStateEnabled=true

	// DLEVY m_szCheckpointMessage="Saving Progress...|Please don't turn off your Xbox console."
	m_szCheckpointMessage1 = "Saving Progress..."
	//m_szCheckpointMessage2 = "Progress Saved..."  //DLEVY remove postcheckpoint message 
	VictoryMovieFile="..\\media\\closing_credits.bik"

	flDoSaveGame=-1.0f

	ButtonBeepSoundString="UI.Boop"
}
//=============================================================================
// TriggeredScriptCheckpoint.
// Created by: Dorian Gorski
//=============================================================================
class TriggeredScriptCheckpoint extends TriggeredScript
	placeable;

var(Events) export editinline Array<name> nmDestroyList;
var(Events) export editinline Array<name> nmEventList;
var(Events) export editinline Array<name> nmPostFadeEventList;

var(Events) int numObjective;

var WargamePlayerController WPC_Ref;

//=============================================================================
function DestroyList()
{
	local int i;

	// Destroy all in Destroy list
	for ( i = 0; i < nmDestroyList.Length; ++i )
		ACTION_DestroyActor( nmDestroyList[i] );
}

//=============================================================================
function EventList( Array<name> nmList )
{
	local int i;

	// Trigger all in nmList
	for ( i = 0; i < nmList.Length; ++i )
		ACTION_TriggerEvent( nmList[i] );
}

//=============================================================================
// Used to lock or unlock/lock the players movement, 
// hide/show hud, and disable/enable battle dialogue
//=============================================================================
function LockPlayer( bool bLock )
{
	if ( bLock )
	{
		WPC_Ref = GetLocalPlayerController();

		ACTION_DisableBattleDialogue();
		ACTION_HideHUD( WPC_Ref, TRUE );
		ACTION_LockPlayerMovement( GetLocalPlayerPawn() );
	}
	else
	{
		// ACTION_ClearForcedFaceActor();
		ACTION_EnableBattleDialogue();
		ACTION_HideHUD( WPC_Ref, FALSE );
		ACTION_UnLockPlayerMovement( GetLocalPlayerPawn() );
	}
}

//=============================================================================
state Triggered
{
	function OnTrigger()
	{
		// Trigger Once
	}

	Begin:

	LockPlayer( TRUE );
	DestroyList();

	ACTION_TriggerEvent( Event );
	EventList( nmEventList );

	ACTION_FadeOverlay( WPC_Ref, 2, 2.0 );
	sleep( 1.0 );
	LockPlayer( FALSE );
	sleep( 1.0 );

	EventList( nmPostFadeEventList );   // Moved nmPostFadeEventList up before objective display

	// Display Objective
	ACTION_SetObjectiveStatus( numObjective, OI_Active, 'ObjectiveList' );
	ACTION_DisplayObjective( numObjective, 'ObjectiveList', 4.0 );
	sleep( 4.0 );

	ScriptEnd:
}
//=============================================================================
// TriggeredScriptCheckpointSave.
// Created by: Dorian Gorski
//=============================================================================
class TriggeredScriptCheckpointSave extends TriggeredScript
	placeable;

var(Events) int numCheckpoint;
var(Events) bool fSaveCustom;
var(Events) string szCustomMapName;

state Triggered
{
	function OnTrigger()
	{
		// Trigger once
	}

	Begin:

	ACTION_SaveMemoryReport( Level.LocalizationFilename $ "_checkpoint_" $ numCheckpoint );
	ACTION_CheckPointSave( numCheckpoint, , Event, fSaveCustom, szCustomMapName );

	ScriptEnd:
}
//=============================================================================
//	TriggeredScriptCheckpointSaveData
//	Created by: Ryan Conlon
//	Description:
//		This actor handles save data from checkpoints. A mapper must attach an 
//		event. When this actor is triggered, it sets its TagValue to 1 and saves
//		off the checkpoint data. When the map is loaded, each of these actors 
//		checks if the checkpoint is being loaded and also checks the TagValue, 
//		triggering that event if it was previously triggered.
//=============================================================================
class TriggeredScriptCheckpointSaveData extends TriggeredScript
	placeable;

var()	name	AttachedEvent;
var()	name	TagName;
var		int		TagValue;
var		int		iCheckpointID;

state Default
{
	Begin:
		if( Level.Game.GameReplicationInfo.GameType == GT_SKIRMISH )
			iCheckpointID = Level.MissionManager.SkirmishGetCheckpointID();
		else
			iCheckpointID = Level.MissionManager.GetCheckpointID();

		if( iCheckpointID > 0 )	// if true, a checkpoint has been loaded
		{
			ACTION_LoadSavedValues();
			ACTION_GetSavedValue( TagName, TagValue );

			if( TagValue > 0 )	// if true, trigger the attached event
			{
				if( AttachedEvent != '' )
				{
					sleep(0.25);
					ACTION_TriggerEvent( AttachedEvent );
				}
			}
		}

	ScriptEnd:
}

state Triggered
{
	function OnTrigger()
	{
		// Trigger once
	}

	Begin:

		TagValue=1;
		if( TagName != '' )
			ACTION_SaveScriptValue( TagName, TagValue );

	ScriptEnd:
}

defaultproperties
{
	TagValue=0

	iCheckpointID=0
}
//=============================================================================
// TriggeredScriptCombat.
// Created by: Dorian Gorski
//=============================================================================
class TriggeredScriptCombat extends TriggeredScript
	placeable;

struct Orders
{
	var() edfindable Unit Unit_DE;
	var() name nmPathNode;
};

struct EventList
{
	var() float fSleep;
	var() name nmEvent;
};

var(Events) edfindable gbxFollowBeacon gbxFB_Beacon;
var(Events) edfindable TriggeredScriptCombat TSC_NextCombat;

var(Events) export editinline Array<Orders> m_Orders;
var(Events) export editinline Array<EventList> m_EventList;

var(Events) export editinline Array<name> nmDestroyList;
var(Events) export editinline Array<name> nmReTriggerEventList;

var int i;
var bool bActive;

function PostBeginPlay()
{
	Super.PostBeginPlay();

	bActive = FALSE;
}

//=============================================================================
// Checks if the current combat is complete, if not it updates the beacon
//=============================================================================
function bool IsComplete()
{
	local int i;

	for ( i = 0; i < m_Orders.Length; ++i )
	{
		if ( m_Orders[i].Unit_DE != None && m_Orders[i].Unit_DE.GetNumLivingMembers() > 0 )
		{
			if ( gbxFB_Beacon != None )
				gbxFB_Beacon.m_anOwner = m_Orders[i].Unit_DE.Leader;

			return FALSE;
		}
	}

	return TRUE;
}

//=============================================================================
// Finds and enables beacon for next combat
//=============================================================================
function HandleNext( TriggeredScriptCombat TSC_NC )
{
	if ( TSC_NC != Self )
	{
		if ( TSC_NC.bActive )
		{
			if ( TSC_NC.gbxFB_Beacon != None && !TSC_NC.gbxFB_Beacon.bEnabled )
			{
				SLog( "**** " $ Tag $ " is triggering " $ TSC_NC.gbxFB_Beacon.Tag $ " because it is active and disabled." );
			 	ACTION_TriggerEvent( TSC_NC.gbxFB_Beacon.Tag );
			}
		}
		else
		{
			if ( TSC_NC.GetStateName() == 'ReTriggered' )
				HandleNext( TSC_NC.TSC_NextCombat );
			else
			{
				SLog( "**** " $ Tag $ " is triggering " $ TSC_NC.gbxFB_Beacon.Tag $ " because it is the next combat, but not active." );
				ACTION_TriggerEvent( TSC_NC.gbxFB_Beacon.Tag );
			}
		}
	}
	else
	{
		SLog( "**** Map Complete ****" );
		ACTION_TriggerEvent( Event );
	}
}

//=============================================================================

state Triggered
{
	function OnTrigger()
	{
		SLog( "*** Error Trigger Multiple" );
		// GoToState( 'ReTriggered' );
	}

	Begin:

	// Destroy all in Destroy list
	for ( i = 0; i < nmDestroyList.Length; ++i )
		ACTION_DestroyActor( nmDestroyList[i] );

	bActive = TRUE;

	// Trigger all in Event list
	for ( i = 0; i < m_EventList.Length; ++i )
	{
		sleep( m_EventList[i].fSleep );
		ACTION_TriggerEvent( m_EventList[i].nmEvent );
	}

	// Order all in Order list
	for ( i = 0; i < m_Orders.Length; ++i )
	{
		if( m_Orders[i].nmPathNode != '' )
			ACTION_OrderMove( m_Orders[i].Unit_DE.Tag, m_Orders[i].nmPathNode );
	}

	GoToState( 'ReTriggered' );

	ScriptEnd:
}

state ReTriggered
{
	function OnTrigger()
	{
		GoToState( 'ReTriggered' );
	}

	Begin:

	if ( IsComplete() && bActive )
	{
		SLog( "**** Combat " $ Tag $ " is complete." );

		bActive = FALSE;

		if ( gbxFB_Beacon.bEnabled )
		{
			ACTION_TriggerEvent( gbxFB_Beacon.Tag );
			HandleNext(TSC_NextCombat);
		}

		// Trigger all in ReTriggerEvent list
		for ( i = 0; i < nmReTriggerEventList.Length; ++i )
			ACTION_TriggerEvent( nmReTriggerEventList[i] );
	}

	ScriptEnd:
}//=============================================================================
// TriggeredScriptCombatManager.
// Created by: Dorian Gorski
// Purpose: To enable and disable combat triggers, allowing a maximum of 2
// combats to run.
//=============================================================================
class TriggeredScriptCombatManager extends TriggeredScript
	placeable;

struct Combat
{
	var() edfindable TriggeredScriptCombat TSC_Combat;
};

var(Events) export editinline Array<Combat> m_TS_Combats;
var(Events) export editinline Array<name> m_nmCombatTriggers;

var bool bOff;
var int numActive;

function PostBeginPlay()
{
	Super.PostBeginPlay();

	bOff = FALSE;
}

//=============================================================================
// Counts the number of active combats in the Combat list
//=============================================================================
function int CountActive()
{
	local int i, numCount;

	numCount = 0;
	for ( i = 0; i < m_TS_Combats.Length; ++i )
	{
		if ( m_TS_Combats[i].TSC_Combat.bActive )
			++numCount;
	}

	return numCount;
}

//=============================================================================
// Toggles all of the triggers in the list
//=============================================================================
function ToggleTriggers()
{
	local int i;

	bOff = !bOff;

	for ( i = 0; i < m_nmCombatTriggers.Length; ++i )
		ACTION_TriggerEvent( m_nmCombatTriggers[i] );
}

//=============================================================================

state Triggered
{
	Begin:

	numActive = CountActive();
	SLog( "**** numActive: " $ numActive );

	if ( numActive > 1 )
	{
		if ( !bOff )
		{
			SLog( "Toggling combat triggers off" );
			ToggleTriggers();
		}
	}
	else if ( bOff )
	{
		SLog( "Toggling combat triggers on" );
		ToggleTriggers();
	}

	ScriptEnd:
}


//=============================================================================
// TriggeredScriptDelayedMove.
// Accessor to gbxDelayedMove
//=============================================================================
class TriggeredScriptDelayedMove extends gbxDelayedMove
	placeable;

var TriggeredScriptSIManager m_TS;
var gbxMessageSI.SIData	m_Process;

state ProcessMove
{
	function OnTrigger()
	{
		GoToState( 'Triggered' );
	}

	function Trigger( Actor Other, Pawn EventInstigator )
	{
		GotoState( 'Triggered' );
	}

	Begin:

		if ( m_TS != None )
		{
			if( m_Process.Unit_DE != None )
			{
				sleep(fDelay);
				m_TS.DoOrderFinal( m_Process, m_MatchTag, m_TriggerTag, m_Location );
			}
			else
			{
				log( "ERROR: m_Process is None!", 'TriggeredScript' );
				GoToState( 'Triggered' );
			}
		}
		else
		{
			log( "ERROR: TriggeredScript NOT specified!", 'TriggeredScript' );
			GoToState( 'Triggered' );
		}

	ScriptEnd:
}

state Triggered
{
	function OnTrigger()
	{
		// Do nothing
	}

	Begin:
	
	ScriptEnd:
}

defaultproperties
{
	m_TS=None
	bHidden=true
}//=============================================================================
// TriggeredScriptIntro.
// Created by: Dorian Gorski
// Purpose: Genral Intro Script
//=============================================================================
class TriggeredScriptIntro extends TriggeredScript
	placeable;

struct Subtitle
{
	var () string	sSubtitleTag;
	var () float	fSubtitleTime;
	var () float	fSubtitleDelay;
};

struct Monologue
{
	var () string	sMonologueSound;
	var	() float	fMonologueDelay;
	var () export editinline Array<Subtitle> aSubtitle;
};

var (Events) name nmPlayerTag;
var (Events) name nmPreFadeEvent;

var (Events) string szMusicSoundFile;
//var (Events) string szVOSoundFile;
var (Events) string szAmbientSoundFile;

var (Events) float fDelayVO;									// Delay between music start and voice over start

var (Events) export editinline Array<Monologue> m_Monologue;		// Used for subtitles during monologue

var (Events) bool bStartCrouched;

var int i, j, numVOID, numMusicID;
var float monologueDuration, monologueDelay;

var WargamePlayerController WGPC_Ref;
var WargamePawn WGP_Ref;

var Actor A_Player;

//=============================================================================
state Triggered
{
	function OnTrigger()
	{
		GoToState( 'Intro_End' );
	}

	Begin:

	ACTION_SaveMemoryReport( Level.LocalizationFilename $ "_start" );

	ACTION_TriggerEvent( nmPreFadeEvent );

	WGPC_Ref = GetLocalPlayerController();
	WGP_Ref = GetLocalPlayerPawn();

	ACTION_DisableBattleDialogue();
	ACTION_HideHUD( WGPC_Ref, TRUE );

	if ( bStartCrouched )
	WGP_Ref.StartGoingToCrouch( TRUE );

	// Limit input
	ACTION_BlockActionKeys( -1 );
	ACTION_UnblockActionKeys( KEY_ACTION_SHOW_MENU );
	ACTION_LimitPlayerInput( WGPC_Ref, TRUE );

	ACTION_LockPlayerMovement( WGP_Ref );

	// Map name, date, time
	Level.Title = Localize( "LevelInfo" , "Title", Level.GetLevelFileName() );
	Level.TitleDate = Localize( "LevelInfo" , "TitleDay", Level.GetLevelFileName() ) @ Localize( "LevelInfo" , "TitleDate", Level.GetLevelFileName() );
	Level.TitleLocation = Localize( "LevelInfo" , "TitleLocation", Level.GetLevelFileName() );
	ACTION_MapIntroTextPos( WGPC_Ref, 50, 350 );
	ACTION_MapIntroText( WGPC_Ref, 1, 2.0 );

	// Begin monologue music, and voice over
	if ( nmPlayerTag != '' )
		A_Player = GetFirstActor( nmPlayerTag );
	else
		SLog( "**** Error empty nmPlayerTag ****" );

	monologueDelay = 0;

	// Start monologue sounds
	if ( A_Player != None )
	{
		if ( szMusicSoundFile != "" )
			numMusicID = A_Player.PlayMusic( szMusicSoundFile, 0.0 );
		else
			SLog( "**** Empty szMusicSoundFile string ****" );

		sleep( fDelayVO );

		for ( i = 0; i < m_Monologue.Length; ++i )
		{
			if ( m_Monologue[i].sMonologueSound != "" )
			{
				Slog( "@#$%^ Play Dialogue - " $ m_Monologue[i].sMonologueSound );
				numVOID = A_Player.PlayMusic( m_Monologue[i].sMonologueSound, 0.0, monologueDuration );
				Slog( "@#$%^ Dialogue Duration - " $ monologueDuration );
				ResetAbsoluteTime();
				StartAbsoluteTime();

				for ( j=0; j<m_Monologue[i].aSubtitle.Length; ++j )
				{
					Slog( "@#$%^ Display Subtitle - " $ m_Monologue[i].aSubtitle[j].sSubtitleTag );
					if ( m_Monologue[i].aSubtitle[j].sSubtitleTag != "" )
						ACTION_DisplaySubTitleMessage2( S_Localize(m_Monologue[i].aSubtitle[j].sSubtitleTag), m_Monologue[i].aSubtitle[j].fSubtitleTime, 1, 1, 1, TRUE, TRUE );

					Slog( "@#$%^ Subtitle Delay - " $ m_Monologue[i].aSubtitle[j].fSubtitleDelay );
					sleep( m_Monologue[i].aSubtitle[j].fSubtitleDelay );
				}

				Slog( "@#$%^ Absolute Time - " $ GetAbsoluteTime() );
				monologueDelay = m_Monologue[i].fMonologueDelay + monologueDuration + 0.25 - GetAbsoluteTime();	// +0.25 to keep the next sound from immediately starting after the previous
				Slog( "@#$%^ Monologue Delay - " $ monologueDelay );
				if( monologueDelay > 0 )
					sleep( monologueDelay );

				StopAbsoluteTime();
				A_Player.StopMusic( numVOID, 1.5 );
			}
			else
			{
				SLog( "@#$%^ Could not find sound - " $ m_Monologue[i].sMonologueSound );
			}
		}
	}
	else
	{
		SLog( "**** Error no matching actor nmPlayerTag found: " $ nmPlayerTag $ " ****" );
	}


	// Stop monologue sounds
	if ( A_Player != None )
	{
		//if ( szVOSoundFile != "" )
		//	A_Player.StopMusic( numVOID, 1.5 );

		if ( szMusicSoundFile != "" )
			A_Player.StopMusic( numMusicID, 1.5 );
	}

	// Fade out text and fade into game
	ACTION_MapIntroText( WGPC_Ref, 2, 2.0 );
	sleep( 2.0 );
	ACTION_FadeOverlay( WGPC_Ref, 2, 6.0 );
	sleep( 0.5 );
	ACTION_UnblockActionKeys( -1 );
	ACTION_BlockActionKeys( KEY_ACTION_CROUCH );
	sleep( 0.5 );

	// ACTION_PlaySoundReturnHandle( nmPlayerTag, szAmbientSoundFile, 1.0, 1.0, 10000 );

	// Trigger map specific intro moment script
	ACTION_TriggerEvent( Event );
}

//=============================================================================
state Intro_End
{
	function  OnTrigger()
	{
		SLog( "Error Multiple Triggers" );
	}

	Begin:

	ACTION_SaveMemoryReport( Level.LocalizationFilename $ "_checkpoint_intro_pre" );
	ACTION_CheckPointSave( 1 );
	ACTION_SaveMemoryReport( Level.LocalizationFilename $ "_checkpoint_intro_post" );

	ACTION_UnBlockActionKeys( KEY_ACTION_CROUCH  );

	if ( bStartCrouched )
		WGP_Ref.ForceUnCrouch();

	ACTION_HideHUD( WGPC_Ref, FALSE );
	ACTION_EnableBattleDialogue();
	ACTION_UnlockPlayerMovement( WGP_Ref );
	ACTION_LimitPlayerInput( WGPC_Ref, FALSE );
	sleep( 3.5 );

	// Display Objective
	ACTION_SetObjectiveStatus( 0, OI_Active, 'ObjectiveList' );
	ACTION_DisplayObjective( 0, 'ObjectiveList', 4.0 );

	ScriptEnd:
}//=============================================================================
// TriggeredScriptMapComplete.
//=============================================================================
class TriggeredScriptMapComplete extends TriggeredScript
	placeable;

state Triggered
{
	Begin:

	ACTION_SaveMemoryReport( Level.LocalizationFilename $ "_end" );
	ACTION_DisplayMapStats();

	ScriptEnd:
}
class TriggeredScriptMP extends TriggeredScript
	placeable;

defaultproperties
{
	bNoDelete=true
	RemoteRole=ROLE_AutonomousProxy
}
//=============================================================================
// TriggeredScriptMPCombat.
// Created by: Dorian Gorski
//=============================================================================
class TriggeredScriptMPCombat extends TriggeredScript
	placeable;

struct Orders
{
	var() edfindable Unit Unit_DE;
	var() name nmPathNode;
};

struct EventList
{
	var() float fSleep;
	var() name nmEvent;
};

var(Events) edfindable gbxFollowBeacon gbxFB_Beacon;
var(Events) edfindable TriggeredScriptMPCombat TSC_NextCombat;

var(Events) export editinline Array<Orders> m_Orders;
var(Events) export editinline Array<EventList> m_EventList;

var(Events) export editinline Array<name> nmDestroyList;
var(Events) export editinline Array<name> nmReTriggerEventList;

var int i;
var bool bActive;

function PostBeginPlay()
{
	Super.PostBeginPlay();

	bActive = FALSE;
}

//=============================================================================
// Checks if the current combat is complete, if not it updates the beacon
//=============================================================================
function bool IsComplete()
{
	local int i;

	for ( i = 0; i < m_Orders.Length; ++i )
	{
		if ( m_Orders[i].Unit_DE != None && m_Orders[i].Unit_DE.GetNumLivingMembers() > 0 )
		{
			if ( gbxFB_Beacon != None )
				gbxFB_Beacon.m_anOwner = m_Orders[i].Unit_DE.Leader;

			return FALSE;
		}
	}

	return TRUE;
}

//=============================================================================
// Finds and enables beacon for next combat
//=============================================================================
function HandleNext( TriggeredScriptMPCombat TSC_NC )
{
	if ( TSC_NC != Self )
	{
		if ( TSC_NC.bActive )
		{
			if ( TSC_NC.gbxFB_Beacon != None && !TSC_NC.gbxFB_Beacon.bEnabled )
			{
				SLog( "**** " $ Tag $ " is triggering " $ TSC_NC.gbxFB_Beacon.Tag $ " because it is active and disabled." );
			 	ACTION_TriggerEvent( TSC_NC.gbxFB_Beacon.Tag );
			}
		}
		else
		{
			if ( TSC_NC.GetStateName() == 'ReTriggered' )
				HandleNext( TSC_NC.TSC_NextCombat );
			else
			{
				SLog( "**** " $ Tag $ " is triggering " $ TSC_NC.gbxFB_Beacon.Tag $ " because it is the next combat, but not active." );
				ACTION_TriggerEvent( TSC_NC.gbxFB_Beacon.Tag );
			}
		}
	}
	else
	{
		SLog( "**** Map Complete ****" );
		ACTION_TriggerEvent( Event );
	}
}

//=============================================================================

state Triggered
{
	function OnTrigger()
	{
		SLog( "*** Error Trigger Multiple" );
		// GoToState( 'ReTriggered' );
	}

	Begin:

	// Destroy all in Destroy list
	for ( i = 0; i < nmDestroyList.Length; ++i )
		ACTION_DestroyActor( nmDestroyList[i] );

	bActive = TRUE;

	// Trigger all in Event list
	for ( i = 0; i < m_EventList.Length; ++i )
	{
		sleep( m_EventList[i].fSleep );
		ACTION_TriggerEvent( m_EventList[i].nmEvent );
	}

	// Order all in Order list
	for ( i = 0; i < m_Orders.Length; ++i )
	{
		if( m_Orders[i].nmPathNode != '' )
			ACTION_OrderMove( m_Orders[i].Unit_DE.Tag, m_Orders[i].nmPathNode );
	}

	GoToState( 'ReTriggered' );

	ScriptEnd:
}

state ReTriggered
{
	function OnTrigger()
	{
		GoToState( 'ReTriggered' );
	}

	Begin:

	if ( IsComplete() && bActive )
	{
		SLog( "**** Combat " $ Tag $ " is complete." );

		bActive = FALSE;

		if ( gbxFB_Beacon.bEnabled )
		{
			ACTION_TriggerEvent( gbxFB_Beacon.Tag );
			HandleNext(TSC_NextCombat);
		}

		// Trigger all in ReTriggerEvent list
		for ( i = 0; i < nmReTriggerEventList.Length; ++i )
			ACTION_TriggerEvent( nmReTriggerEventList[i] );
	}

	ScriptEnd:
}
class TriggeredScriptMPNetworked extends TriggeredScriptMP
	placeable;

// properties
var() bool bReplicateTriggerEvent; // Set to true if the client needs to know when this script is triggered

// internal state
var byte ReplicatedTriggerCount, LastReplicatedTriggerCount;

replication
{
	reliable if (bNetDirty && Role == ROLE_Authority)
		ReplicatedTriggerCount;
}

simulated function PostNetReceive()
{
	if (bReplicateTriggerEvent && ReplicatedTriggerCount != LastReplicatedTriggerCount )
	{
		LastReplicatedTriggerCount = ReplicatedTriggerCount;

		GotoState( 'Triggered' );
	}
}

function OnTrigger()
{
	Super.OnTrigger();

	if (bReplicateTriggerEvent)
	{
		ReplicatedTriggerCount++;
	}
}

// Copied these states from TriggeredScript so that I could make them simulated
auto simulated state Start
{
Begin:

	// Your code here!

	GotoState( 'Default' );
}

simulated state Default
{
Begin:

	// Your code here!

}

simulated state Triggered
{
Begin:

	// Your code here!

	GotoState( 'Default' );
}

defaultproperties
{
	bReplicateTriggerEvent=true

	bNoDelete=false
	RemoteRole=ROLE_AutonomousProxy
	
	bAlwaysRelevant=true
	bSkipActorPropertyReplication=true
	bOnlyDirtyReplication=true

	bNetNotify=true
}class TriggeredScriptPawn extends TriggeredScript
	placeable;

var Pawn		LatentTargetPawn;
var ActorLite	LatentTarget;	// Needed by move commands to track what a pawn was headed for.
var Vector		LatentTargetLoc;
var	Rotator		LatentTargetRot;
var Vector		LatentMoveToLoc;

var float		distance;
var int			angle_diff;
var Name		CompleteState;

function ACTION_PawnMoveToActor( Pawn MyPawn, name TargetName, optional float flOffsetFromActor )
{
	// Your code here!
	SLog("We're running the 'Triggered' state code now...");

	LatentPawn = MyPawn;
	LatentTargetPawn = GetPawn(TargetName);  // get the pawn we want to move to

	if ((MyPawn == None) || (LatentTargetPawn == None))
	{
		SLog("ERROR!!! - Couldn't find a Pawn with that Tag!!!");

		GotoState(CompleteState);
		SetSucceeded( false );
	}
	else
	{
		LatentTargetLoc = LatentTargetPawn.Location;  // save this so we know if it changes
		LatentTargetRot = LatentTargetPawn.Rotation;  // save this so we know if it changes

		if (flOffsetFromActor == 0.0f)
			flOffsetFromActor = 200.0f;
			
		// calculate a location that's 200 units directly in front of the actor/pawn/player...
		LatentMoveToLoc = LatentTargetPawn.Location + vector(LatentTargetPawn.Rotation) * flOffsetFromActor;

		LatentPawn.Controller.MoveTarget = None;  // haven't found a path to destination yet

		LatentPawn.SetMovementPhysics();  // make sure Pawn can walk/run

		LatentPawn.Controller.bRotateToDesired = true;  // we want to automatically rotate

		SLog("Moving to Location = " $ LatentMoveToLoc);

		GotoState('MovingTowardPawn');

		SetSucceeded( true );
	}
}

function ACTION_PawnRotateToActor( Pawn MyPawn, name TargetName )
{
	LatentPawn = MyPawn;
	LatentTargetPawn = GetPawn(TargetName);

	if ((MyPawn == None) || (LatentTargetPawn == None))
	{
		SLog("ERROR!!! - Couldn't find a Pawn with that Tag!!!");

		GotoState(CompleteState);
		SetSucceeded( false );
	}
	else
	{
		LatentPawn.Controller.Focus = LatentTargetPawn;  // get Pawn to rotate toward actor/pawn/player
		LatentPawn.Controller.bRotateToDesired = true;  // we want to automatically rotate
		GotoState('RotatingToward');

		SetSucceeded( true );
	}
}

function ACTION_PawnRotateToPoint( Pawn MyPawn, Vector TargetVec )
{
	LatentPawn = MyPawn;
	
	if (MyPawn == None)
	{
		SLog("ERROR!!! - Couldn't find a Pawn with that Tag!!!");

		GotoState(CompleteState);
		SetSucceeded( false );
	}
	else
	{
		LatentPawn.Controller.Focus = None;
		LatentPawn.Controller.FocalPoint = TargetVec;
		LatentPawn.Controller.bRotateToDesired = true;  // we want to automatically rotate
		GotoState('RotatingToward');

		SetSucceeded( true );
	}
}

function ACTION_PawnRotateToAngle( Pawn MyPawn, int nAngleOffset )
{
	LatentPawn = MyPawn;

	if (MyPawn == None)
	{
		SLog("ERROR!!! - Couldn't find a Pawn with that Tag!!!");

		GotoState(CompleteState);
		SetSucceeded( false );
	}
	else
	{
		LatentTargetRot = LatentPawn.Rotation;
		LatentTargetRot.Yaw += nAngleOffset;
		if (LatentTargetRot.Yaw > 65536)
			LatentTargetRot.Yaw = LatentTargetRot.Yaw - 65536;
			
		LatentMoveToLoc = (LatentPawn.Location + LatentPawn.EyePosition()) + vector(LatentTargetRot) * 200.0f;
		
		SLog("ACTION_PawnRotateToAngle( "$MyPawn$", "$nAngleOffset$" ) - "$LatentPawn.Rotation.Yaw$" - "$LatentTargetRot.Yaw$" - "$LatentMoveToLoc);
		ACTION_PawnRotateToPoint( MyPawn, LatentMoveToLoc );

		SetSucceeded( true );
	}
}

function ACTION_PawnLookAt( Pawn MyPawn, name TargetName, optional bool bFreeze )
{
	local gbxPawn	MygbxPawn;
	local Pawn		LookAt;
	
	MygbxPawn = gbxPawn( MyPawn );
	LookAt = GetPawn(TargetName);
	
	if( (MygbxPawn != None) && (LookAt != None) )
	{
		SLog("Looking At Target = " $LookAt);
		MygbxPawn.bPawnLooksAtTargets = true;
		MygbxPawn.SetLookingAtTarget( LookAt );

		if( bFreeze )
			gbxPawn(MyPawn).bDontLookAtPlayers = true;

		SetSucceeded( true );
	}
	else
	{
		SLog( name $ ".ACTION_SetLookAtTarget( '" $ MygbxPawn.Name $ "', " $ LookAt.Name $ " ): actor tag not found." );
		SetSucceeded( false );
	}
}

////////////////////////////////////////////////////////////////////////////
// Helper States //////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////

state MovingTowardPawn
{
Begin:

	// see if we can move directly to the destination location (without pathfinding)...
	if (LatentPawn.Controller.PointReachable(LatentMoveToLoc))
	{
		LatentPawn.SetWalking(false);  // do we want the pawn to walk/run to the pathnode

		SLog("Calling MoveTo...");

		// move toward destination location...
		ACTION_WaitForPawnMoveTo(LatentPawn, LatentMoveToLoc);
	}
	else
	{
		// find the next pathnode along the path...
		LatentPawn.Controller.MoveTarget = LatentPawn.Controller.FindPathTo(LatentMoveToLoc);

		if (LatentPawn.Controller.MoveTarget == None)  // no path?
		{
			SLog("FindPathTo Failed!!! - Pawn can't get to destination!!!");

			LatentPawn.Acceleration = vect(0,0,0);  // stop pawn from moving

			GotoState(CompleteState);
		}
		else
		{
			SLog("Found a path to MoveToLocation, pathnode = " $ LatentPawn.Controller.MoveTarget.name);

			LatentPawn.SetWalking(false);  // do we want the pawn to walk/run to the pathnode

			SLog("Calling MoveToward...");

			if (LatentPawn.Controller.MoveTarget.IsA('Actor'))
			{
				// move toward pathnode location...
				ACTION_WaitForPawnMoveTo(LatentPawn, Actor(LatentPawn.Controller.MoveTarget).Location);
			}
			else if (LatentPawn.Controller.MoveTarget.IsA('NavigationPointLite'))
			{
				// move toward pathnode location...
				ACTION_WaitForPawnMoveTo(LatentPawn, NavigationPointLite(LatentPawn.Controller.MoveTarget).Location);
			}
		}
	}

	// check to see if actor/pawn/player has changed locations since we started moving...

	distance = VSize(LatentTargetPawn.Location - LatentTargetLoc);

	if (distance > LatentTargetPawn.CollisionRadius * 2.0f)  // have they moved?
	{
		SLog("Actor/Pawn/Player has changed locations, calculating new location to move to...");

		LatentTargetLoc = LatentTargetPawn.Location;  // save this so we know if it changes
		LatentTargetRot = LatentTargetPawn.Rotation;  // save this so we know if it changes

		// calculate a location that's 200 units directly in front of the actor/pawn/player...
		LatentMoveToLoc = LatentTargetPawn.Location + vector(LatentTargetPawn.Rotation) * 200.0f;

		Goto('Begin');
	}

	angle_diff = (LatentTargetPawn.Rotation.Yaw - LatentTargetRot.Yaw) & 65535;
	angle_diff = abs(angle_diff);
	if (angle_diff > 32767)
		angle_diff = (65536 - angle_diff) & 32767;

	if (angle_diff > 2000)  // about 10 degrees
	{
		SLog("Actor/Pawn/Player has rotated, calculating new location to move to...");

		LatentTargetLoc = LatentTargetPawn.Location;  // save this so we know if it changes
		LatentTargetRot = LatentTargetPawn.Rotation;  // save this so we know if it changes

		// calculate a location that's 200 units directly in front of the actor/pawn/player...
		LatentMoveToLoc = LatentTargetPawn.Location + vector(LatentTargetPawn.Rotation) * 200.0f;

		Goto('Begin');
	}

	// how far away are we from the destination?
	distance = VSize(LatentPawn.Location - LatentMoveToLoc);

	// touching the destination point is based on the size of the controlled pawn...
	if (distance < LatentPawn.CollisionRadius)
	{
		// Yes!  We've reached the destination location...

		LatentPawn.Acceleration = vect(0,0,0);  // stop the pawn at his current location

		LatentPawn.Controller.Focus = LatentTargetPawn;  // get Pawn to rotate toward actor/pawn/player

		LatentPawn.Controller.bRotateToDesired = true;  // we want to automatically rotate towards Focus

		ACTION_WaitForPawnRotateToward(LatentPawn);

		SLog("Pawn has reached destination location and is facing target!!!");

		// Do Something Here (say some dialog, play an animation, etc.)

		//
		// YOUR "I've reached the player" CODE HERE!!!
		//

		// now that we've finished playing our animation or saying our dialog...
		// stop looking at the actor/pawn/player

		LatentPawn.Controller.Focus = None;
		LatentPawn.Controller.bRotateToDesired = false;

		if (CompleteState != '')
			GotoState(CompleteState);  // nothing more to do, so go back to default
		else
			GotoState('Default');
	}

	Goto('Begin');
}

state RotatingToward
{
Begin:
	SLog("Pawn is turning to face target!!! - "$LatentPawn$" - "$LatentPawn.Controller.Focus$" - "$LatentPawn.Controller.bRotateToDesired$" - "$LatentPawn.Controller.bRotateToDesired);
	
	ACTION_WaitForPawnRotateToward(LatentPawn);

	SLog("Pawn has reached destination location and is facing target!!!");

	// Do Something Here (say some dialog, play an animation, etc.)

	//
	// YOUR "I've reached the player" CODE HERE!!!
	//

	// now that we've finished playing our animation or saying our dialog...
	// stop looking at the actor/pawn/player

	LatentPawn.Controller.Focus = None;
	LatentPawn.Controller.bRotateToDesired = false;

	if (CompleteState != '')
		GotoState(CompleteState);  // nothing more to do, so go back to default
	else
		GotoState('Default');
}

defaultproperties
{
	CompleteState="Default"
}
//=============================================================================
// TriggeredScriptSIManager.
// Created by: Dorian Gorski
// Purpose: Easy to use, multi stage, each to use SI interface actor
//=============================================================================
class TriggeredScriptSIManager extends TriggeredScript
	placeable;

CONST TARGETBOOST = 50.0;

var name nmPlayerPosition, nmPlayerTwoPosition;
var name nmFirePosition, nmAssaultPosition;
var name nmFireP2Position, nmAssaultP2Position;

var(Events) bool bInitiallyActive;					// SI script can start inactive

var(Events) int numStartStage;						// For different stages of SI, stages change everytime the script is triggered
var(Events) int numMaxStages;						// Maximum Stages

var(Events) name nmPlayerPawnTag;
var(Events) name nmPlayerTwoPawnTag;

var(Events) name nmFireUnitTag;
var(Events) name nmFireUnitP2Tag;

var(Events) name nmAssaultUnitTag;
var(Events) name nmAssaultUnitP2Tag;

var(Events) name nmExtraTag;
var(Events) name nmExtraTag2;

var WargameSkirmish WS_Ref;

var() float UnitsPerCost;

var bool bRunning;									// Track if SI is current running

struct Movements
{
	var Unit Unit_DE;								// German Unit

	var name nmMatchTag;							// Tag of unit which caused the movement
	var name nmTriggerTag;							// Tag of trigger which caused the movement

	var float fScore;								// Value of current SI

	var int numStage;								// Which stage should this SI run in
};

var export Array<Movements> m_Movements;			// Successful moves are stored here

var Array<gbxMessageSI> gbxMT_Received;				// Every messages received is built into the array until processed then removed

//=============================================================================
// Initialize variables
//=============================================================================
function PostBeginPlay()
{
	Super.PostBeginPlay();

	bRunning = FALSE;
	WS_Ref = WargameSkirmish( GetFirstActor('WargameSkirmish') );
}

//=============================================================================
// Process incoming messages from the volumes.
//=============================================================================
function bool ReceiveGBXMessage( gbxMessage msg )
{
	local bool bResult;
	local bool bSuccess;

	bResult = Super.ReceiveGBXMessage( msg );

	// SLog( "**** Receiving GBXMessage: " $ msg );

	if ( gbxMT_Received.Length < 65 )				// Clamp array at 64
	{
		bSuccess = false;

		if ( msg.IsA('gbxMessageSI') )
		{
			SLog( "**** gbxMessageSI(msg).MatchTag: " $ gbxMessageSI(msg).MatchTag );
			SLog( "**** gbxMessageSI(msg).TriggerTag: " $ gbxMessageSI(msg).TriggerTag );

			switch ( gbxMessageSI(msg).MatchTag )
			{
				case nmPlayerPawnTag:
					bSuccess = true;
					nmPlayerPosition = gbxMessageSI(msg).TriggerTag;
					break;
				case nmPlayerTwoPawnTag:
					bSuccess = true;
					nmPlayerTwoPosition = gbxMessageSI(msg).TriggerTag;
					break;
				case nmFireUnitTag:
					bSuccess = true;
					nmFirePosition = gbxMessageSI(msg).TriggerTag;
					break;
				case nmAssaultUnitTag:
					bSuccess = true;
					nmAssaultPosition = gbxMessageSI(msg).TriggerTag;
					break;
				case nmFireUnitP2Tag:
					bSuccess = true;
					nmFireP2Position = gbxMessageSI(msg).TriggerTag;
					break;
				case nmAssaultUnitP2Tag:
					bSuccess = true;
					nmAssaultP2Position = gbxMessageSI(msg).TriggerTag;
					break;
				case nmExtraTag:
					bSuccess = true;
					break;
				case nmExtraTag2:
					bSuccess = true;
					break;
				default:
					SLog( "**** SI failed due to invalid MatchTag on " $ gbxMessageSI(msg).TriggerTag );
					break;
			}
		}

		if ( bSuccess )
		{
			gbxMT_Received.Insert( gbxMT_Received.Length, 1 );
			gbxMT_Received[gbxMT_Received.Length-1] = gbxMessageSI(msg);

			if ( !bRunning )
				Self.GoToState( 'SIMovement' );
		}
	}

	return bResult;
}

//=============================================================================
// Find all SI Data related to current information and performs SI
//=============================================================================
function DoSIMovement( gbxMessageSI m_gbxMSIProcess )
{
	local int i;

	if ( m_gbxMSIProcess != None )
	{
		for ( i = 0; i < m_gbxMSIProcess.m_GermanUnits.Length; ++i )
		{
			ACTION_TriggerEvent( m_gbxMSIProcess.m_GermanUnits[i].nmEvent );

			if ( m_gbxMSIProcess.m_GermanUnits[i].numStage == numStartStage )
			{
				if ( m_gbxMSIProcess.m_GermanUnits[i].m_ReactionSkill == RS_All || WS_Ref == None || m_gbxMSIProcess.m_GermanUnits[i].m_ReactionSkill == WS_Ref.GetSkillValue(1) + 1 )
				{
					if ( m_gbxMSIProcess.m_GermanUnits[i].Unit_DE != None && m_gbxMSIProcess.m_GermanUnits[i].Unit_DE.GetNumLivingMembers() > 0 )
					{
						if ( m_gbxMSIProcess.m_GermanUnits[i].bCheckSupressed && m_gbxMSIProcess.m_GermanUnits[i].Unit_DE.MyUnitController.GetSuppressionLevel() == SL_SUPPRESSED )
						{
							SLog( "**** Order failed " $ m_gbxMSIProcess.m_GermanUnits[i].Unit_DE.Tag $ " are suppressed." );
							ACTION_TriggerEvent( m_gbxMSIProcess.m_GermanUnits[i].nmEventFailure );
						}
						else
						{
							if ( !CheckSICollision(m_gbxMSIProcess, i) )
							{
								// SLog( "**** No SI Collision Found" );
								DoOrder( m_gbxMSIProcess, i );
								// m_gbxMSIProcess.m_GermanUnits[i], m_gbxMSIProcess.MatchTag );
							}
							else
								ACTION_TriggerEvent( m_gbxMSIProcess.m_GermanUnits[i].nmEventFailure );
						}
					}
					else
					{
						SLog( "**** Move failed all Germans are dead in unit " $ m_gbxMSIProcess.m_GermanUnits[i].Unit_DE );
						ACTION_TriggerEvent( m_gbxMSIProcess.m_GermanUnits[i].nmEventFailure );
					}
				}
				else
				{
					SLog( "**** SI Failed, Mismatched Skill Levels ****" );
					ACTION_TriggerEvent( m_gbxMSIProcess.m_GermanUnits[i].nmEventFailure );
				}
			}
			else
			{
				SLog( "**** SI Failed, mismatching stages " $ m_gbxMSIProcess.m_GermanUnits[i].numStage $ " and " $ numStartStage );
				ACTION_TriggerEvent( m_gbxMSIProcess.m_GermanUnits[i].nmEventFailure );
			}
		}

		gbxMT_Received.Remove(0, 1);
	}
}

//=============================================================================
// Performs the near final movement cull steps
//=============================================================================
function DoOrder( gbxMessageSI m_gbxMSIProcess, int numMember )
{
	local int numRand;
	local gbxMessageSI.SIData Process;
	local name MatchTag, TriggerTag;
	local TriggeredScriptDelayedMove DelayedMove;

	Process = m_gbxMSIProcess.m_GermanUnits[numMember];
	MatchTag = m_gbxMSIProcess.MatchTag;
	TriggerTag = m_gbxMSIProcess.TriggerTag;
	
	// if length is greater than 1, get a random location to move to, otherwise just use the only one in the list.
	if( Process.m_Movement.Length > 1 )
		numRand = Rand(numRand);
	else
		numRand = 0;

	if ( !CheckMovementCollision( Process, MatchTag, TriggerTag ) )
	{
		DelayedMove = TriggeredScriptDelayedMove( Process.m_Movement[numRand].DelayedMove );
		if( DelayedMove != None )
		{
			DelayedMove.m_Process = Process;
			DelayedMove.m_TriggerTag = TriggerTag;
			DelayedMove.m_MatchTag = MatchTag;
			DelayedMove.m_Location = numRand;
			DelayedMove.m_TS = self;

			DelayedMove.GotoState('ProcessMove');
			SLog( "**** DelayedMove successful!" );
		}
		else
		{			
			DoOrderFinal( Process, MatchTag, TriggerTag, numRand );
		}
	}
	else
	{
		ACTION_TriggerEvent( Process.nmEventFailure );
	}
}

//=============================================================================
// Performs final cull steps and performs the move if passed
//=============================================================================
function DoOrderFinal( gbxMessageSI.SIData m_Process, name MatchTag, name TriggerTag, int numLocation )
{
	local Actor A_MatchRef;

	local int numRand;
	local int i;

	A_MatchRef = GetFirstActor(MatchTag);

	if ( CheckClear(m_Process.m_Movement[numLocation]) )
	{
		ACTION_TriggerEvent( m_Process.nmEventSuccess );

		if ( m_Process.m_Movement[numLocation].bUnitAssault )
		{
			if ( A_MatchRef.IsA('Unit') )
			{
				ProcessOrderAssault( m_Process.m_Movement[numLocation], m_Process.Unit_DE.Tag, MatchTag );
			}
			else if ( A_MatchRef.IsA('gbxPawn') )
			{
				ProcessOrderAssault( m_Process.m_Movement[numLocation], m_Process.Unit_DE.Tag, gbxPawn(A_MatchRef).MyUnit.Tag );
			}
		}
		else
		{
			if ( m_Process.m_Movement[numLocation].nmPathNode.Length == 1 )
			{
				ProcessOrderMove( m_Process.m_Movement[numLocation], m_Process.Unit_DE.Tag, m_Process.m_Movement[numLocation].nmPathNode[0] );
			}
			else
			{
				for ( i = 0; i < m_Process.m_Movement[numLocation].nmPathNode.Length; ++i )
				{
					ProcessOrderMove( m_Process.m_Movement[numLocation], m_Process.Unit_DE.Tag, m_Process.m_Movement[numLocation].nmPathNode[i], TRUE );
				}
			}
		}

		InsertMovements( m_Process, MatchTag, TriggerTag );
	}
	else
	{
		if ( m_Process.m_Movement[numLocation].bClearFailTryAnother && m_Process.m_Movement.Length > 1 )
		{
			SLog( "**** A movement failed due to the areas given not being cleared, trying another." );

			// Give it one more try, but not multiple because it could result in a dangerous infinite loop

			do
			{
				// This loop COULD go on forever but it most likely will not

				numRand = Rand(m_Process.m_Movement.Length);
			}
			until ( numRand != numLocation );

			numLocation = numRand;
			if ( CheckClear(m_Process.m_Movement[numLocation]) )
			{
				ACTION_TriggerEvent( m_Process.nmEventSuccess );

				if ( m_Process.m_Movement[numLocation].bUnitAssault )
				{
					if ( A_MatchRef.IsA('Unit') )
					{
						ProcessOrderAssault( m_Process.m_Movement[numLocation], m_Process.Unit_DE.Tag, MatchTag );
					}
					else if ( A_MatchRef.IsA('gbxPawn') )
					{
						ProcessOrderAssault( m_Process.m_Movement[numLocation], m_Process.Unit_DE.Tag, gbxPawn(A_MatchRef).MyUnit.Tag );
					}
				}
				else
				{
					if ( m_Process.m_Movement[numLocation].nmPathNode.Length == 1 )
					{
						ProcessOrderMove( m_Process.m_Movement[numLocation], m_Process.Unit_DE.Tag, m_Process.m_Movement[numLocation].nmPathNode[0] );
					}
					else
					{
						for ( i = 0; i < m_Process.m_Movement[numLocation].nmPathNode.Length; ++i )
						{
							ProcessOrderMove( m_Process.m_Movement[numLocation], m_Process.Unit_DE.Tag, m_Process.m_Movement[numLocation].nmPathNode[i], TRUE );
						}
					}
				}

				InsertMovements( m_Process, MatchTag, TriggerTag );
			}
		}
		else
			SLog( "**** Order failed on " $ m_Process.Unit_DE.Tag $ " because the areas to check if clear were not clear." );
	}
}


//=============================================================================
// Checks if a delay is necessary and then Performs the ACTION_OrderMove
//=============================================================================
function ProcessOrderMove( gbxMessageSI.MoveLocation m_Movement, name unitTag, name destinationTag, optional bool bAddtoQueue )
{
	//local TriggeredScriptDelayedMove DelayedMove;
	//DelayedMove = TriggeredScriptDelayedMove( m_Movement.DelayedMove );
	//if( m_Movement.DelayedMove != None )
	//{
	//	DelayedMove.Unit_DE = unitTag;
	//	DelayedMove.nmPath = destinationTag;
	//	DelayedMove.nmMatchTag = '';
	//	DelayedMove.TS = self;

	//	DelayedMove.GotoState('ProcessMove');
	//	SLog( "**** OrderMove successful on " $ unitTag $ " to " $ destinationTag );
	//}
	//else
	//{
		ACTION_OrderMove( unitTag, destinationTag, bAddtoQueue );
		SLog( "**** OrderMove successful on " $ unitTag $ " to " $ destinationTag );
	//}
}

//=============================================================================
// Checks if a delay is necessary and then Performs the ACTION_OrderAssault
//=============================================================================
function ProcessOrderAssault( gbxMessageSI.MoveLocation m_Movement, name unitTag, name targetUnitTag )
{
	//local TriggeredScriptDelayedMove DelayedMove;
	//DelayedMove = TriggeredScriptDelayedMove( m_Movement.DelayedMove );
	//if( m_Movement.DelayedMove != None )
	//{		
	//	DelayedMove.Unit_DE = unitTag;
	//	DelayedMove.nmPath = '';
	//	DelayedMove.nmMatchTag = targetUnitTag;
	//	DelayedMove.TS = self;

	//	DelayedMove.GotoState('ProcessMove');
	//	SLog( "**** OrderAssault successful for " $ unitTag $ " on " $ targetUnitTag );
	//}
	//else
	//{
		ACTION_OrderAssault( unitTag, targetUnitTag );
		SLog( "**** OrderAssault successful for " $ unitTag $ " on " $ targetUnitTag );
	//}
}

//=============================================================================
// Adds successful moves to the movement array for new SI comparisions
//=============================================================================
function InsertMovements( gbxMessageSI.SIData m_Process, name MatchTag, name TriggerTag )
{
	m_Movements.Insert( 0, 1 );	// Insert new element at the base because it does not matter and it's easy to read
	m_Movements[0].Unit_DE = m_Process.Unit_DE;
	m_Movements[0].nmMatchTag = MatchTag;
	m_Movements[0].nmTriggerTag = TriggerTag;
	m_Movements[0].fScore = m_Process.fScore;
	// m_Movements[0].fTime = Level.TimeSeconds;
	m_Movements[0].numStage = m_Process.numStage;
}

//=============================================================================
// Examines the given areas and if they're clear return true
//=============================================================================
function bool CheckClear( gbxMessageSI.MoveLocation m_Move )
{
	local int i;

	if ( m_Move.nmgbxMT_CheckClear.Length > 0 )
	{
		for ( i = 0; i < m_Move.nmgbxMT_CheckClear.Length; ++i )
		{
			if ( m_Move.nmgbxMT_CheckClear[i] == nmPlayerPosition )
				return FALSE;

			if ( m_Move.nmgbxMT_CheckClear[i] == nmPlayerTwoPosition )
				return FALSE;

			if ( m_Move.nmgbxMT_CheckClear[i] == nmFirePosition )
				return FALSE;

			if ( m_Move.nmgbxMT_CheckClear[i] == nmFireP2Position )
				return FALSE;

			if ( m_Move.nmgbxMT_CheckClear[i] == nmAssaultPosition )
				return FALSE;

			if ( m_Move.nmgbxMT_CheckClear[i] == nmAssaultP2Position )
				return FALSE;
		}
	}

	return TRUE;
}

//=============================================================================
// Finds any pre-existing moves, if they're more valuable return TRUE
//=============================================================================
function bool CheckMovementCollision( gbxMessageSI.SIData m_Process, name MatchTag, name TriggerTag )
{
	local int i;
	local float fScore, fScorePast;
	local float fScoreDistance, fScoreDistancePast;

	// Factors include time, distance, and original score
	// Every 64 units subtracts a point
	// Every 8 seconds subtracts a point

	if ( m_Movements.Length > 0 )
	{
		// Subtract distance points from processing SI
		fScore = m_Process.fScore;

		if ( fScore > 0.0 )
		{
			fScoreDistance = vSize( GetFirstActor(MatchTag).Location - m_Process.Unit_DE.UnitCentroid );

			if ( fScoreDistance > 0.0 )
				fScoreDistance = fScoreDistance/UnitsPerCost;

			fScore -= fScoreDistance;
			SLog( "*** Calling TargetBoost for current requested SI on " $ m_Process.Unit_DE.Tag );
			fScorePast += GiveTargetBoost( m_Process.Unit_DE, MatchTag, TriggerTag );

			if ( fScore < 0.0 )
				fScore = 0.0;
		}

		for ( i = 0; i < m_Movements.Length; ++i )
		{
			if ( m_Movements[i].Unit_DE == m_Process.Unit_DE )
			{
				if ( m_Movements[i].nmTriggerTag == TriggerTag )
				{
					SLog( "**** Skipping current processing SI because it was already performed." );
					return TRUE;
				}

				if ( m_Movements[i].nmMatchTag == MatchTag )
				{
					SLog( "**** Hmm this should never happen. But it did, culling past movement to perform new. Please alert Dorian if this does occur." );
					m_Movements.Remove(i, 1);
					return FALSE;
				}

				fScorePast = m_Movements[i].fScore;

				if ( fScorePast > 0.0 )
				{
					fScoreDistancePast = vSize( GetFirstActor(m_Movements[i].nmMatchTag).Location - m_Movements[i].Unit_DE.UnitCentroid );
					if ( fScoreDistancePast > 0.0 )
						fScoreDistancePast = fScoreDistancePast/UnitsPerCost;

					fScorePast -= fScoreDistancePast;
					SLog( "*** Calling TargetBoost for past SI on " $ m_Movements[i].Unit_DE.Tag );
					fScorePast += GiveTargetBoost( m_Movements[i].Unit_DE, m_Movements[i].nmMatchTag, m_Movements[i].nmTriggerTag );
					if ( fScorePast < 0.0 )
						fScorePast = 0.0;
				}

				if ( fScorePast >= fScore )
				{
					SLog( "**** Past SI (" $ fScorePast $ ") is more valuable or equal to the current SI (" $ fScore $ ")on " $ m_Process.Unit_DE.Tag );
					return TRUE;
				}

				m_Movements.Remove(i, 1);
				SLog( "**** Current SI (" $ fScore $ ") is more valuable then past SI (" $ fScorePast $ "), culling member " $ i $ " of m_Movements" );
				return FALSE;
			}
		}
	}

	return FALSE;
}

//=============================================================================
// Finds any colliding SI data in the gbxMT_Received array, if it exists return
// true if its more valuable.
//=============================================================================

function bool CheckSICollision( gbxMessageSI m_gbxMSIProcess, int numPosition )
{
	local int i, j;

	// Mmmm painful O(n2) D: !~!!~! this script doesn't run continuously so this should be ok
	// and in most cases the size of gbxMT_Received will be 2 or less.

	if ( gbxMT_Received.Length > 1 )
		for ( i = 1; i < gbxMT_Received.Length; ++i )
		{
			for ( j = 0; j < gbxMT_Received[i].m_GermanUnits.Length; ++j )
			{
				if ( gbxMT_Received[i].m_GermanUnits[j].Unit_DE.Tag == m_gbxMSIProcess.m_GermanUnits[numPosition].Unit_DE.Tag )
				{
					if ( gbxMT_Received[i].m_GermanUnits[j].numStage == numStartStage )
						if ( !CompareScore(m_gbxMSIProcess, numPosition, gbxMT_Received[i], j) )
						{
							SLog( "**** Found SI Collision at " $ gbxMT_Received[i].TriggerTag $ " skipping order on "
							$ gbxMT_Received[gbxMT_Received.Length-1].m_GermanUnits[i].Unit_DE.Tag $ " in " $ gbxMT_Received[gbxMT_Received.Length-1].TriggerTag );
							return TRUE;
						}
				}
			}
		}
	else
		return FALSE;
}

//=============================================================================
// Compares the left score to the right, if the left is greater or equal it
// returns true
//=============================================================================
function bool CompareScore( gbxMessageSI m_Left, int numLeftPosition, gbxMessageSI m_Right, int numRightPosition )
{
	local float fScoreLeft, fScoreRight;
	local float fDistanceLeft, fDistanceRight;

	// Factors include score, distance

	// Distance compares the vSize between the gbxMessageSI.MatchTag and the
	// current GermanUnit, for every 64 units deducts 1 point

	SLog( "**** Comparing " $ m_Left $ " position " $ numLeftPosition $ " on GermanUnit " $ m_Left.m_GermanUnits[numLeftPosition].Unit_DE.Tag );
	SLog( "**** Comparing " $ m_Right $ " position " $ numRightPosition $ " on GermanUnit " $ m_Right.m_GermanUnits[numRightPosition].Unit_DE.Tag );

	fScoreLeft = m_Left.m_GermanUnits[numLeftPosition].fScore;
	fScoreRight = m_Right.m_GermanUnits[numRightPosition].fScore;

	fDistanceLeft = vSize( GetFirstActor(m_Left.MatchTag).Location - m_Left.m_GermanUnits[numLeftPosition].Unit_DE.UnitCentroid );
	if ( fDistanceLeft > 0 )
	{
		fScoreLeft -= fDistanceLeft/UnitsPerCost;

		fScoreLeft += GiveTargetBoost( m_Left.m_GermanUnits[numLeftPosition].Unit_DE, m_Left.MatchTag, m_Left.TriggerTag );
		if ( fScoreLeft < 0 )
			fScoreLeft = 0;
	}

	fDistanceRight = vSize( GetFirstActor(m_Right.MatchTag).Location - m_Right.m_GermanUnits[numRightPosition].Unit_DE.UnitCentroid );
	if ( fDistanceRight > 0 )
	{
		fScoreRight -= fDistanceRight/UnitsPerCost;
		fScoreRight += GiveTargetBoost( m_Right.m_GermanUnits[numRightPosition].Unit_DE, m_Right.MatchTag, m_Right.TriggerTag );
		if ( fScoreRight < 0 )
			fScoreRight = 0;
	}

	SLog( "**** Score of " $ m_Left $ " is " $ fScoreLeft );
	SLog( "**** Score of " $ m_Right $ " is " $ fScoreRight );

	if ( fScoreLeft >= fScoreRight )
		return TRUE;
	else
		return FALSE;
}

//=============================================================================
// Checks if the leader of the given German unit is targeting the given
// MatchTag.
//=============================================================================
function float GiveTargetBoost( Unit Unit_DE_TB, name MatchTag, name TriggerTag )
{
	local gbxPawn gbxP_DE;

	gbxP_DE = Unit_DE_TB.Leader;
	if ( gbxP_DE != None && gbxP_DE.Controller != None && gbxP_DE.Controller.IsA('Mind') )
	{
		if ( Mind(gbxP_DE.Controller).LastEnemyUnit != None )
		{
			if ( Mind(gbxP_DE.Controller).LastEnemyUnit.Tag == MatchTag )
			{
				// Check if the match is still in the same position
				switch( MatchTag )
				{
					case nmFireUnitTag:
						if ( nmFirePosition == TriggerTag )
						{
							SLog( "**** Boosting score for movement on " $ Unit_DE_TB.Tag $ " matching " $ MatchTag );
							return TARGETBOOST;
						}
						break;
					case nmFireUnitP2Tag:
						if ( nmFireP2Position == TriggerTag )
						{
							SLog( "**** Boosting score for movement on " $ Unit_DE_TB.Tag $ " matching " $ MatchTag );
							return TARGETBOOST;
						}
						break;
					case nmAssaultUnitTag:
						if ( nmAssaultPosition == TriggerTag )
						{
							SLog( "**** Boosting score for movement on " $ Unit_DE_TB.Tag $ " matching " $ MatchTag );
							return TARGETBOOST;
						}
						break;
					case nmAssaultUnitP2Tag:
						if ( nmAssaultP2Position == TriggerTag )
						{
							SLog( "**** Boosting score for movement on " $ Unit_DE_TB.Tag $ " matching " $ MatchTag );
							return TARGETBOOST;
						}
						break;
					default:
						break;
				}

				return 0;
			}
			else if ( Mind(gbxP_DE.Controller).LastEnemyUnit.Leader.Tag == MatchTag )
			{
				// Check if the match is still in the same position
				switch( MatchTag )
				{
					case nmPlayerPawnTag:
						if ( nmPlayerPosition == TriggerTag )
						{
							SLog( "**** Boosting score for movement on " $ Unit_DE_TB.Tag $ " matching " $ MatchTag );
							return TARGETBOOST;
						}
						break;
					case nmPlayerTwoPawnTag:
						if ( nmPlayerTwoPosition == TriggerTag )
						{
							SLog( "**** Boosting score for movement on " $ Unit_DE_TB.Tag $ " matching " $ MatchTag );
							return TARGETBOOST;
						}
						break;
					default:
						break;
				}

				return 0;
			}
			else
				return 0.0;
		}
		else
			return 0.0;
	}
	else
		return 0.0;
}

//=============================================================================
// Searchs through m_GermanUnits for any dead German units and culls
//=============================================================================
function ClearPosition( name nmMatchTag )
{
	switch( nmMatchTag )
	{
	case nmPlayerPawnTag:
		nmPlayerPosition='';
		break;
	case nmPlayerTwoPawnTag:
		nmPlayerTwoPosition='';
		break;
	case nmFireUnitTag:
		nmFirePosition='';
		break;
	case nmFireUnitP2Tag:
		nmFireP2Position='';
		break;
	case nmAssaultUnitTag:
		nmAssaultPosition='';
		break;
	case nmAssaultUnitP2Tag:
		nmAssaultP2Position='';
		break;
	default:
		SLog( "**** nmMatchTag=" $ nmMatchTag $ " NOT FOUND!" );
		break;
	}
}

//=============================================================================
// Searchs through m_GermanUnits for any dead German units and culls
//=============================================================================
function bool CullMovements()
{
	local int i, j;

	i = 0;
	while ( i < m_Movements.Length )
	{
		if ( m_Movements[i].Unit_DE != None && m_Movements[i].Unit_DE.GetNumLivingMembers() <= 0 )
		{
			SLog( "**** Culling m_Movements[" $ i $ "] on " $ m_Movements[i].Unit_DE.Tag $ " because the unit is dead." );
			m_Movements.Remove(i, 1);
		}
		else if ( IsDead(m_Movements[i].nmMatchTag) )
		{
			SLog( "**** Culling m_Movements[" $ i $ "] on " $ m_Movements[i].Unit_DE.Tag $ " because " $ m_Movements[i].nmMatchTag $ "  is dead." );
			ClearPosition( m_Movements[i].nmMatchTag );
			m_Movements.Remove(i, 1);
		}
		else if ( m_Movements[i].nmMatchTag == gbxMT_Received[0].MatchTag )
		{
			if ( m_Movements[i].nmTriggerTag == gbxMT_Received[0].TriggerTag )
				i++;
			else
			{
				switch ( m_Movements[i].nmTriggerTag )
				{
					case nmPlayerPosition:
						SLog( "**** Updating m_Movements[i].nmMatchTag to " $ nmPlayerPawnTag );
						m_Movements[i].nmMatchTag = nmPlayerPawnTag;
						i++;
						break;
					case nmPlayerTwoPosition:
						SLog( "**** Updating m_Movements[i].nmMatchTag to " $ nmPlayerTwoPawnTag );
						m_Movements[i].nmMatchTag = nmPlayerTwoPawnTag;
						i++;
						break;
					case nmFirePosition:
						SLog( "**** Updating m_Movements[i].nmMatchTag to " $ nmFireUnitTag );
						m_Movements[i].nmMatchTag = nmFireUnitTag;
						i++;
						break;
					case nmFireP2Position:
						SLog( "**** Updating m_Movements[i].nmMatchTag to " $ nmFireUnitP2Tag );
						m_Movements[i].nmMatchTag = nmFireUnitP2Tag;
						i++;
						break;
					case nmAssaultPosition:
						SLog( "**** Updating m_Movements[i].nmMatchTag to " $ nmAssaultUnitTag );
						m_Movements[i].nmMatchTag = nmAssaultUnitTag;
						i++;
						break;
					case nmAssaultP2Position:
						SLog( "**** Updating m_Movements[i].nmMatchTag to " $ nmAssaultUnitP2Tag );
						m_Movements[i].nmMatchTag = nmAssaultUnitP2Tag;
						i++;
						break;
					default:
						for ( j = 0; j < gbxMT_Received[0].m_GermanUnits.Length; ++j )
						{
							if ( m_Movements[i].Unit_DE == gbxMT_Received[0].m_GermanUnits[j].Unit_DE )
							{
								SLog( "**** Culling m_Movements[" $ i $ "] on " $ m_Movements[i].Unit_DE.Tag $ " because a newer position exists." );
								m_Movements.Remove(i, 1);
								break;
							}
						}

						if ( j >= gbxMT_Received[0].m_GermanUnits.Length )
							i++;

						break;
				}
			}
		}
		else
			i++;
	}

	return true;
}

//=============================================================================
// Checks if the current unit or player is dead
//=============================================================================
function bool IsDead( name nmCheck )
{
	local Actor A_Check;

	A_Check = GetFirstActor( nmCheck );

	if ( A_Check != None )
	{
		if ( A_Check.IsA('Unit') )
		{
			if ( Unit(A_Check).GetNumLivingMembers() > 0 )
			{
				return FALSE;
			}
			else
			{
				SLog( "Unit(A_Check).GetNumLivingMembers()=" $ Unit(A_Check).GetNumLivingMembers() );
				return TRUE;
			}
		}
		else if ( A_Check.IsA('gbxPlayerPawn') )
		{
			if ( gbxPawn(A_Check).Health > 0 )
			{
				return FALSE;
			}
			else
			{
				SLog( "gbxPawn(A_Check).Health=" $ gbxPawn(A_Check).Health );
				return TRUE;	
			}
		}
		else if ( nmCheck == nmExtraTag )
		{
			SLog( "**** nmCheck matched nmExtraTag ****" );
			return FALSE;
		}
		else if ( nmCheck == nmExtraTag2 )
		{
			SLog( "**** nmCheck matched nmExtraTag2 ****" );
			return FALSE;
		}
		else
		{
			SLog( "IsDead() returned FALSE POSITIVE" );
			return TRUE;
		}
	}
	else
	{
		SLog( "A_Check=" $ A_Check );
		return TRUE;
	}
}

//=============================================================================

state Default
{
	Begin:

	bRunning = TRUE;

	if ( bInitiallyActive )
		GoToState( 'SIMovement' );

	bRunning = FALSE;
}

//=============================================================================

state Triggered
{
	Begin:

	bRunning = TRUE;

	if ( bInitiallyActive )
	{
		if ( ++numStartStage > numMaxStages )
			numStartStage = 0;

		SLog( "**** TS_SIManager triggered, updating stage to: " $ numStartStage );
	}
	else
		bInitiallyActive = TRUE;

	GoToState( 'SIMovement' );
}

//=============================================================================

State SIMovement
{
	Begin:

	if ( bInitiallyActive )
	{
		while ( gbxMT_Received.Length > 0 )
		{
			bRunning = TRUE;
			sleep( 0.5 );

			CullMovements();
			DoSIMovement( gbxMT_Received[0] );
		}
	}

	bRunning = FALSE;

	ScriptEnd:
}

defaultproperties
{
    UnitsPerCost=48.0
}

//=============================================================================
// TriggeredScriptTimedSI.
// Created by: Dorian Gorski
// Purpose: For LD to create timed counter attacks reusing the SI system
//=============================================================================
class TriggeredScriptTimedSI extends TriggeredScript
	placeable;

var(Events) export editinline Array<gbxWave> m_Waves;
var(Events) edfindable TriggeredVolume TrigVolume_CheckActive;	// Every TimerSI should have a fail safe volume setup for assaults that is triggered on, but off after a wave is complete
var(Events) bool bLoopable;

var Array<Unit> Units_InCurrent;

var int numLivingInCurrent;	// This should never exceed 8
var int numCurrentWave;		// This should never exceed m_Waves.Length
var int numCurrentTimer;	// This should never exceed m_Waves[n].m_TimerSI.Length

//=====================================
function PostBeginPlay()
{
	local int i, j;

	Super.PostBeginPlay();

	numLivingInCurrent = 0;
	numCurrentWave = 0;
	numCurrentTimer = 0;

	for ( i = 0; i < m_Waves.Length; i++ )
	{
		for ( j = 0; j < m_Waves[i].m_GermanUnits.Length; j++ )
			m_Waves[i].m_GermanUnits[j].bSelected = FALSE;
	}
}

//=====================================
// Looks at Units_InCurrent and removes bad or dead units
//=====================================
function CullUnits()
{
	local int i;

	for ( i = 0; i < Units_InCurrent.Length; i++ )
	{
		if ( Units_InCurrent[i] == None )
		{
			SLog( "**** Culling member " $ i $ " of Units_InCurrent because the Unit does not exist. ****" );
			Units_InCurrent.Remove(i, 1);
		}
		else if ( Units_InCurrent[i].GetNumLivingMembers() <= 0 )
		{
			SLog( "**** Culling member " $ i $ " of Units_InCurrent because all members are dead. ****" );
			Units_InCurrent.Remove(i, 1);
		}
	}
}

//=====================================
// Find number of living from Units_InCurrent
//=====================================
function int GetLivingInCurrent()
{
	local int i;

	CullUnits();

	numLivingInCurrent = 0;
	for ( i = 0; i < Units_InCurrent.Length; i++ )
	{
		if ( Units_InCurrent[i] != None )
			numLivingInCurrent += Units_InCurrent[i].GetNumLivingMembers();
	}	

	return numLivingInCurrent;
}

//==========================================================================================================================================================

state Triggered
{
	function OnTrigger()
	{
		SLog( "**** " $ Tag $ " was triggered while in the Triggered state. This is an error and was prevented. *****" );
	}

	Begin:

	// Start first wave
	if ( m_Waves.Length > 0 )
		GoToState( 'ProcessWave' );
	else
	{
		SLog( "**** No waves exist ****" );
		GoToState( 'ErrorState' );
	}

	ScriptEnd:
}

//==========================================================================================================================================================

state ProcessWave
{
	function OnTrigger()
	{
		SLog( "**** " $ Tag $ " was triggered while in the ProcessWave state. This is an error and was prevented. *****" );
	}

	//=====================================
	// This randomly selects Germans from the m_GermanUnits list before moving on to the timer state
	//=====================================
	function SelectGermans( gbxWave m_CWave )
	{
		local int numSelected;
		local int numRand;

		if ( m_CWave.m_GermanUnits.Length <= 0 )
		{
			SLog( "**** No m_GermanUnits given in m_Waves[" $ numCurrentWave $ "]. ****" );
			return;
		}

		if ( m_CWave.numUnitsToSelect >= m_CWave.m_GermanUnits.Length )
		{
			m_CWave.numUnitsToSelect = m_CWave.m_GermanUnits.Length;
			
			SLog( "**** Spawning all Germans in current wave *****" );

			for ( numSelected = 0; numSelected < m_CWave.m_GermanUnits.Length; numSelected++ )
				SpawnGroup(m_CWave.m_GermanUnits[numSelected]);

			return;
		}
		else
		{
			SLog( "**** Randomly selecting " $ m_CWave.numUnitsToSelect $ " from the list *****" );

			numSelected = 0;
			while( numSelected < m_CWave.numUnitsToSelect )
			{
				numRand = RAND(m_CWave.m_GermanUnits.Length);
				if ( !m_CWave.m_GermanUnits[numRand].bSelected )
				{
					m_CWave.m_GermanUnits[numRand].bSelected = TRUE;
					SpawnGroup(m_CWave.m_GermanUnits[numRand]);
					++numSelected;
				}
			}

			return;
		}
	}

	//=====================================
	// A group has been selected to be spawned, process it
	//=====================================
	function SpawnGroup( gbxWave.GermanUnit m_GUSelected )
	{
		if ( m_GUSelected.Unit_DE != None )
		{
			SLog( "**** Spawning group " $ m_GUSelected.nmSpawnTag $ " ****" );

			ACTION_TriggerEvent( m_GUSelected.nmSpawnTag );

			Units_InCurrent.Insert( Units_InCurrent.Length, 1 );
			Units_InCurrent[Units_InCurrent.Length-1] = m_GUSelected.Unit_DE;
		}
		else
			SLog( "**** No Unit Specified for m_GermanUnits given in m_Waves[" $ numCurrentWave $ "]. ****" );
	}

	//=====================================
	function Timer()
	{
		SLog( "**** " $ Tag $ " was had a timer event while in the ProcessWave state. This is an error and was prevented. *****" );
	}

	Begin:

	// Clear timer
	SetTimer( 0, FALSE );

	// Check for delays before starting next wave
	if ( numCurrentWave > 0 )
		sleep(m_Waves[numCurrentWave-1].fDelayAfterComplete);

	SLog( "**** Processing Wave " $ numCurrentWave $ " *****" );

	SelectGermans(m_Waves[numCurrentWave]);
	GoToState( 'WaitingForWaveToComplete' );
}

//==========================================================================================================================================================

state WaitingForWaveToComplete
{
	//=====================================
	// Checks if all Germans in current wave are dead and if the current wave is done processing.
	//=====================================
	function OnTrigger()
	{
		local int i;

		SLog( "**** Triggered while in the WaitingForWaveToComplete state, checking if wave is complete. ****" );

		if ( GetLivingInCurrent() <= 0 )
		{
			// Trigger wave complete event
			ACTION_TriggerEvent( m_Waves[numCurrentWave].nmCompleteEvent );

			if (m_Waves[numCurrentWave].bIncrementSkill)
			{
				ACTION_IncrementEnemyAISkillSet();
			}

			// Disable fail safe assault volume
			if ( TrigVolume_CheckActive.bInitiallyActive )
			{
				SLog( "**** " $ TrigVolume_CheckActive $ " is being disabled. ****" );
				TrigVolume_CheckActive.bInitiallyActive = FALSE;
			}

			// Look for next wave
			++numCurrentWave;
			if ( numCurrentWave < m_Waves.Length )
			{
				if ( Units_InCurrent.Length > 0 )
					CullUnits();

				numLivingInCurrent = 0;
				numCurrentTimer = 0;

				for ( i = 0; i < m_Waves.Length; i++ )
					m_Waves[numCurrentWave-1].m_GermanUnits[i].bSelected = FALSE;

				GoToState( 'ProcessWave' );
			}
			else
				GoToState( 'Complete' );
		}
	}

	//=====================================
	// Processes current m_TimerSI
	//=====================================
	function Timer()
	{
		local gbxWave.TimerSI m_TSI;

		SLog( "**** Processing timer " $ numCurrentTimer $ " from wave " $ numCurrentWave $ " *****" );

		m_TSI = m_Waves[numCurrentWave].m_TimerSI[numCurrentTimer];

		if ( m_TSI.gbxMT_Signal != None )
			m_TSI.gbxMT_Signal.Touch( Self );

		ACTION_TriggerEvent( m_TSI.nmEvent );

		++numCurrentTimer;
		if ( numCurrentTimer < m_Waves[numCurrentWave].m_TimerSI.Length )
			SetTimer( m_Waves[numCurrentWave].m_TimerSI[numCurrentTimer].fDelayTillTrigger, FALSE );
		else
			numCurrentTimer = 0;
	}

	Begin:

	if ( m_Waves[numCurrentWave].m_TimerSI.Length > 0 )
		SetTimer( m_Waves[numCurrentWave].m_TimerSI[numCurrentTimer].fDelayTillTrigger, FALSE );
	else
		SLog( "*** No TimerSI members existed for m_Waves[" $ numCurrentWave $ "]. *****" );

	OnTrigger();
}

//==========================================================================================================================================================

state Complete
{
	//=====================================
	function OnTrigger()
	{
		SLog( "**** " $ Tag $ " was triggered while in the Complete state. This is an error and was prevented. *****" );
	}

	//=====================================
	function Timer()
	{
		SLog( "**** " $ Tag $ " was had a timer event while in the Complete state. This is an error and was prevented. *****" );
	}

	Begin:

	SLog( "**** " $ Tag $ " is complete. All waves have been performed and timed events. *****" );

	// Clear timer
	SetTimer( 0, FALSE );

	// Check for delays before starting completion event
	if ( numCurrentWave > 0 )
		sleep(m_Waves[numCurrentWave-1].fDelayAfterComplete);

	GoToState( 'StartOver' );
}

state StartOver
{
	function OnTrigger()
	{
		if ( bLoopable )
		{
		SLog( "**** Starting over ****" );
		PostBeginPlay();
		GoToState( 'Triggered' );
	}
	}

	Begin:
	ACTION_TriggerEvent( Event );
	ScriptEnd:
}

//==========================================================================================================================================================

state ErrorState
{
	function OnTrigger()
	{
		SLog( "**** " $ Tag $ " was triggered while in the ErrorState state. This is an error and was prevented. *****" );
	}

	Begin:

	SLog( "**** In Error State, TimedSI Script Halted ****" );
}

//=============================================================================
// TriggeredVolumeToggle.
//=============================================================================
class TriggeredVolumeToggle extends TriggeredVolume
    placeable;
 
event Trigger( Actor Other, Pawn EventInstigator )
{
    Super.Trigger( Other, EventInstigator );
 
    // Log( "*** Toggle ***", 'TriggeredScript' );
 
    // Toggle between blocking and not blocking.
    SetCollision( !bCollideActors, bBlockActors, bBlockPlayers );
}class TruckOpelBlitzSpawner extends Actor
	hidecategories(Collision,Lighting,LightColor,Karma,Force)
	placeable;


var() bool bWaitForTrigger;			// If false, TruckOpelBlitz is spawned when level loaded. Otherwise, the TruckOpelBlitz is spawned when this actor is triggered.
var() bool bDestroyAfterSpawn;		// If true, this actor self-destructs after spawning its TruckOpelBlitz. Otherwise, it stays around and can spawn additional TruckOpelBlitzs when triggered again.

var() bool		bPlayerDrivable;
var() name		TruckOpelBlitzPawnTag;
var() name		TruckOpelBlitzControllerTag;

var() int		NumberOfPassengersToSpawn;
var() name		DriverUnitToJoin;
var() name		PassengersUnitToJoin;

var() name		TriggerOnDeath;

var() class<AIController>	ControllerClass;

var() bool		bDontSpawnDriver;
var() name		DriverTag;


function PostLinearize()
{
	Super.PostLinearize();

	if( !bWaitForTrigger )
	{
		SpawnTruckOpelBlitz();
	}
}

function Trigger( actor Other, Pawn EventInstigator )
{
	Super.Trigger( Other, EventInstigator );
	SpawnTruckOpelBlitz();
}

function SpawnTruckOpelBlitz()
{
	local TruckOpelBlitz newTruckOpelBlitz;
	local int			nHealth;

	nHealth = -1;

	// This is very slow, and has no meaning for MP anyways. So only do this stuff in SP games. 2004-12-02 JWS
	if (Level.NetMode == NM_Standalone)
	{
		if (Level.MissionManager.GetCheckpointPawnHealth( TruckOpelBlitzPawnTag, nHealth))
		{
			if (nHealth <= 0)
			{
				Log( "Vehicle "$TruckOpelBlitzPawnTag$" not created because it is dead according to the checkpoint." );
				return;
			}
		}
	}
	
	newTruckOpelBlitz = Spawn( class'TruckOpelBlitz',,, Location, Rotation );

	if( newTruckOpelBlitz == None )
	{
		Log( "WARNING: " $ class $ ".SpawnTruckOpelBlitz() unable to spawn TruckOpelBlitz." );
	}
	else
	{
		ConfigureTruckOpelBlitz( newTruckOpelBlitz );

		// give derived class a chance to be returned to...
		if (bDestroyAfterSpawn)
			SetTimer(0.1, false);
	}

//	if (nHealth > 0)
//	{
//		newTruckOpelBlitz.Health = nHealth;
//		if (nHealth < newTruckOpelBlitz.Default.Health)
//		{
//			newTruckOpelBlitz.RespawnSmoke();
//		}
//	}
		
	log(self$".SpawnTruckOpelBlitz() - "$TruckOpelBlitzPawnTag$" - "$newTruckOpelBlitz$" - "$newTruckOpelBlitz.Health$" - "$nHealth);
	
	return;
}

function Timer()
{
	Destroy();
}

function ConfigureTruckOpelBlitz( TruckOpelBlitz newTruckOpelBlitz )
{
	local AIController C;
	local vector X, Y, Z;
	local int i;

	newTruckOpelBlitz.bHasDriver = !bDontSpawnDriver;
	newTruckOpelBlitz.DriverTag = DriverTag;
	newTruckOpelBlitz.NumberOfPassengersToSpawn = NumberOfPassengersToSpawn;

	if (bPlayerDrivable)
	{
		ControllerClass = None;  // no controller for player drivable vehicles
		newTruckOpelBlitz.bNonHumanControl = false;
	}
	else if (ControllerClass == None)
	{
		ControllerClass = class'AIController';
	}

	if ( ControllerClass != None )
	{
		GetAxes(newTruckOpelBlitz.Rotation, X, Y, Z);

		// spawn the driver character spawner...
		newTruckOpelBlitz.DriverSpawner = spawn(class'CharacterSpawnerGermany', self);

		newTruckOpelBlitz.DriverSpawner.bWaitForTrigger = true;  // don't spawn until triggered
		newTruckOpelBlitz.DriverSpawner.bDestroyAfterSpawn = false;  // don't destroy after spawning a Pawn
		newTruckOpelBlitz.DriverSpawner.bSwitchToBestWeapon = true;
		newTruckOpelBlitz.DriverSpawner.bHideWeaponAfterSwitch = true;
		newTruckOpelBlitz.DriverSpawner.bSpawnAnimInGodMode = true;

		CharacterSpawnerGermany(newTruckOpelBlitz.DriverSpawner).UnitToJoin = DriverUnitToJoin;

		newTruckOpelBlitz.DriverSpawner.bPlaySpawnAnimation = true;
		newTruckOpelBlitz.DriverSpawner.SpawnAnimPackage= newTruckOpelBlitz.DriverAnimPackage;
		for (i=0; i < newTruckOpelBlitz.DriverDismountAnims.Length; i++)
		{
			newTruckOpelBlitz.DriverSpawner.SpawnAnims.Length = i + 1;
			newTruckOpelBlitz.DriverSpawner.SpawnAnims[i] = newTruckOpelBlitz.DriverDismountAnims[i];
		}

		newTruckOpelBlitz.DriverSpawner.SetLocation(newTruckOpelBlitz.Location + newTruckOpelBlitz.DriverSpawnerOffset.X * X + newTruckOpelBlitz.DriverSpawnerOffset.Y * Y + newTruckOpelBlitz.DriverSpawnerOffset.Z * Z);
		newTruckOpelBlitz.DriverSpawner.SetRotation(newTruckOpelBlitz.Rotation + rot(0,49152,0));  // face away from the truck
		newTruckOpelBlitz.DriverSpawner.SetBase(newTruckOpelBlitz);

		// spawn the passenger character spawner...
		newTruckOpelBlitz.PassengerSpawner = spawn(class'CharacterSpawnerGermany', self);

		newTruckOpelBlitz.PassengerSpawner.bWaitForTrigger = true;  // don't spawn until triggered
		newTruckOpelBlitz.PassengerSpawner.bDestroyAfterSpawn = false;  // don't destroy after spawning a Pawn
		newTruckOpelBlitz.PassengerSpawner.bSwitchToBestWeapon = true;
		newTruckOpelBlitz.PassengerSpawner.bHideWeaponAfterSwitch = false;
		newTruckOpelBlitz.PassengerSpawner.bSpawnAnimInGodMode = true;

		CharacterSpawnerGermany(newTruckOpelBlitz.PassengerSpawner).UnitToJoin = PassengersUnitToJoin;

		newTruckOpelBlitz.PassengerSpawner.bPlaySpawnAnimation = true;
		newTruckOpelBlitz.PassengerSpawner.SpawnAnimPackage= newTruckOpelBlitz.PassengerAnimPackage;
		for (i=0; i < newTruckOpelBlitz.PassengerDismountAnims.Length; i++)
		{
			newTruckOpelBlitz.PassengerSpawner.SpawnAnims.Length = i + 1;
			newTruckOpelBlitz.PassengerSpawner.SpawnAnims[i] = newTruckOpelBlitz.PassengerDismountAnims[i];
		}

		newTruckOpelBlitz.PassengerSpawner.SetLocation(newTruckOpelBlitz.Location + newTruckOpelBlitz.PassengerSpawnerOffset.X * X + newTruckOpelBlitz.PassengerSpawnerOffset.Y * Y + newTruckOpelBlitz.PassengerSpawnerOffset.Z * Z);
		newTruckOpelBlitz.PassengerSpawner.SetRotation(newTruckOpelBlitz.Rotation + rot(0,32768,0));  // face away from the truck
		newTruckOpelBlitz.PassengerSpawner.SetBase(newTruckOpelBlitz);


		C = Spawn( ControllerClass );

		if ( C == None )
		{
			Log( "WARNING: " $ class $ ".ConfigureTruckOpelBlitz() unable to spawn controller of class '" $ ControllerClass $ "'." );
		}
		else
		{
			C.Possess( newTruckOpelBlitz );
			ConfigureController( C );

			newTruckOpelBlitz.bNonHumanControl = true;

			if( TruckOpelBlitzPawnTag != 'None' )
			{
				newTruckOpelBlitz.Tag = TruckOpelBlitzPawnTag;
			}

			newTruckOpelBlitz.TriggerOnDeath = TriggerOnDeath;
		}
	}
}

function ConfigureController( AIController C )
{
	if( TruckOpelBlitzControllerTag != 'None' )
	{
		C.Tag = TruckOpelBlitzControllerTag;
	}
}

defaultproperties
{
	DrawType=DT_Mesh
	EditorMeshName="k_vehicle_de.de_opel_blitz"

	bHidden=true
	bStatic=false
	bDirectional=true
	CollisionHeight=128.0
	CollisionRadius=200.0

	bWaitForTrigger=false
	bDestroyAfterSpawn=true

	bPlayerDrivable=false

	NumberOfPassengersToSpawn=3
	DriverUnitToJoin=SquadGermanyDefault
	PassengersUnitToJoin=SquadGermanyDefault

	bDontSpawnDriver=false
}
