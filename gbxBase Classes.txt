class AISpeechManager extends IAISpeechManager
	transient
	native;

cpptext
{
	UBOOL ShouldRejectPlayRequest( APawn* P, FName speechName );
	void RemoveSpeechesWithBadContext( FName speechName, APawn* Speaker, UObject* oRegarding );
	int AAISpeechManager::GetPriorityByGroupName( FName GroupName );
	UBOOL IsBlocked( FSpeechInfo& speech, UBOOL& bRedundant );
	UBOOL AAISpeechManager::IsSpeechConflict( FSpeechInfo& playingSpeech, FSpeechInfo& waitingSpeech, UBOOL& bRepetitionSpeech );
	UBOOL IsSpeechFinished( const FSpeechInfo& speech )
	{
		return speech.bIsPlaying != 0 && speech.timeFinishedPlaying < Level->TimeSeconds;
	}		
}

// TODO replication issues.
// TODO incorporate gestures.

var float	UpdateInterval;
var float	SpeechOverlapDistance;	// The maximum distance between pawns within which the pawns' speeches are considered conflicting.
//var float	ShuffleProbability;		// The chance that any one waiting speech will be shuffled with similar ones behind it in the queue.

var bool	bNoGermanVoices;
var bool	bDisabled;
var bool	bNoFlankingSpeeches;
var bool	bNoPlayerWarningSpeeches;

var array< VoiceType >	ArrVoiceTypes;
var array< Name >		DisabledSpeakers;

var const int PRIORITY_INJURY;
var const int PRIORITY_URGENT_REMARK;
var const int PRIORITY_NEW_INFORMATION;
var const int PRIORITY_ORDER_RESPONSE_LEADER;
var const int PRIORITY_ORDER_RESPONSE;
var const int PRIORITY_THROWING_GRENADE;
var const int PRIORITY_BUDDY_HURT;
var const int PRIORITY_ALL_ENEMIES_KILLED;
var const int PRIORITY_ENEMY_KILLED;
var const int PRIORITY_COVERINGFIRE;
var const int PRIORITY_RELOADING;
var const int PRIORITY_RANDOM_COMMENTARY;

struct native SpeechInfo
{
	// API-set values
	var gbxPawn thePawn;					// The Pawn playing the speech.
	var gbxPawn theSpeaker;					// The Pawn saying the speech.
	var gbxPawn theListener;				// The Pawn hearing the speech.
	var name	speechName;					// The actual sound to be played.
	var name	repetitionSpeechName;		// The speech to be played if this request turns out to be a repetition.
	var name	keyName;					// specifies a keyname if desired
	var float	priority;					// The priority of this speech.
	var float	timeDelay;					// How long the Pawn should wait before actually speaking.
	var Object	oRegarding;					// The object this speech is in reference to.
	var float	timeout;					// How long the request should wait before giving up. (0 for infinite)
	var float   timeBlockRedundancies;		// How long after finishing playing the speech continues to block other speeches that say the same thing.

	// System-calculated values
	var byte	bIsPlaying;					// True if the sound is currently playing.
	var byte	bRepetition;				// A recently played speech said the same thing.
	var int		SoundHandle;				// Handle used to stop the sound mid-speech.
	var float	timeRequest;				// The time this speech request was made.
	var float	timePlayed;					// The time this sound actually started playing.
	var float	timeFinishedPlaying;		// The time we expect this sound to finish playing.
};

var array< SpeechInfo > WaitingSpeeches;
var array< SpeechInfo > PlayingSpeeches;
var array< SpeechInfo > FinishedSpeeches;

// API ////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Enable/disable the speech system; useful for LDs to turn off combat dialogue while scripted sequences are playing.
function EnableSpeech() 
{
	bDisabled = false;
}

function DisableSpeech() 
{
	bDisabled = true;
	WaitingSpeeches.Remove( 0, WaitingSpeeches.Length );
	PlayingSpeeches.Remove( 0, PlayingSpeeches.Length );
	FinishedSpeeches.Remove( 0, FinishedSpeeches.Length );
}

function EnableSpeechForCharacter( Pawn P )
{
	local int ndx;

	if ( P == None )
		return;

	for( ndx=0; ndx < DisabledSpeakers.Length; ++ndx )
	{
		if ( DisabledSpeakers[ ndx ] == P.Name )
		{
			DisabledSpeakers.Remove( ndx, 1 );
			return;
		}
	}
}

function DisableSpeechForCharacter( Pawn P )
{
	local int ndx;

	if ( P == None )
		return;

	for( ndx=0; ndx < DisabledSpeakers.Length; ++ndx )
	{
		if ( DisabledSpeakers[ ndx ] == P.Name )
		{
			return;
		}
	}

	DisabledSpeakers.Length = DisabledSpeakers.Length + 1;
	DisabledSpeakers[ DisabledSpeakers.Length - 1 ] = P.Name;

	RemoveSpeechesForSpeaker( P );
}

native function PlaySpeech(
	Pawn Speaker,						// The Pawn saying the speech.
	Pawn Listener,						// The Pawn hearing the speech.
	name speechName,				// The speech to be played.
	optional name repetitionSpeechName,	// The speech to be played if this request turns out to be a repetition.
	optional String keyname,		// specific keyname if desired
	optional float timeDelay,		// How long the Pawn should wait before actually speaking.
	optional Object oRegarding,		// The object this speech is in reference to.
	optional float timeout,			// How long the request should wait before giving up. (0 for infinite)
	optional float timeBlockRedundancies // How long after finishing playing the speech continues to block other speeches that say the same thing.
);

function EnableFlankingSpeeches( bool bEnable )
{
	bNoFlankingSpeeches = !bEnable;

	if ( bNoFlankingSpeeches )
	{
		RemoveSpeeches( 'ShouldFlank' );
	}
}

function EnablePlayerWarningSpeeches( bool bEnable )
{
	bNoPlayerWarningSpeeches = !bEnable;

	if ( bNoPlayerWarningSpeeches )
	{
		RemoveSpeeches( 'WarnPlayerGetDown' );
		RemoveSpeeches( 'PlayerWounded' );
	}
}

function RemoveSpeeches( name speechName, optional Object Regarding )
{
	local int i;

	if ( speechName == '' )
		return;

	for( i = 0; i < WaitingSpeeches.Length; ++i )
	{
		if(	( WaitingSpeeches[i].speechName == speechName ) && 
			( Regarding == None || Regarding == WaitingSpeeches[i].oRegarding ) )
		{
			WaitingSpeeches.Remove( i, 1 );
			--i;
		}		
	}
}

function RemoveSpeechesForSpeaker( Pawn Speaker, optional name speechName, optional bool bKillPlayingSpeeches )
{
	local int i;

	if ( Speaker == None )
		return;

	for( i = 0; i < WaitingSpeeches.Length; ++i )
	{
		if( ( speechName == '' || WaitingSpeeches[i].speechName == speechName ) && 
			 WaitingSpeeches[i].thePawn == Speaker &&
			 WaitingSpeeches[i].speechName != 'Death' )
		{
			WaitingSpeeches.Remove( i, 1 );
			--i;
		}		
	}

	if ( bKillPlayingSpeeches )
	{
		for( i = 0; i < PlayingSpeeches.Length; ++i )
		{
			if( ( speechName == '' || PlayingSpeeches[i].speechName == speechName ) && 
			 PlayingSpeeches[i].thePawn == Speaker &&
			 PlayingSpeeches[i].speechName != 'Death')
			{
				if ( PlayingSpeeches[ i ].SoundHandle > -1 )
				{
					PlayingSpeeches[ i ].thePawn.StopSpeech( PlayingSpeeches[ i ].SoundHandle );
				}

				PlayingSpeeches.Remove( i, 1 );
				--i;
			}
		}
	}
}

// INTERNALS //////////////////////////////////////////////////////////////////////////////////////////////////////

function Initialize()
{
}

function PreBeginPlay()
{
	Super.PreBeginPlay();

	SetTimer( UpdateInterval, true );
}

function Timer()
{
	if ( !bDisabled )
	{
		UpdateSpeech();
	}

	if(TimerRate != UpdateInterval)
		SetTimer( UpdateInterval, true );	
}

function bool ShouldRejectPlayRequest( Pawn P, name speechName )
{
	local int ndx;

	// Check to see if this is a flanking-speech and also if flanking speeches are disallowed.
	if ( bNoFlankingSpeeches && speechName == 'ShouldFlank' )
	{
		return true;
	}
	else if ( bNoPlayerWarningSpeeches && ( speechName == 'WarnPlayerGetDown' || speechName == 'PlayerWounded' ) )
	{
		return true;
	}
	// Check to see if this pawn has had his mouth zipped shut.
	else
	{
		for( ndx=0; ndx < DisabledSpeakers.Length; ++ndx )
		{
			if ( DisabledSpeakers[ ndx ] == P.Name )
			{
				return true;
			}
		}
	}

	return false;
}

// Sometimes, the content of new speech means other waiting speeches should be invalidated because they no longer make sense.
// In the case of really urgent speeches (such as pain utterances), everything by the speaker is considered out of context.
function RemoveSpeechesWithBadContext( name speechName, Pawn Speaker, Object Regarding )
{
	local name ToRemove1, ToRemove2, ToRemove3;
	local bool bInterruptSpeaker, bRemoveIfSameTeamAsSpeaker;
	local int i;

	switch ( speechName )
	{
		// If new enemies are sighted, don't try to say "I think we got 'em all!"
		case 'EnemySighted':
		case 'SeeMG42':
		case 'SeeAT':
		case 'SeeEnemyTank':
		case 'MortarTeam':
		case 'See88':
		case 'RocketLauncherSighted':
			ToRemove1 = 'AllEnemiesDead';
			ToRemove2 = 'SquadKilled';
			ToRemove3 = 'CommentaryUpperHand';			
			bRemoveIfSameTeamAsSpeaker = true;
			break;

		case 'LowImpactWound':
		case 'Wounded':
		case 'Death':
			bInterruptSpeaker = true;
			break;
		default:
			break;
	}

	// If we are to interrupt this speaker, it is urgent, so stop his playing speeches and
	// remove ALL of his waiting speeches.
	if ( bInterruptSpeaker )
	{
		for( i=0; i < PlayingSpeeches.Length; ++i )
		{
			if ( PlayingSpeeches[ i ].thePawn == Speaker && PlayingSpeeches[ i ].speechName != 'Wounded' && PlayingSpeeches[ i ].speechName != 'Death' )
			{
				PlayingSpeeches[ i ].thePawn.StopSpeech( PlayingSpeeches[ i ].SoundHandle );
				PlayingSpeeches.Remove( i, 1 );
				--i;
			}
		}

		for( i=0; i < WaitingSpeeches.Length; ++i )
		{
			if ( WaitingSpeeches[ i ].thePawn == Speaker && WaitingSpeeches[ i ].speechName != 'Wounded' && WaitingSpeeches[ i ].speechName != 'Death')
			{
				WaitingSpeeches.Remove( i, 1 );
				--i;
			}
		}
	}
	// Otherwise, this is a standard case of the context changing.  Remove select waiting speeches only.
	else if ( ToRemove1 != '' )
	{
		for( i=0; i < WaitingSpeeches.Length; ++i )
		{			
			// Remove this speech if it is one of the marked speeches and either the regarding-object is the same
			// OR the speaker is on the same team (and the same-team rule applies).
			if ( ( WaitingSpeeches[ i ].speechName == ToRemove1 || WaitingSpeeches[ i ].speechName == ToRemove2 || WaitingSpeeches[ i ].speechName == ToRemove3 ) && 
				 (	WaitingSpeeches[ i ].oRegarding == Regarding || 
					( bRemoveIfSameTeamAsSpeaker && WaitingSpeeches[ i ].thePawn.SameTeamAs( Speaker ) ) ) )
			{
				WaitingSpeeches.Remove( i, 1 );
				--i;
			}
		}
	}
}

native function UpdateSpeech();


function int GetPriorityByGroupName( name GroupName )
{
	switch( GroupName )
	{
	case 'LowImpactWound':
	case 'Wounded':
	case 'Death':
		return PRIORITY_INJURY;

	case 'IncomingGrenade':
	case 'PlayerWounded':
	case 'BuddyWounded':
	case 'NearMiss':
	case 'AlliesDying':
	case 'OuttaTheWay':
	case 'Flanked':
		return PRIORITY_URGENT_REMARK;	

	case 'EnemySighted':
	case 'EnemyFireTeam':
	case 'SeeMG42':
	case 'SeeAT':
	case 'SeePak88':
	case 'SeeEnemyTank':
	case 'RocketLauncherSighted':
	case 'EnemyUnsuppressed':
		return PRIORITY_NEW_INFORMATION;

	case 'MoveOutLeader':
	case 'TargetOrderLeader':
		return PRIORITY_ORDER_RESPONSE_LEADER;

	case 'OrderResponse':		
	case 'TargetOrderResponse':
	case 'CantHitTarget':
		return PRIORITY_ORDER_RESPONSE;

	case 'ThrowingGrenade':
		return PRIORITY_THROWING_GRENADE;

	case 'BuddyWounded':
	case 'BuddyDown':
	case 'Allen':
	case 'Baker':
	case 'Campbell':
	case 'Cole':
	case 'Combs':
	case 'Corrion':
	case 'Courtland':
	case 'Desola':
	case 'Doe':
	case 'Doyle':
	case 'Friar':
	case 'Garnett':
	case 'Hartsock':
	case 'Hooper':
	case 'Jameson':
	case 'Leggett':
	case 'Locke':
	case 'Mac':
	case 'Marsh':
	case 'McConnel':
	case 'McCreary':
	case 'Muzza':
	case 'Obrieski':
	case 'Paddock':
	case 'Paige':
	case 'Rivas':
	case 'Wheaton':
	case 'York':
	case 'Zanovich':
		return PRIORITY_BUDDY_HURT;

	case 'AllEnemiesDead':
	case 'SquadKilled':
		return PRIORITY_ALL_ENEMIES_KILLED;

	case 'ConfirmedKill':
	case 'EnemyKilled':
	case 'TankKilled':
	case 'MG42Killed':
	case 'EnemyRocketLauncherKilled':	
	case 'EnemySuppressed':	
	case 'FlankTheEnemy':
		return PRIORITY_ENEMY_KILLED;

	case 'CoveringFire':
		return PRIORITY_COVERINGFIRE;

	case 'Reloading':
		return PRIORITY_RELOADING;

	case 'Commentary':
	case 'CommentaryUpperHand':
	case 'CommentaryLowerHand':
		return PRIORITY_RANDOM_COMMENTARY;

	default:
		return 0;
	}
}

event ReallyPlaySpeech( int ndxWaitingSpeech )
{
	local name actualSpeechName;
	local float Duration;
	local SpeechInfo speech;
	local int SoundHandle;

	if ( ndxWaitingSpeech < 0 || ndxWaitingSpeech >= WaitingSpeeches.Length )
		return;

	speech = WaitingSpeeches[ ndxWaitingSpeech ];

	if( speech.thePawn != None && !speech.thePawn.bDeleteMe && !IsSpeaking( speech.thePawn ) )
	{
		if( speech.bRepetition != 0 )
		{
			actualSpeechName = speech.repetitionSpeechName;
		}
		else
		{
			actualSpeechName = speech.speechName;
		}

		if( actualSpeechName != '' )
		{
			//Duration = speech.thePawn.PlaySpeech( actualSpeechName, speech.keyName, SoundHandle );
			Duration = speech.thePawn.PlayBattleDialogue( actualSpeechName, speech.theSpeaker, speech.theListener, speech.keyName, SoundHandle );
			log( "AISpeechManager::ReallyPlaySpeech() - " $ actualSpeechName $ " Duration=" $ Duration $ ", SoundHandle=" $ SoundHandle, 'RSC' );
			//if ( Duration < 0.001f )	// == 0.0
			//{
			//	actualSpeechName = GetSubstituteSpeech( actualSpeechName );
			//	if ( actualSpeechName != '' )
			//	{
			//		//Duration = speech.thePawn.PlaySpeech( actualSpeechName, speech.keyName, SoundHandle );
			//		Duration = speech.thePawn.PlayBattleDialogue( actualSpeechName, speech.theSpeaker, speech.theListener, speech.keyName );;
			//		log( "AISpeechManager::ReallyPlaySpeech() - 2ND try - " $ actualSpeechName $ " Duration=" $ Duration, 'RSC' );
			//	}
			//}

			if ( Duration > 0.0f )
			{
				speech.timePlayed			= Level.TimeSeconds;
				speech.timeFinishedPlaying	= Level.TimeSeconds + Duration;
				speech.bIsPlaying			= 1;
				speech.SoundHandle			= SoundHandle;

				PlayingSpeeches.Length = PlayingSpeeches.Length + 1;
				PlayingSpeeches[ PlayingSpeeches.Length - 1 ] = speech;
			}
		}
	}

	WaitingSpeeches.Remove( ndxWaitingSpeech, 1 );
}

//======================================================================
// IsSpeaking()
// returns true if the pawn is already saying something at the moment.
//======================================================================
function bool IsSpeaking( Pawn Speaker )
{
	local int i;
	for( i=0; i < PlayingSpeeches.Length; ++i )
	{
		if ( PlayingSpeeches[ i ].thePawn == Speaker )
		{
			if( !IsSpeechFinished( PlayingSpeeches[i] ) )
			{
				log( "AISpeechManager::IsSpeaking() returned TRUE", 'RSC' );
				return true;
			}
		}
	}

	log( "AISpeechManager::IsSpeaking() returned FALSE", 'RSC' );
	return false;
}

// In situations where a pawn doesn't have a given speech group-name, see if there's a substitute we can use instead.
function name GetSubstituteSpeech( name speechName )
{
	switch ( speechName )
	{
		case 'AllEnemiesDeadGuys':
			return 'AllEnemiesDead';
		
		default:
			return '';
	}
}

function bool IsSpeechFinished( SpeechInfo speech )
{
	return speech.bIsPlaying != 0 && speech.timeFinishedPlaying < Level.TimeSeconds;
}

function bool IsBlocked( out SpeechInfo speech, out byte bRedundant )
{
	local int i;
	local byte bRepetitionSpeech;

	bRedundant=0;

	for( i = 0; i < PlayingSpeeches.Length; ++i )
	{
		if( IsSpeechConflict( PlayingSpeeches[ i ], speech, bRepetitionSpeech ))
		{
			if( bRepetitionSpeech != 0 )
			{
				// The waiting speech is basically saying the same thing as the playing speech.

				// If the speech I'm repeating is also a repetition, don't say anything. Get rid of this speech request.
				if( PlayingSpeeches[ i ].bRepetition != 0 )
				{
					bRedundant=1;
				}
				else
				{
					// Convert it to an "agree" speech.
					speech.bRepetition = 1;
				}
			}

			return true;
		}
	}

	// Check for redundancy with finished speeches.

	// TODO finished speeches should not block non-redundant agreements.

	for( i = 0; i < FinishedSpeeches.Length; ++i )
	{
		if( IsSpeechConflict( FinishedSpeeches[ i ], speech, bRepetitionSpeech ) && 
			( FinishedSpeeches[i].priority >= speech.priority ) )
		{
			if( bRepetitionSpeech != 0 )
			{
				// The waiting speech is basically saying the same thing as the playing speech.

				// If the speech I'm repeating is also a repetition, don't say anything. Get rid of this speech request.
				if( FinishedSpeeches[ i ].bRepetition != 0 )
				{
					bRedundant=1;
				}
				else
				{
					// Convert it to an "agree" speech.
					speech.bRepetition = 1;
				}
			}

			if( bRedundant != 0 || speech.bRepetition == 0 )
			{
				return true;
			}
		}
	}

	return false;
}

function bool IsSpeechConflict( out SpeechInfo playingSpeech, out SpeechInfo waitingSpeech, out byte bRepetitionSpeech )
{
	bRepetitionSpeech = 0;

	if( playingSpeech.speechName == waitingSpeech.speechName ||
	  ( playingSpeech.oRegarding != None && playingSpeech.oRegarding == waitingSpeech.oRegarding ) ||
	    playingSpeech.thePawn != None && playingSpeech.thePawn == waitingSpeech.thePawn )
	{
		if ( playingSpeech.speechName == waitingSpeech.speechName )
		{
			bRepetitionSpeech = 1;
		}

		// These speeches are indeed similar, said by the same person, saying the same phrase or talking about the same object.

		if( playingSpeech.thePawn == None || waitingSpeech.thePawn == None )
		{
			// Pawnless speeches block every similar speech and are blocked by every similar speech.
			return true;
		}

		if(	playingSpeech.thePawn.SameTeamAs(waitingSpeech.thePawn))
		{
			return VSize( playingSpeech.thePawn.Location - waitingSpeech.thePawn.Location ) <= SpeechOverlapDistance;
		}
	}

	return false;
}

function VoiceType GetGlobalVoiceType( String VoiceTypeStr )
{
	local int i;
	local class< VoiceType > newTypeClass;
	local VoiceType newType;

	for( i = 0; i < ArrVoiceTypes.Length; ++i )
	{
		if( ArrVoiceTypes[ i ].ClassString == VoiceTypeStr )
		{
			return ArrVoiceTypes[ i ];
		}
	}

	// Found no already-existing voice type. Construct one.

	newTypeClass = class< VoiceType >( DynamicLoadObject( VoiceTypeStr, class'class' ));

	if( newTypeClass != None )
	{
		newType = new( Level.Outer ) newTypeClass;

		if( newType != None )
		{
			newType.Initialize( Self );
			ArrVoiceTypes.Length = ArrVoiceTypes.Length + 1;
			ArrVoiceTypes[ ArrVoiceTypes.Length - 1 ] = newType;

			newType.ClassString = VoiceTypeStr;

			return newType;
		}
		else
		{
			Warn( "AISpeechManager.GetGlobalVoiceType( " $ VoiceTypeStr $ " ) could not create an instance of the specified VoiceType class." );
		}
	}
	else
	{
		Warn( "AISpeechManager.GetGlobalVoiceType( " $ VoiceTypeStr $ " ) could not load the specified VoiceType class." );
	}

	return None;
}

function DisplayDebug(Canvas Canvas, out float YL, out float YPos)
{
	local int x;
	local Name Regarding;

	Canvas.SetPos( 500, 20 );
	Canvas.SetDrawColor(255,255,0);

	Canvas.DrawText( "SPEECH MANAGER CONTENTS" );
	
	YPos += YL;
	Canvas.SetPos(500,YPos);
	Canvas.DrawText( "WAITING:" );
	
	YPos += YL;
	for( x = 0; x < WaitingSpeeches.Length; ++x )
	{
		if ( WaitingSpeeches[x].oRegarding != None )
			Regarding = WaitingSpeeches[x].oRegarding.Name;
		else
			Regarding = 'None';
		
		Canvas.SetPos(500,YPos);
		Canvas.DrawText( WaitingSpeeches[x].speechName$" : BY "$WaitingSpeeches[x].thePawn.Name$" : REG "$Regarding );
		YPos += YL;
	}

	YPos += YL;
	Canvas.SetPos(500,YPos);
	Canvas.DrawText( "PLAYING:" );

	YPos += YL;
	for( x = 0; x < PlayingSpeeches.Length; ++x )
	{
		if ( PlayingSpeeches[x].oRegarding != None )
			Regarding = PlayingSpeeches[x].oRegarding.Name;
		else
			Regarding = 'None';
		
		Canvas.SetPos(500,YPos);
		Canvas.DrawText( PlayingSpeeches[x].speechName$" : BY "$PlayingSpeeches[x].thePawn.Name$" : REG "$Regarding );
		YPos += YL;
	}

	YPos += YL;
	Canvas.SetPos(500,YPos);
	Canvas.DrawText( "FINISHED:" );

	YPos += YL;
	for( x = 0; x < FinishedSpeeches.Length; ++x )
	{
		if ( FinishedSpeeches[x].oRegarding != None )
			Regarding = FinishedSpeeches[x].oRegarding.Name;
		else
			Regarding = 'None';		

		Canvas.SetPos(500,YPos);
		Canvas.DrawText( FinishedSpeeches[x].speechName$" : BY "$FinishedSpeeches[x].thePawn.Name$" : REG "$Regarding );
		YPos += YL;
	}
}

function ShoutNameOf(
	Pawn Speaker, 
	Pawn Listener, 
	Pawn Named, 
	name AlternateSpeech, 
	optional float timeDelay, 
	optional float timeout, 
	optional float timeBlockRedundancies 
	)
{
	local name CharacterName;

	if ( Speaker != None && Named != None && Named.IsA( 'gbxPawn' ) )
	{
		CharacterName = gbxPawn( Named ).GetCharacterFName();
		if ( CharacterName != '' )
		{
			PlaySpeech( 
				Speaker, 
				Listener,
				CharacterName, 
				AlternateSpeech, 
				,
				timeDelay, 
				Named, 
				timeout, 
				timeBlockRedundancies 
			);	
		}
	}
}


defaultproperties
{
	bStatic=false
	bKeepOnClient=true
	RemoteRole=Role_NONE

	UpdateInterval=0.11
	SpeechOverlapDistance=2048
	bNoGermanVoices=false

	PRIORITY_INJURY = 100
	PRIORITY_URGENT_REMARK = 90
	PRIORITY_NEW_INFORMATION = 87
	PRIORITY_ORDER_RESPONSE_LEADER = 85
	PRIORITY_ORDER_RESPONSE = 80
	PRIORITY_THROWING_GRENADE = 70
	PRIORITY_BUDDY_HURT = 60
	PRIORITY_ALL_ENEMIES_KILLED = 50
	PRIORITY_ENEMY_KILLED = 45
	PRIORITY_COVERINGFIRE = 40
	PRIORITY_RELOADING = 30
	PRIORITY_RANDOM_COMMENTARY = 20

	//ShuffleProbability=0.5
}
class AnimNotify_EjectShell extends AnimNotify_Scripted;



event Notify( Actor Owner )
{
	local gbxAmmo AmmoClass;

	AmmoClass = gbxAmmo(Weapon(Owner).Ammo[0]);

	if( AmmoClass != None && Weapon(Owner).ThirdPersonActor.IsA('gbxWeaponAttachment') )
	{
		gbxWeaponAttachment(Weapon(Owner).ThirdPersonActor).EjectShell( WeaponAttachment(Weapon(Owner).ThirdPersonActor).GetChamberLocationWorld(), AmmoClass.AmmoShellClass );
	}
}
class AnimNotify_FiregbxWeaponNew extends AnimNotify_Scripted;



event Notify( Actor Owner )
{
	if (Owner.IsA('gbxWeapon'))
	{

	}
}
class AnimNotify_FireWeaponEffect extends AnimNotify_Scripted;

enum EWeapEffect
{
	WeapEffect_M1,
	WeapEffect_30Cal,
	WeapEffect_Thompson,
	WeapEffect_Colt1911,
	WeapEffect_M1Carbine,
	WeapEffect_Bazooka,
	WeapEffect_M3A1
};


var() EWeapEffect	eWeaponEffect;

var MuzzleFlashM1_			M1MuzFlash;
var MuzzleFlashM1_			Cal30MuzFlash;
var MuzzleFlashThompson		ThompsonMuzFlash;
var MuzzleFlashThompson		M3A1MuzFlash;
var MuzzleFlashColt1911_	ColtMuzFlash;
var MuzzleFlashBazooka		BazookaMuzFlash;
var ShellUSM1Lite			M1Shells;
var ShellDEFG42Lite			Cal30Shells;
var ShellUSThompsonLite		ThompsonShells;
var ShellUSThompsonLite		M3A1Shells;
var ShellUSColt1911Lite		ColtShells;
var Cue						FireSoundCue;

event Notify( Actor Owner )
{
	local Coords					FlashLoc, ShellLoc;
	local Rotator					FlashRot, ShellRot;	
	local gbxMuzzleFlash			FlashEmitter;
	local gbxWeaponShells			ShellEmitter;

	switch (eWeaponEffect)
	{
		case WeapEffect_M1:
			if ( Default.M1MuzFlash == None )
			{
				Default.M1MuzFlash = Owner.Spawn(class'MuzzleFlashM1_', Owner);
				Default.M1MuzFlash.InitializeMuzzleFlash();
			}
			if ( Default.M1Shells == None )
				Default.M1Shells = Owner.Spawn(class'ShellUSM1Lite', Owner);

			FlashEmitter = Default.M1MuzFlash;
			ShellEmitter = Default.M1Shells;

			FlashLoc = Owner.GetAttachmentTagWorldCoords( 'rifle_muzzle' );
			FlashRot = Owner.GetBoneRotation( 'rifle_muzzle' );			
			ShellLoc = Owner.GetAttachmentTagWorldCoords( 'rifle_chamber' );
			ShellRot = Owner.GetBoneRotation( 'rifle_chamber' );
			if (FireSoundCue == None)
			{
				FireSoundCue = Owner.LoadSound( "W_M1GARAND.FIRE" );
			}
			break;
		case WeapEffect_30Cal:
			if ( Default.Cal30MuzFlash == None )
			{
				Default.Cal30MuzFlash = Owner.Spawn(class'MuzzleFlashM1_', Owner);
				Default.Cal30MuzFlash.InitializeMuzzleFlash();
			}
			if ( Default.Cal30Shells == None )
				Default.Cal30Shells = Owner.Spawn(class'ShellDEFG42Lite', Owner);

			FlashEmitter = Default.Cal30MuzFlash;
			ShellEmitter = Default.Cal30Shells;

			FlashLoc = Owner.GetAttachmentTagWorldCoords( 'muzzle' );
			FlashRot = Owner.GetBoneRotation( 'muzzle' );
			ShellLoc = Owner.GetAttachmentTagWorldCoords( 'shells' );
			ShellRot = Owner.GetBoneRotation( 'shells' );
			break;
		case WeapEffect_Thompson:
			if ( Default.ThompsonMuzFlash == None )
			{
				Default.ThompsonMuzFlash = Owner.Spawn(class'MuzzleFlashThompson', Owner);
				Default.ThompsonMuzFlash.InitializeMuzzleFlash();
			}
			if ( Default.ThompsonShells == None )
				Default.ThompsonShells = Owner.Spawn(class'ShellUSThompsonLite', Owner);

			FlashEmitter = Default.ThompsonMuzFlash;
			ShellEmitter = Default.ThompsonShells;

			FlashLoc = Owner.GetAttachmentTagWorldCoords( 'rifle_muzzle_thompson' );
			FlashRot = Owner.GetBoneRotation( 'rifle_muzzle_thompson' );
			ShellLoc = Owner.GetAttachmentTagWorldCoords( 'rifle_chamber' );
			ShellRot = Owner.GetBoneRotation( 'rifle_chamber' );
			if (FireSoundCue == None)
			{
				FireSoundCue = Owner.LoadSound( "W_THOMPSON.FIRE" );
			}
			break;
		case WeapEffect_Colt1911:
			if ( Default.ColtMuzFlash == None )
			{
				Default.ColtMuzFlash = Owner.Spawn(class'MuzzleFlashColt1911_', Owner);
				Default.ColtMuzFlash.InitializeMuzzleFlash();
			}
			if ( Default.ColtShells == None )
				Default.ColtShells = Owner.Spawn(class'ShellUSColt1911Lite', Owner);

			FlashEmitter = Default.ColtMuzFlash;
			ShellEmitter = Default.ColtShells;

			FlashLoc = Owner.GetAttachmentTagWorldCoords( 'pistol_muzzle' );
			FlashRot = Owner.GetBoneRotation( 'pistol_muzzle' );
			ShellLoc = Owner.GetAttachmentTagWorldCoords( 'pistol_chamber' );
			ShellRot = Owner.GetBoneRotation( 'pistol_chamber' );
			if (FireSoundCue == None)
			{
				FireSoundCue = Owner.LoadSound( "W_COLT.FIRE" );
			}
			break;
		case WeapEffect_M1Carbine:
			if ( Default.M1MuzFlash == None )
			{
				Default.M1MuzFlash = Owner.Spawn(class'MuzzleFlashM1_', Owner);
				Default.M1MuzFlash.InitializeMuzzleFlash();
			}
			if ( Default.M1Shells == None )
				Default.M1Shells = Owner.Spawn(class'ShellUSM1Lite', Owner);

			FlashEmitter = Default.M1MuzFlash;
			ShellEmitter = Default.M1Shells;

			FlashLoc = Owner.GetAttachmentTagWorldCoords( 'rifle_muzzle' );
			FlashRot = Owner.GetBoneRotation( 'rifle_muzzle' );
			ShellLoc = Owner.GetAttachmentTagWorldCoords( 'rifle_chamber' );
			ShellRot = Owner.GetBoneRotation( 'rifle_chamber' );
			if (FireSoundCue == None)
			{
				FireSoundCue = Owner.LoadSound( "W_M1GARAND.FIRE" );
			}
			break;
		case WeapEffect_Bazooka:
			if ( Default.BazookaMuzFlash == None )
			{
				Default.BazookaMuzFlash = Owner.Spawn(class'MuzzleFlashBazooka', Owner);
				Default.BazookaMuzFlash.InitializeMuzzleFlash();
			}

			FlashEmitter = Default.BazookaMuzFlash;

			FlashLoc = Owner.GetAttachmentTagWorldCoords( 'rifle_muzzle' );
			FlashRot = Owner.GetBoneRotation( 'rifle_muzzle' );
			if (FireSoundCue == None)
			{
				FireSoundCue = Owner.LoadSound( "W_USBAZOOKA.FIRE" );
			}
			break;
		case WeapEffect_M3A1:
			if ( Default.M3A1MuzFlash == None )
			{
				Default.M3A1MuzFlash = Owner.Spawn(class'MuzzleFlashThompson', Owner);
				Default.M3A1MuzFlash.InitializeMuzzleFlash();
			}
			if ( Default.M3A1Shells == None )
				Default.M3A1Shells = Owner.Spawn(class'ShellUSThompsonLite', Owner);

			FlashEmitter = Default.M3A1MuzFlash;
			ShellEmitter = Default.M3A1Shells;

			FlashLoc = Owner.GetAttachmentTagWorldCoords( 'rifle_muzzle_thompson' );
			FlashRot = Owner.GetBoneRotation( 'rifle_muzzle_thompson' );
			ShellLoc = Owner.GetAttachmentTagWorldCoords( 'rifle_chamber' );
			ShellRot = Owner.GetBoneRotation( 'rifle_chamber' );
			if (FireSoundCue == None)
			{
				FireSoundCue = Owner.LoadSound( "W_M3A1.FIRE" );
			}
			break;
	}
	
	if( FlashEmitter != None )
	{
		FlashEmitter.SetLocation( FlashLoc.Origin );
		FlashEmitter.SetRotation( FlashRot );
		FlashEmitter.Flash();
	}
	if( ShellEmitter != None )
	{
		ShellEmitter.TriggerEmitters( ShellLoc.Origin, ShellRot );
	}
	if (FireSoundCue != None)
		Owner.PlayOwnedSoundCue(FireSoundCue, SLOT_Interact,,,,,true);	
}
class AnimNotify_MeleeStrikeNew extends AnimNotify_Scripted;

var() enum ENotifyDesc
{
	Melee_Lunge,
	Melee_Strike,
} StrikeType;

event Notify( Actor Owner )
{
	local gbxPawn WGPawn;

	WGPawn = gbxPawn( Owner );
	if ( WGPawn != None )
	{
		if ( StrikeType == Melee_Lunge )
		{
			WGPawn.DoMeleeLunge();
		}
		else
		{
			WGPawn.CheckMeleeSuccess();
		}
	}
}
class AnimNotify_MortarFireNew extends AnimNotify_Scripted;

event Notify( Actor Owner )
{
	local gbxPawn WGPawn;

	WGPawn = gbxPawn( Owner );
	if ( WGPawn != None )
	{
		WGPawn.MortarFire();
	}
}
class AnimNotify_PlayerBlurEffectNew extends AnimNotify_Scripted;

var() bool	bEnable;

event Notify( Actor Owner )
{
	local	gbxPawn	aPawn;
	
	aPawn = gbxPawn(Owner);
	if ((aPawn != None) && (aPawn.IsA('gbxPlayerPawn')))
	{
		if (bEnable)
		{
			aPawn.BeginTraumaCam();
		}
		else
		{
			aPawn.EndTraumaCam();
		}
	}
}
// This notify is called by first-person player melee animations at the point where the melee strike should do damage.

class AnimNotify_PlayerMeleeStrike extends AnimNotify_Scripted;

event Notify( Actor Owner )
{
	local gbxWeapon TheWeapon;

	TheWeapon = gbxWeapon( Owner );
	if ( TheWeapon != None )
	{
		TheWeapon.MeleeFire(0);
	}
}
class AnimNotify_PlayerStepSound extends AnimNotify_Scripted;

var() int	nSide;
var() bool	bTurn;

event Notify( Actor Owner )
{
	local	gbxPawn	aPawn;
	
	aPawn = gbxPawn(Owner);
	if (aPawn != None)
	{
		if (bTurn)
			aPawn.FootTurnImpact( nSide );
		else
			aPawn.FootStepping( nSide );
	}
}
class AnimNotify_ReturnGrenade extends AnimNotify_Scripted;



event Notify( Actor Owner )
{
	gbxAIController( gbxPawn( Owner ).Controller ).GrenadeTossFromGroundCallBack();
}
class AnimNotify_ReturnGrenadePickup extends AnimNotify_Scripted;



event Notify( Actor Owner )
{
	gbxAIController( gbxPawn( Owner ).Controller ).PickupGrenadeFromGroundCallBack();
}
class AnimNotify_ThrowGrenadeAI extends AnimNotify_Scripted;



event Notify( Actor Owner )
{
//	if( ( Owner.Role<ROLE_Authority ) || (( PlayerController(Pawn( Owner ).Controller) != None) && (PlayerController(Pawn( Owner ).Controller).bBehindView == false)) )
//		return;
	if( Owner.Role<ROLE_Authority )
		return;
//	gbxAIController( gbxPawn( Owner ).Controller ).GrenadeTossCallBack();
//	if (gbxPawn( Owner ).Weapon.FireMode[1] != None )
//	{
//		gbxPawn( Owner ).Weapon.FireMode[1].FireProjectile();
//	}
}
class AnimNotify_UnhideWeapon extends AnimNotify_Scripted;


event Notify( Actor Owner )
{
	if( (Pawn(Owner) != None) && (Pawn(Owner).Weapon != None) && (Pawn(Owner).Weapon.ThirdPersonActor != None) )
	{
		Pawn(Owner).Weapon.ThirdPersonActor.bHidden = false;
	}
}
class BulletListener extends Actor;



var AnimPawn NotifyPawn;


event TraceTouch( Actor Other, vector TouchLocation, vector TouchNormal, vector End, vector Start, vector Extent, int TraceFlags )
{
	if( NotifyPawn != None )
	{
		NotifyPawn.NotifyNearbyTrace( Other, TouchLocation, TouchNormal, End, Start, Extent, TraceFlags );
	}
}

function Destroyed()
{
	Instigator = None;  // prevent references to/in destroyed objects
	NotifyPawn = None;

    super.Destroyed();
}


defaultproperties
{
	bStatic=false
	bNoDelete=false
	bHidden=true

	DrawType=DT_None
	DrawScale=5.0

	bCollideActors=true
	bCollideWorld=false
	bBlockActors=false
	bBlockPlayers=false
	bBlockZeroExtentTraces=false
	bBlockNonZeroExtentTraces=false
	bBlockKarma=false
	bTraceListener=true

	CollisionHeight=600.0
	CollisionRadius=300.0

	RemoteRole=ROLE_None
}
class BulletPassbyProxy extends Actor
	notplaceable
	transient
	poolable(10,0);



defaultproperties
{
	bStatic=false
	bHidden=true
	bCollideActors=false

	Lifespan=2.0

	RemoteRole=ROLE_None
}
// GEARBOX 2004-10-16 JWS created
class CharacterSetupMP extends CharacterSetup;

simulated static function Name GetCharacterHead(int characterType)
{
/*
	switch (characterType)
	{
		case EMPCharacterTypes.SKHartsock:
			return 'Hartsock';

		case EMPCharacterTypes.SKBaker:
			return 'Baker';

		case EMPCharacterTypes.SKCharUSA:
		case EMPCharacterTypes.SKCharUSB:
		case EMPCharacterTypes.SKCharUSC:
			return 'Doe';
	}
*/
	// Multiplayer no longer supports different heads 2005-01-27 JWS
	return '';
}

simulated static function String GetCharacterFacialPackage(int characterType)
{
	// Multiplayer no longer supports facial animation 2005-01-27 JWS
	return "";
}

simulated static function string GetCharacterVoiceType(int characterType,optional bool bIsDemoBuild)
{
	local String voice;

	//log( "CharacterSetupMP::GetCharacterVoiceType() - bIsDemoBuild=" $ bIsDemoBuild, 'RSC' );
	switch (characterType)
	{
	case EMPCharacterTypes.MPPlayer1US:
		if( bIsDemoBuild )
			voice = "gbxCharacters.VoiceTypeHartsock";
		else
			voice = "gbxCharacters.VoiceTypeBaker";
		break;
	
	case EMPCharacterTypes.MPPlayer2US:
		voice = "gbxCharacters.VoiceTypeHartsock";
		break;

	case EMPCharacterTypes.MPCharUSA:
		voice = "gbxCharacters.VoiceTypeMPUSA";
		break;

	case EMPCharacterTypes.MPCharUSB:
		if( bIsDemoBuild )
			voice = "gbxCharacters.VoiceTypeMPUSA";
		else
			voice = "gbxCharacters.VoiceTypeMPUSB";
		break;

	case EMPCharacterTypes.MPCharUSC:
		if( bIsDemoBuild )
			voice = "gbxCharacters.VoiceTypeMPUSA";
		else
			voice = "gbxCharacters.VoiceTypeMPUSC";
		break;

	case EMPCharacterTypes.MPPlayer1DE:		// speaks german
			voice = "gbxCharacters.VoiceTypeMPDEPA";
		break;
	
	case EMPCharacterTypes.MPPlayer2DE:		// speaks german
		if( bIsDemoBuild )
			voice = "gbxCharacters.VoiceTypeMPDEPA";
		else
			voice = "gbxCharacters.VoiceTypeMPDEPB";
		break;

	//case EMPCharacterTypes.MPPlayer1EG:		// speaks english with german accents
	//	voice = "gbxCharacters.VoiceTypeMPEGPA";
	//	break;
	//
	//case EMPCharacterTypes.MPPlayer2EG:		// speaks english with german accents
	//	voice = "gbxCharacters.VoiceTypeMPEGPB";
	//	break;

	case EMPCharacterTypes.MPCharDEA:		// speaks german
			voice = "gbxCharacters.VoiceTypeMPDEA";
		break;

	case EMPCharacterTypes.MPCharDEB:		// speaks german
		if( bIsDemoBuild )
			voice = "gbxCharacters.VoiceTypeMPDEA";
		else
			voice = "gbxCharacters.VoiceTypeMPDEB";
		break;

	case EMPCharacterTypes.MPCharDEC:		// speaks german
		if( bIsDemoBuild )
			voice = "gbxCharacters.VoiceTypeMPDEA";
		else
			voice = "gbxCharacters.VoiceTypeMPDEC";
		break;

	//case EMPCharacterTypes.MPCharEGA:		// speaks english with german accents
	//	voice = "gbxCharacters.VoiceTypeMPEGA";
	//	break;

	//case EMPCharacterTypes.MPCharEGB:		// speaks english with german accents
	//	voice = "gbxCharacters.VoiceTypeMPEGB";
	//	break;

	//case EMPCharacterTypes.MPCharEGC:		// speaks english with german accents
	//	voice = "gbxCharacters.VoiceTypeMPEGC";
	//	break;

	case EMPCharacterTypes.SKHartsock:
		voice = "gbxCharacters.VoiceTypeHartsock";
		break;
	
	case EMPCharacterTypes.SKBaker:
		if( bIsDemoBuild )
			voice = "gbxCharacters.VoiceTypeHartsock";
		else
			voice = "gbxCharacters.VoiceTypeBaker";
		break;

	case EMPCharacterTypes.SKCharUSA:
		voice = "gbxCharacters.VoiceTypeMPUSA";
		break;

	case EMPCharacterTypes.SKCharUSB:
		if( bIsDemoBuild )
			voice = "gbxCharacters.VoiceTypeMPUSA";
		else
			voice = "gbxCharacters.VoiceTypeMPUSB";
		break;

	case EMPCharacterTypes.SKCharUSC:
		if( bIsDemoBuild )
			voice = "gbxCharacters.VoiceTypeMPUSA";
		else
			voice = "gbxCharacters.VoiceTypeMPUSC";
		break;

	case EMPCharacterTypes.SKCharUSD:
		if( bIsDemoBuild )
			voice = "gbxCharacters.VoiceTypeMPUSA";
		else
			voice = "gbxCharacters.VoiceTypeMPUSC";
		break;

	case EMPCharacterTypes.SKHansDE:
		voice = "gbxCharacters.VoiceTypeMPDEPA";	// speaks German
		break;
	
	case EMPCharacterTypes.SKFransDE:
		if( bIsDemoBuild )
			voice = "gbxCharacters.VoiceTypeMPDEPA";	// speaks German
		else
			voice = "gbxCharacters.VoiceTypeMPDEPB";
		break;

	//case EMPCharacterTypes.SKHansEG:
	//	voice = "gbxCharacters.VoiceTypeMPEGPA";	// speaks English with German Accent
	//	break;	
	//
	//case EMPCharacterTypes.SKFransEG:
	//	voice = "gbxCharacters.VoiceTypeMPEGPB";	// speaks English with German Accent
	//	break;

	case EMPCharacterTypes.SKCharDEA:		// speaks German
		voice = "gbxCharacters.VoiceTypeMPDEA";
		break;

	case EMPCharacterTypes.SKCharDEB:		// speaks German
		if( bIsDemoBuild )
			voice = "gbxCharacters.VoiceTypeMPDEA";
		else
			voice = "gbxCharacters.VoiceTypeMPDEB";
		break;

	case EMPCharacterTypes.SKCharDEC:		// speaks German
		if( bIsDemoBuild )
			voice = "gbxCharacters.VoiceTypeMPDEA";
		else
			voice = "gbxCharacters.VoiceTypeMPDEC";
		break;

	case EMPCharacterTypes.SKCharDED:		// speaks German
		if( bIsDemoBuild )
			voice = "gbxCharacters.VoiceTypeMPDEA";
		else
			voice = "gbxCharacters.VoiceTypeMPDEC";
		break;

	//case EMPCharacterTypes.SKCharEGA:		// speaks English with German Accents
	//	voice = "gbxCharacters.VoiceTypeMPEGA";
	//	break;

	//case EMPCharacterTypes.SKCharEGB:		// speaks English with German Accents
	//	voice = "gbxCharacters.VoiceTypeMPEGB";
	//	break;

	//case EMPCharacterTypes.SKCharEGC:		// speaks English with German Accents
	//	voice = "gbxCharacters.VoiceTypeMPEGC";
	//	break;

	//case EMPCharacterTypes.SKCharEGD:		// speaks English with German Accents
	//	voice = "gbxCharacters.VoiceTypeMPEGC";
	//	break;

	default:
		voice = "gbxCharacters.VoiceTypeDefault";
		break;
	}

	log( "CharacterSetupMP::GetCharacterVoiceType() returned " $ voice, 'RSC' );
	return voice;
}

simulated static function float GetCharacterScale(int characterType)
{
	return 1.0f;
}

simulated static function float GetCharacterRank(int characterType)
{
	// MP doesn't support ranks
	local float rank;

	rank = 0.0f;

	return rank;
}

simulated static function string GetCharacterName(int characterType, bool bIsTanker)
{
	// MP doesn't support Character Names
	local string CharacterName;

	CharacterName = "";

	return CharacterName;
}

simulated static function Name GetCharacterFName(int characterType)
{
	// MP doesn't have different names characters for speech
	local Name CharacterFName;

	CharacterFName = '';
	
	return CharacterFName;
}

simulated static function string GetCharacterRankName(int characterType)
{
	// MP doesn't support Rank Names
	local string RankName;

	RankName = "";

	return RankName;
}

simulated static function string GetCharacterPortrait(int characterType, bool bIsTanker)
{
	local string PortraitName;

	switch (characterType)
	{
		case EMPCharacterTypes.MPPlayer1US:
		case EMPCharacterTypes.SKBaker:
			PortraitName = "t_interface_mb.baker_side";
			break;
		case EMPCharacterTypes.MPPlayer2US:
		case EMPCharacterTypes.SKHartsock:
			PortraitName = "t_interface_mb.hartsock_side";
			break;
		case EMPCharacterTypes.MPCharUSA:
		case EMPCharacterTypes.SKCharUSA:
			PortraitName = "t_interface_mb.hooper_side";
			break;
		case EMPCharacterTypes.MPCharUSB:
		case EMPCharacterTypes.SKCharUSB:
			PortraitName = "t_interface_mb.york_side";
			break;
		case EMPCharacterTypes.MPCharUSC:
		case EMPCharacterTypes.SKCharUSC:
			PortraitName = "t_interface_mb.wheaton_side";
			break;
		case EMPCharacterTypes.SKCharUSD:
			PortraitName = "t_interface_mb.doe_side";
			break;
		case EMPCharacterTypes.MPPlayer1DE:
		//case EMPCharacterTypes.MPPlayer1EG:
		case EMPCharacterTypes.SKHansDE:
		//case EMPCharacterTypes.SKHansEG:
			PortraitName = "t_interface_mb.infantry_heinrick";
			break;
		case EMPCharacterTypes.MPPlayer2DE:
		//case EMPCharacterTypes.MPPlayer2EG:
		case EMPCharacterTypes.SKFransDE:
		//case EMPCharacterTypes.SKFransEG:
			PortraitName = "t_interface_mb.infantry_lars";
			break;
		case EMPCharacterTypes.MPCharDEA:
		case EMPCharacterTypes.SKCharDEA:
		//case EMPCharacterTypes.MPCharEGA:
		//case EMPCharacterTypes.SKCharEGA:
			PortraitName = "t_interface_mb.german_infantry_1";
			break;
		case EMPCharacterTypes.MPCharDEB:
		case EMPCharacterTypes.SKCharDEB:
		//case EMPCharacterTypes.MPCharEGB:
		//case EMPCharacterTypes.SKCharEGB:
			PortraitName = "t_interface_mb.german_infantry_2";
			break;
		case EMPCharacterTypes.MPCharDEC:
		case EMPCharacterTypes.SKCharDEC:
		//case EMPCharacterTypes.MPCharEGC:
		//case EMPCharacterTypes.SKCharEGC:
			PortraitName = "t_interface_mb.german_infantry_3";
			break;
		case EMPCharacterTypes.SKCharDED:
		//case EMPCharacterTypes.SKCharEGD:
			PortraitName = "t_interface_mb.infantry_hans";
			break;
		default:
			PortraitName = "t_interface_mb.johnson_side";
			break;
	}

	return PortraitName;
}class CommandRing extends DynamicProjector
	transient;

defaultproperties
{
	bHidden=false
	Texture=None
	bDoNotAlphaFog=true
	bDoNotColorFog=true
	RemoteRole=ROLE_None //SDJ 03/17/2004: The order icon should not be replicated
	FOV=1
	ProjTexture=Texture't_interface_mb.HUD.CommandRing'
	bProjectActor=false
	Rotation=(Roll=0,Yaw=0,Pitch=-16384)
	Physics=PHYS_Rotating
	bFixedRotationDir=true
	RotationRate=(Yaw=4000)
	MaxTraceDistance=512
	bOnlyOwnerSee=true	// PSV: 8/3/2004: Only the player controlling this should see it in the world

	bProjFlag_Shadow=False
	bProjFlag_VehicleShadow=False
	bProjFlag_LevelShadow=False
	bProjFlag_Blood=False
	bProjFlag_Bullet=False
	bProjFlag_Blast=False
	bProjFlag_SAVIcon=False
	bProjFlag_ObjectiveIcon=False
	bProjFlag_CommandRing=True
}//=============================================================================
// Editor-placeable actor denotes the locations of 'corners,'
// around which soldiers can peek.
//
// Author: Neil Johnson, Gearbox Software.
//=============================================================================
class CornerPoint extends NavigationPoint
	native
	placeable;

cpptext
{
	virtual bool ProvidesCoverFrom( const FVector& ThreatLocation, int Posture, APawn* pThreat=NULL );
	virtual bool ProvidesDoubleCoverFrom( const FVector& ThreatLocation, int Posture, APawn* pThreat=NULL );
	void PostEditChange();
}

var (CornerPoint) bool IsLeftCorner;
var Vector VantageVector;		// The location next to this corner from which shots may be taken.

var const float VantageVectHorizOffset;


function PostBeginPlay()
{
	local Rotator TempRot;
	local Vector TempVect;
	
	Super.PostBeginPlay();

	TempRot = Rotation;
	TempRot.Pitch = 0;
	TempRot.Roll = 0;
	
	if ( IsLeftCorner )
	{
		TempRot.Yaw = ( TempRot.Yaw + 16384 ) & 65535;
	}
	else
	{
		TempRot.Yaw = ( TempRot.Yaw - 16384 ) & 65535;
	}
	
	TempVect = Vector( TempRot );
	VantageVector = Location + VantageVectHorizOffset * TempVect;
}

function Vector GetVantageVector()
{
	return VantageVector;
}

// Corner points: in addition to the parent's functionality here,
// consider a direction covered if it is only one cover bit away from 
// the bit that faces the wall (the forward diagonal, in other words)
// and the wall-facing bit provides cover.
//
native function bool ProvidesCoverFrom( Vector ThreatLocation, int Posture );

defaultproperties
{
	Texture=Texture't_interface_mb.debug.S_CornerNode'	
	bCollideWhenPlacing=false

	IsLeftCorner=true
	bDirectional=true
	VantageVectHorizOffset=100.0
}
// ====================================================================
//  Class:  DamageExplosive
// ====================================================================

class DamageExplosive extends gbxDamageExploded;


defaultproperties
{
    DeathString="%k ripped %o full of holes with the %w."
	bArmorStops=false
	GibModifier=+0.4
	LowDetailEffect=None
	LowDetailEmitter=class'gbxBloodEffect'
	LowDetailHeadshotEmitter=class'gbxBloodEffectHeadshot'
	LowDetailLittleEmitter=class'gbxBloodEffectLittle'
	bInstantHit=true
	bFastInstantHit=true
	DamageWeaponName="Explosive"
	PawnDamageEffect=None
	PawnDamageEmitter=class'gbxBloodEffect'
	PawnDamageHeadshotEmitter=class'gbxBloodEffectHeadshot'
	PawnDamageLittleEmitter=class'gbxBloodEffectLittle'
	DamageDesc=2
	DamageThreshold=15
	DamageKick=(x=512,y=0,z=512)
	BloodDecal=class'BloodScorch'

	m_bExplosiveDamage=true
}
// ====================================================================
//  Class:  DamageGrenade
// ====================================================================

class DamageGrenade extends gbxDamageExploded;


defaultproperties
{
    DeathString="%k ripped %o full of holes with the %w."
	bArmorStops=false
	GibModifier=+0.4
	LowDetailEffect=None
	LowDetailEmitter=class'gbxBloodEffect'
	LowDetailHeadshotEmitter=class'gbxBloodEffectHeadshot'
	LowDetailLittleEmitter=class'gbxBloodEffectLittle'
	bInstantHit=true
	bFastInstantHit=true
	DamageWeaponName="Grenade"
	PawnDamageEffect=None
	PawnDamageEmitter=class'gbxBloodEffect'
	PawnDamageHeadshotEmitter=class'gbxBloodEffectHeadshot'
	PawnDamageLittleEmitter=class'gbxBloodEffectLittle'
	DamageDesc=2
	DamageThreshold=15
	DamageKick=(x=512,y=0,z=512)
	BloodDecal=class'BloodScorch'

	m_bDamagesArmor=false
	m_bExplosiveDamage=true
}
// ====================================================================
//  Class:  DamageRunOVer
// ====================================================================

class DamageRunOver extends gbxDamageType;


defaultproperties
{
    DeathString="%o squished %k with the %w."
	bArmorStops=true
	GibModifier=+0.4
	LowDetailEffect=None
	LowDetailEmitter=class'gbxBloodEffect'
	LowDetailHeadshotEmitter=class'gbxBloodEffectHeadshot'
	LowDetailLittleEmitter=class'gbxBloodEffectLittle'
	bInstantHit=true
	bFastInstantHit=true
	DamageWeaponName="Vehicle"
	PawnDamageEffect=None
	PawnDamageEmitter=class'gbxBloodEffect'
	PawnDamageHeadshotEmitter=class'gbxBloodEffectHeadshot'
	PawnDamageLittleEmitter=class'gbxBloodEffectLittle'
	DamageDesc=2
	DamageThreshold=15
	DamageKick=(x=512,y=0,z=512)
	BloodDecal=class'BloodScorch'
}
class ExplosionPhysical extends Actor
	transient
	poolable(0,0);

var() float InitialBlastDuration;
var() float TotalDuration;
var() float MaxRadius;
var() float EaseOutFactor;
var() float WindMaxFlutter;
var() float WindMaxKnockdown;
var() float KnockdownOscillationHz;

// Calculated values.
var   float StartTime;
var	  bool	bUseZoneInfoBlastValuesB;

simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();

	LifeSpan = TotalDuration;	// Ensure the actor isn't destroyed before it's finished with its work.

	StartTime = Level.TimeSeconds;

	bUseZoneInfoBlastValuesB = Region.Zone.bUseBlastB;

	// Tell the zone that the next physical explosion to come along should use the other blast values.
	Region.Zone.bUseBlastB = !Region.Zone.bUseBlastB;

	// TODO check for > 2 objects trying to use the zone blast params at once. Don't do it.

	if( !bUseZoneInfoBlastValuesB )
	{
		Region.Zone.BlastLocationA = Location;
	}
	else
	{
		Region.Zone.BlastLocationB = Location;
	}
}


simulated function Tick( float DeltaTime )
{
	local float TimeSinceStart;
	local float TimeProportion;
	local float BlastTimeProportion;
	local float LerpedTotalTime;
	local float LerpedBlastTime;
	local float TimeSinceInitialBlast;
	local float DurationPostInitialBlast;
	local float CurRadius;
	local float	WindCurFlutter;
	local float	WindCurKnockdown;

	Super.Tick( DeltaTime );

	TimeSinceStart = Level.TimeSeconds - StartTime;

	TimeProportion = TimeSinceStart / TotalDuration;
	BlastTimeProportion = FClamp( TimeSinceStart / InitialBlastDuration, 0.0, 1.0 );

	LerpedTotalTime = Lerp( EaseOutFactor, TimeProportion, 1.0 );			// TODO Maybe a cos-based smoothing would look better?
	LerpedBlastTime = Lerp( EaseOutFactor, BlastTimeProportion, 1.0 );		// TODO Maybe a cos-based smoothing would look better?

    CurRadius			= Lerp( LerpedBlastTime, 0, MaxRadius );			// Blast spreads quickly, over a space InitialBlastDuration seconds.

	WindCurFlutter		= Lerp( LerpedTotalTime, WindMaxFlutter, 0 );		// Flutter begins high and slowly trails off over the total duration.

	TimeSinceInitialBlast = TimeSinceStart - InitialBlastDuration;
	DurationPostInitialBlast = TotalDuration - InitialBlastDuration;

	if( TimeSinceInitialBlast < 0 )
	{
		// Still in the initial blast. Knockdown at the full.
		WindCurKnockdown = WindMaxKnockdown;
	}
	else
	{
		// Knockdown oscillates via cos wave and diminishes in amplitude.
		WindCurKnockdown = Cos( TimeSinceInitialBlast * KnockdownOscillationHz ) * WindMaxKnockdown * ( 1.0 - ( TimeSinceInitialBlast / DurationPostInitialBlast ));
//		Log( StartTime $ " " $ TotalDuration $ " " $ InitialBlastDuration $ " " $ TimeSinceInitialBlast $ " " $ DurationPostInitialBlast $ " " $ WindCurKnockdown $ " " $ ( TimeSinceInitialBlast / DurationPostInitialBlast ) , 'jmw' );
	}

	// TODO knockdown should move faster than flutter?

	if( !bUseZoneInfoBlastValuesB )
	{
		Region.Zone.BlastRadiusA = CurRadius;
		Region.Zone.BlastFlutterFactorA = WindCurFlutter;
		Region.Zone.BlastKnockdownFactorA = WindCurKnockdown;
	}
	else
	{
		Region.Zone.BlastRadiusB = CurRadius;
		Region.Zone.BlastFlutterFactorB = WindCurFlutter;
		Region.Zone.BlastKnockdownFactorB = WindCurKnockdown;
	}
}

simulated function Destroyed()
{
	// Clear out the blast parameters.
	if( !bUseZoneInfoBlastValuesB )
	{
		Region.Zone.BlastRadiusA = 0.0;
		Region.Zone.BlastFlutterFactorA = 0.0;
		Region.Zone.BlastKnockdownFactorA = 0.0;
	}
	else
	{
		Region.Zone.BlastRadiusB = 0.0;
		Region.Zone.BlastFlutterFactorB = 0.0;
		Region.Zone.BlastKnockdownFactorB = 0.0;
	}

	super.Destroyed();
}


defaultproperties
{
	bHidden=true
	bStatic=false
	bNoDelete=false

	InitialBlastDuration=0.2
	TotalDuration=2.0
	MaxRadius = 400.0
	EaseOutFactor = 0.1
	WindMaxFlutter = 10.0
	WindMaxKnockdown = -20.0
	KnockdownOscillationHz=8
}
class ExplosionPhysicalGrenade extends ExplosionPhysical;

defaultproperties
{
}
class FieldPromotionFlow extends Object within gbxPlayerController
	native;
	
var protected gbxPlayerController MyPlayerController;

var private bool bInitialized;
var private bool bInitializedExecution;

native function InitExecution();

function Initialize(gbxPlayerController playerController)
{
	if ( !bInitializedExecution )
	{
		InitExecution();
		bInitializedExecution = true;
	}
	
	MyPlayerController = playerController;
	bInitialized = true;
	
	GotoState('ViewingDeadBody');
}

function Shutdown()
{
	bInitialized = false;
	MyPlayerController = None;
}

function bool IsInitialized()
{
	return bInitialized;
}

function PlayerTick( float DeltaTime )
{
}

exec function FieldPromoteSelect( optional float F )
{
}

exec function FieldPromoteChoose( optional float F )
{
}

function InstantPromote()
{
	ServerSetFieldPromoteAutochoose(true);
	bFieldPromoteAutochoose = true;

    LoadPlayers();
	ServerReStartPlayer();
}

function bool IsViewingDeadBody()
{
	return false;
}

function bool AnyAIGuysRemaining()
{
	local bool rslt;

	if (( LastPlayerUnit != None ) && ( LastPlayerUnit.NumSubUnits <= 0 ))
	{
		rslt = false;
	}
	else
	{
		rslt = true;
	}

	return rslt;
}

state FieldPromotionStep
{
}

state ViewingDeadBody extends FieldPromotionStep
{
	function BeginState()
    {
		log("ViewingDeadBody::BeginState()", 'MP');
    }
    
	function PlayerTick( float DeltaTime )
	{
		Global.PlayerTick( DeltaTime );
	}
	
	exec function FieldPromoteSelect( optional float F )
    {
		Log("ViewingDeadBody::FieldPromoteSelect()", 'MP');

		InstantPromote();
		shutdown();
    }
    
    exec function FieldPromoteChoose( optional float F )
	{
		Log("ViewingDeadBody::FieldPromoteChoose()", 'MP');
		
		if ( AnyAIGuysRemaining() == true )
		{
			ServerViewNextPlayer();
			GotoState('WaitingForNewViewTarget');
		}
	}

	function bool IsViewingDeadBody()
	{
		return true;
	}
}

state WaitingForNewViewTarget extends FieldPromotionStep
{
	function BeginState()
	{
		Log("WaitingForNewViewTarget::BeginState()", 'MP');
	}
	
	function PlayerTick( float DeltaTime )
	{
		Global.PlayerTick( DeltaTime );
		
		// Make sure we still have living AI soldiers, if not, automatically field promote which will cause the player to respawn
		if ( AnyAIGuysRemaining() == false )
		{
			Log("WaitingForNewViewTarget::PlayerTick(): All AI guys are dead -> auto respawn", 'MP');
			InstantPromote();
			shutdown();
		}
		else
		{
			// If we're noew viewing an alive AI soldier, let's go ahead and start tactical view.
			if ( Pawn(ViewTarget) != None && !ViewTarget.IsA('gbxPlayerPawn') && !Pawn(ViewTarget).IsDead() )
			{
				Log("WaitingForNewViewTarget::PlayerTick(): Found new view target", 'MP');
				GotoState('SelectingSoldier');
			}
		}
	}
	
	exec function FieldPromoteSelect( optional float F )
    {
    }
    
    exec function FieldPromoteChoose( optional float F )
	{
	}
}

state SelectingSoldier extends FieldPromotionStep
{
	function BeginState()
	{
		Log("SelectingSoldier::BeginState()", 'MP');
		
		log("SelectingSoldier::BeginState(): Activating oracle.", 'MP');
		ActivateFieldPromotionOracle();
				
		ServerSetFieldPromoteAutochoose(false);
		bFieldPromoteAutochoose = false;
	}
	
	function PlayerTick( float DeltaTime )
	{
		Global.PlayerTick( DeltaTime );
		
		// Make sure we still have living AI soldiers, if not, automatically field promote which will cause the player to respawn
		if ( AnyAIGuysRemaining() == false )
		{
			Log("SelectingSoldier::PlayerTick(): All AI guys are dead -> auto respawn", 'MP');
			GotoState('WaitingForNewPawn');
			InstantPromote();
		}
		else
		{
			// If we're viewing an AI soldier, make sure he's not dead
			if ( Pawn(ViewTarget) != None && !ViewTarget.IsA('gbxPlayerPawn') && Pawn(ViewTarget).IsDead() )
			{
				Log("SelectingSoldier::PlayerTick(): Current view target has died, selecting new one", 'MP');
				FieldPromoteChoose();
			}
			else
			{
				if (ViewTarget != None)
				{
					OracleCam.SetOwnerPlayerController(MyPlayerController);
				}
			}
		}
	}
	
	exec function FieldPromoteSelect( optional float F )
    {
		Log("SelectingSoldier::FieldPromoteSelect()", 'MP');
		
		GotoState('WaitingForNewPawn');

        LoadPlayers();
		ServerReStartPlayer();
    }
    
    exec function FieldPromoteChoose( optional float F )
	{
		Log("SelectingSoldier::FieldPromoteChoose()", 'MP');
		
		ServerViewNextPlayer();
	}
}



simulated state WaitingForNewPawn extends FieldPromotionStep
{
	function BeginState()
	{
		Log("WaitingForNewPawn::BeginState()", 'MP');
	}
	
	function EndState()
	{
		Log("WaitingForNewPawn::EndState()", 'MP');

		if (IsInOracleCamMode())
		{
			OracleCam.AddTarget(Pawn);
			OracleCam.SetOwnerPlayerController(MyPlayerController);
			ActivateFieldPromotionOracle();
		}
		
		Shutdown();
	}
	
	function PlayerTick( float DeltaTime )
	{		
		Global.PlayerTick( DeltaTime );
		
		if (Pawn != None)
		{
			Log("WaitingForNewPawn::PlayerTick(): Now viewing player pawn, shutting down oracle cam.", 'MP');
			GotoState('');
		}
	}
}

defaultproperties
{
	MyPlayerController=None
	bInitialized=false
	bInitializedExecution=false
}

class gbxAIController extends AIController
	abstract
	native;


var ActorLite LastVantagePoint;
var float MaxImpactDistance;

struct native export SeePawnStruct
{
	var Pawn Other;
	var float TimeLastSeen;
};

const SEEPAWNMAX = 12;
var SeePawnStruct SeePawnArray[SEEPAWNMAX];  // list of Pawns who I've seen recently

function PostBeginPlay()
{
	Super.PostBeginPlay();
	InitializeEvents();	
}

// Call this function after Possess().
function StartJob( optional EJobType NewJob );

function bool ApproveFlinchRequest()
{
	// Override me.
	return true;
}

function NotifyTargetOrder(Unit targetUnit) {}
function NotifyTargetOrderRemoved() {}
function NotifyNearbyTrace( Actor Other, vector TouchLocation, vector TouchNormal, vector End, vector Start, vector Extent, int TraceFlags ) {}
function BecomingLeader( Unit ledUnit ) {}
function SetAssignedTarget( Unit newAssignedTarget ) {}
function SetAssignedDestination( Vector newAssignedDestination ) {}
function NewTargetForSpotter( gbxPawn NewTarget ) {}
function BreakOutWholeCrew( optional Pawn InstigatedBy ) {}
function BreakOutJustMe( optional Pawn InstigatedBy ) {}

function bool CanCrewTurret( TurretWeapon TheTurret )
{
	// Override me.
	return true;
}

function GrenadeTossCallBack() {}
function GrenadeTossFromGroundCallBack() {}
function PickupGrenadeFromGroundCallBack() {}

native function InitializeEvents();		// GBX:naj - necessary to register events properly.
native function bool CanSeeOrSuppress( Pawn Other, out Vector SeeLocation, out int bIsHeadShot, out Vector SuppressLocation, out Vector FailLoc, optional int Posture );
native function bool CanSeeOrSuppressFromPoint( Pawn Other, Vector FromLocation, out Vector SeeLocation, out int bIsHeadShot, out Vector SuppressLocation, out Vector FailLoc, optional int Posture );
native function bool HasLineOfSightToNode( ActorLite FromNode, ActorLite ToNode );

function ConsiderPossibleEnemy( Pawn possibleEnemy ) {}

event bool GetLastVantagePoint( out ActorLite VantagePoint )
{
	if ( LastVantagePoint != None )
	{
		VantagePoint = LastVantagePoint;
		return true;
	}
	else
		return false;
}

function CleanUpGrenade( gbxExplosive aGrenade ) {}

function ActorLite GetCoverPoint()
{
	return None;
}

event NavigationPointStolen(ActorLite NavPoint) {}
event VantagePointStolen(ActorLite NavPoint) {}
event CoverPointStolen(ActorLite NavPoint) {}

function NotifyMeleeAnimFinished() {}

function Approaching(Actor Other, Vector OtherMovementDirection) {}

function SetPawnToWatch( Name APawnToWatch );

event bool IsCoveredAtThisNode( ActorLite aNode );

simulated function Unit GetUnit();

simulated function bool GoToDeadGuy( gbxPawn aPawn );

function float GetWeaponReloadRate() { return 1.0; }

function gbxAIController ChangeMind( optional class<gbxAIController> NewMindClass );

function NotifyBeginFiring();
function NotifyStopFiring();
function ReloadTurret();
function NotifyIdleFinished();
function NotifyReloadFinished();
function EnableGrenades( bool bEnabled );
function bool IsFiringFromCover() { return false; }
function DoMeleeLunge();

function bool IsNavigating() { return false; }

function GrenadeHasBeenPlanted(Pawn GrenadePlanter) {}

function NotifyFormationCenterChange();
function NotifyAssaultCommand();

//function SetPlayerAddressingMe( bool bAddressing ) {}

function RespondToPlayerUse() {}
function SetVehicle( gbxSVehicle MyVehicle ) {}  // set the vehicle this pawn is riding in

defaultproperties
{
	MaxImpactDistance=1000.0
}
// ====================================================================
//  Class:  gbxBase.gbxAmmo
//
//  <Enter a description here>
//
// (c) 2001, Epic Games, Inc - All Rights Reserved
// ====================================================================

class gbxAmmo extends Ammunition
		Abstract;




//---------------------------------------------------------
// Variables
//---------------------------------------------------------
var float					WeaponFovKick;			// How much FOVAngle should be adjusted when a shot is fired
var float					WeaponFovKickZoomed;	// How much FOVAngle should be adjusted when a shot is fired when zoomed in
var vector					WeaponKick;				// How much Pitch (Z) and Yaw (X) are applied when a shot is fired.  Negative Values apply
var vector					WeaponKickMin;			// Randomized min Pitch (Z) and Yaw (X) are applied when a shot is fired.  Negative Values apply
var vector					WeaponKickMax;			// Randomized max Pitch (Z) and Yaw (X) are applied when a shot is fired.  Negative Values apply
var vector					WeaponKickZoomed;		// How much Pitch (Z) and Yaw (X) are applied when a shot is fired when zoomed.  Negative Values apply
var vector					WeaponKickZoomedMin;	// Randomized min Pitch (Z) and Yaw (X) are applied when a shot is fired when zoomed.  Negative Values apply
var vector					WeaponKickZoomedMax;	// Randomized max Pitch (Z) and Yaw (X) are applied when a shot is fired when zoomed.  Negative Values apply
var float					KickRecoverRate;		// How fast the kick should move back to center
var float					KickRecoverRateZoomed;	// How fast the kick should move back to center when zoomed
var EWeaponCategory			WeaponCategory;			// GBX:naj - added 5/13/03 - Used with the material-types system to determine what kind of impact to spawn.
var class<gbxWeaponShells>	AmmoShellClass;			// A class for the shell casing for this type of ammo
var class<gbxBulletTracer>	BulletTracerClass;		// A class for the bullet tracers for this type of ammo
var() bool					bUnlimited;				// Unlimited ammo doesn't deplete.
var() bool					bUnlimitedForAI;		// This ammo is unlimited when AI guys use it.
var() bool					bRandomizeWeaponKick;	// WeaponKick and WeaponKickZoomed are randomized slightly (using WeaponKickMin/WeaponKickMax and WeaponKickZoomedMin WeaponKickZoomedMax)

simulated function ApplyKick()
{
	local float diff_x, diff_y, diff_z;
	local vector v_kick;

	if ( gbxPawn(Instigator) != None )
	{
		if (gbxWeapon(Instigator.Weapon).m_fZoomed)
		{
			if (bRandomizeWeaponKick)
			{
				diff_x = WeaponKickZoomedMax.x - WeaponKickZoomedMin.x;
				diff_y = WeaponKickZoomedMax.y - WeaponKickZoomedMin.y;
				diff_z = WeaponKickZoomedMax.z - WeaponKickZoomedMin.z;

				v_kick.x = WeaponKickZoomedMin.x + FRand() * diff_x;
				v_kick.y = WeaponKickZoomedMin.y + FRand() * diff_y;
				v_kick.z = WeaponKickZoomedMin.z + FRand() * diff_z;
			}
			else
			{
				v_kick = WeaponKickZoomed;
			}

			gbxPawn(Instigator).ClientKickView( v_kick, KickRecoverRate, WeaponFovKickZoomed );
		}
		else  // else, not zoomed
		{
			if (bRandomizeWeaponKick)
			{
				diff_x = WeaponKickMax.x - WeaponKickMin.x;
				diff_y = WeaponKickMax.y - WeaponKickMin.y;
				diff_z = WeaponKickMax.z - WeaponKickMin.z;

				v_kick.x = WeaponKickMin.x + FRand() * diff_x;
				v_kick.y = WeaponKickMin.y + FRand() * diff_y;
				v_kick.z = WeaponKickMin.z + FRand() * diff_z;
			}
			else
			{
				v_kick = WeaponKick;
			}

			gbxPawn(Instigator).ClientKickView( v_kick, KickRecoverRate, WeaponFovKick );
		}
	}
}

simulated function bool UseAmmo(int AmountNeeded, optional bool bAmountNeededIsMax)
{
	if ( bUnlimited || ( bUnlimitedForAI && AIController( Instigator.Controller ) != None ))		// TODO safe to ignore bAmountNeededIsMax?
	{
		return true;
	}
	else return Super.UseAmmo( AmountNeeded, bAmountNeededIsMax );
}

function bool HandlePickupQuery( Pickup Item )
{
    local Ammo A;
    local int AdjustedAmount;

    A = Ammo( Item );

    if( A == None )
        return( Super.HandlePickupQuery( Item ) );

    if( AmmoAmount == MaxAmmo )
        return( true );

    AddAmmo( A.AmmoAmount );

	if ( Inventory != None )
	    Inventory.HandlePickupQuery( Item );

    // Only BulletAmmo will announce and SetRespawn
    AdjustedAmount = A.AmmoAmount;
    if( MaxAmmo > default.MaxAmmo ) // ammo affinity
    {
        AdjustedAmount = Ceil(float(AdjustedAmount) * MaxAmmo / default.MaxAmmo);
    }
//	A.AnnouncePickup(Pawn(Owner), AdjustedAmount);
    Item.SetRespawn();

	return( true );
}

defaultproperties
{
	WeaponFovKick=0.0
	WeaponFovKickZoomed=0.0
	WeaponKick=(x=0,y=0,z=0)
	WeaponKickMin=(x=0,y=0,z=0)
	WeaponKickMax=(x=0,y=0,z=0)
	WeaponKickZoomed=(x=0,y=0,z=0)
	WeaponKickZoomedMin=(x=0,y=0,z=0)
	WeaponKickZoomedMax=(x=0,y=0,z=0)
	WeaponCategory=WC_None
	KickRecoverRate = 3.0;
	KickRecoverRateZoomed = 5.0;
	bRandomizeWeaponKick=false

	bUnlimitedForAI=true

	bReplicateInstigator=true
}
class gbxAmmoFromSoldierMessage extends gbxContextUseHUDMessage;


var localized string	PawnRestockMessage1;
var localized string	PawnRestockMessage2;

static function string GetString(
	optional int Switch,
	optional PlayerReplicationInfo RelatedPRI_1,
	optional PlayerReplicationInfo RelatedPRI_2,
	optional Object OptionalObject ) {

	return Default.PawnRestockMessage1$" "$class'CharacterSetupUSA'.Static.GetCharacterName( Switch )$Default.PawnRestockMessage2;
}


defaultproperties
{
	bFadeMessage=True
	bIsSpecial=True
	bIsUnique=True
	Lifetime=-1
	bBeep=True
	FontSize=1
    DrawColor=(R=128,G=128,B=255,A=255)

	bIsConsoleMessage=false
	
	PawnRestockMessage1="%action_use% %icon_use% to receive ammo from"
	PawnRestockMessage2="."

    YPos=240
}
class gbxAmmoReceivedMessage extends LocalMessage;


var localized string	PawnRestockedMessage1;
var localized string	PawnRestockedMessage2;

static function string GetString(
	optional int Switch,
	optional PlayerReplicationInfo RelatedPRI_1,
	optional PlayerReplicationInfo RelatedPRI_2,
	optional Object OptionalObject ) {

	return Default.PawnRestockedMessage1$" "$class'CharacterSetupUSA'.Static.GetCharacterName( Switch )$Default.PawnRestockedMessage2;
}

static simulated function ClientReceive( 
	PlayerController P,
	optional int Switch,
	optional PlayerReplicationInfo RelatedPRI_1, 
	optional PlayerReplicationInfo RelatedPRI_2,
	optional Object OptionalObject
	)
{
	// Need a small tweak to the base class functionality - we want to generate the message string based on the player that will get the message.
	// So this is a copy of that functionality, modified accordingly. 2004-06-17 JWS
	local string msg;

	msg = Static.GetString( Switch, RelatedPRI_1, RelatedPRI_2, OptionalObject );

	if ( P.myHud != None )
	P.myHUD.LocalizedMessage( Default.Class, Switch, RelatedPRI_1, RelatedPRI_2, OptionalObject, msg );

    if ( Default.bIsConsoleMessage && (P.Player != None) && (P.Player.Console != None) )
		P.Player.InteractionMaster.Process_Message( msg, 6.0, P.Player.LocalInteractions);
}

defaultproperties
{
	bFadeMessage=True
	bIsSpecial=True
	bIsUnique=True
	Lifetime=3
	bBeep=True
	FontSize=1
    DrawColor=(R=128,G=128,B=255,A=255)

	bIsConsoleMessage=false
	
	PawnRestockedMessage1="You have received ammo from"
	PawnRestockedMessage2="."

    YPos=240
}
//=============================================================================
//	gbxAnimal - base class for animated animals
//	Created by: Ryan Conlon
//=============================================================================
class gbxAnimal extends AnimPawn;

const QUEUE_DEATH_PRIORITY	= 9999;
const QUEUE_HIT_PRIORITY = 100;
const QUEUE_FLINCH_PRIORITY = 95;
const QUEUE_IDLE_PRIORITY	= 90;

var array<name>		IdleAnimList;
var string			IdleSound;
var Cue				IdleSoundCue;
var array<name>		FlinchAnimList;
var string			FlinchSound;
var Cue				FlinchSoundCue;
var array<name>		HitAnimList;
var string			HitSound;
var Cue				HitSoundCue;
var array<name>		DeathAnimList;
var array<name>		DeathIdleAnimList;
var string			DeathSound;
var Cue				DeathSoundCue;

var bool bIsAnimating;

simulated function PreBeginPlay()
{	
	Super.PreBeginPlay();
}

simulated function BeginPlay()
{
	Super.BeginPlay();
}

simulated function Destroyed()
{
	Super.Destroyed();
}

simulated event bool TargetFriendly( Vector aHitLoc, Pawn SourcePawn, bool bfiring )
{
	// anyone can shoot me
	return false;
}

simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();
}

function PlayIdleAnim( optional int idx )
{
}

function PlayIdleSound()
{
}

function PlayFlinchAnim( optional int idx )
{
}

function PlayFlinchSound()
{
}

function PlayHitAnim( optional int idx )
{
}

function PlayHitSound()
{
}

function PlayDeathAnim( optional int idx )
{
}

function PlayDeathIdleAnim( optional int idx )
{
}

function PlayDeathSound()
{
}

function TakeDamage( int Damage, Pawn instigatedBy, Vector hitlocation,
							Vector momentum, class<DamageType> damageType, optional name HitBoxName )
{
	Super.TakeDamage( Damage, instigatedBy, hitlocation, momentum, damageType, HitBoxName );
}

function Tick( float Delta )
{
	Super.Tick( Delta );
}

defaultproperties
{
	DrawType=DT_Mesh
	Physics=PHYS_None

	MenuName="gbxAnimal"
	
	Health=100
	CollisionHeight=100.0
	CollisionRadius=100.0

	PawnTeam=Team_None

	IdleAnimList[0]=''
	FlinchAnimList[0]=''
	HitAnimList[0]=''
	DeathAnimList[0]=''
	DeathIdleAnimList[0]=''

	IdleSound=""
	FlinchSound=""
	HitSound=""
	DeathSound=""

	bIsAnimating=false
}//=============================================================================
// gbxBaseFireTeamSpawnController: Controls the spawning of player fire teams.
//=============================================================================
class gbxBaseFireTeamSpawnController extends Trigger;

var() ETeamIdentifier PlayerTeam;

// Trigger event to spawn characters.
function TriggerTeamForMemoryReport();
function Name GetAppropriateFireTeamName(EUnitType UnitType);

function Trigger(Actor Other, Pawn EventInstigator)
{	
	local int maxFireteams;
	local PlayerController PC;

	PC = PlayerController(EventInstigator.Controller);

	// PSV: 6/17/2004 Added support for 1v2 games
	maxFireteams = GetMaxFireteamsForPlayer(PC);

	Log(self$ " gbxBaseFireTeamSpawnController::Trigger() maxFireteams: "$maxFireteams, 'MP');

	if ( maxFireteams == 1 )
	{		
		// Spawn a single fire team for this player.
		// Make sure we spawn the fire team that matches the player's unit type (Base/Assault)
		if ( EventInstigator.Controller.PlayerReplicationInfo.TeamID == 0 )
		{
			Log(self$ " gbxBaseFireTeamSpawnController::Trigger() Spawning a single assault fire team", 'MP');
			TriggerAssaultTeam(PC);
		}
		else
		{
			Log(self$ " gbxBaseFireTeamSpawnController::Trigger() Spawning a single base fire team", 'MP');
			TriggerBaseOfFireTeam(PC);
		}
	}
	else
	{
		//Spawn two fire teams for this player.		
		Log(self$ " gbxBaseFireTeamSpawnController::Trigger() Spawning two fire teams", 'MP');
		TriggerAssaultTeam(PC);
		TriggerBaseOfFireTeam(PC);
	}
}

function TriggerTeam(name fireTeam, PlayerController PC)
{	
	Log(self$ " gbxBaseFireTeamSpawnController::TriggerTeam() fireTeamName: "$fireTeam$ " PC: "$PC$ " PC.PlayerReplicationInfo.NumLives: "$PC.PlayerReplicationInfo.NumLives, 'MP');
	
	if (fireTeam != 'None' && PC.PlayerReplicationInfo.NumLives > 0)
	{
		TriggerEvent(fireTeam, self, None);

		// Lame hack relying on the fact that this is None until the first spawn completes (See GameInfo.uc) 2005-01-19 JWS
		if (PC.PreviousPawnClass != None)
		{
			PC.PlayerReplicationInfo.NumLives -= 1;

			if ( PC.PlayerReplicationInfo.NumLives <= 0 )
			{	
				PC.PlayerReplicationInfo.bOutofLives = true;
			}	
		}
	}
}

function TriggerAssaultTeam(PlayerController PC)
{
	local Name FireTeamName;

	Log(self$ " gbxBaseFireTeamSpawnController::TriggerAssaultTeam() PC: "$PC, 'MP');

	FireTeamName = GetAppropriateFireTeamName(UnitType_Assault);
	TriggerTeam(FireTeamName, PC);
}

function TriggerBaseOfFireTeam(PlayerController PC)
{
	local Name FireTeamName;

	Log(self$ " gbxBaseFireTeamSpawnController::TriggerBaseOfFireTeam() PC: "$PC, 'MP');

	FireTeamName = GetAppropriateFireTeamName(UnitType_Base);
	TriggerTeam(FireTeamName, PC);
}

function TriggerTeamByUnitType( int iUnitType, PlayerController PC )
{
	//Log( self$ " gbxBaseFireTeamSpawnController::TriggerTeamByUnitType()", 'PSV');

	if ( iUnitType == 0 )
	{
		TriggerAssaultTeam(PC);
	}
	else
	{
		TriggerBaseOfFireTeam(PC);
	}

	// Make sure the fireteam that just spawned in is told to fall out at their location
	//Log( self$ " gbxBaseFireTeamSpawnController::TriggerTeamByUnitType() Telling reinforcements to fallout", 'PSV');
	//PC.OrderFallOut( false, true );
}

function int GetMaxFireteamsForPlayer(PlayerController PC)
{
	local Name AssaultName, FireName;
	local int maxFireteams;

	assert(PlayerTeam == ETeamIdentifier(PC.PlayerReplicationInfo.Team.TeamIndex));

	maxFireteams = 0;

	AssaultName = GetAppropriateFireTeamName(UnitType_Assault);
	FireName = GetAppropriateFireTeamName(UnitType_Base);

	if (AssaultName != '')
	{
		maxFireteams++;
	}

	if (FireName != '')
	{
		maxFireteams++;
	}

	//Log(self $ " gbxBaseFireTeamSpawnController::GetMaxFireteamsForPlayer() PC = " $ PC $ " AssaultName = " $ AssaultName $ " FireName = " $ FireName $ " maxFireteams = " $ maxFireteams, 'JWS');

	return maxFireteams;
}

defaultproperties
{
	RemoteRole=ROLE_None
}
// GEARBOX 2005-02-08 JWS created
//
// this is the ultimate base of all victory conditions in the map; it exists to solve package dependency problems

class gbxBaseVictoryCondition extends Info
	abstract placeable
	native;

simulated function PostBeginPlay()
{
	local PlayerController PC;

	Super.PostBeginPlay();

	foreach DynamicActors( class'PlayerController', PC )
	{
		if( gbxHUD( PC.myHUD ) != None )
		{
			gbxHUD( PC.myHUD ).RegisterVictoryCondition( self );
		}
	}
}

simulated function Destroyed()
{
	local PlayerController PC;

	foreach DynamicActors( class'PlayerController', PC )
	{
		if( gbxHUD( PC.myHUD ) != None )
		{
			gbxHUD( PC.myHUD ).UnRegisterVictoryCondition( self );
		}
	}

	Super.Destroyed();
}

// PSV: 5/11/2004 Allow each victory condition to draw something to the hud if needed
simulated function DrawGBXHud(canvas Canvas, gbxHud Hud, FontInfo Fonts, int nPass);
// ====================================================================
//  Class:  WarfareGame.Beacons
//
//  <Enter a description here>
//
// (c) 2001, Epic Games, Inc - All Rights Reserved
// ====================================================================

class gbxBeacons extends Trigger
	abstract
	native;


var()	bool				m_bTouchActivate;	// Turn off the beacon and move to the next beacon, if one is availble, when touched.
var()	Color				m_MarkerColor;
var()	Material			Icon;				// 32x32 material to display
var()	bool				bEnabled;			// Is this beacon active
var()	string				MyInWorldIconClass;	// Class name for the InWorldIcon
var()	localized string	TitleString;		// String displayed when browsed in the Oracle camera.
var()	ETeamIdentifier		Team;				// Which team owns this beacon
var()   localized string	CompassStrings[2];	// One character label for beacons on the compass for MP objectives.
var()   Material			m_ObjectiveImage;	// The image that will be displayed in the objective list inspector in tactical view.
var()	array<name>			m_WaypointListTag;	// List of waypoint tags along the way to this main objective
var		array<Actor>		m_WaypointList;		// List of waypoints along the way to this main objective

var		bool		bDrawDistance;		// Should we display the distance
var		bool		bOptional;			// Should this be displayed all the time
var		bool		bDrawReservoirTip;	// Should draw the tip on the objective arrow

var()	bool		bNotInSAView;		// Don't show this objective beacon in the situational awareness view
var()	bool		bNoDirectionArrow;	// Don't show an arrow toward this objective beacon on the hud compass
var()	bool		bNoDistanceArc;		// Don't show a distance arc to this objective beacon on the hud compass

var		float		VisibleTime;		// If Optional, how long to display them for
var		float		Alpha;				// How transparent are they?
var		InWorldObjectiveIcon	MyIcon;	// An InWorldObjectiveIcon for this beacon.  Created and destroyed as necessary
var     int         CompassStringIndex;	

var	Canvas.CanvasIcon		CustomTexture; // Will use a custom image for the bar in the Oracle camera.


native simulated function Actor FindClosestWaypoint( Pawn aPlayerPawn );
// GEARBOX - These 3 PlayerController parametric functions are needed for multiplayer beacons
// to have correct behavior in splitscreen. 2004-05-31 JWS
native simulated function bool VisibleToPlayer( PlayerController PC );
native simulated function vector GetLocationForPlayer( PlayerController PC );
native simulated function Color GetMarkerColorForPlayer( PlayerController PC );

cpptext
{
	virtual AActor* FindClosestWaypoint( APawn *aPlayerPawn );
	virtual UBOOL VisibleToPlayer( APlayerController *PC );
	virtual FVector GetLocationForPlayer( APlayerController* PC );
	virtual FColor GetMarkerColorForPlayer( APlayerController* PC );
}


replication
{
	reliable if (bNetDirty && Role==ROLE_Authority)
		Team, bEnabled, bNotInSAView, bNoDirectionArrow, bNoDistanceArc;
	reliable if (bNetInitial && Role == ROLE_Authority)
		m_MarkerColor, TitleString, CompassStringIndex, bDrawReservoirTip;
}

simulated event Destroyed()
{
	local Controller C;
	local PlayerController PC;
	local gbxHUD myHUD;

	// remove this inspector from all HUDs (could be split screen on Xbox)...
	for ( C=Level.ControllerList; C!=None; C=C.NextController )
	{
		PC = PlayerController(C);
		if (PC != None)
		{
			myHUD = gbxHUD(PC.myHUD);

			if (myHUD != None)
			{
				MyHUD.RemoveInspector(self);
			}
		}
	}
}

simulated function DrawIcon(Canvas C, gbxHud H, float Scale, float X, float Y);

simulated function DrawBeacon(pawn Who, Canvas C, gbxHud H,  float X, float Y)
{
	local float xl,yl,dist, RangeToTarget, DistanceScale;
	local string s;

	RangeToTarget = VSize(Location - Who.Location);
	DistanceScale = (640 / RangeToTarget) * 85 / PlayerController(Who.Controller).FOVAngle;

	DistanceScale=fClamp(DistanceScale,0.25,1);
	DrawIcon(C,H,DistanceScale,X,Y);

	if (bDrawDistance)
	{
		Dist = (Vsize(Location - Who.Location) / 2) * 0.0254;
		C.Font = Font'Engine.DefaultFont';
		s = ""$int(Dist)$"m";
		C.Strlen(s,xl,yl);
		C.SetPos(x-(xl/2),y+20);
		C.SetDrawColor(255,255,0);
		C.DrawText(s,true);
	}
}

simulated function String GetHumanReadableName()
{
	return Level.S_Localize("TitleString", , ""$Name);
//	if ( TitleString == "" )
//		return Super.GetHumanReadableName();
//	return TitleString;
}

function Trigger(actor Other, pawn EventInstigator)
{
	local PlayerController		humanPlayer;
	local int					i;

	bEnabled = !bEnabled;
	if (bEnabled)
	{
		for( humanPlayer = Level.PlayerControllerList; humanPlayer != None; humanPlayer = humanPlayer.nextPlayerController )
		{
			if (humanPlayer != None)
			{
				if (Viewport(humanPlayer.player) == None)
				{
					continue;
				}
				for (i = 0; i < gbxHUD(humanPlayer.MyHud).MAX_OBJECTIVE_BEACONS; i++)
					if (gbxHUD(humanPlayer.MyHud).m_ObjectiveBeacons[i] == None)
					{
						gbxHUD(humanPlayer.MyHud).m_ObjectiveBeacons[i] = self;
						break;
					}
			}
		}
	}
	super.Trigger(Other,EventInstigator);
}

function CreateMyInWorldIcon()
{
	local class<InWorldObjectiveIcon>	InWorldIconClass;

	//Log(self $ " gbxBeacons()::CreateMyInWorldIcon() begin", 'BeaconsIcons');

	if( MyIcon != None && MyIcon.bDeleteMe )
	{
		MyIcon = None;

		//Log(self $ " gbxBeacons()::CreateMyInWorldIcon() set MyIcon to None", 'BeaconsIcons');
	}

	if( MyIcon == None )
	{
		InWorldIconClass = class<InWorldObjectiveIcon>( DynamicLoadObject( MyInWorldIconClass, class'Class' ));
		MyIcon = Spawn( InWorldIconClass );
		MyIcon.SetBase( self );
		MyIcon.SetBeacon( self );

		//Log(self $ " gbxBeacons()::CreateMyInWorldIcon() spawned new icon", 'BeaconsIcons');
	}

	//Log(self $ " gbxBeacons()::CreateMyInWorldIcon() end", 'BeaconsIcons');
}

function Tick( float DeltaTime )
{
	if( Level.Game.bOracleCamActive && bEnabled )
	{
		CreateMyInWorldIcon();
		MyIcon.Show();
	}
	else if( MyIcon != None )
	{
		if( MyIcon.bDeleteMe )
			MyIcon = None;
		else
			MyIcon.HideAndDestroy();
	}
}

simulated function MakeVisible()	// Make it visible for a bit
{
	GotoState('VisibleForABit');
}

state VisibleForABit
{

	simulated event Tick(float Delta)
	{
		if (VisibleTime>0)
		Alpha -= (255*VisibleTime) * Delta;
	}

	simulated event Timer()
	{
		bEnabled = false;
		Gotostate('');
	}


	simulated function BeginState()
	{
		//Log(self $ " state VisibleForABit happening", 'BeaconsIcons');
		Alpha=1;
		bEnabled = true;
		SetTimer(VisibleTime,false);
	}

}


//=============================================================================
// Trigger logic.

//
// See whether the other actor is relevant to this trigger.
//
function bool IsRelevant( actor Other )
{
	if( !bInitiallyActive )
		return false;
	switch( TriggerType )
	{
	case TT_HumanPlayerProximity:
			return (Pawn(Other) != None) && Pawn(Other).IsHumanControlled();
		case TT_PlayerProximity:
			return (Pawn(Other) != None) && (Pawn(Other).IsPlayerPawn() || Pawn(Other).WasPlayerPawn());
		case TT_PawnProximity:
			return (Pawn(Other) != None) && Pawn(Other).CanTrigger(self);
		case TT_ClassProximity:
			return ClassIsChildOf(Other.Class, ClassProximityType);
		case TT_AnyProximity:
			return true;
		case TT_Shoot:
			return ( (Projectile(Other) != None) && (Projectile(Other).Damage >= DamageThreshold) );
	}
}


//
// Called when something touches the trigger.
//
function Touch( actor Other )
{
	if (m_bTouchActivate && IsRelevant( Other ))
	{
		bEnabled = false;
		Super.Touch( Other );
	}
}


function SetStatus( bool bEnabledIn )
{
	local PlayerController	humanPlayer;
	local int				i;

	bEnabled = bEnabledIn;

	humanPlayer = Level.GetLocalPlayerController();

	if (humanPlayer != None)
	{
		for (i = 0; i < gbxHUD(humanPlayer.MyHud).MAX_OBJECTIVE_BEACONS; i++)
			if (bEnabled)
				if (gbxHUD(humanPlayer.MyHud).m_ObjectiveBeacons[i] == None)
				{
					gbxHUD(humanPlayer.MyHud).m_ObjectiveBeacons[i] = self;
					break;
				}
			else
				if (gbxHUD(humanPlayer.MyHud).m_ObjectiveBeacons[i] == self)
				{
					gbxHUD(humanPlayer.MyHud).m_ObjectiveBeacons[i] = None;
					break;
				}
	}
}

// This code is here so that the client can get the beacons reliably. It works in combination with the hud's ability
// to add beacons to itself to ensure that every beacon is on every hud, no matter what order they arrived from the network. 2004-06-01 JWS
simulated function PostBeginPlay()
{
	local int i, count;
	local PlayerController humanPlayer;
	local gbxHUD hud;

	Super.PostBeginPlay();

	// This is the correct place to do the waypoint Initialization for two reasons. Previously, it was done in WargameHUD.
	//
	// Reason 1:
	// That doesn't work because there is no guarantee that the beacons will arrive on the client before
	// the HUD does. Since some beacons could arrive after the HUD, those beacons would never have the
	// waypoint list initialized. Since this is done in a simulated function, and the waypoint list is not
	// replicated, it requires that all waypoint Actors must be on the client already when this is called.
	// That means the waypoints will not work in multiplayer if they refer to any Actor that is replicated,
	// rather than one that already exists on the client.
	//
	// Reason 2:
	// Besides that, it makes more sense for the beacon itself to initialize the waypoint list anyways. 2004-10-20 JWS
	InitializeWaypointList();

	Log(self $ " gbxBeacons::PostBeginPlay() called", 'JWS');

	for( humanPlayer = Level.PlayerControllerList; humanPlayer != None; humanPlayer = humanPlayer.nextPlayerController )
	{
		if ( Viewport(humanPlayer.Player) != None )
		{
			hud = gbxHUD(humanPlayer.MyHud);

			if (hud != None)
			{
				count = ArrayCount(hud.m_ObjectiveBeacons);

				for (i = 0; i < count; i++)
				{
					if (hud.m_ObjectiveBeacons[i] == None)
					{
						log (self$" Added to Objective List in gbxBeacon");
						hud.m_ObjectiveBeacons[i] = self;
						break;
					}
				}
			}
		}
	}
}

simulated function InitializeWaypointList()
{
	local		int		i;
	local		Actor	aWaypoint;
	local		bool	fFound;
	
	for (i = 0; i < m_WaypointListTag.Length; i++)
	{
		fFound = false;
		ForEach DynamicActors(class'Actor', aWaypoint, m_WaypointListTag[i])
		{
			m_WaypointList[i] = aWaypoint;
			fFound = true;
			break;
		}
		
		if (!fFound)
		{
			log("Error: Waypoint "$m_WaypointListTag[i]$" not found for objective "$tag$".");
		}
	}
}


defaultproperties
{
	bStatic=false
	bAlwaysRelevant=true
	RemoteRole=ROLE_SimulatedProxy
	bEnabled=true
	Alpha=1
	m_bTouchActivate=false
	Team = TEAM_None

    SoundVolume=0
    CollisionRadius=+00040.000000
    CollisionHeight=+00040.000000
    bCollideActors=True
	Texture=Texture'Engine.S_Keypoint'

	m_MarkerColor=(R=146,G=141,B=126,A=175)

	MyInWorldIconClass="gbxBase.InWorldObjectiveIcon"
	CompassStrings(0) = "A"
	CompassStrings(1) = "B"
	bDrawReservoirTip = false

	bSkipActorPropertyReplication=true
	bOnlyDirtyReplication=true
}
// This class was factored out of gbxWeapon to make the clients work in MP 2004-09-07 JWS
class gbxBreatheProfile extends Actor
	abstract;

var Range BreathePitchAdjustRate;		// fatigue speeds up  breathing motion (Min @ 0 fatigue)
var Range BreatheYawAdjustRate;			// fatigue speeds up horizontal motion (Min @ 0 fatigue)
var Range BreatheAttenAccel;			// fatigue accelerates inhale/exhale start motion (Max @ 0 fatigue)
var Range BreatheAttenDecel;			// fatigue decelerates inhale/exhale more abruptly (Max @ 0 fatigue)
var Range BreatheYawLimit;				// fatigue increases horizontal motion range (Min @ 0 fatigue)

defaultproperties
{
	BreathePitchAdjustRate=(Min=0,Max=0)
	BreatheYawAdjustRate=(Min=0,Max=0)
	BreatheYawLimit=(Min=0,Max=0)
	BreatheAttenAccel=(Min=0,Max=0)
	BreatheAttenDecel=(Min=0,Max=0)
}//=============================================================================
// Author: Stephen Palmer, Gearbox Software.
//=============================================================================
class gbxBulletImpactDecal extends Projector
	transient
	native
	poolable(0,20);

cpptext
{
	void RefreshImpactDecal( AActor* HitActor, UMaterial* PTexture, const FVector& NewLoc, FRotator& NewRot );
}

var() float Lifetime;
var() bool  RandomOrient;
var() float	BaseScale;
var config bool  bDecalsEnabled;

var bool bIsAttached;

simulated function PostBeginPlay()
{
	if ( !bDecalsEnabled || Level.NetMode == NM_DedicatedServer )
    {
        Destroy();
        return;
    }
}

function DetachProjector( optional bool Force )
{
	bIsAttached = false;
	Super.DetachProjector( Force );
}

function AttachProjector(optional Actor AttachActor)
{
	bIsAttached = true;
	Super.AttachProjector(AttachActor);
}

defaultproperties
{
	BlendEquation=blendequation_Add
	BlendSrcFunction=blend_DstColor
	BlendDstFunction=blend_SrcColor
	bDoNotColorFog=false
	bDoNotAlphaFog=false
	bOverrideFogColor=true
	TransparentFactor=(R=0,G=0,B=0,A=255)
	TransparentColor=(R=128,G=128,B=128,A=255)
	OverriddenFogColor=(R=128,G=128,B=128,A=255)
	
	RemoteRole=ROLE_None
	FOV=1

	MaxTraceDistance=8
	bProjectBSP=true
	bProjectTerrain=true
	bProjectStaticMesh=true
	bProjectActor=false
	
	bClipBSP=true
	bClipStaticMesh=True
	bClipStaticMeshTris=True
	
	bStatic=false
	bNoDelete=false

    RandomOrient=true
    bDecalsEnabled=true

	BaseScale = 0.2f

	bProjFlag_Shadow=False
	bProjFlag_VehicleShadow=False
	bProjFlag_LevelShadow=False
	bProjFlag_Blood=False
	bProjFlag_Bullet=True
	bProjFlag_Blast=False
	bProjFlag_SAVIcon=False
	bProjFlag_ObjectiveIcon=False
	bProjFlag_CommandRing=False
}
class gbxChopperCraft extends gbxSVehicle
	abstract
	native
	nativereplication;

cpptext
{
	INT* GetOptimizedRepList(BYTE* Recent, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel);

#ifdef WITH_KARMA
	// Actor interface.
	virtual UBOOL Tick(FLOAT DeltaTime, enum ELevelTick TickType);
	virtual void PostNetReceive();

	// SVehicle interface.
	virtual void UpdateVehicle(FLOAT DeltaTime);

	// SHover interface.
	virtual void PackState();
#endif
}

var()	float				UprightStiffness;
var()	float				UprightDamping;

var()	float				MaxThrustForce;
var()	float				LongDamping;

var()	float				MaxStrafeForce;
var()	float				LatDamping;

var()	float				MaxRiseForce;
var()	float				UpDamping;

var()	float				TurnTorqueFactor;
var()	float				TurnTorqueMax;
var()	float				TurnDamping;
var()	float				MaxYawRate;

var()	float				PitchTorqueFactor;
var()	float				PitchTorqueMax;
var()	float				PitchDamping;

var()	float				RollTorqueTurnFactor;
var()	float				RollTorqueStrafeFactor;
var()	float				RollTorqueMax;
var()	float				RollDamping;

var()	float				StopThreshold;

var()   float               MaxRandForce;
var()   float               RandForceInterval;

// Internal
var		float				CopterMPH;

var		float				TargetHeading;
var		float				TargetPitch;
var     bool                bHeadingInitialized;

var		float				OutputThrust;
var		float				OutputStrafe;
var		float				OutputRise;

var     vector              RandForce;
var     vector              RandTorque;
var     float               AccumulatedTime;

// Replicated
struct native CopterState
{
	var vector				ChassisPosition;
	var Quat				ChassisQuaternion;
	var vector				ChassisLinVel;
	var vector				ChassisAngVel;

	var byte				ServerThrust;
	var	byte				ServerStrafe;
	var	byte				ServerRise;
	var int                 ServerViewPitch;
	var int                 ServerViewYaw;
};

var		CopterState			CopState, OldCopState;
var		KRigidBodyState		ChassisState;
var		bool				bNewCopterState;

replication
{
	reliable if (bNetDirty && Role == ROLE_Authority)
		CopState;
}

simulated event bool KUpdateState(out KRigidBodyState newState)
{
	// This should never get called on the server - but just in case!
	if(Role == ROLE_Authority || !bNewCopterState)
		return false;

	newState = ChassisState;
	bNewCopterState = false;

	return true;
	//return false;
}

simulated event SVehicleUpdateParams()
{
	Super.SVehicleUpdateParams();

	KSetStayUprightParams( UprightStiffness, UprightDamping );
}

simulated function SpecialCalcFirstPersonView(PlayerController PC, out actor ViewActor, out vector CameraLocation, out rotator CameraRotation )
{
	ViewActor = self;

	CameraLocation = Location + (FPCamPos >> Rotation);
}

defaultproperties
{
	bSpecialHUD=True

	bCanStrafe=true
	bCanFly=true
	bZeroPCRotOnEntry=False
	bFollowLookDir=true
	GroundSpeed=+1200.0
	bCanBeBaseForPawns=false
	bPCRelativeFPRotation=false
}
class gbxContextUseHUDMessage extends LocalMessage;


var localized string	DoorUseMessage;
var localized string	TalkToCharacterMessage;
var localized string	GammonBombMessage;
var localized string	TNTMessage;
var localized string	ReadSignMessage;
var localized string	UseMG42Message;
var localized string	UseBrowningMessage;
var	localized string	UseColt45Message;
var	localized string	UsePak36Message;
var localized string	PickupItemMessage;
var localized string	UseTankMachineGunMessage;
var localized string	RestockWeapons;
var localized string	RestockUsable;
var localized string	PlantExplosive;
var localized string    DisarmExplosive;
var localized string    RearmExplosive;
var localized string	TankGrenadeMessage;
var localized string	PlungerMessage;
var localized string	UseFlareCrateMessage;
var localized string	UseReinforcementMessage;

static function string GetString(
	optional int Switch,
	optional PlayerReplicationInfo RelatedPRI_1,
	optional PlayerReplicationInfo RelatedPRI_2,
	optional Object OptionalObject ) {

	local EContextUseType UseSwitch;
	local gbxMessageStrings	aMsg;
	
	UseSwitch = EContextUseType( Switch );
	aMsg = gbxMessageStrings( OptionalObject );

	switch( UseSwitch )
	{
		case DoorUse:
			return Default.DoorUseMessage;
			break;
		case TalkToCharacterUse:
			return Default.TalkToCharacterMessage;
			break;
		case GammonBomb:
			return Default.GammonBombMessage;
			break;
		case TNT:
			return Default.TNTMessage;
			break;
		case ReadSign:
			return Default.ReadSignMessage;
			break;
		case UseMG42:
			return Default.UseMG42Message;
			break;
		case UseBrowning:
			return Default.UseBrowningMessage;
			break;
		case UseColt45:
			return Default.UseColt45Message;
			break;
		case PickupItem:
			return Default.PickupItemMessage;
			break;
		case UseTankMachineGun:
			return Default.UseTankMachineGunMessage;
			break;
		case UsePak36:
			return Default.UsePak36Message;
			break;
		case RestockWeapons:
			return Default.RestockWeapons;
			break;
		case PlantExplosive:
			return Default.PlantExplosive;
			break;
		case DisarmExplosive:
			return Default.DisarmExplosive;
			break;
		case RearmExplosive:
			return Default.RearmExplosive;
			break;
		case UseTankGrenade:
			return Default.TankGrenadeMessage;
			break;
		case RestockUsable:
			return Default.RestockUsable;
			break;
		case UsePlunger:
			return Default.PlungerMessage;
			break;
		case UseFlareCrate:
			return Default.UseFlareCrateMessage;
			break;
		case UseReinforcement:
			return Default.UseReinforcementMessage;
			break;
	}
}


defaultproperties
{
	bFadeMessage=True
	bIsSpecial=True
	bIsUnique=True
	Lifetime=-1
	bBeep=True
	FontSize=1
    DrawColor=(R=128,G=128,B=255,A=255)

	bIsConsoleMessage=false
	
	DoorUseMessage="%action_use% %icon_use% to Open door."
	TalkToCharacterMessage="%action_use% %icon_use% to Talk."
	GammonBombMessage="%action_use% %icon_use% to plant a Gammon bomb."
	TNTMessage="%action_use% %icon_use% to plant a satchel charge."
	ReadSignMessage="%action_use% %icon_use% to Read the sign."
	UseMG42Message="%action_use% %icon_use% to Use the MG42."
	UseBrowningMessage="%action_use% %icon_use% to Use the Browning MG."
	UseColt45Message="%action_use% %icon_use% to Use the the .45."
	UsePak36Message="%action_use% %icon_use% to Use the the Pak 36."
	PickupItemMessage="%action_use% %icon_use% to pickup item."
	UseTankMachineGunMessage="%action_use% %icon_use% to Use the Tank Machine Gun."
	RestockWeapons="%action_use% %icon_use% to Restock Your Weapons."
	PlantExplosive="%action_use% %icon_use% to plant the explosive."
	DisarmExplosive="%action_use% %icon_use% to disarm the explosive."
	RearmExplosive="%action_use% %icon_use% to rearm the explosive."
	TankGrenadeMessage="%action_use% %icon_use% to drop explosive inside tank."
	RestockUsable="%action_use% %icon_use% to Restock Your Items."
	PlungerMessage="%action_use% %icon_use% to detonate the charge."
	UseFlareCrateMessage="%action_use% %icon_use% to mark the supply drop."
	UseReinforcementMessage="%action_use% %icon_use% to signal in reinforcements."

    YPos=240
}
class gbxContextUseTrigger extends Trigger
	placeable;

var() EContextUseType	m_eUseType;
var() bool		bDontDisplayMessage;
var() name		m_szUseTarget;
var Actor		m_aUseTarget;
var Pawn		m_aTouchedBy;
var bool		m_fMessageActive;
var() bool		bDisabled;
var() float		UseAngleCos;


event Destroyed()
{
	if (m_aTouchedBy != None)
	{
		if (m_fMessageActive)
		{
			m_aTouchedBy.ReceiveLocalizedMessage(class'gbxContextUseHUDMessage', -1);  // remove the message from the HUD
			m_fMessageActive = false;
		}
	}

	Super.Destroyed();
}

function Touch( Actor Other )
{
	local Pawn TouchedBy;

	if (bDisabled)
		return;

	if (bDontDisplayMessage)
		return;

	TouchedBy = Pawn( Other );

	if ( TouchedBy == None || !TouchedBy.IsHumanControlled() )
		return;

	m_fMessageActive = false;

	m_aTouchedBy = TouchedBy;

	if (m_aUseTarget == None)
	{
		if (m_szUseTarget != '')
		{
			foreach AllActors( class'Actor', m_aUseTarget, m_szUseTarget )
				break;
		}
	}

	if( (Other.Instigator != None) )
	{
		if (m_aTouchedBy == None)
			return;

		if (m_aUseTarget != None)
		{
			if (m_aTouchedBy.IsPawnLookingAtActor(m_aUseTarget, UseAngleCos) == false)  // about 60 degrees from straight ahead
			{
				m_aTouchedBy.ReceiveLocalizedMessage(class'gbxContextUseHUDMessage', -1);  // remove the message from the HUD
				return;
			}
		}

		m_aTouchedBy.ReceiveLocalizedMessage(class'gbxContextUseHUDMessage', m_eUseType);  // display the USE message
		m_fMessageActive = true;
	}
}

function UnTouch( Actor Other )
{
	local Pawn User;
	local Pawn UnTouchedBy;

	UnTouchedBy = Pawn( Other );

	if ( UnTouchedBy == None || UnTouchedBy != m_aTouchedBy )
		return;

	m_aTouchedBy = None;

	// the Use message should always be enabled if you've untouched the trigger
	bDontDisplayMessage = false;

	if( (Other.Instigator != None) )
	{
		User = Pawn(Other);

		if (m_fMessageActive)
		{
			User.ReceiveLocalizedMessage(class'gbxContextUseHUDMessage', -1);  // remove the message from the HUD
			m_fMessageActive = false;
		}
	}
}

event bool UsedBy( Pawn User )
{
	local PlayerController	aPlayer;

	if (bDisabled)
		return false;

	if (m_aUseTarget == None)
	{
		if (m_szUseTarget != '')
		{
			foreach AllActors( class'Actor', m_aUseTarget, m_szUseTarget )
				break;
			if (m_aUseTarget != None)
			{
				if (User.IsPawnLookingAtActor(m_aUseTarget, UseAngleCos) == false)  // about 60 degrees from straight ahead
				{
					return false;
				}
			}
		}
	}

	if( (User != None) )
	{
		aPlayer = PlayerController(User.Controller);
		if (aPlayer != None)
		{
			// Using the ContextUseTrigger automatically disables the USE message in the Touch() function.
			//  This needed to be done to prevent "USE messages" and "clear messages" from getting out
			// of order when players used the MG42 machine gun.  You could get a UsedBy() immediately
			// followed by a UnTouch() immediately followed by a Touch(), which would leave the "USE"
			// message displayed on the HUD when it wasn't supposed to be.

			// The USEable item will have to re-enable the USE message in the gbxContextUse trigger
			// if it want's the USE message to appear again.
			if (m_eUseType != GammonBomb)
				bDontDisplayMessage = true;

			User.ReceiveLocalizedMessage(class'gbxContextUseHUDMessage', -2);  // remove the message from the HUD
		}
	}

	// make SURE TriggerEvent is called with 'self' as second parameter (this is necessary for tanks
	// which have multiple triggers and the tank weapon code needs to know which gbxContextUseTrigger
	// was used to trigger it, since 2 or more triggers can trigger the same actor).
	TriggerEvent(Event, self, User);
	if (m_aUseTarget != None)
		TriggerEvent( m_szUseTarget, self, User );

	return true;
}

event Trigger(actor Other, Pawn EventInstigator)
{
	bDisabled = !bDisabled;
}

function Tick( float deltaTime )
{
	Super.Tick( deltaTime );

	if (m_aTouchedBy != None)
	{
		if (m_aUseTarget != None)
		{
			if (m_aTouchedBy.IsPawnLookingAtActor(m_aUseTarget, UseAngleCos) == false)  // about 60 degrees from straight ahead
			{
				if (m_fMessageActive)
				{
					m_aTouchedBy.ReceiveLocalizedMessage(class'gbxContextUseHUDMessage', -1);  // remove the message from the HUD
					m_fMessageActive = false;
				}
			}
			else if (!m_fMessageActive)
			{
				m_aTouchedBy.ReceiveLocalizedMessage(class'gbxContextUseHUDMessage', m_eUseType);  // display the USE message
				m_fMessageActive = true;
			}
		}
	}
}

defaultproperties
{
	Texture=Texture'Engine.S_TriggerContextUse'
    bHidden=true
	bCollideActors=true
    bStatic=false
    CollisionRadius=+0040.000000
	CollisionHeight=+040.000000
	bCollideWhenPlacing=false
    RemoteRole=ROLE_None
    m_eUseType=DoorUse
	UseAngleCos=0.9
}
// ====================================================================
//  Class:  gbxDamageBullet
//
// (c) 2001, Epic Games, Inc - All Rights Reserved
// ====================================================================

class gbxDamageBullet extends gbxDamageType
	abstract;


defaultproperties
{
}
// ====================================================================
//  Class:  gbxDamageExploded
// ====================================================================

class gbxDamageExploded extends gbxDamageType
	abstract;


defaultproperties
{
	m_bExplosiveDamage=true
}
// ====================================================================
//  Class:  gbxDamageType
//
//  <Enter a description here>
//
// (c) 2001, Epic Games, Inc - All Rights Reserved
// ====================================================================

class gbxDamageType extends DamageType
	abstract;

defaultproperties
{
	PawnDamageSounds(0)=Sound'IMPACTS.BULLET_BODY'
}
//=============================================================================
// TriggeredScriptDelayedMove.
// 
// Interface to TriggeredScriptDelayedMove
//=============================================================================
class gbxDelayedMove extends Actor
	placeable;

var(Events) float fDelay;

//var name				Unit_DE;
//var name				nmPath;

var name				m_TriggerTag;
var name				m_MatchTag;
var int					m_Location;

defaultproperties
{
	m_TriggerTag='';
	m_MatchTag='';
	m_Location=0;
}class gbxDummyGrenade extends Actor;



defaultproperties
{
    RemoteRole=ROLE_None
    DrawType=DT_StaticMesh
    DrawScale=0.65
    bUnlit=false
}
//=============================================================================
// Base class for explosions that do damage.
//=============================================================================
class gbxExplosive extends Projectile;

var float		ShakeRadius;			// radius within which to shake player views
var float		ViewRollTime;			// how long to roll the instigator's view
var float		RollMag;				// how far to roll view
var float		RollRate;				// how fast to roll view
var float		OffsetMagVertical;		// max view offset vertically
var float		OffsetRateVertical;		// how fast to offset view vertically
var float		OffsetMagHorizontal;	// max view offset horizontally
var float		OffsetRateHorizontal;	// how fast to offset view horizontally
var float		OffsetIterations;		// how many iterations to offset view
var() float		FuseTimeMin;			// how many seconds before blowing up (min)
var() float		FuseTimeMax;			// how many seconds before blowing up (max)
var float		HeavyTraumaRadius;		// Play 'Heavy Trauma' effect on player if he's within this radius of the grenade
var float		AirBurstThreshold;		// Distance from ground where explosion is considered to be exploding in air

var float		RealFuseTime;
var float		ElapsedFuseTime;
var String		ExplosionMessageName;
var bool		bBlowingUp;
var bool		bDestroyWhenDone;

var float Count, SmokeRate;

var gbxContextUseTrigger TheTrigger;

// PSV: 7/2/2004 Moved flFuseTime out here so we can draw the time remaining
var float		flFuseTime;				
var int			iReplicatedFuseTime;	// integer version of the fusetime sent to each client
var bool		bActivated;				// true when the explosive timer has started
var bool		bShouldExplode;			// server sets this to true so clients can playback effects
var bool		bHideAfterExplosion;	// if true, the explosive will not be deleted when it explodes

var	EWeaponCategory			WeaponCategory;

replication
{
	reliable if( bNetDirty && (Role==ROLE_Authority) )
        RealFuseTime, ElapsedFuseTime, iReplicatedFuseTime, bShouldExplode, bActivated;
        
    reliable if( bNetInitial && (Role==ROLE_Authority) )
		FuseTimeMax;
}

simulated event Destroyed()
{
	SetBase( None );
	Super.Destroyed();
}

simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();
}

simulated function BeginPlay()
{
	if ( (Level.DetailMode != DM_Low) && !Level.bDropDetail )
		SmokeRate = 0.03;
	else
		SmokeRate = 0.15;
}

simulated function Tick(float DeltaTime)
{
	if ( bHidden ) 
		return;

	if ( bActivated )
	{
		if (Role == ROLE_Authority)
		{
			//Log( self$ " gbxExplosive::Tick() flFuseTime: " $flFuseTime, 'PSV');

			// Decrement fuse time
			if ( flFuseTime > 0.0 )
			{
				flFuseTime -= DeltaTime;
				iReplicatedFuseTime = Ceil(flFuseTime);
			}
			else
			{
				flFuseTime = 0.0;
				iReplicatedFuseTime = 0;
				bShouldExplode = true;
				Explosion( Location );
			}
		}
	}

	if( bBlowingUp )
	{
		if ( bHideAfterExplosion )
		{
			bHidden = true;
		}
		else
		{
			Destroy();
		}
	}
}

function ServerExplosion(vector HitLocation)
{
	bShouldExplode = true;
	Explosion( HitLocation );
}

simulated function Explosion(vector HitLocation)
{
	local Controller C;
	local vector OffsetMag, OffsetRate;
	local IImpactManager ImpactMgr;
	local Material FloorMat;
	local Vector HitLoc, HitNormal;
	local ExplosionPhysical MyExplosionPhysical;
	local gbxMessage ExplosionMsg;

	local float AirBurstDistance, BurstDist;

	//Log( self$ " gbxExplosive::Explosion()" , 'PSV');

	if ( Level.NetMode != NM_DedicatedServer )
	{
		Trace( HitLoc, HitNormal, HitLocation - Vect(0, 0, 4096), HitLocation, false,, FloorMat );

		AirBurstDistance = VSize(HitLocation - HitLoc);

		// Clear the floor material so the impact manager will understand the explosion as an air burst
		if( AirBurstDistance > AirBurstThreshold )
			FloorMat = None;

		ImpactMgr = class'ImpactManager'.static.GetInstance( Level.Outer, self );
		if (ImpactMgr != None)
			ImpactMgr.HandleExplosionImpact(self, FloorMat,	WeaponCategory, HitLocation, rotator( HitNormal ));

		// shake the players a bit...
		OffsetMag = OffsetMagHorizontal * vect(1,1,0) + OffsetMagVertical * vect(0,0,1);
		OffsetRate = OffsetRateHorizontal * vect(1,1,0) + OffsetRateVertical * vect(0,0,1);
		for ( C=Level.ControllerList; C!=None; C=C.NextController )
		{
			if ( PlayerController(C) != None )
			{
				BurstDist = VSize(Location - PlayerController(C).ViewTarget.Location);

				if( BurstDist < ShakeRadius && BurstDist > HeavyTraumaRadius )
					C.ShakeView(ViewRollTime,RollMag,OffsetMag,RollRate,OffsetRate,OffsetIterations);
			}
		}

		// Create the physical effect. 
		// TODO The physical effect should do most of the above: shake the player, send a message, etc. 
		// All the non-visual, non-unique-to-this-class stuff.
		MyExplosionPhysical = Spawn( class'ExplosionPhysicalGrenade' );

		// Suppress any units in the vicinity.
		ExplosionMsg = new( Level.Outer ) class<gbxMessage>( DynamicLoadObject( ExplosionMessageName, class'Class' ));
		ExplosionMsg.Sender = self;
		ExplosionMsg.bUseSenderLocation = true;
		ExplosionMsg.bHasLocation = true;
		ExplosionMsg.BroadcastRadius = FMax(1800.0f, DamageRadius * 2.0f);
		ExplosionMsg.Instigator = Instigator;  // store the Pawn that instigated this explosion as the instigator of the gbxMessage

		PostGBXMessage( ExplosionMsg );
	}
	
	if( FloorMat != None )
	{
		DoDamage( HitLocation );
	}
	else
	{
		DoDamage( HitLocation, AirBurstDistance );
	}

	bBlowingUp = true;
	TriggerEvent(Event, self, None);
	if (bDestroyWhenDone)
	{
		Destroy();
	}
}

function DoDamage( vector Location, optional float AirBurstDistance )
{
	if( AirBurstDistance > 0 )
	{
		BlowUp( Location ); // Applies a radius damage
	}
	else
	{
		/// TBD: For now, just call BlowUp.  This could change to be more of a cone type of damage
		BlowUp( Location );
	}
}

// Trace to the ground and return that location
function Vector GetGroundLocation()
{
	local Vector HitLocation, HitNormal;

	if( VSize(Velocity) > 0 )
	{
		Trace( HitLocation, HitNormal, Location + Vect(0,0,-5000),, false );

		if( HitLocation != Vect(0,0,0) )
			return HitLocation;
		else
			return Location;
	}

	return Location;
}

/* HurtRadius()
 Hurt locally authoritative actors within the radius.  Overrides Actor implementation
*/

simulated function HurtRadius( float DamageAmount, float DamageRadius, class<DamageType> DamageType, float Momentum, vector HitLocation )
{
	local actor Victims;
	local float damageScale, dist;
	local vector dir;
	local vector mVector;
	local vector lVector;
	local Vector HitLoc, HitNormal;
	local name HitBoxName;
	local float Coll_Height, Coll_Radius;

	if( bHurtEntry )
		return;

	bHurtEntry = true;
	foreach VisibleCollidingActors( class 'Actor', Victims, DamageRadius, HitLocation + vect(0,0,32) )
	{
		// don't let blast damage affect fluid - VisibleCollisingActors doesn't really work for them - jag
		if( (Victims != self) && (Victims.Role == ROLE_Authority) )
		{
			if (gbxVehicle(Victims) != None)
			{
				Coll_Height = gbxVehicle(Victims).VehicleCollisionHeight;
				Coll_Radius = gbxVehicle(Victims).VehicleCollisionRadius;
			}
			else
			{
				Coll_Height = Victims.CollisionHeight;
				Coll_Radius = Victims.CollisionRadius;
			}

			// Move the hit location to the eyes to help toss the victim around more
			if( Victims.IsA('Pawn') )
			{
				lVector = Victims.Location + Pawn(Victims).EyePosition();
				dir = lVector - HitLocation;
				dist = FMax(1,VSize(dir));

				if( dist < HeavyTraumaRadius && Level.Game.IsA('WargameSinglePlayer') && Victims.IsA('gbxPlayerPawn') && gbxPlayerController(Pawn(Victims).Controller) != None )
				{
					gbxPlayerController(Pawn(Victims).Controller).DoHeavyTrauma();
				}
			}
			else
			{
				lVector = Victims.Location - 0.5 * (Coll_Height + Coll_Radius) * dir;
				dir = Victims.Location - HitLocation;
			}

			dist = FMax(1,VSize(dir));
			
			if( dist > DamageRadius )
				continue;

			damageScale = 1 - FMax(0,(dist - Coll_Radius)/DamageRadius);

			// For the momentum vector, sink the explosion location into the floor some to make the victim fly more
			mVector = damageScale * Momentum  * Normal( lVector - (HitLocation - (vect(0,0,1) * 128.0)) );

			Trace( HitLoc, HitNormal, Victims.Location, HitLocation, true,,,true,, HitBoxName );

			Victims.TakeDamage
			(
				damageScale * DamageAmount,
				Instigator,
				lVector,
				mVector,
				DamageType,
				HitBoxName
			);
		}
	}
	bHurtEntry = false;
}

function StartExplosionTimer()
{
	if (FuseTimeMax > 0.0f)
	{
		bActivated = true;
		
		if (FuseTimeMin < FuseTimeMax)
		{
			flFuseTime = FuseTimeMin + ((FuseTimeMax - FuseTimeMin) * frand());
		}
		else
		{
			flFuseTime = FuseTimeMax;
		}
	}
	else
	{
		Explosion( Location );
	}
}

function Trigger(actor Other, pawn EventInstigator)
{
	super.Trigger(Other,EventInstigator);

	StartExplosionTimer();
}

defaultproperties
{
	ExplosionDecal=class'BlastMark'
	MyDamageType=class'DamageExplosive'
	Damage=500.000000
	//DamageRadius=768.000000
	DamageRadius=375.000000	// GBX:naj - modified 4/5/04
	Physics=PHYS_None
//	AmbientGlow=64
	AmbientGlow=0	// GBX:PAD: These things are a bit bright, so tone them down a bit.  You don't need to draw attention to them.
	bFixedRotationDir=True
	DesiredRotation=(Pitch=12000,Yaw=5666,Roll=2334)
	DrawType=DT_STATICMESH

	ExplosionMessageName="gbxAI.PerceptionGrenadeExplosion"
    
	ShakeRadius=2000.000000
	ViewRollTime=0.200000
	RollMag=20.000000
	RollRate=100.000000
	OffsetMagVertical=20.000000
	OffsetRateVertical=800.000000
	OffsetMagHorizontal=20.000000
	OffsetRateHorizontal=800.000000
	OffsetIterations=10.000000

	AirBurstThreshold=150
	bBlowingUp=false

	FuseTimeMin=5.0
	FuseTimeMax=6.0

	HeavyTraumaRadius=384.0
	flFuseTime=0.0
	iReplicatedFuseTime=0
	bShouldExplode=false
	bActivated=false
	bHideAfterExplosion=false

	WeaponCategory=WC_Grenade
}
//=============================================================================
// Base class for all grenades
//=============================================================================
class gbxGrenade extends gbxExplosive;

#exec OBJ LOAD FILE=..\staticmesh\s_npc_weapon_us.usx

var name		AttachTagName;			// name of tag to query for the attachment point of the grenade

var bool		bHitGround;
var bool		bCanHitOwner;
var bool		bHitWater;
var bool		bDoLobCalc;
var Pawn		ClaimedByPawn;
var Pawn		AttachedToPawn;
var Pawn		PreviousAttachedToPawn;
var Cue			ImpactSoundCue;
var String		ImpactSoundCueName;
var Cue			WaterImpactSoundCue;
var String      WaterImpactSoundCueName;
var Vector		ThrowVector;

var float		MessageInterval;		// how often to tell tell pawns about me
var float		MaxThrowStrength;  // Maximum strength grenade can be thrown with
var float		MinThrowStrength; // Minimum strength grenade can be thrown with
var float		MaxStrengthPitch; // When not auto-calculating a lob, this is the view pitch the player must have (relative to the horizon) to achieve maximum throw strength
var float		MaxLobHeight;	// Maximum height allowed to apply to grenade toss
var float		MinLobHeight;   // Minimum height allowed to apply to grenade toss
var float		IndoorLobHeight; // A uniform lob height when throwing indoors
var float		MaxTargetRange;	// Maximum distance grenade can be thrown
var float		CeilingAdjust;	// Number of units (positive) to adjust down from ceiling when calculating lob apex
var float		GravityFactor;	// Adjust gravity used in calculating lob vector
var float		MaxWallHeight;	// First person tosses will throw over walls, if the distance from the inteaded target to the top of the wall is shorter than this number of units
var float		MaxWindowHeight; // Consider the short wall a window if there is geometry above the "wall" within this number of units
var	float		WallAngleThreshold; // Threshold that the Z component of a HitNormal
var float		NextGrenadeBounceSoundTime;
var float		LastTickTime;	// Keep track of tick
var Range		WallHeightAdjust;	// If adjusting the lob to go over a wall, adjust new target z by this number of units
var float		ScaleDistanceCheckUpdate;  // Keep track of time for checking grenade distance from player.
var float		ScaleDistanceModifier; // Rate of grenade scaling when thrown, based on distance from player.

const SCALE_GROW_LIMIT=1.5;
const SCALE_DISTANCE_CHECK_TIME=0.1f;
const GRENADE_BOUNCE_SOUND_INTERVAL=0.15;



replication
{
	reliable if( bNetDirty && (Role==ROLE_Authority) )
        AttachedToPawn, PreviousAttachedToPawn;
}

simulated event Destroyed()
{
	local int				i;
	local gbxPawn			aPawn;
	local gbxAIController	aController;
	local IGbxPawnList		PawnList;

	PawnList = Level.GetPawnList();
	if (PawnList != None)
	{
		i = gbxPawnList( PawnList ).GetGbxPawn( None, 0, aPawn );
		while( i != -1 )
		{
			if ((aPawn != None) && !aPawn.IsHumanControlled())
			{
				aController = gbxAIController(aPawn.Controller);

				if (aController != None)
				{
					aController.CleanUpGrenade( self );
				}
			}

			i = gbxPawnList( PawnList ).GetGbxPawn( None, i, aPawn );
		}
	}
	
	Super.Destroyed();
}

simulated function PostBeginPlay()
{
	Super.PostBeginPlay();

	RealFuseTime = RandRange(FuseTimeMin, FuseTimeMax);
	
	MaxSpeed = 1000;
	RandSpin(50000);
	bCanHitOwner = False;
}

simulated function PostNetBeginPlay()
{
	LastTickTime = Level.UniversalTimeSeconds;
	Super.PostNetBeginPlay();
	SetStaticMesh(StaticMesh(DynamicLoadObject("s_npc_weapon_us.us_grenade", class'StaticMesh')));
}

simulated function BeginPlay()
{
	if ( (Level.DetailMode != DM_Low) && !Level.bDropDetail )
		SmokeRate = 0.03;
	else
		SmokeRate = 0.15;
}

simulated function PhysicsVolumeChange( PhysicsVolume NewVolume )
{	
	if ( !NewVolume.bWaterVolume )
		return;

	bHitWater = True;


	Spawn(class'WaterSplashSmall',,,,rot(16384,0,0));			//-BB

	if( WaterImpactSoundCue == None )
	{
		WaterImpactSoundCue = LoadSound( WaterImpactSoundCueName );
	}

	PlayOwnedSoundCue( WaterImpactSoundCue,SLOT_Interact,,,,,true );

	Velocity=0.6*Velocity;


}

simulated function StartFuse()
{
	SetTimer(MessageInterval, true);
}

function ThrowGrenadeSP( optional Vector nThrowVector )
{	
	if( AttachedToPawn != None )
	{
//		AttachedToPawn.DetachFromBone( self );

		if (Role==ROLE_Authority)
		{
			if( AttachedToPawn.IsFirstPerson() )
			{
				if( gbxWeapon(Instigator.Weapon).bThrowGrenadeLeftHanded )
				{				
					SetLocation( Instigator.Location + Instigator.EyePosition() + ( Vector( Instigator.GetViewRotation() ) >> Rot(0,49152,0) ) * 16.0 );
				}
				else
				{
					SetLocation( Instigator.Location + Instigator.EyePosition() + ( Vector( Instigator.GetViewRotation() ) >> Rot(0,16384,0) ) * 16.0 );
				}

				SetRotation( AttachedToPawn.GetViewRotation() );
			}
		}

		// Reset the physics
		SetCollision( true, false, false );
		bCollideWorld=true;
		bBounce=true;
		SetPhysics( PHYS_Falling );

		// Remember who we were attached to
		PreviousAttachedToPawn = AttachedToPawn;
		AttachedToPawn = None;
	}

	if( nThrowVector != Vect(0,0,0) )
		ThrowVector = nThrowVector;

	if( ThrowVector == Vect(0,0,0) )
		SetFirstPersonThrowVector();
	
	Velocity = ThrowVector;
	//Log(name$".ThrowGrenade( "$nThrowVector$" ) - "$AttachedToPawn$" - "$PreviousAttachedToPawn$" - "$ThrowVector$" - "$Velocity$" - "$bHidden$" - "$StaticMesh);

//	bReplicateMovement = true;
	bUpdateSimulatedPosition = true;
}

function ThrowGrenadeMP( optional Vector nThrowVector )
{
	local gbxGrenade actualGrenade;
	local Vector throwFromLocation;
		
	if( AttachedToPawn != None )
	{
//		AttachedToPawn.DetachFromBone( self );

		if (Role==ROLE_Authority)
		{
			if( AttachedToPawn.IsFirstPerson() )
			{
				if( gbxWeapon(AttachedToPawn.Weapon).bThrowGrenadeLeftHanded )
				{
					throwFromLocation = AttachedToPawn.Location + AttachedToPawn.EyePosition() + ( Vector( AttachedToPawn.GetViewRotation() ) >> Rot(0,49152,0) ) * 16.0;
				}
				else
				{
					throwFromLocation = AttachedToPawn.Location + AttachedToPawn.EyePosition() + ( Vector( AttachedToPawn.GetViewRotation() ) >> Rot(0,16384,0) ) * 16.0;
				}
			}
			else
			{
				throwFromLocation = AttachedToPawn.Location + AttachedToPawn.EyePosition();
			}
		}
		// GBX:PAD: This was old single player grenade code that the MP guys grabbed when they split off from the
		// single player grenade system that was broken for them.  However, in talking to Steve and Jimmy, there is
		// no technical reason the new single player code shouldn't work, so I've put that in above.
/*
		if (Role==ROLE_Authority)
		{
			if( AttachedToPawn.IsFirstPerson() )
			{
				throwFromLocation = AttachedToPawn.Weapon.GetAttachmentTagWorldCoords( AttachTagName ).Origin;
			}
			else
			{
				throwFromLocation = AttachedToPawn.Location + AttachedToPawn.EyePosition();
			}
		}
*/

		// Reset the physics
		SetCollision( true, false, false );
		bCollideWorld=true;
		bBounce=true;
		SetPhysics( PHYS_Falling );

		// Remember who we were attached to
		// This must be done before calling SetFirstPersonThrowVector!
		PreviousAttachedToPawn = AttachedToPawn;
		AttachedToPawn = None;

		actualGrenade = Spawn(Class, owner,,throwFromLocation);
		
		// If the grenade fails to spawn, then try one more time, moving the spawn point back a little
		if (actualGrenade == None)
		{
			if( nThrowVector != Vect(0,0,0) )
				ThrowVector = nThrowVector;

			if( ThrowVector == Vect(0,0,0) )
				SetFirstPersonThrowVector();

			log("Failed to spawn grenade.  Trying secondary spawn.", 'CRG');
			// Try to spawn back a few units
			actualGrenade = Spawn(Class, owner,,throwFromLocation - 50.0f * Normal(ThrowVector));
		}


		if (actualGrenade != None)
		{
			actualGrenade.PreviousAttachedToPawn = PreviousAttachedToPawn;
			actualGrenade.StartFuse();
			actualGrenade.ElapsedFuseTime = ElapsedFuseTime;
			actualGrenade.RealFuseTime = RealFuseTime;
		}
		else // Was unable to spawn the grenade.  Give it back
		{
			log("Failed to spawn grenade, credit back 1 to player", 'CRG');
			gbxUsableItem(gbxPawn(Instigator).SecondaryWeapon).NumCopies += 1;
		}

	}
	else
	{
		actualGrenade = self;
	}

	if( nThrowVector != Vect(0,0,0) )
		ThrowVector = nThrowVector;

	if( ThrowVector == Vect(0,0,0) )
		SetFirstPersonThrowVector();
			
	actualGrenade.ThrowVector = ThrowVector;
	actualGrenade.Velocity = ThrowVector;

	//bReplicateMovement = true;
	bUpdateSimulatedPosition = true;
	
	if(actualGrenade != self)
	{
		destroy();
	}
}

function ThrowGrenade( optional Vector nThrowVector )
{	
	if (Level.NetMode == NM_StandAlone)
	{
		ThrowGrenadeSP( nThrowVector );
	}
	else
	{
		ThrowGrenadeMP( nThrowVector );
	}
}

simulated function SetFirstPersonThrowVector()
{
	local vector WallTestHitLocation, WallTestHitNormal, WallTestVector, HitLocation, HitNormal, StartTrace, EndTrace, nThrowVector, ViewRotation;
	local Rotator ViewRotator;
	local float HitDistance, LobTime, WallAdjust, DistAtten, LobHeightAtten;
	local Actor HitActor;
	local bool bWallDetection, bDoLobCalc;
	local int i, ViewPitchScale;
		
	bWallDetection = false;

	if( bDoLobCalc )
	{
		bWallDetection = true;
	}

	// Get the point that the player is looking at
	ViewRotator = PreviousAttachedToPawn.GetViewRotation();
	ViewRotation = Vector( ViewRotator );
	StartTrace = PreviousAttachedToPawn.Location + PreviousAttachedToPawn.EyePosition();
	EndTrace = Location + (ViewRotation * MaxTargetRange);
	
	HitActor = Trace( HitLocation, HitNormal, EndTrace, StartTrace, true );
	HitDistance =  VSize( HitLocation - Location );
	
	Log( "****SJP: Threw Grenade.  HitActor is '"$HitActor$"', HitDistance = "$HitDistance, 'SJP' );
	//Spawn( class'gbxEffects.gbxDebugShape',,,HitLocation );
	
	// First determine if we hit a PlayerGrenadeTargetVolume
	if( HitActor.IsA( 'PlayerGrenadeTargetVolume' ) )
	{
		if( HitDistance >= PlayerGrenadeTargetVolume( HitActor ).MinimumPlayerRange )
		{
			bWallDetection = false;
			bDoLobCalc = true;
		}
		else
		{
			// Continue the trace; we're too close.
			HitActor = Trace( HitLocation, HitNormal, EndTrace, HitLocation, true,,,,,, HitActor );
		}
	}
	
	
	if( HitLocation == vect(0,0,0) )
	{
		// Off the grid somewhere
		HitLocation = EndTrace;
	}
	else if( bWallDetection )
	{
		Log( "****SJP: HitNormal.Z = "$HitNormal.Z$"; HitActor = "$HitActor, 'SJP' );

		// If we're throwing at a short wall, cause the grenade to land on the other side of it.
		if( !HitActor.IsA('Pawn') && abs( HitNormal.Z ) < WallAngleThreshold )
		{
			for( i = 4; i > 0; i-- )
			{
				// We hit a sortof vertical surface.  Determine if it's a short wall.
				WallTestVector = HitLocation + ( vect(0,0,1) * MaxWallHeight ) - ( vect(1,1,0) * HitNormal * ( i * 12.0 ) );

				// Trace from a point that should be directly above the wall.
				Trace( WallTestHitLocation, WallTestHitNormal, WallTestVector - ( vect(0,0,1) * MaxWallHeight ), WallTestVector, false );

				Log( "*****SJP: WallTestHitNormal is "$WallTestHitNormal, 'SJP' );

				// If we hit something, and that something is above our original target
				if( WallTestHitLocation != vect(0,0,0) && WallTestHitLocation.Z > HitLocation.Z )
				{
					WallAdjust = VSize( WallTestHitLocation - ( HitLocation - ( vect(1,1,0) * HitNormal * ( i * 12.0 ) ) ) );

					// If we're within the bounds of the max wall height, we seem to have actually hit a short wall.  Adjust the HitLocation to the top of this wall
					if( WallAdjust < MaxWallHeight )
					{
						DistAtten = FMax( ComputeAttenuation( 0.85, HitDistance, MaxTargetRange, true ), 0.1 );
						HitLocation = WallTestHitLocation + vect(0,0,1) * Lerp( DistAtten, WallHeightAdjust.Min, WallHeightAdjust.Max );
						bDoLobCalc = true;
						break;
					}
				}
			}
		}
	}
	
	if( !bDoLobCalc || !CalculateLobVector( HitLocation, nThrowVector, LobTime ) )
	{
		// Calculate lob vector based on view angle.  This is +/- the horizon
		
		if( ViewRotator.pitch <= 18000 )
		{
			ViewPitchScale = Round( MaxStrengthPitch / 2 ) + Min( Round( MaxStrengthPitch / 2 ), ViewRotator.pitch );
		}
		else if( ViewRotator.pitch >= 49152 )
		{
			ViewPitchScale = Round( MaxStrengthPitch / 2 ) - Min( Round( MaxStrengthPitch / 2 ), 65536 - ViewRotator.pitch );
		}

		DistAtten = ( ViewPitchScale / MaxStrengthPitch ) * ( MaxThrowStrength - MinThrowStrength ) + MinThrowStrength;
		LobHeightAtten = ( ViewPitchScale / MaxStrengthPitch ) * (MaxLobHeight - MinLobHeight ) + MinLobHeight;
		nThrowVector = ViewRotation * DistAtten + vect(0,0,1) * LobHeightAtten;
		
		Log( "ViewRotator.pitch is "$ViewRotator.pitch$", DistAtten is "$DistAtten$", Throw vector strength is "$VSize(nThrowVector)$", Throw angle is "$(ViewPitchScale / 182.04), 'SJP' );

		if ( Instigator.HeadVolume.bWaterVolume )
		{
			bHitWater = True;
			nThrowVector *= 0.6;
		}
	}

	// Clamp the throw to the max throw strength
	nThrowVector = Normal(nThrowVector) * Min( VSize( nThrowVector ), MaxThrowStrength );

	ThrowVector = nThrowVector;
}

function bool ReverseThrowVector()
{
	if( ThrowVector == vect(0,0,0) )
		return false;

	//Log(name$"****SJP: GRENADE Old throw vector: "$ThrowVector, 'SJP');

	//ThrowVector = MirrorVectorByNormal( ThrowVector, vect(0,0,1) );
	ThrowVector = ThrowVector >> Rot(0,32768,0);

	//Log(name$"****SJP: GRENADE New throw vector: "$ThrowVector, 'SJP');

	return true;
}

simulated function Timer()
{
	local gbxMessage GrenadeMessage;

	if( ElapsedFuseTime > RealFuseTime / 2 || bHitGround )
	{
		GrenadeMessage = new( None ) class<gbxMessage>( DynamicLoadObject( "gbxAI.PerceptionGrenade", class'Class' ));
		GrenadeMessage.Sender = self;
		GrenadeMessage.bUseSenderLocation = true;
		GrenadeMessage.bHasLocation = true;
		GrenadeMessage.BroadcastRadius = DamageRadius;
		
		if( bHitGround )
		{
			GrenadeMessage.bBroadcastLOSBlocked = true;
		}	
		
		PostGBXMessage( GrenadeMessage );
	}
}

simulated function Tick(float DeltaTime)
{
	local float Delta;
	local float Dist;
	local Pawn PL;
	local PlayerController PC;

	
	// This scales the grenade up too a limit after being thrown.
	if ((AttachedToPawn == None) && (DrawScale < SCALE_GROW_LIMIT))
	{
		ScaleDistanceCheckUpdate -= DeltaTime;
		if (ScaleDistanceCheckUpdate <= 0.0f)
		{
			// get the playerpawn
			PC = Level.GetLocalPlayerController();
			if ( PC != None )
			{
				PL = PC.Pawn;
				if (PL != None)
				{
					Dist = VSize(Location - PL.location);
					if (dist < 1000.0f)
						ScaleDistanceModifier = 0.0f;
					else
						ScaleDistanceModifier = dist / 3000.0f;  
				}
			}
			ScaleDistanceCheckUpdate = SCALE_DISTANCE_CHECK_TIME;	
		}
		SetDrawScale( DrawScale + ScaleDistanceModifier * DeltaTime);
	}

	// Use Level.UniversalTimeSeconds to tick ... this will prevent the grenade from ticking in slow motion during certain situations

	Delta = Level.UniversalTimeSeconds - LastTickTime;

	//if( PreviousAttachedToPawn != None && PreviousAttachedToPawn.IsDead() )
	//	ElapsedFuseTime += Delta;
	//else
		ElapsedFuseTime += DeltaTime;

	if( ElapsedFuseTime > RealFuseTime )
	{
		Explosion(Location+Vect(0,0,1)*16);
	}

	LastTickTime = Level.UniversalTimeSeconds;

	Super.Tick( DeltaTime );
}

simulated function Landed( vector HitLocation, vector HitNormal )
{
	HitWall( HitLocation, HitNormal, None );
}

simulated function ProcessTouch( actor Other, vector HitLocation )
{
//	if ( (Other!=instigator) || bCanHitOwner )
//		Explosion(HitLocation);
	if( Other != Instigator && !Other.IsA( 'PlayerGrenadeTargetVolume' ) )
	{
		//Log(name$".ProcessTouch( "$Other$", "$HitLocation$" )");
		Velocity = vect(0,0,0);
	}
}

simulated function HitWall( vector HitLocation, vector HitNormal, actor Wall )
{
	local gbxMessage GrenadeMessage;
	local vector HitLoc, HitNorm;
	local Material FloorMat;
	local IImpactManager ImpactMgr;

	Log( "*****SJP: dot = "$(HitNormal dot vect(0,0,1))$", Speed = "$VSize(Velocity),'SJP' );
	if( HitNormal dot vect(0,0,1) > 0.7500 )
	{
		if( !bHitGround )
		{
			// Fudge the fuse if our owner is configured to do so
			if( gbxPawn(Instigator) != None && ElapsedFuseTime < RealFuseTime )
			{
				ElapsedFuseTime = FMin( RealFuseTime - gbxPawn(Instigator).HitGroundGrenadeFuseMod, ElapsedFuseTime );
			}
		}

		bHitGround = true;
	}

	bCanHitOwner = True;
	Velocity = 0.50*(( Velocity dot HitNormal ) * HitNormal * (-2.0) + Velocity);   // Reflect off Wall w/damping
	
	speed = VSize(Velocity);

	if( Level.TimeSeconds > NextGrenadeBounceSoundTime )
	{
		if ( Level.NetMode != NM_DedicatedServer )
		{
			// First get the hit material
			Trace( HitLoc, HitNorm, Location + HitNormal * -64.0,Location + HitNormal * 64.0, false,, FloorMat );
			
			ImpactMgr = class'ImpactManager'.static.GetInstance( Level.Outer, self );
			if (ImpactMgr != None)
			{		
				ImpactMgr.HandleGrenadeBounce( FloorMat, Self, bHitWater );
			}
		}

		NextGrenadeBounceSoundTime += Level.TimeSeconds + GRENADE_BOUNCE_SOUND_INTERVAL;

		// Notify nearby pawns about me
		GrenadeMessage = new( None ) class<gbxMessage>( DynamicLoadObject( "gbxAI.PerceptionGrenade", class'Class' ));
		GrenadeMessage.Sender = self;
		GrenadeMessage.bUseSenderLocation = true;
		GrenadeMessage.bHasLocation = true;
		GrenadeMessage.BroadcastRadius = DamageRadius;
		GrenadeMessage.bBroadcastLOSBlocked = false;
		PostGBXMessage( GrenadeMessage );

		RandSpin(100000);
	}

	if ( Velocity.Z > 400 )
	{
		Velocity.Z = 0.5 * (200 + Velocity.Z);
	}
	else if ( speed < 25 )
	{
		bBounce = False;
		SetPhysics(PHYS_None);
	}
}

function ServerExplosion(vector HitLocation)
{
	Explosion( HitLocation );
}

simulated function Explosion(vector HitLocation)
{
	//local gbxMessage ExplosionMsg;

	// GBX:naj - Tell the Instigator's UnitController that his grenade has exploded.
	if ( Instigator.IsA( 'gbxPawn' ) )
	{
		if ( Role == ROLE_Authority )
		{
			if ( gbxPawn( Instigator ).MyUnit != None )
			{
				gbxPawn( Instigator ).MyUnit.NotifyGrenadeExploded( Instigator );
			}
		}
	}

	/*
	if ( Level.NetMode != NM_DedicatedServer )
	{
		// GBX:naj - Suppress any units in the vicinity.
		ExplosionMsg = new( None ) class<gbxMessage>( DynamicLoadObject( "gbxAI.PerceptionGrenadeExplosion", class'Class' ));
		ExplosionMsg.Sender = self;
		ExplosionMsg.bUseSenderLocation = true;
		ExplosionMsg.bHasLocation = true;
		ExplosionMsg.BroadcastRadius = DamageRadius;
		PostGBXMessage( ExplosionMsg );
	}
	*/
	
	if ( (ExplosionDecal != None) && (Level.NetMode != NM_DedicatedServer) )
	{
		Spawn( ExplosionDecal,self,,HitLocation, Rot( 49152, 0, 0 ) ) ;
	}

	Super.Explosion( HitLocation );
}

simulated function AttachToPawn( Pawn aPawn )
{
	local Coords C;

	// Disable collision while it's attached to the pawn
	SetCollision( false, false, false );
	bCollideWorld=false;
	SetPhysics( PHYS_None );

	AttachedToPawn = aPawn;
	Instigator = aPawn;

	//Log(name$".AttachToPawn( "$aPawn$" ) - "$aPawn);
	
	if( aPawn.IsFirstPerson() )
	{
		// Attach to the middle of the player if he's in first person; can't attach to the weapon's AttachTagName because rendering borks
		aPawn.AttachToBone( self, 'Bip01' );
	}
	else
	{
		C = aPawn.GetAttachmentTagWorldCoords( AttachTagName );
		aPawn.AttachToBone( self, AttachTagName );
	}
	
//	SetRelativeLocation( vect(0,0,0) );
}

function bool IsClaimed()
{
	return AttachedToPawn != None || ClaimedByPawn != None;
}

function bool Claim( Pawn cPawn )
{
	if( !IsClaimed() )
	{
		ClaimedByPawn = cPawn;
		return true;
	}

	return false;
}

function AttachToClaimedByPawn()
{
	AttachToPawn( ClaimedByPawn );
}

function bool CalculateLobVector( vector vDest, out vector LobVector, out float LobTime )
{
	local Vector vMidPoint,OutVector;
	local Vector HitLocation, HitNormal;
	local float Gravity, distance1, distance2, time1, time2;

	// log( "*****SJP: CalculateLobVector to "$vDest$" from "$Location$". Distance is "$VSize( vDest - Location ), 'SJP' );
	
	// Mid point between ourselves and the target
	vMidPoint = Location + ( vDest - Location ) * 0.5;

	// Find the ceiling at the midpoint (if any)
	Trace( HitLocation, HitNormal, vMidPoint + ( Vect(0,0,1) * MaxLobHeight ), vMidPoint, false );

	if( HitLocation != Vect(0,0,0) )
	{
		vMidPoint = HitLocation - ( Vect(0,0,1) * CeilingAdjust );
		// vMidPoint.Z += FClamp( VSize( Location - vDest ) / MaxTargetRange, 0.0, 1.0 ) * IndoorLobHeight;
	}
	else
	{
		// We're probably outside.  Attenuate the lob height by the target distance.
		vMidPoint.Z += FClamp( VSize( Location - vDest ) / MaxTargetRange, 0.0, 1.0 ) * MaxLobHeight;
	}

	if( vMidPoint.Z < vDest.Z )
	{
		log( "****SJP: CalculateLobVector failed because the lob arc height was below the target." );
		return false;
	}

	// How high should the grenade travel to reach the apex?
	distance1 = FMax( 0.0, vMidPoint.Z - Location.Z );
	distance2 = vMidPoint.Z - vDest.Z;

	// Gravity is defined by the physics volume, and multiplied by our internal factor
	Gravity = Abs(PhysicsVolume.Gravity.Z) * GravityFactor;

	// How long will it take for the grenade to travel this distance?
	time1 = sqrt( (2.0 * distance1) / Gravity );
	time2 = sqrt( (2.0 * distance2) / Gravity );

	// Lateral velocity needed to get there in time
	OutVector = ( vDest - Location ) / ( time1 + time2 );

	// Vertical velocity needed to get there in time
	OutVector.Z = Gravity * time1;

	LobVector = OutVector;
	LobTime = time1 + time2;
	
	log( "****SJP: "$PreviousAttachedToPawn$" CalculateLobVector success!", 'SJP' );

	return true;
}

defaultproperties
{
	ExplosionDecal=class'BlastMark'
	MyDamageType=class'DamageGrenade'
	speed=1000.000000
	MaxSpeed=1500.000000
	Damage=500.000000
	DamageRadius=650.000000
	HeavyTraumaRadius=384.0
	ImpactSoundCueName="IMPACTS.GRENADE_GROUND"
	WaterImpactSoundCueName="IMPACTS.SPLASH_SMALL"

	MomentumTransfer=50000
	//Mass=050.000
	Physics=PHYS_Falling
//	StaticMesh=StaticMesh's_npc_weapon_us.us_grenade'
	DrawScale=1.00000
	AmbientGlow=64
	bBounce=True
	bFixedRotationDir=True
	DesiredRotation=(Pitch=12000,Yaw=5666,Roll=2334)
	DrawType=DT_STATICMESH

    ShakeRadius=2000.000000
	ViewRollTime=0.200000
	RollMag=20.000000
	RollRate=100.000000
	OffsetMagVertical=20.000000
	OffsetRateVertical=800.000000
	OffsetMagHorizontal=20.000000
	OffsetRateHorizontal=800.000000
	OffsetIterations=10.000000

	bBlowingUp=false

	FuseTimeMin=5.0
	FuseTimeMax=6.0
	MessageInterval=0.5

	AttachTagName=righthand_grenade_us

	IndoorLobHeight=128.0
	CeilingAdjust=128.0
	GravityFactor=0.5
	MaxLobHeight=350.0
	MinLobHeight=200.0
	MaxTargetRange=3072.0
	MaxThrowStrength=1600.0
	MinThrowStrength=500.0
	MaxWallHeight=144.0
	MaxWindowHeight=200.0
	WallAngleThreshold=0.50
	WallHeightAdjust=(Max=14.0,Min=8.0)
	MaxStrengthPitch=5462 // ~ 30 deg.
	bDoLobCalc=false
	ScaleDistanceCheckUpdate = 0.0
	ScaleDistanceModifier = 0.3
}
class gbxHeadlightCorona extends Light
	native;

defaultproperties
{
	bUnlit=True
	DrawType=DT_None
	bHidden=False
	DrawScale=0.4
	bHardAttach=True
	bCollideActors=False
	bCorona=True
	bBlockActors=False
	LightType=LT_None
	LightBrightness=0
	LightSaturation=175
	LightHue=255
	LightRadius=100
	LightPeriod=0
	LightCone=0
	bDynamicLight=False
	bMovable=True
	RemoteRole=ROLE_None
	bNetInitialRotation=true
	Physics=PHYS_None
	bNoDelete=false
	bStatic=false
//jlb	bDirectionalCorona=true
	CoronaRotation=10
//jlb    bDetailAttachment=true
}
class gbxHeadlightProjector extends Projector
	native;

defaultproperties
{
	DrawScale=0.65
	bHidden=true
//jlb	FrameBufferBlendingOp=PB_Add
//jlb	MaterialBlendingOp=PB_Modulate
    FOV=40
    MaxTraceDistance=2048
    bProjectOnUnlit=True
    bGradient=True
    bProjectOnAlpha=True
    bLightChanged=True
    bHardAttach=True
    bProjectActor=True
//jlb    bProjectOnParallelBSP=True
	bClipBSP=True
	RemoteRole=ROLE_None
//jlb	bNoProjectOnOwner=True
	bStatic=False
	bDynamicAttach=True
	CullDistance=2000.0
//jlb    bDetailAttachment=true
}
class gbxHoverCraft extends gbxSVehicle
	abstract
	native
	nativereplication;

cpptext
{
	INT* GetOptimizedRepList(BYTE* Recent, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel);

#ifdef WITH_KARMA
	// Actor interface.
	virtual UBOOL Tick(FLOAT DeltaTime, enum ELevelTick TickType);
	virtual void PostNetReceive();
	virtual UBOOL KRepulsorsShouldHit(AActor* Actor);

	// SVehicle interface.
	virtual void UpdateVehicle(FLOAT DeltaTime);

	// SHover interface.
	virtual void PackState();
#endif
}

var()	array<vector>		ThrusterOffsets;
var()	float				HoverSoftness;
var()	float				HoverPenScale;
var()	float				HoverCheckDist;

var()	float				UprightStiffness;
var()	float				UprightDamping;

var()	float				MaxThrustForce;
var()	float				LongDamping;

var()	float				MaxStrafeForce;
var()	float				LatDamping;

var()	float				MaxRiseForce;
var()	float				UpDamping;

var()	float				TurnTorqueFactor;
var()	float				TurnTorqueMax;
var()	float				TurnDamping;
var()	float				MaxYawRate;

var()	float				PitchTorqueFactor;
var()	float				PitchTorqueMax;
var()	float				PitchDamping;

var()	float				RollTorqueTurnFactor;
var()	float				RollTorqueStrafeFactor;
var()	float				RollTorqueMax;
var()	float				RollDamping;

var()	float				StopThreshold;

var()   float               MaxRandForce;
var()   float               RandForceInterval;

// Internal
var		float				HoverMPH;

var		float				TargetHeading;
var		float				TargetPitch;
var     bool                bHeadingInitialized;

var		float				OutputThrust;
var		float				OutputStrafe;

var     Pawn                OldDriver;

// Replicated
struct native HoverCraftState
{
	var vector				ChassisPosition;
	var Quat				ChassisQuaternion;
	var vector				ChassisLinVel;
	var vector				ChassisAngVel;

	var byte				ServerThrust;
	var	byte				ServerStrafe;
	var int                 ServerViewPitch;
	var int                 ServerViewYaw;
};

var		HoverCraftState		HoverState, OldHoverState;
var		KRigidBodyState		ChassisState;
var		bool				bNewHoverState;

replication
{
	reliable if (bNetDirty && Role == ROLE_Authority)
		HoverState;
}

simulated event bool KUpdateState(out KRigidBodyState newState)
{
	// This should never get called on the server - but just in case!
	if(Role == ROLE_Authority || !bNewHoverState)
		return false;

	newState = ChassisState;
	bNewHoverState = false;

	return true;
	//return false;
}

simulated function PostNetBeginPlay()
{
	local vector RotX, RotY, RotZ;
	local KarmaParams kp;
	local KRepulsor rep;
	local int i;

    GetAxes(Rotation,RotX,RotY,RotZ);

	// Spawn and assign 'repulsors' to hold bike off the ground
	kp = KarmaParams(KParams);
	kp.Repulsors.Length = ThrusterOffsets.Length;

	for(i=0;i<ThrusterOffsets.Length;i++)
	{
    	rep = spawn(class'KRepulsor', self,, Location + ThrusterOffsets[i].X * RotX + ThrusterOffsets[i].Y * RotY + ThrusterOffsets[i].Z * RotZ);
    	rep.SetBase(self);
    	rep.bHidden = true;
    	kp.Repulsors[i] = rep;
    }

    Super.PostNetBeginPlay();
}

function Died(Controller Killer, class<DamageType> damageType, vector HitLocation)
{
	local KarmaParams kp;
	local int i;

	// Destroy repulsors
	kp = KarmaParams(KParams);
	for(i=0;i<kp.Repulsors.Length;i++)
    	kp.Repulsors[i].Destroy();

    kp.Repulsors.Length = 0;

	Super.Died(Killer, damageType, HitLocation);
}

simulated event SVehicleUpdateParams()
{
	local KarmaParams kp;
	local int i;

	Super.SVehicleUpdateParams();

	kp = KarmaParams(KParams);

    for(i=0;i<kp.Repulsors.Length;i++)
	{
        kp.Repulsors[i].CheckDist = HoverCheckDist;
        kp.Repulsors[i].PenScale = HoverPenScale;
        kp.Repulsors[i].Softness = HoverSoftness;
    }

	KSetStayUprightParams( UprightStiffness, UprightDamping );
}

simulated function SpecialCalcFirstPersonView(PlayerController PC, out actor ViewActor, out vector CameraLocation, out rotator CameraRotation )
{
	ViewActor = self;

	CameraLocation = Location + (FPCamPos >> Rotation);
}

defaultproperties
{
	bZeroPCRotOnEntry=False
	bFollowLookDir=True
	bPCRelativeFPRotation=true
}
//=============================================================================
// gbxHUD
// Heads up display
//=============================================================================
class gbxHUD extends HUD
	native
	config;

#exec OBJ LOAD FILE=..\texture\t_interface_mb.utx


#exec TEXTURE IMPORT FILE=Textures\MessageWindow.tga GROUP="Icons" MIPS=OFF ALPHATEXTURE=1 COMPRESS=DXT5 PRECACHE
#exec TEXTURE IMPORT FILE=Textures\BadPaths.tga GROUP="Icons" MIPS=OFF ALPHATEXTURE=1 COMPRESS=DXT5

cpptext
{
	void AgbxHUD::RenderArc(UMaterial* Material, FLOAT U, FLOAT V, FLOAT UL, FLOAT VL, FVector& center, FLOAT radius, INT iSegments, INT nAngle, FLOAT percentage, FColor ArcColor, AHUD* aHud, UCanvas* aCanvas);
}

var() int SizeY,Count;

var gbxInspectorMan		NewestInspector;

var float IdentifyFadeTime;
var PlayerReplicationInfo IdentifyTarget;
var Pawn PawnOwner;	// pawn currently managing this HUD (may be the viewtarget of the owner rather than the owner)
var PlayerReplicationInfo ViewedInfo;
var FontInfo MyFont;
var float StartupMessageEnd;
var int StartupHeight;	// half of height in text lines of startup window
var byte StartupStage;

// Localized Messages
var HUDLocalizedMessage LocalMessages[10];

struct native SubTitleMessage
{
	var string Text;
	var color TextColor;
	var float MessageLife;
	var PlayerReplicationInfo PRI;
	var bool  fCentered;
};

var material	IconSubTitle;
var float		IconSubTitleLife;
var color		IconSubTitleColor;
var globalconfig int SubTitleCount;
var SubTitleMessage TextSubTitles[8];
var name	m_szWaitTag;
var int		m_nSubTitleX;
var int		m_nSubTitleY;
var bool	m_fShowSubTitleBackground;

var float TutIconBlink, TutDir;

var float TalkTime;
var PlayerReplicationInfo TalkPRI;

var int LastReportedTime;
var bool bStartUpMessage;
var bool bTimeValid;
var bool bAdjustPixelAspect;

var color WhiteColor;

// Identify Strings
var localized string IdentifyName, IdentifyHealth;
var localized string LiveFeed;

var float PickupTime;

var float WeaponFadeTime;
var float MessageFadeTime;
var class<CriticalEventPlus> TimeMessageClass;
var string FontInfoClass;

var int EdgeOffsetX, EdgeOffsetY;
var float LastTime, CurrentDeltaTime;

var localized string SingleWaitingMessage;
var localized string gamegoal;
var localized string TourneyMessage;
var localized string WaitingMessage1;
var localized string WaitingMessage2;
var localized string ReadyMessage;
var localized string NotReadyMessage;
var localized string StartMessage;
var localized string LoadoutMessage,LoadoutCycle;

var Material RightHud[2];
var Material LeftHud[2];

var Actor LastTraceActor;		// Who was touched in the last trace

var Texture PortraitDamageOverlays[3];
var Texture PortraitDeathOverlay;

var float			iCompassPosX;
var float			iCompassPosY;
var float			iSplitscreenCompassPosX;
var float			iSplitscreenCompassPosY;
var float			iCompassCenterOffsetX;
var float			iCompassCenterOffsetY;
var float			iObjectiveWidth;
var float			iObjectiveHeight;
var float			iSecondaryPosX;
var float			iSecondaryPosY;

enum HudMode
{
	HudModeNormal,
	HudModeWaitForKey,
	HudModeDead
};

enum ScreenEdge
{
	Left,
	Right,
	Top,
	Bottom
};

var() HudMode m_eHudMode;		// What active mode is the hud in now?

var bool		m_fMenuChoicesVisible;
var float		m_flMenuChoicesAlphaStart;
const MENU_FADE_TIME = 2.0;

var int	m_nSecondarySelectBucket;

const MAX_OBJECTIVE_BEACONS=20;
const OBJECTIVE_WAYPOINT_CALC_DELAY=0.2;
var gbxBeacons	m_ObjectiveBeacons[MAX_OBJECTIVE_BEACONS];
var float		m_flNextWaypointCalcTimer;
var Actor		m_LastObjectiveWaypoint[MAX_OBJECTIVE_BEACONS];
//var array<Pawn>	m_FriendlyPawns;
var bool		bHideWargameHUD;
var bool		bOldHideHUD;
var bool		bLimitedPlayerHUD;
var bool		bForceDrawLocalMessages; // multiplayer needs to draw local messages even when the hud is hidden 2004-06-23 JWS

var array< InWorldIcon > InWorldIcons;
var Font WargameFont;
var Font WargameFont2;
var Font WargameFontNumbers;

var int			m_nHelpOverlay;
var bool		bCheckedPathNodes;
var bool		bHasPathNodes;
var bool		bWarnAboutPath;
var bool		bOptimizedCompass;
var float		fPathWarnTimeLow;
var float		fPathWarnTimeHigh;

var class<LocalMessage> ContextUseMessage;
var	int			ContextUseSwitch;
var float		m_flContextUseLife;


var float		m_flLastHudCalc;
var int			m_nCompassYaw;

var localized string	m_szHintText;
var localized string	m_szHintMessage;

var array< gbxBaseVictoryCondition > VictoryConditions;


simulated native final function RenderArc( material Mat, float U, float V, float UL, float VL, vector Center, float Radius, int iSegments, int nAngle, float Percentage, Color ArcColor, Hud aHud, Canvas aCanvas );

function DoEdgeEffect( ScreenEdge dir, Color color, eRenderStyle rStyle, bool bForce ) {} // Override me

function PlayStartupMessage(byte Stage)
{
	StartupStage = Stage;
	StartupMessageEnd = Level.TimeSeconds + 6;
}

function DrawTextAt(Canvas Canvas, string Text, out int offset, float YL)
{
	Canvas.SetPos(0, Canvas.ClipY*0.5 + YL*(offset-StartupHeight));
	offset++;
	Canvas.DrawText(Text);
}

function int DisplayStartupMessage(Canvas Canvas, int lines)
{
	local int i;
	local float XL, YL;

	if ( StartupStage == 2 )
		return 0;
	Canvas.SetDrawColor(0,32,0);
	Canvas.Font = Font'Engine.DefaultFont';
	Canvas.TextSize( "T", XL, YL );
	Canvas.bCenter = true;
	if ( StartupStage < 2 )
	{
		Canvas.SetPos(Canvas.ClipX*0.25, Canvas.ClipY*0.5 - StartupHeight*YL);
		Canvas.DrawTile(texture'MessageWindow', Canvas.ClipX*0.5, 2*StartupHeight*YL,
							0, 0, texture'MessageWindow'.USize, texture'MessageWindow'.VSize);
	}
	Canvas.SetDrawColor(128,255,128);
	i = 1;

	if ( (StartupStage == 1) && (Level.NetMode != NM_Standalone) )
	{
		DrawTextAt(Canvas,PlayerOwner.GameReplicationInfo.GameName,i,YL);
		DrawTextAt(Canvas,LoadOutMessage@PlayerOwner.PawnClass.Default.MenuName@LoadOutCycle,i,YL);
		DrawTextAt(Canvas,WaitingMessage1,i,YL);
		DrawTextAt(Canvas,WaitingMessage2,i,YL);
		if ( PlayerOwner.PlayerReplicationInfo.bReadyToPlay )
			DrawTextAt(Canvas,ReadyMessage,i,YL);
		else
			DrawTextAt(Canvas,NotReadyMessage,i,YL);
		return i;
	}
	else if ( StartupStage == 3 )
	{
//		DrawTextAt(Canvas,StartMessage,i,YL);
		return i;
	}

	// StartupStage == 0

	DrawTextAt(Canvas,PlayerOwner.GameReplicationInfo.GameName,i,YL);

	if (PlayerOwner.PawnClass!=None)
		DrawTextAt(Canvas,LoadOutMessage@PlayerOwner.PawnClass.Default.MenuName@LoadOutCycle,i,YL);

	// Optional FragLimit
	if ( PlayerOwner.GameReplicationInfo.GoalScore > 0 )
		DrawTextAt(Canvas,PlayerOwner.GameReplicationInfo.GoalScore@GameGoal,i,YL);

	if ( Level.NetMode == NM_Standalone )
		DrawTextAt(Canvas,SingleWaitingMessage,i,YL);
	else
		DrawTextAt(Canvas,TourneyMessage,i,YL);

	return i;
}

simulated function HideHUD()
{
	bHideHUD = true;
}

simulated function ShowHUD()
{
	bHideHUD = false;
}

simulated function PostBeginPlay()
{
	local InWorldIcon icon;
	local AnimPawn		A;
	local gbxBaseVictoryCondition VC;

	Super.PostBeginPlay();
	SetTimer(1.0, True);
	PlayerOwner = PlayerController(Owner);

	if ( (PlayerOwner.GameReplicationInfo != None)
		&& (PlayerOwner.GameReplicationInfo.RemainingTime > 0) )
		TimeMessageClass = class<CriticalEventPlus>(DynamicLoadObject("gbxBase.TimeMessage", class'Class'));

	// Find and register all InWorldIcons
	foreach DynamicActors( class'InWorldIcon', icon )
	{
		RegisterInWorldIcon( icon );
	}

	// Find and register all VictoryConditions
	foreach DynamicActors( class'gbxBaseVictoryCondition', VC)
	{
		RegisterVictoryCondition(VC);
	}

	WargameFont = Font(DynamicLoadObject("t_gbxfonts.WargameFont", class'Font'));
	WargameFont2 = Font(DynamicLoadObject("t_gbxfonts.WargameFont2", class'Font'));
	WargameFontNumbers = Font(DynamicLoadObject("t_gbxfonts.WargameFontNumbers", class'Font'));

	foreach DynamicActors( class'AnimPawn', A )
	{
		if (A.bFriendlyFireListen)
		{
			m_ScriptedPawns.Length = m_ScriptedPawns.Length + 1;
			m_ScriptedPawns[ m_ScriptedPawns.Length - 1 ] = A;
		}
	}
}

simulated function UpdateSplitScreenFlag()
{
	// Get player controller and call native function
	bIsSplitScreen = PlayerOwner.IsSharingScreen();
}

simulated function HUDSetup(canvas canvas)
{
	CurrentDeltaTime = Level.TimeSeconds - LastTime;
	LastTime = Level.TimeSeconds;

	if (PlayerOwner.ViewTarget == PlayerOwner)
	{
		PawnOwner = PlayerOwner.Pawn;
	}
	else if (PlayerOwner.ViewTarget.IsA('Pawn') && Pawn(PlayerOwner.ViewTarget).Controller != None)
	{
		PawnOwner = Pawn(PlayerOwner.ViewTarget);
	}
	else if ( PlayerOwner.Pawn != None )
	{
		PawnOwner = PlayerOwner.Pawn;
	}
	else
	{
		PawnOwner = None;
	}

	if ( (PawnOwner != None) && (PawnOwner.Controller != None) )
		ViewedInfo = PawnOwner.PlayerReplicationInfo;
	else
		ViewedInfo = PlayerOwner.PlayerReplicationInfo;

	// Setup the way we want to draw all HUD elements
	Canvas.Reset();
	Canvas.SpaceX=0;
	Canvas.bNoSmooth = True;

	Style = ERenderStyle.STY_Translucent;
	Canvas.DrawColor = WhiteColor;
	Canvas.Style = Style;
	ScaleX = Canvas.ClipX/640.0;
	ScaleY = Canvas.ClipY/480.0;
	flMinScaleY = FMin( ScaleX, ScaleY );
	flMinScaleX = flMinScaleY; 
	flSplitScreenMinScaleY = FMax( ScaleX, ScaleY ); // 0.5 in splitscreen, 0.9 in singleplayer xbox
	flSplitScreenMinScaleX = flSplitScreenMinScaleY;
	Canvas.Font = Font'Engine.DefaultFont';
}

simulated function DrawBeacon(gbxBeacons B, Canvas C, gbxHud H,  float X, float Y)
{
	B.DrawBeacon(PawnOwner,C,H,X,Y);
}

simulated function DrawStatus(Canvas Canvas)
{
}

/* UseKey()
- The player has hit the use key
*/
simulated function UseKey()
{
}

simulated function ActivateSecondaryWeaponSelect()
{
}

simulated function SelectPrevSecondaryWeapon()
{
}

simulated function SelectNextSecondaryWeapon()
{
}

simulated function SelectPrevSecondaryBucket()
{
}

simulated function SelectNextSecondaryBucket()
{
}

function HideEventActors( name szEventName, bool bHidden )
{
	local	Actor	a;

	ForEach AllActors(class'Actor', a, szEventName)
	{
		a.bHidden = bHidden;
	}
}

/* MoveSelectLeft()
- Move selection to the left
*/
exec function MoveSelectLeft()
{
}

/* MoveSelectRight()
- Move selection to the right
*/
exec function MoveSelectRight()
{
}

/* MoveSelectDown()
- Move selection down
*/
exec function MoveSelectDown()
{
}

/* MoveSelectUp()
- Move selection up
*/
exec function MoveSelectUp()
{
}

simulated function DrawFrontEndMenu(Canvas Canvas)
{
}

simulated function DrawAmmo(Canvas Canvas)
{
}

simulated function DrawGameSynopsis(Canvas Canvas);

function DrawTalkFace(Canvas Canvas, int i, float YPos)
{
}

//========================================
// Master HUD render function.

simulated function DrawHUD( canvas Canvas )
{
}

function DrawSpectatingHud (Canvas C)
{
	HUDSetup(C);

	DisplaySubTitles( C, -1 );
}

function Timer()
{
	local int i;

	// Age all localized messages.
	for (i=0; i<10; i++)
	{
		// Purge expired messages.
		if ( (LocalMessages[i].Message != None) && (LocalMessages[i].Lifetime != -1) && (Level.TimeSeconds >= LocalMessages[i].EndOfLife) )
			ClearMessage(LocalMessages[i]);
	}

	// Clean empty slots.
	for (i=0; i<9; i++)
	{
		if ( LocalMessages[i].Message == None )
		{
			CopyMessage(LocalMessages[i],LocalMessages[i+1]);
			ClearMessage(LocalMessages[i+1]);
		}
	}

	if ( (PlayerOwner == None) || (PawnOwner == None) || (PlayerOwner.GameReplicationInfo == None)
		|| (ViewedInfo == None) )
		return;
}

simulated function TellTime(int num)
{
	PlayerOwner.ReceiveLocalizedMessage( TimeMessageClass, Num );
}

simulated function Tick(float DeltaTime)
{
	Super.Tick(DeltaTime);

	IdentifyFadeTime = FMax(0.0, IdentifyFadeTime - DeltaTime);

	TutIconBlink += TutDir * DeltaTime;
	if ( TutIconBlink >= 1 )
	{
		TutDir *= -1;
		TutIconBlink = 1;
	}
	else if ( TutIconBlink <= 0 )
	{
		TutDir *= -1;
		TutIconBlink = 0;
	}

	if ( MessageFadeTime < 1.0 )
	{
		MessageFadeTime += DeltaTime * 8;
		if (MessageFadeTime > 1.0)
			MessageFadeTime = 1.0;
	}

	// Check to see if we are still in splitscreen...this is needed in case we allow a player to leave a splitscreen game
	// allowing the remaining player to finish the game in fullscreen against another opponent.
	UpdateSplitScreenFlag();
}

// Entry point for string messages.
simulated function Message( PlayerReplicationInfo PRI, coerce string Msg, name MsgType )
{
	local Class<LocalMessage> MessageClass;

	if ( bMessageBeep )
		PlayerOwner.PlayBeepSound();
	switch (MsgType)
	{
		case 'Say':
			MessageClass = class'SayMessagePlus';
			break;
		case 'TeamSay':
			MessageClass = class'TeamSayMessagePlus';
			break;
		case 'CriticalEvent':
			MessageClass = class'CriticalStringPlus';
			LocalizedMessage( MessageClass, 0, None, None, None, Msg );
			return;
		case 'DeathMessage':
			MessageClass = class'StringMessagePlus';
			break;
		case 'Pickup':
			PickupTime = Level.TimeSeconds;
		default:
			MessageClass = class'StringMessagePlus';
			break;
	}

	if ( ClassIsChildOf(MessageClass, class'SayMessagePlus') ||
				     ClassIsChildOf(MessageClass, class'TeamSayMessagePlus') )
	{
		TalkTime = MessageClass.Default.Lifetime + Level.TimeSeconds;
		TalkPRI = PRI;
   		Msg = MessageClass.static.AssembleString(self, 0, PRI, Msg);
	}
	AddTextMessage(Msg,MessageClass,PRI);
}

function ClearTextSubTitles()
{
	local int i;

	IconSubTitle = None;
    for( i=0; i<SubTitleCount; i++ )
    {
        TextSubTitles[i].Text = "";
        TextSubTitles[i].MessageLife = Level.TimeSeconds;
    }
}

function AddTextSubTitle(string M, class<LocalMessage> MessageClass, PlayerReplicationInfo PRI, float LifeTime, color aColor, bool fCentered)
{
	local int i;


	if( bMessageBeep && MessageClass.Default.bBeep )
		PlayerOwner.PlayBeepSound();

    for( i=0; i<SubTitleCount; i++ )
    {
        if ( TextSubTitles[i].Text == "" )
            break;
    }

    if( i == SubTitleCount )
    {
        for( i=0; i<SubTitleCount-1; i++ )
            TextSubTitles[i] = TextSubTitles[i+1];
    }

    TextSubTitles[i].Text = M;
    TextSubTitles[i].MessageLife = Level.TimeSeconds + LifeTime;
    TextSubTitles[i].TextColor = aColor;
    TextSubTitles[i].PRI = PRI;
    TextSubTitles[i].fCentered = fCentered;
}

function AddIconSubTitle(Material Icon, float LifeTime, color IconColor)
{
    IconSubTitle = Icon;
    IconSubTitleLife = Level.TimeSeconds + LifeTime;
    IconSubTitleColor = IconColor;
}

//================================================================================
// Identify Info

simulated function bool TraceIdentify(canvas Canvas)
{
	local actor Other;
	local vector HitLocation, HitNormal, StartTrace, EndTrace;

	if ( (PawnOwner == None) || (PawnOwner != PlayerOwner.Pawn) )
		return false;

	StartTrace = PawnOwner.Location;
	StartTrace.Z += PawnOwner.BaseEyeHeight;
	EndTrace = StartTrace + vector(PlayerOwner.Rotation) * 2048.0;
	Other = Trace(HitLocation, HitNormal, EndTrace, StartTrace, true);

	LastTraceActor = other;

	if ( IdentifyFadeTime == 0.0 )
		IdentifyTarget = None;

	if ( Pawn(Other) != None )
	{
		if ( (Pawn(Other).PlayerReplicationInfo != None) && !Other.bHidden )
		{
			IdentifyTarget = Pawn(Other).PlayerReplicationInfo;
			IdentifyFadeTime = 3.0;
		}
	}
	else if ( (Other != None) && SpecialIdentify(Canvas, Other) )
		return false;

	if ( (IdentifyFadeTime == 0.0) || (IdentifyTarget == None) || (IdentifyTarget.PlayerName == "") )
		return false;

	return true;
}

simulated function bool SpecialIdentify(Canvas Canvas, Actor Other )
{
	return false;
}

simulated function SetIDColor( Canvas Canvas, int type )
{
	if ( type == 0 )
		Canvas.SetDrawColor(0,160 * (IdentifyFadeTime / 3.0),0);
	else
		Canvas.SetDrawColor(0,255 * (IdentifyFadeTime / 3.0),0);
}

simulated function DrawTwoColorID( canvas Canvas, string TitleString, string ValueString, int YStart )
{
	local float XL, YL, XOffset, X1;

	Canvas.Style = Style;
	Canvas.StrLen(TitleString$": ", XL, YL);
	X1 = XL;
	Canvas.StrLen(ValueString, XL, YL);
	XOffset = Canvas.ClipX/2 - (X1+XL)/2;
	Canvas.SetPos(XOffset, YStart);
	SetIDColor(Canvas,0);
	XOffset += X1;
	Canvas.DrawText(TitleString);
	Canvas.SetPos(XOffset, YStart);
	SetIDColor(Canvas,1);
	Canvas.DrawText(ValueString);
	Canvas.DrawColor = WhiteColor;
}


//=====================================================================
// Deal with a localized message.

simulated function LocalizedMessage( class<LocalMessage> Message, optional int Switch, optional PlayerReplicationInfo RelatedPRI_1, optional PlayerReplicationInfo RelatedPRI_2, optional Object OptionalObject, optional String CriticalString )
{
	local int i;
	local PlayerReplicationInfo HUDPRI;

	if ( bMessageBeep && Message.Default.bBeep )
		PlayerOwner.PlayBeepSound();

	if ( ClassIsChildOf(Message, class'PickupMessagePlus') )
		PickupTime = Level.TimeSeconds;

	if (ClassIsChildOf(Message, class'gbxContextUseHUDMessage'))
	{
		if (Switch < 0)  // clear the message?
		{
			ContextUseMessage = None;
			ContextUseSwitch = Switch;
		}
		else
		{
			ContextUseMessage = Message;
			ContextUseSwitch = Switch;
			if (Message.Default.Lifetime > 0)
			{
				m_flContextUseLife = Level.TimeSeconds + Message.Default.Lifetime;
			}
			else
			{
				m_flContextUseLife = Message.Default.Lifetime;
			}
		}
		return;
	}

	if (Switch == -1)
	{
		for (i=0; i<9; i++)
		{
			ClearMessage(LocalMessages[i]);
		}
		return;
	}
	
	if ( !Message.Default.bIsSpecial )
	{
		if ( ClassIsChildOf(Message, class'SayMessagePlus') ||
						 ClassIsChildOf(Message, class'TeamSayMessagePlus') )
		{
			TalkTime = Message.Default.Lifetime + Level.TimeSeconds;
			TalkPRI = RelatedPRI_1;
		}
		// Bug 12898 - support player leaving the game message 2005-03-22 JWS
		else if ( ClassIsChildOf(Message, class'GameMessage') && Switch == 4)
		{
			// This code came from UT2k4, which used this code in a more general context than that player leave messages
			if( CriticalString == "" )
			{
				if ( (PawnOwner != None) && (PawnOwner.PlayerReplicationInfo != None) )
					HUDPRI = PawnOwner.PlayerReplicationInfo;
				else
					HUDPRI = PlayerOwner.PlayerReplicationInfo;
				if ( HUDPRI == RelatedPRI_1 )
					CriticalString = Message.static.GetRelatedString( Switch, RelatedPRI_1, RelatedPRI_2, OptionalObject );
				else
					CriticalString = Message.static.GetString( Switch, RelatedPRI_1, RelatedPRI_2, OptionalObject );
			}

			AddTextMessage( CriticalString, Message, RelatedPRI_1 );
		}
		return;
	}
	else
	{
		if ( CriticalString == "" )
			CriticalString = Message.Static.GetString(Switch, RelatedPRI_1, RelatedPRI_2, OptionalObject);
		if ( Message.Default.bIsUnique )
		{
			for (i=0; i<10; i++)
			{
				if (LocalMessages[i].Message != None)
				{
					if ((LocalMessages[i].Message == Message)
						|| (LocalMessages[i].Message.Static.GetOffset(LocalMessages[i].Switch, 24, 640)
								== Message.Static.GetOffset(Switch, 24, 640)) )
					{
						LocalMessages[i].Message = Message;
						LocalMessages[i].Switch = Switch;
						LocalMessages[i].RelatedPRI = RelatedPRI_1;
						LocalMessages[i].OptionalObject = OptionalObject;
						LocalMessages[i].LifeTime = Message.Default.Lifetime;
						LocalMessages[i].EndOfLife = Message.Default.Lifetime + Level.TimeSeconds;
						LocalMessages[i].StringMessage = CriticalString;
						LocalMessages[i].DrawColor = Message.Static.GetColor(Switch, RelatedPRI_1, RelatedPRI_2);
						LocalMessages[i].StringFont = Font'Engine.DefaultFont';
						return;
					}
				}
			}
		}
		for (i=0; i<10; i++)
		{
			if (LocalMessages[i].Message == None)
			{
				LocalMessages[i].Message = Message;
				LocalMessages[i].Switch = Switch;
				LocalMessages[i].RelatedPRI = RelatedPRI_1;
				LocalMessages[i].OptionalObject = OptionalObject;
				LocalMessages[i].EndOfLife = Message.Default.Lifetime + Level.TimeSeconds;
				LocalMessages[i].StringMessage = CriticalString;
				LocalMessages[i].DrawColor = Message.Static.GetColor(Switch, RelatedPRI_1, RelatedPRI_2);
				LocalMessages[i].LifeTime = Message.Default.Lifetime;
				LocalMessages[i].StringFont = Font'Engine.DefaultFont';
				return;
			}
		}

		// No empty slots.  Force a message out.
		for (i=0; i<9; i++)
			CopyMessage(LocalMessages[i],LocalMessages[i+1]);

		LocalMessages[9].Message = Message;
		LocalMessages[9].Switch = Switch;
		LocalMessages[9].RelatedPRI = RelatedPRI_1;
		LocalMessages[9].OptionalObject = OptionalObject;
		LocalMessages[9].EndOfLife = Message.Default.Lifetime + Level.TimeSeconds;
		LocalMessages[9].StringMessage = CriticalString;
		LocalMessages[9].DrawColor = Message.Static.GetColor(Switch, RelatedPRI_1, RelatedPRI_2);
		LocalMessages[9].LifeTime = Message.Default.Lifetime;
		LocalMessages[9].StringFont = Font'Engine.DefaultFont';
		return;
	}
}

function DisplaySubTitles(Canvas C, int nPass)
{
}

/*
function DisplayMessages(canvas Canvas)
{
	local float XPos, XClip, oOX, oOY, oCX, oCY;

	XPos = 0.25 * Canvas.ClipX;
	oOX = Canvas.OrgX;
	oOY = Canvas.OrgY;
	oCX = Canvas.ClipX;
	oCY = Canvas.ClipY;

	// @@@Hack for bad ammo drawing stuff since it's so small
	if (Scale<1)
		XPos = 195;
	else
		XPos = 195*Scale;

	XClip = Canvas.ClipX - (235*Scale) - XPos ;

	Canvas.SetOrigin(XPos, 5);
	Canvas.SetClip(XClip,Canvas.ClipY);

	DisplayMessagesOld(Canvas);

	Canvas.OrgX  = oOX;
	Canvas.OrgY  = oOY;
	Canvas.ClipX = oCX;
	Canvas.ClipY = oCY;

	Canvas.Reset();
}
*/
simulated function DrawPawnTrackers(Canvas Canvas)
{
	local Pawn p,PlayerPawn;
	local vector vecPawnView;
	local float fX;
	local float fY;
	local gbxWeapon PlayerWeap;
	local vector X, Y, Z, L, V;

	PlayerPawn = PlayerOwner.Pawn;

	if (PlayerPawn==None)
		return;

	GetAxes(PlayerPawn.GetViewRotation(), X, Y, Z);

	foreach DynamicActors(Class'Pawn', p)
	{

		if ( (P!=PlayerPawn) && (!P.bInvulnerableBody) )
		{

			// Get a vector from the player to the pawn
			vecPawnView = P.Location - PlayerPawn.Location - (PlayerPawn.EyeHeight * vect(0,0,1));

			// Is he visible to the player

			if ( PawnIsVisible(vecPawnView,X,P) )
			{
				L = P.Location + ( Vect(0,0,1) * P.CollisionHeight );
				V = PlayerOwner.Player.Console.WorldToScreen(L, PlayerPawn.Location + (PlayerPAwn.EyeHeight * Vect(0,0,1)), PlayerPawn.Rotation);
				fx = V.X;
				fy = V.Y;

				// Allow the Weapon to track players as well

				PlayerWeap = gbxWeapon(PlayerPawn.Weapon);

				if ( ( (PlayerWeap==None) || (!PlayerWeap.TrackPlayer(Canvas, fX, fY, P)) ) &&
						 (PawnIsValid(vecPawnView, X, p)) && PawnIsInRange(P) )
				{
					// draw stuff!

					DrawPawnInfo(Canvas, fX, fY, p);
				}
			}
		}
	}
}

simulated function bool PawnIsVisible(vector vecPawnView, vector X, pawn P)
{
	local vector StartTrace, EndTrace;

    if ( (PawnOwner == None) || (PlayerOwner==None) )
		return false;

	if ( PawnOwner != PlayerOwner.Pawn )
		return false;

	if ( (vecPawnView Dot X) <= 0.70 )
		return false;

	StartTrace = PawnOwner.Location;
	StartTrace.Z += PawnOwner.BaseEyeHeight;

	EndTrace = P.Location;
	EndTrace.Z += P.BaseEyeHeight;

	if ( !FastTrace(EndTrace, StartTrace) )
		return false;

	return true;
}

simulated function bool PawnIsInRange(pawn P)
{
	if ( Vsize(P.Location - PawnOwner.Location) > 4096)
		return false;

	return true;
}

simulated function bool PawnIsValid(vector vecPawnView, vector X, pawn P)
{
	return false;
}

// Should be subclassed
simulated function DrawPawnInfo(Canvas canvas, float screenX, float screenY, pawn P);

simulated function DrawPercBar(Canvas Canvas, int Width, float ScreenX, float ScreenY, float Perc)
{
	local float used;
	Canvas.SetPos(ScreenX - (width/2),ScreenY);
	Canvas.SetDrawColor(255,0,0);
	Canvas.DrawRect(Texture'engine.WhiteSquareTexture', Width, 4);

	Canvas.SetPos(ScreenX - (width/2),ScreenY);
	Canvas.SetDrawColor(0,255,0);
	Used = float(Width) * Perc;
	Canvas.DrawRect(Texture'engine.WhiteSquareTexture', Used, 4);
}

simulated function RegisterInWorldIcon( InWorldIcon icon )
{
	local int ndx;

	ndx = FindInWorldIcon( icon );
	if( ndx < 0 )
	{
		InWorldIcons.Length = InWorldIcons.Length + 1;
		InWorldIcons[ InWorldIcons.Length - 1 ] = icon;
	}
}

simulated function UnregisterInWorldIcon( InWorldIcon icon )
{
	local int ndx;

	ndx = FindInWorldIcon( icon );
	if( ndx >= 0 )
	{
		InWorldIcons.Remove( ndx, 1 );
	}
}

simulated function int FindInWorldIcon( InWorldIcon icon )
{
	local int i;

	for( i = 0; i < InWorldIcons.Length; ++i )
	{
		if( InWorldIcons[ i ] == icon )
		{
			return i;
		}
	}

	return -1;
}

simulated function RegisterVictoryCondition( gbxBaseVictoryCondition VC )
{
	local int ndx;

	ndx = FindVictoryCondition( VC );
	if( ndx < 0 )
	{
		VictoryConditions.Length = VictoryConditions.Length + 1;
		VictoryConditions[ VictoryConditions.Length - 1 ] = VC;
	}
}

simulated function UnRegisterVictoryCondition( gbxBaseVictoryCondition VC )
{
	local int ndx;

	ndx = FindVictoryCondition( VC );
	if( ndx >= 0 )
	{
		VictoryConditions.Remove( ndx, 1 );
	}
}

simulated function int FindVictoryCondition( gbxBaseVictoryCondition VC )
{
	local int i;

	for( i = 0; i < VictoryConditions.Length; ++i )
	{
		if( VictoryConditions[ i ] == VC )
		{
			return i;
		}
	}

	return -1;
}

simulated event PostRender( canvas MyCanvas )
{
	local ActorLite AL;
	local Pawn P;

	HUDSetup(MyCanvas);

	if (PlayerOwner != None)
	{
		P = Pawn(PlayerOwner.ViewTarget);
		if ( (P != None) && (P.Weapon != None) && P.Weapon.IsA( 'TurretWeapon' ) )
		{
			TurretWeapon( P.Weapon ).PostRender( MyCanvas );
		}
	}

	Super.PostRender( MyCanvas );	

	if (!bCheckedPathNodes)
	{
		bCheckedPathNodes = true;

		for (AL=Level.NavigationPointList; AL!=None; AL=AL.nextNavigationPoint)
		{
			if (AL.bIsNavigationPoint)
			{
				if (NavigationPoint(AL).bPathsChanged)
				{
					bWarnAboutPath = true;
					fPathWarnTimeLow = Level.TimeSeconds + 15;	// warn in 15 seconds from now
					fPathWarnTimeHigh = fPathWarnTimeLow + 3;	// warn for 3 seconds
				}

				bHasPathNodes = true;
			}
			else if (AL.bIsNavigationPointLite)
			{
				if (NavigationPointLite(AL).bPathsChanged)
				{
					bWarnAboutPath = true;
					fPathWarnTimeLow = Level.TimeSeconds + 15;	// warn in 15 seconds from now
					fPathWarnTimeHigh = fPathWarnTimeLow + 3;	// warn for 3 seconds
				}

				bHasPathNodes = true;
			}
		}
	}

	if ((bHasPathNodes) && (bWarnAboutPath))
	{
		if ((fPathWarnTimeLow < Level.TimeSeconds) && (fPathWarnTimeHigh > Level.TimeSeconds))
		{
			MyCanvas.SetPos( 40, (MyCanvas.ClipY / 2) - 32 );
			MyCanvas.DrawTile(texture'BadPaths', 128, 64, 0, 0, texture'BadPaths'.USize, texture'BadPaths'.VSize);
		}
		else if (fPathWarnTimeHigh < Level.TimeSeconds)
		{
			fPathWarnTimeLow = Level.TimeSeconds + 15;	// warn again in 15 seconds
			fPathWarnTimeHigh = fPathWarnTimeLow + 3;	// warn for 3 seconds
		}
	}
}

exec function AdjustPixelAspect()
{
	bAdjustPixelAspect = !bAdjustPixelAspect;
}

simulated function DisplayPawnDamagedInspector( gbxPawn hurtPawn )
{
	local gbxInspectorMan myInspectorMan;

	if (hurtPawn == None)
		return;

	hurtPawn = hurtPawn.GetInspectorPawn();  // allow this Pawn to provide an inspector replacement

	// Is there already an inspector up about this guy?
	myInspectorMan = FindInspectorRegardingObject( hurtPawn );

	if( myInspectorMan != None )
	{
		// He's already displayed. Refresh his time.
		myInspectorMan.ExtendLife();
	}
	else
	{
		myInspectorMan = GetNewInspector();

		if( myInspectorMan != None )
		{
			// Show the new one, but wait for the blocking inspector to get out of the way.
			myInspectorMan.ShowPanel( hurtPawn, hurtPawn.myInspectorClass, 0.5 );
		}
	}
}

simulated function DisplayPawnDeathInspector( gbxPawn deadPawn )
{
	local gbxInspectorMan myInspectorMan;

	if (deadPawn == None)
		return;

	deadPawn = deadPawn.GetInspectorPawn();  // allow this Pawn to provide an inspector replacement

	// Is there already an inspector up about this guy?
	myInspectorMan = FindInspectorRegardingObject( deadPawn );

	if( myInspectorMan != None )
	{
		// If this inspector has not yet been demoted, just re-use it.
		// Otherwise, hide it and make a new one.

		if(( myInspectorMan.transitionState != TS_Hiding && myInspectorMan.transitionState != TS_FadingOut && myInspectorMan.transitionState != TS_None ) &&
			 myInspectorMan.DemotionLevel <= 0 )
		{
			myInspectorMan.ExtendLife( true );
			return;
		}
		else
		{
			myInspectorMan.Hide( 0.125 );		// Hide the old one.
		}
	}

	myInspectorMan = GetNewInspector();

	if( myInspectorMan != None )
	{
		myInspectorMan.ShowPanel( deadPawn, deadPawn.myInspectorClass, 0.5,, true /*fade out rather than hide*/ );	
	}
}

simulated function gbxInspectorMan FindInspectorRegardingObject( Object anObject )
{
	local gbxInspectorMan myInspectorMan;

	if( anObject == None )
	{
		return None;
	}

	for( myInspectorMan = NewestInspector; myInspectorMan != None; myInspectorMan = myInspectorMan.OlderInspector )
	{
		if(( myInspectorMan.IsVisible() || myInspectorMan.IsWaiting() ) && 
			 (myInspectorMan.myPanelObject == anObject))
		{
			return myInspectorMan;
		}
	}

	return None;
}

simulated function UpdateInspectors( Canvas aCanvas )
{
	local gbxInspectorMan myInspectorMan, myStandIn, blockingInspector;
	local int iListOrder;
	
	// Find any blocking (non-demotable) inspector.

	for( blockingInspector = NewestInspector; blockingInspector != None; blockingInspector = blockingInspector.OlderInspector )
	{
		if( !blockingInspector.IsDemotable() )
		{
			// Found one.
			break;
		}
	}


	myInspectorMan = NewestInspector;

	while( myInspectorMan != None )
	{
		if (myInspectorMan.myHud == None) 
		{
			myInspectorMan.myHud = Self;
		}

		// Skip until we find the blocking inspector.
		if( blockingInspector != None && blockingInspector != myInspectorMan )
		{
			myInspectorMan = myInspectorMan.OlderInspector;
			continue;
		}

		// We only reach here once we're ready to start drawing inspectors, because the current one
		// is either the blocker or someone below him.
		blockingInspector = None;

		myInspectorMan.StopWaiting();

		// Draw the inspector.
		myInspectorMan.DrawGBXHud( aCanvas, Self, MyFont, iListOrder );
		++iListOrder;

		if( myInspectorMan.WantsDelete() )
		{
			myStandIn = myInspectorMan.OlderInspector;

			if( myInspectorMan == NewestInspector )
			{
				NewestInspector = myInspectorMan.OlderInspector;
			}

			myInspectorMan.SoonToBeDeleted();

			delete( myInspectorMan );
			myInspectorMan = myStandIn;
		}
		else
		{
			myInspectorMan = myInspectorMan.OlderInspector;
		}
	}

//	LogInspectors();
}
/*
simulated function LogInspectors()
{
	local gbxInspectorMan myInspectorMan;
	Log( self $ ".LogInspectors() vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv", 'jmw' );
	for( myInspectorMan = NewestInspector; myInspectorMan != None; myInspectorMan = myInspectorMan.OlderInspector )
	{
		Log( myInspectorMan $ ": demotion= " $ myInspectorMan.DemotionLevel $ " newer = " $ myInspectorMan.NewerInspector, 'jmw' );
	}
	Log( self $ ".LogInspectors() ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^", 'jmw' );
}
*/

simulated function gbxInspectorMan GetNewInspector()
{
	local gbxInspectorMan newInspectorMan;
		
	newInspectorMan = new( None ) class'gbxBase.gbxInspectorMan';

	if( newInspectorMan == None )
	{
		Log( self $ ".GetNewInspector(): ERROR: new( None ) class'gbxBase.gbxInspectorMan' refused; try increasing gbxInspectorMan pool size." );
		return None;
	}

	newInspectorMan.myHud = self;

	newInspectorMan.OlderInspector = NewestInspector;
	if( NewestInspector != None )
	{
		NewestInspector.NewerInspector = newInspectorMan;
	}
	NewestInspector = newInspectorMan;

	return newInspectorMan;
}

simulated function RemoveInspector(Object ObjectToRemove)
{
	local gbxInspectorMan pInspectorMan;

	// walk the doublely linked-list looking for a match...
	pInspectorMan = NewestInspector;

	while (pInspectorMan != None)
	{
		if (pInspectorMan.myPanelObject == ObjectToRemove)
		{
			// see if this is the first item in the list...
			if (pInspectorMan.NewerInspector == None)  // no previous item?
			{
				NewestInspector = pInspectorMan.OlderInspector;
				pInspectorMan.SoonToBeDeleted();  // unlink this from the list
				delete( pInspectorMan );
				break;
			}
			else  // else, just unlink it from the list
			{
				pInspectorMan.SoonToBeDeleted();  // unlink this from the list
				delete( pInspectorMan );
				break;
			}
		}
		pInspectorMan = pInspectorMan.OlderInspector;
	}
}

simulated function ResetInspectors()
{
	local gbxInspectorMan myInspectorMan;
	for( myInspectorMan = NewestInspector; myInspectorMan != None; myInspectorMan = myInspectorMan.OlderInspector )
	{
		myInspectorMan.Reset();
	}
}

// Lame stubs to solve package dependency problems
function SetTrainingText(string Text, float lifetime, bool bShowInOracleCam);
function string ConvertToButtonizedMessage(string Message);

simulated function SetHUDClock( float flBombClockTime );

function ClearObjectiveOverlay();
function SetObjectiveString( string szObjString, EObjectiveComplete bObjComplete, float flObjStringTime, bool bObjPrimary, bool bCriticalMessage );

defaultproperties
{
	StartMessage="Brothers in Arms"
    TourneyMessage="Waiting for other players."
    WaitingMessage1="Waiting for ready signals."
	WaitingMessage2="(Use your fire button to toggle ready!)"
	SingleWaitingMessage="Press Fire to start."
	gamegoal="frags wins the match."
    ReadyMessage="You are READY!"
    NotReadyMessage="You are NOT READY!"
	EdgeOffsetX=16
	EdgeOffsetY=16
	Style=3
	IdentifyName="Name:"
	IdentifyHealth="Health:"
	bStartUpMessage=True
	WhiteColor=(R=181,G=181,B=153,A=255)
	LiveFeed="Live Feed from "
	TimeMessageClass=class'TimeMessage'
	TutDir=+1.0
	FontInfoClass="Engine.FontInfo"
	StartupHeight=3
	LoadOutMessage="Loadout:"
	LoadOutCycle=" (F7 cycles)."
//	RightHud(0)=material'WG_HUD.HUD.map_01'
//	RightHud(1)=material'WG_HUD.HUD.map_01'
//	LeftHud(0)=material'WG_HUD.HUD.ammo_holder'
//	LeftHud(1)=material'WG_HUD.HUD.ammo_holder'

    SubTitleCount=4

	m_nSubTitleX=200
	m_nSubTitleY=250
	m_fShowSubTitleBackground=true

	bCheckedPathNodes=false
	bHasPathNodes=false
	bWarnAboutPath=false
	fPathWarnTimeLow=-1
	fPathWarnTimeHigh=-1

	bOptimizedCompass=false
	bAdjustPixelAspect=true

	flSplitScreenScale = 0.75
	bIsSplitScreen = false

	PortraitDamageOverlays[0]=texture't_interface_mb.head_shots.damage_lvl_1'
	PortraitDamageOverlays[1]=texture't_interface_mb.head_shots.damage_lvl_2'
	PortraitDamageOverlays[2]=texture't_interface_mb.head_shots.damage_lvl_3'

	PortraitDeathOverlay=Texture't_interface_mb.HUD.dead_x'

	m_szHintText="Hint"
}
//=============================================================================
// gbxInspectorBeacon
// Handles displaying the objective inspector
//=============================================================================
class gbxInspectorBeacon extends gbxInspectorPanel;

const OBJECTIVE_MAP_WIDTH = 192;
const OBJECTIVE_MAP_HEIGHT = 160;

const OBJECTIVE_BORDER = 8;

const OBJECTIVE_LIST_HEIGHT = 30;

static function DrawGBXHud( canvas Canvas, object drawObject, gbxInspectorMan mgr, float offsetX, float offsetY, int nPass, float alpha, float timeSinceShow )
{
	local class<gbxInspectorPanel> drawInspectorClass;
	local gbxBeacons drawBeacon;

	drawBeacon = gbxBeacons( drawObject );

	if (nPass == 0)
	{
		DrawStylizedBackground(Canvas, mgr.myHud, offsetX, offsetY, alpha);

        // overview map
		if ( drawBeacon.m_ObjectiveImage != None )
		{
			Canvas.SetDrawColor(255,255,255,255);
			Canvas.SetPos((offsetX+OBJECTIVE_BORDER)*mgr.myHud.ScaleX, (offsetY+OBJECTIVE_LIST_HEIGHT+(OBJECTIVE_BORDER*2))*mgr.myHud.ScaleY);
			Canvas.DrawTile( drawBeacon.m_ObjectiveImage, OBJECTIVE_MAP_WIDTH*mgr.myHud.ScaleX, OBJECTIVE_MAP_HEIGHT*mgr.myHud.ScaleY, 0, 0, 512, 512);
		}
	}
	else 
	{
		drawInspectorClass = class<gbxInspectorPanel>(DynamicLoadObject("gbxGameplay.gbxInspectorObjectiveList", class'Class'));
		drawInspectorClass.Static.DrawGBXHud( Canvas, drawObject, mgr, offsetX+OBJECTIVE_BORDER, offsetY+OBJECTIVE_BORDER, nPass, alpha, timeSinceShow );

		// This should eventually call the hints inspector panel
		//offsetY += OBJECTIVE_MAP_HEIGHT + 2*OBJECTIVE_MAP_BORDER;
	}
}

defaultproperties
{
	myWidth=212
	myHeight=280
}
//=============================================================================
// gbxInspectorMan
// Manages the animation and display of one Inspector panel at a time.
//=============================================================================
class gbxInspectorMan extends Object
	transient
	poolable( 7, 7 );

const DEF_SHOWHIDE_TIME = 0.25;
const DEF_SHOW_DURATION = 3.0;
const MIN_DEMOTION_TIME = 0.75;		// The minimum amount of time a panel can be shown before being demoted.

enum ETransitionState
{
	TS_None,				// not doing anything (in effect, hidden)
	TS_Waiting,				// Wanting to show, but blocked because too much real-estate taken up by prior inspectors
	TS_Showing,				// becoming visible from off-screen, in ShowHideTime seconds
	TS_Show,				// fully visible for ShowDuration seconds
	TS_Hiding,				// becoming hidden to off-screen, in ShowHideTime seconds
	TS_FadingOut,			// becoming hidden through alpha-fade, in ShowHideTime seconds
};

var ETransitionState		transitionState;
var float 					TimeStart;			// the universaltimeseconds when we started the current action
var float					TimeShowStart;		// the universaltimeseconds when we started the show state, regardless of our current state.
var float					ShowHideTime;
var float					ShowDuration;
var float 					transitionFraction;	// 0.0=begin - 1.0=end
var gbxHUD					myHud;				// HUD that this inspector belongs to

var int						DemotionLevel;
var float					CurDemotionOffset;
var float					DemotionTimeStart;
const						DEMOTION_TRANSITION_TIME = 0.25;

var gbxInspectorMan			OlderInspector;
var gbxInspectorMan			NewerInspector;

var bool					bWantFade;
var bool					bNoSelfDelete;

var	class<gbxInspectorPanel>	myPanelClass;		// class of panel being displayed
var	object						myPanelObject;		// object being displayed, to pass to myPanelClass


// un-scaled offset of this manager
// for a right-edge show/hide, myX should be the right edge
var float					myX, myY;

simulated function bool IsVisible()
{
	return (myPanelClass != None) && (transitionState != TS_None) && (transitionState != TS_Waiting);
}

simulated function bool IsWaiting()			// Waiting for other panels to be demoted before being shown?
{
	return transitionState == TS_Waiting;
}

simulated function StopWaiting()			// Don't wait no more.
{
	if( !IsWaiting() )
	{
		return;
	}

	// set to showing.
	transitionState = TS_Showing;
	TimeStart = myHud.PlayerOwner.Level.UniversalTimeSeconds;

	// if immediate, go ahead and update now
	if (ShowHideTime == -1.0)
	{
		Update();
	}
}

simulated function bool IsDemotable()		// Willing to be demoted?
{
	// Can't be demoted if I was "just shown" -- that is, shown and less than MIN_DEMOTION_TIME seconds have passed.
	return !( transitionState == TS_Show && ( myHud.PlayerOwner.Level.UniversalTimeSeconds - TimeStart ) < MIN_DEMOTION_TIME );
}

simulated function bool WantsDelete()
{
	if( bNoSelfDelete )
	{
		return false;
	}
	else
	{
		return !IsVisible() && !IsWaiting();
	}
}

simulated function Reset()
{
	Hide(-1);
}

simulated function ShowPanel(object panelObject, class<gbxInspectorPanel> panelClass, optional float show_time, optional float show_duration, optional bool bFade )
{
	ShowHideTime = show_time;
	ShowDuration = show_duration;
	myPanelClass = panelClass;
	myPanelObject = panelObject;

	bWantFade = bFade;

	if (ShowHideTime == 0.0) ShowHideTime = DEF_SHOWHIDE_TIME;
	if (ShowDuration == 0.0) ShowDuration = DEF_SHOW_DURATION;

	// Prepare to wait.
	TimeStart = myHud.PlayerOwner.Level.UniversalTimeSeconds;
	transitionState = TS_Waiting;
}

simulated function ExtendLife( optional bool bFade )
{
	if( transitionState == TS_Show )
	{
		TimeStart = myHud.PlayerOwner.Level.UniversalTimeSeconds;
		TimeShowStart = TimeStart;
	}
	else if( transitionState == TS_Hiding || transitionState == TS_FadingOut )
	{
		transitionState = TS_Showing;
	}

	bWantFade = bFade;
}

simulated function Hide(optional float hide_time)
{
	if (transitionState == TS_Hiding || transitionState == TS_FadingOut)
	{
		ShowHideTime = -1;
		Update();
	}
	else
	{
		ShowHideTime = hide_time;
		if (ShowHideTime == 0.0) ShowHideTime = DEF_SHOWHIDE_TIME;

		// set to hiding.
		if( bWantFade )
		{
			transitionState = TS_FadingOut;
		}
		else
		{
			transitionState = TS_Hiding;
		}

		TimeStart = myHud.PlayerOwner.Level.UniversalTimeSeconds;
		transitionFraction = 0;

		// if immediate, go ahead and update now
		if (ShowHideTime == -1.0)
		{
			Update();
		}
	}
}

simulated function Update()
{
	local float transitionDelta;

	if (TimeStart == 0.0) return;	// bail if nothing to update

	transitionDelta = myHud.PlayerOwner.Level.UniversalTimeSeconds - TimeStart;

	switch(transitionState)
	{
	case TS_Showing:
		if (ShowHideTime == -1)
			transitionFraction = 1.0;
		else
			transitionFraction = FClamp(transitionDelta / ShowHideTime, 0.0, 1.0);

		if (transitionFraction == 1.0)
		{
			transitionState = TS_Show;
			if (ShowDuration != -1)
				TimeStart = myHud.PlayerOwner.Level.UniversalTimeSeconds;
			else
				TimeStart = 0.0;

			TimeShowStart = TimeStart;

		}
		break;

	case TS_Show:
		if (ShowDuration != -1)
		{
			transitionFraction = FClamp(transitionDelta / ShowDuration, 0.0, 1.0);
			
			if (transitionFraction == 1.0)
			{
				Hide(ShowHideTime);
			}
		}
		break;

	case TS_Hiding:
	case TS_FadingOut:
		if (ShowHideTime == -1)
			transitionFraction = 1.0;
		else
			transitionFraction = FClamp(transitionDelta / ShowHideTime, 0.0, 1.0);

		// finished hiding
		if (transitionFraction == 1.0)
		{
			transitionState = TS_None;
			TimeStart = 0.0;
			myPanelClass = None;
			myPanelObject = None;
		}
		break;

	case TS_None:
		TimeStart = 0.0;
		break;
	}
}

simulated function float GetLerpPos(float visible_pos, float hidden_pos)
{
	local float result;

	switch(transitionState)
	{
	case TS_Showing:
		result = hidden_pos + (visible_pos-hidden_pos)*transitionFraction;
		break;

	case TS_Show:
	case TS_FadingOut:
		result = visible_pos;
		break;

	case TS_Hiding:
		result = visible_pos - (visible_pos-hidden_pos)*transitionFraction;
		break;

	case TS_Waiting:
	case TS_None:
		result = hidden_pos;
	}

	return result;
}

simulated function float GetLerpAlpha()
{
	switch(transitionState)
	{
	case TS_FadingOut:
		return 1.0 - transitionFraction;
	}

	return 1.0;
}

simulated function UpdateDemotionLevel( int newDemotionLevel )
{
	if( DemotionLevel != newDemotionLevel )
	{
		if( transitionState == TS_FadingOut || transitionState == TS_Hiding )
		{
			// Only allow downward movement in these states.
			if( newDemotionLevel < DemotionLevel )
			{
				return;
			}
		}

		DemotionLevel = newDemotionLevel;

		DemotionTimeStart = myHud.PlayerOwner.Level.UniversalTimeSeconds;

		if( DemotionLevel > 3 )
		{
			// REALLY demoted. Just go away.
			Log( "Demote(): Reset.", 'jmw' );
			Reset();
		}
		else if( DemotionLevel > 2 )
		{
			Log( "Demote(): Hide.", 'jmw' );
			Hide();
		}
	}
}

simulated function DrawGBXHud( canvas Canvas, gbxHud Hud, FontInfo Fonts, int newDemotionLevel )
{
	local float offsetX, offsetY, timeSinceShow, demotionTransitionFraction, demotionAlpha, x0;
	local int iPass;

	if (myPanelClass == None) return;

	Canvas.Font = Hud.WargameFont;

	Update();

	if( transitionState==TS_None || transitionState==TS_Waiting )
	{
		return;
	}

	if( transitionState == TS_Show || transitionState == TS_Hiding || transitionState == TS_FadingOut )
	{
		timeSinceShow = myHud.PlayerOwner.Level.UniversalTimeSeconds - TimeShowStart;
	}

	UpdateDemotionLevel( newDemotionLevel );

	// ok we're only going to handle show/hide from right edge for now...

	demotionTransitionFraction = FClamp(( myHud.PlayerOwner.Level.UniversalTimeSeconds - DemotionTimeStart ) / DEMOTION_TRANSITION_TIME, 0.0, 1.0 );
	demotionAlpha = 1.0;
	if( DemotionLevel > 0 )
	{
		demotionAlpha = 0.5;
	}

	CurDemotionOffset = Lerp( demotionTransitionFraction, CurDemotionOffset, DemotionLevel * 100 );

	X0 = (Canvas.SafeOffX + Canvas.SafeSizeX) / Hud.ScaleX;
	offsetY = (Canvas.SafeOffY / Hud.ScaleY) + 60 + CurDemotionOffset;
	offsetX = GetLerpPos( x0 - myPanelClass.Default.myWidth, x0);	// leave a 20 unit border area

	if( GetLerpAlpha() * demotionAlpha > 1.0 / 255 )
	{
		for( iPass = 0; iPass < 2; iPass++ )
		{
			myPanelClass.static.DrawGBXHud( Canvas, myPanelObject, self, offsetX, offsetY, iPass, GetLerpAlpha() * demotionAlpha, timeSinceShow );
		}
	}
}

simulated function SoonToBeDeleted()
{
	if( OlderInspector != None )
	{
		OlderInspector.NewerInspector = NewerInspector;
	}

	if( NewerInspector != None )
	{
		NewerInspector.OlderInspector = OlderInspector;
	}
}

defaultproperties
{
	myX=592
	myY=64
}//=============================================================================
// gbxInspectorPanel
// Base class that handles the display of an inspector
//=============================================================================
class gbxInspectorPanel extends object
	transient;

var float				myWidth, myHeight;	// in 640x480 units

enum EGenTextJust
{
	TJ_LEFT_TOP,
	TJ_CENTER,
	TJ_BOTTOM_RIGHT,
};

static function DrawGenericText( Canvas C, gbxHUD Hud, string text, float posX, float posY, float scale, optional EGenTextJust justX, optional EGenTextJust justY)
{
	local float XL, YL, sX, sY;

	sX = scale * Hud.ScaleX;
	sY = scale * Hud.ScaleY;
	posX *= Hud.ScaleX;
	posY *= Hud.ScaleY;

	C.StrLen(text, XL, YL, sX, sY);
	switch(justX)
	{
	case TJ_LEFT_TOP: break;

	case TJ_CENTER:
		posX -= (XL/2);
		break;

	case TJ_BOTTOM_RIGHT:
		posX -= XL;
		break;
	}
	switch(justY)
	{
	case TJ_LEFT_TOP: break;

	case TJ_CENTER:
		posY -= (YL/2);
		break;

	case TJ_BOTTOM_RIGHT:
		posY -= YL;
		break;
	}

	C.SetPos( posX, posY );
	C.DrawTextClipped( text, false, sX, sY );
}

static function float GetWidth( optional gbxHUD Hud )
{
	if (Hud != None)
		return Default.myWidth*Hud.ScaleX;
	else
		return Default.myWidth;
}

static function float GetHeight( optional gbxHUD Hud )
{
	if (Hud != None)
		return Default.myHeight*Hud.ScaleY;
	else
		return Default.myHeight;
}

static function DrawStylizedBackground(canvas Canvas, gbxHUD Hud, float offsetX, float offsetY, float alpha)
{
	Canvas.SetPos(offsetX*Hud.ScaleX, offsetY*Hud.ScaleY);

	Canvas.SetDrawColor(0, 0, 0, alpha * 92 );
	Canvas.DrawTileTiledClip(	Texture't_interface_mb.hud.interface_comp', 
								(645 - offsetX)*Hud.ScaleX, Default.myHeight*Hud.ScaleY, 
								284, 128, 128, 128,
								32, 32);
}

static function DrawGBXHud( canvas Canvas, object drawObject, gbxInspectorMan mgr, float offsetX, float offsetY, int nPass, float alpha, float timeSinceShow )
{
	DrawStylizedBackground(Canvas, mgr.myHud, offsetX, offsetY, alpha);
}

defaultproperties
{
	myWidth=220
	myHeight=240
}
//=============================================================================
// gbxInspectorPawn
//=============================================================================
class gbxInspectorPawn extends gbxInspectorPanel;

var float				myNameScale;


const DEF_BARGRAPH_WIDTH = 100.0;
const DEF_BARGRAPH_HEIGHT = 20.0;

static function DrawPawnHealthBar( canvas Canvas, gbxPawn drawPawn, gbxHud Hud, float offsetX, float offsetY, float alpha, optional float length, optional float thickness, optional bool bVertical )
{
	local float healthFrac;
	local float dX, dY;
	local float w, h;
	local Rotator myRot;

	// if drawing a vertical bar, calculate the rotation
	// and also adjust the offset so upper left becomes lower left
	if (bVertical)
	{
		myRot = Rot(0,-16384,0);
		offsetY += length;
	}

	offsetX *= Hud.ScaleX;
	offsetY *= Hud.ScaleY;

	if (length == 0)
	{
		length = 1.0;
	}
	else
	{
		length = length / DEF_BARGRAPH_WIDTH;
	}
	if (thickness == 0)
	{
		thickness = 1.0;
	}
	else
	{
		thickness = thickness / DEF_BARGRAPH_HEIGHT;
	}

	healthFrac = float( drawPawn.Health ) / float( drawPawn.default.Health );
	
	healthFrac = FClamp( healthFrac, 0.0, 1.0);
	
	w = 100*length;
	h = 20*thickness;

	Canvas.SetDrawColor(26,20,14,175 * alpha);
	Canvas.SetPos(offsetX, offsetY);
	if (bVertical)
		Canvas.DrawTileRotated(material't_interface_mb.hud.interface_comp',w*Hud.ScaleY,h*Hud.ScaleX,412,205,65,31, offsetX, offsetY, myRot);
	else
		Canvas.DrawTile(material't_interface_mb.hud.interface_comp',w*Hud.ScaleX,h*Hud.ScaleY,412,205,65,31);

	dX = offsetX + (3 * Hud.ScaleX);
	dY = offsetY + (3 * Hud.ScaleY);
	w = 90*length;
	h = 14*thickness;
	Canvas.SetDrawColor(52,40,28,175 * alpha);
	Canvas.SetPos(dX, dY);
	if (bVertical)
		Canvas.DrawTileRotated(material't_interface_mb.hud.interface_comp',w*Hud.ScaleY,h*Hud.ScaleX, 412,205,65,31, offsetX, offsetY, myRot);
	else
		Canvas.DrawTile(material't_interface_mb.hud.interface_comp',w*Hud.ScaleX,h*Hud.ScaleY, 412,205,65,31);

	// get the color
	if (healthFrac < 0.3)
		Canvas.SetDrawColor(185, 48, 38, alpha * 255);
	else if (healthFrac < 0.5)
		Canvas.SetDrawColor(223,95,28, alpha * 255);
	else if (healthFrac < 0.8)
		Canvas.SetDrawColor(193,188,44, alpha * 255);
	else
		Canvas.SetDrawColor(107,147,28, alpha * 255);

	w = w*healthFrac;

	Canvas.SetPos(dX, dY);
	if (bVertical)
		Canvas.DrawTileRotated(material't_interface_mb.hud.interface_comp',w*Hud.ScaleY,h*Hud.ScaleX,412,205,(65 * healthFrac),31, offsetX, offsetY, myRot);
	else
		Canvas.DrawTile(material't_interface_mb.hud.interface_comp',w*Hud.ScaleX,h*Hud.ScaleY,412,205,(65 * healthFrac),31);
}

static function DrawPortraitDamageOverlay( canvas Canvas, gbxPawn drawPawn, gbxHud Hud, float offsetX, float offsetY, float alpha )
{
	local float healthFrac;
	local int damageIndex;

	if ( drawPawn.Portrait != None )
	{
		healthFrac = float( drawPawn.Health ) / 100.0;
		healthFrac = FClamp( healthFrac, 0.0, 100.0);

		// Scale damage overlays if necessay
		damageIndex = GetDamageOverlayIndex(drawPawn);
		if ( damageIndex >= 0 )
		{
			Canvas.SetDrawColor(255,255,255,255 * alpha);
			Canvas.SetPos(offsetX*Hud.ScaleX, offsetY*Hud.ScaleY);

			if( !Hud.bIsSplitScreen )
			{
				Canvas.DrawTile(Hud.PortraitDamageOverlays[damageIndex], 64*Hud.ScaleX, 64*Hud.ScaleY, 0, 0, 64, 64);
			}
			else
			{
				Canvas.DrawTile(Hud.PortraitDamageOverlays[damageIndex], 48*Hud.flSplitScreenScale, 48*Hud.flSplitScreenScale, 0, 0, 64, 64);
			}
		}
	}
}

static function DrawDeathSymbol( canvas Canvas, gbxPawn drawPawn, gbxHud Hud, float offsetX, float offsetY, float scale, float alpha )
{
	Canvas.SetDrawColor(255,255,255,255 * alpha );
	Canvas.SetPos((offsetX - 32 * ( scale - 1 ))*Hud.ScaleX, (offsetY - 32 * ( scale - 1 ))*Hud.ScaleY);

	if( !Hud.bIsSplitScreen )
	{
		Canvas.DrawTile(Hud.PortraitDeathOverlay, 64*Hud.ScaleX * scale, 64*Hud.ScaleY * scale, 0, 0, 64, 64);
	}
	else
	{
		Canvas.DrawTile(Hud.PortraitDeathOverlay, 48*Hud.flSplitScreenScale * scale, 48*Hud.flSplitScreenScale * scale, 0, 0, 64, 64);
	}
}

static function DrawDeathSymbolScaled( canvas Canvas, gbxPawn drawPawn, gbxHud Hud, float offsetX, float offsetY, float scaleX, float scaleY, float alpha )
{
	Canvas.SetDrawColor(255,255,255,255 * alpha );
	Canvas.SetPos((offsetX - 32 * ( scaleX - 1 ))*Hud.ScaleX, (offsetY - 32 * ( scaleY - 1 ))*Hud.ScaleY);

	if( !Hud.bIsSplitScreen )
	{
		Canvas.DrawTile(Hud.PortraitDeathOverlay, 64*Hud.ScaleX * scaleX, 64*Hud.ScaleY * scaleY, 0, 0, 64, 64);
	}
	else
	{
		Canvas.DrawTile(Hud.PortraitDeathOverlay, 48*Hud.flSplitScreenScale * scaleX, 48*Hud.flSplitScreenScale * scaleY, 0, 0, 64, 64);
	}
}

static function int GetDamageOverlayIndex( gbxPawn drawPawn )
{
	local float healthFrac;

	healthFrac = float( drawPawn.Health ) / 100.0;
	healthFrac = FClamp( healthFrac, 0.0, 100.0);

	// get the overlay material
	if (healthFrac < 0.3)
		return 2;
	else if (healthFrac < 0.5)
		return 1;
	else if (healthFrac < 0.8)
		return 0;
	else
		return -1;
}

defaultproperties
{
	myNameScale=0.9
	myWidth=145
	myHeight=66
}
class gbxInspectorTankUnit extends gbxInspectorUnit;

defaultproperties
{
	myWidth=165
	myHeight=290
	subIndent=0
}//=============================================================================
// gbxInspectorUnit
// Displays the pawn inspectors for members of this unit
//=============================================================================
class gbxInspectorUnit extends gbxInspectorPanel;

var float subIndent;

static function bool ShouldDrawInspectorForTeam(PlayerController owner, ETeamIdentifier team)
{
	local bool rslt;

	rslt = false;
	if ( team == TEAM_US )
	{
		rslt = true;
	}

	return rslt;
}

static function DrawGBXHud( canvas Canvas, object drawObject, gbxInspectorMan mgr, float offsetX, float offsetY, int nPass, float alpha, float timeSinceShow )
{
	local Unit drawUnit;
	local int i,count,spacing,swapMemberIndex;
	local float drawOffset;
	local class<gbxInspectorPanel> drawInspectorClass;
	local gbxPawn swapMember;

	drawUnit = Unit(drawObject);
	count = Min(drawUnit.NumMembers,3);

	// Find the index of the team leader
	for( i = 0; i < count; i++ )
	{
		if( drawUnit.Members[i].Health > 0 && drawUnit.Members[i] == drawUnit.Leader )
		{
			swapMemberIndex = i;
			break;
		}
	}

	// Move the team leader to the top, if necessary
	if( swapMemberIndex > 0 )
	{
		swapMember = drawUnit.Members[0];
		drawUnit.Members[0] = drawUnit.Members[swapMemberIndex];
		drawUnit.Members[swapMemberIndex] = swapMember;
	}

	drawOffset = offsetY;

	if ( ShouldDrawInspectorForTeam(Canvas.Viewport.Actor, drawUnit.Members[0].PawnTeam) )
	{
		for (i=0; i < count; i++)
		{
			if( drawUnit.Members[i].Health <= 0 )
			{
				// Units don't draw dead members.
				continue;
			}

			drawInspectorClass = drawUnit.Members[i].myInspectorClass;

			spacing = (default.myHeight - drawInspectorClass.Default.myHeight * 3) / 2;

			if (drawInspectorClass != None)
			{
				if( i == 0 )
				{
					drawInspectorClass.Static.DrawGBXHud( Canvas, drawUnit.Members[i], mgr, offsetX, drawOffset, nPass, alpha, timeSinceShow );
				}
				else
				{
					drawInspectorClass.Static.DrawGBXHud( Canvas, drawUnit.Members[i], mgr, offsetX + default.subIndent, drawOffset, nPass, alpha, timeSinceShow );
				}

				drawOffset += drawInspectorClass.Default.myHeight + spacing;
			}
		}
	}
	else
	{
		drawInspectorClass = drawUnit.Members[0].myInspectorClass;

		if (drawInspectorClass != None)
		{
			drawInspectorClass.Static.DrawGBXHud( Canvas, drawUnit, mgr, offsetX, drawOffset, nPass, alpha, timeSinceShow );
		}
	}
}

defaultproperties
{
	myWidth=145
	myHeight=290
	subIndent=16
}
//=============================================================================
// gbxInspectorUnitMP
// Displays the pawn inspectors for members of this unit
//=============================================================================
class gbxInspectorUnitMP extends gbxInspectorUnit;

static function bool ShouldDrawInspectorForTeam(PlayerController owner, ETeamIdentifier team)
{
	local bool rslt;

	rslt = false;
	if ( (owner != None) && (Owner.Pawn != None) )
	{
		if (Owner.Pawn.PawnTeam == team)
		{
			rslt = true;
		}
	}

	return rslt;
}//=============================================================================
// gbxMessageSI.
//=============================================================================
class gbxMessageSI extends gbxMessage
	hidecategories(MessageBroadcast,MessageData,MessageDuplication,MessageLocation);

struct MoveLocation
{
	var() bool bClearFailTryAnother;								// If the check clear failed try another
	var() bool bUnitAssault;										// If flagged this will cause an assault on the unit which triggered the message
	var() export editinline Array<name> nmPathNode;					// PathNode to move to, if multiple paths are supplied do sub movements
	var() export editinline Array<name> nmgbxMT_CheckClear;			// Check if the follow areas are clear before moving
	var() edfindable gbxDelayedMove DelayedMove;
};

// change here
enum ReactionSkill
{
	RS_All,
	RS_Novice,
	RS_Intermediate,
	RS_Advanced,
	RS_Veteran
};

struct SIData
{
	var() ReactionSkill m_ReactionSkill;

	var() edfindable Unit Unit_DE;

	var() name nmEvent;
	var() name nmEventSuccess;
	var() name nmEventFailure;

	var() export editinline Array<MoveLocation> m_Movement;
	var() int numStage;

	var() float fScore;

	var() bool bCheckSupressed;
};

var() export editinline Array<SIData> m_GermanUnits;
var name TriggerTag;
var name MatchTag;

defaultproperties
{
}
// ====================================================================
//  Class:  gbxMessageStrings
//
//  <Enter a description here>
//
// (c) 2001, Epic Games, Inc - All Rights Reserved
// ====================================================================

class gbxMessageStrings extends Object;

var int						nCharType;
var int						nWeaponIdx;
class gbxMessageTrigger extends Trigger;



var bool bInitialized;
var() editinline array< gbxMessage > Messages;

// GBX:naj - Required to mark each message as 'not deletable,' otherwise a crash is possible if this gbxMessageTrigger gets triggered twice.
function PostBeginPlay()
{
	local int i;
	Super.PostBeginPlay();

	for( i = 0; i < Messages.Length; ++i )
	{
		Messages[ i ].bNoDelete = true;
	}

	bInitialized = true;
}

function PostMessages()
{
	local int i;

	if ( bInitialized )
	{
		// Post the specified gbxMessages.
		for( i = 0; i < Messages.Length; ++i )
		{
			PostGBXMessage( Messages[ i ] );
		}
	}
}

function Trigger( actor Other, Pawn EventInstigator )
{
	Super.Trigger( Other, EventInstigator );

	PostMessages();
}


//
// Called when something touches the trigger.
//
function Touch( actor Other )
{
	local int i;

	if( IsRelevant( Other ) )
	{
		if ( ReTriggerDelay > 0 )
		{
			if ( Level.TimeSeconds - TriggerTime < ReTriggerDelay )
				return;
			TriggerTime = Level.TimeSeconds;
		}

		// Broadcast the Trigger message to all matching actors.
		TriggerEvent(Event, self, Other.Instigator);

		// Here's the change from the Trigger superclass ////////////////////////////////////////////////

		PostMessages();

		// END the change from the Trigger superclass ////////////////////////////////////////////////

		if ( (Pawn(Other) != None) && (Pawn(Other).Controller != None) )
		{
			for ( i=0;i<4;i++ )
				if ( Pawn(Other).Controller.GoalList[i] == self )
				{
					Pawn(Other).Controller.GoalList[i] = None;
					break;
				}
		}

		if( (Message != "") && (Other.Instigator != None) )
			// Send a string message to the toucher.
			Other.Instigator.ClientMessage( Message );

		if( bTriggerOnceOnly )
			// Ignore future touches.
			SetCollision(False);
		else if ( RepeatTriggerTime > 0 )
			SetTimer(RepeatTriggerTime, false);
	}
}

function Destroyed()
{
	bInitialized = false;
	Messages.Remove( 0, Messages.Length );
	Super.Destroyed();
}

defaultproperties
{
	 Texture=Texture'Engine.S_TriggerMessage'
}

//=============================================================================
// gbxMessageTriggerSI.
//=============================================================================
class gbxMessageTriggerSI extends gbxMessageTrigger
	placeable;

var(Trigger) name MatchTags[6];
var(Trigger) edfindable gbxMessageTriggerSI gbxMT_Leave;
var(Trigger) float fDelayTillActive;

function UnTouch( actor Other )
{
	Super.UnTouch( Other );

	if ( Messages.Length > 0 )
		if ( gbxMessageSI(Messages[0]).MatchTag == Other.tag )
		{
			Log( "****<" $ Tag $ "> Untouching Other.tag: " $ Other.tag $ " ****", 'TriggeredScript' );

			if ( Level.TimeSeconds - TriggerTime < ReTriggerDelay )
			{
				Log( "****<" $ Tag $ "> Untouching Canceled ****", 'TriggeredScript' );
				return;
			}

			if ( gbxMT_Leave != None )
				gbxMT_Leave.Touch( Other );
		}
}

function PostMessages()
{
	local int i;

	// Post the specified gbxMessages.
	for( i = 0; i < Messages.Length; ++i )
	{
		if ( Messages[i].IsA('gbxMessageSI') )
			gbxMessageSI(Messages[ i ]).TriggerTag = Self.Tag;

		PostGBXMessage( Messages[ i ] );
	}
}

function SetMatch( actor Other )
{
	local int i;

	// Log( "Match Found." );

	for ( i = 0; i < Messages.Length; ++i )
	{
		if ( Messages[i].IsA('gbxMessageSI') )
			gbxMessageSI(Messages[i]).MatchTag = Other.Tag;
	}
}

function bool IsRelevant( actor Other )
{
	local int i;

	if ( Super.IsRelevant(Other) )
	{
		for ( i = 0; i < 6; ++i )
		{
			if ( MatchTags[i] != '' && MatchTags[i] == Other.Tag )
			{
				SetMatch( Other );
				return TRUE;
			}
		}

		return FALSE;
	}
	else
		return FALSE;
}

function Touch( actor Other )
{
	if ( !bInitiallyActive )
		SetTimer( fDelayTillActive, FALSE );
	else
		Super.Touch( Other );
}

function Timer()
{
	if ( !bInitiallyActive )
		bInitiallyActive = TRUE;

	Super.Timer();
}

defaultproperties 	 
{ 	 
	RepeatTriggerTime=4.0 	 
	ReTriggerDelay=0.3 	 
	TriggerType=TT_AnyProximity 	 
} 	 
class gbxMessageUnitMove extends gbxMessage;


var() edfindable ActorLite MoveLocation;

defaultproperties
{
	bBroadcastRecipientsOnly=true
}
class gbxMessageUnitTarget extends gbxMessage;



var() name TargetUnitTag;

defaultproperties
{
	bBroadcastRecipientsOnly=true
}
class gbxPawn extends AnimPawn
	abstract
	native
	config(User);

var byte		LoadOut;
var	() bool		bNoDefaultInventory;	// don't spawn default inventory for this guy
var bool		bAcceptAllInventory;	// can pick up anything
var bool		bSoakDebug;				// use less verbose version of debug display
var bool		bKeepTaunting;
var	bool		m_fWeaponRightHand;
var bool		m_fPrimaryWeaponSelect;
var bool		m_fTrophySelect;
var bool		m_fRunningTorsoAnim;
var bool		m_fNoInterruptTorso;
var bool		m_fBodyFaceTarget;
var bool		m_fCanTalk;
var bool		m_bIsCowering;
var bool		bPawnLooksAtTargets;
var bool		m_bTransitioningToRelaxed;

//----------------------------------------------------------
// Cover-firing variables.
//
var bool			m_bCornerFiring;			// For knowing whether to play corner-fire idle.
var bool			m_bCornerHunkered;
var bool			m_bUsingCrouchedCover;		// For knowing whether to play facing-wall crouch idle.
var bool			m_bStandingBackToWall;		// For standing cover, when the pawn has his back to the wall.
var bool			m_bCornerPeeking;			// For knowing whether to play corner-peek idle.
var bool			m_bStandingOverCorner;		// For knowing whether to play standing-fire-over-corner idle.
var bool			m_bStandPeeking;			// For knowing whether to play standing-peek idle.
var bool			bInBodyDeathCam;
var bool			bAttachCamToHead;
var bool			m_bFreezeCurPointOfInterest;	// Keep the current point of interest until set to false

var bool			m_bFlinching;
var bool			m_bReloadingThirdPerson;
var bool bUseSmirkFacialExpressions;
var bool bUseScowlFacialExpressions;

var bool			m_bCoweringOnGround;		// I just dived to the ground, and I'm cowering.  in fear.
var bool			m_bCookingGrenade;			// I'm holding a grenade, letting it cook off

var bool			bNavigateUsingCover;  // build navigation path using cover points and cover paths
var bool			m_bUseAimErrorOverride;
var bool			bEnableProtectionTimers;
var bool			bRepelBullets;
var bool			bPrioritizeVehicles; // If I'm holding an anti-vehicle weapon, prioritize them as targets.  Only works for the panzerfaust, currently.
var bool			bIsHalftrackRider;  // set to true if this pawn is riding in a Halftrack so that we can handle bullet damage differently

var bool			bDontTransitionToCombat; // This is a hack, but if this is set when a pawn is possessed, don't run the idle to combat transition
var bool			bPlayHeavyTraumaSound;  //NAC: added here for access in inventory classes
var bool			bIsVehicle;				// is this gbxPawn a vehicle?

var() bool            bNoShadow;
var config bool bPlayOwnFootsteps;
var globalconfig bool bBlobShadow;

var	Unit	MyUnit;

var(Sounds)					string VoiceTypeName;
var transient VoiceType				VoiceType;

var config byte SelectedEquipment[16];	// what player has selected (replicate using function)
var()	string	RequiredEquipment[16];	// allow L.D. to modify for single player
var		string	OptionalEquipment[16];	// player can optionally incorporate into loadout

var		float	RepelBulletsCutoffDist;
var		float	AttackSuitability;		// range 0 to 1, 0 = pure defender, 1 = pure attacker
var		float	LastFootStepTime;
var		float	LastFootTurnTime;
var		float	EyeHeightDiff;				// The difference between where the pawn's eyes are when crouched vs. when standing.
var		float	EyeToShoulderHeightDiff;	// The difference between where the pawn's eyes are and where his shoulder (and rifle) are.
var		float	FlinchStartTime;
var		float	ThirdPersonReloadStartTime;
var		float	LastTakeDamageNotifyTime;
var		float	flHeavyTraumaSoundTime;  //NAC: added here for access in inventory classes
var		float	LastKAddImpulseTime;

const			MIN_TAKEDAMAGE_NOTIFY_TIME = 0.5;

var eDoubleClickDir CurrentDir;
var vector			GameObjOffset;
var rotator			GameObjRot;

// Protection Timer variables.
var float LongTimerStart, ShortTimerStart;
var float LongTimerDur, ShortTimerDur, VulnerableDur, TimerTotalDur;

var(Karma) float RagdollLifeSpan; // MAXIMUM time the ragdoll will be around. De-res's early if it comes to rest.
var(Karma) float RagInvInertia; // Use to work out how much 'spin' ragdoll gets on death.
var(Karma) float RagDeathVel; // How fast ragdoll moves upon death
var(Karma) float RagShootStrength; // How much effect shooting ragdolls has. Be careful!
var(Karma) float RagSpinScale; // Increase propensity to spin around Z (up).
var(Karma) float RagDeathUpKick; // Amount of upwards kick ragdolls get when they die

var(Karma) material RagConvulseMaterial;

// Ragdoll impact sounds.
var(Karma) string			RagImpactCueName;
var(Karma) Cue				RagImpactCue;
var(Karma) float			RagImpactSoundInterval;
var(Karma) float			RagImpactVolume;
var transient float			RagLastSoundTime;

var string RagdollOverride;
var bool bUseCustomDeathAnim;
var array<name> CustomDeathAnims;

var gbxVehicle gbxDrivenVehicle;

var int spree;

var array<name> TauntAnims; // Array of names of taunt anim that can be played by this character. First 4 assumed to be orders.
var localized string TauntAnimNames[8]; // Text description

var travel Inventory	SecondaryWeapon;	// The pawn's current secondary weapon.
var travel Inventory	PendingSecondaryWeapon;	// The pawn's pending secondary weapon.
var float				flSecondaryUIFadeTime;
var float				flSecondaryUILastFadeTime;

// Supress the talk to other soldiers message
var bool SupressTalkToMessage;

var float m_flLastBobSpeed;

//---------------------------------------------------------
// Turret weapon-related variables.
//
var TurretWeapon	Turret;					// A turret which is being used by this pawn.
var Vector			TurretMountPoint;		// The location to maneuver to when mounting a turret.
var Rotator			TurretFaceDir;			// Direction to face before mounting a turret.
var Name			TurretMountAnim;		// The mount animation to use.
var Name			TurretDismountAnim;		// The dismount animation to use.
var Weapon			LastWeapon;				// Remember what the pawn was carrying before mounting.

//----------------------------------------------------------
// Grenade variables
//
var float			HitGroundGrenadeFuseMod;	// Time added to grenades thrown by me when they hit the ground
var float			G_MaxTargetRange;			// Maximum distance grenade can be thrown
var range			G_RangeAccuracyMod;			// Minimum and maximum modifiers applied to accuracy based on target range
var range			G_LobAccuracyMod;			// Accuracy range, attenuated by suppression level
var float			G_MaxLobHeight;				// Maximum height allowed to apply to grenade toss
var float			G_OverthrowFactor;			// How far past the target the pawn will throw, given perfect accuracy
var float			G_FrustrationFactor;		// Multiple applied to frustration adjustment to target score
var float			G_MinLobYaw;				// Keeps grenades landing within a certain 'pie' area in front pf (and if very close, behind) the target.  Set very low to allow grenades to land anywhere around target.

var float			m_flLastWalkBobSpeed;		// Last "velocity" we calculated walk bob at.

var ECornerDir		m_MyLeanDirection;			// Will be opposite of the cornerpoint's direction (e.g. pawns lean left at a right corner, etc.)

var() name			m_szUsedByTrigger;			// Fire this trigger when this guy is used by the player

var EJobType		Job;

//----------------------------------------------------------
// Fatigue rates and variables
//
// recovery rates, based on unit skill level
var float FatigueRecovery_Novice;
var float FatigueRecovery_Interm;
var float FatigueRecovery_Advanced;
var float FatigueRecovery_Veteran;
var const float FatigueRecovery_Player;

// Fatigue movement rates
var const float FatigueRate_Sprinting;
var const float FatigueRate_Running;
var const float FatigueRate_Walking;

// One-time fatigue "jog" values
var const float FatigueJog_Rotation;
var const float FatigueJog_Suppression;
var const float FatigueJog_PostureChange_AI;
var const float FatigueJog_PostureChange_Player;

// Player-only "jog" values (put here instead of gbxPlayerPawn for convenience).
var const float FatigueJog_PlayerFiredShot;
var const float FatigueJog_PlayerJump;
var float FatigueJog_PlayerWarningShot;

// Jog interval (time that must pass before allowing another jog)
var const float FatigueJogInterval;
var float NextFatigueJog;

// NavigationController flocking stuff (has to be here because Unit is in gbxBase instead of gbxAI)
var int FormationPosition;
var ActorLite MyClaimedNavPoint;  // NavigationPoint that was last claimed by this Pawn
var ActorLite MyRecentlyTouchedNavPoint;  // NavigationPoint that was most recently touched by this Pawn

var	class<ItemPawnAnimInfo> PawnAnimInfoClass;
var class<GorePackSetup> PawnPackGoreClass;

// ViewKickAdjustment and ViewKickRate - Used to kick the view around for weapons and damage
var vector ViewKickAdjustment, ViewKickRate, ViewKickMax;
var float  ViewKickReturnLagMax;
var float  ViewKickReturnLag;

// PSV: 6/17/2004 MP unit icon scale modifier for compass
var float		m_fUnitReinforcementsIconMultiplier;
var float		m_fReinforcementEffectTimeRemaining;

var int				LimpState;

var BulletListener MyBulletListener;

//----------------------------------------------------------
// Suppression Variables.
//
var int				gbxPawnIndex;

var float		fPlayerLookAtInterval;
var float		fNextPlayerLookAtTime;
var bool		bIsLookingAtPlayer;
var Actor		LookingAtPlayerActor;
var float		m_flPlayerInterestDistance;
var float		m_flPlayerLookAtDotProduct;
var bool		bDontLookAtPlayers;			// temporary override for scripted sequences

var vector		BreathOffset;
var rotator		BreathAngle;
var rotator		LastAimRotator;

var byte		m_bCurIdleAnim;				// Index of the current idle that is playing
var byte		m_bNumIdlePlays;			// Number of times the current idle has played.

var bool karma_need_to_wakeup;

var bool		bUseFaceCam;

var int			m_nAimErrorOverride;
var string		m_szWeaponName;


var	class<gbxInspectorPanel> myInspectorClass;	// HUD inspector class (static)

var Texture	Portrait;
var string CharacterName;

// shadow decal
var ShadowProjector Shadow;
var ShadowProjector TeamLogoShadow;

var class<Weapon> CurrentPawnWeaponClass;

simulated native function vector CalcDrawOffset(Inventory Inv);


replication
{
	reliable if (ROLE==ROLE_Authority)
		ClientKickZoom, ClientKickView, ClientChangedWeapon;

	// Variables the server should send to the client.
	reliable if( bNetDirty && (Role==ROLE_Authority) )
        m_fPrimaryWeaponSelect, m_fTrophySelect, PawnAnimInfoClass, m_fWeaponRightHand, LastAimRotator, Portrait, CharacterName;

	reliable if( bNetDirty && (Role==ROLE_Authority) )
		MyUnit, CurrentPawnWeaponClass;

//	reliable if( Role<ROLE_Authority )
//		ServerSetWeaponAnims;
}

simulated function EnteringTacticalView();
simulated function LeavingTacticalView();

simulated function Destroyed()
{
	local PlayerController PC;
	local gbxHUD myHUD;
	local IGbxPawnList PawnList;

	UnClaimNavPoint();
	
	// remove this inspector from all HUDs (could be split screen on Xbox)...
	for ( PC=Level.PlayerControllerList; PC!=None; PC=PC.nextPlayerController )
	{
		myHUD = gbxHUD(PC.myHUD);

		if (myHUD != None)
		{
			MyHUD.RemoveInspector(self);
		}
	}

	if ( Shadow != None )
	{
		Shadow.Destroy();
		Shadow = None;
	}

	if ( TeamLogoShadow != None )
	{
		TeamLogoShadow.Destroy();
		TeamLogoShadow = None;
	}

	// pawns can be destroyed by level designers at any time and they don't call the IAmDying() function...
	PawnList = Level.GetPawnList();
	gbxPawnList( PawnList ).UnregisterGbxPawn( Self );

	NotSimulatedDestroyed();
	
	super.Destroyed();
}

function NotSimulatedDestroyed()
{
	if ( MyUnit != None )
	{
		MyUnit.RemoveMember( Self );
	}

	if (MyBulletListener != None)
	{
		MyBulletListener.Destroy();
		MyBulletListener = None;
	}
		
	UnClaimNavPoint();
}

simulated event bool SameTeamAs( Pawn other )
{
	local MultiplayerUnit mpUnit, mpUnitOther;

	if (other == None)
	{
		return true;  // not an enemy (yes, on same team)
	}

	// hacky fix for teams on Multiplayer JWS 2004-03-22
	mpUnit = MultiplayerUnit(MyUnit);
	if (gbxPawn(other) != None)
		mpUnitOther = MultiplayerUnit(gbxPawn(other).MyUnit);

	if (mpUnit != None && mpUnitOther != None)
	{
		return mpUnit.SameTeamAsUnit(mpUnitOther);
	}

	return Super.SameTeamAs( other );
}

simulated function ClientKickView( vector Kick, float RecoverDampener, optional float ZoomKick )
{
	local vector deltaKick;
	local vector OldKick;
	local rotator VR;
	local int OverKick;

	ViewKickRate= Kick * RecoverDampener;

	OldKick = ViewKickAdjustment;

	ViewKickAdjustment.Z = Clamp(ViewKickAdjustment.Z + Kick.Z, ViewKickMax.Z*-1, ViewKickMax.Z);		// Pitch
	
	if( Controller.Rotation.pitch < 18000 )
	{
		OverKick = Max( 0, ViewKickAdjustment.Z + Controller.Rotation.pitch - 18000 );
		ViewKickAdjustment.Z -= OverKick;
	}

	// If we've reached the max (or min) vertical (pitch) kick, randomize the horizontal (Yaw) kick left or right
	if( Abs( ViewKickAdjustment.Z / ViewKickMax.Z ) == 1 )
	{
			if( frand() > 0.5 )
			Kick.X *= -1;
	}

	ViewKickAdjustment.X = Clamp(ViewKickAdjustment.X + Kick.X, ViewKickMax.X*-1, ViewKickMax.X);		// Yaw

	// Always randomize roll kick angle left or right
	if (Kick.Y!=0)
	{
		if (frand()>0.5)
			Kick.Y *= -1;
	}

	ViewKickAdjustment.Y = Clamp(ViewKickAdjustment.Y + Kick.Y, ViewKickMax.Z*-1, ViewKickMax.Z);		// Roll


	DeltaKick = ViewKickAdjustment - OldKick;

	if ((Controller != None) && (Controller.bIsHumanPlayer))
	{
		vr = Controller.Rotation;
		vr.yaw += DeltaKick.x;
		vr.roll += DeltaKick.y;

		// Sanity check for adding kick
		if( ( vr.pitch <= 18000 && vr.pitch + DeltaKick.z <= 18000 ) || 
			( vr.pitch >= 49152 && vr.pitch + DeltaKick.z >= 49152 ) )
		{
			vr.pitch += DeltaKick.z;
		}

		Controller.SetRotation(vr);
	}

	if( ViewKickReturnLag > ViewKickReturnLagMax )
	{
		ViewKickAdjustment = DeltaKick;
	}

	// Kick the FOV as well, if specified
	if( ZoomKick > 0.0f )
		ClientKickZoom( ZoomKick );
}

simulated function ClientKickZoom(float ZoomKick)
{
	kick_zoom_active = true;
	kick_zooming_out = true;
	PreZoomFOV = Controller.FOVAngle;
	DesiredZoomFOV = Controller.FOVAngle + ZoomKick;
}

function RestoreViews(float Delta)
{
	local vector OldKick, DeltaKick;
	local rotator VR;
	
	if ( ViewKickAdjustment == vect(0,0,0) )
	{
		ViewKickReturnLag = 0;
		return;
	}

	ViewKickReturnLag += Delta;

	OldKick = ViewKickAdjustment;

	ViewKickAdjustment.X = MoveToZero(ViewKickRate.X * Delta, ViewKickAdjustment.X);
	ViewKickAdjustment.Y = MoveToZero(ViewKickRate.Y * Delta, ViewKickAdjustment.Y);
	ViewKickAdjustment.Z = MoveToZero(ViewKickRate.Z * Delta, ViewKickAdjustment.Z);

	DeltaKick = OldKick - ViewKickAdjustment;

	if ((Controller != None) && (Controller.bIsHumanPlayer))
	{
		vr = Controller.Rotation;
		vr.yaw -= DeltaKick.x;
		vr.roll -= DeltaKick.y;

		if( ( vr.pitch <= 18000 && vr.pitch - DeltaKick.z <= 18000 ) || 
			( vr.pitch >= 49152 && vr.pitch - DeltaKick.z >= 49152 ) )
		{
			vr.pitch -= DeltaKick.z;
		}
		
		Controller.SetRotation(vr);
	}
}

function float MoveToZero(float step, float Value)
{
	// Make step positive
	step = Abs( step );

	if (Value < 0)
	{
		Value += Step;
		return FMin(Value, 0);
	}
	else if(Value > 0)
	{
		Value -= Step;
		return FMax(Value,0);
	}

	return Value;
}

simulated function bool CheckTauntValid( name Sequence )
{
	local int i;

	for(i=0; i<TauntAnims.Length; i++)
	{
		if(Sequence == TauntAnims[i])
			return true;
	}
	return false;
}

/* DisplayDebug()
list important actor variable on canvas.  Also show the pawn's controller and weapon info
*/
simulated function DisplayDebug(Canvas Canvas, out float YL, out float YPos)
{
	//local string T;
	//local float XL;

	if ( !bSoakDebug )
	{
		Super.DisplayDebug(Canvas, YL, YPos);
	}

	YPos += YL;
	Canvas.SetPos(4,YPos);
	Canvas.SetDrawColor(255,255,0);

	if ( Controller == None )
	{
		Canvas.SetDrawColor(255,0,0);
		Canvas.DrawText("NO CONTROLLER", false, 0.9, 0.9);
		YPos += YL;
		Canvas.SetPos(4,YPos);
	}
	else
	{
		Controller.DisplayDebug(Canvas,YL,YPos);
	}

	// DEBUG
	//Canvas.DrawTile3d( Texture't_interface_mb.debug.FC_Bullseye', GetEyePointAtPosture( 2,, true ), 32,32, 0,0, 32,32 );
}

/* BotDodge()
returns appropriate vector for dodge in direction Dir (which should be normalized)
*/
function vector BotDodge(Vector Dir)
{
	local vector Vel;

	Vel = GroundSpeed*Dir;
	Vel.Z = JumpZ;
	return Vel;
}

function HoldCarriedObject(CarriedObject O, name AttachmentBone)
{
	if ( AttachmentBone == 'None' )
	{
		O.SetPhysics(PHYS_Rotating);
		O.SetLocation(Location);
		O.SetBase(self);
		O.SetRelativeLocation(vect(0,0,0));
	}
	else
	{
		AttachToBone(O,AttachmentBone);
		O.SetRelativeRotation(GameObjRot);
		O.SetRelativeLocation(GameObjOffset);
	}
}

function EndJump();	// Called when stop jumping

simulated function ShouldUnCrouch();

simulated event SetAnimAction(name NewAction)
{
// GBX:PAD: This shouldn't be called, but just to be on the safe side, make sure it isn't.
//	AnimAction = NewAction;
//	PlayAnim(AnimAction);
}

function String GetDebugName()
{
	if ( PlayerReplicationInfo != None )
		return PlayerReplicationInfo.PlayerName;
	return GetItemName(string(self));
}

simulated function FootStepping(int side, optional bool bAllowFirstPerson);
simulated function FootTurnImpact(int side);

function bool CheckReflect( Vector HitLocation, out Vector RefNormal, int Damage )
{
    if (Weapon != None)
        return Weapon.CheckReflect( HitLocation, RefNormal, Damage );
    else
        return false;
}

function name GetWeaponBoneFor(Inventory I)
{
	if( I.IsA('gbxWeapon') )
		return gbxWeapon(I).GetWeaponBone();

	return 'rifle_hold';
}

function vector WeaponBob(float BobDamping)
{
	Local Vector WBob;

	WBob = BobDamping * WalkBob;
	WBob.Z = (0.45 + 0.55 * BobDamping) * WalkBob.Z;
	return WBob;
}

function CheckBob(float DeltaTime, vector Y)
{
	local float OldBobTime;
//	local int m,n;
	//local float Speed2D;

	if ((Controller != None) && (Controller.bIsHumanPlayer))
	{
		if (((gbxPlayerController(Controller) != None) && gbxPlayerController(Controller).bLockedMovement) || (accelRate == 0.0) || !bWeaponBob )
    	{
			BobTime = 0;
			WalkBob = Vect(0,0,0);
    	    return;
	    }
	}

	OldBobTime = BobTime;

	Bob = FClamp(Bob, -0.5, 0.5);

	if (Physics == PHYS_Walking )
	{
		CalculateWalkingWalkBob( DeltaTime, Y );
/*
		Speed2D = VSize(Velocity);
		if ( Speed2D < 10 )
			BobTime += 0.2 * DeltaTime;
		else
			BobTime += DeltaTime * (Speed2D / GroundSpeed);
		WalkBob = Y * Bob * Speed2D * sin(8.0 * BobTime);
		AppliedBob = AppliedBob * (1.0 - FMin(1.0, 16.0 * deltatime));
		WalkBob.Z = AppliedBob;
		if ( Speed2D > 10 )
			WalkBob.Z = WalkBob.Z + 0.75 * Bob * Speed2D * sin(16.0 * BobTime);
		if ( LandBob > 0.01 )
		{
			AppliedBob += FMin(1.0, 16.0 * deltatime) * LandBob;
			LandBob *= (1.0 - 8.0 * Deltatime);
		}
*/
	}
	else
	{
		Super.CheckBob(DeltaTime,Y);
	}

//	if ( (Physics != PHYS_Walking) || (VSize(Velocity) < 10)
//		|| ((PlayerController(Controller) != None) && PlayerController(Controller).bBehindView) )
	if ( (Physics != PHYS_Walking) || (m_flLastWalkBobSpeed < 10)
		|| ((PlayerController(Controller) != None) && PlayerController(Controller).bBehindView))
	{
		BobTime = 0;
		WalkBob = Vect(0,0,0);
		return;
	}

//	m = int(0.5 * Pi + 9.0 * OldBobTime/Pi);
//	n = int(0.5 * Pi + 9.0 * BobTime/Pi);

//	if ( (m != n) && !bIsCrouched )
//		FootStepping(0);
//	else if ( !bWeaponBob && bPlayOwnFootSteps && !bIsCrouched && (Level.TimeSeconds - LastFootStepTime > 0.35) )
//	{
//		LastFootStepTime = Level.TimeSeconds;
//		FootStepping(0);
//	}
}

//***************************************
// Vehicle driving
// StartDriving() and StopDriving() also called on client
// on transitions of bIsDriving setting

simulated event gbxStartDriving(gbxVehicle V)
{
	gbxDrivenVehicle = V;
	NetUpdateTime = Level.TimeSeconds - 1;
    AmbientSound = None;
//jlb    StopWeaponFiring();
	if (Weapon != None)
	{
		Weapon.StopFire(0);
		Weapon.StopFire(1);
	}
//jlb	DeactivateSpawnProtection();

	// Move the driver into position, and attach to vehicle.
	ShouldCrouch(false);
	bIgnoreForces = true;
	Velocity = vect(0,0,0);
	Acceleration = vect(0,0,0);
	bCanTeleport = false;

	if ( !V.bRemoteControlled || V.bHideRemoteDriver )
    {
		SetCollision( False, False, False);
		bCollideWorld = false;
		V.AttachDriver( Self );
		if ( V.bDrawDriverinTP )
			CullDistance = 5000;
		else
		   	bHidden = true;
    }

	// set animation
	bPhysicsAnimUpdate = false;
//jlb	bWaitForAnim = false;
	if ( !V.bHideRemoteDriver && V.bDrawDriverinTP )
	{
		if ( HasAnim(gbxDrivenVehicle.DriveAnim) )
			LoopAnim(gbxDrivenVehicle.DriveAnim);
		else
			LoopAnim('Vehicle_Driving');
		SetAnimFrame(0.5);
//jlb		SmoothViewYaw = Rotation.Yaw;
//jlb		SetTwistLook(0,0);
	}
}

simulated event gbxStopDriving(gbxVehicle V)
{
	if ( (Role == ROLE_Authority) && (PlayerController(Controller) != None) )
		V.PlayerStartTime = Level.TimeSeconds + 12;
	CullDistance = Default.CullDistance;
	NetUpdateTime = Level.TimeSeconds - 1;

	if (V != None && V.Weapon != None )
	{
//jlb    	V.Weapon.ImmediateStopFire();
    	V.Weapon.StopFire(0);
    	V.Weapon.StopFire(1);
	}

	if ( Physics == PHYS_Karma )
		return;

	gbxDrivenVehicle	= None;
	bIgnoreForces	= false;
	bHardAttach	= false;
//jlb	bWaitForAnim	= false;
	bCanTeleport	= true;
	bCollideWorld	= true;
	PlayWaiting();
	//PrePivot = vect(0,0,0);

	if ( V != None )
		V.DetachDriver( Self );

	bPhysicsAnimUpdate = Default.bPhysicsAnimUpdate;
	SetCollision(True, True);

	if ( (Role == ROLE_Authority) && (Health > 0) )
	{
    	if ( !V.bRemoteControlled || V.bHideRemoteDriver )
        {
			Acceleration = vect(0, 0, 24000);
			SetPhysics(PHYS_Falling);
			SetBase(None);
			bHidden = false;
        }
	}

    bOwnerNoSee = default.bOwnerNoSee;

	if ( Weapon != None )
	{
		PendingWeapon = None;
		Weapon.BringUp();
	}
}

/* IsInLoadout()
return true if InventoryClass is part of required or optional equipment
*/
function bool IsInLoadout(class<Inventory> InventoryClass)
{
	local int i;
	local string invstring;

	if ( bAcceptAllInventory )
		return true;

	invstring = string(InventoryClass);

	for ( i=0; i<16; i++ )
	{
		if ( RequiredEquipment[i] ~= invstring )
			return true;
		else if ( RequiredEquipment[i] == "" )
			break;
	}

	for ( i=0; i<16; i++ )
	{
		if ( OptionalEquipment[i] ~= invstring )
			return true;
		else if ( OptionalEquipment[i] == "" )
			break;
	}
	return false;
}

function AddDefaultInventory()
{
	local int i, nNumWeapons;

	// GBX:PAD: This is a hack to clear out the grenade count before adding the inventory, since this code is called
	// multiple times in character setup.
	ClearInventory();
	
	if (bNoDefaultInventory)
	{
		PawnAnimInfoClass = Default.PawnAnimInfoClass;
		SetWeaponAnims( PawnAnimInfoClass, false );
		return;
	}
	
	nNumWeapons = 0;
	if ( IsLocallyControlled() )
	{
		for ( i=0; i<16; i++ )
		{
			if ( RequiredEquipment[i] != "" )
			{
				CreateInventory(RequiredEquipment[i]);
			}
		}

		for ( i=0; i<16; i++ )
		{
			if ( (SelectedEquipment[i] == 1) && (OptionalEquipment[i] != "") )
			{
				CreateInventory(OptionalEquipment[i]);
			}
		}

	    Level.Game.AddGameSpecificInventory(self);
	}
	else
	{
	    Level.Game.AddGameSpecificInventory(self);

		for ( i=15; i>=0; i-- )
			if ( (SelectedEquipment[i] == 1) && (OptionalEquipment[i] != "") )
			{
				CreateInventory(OptionalEquipment[i]);
			}

		for ( i=15; i>=0; i-- )
			if ( RequiredEquipment[i] != "" )
			{
				CreateInventory(RequiredEquipment[i]);
			}
	}

	// HACK FIXME
	if ( inventory != None )
		inventory.OwnerEvent('LoadOut');

	if( Controller != None )
	{
		Controller.ClientSwitchToBestWeapon();
	}

	if (Weapon == None)
	{
		PawnAnimInfoClass = Default.PawnAnimInfoClass;
		SetWeaponAnims( PawnAnimInfoClass, false );
	}
	// rss: added so ModifyPlayers will affect MP games aswell
	if( Controller != none && Controller.bIsHumanPlayer )
		Level.Game.SetPlayerDefaults(self);
}

function ClearInventory()
{
	local int		nBucket;
	local Inventory	Inv;
	
	for( nBucket = 0; nBucket < MAX_SECONDARY_BUCKETS; nBucket++ )
	{
		for( Inv=SecondaryInventory[nBucket]; Inv!=None; Inv=Inv.Inventory )
		{
			if (Inv.bCanHaveMultipleCopies && (Powerups(Inv) != None))
			{
				Powerups(Inv).NumCopies = 0;
			}
		}
	}
}

function CreateInventory(string InventoryClassName)
{
	local class<Inventory> InventoryClass;

	InventoryClass = Level.Game.BaseMutator.GetInventoryClass(InventoryClassName);
	CreateInventoryClass( InventoryClass );
}

function Inventory CreateInventoryClass(class<Inventory> InventoryClass)
{
	local Inventory Inv;

	if( (InventoryClass!=None) && (InventoryClass.Default.bCanHaveMultipleCopies || (FindInventoryType(InventoryClass)==None)) )
	{
		Inv = Spawn(InventoryClass);
		if( Inv != None )
		{
			if (Inv.GiveTo(self))
			{
				Inv.PickupFunction(self);
			}
		}
		// GBX:naj - test
		Inv.Instigator = Self;
		return Inv;
	}
	else
	{
		log("WARNING: Could not find inventory item "$InventoryClass.Name, 'gbxPawn');
	}
	return None;
}

function bool Dodge(eDoubleClickDir DoubleClickMove)
{
/* // GBX:PAD
	local vector X,Y,Z;

	if ( bIsCrouched || bWantsToCrouch || (Physics != PHYS_Walking) )
		return false;

    GetAxes(Rotation,X,Y,Z);
	if (DoubleClickMove == DCLICK_Forward)
		Velocity = 1.5*GroundSpeed*X + (Velocity Dot Y)*Y;
	else if (DoubleClickMove == DCLICK_Back)
		Velocity = -1.5*GroundSpeed*X + (Velocity Dot Y)*Y;
	else if (DoubleClickMove == DCLICK_Left)
		Velocity = 1.5*GroundSpeed*Y + (Velocity Dot X)*X;
	else if (DoubleClickMove == DCLICK_Right)
		Velocity = -1.5*GroundSpeed*Y + (Velocity Dot X)*X;

	Velocity.Z = 210;
	CurrentDir = DoubleClickMove;
	SetPhysics(PHYS_Falling);
	return true;
*/  // GBX:PAD
	return false;
}

function PostBeginPlay()
{
	local IGbxPawnList PawnList;

	Super.PostBeginPlay();

	if( VoiceType == None )
	{
		SetVoiceType( VoiceTypeName );
	}

	// Find our hash index.
	gbxPawnIndex = class'gbxPawn'.Default.gbxPawnIndex;
	class'gbxPawn'.Default.gbxPawnIndex++;

	if ( Role == ROLE_Authority )
	{
		PawnList = Level.GetPawnList();
		gbxPawnList( PawnList ).RegisterGbxPawnByTeam( Self, PawnTeam );
	}
}

simulated function PostNetBeginPlay()
{
	local IGbxPawnList PawnList;

	Super.PostNetBeginPlay();

	if ( Role == ROLE_Authority )
	{
		CreateBulletListener(); // Only the server needs bullet listeners now, since the client hears about whizzes from the server	
	}

	PawnList = Level.GetPawnList();

	if (PawnList != None)
	{
		gbxPawnList( PawnList ).RegisterGbxPawnByTeam( Self, PawnTeam );
	}
}

simulated function PostLoadGame()
{
	SetVoiceType( GetCharacterVoiceType( Level.IsDemoBuild() ) );	
}

simulated function CreateBulletListener()
{
	if (MyBulletListener == None)
	{	
		MyBulletListener = Spawn( class'BulletListener' );
		MyBulletListener.SetLocation(Location);
		MyBulletListener.SetBase(self);
		MyBulletListener.SetRelativeLocation(vect(0,0,0));
		MyBulletListener.NotifyPawn = self;
	}
}

simulated function NotifyNearbyTrace( Actor Other, vector TouchLocation, vector TouchNormal, vector End, vector Start, vector Extent, int TraceFlags )
{
	if( Other == None || !Other.IsA( 'InstantFire' ) && !Other.IsA( 'gbxGrenade' ) && !(Other.IsA( 'InstantFireWeaponAttachment' ) && Other.Role < ROLE_Authority) )
	{
		// This is no bullet! Only InstantFire's do bullet traces. (So I claim.)
		// 2004-08-17 JWS: And InstantFireWeaponAttachment on the client can do traces also to get bullet whiz...
		return;
	}

	if ((Controller != None) && (Controller.bIsHumanPlayer))
	{
		if( gbxPlayerController( Controller ) != None )
			gbxPlayerController( Controller ).NotifyNearbyTrace( Other, TouchLocation, TouchNormal, End, Start, Extent, TraceFlags );
	}
	else if( gbxAIController( Controller ) != None )
	{
		gbxAIController( Controller ).NotifyNearbyTrace( Other, TouchLocation, TouchNormal, End, Start, Extent, TraceFlags );
	}
}

function SetVoiceType( string strVoiceTypeName )
{
	VoiceTypeName = strVoiceTypeName;

	// Try to set the voice type to a global voice first
	if( AISpeechManager( Level.TheAISpeechManager ) != None )
	{
		VoiceType = AISpeechManager( Level.TheAISpeechManager ).GetGlobalVoiceType( strVoiceTypeName );

		if( VoiceType != None )
			return;
	}
}

function SetMovementPhysics()
{
	if (Physics == PHYS_Falling)
		return;
	if ( PhysicsVolume.bWaterVolume )
		SetPhysics(PHYS_Swimming);
	else
		SetPhysics(PHYS_Walking);
}

function TakeDamage( int Damage, Pawn instigatedBy, Vector hitlocation,
							Vector momentum, class<DamageType> damageType, optional name HitBoxName )
{
	Super.TakeDamage( Damage, instigatedBy, hitlocation, momentum, damageType, HitBoxName );

	if ( Level.Game.GameReplicationInfo.GameType != GT_MULTIPLAYER )
	{
		// Don't notify too often.
		if( Level.TimeSeconds - LastTakeDamageNotifyTime > MIN_TAKEDAMAGE_NOTIFY_TIME )
		{
			NotifyPlayersImTakingDamage();
		}
	}
}


simulated function PlayFootStep()
{
	if ( (Role==ROLE_SimulatedProxy) || (PlayerController(Controller) == None) || PlayerController(Controller).bBehindView )
	{
		FootStepping(0);
		return;
	}
}

//-----------------------------------------------------------------------------

/*
Pawn was killed - detach any controller, and die
*/
simulated function ChunkUp( Rotator HitRotation, class<DamageType> D )
{

	// TODO This is a 2ND LOOK HACK 11/22/2003
	// TODO reinstate, perhaps, unless our gore system works a complete different way.

	// Ignore chunking up, otherwise Karma crashes for us.
	return;


	if ( (Level.NetMode != NM_Client))
	{
		IAmDying();
	}

	bTearOff = true;
	HitDamageType = class'Gibbed'; // make sure clients gib also
	if ( (Level.NetMode == NM_DedicatedServer) || (Level.NetMode == NM_ListenServer) )
		GotoState('TimingOut');
	if ( Level.NetMode == NM_DedicatedServer )
		return;
	if ( class'GameInfo'.static.UseLowGore() )
	{
		Destroy();
		return;
	}
	SpawnGibs(HitRotation,D);

	if ( Level.NetMode != NM_ListenServer )
		Destroy();
}

event EncroachedBy( actor Other )
{
	// do nothing, vehicles will push and/or damage Pawns appropriately.
}

// spawn gibs (local, not replicated)
simulated function SpawnGibs(Rotator HitRotation, class<DamageType> D);

simulated function PlayDying(class<DamageType> DamageType, vector HitLoc)
{
	local vector shotDir, hitLocRel, deathAngVel, shotStrength;
	local float maxDim;
	local string RagSkelName;
	local KarmaParamsSkel skelParams;

	AmbientSound = None;
    bCanTeleport = false;
    bReplicateMovement = false;
    bTearOff = true;
    bPlayedDeath = true;
	RagLastSoundTime=Level.TimeSeconds;

	HitDamageType = DamageType; // these are replicated to other clients
    TakeHitLocation = HitLoc;

    // stop shooting
    AnimBlendParams(1, 0.0);
	LifeSpan = RagdollLifeSpan;

    GotoState('Dying');

	if ( Level.NetMode != NM_DedicatedServer )
	{
		// In low physics detail, if we were not just controlling this pawn,
		// and it has not been rendered in 3 seconds, just destroy it.
		if(Level.PhysicsDetailLevel == PDL_Low && (Level.TimeSeconds - LastRenderTime > 3) )
		{
			Destroy();
			return;
		}

		// Try and obtain a rag-doll setup.
		if( RagdollOverride != "")
			RagSkelName = RagdollOverride;
		else
			Log("gbxPawn.PlayDying: No RagdollOverride",'Pawn');

		// If we managed to find a name, try and make a rag-doll slot availbale.
		if( RagSkelName != "" )
		{
			KMakeRagdollAvailable();
		}

		if( KIsRagdollAvailable() && RagSkelName != "" )
		{
			skelParams = KarmaParamsSkel(KParams);
			skelParams.KSkeleton = RagSkelName;
			//KParams = skelParams;

			//Log("RAGDOLL");

			// Stop animation playing.
			StopAnimating(true);

			// DEBUG
			//TearOffMomentum = vect(0, 0, 0);
			//if(VSize(TearOffMomentum) < 0.01)
			//	Log("TearOffMomentum magnitude of Zero");
			// END DEBUG

			if(DamageType != None && DamageType.default.bKUseOwnDeathVel)
			{
				RagDeathVel = DamageType.default.KDeathVel;
				RagDeathUpKick = DamageType.default.KDeathUpKick;
			}

			// Set the dude moving in direction he was shot in general
			shotDir = Normal(TearOffMomentum);
			shotStrength = RagDeathVel * shotDir;

		    // Calculate angular velocity to impart, based on shot location.
		    hitLocRel = TakeHitLocation - Location;

		    // We scale the hit location out sideways a bit, to get more spin around Z.
		    hitLocRel.X *= RagSpinScale;
		    hitLocRel.Y *= RagSpinScale;

			// If the tear off momentum was very small for some reason, make up some angular velocity for the pawn
			if( VSize(TearOffMomentum) < 0.01 )
			{
				//Log("TearOffMomentum magnitude of Zero");
				deathAngVel = VRand() * 18000.0;
			}
			else
			{
				deathAngVel = RagInvInertia * (hitLocRel Cross shotStrength);
			}

    		// Set initial angular and linear velocity for ragdoll.
			// Scale horizontal velocity for characters - they run really fast!
			skelParams.KStartLinVel.X = 0.6 * Velocity.X;
			skelParams.KStartLinVel.Y = 0.6 * Velocity.Y;
			skelParams.KStartLinVel.Z = 1.0 * Velocity.Z;
    		skelParams.KStartLinVel += shotStrength;

			// If not moving downwards - give extra upward kick
			if(Velocity.Z > -10)
				skelParams.KStartLinVel.Z += RagDeathUpKick;

    		skelParams.KStartAngVel = deathAngVel;

    		// Set up deferred shot-bone impulse
			maxDim = Max(CollisionRadius, CollisionHeight);

    		skelParams.KShotStart = TakeHitLocation - (1 * shotDir);
    		skelParams.KShotEnd = TakeHitLocation + (2*maxDim*shotDir);
    		skelParams.KShotStrength = RagShootStrength;

    		// Turn on Karma collision for ragdoll.
			KSetBlockKarma(true);

			// Set physics mode to ragdoll.
			// This doesn't actaully start it straight away, it's deferred to the first tick.
			SetPhysics(PHYS_KarmaRagdoll);

			return;
		}
		// jag
	}

	// non-ragdoll death fallback
	Velocity += TearOffMomentum;
    BaseEyeHeight = Default.BaseEyeHeight;
	//PlayDyingAnim(DamageType, HitLoc);
    //PlayDirectionalDeath(HitLoc);
    SetPhysics(PHYS_Falling);

    if (gbxWeapon(Weapon) != None)
    {
		gbxWeapon(Weapon).InvalidateBurst();
    }
}

event KVelDropBelow()
{
	Super.KVelDropBelow();

// GBX:PAD: I have to remove all of this for now since it's possible a guy will have 0 velocity when they go to ragdoll, so this
// causes them to lock up in their initial pose.

//	KFreezeRagdoll();
//	SetPhysics( PHYS_None );
//	karma_need_to_wakeup = true;
}

// Called when in Ragdoll when we hit something over a certain threshold velocity
// Used to play impact sounds.
event KImpact(actor other, vector pos, vector impactVel, vector impactNorm)
{
	if( RagImpactCueName != "" && Level.TimeSeconds > RagLastSoundTime + RagImpactSoundInterval )
	{
		RagImpactCue = LoadSound( RagImpactCueName );

		if( RagImpactCue != None )
		{
			PlaySoundCue( RagImpactCue, SLOT_None,,,,, );
		}

		RagLastSoundTime = Level.TimeSeconds;
	}
}

/* TimingOut - where gibbed pawns go to die (delay so they can get replicated)
*/
State TimingOut
{
ignores BaseChange, Landed, AnimEnd, Trigger, Bump, HitWall, HeadVolumeChange, PhysicsVolumeChange, Falling, BreathTimer;

	function TakeDamage( int Damage, Pawn instigatedBy, Vector hitlocation,
							Vector momentum, class<DamageType> damageType, optional name HitBoxName)
	{
	}

	function BeginState()
	{
		SetPhysics(PHYS_None);
		SetCollision(false,false,false);
		LifeSpan = 1.0;

		IAmDying();
	}
}

State Dying
{
ignores AnimEnd, Trigger, Bump, HitWall, HeadVolumeChange, PhysicsVolumeChange, Falling, BreathTimer;

	function Landed(vector HitLocation, vector HitNormal)
	{
		LandBob = FMin(50, 0.055 * Velocity.Z);
		if ( Level.NetMode == NM_DedicatedServer )
			return;
	}

	singular function BaseChange()
	{
		Super.BaseChange();
		// fixme - wake up karma
	}

	// If a ragdoll, add an impulse when shot
    simulated function TakeDamage( int Damage, Pawn InstigatedBy, Vector Hitlocation, Vector Momentum, class<DamageType> damageType, optional name HitBoxName)
    {
        local Vector PushLinVel;

		//log("Take Damage");

		if(bPlayedDeath && Physics == PHYS_KarmaRagdoll)
		{
			//log("HIT RAGDOLL. M:"$Momentum);

			if (LastKAddImpulseTime + 3.0f < Level.TimeSeconds)
			{
				LastKAddImpulseTime = Level.TimeSeconds;
				PushLinVel = RagShootStrength*Normal(Momentum);
				KAddImpulse(PushLinVel, HitLocation);
			}

			return;
		}

		Super.TakeDamage(Damage, InstigatedBy, Hitlocation, Momentum, damageType);
	}

	function BeginState()
	{
		if ( (LastStartSpot != None) && (Level.TimeSeconds - LastStartTime < 7) )
			LastStartSpot.LastSpawnCampTime = Level.TimeSeconds;

		SetCollision(true,false,false);

        if ( bTearOff && (Level.NetMode == NM_DedicatedServer) )
			LifeSpan = 1.0;
		else
			SetTimer(2.0, false);
        SetPhysics(PHYS_Falling);
		bInvulnerableBody = true;

		IAmDying();
	}
}

function Died(Controller Killer, class<DamageType> damageType, vector HitLocation)
{
	if ( Level.Game.GameReplicationInfo.GameType != GT_MULTIPLAYER )
	{
		NotifyPlayersIDied();
	}

	Super.Died( Killer, damageType, HitLocation );

	Level.TheAISpeechManager.RemoveSpeechesForSpeaker( Self,, true );
}

function NotifyPlayersImTakingDamage()
{
	local PlayerController PC;

	for ( PC=Level.PlayerControllerList; PC!=None; PC=PC.nextPlayerController )
	{
		gbxPlayerController(PC).ClientNotifyPawnTakingDamage( Self );
	}

	LastTakeDamageNotifyTime = Level.TimeSeconds;
}

function NotifyPlayersIDied()
{
	local PlayerController PC;

	for ( PC=Level.PlayerControllerList; PC!=None; PC=PC.nextPlayerController )
	{
		gbxPlayerController(PC).ClientNotifyPawnDied( Self );
	}
}

function IAmDying()
{
	// NOTE TO ALL: This function apparently does not get called in all circumstances.
	// If you have code that must be called when a Pawn dies, check Died() instead.

	local IGbxPawnList PawnList;

	if ( Controller != None )
	{
		if ( Controller.bIsPlayer )
			Controller.PawnDied(self);
		else
			Controller.Destroy();
	}

	if (MyClaimedNavPoint != None)
		UnClaimNavPoint();

	if ( bIsManningTurret )
	{
		Turret.NotifyCrewMemberDied( Self );
	}

// GBX:PAD: I'm working on a pawn caching system that ties into this pawn list, so don't unregister it until it's really
// destroyed.
	if ( !Level.bPoolPawns && (Role == ROLE_Authority) )
	{
		PawnList = Level.GetPawnList();
		gbxPawnList( PawnList ).UnregisterGbxPawn( Self );
	}
}

function FireSecondary( optional float F )
{
}

// Just changed to pendingSecondaryWeapon
function ChangedSecondaryWeapon()
{
}

function MountTurretPlayer( TurretWeapon aTurret, bool bUseRootMotion );
function DismountTurretPlayer(bool bUseRootMotion);

function CompleteTurretMount( bool bAnimQueueFailed );
function PrepareTurretDismount();
function CompleteTurretDismount();

function PrepareToMount();
function StartMount();
function CompleteMount();
function LoadMountAnimations( EMountAction Action );
function SetTurretAnims( Name MountAnim, Name DismountAnim );
function SetNinePointAnimations( Name ForDown, Name ForLev, Name ForUp,
								 Name LeftDown, Name LeftLev, Name LeftUp,
								 Name RightDown, Name RightLev, Name RightUp );
function DoNinePointBlending( NinePointDir Dir1, float BlendAlpha1, NinePointDir Dir2, float BlendAlpha2, optional bool fTorsoOnly );
function StopNinePointBlending();
function StartFeedingAmmo();
function StopFeedingAmmo();

function int WeaponCount()
{
	local int		nCount;
	local Inventory	anItem, anLastItem;

	nCount = 0;
	anItem = Inventory;
	while( (anItem != None) && (anLastItem != anItem) )
	{
		if (gbxWeapon(anItem) != None)
			nCount++;
		anLastItem = anItem;
		anItem = Inventory.Inventory;
	}

	return nCount;
}

function JoinUnit( name UnitTag, optional bool bForceBecomingLeader )
{
	local Unit U;
	//Log( " gbxPawn::JoinUnit()", 'MP' );

	foreach DynamicActors( class'Unit', U, UnitTag ) break;

	if( UnitTag != '' && UnitTag != 'None' && U == None )
	{
		// Couldn't find the unit, so create it.
		U = Spawn( class'Unit' );
		U.Tag = UnitTag;
		U.UnitType = UnitType_None;
	}

	//Log( self$" gbxPawn::JoinUnit() U="$U, 'MP' );

	LeaveCurrentUnit();

	if( U != None )
	{
		U.AddMember( Self );

		if( bForceBecomingLeader )
		{
			U.SetLeader( Self );
		}
	}
}

function LeaveCurrentUnit()
{
	if( MyUnit != None )
	{
		MyUnit.RemoveMember( Self );
	}

	MyUnit = None;
}

function bool IsInUnit( Unit aUnit )
{
	return aUnit == MyUnit && aUnit != None;
}

function BecomingLeader( Unit ledUnit )
{
	// This is called to notify the pawn that it is becoming the leader of
	// the ledUnit.

	if( gbxPlayerController( Controller ) != None )
	{
		gbxPlayerController( Controller ).BecomingLeader( ledUnit );
	}
	if( gbxAIController( Controller ) != None )
	{
		gbxAIController( Controller ).BecomingLeader( ledUnit );
	}
}

function SetFormationPosition(int position)
{
	FormationPosition = position;
}

function int GetFormationPosition()
{
	return FormationPosition;
}

//------------------------------------------------------------------
// Play All Speeches - Debug Mechanism
//------------------------------------------------------------------
function PlayAllSpeeches()
{
	local int sndIdx;
	local name speechName;

	for( sndIdx=0; sndIdx<VoiceType.MAX_SPEECH_SOUND_INFOS; ++sndIdx )
	{
		speechName = VoiceType.GetKeyName( sndIdx );

		if( speechName != '' )
		{
			PlaySound(
				VoiceType.GetSound( speechName ),
				SLOT_Talk,
				VoiceType.GetVolume( speechName ),
				false,
				VoiceType.GetRadius( speechName ),
				VoiceType.GetPitch( speechName ),
				,
				true
			);
		}
	}
}

//------------------------------------------------------------------
// Play Battle Dialogue
//------------------------------------------------------------------
function float PlayBattleDialogue( Name nameSpeech, Pawn Speaker, Pawn Listener, optional Name nameKey, optional out int iSoundHandle )
{
	local vector SpeakerPos, ListenerPos, SpeakerToListener;
	local float flDist, flDuration;
	local string strSound, strSoundName, strType, strOrigType;
	local name keyName;
	local sound sndDialogue;

	if( nameSpeech == '' )
	{
		Log( "gbxPawn::PlayBattleDialogue(): nameSpeech Invalid!", 'RSC' );
		return 0.0;
	}

	flDuration = 0;
	iSoundHandle=-1;

	if( Speaker == None || Listener == None || Speaker==Listener )
	{
		//Log( "gbxPawn::PlayBattleDialogue(): Speaker/Listener invalid ==> Speaker=" $ Speaker $ ", Listener=" $ Listener $ ", nameSpeech=" $ nameSpeech, 'RSC' );
		
		// figure out which sound to play
		keyName = VoiceType.GetGroupMember( nameSpeech );
		//log( "gbxPawn::PlayBattleDialogue() - " $ VoiceType $ ".GetGroupMember( " $ nameSpeech $ " ) returned " $ keyName, 'RSC' );
		if( keyName == '' )
		{
			log( "gbxPawn::PlayBattleDialogue() - keyName Invalid for " $ nameSpeech, 'RSC' );
			return 0.0;
		}
		
		strSoundName = VoiceType.GetSoundName( keyName );
		//log( "gbxPawn::PlayBattleDialogue() - " $ VoiceType $ ".GetSoundName( " $ keyName $ " ) returned " $ strSoundName, 'RSC' );
		if( strSoundName == "" )
		{
			log( "gbxPawn::PlayBattleDialogue() - strSoundName Invalid for " $ keyName, 'RSC' );
			return 0.0;
		}
		
		strSound = VoiceType.GetPackage() $ "." $ strSoundName;
		//log( "gbxPawn::PlayBattleDialogue() - strSound=" $ strSound, 'RSC' );
		if( strSound == "" )
		{
			log( "gbxPawn::PlayBattleDialogue() - strSound Invalid for " $ strSoundName, 'RSC' );
			return 0.0;
		}

	}
	else if( nameKey != '' )	// check if the optional key was provided
	{
		strSoundName = VoiceType.GetSoundName( nameKey );
		//log( "gbxPawn::PlayBattleDialogue() - " $ VoiceType $ ".GetSoundName( " $ nameKey $ " ) returned " $ strSoundName, 'RSC' );
		if( strSoundName == "" )
		{
			log( "gbxPawn::PlayBattleDialogue() - strSoundName Invalid for " $ nameKey, 'RSC' );
			return 0.0;
	}

		strSound = VoiceType.GetPackage() $ "." $ strSoundName;
		//log( "gbxPawn::PlayBattleDialogue() - strSound=" $ strSound, 'RSC' );
		if( strSound == "" )
		{
			log( "gbxPawn::PlayBattleDialogue() - strSound Invalid for " $ strSoundName, 'RSC' );
			return 0.0;
		}
	}
	else // if we get here we should have everything we need, i.e. Speaker, Listener
	{
		// get the distance between the two pawns
		SpeakerPos = Speaker.Location;
		ListenerPos = Listener.Location;
		//log( "gbxPawn::PlayBattleDialogue() - Pawn Locations: SpeakerPos=" $ SpeakerPos $ ", ListenerPos=" $ ListenerPos, 'RSC' );

		SpeakerToListener = ListenerPos - SpeakerPos;
		flDist = VSize( SpeakerToListener );
		log( "gbxPawn::PlayBattleDialogue() - SpeakerToListener=" $ SpeakerToListener $ ", dist=" $ flDist, 'RSC' );

		// figure out which sound to play
		keyName = VoiceType.GetGroupMember( nameSpeech );
		//log( "gbxPawn::PlayBattleDialogue() - " $ VoiceType $ ".GetGroupMember( " $ nameSpeech $ " ) returned " $ keyName, 'RSC' );
		if( keyName == '' )
		{
			//log( "gbxPawn::PlayBattleDialogue() - keyName Invalid for " $ nameSpeech, 'RSC' );
			return 0.0;
		}		
		
		strSoundName = VoiceType.GetSoundName( keyName );
		//log( "gbxPawn::PlayBattleDialogue() - " $ VoiceType $ ".GetSoundName( " $ keyName $ " ) returned " $ strSoundName, 'RSC' );
		if( strSoundName == "" )
		{
			//log( "gbxPawn::PlayBattleDialogue() - strSoundName Invalid for " $ keyName, 'RSC' );
			return 0.0;
		}

		strOrigType = Left( strSoundName, 1 );
		// if we are far away, and this is the player and we are not trying to speak softly, play LOUD
		if( flDist > 1250 && Speaker.IsHumanControlled() && strOrigType != "S" )
		{
			strType = "L";
		}
		else if( flDist > 250 && strOrigType != "S" )	// if we are closer and not trying to speak softly, play MEDIUM
		{
			strType = "M";
		}
		else	// otherwise try SOFT
		{
			strType = "S";
		}

		//
		// GBX:RSC 9/7/05 - this was changed to curb log spam from the sound engine trying to load missing sounds too often
		//

		//if( flDist < 3000 || strOrigType == "S" )	// play the soft version at 3 meter
		//{
		//	strType = "S";
		//}
		//else if( flDist < 6000 )	// play the medium version at 6 meters
		//{
		//	strType = "M";
		//}
		//else // must be farther than the medium range so use the loud version
		//{
		//	strType = "L";
		//}
		strSound = VoiceType.GetPackage() $ "." $ strType $ Right( strSoundName, Len(strSoundName)-1 );
		//log( "gbxPawn::PlayBattleDialogue() - strSound=" $ strSound, 'RSC' );
	}

	// load the sound
	//log( "gbxPawn::PlayBattleDialogue() - Loading " $ strSound, 'RSC' );
	sndDialogue = sound( DynamicLoadObject( strSound, class'Sound' ) );
	
	// if we couldn't load the sound for some reason try the medium one just in case
	if( sndDialogue == None )
	{
		if( strType != "M" ) // try to load the medium version for fallback if we haven't already
		{
			strType = "M";
			strSound = VoiceType.GetPackage() $ "." $ strType $ Right( strSoundName, Len(strSoundName)-1 );

			// load the sound
			//log( "gbxPawn::PlayBattleDialogue() - Loading " $ strSound $ " (2nd attempt)", 'RSC' );
			sndDialogue = sound( DynamicLoadObject( strSound, class'Sound' ) );

			if( sndDialogue == None )
			{
				//log( "gbxPawn::PlayBattleDialogue() - DynamicLoadObject (2nd attempt) Failed for sound " $ strSound, 'RSC' );
				return 0.0;
			}
		}
		else
		{
			//log( "gbxPawn::PlayBattleDialogue() - DynamicLoadObject Failed for sound " $ strSound, 'RSC' );
			return 0.0;
		}
	}

	// we should have a valid sound at this point, let's try to play it
	//log( "gbxPawn::PlayBattleDialogue() - PlaySpeechDirect( " $ strSound $ ", " $ nameSpeech $ " )", 'RSC' );
	if( !PlaySpeechDirect( sndDialogue, nameSpeech, iSoundHandle ) )
	{
		//log( "gbxPawn::PlayBattleDialogue() - PlaySpeechDirect Failed for sound " $ strSound, 'RSC' );
		return 0.0;
	}

	flDuration = GetSoundDuration( sndDialogue );
	//log( "gbxPawn::PlayBattleDialogue() - flDuration=" $ flDuration, 'RSC' );

	return flDuration;
}

//------------------------------------------------------------------
// Play Speech
//------------------------------------------------------------------
function float PlaySpeech(Name nameSpeech, optional Name nameKey, optional out int iSoundHandle )
{
	local name		nameGroup;
	local Sound		sndSpeech;
	local String	strSpeech, strPackage, strSound;
	local float flDuration;

	if ( VoiceType == None )
	{
		return 0.0f;
	}

	iSoundHandle = -1;

	// if nameKey is specified, then the caller wants a specific sound played
	if( nameKey != '' )
		nameGroup = nameKey;
	else
		nameGroup = VoiceType.GetGroupMember( nameSpeech );

	if( nameGroup != '' )
	{
		nameSpeech = nameGroup;
	}
	else 
	{
		log( "gbxPawn::PlaySpeech() - Invalid GroupName: " $ nameGroup, 'RSC' );
		return 0.0;
	}

	strSpeech = VoiceType.GetSoundName( nameSpeech );
	strPackage = VoiceType.GetPackage();
	strSound = strPackage $ "." $ strSpeech;

	//log( "gbxPawn::PlaySpeech() - strSound=" $ StrSound, 'RSC' );
	sndSpeech = sound( DynamicLoadObject( strSound, class'Sound' ) );

	if( sndSpeech == None )
	{
		//log( "gbxPawn::PlaySpeech() - DynamicLoadObjectFailed on " $ strSound, 'RSC' );
		return 0.0;
	}

	if( !PlaySpeechDirect( sndSpeech, nameSpeech, iSoundHandle ) )
	{
		//log( "gbxPawn::PlaySpeech() - PlaySpeechDirect Failed for sound " $ strSound, 'RSC' );
		return 0.0;
	}

	flDuration = GetSoundDuration( sndSpeech );
	//log( "gbxPawn::PlaySpeech() - flDuration=" $ flDuration, 'RSC' );

	return flDuration;
}


//------------------------------------------------------------------
// Play Speech Direct
//------------------------------------------------------------------
function bool PlaySpeechDirect( sound snd, name nameSpeech, optional out int iSoundHandle )
{
	local bool bLipSync;
	local Controller C;
	local gbxPlayerController PC;

	if( snd == None )
	{
		log( "ERROR: gbxPawn::PlaySpeechDirect() - snd is None for speech " $ nameSpeech, 'RSC' );
		return false;
	}
	//log( "gbxPawn::PlaySpeechDirect() - snd= " $ snd $ ", nameSpeech=" $ nameSpeech, 'RSC' );

	bLipSync = false;
	if ((Level.NetMode == NM_Standalone) )
	{
		PC = gbxPlayerController(Level.GetLocalPlayerController());

		// is this Pawn close enough to the player to see lipsynching?
		if ( (PC != None) && (PC.Pawn != None) && (VSize(PC.Pawn.Location - Location) < 1500.0) )
		{
			bLipSync = true;
		}
	}
	//log( "gbxPawn::PlaySpeechDirect() - bLipSync=" $ bLipSync, 'RSC' );

	if (Level.NetMode == NM_Standalone)
	{
		if( VoiceType.GetPackage() == "BD_HARTSOCK" || VoiceType.GetPackage() == "BD_BAKER" )
		{
			//log( "gbxPawn::PlaySpeechDirect() - PlayOwnedSoundSP(" $ snd $ ")", 'RSC' );
			PlayOwnedSound( snd, SLOT_Talk );
		}
		else
		{
			//log( "gbxPawn::PlaySpeechDirect() - PlaySoundSP(" $ snd $ ")", 'RSC' );
			iSoundHandle = PlaySound(
				snd,
				SLOT_Talk,
				VoiceType.GetVolume( nameSpeech ),
				false,
				VoiceType.GetRadius( nameSpeech ),
				VoiceType.GetPitch( nameSpeech ),
				,
				bLipSync
			);
		}

	}
	else
	{
		// if Level.ControllerList is populated, we are the server
		if( Level.ControllerList != None )
		{
				// if the package is command dialogue, this is a squad command
			if( VoiceType.GetPackage() == "BD_HARTSOCK" || VoiceType.GetPackage() == "BD_BAKER" ||
				VoiceType.GetPackage() == "BD_CMD_GER_A" || VoiceType.GetPackage() == "BD_CMD_GER_B" ||
				VoiceType.GetPackage() == "BD_CMD_EGA_A" || VoiceType.GetPackage() == "BD_CMD_EGA_B" ||
				VoiceType.GetPackage() == "BD_CMD_ENG_A" || VoiceType.GetPackage() == "BD_CMD_ENG_B" )
			{
				//log( "gbxPawn::PlaySpeechDirect() - PlayOwnedSoundMPA(" $ snd $ ")", 'RSC' );
				iSoundHandle = PlayLocalSound( snd, SLOT_Talk );
				//PlayRemoteSound( snd, SLOT_Talk );	// play command for other clients
			}
			else
			{
				if( /*PC.GameReplicationInfo.GameType == GT_SKIRMISH ||*/ Level.bEnableClientBattleDialogue )
				{
					//log( "gbxPawn::PlaySpeechDirect() - PlaySoundMP(" $ snd $ ")", 'RSC' );
					iSoundHandle = PlaySound(
						snd,
						SLOT_Talk,
							VoiceType.GetVolume( nameSpeech ),
						false,
							VoiceType.GetRadius( nameSpeech ),
							VoiceType.GetPitch( nameSpeech ),
						,
						bLipSync
					);
				}
				else
				{
					// FROM BIA 1.0 - Multiplayer
					//if we get here we are the server trying to play battle dialogue
					//Look through units this way so that we can always find the player, even if he is dead
					for (C = Level.ControllerList; C != None; C=C.NextController)
					{
						PC = gbxPlayerController(C);

						//log( "gbxPawn::PlaySpeechDirect() - PC=" $ PC $ ", MyUnit=" $ MyUnit $ ", MyUnit.SuperUnit=" $ MyUnit.SuperUnit $ ", PC.LastPlayerUnit=" $ PC.LastPlayerUnit, 'RSC' );
						if (PC != None && MyUnit != None && MyUnit.SuperUnit != None && PC.LastPlayerUnit == MyUnit.SuperUnit)
						{
							//log( "gbxPawn::PlaySpeechDirect() - " $ PC $ ".PlaySoundMPA(" $ self $ ", " $ snd $ ")", 'RSC' );
							iSoundHandle = PC.ClientPlaySoundForPawn(
								self,
								snd,
								SLOT_Talk,
								VoiceType.GetVolume( nameSpeech ),
								false,
								VoiceType.GetRadius( nameSpeech ),
								VoiceType.GetPitch( nameSpeech ),
								,
								bLipSync
							);

							break;	// take out the break in order to play battle dialogue for all clients
						}
					}
				}
			}
		}
		else	// if we get here, we are on the client in mutliplayer/skirmish trying to play a squad command 
		{
			//log( "gbxPawn::PlaySpeechDirect() - Level.ControllerList=None", 'RSC' );
			if( VoiceType.GetPackage() == "BD_HARTSOCK" || VoiceType.GetPackage() == "BD_BAKER" ||
				VoiceType.GetPackage() == "BD_CMD_GER_A" || VoiceType.GetPackage() == "BD_CMD_GER_B" ||
				VoiceType.GetPackage() == "BD_CMD_EGA_A" || VoiceType.GetPackage() == "BD_CMD_EGA_B" ||
				VoiceType.GetPackage() == "BD_CMD_ENG_A" || VoiceType.GetPackage() == "BD_CMD_ENG_B" )
			{
				//log( "gbxPawn::PlaySpeechDirect() - PlayOwnedSoundMPB(" $ snd $ ")", 'RSC' );
				iSoundHandle = PlayLocalSound( snd, SLOT_Talk );
				//PlayRemoteSound( snd, SLOT_Talk );	// play command for other clients
			}
		}
	}

	if( iSoundHandle < 0 )
	{
		//log( "WARNING: gbxPawn::PlaySpeechDirect() - iSoundHandle=" $ iSoundHandle, 'RSC' );
		return false;
	}

	//log( "gbxPawn::PlaySpeechDirect() returned true (iSoundHandle=" $ iSoundHandle $ ")", 'RSC' );
	return true;
}

event StopSpeech( int SoundHandle )
{
	if ( SoundHandle > -1 )
	{
		if (Level.NetMode == NM_Standalone)
		{		
			StopSound( SoundHandle );
		}
		else
		{
			// TODO: stop speech in MP
		}
	}
}

function Cue GetCuePlayerSayingMyName()
{
	if ( VoiceType != None )
		return VoiceType.GetCuePlayerSayingMyName();
	else
		return None;
}

// GBX:PAD: These are accessor functions for outside code (e.g. the mind) to call when trying to set up the weapon related
// functions.

//-------------------------------------
// GBX:PAD: Weapon switching functions
//-------------------------------------

simulated function bool CanToggleWeapon()
{
	local	Inventory	anItem, aNewItem;

	if( Level.IsPaused() )
		return false;

	anItem = Inventory;
	while (anItem != None)
	{
		if ((gbxWeapon(anItem) != None) && (anItem != Weapon))
			if (gbxWeapon(anItem).m_eWeaponType == WeaponPrimary)
			{
				aNewItem = Weapon(anItem);
				break;
			}
		anItem = anItem.Inventory;
	}
	if (anItem != None)
		return true;
		
	return false;
}

// Toggle between the two character held weapons
simulated function ToggleWeapon()
{
	local	Inventory	anItem;

	if( Level.IsPaused() )
		return;

	if (Weapon.ClientState != Weapon.EWeaponClientState.WS_ReadyToFire)
		return;
		
	if ( Weapon == None )
	{
		anItem = Inventory;
		while (anItem != None)
		{
			if (gbxWeapon(anItem) != None)
				if (gbxWeapon(anItem).m_eWeaponType == WeaponPrimary)
				{
					PendingWeapon = Weapon(anItem);
					break;
				}
			anItem = anItem.NextWeapon(None, None);
		}
		if (anItem != None)
			ChangedWeapon();

		return;
	}

	if ((gbxWeapon(Weapon) != None) && !gbxWeapon(Weapon).m_fCanZoom)
	{
		return;
	}
	
	if ( PendingWeapon != None )
		PendingWeapon = Inventory.NextWeapon(None, PendingWeapon);
	else
		PendingWeapon = Inventory.NextWeapon(None, Weapon);

	if ( PendingWeapon != None )
		Weapon.PutDown();
}

// Set the characters weapon to a specific one (mostly used for setting mounted weapons).
function SetWeapon( Weapon aWeapon )
{
	PendingWeapon = aWeapon;

	//if (PendingWeapon != None)
	if ( Weapon != None )
	{
		Weapon.PutDown();
	}
	else
	{
		ChangedWeapon();
	}
}

//----------------------------------------------------------------------
// GBX:PAD: Weapon interaction functions (e.g. fire, reload, check ammo)
//----------------------------------------------------------------------

function SetWeaponAimedState( EWeaponAimedStateTypes eNewState )
{
	if (eWeaponAimedState != eNewState)
	{
		log(self$".SetWeaponAimedState( "$eNewState$" )", 'pad' );
		eWeaponAimedState = eNewState;
		PlayWaiting();
		if (eWeaponAimedState == WAS_Relaxed)
		{
			bDoTorsoTwist = false;
		}
		else
		{
			bDoTorsoTwist = true;
		}
	}
}

function bool TestWeaponAimedState( EWeaponAimedStateTypes eState )
{
	return (eWeaponAimedState == eState);
}

function bool IsWeaponFiring()
{
	if (gbxWeapon(Weapon) != None)
	{
		return gbxWeapon(Weapon).IsWeaponFiring();
	}
	else
		return false;
}

// Start the character firing their weapon
function StartFiringWeapon()
{
	if (gbxWeapon(Weapon) != None)
	{
		gbxWeapon(Weapon).StartFiringWeapon();
	}
}

// Stop the character's firing their weapon
function StopFiringWeapon()
{
	if (gbxWeapon(Weapon) != None)
	{
		gbxWeapon(Weapon).StopFiringWeapon();
	}
}

// Start the character firing a burst from their weapon
event FireWeaponBurst( int nNumShots )
{
	if (gbxWeapon(Weapon) != None)
	{
		gbxWeapon(Weapon).FireWeaponBurst( nNumShots );
	}
}

// Cause the character to manually reload their weapon
simulated function ReloadWeapon()
{
	if (gbxWeapon(Weapon) != None)
		gbxWeapon(Weapon).ReloadWeapon();
}

// Check to see if the character is in a state where they can fire
function bool CanFireWeapon()
{
	if (gbxWeapon(Weapon) != None)
		return gbxWeapon(Weapon).CanFireWeapon();
	return false;
}

// Check to see if the character has adequete ammo
function bool IsWeaponAmmo()
{
	return true;
}

// Check to see if the character is low on ammo
function bool IsWeaponAmmoLow()
{
	return true;
}

//--------------------------------------------------------------------
// GBX:PAD: Disposition altering functions (e.g. stand, crouch, prone)
//--------------------------------------------------------------------

function bool IsCrouchedOrGoingToCrouch()
{
	return bIsCrouched || bWantsToCrouch;
}

// Transition the character to a crouching position
function StartGoingToCrouch( optional bool bSkipAnim )
{
	if (bIsCrouched)
		return;

	log(self$".StartGoingToCrouch() - "$bIsCrouched$" - "$m_fDispositionAnimPlaying, 'pad');
	bWantsToCrouch = true;
	bWantsToGoProne = false;
//	m_fStartDispositionChange = true;
}

// Transition the character to a prone position
function StartGoingToProne()
{
	if (bIsProne)
		return;

//	bWantsToGoProne = true;
//	bWantsToCrouch = false;
//	m_fStartDispositionChange = true;
}

// Transition the character to a standing position
function StartGoingToStand( optional bool bSkipAnim )
{
	if (!bIsCrouched && !bIsProne)
		return;

	log(self$".StartGoingToCrouch() - "$bIsCrouched$" - "$m_fDispositionAnimPlaying, 'pad');
	bWantsToCrouch = false;
	bWantsToGoProne = false;

//	m_fStartDispositionChange = true;
}

function StartThirdPersonReload()
{	
	// AI-controlled NPCs only: 1st person reload animation has to wait for the 3rd person reload anim to finish.
	if ( !IsHumanControlled() )
	{
		m_bReloadingThirdPerson = true;
		ThirdPersonReloadStartTime = Level.TimeSeconds;
	}
}

function StopThirdPersonReload()
{
	// AI-controlled NPCs only: 1st person reload animation has to wait for the 3rd person reload anim to finish.
	if ( !IsHumanControlled() )
	{
		m_bReloadingThirdPerson = false;
		ThirdPersonReloadStartTime = 0.0f;
		
		if ( Weapon != None )
			Weapon.NotifyThirdPersonReloadFinished();
	}
}

function bool IsReloadingThirdPerson()
{
	// AI-controlled NPCs only: 1st person reload animation has to wait for the 3rd person reload anim to finish.
	if ( !IsHumanControlled() )
	{
		if ( m_bReloadingThirdPerson && Level.TimeSeconds > (ThirdPersonReloadStartTime + 4.0f ) )
		{
			StopThirdPersonReload();
		}

		return m_bReloadingThirdPerson;
	}
	else
	{
		return false;
	}
}

function StartFlinching() 
{
	m_bFlinching = true;
	FlinchStartTime = Level.TimeSeconds;
	m_fWeaponRightHand = true;
	Weapon.AttachToPawn( self );
}

function StopFlinching() 
{
	m_bFlinching = false;
	FlinchStartTime = 0.0f;
}

function bool IsFlinching()
{
	if ( m_bFlinching && Level.TimeSeconds > (FlinchStartTime + 4.0f ) )
	{
		StopFlinching();
	}

	return m_bFlinching;
}

//-------------------------------------------------------------------------------------
// GBX:PAD: Visual behavior altering functions (e.g. facial expression, gestures, etc).
//-------------------------------------------------------------------------------------

// Set the facial animation that will be blended in above the neck bone
// The actual code for this function is defined elsewhere, but I put the comment here so that it would be with all the
// other pawn access functions.
function AnimFacialExpression( name szFacialAnim, optional float Rate, optional float Tween, optional float Blend )
{
}

// allow periodic and/or situational updated of Pawn's facial expression
function SetFacialExpression( name szFacialAnim )
{
}

// Play a gesture animation.  If bTorsoOnly is set, the gesture will only be played above the hip bone, and it can be
// played while in motion.  If bNoInterrupt is set, then the animation will have to fully play out before other animations
// such as firing or reloading can be run.
//
// True == Queued up an animation.  False == Couldn't play an anim.
function bool PlayGestureAnim( name szGestureAnim, bool bNoInterrupt )
{
	return false;
}

// GBX:naj - added 9/23/03
function bool ApproveShot()
{
	// Override me.
	return true;
}

//--------------------------------------
// GBX:naj: Teammate/Enemy iterator functions.
//--------------------------------------
native function int GetNextTeammate( int index, out gbxPawn gbxP );
native function int GetNextTeammateByTeam( int team, int index, out gbxPawn gbxP );
native function int GetNextEnemy( int index, out gbxPawn gbxP );
native function int GetNextEnemyByTeam( int team, int index, out gbxPawn gbxP );

//--------------------------------------
// GBX:pad: Weapon bob functions.
//--------------------------------------
native function CalculateWalkingWalkBob( float DeltaTime, Vector Y );

//--------------------------------------
// GBX:PAD: Focus/aim related functions.  NOTE: Facing indicates the orientation of the body, LookingAt indicates
// the orientation of the head and eyes.
//--------------------------------------

// Is the body facing the target actor?
function bool IsFacingTarget()
{
	return Controller.IsFacingFocus();
}

// Is the body facing a given rotator?
function bool IsFacingRotator( rotator testRot, int Threshold )
{
	local int diff;

	diff = testRot.Yaw - Rotation.Yaw;
	diff = abs(diff);

	if ( diff > 32768)
		diff = 65536 - diff;
	
	if( diff > Threshold )
		return false;

	return true;
}

// Is the weapon aiming toward the target actor?
function bool IsAimingAtTarget()
{
	if (DrawType == DT_StaticMesh)
		return true;
		
	return (bIsAtAiming && TorsoLookAt);
}

// Is the eyes and/or head facing the target actor?
function bool IsLookingAtTarget()
{
	if (DrawType == DT_StaticMesh)
		return true;

	return bIsAtLooking;
}

// Set a target for the body to face.  If bOverrideHead is set, then also focus the head to look at this target.
function SetFacingTarget( Actor aTarget, bool bOverrideHead, bool bOverrideTorso )
{
	if (bOverrideHead)
	{
		StopLookAt( true, true, false );
	}

	if (bOverrideTorso)
	{
		StopLookAt( false, false, true );
	}

	log(self$".SetFacingTarget( "$aTarget$", "$bOverrideHead$", "$bOverrideTorso$" )", 'pad');
	Controller.Focus = aTarget;		// TODO Set mind focus here?
}

// This is mostly for internal use.  Basically, reset the nine point blend when we aren't aiming at anything
function ResetNinePointBlend()
{
}

// GBX:naj - added 9/14/03 - Set an aiming target by vector.  Mostly for use with turret weapons.
function SetAimingAtVector( Vector TargetVect )
{
	// TBD
}

// Set a target for the weapon to aim toward.
function SetAimingAtTarget( Actor aTarget )
{
	if (aTarget == None)
	{
		StopLookAt( false, false, true );
		ResetNinePointBlend();
		ResetLookAtImmediate( false, false, true );
	}
	else
	{
		log(self$".SetAimAtTarget( "$aTarget$" )", 'pad');
		SetAimAtTarget( aTarget, true );
	}
}

// Set a target for the head to look at.
function SetLookingAtTarget( Actor aTarget, optional name szLookBoneName )
{
	if (!bPawnLooksAtTargets)
		return;

	if (aTarget == None)
	{
		ResetLookAt( true, true, false );
	}
	else
	{
		log(self$".SetLookAtTarget( "$aTarget$" )", 'pad');
		SetLookAtTarget( aTarget, true, true );
		if (aTarget.IsA('gbxPawn'))
		{
			gbxPawn(aTarget).m_szLookBoneName = szLookBoneName;
		}
	}
}

event bool ClaimNavPoint(ActorLite NavPointToClaim)
{
	local Pawn NavPointClaimant;
	local Pawn MyNavPointClaimant;

	if (NavPointToClaim == None)
	{
		Log(name $ " - ClaimNavPoint: ERROR - NavPointToClaim is NULL!!!");
		return false;  // can't claim null points
	}

	// I can only claim points that aren't already claimed (or are already claimed by me)
	NavPointClaimant = None;
	if (NavPointToClaim.bIsNavigationPoint)
		NavPointClaimant = NavigationPoint(NavPointToClaim).Claimant;
	else if (NavPointToClaim.bIsNavigationPointLite)
		NavPointClaimant = NavigationPointLite(NavPointToClaim).Claimant;

	if ((NavPointClaimant == None) || (NavPointClaimant == self))
	{
		// Unclaim my prior navpoint
		if (MyClaimedNavPoint != None)
		{
			MyNavPointClaimant = None;
			if (MyClaimedNavPoint.bIsNavigationPoint)
				MyNavPointClaimant = NavigationPoint(MyClaimedNavPoint).Claimant;
			else if (MyClaimedNavPoint.bIsNavigationPointLite)
				MyNavPointClaimant = NavigationPointLite(MyClaimedNavPoint).Claimant;

			if (MyNavPointClaimant != self)
			{
				Log(name $ " - ClaimNavPoint: ERROR - MyClaimedNavPoint "$MyClaimedNavPoint.Name$" is claimed by " $MyNavPointClaimant);
				return false;
			}

			if (MyClaimedNavPoint.bIsNavigationPoint)
				NavigationPoint(MyClaimedNavPoint).Claimant = None;  // release my previously claimed NavPoint
			else if (MyClaimedNavPoint.bIsNavigationPointLite)
				NavigationPointLite(MyClaimedNavPoint).Claimant = None;  // release my previously claimed NavPoint
		}

		if (NavPointToClaim.bIsNavigationPoint)
			NavigationPoint(NavPointToClaim).Claimant = self;
		else if (NavPointToClaim.bIsNavigationPointLite)
			NavigationPointLite(NavPointToClaim).Claimant = self;

		MyClaimedNavPoint = NavPointToClaim;
		return true;
	}

	Log(name $ " - ClaimNavPoint: ERROR - NavPointToClaim "$NavPointToClaim.Name$" is already claimed by " $ NavPointClaimant.name, 'pawn' );
	return false;  // can't claim points already claimed by someone else
}

event UnClaimNavPoint()
{
	local Pawn NavPointClaimant;
	
	// Unclaim my prior navpoint
	if (MyClaimedNavPoint != None)
	{
		NavPointClaimant = None;
		if (MyClaimedNavPoint.bIsNavigationPoint)
			NavPointClaimant = NavigationPoint(MyClaimedNavPoint).Claimant;
		else if (MyClaimedNavPoint.bIsNavigationPointLite)
			NavPointClaimant = NavigationPointLite(MyClaimedNavPoint).Claimant;

		if (NavPointClaimant != self)
		{
			Log(name $ " - UnClaimNavPoint: ERROR - MyClaimedNavPoint "$MyClaimedNavPoint$" is claimed by " $NavPointClaimant);
			return;
		}

		if (MyClaimedNavPoint.bIsNavigationPoint)
			NavigationPoint(MyClaimedNavPoint).Claimant = None;  // release my previously claimed NavPoint
		else if (MyClaimedNavPoint.bIsNavigationPointLite)
			NavigationPointLite(MyClaimedNavPoint).Claimant = None;  // release my previously claimed NavPoint

		MyClaimedNavPoint = None;
	}
}

event SetMyRecentlyTouchedNavPoint(ActorLite NavPoint)
{
	MyRecentlyTouchedNavPoint = NavPoint;
}

simulated function SetWeaponAnims( class<ItemPawnAnimInfo> AnimInfoClass, bool bUnlinkOldAnims )
{
	local MeshAnimation	aMeshAnim;

	if (Level.bUrbanCover)
	{
		aMeshAnim = MeshAnimation(DynamicLoadObject("a_corner_city.a_corner_city",class'MeshAnimation'));
	}
	else
	{
		aMeshAnim = MeshAnimation(DynamicLoadObject("a_corner_standard.a_hold_rifle",class'MeshAnimation'));
	}
	if (aMeshAnim != None)
	{
		LinkSkelAnim(aMeshAnim);
	}
	PawnAnimInfoClass = AnimInfoClass;
	if ((PawnAnimInfoClass.Default.WeaponAnimSet != "") && (PawnAnimInfoClass.Default.WeaponAnimSet != CurMeshAnimName))
	{
		aMeshAnim = MeshAnimation(DynamicLoadObject(PawnAnimInfoClass.Default.WeaponAnimSet,class'MeshAnimation'));
		if (aMeshAnim != None)
		{
			if ((MeshAnim != None) && bUnlinkOldAnims)
				UnlinkSkelAnim(MeshAnim, false);
			if (LinkSkelAnim(aMeshAnim))
			{
				MeshAnim = aMeshAnim;
				MeshAnimName = PawnAnimInfoClass.Default.WeaponAnimSet;
				CurMeshAnimName = MeshAnimName;
			}
			bInitializeAnimation = false;
		}

		// GBX:PAD: In multiplayer, just to make sure we don't end up in a reference pose briefly, make sure to
		// flush the animation queue so no stray idles come in.
		FlushAnimQueueChannel( 0,, true );
		
		// GBX:PAD: I moved these in here since it didn't make sense to call playwaiting and playmoving unless the weapon
		// type actually changed.		
		PlayWaiting();
		PlayMoving();
	}
}

function bool IsTransitioning() { return false; }

function bool IsOkayToUnlink()
{
	// custom death animations can come from other animation sets and we don't want them unloaded when weapons are switched out
	if (bUseCustomDeathAnim)
		return false;

	return !IsTransitioning();
}

event bool GetLastVantagePoint( out ActorLite VantagePoint )
{
	return false;
}

event bool IsFiringFromCover()
{
	if ( IsHumanControlled() || Controller == None || !Controller.IsA( 'gbxAIController' ) )
		return false;
	else
	{
		return gbxAIController( Controller ).IsFiringFromCover();
	}
}

event bool IsCoveredFrom( Vector ThreatLocation, out ActorLite CoverPoint )
{
	return false;
}

simulated event IShotAtYou( gbxPawn Instigator, bool bIsWarningShot ) {} // Implement me.

function NewTargetForSpotter( gbxPawn NewTarget );	// Implement me.

function PointAtSpottedTarget();	// Implement me.

function BreakOutOfJob();			// Implement me.

function bool CanCrewTurret( TurretWeapon TheTurret );		// Implement me.

// Implement me.
function CrewTurret( TurretWeapon NewTurret, class<gbxAIController> NewMindClass, EJobType NewJob );

// Implemented in gbxGameplay.gbxPlayerPawn
function DoMeleeTrauma();
function BeginTraumaCam();
function EndTraumaCam();
function StartTraumaSound();

function ServerChangedWeapon(Weapon OldWeapon, Weapon NewWeapon)
{
	Super.ServerChangedWeapon( OldWeapon, NewWeapon );

	ClientChangedWeapon( Weapon );
}

simulated function ClientChangedWeapon( Weapon newWeapon )
{
	Weapon = newWeapon;
	if ( Weapon != None )
		Weapon.AttachToPawn(self);
}

// amb ---
function vector CameraShake()
{
    local vector x, y, z, shakevect;
    local PlayerController pc;

	if ((Controller == None) || (!Controller.bIsHumanPlayer))
		return shakevect;

    pc = PlayerController(Controller);

    if (pc == None)
        return shakevect;

    GetAxes(pc.Rotation, x, y, z);

    shakevect = pc.ShakeOffset.X * x +
                pc.ShakeOffset.Y * y +
                pc.ShakeOffset.Z * z;

//    return shakevect;
    return (pc.ShakeOffset * 0.9);
}
// --- amb


event Approaching(Actor Other, Vector OtherMovementDirection)
{
	// some other Actor is approaching this gbxPawn...
}


function SetCharacterType( int nCharType )
{
	m_nCharType = nCharType;
	m_nNewCharType = nCharType;
}

simulated function String GetCharacterFacialPackage()
{
	if (CharacterSetupClass != None)
		return CharacterSetupClass.Static.GetCharacterFacialPackage(m_nCharType);
	else
		return "";
}

simulated function Name GetCharacterHead()
{
//	if ((CharacterSetupClass != None) && ((Level.NetMode != NM_StandAlone) || (m_nCharType != 0)))
	if (CharacterSetupClass != None)
		return CharacterSetupClass.Static.GetCharacterHead(m_nCharType);
	else
		return '';
}
simulated function string GetCharacterVoiceType( optional bool bIsDemoBuild )
{
	if (CharacterSetupClass != None)
		return CharacterSetupClass.Static.GetCharacterVoiceType(m_nCharType,bIsDemoBuild);
	else
		return "";
}
simulated function float GetCharacterScale()
{
	if (CharacterSetupClass != None)
		return CharacterSetupClass.Static.GetCharacterScale(m_nCharType);
	else
		return 1.0f;
}
simulated function float GetCharacterRank()
{
	if (CharacterSetupClass != None)
		return CharacterSetupClass.Static.GetCharacterRank(m_nCharType);
	else
		return 0.0f;
}
simulated function string GetCharacterName()
{
	if (CharacterSetupClass == class'CharacterSetupGermany')
		return CharacterSetupClass.Static.GetCharacterName(Level.BaseUnitSkillLevel);
	else
		return CharacterSetupClass.Static.GetCharacterName(m_nCharType);
}

simulated event string GetCharacterRankName()
{
	if (CharacterSetupClass == class'CharacterSetupGermany')
		return CharacterSetupClass.Static.GetCharacterName(Level.BaseUnitSkillLevel);
	else
		return CharacterSetupClass.Static.GetCharacterRankName(m_nCharType);
}

simulated function name GetCharacterFName()
{
	if ( CharacterSetupClass != None )
	{
		return CharacterSetupClass.Static.GetCharacterFName(m_nCharType);
	}
	else
	{
		return '';
	}
}

simulated function string GetCharacterPortrait()
{
	if (CharacterSetupClass == class'CharacterSetupGermany')
	{
//		if (Level.IsXbox())
//		{
			return CharacterSetupClass.Static.GetCharacterPortrait(Level.BaseUnitSkillLevel);
//		}
//		else
//		{
//			return CharacterSetupClass.Static.GetCharacterPortrait(MyUnit.BaseSkillLevel);
//		}
	}
	else
		return CharacterSetupClass.Static.GetCharacterPortrait(m_nCharType);
}

function ClearProtectionTimer()
{
	LongTimerStart = 0.0f;
	ShortTimerStart = 0.0f;	
}

function bool DoWarningShot() 
{ 
	if ( !bEnableProtectionTimers )
		return false;

	// Has protection timer never been used, or has it expired?
	if ( LongTimerStart < 0.00001f || Level.TimeSeconds > ( LongTimerStart + TimerTotalDur ) )
	{		
		LongTimerStart = Level.TimeSeconds;
		ShortTimerStart = LongTimerStart + ( LongTimerDur - ShortTimerDur );
		//log("NAJ**** Starting new Protection Timer at "$LongTimerStart$" ; ShortTimerStart at "$ShortTimerStart$" ; 1st period expires "$(LongTimerStart+LongTimerDur), 'naj' );
		return true;
	}
	// Is the pawn still being protected by the first period of invincibility?
	else if ( Level.TimeSeconds < ( LongTimerStart + LongTimerDur ) )
	{
		//log("NAJ**** Still being protected by first period at "$Level.TimeSeconds, 'naj' );
		return true;
	}
	// Is the pawn being protected by the second period of invincibility?
	else if ( Level.TimeSeconds < ( ShortTimerStart + ShortTimerDur ) )
	{
		//log("NAJ**** Being protected by second period at "$Level.TimeSeconds, 'naj' );
		return true;
	}
	// Has the pawn passed the second invincibility period and entered the "vulnerable" window?
	// If so, let him get damaged and start a second period of invincibility.
	else if ( Level.TimeSeconds < ( ShortTimerStart + ShortTimerDur + VulnerableDur ) )
	{		
		ShortTimerStart = Level.TimeSeconds;
		//log("NAJ**** DAMAGE ALLOWED.  Starting second period at "$ShortTimerStart$" ; expires "$(ShortTimerStart+ShortTimerDur), 'naj' );
		return false;
	}
	// The pawn has survived long enough for the "vulnerable" window to elapse.
	// He's back in the second period of invincibility.
	else
	{		
		ShortTimerStart = Level.TimeSeconds;
		//log("NAJ**** Pawn outlasted vulnerability window.  Starting second period at "$ShortTimerStart$" ; expires "$(ShortTimerStart+ShortTimerDur), 'naj' );
		return true;
	}
}

function RegisterDamageWithProtectionTimer()
{
	//LastDamagedTime = Level.TimeSeconds;
}

/* PossessedBy()
 Pawn is possessed by Controller
*/
function PossessedBy(Controller C)
{
	local MeshAnimation	aMeshAnim;
	local string CharFacialPkg;
	
	Super.PossessedBy( C );

	if ((Controller != None) && (!Controller.bIsHumanPlayer))
	{
		log(self$" emotion package set to "$GetCharacterFacialPackage(), 'pad');
		CharFacialPkg = GetCharacterFacialPackage();
		if (CharFacialPkg != "")
		{
			aMeshAnim = MeshAnimation( DynamicLoadObject(CharFacialPkg, class'MeshAnimation') );
			if (aMeshAnim != None)
			{
				LinkSkelAnim(aMeshAnim);
			}
		}
	}
}

simulated event PostNetReceive()
{
	local MeshAnimation	aMeshAnim;
	local ExtendedAttachmentInfo	anEAInfo;
	local String facialPackage;
	local int			j;
	
	Super.PostNetReceive();
	
	if (Role < ROLE_Authority)
	{
		if (m_nCharType != m_nNewCharType)
		{
			m_nCharType = m_nNewCharType;
			facialPackage = GetCharacterFacialPackage();

			log(self$" emotion package set to a_ev_" $ facialPackage);
			if (facialPackage != "")
			{
				aMeshAnim = MeshAnimation(DynamicLoadObject(facialPackage, class'MeshAnimation'));
				if (aMeshAnim != None)
				{
					LinkSkelAnim(aMeshAnim);
				}
			}

			if (GetCharacterHead() != '')
			{
				if ((ExtendedAttachments.Length <= 0) || (ExtendedAttachments[0] == None))
				{
					anEAInfo = new( Level.Outer ) class'ExtendedAttachmentInfo';
					anEAInfo.m_nmSocketName = 'Head';
					anEAInfo.m_nmPartName = GetCharacterHead();

					ExtendedAttachments[0] = anEAInfo;
					ExtendedAttachments[0].m_AttachedPart = Spawn( class'AttachedPart', self );
				}
				else
				{
					if (GetCharacterHead() != '')
					{
						ExtendedAttachments[0].m_nmPartName = GetCharacterHead();
					}
				}
				
				if (ExtendedSkins.Length > 0)
				{
					for (j = 0; j < ExtendedSkins.Length; j++)
					{
						if (ExtendedSkins[j] != None)
						{
							ExtendedAttachments[0].m_AttachedPart.Skins[j] = ExtendedSkins[j];
						}
					}
				}
				
				if (ExtendedAttachments[0].m_szGroupName != "")
					ExtendedAttachmentNamedGroup( ExtendedAttachments[0].m_AttachedPart, ExtendedAttachments[0].m_szGroupName );
				else
					ExtendedAttachment( ExtendedAttachments[0].m_AttachedPart, ExtendedAttachments[0].m_nmSocketName, ExtendedAttachments[0].m_nmPartName );
			}
				
			SetVoiceType( GetCharacterVoiceType( Level.IsDemoBuild() ) );

			if (m_flLegScale == 1.0f)
			{
				m_flLegScale = GetCharacterScale();
				if (m_flLegScale != 1.0f)
				{
					ChangeCharacterHeight();
				}
			}

			Portrait = Texture( DynamicLoadObject( GetCharacterPortrait(), class'Texture' ));
		}
	}
}

function float GetIdealGroundSpeed();
function float GetIdealBaseMovementRate();

simulated function bool SpecialCalcView( out actor ViewActor, out vector CameraLocation, out rotator CameraRotation )
{
	local vector CamLookAt;

	if(bUseFaceCam)
	{
		// Look at face
		CamLookAt = GetBoneCoords(LeftEye).Origin;
		CameraLocation = CamLookAt + (vect(30, 0, 0) >> CameraRotation);
		CameraRotation = rotator(CamLookAt-CameraLocation);
		return true;
		}
	else
	{
		return super.SpecialCalcView( ViewActor, CameraLocation, CameraRotation );
	}
}

function SetTransitioningToRelaxed( bool bTransitioning )
{
	m_bTransitioningToRelaxed = bTransitioning;
}

event bool UsedBy(Pawn User)
{
	if (m_szUsedByTrigger != '')
	{
		TriggerEvent(m_szUsedByTrigger, Controller, self);
		return true;
	}
		
	return false;
}

event bool CanBeAttackedBy( Weapon aWeapon )
{
	// Overriden in Tank.
	return true;
}

event bool CanBeMeleed()
{
	// Overriden in Tank.
	return true;
}

function bool CanPlaceTNT() { return false; }
function PlaceTNT( Actor Target, TNTTrigger TheTNTTrigger ) {}
function TNTPlantAnimFinished() {}
function TNTMountAnimFinished() {}
function TNTDismountAnimFinished() {}

function bool CanGrenadeTank() { return false; }
function GrenadeTank( gbxPawn Target ) {}
function TankGrenadeAnimZoomIn() {}

simulated function PlayReloadTurret() {}

simulated function ChangeCharacterHeight();
/*
event PreRenderActor()
{
	SetCharacterRank( GetCharacterRank() );
}
*/
function bool RestockWeapons( WeaponLoadoutInfo WeaponInfo, int MaxWeaponPickupsCreated );
function bool RestockUsables( UsableLoadoutInfo WeaponInfo );

native function Vector GetEyePointAtPosture( int Posture, optional Vector FromLocation, optional bool bFromShoulders );

function bool IsNavigating()
{
	if ( Controller == None )
		return false;
	else if ( Controller.IsA( 'gbxAIController' ) )
	{
		return gbxAIController( Controller ).IsNavigating();
	}
	else
		return false;
}

function BlockingVolumeTeamSpecific IsTouchingTeamBlockingVolume()
{
	local BlockingVolumeTeamSpecific v;

	foreach TouchingActors(class'BlockingVolumeTeamSpecific', v)
	{
		return v;
	}

	return None;
}

function bool HasBetterWeaponThan( gbxPawn Other )
{
	local gbxWeapon MyWeapon, OtherWeapon;

	if ( Weapon == None || Other.Weapon == None )
		return false;
	else
	{
		MyWeapon = gbxWeapon( Weapon );
		OtherWeapon = gbxWeapon( Other.Weapon );
		if ( MyWeapon == None || OtherWeapon == None )
			return false;
		else
			return MyWeapon.IsBetterWeaponThan( OtherWeapon );
	}
}

simulated function DoBuzzView() {} // Overriden in gbxPlayerPawn

simulated function CreateTeamLogoShadowByTeam( optional ETeamIdentifier team )
{
	if (team == TEAM_None)
	{
		team = PawnTeam;
	}

	if ( team == TEAM_US )
	{
		CreateTeamLogoShadow("t_interface_mb.shadow_us_star");
	}
	else if ( team == TEAM_German )
	{
		CreateTeamLogoShadow("t_interface_mb.shadow_de_cross");
	}
}

simulated function CreateTeamLogoShadow( string texture )
{
	local BitmapMaterial ShadowTexture;
	ShadowTexture = BitmapMaterial( DynamicLoadObject( texture, class'Texture') );
	
	if ( ShadowTexture != None )
	{
		TeamLogoShadow = Spawn(class'TeamLogoProjector',None,'',Location);
		TeamLogoShadow.ShadowActor = self;
		TeamLogoShadow.LightDirection = vect(0,0,1);
		TeamLogoShadow.LightDistance = 250;
		TeamLogoShadow.MaxTraceDistance = 350;
		TeamLogoShadow.RootMotion = true;
		TeamLogoShadow.InitShadow(ShadowTexture, false);
		TeamLogoShadow.SetDrawScale(1.0);
		TeamLogoShadow.FOV = 1;	
//		TeamLogoShadow.ShadowActor = None;
		TeamLogoShadow.SetProjectorActor( None );
	}
}

simulated function DrawSelfForGBXHud(canvas Canvas, gbxHud Hud, FontInfo Fonts, int nPass);

// Override in tank child classes.
function bool IsTank() { return false; }
function bool IsTankCommander() { return false; }
function Pawn GetMyTank() { return None; }
function bool IsTankCommanderButtonedUp() { return true; }
function MakeTankCommanderGoInQuick() {}

simulated function bool DisarmWeapon( name BoneName )
{
	if (Weapon != None)
	{
		return Weapon.DisarmWeapon( BoneName );
	}
	return false;
}

simulated function bool RearmWeapon( name BoneName )
{
	if (Weapon != None)
	{
		return Weapon.RearmWeapon( BoneName );
	}
	return false;
}

function bool RepelsBullets( optional out float CutoffDistance )
{
	CutoffDistance = RepelBulletsCutoffDist;
	return bRepelBullets;
}

function SetRepelBullets( bool bRepel, optional float CutoffDistance )
{
	bRepelBullets = bRepel;
	RepelBulletsCutoffDist = CutoffDistance;
}

function LookAtPlayerOverShoulder( bool bLook ) {}

simulated function DoMeleeLunge();
simulated function CheckMeleeSuccess();
simulated function MortarFire();

simulated event PostRespawnPlay()
{
	Super.PostRespawnPlay();
	
	SetPhysics( PHYS_None );
	m_fRunningTorsoAnim = false;
	G_OverthrowFactor = Default.G_OverthrowFactor;
	G_FrustrationFactor = Default.G_FrustrationFactor;
	m_nCharType = Default.m_nCharType;
	m_nNewCharType = Default.m_nNewCharType;
	
	karma_need_to_wakeup = false;
	bEnableProtectionTimers = true;
}

simulated event int GetDefaultHealth()
{
	return default.Health;
}

simulated function Pawn GetPlayerLeader()
{
	if (MyUnit != None)
	{
		if (MyUnit.SuperUnit != None)
		{
			if (MyUnit.SuperUnit.Leader.Controller.IsA('PlayerController'))
			{
				return MyUnit.SuperUnit.Leader;
			}
		}
		else
		{
			if (MyUnit.Leader.Controller.IsA('PlayerController'))
			{
				return MyUnit.Leader;
			}
		}
	}
	return None;
}

simulated function bool IsSameFireTeamType( Unit aUnit )
{
	if (MyUnit.UnitType == aUnit.UnitType)
	{
		return true;
	}
	return false;
}

simulated function int GetFireTeamType()
{
	log (self$".GetFireTeamType() - "$MyUnit$" - "$MyUnit.UnitType);
	if (MyUnit != None)
	{
		return MyUnit.UnitType;
	}
	else
	{
		return Super.GetFireTeamType();
	}
}

simulated function bool ContainsPawn(gbxPawn SomeOtherPawn)
{
	// does this pawn contain some other pawn (like tank commanders riding in tanks?)...
	return false;
}

simulated function gbxPawn GetInspectorPawn()
{
	return self;
}

defaultproperties
{
	// don't change the default Physics property otherwise guys fall through terrain!!!
	Physics=PHYS_None

	BaseEyeHeight=79.0
	EyeHeight=79.0
	CrouchHeight=51.0

	MeleeRange=+20.0
	ControllerClass=class'Engine.Controller'
//	bMuffledHearing=true
	bMuffledHearing=false  // this is SLOW (does a line check for each sound heard)
	bLOSHearing=false  // this is SLOW (does a line check for each sound heard)

	Buoyancy=+00099.000000
	UnderWaterTime=+00020.000000
	GroundSpeed=+00600.000000
	AirSpeed=+00600.000000
	WaterSpeed=+00300.000000
	AccelRate=+02048.000000
	JumpZ=+00540.000000
	MinJumpZ=+00200.000000
	bCanStrafe=True
	bCanSwim=true
	DrawType=DT_Mesh
	LightBrightness=70
	LightHue=40
	LightSaturation=128
	LightRadius=6
	RotationRate=(Pitch=0,Yaw=30000,Roll=2048)
	AmbientGlow=30
	AirControl=+0.35
	bStasis=false
	bCanCrouch=true
	bCanClimbLadders=True
	bCanPickupInventory=True
	WalkingPct=+0.3
//	SprintPct=1.7
	SprintPct=1.15
	ForceType=FT_DragAlong
	ForceRadius=100
	ForceScale=2.5
	SightRadius=+12000.0
	LoadOut=255
	AttackSuitability=+0.5
	bAcceptAllInventory=true
	bPlayOwnFootsteps=true

	Begin Object Class=KarmaParamsSkel Name=PawnKParams
	KFriction=0.6
	KRestitution=0.3
	KAngularDamping=0.05
	KLinearDamping=0.15
	KBuoyancy=1
	KStartEnabled=True
	KImpactThreshold=500
	KVelDropBelowThreshold=0.01
	KConvulseSpacing=(Min=0.5,Max=2.2)
	bHighDetailOnly=False
	Name="PawnKParams"
	End Object
	KParams=KarmaParams'PawnKParams'

	ViewKickMax=(x=16384,y=2048,z=4096)
	ViewKickReturnLagMax = 0.35
	ViewKickReturnLag = 0.0

	RagImpactCueName="IMPACTS.BODY_GROUND"
	RagImpactSoundInterval=0.25

	RagdollLifeSpan=8
	RagDeathVel=200
	RagInvInertia=4
	RagShootStrength=8000
	RagSpinScale=2.5
	RagDeathUpKick=150
	m_fRunningTorsoAnim=false

	VoiceTypeName="gbxCharacters.VoiceTypeDefault"

	G_MaxTargetRange=3072.0
	G_RangeAccuracyMod=(Min=0.75,Max=2.0)
	G_LobAccuracyMod=(Min=128,Max=1024)
	G_MaxLobHeight=1024.0
	G_OverthrowFactor=0.0
	G_FrustrationFactor=1.0

	bPawnLooksAtTargets=false

	m_fCanTalk=true

	FatigueRecovery_Novice=0.125		// 8 seconds to go from 1 to 0
	FatigueRecovery_Interm=0.154		// 6.5 seconds to go from 1 to 0
	FatigueRecovery_Advanced=0.182		// 5.5 seconds to go from 1 to 0
	FatigueRecovery_Veteran=0.25		// 4 seconds to go from 1 to 0
	//FatigueRecovery_Player=0.125		// 8 seconds
	FatigueRecovery_Player=0.25			// SJP: Reducing per Marc Blondeau's suggestion

	FatigueRate_Sprinting=0.33
	FatigueRate_Running=0.165			
	FatigueRate_Walking=0.03

	FatigueJog_Rotation=1.0				// Maximum jog
	FatigueJog_Suppression=0.02			// Moderate jog (over several bullets)
	//FatigueJog_PostureChange=0.15		// Mild jog
	FatigueJog_PostureChange_AI=0.15			// GBX:naj - Increasing to make sniping more difficult on the PC.
	FatigueJog_PostureChange_Player=1.0		// GBX:naj - Increasing to make sniping more difficult on the PC.

	//FatigueJog_PlayerFiredShot=0.0		// SJP: Reducing per Marc Blondeau's suggestion
	//FatigueJog_PlayerFiredShot=1.0		// GBX:naj - Increasing to make sniping more difficult on the PC.
	FatigueJog_PlayerFiredShot=0.3			// GBX:naj - Decreased because it was too frustrating.
	FatigueJog_PlayerJump=1.0
	FatigueJog_PlayerWarningShot=1.0

	FatigueJogInterval=2.0				// Allow no more than 1 jog in any 2 second period

	m_nCharType=9
	m_nNewCharType=0
	
	karma_need_to_wakeup=false
	bEnableProtectionTimers=true

	EyeHeightDiff=71.0f
	EyeToShoulderHeightDiff=17.0f	

	flSecondaryUIFadeTime = 3;			// Initialize grenade icon fade so that when the game starts it will fade out
	
	SupressTalkToMessage = false;

	bIsVehicle=false
}
class gbxPawnList extends IgbxPawnList
	native
	notplaceable
	dependson(gbxPawn);



//---------------------------------------------------------
// Variables
//---------------------------------------------------------
var gbxPawnList		MyInstance;		// Singleton instance.
var Array<gbxPawn>	Germans;
var Array<gbxPawn>	Americans;
var Array<gbxPawn>	AllPawns;
var class<gbxPawn>	GermanClass, AmericanClass;

const SPAWN_CHARACTER_DELAY	=	0.1f;
var float			m_flNextSpawnTime;

function PostBeginPlay()
{
	Super.PostBeginPlay();
	GermanClass   = class<gbxPawn>( DynamicLoadObject( "gbxCharacters.InfantryGermany", class'Class' ) );
	AmericanClass = class<gbxPawn>( DynamicLoadObject( "gbxCharacters.InfantryUSA", class'Class' ) );
}

function bool CanSpawnNow()
{
	if (m_flNextSpawnTime > Level.TimeSeconds)
		return false;
	return true;
}

function float GetRespawnDelay()
{
	return (m_flNextSpawnTime - Level.TimeSeconds);
}

function IncrementRespawnDelay()
{
	if (m_flNextSpawnTime < Level.TimeSeconds)
		m_flNextSpawnTime = Level.TimeSeconds + SPAWN_CHARACTER_DELAY;
	else
		m_flNextSpawnTime = m_flNextSpawnTime + SPAWN_CHARACTER_DELAY;
}

function Pawn GetRespawnPawn( class<Pawn> pawnType )
{
	local	gbxPawn	aPawn;
	local	bool	bReturn;

	bReturn = false;
	if (pawnType.IsA('InfantryUSA'))
	{
		bReturn = GetRespawnAmerican( aPawn );
	}
	else if (pawnType.IsA('InfantryGermany'))
	{
		bReturn = GetRespawnGerman( aPawn );
	}
	
	if (bReturn)
	{
		return aPawn;
	}
	
	return None;
}

function Pawn GetGermanSpawn()
{
	local	gbxPawn	aPawn;
	local	bool	bReturn;
	
	bReturn = GetRespawnGerman( aPawn );
	if (bReturn)
	{
		return aPawn;
	}
	
	return None;
}

function Pawn GetAmericanSpawn()
{
	local	gbxPawn	aPawn;
	local	bool	bReturn;
	
	bReturn = GetRespawnAmerican( aPawn );
	if (bReturn)
	{
		return aPawn;
	}
	
	return None;
}

//---------------------------------------------------------
// NotRegistered
//---------------------------------------------------------
function bool IsRegistered( gbxPawn gbxP, Array<gbxPawn> theArray )
{
	local int x;
	for( x=0; x < theArray.Length; ++x)
		if ( theArray[x] == gbxP )
			return true;

	return false;
}

function execDumpPawnLists()
{
	local	int	i;
	
	for( i = 0; i < Germans.Length; i++ )
	{
		if ((Germans[ i ].Health > 0) && (Germans[ i ].bHidden == false))
			log("GermanPawnInList - "$Germans[ i ]$"- "$Germans[ i ].tag$" - "$Germans.Length);
	}

	for( i = 0; i < Americans.Length; i++ )
	{
		if ((Americans[ i ].Health > 0) && (Americans[ i ].bHidden == false))
			log("AmericanPawnInList - "$Germans[ i ]$"- "$Americans[ i ].tag$" - "$Americans.Length);
	}
}

function DumpGermanPawnList()
{
	local	int	i, count;
	
	count = 0;
	for( i = 0; i < Germans.Length; i++ )
	{
		if ((Germans[ i ].Health > 0) && (Germans[ i ].bDeleteMe != true))
		{
			log(Germans[ i ]$".DumpGermanPawnList() - "$Germans[ i ].tag$" - "$Germans[ i ].bHidden);
			count++;
		}
	}
	log(self$".DumpGermanPawnList() - "$count$" - "$Germans.Length);
}

function DumpAmericanPawnList()
{
	local	int	i, count;
	
	for( i = 0; i < Americans.Length; i++ )
	{
		if ((Americans[ i ].Health > 0) && (Americans[ i ].bDeleteMe != true))
		{
			log(Americans[ i ]$".DumpAmericanPawnList() - "$Americans[ i ].tag$" - "$Americans[ i ].bHidden);
			count++;
		}
	}
	log(self$".DumpAmericanPawnList() - "$count$" - "$Americans.Length);
}

//---------------------------------------------------------
// RegisterGbxPawn
//---------------------------------------------------------
function RegisterGbxPawn( gbxPawn gbxP )
{
	if ( gbxP.IsA( 'InfantryGermany' ) )
	{
//		DumpGermanPawnList();
		if ( !IsRegistered( gbxP, Germans ) )
		{
			Germans[ Germans.Length ] = gbxP;			// Implicitly lengthens array by 1.
		}
	}
	else if ( gbxP.IsA( 'InfantryUSA' ) )
	{
//		DumpAmericanPawnList();
		if ( !IsRegistered( gbxP, Americans ) )
		{
			//log("NAJ**** RegisterGbxPawn(): Added "$gbxP.Name, 'naj');
			Americans[ Americans.Length ] = gbxP;		// Implicitly lengthens array by 1.
		}
	}

	AllPawns[ AllPawns.Length ] = gbxP;			// Implicitly lengthens array by 1.
}

//---------------------------------------------------------
// RegisterGbxPawnByTeam
//---------------------------------------------------------
function RegisterGbxPawnByTeam( gbxPawn gbxP, int team)
{
	local ETeamIdentifier eTeam;

	// Thanks alot UnrealScript
	eTeam = ETeamIdentifier(team);

	if (eTeam == TEAM_US)
	{
//		DumpAmericanPawnList();
		if ( !IsRegistered( gbxP, Americans ) )
		{
			Americans[ Americans.Length ] = gbxP;		// Implicitly lengthens array by 1.
		}
	}
	else
	{
		if (eTeam == TEAM_German)
		{
//			DumpGermanPawnList();
			if ( !IsRegistered( gbxP, Germans ) )
			{
				Germans[ Germans.Length ] = gbxP;			// Implicitly lengthens array by 1.
			}
		}
	}

	AllPawns[ AllPawns.Length ] = gbxP;			// Implicitly lengthens array by 1.
}

//---------------------------------------------------------
// UnRegisterGbxPawn
//---------------------------------------------------------
function UnRegisterGbxPawn( gbxPawn gbxP )
{
	local int index;

	if ( gbxP.IsA( 'InfantryGermany' ) )
	{
		for( index = 0; index < Germans.Length; ++index )
		{
			if ( Germans[index] == gbxP )
			{
				Germans.Remove( index, 1 );
				break;
			}
		}
	}
	else if( gbxP.IsA( 'InfantryUSA' ) )
	{
		for( index = 0; index < Americans.Length; ++index )
		{
			if ( Americans[index] == gbxP )
			{
				//log("NAJ**** Removing American "$gbxP.Name, 'naj');
				Americans.Remove( index, 1 );
				break;
			}
		}
	}
	else
	{
		// Otherwise do nothing; don't allow unregister from AllPawns unless gbxP belongs to one of the two classes.
		return;
	}

	// Remove the gbxP from AllPawns
	for( index = 0; index < AllPawns.Length; ++index )
	{
		if ( AllPawns[index] == gbxP )
		{
			AllPawns.Remove( index, 1 );
			return;
		}
	}
}

//---------------------------------------------------------
// Reset
//---------------------------------------------------------
function Reset()
{
	//log("NAJ**** Reset() called.", 'naj');

	if ( AllPawns.Length > 0 )
	{
		Americans.Remove( 0, Americans.Length );
		Germans.Remove( 0, Germans.Length );
		AllPawns.Remove( 0, AllPawns.Length );
	}
}

native function int GetGbxPawn( class<gbxPawn> WGClass, int index, out gbxPawn gbxP );
native function int GetGbxPawnByTeam( int team, int index, out gbxPawn gbxP );
native function int GetGerman( int index, out gbxPawn gbxP );
native function int GetAmerican( int index, out gbxPawn gbxP );
//native function int GetEither( int index, out gbxPawn gbxP );
native function bool GetRespawnGerman( out gbxPawn gbxP );
native function bool GetRespawnAmerican( out gbxPawn gbxP );

//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
	bHidden=true
	
	m_flNextSpawnTime=0.0
	RemoteRole=ROLE_None
	bKeepOnClient=true
}
class gbxPlaneCraft extends gbxSVehicle
	abstract
	native
	nativereplication;

cpptext
{
	INT* GetOptimizedRepList(BYTE* Recent, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel);

#ifdef WITH_KARMA
	// Actor interface.
	virtual UBOOL Tick(FLOAT DeltaTime, enum ELevelTick TickType);
	virtual void PostNetReceive();

	// SVehicle interface.
	virtual void UpdateVehicle(FLOAT DeltaTime);

	// SHover interface.
	virtual void PackState();
#endif
}

// Flying Parameters
var()   InterpCurve         LiftCoefficientCurve;
var()   InterpCurve         DragCoefficientCurve;
var()   float               AirFactor; // Technically this should be air density * wingspan area

var()	float				MaxThrust;
var()   float               ThrustAcceleration;

// Hovering Parameters
var()   bool                bHoverOnGround;
var()   float               COMHeight;
var()   InterpCurve         HoverForceCurve;

// Camera Parameters
var()   float               CameraSwingRatio;
var()   float               CameraDistance;

// Hover Stuff
var		array<vector>		ThrusterOffsets;
var()	float				HoverSoftness;
var()	float				HoverPenScale;
var()	float				HoverCheckDist;

// Internal
var		float				OutputThrust;
var		float				OutputStrafe;
var		float				OutputRise;

var     float               CurrentThrust;

var     float               AccumulatedTime;

var     float               LastCamTime;
var     rotator             LastCamRot;

//////////////////////////////////////////////////
// Physics
var()   float           PitchTorque;
var()   float           BankTorque;
//////////////////////////////////////////////////

// Replicated
struct native PlaneStateStruct
{
	var KRBVec				ChassisPosition;
	var Quat				ChassisQuaternion;
	var KRBVec				ChassisLinVel;
	var KRBVec				ChassisAngVel;

	var float				ServerThrust;
	var	float				ServerStrafe;
	var	float				ServerRise;
	var int                 ServerViewPitch;
	var int                 ServerViewYaw;
};

var		PlaneStateStruct	PlaneState, OldPlaneState;
var		KRigidBodyState		ChassisState;
var		bool				bNewPlaneState;

replication
{
	reliable if (bNetDirty && Role == ROLE_Authority)
		PlaneState;
}

simulated function PostNetBeginPlay()
{
	local vector RotX, RotY, RotZ;
	local KarmaParams kp;
	local KRepulsor rep;
	local int i;

    GetAxes(Rotation,RotX,RotY,RotZ);

	// Spawn and assign 'repulsors' to hold bike off the ground
	kp = KarmaParams(KParams);
	kp.Repulsors.Length = ThrusterOffsets.Length;

	for(i=0;i<ThrusterOffsets.Length;i++)
	{
    	rep = spawn(class'KRepulsor', self,, Location + ThrusterOffsets[i].X * RotX + ThrusterOffsets[i].Y * RotY + ThrusterOffsets[i].Z * RotZ);
    	rep.SetBase(self);
    	rep.bHidden = true;
    	kp.Repulsors[i] = rep;
    }

    Super.PostNetBeginPlay();
}

simulated event Destroyed()
{
	local KarmaParams kp;
	local int i;

	// Destroy repulsors
	kp = KarmaParams(KParams);
	for(i=0;i<kp.Repulsors.Length;i++)
    	kp.Repulsors[i].Destroy();

	Super.Destroyed();
}

simulated event bool KUpdateState(out KRigidBodyState newState)
{
	// This should never get called on the server - but just in case!
	if(Role == ROLE_Authority || !bNewPlaneState)
		return false;

	newState = ChassisState;
	bNewPlaneState = false;

	return true;
	//return false;
}

simulated event SVehicleUpdateParams()
{
	local KarmaParams kp;
	local int i;

	Super.SVehicleUpdateParams();

	kp = KarmaParams(KParams);

    for(i=0;i<kp.Repulsors.Length;i++)
	{
        kp.Repulsors[i].Softness = HoverSoftness;
        kp.Repulsors[i].PenScale = HoverPenScale;
        kp.Repulsors[i].CheckDist = HoverCheckDist;
    }
}

function int GetRotDiff(int A, int B)
{
	local int comp;

	comp = (A - B) & 65535;
	if(comp > 32768)
		comp -= 65536;

	return comp;
}

simulated function SpecialCalcBehindView(PlayerController PC, out actor ViewActor, out vector CameraLocation, out rotator CameraRotation )
{
   local vector CamLookAt, HitLocation, HitNormal;
   local float LerpAmount;
   local float CurTime;

   ViewActor = self;

   CurTime = Level.TimeSeconds;
   LerpAmount = 1.0 - ( CameraSwingRatio ** (CurTime - LastCamTime) );
   LastCamTime = CurTime;

/*   if(bRearView)
   {
      CamLookAt = Location;
      CameraRotation.Yaw = LastCamRot.Yaw + GetRotDiff(Rotation.Yaw + 32768, LastCamRot.Yaw) * LerpAmount;
      CameraRotation.Roll = 0;
      CameraRotation.Pitch = -4000;
   }
   else
   {*/
      CamLookAt = Location;
      CameraRotation.Roll = 0;
      CameraRotation.Yaw = LastCamRot.Yaw + GetRotDiff(Rotation.Yaw, LastCamRot.Yaw) * LerpAmount;
      CameraRotation.Pitch = -4000;
   //}

    CameraLocation = CamLookAt + (CameraDistance * vect(-1, 0, 0) >> CameraRotation);
    if( Trace( HitLocation, HitNormal, CameraLocation, CamLookAt, false, vect(10, 10, 10) ) != None )
    {
        CameraLocation = HitLocation;
    }

   LastCamRot = CameraRotation;
}

simulated function SpecialCalcFirstPersonView(PlayerController PC, out actor ViewActor, out vector CameraLocation, out rotator CameraRotation )
{
   local vector CamLookAt, HitLocation, HitNormal;
   local float LerpAmount;
   local float CurTime;

   ViewActor = self;

   CurTime = Level.TimeSeconds;
   LerpAmount = 1.0 - ( CameraSwingRatio ** (CurTime - LastCamTime) );
   LastCamTime = CurTime;

/*   if(bRearView)
   {
      CamLookAt = Location;
      CameraRotation.Yaw = LastCamRot.Yaw + GetRotDiff(Rotation.Yaw + 32768, LastCamRot.Yaw) * LerpAmount;
      CameraRotation.Roll = 0;
      CameraRotation.Pitch = -4000;
   }
   else
   {*/
      CamLookAt = Location;
      CameraRotation.Roll = 0;
      CameraRotation.Yaw = 16384 + LastCamRot.Yaw + GetRotDiff(Rotation.Yaw, LastCamRot.Yaw) * LerpAmount;
      CameraRotation.Pitch = -4000;
   //}

    CameraLocation = CamLookAt + (CameraDistance * vect(0, 1, 0) >> CameraRotation);
    if( Trace( HitLocation, HitNormal, CameraLocation, CamLookAt, false, vect(10, 10, 10) ) != None )
    {
        CameraLocation = HitLocation;
    }

   LastCamRot = CameraRotation;
}

defaultproperties
{
	CameraSwingRatio=0.02
	CameraDistance=900.0
	bZeroPCRotOnEntry=False
}
class gbxPlayerController extends PlayerController
	native
	config(user);


var() float TeamOrderTraceNear;
var() float TeamOrderTraceFar;
var() float TeamOrderRadius;
var() float MaxTeamOrderTraceHeight;

var	  int	iAddresseeUnit;

var	  float	TimeLastOrder;
var() float TeamOrderRepeatDelay;

var   float NextUnitAttachTime;
var() float HoldUnitSelectToAttachTime;
var() float HoldUnitSelectToAttachAllTime;

var   float NextEnemyUnitSearchTime;
var() float EnemyUnitSearchInterval;
var() float FoundEnemyCosAngleMin;
var() float	EnemyUnitTraceFar;
var() sound ToggleAddresseeUnitSound;
var() sound USReinforcementsArriveSound;
var() sound DEReinforcementsArriveSound;

var globalconfig float NotificationMinRadiusDamage;
var globalconfig float NotificationMinRadiusDeath;


var() float MinPassbyShotDistance;		// The minimum distance at which a shot can have been fired where you can still hear the bullet zip past.

var() float UnitTargetCosAngleMin;
var() float PawnTargetCosAngleMin;

var() bool	bNeverEnemy;
var() bool	bMoveOrderEnabled;
var() bool	bTargetOrderEnabled;
var() bool  bAssaultOrderEnabled;
var() bool	bHideSuppressionIcons;  // so TriggeredScript can show/hide suppression icons without effecting player settings
var   bool	bDisableCrosshair;  // temporarily disable crosshair while mounting stuff

var() globalconfig bool bTargetOrderPawns;

var() config bool	bDisableClientMessages;
var() globalconfig	bool	bNoSuppressionIcons;
var() globalconfig	bool	bEnableAIDebugCam;	// Allow the display of the AI Debug Cam -- NOTE: setting this flag to false does NOT stop the AI Debug Cam from collecting data in the background; to do that you must set LevelInfo's bUseAIDebugCam flag to false.
var() globalconfig	bool	bUseCommandProjector;
var() config bool	bForceSuppressionIcons;
var() config bool	bUseGermanAccent;	// use to set german battle dialogue to german or english with german accent
var() globalconfig	bool	bRemoveWeaponFromHud; // Use to remove displaying weapon ammo from hud.  For use with Logitech LCD's.
var() globalconfig	bool	bUseStickyTargeting;

var bool	bAddressTeamLeaderNextTime;

var() globalconfig	bool	bFriendlyFireIDDisable;
var() globalconfig	bool	bObjectiveMessageDisable;
var() globalconfig	bool	bDisableCombatDesat;

var config bool bDisplayMPMissionHints;

var Cue BulletPassByCue;

var transient InWorldOrderIconBase OrderIcon;
var transient InWorldOrderIconBase PriorMoveOrderIcon;
var transient InWorldOrderIconBase UnitOrderIcon;  //NAC

var float fUpdateOrderIconTime;
var float fStickyOrderIconTime;
var bool bSavedIsAtValidPosition;
var vector SavedOrderLocation;
var transient InWorldAttachTarget SavedFoundAttachTarget;
var transient gbxPawn SavedFoundAttachPawn;
var vector SavedOrderHitNormal;

var float MyNavPointUpdateTime;
var gbxPawn	aDeadPawn;

var input byte
	bUnitSelect, // Command button is pressed
	bPlayerBreak;

//UBI.COM utility variables
var transient byte   StoredAutorizationID[20];
var transient string StoredUbiComUserName;
var transient float  TimeOfUbiComValidationRequest;
var transient gbx_OnlineProfile UbiComOnlineProfile;

var bool FallInIssued;
var bool AllFallInIssued;
var bool bLimitedMode;

var array<Cue> SpeechQueue;
var float SpeechFinishedTime;

var bool bLCDAvailable; // If lcd is connected.
var bool bLCDCheck;

enum EAssaultInterface
{
	ASSAULT_Toggle,
	ASSAULT_FireChord,
	ASSAULT_None
};

var() globalconfig EAssaultInterface AssaultInterface;

enum EOrderType
{
	ORDER_None,
	ORDER_Move,
	ORDER_Target,
	ORDER_Assault,
	ORDER_FallIn,
	ORDER_FallOut
};
var EOrderType TypeLastOrder;

var Unit LastAttackTargetUnit;

/// Oracle camera related variables

var transient OracleCamera	OracleCam;
var transient IAIDebugCamera	AIDebugCam;
var string AIDebugCamClassName;

var protected FieldPromotionFlow	FieldPromotionState;

// PSV: 5/18/2004 Field promotion support
var bool bFieldPromoteAutochoose;
// PSV: 6/24/2004 Keep track of the last unit that was controlled
var Unit LastPlayerUnit;


var gbxBaseFireTeamSpawnController SpawnController;

/// There are a couple of "delayed actions" that need to be flagged and process
enum EDelayedAction
{
	NoAction,
	ReloadAfterZoomOut,
	ZoomInAfterReload,
	ZoomInAfterWeaponSwitch,
	ToggleWeaponAfterZoomOut,
	ToggleWeaponAfterZoomOutAfterFire,
	MeleeAfterZoomOut,
    PutDownWeaponAfterZoomOut,
	PutDownWeaponAfterReload,
	PutDownWeaponAfterMelee
};

var EDelayedAction	PendingDelayedAction;

// These variables specify which package to load command cues from depending on the game conditions:
// Game Mode (Single Player or Multiplayer)
// Which command language is chosen (One or Two)
// In Multiplayer, which character the player is (A or B)
// Single player only supports a single language (the player's native language)
var config string CommandCuePkgSP;

var config string CommandCuePkgSKRA;
var config string CommandCuePkgSKRB;

var config string CommandCuePkgMPUSA;
var config string CommandCuePkgMPUSB;

var config string CommandCuePkgMPDEA;
var config string CommandCuePkgMPDEB;

var Cue		PainCue;

var globalconfig int	nSpectateObjectiveOffset;
var byte	CombatDesaturationAmount;
var float	flLastCombatDesatTime;
var float	m_flNextTargetChange;

const ORDER_TRACE_OFFSET = 300.0f;
const COMBAT_DESAT_INCREMENT = 32;
const COMBAT_DESAT_TIME_SLOT = 5.0f;
const MAX_COMBAT_DESAT = 128;


replication
{
	// Variables the server should send to the client.
	reliable if( bNetDirty && (Role==ROLE_Authority) )
        PendingDelayedAction, LastPlayerUnit;

	// Functions client can call.
	reliable if( Role < ROLE_Authority )
        ServerOrderMove, ServerOrderFallIn, ServerOrderFallOut, ServerOrderTarget, ServerOrderAssault, ServerCallInReinforcements, 
		ServerSetFieldPromoteAutochoose, SendAuthIdToServer, ServerSetOrderAndTime, ServerSpectate;

	// Functions server can call.
	reliable if( Role==ROLE_Authority )
		ClientPawnDied, ClientDoBulletWhiz, ClientSubUnitRemoved, RequestAuthIdFromClient, NotifyClientOfKickout, ClientNotifyPawnDied, ClientNotifyPawnTakingDamage,
		ClientSkirmishEndFieldPromotion;
}


simulated event Destroyed()
{
	Super.Destroyed();
	if (FieldPromotionState != None)
	{
		FieldPromotionState.Shutdown();
		delete(FieldPromotionState);
		FieldPromotionState = None;
	}
}

simulated function string GetCommandPackageName()
{
	local string pkg;
	local PlayerController otherPC;

	if (Level.NetMode == NM_Standalone)
	{
		if( GameReplicationInfo.GameType == GT_SKIRMISH )
			pkg = CommandCuePkgSKRA;
		else
			pkg = CommandCuePkgSP;
	}
	else
	{
		if (PlayerReplicationInfo.Team.TeamIndex == ETeamIdentifier.TEAM_US)
		{
			if (Player.SplitIndex == 0)	// either for player 1 of splitscreen or system link games
			{
				if( GameReplicationInfo.GameType == GT_SKIRMISH )
				{
					if( PlayerReplicationInfo.TeamID > 0 )
						pkg = CommandCuePkgSKRB;
					else
						pkg = CommandCuePkgSKRA;
				}
				else
				{
					pkg = CommandCuePkgMPUSA;
				}
			}
			else
			{
				otherPC = Level.PlayerControllerList;

				for (otherPC = otherPC.nextPlayerController; otherPC != None; otherPC = otherPC.nextPlayerController)
				{
					if (otherPC != self &&
						otherPC.PlayerReplicationInfo != None &&
						otherPC.PlayerReplicationInfo.Team != None &&
						Viewport(otherPC.Player) != None &&
						otherPC.Player.SplitIndex != Player.SplitIndex)
					{
						break;
					}
				}

				if (otherPC != None)
				{			
					if (otherPC.PlayerReplicationInfo.Team.TeamIndex == PlayerReplicationInfo.Team.TeamIndex)
					{
						if( GameReplicationInfo.GameType == GT_SKIRMISH )
							pkg = CommandCuePkgSKRB;
						else
							pkg = CommandCuePkgMPUSB;
					}
					else
					{
						if( GameReplicationInfo.GameType == GT_SKIRMISH )
							pkg = CommandCuePkgSKRA;
						else
							pkg = CommandCuePkgMPUSA;
					}
				}
				else
				{
					if( GameReplicationInfo.GameType == GT_SKIRMISH )
						pkg = CommandCuePkgSKRA;
					else
						pkg = CommandCuePkgMPUSA;
				}
			}
		}
		else if (PlayerReplicationInfo.Team.TeamIndex == ETeamIdentifier.TEAM_German)
		{
			if (Player.SplitIndex == 0)
			{
				pkg = CommandCuePkgMPDEA;
			}
			else
			{
				otherPC = Level.PlayerControllerList;

				for (otherPC = otherPC.nextPlayerController; otherPC != None; otherPC = otherPC.nextPlayerController)
				{
					if (otherPC != self &&
						otherPC.PlayerReplicationInfo != None &&
						otherPC.PlayerReplicationInfo.Team != None &&
						Viewport(otherPC.Player) != None &&
						otherPC.Player.SplitIndex != Player.SplitIndex)
					{
						break;
					}
				}

				if (otherPC != None)
				{			
					if (otherPC.PlayerReplicationInfo.Team.TeamIndex == PlayerReplicationInfo.Team.TeamIndex)
					{
						pkg = CommandCuePkgMPDEB;
					}
					else
					{
						pkg = CommandCuePkgMPDEA;
					}
				}
				else
				{
					pkg = CommandCuePkgMPDEA;
				}
			}
		}
		else
		{
			if( GameReplicationInfo.GameType == GT_SKIRMISH )
				pkg = CommandCuePkgSKRA;
			else
				pkg = CommandCuePkgMPUSA;
		}
	}

	log( "gbxPlayerController::GetCommandPackageName() - GameType=" $ GameReplicationInfo.GameType, 'RSC' );
	log( "gbxPlayerController::GetCommandPackageName() - Package=" $ pkg, 'RSC' );
	return pkg;
}

simulated function LoadCommandCues()
{
	if ( BulletPassByCue == None )
	{
		BulletPassByCue = LoadSound( "IMPACTS.BULLET_PASSBY" );
	}
}

simulated function bool CanFire()
{
    if( IsInOracleCamMode() )
		return false;

	return super.CanFire();
}

function ClientMatchStarting()
{
	Super.ClientMatchStarting();

	LoadCommandCues();
}

function Possess( Pawn aPawn )
{
	local Unit U;

	Super.Possess( aPawn );

	// What unit should I go into?
	foreach DynamicActors( class'Unit', U )
	{
		if( U.bPullPlayerIn || U.bMakePlayerLeader )
		{
			//SDJ 03/12/2004: Give the unit an oportunity to reject this pawn.  Used in MP to limit player's to specific units.
			if (U.AllowPawnToJoin(aPawn))
			{
				// This unit wants me.
				U.AddMember( gbxPawn( aPawn ));

				if( U.bMakePlayerLeader )
				{
					// This unit wants me to be leader.
					U.SetLeader( gbxPawn( aPawn ));
				}

				// PSV: 6/24/2004 Save the unit so we can reference its subunits when the pawn is dead
				LastPlayerUnit = U;
			}
		}
	}

	MyNavPointUpdateTime = Level.TimeSeconds;
}

simulated exec notinship function ToggleClientMessages()
{
	bDisableClientMessages = !bDisableClientMessages;
}

simulated exec notinship function ToggleSuppressionIcons()
{
	bNoSuppressionIcons = !bNoSuppressionIcons;
//	bTargetOrderPawns = bNoSuppressionIcons;

	if( bNoSuppressionIcons )
	{
		ClientMessage("Suppression Icons off");
	}
	else
	{
		ClientMessage("Suppression Icons on");
	}

}

simulated exec notinship function ToggleCommandRing()
{
	bUseCommandProjector = !bUseCommandProjector;

	if( bUseCommandProjector )
	{
		ClientMessage("Command Ring in Projector mode");
	}
	else
	{
		ClientMessage("Command Ring in StaticMesh mode");
	}
}

simulated exec notinship function ToggleAssaultInterface()
{
	if( AssaultInterface == ASSAULT_Toggle )
	{
		AssaultInterface = ASSAULT_FireChord;
		ClientMessage("Assault in Fire Chord mode");
	}
	else
	{
		AssaultInterface = ASSAULT_Toggle;
		ClientMessage("Assault in Toggle mode");
	}
}

simulated function bool ShowUnitIcon( InWorldUnitIcon anIcon )
{
	// Confirm the icon represents a valid unit.
	if( anIcon == None || anIcon.MyUnit == None || !anIcon.MyUnit.AnyLivingMembers() )
	{
		return false;
	}

	// Consider conditions relating to being in OracleCam mode.

	if( OracleCam != None && OracleCam.bWantOracleCamMode )
	{
		// In oracle cam mode.

		// The icon's unit is a subunit of the player's unit (show friendly, owned units).
		if( gbxPawn( Pawn ).MyUnit.IsSubUnit( anIcon.MyUnit ) )
		{
			return true;
		}

		// The icon's unit is a known enemy unit.
		if( gbxPawn( Pawn ).MyUnit.MyUnitController.IsUnitKnown( anIcon.MyUnit ))
		{
			return true;
		}

		// Don't show any other unit icons in oracle cam mode.
		return false;
	}
	else
	{
		// Not in oracle cam mode.

		// Cull out NoSuppressionIcon mode cases.

		if( Level.bNoSuppressionIcons )
		{
			// Suppression icons outlawed in this level.
			return false;
		}

		if (bHideSuppressionIcons)
			return false;

		if( GetbNoSuppressionIcons() )
		{
			// Never show icons with nosuppressionicons and targetorderpawn options.
			if( bTargetOrderPawns )
			{
				return false;
			}
			
			// Only show icons when ordering in no suppression mode.
			if( !IsOrdering() )
			{
				return false;
			}
		}

		// At this point, definitely show the icon if it is being targetted.
		if( anIcon.GetNumAttachedIcons() > 0 )
		{
			return true;
		}

		//SDJ 05/28/2004: Only show the player's unit in oracle cam mode.
		if( anIcon.MyUnit.IsLeaderHumanPlayer() )
		{
			return false;
		}

		// If the unit is known, maybe show it.
		if( gbxPawn( Pawn ).MyUnit.MyUnitController.IsUnitKnown( anIcon.MyUnit ))
		{
			return true;

			/* Preserving this in case we want to go back to the old method of contextually hiding the icons
			// If the player is giving an order, show known units.
			if( IsOrdering() )
			{
				return true;
			}

			// If it is not entirely unsuppressed, or has been unsuppressed for less than a few seconds, show it.
			if( anIcon.MyUnit.MyUnitController.GetUnsuppressionDuration() <= 3.0 )
			{
				return true;
			}
			*/
		}
	}

	return false;
}

simulated function bool ShouldRefuseIconOcclusion( InWorldIcon anIcon )
{
	return IsInOracleCamMode() || IsOrdering() || anIcon.GetNumAttachedIcons() > 0;
}


simulated function bool ShouldShowSuppressionClockForUnitIcon( InWorldUnitIcon anIcon )
{
	local bool rslt;

	if (bHideSuppressionIcons)
		return false;
	
	rslt = !GetbNoSuppressionIcons() && !IsInOracleCamMode() && !gbxPawn( Pawn ).MyUnit.SameTeamAsUnit( anIcon.MyUnit );
	
	return rslt;
}

simulated function bool GetbNoSuppressionIcons()
{
	local bool rslt;

	rslt = bNoSuppressionIcons;

	if ((Level.NetMode != NM_StandAlone) && (GameReplicationInfo.GameType != GT_SKIRMISH))
	{
		rslt = true;
	}
	else
	{
		if (GameReplicationInfo.GameType != GT_SKIRMISH)
		{
			if (Level.Game.GameDifficulty == EDifficulty.DIFF_Authentic)
			{
				rslt = true;
			}
		}
	}

	if (bForceSuppressionIcons)
	{
		rslt = false;
	}
	
	return rslt;
}


function ClientMessage( coerce string S, optional Name Type )
{
	if( !bDisableClientMessages )
	{
		Super.ClientMessage( S, Type );
	}
}

simulated function NotifyNearbyTrace( Actor Other, vector TouchLocation, vector TouchNormal, vector End, vector Start, vector Extent, int TraceFlags )
{
	local vector NearestPoint;		// The nearest point to the pawn that this trace passed through.
	local float MissDistance;		// How far away from me the bullet passed.
	local float MissDistanceRelative;		// How far away from me the bullet passed, scaled and clamped to (0,1)
	local float ShotOriginDistance;	// How far from me the shot originated.
	local vector TraceNormal;
	local bool	 bDesaturated;

	TraceNormal = Normal( Start - End );

	NearestPoint = End + TraceNormal * (( Pawn.Location - End ) dot TraceNormal );

	MissDistance = VSize( NearestPoint - Pawn.Location ) - Pawn.CollisionRadius;
	MissDistanceRelative =
		FClamp(
			MissDistance / ( gbxPawn( Pawn ).MyBulletListener.CollisionRadius - Pawn.CollisionRadius ),
			0.0, 1.0 );

	ShotOriginDistance = VSize( Start - Pawn.Location );

	if( ShotOriginDistance >= MinPassbyShotDistance )
	{
		if ( Pawn.IsLocallyControlled() )
		{
			DoBulletWhiz( NearestPoint );
		}
		else
		{
			ClientDoBulletWhiz( NearestPoint );
		}
	}
	if (!bDisableCombatDesat)
	{
		if (!(Pawn.bSpecialCalcView) && (Level.Game.GameSpeed == 1.0))
		{
			if (CombatDesaturationAmount > 0)
			{
				bDesaturated = true;
			}
			else
			{
				bDesaturated = false;
			}
			CombatDesaturationAmount = Clamp( CombatDesaturationAmount + COMBAT_DESAT_INCREMENT, 0, MAX_COMBAT_DESAT );
			if (bDesaturated)
			{
				UpdateCamDesaturation( CombatDesaturationAmount );
			}
			else
			{
				BeginCamDesaturation( CombatDesaturationAmount );
			}
			flLastCombatDesatTime = Level.TimeSeconds;
		}
	}
}

simulated function DoBulletWhiz( vector loc )
{
	local BulletPassbyProxy proxy;

	// Create proxy to represent bullet passing.
	proxy = PlaceBulletPassbyProxy( loc );

	// Make noise near the player to represent bullet whizzing past.

	// TODO STEPHEN - Maybe play different sounds depending on MissDistanceRelative. Certainly affect volume.
	if( BulletPassByCue != None )
	{
		proxy.PlaySoundCue( BulletPassByCue, SLOT_None,,,,, );
	}
}

simulated function ClientDoBulletWhiz( vector loc )
{
	DoBulletWhiz( loc );
}

simulated function BulletPassbyProxy PlaceBulletPassbyProxy( vector loc )
{
	// TODO Keep queue of proxies to avoid many spawns/destroys.
	return Spawn( class'BulletPassbyProxy',,, loc );
}

simulated function PlayPainSound()
{
	//Pawn.PlayOwnedSoundCue( PainCue, SLOT_Talk,,,,,true );
	Level.TheAISpeechManager.PlaySpeech(
		Pawn, 
		None,
		'Pain',
		,
		, 
		0.0, 
		, 
		5.0, 
		0.5
	);
}

simulated function NotifyUnitOfVisibleEnemies()
{
	local vector LookVector, TestPawnVector, MyVector, HitLocation, HitNormal;
	local gbxPawn TestPawn;
	local Actor HitActor;
	local float LookTargetDot;
	local gbxPawn Myself;

	Myself = gbxPawn(Pawn);
	if( Myself == None )
		return;

	if( Myself.MyUnit == None )
	{
		return;
	}

	LookVector = Vector( Rotation );
	MyVector = Pawn.Location + Pawn.EyePosition();

	foreach DynamicActors( class'gbxPawn', TestPawn )
	{
		if( TestPawn.MyUnit != None && !TestPawn.SameTeamAs(Pawn) )
		{
			// My unit is already aware of this unit .. go ahead and refresh it.
			if ( Myself.MyUnit.MyUnitController.IsUnitKnown(TestPawn.MyUnit) )
			{
				Myself.MyUnit.MyUnitController.UnitMemberUpdatedTarget( TestPawn );
				continue;
			}

			TestPawnVector = Normal( (TestPawn.Location + TestPawn.EyePosition()) - MyVector );
			LookTargetDot = LookVector dot TestPawnVector;

			if( LookTargetDot >= FoundEnemyCosAngleMin )
			{
				// Found an enemy within our view.  See if it is visible.
				HitActor = Trace( HitLocation, HitNormal, TestPawn.Location + TestPawn.EyePosition(), MyVector, true );

				// If our trace hit the pawn, we can see him
				// GBX:PAD: See if this trace hit nothing since StaticPawn's are not solid, but we still need to
				// test for visibility.
				if( (HitActor == TestPawn) || (HitActor == None) )
				{
					Myself.MyUnit.MyUnitController.UnitMemberUpdatedTarget( TestPawn );
				}
			}
		}
	}
}

function bool SameTeamAs( Controller other )
{
//	Log( Name $ "(" $ Pawn.Name $ ").SameTeamAs()", 'Mind' );

	if( gbxPawn( Pawn ) == None )
	{
		Log( "WARNING: " $ self $ ".SameTeamAs( " $ other $ " ) found gbxPawn( Pawn ) == None.", 'Pawn' );
		return false;
	}
	return gbxPawn( Pawn ).SameTeamAs( other.Pawn );
}

simulated function bool GetOrderInfoAtTrace( out Vector OrderLocation, out InWorldAttachTarget FoundAttachTarget, out gbxPawn FoundAttachPawn, out Vector HitNormal )
{
	// FUNCTION USAGE:
	// If legal order position, returns true; otherwise you should ignore the output parameters.
	// If TargetUnit != None, this is a target order.
	// Else, this is a move order to OrderLocation.

	local Actor HitActor;
	local vector LookVector, TraceStart, TraceEnd, HitLocation, Extents, DeltaNormal, LookGroundLocation;
	local float Dist, distToTargetPawn, bestTargetScore, cosAngle, angA, angR, lookDist;
	local float offsetAtten;
	local Actor AssociatedActor;
	local Unit AssociatedUnit;
	local InWorldAttachTarget anIcon;
	local gbxPawn TestPawn;

	FoundAttachTarget = None;

	LookVector = Vector( Rotation );

	if( Pawn.bIsManningTurret )
	{
		TraceStart = gbxPawn(Pawn).Turret.GetMuzzleLocationWorld();
	}
	else
	{
		TraceStart = Pawn.Location + Pawn.EyePosition();
	}

	// If we're looking at a downward angle, start the trace above our heads so it is easier to place the command ring opposite of a close obstacle
	if( Rotation.Pitch > 49152 )
	{
		// 1. First see how far our raw trace would be
		TraceEnd = TraceStart + ( LookVector * TeamOrderTraceFar );

		HitActor = Trace(
			HitLocation,
			HitNormal,
			TraceEnd,
			TraceStart,
			true			// Do trace against actors
		);

		LookGroundLocation = HitLocation;
		
		// 2. Trace to find the ceiling; reset TraceStart to the ceiling or distance defined in ORDER_TRACE_OFFSET

		if( Pawn.bIsManningTurret )
		{
			offsetAtten = ComputeAttenuation( 0.5, float( Rotation.Pitch - 49152 ) / 16384.0, 1.0 );
		}
		else
		{
			offsetAtten = ComputeAttenuation( 0.75, float( Rotation.Pitch - 49152 ) / 16384.0, 1.0 );
		}

		TraceEnd = TraceStart + vect(0,0,1) * offsetAtten * ORDER_TRACE_OFFSET;

		HitActor = Trace(
			HitLocation,
			HitNormal,
			TraceEnd,
			TraceStart,
			true			// Do trace against actors
		);

		if( HitActor != None )
		{
			TraceStart = HitLocation - vect(0,0,1) * 32.0f;
		}
		else
		{
			TraceStart = TraceEnd;
		}

		// 3. Calculate new LookVector from the new position, based on where the player is looking.
		if( LookGroundLocation != vect(0,0,0) && LookGroundLocation.Z >= Pawn.Location.Z - Pawn.CollisionHeight )
		{
			angR = ( ( Rotation.Pitch - 49152 ) / 182.0444444f /* 65536.0 / 360.0 */ )  * ( 0.01745329f /* Pi / 180 */ );
			angA = Pi / 2 - angR;

			lookDist = ( Pawn.BaseEyeHeight * 2 ) / tan( angA );

			LookGroundLocation = Pawn.Location - ( vect(0,0,1) * Pawn.CollisionHeight ) + Normal( LookVector * vect(1,1,0) ) * lookDist;
		}

		LookVector = Normal( LookGroundLocation - TraceStart );
	}

	TraceEnd = TraceStart + ( LookVector * TeamOrderTraceFar );

	// Determine whether this is a target or move command.
	// If enemies are within a radius of the hit location, it's a target command.

	if( bTargetOrderEnabled )
	{
		bestTargetScore = -1;	// Very wide/bad.

		FoundAttachTarget = None;
		FoundAttachPawn = None;

		if( bTargetOrderPawns )
		{
			HitActor = Trace(
				HitLocation,
				HitNormal,
				TraceEnd,
				TraceStart,
				true			// Do trace against actors
			);

			//NAC+:  Used to return false here, but this kept us from colliding against BSP, added code to make it work with BSP as well.
			if( HitActor == Level )
			{
				// The user is trying to command the selected unit to move to, target, or otherwise interact with
				// the point he is looking at.

				HitActor = Trace(
					HitLocation,
					HitNormal,
					TraceEnd,
					TraceStart,
					false
				);
				if( HitActor != None )
				{
					if( bUseCommandProjector )
					{
						OrderLocation = HitLocation;
						return true;
					}

					//
					// Find a location near the hit point that is big enough for a person.
					//

					Dist = VSize( HitLocation - TraceStart );

					TraceEnd = HitLocation;
					TraceStart = HitLocation - LookVector * FMin( Dist, TeamOrderTraceNear );
					Extents = vect( 1, 1, 1 ) * Pawn.CollisionRadius;

					HitActor = Trace(
						OrderLocation,
						HitNormal,
						TraceEnd,
						TraceStart,
						false,
						Extents
					);

					if( HitActor != None )
					{
						// Trace down to the ground.

						TraceEnd = OrderLocation - vect( 0, 0, 10000 );
						TraceStart = OrderLocation;
						Extents = vect( 1, 1, 1 ) * Pawn.CollisionRadius;

						HitActor = Trace(
							OrderLocation,
							HitNormal,
							TraceEnd,
							TraceStart,
							false,
							Extents
						);

						if( HitActor != None )
						{
							// Now move the order location up a bit.
							OrderLocation.Z += 16;
							return true;
						}
					}
				}
				OrderLocation = Pawn.Location + Pawn.EyePosition() + ( LookVector * TeamOrderTraceFar );

				return false;
			}

			if( HitLocation == vect(0,0,0) )
				HitLocation = TraceEnd;

			// Am I "shooting" an enemy. If so, just use him as the attach pawn immediately.
			TestPawn = gbxPawn( HitActor );
			if( (TestPawn != None) && (!TestPawn.IsDead()) && (TestPawn.MyUnit != None) && (TestPawn.PawnTeam != TEAM_None) && !TestPawn.SameTeamAs(Pawn) )
			{
				FoundAttachPawn = TestPawn;
				OrderLocation = HitLocation;
				return true;
			}
			else 
			{
				FoundAttachPawn = None;
			}

			Dist = VSize( HitLocation - TraceStart );

			foreach DynamicActors( class'gbxPawn', TestPawn )
			{
				if( (!TestPawn.IsDead()) && (TestPawn.MyUnit != None) && (TestPawn.PawnTeam != TEAM_None) && !TestPawn.SameTeamAs(Pawn) )  // Pawn on the enemy team.
				{
					// Is he within a reasonable cone of my view angle?
					DeltaNormal = Normal( TestPawn.Location - TraceStart );
					cosAngle = LookVector dot DeltaNormal;

					if( cosAngle >= PawnTargetCosAngleMin )
					{
						// So far, so good.

						// But is the distance to this guy not ridiculously beyond my hit location?
						distToTargetPawn = VSize( TestPawn.Location - TraceStart );
						if( Dist >= distToTargetPawn - 2000 )
						{
							// This seems like a good pawn to consider. Either my hit location is beyond him or he's less than 50%
							// beyond the hit location.

							// Score him according to cos and dist.
							cosAngle = (( cosAngle - PawnTargetCosAngleMin ) / ( 1.0 - PawnTargetCosAngleMin )) * distToTargetPawn;

							if( cosAngle > bestTargetScore )
							{
								FoundAttachPawn = TestPawn;
								bestTargetScore = cosAngle;
								//FoundAttachTarget =TestPawn.MyUnit.MyInWorldIcon;
							}
						}
					}
				}
			}
			//NAC-

			if( (FoundAttachPawn != None) && (FoundAttachPawn.MyUnit != None) && (FoundAttachPawn.PawnTeam != TEAM_None) && !FoundAttachPawn.SameTeamAs(Pawn) )
			{
				OrderLocation = HitLocation;
				return true;
			}
			else {
				FoundAttachPawn = None;
			}

			foreach DynamicActors( class'InWorldAttachTarget', anIcon )
			{
				AssociatedActor = anIcon.GetAssociatedActor();

				if( AssociatedActor != None )
					AssociatedUnit = Unit( AssociatedActor );

				if( AssociatedUnit != None && anIcon.IsShownInternal() )
				{
					// Is it within angular range (screen space) of my look vector?

					DeltaNormal = Normal( anIcon.Location - TraceStart );

					cosAngle = LookVector dot DeltaNormal;

					if( cosAngle >= UnitTargetCosAngleMin && cosAngle > bestTargetScore )
					{
						// Pick a pawn in this unit (if it is one)
						FoundAttachPawn = AssociatedUnit.Members[0];
						bestTargetScore = cosAngle;
					}
				}
			}

			if( (FoundAttachPawn != None) && (FoundAttachPawn.MyUnit != None) && (FoundAttachPawn.PawnTeam != TEAM_None) && !FoundAttachPawn.SameTeamAs(Pawn) )
			{
				OrderLocation = HitLocation;
				return true;
			}
			else {
				FoundAttachPawn = None;
			}
		}
		else
		{
			foreach DynamicActors( class'InWorldAttachTarget', anIcon )
			{
				AssociatedActor = anIcon.GetAssociatedActor();

				if( AssociatedActor != None && anIcon.IsShownInternal() && anIcon.CanAcceptAttachmentsFrom( Pawn )  )
				{
					// Is it within angular range (screen space) of my look vector?

					DeltaNormal = Normal( anIcon.Location - TraceStart );

					cosAngle = LookVector dot DeltaNormal;

					if( cosAngle >= UnitTargetCosAngleMin && ( FoundAttachTarget == None || cosAngle > bestTargetScore ))
					{
						FoundAttachTarget = anIcon;
						bestTargetScore = cosAngle;
					}
				}
			}

			// Did we find an attach target?
			if( (FoundAttachPawn != None) && (FoundAttachPawn.MyUnit != None) && (FoundAttachPawn.PawnTeam != TEAM_None) && !FoundAttachPawn.SameTeamAs(Pawn) )
			{
				return true;
			}
			else {
				FoundAttachPawn = None;
			}
		}
	}

	// The user is trying to command the selected unit to move to, target, or otherwise interact with
	// the point he is looking at.

	HitActor = Trace(
		HitLocation,
		HitNormal,
		TraceEnd,
		TraceStart,
		false
	);

	if( HitActor != None )
	{
		if( bUseCommandProjector )
        {
		    OrderLocation = HitLocation;
		    return true;
        }

		//
		// Find a location near the hit point that is big enough for a person.
		//

		Dist = VSize( HitLocation - TraceStart );

		TraceEnd = HitLocation;
		TraceStart = HitLocation - LookVector * FMin( Dist, TeamOrderTraceNear );
		Extents = vect( 1, 1, 1 ) * Pawn.CollisionRadius;

		HitActor = Trace(
			OrderLocation,
			HitNormal,
			TraceEnd,
			TraceStart,
			false,
			Extents
		);

		if( HitActor != None )
		{
			// Trace down to the ground.

			TraceEnd = OrderLocation - vect( 0, 0, 10000 );
			TraceStart = OrderLocation;
			Extents = vect( 1, 1, 1 ) * Pawn.CollisionRadius;

			HitActor = Trace(
				OrderLocation,
				HitNormal,
				TraceEnd,
				TraceStart,
				false,
				Extents
			);

			if( HitActor != None )
			{
				// Now move the order location up a bit.
				OrderLocation.Z += 16;
				return true;
			}
		}
	}

/*
		//
		// Find a location near the hit point that is big enough for a person.
		//

		Dist = VSize( HitLocation - TraceStart );

		// Trace back toward the camera some distance, but don't go through obstacles.
		TraceEnd = TraceStart;
		TraceStart = HitLocation;

		Extents = vect( 1, 1, 1 ) * Pawn.CollisionRadius;

		HitActor = Trace(
			OrderLocation,		// Not really getting the order location here.
			HitNormal,
			TraceEnd,
			TraceStart,
			false,
			Extents
		);

		if( HitActor != None )
		{
			Dist = VSize( OrderLocation - TraceStart );

			if( Dist < Pawn.CollisionRadius )
			{
				// Failed to go back very far. The next trace should go forward from some arbitrary distance.
				TraceStart = HitLocation - LookVector * TeamOrderTraceNear;
			}
			else
			{
				TraceStart = OrderLocation;
			}
		}
		else
		{
			// Hit nothing. The next trace should go forward from some arbitrary distance.
			TraceStart = HitLocation - LookVector * TeamOrderTraceNear;
		}

		TraceEnd = HitLocation;

		HitActor = Trace(
			OrderLocation,
			HitNormal,
			TraceEnd,
			TraceStart,
			false,
			Extents
		);

		if( HitActor != None )
		{
			// Trace down to the ground.

			TraceEnd = OrderLocation - vect( 0, 0, 10000 );
			TraceStart = OrderLocation;
			Extents = vect( 1, 1, 0.5 ) * Pawn.CollisionRadius;

			HitActor = Trace(
				OrderLocation,
				HitNormal,
				TraceEnd,
				TraceStart,
				false,
				Extents
			);

			if( HitActor != None )
			{

				// Now move the order location up a bit.
				OrderLocation.Z += 16;
				return true;
			}
		}
	}
*/

	// This order is invalid, but find a place to point at anyway.
	OrderLocation = Pawn.Location + Pawn.EyePosition() + ( LookVector * TeamOrderTraceFar );

	return false;
}

event ServerPlayerTick( float DeltaTime )
{
	Super.ServerPlayerTick(DeltaTime);

	UpdateNavPoint();
}

simulated function UpdateCameraEffects( float DeltaTime )
{
	local int playerindex;

	playerindex = 0;

	if (Player != None)
		playerindex = Player.SplitIndex;

	if (CombatDesaturationAmount > 0)
	{
		if ((Level.TimeSeconds - flLastCombatDesatTime) > COMBAT_DESAT_TIME_SLOT)
		{
			CombatDesaturationAmount = max( 0, CombatDesaturationAmount - COMBAT_DESAT_INCREMENT );
			flLastCombatDesatTime = Level.TimeSeconds;
			if (CombatDesaturationAmount == 0)
			{
				// GBX:PAD: I probably need to find a better way to do this, but basically, after the player
				// has gone into desat mode from combat, make sure to turn off the glow effect so that we stay
				// in a subdued lighting for the rest of the level, or until a mapper turns on the glow again.
				Level.CameraEffectManager[playerindex].DefaultCameraMode = CAM_None;
				EndCamDesaturation();
			}
			else
			{
				UpdateCamDesaturation( CombatDesaturationAmount );
			}
		}
	}

	if ( Level.CameraEffectManager[playerindex] != None )
	{
		Level.CameraEffectManager[playerindex].UpdateCameraEffect(DeltaTime);
	}
}

simulated function UpdateSituationalAwarenessCamOverlayAlpha( float DeltaTime, bool bDesaturate )
{
	local int playerindex;
	local CamSituationalAwareness SACam;

	playerindex = 0;

	if (Player != None)
		playerindex = Player.SplitIndex;

	if ( Level.CameraEffectManager[playerindex] != None && Level.CameraEffectManager[playerindex].CurrentCameraEffect != None )
	{

		SACam = CamSituationalAwareness( Level.CameraEffectManager[playerindex].CurrentCameraEffect );

		if( SACam != None )
		{
			SACam.UpdateOverlayAlpha( DeltaTime, bDesaturate );
		}
	}
}

simulated function PlayerTick( float DeltaTime )
{
	local InWorldUnitIcon aUnitIcon;
	local Unit addresseeUnit, victimUnit;
	local Actor AssociatedActor;
	local float DotProduct;
	
	if ((!bFrozen) && (FieldPromotionState != None) && (FieldPromotionState.IsInitialized()))
	{
		FieldPromotionState.PlayerTick( DeltaTime );
	}
	
	Super.PlayerTick( DeltaTime );

	if (Pawn == None)
		return;

	UpdateCameraEffects( DeltaTime );

	// Cancelled order if empty or invalid addressee unit.
	if ( GetAddresseeUnit() == None )
	{
		CancelOrderIcon();
	}

	if( bLButton == 0 && OrderIcon != None && OrderIcon.IsShown() )
	{
		CancelOrderIcon();
	}

	// GBX:PAD: If the player input is in limited mode, don't allow squad commands.
	if (!bLimitedMode && (gbxPawn(Pawn) != None) && gbxPawn(Pawn).MyUnit != None && gbxPawn(Pawn).MyUnit.NumSubUnits > 0 )
	{
		////>SJP: As you hold down bUnitSelect, the selected sub-unit is told to fall in.  If you continue to hold, at the next interval,
		//// all remaining sub-units will be told to fallin.
		if( bUnitSelect == 1 )
		{
			if( NextUnitAttachTime == 0 )
			{
				NextUnitAttachTime = Level.UniversalTimeSeconds + HoldUnitSelectToAttachTime;
			}
			else if( NextUnitAttachTime < Level.UniversalTimeSeconds )
			{
				if( FallInIssued )
				{
					if( !AllFallInIssued )
					{
						OrderFallIn( true );
						AllFallInIssued = true;
					}
				}
				else
				{
					OrderFallIn();
					FallInIssued = true;
				}

				NextUnitAttachTime = Level.UniversalTimeSeconds + HoldUnitSelectToAttachAllTime;
			}
		}
		else
		{
			if( NextUnitAttachTime > Level.UniversalTimeSeconds && !FallInIssued )
			{
				ToggleAddresseeUnit();
			}

			NextUnitAttachTime = 0;
			FallInIssued = false;
			AllFallInIssued = false;
		}
	}
	/////<

	// Manage the queue of speech events for the player's pawn to say.
	//if ( Level.TimeSeconds > SpeechFinishedTime && SpeechQueue.Length > 0 )
	//{
	//	Pawn.PlayOwnedSoundCue( SpeechQueue[ 0 ], SLOT_Talk,,,,, );
	//	SpeechFinishedTime = Level.TimeSeconds + 0.8;
	//	SpeechQueue.Remove( 0, 1 );
	//}

	///  Can we see any enemies?
	if( NextEnemyUnitSearchTime < Level.TimeSeconds )
	{
		NextEnemyUnitSearchTime = Level.TimeSeconds + EnemyUnitSearchInterval;
		NotifyUnitOfVisibleEnemies();
	}

	if( ((gbxPawn(Pawn) != None) && gbxPawn(Pawn).MyUnit != None) && (OrderIcon != None) && OrderIcon.IsShown() )
	{
		// Display all friendly unit icons iff in ordering mode.
		foreach DynamicActors( class'InWorldUnitIcon', aUnitIcon )
		{
			if( aUnitIcon.MyUnit.SameTeamAs( Pawn ))
			{
				aUnitIcon.SetOrderMode( OrderIcon != None && OrderIcon.IsShown() );
			}
		}

		if( OrderIcon != None && OrderIcon.IsShown() )
		{
			// GBX:PAD: Since the Unit ID is a field in the Unit, get that information now to determine which command
			// "icon" to use when directing a fire team.

			addresseeUnit = GetAddresseeUnit();

			if ( addresseeUnit != None)
			{
				if (bUseStickyTargeting)
				{
					if (SavedFoundAttachTarget != None)
					{
						DotProduct = vector(Rotation) dot Normal(SavedFoundAttachTarget.Location - Pawn.Location);
						if (DotProduct > 0.995)
							fUpdateOrderIconTime = Level.UniversalTimeSeconds + 0.1;  // make the targeting icon stick to where it was last
					}

					if (SavedFoundAttachPawn != None)
					{
						DotProduct = vector(Rotation) dot Normal(SavedFoundAttachPawn.Location - Pawn.Location);
						if (DotProduct > 0.995)
							fUpdateOrderIconTime = Level.UniversalTimeSeconds + 0.1;  // make the targeting icon stick to where it was last
					}
				}

				if (((SavedFoundAttachTarget == None) && (SavedFoundAttachPawn == None)) ||
					(fUpdateOrderIconTime <= Level.UniversalTimeSeconds))
				{
					fUpdateOrderIconTime = Level.UniversalTimeSeconds;

					bSavedIsAtValidPosition = GetOrderInfoAtTrace( SavedOrderLocation, SavedFoundAttachTarget, SavedFoundAttachPawn, SavedOrderHitNormal );
				}

				OrderIcon.Update( 
					GetAlliedUnitSlot( addresseeUnit ),
					addresseeUnit.UnitType,
					bSavedIsAtValidPosition,
					SavedOrderLocation,
					SavedFoundAttachTarget,
					SavedFoundAttachPawn,
					SavedOrderHitNormal );

				// Determine whether this is a proposed assault or target order.
				if( AssaultInterface == ASSAULT_Toggle )
				{
					if( SavedFoundAttachTarget != None )
					{
						AssociatedActor = SavedFoundAttachTarget.GetAssociatedActor();
						if ( AssociatedActor.IsA( 'Unit' ) )
						{
							victimUnit = Unit( AssociatedActor );
						}
					}
					else if( (SavedFoundAttachPawn != None) && (SavedFoundAttachPawn.MyUnit != None) && (SavedFoundAttachPawn.PawnTeam != TEAM_None) && !SavedFoundAttachPawn.SameTeamAs(Pawn) )
					{
						// This is a target or assault command.
						victimUnit = SavedFoundAttachPawn.MyUnit;
					}

					if( victimUnit != None )
					{
						OrderIcon.SetAssaulting( addresseeUnit.AssignedTargetUnit == victimUnit && !addresseeUnit.bAssaultingTargetUnit );
					}
					else
					{
						OrderIcon.SetAssaulting( false );
					}
				}
				else
				{
					OrderIcon.SetAssaulting( false );
				}
			}
		}
	}
}

function UpdateNavPoint()
{
	local float distance;
	local ActorLite ClosestNavPoint;
	local bool bStoleNavPoint;
	local bool bSkipThisNavPoint;
	local Pawn NavPointClaimant;
	local gbxPawn OtherPawn;
	local Vector NavPointLoc;
	local gbxAIController OtherController;  // this should usually be 'Mind' but we can't reference from gbxBase
	local vector TempLoc;
	local gbxPawn MyGbxPawn;

	if (MyNavPointUpdateTime < Level.TimeSeconds)  // time to update nearest NavigationPoint to player yet?
	{
		MyNavPointUpdateTime = Level.TimeSeconds + 1.0f;

		distance = 0.0f;

		MyGbxPawn = gbxPawn(Pawn);

		if (MyGbxPawn != None)
		{
			if (MyGbxPawn.MyClaimedNavPoint != None)
			{
				if (MyGbxPawn.MyClaimedNavPoint.bIsNavigationPoint)
					distance = VSizeIgnoreZ(NavigationPoint(MyGbxPawn.MyClaimedNavPoint).Location - MyGbxPawn.Location);
				else if (MyGbxPawn.MyClaimedNavPoint.bIsNavigationPointLite)
					distance = VSizeIgnoreZ(NavigationPointLite(MyGbxPawn.MyClaimedNavPoint).Location - MyGbxPawn.Location);
			}

			// do we not have a NavigationPoint yet, or are we far enough from the previous one yet?
			if ((MyGbxPawn.MyClaimedNavPoint == None) || (distance > 400.0f))
			{
				// Offset upwards 200 units to handle case of player riding on the tank (since the Trace will
				// more than likely fail to "see" the nearest NavPoint when the player is riding the tank)
				// The GetNearestNavpoint function ignores the Z height when finding the nearest Navpoint anyway
				TempLoc = MyGbxPawn.Location + vect(0,0,200.0);

				ClosestNavPoint = GetNearestNavpoint( TempLoc, 4000.0, true, true, true, true, Pawn );

				if ((ClosestNavPoint != None) && (ClosestNavPoint != MyGbxPawn.MyClaimedNavPoint))
				{
					bStoleNavPoint = false;
					bSkipThisNavPoint = false;

					// check if point is already claimed by an AI Pawn...
					NavPointClaimant = None;
					if (ClosestNavPoint.bIsNavigationPoint)
						NavPointClaimant = NavigationPoint(ClosestNavPoint).Claimant;
					else if (ClosestNavPoint.bIsNavigationPointLite)
						NavPointClaimant = NavigationPointLite(ClosestNavPoint).Claimant;

					if (NavPointClaimant != None)
					{
						OtherPawn = gbxPawn(NavPointClaimant);
		
						if (OtherPawn != None)
						{
							if (ClosestNavPoint.bIsNavigationPoint)
								NavPointLoc = NavigationPoint(ClosestNavPoint).Location;
							else if (ClosestNavPoint.bIsNavigationPointLite)
								NavPointLoc = NavigationPointLite(ClosestNavPoint).Location;

							// see if Other Pawn is fairly close to the NavPoint...
							if (VSize(OtherPawn.Location - NavPointLoc) < OtherPawn.CollisionRadius * 4.0)
							{
								// Other Pawn is already at this NavPoint, don't steal it from him (otherwise guys
								// get REAL "jittery" around you when you walk up to them while their standing at
								// a NavigationPoint and they always run away from you).

								bSkipThisNavPoint = true;
							}

							if (!bSkipThisNavPoint)
							{
								// get the other pawn to release his claim on the NavPoint...
								if (ClosestNavPoint == OtherPawn.MyClaimedNavPoint)
								{
									OtherPawn.UnClaimNavPoint();
									bStoleNavPoint = true;
								}
							}
						}

						if (!bSkipThisNavPoint)
						{
							MyGbxPawn.ClaimNavPoint( ClosestNavPoint );

							OtherController = gbxAIController( OtherPawn.Controller );
							if (OtherController != None)
							{
								if (bStoleNavPoint)
									OtherController.NavigationPointStolen( ClosestNavPoint );
							}
						}
					}
					else  // else not already claimed, just claim it...
					{
						MyGbxPawn.ClaimNavPoint( ClosestNavPoint );
					}

					if (!bSkipThisNavPoint)
					{
						if( MyGbxPawn.MyUnit != None && MyGbxPawn.MyUnit.Leader == MyGbxPawn )
						{
							// I'm leading my unit. Set the formation center.
							MyGbxPawn.MyUnit.OrderMove( ClosestNavPoint );
						}
					}
				}
			}
		}
	}
}

exec simulated function CancelOrderIcon()
{
	if (bLimitedMode)
		return;

	if( OrderIcon != None )
	{
		OrderIcon.DetachFromParent();
		OrderIcon.bDestroyWhenNextHidden = true;
		OrderIcon.Hide();
		OrderIcon = None;
	}
}

exec simulated function ShowInWorldOrderIcon()
{
	if (bLimitedMode)
		return;
		
	if ( Level.Pauser == PlayerReplicationInfo ) // Dont change view while paused.
		return;
		
	// Can't order in SA view.
	if( IsInOracleCamMode() )
	{
		return;
	}

	// Make sure the player isn't pushing this button too quickly.
	if( TimeLastOrder + TeamOrderRepeatDelay > Level.TimeSeconds )
	{
		// The button is being pushed pretty fast after the last order was given. Is this illegal?
		if( AssaultInterface != ASSAULT_Toggle || TypeLastOrder == ORDER_Move || TypeLastOrder == ORDER_FallIn || TypeLastOrder == ORDER_FallOut )
		{
			// Yes, it's illegal. Bail out.
			return;
		}
	}

	if( GetAddresseeUnit() != None )
	{
		if( OrderIcon == None )
		{
			// Create the order icon.
			if( bUseCommandProjector )
			{
				OrderIcon = Spawn( class'InWorldOrderIconB', Pawn );
			}
			else
			{
				OrderIcon = Spawn( class'InWorldOrderIcon', Pawn );
			}
			OrderIcon.SetPlayerOwner(self);
			OrderIcon.SetOwner(Pawn);
		}
		
		if ( OrderIcon != None )
		{
			OrderIcon.SetOwner(Pawn);
			OrderIcon.Show();
		}
	}
}

simulated function bool IsOrdering()
{
	return OrderIcon != None;
}

simulated function OrderAttack( Unit VictimUnit, optional bool bForceAssault )
{
	local Unit addresseeUnit;

	if( AssaultInterface == ASSAULT_Toggle )
	{
		addresseeUnit = GetAddresseeUnit();

		if( bForceAssault || ( addresseeUnit.AssignedTargetUnit == VictimUnit && !addresseeUnit.bAssaultingTargetUnit ))
		{
			OrderAssault( VictimUnit );
		}
		else
		{
			OrderTarget( VictimUnit );
		}
	}
	else if( bForceAssault )
	{
		OrderAssault( VictimUnit );
	}
	else
	{
		OrderTarget( VictimUnit );
	}

	LastAttackTargetUnit = VictimUnit;
}

exec simulated function TeamOrder( optional bool bForceAssaultIfAttack )
{
	local Actor AssociatedActor;

	if (bLimitedMode || OrderIcon == None )
		return;

	if( GetAddresseeUnit() == None )
	{
		return;
	}

	if( bSavedIsAtValidPosition )	
	{
		OrderIcon.Execute();

		if( SavedFoundAttachTarget != None )
		{
			AssociatedActor = SavedFoundAttachTarget.GetAssociatedActor();
			if ( AssociatedActor.IsA( 'Unit' ) )
			{
				OrderAttack( Unit( AssociatedActor ), bForceAssaultIfAttack );
			}
			/*
			else if ( AssociatedActor.IsA( 'TurretWeapon' ) )
			{
				// TBD: Man this turret weapon.
				OrderManTurret( TurretWeapon( AssociatedActor ) );
			}
			*/
		}
		else if( SavedFoundAttachPawn != None )
		{
			// This is a target or assault command.
			OrderAttack( SavedFoundAttachPawn.MyUnit, bForceAssaultIfAttack );

			// Kill this icon automatically when it is next hidden.
			OrderIcon.bDestroyWhenNextHidden = true;
		}
		else
		{
			if (bMoveOrderEnabled)
			{
				// This is a move command.
				OrderMove( SavedOrderLocation );
			}

			// Kill this icon automatically when it is next hidden.
			OrderIcon.bDestroyWhenNextHidden = true;

			// Kill the old OrderIcon.
			if( PriorMoveOrderIcon != None )
			{
				PriorMoveOrderIcon.Destroy();
			}

			PriorMoveOrderIcon = OrderIcon;
		}

		// Order successfully given.
		TimeLastOrder = Level.TimeSeconds;
	}
	else
	{
		// Cancel.
		OrderIcon.bDestroyWhenNextHidden = true;
		OrderIcon.Hide();
	}

	OrderIcon = None;
}

simulated exec notinship function NoTarget()
{
	bNeverEnemy = !bNeverEnemy;
}

/////////////////////////////////////////////////////////////////////////////////////////////
// SQUAD COMMAND ////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////

function BecomingLeader( Unit ledUnit )
{
	// This is called to notify the controller that its pawn is becoming the leader of
	// the ledUnit.

	//
	// Set up the unit for player leadership.
	//

	// One of the subsequent fire teams, if any, become the addressee unit.
	iAddresseeUnit = 0;
}

function Unit GetPlayerLedUnit()
{
	local Unit aUnit;

	if (gbxPawn(Pawn) == None)
		return None;

	aUnit = gbxPawn( Pawn ).MyUnit;

	// Returns the unit, if any, that this player is the leader of.
	if( aUnit != None &&
		aUnit.Leader == Pawn )
	{
//		Log( class $ ".GetPlayerLedUnit() returning " $ MyUnit );
		return aUnit;
	}
	else
	{
//		Log( class $ ".GetPlayerLedUnit() returning None." );
		return None;
	}
}

function QueueSpeech( Cue NextQueue )
{
	SpeechQueue.Length = SpeechQueue.Length + 1;
	SpeechQueue[ SpeechQueue.Length - 1 ] = NextQueue;
}

function ClearSpeechQueue()
{
	SpeechQueue.Remove( 0, SpeechQueue.Length );
}

simulated function ClientSubUnitRemoved(int RemovedSubUnitIndex)
{
	if (Level.NetMode == NM_Client)
	{
		if (iAddresseeUnit >= RemovedSubUnitIndex && iAddresseeUnit > 0)
		{
			iAddresseeUnit--;
		}
	}
}

simulated exec function ToggleAddresseeUnit()
{
	local Unit ledUnit;
	local int oldAUnit;
	
	ledUnit = GetPlayerLedUnit();
	oldAUnit = iAddresseeUnit;

	if( ledUnit != None )
	{
		++iAddresseeUnit;
		if( iAddresseeUnit >= ledUnit.NumSubUnits )
			iAddresseeUnit = 0;

		while (!(ledUnit.SubUnits[iAddresseeUnit].AnyLivingMembers()) && iAddresseeUnit < ledUnit.NumSubUnits)
		{
			iAddresseeUnit++;		
		}
		if( iAddresseeUnit >= ledUnit.NumSubUnits )
			iAddresseeUnit = 0;

		if( oldAUnit != iAddresseeUnit )
		{
			DisplayUnitPawnInfo( iAddresseeUnit );
			HideUnitPawnInfo( oldAUnit );

			// Change sound to A_Interface.Buttons.Situational_View - Only play sound if something happens.
			PlaySound( ToggleAddresseeUnitSound, SLOT_Interact, 1.0, false );
		}


		bAddressTeamLeaderNextTime = true;
	}
}

simulated function DisplayUnitPawnInfo( int subUnitIdx )
{
	local int i;
	local Unit ledUnit;

	ledUnit = GetPlayerLedUnit();

	if( ledUnit == None )
		return;

	for( i = 0; i < ledUnit.SubUnits[ subUnitIdx ].GetNumLivingMembers(); i++ )
	{
		if( Level.TimeSeconds - ledUnit.SubUnits[ subUnitIdx ].Members[ i ].m_flLastDisplayPawnInfo > 1.0f )
		{
			ledUnit.SubUnits[ subUnitIdx ].Members[ i ].m_flLastDisplayPawnInfo = Level.TimeSeconds + 0.5f;
			ledUnit.SubUnits[ subUnitIdx ].Members[ i ].bPawnInfoIconOnly = true;
		}
	}
}

simulated function HideUnitPawnInfo( int subUnitIdx )
{
	local int i;
	local Unit ledUnit;

	ledUnit = GetPlayerLedUnit();

	if( ledUnit == None )
		return;

	for( i = 0; i < ledUnit.SubUnits[ subUnitIdx ].GetNumLivingMembers(); i++ )
	{
		if( ledUnit.SubUnits[ subUnitIdx ].Members[ i ].bPawnInfoIconOnly )
			ledUnit.SubUnits[ subUnitIdx ].Members[ i ].m_flLastDisplayPawnInfo = -1;
	}
}

simulated function byte GetAlliedUnitSlot( Unit aUnit )
{
	local Unit ledUnit;
	local byte iSlot;

	ledUnit = GetPlayerLedUnit();

	if( ledUnit != None )
	{
		for( iSlot = 0; iSlot < ledUnit.NumSubUnits; ++iSlot )
		{
			if( ledUnit.SubUnits[ iSlot ] == aUnit )
			{
				return iSlot;
			}
		}
	}
	return -1;
}

simulated exec function FallInInput()
{
	if (bLimitedMode || IsInAIDebugMode() || IsInOracleCamMode() )
		return;

	OrderFallIn();
}

simulated exec function FallOutInput()
{
	if (bLimitedMode || IsInAIDebugMode() || IsInOracleCamMode() )
		return;

	OrderFallOut();
}

simulated exec function SelectFireTeam()
{
	local int  nCurUnitIdx, nUseUnitIdx, nOtherUnitIdx, nVehicleUnitIdx;
	local Unit ledUnit, tempUnit;	

	ledUnit = GetPlayerLedUnit();
	
	if( (ledUnit != None) && (ledUnit.NumSubUnits > 0) )
	{
		nCurUnitIdx = 0;
		nOtherUnitIdx = -1;
		nUseUnitIdx = -1;
		nVehicleUnitIdx = -1;
		
		do
		{
			tempUnit = ledUnit.SubUnits[ nCurUnitIdx ];
			if (tempUnit==None)
				return;

			if (tempUnit.UnitType == EUnitType.UnitType_Base)
			{
				if (nUseUnitIdx >= 0)
				{
					nOtherUnitIdx = nCurUnitIdx;
				}
				else
				{
					nUseUnitIdx = nCurUnitIdx;
				}
			}
			else if ( tempUnit.UnitType == EUnitType.UnitType_Assault )
			{
				if (nOtherUnitIdx >= 0)
				{
					nUseUnitIdx = nOtherUnitIdx;
					nOtherUnitIdx = nCurUnitIdx;
				}
				else
				{
					nOtherUnitIdx = nCurUnitIdx;
				}
			}
			else if (tempUnit.UnitType == EUnitType.UnitType_Vehicle)
			{
				if (nVehicleUnitIdx >= 0)
				{
					nUseUnitIdx = nVehicleUnitIdx;
					nVehicleUnitIdx = nCurUnitIdx;
				}
				else
				{
					nVehicleUnitIdx = nCurUnitIdx;
				}
			}

			nCurUnitIdx++;
		}
		until (nCurUnitIdx >= ledUnit.NumSubUnits);

		if (nUseUnitIdx >= 0)
		{
			if ((nVehicleUnitIdx >= 0) && (nOtherUnitIdx == -1))
			{
				nOtherUnitIdx = nVehicleUnitIdx;
			}
		}
		else
		{
			if (nVehicleUnitIdx >= 0)
			{
				nUseUnitIdx = nVehicleUnitIdx;
			}
		}
		if (nUseUnitIdx >= 0 && ledUnit.SubUnits[ nUseUnitIdx ].AnyLivingMembers() )
		{
			iAddresseeUnit = nUseUnitIdx;			
			DisplayUnitPawnInfo( iAddresseeUnit );

			if( nOtherUnitIdx >= 0 )
			{
				HideUnitPawnInfo( nOtherUnitIdx );
			}
		}
	}	
}

simulated exec function SelectAssaultTeam()
{
	local int  nCurUnitIdx, nUseUnitIdx, nOtherUnitIdx, nVehicleUnitIdx;
	local Unit ledUnit, tempUnit;

	ledUnit = GetPlayerLedUnit();
	
	if( (ledUnit != None) && (ledUnit.NumSubUnits > 0) )
	{
		nCurUnitIdx = 0;
		nOtherUnitIdx = -1;
		nUseUnitIdx = -1;
		nVehicleUnitIdx = -1;
		
		do
		{
			tempUnit = ledUnit.SubUnits[ nCurUnitIdx ];
			if (tempUnit==None)
				return;

			if (tempUnit.UnitType == EUnitType.UnitType_Assault)
			{
				if (nUseUnitIdx >= 0)
				{
					nOtherUnitIdx = nUseUnitIdx;
					nUseUnitIdx = nCurUnitIdx;
				}
				else
				{
					nUseUnitIdx = nCurUnitIdx;
				}
			}
			else if ( tempUnit.UnitType == EUnitType.UnitType_Base )
			{
				if (nOtherUnitIdx >= 0)
				{
					nUseUnitIdx = nCurUnitIdx;
				}
				else
				{
					nOtherUnitIdx = nCurUnitIdx;
				}
			}
			else if (tempUnit.UnitType == EUnitType.UnitType_Vehicle)
			{
				if (nVehicleUnitIdx >= 0)
				{
					nUseUnitIdx = nCurUnitIdx;
				}
				else
				{
					nVehicleUnitIdx = nCurUnitIdx;
				}
			}

			nCurUnitIdx++;
		}
		until (nCurUnitIdx >= ledUnit.NumSubUnits);

		if (nUseUnitIdx >= 0)
		{
			if ((nVehicleUnitIdx >= 0) && (nOtherUnitIdx == -1))
			{
				nOtherUnitIdx = nVehicleUnitIdx;
			}
		}
		else
		{
			if (nVehicleUnitIdx >= 0)
			{
				nUseUnitIdx = nVehicleUnitIdx;
			}
		}
		if (nUseUnitIdx >= 0 && ledUnit.SubUnits[ nUseUnitIdx ].AnyLivingMembers() )
		{
			iAddresseeUnit = nUseUnitIdx;			
			DisplayUnitPawnInfo( iAddresseeUnit );

			if( nOtherUnitIdx >= 0 )
			{
				HideUnitPawnInfo( nOtherUnitIdx );
			}
		}
	}
}

simulated exec notinship function BuzzView()
{
	gbxPawn(Pawn).DoBuzzView();
}

simulated function bool IsUnderPlayerCommand( gbxPawn aPawn )
{
	local Unit ledUnit;
	ledUnit = GetPlayerLedUnit();

	if( ledUnit != None )
	{
		return ledUnit.IsPawnWithinUnit( aPawn );
	}
}

simulated function Unit GetAddresseeUnit()
{
	local Unit ledUnit;

	ledUnit = GetPlayerLedUnit();

	if( ledUnit != None && ledUnit.NumSubUnits > 0 )
	{
		// Bit of a hack to fix Bug #14941.  When a checkpoint is loaded after
		// one fireteam has died, that unit is added but is empty.
		// There seems to be no real good spot to check for that. So I did it here.
		while (!(ledUnit.SubUnits[iAddresseeUnit].AnyLivingMembers()) && iAddresseeUnit < ledUnit.NumSubUnits)
		{
			iAddresseeUnit++;		
		}
		if (iAddresseeUnit >= ledUnit.NumSubUnits)
			iAddresseeUnit = 0;

		// Verify this unit is actually "real".
		if( ledUnit.SubUnits[ iAddresseeUnit ].AnyLivingMembers() )
		{
			return ledUnit.SubUnits[ iAddresseeUnit ];
		}
		else
		{
			return None;
		}
	}

	return None;
}

function gbxAIController GetAddresseeLeaderController()
{
	local Unit addresseeUnit;

	addresseeUnit = GetAddresseeUnit();

	if( addresseeUnit != None && addresseeUnit.Leader != None && addresseeUnit.Leader.Controller != None )
	{
		return gbxAIController( addresseeUnit.Leader.Controller );
	}
	else
	{
		return None;
	}
}

simulated function MaybeAddressLeaderByName( Unit ledUnit )
{
//	local Cue PlayerSayingLeaderName;
	local String strLeader;
	local Name nameLeader;
	local gbxPawn PlayerPawn;
	local int dot;

	if ( bAddressTeamLeaderNextTime && Level.NetMode == NM_Standalone )
	{
		//PlayerSayingLeaderName = ledUnit.Leader.GetCuePlayerSayingMyName();
		strLeader = ledUnit.Leader.VoiceType.GetStringPlayerSayingMyName();

		if ( /*PlayerSayingLeaderName != None ||*/ strLeader != "" )
		{
			//QueueSpeech( PlayerSayingLeaderName );
			PlayerPawn = gbxPawn( ledUnit.GetControllingPlayerController().Pawn );
			dot = InStr( strLeader, "." );
			nameLeader = PlayerPawn.VoiceType.GetGroupFromSoundName( Right( strLeader, Len(strLeader)-dot-1 ) );
			log( "gbxPlayerController::MaybeAddressLeaderByName() - FindNameFromString( " $ strLeader $ ") returned " $ nameLeader, 'RSC' );
			if( nameLeader != '' )
			{
				log( "gbxPlayerController::MaybeAddressLeaderByName() - PlaySpeech( " $ PlayerPawn $ ", " $ ledUnit.Leader $ ", " $ nameLeader $ ")", 'RSC' );
				Level.TheAISpeechManager.PlaySpeech( 
					PlayerPawn, 
					ledUnit.Leader, 
					nameLeader,
					,
					, 
					0.0, 
					, 
					5.0, 
					1.0
				);
			}
		}
	}

	bAddressTeamLeaderNextTime = false;
}

simulated function OrderMove( Vector dest )
{
	local Unit ledUnit;
	local Name nameCommand;
	local gbxPawn PlayerPawn;
	local float delay;
	delay=0.0;

	if ( Level.Pauser == PlayerReplicationInfo ) // Dont change view while paused.
		return;

	ledUnit = GetAddresseeUnit();
	if( ledUnit != None )
	{
		// Play first person move out animation
		if (Pawn.Weapon.CanPlaySignalAnim())
			Pawn.Weapon.PlayAnim('signal_moveout', 1.0, 0.0);
		
		if( bAddressTeamLeaderNextTime && Level.NetMode == NM_Standalone && ( !ledUnit.Leader.IsTank() && !ledUnit.Leader.IsTankCommander() ) )
		{
			delay = 1.0;
		}

		ClearSpeechQueue();
		MaybeAddressLeaderByName( ledUnit );

		if ( ledUnit.HasVehicles() )
		{
			//QueueSpeech( CommandCueMoveTank );
			nameCommand = 'MoveTank';
		}
		else
		{
			//QueueSpeech( CommandCueMove );
			nameCommand = 'MoveGeneric';
		}
		
		// play the command
		PlayerPawn = gbxPawn( ledUnit.GetControllingPlayerController().Pawn );
		log( "gbxPlayerController::OrderMove() - VoiceType=" $ PlayerPawn.VoiceType, 'RSC' );
		log( "gbxPlayerController::OrderMove() - PlaySpeech( " $ ledUnit.GetControllingPlayerController().Pawn $ ", " $ ledUnit.Leader $ ", " $ nameCommand $ ")", 'RSC' );
		Level.TheAISpeechManager.PlaySpeech( 
			ledUnit.GetControllingPlayerController().Pawn, 
			ledUnit.Leader, 
			nameCommand,
			,
			, 
			delay, 
			, 
			5.0, 
			0.0
		);

		ServerOrderMove(dest, iAddresseeUnit);
		ledUnit.ClientClearTargetOrderIcon();
		ledUnit.ClientSetTargetUnit_Hack( None );

		TypeLastOrder = ORDER_Move;
		if ( Role < ROLE_Authority ) // Update order information to server
			ServerSetOrderAndTime( TypeLastOrder );
	}
}

function ServerOrderMove( Vector dest, int addresseeUnit )
{
	local Unit ledUnit;
	local ActorLite navPoint;

//	Log( class $ ".ServerOrderMove( " $ dest $ " )" );

	ledUnit = GetPlayerLedUnit();
	if( ledUnit != None )
	{
		if((addresseeUnit >= 0) && (addresseeUnit < ledUnit.NumSubUnits))
		{
			ledUnit = ledUnit.SubUnits[ addresseeUnit ];
		}
		else
		{
			ledUnit = None;
		}
	}

	if( ledUnit != None )
	{
		// Detach the unit from my unit
		ledUnit.DetachFromSuperUnit();

		// Find nearest navpoint to dest.
		navPoint = GetNearestNavpoint( dest, -1.0, false, true, false, false );

		ledUnit.OrderMove( navPoint );

		// Detach any pre-existing target order icon.
		// TODO
	}
}

simulated function OrderTarget( Unit targetUnit )
{
	local Unit ledUnit;
	//local Cue  cueTarget;
	local Name nameCommand;
	local float delay;
	delay=0.0;
	
	if ( Level.Pauser == PlayerReplicationInfo ) // Dont change view while paused.
		return;

	ledUnit = GetAddresseeUnit();
	ledUnit.SetTargetOrderIcon(None);  //NAC changed this to call new set target order icon function
	// Ensure this unit isn't already targetting the enemy.
	if( ledUnit != None )
	{
		OrderIcon.ShowRing(false);
		OrderIcon.SetAssaulting( false );

	// GBX:PAD: Got rid of this since the current way of toggling the attack vs assault state means that we might
	// constantly rotate through states on this target.
//		if( ledUnit.AssignedTargetUnit != targetUnit )
//		{
			// Play first person action animation
			if (Pawn.Weapon.CanPlaySignalAnim())
				Pawn.Weapon.PlayAnim('signal_action_front', 1.0, 0.0);
			
			if( targetUnit.HasVehicles() )
			{
				//cueTarget = CommandCueTargetTank;
				nameCommand = 'AttackTank';
			}
			else if( targetUnit.HasArtillery() )
			{
				//cueTarget = CommandCueTargetArtillery;
				nameCommand = 'AttackArtillery';
			}
			else if( targetUnit.HasMachineGun() )
			{
				//cueTarget = CommandCueTargetMG;
				nameCommand = 'AttackMG42';
			}
			else if( targetUnit.HasMortar() )
			{
				//cueTarget = CommandCueTargetMortar;
				nameCommand = 'AttackMortar';
			}
			else
			{
				//cueTarget = CommandCueTarget;
				nameCommand = 'AttackGeneric';
			}

			if( bAddressTeamLeaderNextTime && Level.NetMode == NM_Standalone && ( !ledUnit.Leader.IsTank() && !ledUnit.Leader.IsTankCommander() ) )
				delay=1.0;

			ClearSpeechQueue();
			MaybeAddressLeaderByName( ledUnit );
			//QueueSpeech( cueTarget );	

			// play the command
			log( "gbxPlayerController::OrderTarget() - PlaySpeech( " $ ledUnit.GetControllingPlayerController().Pawn $ ", " $ ledUnit.Leader $ ", " $ nameCommand $ ")", 'RSC' );
			Level.TheAISpeechManager.PlaySpeech( 
				ledUnit.GetControllingPlayerController().Pawn, 
				ledUnit.Leader, 
				nameCommand,
				,
				, 
				delay, 
				, 
				5.0, 
				0.0 
			);		

			ServerOrderTarget( targetUnit, iAddresseeUnit);
			ledUnit.ClientClearTargetOrderIcon();
//		}
			if (UnitOrderIcon==None){
				UnitOrderIcon = Spawn( class'InWorldOrderIcon', Pawn );
			}

		//ledUnit.TargetOrderIcon = OrderIcon;
		ledUnit.ClientSetTargetUnit_Hack( targetUnit );
		ledUnit.SetTargetOrderIcon( UnitOrderIcon ); //NAC changed this to call new set target order icon function

		TypeLastOrder = ORDER_Target;
		if ( Role < ROLE_Authority ) // Update order information to server
			ServerSetOrderAndTime( TypeLastOrder );
	}
	else
	{
		// Bogus order. Kill the icon to attach.
		OrderIcon.bDestroyWhenNextHidden = true;
		OrderIcon.Hide();
		OrderIcon = None;
	}
}

function ServerOrderTarget( Unit targetUnit, int addresseeUnit )
{
	local Unit ledUnit;
		
	ledUnit = GetPlayerLedUnit();
	if( ledUnit != None )
	{
		if((addresseeUnit >= 0) && (addresseeUnit < ledUnit.NumSubUnits))
		{
			ledUnit = ledUnit.SubUnits[ addresseeUnit ];
		}
		else
		{
			ledUnit = None;
		}
	}

	if (ledUnit != None)
	{
		ledUnit.OrderTarget( targetUnit );
	}
}

simulated function OrderAssault( Unit targetUnit )
{
	local Unit ledUnit;
	//local Cue AssaultCue;
	local Name nameCommand;
	local float delay;
	delay=0.0;
	
	if ( Level.Pauser == PlayerReplicationInfo ) // Dont change view while paused.
		return;
		
	ledUnit = GetAddresseeUnit();

	if( ledUnit != None )
	{
		OrderIcon.ShowRing(false);
		ledUnit.SetTargetOrderIcon(None);  //NAC changed this to call new set target order icon function
		OrderIcon.SetAssaulting( true );

		// Play first person action animation
		if (Pawn.Weapon.CanPlaySignalAnim())
			Pawn.Weapon.PlayAnim('signal_action_front', 1.0, 0.0);
		
		if( bAddressTeamLeaderNextTime && Level.NetMode == NM_Standalone && ( !ledUnit.Leader.IsTank() && !ledUnit.Leader.IsTankCommander() ) )
			delay=1.0;

		ClearSpeechQueue();
		MaybeAddressLeaderByName( ledUnit );

		if( targetUnit.HasVehicles() )
		{
			//AssaultCue = CommandCueAssaultTank;
			nameCommand = 'AssaultTank';
		}
		else if( targetUnit.HasArtillery() )
		{
			//AssaultCue = CommandCueAssaultArtillery;
			nameCommand = 'AssaultArtillery';
		}
		//else if( targetUnit.HasMachineGun() && ledUnit.HasVehicles()) //NAC:  added check for assualting an MG with a tank in the unit
		//{
		//	//AssaultCue = CommandCueAssaultMGTank;
		//	nameCommand = 'TankAssaultMG';
		//}
		else if( targetUnit.HasMachineGun() )
		{
			//AssaultCue = CommandCueAssaultMG;
			nameCommand = 'AssaultMG42';
		} 
		else if( targetUnit.HasMortar() )
		{
			//AssaultCue = CommandCueAssaultMortar;
			nameCommand = 'AssaultMortar';
		}
		else
		{
			//AssaultCue = CommandCueAssault;
			nameCommand = 'AssaultGeneric';
		}

		//QueueSpeech( AssaultCue );
		// play the command
		log( "gbxPlayerController::OrderAssault() - PlaySpeech( " $ ledUnit.GetControllingPlayerController().Pawn $ ", " $ ledUnit.Leader $ ", " $ nameCommand $ ")", 'RSC' );
		Level.TheAISpeechManager.PlaySpeech( 
			ledUnit.GetControllingPlayerController().Pawn, 
			ledUnit.Leader, 
			nameCommand,
			,
			, 
			delay, 
			, 
			5.0, 
			0.0
		);

		ServerOrderAssault( targetUnit, iAddresseeUnit );
		ledUnit.ClientClearTargetOrderIcon();	
		//ledUnit.TargetOrderIcon = OrderIcon;
		ledUnit.ClientSetTargetUnit_Hack( targetUnit );
		ledUnit.SetTargetOrderIcon( OrderIcon ); //NAC changed this to call new set target order icon function

		TypeLastOrder = ORDER_Assault;
		if ( Role < ROLE_Authority ) // Update order information to server
			ServerSetOrderAndTime( TypeLastOrder );
	}
	else
	{
		// Bogus order.  Kill the icon to attach.
	}
}

function ServerOrderAssault( Unit targetUnit, int addresseeUnit )
{
	local Unit ledUnit;

			
	ledUnit = GetPlayerLedUnit();
	if( ledUnit != None )
	{
		if((addresseeUnit >= 0) && (addresseeUnit < ledUnit.NumSubUnits))
		{
			ledUnit = ledUnit.SubUnits[ addresseeUnit ];
		}
		else
		{
			ledUnit = None;
		}
	}

	if (ledUnit != None)
	{
		ledUnit.OrderAssault( targetUnit );
	}
	else
	{
		// Bogus order.  Kill the icon to attach.
	}
}

/*
function OrderManTurret( TurretWeapon Turret )
{
	local Unit ledUnit;

	ledUnit = GetAddresseeUnit();

	if( ledUnit != None )
	{
		ledUnit.OrderManTurret( Turret );
		//ledUnit.TargetOrderIcon = OrderIcon;
		ledUnit.SetTargetOrderIcon( OrderIcon );
	}
}
*/

simulated function OrderFallIn( optional bool AllSubUnits )
{
	local Unit ledUnit;	
	local int i;
	local float delay;
	delay=0.0;
	
	if ( Level.Pauser == PlayerReplicationInfo ) // Dont change view while paused.
		return;

	if( AllSubUnits )
	{	
		ledUnit = GetPlayerLedUnit();

		if( ledUnit != None ){
			//loop through all of the sub units and set their order icon to none because all are falling in
			for (i=0;i<ledUnit.NumSubUnits;i++){
				ledUnit.SubUnits[ i ].SetTargetOrderIcon(None);
			}				
		}
		ServerOrderFallIn(0,AllSubUnits);
	}
	else
	{
		ledUnit = GetAddresseeUnit();
		// Make sure we have a Unit to give orders to	
		if(ledUnit != None)
		{						
			// If the pawn has a weapon, play first person action animation
			if( Pawn.Weapon != None && Pawn.Weapon.CanPlaySignalAnim())
				Pawn.Weapon.PlayAnim('signal_rally', 1.0, 0.0);

			if( bAddressTeamLeaderNextTime && Level.NetMode == NM_Standalone && ( !ledUnit.Leader.IsTank() && !ledUnit.Leader.IsTankCommander() ) )
				delay=1.0;

			ClearSpeechQueue();	
			MaybeAddressLeaderByName( ledUnit );
			//QueueSpeech( CommandCueFallIn );
		
			// play the command
			log( "gbxPlayerController::OrderFallIn() - PlaySpeech( " $ ledUnit.GetControllingPlayerController().Pawn $ ", " $ ledUnit.Leader $ ", FallIn )", 'RSC' );
			Level.TheAISpeechManager.PlaySpeech( 
				ledUnit.GetControllingPlayerController().Pawn, 
				ledUnit.Leader, 
				'FallIn',
				,
				, 
				delay, 
				, 
				5.0, 
				0.0
			);

			ledUnit.SetTargetOrderIcon(None); //NAC:set his target icon to none
		}
		
		ServerOrderFallIn(iAddresseeUnit, AllSubUnits);		// -BB If the LedUnit is None, should we send this to the server?
		ledUnit.ClientSetTargetUnit_Hack( None );
		TypeLastOrder = ORDER_FallIn;
		if ( Role < ROLE_Authority ) // Update order information to server
			ServerSetOrderAndTime( TypeLastOrder );
	}
}

simulated function OrderFallOut( optional bool AllSubUnits )
{
	local Unit ledUnit;
	local Name nameCommand;
	local float delay;
	delay=0;

	if ( Level.Pauser == PlayerReplicationInfo ) // Do not allow fall out while paused.
		return;

	if( AllSubUnits )
	{
		ServerOrderFallOut(0,AllSubUnits);
	}
	else
	{
		ledUnit = GetAddresseeUnit();
		// Make sure we have a Unit to give orders to	
		if( ledUnit != None )
		{		
			// If the pawn has a weapon, play first person action animation
			if (Pawn.Weapon != None && Pawn.Weapon.CanPlaySignalAnim())
				Pawn.Weapon.PlayAnim('signal_rally', 1.0, 0.0);

			if( bAddressTeamLeaderNextTime && Level.NetMode == NM_Standalone && ( !ledUnit.Leader.IsTank() && !ledUnit.Leader.IsTankCommander() ) )
				delay=1.0;

			ClearSpeechQueue();
			MaybeAddressLeaderByName( ledUnit );

			// play the command
			log( "gbxPlayerController::OrderFallOut() - PlaySpeech( " $ ledUnit.GetControllingPlayerController().Pawn $ ", " $ ledUnit.Leader $ ", " $ nameCommand $ ")", 'RSC' );
			if( ledUnit.HasVehicles() && Level.NetMode == NM_Standalone )
			{
				Level.TheAISpeechManager.PlaySpeech( 
					ledUnit.GetControllingPlayerController().Pawn, 
					ledUnit.Leader, 
					'TankFallOut',
					,
					, 
					delay, 
					, 
					5.0, 
					0.0
				);	
			}
			else
			{
				Level.TheAISpeechManager.PlaySpeech( 
					ledUnit.GetControllingPlayerController().Pawn, 
					ledUnit.Leader, 
					'FallOut',
					,
					, 
					delay, 
					, 
					5.0, 
					0.0
				);	
			}
		}

		ServerOrderFallOut(iAddresseeUnit, AllSubUnits);
		TypeLastOrder = ORDER_FallOut;
		if ( Role < ROLE_Authority ) // Update order information to server
			ServerSetOrderAndTime( TypeLastOrder );
	}
}

function ServerOrderFallIn( int addresseeUnit, optional bool AllSubUnits )
{
	local Unit ledUnit;

	if( AllSubUnits )
	{
		ledUnit = GetPlayerLedUnit();
		ledUnit.OrderAllFallIn();
	}
	else
	{
		ledUnit = GetPlayerLedUnit();
		if( ledUnit != None )
		{
			if((addresseeUnit >= 0) && (addresseeUnit < ledUnit.NumSubUnits) && ledUnit.SubUnits[ addresseeUnit ].AnyLivingMembers() )
			{
				ledUnit = ledUnit.SubUnits[ addresseeUnit ];
			}
			else
			{
				ledUnit = None;
			}
		}

		if (ledUnit != None)
		{
			ledUnit.OrderFallIn();
		}
	}
}

function ServerOrderFallOut( int addresseeUnit, optional bool AllSubUnits )
{
	local Unit	ledUnit;
	local int	i;
		
	if( AllSubUnits )
	{
		ledUnit = GetPlayerLedUnit();
		for( i = 0; i < ledUnit.NumSubUnits; i++ )
		{
			ledUnit.SubUnits[ i ].DetachFromSuperUnit();
		}
	}
	else
	{
		ledUnit = GetPlayerLedUnit();
		if( ledUnit != None )
		{
			if((addresseeUnit >= 0) && (addresseeUnit < ledUnit.NumSubUnits) && ledUnit.SubUnits[ addresseeUnit ].AnyLivingMembers())
			{
				ledUnit = ledUnit.SubUnits[ addresseeUnit ];
			}
			else
			{
				ledUnit = None;
			}
		}

		if (ledUnit != None)
		{
			ledUnit.DetachFromSuperUnit();
		}
	}
}


function ServerSetOrderAndTime(EOrderType order)
{
	TypeLastOrder = order;
	TimeLastOrder = Level.TimeSeconds;
}


function Restart()
{
	local name LastStartSpotEvent;

	Super.Restart();
	Level.Game.SetGameSpeed(1.0);
	aDeadPawn = None;

	if (Pawn.LastStartSpot != None)
		LastStartSpotEvent = Pawn.LastStartSpot.Event;

	if (SpawnController == None)
	{
		ForEach DynamicActors( class'gbxBaseFireTeamSpawnController', SpawnController, LastStartSpotEvent )
		{
			break;
		}
	}

	if (CombatDesaturationAmount > 0)
	{
		CombatDesaturationAmount = 1;
		flLastCombatDesatTime = Level.TimeSeconds + COMBAT_DESAT_TIME_SLOT + 0.1;
	}
}

function CalcBehindView(out vector CameraLocation, out rotator CameraRotation, float Dist)
{
	local gbxPawn gbxP;

	gbxP = gbxPawn( Pawn );

	if ( (gbxP != None) && (gbxP.Turret != None && ( gbxP.bHasStartedMountAnim || gbxP.bIsManningTurret )) )
	{
		//gbxP.Turret.CalcBehindView( CameraLocation, CameraRotation, Dist );
	}
	else
		Super.CalcBehindView( CameraLocation, CameraRotation, Dist );
}

native function bool CanSeeOrSuppress( Pawn Other, out Vector SeeLocation, out int bIsHeadShot, out Vector SuppressLocation, out Vector FailLoc, optional int Posture );
native function bool CanSeeOrSuppressFromPoint( Pawn Other, Vector FromLocation, out Vector SeeLocation, out int bIsHeadShot, out Vector SuppressLocation, out Vector FailLoc, optional int Posture );
native function float GetTargetExposureToMeNative( Pawn Target );

// unpossessed a pawn (because pawn was killed)
function PawnDied(Pawn P)
{
	local gbxPawn deadGbxPawn;
	
	// Remove any use messages from the HUD
	P.ReceiveLocalizedMessage(class'gbxContextUseHUDMessage', -1);  

    ClientPawnDied();

	Super.PawnDied(P);

	//SDJ 05/17/2004: Remove the pawn from their unit when they die.
	if (gbxPawn(P) != None)
	{
		deadGbxPawn = gbxPawn(P);
		if (deadGbxPawn.MyUnit != None)
		{
			deadGbxPawn.MyUnit.RemoveMember(deadGbxPawn);
		}
	}

	if (Level.Game.IsA('WargameSinglePlayer') && gbxPawn(P) != None)
	{
		bBehindView = false;
		log(self$".PawnDied( "$P$" )", 'Pawn');
		P.bSpecialCalcView = true;
		gbxPawn(P).bInBodyDeathCam = true;
		aDeadPawn = gbxPawn(P);

		EnableSoundCategory( ESoundCategory.SC_AMBIENT,	false, 6.0 );	
		EnableSoundCategory( ESoundCategory.SC_CINEMATIC, false, 6.0 );
		EnableSoundCategory( ESoundCategory.SC_SOUNDFX,	false, 6.0 );
	}
	else if ( Level.Game.IsA('WargameMultiplayer') )
	{
		// PSV: 5/17/2004 No longer go to Dead state, go to field promoting 
		//Log("PlayerController::PawnDied() GotoState FieldPromoting", 'PSV');
		if (GameReplicationInfo.GameType == GT_Skirmish)
		{
			GotoState('SkirmishDeathView');
		}
		else
		{
			GotoState('FieldPromoting');
		}
	}
}

simulated function ClientNotifyPawnDied( gbxPawn deadPawn )
{
	NotifyPawnDied( deadPawn );
}

simulated function NotifyPawnDied( gbxPawn deadPawn )
{
	// Called when any pawn in the game gets killed.

	if( (deadPawn == Pawn) || (deadPawn == None) )
	{
		return;
	}

	// Show inspector for friendly pawns who die.
	if( NotificationMinRadiusDeath >= 0 && NotificationMinRadiusDeath <= VSize( deadPawn.Location - Pawn.Location ) &&
		!IsInOracleCamMode() && IsUnderPlayerCommand( deadPawn ))
	{
		gbxHUD(MyHUD).DisplayPawnDeathInspector( deadPawn );
	}
}

simulated function ClientNotifyPawnTakingDamage( gbxPawn hurtPawn )
{
	// Called when any pawn in the game gets hurt and hasn't notified in a while.

	if ( (hurtPawn == Pawn) || (hurtPawn == None) )
	{
		return;
	}

	// Show inspector for friendly pawns who die.
	if( NotificationMinRadiusDamage >= 0 && NotificationMinRadiusDamage <= VSize( hurtPawn.Location - Pawn.Location ) &&
		!IsInOracleCamMode() && IsUnderPlayerCommand( hurtPawn ))
	{
		gbxHUD(MyHUD).DisplayPawnDamagedInspector( hurtPawn );
	}
}

function ClientPawnDied()
{
	local int playerindex;

	if( OrderIcon != None && OrderIcon.IsShown() )
	{
		CancelOrderIcon();
	}

	// PSV: 5/26/2004 If we're in tactical view, pull us out.
	// The flag below is only set in MP.
	if ( bInOracleCameraMP )
	{
		// Not no mo' you aint sucka!
		ClientDeactivateOracleImmediately();

		playerindex = Player.SplitIndex;
	    Level.CameraEffectManager[playerindex].RestoreDefaultEffect();
	}
}

simulated event PlayerCalcView(out actor ViewActor, out vector CameraLocation, out rotator CameraRotation )
{
	// Tatical cam mode.
	if ( IsInOracleCamMode() )
	{
		if( OracleCam.SpecialCalcView( ViewActor, CameraLocation, CameraRotation ))
		{
			return;
		}
	}

	// AI Debugging Mode.
	if ( IsInAIDebugMode() )
	{
		if ( AIDebugCam.SpecialCalcView( ViewActor, CameraLocation, CameraRotation ))
		{
			return;
		}
	}

	if( aDeadPawn != None && aDeadPawn.bSpecialCalcView )
	{
		aDeadPawn.SpecialCalcView( ViewActor, CameraLocation, CameraRotation );
		return;
	}

	Super.PlayerCalcView( ViewActor, CameraLocation, CameraRotation );
}

state GameEnded
{
	function BeginState()
	{
		Super.BeginState();

		gbxHUD(MyHUD).bForceDrawLocalMessages = true;

		// Only local players should get OracleCamera activated: Bug 12226
		if (Viewport(Player) != None)
		{
			ActivateSimplifiedOracle();
		}
	}

	function EndState()
	{
		Super.EndState();

		gbxHUD(MyHUD).bForceDrawLocalMessages = false;
	}
}

// This state override is solely for the purpose of providing an overridden PlayerMove,
// which is solely for the purpose of preventing player movement while mounting turret weapons.
state PlayerWalking
{
	function PlayerMove( float DeltaTime )
	{
		local vector NewAccel;
		local eDoubleClickDir DoubleClickMove;
		local rotator OldRotation, ViewRotation;
		local bool	bSaveJump;

		if ( Pawn == None ||
			( Pawn != None && !( Pawn.bIsManningTurret || gbxPawn(Pawn).bHasStartedMountAnim ) ) )
			Super.PlayerMove( DeltaTime );
		else
		{
			// Update rotation only.

			ViewRotation = Rotation;

			SetRotation(ViewRotation);
			OldRotation = Rotation;
			UpdateRotation(DeltaTime, 1);
			bDoubleJump = false;

			if ( bPressedJump && Pawn.CannotJumpNow() )
			{
				bSaveJump = true;
				bPressedJump = false;
			}
			else
				bSaveJump = false;

			if ( Role < ROLE_Authority ) // then save this move and replicate it
				ReplicateMove(DeltaTime, NewAccel, DoubleClickMove, OldRotation - Rotation);
			else
				ProcessMove(DeltaTime, NewAccel, DoubleClickMove, OldRotation - Rotation);
			bPressedJump = bSaveJump;
		}
	}
}

// Hook for zoom in/out function in WargamePlayerController
exec function ChangeView( int nFirstPerson );

// Hook for LimtPlayerInput in WargamePlayerController
simulated function LimitPlayerInput( bool bLimited );

// Hook for heavy trauma effect in WargamePlayerController
exec function DoHeavyTrauma();

simulated function EnableHeavyTrauma( bool bEnabled );	// Implement in WargamePlayerController

exec simulated function EnableHighDynamicRange( optional bool setDefault )
{
    local int playerindex;

	playerindex = 0;
	if (Player != None)
	    playerindex = Player.SplitIndex;
    
	Level.CameraEffectManager[playerindex].SetCameraEffect(CAM_HighDynamicRange, setDefault);
}

exec simulated function EnableBlur( optional bool setDefault )
{
    local int playerindex;

	playerindex = 0;
	if (Player != None)
	    playerindex = Player.SplitIndex;

	Level.CameraEffectManager[playerindex].SetCameraEffect(CAM_Blur, setDefault);
}

exec simulated function EnableCamRenderTarget( optional bool setDefault )
{
    local int playerindex;

	playerindex = 0;
	if (Player != None)
	    playerindex = Player.SplitIndex;
    
	Level.CameraEffectManager[playerindex].SetCameraEffect(CAM_Default , setDefault);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// TACTICAL VIEW ////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

simulated exec function ActivateOracle()
{
	local int m;

	if (Level.TimeSeconds < 1.0f)
	{
		return;
	}
	
	if ((gbxHUD(MyHUD) != None) && (gbxHUD(MyHUD).m_nHelpOverlay > 0))
	{
		return;
	}
	
	// Dont enter oracle cam when game is paused
	if(Level.Pauser != None)
	{
		return;
	}
	
	// This is pretty bad, but no real good way around this.
	// We do not want to enter SA view while there is a cam motion blur active.
	if (Level.CameraEffectManager[Player.SplitIndex].CamMotionBlurEffect == Level.CameraEffectManager[Player.SplitIndex].CurrentCameraEffect
	&& Level.CameraEffectManager[Player.SplitIndex].CamMotionBlurEffect.bFade)
	{
		return;
	}
	
	
	// Create the oracle camera if it doesn't exist yet
	if( OracleCam == None )
	{
		if( Level.IsXbox() )
		{
			OracleCam = new( Self ) class'OracleCameraXbox';
		}
		else
		{
			OracleCam = new( Self ) class'OracleCamera';
		}
	}

	// Bug 1853: Don't let the player close OracleCam when the game is ending
	if ( OracleCam.IsActive() && OracleCam.IsSimplified())
	{
		return;
	}

	if( OracleCam != None )
	{
		OracleCam.SetOwnerPlayerController( self );
	}
	else
	{
		log("ERROR: "$self$" unable to initialize Oracle Camera.");
		return;
	}

//DLEVY 1/15/05 stop weapon firing when Activate OracleCam
	for ( m = 0; m < Pawn.Weapon.NUM_FIRE_MODES; m++)
    {
        if (Pawn.Weapon.FireModeClass[m] != None)
        {
			if (Pawn.Weapon.FireMode[m].bIsFiring)
                Pawn.Weapon.StopFire(m);
        }
    }
//end DLEVY

	if (Pawn.Weapon != None)
	{
		// notify the Weapon that OracleCam (SA View) is being activated/deactivated)...
		Pawn.Weapon.ActivateOracle();
	}

	OracleCam.ToggleActive();
}

simulated function ActivateSimplifiedOracle()
{
	if ((gbxHUD(MyHUD) != None) && (gbxHUD(MyHUD).m_nHelpOverlay > 0))
	{
		return;
	}
	
	// Create the oracle camera if it doesn't exist yet
	if( OracleCam == None )
	{
		if( Level.IsXbox() )
		{
			OracleCam = new( Self ) class'OracleCameraXbox';
		}
		else
		{
			OracleCam = new( Self ) class'OracleCamera';
		}
	}

	if( OracleCam != None )
	{
		OracleCam.SetOwnerPlayerController( self );
	}
	else
	{
		return;
	}

	if ( OracleCam.IsActive() )
	{
		OracleCam.Reactivate(true);
	}
	else
	{
		OracleCam.ToggleActive(true);
	}
}

function DeactivateOracleImmediately()
{
	OracleCam.DeactivateImmediately();
}

simulated function ClientDeactivateOracleImmediately()
{
	OracleCam.DeactivateImmediately();
}

simulated function bool IsInOracleCamMode()
{
	return OracleCam != None && OracleCam.IsActive();
}

simulated exec function OracleCamUnitSelect()
{
	if( IsInOracleCamMode() && !OracleCam.IsSimplified() )
	{
		OracleCam.UnitSelect();
	}
}

simulated exec function OracleCamTargetObjective()
{
	if( IsInOracleCamMode() && !OracleCam.IsSimplified() )
	{
		OracleCam.SelectObjective();
	}
}

simulated exec function OracleCamTargetSelf()
{
	if( IsInOracleCamMode() && !OracleCam.IsSimplified() )
	{
		OracleCam.SelectSelf();
	}
}

simulated exec function NextOracleCamTarget()
{
	if( IsInOracleCamMode() && !OracleCam.IsSimplified() )
	{
		OracleCam.CycleNextTarget();
	}
}

simulated exec function PrevOracleCamTarget()
{
	if( IsInOracleCamMode() && !OracleCam.IsSimplified() )
	{
		OracleCam.CyclePrevTarget();
	}
}

simulated exec function ToggleOracleZoom()
{
	if( IsInOracleCamMode() && !OracleCam.IsSimplified() )
	{
		OracleCam.ToggleZoom();
	}
}

simulated exec function ResetOracleCamOffset()
{
	if( IsInOracleCamMode() && !OracleCam.IsSimplified() )
	{
		OracleCam.ResetZenithOffset();
		OracleCam.CycleTargetStartTime = Level.UniversalTimeSeconds;
	}
}

simulated function bool IsInAIDebugMode()
{
	return ( Level.bUseAIDebugCam && AIDebugCam != None && AIDebugCam.IsActive() );
}

simulated function bool DoAssaultIfFire()
{
	if (!bAssaultOrderEnabled)
		return false;

	return AssaultInterface == ASSAULT_FireChord && OrderIcon != None && ( OrderIcon.TargetIcon != None || OrderIcon.TargetPawn != None );
}

simulated function bool AllowFire()
{
	// Don't allow fire if about to assault-on-fire,
	// or if we just assaulted.
	return !DoAssaultIfFire() &&
		( Level.TimeSeconds - TimeLastOrder > 0.5 || TypeLastOrder != ORDER_Assault );
}

exec function Fire( optional float F )
{
	if (gbxVehicle(Pawn) != None)  // player pressing Fire while in vehicle?
	{
		gbxVehicle(Pawn).Fire();
		return;
	}
	else if( DoAssaultIfFire() )
	{
		TeamOrder( true );	// Force an assault.
	}
	else
	{
		CancelOrderIcon();

		//DLEVY 1/15/05 dont allow weapons to fire when in player in Oracle cam mode. Previously weapons 
		//were prevented from firing in oraclecam mode because they were not being ticked when game was paused
		//this did not stop the MGs however.
		if (!IsInOracleCamMode())
		{
			Super.Fire( F );
		}
		
	}
}

// The player wants to alternate-fire.
exec function AltFire( optional float F )
{
	if (gbxVehicle(Pawn) != None)  // player pressing Fire while in vehicle?
	{
		gbxVehicle(Pawn).AltFire();
		return;
	}

	Super.AltFire( F );
}

simulated function BeginCamDesaturation( optional byte DesaturationAmount )
{
    local int playerindex;

	playerindex = 0;
	if (Player != None)
	    playerindex = Player.SplitIndex;

    Level.CameraEffectManager[playerindex].SetCameraEffect(CAM_Desaturation);
    
    // Initialize the saturation
    Level.CameraEffectManager[playerindex].CamDesaturationEffect.GlobalColor.A = 0;
    Level.CameraEffectManager[playerindex].CamDesaturationEffect.MaxDesaturation = DesaturationAmount;
    
    // Start the transition
    Level.CameraEffectManager[playerindex].CamDesaturationEffect.bDesaturate = true;
    Level.CameraEffectManager[playerindex].CamDesaturationEffect.bDesaturateUpdate = true;
    Level.CameraEffectManager[playerindex].CamDesaturationEffect.SaturationStartTime = Level.UniversalTimeSeconds;
}

simulated function UpdateCamDesaturation( byte DesaturationAmount )
{
    local int playerindex;

	playerindex = 0;
	if (Player != None)
	    playerindex = Player.SplitIndex;

    Level.CameraEffectManager[playerindex].CamDesaturationEffect.MaxDesaturation = DesaturationAmount;
    
    // Start the transition
    Level.CameraEffectManager[playerindex].CamDesaturationEffect.SaturationStartTime = Level.UniversalTimeSeconds;
}

simulated function EndCamDesaturation()
{
    local int playerindex;

	playerindex = 0;
	if (Player != None)
	    playerindex = Player.SplitIndex;

    Level.CameraEffectManager[playerindex].CamDesaturationEffect.bDesaturate = false;
    Level.CameraEffectManager[playerindex].CamDesaturationEffect.bDesaturateUpdate = false;
    Level.CameraEffectManager[playerindex].CamDesaturationEffect.SaturationStartTime = Level.UniversalTimeSeconds;
}

simulated function BeginCamSituationalAwareness()
{
    local int playerindex;

	playerindex = 0;
	if (Player != None)
	    playerindex = Player.SplitIndex;
    
	if (Level.CameraEffectManager[playerindex].CurrentCameraMode == CAM_OldMovie)  //NAC: If we are in old movie mode, we dont need to do all the saturation effects.
		Level.CameraEffectManager[playerindex].SetCameraEffect(CAM_SituationalAwareness);
	else
	{
                Level.CameraEffectManager[playerindex].SetCameraEffect(CAM_SituationalAwareness);
	        Level.CameraEffectManager[playerindex].CamSituationalAwarenessEffect.GlobalColor.A = 0;
                // Start the transition
                Level.CameraEffectManager[playerindex].CamSituationalAwarenessEffect.bDesaturate = true;
                Level.CameraEffectManager[playerindex].CamSituationalAwarenessEffect.SaturationStartTime = Level.UniversalTimeSeconds;
        }
}

simulated function EndCamSituationalAwareness()
{
    local int playerindex;

	playerindex = 0;
	if (Player != None)
	    playerindex = Player.SplitIndex;

    Level.CameraEffectManager[playerindex].CamSituationalAwarenessEffect.bDesaturate = false;
    Level.CameraEffectManager[playerindex].CamSituationalAwarenessEffect.SaturationStartTime = Level.UniversalTimeSeconds;
}

simulated function OracleCamDeactivated()
{	
	bBehindView = Pawn != None && Pawn.bIsManningTurret;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// AI DEBUGGING  ////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

exec notinship function EnableAIDebugCam()
{
	bEnableAIDebugCam = true;
}

exec notinship function DisableAIDebugCam()
{
	bEnableAIDebugCam = false;
}

simulated exec notinship function ActivateAIDebugCam()
{
	local class<IAIDebugCamera> AIDebugCameraClass;
	if ( !Level.bUseAIDebugCam || !bEnableAIDebugCam )
		return;

	if ( AIDebugCam == None )
	{
		AIDebugCameraClass = class<IAIDebugCamera>( DynamicLoadObject( AIDebugCamClassName, class'Class' ) );
		AIDebugCam = new( None ) AIDebugCameraClass;
		AIDebugCam.LoadResources();
		AIDebugCam.SetOwnerPlayerController( Self );
	}

	AIDebugCam.ToggleActive();
}

simulated exec notinship function AIDebugCamToggleMode()
{
	if ( IsInAIDebugMode() )
		AIDebugCam.ToggleMode();
}

simulated exec notinship function AIDebugCamToggleTeam() 
{
	if ( IsInAIDebugMode() )
		AIDebugCam.ToggleTeam();
}

simulated exec notinship function AIDebugCamToggleUnit()
{
	if ( IsInAIDebugMode() )
		AIDebugCam.ToggleUnit();
}

simulated exec notinship function AIDebugCamTogglePawn() 
{
	if ( IsInAIDebugMode() )
		AIDebugCam.TogglePawn();
}

simulated exec notinship function AIDebugCamToggleEnemy()
{
	if ( IsInAIDebugMode() )
		AIDebugCam.ToggleEnemy();
}

simulated exec notinship function AIDebugCamTogglePause()
{
	if ( IsInAIDebugMode() )
	{
		AIDebugCam.TogglePause();
	}
}

simulated exec notinship function AIDebugCamClose()
{
	if ( IsInAIDebugMode() )
		AIDebugCam.ToggleActive();
}

simulated exec notinship function PrevAIDebugCamTarget()
{
	if ( IsInAIDebugMode() )
		AIDebugCam.PrevNodeOrEnemy();
}

simulated exec notinship function NextAIDebugCamTarget()
{
	if ( IsInAIDebugMode() )
		AIDebugCam.NextNodeOrEnemy();
}

simulated exec notinship function AIDebugCamToggleZoom()
{
	if ( IsInAIDebugMode() )
		AIDebugCam.ToggleZoom();
}

simulated function Tick( float DeltaTime )
{
	Super.Tick( DeltaTime );
}


////////////////////////

// PSV: 5/17/2004 New field promotion state
//		Mix between Dead and Spectating state
state FieldPromoting
{
ignores SeePlayer, HearNoise, KilledBy, SwitchWeapon, NextWeapon, PrevWeapon, OracleCamTargetObjective, OracleCamTargetSelf, Fire;

	function PlayerTick( float DeltaTime )
	{
		Global.PlayerTick( DeltaTime );
	}

	function ThrowWeapon()
	{
	}

	function bool IsDead()
	{
		return true;
	}

	function bool IsSpectating()
	{
		return false;
	}

	function bool IsFieldPromoting()
	{
		return true;
	}

	function bool IsViewingDeadBody()
	{
		if (FieldPromotionState == None)
		{
			return true;
		}
		
		return FieldPromotionState.IsViewingDeadBody();
	}

	function ServerReStartPlayer()
	{
		// From Controller.uc
		if ( Level.NetMode == NM_Client )
			return;
		Log("PlayerController::State FieldPromoting RestartPlayer()", 'PSV');
		Level.Game.RestartPlayer(self);
	}

    exec function FieldPromoteSelect( optional float F )
	{
		if (!bFrozen && (FieldPromotionState != None))
		{
			FieldPromotionState.FieldPromoteSelect( F );
		}
	}

	exec function FieldPromoteChoose( optional float F )
	{
		// Skirmish mode doesn't support field promotoion
		if ( GameReplicationInfo != None && GameReplicationInfo.GameType == GT_SKIRMISH )
			return;

 		if (!bFrozen && (FieldPromotionState != None))
		{
			FieldPromotionState.FieldPromoteChoose( F );
		}
	}

    function ServerMove
	(
		float TimeStamp,
		vector Accel,
		vector ClientLoc,
		bool NewbRun,
		bool NewbDuck,
		bool NewbJumpStatus,
        bool NewbDoubleJump,
		eDoubleClickDir DoubleClickMove,
		byte ClientRoll,
		int View,
		optional byte OldTimeDelta,
		optional int OldAccel
	)
	{
		Global.ServerMove(
					TimeStamp,
					Accel,
					ClientLoc,
					false,
					false,
					false,
                    false,
					DoubleClickMove,
					ClientRoll,
					View);
	}

    function PlayerMove(float DeltaTime)
	{
		if ( !bFrozen )
		{
			if ( bPressedJump )
			{
				Fire(0);
				bPressedJump = false;
			}
		}
        else if ( (TimerRate <= 0.0) || (TimerRate > 1.0) )
			bFrozen = false;

		ViewShake(DeltaTime);
		ViewFlash(DeltaTime);
	}

    function FindGoodView()
	{
		local vector cameraLoc;
		local rotator cameraRot, ViewRotation;
		local int tries, besttry;
		local float bestdist, newdist;
		local int startYaw;
		local actor ViewActor;

		////log("Find good death scene view");
		ViewRotation = Rotation;
		ViewRotation.Pitch = 56000;
		tries = 0;
		besttry = 0;
		bestdist = 0.0;
		startYaw = ViewRotation.Yaw;

		for (tries=0; tries<16; tries++)
		{
			cameraLoc = ViewTarget.Location;
			SetRotation(ViewRotation);
			PlayerCalcView(ViewActor, cameraLoc, cameraRot);
			newdist = VSize(cameraLoc - ViewTarget.Location);
			if (newdist > bestdist)
			{
				bestdist = newdist;
				besttry = tries;
			}
			ViewRotation.Yaw += 4096;
		}

		ViewRotation.Yaw = startYaw + besttry * 4096;
		SetRotation(ViewRotation);
	}

    function Timer()
    {
        if (!bFrozen)
            return;

        bFrozen = false;
        bPressedJump = false;
    }

    function BeginState()
    {
		log("FieldPromotion BeginState()", 'MP');
		
		if ( FieldPromotionState == None )
		{
			FieldPromotionState = new( Self ) class'FieldPromotionFlow';
		}
		FieldPromotionState.Initialize(self);
		
		// From Dead
		if ( (Pawn != None) && (Pawn.Controller == self) )
			Pawn.Controller = None;
		EndZoom();
		FOVAngle = 63.0;  // DesiredFOV
		Pawn = None;
		Enemy = None;
		bBehindView = true;
		bFrozen = true;
		bJumpStatus = false;
		bPressedJump = false;
        bBlockCloseCamera = true;
		bValidBehindCamera = false;
		FindGoodView();
        SetTimer(1.0, false);
		CleanOutSavedMoves();

		// From Spectating
		bCollideWorld = true;

		// New code
		ServerSetFieldPromoteAutochoose(true);
		bFieldPromoteAutochoose = true;
    }

    function EndState()
    {
		log("FieldPromotion EndState(): Pawn = " $ Pawn $ ", ViewTarget = " $ ViewTarget, 'MP');
		
		// From Dead
		bBlockCloseCamera = false;
		CleanOutSavedMoves();
		Velocity = vect(0,0,0);
		Acceleration = vect(0,0,0);
        if ( !PlayerReplicationInfo.bOutOfLives )
			bBehindView = false;
		bPressedJump = false;
		myHUD.bShowScores = false;

		// From Spectating
		PlayerReplicationInfo.bIsSpectator = false;
		bCollideWorld = false;
    }

Begin:
    Sleep(1.0);
}

function ServerSpectate()
{
	if( Level.Game.MaxPlayers <= 1 )
		return;

	GotoState('Spectating');
	
	ClientGotoState('Spectating', 'Begin');
    bBehindView = true;
    ServerViewNextPlayer();
}

////////////////////////

// PAD: 5/17/2004 New skirmish death view state
//		Mix between Dead and Spectating state
state SkirmishDeathView
{
ignores SeePlayer, HearNoise, KilledBy, SwitchWeapon, NextWeapon, PrevWeapon, OracleCamTargetObjective, OracleCamTargetSelf, Fire;

	function PlayerTick( float DeltaTime )
	{
		Global.PlayerTick( DeltaTime );
	}

	function ThrowWeapon()
	{
	}

	function bool IsDead()
	{
		return true;
	}

	function bool IsSpectating()
	{
		return false;
	}

	function bool IsFieldPromoting()
	{
		return false;
	}

	function bool IsViewingDeadBody()
	{
		return true;
	}

	function ServerReStartPlayer()
	{
		// From Controller.uc
		if ( Level.NetMode == NM_Client )
			return;
		Log("PlayerController::State FieldPromoting RestartPlayer()", 'PSV');
		Level.Game.RestartPlayer(self);
	}

    exec function FieldPromoteSelect( optional float F )
	{
		if ( bFrozen )
		{
			if ( (TimerRate <= 0.0) || (TimerRate > 1.0) )
				bFrozen = false;
			return;
		}
		ServerSpectate();
	}

	exec function FieldPromoteChoose( optional float F )
	{
	}

    function ServerMove
	(
		float TimeStamp,
		vector Accel,
		vector ClientLoc,
		bool NewbRun,
		bool NewbDuck,
		bool NewbJumpStatus,
        bool NewbDoubleJump,
		eDoubleClickDir DoubleClickMove,
		byte ClientRoll,
		int View,
		optional byte OldTimeDelta,
		optional int OldAccel
	)
	{
		Global.ServerMove(
					TimeStamp,
					Accel,
					ClientLoc,
					false,
					false,
					false,
                    false,
					DoubleClickMove,
					ClientRoll,
					View);
	}

    function PlayerMove(float DeltaTime)
	{
		local vector X,Y,Z;
		local rotator ViewRotation;

		if ( !bFrozen )
		{
			if ( bPressedJump )
			{
				Fire(0);
				bPressedJump = false;
			}
			GetAxes(Rotation,X,Y,Z);
			// Update view rotation.
			ViewRotation = Rotation;
			ViewRotation.Yaw += 2.0 * DeltaTime * aTurn;
			ViewRotation.Pitch += 2.0 * DeltaTime * aLookUp;
			ViewRotation.Pitch = ViewRotation.Pitch & 65535;

            if((ViewRotation.Pitch > 18000) && (ViewRotation.Pitch < 49152)) 	 
            { 	                         
                If (aLookUp > 0) 	 
					ViewRotation.Pitch = 18000; 	 
                else 	 
					ViewRotation.Pitch = 49152; 	 
            }


			SetRotation(ViewRotation);
			if ( Role < ROLE_Authority ) // then save this move and replicate it
				ReplicateMove(DeltaTime, vect(0,0,0), DCLICK_None, rot(0,0,0));
		}
        else if ( (TimerRate <= 0.0) || (TimerRate > 1.0) )
			bFrozen = false;

		ViewShake(DeltaTime);
		ViewFlash(DeltaTime);
	}

    function FindGoodView()
	{
		local vector cameraLoc;
		local rotator cameraRot, ViewRotation;
		local int tries, besttry;
		local float bestdist, newdist;
		local int startYaw;
		local actor ViewActor;

		////log("Find good death scene view");
		ViewRotation = Rotation;
		ViewRotation.Pitch = 56000;
		tries = 0;
		besttry = 0;
		bestdist = 0.0;
		startYaw = ViewRotation.Yaw;

		for (tries=0; tries<16; tries++)
		{
			cameraLoc = ViewTarget.Location;
			SetRotation(ViewRotation);
			PlayerCalcView(ViewActor, cameraLoc, cameraRot);
			newdist = VSize(cameraLoc - ViewTarget.Location);
			if (newdist > bestdist)
			{
				bestdist = newdist;
				besttry = tries;
			}
			ViewRotation.Yaw += 4096;
		}

		ViewRotation.Yaw = startYaw + besttry * 4096;
		SetRotation(ViewRotation);
	}

    function Timer()
    {
        if (!bFrozen)
            return;

        bFrozen = false;
        bPressedJump = false;
    }

    function BeginState()
    {
		log("SkirmishDeathView BeginState()", 'MP');
		
		// From Dead
		if ( (Pawn != None) && (Pawn.Controller == self) )
			Pawn.Controller = None;
		EndZoom();
		FOVAngle = 63.0;  // DesiredFOV
		Pawn = None;
		Enemy = None;
		bBehindView = true;
		bFrozen = true;
		bJumpStatus = false;
		bPressedJump = false;
        bBlockCloseCamera = true;
		bValidBehindCamera = false;
		FindGoodView();
        SetTimer(1.0, false);
		CleanOutSavedMoves();

		// From Spectating
		bCollideWorld = true;
    }

    function EndState()
    {
		log("SkirmishDeathView EndState(): Pawn = " $ Pawn $ ", ViewTarget = " $ ViewTarget, 'MP');
		
		// From Dead
		bBlockCloseCamera = false;
		CleanOutSavedMoves();
		Velocity = vect(0,0,0);
		Acceleration = vect(0,0,0);
        if ( !PlayerReplicationInfo.bOutOfLives )
			bBehindView = false;
		bPressedJump = false;
		myHUD.bShowScores = false;

		// From Spectating
		PlayerReplicationInfo.bIsSpectator = false;
		bCollideWorld = false;
    }

Begin:
    Sleep(1.0);
}

simulated function ActivateFieldPromotionOracle()
{
	log(self $ " gbxPlayerController::ActivateFieldPromotionOracle()", 'MP');

	if ((gbxHUD(MyHUD) != None) && (gbxHUD(MyHUD).m_nHelpOverlay > 0))
	{
		return;
	}
	
	// Create the oracle camera if it doesn't exist yet
	if( OracleCam == None )
	{
		if( Level.IsXbox() )
		{
			OracleCam = new( Self ) class'OracleCameraXbox';
		}
		else
		{
			OracleCam = new( Self ) class'OracleCamera';
		}
	}

	if( OracleCam != None )
	{
		if (!OracleCam.IsActive())
		{
			OracleCam.EnterFieldPromotionMode();
		}
	
		OracleCam.SetOwnerPlayerController( self );
	}
	else
	{
		log("ERROR: "$self$" unable to initialize Oracle Camera.");
		return;
	}
	
	OracleCam.ToggleActive();
}

event ServerSetFieldPromoteAutochoose(bool B)
{
	Log("ServerSetFieldPromoteAutochoose: "$B, 'PSV');
	bFieldPromoteAutochoose = B;
}

simulated exec function CallInReinforcements()
{
	local bool bReinforcementsAllowed;
	local MultiplayerUnit mpUnit;

	bReinforcementsAllowed = false;
	
	if (!IsInOracleCamMode())
	{
		//Log( self$ " gbxPlayerController::CallInReinforcements()", 'PSV');
		mpUnit = MultiplayerUnit( gbxPawn(Pawn).MyUnit );
		if ( mpUnit != None )
		{
			//Log( self$ " gbxPlayerController::CallInReinforcements() NumSubUnits: " $mpUnit.NumSubUnits, 'PSV');
			// Do a really crappy check to see if we already have 2 or more subunits in which case we 
			// know it's not possible.  
			if ( mpUnit.NumSubUnits < 2 )
			{
				//Log( self$ " gbxPlayerController::CallInReinforcements() mpUnit: " $mpUnit$ " has less then two members.", 'PSV');
				bReinforcementsAllowed = true;
			}
		}
	}

	if ( bReinforcementsAllowed )
	{
		// We passed our own check, so ask server to call in reinforcements
		//Log( self$ " gbxPlayerController::CallInReinforcements() Ask server to be reinforced", 'PSV');	
		ServerCallInReinforcements();
	}
}

// Client calls this function to bring in reinforcements after preliminary check on the client.
function ServerCallInReinforcements()
{
	//Log( self$ " gbxPlayerController::ServerCallInReinforcements()", 'PSV');

	// Call function in WargameMultiplayer to handle everything...
	Level.Game.CallInReinforcements( self );
}

// For MP hud reinforcement effects 
simulated function ActivateReinforcementsEffect()
{
	if (GameReplicationInfo.GameType != GT_Skirmish)
	{
		//Log( self$ " gbxPlayerController::ActivateReinforcementsEffect() ReinforcementsArriveSound " $ReinforcementsArriveSound, 'PSV');
		ReceiveLocalizedMessage(class'MPGameMessages', 0);
	}

	if (Viewport(Player) != None)
	{
		if (PlayerReplicationInfo.Team != None && ETeamIdentifier(PlayerReplicationInfo.Team.TeamIndex) == TEAM_US)
		{
			PlaySound( USReinforcementsArriveSound, SLOT_Interact, 1.0, false );
		}
		else if (PlayerReplicationInfo.Team != None && ETeamIdentifier(PlayerReplicationInfo.Team.TeamIndex) == TEAM_German)
		{
			PlaySound( DEReinforcementsArriveSound, SLOT_Interact, 1.0, false );
		}
	}
}

simulated function OnSpectatingBegin()
{
	if (IsInOracleCamMode())
	{
		DeactivateOracleImmediately();
	}

	if ((FieldPromotionState != None) && FieldPromotionState.IsInitialized())
	{
		FieldPromotionState.Shutdown();
	}
}

function SkirmishEndFieldPromotion()
{
	SetInitialState();
	ClientSkirmishEndFieldPromotion();
}

simulated function ClientSkirmishEndFieldPromotion()
{
	SetInitialState();
}

simulated function bool AttachBombToTarget(Pawn User);

function CreateHudBloodEffect( Vector vecdir, int numParticles );

simulated function bool TestForUseTargetHit( Actor TestTarget, Vector TestHitLoc, Vector TestHitNormal );
simulated function PlantBombOnTarget( gbxExplosive aBomb );

simulated function ResetClientView();

//------------------------------------------------------------------------------
// UBI.COM Server Validation Functions
//------------------------------------------------------------------------------
event PreClientTravel()
{
    //###+ lbouchard    
    if ( Level.NetMode==NM_Client)
	{
        // It's very important for the clients connected to the server
        // to inform ubi.com that they are leaving, so that the 
        // server will create a fresh connection for them 
        // when they rejoin on the new instance
        log("Inform ubi.com that we are leaving the server");
		class'GameService.GameService'.static.LeaveServer();	
	}
    //###-
    
    Super.PreClientTravel();
    
}

//Replicated to client
event RequestAuthIdFromClient()
{
	local string component;
	local string result;
	local int i;
	
	result = "";
	
	class'GameService.GameService'.static.GetAuthorizationID(StoredAutorizationID);
	class'GameService.GameService'.static.GetUserName(StoredUbiComUserName);
	
	for(i=0;i<20;i++)
	{
		component = string(StoredAutorizationID[i]);
		while (len(component) < 3)
			component = "0" $ component;
		result = result $ component;
	}
	
	SendAuthIdToServer(result, StoredUbiComUserName);
}

//Replicated to server
event SendAuthIdToServer(string sAuthID, string sUbiComLogin)
{
	local int i;
	local string component;
	for (i=0;i<20;i++)
	{
		component = mid(sAuthID, i*3, 3);
		StoredAutorizationID[i] = byte(component);
	}
	StoredUbiComUserName = sUbiComLogin;
	TimeOfUbiComValidationRequest = -1;
	//log("LAPSUSX : SendAuthIdToServer received " $ StoredUbiComUserName @ StoredAutorizationID[0]  @ StoredAutorizationID[1] @ StoredAutorizationID[2] @ StoredAutorizationID[3]);
	
    PlayerReplicationInfo.Ubicomname=sUbiComLogin;
}

//Replicated to client
event NotifyClientOfKickout()
{
	NativeNotifyClientOfKickout();
}

function gbx_OnlineProfile GetUbiComOnlineProfile()
{
    //log("LAPSUSR: GetUbiComOnlineProfile() " $ UbiComOnlineProfile);
    if (UbiComOnlineProfile == None)
    {
        UbiComOnlineProfile = Spawn(class'gbx_OnlineProfile');
       	UbiComOnlineProfile.BeginPlay();
    	UbiComOnlineProfile.PostBeginPlay();
        //log("LAPSUSR: GetUbiComOnlineProfile() CREATING NEW " $ UbiComOnlineProfile);
    }
    
    return UbiComOnlineProfile;
}

event TeamMessage( PlayerReplicationInfo PRI, coerce string S, name Type  )
{
	local Class<LocalMessage> MessageClass;

	if ( myHUD != None )
	    myHUD.Message( PRI, S, Type );

	switch (Type)
	{
		case 'Say':
			MessageClass = class'SayMessagePlus';
			break;
		case 'TeamSay':
			MessageClass = class'TeamSayMessagePlus';
			break;
		default:
			MessageClass = None;
	}

    if ( (MessageClass != None) && (PRI != None) )
	{
		// Don't munge the name into the message yet, so that the GUI can do as it sees fit
		GetGUIController().ChatMessageReceived(PRI, S);
 		
		S = MessageClass.static.AssembleString(myHUD, 0, PRI, S);
	}

    Player.Console.Message( S, 6.0 );
}

native function NativeNotifyClientOfKickout();

simulated function bool DisableCrosshair()
{
	if (bDisableCrosshair)
		return true;

	return super.DisableCrosshair();
}

function ServerServer( string Msg )
{
	local gbxPawn SomeGbxPawn;
	local MultiplayerUnit mpUnit;

	if ((Msg ~= "mp_switchteam") || (Msg ~= "mp_switchteams"))
	{
		SomeGbxPawn = gbxPawn(Pawn);

		if (SomeGbxPawn != None)
		{
			mpUnit = MultiplayerUnit(SomeGbxPawn.MyUnit);

			if (mpUnit != None)
			{
				if (mpUnit.Team == TEAM_US)
				{
					SomeGbxPawn.PawnTeam = TEAM_German;
					mpUnit.Team = TEAM_German;
				}
				else
				{
					SomeGbxPawn.PawnTeam = TEAM_US;
					mpUnit.Team = TEAM_US;
				}
			}
		}

		return;
	}

	super.ServerServer(Msg);
}

simulated function EndZoomLocal()
{
	bZooming = false;
	DesiredFOV = DefaultFOV;
}

function bool RemoveWeaponFromHud()
{
	if (!bLCDCheck)
	{
		bLCDCheck = true;
		bLCDAvailable = ConsoleCommand("LCD_AVAILABLE") ~= "TRUE";
	}
	
	if (!bLCDAvailable)
		return false;
	
	return bRemoveWeaponFromHud;
}


function ServerViewNextPlayer()
{
	if (m_flNextTargetChange > Level.TimeSeconds)
	{
		return;
	}
	m_flNextTargetChange = Level.TimeSeconds + 0.5;
	
	Super.ServerViewNextPlayer();
}
	
defaultproperties
{
	bHidden=true
    FovAngle=+00070.000000
	LocalMessageClass=class'LocalMessage'

	iAddresseeUnit=0
	TeamOrderTraceNear=1000.0
	TeamOrderTraceFar=30000.0
	TeamOrderRadius=1024
	MaxTeamOrderTraceHeight=512
	TeamOrderRepeatDelay=0.2

	MinPassbyShotDistance=400

	UnitTargetCosAngleMin=0.997
	PawnTargetCosAngleMin=0.997
	FoundEnemyCosAngleMin=0.850
	bTargetOrderPawns=true

	HoldUnitSelectToAttachTime=0.75
	HoldUnitSelectToAttachAllTime=1.50

	EnemyUnitSearchInterval = 2;
	EnemyUnitTraceFar = 10000.0;

	ToggleAddresseeUnitSound=Sound'UI.CLICK'
	USReinforcementsArriveSound=Sound'MP_MISC.REINFORCEMENTS_ALLIES'
	DEReinforcementsArriveSound=Sound'MP_MISC.REINFORCEMENTS_ENEMY'

	bMoveOrderEnabled=true
	bTargetOrderEnabled=true
	bAssaultOrderEnabled=true
	bHideSuppressionIcons=false
	bUseGermanAccent=false

	CameraDist=+32.0	// PSV: 6/16/2004 Changed from 9 units for MP field promotion...doesn't seem to affect anything in SP
	bFieldPromoteAutochoose = true

	bAlwaysTick=true		// gbxPlayerController needs to be ticked all the time, for oracle cam support.
	AIDebugCamClassName="gbxAI.AIDebugCamera"	
	AssaultInterface=ASSAULT_None
	MinHitWall=1.0f

	NotificationMinRadiusDamage=0
	NotificationMinRadiusDeath=0

	bAddressTeamLeaderNextTime=true

	bDisplayMPMissionHints=false  // defaults to false for now because the current hint display mechanism isn't so great... 2004-12-16 JWS
	
	FieldPromotionState=None

	CommandCuePkgSP = "BD_HARTSOCK"

	CommandCuePkgSKRA = "BD_HARTSOCK"
	CommandCuePkgSKRB = "BD_BAKER"

	CommandCuePkgMPUSA = "BD_HARTSOCK"
	CommandCuePkgMPUSB = "BD_BAKER"

	CommandCuePkgMPDEA = "BD_CMD_GER_A"
	CommandCuePkgMPDEB = "BD_CMD_GER_B"

	bRemoveWeaponFromHud = false
	bLCDAvailable = false;
	bLCDCheck = false;
	
	nSpectateObjectiveOffset=-20
}

// usage: base class for localized messages for network player death
class gbxPlayerDeadMessage extends LocalMessage;

var localized string OtherDeathMessageClient;
var localized string OtherDeathMessageServer;
var localized string YourDeathMessageServer;
var localized string OtherDeathMessageServerCP;
var localized string YourDeathMessageServerCP;
var localized string OtherDeathMessageTour;
var localized string YourDeathMessageTour;

static simulated function ClientReceive( 
	PlayerController P,
	optional int Switch,
	optional PlayerReplicationInfo RelatedPRI_1, 
	optional PlayerReplicationInfo RelatedPRI_2,
	optional Object OptionalObject
	)
{
	// Need a small tweak to the base class functionality - we want to generate the message string based on the player that will get the message.
	// So this is a copy of that functionality, modified accordingly. 2004-06-17 JWS
	local string msg;

	msg = Static.GetStringForPlayer( Switch, RelatedPRI_1, RelatedPRI_2, OptionalObject, P );

	if ( P.myHud != None )
	P.myHUD.LocalizedMessage( Default.Class, Switch, RelatedPRI_1, RelatedPRI_2, OptionalObject, msg );

    if ( Default.bIsConsoleMessage && (P.Player != None) && (P.Player.Console != None) )
		P.Player.InteractionMaster.Process_Message( msg, 6.0, P.Player.LocalInteractions);
}

static function bool IsPRISelf(PlayerController player, PlayerReplicationInfo pri)
{
	local bool result;

	if (player.PlayerReplicationInfo == pri)
	{
		result = true;
	}
	else
	{
		result = false;
	}

	return result;
}

static function bool IsPRIAlly(PlayerController player, PlayerReplicationInfo pri)
{
	local bool result;

	if (player.PlayerReplicationInfo.Team.TeamIndex == pri.Team.TeamIndex)
	{
		result = true;
	}
	else
	{
		result = false;
	}

	return result;
}

// PRI1 is the player that generated the message
// OptionalObject is a gbxMcGuffin class
static function string GetStringForPlayer(
	int Switch,
	PlayerReplicationInfo RelatedPRI_1, 
	PlayerReplicationInfo RelatedPRI_2,
	Object OptionalObject,
	PlayerController DisplayPlayer)
{
	local string msg;
	local bool isself, isally;
	local LevelInfo level;

	msg = "";
   	
	level = DisplayPlayer.Level;

	assert(RelatedPRI_1 != None);

	if (RelatedPRI_1 != None)
	{
		isself = static.IsPRISelf(DisplayPlayer, RelatedPRI_1);
		if (Switch == 255)
		{
			if (isself)
			{
				msg = Default.YourDeathMessageTour;
			}
			else
			{
				isally = static.IsPRIAlly(DisplayPlayer, RelatedPRI_1);
				if (isally)
				{
					msg = Default.OtherDeathMessageTour;
				}
			}
			return msg;
		}
		if (isself)
		{
			isally = false;
			if (Switch > 0)
			{
				msg = Default.YourDeathMessageServerCP;
			}
			else
			{
				msg = Default.YourDeathMessageServer;
			}
		}
		else
		{
			isally = static.IsPRIAlly(DisplayPlayer, RelatedPRI_1);
		}

		if (isally)
		{
			if (Level.NetMode == NM_ListenServer)
			{
				if (Switch > 0)
				{
					msg = Default.OtherDeathMessageServerCP;
				}
				else
				{
					msg = Default.OtherDeathMessageServer;
				}
			}
			else
			{
				msg = Default.OtherDeathMessageClient;
			}
		}
		else
		{
			msg = "";
		}
	}
	else
	{
		// Fall back for cases where the player is no longer around. This sucks, but there's not much else we can do except ignore the message
		msg = "";
	}

	return msg;
}

defaultproperties
{
	OtherDeathMessageClient="The other player has died."
	OtherDeathMessageServer="The other player has died.|You may continue playing, end the mission,|or restart the mission from the menu."
	YourDeathMessageServer="You have died.|You may continue playing, end the mission,|or restart the mission from the menu."
	OtherDeathMessageServerCP="The other player has died.|You may continue playing, end the mission,|restart the mission from the menu,|or reload from the last checkpoint."
	YourDeathMessageServerCP="You have died.|You may continue playing, end the mission,|restart the mission from the menu,|or reload from the last checkpoint."
	OtherDeathMessageTour="The other player has died.|Your tour of duty has ended."
	YourDeathMessageTour="You have died.|Your tour of duty has ended."

	bBeep=false
	bFadeMessage=True
	bIsSpecial=True
	bIsUnique=True
	Lifetime=5

	DrawColor=(R=0,G=160,B=255,A=255)
	FontSize=1

	YPos=240
}class gbxRestockUsableCrate extends StaticMeshActor
	placeable;

var()	export	editinline	UsableLoadoutInfo	Usable;		// A list of weapons stored in this crate.

simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();
	
	if (StaticMesh == None)
	{
		SetStaticMesh(StaticMesh(DynamicLoadObject("s_placeholder.scene_prop.ripe_stacked_crates", class'StaticMesh')));
		SetDrawType( DT_StaticMesh );
	}
}

event bool UsedBy(Pawn User)
{
	if (!Super.UsedBy( User ))
	{
		if (gbxPawn(User) != None)
		{
			if (Usable != None)
			{
				if (gbxPawn(User).RestockUsables( Usable ))
				{
					return true;
				}
			}
			else
			{
				gbxPawn(User).RestockUsables( None );
			}
		}
	}
	return true;
}

defaultproperties
{
//	DrawType=DT_StaticMesh
//	StaticMesh=StaticMesh's_placeholder.scene_prop.ripe_stacked_crates'
	DrawType=DT_Sprite
	Texture=Texture'Engine.S_Weapon'
}
class gbxRestockWeaponsCrate extends StaticMeshActor
	placeable;

var()	export	editinline	WeaponLoadoutInfo	Weapon;		// A list of weapons stored in this crate.
var()   int	MaxWeaponPickupsCreated;

var gbxRestockWeaponsCrateTrigger MyTrigger;

simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();
	
	if (StaticMesh == None)
	{
		SetStaticMesh(StaticMesh(DynamicLoadObject("s_placeholder.scene_prop.ripe_stacked_crates", class'StaticMesh')));
		SetDrawType( DT_StaticMesh );
	}
}

function PostBeginPlay()
{
	// spawn the context use trigger
	MyTrigger = spawn( class'gbxRestockWeaponsCrateTrigger' );
	MyTrigger.SetCollisionSize( CollisionRadius, CollisionHeight );
	MyTrigger.m_eUseType = RestockWeapons;
	MyTrigger.Event = Tag;
	MyTrigger.SetBase(Self);
	MyTrigger.SetCollision( true, false, false );
	MyTrigger.theCrate = Self;
	//if( !bAllowPlayerMount )
	//	MyTrigger.bDisabled = true;
}

event bool UsedBy(Pawn User)
{
	if (!Super.UsedBy( User ))
	{
		if (gbxPawn(User) != None)
		{
			if (Weapon != None)
			{
				if (gbxPawn(User).RestockWeapons( Weapon, MaxWeaponPickupsCreated ))
				{
					return true;
				}
			}
			else
			{
				gbxPawn(User).RestockWeapons( None, MaxWeaponPickupsCreated );
			}
		}
	}
	return true;
}

defaultproperties
{
//	DrawType=DT_StaticMesh
//	StaticMesh=StaticMesh's_placeholder.scene_prop.ripe_stacked_crates'
	DrawType=DT_Sprite
	Texture=Texture'Engine.S_Weapon'
	MaxWeaponPickupsCreated=3

	CollisionRadius=125.0
	CollisionHeight=50.0
}
class gbxRestockWeaponsCrateTrigger extends gbxContextUseTrigger;

var gbxRestockWeaponsCrate theCrate;

var class<LocalMessage> RestockMessage;
var class<LocalMessage> PickupMessage;
var class<LocalMessage> GenericMessage;

function PostBeginPlay()
{
	RestockMessage = class<LocalMessage>( DynamicLoadObject( "gbxGamePlay.gbxWeaponRestockMessage", class'class' ) );
	PickupMessage = class<LocalMessage>( DynamicLoadObject( "gbxGamePlay.gbxWeaponPickupMessage", class'class' ) );
	GenericMessage = class<LocalMessage>( DynamicLoadObject( "gbxGamePlay.gbxContextUseHUDMessage", class'class' ) );
}

function Touch( Actor Other )
{
	local Pawn TouchedBy;
	local gbxWeapon theWeapon;
	local string strWeapon;

	if( bDisabled )
		return;

	if( bDontDisplayMessage )
		return;

	TouchedBy = Pawn( Other );

	if( TouchedBy == None || !TouchedBy.IsHumanControlled() )
		return;

	m_fMessageActive = false;

	m_aTouchedBy = TouchedBy;

	if( m_aUseTarget == None )
	{
		if( m_szUseTarget != '' )
		{
			foreach AllActors( class'Actor', m_aUseTarget, m_szUseTarget )
				break;
		}
	}

	if( (Other.Instigator != None) )
	{
		if( m_aTouchedBy == None )
			return;

		if( theCrate != None )
		{			
			if( theCrate.Weapon != None && theCrate.Weapon.m_WeaponClass != None )
			{
				strWeapon = theCrate.Weapon.m_WeaponClass.default.ItemName;
			}

			if( strWeapon != "" )
			{
				// see if we already have this weapon
				theWeapon = gbxWeapon( m_aTouchedBy.FindInventoryType( theCrate.Weapon.m_WeaponClass ) );

				if( theWeapon != None )
				{
					if( theWeapon.ClientState == WS_ReadyToFire )
					{
						m_aTouchedBy.ReceiveLocalizedMessage( RestockMessage, theCrate.Weapon.m_WeaponClass.default.WeaponName );  // display the USE message
						m_fMessageActive = true;
					}
				}
				else
				{
					m_aTouchedBy.ReceiveLocalizedMessage( PickupMessage, theCrate.Weapon.m_WeaponClass.default.WeaponName );  // display the USE message
					m_fMessageActive = true;
				}
			}
			else
			{
				m_aTouchedBy.ReceiveLocalizedMessage( GenericMessage, m_eUseType );  // display the USE message
				m_fMessageActive = true;
			}
		}
	}
}

function UnTouch( Actor Other )
{
	local Pawn User;
	local Pawn UnTouchedBy;

	UnTouchedBy = Pawn( Other );

	if ( UnTouchedBy == None || UnTouchedBy != m_aTouchedBy )
		return;

	m_aTouchedBy = None;

	bDontDisplayMessage = false;  //NAC: you've walked out of the trigger zone, so make sure that you allow the message to display again no matter what.

	if( (Other.Instigator != None) )
	{
		User = Pawn(Other);

		if (m_fMessageActive)
		{
			User.ReceiveLocalizedMessage(class'gbxContextUseHUDMessage', -1);  // remove the message from the HUD
			m_fMessageActive = false;
		}
	}
}

function Tick( float deltaTime )
{
	//Super.Tick( deltaTime );
}

event bool UsedBy( Pawn User )
{
	if( theCrate != None )
		return theCrate.UsedBy( User );
	else
		return false;
}

defaultproperties
{
	m_eUseType=RestockWeapons
}//=============================================================================
// gbxSVehicle
// karma physics subclass of vehicle, including networking support
//=============================================================================

class gbxSVehicle extends gbxVehicle
	native
	abstract;

cpptext
{
#ifdef WITH_KARMA
	// Actor interface.
	virtual void PostBeginPlay();
	virtual void Destroy();
	virtual void PostNetReceive();
	virtual void PostNetReceiveLocation();
    virtual void PostEditChange();
	virtual void setPhysics(BYTE NewPhysics, AActor *NewFloor, FVector NewFloorV);
	virtual void TickSimulated( FLOAT DeltaSeconds );
	virtual void TickAuthoritative( FLOAT DeltaSeconds );
	virtual UBOOL Tick(FLOAT DeltaTime, enum ELevelTick TickType);
	virtual void physKarma(FLOAT DeltaTime);
	virtual void preContactUpdate();
	virtual void preKarmaStep(FLOAT DeltaTime);
	virtual UBOOL ReachedDestination(FVector Dir, UActorLite* GoalActor);
	virtual void ClaimUnClaimNavPoints(void);

	// SVehicle interface.
	virtual void UpdateVehicle(FLOAT DeltaTime);
	virtual void KTermSVehicleDynamics();
#endif

}

var () editinline export	array<SVehicleWheel>		Wheels; // Wheel data

var	const bool			bVehicleOnGround; // OUTPUT: True if _any_ SVehicleWheel is currently touching the ground (ignores contacts with chassis etc)

//// PHYSICS ////
var () float	VehicleMass;
var () float	FlipTorque, FlipTime;
var float FlipScale, FlipTimeLeft;
var vector FlipAxis;
var float LastCheckUpsideDownTime;

var()	float	FTScale;

var		VehicleKarmaWakeTrigger KarmaWakeTrigger;
var		float	KarmaSleepTime;  // time when this Karma actor should change to PHYS_None


//// PROXIMITY VIEWSHAKE ////
var()				float			ViewShakeRadius; // Distance from vehicle origin that view starts to shake.
var()				rotator			ViewShakeRotMag;
var()				float			ViewShakeRotFreq;
var()				vector			ViewShakeOffsetMag;
var()				float			ViewShakeOffsetFreq;
var					float			ViewShakeLastCheck; // Internal

// BOOLS //
var()	bool                        bEnableProximityViewShake;
var()   bool                        bOnlyViewShakeIfDriven;
var     bool                        bEjectPassengersWhenFlipped;
var		bool						bGermanTanksDontStopAtOneHealth;

//// HEADLIGHTS ////
var		float						ShadowCullDistance;
var		array<gbxHeadlightCorona>	HeadlightCorona;
var()	array<vector>				HeadlightCoronaOffset;
var()	Material					HeadlightCoronaMaterial;
var()	float						HeadlightCoronaMaxSize;
var()	bool						bUseHeadlights;
var()	float						HeadlightScaling;

var		gbxHeadlightProjector		HeadlightProjector;
var()	Material					HeadlightProjectorMaterial; // If null, do not create projector.
var()	vector						HeadlightProjectorOffset;
var()	rotator						HeadlightProjectorRotation;
var()	float						HeadlightProjectorScale;

var()	array<ActorLite> MyClaimedNavPoints;  // NavigationPoints that are currently claimed by this Tank
var()	array<ActorLite> MyBlockedNavPoints;	// NavigationPoints that the tank is currently sitting on top of (blocked for pathfinding)
var		float		fClaimNavPointTime;
var()	float		ClaimNavPointRadius;
var()	float		fForwardConeDot;			// Indicates the width of a forward-looking cone used to claim pathnodes.
var()	float		fForwardConeRadiusSquared;	// The squared-length of the forward-looking cone.


native function ClaimUnClaimNavPoints();

// Useful function for plotting data to real-time graph on screen.
native final function GraphData(string DataName, float DataValue);

// You got some new info from the server (ie. VehicleState has some new info).
event VehicleStateReceived();

// Do script car model stuff here - but DONT create/destroy anything.
native event UpdateVehicle( float DeltaTime );

// Do any general vehicle set-up when it gets spawned.
simulated function PostNetBeginPlay()
{
	local int i;

    Super.PostNetBeginPlay();

	// Make sure params are up to date.
	SVehicleUpdateParams();

	if(Level.NetMode != NM_DedicatedServer && bUseHeadlights && !(Level.bDropDetail || (Level.DetailMode == DM_Low)))
	{
		HeadlightCorona.Length = HeadlightCoronaOffset.Length;

		for(i=0; i<HeadlightCoronaOffset.Length; i++)
		{
			HeadlightCorona[i] = spawn( class'gbxHeadlightCorona', self,, Location + (HeadlightCoronaOffset[i] >> Rotation) );
			HeadlightCorona[i].SetBase(self);
			HeadlightCorona[i].SetRelativeRotation(rot(0,0,0));
			HeadlightCorona[i].Skins[0] = HeadlightCoronaMaterial;
			HeadlightCorona[i].MaxCoronaSize = HeadlightCoronaMaxSize * HeadlightScaling;
		}

		if(HeadlightProjectorMaterial != None && Level.DetailMode == DM_SuperHigh)
		{
			HeadlightProjector = spawn( class'gbxHeadlightProjector', self,, Location + (HeadlightProjectorOffset >> Rotation) );
			HeadlightProjector.SetBase(self);
			HeadlightProjector.SetRelativeRotation( HeadlightProjectorRotation );
			HeadlightProjector.ProjTexture = HeadlightProjectorMaterial;
			HeadlightProjector.SetDrawScale(HeadlightProjectorScale);
			HeadlightProjector.CullDistance	= ShadowCullDistance;
		}
	}

	if (Level.NetMode != NM_Client)
	{
		// spawn the Karma Wake Up Trigger...
		KarmaWakeTrigger = spawn(class'VehicleKarmaWakeTrigger', self,, Location, Rotation);
		if (KarmaWakeTrigger != None)
		{
			KarmaWakeTrigger.MyVehicle = self;
			KarmaWakeTrigger.SetCollisionSize(VehicleCollisionRadius * 1.5, VehicleCollisionHeight);
			KarmaWakeTrigger.SetBase(self);
		}

		KarmaSleepTime = Level.TimeSeconds + 1.0f;  // go to sleep in 1.0 seconds
	}

	fClaimNavPointTime = 0.0f;
	ClaimNavPointRadius = VehicleCollisionRadius * 2.0f;
}

function JumpOffPawn() {}

// Called when a parameter of the overall articulated actor has changed (like PostEditChange)
// The script must then call KUpdateConstraintParams or Actor Karma mutators as appropriate.
simulated event SVehicleUpdateParams()
{
	local int i;

	KSetMass(VehicleMass);

	// This code just for making it easy to position coronas etc.
	if(Level.NetMode != NM_DedicatedServer)
	{
		for(i=0; i<HeadlightCorona.Length; i++)
		{
			HeadlightCorona[i].SetBase(None);
			HeadlightCorona[i].SetLocation( Location + (HeadlightCoronaOffset[i] >> Rotation) );
			HeadlightCorona[i].SetBase(self);
			HeadlightCorona[i].Skins[0] = HeadlightCoronaMaterial;
			HeadlightCorona[i].MaxCoronaSize = HeadlightCoronaMaxSize * HeadlightScaling;
		}

		if(HeadlightProjector != None)
		{
			HeadlightProjector.SetBase(None);
			HeadlightProjector.SetLocation( Location + (HeadlightProjectorOffset >> Rotation) );
			HeadlightProjector.SetBase(self);
			HeadlightProjector.SetRelativeRotation( HeadlightProjectorRotation );
			HeadlightProjector.ProjTexture = HeadlightProjectorMaterial;
			HeadlightProjector.SetDrawScale(HeadlightProjectorScale);
		}
	}
}

// The pawn Driver has tried to take control of this vehicle
function bool TryToDrive(Pawn P)
{
	if (FlipTimeLeft > 0)
		return false;

	if (NeedsFlip())
	{
		Flip(vector(P.Rotation), 1);
		return false;
	}

	return super.TryToDrive(P);
}

function Flip(vector HitNormal, float ForceScale)
{
	if (!bCanFlip)
		return;

	FlipTimeLeft = FlipTime;
	FlipScale = ForceScale;
	FlipAxis = HitNormal;
	FlipAxis.Z = 0;
//jlb	enable('Tick');
}

simulated function KApplyForce(out vector Force, out vector Torque)
{
	local float torqueScale;
	local vector worldUp, torqueAxis;

	Super.KApplyForce(Force, Torque);

	if (FlipTimeLeft <= 0)
		return;

	worldUp = vect(0, 0, 1) >> Rotation;

	torqueAxis = Normal(FlipAxis Cross worldUp);

	// Torque scaled by how far over we are.
	// This will be between 0 and PI - so convert to between 0 and 1.
	torqueScale = Acos(worldUp Dot vect(0, 0, 1))/3.1416;

	Torque = FlipScale * FlipTorque * torqueScale * torqueAxis;
}

simulated function Tick(float deltaTime)
{
	local int index;

	Super.Tick(deltaTime);

	if (FlipTimeLeft > 0)
	{
		KWake();
		FlipTimeLeft -= deltaTime;
//jlb		if (FlipTimeLeft <= 0 && !bDriving)
//jlb			disable('Tick');
	}

	if (fClaimNavPointTime <= Level.TimeSeconds)
	{
		fClaimNavPointTime = Level.TimeSeconds + 0.5f;

		ClaimUnClaimNavPoints();
	}

	if (KarmaWakeTrigger != None)
	{
		for (index = (KarmaWakeTrigger.touchers.Length-1); index >= 0 ; index--)
		{
			if (VSize(KarmaWakeTrigger.touchers[index].Location - Location) < (VehicleCollisionRadius * 3.0))
			{
				if (KarmaSleepTime < 0)  // is the vehicle already asleep?
				{
					SetPhysics(PHYS_Karma);
					KWake();  // wake it up
				}

				// keep extending the karam sleep time while something that touched the trigger is still near me
				KarmaSleepTime = Level.TimeSeconds + 1.0f;  // go to sleep in 1.0 seconds
			}
			else
			{
				KarmaWakeTrigger.touchers.Remove(index, 1);
			}
		}
	}

	if ((VSize(Velocity) > 50.0) || (abs(Throttle) > 0.01f) || (abs(Steering) > 0.01f))
	{
		if (Physics != PHYS_Karma)  // is the vehicle already asleep?
		{
			SetPhysics(PHYS_Karma);
			KWake();  // wake it up
		}

		KarmaSleepTime = Level.TimeSeconds + 1.0f;  // as long as the vehicle is moving, keep it simulating
	}

	if ((KarmaSleepTime > 0.0f) && (KarmaSleepTime < Level.TimeSeconds))
	{
		SetPhysics(PHYS_None);  // put Karma to sleep

		KarmaSleepTime = -1.0;
	}
}

simulated function Destroyed()
{
	local int i;

	// unclaim any claimed NavigationPoints...
	for (i = 0; i < MyClaimedNavPoints.Length; i++)
	{
		if (MyClaimedNavPoints[i].bIsNavigationPoint)
			NavigationPoint(MyClaimedNavPoints[i]).Claimant = None;
		else if (MyClaimedNavPoints[i].bIsNavigationPointLite)
			NavigationPointLite(MyClaimedNavPoints[i]).Claimant = None;
	}

	// unblock any blocked NavigationPoints...
	for (i = 0; i < MyBlockedNavPoints.Length; i++)
	{
		if (MyBlockedNavPoints[i].bIsNavigationPoint)
			NavigationPoint(MyBlockedNavPoints[i]).bVehicleBlocked = false;
		else if (MyBlockedNavPoints[i].bIsNavigationPointLite)
			NavigationPointLite(MyBlockedNavPoints[i]).bVehicleBlocked = false;
	}

	if (KarmaWakeTrigger != None)
		KarmaWakeTrigger.Destroy();

    // Destroy the effects
	if(Level.NetMode != NM_DedicatedServer)
	{
		for(i=0;i<HeadlightCorona.Length;i++)
			HeadlightCorona[i].Destroy();
		HeadlightCorona.Length = 0;

		if(HeadlightProjector != None)
			HeadlightProjector.Destroy();
	}

	TriggerEvent(Event, self, None);

	super.Destroyed();
}

function bool HasBeenFiredAtByAT( gbxPawn Attacker, gbxWeapon AttackingWeapon )
{
	return bHasBeenFiredAtByAT;
}

function SetFiredAtByAT( gbxPawn Attacker, gbxWeapon AttackingWeapon )
{
	bHasBeenFiredAtByAT = true;
}

function GrenadeHasBeenPlanted(Pawn GrenadePlanter)
{
	// tell the controller that the grenade has been planted...
	if (gbxAIController(Controller) != None)
	{
		gbxAIController(Controller).GrenadeHasBeenPlanted(GrenadePlanter);
	}
}

function vector	GetCollisionExtent()
{
	local vector Extent;

	Extent = VehicleCollisionRadius * vect(1,1,0);
	Extent.Z = VehicleCollisionHeight;
	return Extent;
}

event PawnUnClaimNavPoint( gbxPawn OtherPawn )  // needed by native code
{
	OtherPawn.UnClaimNavPoint();  // unclaim this Pawn's claimed NavPoint
}

event ControllerCoverPointStolen( gbxAIController OtherController, ActorLite Nav )  // needed by native code
{
	OtherController.CoverPointStolen( Nav );
}

simulated function Died(Controller Killer, class<DamageType> damageType, vector HitLocation)
{
	local int i;
	local Pawn NavPointClaimant;
	local float distance;

	// unclaim any claimed navigation points that are outside the VehilceCollisionRadius of the tank...
	// (the tank still claims the navigation points that sit directly underneath it)
	for (i = MyClaimedNavPoints.Length-1; i >= 0; i--)
	{
		NavPointClaimant = None;
		if (MyClaimedNavPoints[i].bIsNavigationPoint)
			NavPointClaimant = NavigationPoint(MyClaimedNavPoints[i]).Claimant;
		else if (MyClaimedNavPoints[i].bIsNavigationPointLite)
			NavPointClaimant = NavigationPointLite(MyClaimedNavPoints[i]).Claimant;

		if (NavPointClaimant == self)
		{
			if (MyClaimedNavPoints[i].bIsNavigationPoint)
				distance = VSize(NavigationPoint(MyClaimedNavPoints[i]).Location - Location);
			else if (MyClaimedNavPoints[i].bIsNavigationPointLite)
				distance = VSize(NavigationPointLite(MyClaimedNavPoints[i]).Location - Location);

			if (distance > (VehicleCollisionRadius * 1.2f))  // add a 20% fudge factor to VehicleCollisionRadius
			{
				if (MyClaimedNavPoints[i].bIsNavigationPoint)
					NavigationPoint(MyClaimedNavPoints[i]).Claimant = None;
				else if (MyClaimedNavPoints[i].bIsNavigationPointLite)
					NavigationPointLite(MyClaimedNavPoints[i]).Claimant = None;

				MyClaimedNavPoints.Remove(i, 1);
			}
		}
	}

	super.Died(Killer, damageType, HitLocation);
}

// Includes properties from KActor
defaultproperties
{
	VehicleMass=1.0
    Physics=PHYS_Karma
	bEdShouldSnap=True
	bStatic=False
	bShadowCast=False
	bCollideActors=True
	bCollideWorld=False
    bProjTarget=True
	bBlockActors=True
	bBlockNonZeroExtentTraces=True
	bBlockZeroExtentTraces=True
	bWorldGeometry=False
	bBlockKarma=True
	bAcceptsProjectors=True
	bCanBeBaseForPawns=True
	bAlwaysRelevant=false
	RemoteRole=ROLE_SimulatedProxy
	bNetInitialRotation=True
	bSpecialCalcView=True
//jlb	bDramaticLighting=True
	FTScale=0.03
	FlipTorque=300
	FlipTime=2

	// this needs to be true to collide with AI Pawns
	bCollideSkeletalMesh=true

	ShadowCullDistance=1500.0

	fForwardConeDot=0.95
	fForwardConeRadiusSquared=1000000.0
}
//=============================================================================
// SVehicle spawner location.
//=============================================================================

class gbxSVehicleFactory extends Actor
	native
	placeable;

var()	class<gbxVehicle>		VehicleClass;

var()	bool	bDontWaitForTrigger;
var()	int		MaxVehicleCount;
var		int		VehicleCount;

cpptext
{
	INT AddMyMarker(AActor *S);
}

function PreBeginPlay()
{
	local gbxVehicle CreatedVehicle;

/*jlb
	if (!Level.Game.bAllowVehicles && !bNoDelete)
	{
		Destroy();
		return;
	}
jlb*/

	Super.PreBeginPlay();

	if (bDontWaitForTrigger)
	{
		if ( VehicleClass != None )
		{
			CreatedVehicle = spawn(VehicleClass, , , Location, Rotation);
			if ( CreatedVehicle != None )
			{
				CreatedVehicle.bNonHumanControl = false;

				VehicleCount++;
				CreatedVehicle.ParentFactory = self;
			}
		}
	}
}

event VehicleDestroyed( gbxVehicle V )
{
	VehicleCount--;
}

event VehiclePossessed( gbxVehicle V );
event VehicleUnPossessed( gbxVehicle V );


event Trigger( Actor Other, Pawn EventInstigator )
{
	local gbxVehicle CreatedVehicle;

//jlb	if (!Level.Game.bAllowVehicles)
//jlb		return;

	if ( VehicleClass == None )
	{
		Log("SVehicleFactory:"@self@"has no VehicleClass");
		return;
	}

	if ( !EventInstigator.IsA('gbxPawn') )
		return;

	if ( VehicleCount >= MaxVehicleCount )
	{
		// Send a message saying 'too many vehicles already'
		return;
	}

	if ( VehicleClass != None )
	{
		CreatedVehicle = spawn(VehicleClass, , , Location, Rotation);
		if ( CreatedVehicle != None )
		{
			CreatedVehicle.bNonHumanControl = false;

			VehicleCount++;
			CreatedVehicle.ParentFactory = self;
		}
	}
}


defaultproperties
{
	MaxVehicleCount=1
	bHidden=true
	Texture=Texture'Engine.S_KVehFact'
	RemoteRole=ROLE_None
	bNoDelete=True
	bDirectional=true
}
class gbxTalkToSoldierMessage extends gbxContextUseHUDMessage;


var localized string	TalkToPawnMessage1;
var localized string	TalkToPawnMessage2;

static function string GetString(
	optional int Switch,
	optional PlayerReplicationInfo RelatedPRI_1,
	optional PlayerReplicationInfo RelatedPRI_2,
	optional Object OptionalObject ) {

	return Default.TalkToPawnMessage1$" "$class'CharacterSetupUSA'.Static.GetCharacterName( Switch )$Default.TalkToPawnMessage2;
}


defaultproperties
{
	bFadeMessage=True
	bIsSpecial=True
	bIsUnique=True
	Lifetime=-1
	bBeep=True
	FontSize=1
    DrawColor=(R=128,G=128,B=255,A=255)

	bIsConsoleMessage=false
	
	TalkToPawnMessage1="%action_use% %icon_use% to talk to"
	TalkToPawnMessage2="."

    YPos=240
}
class gbxTargetPawn extends gbxPawn;

simulated function PostNetBeginPlay()
{
	SetCollision(false,false,false);
	SetPhysics(PHYS_None);
}

function TakeDamage( int Damage, Pawn instigatedBy, Vector hitlocation,	Vector momentum, class<DamageType> damageType, optional name HitBoxName)
{
}
	
function SetMovementPhysics()
{
	SetPhysics(PHYS_None);
}

defaultproperties
{
	// don't change the default Physics property otherwise guys fall through terrain!!!
	Physics=PHYS_None

	DrawType=DT_None
	bCanCrouch=false
}
//=============================================================================
// gbxTeamTrigger.
//=============================================================================

class gbxTeamTrigger extends gbxTrigger
	placeable;

var() ETeamIdentifier m_TriggerTeam;

function bool IsRelevant(actor Other)
{
	local Pawn p;
	p = Pawn(other);

	if (Super.IsRelevant(Other) && p != None)
	{
		Log(self $ " gbxTeamTrigger::Trigger() touched by " $ p $ " on team " $ p.PawnTeam );

		if ( p.PawnTeam == m_TriggerTeam )
			return TRUE;
	}
	else
	{
		return FALSE;
	}
}class gbxTreadCraft extends gbxSVehicle
	abstract
	native
	nativereplication;

cpptext
{
	INT* GetOptimizedRepList(BYTE* Recent, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel);

#ifdef WITH_KARMA
	// Actor interface.
	virtual UBOOL Tick(FLOAT DeltaTime, enum ELevelTick TickType);
	virtual void PostNetReceive();

	// SVehicle interface.
	virtual void UpdateVehicle(FLOAT DeltaTime);

	// SHover interface.
	virtual void PackState();
#endif
}

var		array<vector>		ThrusterOffsets;
var		array<int>			ThrusterContacts;  // how many contacts each thruster has (should be 0 or 1)

var()	float				HoverSoftness;
var()	float				HoverPenScale;
var()	float				HoverCheckDist;

var()	float				UprightStiffness;
var()	float				UprightDamping;

var()	float				MaxThrust;
var()	float				MaxSteerTorque;
var()	float				ForwardDampFactor;
var()   float               TurnDampFactor;
var()	float				LateralDampFactor;
var()   float               ParkingDampFactor;
var()	float				SteerDampFactor;
var()	float				PitchTorqueFactor;
var()	float				PitchDampFactor;
var()	float				BankTorqueFactor;
var()	float				BankDampFactor;
var()	float				DecelerateDampFactor;
var()	float				SteerDecayDampFactor;

var()	float				InvertSteeringThrottleThreshold;
var()	float				SteerSpeed; // degrees per second
var		float				ActualSteering;
var		float				MaxSteerAngle;

var		float				NumPoweredWheels;

// MPH meter
var		material			MPHMeterMaterial;
var()	float				MPHMeterPosX;
var()	float				MPHMeterPosY;
var()	float				MPHMeterScale;
var()	float				MPHMeterSizeY;

// Internal
var		float				CraftMPH;

var		float				OutputThrust;
var		float				OutputTurn;

// Replicated
struct native TreadCraftState
{
	var vector				ChassisPosition;
	var Quat				ChassisQuaternion;
	var vector				ChassisLinVel;
	var vector				ChassisAngVel;

	var byte				ServerThrust;
	var	byte				ServerTurn;
	var int                 ServerViewPitch;
	var int                 ServerViewYaw;
};

var		TreadCraftState		TreadState, OldTreadState;
var		KRigidBodyState		ChassisState;
var		bool				bNewTreadState;

replication
{
	reliable if (bNetDirty && Role == ROLE_Authority)
		TreadState;
}

simulated event bool KUpdateState(out KRigidBodyState newState)
{
	// This should never get called on the server - but just in case!
	if(Role == ROLE_Authority || !bNewTreadState)
		return false;

	newState = ChassisState;
	bNewTreadState = false;

	return true;
}

simulated function PostNetBeginPlay()
{
	local vector RotX, RotY, RotZ;
	local KarmaParams kp;
	local KRepulsor rep;
	local int i;

	// Count the number of powered wheels on the car
	NumPoweredWheels = 0.0;
	for(i=0; i<Wheels.Length; i++)
	{
		NumPoweredWheels += 1.0;
	}

	// Spawn and assign 'repulsors' to hold craft off the ground
	kp = KarmaParams(KParams);
	kp.Repulsors.Length = ThrusterOffsets.Length;
	ThrusterContacts.Length = ThrusterOffsets.Length;

    GetAxes(Rotation,RotX,RotY,RotZ);

	for(i=0;i<ThrusterOffsets.Length;i++)
	{
    	rep = spawn(class'KRepulsor', self,, Location + ThrusterOffsets[i].X * RotX + ThrusterOffsets[i].Y * RotY + ThrusterOffsets[i].Z * RotZ);
    	rep.SetBase(self);
    	rep.bHidden = true;
    	kp.Repulsors[i] = rep;
		ThrusterContacts[i] = 0;  // no contacts yet
    }

    Super.PostNetBeginPlay();
}

simulated event Destroyed()
{
	local KarmaParams kp;
	local int i;

	// Destroy repulsors
	kp = KarmaParams(KParams);
	for(i=0;i<kp.Repulsors.Length;i++)
    	kp.Repulsors[i].Destroy();

	Super.Destroyed();
}

simulated event SVehicleUpdateParams()
{
	local KarmaParams kp;
	local int i;

	Super.SVehicleUpdateParams();

	kp = KarmaParams(KParams);

    for(i=0;i<kp.Repulsors.Length;i++)
	{
        kp.Repulsors[i].Softness = HoverSoftness;
        kp.Repulsors[i].PenScale = HoverPenScale;
        kp.Repulsors[i].CheckDist = HoverCheckDist;
    }

	KSetStayUprightParams( UprightStiffness, UprightDamping );
}

//function DrawHUD(Canvas Canvas)
//{
//	local Color WhiteColor;
//	local float XL, YL;
//
//	Super.DrawHUD(Canvas);
//
//	WhiteColor = class'Canvas'.Static.MakeColor(255,255,255);
//	Canvas.DrawColor = WhiteColor;
//
//	Canvas.Style = ERenderStyle.STY_Normal;
//	Canvas.StrLen("TEST", XL, YL);
//
//	// Draw rev meter
//	Canvas.SetPos(MPHMeterPosX * Canvas.ClipX, MPHMeterPosY * Canvas.ClipY);
//	Canvas.DrawTileStretched(MPHMeterMaterial, (BikeMPH/MPHMeterScale) * Canvas.ClipX, MPHMeterSizeY * Canvas.ClipY);
//
//	Canvas.SetPos( MPHMeterPosX * Canvas.ClipX, (MPHMeterSizeY + MPHMeterPosY) * Canvas.ClipY + YL );
//    Canvas.Font = class'HUD'.Static.GetConsoleFont(Canvas);
//	Canvas.DrawText(BikeMPH);
//}

defaultproperties
{
	bSpecialHUD=true

//	MPHMeterMaterial=Material'InterfaceContent.BorderBoxD'
	MPHMeterPosX=0.01
	MPHMeterPosY=0.9
	MPHMeterScale=70.0
	MPHMeterSizeY=0.05
}
//=============================================================================
// Basically just the Unreal trigger, with an extra field for the mask test.
//=============================================================================
class gbxTrigger extends Trigger;



var int		m_nCurMask;
var()	int	m_nSetMask;
var()	export	editinline	array<MaskTestInfo>		m_TestMasks;

function CheckMask( Pawn EventInstigator)
{
	local int		i;

	for( i = 0; i < m_TestMasks.Length; i++ )
		if (m_TestMasks[ i ].m_nTestMask == m_nCurMask)
			TriggerEvent( m_TestMasks[ i ].m_szMaskEvent, self, EventInstigator );
}

function Trigger(actor Other, pawn EventInstigator)
{
	super.Trigger(Other,EventInstigator);

	if ((gbxTrigger(Other) != None) && (gbxTrigger(Other).m_nSetMask >= 0))
		m_nCurMask = m_nCurMask | (1 << gbxTrigger(Other).m_nSetMask);
	CheckMask( EventInstigator );
}

// bTraceListeners must be true for this to be triggered
event TraceTouch( Actor	Other, vector TouchLocation, vector	TouchNormal, vector	End, vector	Start, vector Extent, int TraceFlags )
{
	if ( bInitiallyActive && (TriggerType == TT_Shoot) && (Other != None) && (Other.Instigator != None) && (Other.IsA('WeaponFire') ) )
	{
		if ( ReTriggerDelay > 0 )
		{
			if ( Level.TimeSeconds - TriggerTime < ReTriggerDelay )
				return;
			TriggerTime = Level.TimeSeconds;
		}
		// Broadcast the Trigger message to all matching actors.
		TriggerEvent(Event, self, Other.Instigator);

		if( Message != "" )
			// Send a string message to the toucher.
			Other.Instigator.ClientMessage( Message );
	}
}

defaultproperties
{
	m_nSetMask=0
}
//=============================================================================
// gbxUsableItem - activatable inventory.
//=============================================================================
class gbxUsableItem extends Powerups
	abstract;



var () byte		m_bItemBucket;
var class<gbxDummyGrenade>	DummyGrenadeType;
var gbxDummyGrenade DummyGrenade;

replication
{
    // Functions called by server on client
    reliable if( Role==ROLE_Authority )
        ClientWeaponSet;
}

// Compare self to current weapon.  If better than current weapon, then switch
simulated function ClientWeaponSet(bool bOptionalSet)
{
	local gbxPawn	aPlayer;

    Instigator = Pawn(Owner);
    if( Instigator == None )
    {
        GotoState('PendingClientWeaponSet');
        return;
    }

	if (gbxPawn( Instigator ) != None)
	{
		aPlayer = gbxPawn( Instigator );

		if ( aPlayer.SecondaryWeapon == None )
		{
			aPlayer.PendingSecondaryWeapon = self;
			aPlayer.ChangedSecondaryWeapon();
		}
	}

	Instigator = Pawn(Owner); //weapon's instigator isn't replicated to client
	GotoState('');
}

simulated function name GetUseAnimation()
{
	return '';
}

// Called in ModeDoFire(), before Use() is called in FireSecondary.
function Prepare()
{
}

state PendingClientWeaponSet
{
    simulated function Timer()
    {
        if ( Pawn(Owner) != None )
            ClientWeaponSet(true);
    }

    simulated function BeginState()
    {
        SetTimer(0.05, true);
    }

    simulated function EndState()
    {
        SetTimer(0.0, false);
    }
}

defaultproperties
{
}
class gbxUseKeyHUDMessage extends gbxContextUseHUDMessage;


var localized string	ReloadWeaponMsg;

static function string GetString(
	optional int Switch,
	optional PlayerReplicationInfo RelatedPRI_1,
	optional PlayerReplicationInfo RelatedPRI_2,
	optional Object OptionalObject ) {

	local EContextUseType UseSwitch;
	UseSwitch = EContextUseType( Switch );

	switch( UseSwitch )
	{
		case ReloadWeaponButton:
			return Default.ReloadWeaponMsg;
			break;
	}
}

defaultproperties
{
	bFadeMessage=True
	bIsSpecial=True
	bIsUnique=True
	Lifetime=2
	bBeep=True
	FontSize=1
    DrawColor=(R=128,G=128,B=255,A=255)

	ReloadWeaponMsg=" to reload your weapon."

    YPos=240
}
//=============================================================================
// gbxVehicle
// this abstract base class contains gameplay and AI code for GBX vehicles
//=============================================================================

class gbxVehicle extends gbxPawn
    native
    nativereplication
    abstract;

var globalconfig bool bVehicleShadows;	// Global config option for vehicle shadows

var		bool    bDriving;               // Vehicle is being driven
var		bool    bOldDriving;
var ()	bool	bDrawDriverInTP;		// Whether to draw the driver when in 3rd person mode.
var ()	bool	bDriverCollideActors;	// if driver is drawn in vehicle, is Driver.bCollideActors true ?
var ()	bool	bRelativeExitPos;		// relative vector to vehicle?

var		bool	bDefensive;				// should be used by defenders
var		bool	bAutoTurret;			// controlled by AI if no player controlling (FIXME Move to subclass)
var		bool	bRemoteControlled;		// destroying vehicle won't kill player
var	()	bool	bEjectDriver;			// If vehicle is destroyed, don't kill and eject driver(s)
var		bool	bTurnInPlace;			// whether vehicle can turn in place
var		bool	bFollowLookDir;			// used by AI to know that controller's rotation determines vehicle rotation
var	()	bool	bNonHumanControl;		// Cannot be controlled by humans
var		bool	bStalled;				// Vehicle is stalled (can't apply acceleration)
var     bool    bVehicleDestroyed;      // Vehicle has been destroyed (no more need to simulate special vehicle physics)
var     bool    bShowDamageOverlay;     // Vehicle should display the normal pawn damage overlay when hit by a weapon
var     bool    bDropDetail;            // Vehicle should reduce its detail level
var		bool	bNoFriendlyFire;		// FriendlyFire disabled for this vehicle

// Cameras
var () bool	bDrawMeshInFP;		// Whether to draw the vehicle mesh when in 1st person mode.
var () bool	bZeroPCRotOnEntry;	// If true, set camera rotation to zero on entering vehicle. If false, set it to the vehicle rotation.
var	bool	bPCRelativeFPRotation;		// In 1st person, PlayerController rotation is relative to vehicle rotation
var		bool	bHasBeenFiredAtByAT;
var		int		StopMovingHealth;	// AI controlled tanks stop moving when health is at or below this value

var     bool    bWeaponisFiring;
var     bool    bWeaponisAltFiring;

var		bool	bTeamLocked;		// Team defines which players are allowed to enter the vehicle
var		bool	bEnterringUnlocks;	// Vehicle is unlocked when a player enterred it..
var	bool bCanFlip;
var	bool bAllowViewChange;
var	bool bAllowWeaponToss; //if the driver dies, will he toss his weapon?

var bool bHasHandbrake;					// hint for AI
var bool bScriptedRise;					// hint for AI

var	bool	bAdjustDriversHead;	// rotate driver's head depending on view rotation
var config bool bDesiredBehindView;

var	bool bHideRemoteDriver; // If Set to true, the remote controlling driver will be hidden
var bool bShowChargingBar;
var bool bDriverHoldsFlag;
var bool bCanCarryFlag;

var bool bSpawnProtected;	// Cannot be destroyed by a player before its been possessed.

var() bool bFPNoZFromCameraPitch; // Ignore any vehicle-space Z due to FPCamViewOffset (so looking up and down doesn't change camera Z rel to vehicle)

var		byte	StuckCount;				// used by AI
var()	byte	Team;
var     byte    OldTeam, PrevTeam;  // OldTeam is used for replication purposes, PrevTeam is the team of the previous driver.

var				Rotator	PlayerEnterredRotation;	// Original rotation when player enterred vehicle
var		float	EjectMomentum;

var class<Controller> AutoTurretControllerClass;

// generic controls (set by controller, used by concrete derived classes)
var () float		Steering;		// between -1 and 1
var () float		Throttle;		// between -1 and 1
var () float		Rise;			// between -1 and 1

var           int       DriverViewPitch;      // The driver's view pitch
var           int       DriverViewYaw;        // The driver's view yaw

var float		ThrottleTime;	// last time at which throttle was 0 (used by AI)
var float		StuckTime;
var float		VehicleMovingTime; // used by AI C++

var () vector	DrivePos;		// Position (rel to vehicle) to put player while driving.
var () rotator	DriveRot;		// Rotation (rel to vehicle) to put driver while driving.
var () name		DriveAnim;		// Animation to play while driving.

//Info for EntryPositions
var () array<vector>	ExitPositions;		// Positions (rel to vehicle) to try putting the player when exiting.
var () vector	                EntryPosition;		// Offset for the entry trigger
var () float                     EntryRadius;        // Radius for the entry trigger

var () vector   FPCamPos;		// Position of camera when driving first person.
var () vector   FPCamViewOffset; // Offset in reference frame of camera.

//clientside settings
var config float TPCamDistance;
// force feedback
var string CenterSpringForce;
var int CenterSpringRangePitch;
var int CenterSpringRangeRoll;

var () vector   TPCamLookat; // Look at location in vehicle space
var () vector   TPCamWorldOffset; // Applied in world space after vehicle transform.
var float DesiredTPCamDistance, LastCameraCalcTime, CameraSpeed; //for smoothly interpolating TPCamDistance to new value
var () Range    TPCamDistRange;

var () int	MaxViewYaw;			// Maximum amount you can look left and right
var () int	MaxViewPitch;		// Maximum amount you can look up and down

var		Pawn			Driver;		// Can be None if Controller spawns right away with vehicle
var		gbxSVehicleFactory	ParentFactory;

var		float	VehicleCollisionHeight;  // vehicle collision height changed to 2.0, use this instead for the actual height
var		float	VehicleCollisionRadius;  // vehicle collision radius changed to 2.0, use this instead for the actual radius

// FX
var String			TransEffects[2];		// Spawning effects
//jlbvar	float			ShadowMaxTraceDist;
//jlbvar float			ShadowCullDistance;

var float MomentumMult;	//damage momentum multiplied by this value before being applied to vehicle
var float DriverDamageMult; //damage to the driver is multiplied by this value

// Missle warning
var String	LockOnClassString;
var float	LastLockWarningTime;

var Vehicle NextVehicle;
var localized string VehiclePositionString;
var localized string VehicleNameString;
var localized string VehicleDescription;

var Texture TeamBeaconTexture, NoEntryTexture;
var Material TeamBeaconBorderMaterial;

var AIMarker myMarker;  // used for stationary turrets

//VEHICULAR MANSLAUGHTER
var float MinRunOverSpeed; //speed must be greater than this for running into someone to do damage
var class<DamageType> RanOverDamageType, CrushedDamageType;
var sound RanOverSound;
var name StolenAnnouncement;
var sound StolenSound;

var	float LinkHealMult;	// If > 0, Link Gun secondary heals an amount equal to its damage times this

var float OldSteering;
var float VehicleLostTime, TeamUseTime, PlayerStartTime;
var float MaxDesireability;
var const float AIMoveCheckTime;
var float ObjectiveGetOutDist; //if AI controlled and bot needs to trigger an objective not triggerable by vehicles, it will try to get out this far away

var name FlagBone;
var vector FlagOffset;
var rotator FlagRotation;

var	float	WheelsScale;

// HORN
var array<sound>	HornSounds;
var float			LastHornTime;

//// SOUNDS ////
var()               sound           IdleSound;
var()               sound           StartUpSound;
var()               sound           ShutDownSound;

// BULLET HITS
var() array<sound>    BulletSounds;

// HUD OVERLAY
var class<Actor>            HUDOverlayClass;
var Actor                   HUDOverlay;
var() vector                HUDOverlayOffset;
var() float                 HUDOverlayFOV;

// SPAWN OVERLAY MATERIAL
var()   Material            SpawnOverlay[2];

// Shadow projector
var (SVehicle) bool bDrawVehicleShadow;
var ShadowProjector VehicleShadow;
var BitmapMaterial  VehicleShadowTexture;
var Float           VehicleShadowDrawScale;


struct native gbxSVehicleIcon
{
	var Material	Material;
	var float		X, Y, SizeX, SizeY;
	var bool		bIsGreyScale;
};

var gbxSVehicleIcon VehicleIcon;

cpptext
{
	virtual void PreNetReceive();
	virtual void PostNetReceive();
	void performPhysics(FLOAT DeltaSeconds);
	virtual UBOOL moveToward(const FVector &Dest, UActorLite *GoalActor);
	virtual void rotateToward(AActor *Focus, FVector FocalPoint);
	virtual UBOOL IsStuck();
	INT* GetOptimizedRepList(BYTE* Recent, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel);
	INT AddMyMarker(AActor *S);
	void SteerVehicle(FVector Direction);
	UBOOL IsNetRelevantFor( APlayerController* RealViewer, AActor* Viewer, FVector SrcLocation );
	virtual FVector GetDestination(AController *C);
	virtual int Reachable(FVector aPoint, UActorLite* GoalActor);
	virtual void setMoveTimer(FVector MoveDir);
	virtual int calcMoveFlags();
}

replication
{
	reliable if ( Role==ROLE_Authority )
		ClientKDriverEnter, ClientKDriverLeave, FixPCRotation, ClientClearController;

	unreliable if( bNetDirty && Role==ROLE_Authority )
        bDriving, bTeamLocked, Driver, Team, bVehicleDestroyed, WheelsScale;

	reliable if ( Role < ROLE_Authority )
		VehicleFire, VehicleCeaseFire;
}

function PreBeginPlay()
{
/*jlb
	if ( !Level.Game.bAllowVehicles && !bDeleteMe )
	{
		Destroy();
		return;
	}
jlb*/

	Super.PreBeginPlay();
}

/*jlb
function PlayerChangedTeam()
{
	if ( Driver != None )
		Driver.KilledBy(Driver);
	else
		Super.PlayerChangedTeam();
}
jlb*/

simulated function SetBaseEyeheight()
{
	BaseEyeheight = Default.BaseEyeheight;
	Eyeheight = BaseEyeheight;
}

simulated function string GetVehiclePositionString()
{
	return VehiclePositionString;
}

function Suicide()
{
	if ( Driver != None )
		Driver.KilledBy(Driver);
	else
		KilledBy(self);
}

function bool CheatWalk()
{
	return false;
}

function bool CheatGhost()
{
	return false;
}

function bool CheatFly()
{
	return false;
}

simulated function PostBeginPlay()
{
	local controller NewController;

	super.PostBeginPlay();

	if ( bDeleteMe )
		return;

	// Glue a shadow projector on
	if ( bVehicleShadows && bDrawVehicleShadow && (Level.NetMode != NM_DedicatedServer) )
    {
        VehicleShadow = Spawn(class'VehicleShadowProjector', self, '', Location);
        VehicleShadow.ShadowActor = self;
        VehicleShadow.LightDirection = Normal(vect(1,1,6));
        VehicleShadow.LightDistance = 1200;
        VehicleShadow.MaxTraceDistance = 350;
        VehicleShadow.InitShadow(VehicleShadowTexture, true);
        VehicleShadow.SetDrawScale(VehicleShadowDrawScale);
        VehicleShadow.FOV = 1;
    }

	if ( Role == Role_Authority )
	{
		if ( bAutoTurret && (Controller == None) && (AutoTurretControllerClass != None) )
		{
			NewController = spawn(AutoTurretControllerClass);
			if ( NewController != None )
				NewController.Possess(self);
		}
//jlb		if ( !bAutoTurret && !bNonHumanControl && IndependentVehicle() )
//jlb			Level.Game.RegisterVehicle(self);
	}

    OldTeam = Team;
    PrevTeam = Team;
}

simulated event SetInitialState()
{
    Super.SetInitialState();

//jlb    Disable('Tick');
}

/*jlb
//return a value indicating how useful this vehicle is to bots
function float BotDesireability(Actor S, int TeamIndex, Actor Objective)
{
	local bool bSameTeam;
	local PlayerController P;

	bSameTeam = ( GetTeamNum() == TeamIndex );
	if ( bSameTeam )
	{
		if ( Level.TimeSeconds < TeamUseTime )
			return 0;
		if ( !bKeyVehicle && (Level.TimeSeconds < PlayerStartTime) )
		{
			P = Level.GetLocalPlayerController();
			if ( (P == None) || ((P.Pawn != None) && (Vehicle(P.Pawn) == None)) )
				return 0;
		}
	}
	if ( !bKeyVehicle && !bStationary && (Level.TimeSeconds < VehicleLostTime) )
		return 0;
	else if (Health <= 0 || Occupied() || (bTeamLocked && !bSameTeam))
		return 0;

	if (bKeyVehicle)
		return 100;

	return ((MaxDesireability * 0.5) + (MaxDesireability * 0.5 * (float(Health) / HealthMax)));
}
jlb*/

simulated function Destroyed()
{
//jlb	local Vehicle	V, Prev;

	if ( ParentFactory != None )
		ParentFactory.VehicleDestroyed( Self );		// Notify parent factory of death

	// Destroy shadow projector
    if (VehicleShadow != None)
		VehicleShadow.Destroy();

	if ( bAutoTurret && (Controller != None) && ClassIsChildOf(Controller.Class, AutoTurretControllerClass) && !Controller.bDeleteMe )
	{
		Controller.Destroy();
		Controller = None;
	}

	if (( Driver != None ) && (Driver != self))
		Destroyed_HandleDriver();

/*jlb
	if ( Level.Game != None )
	{
		if ( Level.Game.VehicleList == Self )
			Level.Game.VehicleList = NextVehicle;
		else
		{
			Prev = Level.Game.VehicleList;
			if ( Prev != None )
				for ( V=Level.Game.VehicleList.NextVehicle; V!=None; V=V.NextVehicle )
				{
					if ( V == self )
					{
						Prev.NextVehicle = NextVehicle;
						break;
					}
					else
						Prev = V;
				}
		}
	}
jlb*/

	super.Destroyed();
}

simulated function Destroyed_HandleDriver()
{
	local Pawn		OldDriver;

	Driver.LastRenderTime = LastRenderTime;
	if ( Role == ROLE_Authority )
	{
		// if Driver wasn't visible in vehicle, destroy it
		if ( Driver != None && !bRemoteControlled && !bEjectDriver && !bDrawDriverInTP && Driver.Health > 0 )
		{
			OldDriver = Driver;
			Driver = None;
			if (gbxPawn(OldDriver) != None)
				gbxPawn(OldDriver).gbxDrivenVehicle = None;
			if ( !OldDriver.bDeleteMe )
				OldDriver.Destroy();
		}
		else if ( !bRemoteControlled && !bEjectDriver )
        {
			// otherwise spawn dead karma body
	        if (!bDrawDriverInTP && PlaceExitingDriver())
	        {
				if (gbxPawn(Driver) != None)
				{
		            gbxPawn(Driver).gbxStopDriving(self);
		            gbxPawn(Driver).gbxDrivenVehicle = self;
				}
	        }
			Driver.TearOffMomentum = Velocity * 0.25;
//			Driver.Died(Controller, class'DamRanOver', Driver.Location);
			Driver.Died(Controller, class'Crushed', Driver.Location);
        }
	}
	else if ( (gbxPawn(Driver) != None) && (gbxPawn(Driver).gbxDrivenVehicle == self) )
	{
		gbxPawn(Driver).gbxStopDriving(self);
	}
}

simulated function vector GetCameraLocationStart()
{
	return Location;
}

simulated function SpecialCalcBehindView(PlayerController PC, out actor ViewActor, out vector CameraLocation, out rotator CameraRotation )
{
	local vector CamLookAt, HitLocation, HitNormal, OffsetVector;
	local Actor HitActor;
    local vector x, y, z;

	if (DesiredTPCamDistance < TPCamDistance)
		TPCamDistance = FMax(DesiredTPCamDistance, TPCamDistance - CameraSpeed * (Level.TimeSeconds - LastCameraCalcTime));
	else if (DesiredTPCamDistance > TPCamDistance)
		TPCamDistance = FMin(DesiredTPCamDistance, TPCamDistance + CameraSpeed * (Level.TimeSeconds - LastCameraCalcTime));

    GetAxes(PC.Rotation, x, y, z);
	ViewActor = self;
	CamLookAt = GetCameraLocationStart() + (TPCamLookat >> Rotation) + TPCamWorldOffset;

	OffsetVector = vect(0, 0, 0);
	OffsetVector.X = -1.0 * TPCamDistance;

	CameraLocation = CamLookAt + (OffsetVector >> PC.Rotation);

	HitActor = Trace(HitLocation, HitNormal, CameraLocation, CamLookAt, true, vect(40, 40, 40));
	if ( HitActor != None
	     && (HitActor.bWorldGeometry || HitActor == GetVehicleBase() || Trace(HitLocation, HitNormal, CameraLocation, CamLookAt, false, vect(40, 40, 40)) != None) )
			CameraLocation = HitLocation;

//jlb    CameraRotation = Normalize(PC.Rotation + PC.ShakeRot);
    CameraRotation = Normalize(PC.Rotation);
//jlb    CameraLocation = CameraLocation + PC.ShakeOffset.X * x + PC.ShakeOffset.Y * y + PC.ShakeOffset.Z * z;
    CameraLocation = CameraLocation;
}

simulated function SpecialCalcFirstPersonView(PlayerController PC, out actor ViewActor, out vector CameraLocation, out rotator CameraRotation )
{
	local quat CarQuat, LookQuat, ResultQuat;
	local vector VehicleZ, CamViewOffsetWorld, x, y, z;
	local float CamViewOffsetZAmount;

	GetAxes(PC.Rotation, x, y, z);
	ViewActor = self;

	if (bPCRelativeFPRotation)
	{
		CarQuat = QuatFromRotator(Rotation);
		CameraRotation = Normalize(PC.Rotation);
		LookQuat = QuatFromRotator(CameraRotation);
		ResultQuat = QuatProduct(LookQuat, CarQuat);
		CameraRotation = QuatToRotator(ResultQuat);
	}
	else
		CameraRotation = PC.Rotation;

	// Camera position is locked to car
	CamViewOffsetWorld = FPCamViewOffset >> CameraRotation;
	CameraLocation = GetCameraLocationStart() + (FPCamPos >> Rotation) + CamViewOffsetWorld;

	if(bFPNoZFromCameraPitch)
	{
		VehicleZ = vect(0,0,1) >> Rotation;
		CamViewOffsetZAmount = CamViewOffsetWorld Dot VehicleZ;
		CameraLocation -= CamViewOffsetZAmount * VehicleZ;
	}

//jlb	CameraRotation = Normalize(CameraRotation + PC.ShakeRot);
	CameraRotation = Normalize(CameraRotation);
//jlb	CameraLocation = CameraLocation + PC.ShakeOffset.X * x + PC.ShakeOffset.Y * y + PC.ShakeOffset.Z * z;
	CameraLocation = CameraLocation;
}

// Special calc-view for vehicles
simulated function bool SpecialCalcView(out actor ViewActor, out vector CameraLocation, out rotator CameraRotation )
{
	local PlayerController pc;

	pc = PlayerController(Controller);

	// Only do this mode we have a playercontroller
	if( (pc == None) || (pc.Viewtarget != self) )
		return false;

	if( pc.bBehindView )
		SpecialCalcBehindView(PC,ViewActor,CameraLocation,CameraRotation);
	else
		SpecialCalcFirstPersonView(PC,ViewActor,CameraLocation,CameraRotation);

	LastCameraCalcTime = Level.TimeSeconds;

	return true;
}

simulated function bool SpectatorSpecialCalcView(PlayerController Viewer, out Actor ViewActor, out vector CameraLocation, out rotator CameraRotation)
{
	local rotator DummyRotation;

	if (Viewer.ViewTarget != self)
		return false;

	if (Viewer.bBehindView)
	{
		DesiredTPCamDistance = (TPCamDistRange.Max - TPCamDistRange.Min) * (Viewer.CameraDist / Viewer.CameraDistRange.Max) + TPCamDistRange.Min;
		SpecialCalcBehindView(Viewer, ViewActor, CameraLocation, CameraRotation);
	}
	else
		SpecialCalcFirstPersonView(Viewer, ViewActor, CameraLocation, DummyRotation); //use rotation set by playercontroller

	LastCameraCalcTime = Level.TimeSeconds;

	Viewer.SetLocation(CameraLocation);

	return true;
}

// Events called on driver entering/leaving vehicle

function gbxVehicle FindEntryVehicle(Pawn P)
{
	if ( AIController(P.Controller) != None )
		return self;
	if (VSize(P.Location - (Location + (EntryPosition >> Rotation))) < EntryRadius)
        return self;
    return None;
}

// The pawn Driver has tried to take control of this vehicle
function bool TryToDrive(Pawn P)
{
	if ( P.bIsCrouched ||  bNonHumanControl || (P.Controller == None) || (Driver != None) || (P.DrivenVehicle != None) || !P.Controller.bIsPlayer
	     || P.IsA('Vehicle') || Health <= 0 )
		return false;

	if ( (gbxPawn(P) != None) && (gbxPawn(P).gbxDrivenVehicle != None) )
		return false;

//jlb	if( !Level.Game.CanEnterVehicle(self, P) )
//jlb		return false;

/*jlb
	// Check vehicle Locking....
	if ( !bTeamLocked || P.GetTeamNum() == Team )
	{
		if ( bEnterringUnlocks && bTeamLocked )
			bTeamLocked = false;

		KDriverEnter( P );
		return true;
	}
	else
	{
		VehicleLocked( P );
		return false;
	}
jlb*/

	KDriverEnter( P );
	return true;
}

event VehicleLocked( Pawn P );	// Pawn tried to enter vehicle, but it's locked!!

function PossessedBy(Controller C)
{
	local PlayerController PC;
	local AIController AIC;

	if ( bAutoTurret && (Controller != None) && ClassIsChildOf(Controller.Class, AutoTurretControllerClass) && !Controller.bDeleteMe )
	{
		Controller.Destroy();
		Controller = None;
	}

	super.PossessedBy( C );

/*jlb
	// Stole another team's vehicle, so set Team to new owner's team
	if ( C.GetTeamNum() != Team )
	{
		//add stat tracking event/variable here?
		if ( Team != 255 && PlayerController(C) != None )
		{
			if( StolenAnnouncement != '' )
				PlayerController(C).PlayRewardAnnouncement(StolenAnnouncement, 1);

			if( StolenSound != None )
				PlaySound( StolenSound,, 2.5*TransientSoundVolume,, 400);
		}

		if ( C.GetTeamNum() != 255 )
			SetTeamNum( C.GetTeamNum() );
	}
jlb*/

	NetPriority = 3;
	NetUpdateFrequency = 100;
	ThrottleTime = Level.TimeSeconds;
	bSpawnProtected = false;

	PC = PlayerController(C);
	if ( PC != None )
		ClientKDriverEnter( PC );
	else
	{
		AIC = AIController(C);
		if ( AIC != None )
		{
			bDriving = True;
			StuckCount = 0;

			Driver = self;  // AI controlled vehicles drive themselves

			DrivingStatusChanged();

//jlb			AttachFlag(PlayerReplicationInfo.HasFlag);

//jlb			Level.Game.DriverEnteredVehicle(self, P);
		}
	}

//jlb	if ( ParentFactory != None && ( !bAutoTurret || !ClassIsChildOf(C.Class, AutoTurretControllerClass) ) )
//jlb		ParentFactory.VehiclePossessed( Self );		// Notify parent factory
	if ( ParentFactory != None )
		ParentFactory.VehiclePossessed( Self );		// Notify parent factory
}

function UnPossessed()
{
	local PlayerController	PC;
	local Controller		NewController;
	local bool				bWasPlayer;

	StopWeaponFiring();
	PC = PlayerController(Controller);



    if ( PC != None )
	{
		bWasPlayer = true;
        ClientKDriverLeave(PC);
		if (bPCRelativeFPRotation && !PC.bBehindView)
			FixPCRotation(PC);
	}
	else
        ClientClearController();

	NetPriority = Default.NetPriority;			// restore original netpriority changed when possessing
	NetUpdateTime = Level.TimeSeconds - 1;
	NetUpdateFrequency = 8;

	super.UnPossessed();

//jlb	if ( ParentFactory != None && ( !bAutoTurret || (Controller == None) || !ClassIsChildOf(Controller.Class, AutoTurretControllerClass) ) )
//jlb		ParentFactory.VehicleUnPossessed( Self );		// Notify parent of UnPossessed()
	if ( ParentFactory != None )
		ParentFactory.VehicleUnPossessed( Self );		// Notify parent of UnPossessed()

	if ( Health > 0 && !bDeleteMe )
	{
		if ( bWasPlayer && bAutoTurret && (AutoTurretControllerClass != None) )
		{
			Controller		= None;
			NewController	= spawn(AutoTurretControllerClass);
			if ( NewController != None )
				NewController.Possess( Self );
		}
	}
}

function KDriverEnter(Pawn P)
{
	local Controller C;

	bDriving = True;
	StuckCount = 0;

	// We don't have pre-defined exit positions here, so we use the original player location as an exit point
	if ( !bRelativeExitPos )
	{
		PlayerEnterredRotation = P.Rotation;
		ExitPositions[0] =  P.Location + Vect(0,0,16);
	}

	// Set pawns current controller to control the vehicle pawn instead
	C = P.Controller;
//jlb	if ( !bCanCarryFlag && (C.PlayerReplicationInfo.HasFlag != None)  )
//jlb		P.DropFlag();

	Driver = P;
	if (gbxPawn(Driver) != None)
		gbxPawn(Driver).gbxStartDriving( Self );

	// Disconnect PlayerController from Driver and connect to SVehicle.
//jlb	C.bVehicleTransition = true; // to keep Bots from doing Restart()
	C.Unpossess();
	Driver.SetOwner( Self ); // This keeps the driver relevant.
	C.Possess( Self );
//jlb	C.bVehicleTransition = false;

	DrivingStatusChanged();

	if ( PlayerController(C) != None )
		VehicleLostTime = 0;

    if ( IdleSound != None )
        AmbientSound = IdleSound;

    if ( StartUpSound != None )
        PlaySound(StartUpSound, SLOT_None, 1.0);

//jlb	AttachFlag(PlayerReplicationInfo.HasFlag);

//jlb	Level.Game.DriverEnteredVehicle(self, P);
}

function AttachFlag(Actor FlagActor)
{
	if ( !bDriverHoldsFlag && (FlagActor != None) )
	{
		AttachToBone(FlagActor,FlagBone);
		FlagActor.SetRelativeRotation(FlagRotation);
		FlagActor.SetRelativeLocation(FlagOffset);
	}
}

simulated event SetWheelsScale(float NewScale)
{
	WheelsScale = NewScale;
}

// Called from the PlayerController when player wants to get out.
event bool KDriverLeave( bool bForceLeave )
{
	local Controller C;
	local PlayerController	PC;
	local bool havePlaced;

//jlb	if( !bForceLeave && !Level.Game.CanLeaveVehicle(self, Driver) )
//jlb		return false;

//jlb	if ( (PlayerReplicationInfo != None) && (PlayerReplicationInfo.HasFlag != None) )
//jlb		Driver.HoldFlag(PlayerReplicationInfo.HasFlag);

	// Do nothing if we're not being driven
	if (Controller == None )
		return false;

	// Before we can exit, we need to find a place to put the driver.
	// Iterate over array of possible exit locations.

	if ( (Driver != None) && (!bRemoteControlled || bHideRemoteDriver) )
    {
	    Driver.bHardAttach = false;
	    Driver.bCollideWorld = true;
	    Driver.SetCollision(true, true);
	    havePlaced = PlaceExitingDriver();

	    // If we could not find a place to put the driver, leave driver inside as before.
	    if (!havePlaced && !bForceLeave )
	    {
	        Driver.bHardAttach = true;
	        Driver.bCollideWorld = false;
	        Driver.SetCollision(false, false);
	        return false;
	    }
	}

	bDriving = False;

	// Reconnect Controller to Driver.
	C = Controller;
	if (C.RouteGoal == self)
		C.RouteGoal = None;
	if (C.MoveTarget == self)
		C.MoveTarget = None;
//jlb	C.bVehicleTransition = true;
	Controller.UnPossess();

	if ( (Driver != None) && (Driver.Health > 0) )
	{
		Driver.SetOwner( C );
		C.Possess( Driver );

		PC = PlayerController(C);
		if ( PC != None )
			PC.ClientSetViewTarget( Driver ); // Set playercontroller to view the person that got out

		if (gbxPawn(Driver) != None)
			gbxPawn(Driver).gbxStopDriving( Self );
	}
//jlb	C.bVehicleTransition = false;

	if ( C == Controller )	// If controller didn't change, clear it...
		Controller = None;

//jlb	Level.Game.DriverLeftVehicle(self, Driver);

	// Car now has no driver
	Driver = None;

	DriverLeft();

	// Put brakes on before you get out :)
    Throttle	= 0;
    Steering	= 0;
	Rise		= 0;

    return true;
}

// DriverLeft() called by KDriverLeave()
function DriverLeft()
{
    DrivingStatusChanged();

    if (AmbientSound != None)
        AmbientSound = None;
    if (ShutDownSound != None)
        PlaySound(ShutDownSound, SLOT_None, 1.0);
}

simulated function UpdateTiltForceFeedback()
{
/*jlb
	local rotator SpringCenter;
	local PlayerController PC;
	local float pitch, roll;

	PC = PlayerController(Controller);
	if(	PC != None
	&&	PC.bEnableGUIForceFeedback
	&&	PC.bForceFeedbackSupported
	&&	Viewport(PC.Player) != None
	&&	CenterSpringRangePitch > 0
	&&	CenterSpringRangeRoll > 0
	){
		SpringCenter = rotation;
		pitch = Clamp(SpringCenter.Pitch, -CenterSpringRangePitch, CenterSpringRangePitch);
		roll = Clamp(SpringCenter.Roll, -CenterSpringRangeRoll, CenterSpringRangeRoll);
		pitch /= CenterSpringRangePitch;
		roll /= CenterSpringRangeRoll;
		PC.ChangeSpringFeedbackEffect(CenterSpringForce, roll, pitch);
	}
jlb*/
}

simulated function ClientKDriverEnter(PlayerController PC)
{
//	PC.bFreeCamera = true;

	// Set rotation of camera when getting into vehicle based on bZeroPCRotOnEntry
	if ( bZeroPCRotOnEntry )
		PC.SetRotation( rot(0, 0, 0) );

	//set starting camera distance to local player's preferences
	TPCamDistance = default.TPCamDistance;
	DesiredTPCamDistance = TPCamDistance;

    if (!PC.bBehindView)
	   ActivateOverlay(True);

	if (PC.bEnableGUIForceFeedback)
	{
		UpdateTiltForceFeedback();
		PC.ClientPlayForceFeedback(CenterSpringForce);
	}
}

simulated function ClientClearController()
{
    ActivateOverlay(False);
}

simulated function ClientKDriverLeave(PlayerController PC)
{
//	PC.bFreeCamera = false;

	// Stop messing with bOwnerNoSee
	if ( Driver != None )
		Driver.bOwnerNoSee = Driver.default.bOwnerNoSee;

	if (PC.bEnableGUIForceFeedback)
		PC.ClientStopForceFeedback(CenterSpringForce);

	bWeaponisFiring = False;
	bWeaponisAltFiring = False;

	ActivateOverlay(False);
}

simulated function ActivateOverlay(bool bActive)
{
    if (bActive)
    {
        if (HUDOverlayClass != None && HUDOverlay == None)
            HUDOverlay = spawn(HUDOverlayClass);
    }
    else if (HUDOverlay != None)
        HUDOverlay.Destroy();
}

//seperate replicated function called from UnPossessed() to make PC rotation no longer relative to vehicle
//needed because PC.bBehindView will get screwed around with as a result of unpossessing vehicle and repossessing Driver
simulated function FixPCRotation(PlayerController PC)
{
	PC.SetRotation(rotator(vector(PC.Rotation) >> Rotation));
}

simulated function AttachDriver(Pawn P)
{
	local vector AttachPos;

	P.bHardAttach = true;
	AttachPos = Location + (DrivePos >> Rotation);
	P.SetLocation( AttachPos );
	P.SetPhysics( PHYS_None );
	P.SetBase( Self );
	P.SetRelativeRotation( DriveRot );
}

simulated function DetachDriver(Pawn P) {}

function bool PlaceExitingDriver()
{
	local int		i, j;
	local vector	tryPlace, Extent, HitLocation, HitNormal, ZOffset, RandomSphereLoc;

	Extent = Driver.default.CollisionRadius * vect(1,1,0);
	Extent.Z = Driver.default.CollisionHeight;
	ZOffset = Driver.default.CollisionHeight * vect(0,0,1);

	//avoid running driver over by placing in direction perpendicular to velocity
	if ( VSize(Velocity) > 100 )
	{
		tryPlace = Normal(Velocity cross vect(0,0,1)) * (CollisionRadius + Driver.default.CollisionRadius ) * 1.25 ;
		if ( FRand() < 0.5 )
			tryPlace *= -1; //randomly prefer other side
		if ( (Trace(HitLocation, HitNormal, Location + tryPlace + ZOffset, Location + ZOffset, false, Extent) == None && Driver.SetLocation(Location + tryPlace + ZOffset))
		     || (Trace(HitLocation, HitNormal, Location - tryPlace + ZOffset, Location + ZOffset, false, Extent) == None && Driver.SetLocation(Location - tryPlace + ZOffset)) )
			return true;
	}


	if ( !bRelativeExitPos )
	{
		for( i=0; i<ExitPositions.Length; i++)
		{
			tryPlace = ExitPositions[i];

			if ( Driver.SetLocation(tryPlace) )
				return true;
			else
			{
				for (j=0; j<10; j++) // try random positions in a sphere...
				{
					RandomSphereLoc = VRand()*200* FMax(FRand(),0.5);
					RandomSphereLoc.Z = Extent.Z * FRand();

					// First, do a line check (stops us passing through things on exit).
					if ( Trace(HitLocation, HitNormal, tryPlace+RandomSphereLoc, tryPlace, false, Extent) == None )
					{
						if ( Driver.SetLocation(tryPlace+RandomSphereLoc) )
							return true;
					}
					else if ( Driver.SetLocation(HitLocation) )
						return true;
				}
			}
		}
		return false;
	}

	for( i=0; i<ExitPositions.Length; i++)
	{
		if ( ExitPositions[0].Z != 0 )
			ZOffset = Vect(0,0,1) * ExitPositions[0].Z;
		else
			ZOffset = Driver.default.CollisionHeight * vect(0,0,2);

		tryPlace = Location + ( (ExitPositions[i]-ZOffset) >> Rotation) + ZOffset;

		// First, do a line check (stops us passing through things on exit).
		if ( Trace(HitLocation, HitNormal, tryPlace, Location + ZOffset, false, Extent) != None )
			continue;

		// Then see if we can place the player there.
		if ( !Driver.SetLocation(tryPlace) )
			continue;

		return true;
	}
	return false;
}

function Pawn CheckForHeadShot(Vector loc, Vector ray, float AdditionalScale)
{
    return None;
}

function TakeDamage( int Damage, Pawn instigatedBy, Vector hitlocation,
						Vector momentum, class<DamageType> damageType, optional	name HitBoxName)
{
	local int ActualDamage;
	local Controller Killer;

	// Spawn Protection: Cannot be destroyed by a player until possessed
	if ( bSpawnProtected && instigatedBy != None && instigatedBy != Self )
		return;

	NetUpdateTime = Level.TimeSeconds - 1; // force quick net update

/*jlb
	if (DamageType != None)
	{
		if ((instigatedBy == None || instigatedBy.Controller == None) && DamageType.default.bDelayedDamage && DelayedDamageInstigatorController != None)
			instigatedBy = DelayedDamageInstigatorController.Pawn;

		Damage *= DamageType.default.VehicleDamageScaling;
		momentum *= DamageType.default.VehicleMomentumScaling * MomentumMult;

	        if (bShowDamageOverlay && DamageType.default.DamageOverlayMaterial != None && Damage > 0 )
        	    SetOverlayMaterial( DamageType.default.DamageOverlayMaterial, DamageType.default.DamageOverlayTime, false );
	}
jlb*/

	if (bRemoteControlled && Driver!=None)
	{
	    ActualDamage = Damage;
	    if (Weapon != None)
	        Weapon.AdjustPlayerDamage(ActualDamage, InstigatedBy, HitLocation, Momentum, DamageType );
//jlb	    if (InstigatedBy != None && InstigatedBy.HasUDamage())
//jlb	        ActualDamage *= 2;

	    ActualDamage = Level.Game.ReduceDamage(ActualDamage, self, instigatedBy, HitLocation, Momentum, DamageType);

	    if (Health - ActualDamage <= 0)
	       	KDriverLeave(false);
	}

    if ( Physics != PHYS_Karma )
	{
		super.TakeDamage(Damage,InstigatedBy,HitLocation,Momentum,DamageType);
		return;
	}

	if (Weapon != None)
	        Weapon.AdjustPlayerDamage(Damage, InstigatedBy, HitLocation, Momentum, DamageType );
//jlb	if (InstigatedBy != None && InstigatedBy.HasUDamage())
//jlb		Damage *= 2;
	ActualDamage = Level.Game.ReduceDamage(Damage, self, instigatedBy, HitLocation, Momentum, DamageType);
	Health -= ActualDamage;

	PlayHit(actualDamage, InstigatedBy, hitLocation, damageType, Momentum);
	// The vehicle is dead!
	if ( Health <= 0 )
	{

		if ( Driver!=None && (bEjectDriver || bRemoteControlled) )
		{
			if ( bEjectDriver )
				EjectDriver();
			else
        		KDriverLeave( false );
		}

		// pawn died
		if ( instigatedBy != None )
			Killer = instigatedBy.GetKillerController();
//jlb		if ( Killer == None && (DamageType != None) && DamageType.Default.bDelayedDamage )
//jlb			Killer = DelayedDamageInstigatorController;
		Died(Killer, damageType, HitLocation);
	}
	else if ( Controller != None )
		Controller.NotifyTakeHit(instigatedBy, HitLocation, actualDamage, DamageType, Momentum);

	MakeNoise(1.0);

	if ( !bDeleteMe )
	{
//jlb		if ( Location.Z > Level.StallZ )
//jlb			Momentum.Z = FMin(Momentum.Z, 0);
		KAddImpulse(Momentum, hitlocation);
	}
}

function bool HealDamage(int Amount, Controller Healer, class<DamageType> DamageType)
{
	if ( PlayerController(Healer) != None )
		PlayerStartTime = Level.TimeSeconds + 3;
//jlb	if (Health <= 0 || Health >= HealthMax || Amount <= 0 || Healer == None || !TeamLink(Healer.GetTeamNum()))
	if (Health <= 0 || Amount <= 0 || Healer == None)
		return false;

//jlb	Health = Min(Health + (Amount * LinkHealMult), HealthMax);
	Health = Health + (Amount * LinkHealMult);
	NetUpdateTime = Level.TimeSeconds - 1;
	return true;
}

//determine if radius damage that hit the vehicle should damage the driver
function DriverRadiusDamage(float DamageAmount, float DamageRadius, Controller EventInstigator, class<DamageType> DamageType, float Momentum, vector HitLocation)
{
	local float damageScale, dist;
	local vector dir;

	//if driver has collision, whatever is causing the radius damage will hit the driver by itself
	if (EventInstigator == None || Driver == None || Driver.bCollideActors || bRemoteControlled)
		return;

	dir = Driver.Location - HitLocation;
	dist = FMax(1, VSize(dir));
	dir = dir/dist;
	damageScale = 1 - FMax(0,(dist - Driver.CollisionRadius)/DamageRadius);
	if (damageScale <= 0)
		return;

//jlb	Driver.SetDelayedDamageInstigatorController(EventInstigator);
	Driver.TakeDamage( damageScale * DamageAmount, EventInstigator.Pawn, Driver.Location - 0.5 * (Driver.CollisionHeight + Driver.CollisionRadius) * dir,
			   damageScale * Momentum * dir, DamageType );
}


function DriverDied()
{
	local Controller C;

	Level.Game.DiscardInventory( Driver );
//jlb	if (PlayerReplicationInfo != None && PlayerReplicationInfo.HasFlag != None)
//jlb		PlayerReplicationInfo.HasFlag.Drop(0.5 * Velocity);

	C = Controller;
	if (gbxPawn(Driver) != None)
		gbxPawn(Driver).gbxStopDriving( Self );
	Driver.Controller = C;
	if (gbxPawn(Driver) != None)
		gbxPawn(Driver).gbxDrivenVehicle = self; //for in game stats, so it knows pawn was killed inside a vehicle

	if ( Controller == None )
		return;

	if ( PlayerController(Controller) != None )
	{
		Controller.SetLocation(Location);
		PlayerController(Controller).SetViewTarget( Driver );
		PlayerController(Controller).ClientSetViewTarget( Driver );
	}

	Controller.Unpossess();
	if ( Controller == C )
		Controller = None;
	C.Pawn = Driver;

//jlb	Level.Game.DriverLeftVehicle(self, Driver);

	// Car now has no driver
	Driver = None;
	bDriving = false;

	// Put brakes on before you get out :)
    Throttle	= 0;
    Steering	= 0;
	Rise		= 0;
}

function Died(Controller Killer, class<DamageType> damageType, vector HitLocation)
{
	local PlayerController PC;
	local Controller C;

	if ( bDeleteMe || Level.bLevelChange )
		return; // already destroyed, or level is being cleaned up

	if ( Physics != PHYS_Karma )
	{
		super.Died(Killer, damageType, HitLocation);
		return;
	}

	if ( Level.Game.PreventDeath(self, Killer, damageType, HitLocation) )
	{
		Health = max(Health, 1); //mutator should set this higher
		return;
	}
	Health = Min(0, Health);

	if ( Controller != None )
	{
		C = Controller;
		C.WasKilledBy(Killer);
		Level.Game.Killed(Killer, C, self, damageType);
		if( C.bIsPlayer )
		{
			PC = PlayerController(C);
			if ( PC != None )
				ClientKDriverLeave(PC); // Just to reset HUD etc.
			else
                ClientClearController();
			if ( (bRemoteControlled || bEjectDriver) && (Driver != None) && (Driver.Health > 0) )
			{
				C.Unpossess();
				C.Possess(Driver);

				if ( bEjectDriver )
					EjectDriver();

				Driver = None;
			}
			else
				C.PawnDied(self);
		}

		if ( !C.bIsPlayer && !C.bDeleteMe )
			C.Destroy();
	}
	else
		Level.Game.Killed(Killer, Controller(Owner), self, damageType);

	if ( Killer != None )
		TriggerEvent(Event, self, Killer.Pawn);
	else
		TriggerEvent(Event, self, None);

	if ( IsHumanControlled() )
		PlayerController(Controller).ForceDeathUpdate();

	if ( !bDeleteMe )
		Destroy(); // Destroy the vehicle itself (see Destroyed)
}

function AdjustDriverDamage(out int Damage, Pawn InstigatedBy, Vector HitLocation, out Vector Momentum, class<DamageType> DamageType)
{
	if ( InGodMode() )
 		Damage = 0;
	else
 		Damage *= DriverDamageMult;
}

function EjectDriver()
{
	local Pawn		OldPawn;
	local vector	EjectVel;

	OldPawn = Driver;

	KDriverLeave( true );

	if ( OldPawn == None )
		return;

	EjectVel	= VRand();
	EjectVel.Z	= 0;
	EjectVel	= (Normal(EjectVel)*0.2 + Vect(0,0,1)) * EjectMomentum;

	OldPawn.Velocity = EjectVel;

	// Spawn Protection
	OldPawn.SpawnTime = Level.TimeSeconds;
	OldPawn.PlayTeleportEffect( false, false);
}

// Input
event bool UsedBy( Pawn user )
{
	if ( Driver != None )
			return false;

	// Enter vehicle code
	TryToDrive( User );
	return true;
}

function Fire( optional float F )
{
	VehicleFire( false );
	bWeaponIsFiring = true;
}

function AltFire( optional float F )
{
	VehicleFire( true );
	bWeaponIsAltFiring = true;
}

function ClientVehicleCeaseFire(bool bWasAltFire)
{
	if (bWasAltFire)
		bWeaponIsAltFiring = false;
	else
		bWeaponIsFiring = false;

	VehicleCeaseFire(bWasAltFire);
}

// Do some server-side vehicle firing stuff
function VehicleFire(bool bWasAltFire)
{
	if ( bWasAltFire )
		bWeaponIsAltFiring = true;
	else
		bWeaponIsFiring = true;
}

function VehicleCeaseFire(bool bWasAltFire)
{
	if ( bWasAltFire )
		bWeaponIsAltFiring = false;
	else
		bWeaponIsFiring = false;
}

state UnDeployed
{
    function VehicleFire(bool bWasAltFire)
    {
        Global.VehicleFire(bWasAltFire);
    }

    function VehicleCeaseFire(bool bWasAltFire)
    {
        Global.VehicleCeaseFire(bWasAltFire);
    }
}

state Deployed
{
    function VehicleFire(bool bWasAltFire)
    {
        Global.VehicleFire(bWasAltFire);
    }

    function VehicleCeaseFire(bool bWasAltFire)
    {
        Global.VehicleCeaseFire(bWasAltFire);
    }
}

function bool StopWeaponFiring()
{
	local bool bResult;

	if ( bWeaponIsFiring )
	{
		ClientVehicleCeaseFire( false );
		bWeaponIsFiring = false;
		bResult = true;
	}
	if ( bWeaponIsAltFiring )
	{
		ClientVehicleCeaseFire( true );
		bWeaponIsAltFiring = false;
		bResult = true;
	}
	return bResult;
}


event UpdateEyeHeight( float DeltaTime )
{
	local Controller C;

	if ( Controller != None && Controller.IsA('PlayerController') )
		Controller.AdjustView( DeltaTime );

	for ( C=Level.ControllerList; C!=None; C=C.NextController )
		if ( C.IsA('PlayerController') && (PlayerController(C).ViewTarget == self) )
			return;

	bUpdateEyeHeight =false;
	Eyeheight = BaseEyeheight;
}

// Vehicles ignore 'face rotation'.
simulated function FaceRotation( rotator NewRotation, float DeltaTime ) {}

simulated event SetAnimAction(name NewAction)
{
	if ( bDrawDriverInTP && (Driver != None) )
		Driver.SetAnimAction(NewAction);
}

// Vehicles dont get telefragged.
event EncroachedBy(Actor Other) {}

// RanInto() called for encroaching actors which successfully moved the other actor out of the way
event RanInto(Actor Other)
{
	local vector Momentum;
	local float Speed;

	if (Pawn(Other) == None || Vehicle(Other) != None || Other == Instigator || Other.Role != ROLE_Authority)
		return;

	Speed = VSize(Velocity);
	if (Speed > MinRunOverSpeed)
	{
		Momentum = Velocity * 0.25 * Other.Mass;

		if (Controller != None && Controller.SameTeamAs(Pawn(Other).Controller))
			Momentum += Speed * 0.25 * Other.Mass * Normal(Velocity cross vect(0,0,1));
		if (RanOverSound != None)
			PlaySound(RanOverSound,,TransientSoundVolume*2.5);

       		Other.TakeDamage(int(Speed * 0.075), Instigator, Other.Location, Momentum, RanOverDamageType);
	}
}

// This will get called if we couldn't move a pawn out of the way.
function bool EncroachingOn(Actor Other)
{
	if ( Other == None || Other == Instigator || Other.Role != ROLE_Authority || (!Other.bCollideActors && !Other.bBlockActors)
	     || VSize(Velocity) < 10 )
		return false;

	// If its a non-vehicle pawn, do lots of damage.
	if( (Pawn(Other) != None) && (Vehicle(Other) == None) )
	{
		Other.TakeDamage(10000, Instigator, Other.Location, Velocity * Other.Mass, CrushedDamageType);
		return false;
	}
}

/*jlb
simulated function bool CheckTauntValid( name Sequence )
{
	if ( !bDrawDriverInTP || (Driver == None) )
		return false;
	return Driver.CheckTauntValid(Sequence);
}
jlb*/


// AI code
function bool Occupied()
{
	return ( Controller != None );
}

function float ReservationCostMultiplier()
{
	return 1.0;
}

function bool SpokenFor(Controller C)
{
	return false;
}

function SetReservation(controller C);

function gbxVehicle OpenPositionFor(Pawn P)
{
	if ( Controller == None )
		return self;
	return None;
}

simulated function bool IndependentVehicle()
{
	return true;
}

function Actor GetBestEntry(Pawn P)
{
	return self;
}

function gbxVehicle GetMoveTargetFor(Pawn P)
{
	return self;
}

simulated event DrivingStatusChanged()
{
    local PlayerController PC;

	PC = Level.GetLocalPlayerController();

//jlb	if (bDriving && PC != None && (PC.ViewTarget == None || !(PC.ViewTarget.IsJoinedTo(self))))
	if (bDriving && PC != None && (PC.ViewTarget == None))
        bDropDetail = (Level.bDropDetail || (Level.DetailMode == DM_Low));
    else
        bDropDetail = False;

//jlb    if (bDriving)
//jlb        Enable('Tick');
//jlb    else
//jlb        Disable('Tick');
}

simulated function Tick(float DeltaTime)
{
//jlb    local	rotator				Look;

//	DrawDebugSphere(Location + (EntryPosition >> Rotation), EntryRadius, 20, 255, 0, 0);

/*jlb
	if ( Level.NetMode != NM_DedicatedServer && !bDropDetail && bAdjustDriversHead && bDrawDriverinTP && (Driver != None) && (Driver.HeadBone != '') )
	{
		Look.Yaw = (DriverViewYaw - Driver.Rotation.Yaw) & 65535;
		if ( Look.Yaw > 12000 )
		{
			if ( Look.Yaw < 32768 )
			{
				if ( Look.Yaw > 20768 )
					Look.Yaw = Look.Yaw - 32768;
				else if ( Look.Yaw > 16768 )
					Look.Yaw = -12000 + 6 * (20768 - Look.Yaw);
				else
					Look.Yaw = 12000;
			}
			else if ( Look.Yaw < 53535 )
			{
				if ( Look.Yaw < 44768 )
					Look.Yaw = Look.Yaw + 32768;
				else if ( Look.Yaw < 48768 )
					Look.Yaw = 12000 + 6 * (44768 - Look.Yaw);
				else
					Look.Yaw = 53535;
			}
		}
		Look.Yaw *= -1;
		Driver.SetBoneDirection(Driver.HeadBone, Look, vect(0,0,0), 1.0f, 0);
	}
jlb*/

	UpdateTiltForceFeedback();
}

/* PointOfView()
called by controller when possessing this pawn
false = 1st person, true = 3rd person
*/
simulated function bool PointOfView()
{
	if (!bAllowViewChange)
		return true;

	return default.bDesiredBehindView;
}

// Spawn FX
function PlayTeleportEffect( bool bOut, bool bSound)
{
	local Actor			A;
	local class<Actor>	TransEffect;

	if ( (GetTeam() == None) || (GetTeam().TeamIndex == 0) )
		TransEffect = class<Actor>(DynamicLoadObject(TransEffects[0], class'Class'));
	else
		TransEffect = class<Actor>(DynamicLoadObject(TransEffects[1], class'Class'));

	if ( TransEffect != None )
		A = Spawn(TransEffect,,,Location + CollisionHeight * vect(0,0,0.75));

	// for fast moving vehicles, make the effect sticky
	if ( A != None )
		A.SetBase( Self );

    super.PlayTeleportEffect( bOut, bSound );
}

simulated event PlayDying(class<DamageType> DamageType, vector HitLoc) {}

/*jlb
simulated function int GetTeamNum()
{
	if ( Role == Role_Authority && Team == 255 && (Controller != None) )
	   SetTeamNum( Controller.GetTeamNum() );

    return Team;
}
jlb*/


/*
Team is changed when vehicle is possessed
and PrevTeam is restored when vehicle is unpossessed
*/
function SetTeamNum(byte T)
{
	PrevTeam	= Team;
    Team		= T;

	if ( PrevTeam != Team )
		TeamChanged();
}

simulated event TeamChanged() {}

simulated function DisplayDebug(Canvas Canvas, out float YL, out float YPos)
{
	super.DisplayDebug(Canvas, YL, YPos);

	Canvas.SetDrawColor(255,255,255);
	Canvas.DrawText("Steering "$Steering$" throttle "$Throttle$" rise "$Rise);

	if (( Driver != None ) && ( Driver != self ))
	{
        YPos += YL;
    	YPos += YL;
		Canvas.SetPos(0, YPos);
		Canvas.SetDrawColor(0,0,255);
		Canvas.DrawText("--- DRIVER");
		Canvas.SetPos(4, YPos);
		Driver.DisplayDebug( Canvas, YL, YPos );
	}
}

function Actor ShootSpecial(Actor A)
{
	local Controller OldController;

	if ( !Controller.bCanDoSpecial || (Weapon == None) )
		return None;

	Controller = OldController;
	if ( KDriverLeave(false) && (OldController.Pawn != None) )
	{
		OldController.Pawn.SetRotation(rotator(A.Location - OldController.Pawn.Location));
		OldController.Focus = A;
		OldController.FireWeaponAt(A);
	}
	return A;
}

//Vehicles stall when they go above the level's StallZ
simulated event Stalled();
simulated event UnStalled();

simulated function NextWeapon()
{
    local PlayerController PC;

    if ( Level.Pauser != None )
        return;

    PC = PlayerController(Controller);
    if (PC == None)
    	return;

    if (!PC.bBehindView)
    {
    	PC.BehindView(true);
	DesiredTPCamDistance = TPCamDistRange.Min;
	TPCamDistance = DesiredTPCamDistance;
    }
    else
	DesiredTPCamDistance = Min(DesiredTPCamDistance + 100, TPCamDistRange.Max);

    default.TPCamDistance = DesiredTPCamDistance;
    StaticSaveConfig();
}

simulated function PrevWeapon()
{
    local PlayerController PC;

    if ( Level.Pauser != None )
        return;

    PC = PlayerController(Controller);
    if (PC == None || !PC.bBehindView)
    	return;

    if (DesiredTPCamDistance ~= TPCamDistRange.Min)
    	PC.BehindView(false);
    else
    {
	DesiredTPCamDistance = Max(DesiredTPCamDistance - 100, TPCamDistRange.Min);
	default.TPCamDistance = DesiredTPCamDistance;
	StaticSaveConfig();
    }
}

function bool TeamLink(int TeamNum)
{
	return (LinkHealMult > 0 && Team == TeamNum && Health > 0);
}

event bool NeedsFlip()
{
	local vector worldUp, gravUp;
	local float GravMag;

	GravMag = VSize(PhysicsVolume.Gravity);
	if( GravMag < 0.1 )
		gravUp = vect(0,0,1);
	else
		gravUp = -1.0 * (PhysicsVolume.Gravity/GravMag);

	worldUp = vect(0,0,1) >> Rotation;
	if (worldUp Dot gravUp < 0.7071)
		return true;

	return false;
}

function Flip(vector HitNormal, float ForceScale);

simulated function float ChargeBar();

simulated function ClientPlayForceFeedback( String EffectName )
{
    local PlayerController PC;

    PC = PlayerController(Controller);
    //if ( PC != None && PC.bEnableVehicleForceFeedback )
    if ( PC != None && PC.bEnableGUIForceFeedback )
    {
        PC.ClientPlayForceFeedback( EffectName );
    }
}

simulated function StopForceFeedback( String EffectName )
{
    local PlayerController PC;

    PC = PlayerController(Controller);
    //if ( PC != None && PC.bEnableVehicleForceFeedback )
    if ( PC != None && PC.bEnableGUIForceFeedback )
    {
        PC.ClientStopForceFeedback( EffectName );
    }
}

function ServerPlayHorn(int HornIndex)
{
	if( (Level.TimeSeconds - LastHornTime > 3.0) && (HornIndex >= 0) && (HornIndex < HornSounds.Length) )
	{
		PlaySound( HornSounds[HornIndex],, 3.5*TransientSoundVolume,, 800);
		LastHornTime = Level.TimeSeconds;
	}
}

function int NumPassengers()
{
	if ( Driver != None )
		return 1;
	return 0;
}

function Pawn GetInstigator()
{
	return Self;
}

function AIController GetBotPassenger()
{
	return AIController(Controller);
}

function bool IsVehicleEmpty()
{
	return (Driver == None);
}

function bool HasOccupiedTurret()
{
	return false;
}

/*jlb
function float AdjustedStrength()
{
	if (bStationary && bDefensive)
		return 1.0;

	return 0;
}
jlb*/

static function StaticPrecache(LevelInfo L);

/*jlb
function int GetSpree()
{
	if (Driver != None)
		return Driver.GetSpree();

	return 0;
}

function IncrementSpree()
{
	if (Driver != None)
		Driver.IncrementSpree();
}
jlb*/

simulated function POVChanged(PlayerController PC, bool bBehindViewChanged)
{
	if (PC.bBehindView)
	{
		if (bBehindViewChanged && bPCRelativeFPRotation)
			PC.SetRotation(rotator(vector(PC.Rotation) >> Rotation));

		bOwnerNoSee = false;

		if (Driver != None)
		{
			if (bDrawDriverInTP)
				Driver.bOwnerNoSee = false;
			else
				Driver.bOwnerNoSee = true;
		}

        if (PC == Controller)   // No overlays for spectators
            ActivateOverlay(False);
	}
	else
	{
		if (bPCRelativeFPRotation)
			PC.SetRotation(rotator(vector(PC.Rotation) << Rotation));

		if (bDrawMeshInFP)
			bOwnerNoSee = false;
		else
			bOwnerNoSee = true;

		if (Driver != None)
		{
			Driver.bOwnerNoSee = true;
		}

        if (bDriving && PC == Controller)   // No overlays for spectators
            ActivateOverlay(True);
	}
}

function PlayTakeHit(vector HitLocation, int Damage, class<DamageType> DamageType)
{
/*jlb
    local int SoundNum;

    if (IndependentVehicle() && DamageType.Default.bBulletHit && BulletSounds.Length > 0)
    {
		SoundNum = Rand(BulletSounds.Length);

		if (Controller != None && Controller == Level.GetLocalPlayerController())
            PlayOwnedSound(BulletSounds[SoundNum], SLOT_None, 2.0, False, 400);
        else
            PlayOwnedSound(BulletSounds[SoundNum], SLOT_None, 2.0, False, 100);
	}
jlb*/
}

function array<Vehicle> GetTurrets();

function CheckSuperBerserk();


//=============================================================================
// defaultproperties
//=============================================================================

defaultproperties
{
    SoundRadius=200
    TransientSoundRadius=600

	bAdjustDriversHead=true
	LandMovementState=PlayerDriving
	bVehicleShadows=true
	bShadowCast=false
	bDrawVehicleShadow=true
	bDontPossess=false
	bUseCompressedPosition=false
	Team=255
	OldTeam=255
	PrevTeam=255

	bCanSwim=false
	bCanCrouch=false
	bCanClimbLadders=false
	bCanPickupInventory=false

	Steering=0
    Throttle=0

	EjectMomentum=1000
	ExitPositions(0)=(X=0,Y=0,Z=0)

	EntryPosition=(X=0,Y=0,Z=0)
	EntryRadius=100.0

	DrivePos=(X=0,Y=0,Z=0)
	bZeroPCRotOnEntry=true
	bRelativeExitPos=true
	bPCRelativeFPRotation=true

	TPCamLookat=(X=-100,Y=0,Z=100)
	TPCamWorldOffset=(X=0,Y=0,Z=0)
	TPCamDistance=600
	TPCamDistRange=(Min=50,Max=1500)
	CameraSpeed=500
	bDesiredBehindView=true

	MaxViewYaw=16000
	MaxViewPitch=16000

//jlb	TransEffects(0)="XEffects.TransEffectRed"
//jlb	TransEffects(1)="XEffects.TransEffectBlue"

	DriveAnim=Vehicle_Driving
	CollisionRadius=+120.0
	CollisionHeight=+50.0
	SightRadius=+15000.0
//jlb	ShadowMaxTraceDist=+350
//jlb	ShadowCullDistance=1500.0
//jlb	bForceSkelUpdate=true
	bCanBeBaseForPawns=True

	MomentumMult=4.0
	DriverDamageMult=1.0
	VehiclePositionString="in a vehicle"
	VehicleNameString="Vehicle"

//jlb	LockOnClassString="Onslaught.ONSOnslaughtMessage"

//jlb	RanOverDamageType=class'DamRanOver'
	CrushedDamageType=class'Crushed'
    bAllowViewChange=true
	LinkHealMult=0.35
	VehicleLostTime=0.0
	NetUpdateFrequency=4
	NetPriority=1

//jlb	CenterSpringForce="SpringONSHoverBike"
	CenterSpringRangePitch=2000
	CenterSpringRangeRoll=2000

	bDriverHoldsFlag=true
	bCanCarryFlag=true

	WalkingPct=+1.0
	CrouchedPct=+1.0

	MaxDesireability=0.5

	ObjectiveGetOutDist=1000.0

	MinRunOverSpeed=0.0
	VehicleShadowTexture=Texture't_effect.Shadow.tank_shadow'
	VehicleShadowDrawScale=1.0

	bUsesHoldRifleAnim=false
	
    bProjFlag_LevelShadow=True
    bProjFlag_Blast=True	

	// These bones are used by AnimPawns to draw the no shoot icon, so I'm setting them to the equivalent of the
	// spine bone on a tank.
	SpineBone1="chassis"
	SpineBone2="chassis"

	bIsVehicle=true
}
//=============================================================================
// gbxWave.
// Created by: Dorian Gorski
// Purpose: Used by TriggeredScriptTimedSI
//=============================================================================
class gbxWave extends Object
	hidecategories(Object)
	editinlinenew;

struct GermanUnit
{
	var() edfindable Unit Unit_DE;
	var() name nmSpawnTag;

	var bool bSelected;
};

struct TimerSI
{
	var() edfindable gbxMessageTriggerSI gbxMT_Signal;
	var() float fDelayTillTrigger;
	var() name nmEvent;
};

var() editinline Array<GermanUnit> m_GermanUnits;
var() editinline Array<TimerSI> m_TimerSI;

var() int numUnitsToSelect;
var() float fDelayAfterComplete;

var() name nmCompleteEvent;

var() bool bIncrementSkill;
class gbxWeapon extends Weapon
	abstract
	native;

#exec OBJ LOAD FILE=..\texture\t_interface_mb.utx
#exec OBJ LOAD FILE=..\texture\T_View_model_us.utx
#exec OBJ LOAD FILE=..\texture\T_View_model_de.utx
#exec TEXTURE IMPORT FILE=Textures\crosshair_a.tga GROUP="Icons" COMPRESS=DXT1 PRECACHE
#exec TEXTURE IMPORT FILE=Textures\crosshair_b.tga GROUP="Icons" COMPRESS=DXT1 PRECACHE
#exec TEXTURE IMPORT FILE=Textures\crosshair_c.tga GROUP="Icons" COMPRESS=DXT1 PRECACHE
#exec TEXTURE IMPORT FILE=Textures\crosshair_d.tga GROUP="Icons" COMPRESS=DXT1 PRECACHE
#exec TEXTURE IMPORT FILE=Textures\crosshair_e.tga GROUP="Icons" COMPRESS=DXT1 PRECACHE
#exec TEXTURE IMPORT FILE=Textures\crosshair_f.tga GROUP="Icons" COMPRESS=DXT1 PRECACHE

//cpptext
//{
//	virtual void SetFatigue( FLOAT flFatigue );
//	void SetNoDamageThisBullet() { FireMode[0]->SetNoDamageThisBullet(); }
//}

var bool				bIsReloadingThirdPerson;		// GBX:naj - Used when the weapon's reload anim (1st person) does not match the pawn's (3rd person) in length.
var sound				HolsterSound;
var Cue					MeleeStrikeCue, MeleeSwooshCue;
var string				MeleeStrikeCueName, MeleeSwooshCueName;
var float				Desirability;
var float				AdjustStep;					// Used for aligning effects
var int					AdjustPerson;				// Used for aligning effects
var int					m_nBulletIconTextureX;
var int					m_nBulletIconTextureY;
var int					m_nClipIconTextureX;
var int					m_nClipIconTextureY;
var	float				NextPollThirdPersonReloadTime;	// GBX:naj - Used when the weapon's reload anim (1st person) does not match the pawn's (3rd person) in length.

var class<DamageType>	MyMeleeDamageType;

enum WeaponType
{
	WeaponPrimary,
	WeaponSecondary,
	WeaponTrophy,
	WeaponHidden
};

var() WeaponType		m_eWeaponType;		// What active mode is the hud in now?
var() byte				m_bWeaponBucket;

var Texture				m_TestCrosshairs[6];
var Mesh				m_NormalViewMesh;
var Mesh				m_ZoomViewMesh;
var int					m_nCharacterBodyIdx;

var int					m_nAIWeaponBurstCount;

var bool				m_fClipFront;
var bool				bPerfectAccuracy;			// GBX:jlb - added for AI AdjustAim() needing perfect aim to miss
var bool				m_fCanZoom;					// Allow us to shut off zooming in certain states (e.g. throwing a grenade)
var bool				m_fAIWeaponWaitingToFire;
var bool				m_fResetBreathe;			// We just played some other animation, so make sure the breath is reset afterward
var bool				m_fPlayingFire;				// Currently playing the fire animation
var bool				m_fPlayingMelee;			// Currently playing the melee animation
var bool				bDamagesVehicles;			// this weapon can damage vehicles (like tanks)
var bool				bFiringAtFriendly;			// The weapon was fired at a friendly soldier, so let someone know.
var bool				bThrowGrenadeLeftHanded;	// Some weapons, like the bazooka, are animated with a left hand grenade throw
var bool				bHudCoordInitialized;
var bool				bMustSwitchWhenEmpty;		// Set this to true to force a weapon to switch to the other weapon when it's empty.  Panzerfaust needs it.
var bool				m_fZoomHasHands;			// You can see the hands on the zoom model.

var float				m_flLastClipX;
var float				m_flLastClipY;

var float				flAmmoFadeTime;
var float				flLastAmmoFadeTime;
var float				flLastFireTime;
var float				ZoomFovMod;					// Amount to subtract from FOV for zoomed state
var float				ZoomDisplayFovMod;			// Amount to subtract from FOV of the weapon itself for zoomed state
var float				m_flPauseTimeExposed;		// Amount of time to pause between bursts with this weapon (usually 0.0 for non-automatic weapons).

var name				WeaponBoneName;
var name				HolsterBoneName;
var float				m_flFatigue;
var float				m_flNewFatigue;
var Name				BreathingAnim;

var float				flAmmoPosX;
var float				flAmmoPosY;
var float				flClipPosX;
var float				flClipPosY;

// Breathe profile is used by WargamePlayerController.PlayerTick()
// Factored out the old structs and stuff here into separate classes so the client could use it. 2004-09-07 JWS
var Class<gbxBreatheProfile>	BreatheProfileClass;

//var array<string>	 DEPawnPackGoreClassName;
const MAX_GERMAN_SKILL_LEVELS = 4;
var class<GorePackSetup>	DEPawnPackGoreClass[MAX_GERMAN_SKILL_LEVELS];
var class<GorePackSetup>	USPawnPackGoreClass;

const FIRE_FADE_TIME = 3.0;

const FORWARD_TEST_DISTANCE = 120.0f;
const FORWARD_TEST_TIME = 0.1f;
const FORWARD_LERP_MULTIPLIER = 1.0f;
const MAX_OFFSET_CHANGE = 10.0f;
var float				m_flLastTraceTest;
var float				m_flOldOffset;
var float				m_flNewOffset;
var float				m_flBaseOffset;

const FRIENDLY_TEST_DISTANCE = 1024.0f;
const FRIENDLY_TEST_TIME = 0.2f;
var float				m_flLastFriendlyTest;

var Actor				m_aGuideTarget; // GBX:PAD: OK.  Total freakin' hack here.  This will "guide" a projectile to absolutely hit a target.

// LCD Textures
var Texture				m_LCDAmmo;
var Texture				m_LCDClip;

const AMMO_DISPLAY_SCALE = 1.0;

var EWeaponName WeaponName;
var EAmmoName	AmmoName;
var Texture		WeaponSkinOverride;

replication
{
	reliable if( Role<ROLE_Authority )
		ServerNextWeaponFunction, ServerPrevWeaponFunction, ServerPlayZoomOut, ServerZoomInAnimEnd, ServerSwitchZoomView;

	reliable if( ROLE==ROLE_Authority)
		NextWeaponFunction, PrevWeaponFunction;

	reliable if( bNetDirty && (Role==ROLE_Authority) )
		m_fCanZoom;
}

function PostBeginPlay()
{
	Super.PostBeginPlay();

	if( MeleeStrikeCueName != "" )
	{
		MeleeStrikeCue = LoadSound( MeleeStrikeCueName );//Sound( DynamicLoadObject( MeleeStrikeSoundName, class'Sound' ) );
	}

	if( MeleeSwooshCueName != "" )
	{
		MeleeSwooshCue = LoadSound( MeleeSwooshCueName );
	}
}

simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();
	
	LoadWeaponMesh();
}

simulated native function OffsetWeaponCollision( Vector StartTrace, Vector Dir, optional bool bDoRetraction, optional bool bForceTest );

/*
simulated exec function SetMuzzleX(float NewX)
{
    FlashOffsetX=NewX;
}
simulated exec function SetMuzzleY(float NewY)
{
    FlashOffsetY=NewY;
}
simulated exec function ShowMuzzle()
{
	log("#### Muzzle X/Y: "$FlashOffsetX$"/"$FlashOffsetY);
}
simulated function SetAdjustStep(float NewStep)
{
	AdjustStep = NewStep;
	Log("#### Setting Adjustment Step to "$NewStep);
}

simulated function IncAdjustStep()
{
	AdjustStep += 0.25;
	Log("#### Setting Adjustment Step to "$AdjustStep);
}

simulated function DecAdjustStep()
{
	AdjustStep -= 0.25;
	Log("#### Setting Adjustment Step to "$AdjustStep);
}

simulated function SetAdjustPerson(int NewPerson)
{
	AdjustPerson = NewPerson;
	if (AdjustPerson==0)
		Log("#### Adjusting 3rd Person offsets");
	else
		Log("#### Adjusting 1st Person offsets");
}

simulated function AdjustX(int dir)
{

	local gbxWeaponAttachment W;
	local vector v;

	W = gbxWeaponAttachment(ThirdPersonActor);
	if (w==none)
		return;

	v.X = AdjustStep *Dir;
	W.Adjust(AdjustPerson,V);
}

simulated function AdjustY(int dir)
{

	local gbxWeaponAttachment W;
	local vector v;

	W = gbxWeaponAttachment(ThirdPersonActor);
	if (w==none)
		return;

	v.Y = AdjustStep *Dir;
	W.Adjust(AdjustPerson,V);

}

simulated function AdjustZ(int dir)
{

	local gbxWeaponAttachment W;
	local vector v;

	W = gbxWeaponAttachment(ThirdPersonActor);
	if (w==none)
		return;

	v.z = AdjustStep *Dir;
	W.Adjust(AdjustPerson,V);

}
*/

simulated function AttachToPawn(Pawn P, optional bool bDontInitAttachment)
{
	Super.AttachToPawn(P);
	if (!bDontInitAttachment)
	{
		gbxWeaponAttachment(ThirdPersonActor).SetAmmoType(FireMode[0].AmmoClass, FireMode[0].FlashEmitterClass);
		WeaponAttachment( ThirdPersonActor ).SetupInstigatorProperties();

		// Bug 1090 - Give teams proper skins for sleeves
		if (Level.NetMode != NM_Standalone)
		{
			if (P.PawnTeam == TEAM_US)
			{
				m_anExtendedActor.Skins[0] = Texture'T_View_model_us.View_weapons.hand';
				if (m_fZoomHasHands)
				{
					Skins[0] = WeaponSkinOverride;
					Skins[1] = Texture'T_View_model_us.View_weapons.hand';
				}
			}
			else if (P.PawnTeam == TEAM_German)
			{
				m_anExtendedActor.Skins[0] = Texture'T_View_model_de.View_weapons.hand';
				if (m_fZoomHasHands)
				{
					Skins[0] = WeaponSkinOverride;
					Skins[1] = Texture'T_View_model_de.View_weapons.hand';
				}
			}
		}
	}

/*	
	P.m_flEncumberance = m_flEncumberance;
	P.m_fCanSprint = m_fCanSprint;
	
	if ((gbxPawn(P) != None) && (gbxPawn(P).MyUnit != None))
	{
		gbxPawn(P).MyUnit.PropegateEncumberance();
	}
*/
}

simulated function gbxMuzzleFlash GetMuzzleFlash()
{
	return gbxMuzzleFlash(FireMode[0].GetMuzzleFlash());
}

simulated function DisplayDebug(Canvas Canvas, out float YL, out float YPos)
{
	local gbxWeaponAttachment W;

	Super.DisplayDebug(Canvas, YL, YPos);

	W = gbxWeaponAttachment(ThirdPersonActor);

	Canvas.SetDrawColor(255,255,0);
	YPos += YL;
	Canvas.SetPos(4,YPos);

	if (AdjustPerson==0)
		Canvas.DrawText("Adjusting 3rd Person View with a step of "$AdjustStep, false, 0.9, 0.9);
	else
		Canvas.DrawText("Adjusting 1st Person View with a step of "$AdjustStep, false, 0.9, 0.9);
/*
	YPos += YL;
	Canvas.SetPos(4,YPos);
	Canvas.DrawText("     3rd Person Offset: "$W.EffectLocationOffset[0]);
	YPos += YL;
	Canvas.SetPos(4,YPos);
	Canvas.DrawText("     1st Person Offset: "$W.EffectLocationOffset[1]);
*/
}


simulated exec function SetWeapFOV(float newfov)
{
	if ( Pawn(Owner).Weapon != self)
		return;

	DisplayFOV = newFOV;
}

simulated exec function ShowWeapFOV()
{
	if ( Pawn(Owner).Weapon != self)
		return;

	log("#### DisplayFOV = "$DisplayFOV);
}

simulated exec function SetWeapScale(float ns)
{
	if ( Pawn(Owner).Weapon != self)
		return;

	SetDrawScale(ns);
}

simulated exec function ShowWeapScale()
{
	if ( Pawn(Owner).Weapon != self)
		return;

	log("#### DrawScale= "$DrawScale);
}

simulated exec function SetWeapX(float x)
{
	if ( Pawn(Owner).Weapon != self)
		return;

	PlayerViewOffset.X = x;
}

simulated exec function SetWeapY(float Y)
{
	if ( Pawn(Owner).Weapon != self)
		return;

	PlayerViewOffset.Y = Y;

}
simulated exec function SetWeapZ(float Z)
{
	if ( Pawn(Owner).Weapon != self)
		return;

	PlayerViewOffset.Z = Z;

}

simulated exec function ShowWeapXYZ()
{
	if ( Pawn(Owner).Weapon != self)
		return;

	log("#### ViewOffset: "$PlayerViewOffset);
}

// TrackPlayer - This function is linked to the hud and used to display any special
// player tracking or targetting info.  X/Y is the screen coordinates of the player.
// returns FALSE if it doesn't process the player.

simulated function bool TrackPlayer(canvas Canvas, float X, float Y, pawn P);

native final function DrawGBXHudC(canvas Canvas, gbxHud Hud, FontInfo Fonts, int nPass);

simulated function DrawHud(canvas Canvas, gbxHud Hud, FontInfo Fonts, int nPass)
{
	local int lcdAmmoIX, lcdAmmoNX, lcdClipIX, lcdClipNX, lcdY;
	local int nNumClips;
		
	if (nPass == 0)
	{
		// Draw LCD info. 
		lcdAmmoIX = 5; // Strange casting issues if not set to vars.
		lcdAmmoNX = 30;
		lcdClipIX = 55;
		lcdClipNX = 90;
		lcdY = 5;
		
		nNumClips = ((Ammo[0].AmmoAmount - ClipAmt) / AmmoClipSize);
		if (((nNumClips * AmmoClipSize) + ClipAmt) < Ammo[0].AmmoAmount)
			nNumClips++;

		Canvas.DrawLCDIcon(0, m_LCDAmmo, lcdAmmoIX, lcdY);
		Canvas.DrawLCDNumber(0, ClipAmt, lcdAmmoNX, lcdY);
		Canvas.DrawLCDIcon(0, m_LCDClip, lcdClipIX, lcdY);
		Canvas.DrawLCDNumber(0, nNumClips, lcdClipNX, lcdY);
	}

	if (gbxPlayerController(Pawn(Owner).Controller).RemoveWeaponFromHud())
		return;
	
	DrawGBXHudC( Canvas, Hud, Fonts, nPass );
}

/*
simulated function DrawHud(canvas Canvas, gbxHud Hud, FontInfo Fonts, int nPass)
{
//	local int i;
//	local float cY, sY, fY;
	local float xl,yl;
	local string s;
	local int	nNumClips;
	local byte	nAlpha;
	local Font oldFont;

	if ( Instigator == None )
		return;

	
	oldFont = Canvas.Font;
	Canvas.Font = Hud.WargameFontNumbers;

	if (nPass == 0)
	{
		if (!bHudCoordInitialized || (m_flLastClipX != Canvas.ClipX) || (m_flLastClipY != Canvas.ClipY))
		{
			if (!Hud.bIsSplitScreen)
			{
				flAmmoPosX = (Canvas.SafeOffX + Canvas.SafeSizeX) - (147 * Hud.flMinScaleX);
				flAmmoPosY = (Canvas.SafeOffY + Canvas.SafeSizeY) - (46 * Hud.flMinScaleY);
				flClipPosX = (Canvas.SafeOffX + Canvas.SafeSizeX) - (72 * Hud.flMinScaleX);
				flClipPosY = (Canvas.SafeOffY + Canvas.SafeSizeY) - (46 * Hud.flMinScaleY);
			}
			else
			{
				flAmmoPosX = (Canvas.SafeOffX + Canvas.SafeSizeX) - (147 * Hud.flSplitScreenScale);
				flAmmoPosY = (Canvas.SafeOffY + Canvas.SafeSizeY) - (46 * Hud.flSplitScreenScale);
				flClipPosX = (Canvas.SafeOffX + Canvas.SafeSizeX) - (72 * Hud.flSplitScreenScale);
				flClipPosY = (Canvas.SafeOffY + Canvas.SafeSizeY) - (46 * Hud.flSplitScreenScale);
			}
			
			bHudCoordInitialized = true;
			m_flLastClipX = Canvas.ClipX;
			m_flLastClipY = Canvas.ClipY;
		}

		if ((flLastFireTime + FIRE_FADE_TIME) < Level.TimeSeconds)
			nAlpha = 51;
		else
			nAlpha = Lerp( (Level.TimeSeconds - flLastFireTime) / FIRE_FADE_TIME, 255, 51 );

		Canvas.SetDrawColor(26,20,14,nAlpha);
		if ( !Hud.bIsSplitScreen )
		{
			Canvas.SetPos( flClipPosX, flClipPosY );
			Canvas.DrawTile( material't_interface_mb.hud.interface_comp', 65 * Hud.flMinScaleX, 31 * Hud.flMinScaleY, 412, 205, 65, 31);
		}
		else
		{
			Canvas.SetPos( flClipPosX, flClipPosY );
			Canvas.DrawTile( material't_interface_mb.hud.interface_comp', 65 * Hud.flSplitScreenScale, 31 * Hud.flSplitScreenScale, 412, 205, 65, 31);
		}

		if (ClipAmt <= 2)
		{
			Canvas.SetDrawColor(185, 48, 38, nAlpha);
		}
		else
		{
			Canvas.SetDrawColor(228, 220, 197, nAlpha);
		}

		if ( !Hud.bIsSplitScreen )
		{
			Canvas.SetPos( flClipPosX + (39 * Hud.flMinScaleX), flClipPosY + (2.5f * Hud.flMinScaleY) );
			Canvas.DrawTile( material't_interface_mb.hud.interface_comp', 26 * Hud.flMinScaleX, 26 * Hud.flMinScaleY, m_nBulletIconTextureX, m_nBulletIconTextureY, 26, 26);
		}
		else
		{
			Canvas.SetPos( flClipPosX + (39 * Hud.flSplitScreenScale), flClipPosY + (2.5f * Hud.flSplitScreenScale) );
			Canvas.DrawTile( material't_interface_mb.hud.interface_comp', 26 * Hud.flSplitScreenScale, 26 * Hud.flSplitScreenScale, m_nBulletIconTextureX, m_nBulletIconTextureY, 26, 26);
		}

		if (flAmmoFadeTime > 0.0f)
		{
			if (flAmmoFadeTime < 1.0)
				Canvas.SetDrawColor(26,20,14, 255 * flAmmoFadeTime);
			else
				Canvas.SetDrawColor(26,20,14);

			if ( !Hud.bIsSplitScreen )
			{
				Canvas.SetPos( flAmmoPosX, flAmmoPosY );
				Canvas.DrawTile( material't_interface_mb.hud.interface_comp', 65 * Hud.flMinScaleX, 31 * Hud.flMinScaleY, 412, 205, 65, 31);
			}
			else
			{
				Canvas.SetPos( flAmmoPosX, flAmmoPosY );
				Canvas.DrawTile( material't_interface_mb.hud.interface_comp', 65 * Hud.flSplitScreenScale, 31 * Hud.flSplitScreenScale, 412, 205, 65, 31);
			}

			nNumClips = ((Ammo[0].AmmoAmount - ClipAmt) / AmmoClipSize);
			if (((nNumClips * AmmoClipSize) + ClipAmt) < Ammo[0].AmmoAmount)
				nNumClips++;
			if (nNumClips <= 2)
			{
				if (flAmmoFadeTime < 1.0)
					Canvas.SetDrawColor(185, 48, 38, 255 * flAmmoFadeTime);
				else
					Canvas.SetDrawColor(185, 48, 38);
			}
			else
			{
				if (flAmmoFadeTime < 1.0)
					Canvas.SetDrawColor(228, 220, 197, 255 * flAmmoFadeTime);
				else
					Canvas.SetDrawColor(228, 220, 197);
			}

			if ( !Hud.bIsSplitScreen )
			{
				Canvas.SetPos( flAmmoPosX + (39 * Hud.flMinScaleX), flAmmoPosY + (2.5f * Hud.flMinScaleY) );
				Canvas.DrawTile( material't_interface_mb.hud.interface_comp', 26 * Hud.flMinScaleX, 26 * Hud.flMinScaleY, m_nClipIconTextureX, m_nClipIconTextureY, 26, 26);
			}
			else
			{
				Canvas.SetPos( flAmmoPosX + (39 * Hud.flSplitScreenScale), flAmmoPosY + (2.5f * Hud.flSplitScreenScale) );
				Canvas.DrawTile( material't_interface_mb.hud.interface_comp', 26 * Hud.flSplitScreenScale, 26 * Hud.flSplitScreenScale, m_nClipIconTextureX, m_nClipIconTextureY, 26, 26);
			}
		}
	}
	else if (nPass == 1)
	{
		if ((flLastFireTime + FIRE_FADE_TIME) < Level.TimeSeconds)
			nAlpha = 51;
		else
			nAlpha = Lerp( (Level.TimeSeconds - flLastFireTime) / FIRE_FADE_TIME, 255, 51 );

		s = ""$ClipAmt;
		if ( !Hud.bIsSplitScreen )
		{
			Canvas.StrLen(s,xl,yl, AMMO_DISPLAY_SCALE * Hud.flMinScaleX, AMMO_DISPLAY_SCALE * Hud.flMinScaleY);
		}
		else
		{
			Canvas.StrLen(s,xl,yl, AMMO_DISPLAY_SCALE * Hud.flSplitScreenScale, AMMO_DISPLAY_SCALE * Hud.flSplitScreenScale);
		}
		// GBX:PAD: I have these broken down into "formulas" so that the large number can be replaced with variables
		// later on.
		if (ClipAmt <= 2)
		{
			Canvas.SetDrawColor(185, 48, 38, nAlpha);
		}
		else
		{
			Canvas.SetDrawColor(228, 220, 197, nAlpha);
		}

		if ( !Hud.bIsSplitScreen )
		{
            Canvas.SetPos((flClipPosX + (35 * Hud.flMinScaleX)) - xl, flClipPosY - (7.0f * Hud.flMinScaleY));
			Canvas.DrawText(s, false, (AMMO_DISPLAY_SCALE * Hud.flMinScaleX), (AMMO_DISPLAY_SCALE * Hud.flMinScaleY));
		}
		else
		{
			Canvas.SetPos((flClipPosX + (35 * Hud.flSplitScreenScale)) - xl, flClipPosY - (7.0f * Hud.flSplitScreenScale));
			Canvas.DrawText(s, false, (AMMO_DISPLAY_SCALE * Hud.flSplitScreenScale), (AMMO_DISPLAY_SCALE * Hud.flSplitScreenScale));
		}

		if (flAmmoFadeTime > 0.0f)
		{
			if (Ammo[0].AmmoAmount > 0)
			{
				nNumClips = ((Ammo[0].AmmoAmount - ClipAmt) / AmmoClipSize);
				if (((nNumClips * AmmoClipSize) + ClipAmt) < Ammo[0].AmmoAmount)
					nNumClips++;
				if (nNumClips <= 2)
				{
					if (flAmmoFadeTime < 1.0)
						Canvas.SetDrawColor(185, 48, 38, 255 * flAmmoFadeTime);
					else
						Canvas.SetDrawColor(185, 48, 38);
				}
				else
				{
					if (flAmmoFadeTime < 1.0)
						Canvas.SetDrawColor(228, 220, 197, 255 * flAmmoFadeTime);
					else
						Canvas.SetDrawColor(228, 220, 197);
				}
			}
			else
			{
				nNumClips = 0;
				if (flAmmoFadeTime < 1.0)
					Canvas.SetDrawColor(185, 48, 38, 255 * flAmmoFadeTime);
				else
					Canvas.SetDrawColor(185, 48, 38);
			}
			s = ""$nNumClips;
			if ( !Hud.bIsSplitScreen )
			{
				Canvas.StrLen(s,xl,yl, AMMO_DISPLAY_SCALE * Hud.flMinScaleX, AMMO_DISPLAY_SCALE * Hud.flMinScaleY);
			}
			else
			{
				Canvas.StrLen(s,xl,yl, AMMO_DISPLAY_SCALE * Hud.flSplitScreenScale, AMMO_DISPLAY_SCALE * Hud.flSplitScreenScale);
			}
			// GBX:PAD: I have these broken down into "formulas" so that the large number can be replaced with variables
			// later on.
			if ( !Hud.bIsSplitScreen )
			{
				Canvas.SetPos((flAmmoPosX + (39 * Hud.flMinScaleX)) - xl, flAmmoPosY - (7.0f * Hud.flMinScaleY));
				Canvas.DrawText(s, false, (AMMO_DISPLAY_SCALE * Hud.flMinScaleX), (AMMO_DISPLAY_SCALE * Hud.flMinScaleY));
			}
			else
			{
				Canvas.SetPos((flAmmoPosX + (39 * Hud.flSplitScreenScale)) - xl, flAmmoPosY - (7.0f * Hud.flSplitScreenScale));
				Canvas.DrawText(s, false, (AMMO_DISPLAY_SCALE * Hud.flSplitScreenScale), (AMMO_DISPLAY_SCALE * Hud.flSplitScreenScale));
			}
			flAmmoFadeTime -= (Level.TimeSeconds - flLastAmmoFadeTime);
			flLastAmmoFadeTime = Level.TimeSeconds;
		}
	}

	Canvas.Font = oldFont;
}
*/

simulated function TweenDown()
{
	local name Anim;
	local float frame,rate;

	if ( IsAnimating() && AnimIsInGroup(0,'Select') )
	{
		GetAnimParams(0,Anim,frame,rate);
		TweenAnim( Anim, frame * 0.4 );
	}
	else
	{
		PlayAnim('Holster', 1.0, 0.05);
		PlayOwnedSound(HolsterSound);
	}
}

// Next/PrevWeaponFunctions are used to scroll though alternate functions on the weapon.

simulated function NextWeaponFunction()
{
	ServerNextWeaponFunction();
}

function ServerNextWeaponFunction();

simulated function PrevWeaponFunction()
{
	ServerPrevWeaponFunction();
}

function ServerPrevWeaponFunction();

// FakeTrace - Performs the same logic as a TraceHit, but doesn't actually pass it
// to the ammo.  It's used for spawning beam effects and such in first/person
simulated function FakeTrace()
{
	local vector HitLocation, HitNormal, StartTrace, EndTrace, X,Y,Z;
	local actor Other;

	Owner.MakeNoise(1.0);
	GetAxes(Instigator.GetViewRotation(),X,Y,Z);
	StartTrace = GetFireStart(X,Y,Z);
	EndTrace = StartTrace + TraceDist * X;
	Other = Trace(HitLocation,HitNormal,EndTrace,StartTrace,True);
	if (Other==None)
		HitLocation = EndTrace;

	if (ThirdPersonActor!=None)
	{
		gbxWeaponAttachment(ThirdPersonActor).HitLoc=HitLocation;
		gbxWeaponAttachment(ThirdPersonActor).ThirdPersonEffects();
	}
}

simulated function Weapon RecommendWeapon( out float rating, optional bool bForceIfLast )
{
	if ( (Ammo[0] != None && Ammo[0].AmmoAmount > 0) || Inventory == None )
	{
		return self;
	}
	else
	{
		// Check if the next weapon in the chain cannot be switched to when empty
		if( !bMustSwitchWhenEmpty )
		{
			if( Inventory.inventory != None && gbxWeapon(Inventory.inventory) != None )
			{
				if( gbxWeapon(Inventory.inventory).bMustSwitchWhenEmpty && !gbxWeapon(Inventory.inventory).HasAmmo() )
					return self;
			}
			else if( bForceIfLast )
			{
				return self;
			}
		}
		else if( bMustSwitchWhenEmpty )
		{
			return Inventory.RecommendWeapon( rating, true );
		}

		return Inventory.RecommendWeapon( rating );
	}
}

simulated function MeleeFire( float Value )
{
	local AnimPawn aPawn;
	local vector HitLocation, HitNormal, StartTrace, EndTrace, X,Y,Z, View;
	local bool bHitSuccess, bHitWater;
	local IImpactManager ImpactMgr;
	local Material HitMat;
	local Actor HitActor;
	//local Emitter WaterRippleEmitter;

	GetAxes(Pawn(Owner).GetViewRotation(), X, Y, Z);
	StartTrace = Owner.Location + (Pawn(Owner).EyeHeight * vect(0,0,1));	// Start the trace at the character's eye position

	foreach VisibleCollidingActors(class'AnimPawn',aPawn,Pawn(Owner).MeleeRange,Owner.Location)
	{
		if ( aPawn == Owner || aPawn.SameTeamAs( Pawn(Owner) ) )	// Skip the player's pawn
			continue;

		View = (aPawn.Location + (aPawn.EyeHeight * vect(0,0,1))) - StartTrace;

		View = Normal( View );

		if ( (View Dot X) > 0.50 )	// Determine if the thing being hit is mainly in front of the attacker's view
		{	
			EndTrace = aPawn.Location + (aPawn.EyeHeight * vect(0,0,1));   // End the trace at the eye of the character being hit

			Trace(HitLocation,HitNormal,EndTrace,StartTrace,True);					

			if (!aPawn.IsDead())
			{
			// GBX:naj - this function is called for player pawns only, so make sure it does instant-kill damage.
			aPawn.TakeDamage(1000, Pawn(Owner), HitLocation, 30000.000000*( Vector( gbxPawn(Owner).Controller.GetViewRotation() ) ), MyMeleeDamageType);
			PlayMeleeStrikeSound( Pawn( Owner ) );
			PlayerController(Pawn(Owner).Controller).ClientPlayForceFeedback( "Melee" );
			bHitSuccess=true;
				break;		//NAC: only break out if this look if we have hit an actor that is alive (now dead).
			}
			else if(gbxPawn(Owner).bIsCrouched)
			{
				//create a normal vector for the dead pawn
				View = (aPawn.Location);
				View.Z -=aPawn.CollisionHeight;
				Y.X = View.X;
				Y.Y = View.Y;
				Y.Z = aPawn.CollisionHeight;
				View = Y - View;
				View = Normal( View );
				//check the dead pawn's normal vector vs. players lookat vector
				if ((View Dot X) < -0.4)
				{
					PlayMeleeStrikeSound( Pawn( Owner ) );
					PlayerController(Pawn(Owner).Controller).ClientPlayForceFeedback( "Melee" );
					bHitSuccess = true;
				}
			}
		
		}


	}
	

	if(!bHitSuccess)
	{
		// Trace to see if we hit a wall
		StartTrace = Owner.Location + (Pawn(Owner).EyeHeight * vect(0,0,1));
		EndTrace = StartTrace + Normal(Vector(Pawn(Owner).GetViewRotation())) * Pawn(Owner).MeleeRange;

		//Debug Tool
		//WaterRippleEmitter=Spawn(class'gbxEffects.WaterRipple',,,EndTrace,rot(16384,0,0));
		//WaterRippleEmitter.Emitters[0].bSuspendSpawning=false;

		bTraceWater = true;
		HitActor = Trace( HitLocation, HitNormal, EndTrace, StartTrace, true,, HitMat );
		bTraceWater = false;

		if( HitActor!=None && HitActor.IsA('WaterVolume') ) // The pawn is in water
			bHitWater=true;

		// If we hit a wall send an impact to the impact manager at the location of the hit.
		if(HitMat != None || bHitWater)
		{
			ImpactMgr = class'ImpactManager'.static.GetInstance( Level.Outer, self );
			if (ImpactMgr != None)
			{
				ImpactMgr.HandleMeleeImpact( self, HitMat, bHitWater, HitLocation, rotator(HitNormal)  );
			}
		}

	}

	gbxWeaponAttachment(ThirdPersonActor).ThirdPersonEffects();
}

simulated function PlayMeleeStrikeSound( Pawn Attacker )
{
	if ( Attacker != None )
	{
		Attacker.PlayOwnedSoundCue( MeleeStrikeCue, SLOT_None );
	}
}

simulated function PlayMeleeSwooshSound( Pawn Attacker )
{
	if ( Attacker != None )
	{
		Attacker.PlayOwnedSoundCue( MeleeSwooshCue, SLOT_None );
	}
}

simulated function name GetWeaponBone()
{
	return WeaponBoneName;
}

simulated function name GetHolsterBone()
{
	return HolsterBoneName;
}

function ServerSwitchZoomView( bool fZoomed )
{
	if (fZoomed)
	{
		Instigator.m_flEncumberance = m_flSiteEncumberance;

	}
	else
	{
		Instigator.m_flEncumberance = Default.m_flEncumberance;
	}
}

simulated function bool SwitchZoomView( bool fZoomed )
{
	if (m_ZoomViewMesh == None)
		return false;

	ServerSwitchZoomView(fZoomed);

	if (fZoomed)
	{
		LinkMesh( m_ZoomViewMesh );

	}
	else
	{
		LinkMesh( m_NormalViewMesh );
		if (Level.NetMode == NM_StandAlone)
		{
			if (((Instigator != None) && (Instigator.m_fFingerMissing)) || Level.bHartsockWounded)
			{
				ExtendedAttachment( m_anExtendedActor, 'hands', 'hands_bandage' );
			}
			else
			{
				ExtendedAttachment( m_anExtendedActor, 'hands', 'hands' );
			}
		}
		else
		{
			ExtendedAttachment( m_anExtendedActor, 'hands', 'hands_MP' );
		}
	}

	if ((Instigator.Controller != None) && (Instigator.Controller.bIsHumanPlayer))
		PlayerController(Instigator.Controller).ResetShakeView();
		
	if ((m_fZoomed != fZoomed) && !fZoomed)
		PlayIdle();

	m_fZoomed = fZoomed;
	if (m_fZoomed)
	{
		if (gbxPawn(Instigator) != None)
			gbxPawn(Instigator).BreathOffset = vect(0, 0, 0);

		PlayAnim('Idle', 1, 0.0);
		if (m_flFatigue > 0.0)
		{
//			if (m_fResetBreathe)
//				AnimBlendParams(1, 0.0);
//			else
//				AnimBlendParams(1, m_flFatigue);
//			LoopAnim(BreathingAnim, m_flFatigue, 0.0, 1);
//			SetAnimFrame( 0.0, 1 );		// Reset the breathing frame to 0 so we don't pop after an animation interrupted it.
		}
		else
		{
			AnimBlendToAlpha( 1, 0.0, 0.0 );
		}
	}
	else
	{
		AnimBlendToAlpha( 1, 0.0, 0.0 );
	}

	return true;
}

// GBX:naj - added 4/27/03 - Dirty hack to avoid dangling pointer that occurs with Emitters when they autodestroy.
simulated function ShellsDestroyed() {}
simulated function ClipDestroyed() {}
// GBX:naj - end added 4/27/03

// GBX:PAD: These are stubs so that we can maintain some level of being abstract.
simulated function DrawCrossHair( canvas Canvas)
{
	Super.DrawCrosshair( Canvas );
}

simulated function ForceUnzoom()
{

}


function ServerPlayZoomOut()
{
	Instigator.m_flEncumberance = Default.m_flEncumberance;
}

simulated function PlayZoomOut()
{
	Mesh = m_NormalViewMesh;
	ServerPlayZoomOut();
	Super.PlayZoomOut();
	if (Level.NetMode == NM_StandAlone)
	{
		if (((Instigator != None) && (Instigator.m_fFingerMissing)) || Level.bHartsockWounded)
		{
			ExtendedAttachment( m_anExtendedActor, 'hands', 'hands_bandage' );
		}
		else
		{
			ExtendedAttachment( m_anExtendedActor, 'hands', 'hands' );
		}
	}
	else
	{
		ExtendedAttachment( m_anExtendedActor, 'hands', 'hands_MP' );
	}
}

simulated function AnimEnd(int channel)
{
    local name anim;
    local float frame, rate;
//    local int	Mode;

	if (channel > 0)
		return;

    GetAnimParams(0, anim, frame, rate);

	//Super.AnimEnd( channel );

	if (ClientState == WS_ReadyToFire)
	{
		m_fPlayingFire = false;
		if ((FireMode[0] != None) && (anim == FireMode[0].FireAnim) && HasAnim(FireMode[0].FireEndAnim)) // rocket hack
		{
			PlayAnim(FireMode[0].FireEndAnim, FireMode[0].FireEndAnimRate, 0.0);
		}
		else if ((FireMode[1] != None) && (anim==FireMode[1].FireAnim) && HasAnim(FireMode[1].FireEndAnim))
		{
			PlayAnim(FireMode[1].FireEndAnim, FireMode[1].FireEndAnimRate, 0.0);
		}
//		else if ((FireMode[0] == None || !FireMode[0].bIsFiring) && (FireMode[1] == None || !FireMode[1].bIsFiring))
		else
		{
//			if (Instigator.Controller.ReloadAfterWeaponFire() && NeedsToReload() && !bDelayReloading)
//			{
//				if( gbxPlayerController(Pawn(Owner).Controller) != None && gbxPlayerController(Pawn(Owner).Controller).IsZoomed() )
//				{
//					gbxPlayerController(Pawn(Owner).Controller).PendingDelayedAction = ReloadAfterZoomOut;
//					gbxPlayerController(Pawn(Owner).Controller).ChangeView(0);
//				}
////				else
////				{
////					FireMode[0].PlayReloading();
////				}
//			}
//			else
//			{
				PlayIdle();
//			}
		}
	}
	else if (ClientState == WS_Reloading)
	{
		m_fPlayingFire = false; // RSC: we are not playing the fire animation anymore so set this to false - BUG 10044

		if ( Instigator != None && Instigator.IsA( 'gbxPawn' ) && gbxPawn( Instigator ).IsReloadingThirdPerson() )
		{
			bIsReloadingThirdPerson = true;
			NextPollThirdPersonReloadTime = Level.TimeSeconds + 0.25;
		}
		else
		{

			if (Role == ROLE_Authority){		//NAC: only allow the server to change the clientstate from WS_Reloading to WS_ReadyToFire BUG #7023
				ClientState = WS_ReadyToFire;
			}
			PlayIdle();
			ReloadClip();

		}
	}
	else if (ClientState == WS_ZoomIn)
	{
		ServerZoomInAnimEnd();
		Mesh = m_ZoomViewMesh;
		m_fZoomed = true;
		ClientState = WS_ReadyToFire;

		if( gbxPawn(Owner) != None )
		{
			gbxPawn(Owner).SetWeaponAimedState( WAS_Sighted );
			gbxPawn(Owner).flLastAimedStateChange = Level.TimeSeconds;
		}

		if (gbxPawn(Instigator) != None)
			gbxPawn(Instigator).BreathOffset = vect(0, 0, 0);

		// Moved this out of below if statment.  This should'nt hurt anything, and fixes a few issues.
		PlayAnim('Idle', 1, 0.0);
		if (m_flFatigue > 0.0)
		{
//			if (m_fResetBreathe)
//				AnimBlendParams(1, 0.0);
//			else
//				AnimBlendParams(1, m_flFatigue);
//			LoopAnim(BreathingAnim, m_flFatigue, 0.0, 1);
//			SetAnimFrame( 0.0, 1 );		// Reset the breathing frame to 0 so we don't pop after an animation interrupted it.
		}
		else
		{
			AnimBlendToAlpha( 1, 0.0, 0.0 );
		}
	}
	else if (ClientState == WS_ZoomOut)
	{
		m_fZoomed = false;

		if (gbxPlayerController(Pawn(Owner).Controller) != None)
		{
			if (gbxPlayerController(Pawn(Owner).Controller).PendingDelayedAction == ReloadAfterZoomOut)
			{
				ClientState = WS_Reloading;
			}
			else if (gbxPlayerController(Pawn(Owner).Controller).PendingDelayedAction == MeleeAfterZoomOut)
			{
				ClientState = WS_ReadyToFire;
				gbxPlayerController(Pawn(Owner).Controller).bMeleeFire = 1;
			}
			else
			{
				ClientState = WS_ReadyToFire;
			}
		}
		else
			ClientState = WS_ReadyToFire;

		AnimBlendToAlpha( 1, 0.0, 0.0 );
		if (ClientState == WS_ReadyToFire)
		{
			PlayIdle();
		}
	}
	else if ( ClientState == WS_ThrowGrenade )
	{
		ClientState = WS_ReadyToFire;
		PlayIdle();
	}
	else if ( ClientState == WS_Melee )
	{
		// -BB
		m_flDrawOffset = 0.0f;
		m_flOldOffset = 0.0f;
		m_flNewOffset = 0.0f;
		// /BB

		ClientState = WS_ReadyToFire;
		PlayIdle();
	}
/*
    else if (ClientState == WS_BringUp)
    {
		for( Mode = 0; Mode < NUM_FIRE_MODES; Mode++ )
	       FireMode[Mode].InitEffects();
        PlayIdle();
	      WeaponAttachment( ThirdPersonActor ).SetupInstigatorProperties();
        ClientState = WS_ReadyToFire;
		m_flLastTraceTest = Level.TimeSeconds;
		flLastFireTime = Level.TimeSeconds;
		log(self$".AnimEnd( "$channel$" ) - WS_BringUp - "$Pawn(Owner).Weapon$" - "$Pawn(Owner).PendingWeapon$" - "$Level.TimeSeconds);
    }
    else if (ClientState == WS_PutDown)
    {
		ClientState = WS_Hidden;
		Instigator.ChangedWeapon();
		for( Mode = 0; Mode < NUM_FIRE_MODES; Mode++ )
			FireMode[Mode].DestroyEffects();
		log(self$".AnimEnd( "$channel$" ) - WS_PutDown - "$Pawn(Owner).Weapon$" - "$Pawn(Owner).PendingWeapon$" - "$Level.TimeSeconds);
    }
*/
	else
	{
		PlayIdle();
	}

	if (m_fResetBreathe)
	{
		if (m_fZoomed)
			SetAnimFrame( 0.0, 1 );		// Reset the breathing frame to 0 so we don't pop after an animation interrupted it.
		m_fResetBreathe = false;
	}

	if (m_fPlayingMelee)
	{
		m_fPlayingMelee = false;
		m_fCanZoom = true;
	}

	if (FireMode[0] != None)
		FireMode[0].bWaitForAnim = false;
	if (FireMode[1] != None)
		FireMode[1].bWaitForAnim = false;
	if (FireMode[2] != None)
		FireMode[2].bWaitForAnim = false;
}

simulated function NotifyThirdPersonReloadFinished()
{	
	if ( bIsReloadingThirdPerson )
	{
		ClientState = WS_ReadyToFire;
		PlayIdle();
		ReloadClip();
		bIsReloadingThirdPerson = false;
	}
}

function ServerZoomInAnimEnd()
{
	Instigator.m_flEncumberance = m_flSiteEncumberance;
}

simulated function IncrementFlashCount(int Mode)
{
	Super.IncrementFlashCount( Mode );
	if (m_nAIWeaponBurstCount > 0)
	{
		m_nAIWeaponBurstCount--;
		if (m_nAIWeaponBurstCount == 0)
		{
			FireMode[0].bIsFiring = false;
			m_nAIWeaponBurstCount = -1;
		}
	}
}

// GBX:naj - added 9/3/03
simulated function ZeroFlashCount(int Mode)
{
	Super.ZeroFlashCount( Mode );
	m_nAIWeaponBurstCount = 0;
}

function Tick( float DeltaTime )
{
    local Controller C;

	if (Instigator != None)
		C = Instigator.Controller;

	Super.Tick( DeltaTime );

	if ( bIsReloadingThirdPerson && Level.TimeSeconds > NextPollThirdPersonReloadTime )
	{		
		if ( Instigator != None && Instigator.IsA( 'gbxPawn' ) && gbxPawn( Instigator ).IsReloadingThirdPerson() )
		{
			NextPollThirdPersonReloadTime = Level.TimeSeconds + 0.25;
		}
		else
		{
			NotifyThirdPersonReloadFinished();
		}
	}

	if (IsReloading())
	{
		m_nAIWeaponBurstCount = 0;
	}

	if (m_fAIWeaponWaitingToFire)
	{
//		StartFire(0);
		StartFiringWeapon();
//		m_fAIWeaponWaitingToFire = false;
	}
}

//----------------------------------------------------------------------
// GBX:PAD: Weapon interaction functions (e.g. fire, reload, check ammo)
//----------------------------------------------------------------------

// Start the character firing their weapon
function StartFiringWeapon()
{
    local Controller C;

	if (ClipAmt <= 0)
	{
			if (AlwaysAutoReload())	//-BB 
				ReloadWeapon();

			return;
	}

	C = Instigator.Controller;
	C.bFire = 1;
	C.bAltFire = 0;
	C.bMeleeFire = 0;

	BotMode = 0;
	FireMode[0].bWaitForRelease = false;		// GBX:PAD: Since this is AI, the concept of "semi-automatic" becomes a hinderance,
												// so for now turn this off
	FireMode[0].bNowWaiting = false;
    if ( !ReadyToFire(0) || ClientState != WS_ReadyToFire || ClientState == WS_Reloading )
	{
		m_fAIWeaponWaitingToFire = true;
		return;
	}

	m_fAIWeaponWaitingToFire = false;
    StartFire(0);
}

// Stop the character's firing their weapon
function StopFiringWeapon()
{
    local Controller C;

    C = Instigator.Controller;

	if (C != None)
	{
		C.bFire = 0;
		C.bAltFire = 0;
		C.bMeleeFire = 0;
	}

	// GBX:naj - added 8/26/03
	m_fAIWeaponWaitingToFire = false;
	m_nAIWeaponBurstCount = -1;
	// GBX:naj - end

	FireMode[0].bWaitForRelease = FireMode[0].Default.bWaitForRelease;		// GBX:PAD: Since this is AI, the concept of "semi-automatic" becomes a hinderance,
																			// so for now turn this off
	StopFire(0);
}

// Start the character firing a burst from their weapon
function FireWeaponBurst( int nNumShots )
{
	m_nAIWeaponBurstCount = min( nNumShots, ClipAmt );
	FireMode[0].ShotCount = 0;
	StartFiringWeapon();
}

function bool IsWeaponFiring()
{
	return ((m_nAIWeaponBurstCount > 0) || FireMode[0].bIsFiring);
}

// GBX:naj - added 9/23/03
simulated event StopFire(int Mode)
{
	m_nAIWeaponBurstCount = -1;
	m_fAIWeaponWaitingToFire = false;
	Super.StopFire( Mode );
}

// GBX:naj - added 11/20/03 - Overrides empty function in Weapon.uc.
function InvalidateBurst()
{
	m_nAIWeaponBurstCount = -1;
	m_fAIWeaponWaitingToFire = false;
	FireMode[0].bIsFiring = false;
}

simulated function ReloadWeapon()
{
	FireMode[0].PlayReloading();
}

function bool CanFireWeapon()
{
	if (Pawn(Owner).bIsSprinting && Pawn(Owner).IsMoving())
		return false;

	if ((ClipAmt > 0) && (ClientState == WS_ReadyToFire))
		return true;
		
	return false;
}

function bool BotFire(bool bFinished, optional name FiringMode)
{
	StartFiringWeapon();
	return true;
}

simulated function bool CanZoom()
{
	if (m_ZoomViewMesh == None)
	{
		return false;
	}
	return true;
}

function Rotator GetLastAimRotator()
{
	if ( FireMode[0] != None )
	{
		return FireMode[0].GetLastAimRotator();
	}
}
function float GetSuppressionMultiplier()
{
	if ( FireMode[0] != None )
	{
		if ( Level.Game.GameReplicationInfo.GameType != GT_MULTIPLAYER )
			return FireMode[0].SuppressionMultiplierSP;
		else
			return FireMode[0].SuppressionMultiplierMP;
	}
	else
	{
		return 1.0;
	}
}

function GetBestBurstCount( ESuppressionLevel SuppressionLevel, out int MinShots, out int MaxShots )
{
	FireMode[0].GetBestBurstCount( SuppressionLevel, MinShots, MaxShots );
}

function GetOpBurstCount( out int MinShots, out int MaxShots )
{
	FireMode[0].GetOpBurstCount( MinShots, MaxShots );
}

simulated function PlayIdle()
{
	local int nRandom, nIdle;

	if (ClientState != WS_ReadyToFire)
		return;

	if (IdleAnim[0] == '')  // can't play idle animations if there are none
		return;

	if (m_fZoomed)
	{
		nIdle = 0;
		PlayAnim(IdleAnim[0], IdleAnimRate, 0.2);
	}
	else
	{
		nIdle = 0;  // assume idle animation zero until known otherwise

		nRandom = Rand( 100 );
		if (nRandom <= 60)
			nIdle = 0;
		else if ((nRandom <= 90) && (IdleAnim[1] != ''))
			nIdle = 1;
		else if (IdleAnim[2] != '')
			nIdle = 2;

		PlayAnim(IdleAnim[nIdle], IdleAnimRate, 0.2);
	}

	if (m_fZoomed)
	{
		if (m_flFatigue == 0.0)
		{
//			if (m_fResetBreathe)
//				AnimBlendParams(1, 0.0);
//			else
//				AnimBlendParams(1, m_flNewFatigue);
//			LoopAnim(BreathingAnim, m_flNewFatigue, 0.1, 1);
//			SetAnimFrame( 0.0, 1 );		// Reset the breathing frame to 0 so we don't pop after an animation interrupted it.
		}
		else
		{
			AnimBlendToAlpha( 1, m_flNewFatigue, 0.0 );
		}
		m_flFatigue = m_flNewFatigue;
	}
}

simulated function CalcOffsetWeaponCollision()
{
//jlbzz
//jlbzz - OPTIMIZE ME!!!!
//jlbzz

	local vector X,Y,Z, vecStart;

	// -BB  
	// When we are doing a melee attack we suspend the Offset calculations but
	// we want to make the system think we are checking.  This is so that when the melee attack
	// ends we don't just snap into place.
	if(ClientState == WS_Melee)
	{
		m_flLastTraceTest = Level.TimeSeconds;
		flLastFireTime = Level.TimeSeconds;
		return;
	}
	// /BB

	GetAxes(Instigator.GetViewRotation(),X,Y,Z);
//	vecStart = Location;
//	vecStart.Z = GetFireStart(X, Y, Z).Z;
	vecStart = GetFireStart(X, Y, Z);

	OffsetWeaponCollision( vecStart, X, true );
//	OffsetWeaponCollision( Instigator.Location, X );

	if (m_fZoomed && (ClientState != WS_ZoomOut) )
	{
		m_flDrawOffset = 0.0f;
	}
}

simulated event RenderOverlays( Canvas Canvas )
{
	if ( gbxPawn(Instigator) != None && gbxPawn(Instigator).bAttachCamToHead )
		return;

	CalcOffsetWeaponCollision();

	Super.RenderOverlays( Canvas );
}

function SetNoDamageThisBullet()
{
	FireMode[0].SetNoDamageThisBullet();
}

function float GetPauseTimeExposed()
{
	return m_flPauseTimeExposed;
}

function bool CanShootDuringMelee() { return true; }

// GBX:PAD: Overriding Weapon.NextWeapon since we want to be able to switch to the weapon even if there is no ammo.
simulated function Weapon NextWeapon(Weapon CurrentChoice, Weapon CurrentWeapon)
{
    if ( (CurrentChoice == None) )
    {
        if ( CurrentWeapon != self )
            CurrentChoice = self;
    }
    else if ( InventoryGroup == CurrentChoice.InventoryGroup )
    {
        if ( InventoryGroup == CurrentWeapon.InventoryGroup )
        {
            if ( (GroupOffset > CurrentWeapon.GroupOffset)
                && (GroupOffset < CurrentChoice.GroupOffset) )
                CurrentChoice = self;
        }
        else if ( GroupOffset < CurrentChoice.GroupOffset )
            CurrentChoice = self;
    }

    else if ( InventoryGroup < CurrentChoice.InventoryGroup )
    {
        if ( (InventoryGroup > CurrentWeapon.InventoryGroup)
            || (CurrentChoice.InventoryGroup < CurrentWeapon.InventoryGroup) )
            CurrentChoice = self;
    }
    else if ( (CurrentChoice.InventoryGroup < CurrentWeapon.InventoryGroup)
            && (InventoryGroup > CurrentWeapon.InventoryGroup) )
        CurrentChoice = self;
        
    if ( Inventory == None )
        return CurrentChoice;
    else
        return Inventory.NextWeapon(CurrentChoice,CurrentWeapon);
}

simulated event bool TestForUseTarget( Actor aTarget, Vector aHitLoc, Vector aHitNormal )
{
	if (gbxPlayerController(Instigator.Controller) != None)
	{
		return gbxPlayerController(Instigator.Controller).TestForUseTargetHit( aTarget, aHitLoc, aHitNormal );
	}
	
	return false;
}

simulated function Timer()
{
	local int Mode;

	if (ClientState == WS_BringUp)
	{
		for( Mode = 0; Mode < NUM_FIRE_MODES; Mode++ )
		{
			if (FireMode[Mode] != None)
				FireMode[Mode].InitEffects();
		}
		WeaponAttachment( ThirdPersonActor ).SetupInstigatorProperties();
		ClientState = WS_ReadyToFire;
		PlayIdle(); // This must be after setting the client state!
		m_flLastTraceTest = Level.TimeSeconds;
		flLastFireTime = Level.TimeSeconds;
	}
    else if (ClientState == WS_PutDown)
    {
		ClientState = WS_Hidden;
		Instigator.ChangedWeapon();
		
		//for( Mode = 0; Mode < NUM_FIRE_MODES; Mode++ )
		//	FireMode[Mode].DestroyEffects();
		if (m_fDestroyAfterSwitch)
		{
			Destroy();
		}
    }
}

simulated function PlantGammonBombOnTarget();
simulated function RestockWeapon()
{
	if (Ammo[0] != None)
	{
		Ammo[0].AmmoAmount = max(Default.DefaultAmmoCount[0], Ammo[0].AmmoAmount);
		flAmmoFadeTime = 3.0f;
	}
}

function bool IsRocketLauncher()
{
	return false;
}

function bool IsBetterWeaponThan( gbxWeapon Other )
{
	return ( Desirability > Other.Desirability );
}

function bool RequiresSpecialMind( out class<gbxAIController> RequiredFC )
{
	return false;
}

function SetInstaKill( bool bInstaKill )
{
	if ( FireMode[0] != None )
		FireMode[0].SetInstaKill( bInstaKill );
}

//// client & server ////
simulated function bool StartFire(int Mode)
{
	if (Owner != None)
	{
		// Don't reload if we're holding down the command trigger.  Best I could do; the actual order stuff happens after
		// StartFire, because it's within the exec Fire function, which is called after the button detection that got us here.
		if( (Pawn(Owner) != None) && Pawn(Owner).IsHumanControlled() && NeedsToReload() )
		{
			if( PlayerController(Pawn(Owner).Controller).bLButton > 0 )
				return false;
		}

		if (bAimingAtFriendly && Owner.IsA('AnimPawn'))
		{
			bFiringAtFriendly = true;
		}
	}
	
	return Super.StartFire( Mode );
}
	
simulated function HolsterOnPawn(Pawn P, name BoneName)
{
	local name NewBoneName;

	// If the ThirdPersonActor is not set and we're a client in a multiplayer game, don't try to spawn this thing.
	if ((Level.NetMode == NM_Client) && (ThirdPersonActor == None))
	{
		return;
	}
	
	if ( ThirdPersonActor == None )
	{
		ThirdPersonActor = Spawn(AttachmentClass,Owner);
		InventoryAttachment(ThirdPersonActor).InitFor(self);
	}
	if (BoneName == '')
		NewBoneName = P.GetHolsterBoneFor(self);
	else
		NewBoneName = BoneName;
	if ( NewBoneName == '' )
	{
		ThirdPersonActor.SetLocation(P.Location);
		ThirdPersonActor.SetBase(P);
	}
	else
	{
		P.AttachToBone(ThirdPersonActor,NewBoneName);
	}
}

simulated function UnHolsterOnPawn(Pawn P, name BoneName)
{
	local name NewBoneName;

	// If the ThirdPersonActor is not set and we're a client in a multiplayer game, don't try to spawn this thing.
	if ((Level.NetMode == NM_Client) && (ThirdPersonActor == None))
	{
		return;
	}
	
	if ( ThirdPersonActor == None )
	{
		ThirdPersonActor = Spawn(AttachmentClass,Owner);
		InventoryAttachment(ThirdPersonActor).InitFor(self);
	}
	if (BoneName == '')
		NewBoneName = P.GetWeaponBoneFor(self);
	else
		NewBoneName = BoneName;
	if ( NewBoneName == '' )
	{
		ThirdPersonActor.SetLocation(P.Location);
		ThirdPersonActor.SetBase(P);
	}
	else
	{
		P.AttachToBone(ThirdPersonActor,NewBoneName);
	}
}

simulated function bool DisarmWeapon( name BoneName )
{
    local int Mode;

	Super.DisarmWeapon( BoneName );
	
    if (ClientState == WS_ReadyToFire)
    {
		HolsterOnPawn( Instigator, BoneName );
        if (Instigator.IsLocallyControlled())
        {
            for (Mode = 0; Mode < NUM_FIRE_MODES; Mode++)
            {
                if (FireMode[Mode].bIsFiring)
                    ClientStopFire(Mode);
            }

        }

		if (Instigator.IsA('gbxPawn'))
		{
			gbxPawn(Instigator).SetWeaponAnims( gbxPawn(Instigator).Default.PawnAnimInfoClass, false );
		}
        ClientState = WS_Disarmed;
        return true;
    }
    return false; // return false if preventing weapon switch
}

simulated function bool RearmWeapon( name BoneName )
{
	Super.RearmWeapon( BoneName );
	
    ClientState = WS_ReadyToFire;
    UnHolsterOnPawn( Instigator, BoneName );
	if (Instigator.IsA('gbxPawn') && ThirdPersonActor.IsA('gbxWeaponAttachment'))
	{
		gbxPawn(Instigator).SetWeaponAnims( gbxWeaponAttachment(ThirdPersonActor).PawnAnimInfoClass, true );
	}
    return true; // return false if preventing weapon switch
}

//NAC: added a DoAutoSwitch function in gbxWeapon so that we can take the player out of zoom mode when he does an autoswitch
simulated function DoAutoSwitch()
{
	local PlayerController pc;

	//NAC: if we are doing an auto switch and we are zooming, we need to make sure that we come out of zooming
	pc = PlayerController(Instigator.Controller);
	if (pc.isZoomed()){
		ForceUnZoom();
	}
    Instigator.Controller.SwitchToBestWeapon();
}
//NAC

simulated function LoadWeaponMesh()
{
	if (Level.NetMode == NM_StandAlone)
	{
		if (((Instigator != None) && (Instigator.m_fFingerMissing)) || Level.bHartsockWounded)
		{
			ExtendedAttachment( m_anExtendedActor, 'hands', 'hands_bandage' );
		}
		else
		{
			ExtendedAttachment( m_anExtendedActor, 'hands', 'hands' );
		}
	}
	else
	{
		ExtendedAttachment( m_anExtendedActor, 'hands', 'hands_MP' );
	}
}

function bool AmmoMatches( Weapon aWeapon )
{
//	return (gbxWeapon(aWeapon).AmmoName == AmmoName);
	// GBX:PAD: A bit of a hack, but since only US weapons have an ammo type, then just testing for AM_None means this
	// test will succeed for all US weapons.
	return (AmmoName != AM_Nothing);
}

simulated function CalcWeaponHitTest()
{
	local vector X,Y,Z, vecStart;
	
	GetAxes(Instigator.GetViewRotation(),X,Y,Z);
	vecStart = Location;
	vecStart.Z = GetFireStart(X, Y, Z).Z;
	OffsetWeaponCollision( vecStart, X, false, true );
}

simulated function ClientWeaponThrown()
{
	local gbxPlayerController	aPlayer;
	
	Super.ClientWeaponThrown();
	
	aPlayer = gbxPlayerController(Instigator.Controller);
	if (aPlayer != None)
	{
		// GBX:PAD: We should make sure to zoom out before throwing away the weapon.
		aPlayer.EndZoomLocal();
	}
        
	if( gbxWeaponAttachment(ThirdPersonActor) != None )
		gbxWeaponAttachment(ThirdPersonActor).DestroyEffectEmitters();
}

defaultproperties
{
//	Crosshair=texture'CHair1'
	Crosshair=None
	m_TestCrosshairs(0)=texture'crosshair_a'
	m_TestCrosshairs(1)=texture'crosshair_b'
	m_TestCrosshairs(2)=texture'crosshair_c'
	m_TestCrosshairs(3)=texture'crosshair_d'
	m_TestCrosshairs(4)=texture'crosshair_e'
	m_TestCrosshairs(5)=texture'crosshair_f'
	AdjustStep=1
	AdjustPerson=1
	TraceDist=+10000.0
	m_nAIWeaponBurstCount=-1
	
	// LCD Icons
	m_LCDAmmo=texture'Engine.LCD_Ammo'
	m_LCDClip=texture'Engine.LCD_Clip'
	
	
	WeaponBoneName=rifle_hold
	HolsterBoneName=rifle_hold

	ZoomFovMod = 35.00000
	m_flPauseTimeExposed=0.0

	BreathingAnim=breathe
	BreatheProfileClass=class'gbxBreatheProfile'
	
	m_fCanZoom=true
	m_flPctOffset=0.4
	m_flMinOffset=80.0

	bDamagesVehicles=false

	Desirability=1.0
	ZoomBobDamping=0.90
	flAmmoFadeTime = 3.0;  //NAC: added to initialize this variable
	MeleeStrikeCueName="PLAYER.MELEE"

	bThrowGrenadeLeftHanded=false
	MeleeSwooshCueName="PLAYER.MELEE_SWOOSH"

	WeaponName = WN_None
	
	bRenderAttachmentsFirst=true
	bRenderExtendedFirst=false
}
// ====================================================================
//  Class:  gbxWeaponAttachment
//
//  <Enter a description here>
//
// (c) 2001, Epic Games, Inc - All Rights Reserved
// ====================================================================

class gbxWeaponAttachment extends WeaponAttachment;

var vector			HitLoc;

// muzzle flash
var transient gbxMuzzleFlash			MuzFlash;
var class<ItemPawnAnimInfo>	PawnAnimInfoClass;
var class<gbxAmmo>			MyAmmoTypeClass;
var class<gbxMuzzleFlash>	MuzFlashClass;

// Ejected shells
var transient gbxWeaponShells			ShellEmitter;			// Instance of shell emitter object
var transient gbxBulletTracer			TracerEmitter;			// Instace of tracer emitter object
var int						TracerFrequency;

var bool					bUseTracers;
var bool					bNoShellCasings;
var bool					bFirstPersonTracers;

var float					LastFlashTime;
var float					MinFlashInterval;


const SHELL_CULL_DIST = 1000.0;			// Past a certain distance, don't bother firing shell emitters since they are too costly to be using when they can't be seen

replication
{
	// Things the server should send to the client.
	reliable if( bNetDirty && (Role==ROLE_Authority) )
		MyAmmoTypeClass, MuzFlashClass;
}

function DestroyEffectEmitters()
{
	if( ShellEmitter != None )
	{
		ShellEmitter.Destroy();
		ShellEmitter = None;
	}

	if( TracerEmitter != None )
	{
		TracerEmitter.Destroy();
		TracerEmitter = None;
	}

	if( MuzFlash != None )
	{
		MuzFlash.Destroy();
		MuzFlash = None;
	}
}

simulated event ThirdPersonEffects()
{
	local Vector MuzzleVec;
	//Log( " gbxWeaponAttachment::ThirdPersonEffects() FlashCount="$FlashCount$" FiringMode="$FiringMode$" MyAmmoTypeClass="$MyAmmoTypeClass, 'MP' );

	if (FlashCount==0)
		return;

	// have pawn play firing anim
	if ( Instigator != None )
	{

		switch( FiringMode )
		{
		case WEAP_StateFiring:
			Instigator.PlayFiring(1.0,FiringMode);
			break;
		case WEAP_StateMelee:
			Instigator.PlayMelee(FiringMode);
			break;
		case WEAP_StateReload:
			Instigator.PlayReload(FiringMode);
			break;
		case WEAP_StateThrow:
			Instigator.PlayThrow(FiringMode);
			break;
		case WEAP_StateDeploy:
			Instigator.PlayDeploy(FiringMode);
			break;
		case WEAP_StateHolster:
			Instigator.PlayHolster(FiringMode);
			break;
		default:
			Instigator.PlayFiring(1.0,FiringMode);
			break;
		}
	}

	if ((MyAmmoTypeClass != None) && (FiringMode == WEAP_StateFiring))
	{
		MuzzleVec = GetMuzzleLocationWorld();

		FlashMuzzleFlash( MuzzleVec );

		DoImpactEffects();

		if( (Instigator == None) || !Instigator.IsFirstPerson() )
		{
			// Third Person only effects

			if ((Instigator != None) && (Instigator.DrawType != DT_StaticMesh))
				EjectShell( GetChamberLocationWorld(), MyAmmoTypeClass.Default.AmmoShellClass );

			if( bUseTracers )
			{
				SendTracer( MuzzleVec, MyAmmoTypeClass.Default.BulletTracerClass );
			}
		}
		else
		{
			// First Person only effects

			if( bFirstPersonTracers )
			{
				SendTracer( MuzzleVec, MyAmmoTypeClass.Default.BulletTracerClass );
			}
			if (gbxAmmo(Instigator.Weapon.Ammo[0]) != None)
				gbxAmmo(Instigator.Weapon.Ammo[0]).ApplyKick();
		}
	}
}

// For debugging: tracer fire on every bullet.
function TracersOff()
{
	bUseTracers = false;
}
function TracersOn()
{
	bUseTracers = true;
}

simulated function FlashMuzzleFlash( Vector MuzzleLocation )
{
	//log( self$ " gbxWeaponAttachment::FlashMuzzleFlash() MuzzleTagName="$MuzzleTagName$" MuzFlashClass="$MuzFlashClass$" MuzFlash="$MuzFlash$" Instigator="$Instigator$" Instigator.Weapon="$Instigator.Weapon , 'MP' );
	
	if (MuzFlash == None)
	{
		if (Instigator.IsFirstPerson())
		{
			if (gbxWeapon(Instigator.Weapon) != None)
			{
				MuzFlash = gbxWeapon(Instigator.Weapon).GetMuzzleFlash();
                MuzFlash.DisableZTest();
                Instigator.Weapon.bRenderAttachmentsFirst = true;
			    Instigator.Weapon.AttachToBone( MuzFlash, ViewMuzzleTagName );
			}
		}
		else
		{
			MuzFlash = Spawn( MuzFlashClass );
			Instigator.AttachToBone( MuzFlash, MuzzleTagName );
		}
	}

	if (MuzFlash != None)
	{
		if( Level.TimeSeconds - LastFlashTime > MinFlashInterval )
		{
			MuzFlash.Flash();
			LastFlashTime = Level.TimeSeconds;
		}
	}
}

simulated function SendTracer( Vector Location, class<gbxBulletTracer> TracerClass )
{
	//Log( self$" gbxWeaponAttachment::SendTracer() Instigator="$Instigator$" Instigator.Weapon="$Instigator.Weapon$" Location="$Location$" TracerClass="$TracerClass$" FlashCount="$FlashCount$" TracerFrequency="$TracerFrequency$" TracerEmitter="$TracerEmitter, 'MP' );

	if ( FlashCount > 0 && (FlashCount % TracerFrequency ) == 0 )
	{
		// Create a tracer emitter object if need be, otherwise use the existing one
		if( TracerEmitter == None || TracerEmitter.Class != TracerClass )
		{
			// Changing tracer types
			if( TracerEmitter != None )
			{
				TracerEmitter.Destroy();
				TracerEmitter = None;
			}

			if ( Instigator.Weapon != None )
			{
				//Log( self$" gbxWeaponAttachment::SendTracer() Instigator.Weapn != None so spawning trace emitter with weapon as owner.", 'MP' );
			TracerEmitter = Spawn(TracerClass, Instigator.Weapon);
		}
			else
			{
				//Log( self$" gbxWeaponAttachment::SendTracer() Instigator.Weapn == NONE so spawning trace emitter with instigator as owner!!!!! Instigator.Location="$Instigator.Location, 'MP' );
				TracerEmitter = Spawn(TracerClass, Instigator);
				
			}
		}

		// Emit a tracer
		if( (TracerEmitter != None) && (gbxPawn(Instigator) != None) )
		{
			//Log( self$" gbxWeaponAttachment::SendTracer() 4 Calling TriggerEmitters() Location="$Location$" gbxPawn(Instigator).LastAimRotator="$gbxPawn(Instigator).LastAimRotator, 'MP' );
			TracerEmitter.TriggerEmitters( Location, gbxPawn(Instigator).LastAimRotator );
	}
}
}

simulated function bool EjectShell( Vector Location, class<gbxWeaponShells> ShellClass )
{
	local	PlayerController	aPlayer;
	local	float			flDist;
	local	int				nNum;
	
	if ( bNoShellCasings )
		return false;

	// GBX:PAD: No player is looking at the owner of this gun anyway, so don't bother ejecting shells.
	if ( (Instigator != None) && !Instigator.IsFirstPerson() && !Instigator.PlayerCanSeeMe() )
	{
		return false;
	}
	
	if (Level.PlayerControllerList != None)
	{
		nNum = 0;
		for( aPlayer = Level.PlayerControllerList; aPlayer != None; aPlayer = aPlayer.nextPlayerController )
		{
			flDist = VSize(aPlayer.Pawn.Location - Location);
			if (flDist < SHELL_CULL_DIST)
			{
				nNum++;
				break;
			}
		}
	}
	
	// There is no local player close enough to reasonably see this shell, so don't bother ejecting it.
	if (nNum == 0)
	{
		return false;
	}
	
	// Create the shell emitter object if need be, otherwise use the existing one
	if( ShellEmitter == None || ShellEmitter.Class != ShellClass )
	{
		// Changing shell types
		if( ShellEmitter != None )
		{
			ShellEmitter.Destroy();
			ShellEmitter=None;
		}

//		ShellEmitter = Spawn(ShellClass, Instigator.Weapon);
		// GBX:PAD: Since Weapon does not exist on clients in a network game, see if this will work as the owner.
		ShellEmitter = Spawn(ShellClass, Instigator);
	}

	// Eject a shell
	if( ShellEmitter != None )
	{
		ShellEmitter.TriggerEmitters( Location, Instigator.Rotation );
	}
	
	return true;
}

// GBX:naj - added 4/27/03 - Dirty hack to avoid dangling pointer that occurs with Emitters when they autodestroy.
simulated function ShellsDestroyed() {}
simulated function ClipDestroyed() {}
// GBX:naj - end added 4/27/03

//*********************************************************
// InitFor
//*********************************************************
function InitFor(Inventory I)
{
	Instigator = I.Instigator;
}


//*********************************************************
//	SetGun
//*********************************************************
simulated function SetAmmoType(class<Ammunition> NewAmmoTypeClass, class<Emitter> NewMuzzleFlashClass)
{
	MyAmmoTypeClass = class<gbxAmmo>(NewAmmoTypeClass);
	MuzFlashClass = class<gbxMuzzleFlash>(NewMuzzleFlashClass);
}

//*********************************************************
//	SetupInstigatorProperties
//*********************************************************
simulated function SetupInstigatorProperties()
{
	local gbxPawn gbxP;
	if ( Instigator.IsA( 'gbxPawn' ) )
	{
		gbxP = gbxPawn(Instigator);
		gbxP.SetWeaponAnims( PawnAnimInfoClass, gbxP.IsOkayToUnlink() );
	}
}

defaultproperties
{
	bFirstPersonTracers=false
	bUseTracers=false
	TracerFrequency=1
	MinFlashInterval=0.2
}
class gbxWeaponPickup extends WeaponPickup
	abstract;



enum WeaponType
{
	WeaponPrimary,
	WeaponSecondary,
	WeaponTrophy,
	WeaponHidden
};

const WAIT_FOR_PICKUP_TIME = 1.0;
const DROP_CUE_PLAY_INTERVAL = 0.5;
const KARMA_ATREST_TIME = 2.0;

const MP_DROPPED_WEAPON_MIN_SECONDS_BEFORE_DISAPPEAR = 65;

var() WeaponType	m_eWeaponType;		// What active mode is the hud in now?
var() Pawn			m_aTouchPawn;		// What is the pawn we were last touching?
var() bool			bDisabled;
var bool			bInWater;
var float			m_flLastOwned;

var float			NextDropCuePlayTime;
var Cue				DropCue;
var String			DropCueName;
var Cue				DropWaterCue;
var String			DropWaterCueName;
var float			AtRestStartTime;

simulated function PreBeginPlay()
{
	Super.PreBeginPlay();

	if (Level.NetMode != NM_Standalone)
	{
		SetCollisionSize(10.0f, CollisionHeight);
	}
}

simulated function PostLoadGame()
{
	Super.PostLoadGame();

	// It's a bit silly, but if this weapon was placed by the mapper, we need to adjust the collision size back up
	// so that the player can pick it up easily.  This is silly because we're essentially shrinking this thing, then
	// re-expanding it in single player map placed drops.
	SetCollisionSize(default.CollisionRadius, CollisionHeight);
}

/* CheckIfPickupValid()
	Verify that this item can actually be picked up
*/
function bool CheckIfPickupValid( Pawn Other )
{
	local Weapon	aWeapon;  //NAC added 
	local int		nCount;
	local Inventory	anInv;

	if ((m_flLastOwned + WAIT_FOR_PICKUP_TIME) > Level.TimeSeconds)
		return false;

	// SJP: We allow pickup if you've already got the weapon (for more ammo)
	if ( Weapon(Other.FindInventoryType(InventoryType) ) != none )
	{
		//// NAC: If we have full ammo, don't pick it up
		aWeapon = Weapon(Other.FindInventoryType(InventoryType) );
		if (aWeapon.Ammo[0].AmmoAmount == aWeapon.Ammo[0].MaxAmmo)
			return false;
		return true;
	}

	if (m_eWeaponType == WeaponPrimary)
	{
		nCount = 0;
		anInv = Other.Inventory;
		while (anInv != None)
		{
			if (gbxWeapon(anInv) != None)
				if (gbxWeapon(anInv).m_eWeaponType == WeaponPrimary)
					nCount++;
			anInv = anInv.Inventory;
		}
//		aWeapon = Other.Inventory.NextWeapon( None, Other.Weapon );
//		if ((m_eWeaponType == WeaponPrimary) && ((aWeapon != None) && (Other.Weapon != None)))
//			return false;
		if (nCount >= 2)
			return false;
	}

	if (m_eWeaponType == WeaponTrophy)
		return false;

	return true;
}

/* SJP - this override broke WeaponStay in a bad way
function StartSleeping()
{
    GotoState('Sleeping');
}
*/

event KVelDropBelow()
{
	AtRestStartTime = Level.TimeSeconds;	
}

event KImpact( actor other, vector pos, vector impactVel, vector impactNorm )
{
	Super.KImpact( other, pos, impactVel, impactNorm );

	// Log( "****SJP: "$Name: BIA15_PC $":Kimpact() actor = "$other$", pos = "$pos$", impactNorm = "$impactNorm$" ("$VSize(impactVel)$")", 'SJP' );

	if( Level.TimeSeconds > NextDropCuePlayTime && DropCueName != "" )
	{
		if( DropCue == None )
		{
			DropCue = LoadSound( DropCueName );
		}

		if( DropCue != None )
		{
			PlaySoundCue( DropCue, SLOT_None );
		}

		NextDropCuePlayTime = Level.TimeSeconds + DROP_CUE_PLAY_INTERVAL;
	}
}

function InitDroppedPickupFor(Inventory Inv)
{
	Super.InitDroppedPickupFor( Inv );

	SetPhysics(PHYS_Falling);

	bAlwaysRelevant = false;
	bOnlyReplicateHidden = false;
	bUpdateSimulatedPosition = true;
    bDropped = true;
	bIgnoreEncroachers=false; // handles case of dropping stuff on lifts etc
	NextDropCuePlayTime = 0.25; // Delay the sound so it doesn't play if we collide with the actor that dropped it 

	m_flLastOwned = Level.TimeSeconds;
	
	//SDJ 07/09/2004: In MP we need dropped weapon's to disappear after a while.
	if (Level.NetMode == NM_StandAlone)
	{
		LifeSpan = 0;
	}
	else
	{
		LifeSpan = MP_DROPPED_WEAPON_MIN_SECONDS_BEFORE_DISAPPEAR;
	}
	
	bFixedRotationDir=false;
	bRotatetoDesired=false;
	Velocity = Inv.Velocity;
	//RotationRate = Inv.RotationRate;
	RotationRate.Yaw = 0;
	RotationRate.Pitch = 0;
	RotationRate.Roll = 0;
//	DesiredRotation.Yaw = Rotation.Yaw + (Rand(16000) - 8000);
	DesiredRotation.Yaw = 0;
	DesiredRotation.Pitch = 0;
	DesiredRotation.Roll = 0;
	
	AtRestStartTime = 0.0;
}

event Landed(vector HitLocation, Vector HitNormal)
{
	Super.Landed(HitLocation, HitNormal);

//	if (Level.NetMode != NM_Standalone)
//	{
		SetCollisionSize(default.CollisionRadius, CollisionHeight);
//	}
}

//=============================================================================
// Pickup state: this inventory item is sitting on the ground.

auto state Pickup
{
	// When touched by an actor.
	simulated function Touch( actor Other )
	{
		local PlayerController		aController;
		local bool					fState;
		local Weapon				AlreadyHas;

		local Inventory Copy;

		if (Other == None)
			return;

		//DHW + -- Added to supress pickup messages while mounted on a turret
		//      -- If you are a pawn and you are manning the turrent or preparing to mount the turret
		//      -- then bail out early and set your primary weapon select to false to dispell messages
		if (Other.IsA('gbxPawn') && 
			(gbxPawn(Other).bIsManningTurret || gbxPawn(Other).bHasStartedMountAnim))
		{	
			gbxPawn(Other).m_fPrimaryWeaponSelect = false;
			return;
		}
		//DHW -


		if (Pawn(Other) != None)
		{
			// This fix's problems when multiple players are touching the same weapon.
			// Only one player can be the m_aTouchPawn at a time.
			if (m_aTouchPawn != Pawn(Other))
				UnTouch(m_aTouchPawn);
			m_aTouchPawn = Pawn(Other);
		}
		
		//DHW + -- Throw out the weapon if the pawn has signaled that they wish to do so.  The throw is in 
		//      -- the touch to make sure the two operations (throw & pickup) are atomic.
		if (AnimPawn(Other).bthrowWeapon > 0.0f)
		{
			gbxPlayerController(Pawn(Other).controller).ServerThrowWeapon();
			AnimPawn(Other).bthrowWeapon = 0.0f;
		}
		//DHW -

		if (Level.NetMode != NM_Client)
		{
			if (m_aTouchPawn != None)
				AlreadyHas = Weapon(m_aTouchPawn.FindInventoryType(InventoryType));
			else
				AlreadyHas = None;

			// If touched by a player pawn, let him pick this up.
			if( (AlreadyHas != None) || ValidTouch(Other) )
			{
				if (Pawn(Other) != None && ValidTouch(Other) )
				{
					Copy = SpawnCopy(Pawn(Other));
					if (Copy != None)
					{
						AnnouncePickup(Pawn(Other));
						SetRespawn();
						Copy.PickupFunction(Pawn(Other));
					}
					else
					{
						log("Unable to create copy of pickup weapon!");
					}
				}
				fState = false;
			}
			else
				fState = true;
		}

		if (m_aTouchPawn != None)
		{
			aController = PlayerController(m_aTouchPawn.Controller);
			if (aController != None)
			{			
				if ((m_eWeaponType == WeaponPrimary) && (aController.myHUD != None))
				{
					if (Level.NetMode != NM_Client)
					{
						gbxPawn(Other).m_fPrimaryWeaponSelect = fState;				
					}

					//DHW+ -- Added a blocking check so that only the first weapon touched updates the name field
					if (!gbxPawn(Other).bhasWeaponName)
					{
						gbxPawn(Other).m_szWeaponName = default.PickupName;
						gbxPawn(Other).bhasWeaponName = true;
					}
					//DHW-
				}
				else if ((m_eWeaponType == WeaponTrophy) && (aController.myHUD != None))
				{			
					if (Level.NetMode != NM_Client)
					{
						gbxPawn(Other).m_fTrophySelect = fState;
					}
				}
			}
		}
	
	}

	// When touched by an actor.
	function UnTouch( actor Other )
	{
		local PlayerController	 aController;

		Super.UnTouch( Other );

		// Only if the actor untouching is the current m_aTouchPawn
		if (Other != m_aTouchPawn)
			return;

		if (Pawn(Other) != None)
			m_aTouchPawn = None;

		if (Pawn(Other) != None)
		{
			aController = PlayerController(Pawn(Other).Controller);

			if (aController != None)
			{
				if (m_eWeaponType == WeaponPrimary)
					gbxPawn(Other).m_fPrimaryWeaponSelect = false;
				else if (m_eWeaponType == WeaponTrophy)
					gbxPawn(Other).m_fTrophySelect = false;
			}
		}
	}

	function Tick(float DeltaTime)
	{
		// Disable this pickup item before we are destroyed.
		if( LifeSpan != 0.f && LifeSpan <= 5.0f )
		{
			if( m_aTouchPawn != None )
			{
				UnTouch( m_aTouchPawn );
			}

			GotoState( 'AboutToDie' );
		}
		else
		{
			if (m_aTouchPawn != None)
			{
				Touch( m_aTouchPawn );
			}
		}
	}

	//DHW + -- This code is intended to make machine guns black holes for weapon drops
	//      -- It has been temporarily removed pending the suppress message fix
	//function BeginState()
	//{
	//	local gbxContextUseTrigger T;

	//	if ( bDropped )
 //       {
	//		foreach AllActors( class'gbxContextUseTrigger', T )
	//		{
	//			if ( T.m_eUseType == UseMG42 && VSizeIgnoreZ( Location - T.Location ) <= T.CollisionRadius )
	//				GotoState('FadeOut');
	//		}
	//	}
	//}
	//DHW -

	function BeginState()
	{
		Super.BeginState();
		// BB - Check to see if the weapon is already in water when it is thrown
		if(PhysicsVolume.bWaterVolume)
			bInWater=true;
	}


	function Timer()
	{
	}
}

state FallingPickup
{
	function Tick( float DeltaTime )
	{
		local PhysicsVolume V;
		local Vector HitLoc, HitNormal;

		Super.Tick( DeltaTime );
		
		// BB - If the weapon falls into a water volume spawn the ripple at the top
		//		of the volume and play the sound.

		if(!bInWater)
		{
			ForEach TouchingActors(class'PhysicsVolume',V)
			{
				if ( V.bWaterVolume )
				{
					//PlaySound(WaterStep, SLOT_Interact, 1, false, 75.0, 1.0);
					
					//Create water ring at the top of the water volume
					if(!V.TraceThisActor(HitLoc, HitNormal,Location, Location+500*vect(0,0,1.0)))
					{
							if( DropWaterCue == None )
							{
								DropWaterCue = LoadSound( DropWaterCueName );
							}

							if( DropWaterCue != None )
							{
								PlaySoundCue( DropWaterCue, SLOT_None );
							}


							Spawn(class'gbxEffects.WaterSplashLarge',,,HitLoc,rot(16384,0,0));
							bInWater=true;
					}
				}
			
			}
		
		}
		// -BB

		// Detect when we're at rest after karma simulation.  For non-karma (MP) mode, see Engine.Pickup.Landed().
		if( AtRestStartTime > 0.0 )
		{
			if( Level.TimeSeconds - AtRestStartTime > KARMA_ATREST_TIME )
			{
				// Log( "****SJP: "$Self.Name:  $" Now at rest, moving to the 'Pickup' state.", 'SJP' );
				SetPhysics( PHYS_None );
				GotoState( 'Pickup' );
			}
		}
	}
}

state AboutToDie
{
	function BeginState()
	{
		Super.BeginState();
		bHidden = true;
	}
	function Timer(){}
	function Touch( Actor other ){}
	function UnTouch( Actor other ){}
}

function float PlaySpawnEffect()
{
// GBX:PAD: Removing EnhancedReSpawn effect script
//	spawn( class 'EnhancedReSpawn',self,, Location );
	return 0.3;
}

function PickupItem( Pawn aPawn )
{
	local Inventory Copy;

	Copy = SpawnCopy(aPawn);
	AnnouncePickup(aPawn);
    SetRespawn();
	Copy.PickupFunction(aPawn);
}

event Trigger(actor Other, Pawn EventInstigator)
{
	bDisabled = !bDisabled;
}

function AddPhysics( Pawn LastOwner, optional vector StartingVelocity )
{
	// This is not the epitomy of elegance, but by building a new KarmaParms object in defaultproperties,
	// we were experiencing random crashes when the pickup object was created.  Creating the new KarmaParams
	// object here seems to have licked that problem.  I'll take fugliness over crashing anyday.
	KParams = new(Self,"PickupKarmaParams")class'KarmaParams';

	if( KParams != None && KarmaParams(KParams) != None )
	{
		KarmaParams(KParams).KMass=1.0;
		KarmaParams(KParams).KStartEnabled=false;
	        KarmaParams(KParams).bHighDetailOnly=false;
	        KarmaParams(KParams).KFriction=0.75000;
	        KarmaParams(KParams).KRestitution=0.0; //0.020000;
		KarmaParams(KParams).bKStayUpright=false;
		KarmaParams(KParams).KLinearDamping=0.2;
		KarmaParams(KParams).KAngularDamping=0.6; //0.25
		KarmaParams(KParams).KVelDropBelowThreshold=5.0;
		KarmaParams(KParams).KImpactThreshold=100.0;
		KarmaParams(KParams).KBuoyancy=0.2;
		KarmaParams(KParams).bDoSafeTime=true;
		KarmaParams(KParams).KStartLinVel = StartingVelocity;
		KarmaParams(KParams).KStartAngVel = Normal( Location - (LastOwner.Location + LastOwner.EyePosition()) ) * 256.0;
		KarmaParams(KParams).bKNonSphericalInertia=false;

		bCollideWorld = False;

		SetPhysics(PHYS_Karma);

		KWake();
	}
}

// GBX:SJP: need to clear the m_aTouchPawn when the weapon goes to sleep, otherwise if weapon respawn is true, the weapon will be automatically picked up by the Tick()
// function in 'state Pickup', regardless of where the weapon is in the world.
State Sleeping
{
	function BeginState()
	{
		m_aTouchPawn = None;
		bHidden = true;
	}
}

defaultproperties
{
	CollisionRadius=+0075.000000
	CollisionHeight=+008.000000

	MessageClass=class'PickupMessagePlus'
	Physics=PHYS_None

	bDisabled=false

	DropCueName="GEAR.DROPRIFLE"
	DropWaterCueName="IMPACTS.SPLASH_LARGE"
	NextDropCuePlayTime=0.0

	bProjTarget=True
	bBlockActors=false
	bBlockPlayers=False
	bWorldGeometry=False
	bBlockKarma=true
	bCollideActors=true
	bCollideWorld=True
}
//*********************************************************
// gbxWeaponShells.uc
//
// Author: Stephen Palmer
// 9/20/2003
//
// Base class for weapon shell objects.  Emitters that produce
// a shell casing for a specific weapon or weapon type.
//
//*********************************************************
class gbxWeaponShells extends gbxRepeatableEmitter
	transient;



function Destroyed() {

	if (Owner.IsA('gbxWeapon'))
		gbxWeapon(Owner).ShellsDestroyed();
	else
	if (Owner.IsA('gbxWeaponAttachment'))
		gbxWeaponAttachment(Owner).ShellsDestroyed();

	Super.Destroyed();
}

defaultproperties
{
	bNoDelete=false
    RemoteRole=ROLE_None
	bUnlit=true
	Mass=+4.0
	PlaySoundPct = .4
}
//-----------------------------------------------------------
//
//-----------------------------------------------------------
class gbxWheeledCraft extends gbxSVehicle
	abstract
	native
	nativereplication;

//#exec OBJ LOAD FILE=..\textures\InterfaceContent.utx
//#exec OBJ LOAD FILE=..\textures\HudContent.utx

cpptext
{
	INT* GetOptimizedRepList(BYTE* Recent, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel);

#ifdef WITH_KARMA
	// Actor interface.
	virtual UBOOL Tick(FLOAT DeltaTime, enum ELevelTick TickType);
	virtual void preKarmaStep(FLOAT DeltaTime);
	virtual void PostNetReceive();

	// SVehicle interface.
	virtual void UpdateVehicle(FLOAT DeltaTime);

	// SCar interface.
	virtual void ProcessCarInput();
	virtual void ChangeGear(UBOOL bReverse);
	virtual void PackState();
#endif
}

// wheel params
var()	float			WheelSoftness;
var()	float			WheelPenScale;
var()	float			WheelPenOffset;
var()	float			WheelRestitution;
var()	float			WheelAdhesion;
var()	float			WheelInertia;
var()	InterpCurve		WheelLongFrictionFunc;
var()	float			WheelLongSlip;
var()	InterpCurve		WheelLatSlipFunc;
var()	float			WheelLongFrictionScale;
var()	float			WheelLatFrictionScale;
var()	float			WheelHandbrakeSlip;
var()	float			WheelHandbrakeFriction;
var()	float			WheelSuspensionTravel;
var()	float			WheelSuspensionOffset;
var()	float			WheelSuspensionMaxRenderTravel;

var()	float			ChassisTorqueScale;
var()	float			MinBrakeFriction;

var()	InterpCurve		MaxSteerAngleCurve; // degrees based on velocity
var()	InterpCurve		TorqueCurve; // Engine output torque
var()	float			GearRatios[5]; // 0 is reverse, 1-4 are forward
var()	int				NumForwardGears;
var()	float			TransRatio; // Other (constant) gearing
var()	float			ChangeUpPoint;
var()	float			ChangeDownPoint;
var()	float			LSDFactor;

var()	float			EngineBrakeFactor;
var()	float			EngineBrakeRPMScale;

var()	float			MaxBrakeTorque;
var()	float			SteerSpeed; // degrees per second
var()	float			TurnDamping;

var()	float			StopThreshold;
var()	float			HandbrakeThresh;

var()	float			EngineInertia; // Pre-gear box engine inertia (racing flywheel etc.)

var()	float			IdleRPM;
var()	float			EngineRPMSoundRange;

var()	name			SteerBoneName;
var()	EAxis			SteerBoneAxis;
var()	float			SteerBoneMaxAngle; // degrees

// Wheel dirt emitter
var     array<Emitter>    Dust; // FL, FR, RL, RR
var()   float                       DustSlipRate; // Ratio between dust kicked up and amount wheels are slipping
var()   float                       DustSlipThresh;

// Internal
var		float			OutputBrake;
var		float			OutputGas;
var		bool			OutputHandbrake;
var		int				Gear;

var		float			ForwardVel;
var		bool			bIsInverted;
var		bool			bIsDriving;
var		float			NumPoweredWheels;

var		float			TotalSpinVel;
var		float			EngineRPM;
var		float			CarMPH;
var		float			ActualSteering;

// Rev meter
var		material		RevMeterMaterial;
var()	float			RevMeterPosX;
var()	float			RevMeterPosY;
var()	float			RevMeterScale;
var()	float			RevMeterSizeY;

// Brake lights
var()	bool				bMakeBrakeLights;
var()	vector				BrakeLightOffset[2];
//jlbvar		ONSBrakelightCorona	BrakeLight[2];
var()	Material			BrakeLightMaterial;

// Stunts
var		rotator				OldRotation;
var		vector				LastOnGroundLocation;
var		float				LastOnGroundTime;

var		float				InAirSpin; // Degrees
var		float				InAirPitch; // Degrees
var		float				InAirRoll; // Degrees
var		float				InAirTime; // Seconds
var		float				InAirDistance; // Meters

var		int					DaredevilPoints;

var()	float				DaredevilThreshInAirSpin;
var()	float				DaredevilThreshInAirPitch;
var()	float				DaredevilThreshInAirRoll;
var()	float				DaredevilThreshInAirTime;
var()	float				DaredevilThreshInAirDistance;
var()	class<LocalMessage>	DaredevilMessageClass;

struct native SCarState
{
	var vector				ChassisPosition;
	var Quat				ChassisQuaternion;
	var vector				ChassisLinVel;
	var vector				ChassisAngVel;

	var byte				ServerHandbrake;
	var byte				ServerBrake;
	var byte				ServerGas;
	var byte				ServerGear;
	var	byte				ServerSteering;
	var int                 ServerViewPitch;
	var int                 ServerViewYaw;
};

var		SCarState			CarState, OldCarState;
var		KRigidBodyState		ChassisState;
var		bool				bNewCarState;

var		bool				bOldVehicleOnGround;
var()	bool				bDoStuntInfo;
var()	bool				bAllowAirControl;
var()	bool				bAllowChargingJump;
var		bool				bAllowBigWheels;

// Jumping
var	bool				    bPushDown; //jump is being charged

var()	float				MaxJumpForce;
var     float               JumpForce;

var()	float				MaxJumpSpin;
var	    float               JumpSpin;

var()	float				JumpChargeTime;
var     float				DesiredJumpForce; //used by AI
var     string				JumpFeedbackForce;

var		sound				JumpSound;

var()	float				JumpMeterOriginX, JumpMeterOriginY;
var()	float				JumpMeterWidth, JumpMeterHeight, JumpMeterSpacing;
var()	color				JumpMeterColor, SpinMeterColor;
var     Texture				JumpMeterTexture;

// Air control
var		float				OutputPitch;
var()	float				AirTurnTorque;
var()	float				AirPitchTorque;
var()	float				AirPitchDamping; // This is on even if bAllowAirControl is false.
var()	float				AirRollTorque;
var()	float				AirRollDamping;
var()	float				MinAirControlDamping; // To limit max speed you can spin/flip at.

var     float				FenderBenderSpeed;

replication
{
	reliable if (Role == ROLE_Authority)
		CarState;
	reliable if (bNetInitial && Role == ROLE_Authority)
		bAllowAirControl, bAllowChargingJump;
	reliable if (bNetInitial && bAllowChargingJump && Role == ROLE_Authority)
		JumpChargeTime, MaxJumpForce, MaxJumpSpin;
	reliable if (bNetInitial && bDoStuntInfo && Role == ROLE_Authority)
		DaredevilThreshInAirDistance, DaredevilThreshInAirTime, DaredevilThreshInAirSpin, DaredevilThreshInAirPitch, DaredevilThreshInAirRoll;
}
///////////////////////////////////////////
/////////////// CREATION //////////////////
///////////////////////////////////////////

simulated function PostNetBeginPlay()
{
    local int i;

	// Count the number of powered wheels on the car
	NumPoweredWheels = 0.0;
	for(i=0; i<Wheels.Length; i++)
	{
		NumPoweredWheels += 1.0;
	}

    Super.PostNetBeginPlay();
}

simulated function Destroyed()
{
    local int i;

	if(Level.NetMode != NM_DedicatedServer)
	{
        for(i=0; i<Dust.Length; i++)
            Dust[i].Destroy();

/*jlb
	   if(bMakeBrakeLights)
	   {
            if (BrakeLight[0] != None)
				BrakeLight[0].Destroy();

            if (BrakeLight[1] != None)
				BrakeLight[1].Destroy();
	   }
jlb*/
	}

    Super.Destroyed();
}

///////////////////////////////////////////
/////////////// NETWORKING ////////////////
///////////////////////////////////////////


simulated event bool KUpdateState(out KRigidBodyState newState)
{
	// This should never get called on the server - but just in case!
	if(Role == ROLE_Authority || !bNewCarState)
		return false;

	newState = ChassisState;
	bNewCarState = false;

	return true;
	//return false;
}

///////////////////////////////////////////
////////////////// OTHER //////////////////
///////////////////////////////////////////

simulated event SVehicleUpdateParams()
{
	local int i;

	Super.SVehicleUpdateParams();

	for(i=0; i<Wheels.Length; i++)
	{
		Wheels[i].Softness = WheelSoftness;
		Wheels[i].PenScale = WheelPenScale;
		Wheels[i].PenOffset = WheelPenOffset;
		Wheels[i].LongSlip = WheelLongSlip;
		Wheels[i].LatSlipFunc = WheelLatSlipFunc;
		Wheels[i].Restitution = WheelRestitution;
		Wheels[i].Adhesion = WheelAdhesion;
		Wheels[i].WheelInertia = WheelInertia;
		Wheels[i].LongFrictionFunc = WheelLongFrictionFunc;
		Wheels[i].HandbrakeFrictionFactor = WheelHandbrakeFriction;
		Wheels[i].HandbrakeSlipFactor = WheelHandbrakeSlip;
		Wheels[i].SuspensionTravel = WheelSuspensionTravel;
		Wheels[i].SuspensionOffset = WheelSuspensionOffset;
		Wheels[i].SuspensionMaxRenderTravel = WheelSuspensionMaxRenderTravel;
	}

	if(Level.NetMode != NM_DedicatedServer && bMakeBrakeLights)
	{
/*jlb
		for(i=0; i<2; i++)
		{
            if (BrakeLight[i] != None)
            {
				BrakeLight[i].SetBase(None);
				BrakeLight[i].SetLocation( Location + (BrakelightOffset[i] >> Rotation) );
				BrakeLight[i].SetBase(self);
				BrakeLight[i].SetRelativeRotation( rot(0,32768,0) );
				BrakeLight[i].Skins[0] = BrakeLightMaterial;
			}
		}
jlb*/
	}
}

simulated event DrivingStatusChanged()
{
	local int i;
//jlb	local Coords WheelCoords;

	Super.DrivingStatusChanged();

    if (bDriving && Level.NetMode != NM_DedicatedServer && !bDropDetail)
	{
/*jlb
        Dust.length = Wheels.length;
        for(i=0; i<Wheels.Length; i++)
            if (Dust[i] == None)
            {
        		// Create wheel dust emitters.
        		WheelCoords = GetBoneCoords(Wheels[i].BoneName);
        		Dust[i] = spawn(class'ONSDirtSlipEffect', self,, WheelCoords.Origin + ((vect(0,0,-1) * Wheels[i].WheelRadius) >> Rotation));
        		Dust[i].SetBase(self);
			    Dust[i].SetDirtColor( Level.DustColor );
        	}
jlb*/

/*jlb
		if(bMakeBrakeLights)
		{
			for(i=0; i<2; i++)
    			if (BrakeLight[i] == None)
    			{
    				BrakeLight[i] = spawn(class'ONSBrakelightCorona', self,, Location + (BrakeLightOffset[i] >> Rotation) );
    				BrakeLight[i].SetBase(self);
    				BrakeLight[i].SetRelativeRotation( rot(0,32768,0) ); // Point lights backwards.
    				BrakeLight[i].Skins[0] = BrakeLightMaterial;
    			}
		}
jlb*/
	}
    else
    {
        if (Level.NetMode != NM_DedicatedServer)
    	{
            for(i=0; i<Dust.Length; i++)
                Dust[i].Destroy();

            Dust.Length = 0;

/*jlb
            if(bMakeBrakeLights)
            {
            	for(i=0; i<2; i++)
                    if (BrakeLight[i] != None)
                        BrakeLight[i].Destroy();
            }
jlb*/
        }

        TurnDamping = 0.0;
    }
}

simulated function Tick(float dt)
{
//jlb    local int i;
    local bool lostTraction;

    Super.Tick(dt);

 	// Dont bother doing effects on dedicated server.
	if(Level.NetMode != NM_DedicatedServer && !bDropDetail)
	{
		lostTraction = true;

   		// Update dust kicked up by wheels.
//jlb   		for(i=0; i<Dust.Length; i++)
//jlb	   	   Dust[i].UpdateDust(Wheels[i], DustSlipRate, DustSlipThresh);

/*jlb
		if(bMakeBrakeLights)
		{
			for(i=0; i<2; i++)
                if (BrakeLight[i] != None)
                    BrakeLight[i].bCorona = True;

			for(i=0; i<2; i++)
                if (BrakeLight[i] != None)
                    BrakeLight[i].UpdateBrakelightState(OutputBrake, Gear);
		}
jlb*/
	}

	TurnDamping = default.TurnDamping;
}

function bool Dodge(eDoubleClickDir DoubleClickMove)
{
	if (bAllowChargingJump)
	{
		Rise = -1;
		return true;
	}

	return false;
}

simulated event KImpact(Actor Other, vector Pos, vector ImpactVel, vector ImpactNorm)
{
	Super.KImpact(Other, Pos, ImpactVel, ImpactNorm);

//jlb	if ( gbxWheeledCraft(Other) != None && gbxWheeledCraft(Other).bDriving && PlayerController(Controller) != None
//jlb	     && gbxWheeledCraft(Other).GetTeamNum() != Controller.GetTeamNum()
//jlb	     && VSize(ImpactVel) > FenderBenderSpeed && (vector(Rotation) Dot vector(Other.Rotation)) < 0 )
//jlb		PlayerController(Controller).ReceiveLocalizedMessage(class'ONSVehicleKillMessage', 7);
}

simulated function DrawHUD(Canvas C)
{
	local float JumpChargeAmount, SpinChargeAmount, BarHeight;
	local PlayerController PC;

    Super.DrawHUD(C);

	// Don't draw if we are dead, scoreboard is visible, etc
	PC = PlayerController(Controller);
	if (!bAllowChargingJump || Health < 1 || PC == None || PC.myHUD == None)
		return;

	// Draw background box
	C.Style = ERenderStyle.STY_Alpha;

	C.SetPos( JumpMeterOriginX * C.ClipX, JumpMeterOriginY * C.ClipY );

	//C.DrawColor = C.MakeColor(255,255,255,255);
	//C.DrawTile( Texture'HudContent.Generic.HUD', JumpMeterWidth * C.ClipX, JumpMeterHeight * C.ClipY, 125, 458, 166, 53);
	C.DrawColor = C.MakeColor(0,0,0,150);
	//C.DrawTile( Texture'HudContent.Generic.HUD', JumpMeterWidth * C.ClipX, JumpMeterHeight * C.ClipY, 168, 211, 166, 44);
//jlb	C.DrawTile( Texture'HudContent.Generic.HUD', JumpMeterWidth * C.ClipX, JumpMeterHeight * C.ClipY, 251, 211, 83, 44);

	// Draw charge bars
	C.Style = ERenderStyle.STY_Normal;

	BarHeight = 0.5 * (JumpMeterHeight - (3*JumpMeterSpacing));

	JumpChargeAmount = FClamp( JumpForce/MaxJumpForce, 0.0, 1.0 );
	C.DrawColor	= JumpMeterColor;
	C.SetPos( (JumpMeterOriginX+JumpMeterSpacing) * C.ClipX, (JumpMeterOriginY+JumpMeterSpacing) * C.ClipY );
	C.DrawTile(JumpMeterTexture, (JumpMeterWidth-(2*JumpMeterSpacing)) * C.ClipX * JumpChargeAmount, BarHeight * C.ClipY, 0, 0, JumpMeterTexture.USize, JumpMeterTexture.VSize*JumpChargeAmount);

	SpinChargeAmount = FClamp( Abs(JumpSpin)/MaxJumpSpin, 0.0, 1.0 );
	C.DrawColor	= SpinMeterColor;
	C.SetPos( (JumpMeterOriginX+JumpMeterSpacing) * C.ClipX, (JumpMeterOriginY+(2*JumpMeterSpacing)+BarHeight) * C.ClipY );
	C.DrawTile(JumpMeterTexture, (JumpMeterWidth-(2*JumpMeterSpacing)) * C.ClipX * SpinChargeAmount, BarHeight * C.ClipY, 0, 0, JumpMeterTexture.USize, JumpMeterTexture.VSize*SpinChargeAmount);
}

//if bAllowChargingJump is true, this will be called just BEFORE the vehicle does a jump
simulated event Jumping()
{
	ClientPlayForceFeedback(JumpFeedbackForce);

	if( JumpSound != None )
		PlaySound( JumpSound,, 2.5*TransientSoundVolume );
}

simulated event SetWheelsScale(float NewScale)
{
	local int i;
	local vector v;

	v.x = NewScale;
	v.y = NewScale;
	v.z = NewScale;

	Super.SetWheelsScale(NewScale);

	if(!bAllowBigWheels)
		return;

	for(i=0; i<Wheels.Length; i++)
	{
		SetBoneScale(i, v, Wheels[i].BoneName);
	}
}

defaultproperties
{
    SoundVolume=255
	DustSlipRate=2.8
	DustSlipThresh=50.0
	NumForwardGears=4

	bCanFlip=true

	CenterSpringRangePitch=5000
	CenterSpringRangeRoll=5000

	MaxJumpForce=200000.0
	MaxJumpSpin=30000.0
	JumpChargeTime=1.0
	JumpFeedbackForce="HoverBikeJump"
//jlb	JumpSound=sound'ONSVehicleSounds-S.Hydraulic10'

	bSpecialHUD=false
	JumpMeterOriginX=0.275
	JumpMeterOriginY=0.943
	JumpMeterHeight=0.057
	JumpMeterWidth=0.136
	JumpMeterSpacing=0.01
//jlb	JumpMeterTexture=Texture'Engine.WhiteTexture'
	JumpMeterColor=(R=215,G=0,B=0,A=255)
	SpinMeterColor=(R=0,G=100,B=215,A=255)

	MinAirControlDamping=0.1

	bOldVehicleOnGround=True
//jlb	DaredevilMessageClass=class'Onslaught.ONSDaredevilMessage'
	DaredevilThreshInAirSpin=100.0
	DaredevilThreshInAirPitch=300.0
	DaredevilThreshInAirRoll=300.0
	DaredevilThreshInAirTime=1.5
	DaredevilThreshInAirDistance=17.0

	FenderBenderSpeed=750.0
}
class gbx_OnlineProfile extends Actor
	config(OnlineProfile);
	
var config  Bool    bRememberPassword;
var config  String  sLoginName;
var config  String  sData1;

function String GetPassword()
{
	return "";
}

function SetPassword(String NewPassword)
{
}

function string ScrambleChar(string char)
{
	return "";
}class GorePackSetup extends Object
	abstract;

var	array<string>		PackGoreTextureNames;
var	array<Texture>		PackGoreTextures;
var array<Color>		PackGoreHandState;

simulated static function InitGorePackObject()
{
	local	int	i;
	
	if ((Default.PackGoreTextures.Length > 0) && (Default.PackGoreTextures[ 0 ] != None))
	{
		return;
	}
	
	for (i = 0; i < Default.PackGoreTextureNames.Length; i++)
	{
		Default.PackGoreTextures[ i ] = Texture(DynamicLoadObject( Default.PackGoreTextureNames[ i ], class'Texture' ));
	}
}

simulated static function int GetNumPackGoreTextures()
{
	InitGorePackObject();
	return Default.PackGoreTextures.Length;
}

simulated static function Texture GetPackGoreTexture(int nPackLimb)
{
	InitGorePackObject();

	if (nPackLimb >= Default.PackGoreTextures.Length)
		return None;  // nPackLib parameter was larger than the number of Textures in the array

	return Default.PackGoreTextures[ nPackLimb ];
}

simulated static function Color GetPackGoreHandState(int nPackLimb)
{
	return Default.PackGoreHandState[ nPackLimb ];
}

defaultproperties
{
	PackGoreHandState(0)=(R=1,G=1,B=1)
	PackGoreHandState(1)=(R=0,G=1,B=1)
	PackGoreHandState(2)=(R=0,G=1,B=1)
	PackGoreHandState(3)=(R=1,G=1,B=1)
	PackGoreHandState(4)=(R=1,G=0,B=1)
	PackGoreHandState(5)=(R=1,G=1,B=1)
}
class HUDClockIcon extends Actor
	native
	placeable;

#exec OBJ LOAD FILE=..\texture\t_interface_mb.utx


////////////////////////////////////////////////////////////////////////////////////////
/*	HUDClockIcon

	The HUDClockIcon object is an icon which draws data represented as a clock. 
	This object is used only to represent time data, it does not have any mechanism
    for updating the time internally.
*/
////////////////////////////////////////////////////////////////////////////////////////

var() Color					ClockColorNormal;
var   Color					CurrentClockColor;
var() Color					BackgroundColor;
var() Color					PausedClockColor;
var   float					ClockPercentage;
var   int					ReplicatedClockPercentage;
var   bool					ShouldFlashClock;
var() Color					FlashColor;
var() float					FlashLerpAlpha;

var   float					ClockCenterX;
var   float					ClockCenterY;

var   float					fNextFlashTime;

var()	protected Material	MyClockMaterial;
var()	int					ClockMaterialWidth;		// TODO make private and internally calculated.
var()	int					ClockMaterialHeight;		// TODO make private and internally calculated.
var()	int					ClockMaterialU;
var()	int					ClockMaterialV;

var()	Canvas.CanvasIcon	IconClock;
var()	Canvas.CanvasIcon	IconBack;

var()   float				fRadius;

var     int					iSegments;
var     bool				bPaused;

replication
{
	unreliable if( bNetDirty && (Role==ROLE_Authority) )
        ReplicatedClockPercentage, ShouldFlashClock, CurrentClockColor, ClockColorNormal, bPaused;

	reliable if ( bNetInitial && (Role==ROLE_Authority) )
		IconClock, IconBack;
}

////////////////////////////////////////////////////////////////////////////////////////
// Internal Implementation Functions
////////////////////////////////////////////////////////////////////////////////////////

simulated function RenderIcon( Canvas aCanvas, gbxHud Hud )
{
	//Log(self $ " InWorldIcon::RenderIcon() Location(" $Location.X$ "," $Location.Y$ ")", 'PSV');

	aCanvas.DrawCanvasIconComposite(Location.X, Location.Y,	Hud.flMinScaleX, Hud.flMinScaleY, IconClock, IconBack );
}

simulated function Timer()
{
	ShouldFlashClock = false;
}

function RestartClock()
{
	ShouldFlashClock = true;
	CurrentClockColor = FlashColor;
	ClockColorNormal = default.ClockColorNormal;
	bPaused = false;

	SetTimer( 1.0f, false );
}

function PauseClock()
{
	ShouldFlashClock = true;
	CurrentClockColor = FlashColor;
	ClockColorNormal = PausedClockColor;
	bPaused = true;

	SetTimer( 1.0f, false );
}

simulated function DrawGBXHud(canvas aCanvas, gbxHud Hud, FontInfo Fonts, int nPass)
{
	//Log( self$ " HUDClockIcon::DrawGBXHud() ClockPercentage = "$ClockPercentage, 'PSV');

	if (nPass == 0)
	{
		//Log( self$ " HUDClockIcon::DrawGBXHud() nPass == 0!", 'PSV');

		if ( ClockPercentage < 0.25 && !ShouldFlashClock && !bPaused )
		{
			//Log( self$ " Setting CurrentClockColor to FlashColor!", 'PSV');
			ShouldFlashClock = true;
			CurrentClockColor = FlashColor;
			SetTimer( 1.0f, false );
		}
						
		// Render the clock.
		CurrentClockColor.R = Lerp( FlashLerpAlpha, CurrentClockColor.R, ClockColorNormal.R );
		CurrentClockColor.G = Lerp( FlashLerpAlpha, CurrentClockColor.G, ClockColorNormal.G );
		CurrentClockColor.B = Lerp( FlashLerpAlpha, CurrentClockColor.B, ClockColorNormal.B );
		//Log( self$ " Setting CurrentClockColor (" $CurrentClockColor.R$ "," $CurrentClockColor.G$ "," $CurrentClockColor.B$ ")", 'PSV');

		RenderClockBackground( aCanvas, Hud );

		RenderClock( MyClockMaterial, ClockMaterialU, ClockMaterialV, ClockMaterialWidth, ClockMaterialHeight, 
					Location, 0.5 * fRadius, iSegments, ClockPercentage, Hud, aCanvas );

		RenderClockForeground( aCanvas, Hud );
	}
}

simulated function RenderClockBackground( Canvas aCanvas, gbxHud Hud )
{
	//local float XL, YL;
	
	aCanvas.DrawColor = IconBack.DrawColor;

	// Render the clock background.
	if ( !Hud.bIsSplitscreen )
	{
		aCanvas.SetPos( (aCanvas.SafeOffX + (Location.X * Hud.flMinScaleX)) - ((IconBack.UL/2) * IconBack.ScaleX * Hud.flMinScaleX), 
						(aCanvas.SafeOffY + (Location.Y * Hud.flMinScaleY)) - ((IconBack.VL/2) * IconBack.ScaleY * Hud.flMinScaleY) );
		aCanvas.DrawTile( IconBack.Icon, IconBack.UL * IconBack.ScaleX * Hud.flMinScaleX, 
					  IconBack.VL * IconBack.ScaleY * Hud.flMinScaleY, IconBack.U, IconBack.V, IconBack.UL, IconBack.VL );
	}
	else
	{
		aCanvas.SetPos( (aCanvas.SafeOffX + (Location.X * Hud.flSplitscreenScale)) - ((IconBack.UL/2) * IconBack.ScaleX * Hud.flSplitScreenScale), 
						(aCanvas.SafeOffY + (Location.Y * Hud.flSplitscreenScale)) - ((IconBack.VL/2) * IconBack.ScaleY * Hud.flSplitScreenScale) );
		aCanvas.DrawTile( IconBack.Icon, IconBack.UL * IconBack.ScaleX * Hud.flSplitScreenScale, 
					  IconBack.VL * IconBack.ScaleY * Hud.flSplitScreenScale, IconBack.U, IconBack.V, IconBack.UL, IconBack.VL );
	}
	
	//XL = IconBack.UL * IconBack.ScaleX * Hud.flMinScaleX;
	//YL =IconBack.VL * IconBack.ScaleY * Hud.flMinScaleY;
	//Log( self$ " RenderClockBackground() - XL: " $XL$ " YL: " $YL , 'PSV');
}

simulated function RenderClockForeground( Canvas aCanvas, gbxHud Hud )
{
	//local float XL, YL;
	aCanvas.DrawColor = IconClock.DrawColor;
	
	if ( !Hud.bIsSplitscreen )
	{
		aCanvas.SetPos( (aCanvas.SafeOffX + (Location.X * Hud.flMinScaleX)) - ((IconClock.UL/2) * IconClock.ScaleX * Hud.flMinScaleX), 
						(aCanvas.SafeOffY + (Location.Y * Hud.flMinScaleY)) - ((IconClock.VL/2) * IconClock.ScaleY * Hud.flMinScaleY) );
		aCanvas.DrawTile( IconClock.Icon, IconClock.UL * IconClock.ScaleX * Hud.flMinScaleX, 
					  IconClock.VL * IconClock.ScaleY * Hud.flMinScaleY, IconClock.U, IconClock.V, IconClock.UL, IconClock.VL );
	}
	else
	{
		aCanvas.SetPos( (aCanvas.SafeOffX + (Location.X * Hud.flSplitscreenScale)) - ((IconClock.UL/2) * IconClock.ScaleX * Hud.flSplitScreenScale), 
						(aCanvas.SafeOffY + (Location.Y * Hud.flSplitscreenScale)) - ((IconClock.VL/2) * IconClock.ScaleY * Hud.flSplitScreenScale) );
		aCanvas.DrawTile( IconClock.Icon, IconClock.UL * IconClock.ScaleX * Hud.flSplitScreenScale, 
					  IconClock.VL * IconClock.ScaleY * Hud.flSplitScreenScale, IconClock.U, IconClock.V, IconClock.UL, IconClock.VL );
	}
	
	//XL = IconClock.UL * IconClock.ScaleX * Hud.flMinScaleX;
	//YL =IconClock.VL * IconClock.ScaleY * Hud.flMinScaleY;
	//Log( self$ " RenderClockForeground() - XL: " $XL$ " YL: " $YL , 'PSV');
}

simulated native final function RenderClock( material Mat, float U, float V, float UL, float VL, vector Center, float Radius, int iSegments, float Percentage, Hud aHud, Canvas aCanvas );

defaultproperties
{
	DrawType=DT_None
	MyClockMaterial=material't_interface_mb.hud.interface_comp'		// solid_white
	ClockMaterialWidth=5
	ClockMaterialHeight=5
	ClockMaterialU=97
	ClockMaterialV=180

	IconClock=(Icon=Texture't_interface_mb.hud.interface_comp',U=143,V=0,UL=59,VL=59,DrawColor=(R=228,G=220,B=197,A=255),ScaleX=1.0,ScaleY=1.0,PivotU=0.5,PivotV=0.5)	// suppression_circle
	IconBack=(Icon=Texture't_interface_mb.hud.interface_comp',U=192,V=131,UL=46,VL=46,DrawColor=(R=26,G=20,B=14,A=255),ScaleX=1.28,ScaleY=1.28,PivotU=0.5,PivotV=0.5)	// bg_unit

	CurrentClockColor=(R=185,G=48,B=38,A=255)
	ClockColorNormal=(R=185,G=48,B=38,A=255)
	PausedClockColor=(R=231,G=144,B=30,A=255)
	FlashColor=(R=255,B=255,G=255,A=255)
	FlashLerpAlpha=0.1
	ShouldFlashClock=false

	BackgroundColor=(R=0,G=0,B=0,A=255)
	
	ClockCenterX = 250
	ClockCenterY = 250
	fRadius = 52
	iSegments = 16
	bPaused = false;

	ReplicatedClockPercentage=0
	bNetNotify=True
	bAlwaysRelevant=True
	bSkipActorPropertyReplication=true
	bOnlyDirtyReplication=true
	RemoteRole=ROLE_SimulatedProxy
}
// abstract base class of gbxAI.AIDebugCamera.
//
class IAIDebugCamera extends Object
	native
	abstract
	transient;

cpptext
{
	virtual UBOOL IsActive();
}

simulated NotInShip function LoadResources();
simulated NotInShip function SetOwnerPlayerController( gbxPlayerController PC );
simulated function bool IsActive();
simulated NotInShip function ToggleActive();
simulated NotInShip function ToggleTeam();
simulated NotInShip function ToggleUnit();
simulated NotInShip function TogglePawn();
simulated NotInShip function ToggleEnemy();
simulated NotInShip function TogglePause();
simulated NotInShip function ToggleMode();
simulated NotInShip function ToggleZoom();
simulated NotInShip function PrevNodeOrEnemy();
simulated NotInShip function NextNodeOrEnemy();

simulated event Tick( float DeltaTime );

simulated function bool SpecialCalcView( out actor ViewActor, out vector CameraLocation, out rotator CameraRotation );
simulated NotInShip function DrawGBXHud( canvas Canvas, gbxHud Hud, FontInfo Fonts, int nPass );//*********************************************************
// ImpactHandlerAirExplosions.uc
//
// Author: Stephen Palmer
// 10/15/2003
//
// MaterialImpact subclass responsible for spawning visual/sound
// effects when explosions happen in mid-air
//
//*********************************************************
class ImpactHandlerAirExplosions extends MaterialImpact
	transient
	native;


//---------------------------------------------------------
//	HandleExplosionImpact
//---------------------------------------------------------
function HandleExplosionImpact(Actor Spawner, EWeaponCategory WeaponCategory, Vector ImpactLoc, Rotator ImpactRot)
{
	switch( WeaponCategory )
	{
		case WC_Grenade :

			Spawner.Spawn(class'GrenadeExplosionAir',,, ImpactLoc, ImpactRot);
			break;

		case WC_LightExplosive :
			break;

		case WC_HeavyExplosive :
			break;

		case WC_Mortar:

			Spawner.Spawn(class'MortarExplosionDefault',,, ImpactLoc, ImpactRot);
			break;

		case WC_Bazooka:

			Spawner.Spawn(class'BazookaExplosionAir',,, ImpactLoc, ImpactRot);
			break;

		case WC_TankShell:

			Spawner.Spawn(class'TankShellExplosionAir',,, ImpactLoc, ImpactRot);
			break;
	}
}

//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
}
//=============================================================================
// ImpactHandlerAsparagus.uc
//
// Author: Stephen Palmer
// 2/03/2005
//
// MaterialImpact subclass responsible for spawning visual/sound
// effects when weapons strike wooden surfaces.
//
//=============================================================================
class ImpactHandlerAsparagus extends MaterialImpact
	transient
	native;

#exec OBJ LOAD FILE=..\texture\t_effect.utx

//---------------------------------------------------------
//	HandleExplosionImpact
//---------------------------------------------------------
function HandleExplosionImpact(Actor Spawner, EWeaponCategory WeaponCategory, Vector ImpactLoc, Rotator ImpactRot)
{
	Spawner.Spawn(class'GrenadeExplosionAsparagus',,, ImpactLoc, ImpactRot);
}

//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
}
//*********************************************************
// ImpactHandlerDefault.uc
//
// Author: Stephen Palmer
// 10/15/2003
//
// MaterialImpact subclass responsible for spawning visual/sound
// effects when weapons strike undefined surfaces.
//
//*********************************************************
class ImpactHandlerDefault extends MaterialImpact
	transient
	native;

#exec OBJ LOAD FILE=..\texture\t_effect.utx



// GBX:PAD: I'm putting this here, even though this data is initialized in default properties, just because this handler
// is only created once per game session, but since the data is transient, it gets wiped when changing from Entry to the next map.
function Initialize()
{
	Super.Initialize();
	
	if (ImpactDecals[0] == None)
	{
		ImpactDecals[0]=Texture't_effect.decal.d_default_01';
		ImpactDecals[1]=Texture't_effect.decal.d_default_02';
		ImpactDecals[2]=Texture't_effect.decal.d_default_03';
		ImpactDecals[3]=Texture't_effect.decal.d_default_04';
	}
}

//*********************************************************
//	HandleBulletImpact
//*********************************************************
event HandleBulletImpact(Actor HitActor, Actor Spawner, EWeaponCategory WeaponCategory, Vector ImpactLoc, Rotator ImpactRot, bool bLowDetail)
{
	Super.HandleBulletImpact( HitActor, Spawner, WeaponCategory, ImpactLoc, ImpactRot, bLowDetail );

	if ( !bDisableEmitters )
	{
		Spawner.Spawn(class'ImpactEmitterDefault',,, ImpactLoc, ImpactRot);
	}
}

//*********************************************************
//	HandleExplosionImpact
//*********************************************************
function HandleExplosionImpact(Actor Spawner, EWeaponCategory WeaponCategory, Vector ImpactLoc, Rotator ImpactRot)
{
	switch( WeaponCategory )
	{
		case WC_Grenade :

			Spawner.Spawn(class'GrenadeExplosionDefault',,, ImpactLoc, ImpactRot);
			break;

		case WC_LightExplosive :
			break;

		case WC_HeavyExplosive :
			break;

		case WC_Mortar:

			Spawner.Spawn(class'MortarExplosionDefault',,, ImpactLoc, ImpactRot);
			break;

		case WC_Bazooka:

			Spawner.Spawn(class'BazookaExplosionDefault',,, ImpactLoc, ImpactRot);
			break;

		case WC_TankShell:

			Spawner.Spawn(class'TankShellExplosionDefault',,, ImpactLoc, ImpactRot);
			break;
	}
}

//*********************************************************
//	HandleMeleeImpact
//*********************************************************
function HandleMeleeImpact( Actor Spawner, Material HitMaterial, Vector ImpactLoc, Rotator ImpactRot)
{
	if ( !bDisableEmitters )
	{
		Spawner.Spawn(class'ImpactEmitterDefault',,, ImpactLoc, ImpactRot);
	}
}

//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
	FootStepSoundFile = "PLAYER.FOOTSTEPS_DIRT"
	FootTurnSoundFile = "PLAYER.FOOTSTEPS_SHUFFLE_DIRT"

	ImpactSoundFile = "IMPACTS.BULLET_DIRT"
	MeleeImpactSoundFile = "IMPACTS.BULLET_DIRT"
	GrenadeBounceSoundFile = "IMPACTS.GRENADE_DIRT"

	ImpactDecals(0)=Texture't_effect.decal.d_default_01'
	ImpactDecals(1)=Texture't_effect.decal.d_default_02'
	ImpactDecals(2)=Texture't_effect.decal.d_default_03'
	ImpactDecals(3)=Texture't_effect.decal.d_default_04'
}
//*********************************************************
// ImpactHandlerDirt.uc
//
// Author: Neil Johnson
// 5/14/2003
//
// MaterialImpact subclass responsible for spawning visual/sound
// effects when weapons strike dirt surfaces.
//
//*********************************************************
class ImpactHandlerDirt extends MaterialImpact
	transient
	native;

#exec OBJ LOAD FILE=..\texture\t_effect.utx

var float DirtEffectSquaredDistBullet;
var float DirtEffectSquaredDistExplosion;
var range DirtEffectParticleCountBullet;
var range DirtEffectParticleCountExplosion;

// GBX:PAD: I'm putting this here, even though this data is initialized in default properties, just because this handler
// is only created once per game session, but since the data is transient, it gets wiped when changing from Entry to the next map.
function Initialize()
{
	Super.Initialize();

	if (ImpactDecals[0] == None)
	{
		ImpactDecals[0]=Texture't_effect.decal.d_dirt_01';
		ImpactDecals[1]=Texture't_effect.decal.d_dirt_02';
		ImpactDecals[2]=Texture't_effect.decal.d_dirt_03';
		ImpactDecals[3]=Texture't_effect.decal.d_dirt_04';
	}
}

//*********************************************************
//	HandleBulletImpact
//*********************************************************
event HandleBulletImpact(Actor HitActor, Actor Spawner, EWeaponCategory WeaponCategory, Vector ImpactLoc, Rotator ImpactRot, bool bLowDetail)
{
	CreateHudDirtEffect( Spawner.Level.GetLocalPlayerController(), ImpactLoc, DirtEffectSquaredDistBullet, DirtEffectParticleCountBullet, false, true );

	if ( !bDisableEmitters )
	{
		Spawner.Spawn(class'ImpactEmitterDirt',,, ImpactLoc, ImpactRot);
	}
}

//*********************************************************
//	HandleExplosionImpact
//*********************************************************
function HandleExplosionImpact(Actor Spawner, EWeaponCategory WeaponCategory, Vector ImpactLoc, Rotator ImpactRot)
{
	CreateHudDirtEffect( Spawner.Level.GetLocalPlayerController(), ImpactLoc, DirtEffectSquaredDistExplosion, DirtEffectParticleCountExplosion, true, false );

	switch( WeaponCategory )
	{
		case WC_Grenade :

			Spawner.Spawn(class'GrenadeExplosionDirt',,, ImpactLoc, ImpactRot);
			break;

		case WC_LightExplosive :
			break;

		case WC_HeavyExplosive :
			break;

		case WC_Mortar:

			Spawner.Spawn(class'MortarExplosionDefault',,, ImpactLoc, ImpactRot);
			break;

		case WC_Bazooka:

			Spawner.Spawn(class'BazookaExplosionDirt',,, ImpactLoc, ImpactRot);
			break;

		case WC_TankShell:

			Spawner.Spawn(class'TankShellExplosionDirt',,, ImpactLoc, ImpactRot);
			break;
	}
}

//*********************************************************
//	HandleMeleeImpact
//*********************************************************
function HandleMeleeImpact( Actor Spawner, Material HitMaterial, Vector ImpactLoc, Rotator ImpactRot)
{
	CreateHudDirtEffect( Spawner.Level.GetLocalPlayerController(), ImpactLoc, DirtEffectSquaredDistBullet, DirtEffectParticleCountBullet, false, true );

	if ( !bDisableEmitters )
	{
		Spawner.Spawn(class'ImpactEmitterDirt',,, ImpactLoc, ImpactRot);
	}
}

//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
	FootStepSoundFile = "PLAYER.FOOTSTEPS_DIRT"
	FootTurnSoundFile = "PLAYER.FOOTSTEPS_SHUFFLE_DIRT"

	ImpactSoundFile = "IMPACTS.BULLET_DIRT"
	MeleeImpactSoundFile = "IMPACTS.BULLET_DIRT"
	GrenadeBounceSoundFile = "IMPACTS.GRENADE_DIRT"

	ImpactDecals(0)=Texture't_effect.decal.d_dirt_01'
	ImpactDecals(1)=Texture't_effect.decal.d_dirt_02'
	ImpactDecals(2)=Texture't_effect.decal.d_dirt_03'
	ImpactDecals(3)=Texture't_effect.decal.d_dirt_04'

	DirtEffectSquaredDistBullet = 262144.0
	DirtEffectSquaredDistExplosion = 1048576.0
	DirtEffectParticleCountBullet = (Min=15,Max=25)
	DirtEffectParticleCountExplosion = (Min=25,Max=250)
}
//*********************************************************
// ImpactHandlerFlesh.uc
//
// MaterialImpact subclass responsible for spawning visual/sound
// effects when weapons strike flesh (like dead cows/horses).
//
//*********************************************************
class ImpactHandlerFlesh extends MaterialImpact
	transient
	native;



//*********************************************************
//	HandleBulletImpact
//*********************************************************
event HandleBulletImpact(Actor HitActor, Actor Spawner, EWeaponCategory WeaponCategory, Vector ImpactLoc, Rotator ImpactRot, bool bLowDetail)
{
	Super.HandleBulletImpact( HitActor, Spawner, WeaponCategory, ImpactLoc, ImpactRot, bLowDetail );

	if ( !bDisableEmitters )
	{
		Spawner.Spawn(class'ImpactEmitterFlesh',,, ImpactLoc, ImpactRot);
	}
}

//*********************************************************
//	HandleExplosionImpact
//*********************************************************
function HandleExplosionImpact(Actor Spawner, EWeaponCategory WeaponCategory, Vector ImpactLoc, Rotator ImpactRot)
{
	switch( WeaponCategory )
	{
		case WC_Grenade :

			Spawner.Spawn(class'GrenadeExplosionDefault',,, ImpactLoc, ImpactRot);
			break;

		case WC_LightExplosive :
			break;

		case WC_HeavyExplosive :
			break;

		case WC_Mortar:

			Spawner.Spawn(class'MortarExplosionDefault',,, ImpactLoc, ImpactRot);
			break;

		case WC_Bazooka:

			Spawner.Spawn(class'BazookaExplosionDefault',,, ImpactLoc, ImpactRot);
			break;

		case WC_TankShell:

			Spawner.Spawn(class'TankShellExplosionDefault',,, ImpactLoc, ImpactRot);
			break;
	}
}

//*********************************************************
//	HandleMeleeImpact
//*********************************************************
function HandleMeleeImpact( Actor Spawner, Material HitMaterial, Vector ImpactLoc, Rotator ImpactRot)
{
	if ( !bDisableEmitters )
	{
		Spawner.Spawn(class'ImpactEmitterFlesh',,, ImpactLoc, ImpactRot);
	}
}

//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
	FootStepSoundFile = "PLAYER.FOOTSTEPS_DIRT"
	FootTurnSoundFile = "PLAYER.FOOTSTEPS_SHUFFLE_DIRT"

	ImpactSoundFile = "IMPACTS.BULLET_BODY"
	MeleeImpactSoundFile = "IMPACTS.BULLET_DIRT"
	GrenadeBounceSoundFile = "IMPACTS.GRENADE_BODY"
}
//*********************************************************
// ImpactHandlerGrass.uc
//
// Author: Neil Johnson
// 5/14/2003
//
// MaterialImpact subclass responsible for spawning visual/sound
// effects when weapons strike grassy surfaces.
//
//*********************************************************
class ImpactHandlerGrass extends MaterialImpact
	transient
	native;

#exec OBJ LOAD FILE=..\texture\t_effect.utx

var float DirtEffectSquaredDistBullet;
var float DirtEffectSquaredDistExplosion;
var range DirtEffectParticleCountBullet;
var range DirtEffectParticleCountExplosion;

// GBX:PAD: I'm putting this here, even though this data is initialized in default properties, just because this handler
// is only created once per game session, but since the data is transient, it gets wiped when changing from Entry to the next map.
function Initialize()
{
	Super.Initialize();

	if (ImpactDecals[0] == None)
	{
		ImpactDecals[0]=Texture't_effect.decal.d_grass_02';
		ImpactDecals[1]=Texture't_effect.decal.d_grass_02';
		ImpactDecals[2]=Texture't_effect.decal.d_grass_03';
		ImpactDecals[3]=Texture't_effect.decal.d_grass_04';
	}
}

//*********************************************************
//	HandleBulletImpact
//*********************************************************
event HandleBulletImpact(Actor HitActor, Actor Spawner, EWeaponCategory WeaponCategory, Vector ImpactLoc, Rotator ImpactRot, bool bLowDetail)
{
	Super.HandleBulletImpact( HitActor, Spawner, WeaponCategory, ImpactLoc, ImpactRot, bLowDetail );

	CreateHudDirtEffect( Spawner.Level.GetLocalPlayerController(), ImpactLoc, DirtEffectSquaredDistBullet, DirtEffectParticleCountBullet, false, true );

	if ( !bDisableEmitters )
	{
		Spawner.Spawn(class'ImpactEmitterGrass',,, ImpactLoc, ImpactRot);
	}
}

//*********************************************************
//	HandleExplosionImpact
//*********************************************************
function HandleExplosionImpact(Actor Spawner, EWeaponCategory WeaponCategory, Vector ImpactLoc, Rotator ImpactRot)
{
	CreateHudDirtEffect( Spawner.Level.GetLocalPlayerController(), ImpactLoc, DirtEffectSquaredDistExplosion, DirtEffectParticleCountExplosion, true, false );

	switch( WeaponCategory )
	{
		case WC_Grenade :

			Spawner.Spawn(class'GrenadeExplosionGrass',,, ImpactLoc, ImpactRot);
			break;

		case WC_LightExplosive :
			break;

		case WC_HeavyExplosive :
			break;

		case WC_Mortar:

			Spawner.Spawn(class'MortarExplosionDefault',,, ImpactLoc, ImpactRot);
			break;

		case WC_Bazooka:

			Spawner.Spawn(class'BazookaExplosionGrass',,, ImpactLoc, ImpactRot);
			break;

		case WC_TankShell:

			Spawner.Spawn(class'TankShellExplosionGrass',,, ImpactLoc, ImpactRot);
			break;
	}
}

//*********************************************************
//	HandleMeleeImpact
//*********************************************************
function HandleMeleeImpact( Actor Spawner, Material HitMaterial, Vector ImpactLoc, Rotator ImpactRot)
{
	CreateHudDirtEffect( Spawner.Level.GetLocalPlayerController(), ImpactLoc, DirtEffectSquaredDistBullet, DirtEffectParticleCountBullet, false, true );

	if ( !bDisableEmitters )
	{
		Spawner.Spawn(class'ImpactEmitterGrass',,, ImpactLoc, ImpactRot);
	}
}

//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
	FootStepSoundFile = "PLAYER.FOOTSTEPS_DIRT"
	FootTurnSoundFile = "PLAYER.FOOTSTEPS_SHUFFLE_DIRT"

	ImpactSoundFile = "IMPACTS.BULLET_DIRT"
	MeleeImpactSoundFile = "IMPACTS.BULLET_DIRT"
	GrenadeBounceSoundFile = "IMPACTS.GRENADE_GRASS"

	ImpactDecals(0)=Texture't_effect.decal.d_grass_02'
	ImpactDecals(1)=Texture't_effect.decal.d_grass_02'
	ImpactDecals(2)=Texture't_effect.decal.d_grass_03'
	ImpactDecals(3)=Texture't_effect.decal.d_grass_04'

	DirtEffectSquaredDistBullet = 262144.0
	DirtEffectSquaredDistExplosion = 1048576.0
	DirtEffectParticleCountBullet = (Min=15,Max=25)
	DirtEffectParticleCountExplosion = (Min=25,Max=250)
}
//*********************************************************
// ImpactHandlerHay.uc
//
// Author: Neil Johnson
// 1/14/2005
//
// MaterialImpact subclass responsible for spawning visual/sound
// effects when weapons strike hay surfaces.
//
//*********************************************************
class ImpactHandlerHay extends MaterialImpact
	transient
	native;

//*********************************************************
//	HandleBulletImpact
//*********************************************************
event HandleBulletImpact(Actor HitActor, Actor Spawner, EWeaponCategory WeaponCategory, Vector ImpactLoc, Rotator ImpactRot, bool bLowDetail)
{
	Super.HandleBulletImpact( HitActor, Spawner, WeaponCategory, ImpactLoc, ImpactRot, bLowDetail );

	if ( !bDisableEmitters )
	{
		Spawner.Spawn(class'ImpactEmitterHay',,, ImpactLoc, ImpactRot);
	}
}

//*********************************************************
//	HandleExplosionImpact
//*********************************************************
function HandleExplosionImpact(Actor Spawner, EWeaponCategory WeaponCategory, Vector ImpactLoc, Rotator ImpactRot)
{
	switch( WeaponCategory )
	{
		case WC_Grenade :

			Spawner.Spawn(class'GrenadeExplosionDefault',,, ImpactLoc, ImpactRot);
			break;

		case WC_LightExplosive :
			break;

		case WC_HeavyExplosive :
			break;

		case WC_Mortar:

			Spawner.Spawn(class'MortarExplosionDefault',,, ImpactLoc, ImpactRot);
			break;

		case WC_Bazooka:

			Spawner.Spawn(class'BazookaExplosionDefault',,, ImpactLoc, ImpactRot);
			break;

		case WC_TankShell:

			Spawner.Spawn(class'TankShellExplosionDefault',,, ImpactLoc, ImpactRot);
			break;
	}
}

//*********************************************************
//	HandleMeleeImpact
//*********************************************************
function HandleMeleeImpact( Actor Spawner, Material HitMaterial, Vector ImpactLoc, Rotator ImpactRot)
{
	if ( !bDisableEmitters )
	{
		Spawner.Spawn(class'ImpactEmitterHay',,, ImpactLoc, ImpactRot);
	}
}

//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
	FootStepSoundFile = "PLAYER.FOOTSTEPS_GRASS"
	FootTurnSoundFile = "PLAYER.FOOTSTEPS_SHUFFLE_GRASS"

	ImpactSoundFile = "IMPACTS.BULLET_DIRT"
	MeleeImpactSoundFile = "IMPACTS.BULLET_DIRT"
	GrenadeBounceSoundFile = "IMPACTS.GRENADE_GRASS"

}
//*********************************************************
// ImpactHandlerMetal.uc
//
// Author: Neil Johnson
// 5/14/2003
//
// MaterialImpact subclass responsible for spawning visual/sound
// effects when weapons strike metal surfaces.
//
//*********************************************************
class ImpactHandlerMetal extends MaterialImpact
	transient
	native;

#exec OBJ LOAD FILE=..\texture\t_effect.utx



var Sound RicochetSound;
var String RicochetSoundFile;

//*********************************************************
//	Initialize
//*********************************************************
function Initialize()
{
	Super.Initialize();

	// Play the ricochet sound cue
	if( RicochetSoundFile != "" )
		RicochetSound = Sound( DynamicLoadObject( RicochetSoundFile, class'Sound' ) );

	if (ImpactDecals[0] == None)
	{
		ImpactDecals[0]=Texture't_effect.decal.d_metal_01';
		ImpactDecals[1]=Texture't_effect.decal.d_metal_02';
		ImpactDecals[2]=Texture't_effect.decal.d_metal_03';
		ImpactDecals[3]=Texture't_effect.decal.d_metal_04';
	}
}

//*********************************************************
//	HandleBulletImpact
//*********************************************************
event HandleBulletImpact(Actor HitActor, Actor Spawner, EWeaponCategory WeaponCategory, Vector ImpactLoc, Rotator ImpactRot, bool bLowDetail)
{
	Super.HandleBulletImpact( HitActor, Spawner, WeaponCategory, ImpactLoc, ImpactRot, bLowDetail );

	if ( !bDisableEmitters )
	{
		Spawner.Spawn(class'ImpactEmitterMetal',,, ImpactLoc, ImpactRot);
	}
}

//*********************************************************
//	HandleExplosionImpact
//*********************************************************
function HandleExplosionImpact(Actor Spawner, EWeaponCategory WeaponCategory, Vector ImpactLoc, Rotator ImpactRot)
{
	switch( WeaponCategory )
	{
		case WC_Grenade :

			Spawner.Spawn(class'GrenadeExplosionDefault',,, ImpactLoc, ImpactRot);
			break;

		case WC_LightExplosive :
			break;

		case WC_HeavyExplosive :
			break;

		case WC_Mortar:

			Spawner.Spawn(class'MortarExplosionDefault',,, ImpactLoc, ImpactRot);
			break;

		case WC_Bazooka:

			Spawner.Spawn(class'BazookaExplosionDefault',,, ImpactLoc, ImpactRot);
			break;

		case WC_TankShell:

			Spawner.Spawn(class'TankShellExplosionDefault',,, ImpactLoc, ImpactRot);
			break;
	}
}

//*********************************************************
//	PlayBulletImpactSound
//*********************************************************
function PlayBulletImpactSound(EWeaponCategory WeaponCategory, Vector ImpactLoc )
{
	Super.PlayBulletImpactSound( WeaponCategory, ImpactLoc );

	if( RicochetSound != None && Proxy != None )
		Proxy.PlaySound( RicochetSound, SLOT_None );
}

//*********************************************************
//	HandleMeleeImpact
//*********************************************************
function HandleMeleeImpact( Actor Spawner, Material HitMaterial, Vector ImpactLoc, Rotator ImpactRot)
{
	if ( !bDisableEmitters )
	{
		Spawner.Spawn(class'ImpactEmitterMetal',,, ImpactLoc, ImpactRot);
	}
}

//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
	FootStepSoundFile = "PLAYER.FOOTSTEPS_STONE"
	FootTurnSoundFile = "PLAYER.FOOTSTEPS_SHUFFLE_STONE"
	
	ImpactSoundFile = "IMPACTS.BULLET_METAL"
	MeleeImpactSoundFile = "IMPACTS.BULLET_METAL"
	RicochetSoundFile = "IMPACTS.RICOCHET"
	GrenadeBounceSoundFile = "IMPACTS.GRENADE_METAL"

	ImpactDecals(0)=Texture't_effect.decal.d_metal_01'
	ImpactDecals(1)=Texture't_effect.decal.d_metal_02'
	ImpactDecals(2)=Texture't_effect.decal.d_metal_03'
	ImpactDecals(3)=Texture't_effect.decal.d_metal_04'
}
//*********************************************************
// ImpactHandlerMetal.uc
//
// Author: Neil Johnson
// 5/14/2003
//
// MaterialImpact subclass responsible for spawning visual/sound
// effects when weapons strike plaster surfaces.
//
//*********************************************************
class ImpactHandlerPlaster extends MaterialImpact
	transient
	native;

#exec OBJ LOAD FILE=..\texture\t_effect.utx



// GBX:PAD: I'm putting this here, even though this data is initialized in default properties, just because this handler
// is only created once per game session, but since the data is transient, it gets wiped when changing from Entry to the next map.
function Initialize()
{
	Super.Initialize();

	if (ImpactDecals[0] == None)
	{
		ImpactDecals[0]=Texture't_effect.decal.d_plaster_01';
		ImpactDecals[1]=Texture't_effect.decal.d_plaster_02';
		ImpactDecals[2]=Texture't_effect.decal.d_plaster_03';
		ImpactDecals[3]=Texture't_effect.decal.d_plaster_04';
	}
}

//*********************************************************
//	HandleBulletImpact
//*********************************************************
event HandleBulletImpact(Actor HitActor, Actor Spawner, EWeaponCategory WeaponCategory, Vector ImpactLoc, Rotator ImpactRot, bool bLowDetail)
{
	Super.HandleBulletImpact( HitActor, Spawner, WeaponCategory, ImpactLoc, ImpactRot, bLowDetail );

	if ( !bDisableEmitters )
	{
		Spawner.Spawn(class'ImpactEmitterPlaster',,, ImpactLoc, ImpactRot);
	}
}

//*********************************************************
//	HandleExplosionImpact
//*********************************************************
function HandleExplosionImpact(Actor Spawner, EWeaponCategory WeaponCategory, Vector ImpactLoc, Rotator ImpactRot)
{
	switch( WeaponCategory )
	{
		case WC_Grenade :

			Spawner.Spawn(class'GrenadeExplosionDefault',,, ImpactLoc, ImpactRot);
			break;

		case WC_LightExplosive :
			break;

		case WC_HeavyExplosive :
			break;

		case WC_Mortar:

			Spawner.Spawn(class'MortarExplosionDefault',,, ImpactLoc, ImpactRot);
			break;

		case WC_Bazooka:

			Spawner.Spawn(class'BazookaExplosionDefault',,, ImpactLoc, ImpactRot);
			break;

		case WC_TankShell:

			Spawner.Spawn(class'TankShellExplosionDefault',,, ImpactLoc, ImpactRot);
			break;
	}
}

//*********************************************************
//	HandleMeleeImpact
//*********************************************************
function HandleMeleeImpact( Actor Spawner, Material HitMaterial, Vector ImpactLoc, Rotator ImpactRot)
{
	if ( !bDisableEmitters )
	{
		Spawner.Spawn(class'ImpactEmitterPlaster',,, ImpactLoc, ImpactRot);
	}
}

//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
	FootStepSoundFile = "PLAYER.FOOTSTEPS_GRAVEL"
	FootTurnSoundFile = "PLAYER.FOOTSTEPS_SHUFFLE_GRAVEL"
	GrenadeBounceSoundFile = "IMPACTS.GRENADE_STONE"

	ImpactDecals(0)=Texture't_effect.decal.d_plaster_01'
	ImpactDecals(1)=Texture't_effect.decal.d_plaster_02'
	ImpactDecals(2)=Texture't_effect.decal.d_plaster_03'
	ImpactDecals(3)=Texture't_effect.decal.d_plaster_04'
}
//*********************************************************
// ImpactHandlerShrubbery.uc
//
// Author: Neil Johnson
// 9/29/2003
//
// MaterialImpact subclass responsible for spawning visual/sound
// effects when weapons strike shrubbery.
//
//*********************************************************
class ImpactHandlerShrubbery extends MaterialImpact
	transient
	native;



//*********************************************************
//	HandleBulletImpact
//*********************************************************
event HandleBulletImpact(Actor HitActor, Actor Spawner, EWeaponCategory WeaponCategory, Vector ImpactLoc, Rotator ImpactRot, bool bLowDetail)
{
	Super.HandleBulletImpact( HitActor, Spawner, WeaponCategory, ImpactLoc, ImpactRot, bLowDetail );

	if ( !bDisableEmitters )
	{
		Spawner.Spawn(class'ImpactEmitterShrubbery',,, ImpactLoc, ImpactRot);
	}
}

//*********************************************************
//	HandleExplosionImpact
//*********************************************************
function HandleExplosionImpact(Actor Spawner, EWeaponCategory WeaponCategory, Vector ImpactLoc, Rotator ImpactRot)
{
	switch( WeaponCategory )
	{
		case WC_Grenade :

			Spawner.Spawn(class'GrenadeExplosionDefault',,, ImpactLoc, ImpactRot);
			break;

		case WC_LightExplosive :
			break;

		case WC_HeavyExplosive :
			break;

		case WC_Mortar:

			Spawner.Spawn(class'MortarExplosionDefault',,, ImpactLoc, ImpactRot);
			break;

		case WC_Bazooka:

			Spawner.Spawn(class'BazookaExplosionDefault',,, ImpactLoc, ImpactRot);
			break;

		case WC_TankShell:

			Spawner.Spawn(class'TankShellExplosionDefault',,, ImpactLoc, ImpactRot);
			break;
	}
}

//*********************************************************
//	HandleMeleeImpact
//*********************************************************
function HandleMeleeImpact( Actor Spawner, Material HitMaterial, Vector ImpactLoc, Rotator ImpactRot)
{
	if ( !bDisableEmitters )
	{
		Spawner.Spawn(class'ImpactEmitterShrubbery',,, ImpactLoc, ImpactRot);
	}
}

//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
	FootStepSoundFile = "PLAYER.FOOTSTEPS_GRASS"
	FootTurnSoundFile = "PLAYER.FOOTSTEPS_SHUFFLE_GRASS"

	ImpactSoundFile = "IMPACTS.BULLET_DIRT"
	MeleeImpactSoundFile = "IMPACTS.BULLET_DIRT"
	GrenadeBounceSoundFile = "IMPACTS.GRENADE_GRASS"
}
//*********************************************************
// ImpactHandlerStone.uc
//
// Author: Neil Johnson
// 9/8/2003
//
// MaterialImpact subclass responsible for spawning visual/sound
// effects when weapons strike stone surfaces.
//
//*********************************************************
class ImpactHandlerStone extends MaterialImpact
	transient
	native;

#exec OBJ LOAD FILE=..\texture\t_effect.utx



var Sound RicochetSound;
var String RicochetSoundFile;

//*********************************************************
//	Initialize
//*********************************************************
function Initialize()
{
	Super.Initialize();

	if (ImpactDecals[0] == None)
	{
		ImpactDecals[0]=Texture't_effect.decal.d_stone_01';
		ImpactDecals[1]=Texture't_effect.decal.d_stone_02';
		ImpactDecals[2]=Texture't_effect.decal.d_stone_03';
		ImpactDecals[3]=Texture't_effect.decal.d_stone_04';
	}
}

//*********************************************************
//	HandleBulletImpact
//*********************************************************
event HandleBulletImpact(Actor HitActor, Actor Spawner, EWeaponCategory WeaponCategory, Vector ImpactLoc, Rotator ImpactRot, bool bLowDetail)
{
	Super.HandleBulletImpact( HitActor, Spawner, WeaponCategory, ImpactLoc, ImpactRot, bLowDetail );

	if ( !bDisableEmitters )
	{
//		Spawner.Spawn(class'ImpactEmitterStone',,, ImpactLoc, ImpactRot);
		Spawner.Spawn(class'ImpactEmitterDefault',,, ImpactLoc, ImpactRot);
	}
}

//*********************************************************
//	HandleExplosionImpact
//*********************************************************
function HandleExplosionImpact(Actor Spawner, EWeaponCategory WeaponCategory, Vector ImpactLoc, Rotator ImpactRot)
{
	switch( WeaponCategory )
	{
		case WC_Grenade :

			Spawner.Spawn(class'GrenadeExplosionStone',,, ImpactLoc, ImpactRot);
			break;

		case WC_LightExplosive :
			break;

		case WC_HeavyExplosive :
			break;

		case WC_Mortar:

			Spawner.Spawn(class'MortarExplosionDefault',,, ImpactLoc, ImpactRot);
			break;

		case WC_Bazooka:

			Spawner.Spawn(class'BazookaExplosionStone',,, ImpactLoc, ImpactRot);
			break;

		case WC_TankShell:

			Spawner.Spawn(class'TankShellExplosionStone',,, ImpactLoc, ImpactRot);
			break;
	}
}

//*********************************************************
//	HandleMeleeImpact
//*********************************************************
function HandleMeleeImpact( Actor Spawner, Material HitMaterial, Vector ImpactLoc, Rotator ImpactRot)
{
	if ( !bDisableEmitters )
	{
//		Spawner.Spawn(class'ImpactEmitterStone',,, ImpactLoc, ImpactRot);
		Spawner.Spawn(class'ImpactEmitterDefault',,, ImpactLoc, ImpactRot);
	}
}

//*********************************************************
//	PlayBulletImpactSound
//*********************************************************
function PlayBulletImpactSound(EWeaponCategory WeaponCategory, Vector ImpactLoc )
{
	Super.PlayBulletImpactSound( WeaponCategory, ImpactLoc );
}

//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
	FootStepSoundFile = "PLAYER.FOOTSTEPS_STONE"
	FootTurnSoundFile = "PLAYER.FOOTSTEPS_SHUFFLE_STONE"
	
	ImpactSoundFile = "IMPACTS.BULLET_STONE"
	MeleeImpactSoundFile = "IMPACTS.BULLET_STONE"
	GrenadeBounceSoundFile = "IMPACTS.GRENADE_STONE"

	ImpactDecals(0)=Texture't_effect.decal.d_stone_01'
	ImpactDecals(1)=Texture't_effect.decal.d_stone_02'
	ImpactDecals(2)=Texture't_effect.decal.d_stone_03'
	ImpactDecals(3)=Texture't_effect.decal.d_stone_04'
}
//*********************************************************
// ImpactHandlerWater.uc
//
// Author: Neil Johnson
// 5/14/2003
//
// MaterialImpact subclass responsible for spawning visual/sound
// effects when weapons strike water surfaces.
//
//*********************************************************
class ImpactHandlerWater extends MaterialImpact
	transient
	native;

#exec OBJ LOAD FILE=..\texture\t_effect.utx

var float WaterEffectSquaredDistBullet;
var float WaterEffectSquaredDistExplosion;
var range WaterEffectParticleCountBullet;
var range WaterEffectParticleCountExplosion;

function Initialize()
{
	Super.Initialize();
}

//*********************************************************
//	HandleBulletImpact
//*********************************************************
event HandleBulletImpact(Actor HitActor, Actor Spawner, EWeaponCategory WeaponCategory, Vector ImpactLoc, Rotator ImpactRot, bool bLowDetail)
{
	Super.HandleBulletImpact( HitActor, Spawner, WeaponCategory, ImpactLoc, ImpactRot, bLowDetail );

	CreateHudWaterEffect( Spawner.Level.GetLocalPlayerController(), ImpactLoc, WaterEffectSquaredDistBullet, WaterEffectParticleCountBullet, false, true );
		
	if ( !bDisableEmitters )
	{
		Spawner.Spawn(class'WaterBulletSplash',,, ImpactLoc, ImpactRot);
	}	
}

//*********************************************************
//	PlayBulletImpactSound
//*********************************************************
function PlayBulletImpactSound(EWeaponCategory WeaponCategory, Vector ImpactLoc )
{
	Super.PlayBulletImpactSound( WeaponCategory, ImpactLoc );
}

//*********************************************************
//	HandleExplosionImpact
//*********************************************************
function HandleExplosionImpact(Actor Spawner, EWeaponCategory WeaponCategory, Vector ImpactLoc, Rotator ImpactRot)
{
	local Vector HitLoc, HitNormal;
		
	CreateHudWaterEffect( Spawner.Level.GetLocalPlayerController(), ImpactLoc, WaterEffectSquaredDistExplosion, WaterEffectParticleCountExplosion, true, false );

	// if this is a grenade fix the impact location for the trace
	if( WeaponCategory == WC_Grenade )
	{
		ImpactLoc = ImpactLoc - vect(0,0,1)*16;
	}

	//Create water ring at the top of the water volume
	if( !Spawner.PhysicsVolume.TraceThisActor( HitLoc, HitNormal,ImpactLoc, ImpactLoc+500*vect(0,0,1.0) ) )
	{
		switch( WeaponCategory )
		{
			case WC_Grenade:
				Spawner.Spawn(class'WaterExplosion',,, HitLoc, ImpactRot);
				break;

			case WC_LightExplosive:
				break;

			case WC_HeavyExplosive:
				break;

			case WC_Mortar:
				Spawner.Spawn(class'WaterExplosion',,, HitLoc, ImpactRot);
				break;

			case WC_Bazooka:
				Spawner.Spawn(class'WaterExplosion',,, HitLoc, ImpactRot);
				break;

			case WC_TankShell:
				Spawner.Spawn(class'WaterExplosion',,, HitLoc, ImpactRot);
				break;
		}
		return;
	}
}

//*********************************************************
//	HandleMeleeImpact
//*********************************************************
function HandleMeleeImpact( Actor Spawner, Material HitMaterial, Vector ImpactLoc, Rotator ImpactRot)
{
	CreateHudWaterEffect( Spawner.Level.GetLocalPlayerController(), ImpactLoc, WaterEffectSquaredDistBullet, WaterEffectParticleCountBullet, false, true );

	if ( !bDisableEmitters )
	{
		Spawner.Spawn(class'WaterSplashSmall',,, ImpactLoc, ImpactRot);
	}

}


//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
	GrenadeBounceSoundFile = "IMPACTS.GRENADE_WATER"
	ImpactSoundFile = "IMPACTS.BULLET_WATER"
	MeleeImpactSoundFile = "IMPACTS.SPLASH_SMALL"
	WaterEffectSquaredDistBullet = 262144.0
	WaterEffectSquaredDistExplosion = 1048576.0
	WaterEffectParticleCountBullet = (Min=15,Max=25)
	WaterEffectParticleCountExplosion = (Min=25,Max=250)
}
//=============================================================================
// ImpactHandlerWood.uc
//
// Author: Neil Johnson
// 5/14/2003
//
// MaterialImpact subclass responsible for spawning visual/sound
// effects when weapons strike wooden surfaces.
//
//=============================================================================
class ImpactHandlerWood extends MaterialImpact
	transient
	native;

#exec OBJ LOAD FILE=..\texture\t_effect.utx



// GBX:PAD: I'm putting this here, even though this data is initialized in default properties, just because this handler
// is only created once per game session, but since the data is transient, it gets wiped when changing from Entry to the next map.
function Initialize()
{
	Super.Initialize();

	if (ImpactDecals[0] == None)
	{
		ImpactDecals[0]=Texture't_effect.decal.d_wood_01';
		ImpactDecals[1]=Texture't_effect.decal.d_wood_02';
		ImpactDecals[2]=Texture't_effect.decal.d_wood_03';
		ImpactDecals[3]=Texture't_effect.decal.d_wood_04';
	}
}

//---------------------------------------------------------
//	HandleBulletImpact
//---------------------------------------------------------
event HandleBulletImpact(Actor HitActor, Actor Spawner, EWeaponCategory WeaponCategory, Vector ImpactLoc, Rotator ImpactRot, bool bLowDetail)
{
	Super.HandleBulletImpact( HitActor, Spawner, WeaponCategory, ImpactLoc, ImpactRot, bLowDetail );

	if ( !bDisableEmitters )
	{
		Spawner.Spawn(class'ImpactEmitterWood',,, ImpactLoc, ImpactRot);
	}
}

//---------------------------------------------------------
//	HandleExplosionImpact
//---------------------------------------------------------
function HandleExplosionImpact(Actor Spawner, EWeaponCategory WeaponCategory, Vector ImpactLoc, Rotator ImpactRot)
{
	switch( WeaponCategory )
	{
		case WC_Grenade :

			Spawner.Spawn(class'GrenadeExplosionDefault',,, ImpactLoc, ImpactRot);
			break;

		case WC_LightExplosive :
			break;

		case WC_HeavyExplosive :
			break;

		case WC_Mortar:

			Spawner.Spawn(class'MortarExplosionDefault',,, ImpactLoc, ImpactRot);
			break;

		case WC_Bazooka:

			Spawner.Spawn(class'BazookaExplosionDefault',,, ImpactLoc, ImpactRot);
			break;

		case WC_TankShell:

			Spawner.Spawn(class'TankShellExplosionDefault',,, ImpactLoc, ImpactRot);
			break;
	}
}

//*********************************************************
//	HandleMeleeImpact
//*********************************************************
function HandleMeleeImpact( Actor Spawner, Material HitMaterial, Vector ImpactLoc, Rotator ImpactRot)
{	
	if ( !bDisableEmitters )
	{
		Spawner.Spawn(class'ImpactEmitterWood',,, ImpactLoc, ImpactRot);
	}
}

//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
	//GBX:PAD: This sound file is bad, so until it gets fixed, it is messing up the creating of linear load files.
	FootStepSoundFile = "PLAYER.FOOTSTEPS_WOOD"
	FootTurnSoundFile = "PLAYER.FOOTSTEPS_SHUFFLE_WOOD"
	
	ImpactSoundFile = "IMPACTS.BULLET_WOOD"
	MeleeImpactSoundFile = "IMPACTS.BULLET_WOOD"

	GrenadeBounceSoundFile = "IMPACTS.GRENADE_WOOD"
	ImpactDecals(0)=Texture't_effect.decal.d_wood_01'
	ImpactDecals(1)=Texture't_effect.decal.d_wood_02'
	ImpactDecals(2)=Texture't_effect.decal.d_wood_03'
	ImpactDecals(3)=Texture't_effect.decal.d_wood_04'
}
//*********************************************************
// ImpactManager.uc
//
// Author: Neil Johnson
// 5/13/2003
//
// Manager for the various types of impact emitters that can
// be spawned when weapons of a certain type strike materials of
// a certain type.  ImpactManager knows what type of effect
// to spawn based on the weapon type/surface type.
//
//*********************************************************
class ImpactManager extends IImpactManager
	native
	transient;

cpptext
{
	void HandleBulletImpact( AActor* HitActor, AActor* Spawner, UMaterial* HitMaterial, bool HitWater, BYTE WeaponCategory, const FVector& ImpactLoc, const FRotator& ImpactRot );
	class AMaterialImpact* GetCorrectHandler( BYTE SurfaceType );	
}

//---------------------------------------------------------
// Variables
//---------------------------------------------------------
//var ImpactManager MyInstance;	// Singleton instance.

var transient ImpactHandlerDirt				Dirt;
var transient  ImpactHandlerGrass			Grass;
var transient  ImpactHandlerMetal			Metal;
var transient  ImpactHandlerStone			Stone;
var transient  ImpactHandlerWood			Wood;
var transient  ImpactHandlerPlaster			Plaster;
var transient  ImpactHandlerHay				Hay;
var transient  ImpactHandlerShrubbery		Shrub;
var transient  ImpactHandlerAirExplosions	AirExplosions;
var transient  ImpactHandlerWater			Water;
var transient  ImpactHandlerFlesh			Flesh;
var transient  ImpactHandlerAsparagus		Asparagus;
var transient  ImpactHandlerDefault			HandlerDefault;
var transient  Class<gbxMessage>			PerceptionImpactClass;
//var transient	PlayerController			LocalPC;
var array<gbxBulletImpactDecal>				BulletDecalList;	// Dynamic array of bullet decals
var config int										MaxBulletDecals;
var int										BulletDecalListPointer;

var int										ndxLastUnusedImpactMessage;
var int										DrawDecalSquaredDist;
var int										PlayImpactSoundSquaredDist;

var bool									bCullSounds, bCullEmitters;

// statically defined materials...
var Material Material_Metal;


//*********************************************************
//	GetInstance - Singleton Accessor
//*********************************************************
static function IImpactManager GetInstance( Object InOuter, Actor Spawner )
{
	if (Spawner == None)
	{
		return None;
	}
	
	if (Spawner.Level.TheImpactManager == None && InOuter != None )
	{
		// Create the singleton instance.
		Spawner.Level.TheImpactManager = new( InOuter ) class'ImpactManager';
		Spawner.Level.TheImpactManager.Initialize( Spawner );
	}

	return Spawner.Level.TheImpactManager;
}


//*********************************************************
//	Initialize
//*********************************************************
function Initialize( Actor Spawner )
{
	Dirt			= Spawner.Spawn( class'ImpactHandlerDirt' );
	Grass			= Spawner.Spawn( class'ImpactHandlerGrass' );
	Metal			= Spawner.Spawn( class'ImpactHandlerMetal' );
	Stone			= Spawner.Spawn( class'ImpactHandlerStone' );
	Wood			= Spawner.Spawn( class'ImpactHandlerWood' );
	Plaster			= Spawner.Spawn( class'ImpactHandlerPlaster' );
	Hay				= Spawner.Spawn( class'ImpactHandlerHay' );
	Shrub			= Spawner.Spawn( class'ImpactHandlerShrubbery' );
	AirExplosions	= Spawner.Spawn( class'ImpactHandlerAirExplosions' );
	Water			= Spawner.Spawn( class'ImpactHandlerWater' );
	Flesh			= Spawner.Spawn( class'ImpactHandlerFlesh' );
	Asparagus		= Spawner.Spawn( class'ImpactHandlerAsparagus' );
	HandlerDefault	= Spawner.Spawn( class'ImpactHandlerDefault' );

	Dirt.Initialize();
	Grass.Initialize();
	Metal.Initialize();
	Stone.Initialize();
	Wood.Initialize();	
	Plaster.Initialize();
	Hay.Initialize();
	Shrub.Initialize();
	AirExplosions.Initialize();
	Water.Initialize();
	Flesh.Initialize();
	// Don't need to initialize Asparagus
	HandlerDefault.Initialize();

	if ( PerceptionImpactClass == None )
		PerceptionImpactClass = class<gbxMessage>( DynamicLoadObject( "gbxAI.PerceptionImpact", class'Class' ));	

	// allocate and initialize static materials...
	Material_Metal = Material(Spawner.Level.ObjectPool.AllocateObject(class'Material', Spawner.Level.Outer ));
	Material_Metal.SurfaceType = EST_Metal;

	BulletDecalList.Length = MaxBulletDecals;

	ndxLastUnusedImpactMessage = 0;
}

//*********************************************************
//	HandleExplosionImpact
//*********************************************************
function HandleExplosionImpact(
		Actor						Spawner,
		Material					HitMaterial,
		EWeaponCategory				WeaponCategory,
		Vector						ImpactLoc,
		Rotator						ImpactRot)
{
	local MaterialImpact ImpactHandler;
	
	if( Spawner.PhysicsVolume.bWaterVolume )	//-BB
	{
		ImpactHandler = Water;
	}
	else if( Spawner.IsA('TNTAsparagus') )
	{
		ImpactHandler = Asparagus;
	}
	else if( HitMaterial != None )
	{
		ImpactHandler = GetCorrectHandler(HitMaterial.SurfaceType);
	}
	else
	{
		ImpactHandler = AirExplosions;
	}

	if (ImpactHandler != None )
	{
		ImpactHandler.HandleExplosionImpact(Spawner, WeaponCategory, ImpactLoc, ImpactRot);
	}
}
//*********************************************************
//	HandleBulletImpact
//*********************************************************
native simulated function HandleBulletImpact(
		Actor						HitActor,
		Actor						Spawner,
		Material					HitMaterial,
		bool						HitWater,
		EWeaponCategory				WeaponCategory,
		Vector						ImpactLoc,
		Rotator						ImpactRot);

//*********************************************************
// HandleGrenadeBounce
//*********************************************************
function HandleGrenadeBounce( Material FloorMat, Actor Sponsor, bool bInWater )
{
	local MaterialImpact ImpactHandler;

	if( FloorMat != None )
	{
		ImpactHandler = GetCorrectHandler(FloorMat.SurfaceType);
	}
	else if(bInWater)
	{
		ImpactHandler = Water;
	}

	if (ImpactHandler != None )
	{
		ImpactHandler.PlayGrenadeBounceSound( Sponsor );
	}
}

//*********************************************************
// HandleMeleeImpact
//*********************************************************
function HandleMeleeImpact( Actor Sponsor, Material HitMat, bool bHitWater, Vector ImpactLoc, Rotator ImpactRot)
{
	local MaterialImpact ImpactHandler;

	if( bHitWater)
	{
		ImpactHandler = Water;
	}
	else if( HitMat != None )
	{
		ImpactHandler = GetCorrectHandler(HitMat.SurfaceType);
	}

	if (ImpactHandler != None )
	{
		ImpactHandler.HandleMeleeImpact( Sponsor, HitMat, ImpactLoc, ImpactRot );
		ImpactHandler.PlayMeleeImpactSound( Sponsor, ImpactLoc );
	}


}

//*********************************************************
//	HandleFootStep
//*********************************************************
function HandleFootStep( Material FloorMat, Actor Sponsor )
{
	local MaterialImpact ImpactHandler;

	if( FloorMat != None )
	{
		ImpactHandler = GetCorrectHandler(FloorMat.SurfaceType);
	}

	if (ImpactHandler != None )
	{
		ImpactHandler.PlayFootStepSound( Sponsor );
	}
}

//*********************************************************
//	HandleFootTurn
//*********************************************************
function HandleFootTurn( Material FloorMat, Actor Sponsor )
{
	local MaterialImpact ImpactHandler;

	if( FloorMat != None )
	{
		ImpactHandler = GetCorrectHandler(FloorMat.SurfaceType);
	}

	if (ImpactHandler != None )
	{
		ImpactHandler.PlayFootTurnSound( Sponsor );
	}
}

//*********************************************************
//	GetCorrectHandler
//*********************************************************
native function MaterialImpact GetCorrectHandler(ESurfaceTypes SurfaceType);

defaultproperties
{
	bCullSounds=true
	bCullEmitters=true
	MaxBulletDecals=64
	DrawDecalSquaredDist=360000		// 600 units
	PlayImpactSoundSquaredDist=1000000
}
//=============================================================================
// Abstract base class for all in-world icons to which team order icons can be attached.
//
// Author: Neil Johnson, Gearbox Software.
//=============================================================================
class InWorldAttachTarget extends InWorldIcon
	native;

defaultproperties
{
}class InWorldIcon extends Actor
	native
	placeable;




////////////////////////////////////////////////////////////////////////////////////////
/*	InWorldIcon

	The InWorldIcon class is a sprite with extra bonus features that are similar, but
	different, from those of a corona.

	Like a corona, an InWorldIcon can remain a constant on-screen size regardless of Z
	distance. Unlike a corona, an InWorldIcon can also scale *somewhat* but never
	get smaller than a certain size and never get bigger than another.

	Like a corona, an InWorldIcon is rendered in front of everything else but can be
	occluded by line traces. Unlike a corona, an InWorldIcon can opt never to be
	occluded, or to be occluded only at certain distance ranges.

	Like a corona, an InWorldIcon can render either as a normal texture or with a
	FinalBlend.

	Like a corona, InWorldIcons can fade in and out when appearing or disappearing.
	Unlike a corona, InWorldIcons can fade in and out in configurable ways, and
	can also add (in subclasses) additional animations and states.
*/
////////////////////////////////////////////////////////////////////////////////////////

var()	Canvas.CanvasIcon	MyIconBack;
var()	Canvas.CanvasIcon	MyIcon;



var()	protected Material	MyMaterial;
var()	int					MaterialWidth;		// TODO make private and internally calculated.
var()	int					MaterialHeight;		// TODO make private and internally calculated.
var()	float				MaterialCenterU;
var()	float				MaterialCenterV;
var()	int					MaterialU;
var()	int					MaterialV;
// GBX:PAD: We can't set a value in DefaultProperties to an enum, so setting this up as such is a problem.  For now,
// I just going to let it use the render style that is set before trying to draw it.
//var()	ERenderStyle		RenderStyle;

var()	float	MinSizeScalar;
var()	float	MaxSizeScalar;

var()	float	DistAtMaxSize;			// The distance at which the icon will be at its maximum size
var()	float	DistAtMinSize;			// The distance at which the icon will be at its smallest size (intervening distances are interpolated linearly).
var()	float	MaxDistClip;			// The farthest point at which intervening geometry clips (hides) the icon. This is based on intersection distance, not icon distance.
											// Beyond this point, the icon is not clipped by anything.
											// If this value is < 0, icon is always clipped by intervening geometry.
											// If 0, the icon is never clipped.
var()	float	MinDistShow;			// The minimum distance at which this icon is displayed. When it is nearer than this distance, it is hidden.
var()	float	MaxDistShow;			// The maximum distance at which this icon is displayed. When it is farther than this distance, it is hidden. Set to -1 to allow infinite range.

var()	protected bool bShow;					// True when the icon "wants" to be shown on a high level.
var()	bool	bOccluded;				// True when the icon cannot be shown due to occlusion (distance or linecheck).
var()	bool	bRenderIcon;			// True whenever the icon is rendered, which includes when it is disappearing.
var()	bool	bDisabled;

var()	byte	MaxAlpha;
var()   float	MaxScale;
var()	float	DurationAppear;
var()	float	DurationDisappear;
var()	float	AppearScaleMultiplier;
var()	float	DisappearScaleMultiplier;

var()	vector	LocationOffset;			// World space offset from this actor's location to draw the actual icon.

var()	Color	CurrentDrawColor;		// TODO Allow tweening of color rather than setting.

var()	float	UpdateInterval;
var()	float	OcclusionUpdateInterval;

var		int					 iAttachedParentSlot;
var		InWorldIcon			 AttachedParent;
var		array< InWorldIcon > AttachedIcons;

var		protected byte	CurrentAlpha;
var		protected float	CurrentScaleX;
var		protected float	CurrentScaleY;
var		protected float FalsePerspectiveScale;
var		protected float	NextUpdateTime;
var		protected float NextOcclusionUpdateTime;

var				rotator IconRotation;
var				rotator BackRotation;

var				  float ScreenScaleX;		// These affect screen size uniformly, not texel size.
var				  float ScreenScaleY;

// Internal Tween data
var		protected bool	bTweening;
var		protected float	TweenTimeStart;
var		protected float	TweenDuration;
var		protected float	TweenAlphaStart;
var		protected float	TweenAlphaEnd;
var		protected float	TweenScaleXStart;
var		protected float	TweenScaleXEnd;
var		protected float	TweenScaleYStart;
var		protected float	TweenScaleYEnd;

var float		m_flNextHudCalc;

var bool		bDestroyWhenNextHidden;

var     float			fOpacityMultiplier;

//var EUnitType targetingUnitType;		//NAC added this for access in InWorldUnitIcon
var Unit	TargetingUnit;				//NAC 1/3/05

////////////////////////////////////////////////////////////////////////////////////////
// API Functions
////////////////////////////////////////////////////////////////////////////////////////

simulated function bool IsShown()
{
	return bShow;
}

simulated function Show()
{
	if( !IsShown() )
	{
		//Log(self $ " InWorldIcon::Show() showing", 'BeaconsIcons');

		bShow = true;
		GotoState( 'Appearing' );
	}
}

simulated function Hide()
{
	if( IsShown() )
	{
		//Log(self $ " InWorldIcon::Hide() hiding", 'BeaconsIcons');

		bShow = false;
		GotoState( 'Disappearing' );
	}
}

simulated function SetMaterial( Material newMaterial )
{
	MyMaterial = newMaterial;
//	MaterialWidth = ???;		// TODO glean from MyMaterial.
//	MaterialHeight = ???;		// TODO glean from MyMaterial.
}


simulated function int GetNumAttachedIcons()
{
	local int i, iCount;

	for( i = 0; i < AttachedIcons.Length; i++ )
	{
		if( AttachedIcons[ i ] != None )
		{
			++iCount;
		}
	}
	return iCount;
}

simulated function Actor GetAssociatedActor() { return None; }
simulated function bool CanAcceptAttachmentsFrom( Pawn Attacher ) { return false; }

simulated function AttachIcon( InWorldIcon anIcon, optional int slot, optional bool bNoDestroy )
{
	if( anIcon == None )
	{
		return;
	}

	if( slot < AttachedIcons.Length && AttachedIcons[ slot ] != None && AttachedIcons[ slot ] != anIcon )
	{
		// Detach existing icon on this slot.
		DetachIcon( slot, bNoDestroy );
	}

	anIcon.AttachedParent = Self;
	anIcon.iAttachedParentSlot = slot;
	anIcon.GotoState( 'AttachedToParent' );

	AttachedIcons.Length = Max( AttachedIcons.Length, slot + 1 );
	AttachedIcons[ slot ] = anIcon;
}

simulated function DetachIcon( int slot, optional bool bNoDestroy )
{
	if( slot >= 0 && slot < AttachedIcons.Length )
	{
		AttachedIcons[ slot ].AttachedParent = None;
		AttachedIcons[ slot ].bDestroyWhenNextHidden = !bNoDestroy;
		if( !bNoDestroy )
		{
			AttachedIcons[ slot ].Hide();
		}

		AttachedIcons[ slot ] = None;
	}
}

simulated function DetachAllIcons( optional bool bNoDestroy )
{
	local int i;

	for( i = 0; i < AttachedIcons.Length; i++ )
	{
		AttachedIcons[ i ].AttachedParent = None;
		AttachedIcons[ i ].bDestroyWhenNextHidden = !bNoDestroy;
		if( !bNoDestroy )
		{
			AttachedIcons[ i ].Hide();
		}
	}

	AttachedIcons.Length = 0;
}

simulated function DetachFromParent( optional bool bNoDestroy )
{
	if( AttachedParent != None )
	{
		AttachedParent.DetachIcon( iAttachedParentSlot, bNoDestroy );
	}
}

////////////////////////////////////////////////////////////////////////////////////////
// Internal Implementation Functions
////////////////////////////////////////////////////////////////////////////////////////

simulated function SetOccluded( bool isOccluded )
{
	bOccluded = isOccluded;
}

simulated function bool IsShownInternal()
{
	return IsInState( 'Appearing' ) || IsInState( 'Shown' );
}

simulated function bool WantsShowInternal()
{
	return bShow && !bOccluded;
}

simulated function ShowInternal()
{
//	Log( name $ "<" $ GetStateName() $ ">.ShowInternal()", 'JMW' );

	if( !bShow )
	{
		Log( name $ "<" $ GetStateName() $ ">.ShowInternal() ERROR: Called without bShow == true", 'JMW' );
	}

	if( !IsShownInternal() )
	{
		GotoState( 'Appearing' );
	}
}

simulated function HideInternal()
{
	if( IsShownInternal() )
	{
		GotoState( 'Disappearing' );
	}
}

simulated function HideAndDestroy()
{
	if( bRenderIcon )
	{
		bDestroyWhenNextHidden = true;
		Hide();
	}
	else
	{
		Destroy();
	}
}

simulated function Destroyed()
{
	local PlayerController PC;
	local int i;

	if( AttachedParent != None )
	{
		DetachFromParent();
	}

	for( i = 0; i < AttachedIcons.Length; i++ )
	{
		AttachedIcons[ i ].Destroy();
	}

	// Unregister self with all local gbxHUDs.
	foreach DynamicActors( class'PlayerController', PC )
	{
		if( gbxHUD( PC.myHUD ) != None )
		{
			gbxHUD( PC.myHUD ).UnregisterInWorldIcon( self );
		}
	}

	TargetingUnit = None;  // prevent references to/in destroyed objects

	Super.Destroyed();
}

simulated function vector GetCameraLocation( Canvas aCanvas )
{
	local Vector camLoc;
	local Rotator camRot;
	local Actor viewActor;

	aCanvas.Viewport.Actor.PlayerCalcView( viewActor, camLoc, camRot );

	return camLoc;
}

simulated function float GetDistanceFromCamera( Canvas aCanvas )
{
	return VSize( GetCameraLocation( aCanvas ) - Location );
}

simulated function bool ShouldDrawForPlayer(PlayerController player)
{
	return bRenderIcon;
}

simulated function DrawGBXHud(canvas aCanvas, gbxHud Hud, FontInfo Fonts, int nPass)
{
	if (nPass == 0)
	{
		DoRenderCalculations( aCanvas );

		if( ShouldDrawForPlayer(Hud.PlayerOwner) )
		{
			//Log(self $ " InWorldIcon::DrawGBXHud() shoulddrawforplayer=true, rendering", 'BeaconsIcons');
			RenderIcon( aCanvas, Hud );
		}
		else if( bDestroyWhenNextHidden )
		{
			Destroy();
			return;
		}
	}
}

simulated function DoRenderCalculations( Canvas aCanvas )
{
	local Actor HitActor;
	local float DistCamera, DistHit, NormalizedDistForScale;
	local vector CamLocation, HitLocation, HitNormal, TargetLocation;
	local gbxPlayerController myPlayerController;

	//Log(self $ " InWorldIcon::DoRenderCalculations() begin", 'BeaconsIcons');

	CamLocation = GetCameraLocation( aCanvas );
	DistCamera = VSizeSquared( CamLocation - GetWorldLocation( aCanvas ) );

	if( aCanvas.Viewport.Actor == None || aCanvas.Viewport.Actor.Pawn == None || gbxPlayerController( aCanvas.Viewport.Actor ) == None )
	{
		// This icon isn't being rendered to any meaningful player.
		return;
	}

	myPlayerController = gbxPlayerController( aCanvas.Viewport.Actor );

	if( myPlayerController.ShouldRefuseIconOcclusion( Self ) )
	{
		// Player controller doesn't allow occlusion.
		SetOccluded( false );
	}
	else
	{
		// Distance based occlusion.
		if( DistCamera < MinDistShow * MinDistShow || ( MaxDistShow >= 0 && DistCamera > MaxDistShow * MaxDistShow ))
		{
			// Outside of show range. Disappear.
			SetOccluded( true );

			//Log(self $ " InWorldIcon::DoRenderCalculations() occluded due to out of range", 'BeaconsIcons');
		}
		else if( NextOcclusionUpdateTime < Level.UniversalTimeSeconds )
		{
			NextOcclusionUpdateTime = Level.UniversalTimeSeconds + OcclusionUpdateInterval;
			// Linecheck-based occlusion.
			TargetLocation = GetWorldLocation( aCanvas );
			HitActor = Trace( HitLocation, HitNormal, TargetLocation, CamLocation );

			if( HitActor == None )
			{
				SetOccluded( false );
			}
			else if( HitActor.IsA( 'TerrainInfo' ))
			{
				SetOccluded( true );

				//Log(self $ " InWorldIcon::DoRenderCalculations() occluded due to terrain info", 'BeaconsIcons');
			}
			else
			{
				DistHit = VSizeSquared( GetWorldLocation( aCanvas ) - HitLocation );

				SetOccluded( MaxDistClip >= 0 && DistHit > MaxDistClip * MaxDistClip );
			
				//if (bOccluded)
				//{
				//	Log(self $ " InWorldIcon::DoRenderCalculations() occluded due max dist clip", 'BeaconsIcons');
				//}
			}
	/*
			// Old system, based on dist from cam.
			{
				DistHit = VSizeSquared( HitLocation - CamLocation );
				SetOccluded( MaxDistClip < 0 || DistHit <= MaxDistClip * MaxDistClip );
			}
	*/
		}
	}

	// What state should we be in?

	if( WantsShowInternal() )
	{
		ShowInternal();
	}
	else
	{
		HideInternal();
	}

	// Do the rendering.

	if( bRenderIcon )
	{
		if( bTweening )
		{
			DoTweenCalculations();
		}

		aCanvas.DrawColor = CurrentDrawColor;
		aCanvas.DrawColor.A = CurrentAlpha * fOpacityMultiplier;
//		aCanvas.Style = Default.RenderStyle;

		// Compute actual scale to use.
		NormalizedDistForScale = FClamp( ( Sqrt( DistCamera ) - DistAtMaxSize ) / ( DistAtMinSize - DistAtMaxSize ), 0.0, 1.0 );
		FalsePerspectiveScale = Lerp( NormalizedDistForScale, MaxSizeScalar, MinSizeScalar );
	}
}

simulated function DoTweenCalculations()
{
	local float TweenProportion;		// How far along in the tween are we, range (0,1) where 0=start of tween and 1=end of tween.

	TweenProportion = FClamp(( Level.UniversalTimeSeconds - TweenTimeStart ) / TweenDuration, 0.0, 1.0 );

	CurrentAlpha	= TweenAlphaStart  + TweenProportion * ( TweenAlphaEnd  - TweenAlphaStart  );
	CurrentScaleX	= TweenScaleXStart + TweenProportion * ( TweenScaleXEnd - TweenScaleXStart );
	CurrentScaleY	= TweenScaleYStart + TweenProportion * ( TweenScaleYEnd - TweenScaleYStart );
}


simulated function vector GetScreenToWorldDelta( vector inVector, float distFromCam )
{
	local float fovRadians;

	fovRadians = Level.GetLocalPlayerController().FOVAngle / 180 * Pi;

	return inVector * ( distFromCam / Cos( fovRadians ));
}


simulated function vector GetWorldLocation( Canvas aCanvas )
{
	return Location + GetScreenToWorldDelta( LocationOffset, VSize( GetCameraLocation( aCanvas ) - Location ));		// inverse perspective scale
}

simulated function RenderIcon( Canvas aCanvas, gbxHud Hud )
{
	local vector screenPos;
	local float ScaleX, ScaleY;

	screenPos = aCanvas.ScreenProject(GetWorldLocation( aCanvas ));

	//Log(self $ " InWorldIcon::RenderIcon() screenPos = " $ screenPos, 'BeaconsIcons');

	if (screenPos.Z < 1.0)
	{
		ScaleX = CurrentScaleX * FalsePerspectiveScale * Hud.flMinScaleX;
		ScaleY = CurrentScaleY * FalsePerspectiveScale * Hud.flMinScaleY;

		MyIconBack.DrawColor.A = CurrentAlpha * fOpacityMultiplier;
		MyIcon.DrawColor.A = CurrentAlpha * fOpacityMultiplier;

		//Log(self $ " InWorldIcon::RenderIcon() drawing" @ ScreenPos.X @ ScreenPos.Y @ ScaleX @ ScaleY @ CurrentScaleX @ CurrentScaleY @ FalsePerspectiveScale @ Hud.flMinScaleX @ Hud.flMinScaleY, 'BeaconsIcons');

		aCanvas.DrawCanvasIconComposite(	
							ScreenPos.X, ScreenPos.Y,
							ScaleX,
							ScaleY,
							MyIcon, 
							MyIconBack,
							IconRotation,
							BackRotation );
	}
}


simulated function PostNetBeginPlay()
{
	local PlayerController PC;

	Super.PostBeginPlay();

	// Register self with all local gbxHUDs.
	for( PC = Level.PlayerControllerList; PC != None; PC = PC.nextPlayerController )
	{
		if( gbxHUD( PC.myHUD ) != None )
		{
			gbxHUD( PC.myHUD ).RegisterInWorldIcon( self );
		}
	}
}


/*simulated function BeginState()		// TODO DEBUGGING
{
	Log( name $ "<" $ GetStateName() $ ">.BeginState()", 'JMW' );
}
*/

////////////////////////////////////////////////////////////////////////////////////////
// States
////////////////////////////////////////////////////////////////////////////////////////

simulated state Appearing
{
	simulated function BeginState()
	{
		//Log(self $ " InWorldIcon::BeginState()[Appearing]", 'BeaconsIcons');

		Global.BeginState();

	}

	simulated function StartTween()
	{
		//Log(self $ " InWorldIcon::StartTween()[Appearing] begin", 'BeaconsIcons');

		bRenderIcon = true;
		bTweening = true;

		// Setup tween.

		TweenTimeStart = Level.UniversalTimeSeconds;
		TweenDuration  = DurationAppear;

		TweenAlphaStart = 0;
		TweenScaleXStart = AppearScaleMultiplier;
		TweenScaleYStart = TweenScaleXStart;

		TweenAlphaEnd = MaxAlpha;
		TweenScaleXEnd = MaxScale;
		TweenScaleYEnd = TweenScaleXEnd;

		CurrentAlpha = 0;
		CurrentScaleX = TweenScaleXStart;
		CurrentScaleY = TweenScaleYStart;
	}

Begin:
	//Log(self $ " InWorldIcon::State Code[Appearing] begin", 'BeaconsIcons');
	// Wait a moment in case this is just a "click".
	Sleep( 0.1 );

	// Do the tween.
	StartTween();

	Sleep( TweenDuration );
	//Log(self $ " InWorldIcon::State Code[Appearing] end, going to Shown state", 'BeaconsIcons');
	GotoState( 'Shown' );
}

simulated state Shown
{
	simulated function BeginState()
	{
		//Log(self $ " InWorldIcon::BeginState()[Shown]", 'BeaconsIcons');
	
		Global.BeginState();

		bRenderIcon = true;

		bTweening = false;

		CurrentAlpha = MaxAlpha;
		CurrentScaleX = MaxScale;
		CurrentScaleY = CurrentScaleX;
	}
}


simulated state AttachedToParent
{
	simulated function bool IsShown()
	{
		return AttachedParent.IsShown();
	}

	simulated function Show()
	{
	}

	simulated function Hide()
	{
	}

	simulated function HideAndDestroy()
	{
		DetachFromParent();
	}

	simulated function SetOccluded( bool isOccluded )
	{
	}

	simulated function bool IsShownInternal()
	{
		return AttachedParent.IsShownInternal();
	}

	simulated function ShowInternal()
	{
	}

	simulated function HideInternal()
	{
	}

	simulated function DoRenderCalculations( Canvas aCanvas )
	{
		if( AttachedParent == None )
		{
			Log( name $ "<" $ GetStateName() $ ">.DoRenderCalculations(): WARNING: AttachedParent == None.", 'JMW' );
			Destroy();
			return;
		}
		bShow = AttachedParent.bShow;
		bOccluded = AttachedParent.bOccluded;
		bRenderIcon = AttachedParent.bRenderIcon;
		CurrentAlpha	= AttachedParent.CurrentAlpha;	// TODO offset
		CurrentScaleX	= AttachedParent.CurrentScaleX; // TODO offset
		CurrentScaleY	= AttachedParent.CurrentScaleY; // TODO offset

		aCanvas.DrawColor = CurrentDrawColor;
		aCanvas.DrawColor.A = CurrentAlpha * fOpacityMultiplier;
//		aCanvas.Style = Default.RenderStyle;

		// Compute actual scale to use.
		FalsePerspectiveScale = AttachedParent.FalsePerspectiveScale;
	}
}

simulated state Disappearing
{
	simulated function BeginState()
	{
		//Log(self $ " InWorldIcon::BeginState()[Disappearing]", 'BeaconsIcons');

		Global.BeginState();

		// Setup tween.

		bTweening = true;

		TweenTimeStart = Level.UniversalTimeSeconds;
		if( Level.NetMode == NM_ListenServer || Level.NetMode == NM_Client )
			TweenDuration  = 0;
		else
			TweenDuration  = DurationDisappear;

		TweenAlphaStart = CurrentAlpha * fOpacityMultiplier;
		TweenScaleXStart = CurrentScaleX;
		TweenScaleYStart = CurrentScaleY;

		TweenAlphaEnd = 0;
		TweenScaleXEnd = DisappearScaleMultiplier;
		TweenScaleYEnd = TweenScaleXEnd;
	}

Begin:
	//Log(self $ " InWorldIcon::State Code[Disappearing] begin", 'BeaconsIcons');
	Sleep( TweenDuration );
	//Log(self $ " InWorldIcon::State Code[Disappearing] end, going to Hidden state", 'BeaconsIcons');
	GotoState( 'Hidden' );
}

auto simulated state Hidden
{
	simulated function BeginState()
	{
		//Log(self $ " InWorldIcon::BeginState()[Hidden]", 'BeaconsIcons');

		Global.BeginState();

		// GBX:PAD: It's possible that a low frame rate bogged things down enough to the point where tweening didn't
		// finish in time, so make sure to set these to their target values so that we don't have ghost images hanging
		// around.
		CurrentAlpha	= TweenAlphaEnd;
		CurrentScaleX	= TweenScaleXEnd;
		CurrentScaleY	= TweenScaleYEnd;

		bRenderIcon = false;
		bTweening = false;
	}
}

defaultproperties
{
	bStatic=false
	bHidden=true
	bNoDelete=false
	CollisionRadius=+00024.000000
	CollisionHeight=+00024.000000

	MyMaterial=Texture't_interface_mb.debug.FC_RedLight'
	MaterialWidth=64
	MaterialHeight=64
	MaterialCenterU=0.5
	MaterialCenterV=0.5
	MaterialU=0
	MaterialV=0

	MyIcon=(DrawColor=(R=255,G=255,B=255,A=255),ScaleX=1.0,ScaleY=1.0,PivotU=0.5,PivotV=0.5)
	MyIconBack=(DrawColor=(R=255,G=255,B=255,A=255),ScaleX=1.0,ScaleY=1.0,PivotU=0.5,PivotV=0.5)
	//AttackAssaultIcon=(DrawColor=(R=0,G=255,B=255,A=255),ScaleX=1.0,ScaleY=1.0,PivotU=0.5,PivotV=0.5)

// GBX:PAD: We can't set a value in DefaultProperties to an enum, so setting this up as such is a problem.  For now,
// I just going to let it use the render style that is set before trying to draw it.
//	RenderStyle=ERenderStyle.STY_Alpha
	CurrentDrawColor=(R=255,B=255,G=255,A=255)
	MaxAlpha=128
	MaxScale=1.0
	DurationAppear=0.5
	DurationDisappear=0.5
	AppearScaleMultiplier=4
	DisappearScaleMultiplier=0.1

	ScreenScaleX=1.0
	ScreenScaleY=1.0

	MinDistShow=0
	MaxDistShow=-1

	MaxDistClip=5000
	MinSizeScalar=0.7
	MaxSizeScalar=1.0
	DistAtMaxSize=2000
	DistAtMinSize=3000

	FalsePerspectiveScale=1.0

	OcclusionUpdateInterval=1.0

	bDisabled=false
	
	fOpacityMultiplier = 1.0

	//targetingUnitType=UnitType_None;	//NAC added default value
}
class InWorldObjectiveIcon extends InWorldIcon;

#exec OBJ LOAD FILE=..\texture\t_interface_mb.utx

var gbxBeacons MyBeacon;

replication
{
	reliable if (bNetDirty && Role == ROLE_Authority)
		MyBeacon;
}

simulated function SetBeacon( gbxBeacons beacon )
{
	MyBeacon = beacon;
}

simulated function Actor GetAssociatedActor() 
{ 
	return MyBeacon; 
}

simulated function bool ShouldDrawForPlayer(PlayerController player)
{
	local bool result;

	//Log(self $ " InWorldObjectiveIcon::ShouldDrawForPlayer(" $ player $ " begin", 'BeaconsIcons');

	result = MyBeacon.VisibleToPlayer(player);

	if (result)
	{
		if (gbxPlayerController(player) != None)
		{
			result = gbxPlayerController(player).IsInOracleCamMode();
			
			//Log(self $ " InWorldObjectiveIcon::ShouldDrawForPlayer() IsInOracleCam returned" $ result, 'BeaconsIcons');
		}
		else
		{
			result = false;
			
			//Log(self $ " InWorldObjectiveIcon::ShouldDrawForPlayer() not a gbxPlayerController, therefore result = false", 'BeaconsIcons');
		}
	}
	else
	{
		//Log(self $ " InWorldObjectiveIcon::ShouldDrawForPlayer() beacon said visible for player is false", 'BeaconsIcons');
	}

	return result;
}

simulated function DoRenderCalculations( Canvas aCanvas )
{
	if ( ShouldDrawForPlayer( aCanvas.Viewport.Actor ) )
	{
		//Log(self $ " InWorldObjectiveIcon::DoRenderCalculations() showing icon since it should draw for player " $ aCanvas.Viewport.Actor, 'BeaconsIcons');

		Show();
	}
	else if ( !IsSplitScreen() )
	{
		//Log(self $ " InWorldObjectiveIcon::DoRenderCalculations() hiding icon since it should not draw for player " $ aCanvas.Viewport.Actor, 'BeaconsIcons');

		Hide();
	}

	Super.DoRenderCalculations( aCanvas );
}

simulated state Appearing
{
	simulated function BeginState()
	{
		if ( !IsSplitScreen() )
		{
			Super.BeginState();
		}
		else
		{
			GotoState('Shown');
		}
	}
}

simulated state Disappearing
{
	simulated function BeginState()
	{
		if ( !IsSplitScreen() )
		{
			Super.BeginState();
		}
		else
		{
			GotoState('Hidden');
		}
	}
}

defaultproperties
{
	bAlwaysTick=true
	bStatic=false
	bHidden=true
	bNoDelete=false
	CollisionRadius=+00024.000000
	CollisionHeight=+00024.000000

	MyIcon=(Icon=Texture't_interface_mb.hud.interface_comp',U=94,V=100,UL=40,VL=29,DrawColor=(R=0,G=0,B=0,A=255),ScaleX=0.45,ScaleY=0.45)	// icon_obj_primary
	MyIconBack=(Icon=Texture't_interface_mb.hud.interface_comp',U=238,V=131,UL=46,VL=46,DrawColor=(R=217,G=173,B=46,A=255),ScaleX=0.45,ScaleY=0.45)	// bg_objective

	ScreenScaleX=0.45
	ScreenScaleY=0.45

// GBX:PAD: We can't set a value in DefaultProperties to an enum, so setting this up as such is a problem.  For now,
// I just going to let it use the render style that is set before trying to draw it.
//	RenderStyle=ERenderStyle.STY_Alpha
	CurrentDrawColor=(R=255,B=255,G=255,A=255)
	MaxAlpha=196
	DurationAppear=0.5
	DurationDisappear=0.5
	AppearScaleMultiplier=4
	DisappearScaleMultiplier=0.1

	MinDistShow=0
	MaxDistShow=-1

	MaxDistClip=0
	MinSizeScalar=1.5
	MaxSizeScalar=1.5
	DistAtMaxSize=2000
	DistAtMinSize=3000

	FalsePerspectiveScale=1.0

	OcclusionUpdateInterval=0.5

	LocationOffset=(Z=0.001)
	bDisabled=false

	bAlwaysRelevant=True
	RemoteRole=ROLE_SimulatedProxy
	bSkipActorPropertyReplication=true
	bOnlyDirtyReplication=true
}
class InWorldOrderIcon extends InWorldOrderIconBase
	transient;

#exec OBJ LOAD FILE=..\texture\t_interface_mb.utx
#exec OBJ LOAD FILE=..\staticmesh\s_interface_mb.usx


var StaticMesh RingMesh;

var ColorModifier RingColorFront;
var ColorModifier RingColorBack;
var ColorModifier RingColorModFront;
var ColorModifier RingColorModFrontHi;
var ColorModifier RingColorModBack;
var ColorModifier RingColorModBackHi;

var GbxShaderMaterial RingTex;
var GbxShaderMaterial RingTexHi;
var transient StaticMeshActorDynamic Ring;


simulated function UpdateIcons( vector AimLocation )
{
	if( LastUniversalTimeSeconds == 0 )
	{
		LastUniversalTimeSeconds = Level.UniversalTimeSeconds;
	}

	// Update commanded unit number.
	MyIcon = UnitIcons[ iOrderedUnit ];

	ShowRing( false );

	// RSC: don't show the assault icon on friendlies
	if( (TargetPawn != None) && (TargetPawn.MyUnit != None) && (TargetPawn.PawnTeam != TEAM_None) && !TargetPawn.SameTeamAs(PlayerOwner.Pawn) )
	{
		// Targetting Pawn
		SetLocation( AimLocation );

		DeltaUniversalTime = Level.UniversalTimeSeconds - LastUniversalTimeSeconds;

		// Update icon rotation.
		IconRotation.Yaw += DeltaUniversalTime * 12000;

		MyIconBack = TargetPawnIcon;

		MyIcon.PivotV = 0.5;
		MyIcon.DrawColor = UnitBackgroundColors[2];
	}
	else 
	{
		IconRotation.Yaw = 0;

		MyIconBack = default.MyIconBack;

		if( TargetIcon == None )
		{
			// Move Order
			ShowRing( true );

			SetLocation( AimLocation );

			MyIconBack.DrawColor = UnitBackgroundColors[0];
		}
		else
		{
			// Target Order

			// Location is updated when the icon is drawn.

			MyIconBack.DrawColor = UnitBackgroundColors[1];

			SetLocation( TargetIcon.Location );
			MyIconBack.PivotV += AttachToEdgeVOffset;
		}
	}

	LastUniversalTimeSeconds = Level.UniversalTimeSeconds;
}

/////////////////////////////////////////////////////////////////////////////////
// Implementation functions
/////////////////////////////////////////////////////////////////////////////////

simulated function PostBeginPlay()
{
	Super.PostBeginPlay();

	Ring = Spawn( class'StaticMeshActorDynamic', Owner );
	Ring.bHidden = true;
	Log( name $ "<" $ GetStateName() $ ">.ShowRing(): Ring.bHidden=" $ Ring.bHidden, 'jmw' );
	Ring.RemoteRole = ROLE_None; //SDJ 03/17/2004: The order icon should not be replicated.
	Ring.SetDrawScale( RingMaxScale );

	Ring.bWorldGeometry = false;
	Ring.SetCollision( false, false, false );
	Ring.KSetBlockKarma( false );

	Ring.SetLocation( Location - vect(0,0,32) );

	Ring.bHardAttach = true;
	Ring.SetBase( self );
	Ring.SetStaticMesh( RingMesh );
	Ring.SetRotation( rotator( vect(1,0,0) ));
	Ring.bOnlyOwnerSee = true;	// PSV: 8/3/2004: Only the player controlling this should see it in the world.
	Ring.SetOwner( Owner );
	Ring.Skins[0] = RingTex;

	GotoState( 'Hidden' );
}

simulated function Destroyed()
{
	Ring.Destroy();

	Super.Destroyed();
}

simulated function DrawGBXHud(canvas aCanvas, gbxHud Hud, FontInfo Fonts, int nPass)
{
	local float RingScale;
	local float ScaleProportion;		// How far along in the tween are we, range (0,1) where 0=start of tween and 1=end of tween.
	local vector scaleVec;

	if( aCanvas.Viewport.Actor != PlayerOwner )
	{
		return;
	}		

	if (nPass == 0)
	{
		Super.DrawGBXHud( aCanvas, Hud, Fonts, nPass );

		// If targetting (and rendering), keep position on the unit.
		if( bRenderIcon )
		{
			RingColorFront.Color.A = CurrentAlpha;
			RingColorBack.Color.A = CurrentAlpha / 2;

			if( bTweening )
			{
				ScaleProportion = ( CurrentScaleX - TweenScaleXEnd ) / ( TweenScaleXStart - TweenScaleXEnd );
			}
			else
			{
				ScaleProportion = 0;
			}

			RingScale = RingMinScale + ScaleProportion * ( RingMaxScale - RingMinScale );

			scaleVec.X = RingScale;
			scaleVec.Y = RingScale;
			scaleVec.Z = RingMinScale;
			Ring.SetDrawScale3D( scaleVec );

			if( TargetIcon != None )
			{
				SetLocation( TargetIcon.Location );
				MyIconBack.PivotV = default.MyIconBack.PivotV + AttachToEdgeVOffset;
			}
		}
	}
}

simulated function ShowRing( bool bShow )
{
	Ring.bHidden = !bShow;
	Log( name $ "<" $ GetStateName() $ ">.ShowRing(): Ring.bHidden=" $ Ring.bHidden, 'jmw' );
}


/////////////////////////////////////////////////////////////////////////////////
// States
/////////////////////////////////////////////////////////////////////////////////

simulated state Appearing
{
	simulated function BeginState()
	{
		Super.BeginState();

		TweenSpinStart = 0;
		TweenSpinEnd = 0x3fff;

		ShowRing( TargetPawn == None && TargetIcon == None );		// Move order only.
	}

	simulated function StartTween()
	{
		Super.StartTween();
		RingColorFront = RingColorModFront;
		RingColorBack = RingColorModBack;
		RingColorFront.Color.A = 0;
		RingColorBack.Color.A = 0;
	}
}

simulated state Executing
{
	simulated function BeginState()
	{
		local vector scaleVec;
		// Fully show the icon and ring, as with the shown state.

		Super.BeginState();
		scaleVec.X = RingMinScale;
		scaleVec.Y = RingMinScale;
		scaleVec.Z = RingMinScale;
		Ring.SetDrawScale3D( scaleVec );

		ShowRing( TargetPawn == None && TargetIcon == None );		// Move order only.
	}

	simulated function Highlight()
	{
		Super.Highlight();
		RingColorFront = RingColorModFrontHi;
		RingColorBack = RingColorModBackHi;
		Ring.Skins[0] = RingTex;
	}

	simulated function DeHighlight()
	{
		Super.DeHighlight();
		RingColorFront = RingColorModFront;
		RingColorBack = RingColorModBack;
		Ring.Skins[0] = RingTexHi;
	}
}

simulated state Targetting
{
	simulated function Highlight()
	{
		Super.Highlight();
		RingColorFront = RingColorModFrontHi;
		RingColorBack = RingColorModBackHi;
		Ring.Skins[0] = RingTex;
	}

	simulated function DeHighlight()
	{
		Super.DeHighlight();
		RingColorFront = RingColorModFront;
		RingColorBack = RingColorModBack;
		Ring.Skins[0] = RingTexHi;
	}
}

defaultproperties
{
	MyIconBack=(Icon=Texture't_interface_mb.hud.interface_comp',U=480,V=186,UL=32,VL=50,DrawColor=(R=255,G=255,B=255,A=255),ScaleX=0.9,ScaleY=0.9,PivotU=0.5,PivotV=1.0)	// command_tab

	LocationOffset=(Z=0.008)
	RingMinScale=0.3
	RingMaxScale=2

	AttachToEdgeVOffset=0.5

	RingColorModFront=ColorModifier't_interface_mb.hud.ring_mod_b_front'
	RingColorModFrontHi=ColorModifier't_interface_mb.hud.ring_mod_y_front'
	
	RingColorModBack=ColorModifier't_interface_mb.hud.ring_mod_b_back'
	RingColorModBackHi=ColorModifier't_interface_mb.hud.ring_mod_y_back'

	RingTex=GbxShaderMaterial't_interface_mb.hud.ring_b_gs'
	RingTexHi=GbxShaderMaterial't_interface_mb.hud.ring_y_gs'

	RingMesh=StaticMesh's_interface_mb.command.command_move'
}class InWorldOrderIconB extends InWorldOrderIconBase
	transient;


var	Canvas.CanvasIcon	MyIconInvalid;

var bool bIsValid;
var bool bTweenRingScale;
var float TweenRingScaleStart;
var float TweenRingScaleEnd;
var float TweenRingScaleTimeStart;
var float TweenRingScaleDuration;

var DynamicProjector RingProjector;


simulated function bool MarkValid( bool isValid )
{
	bIsValid = isValid;
	return true;
}



simulated function UpdateIcons( vector AimLocation )
{
	local Actor HitActor;
	local vector HitLocation, HitNormal;

	if( LastUniversalTimeSeconds == 0 )
	{
		LastUniversalTimeSeconds = Level.UniversalTimeSeconds;
	}

	// Update commanded unit number.
	MyIcon = UnitIcons[ iOrderedUnit ];

	if( bIsValid )
	{
		MyIconBack = default.MyIconBack;

		if( (TargetPawn != None) && (TargetPawn.MyUnit != None) && (TargetPawn.PawnTeam != TEAM_None) && !TargetPawn.SameTeamAs(PlayerOwner.Pawn) )
		{
			// Targetting Pawn
			SetLocation( AimLocation );

			RingProjector.MaxTraceDistance = 0;

			DeltaUniversalTime = Level.UniversalTimeSeconds - LastUniversalTimeSeconds;

			// Update icon rotation.
			IconRotation.Yaw += DeltaUniversalTime * 12000;

			// Show a bullseye over the pawn.
			MyIconBack = TargetPawnIcon;
			MyIcon.PivotV = 0.5;
			MyIcon.DrawColor.R = 0;
			MyIcon.DrawColor.G = 0;
			MyIcon.DrawColor.B = 0;
				//UnitBackgroundColors[2];
		}
		else 
		{
			IconRotation.Yaw = 0;

			if( TargetIcon == None )
			{
				// Move Order
				SetLocation( AimLocation );

				// Update projector position
				HitActor = Trace(
					HitLocation,
					HitNormal,
					Location + vect( 0, 0, -1000 ),
					Location + vect( 0, 0, 256 ),
					false,
					vect( 512, 512, 0 )
				);
				if( HitActor != None )
				{
					RingProjector.SetLocation( HitLocation + vect( 0, 0, 32 ));
				}
				else
				{
					RingProjector.SetLocation( Location + vect( 0, 0, 4 ));
				}
				RingProjector.MaxTraceDistance = 512;

				MyIconBack.DrawColor = UnitBackgroundColors[0];
			}
			else
			{
				// Target Order

				// Location is updated when the icon is drawn.

				MyIconBack.DrawColor = UnitBackgroundColors[1];

				RingProjector.MaxTraceDistance = 0;

				SetLocation( TargetIcon.Location );
				MyIconBack.PivotV += AttachToEdgeVOffset;
			}
		}
	}
	else
	{
		MyIconBack = MyIconInvalid;
		SetLocation( AimLocation );
		RingProjector.MaxTraceDistance = 0;
	}

	LastUniversalTimeSeconds = Level.UniversalTimeSeconds;
}

/////////////////////////////////////////////////////////////////////////////////
// Implementation functions
/////////////////////////////////////////////////////////////////////////////////

simulated function PostBeginPlay()
{
	Super.PostBeginPlay();

	RingProjector = Spawn( class'CommandRing', Owner,, Location + vect( 0, 0, 4 ), rotator( vect( 0, 0, -1 )) );
	RingProjector.SetDrawScale( RingMaxScale );
//	RingProjector.bHardAttach = true;
//	RingProjector.SetBase( self );

	GotoState( 'Appearing' );
}

simulated function Destroyed()
{
	RingProjector.Destroy();

	Super.Destroyed();
}

simulated function DrawGBXHud(canvas aCanvas, gbxHud Hud, FontInfo Fonts, int nPass)
{
	local float ScaleProportion;		// How far along in the tween are we, range (0,1) where 0=start of tween and 1=end of tween.

	if( aCanvas.Viewport.Actor != PlayerOwner )
	{
		return;
	}		

	if (nPass == 0)
	{
		Super.DrawGBXHud( aCanvas, Hud, Fonts, nPass );

		// Update ring.
		if( !bRenderIcon || TargetIcon != None || TargetPawn != None )
		{
			RingProjector.MaxTraceDistance = 0;
		}
		else
		{
			RingProjector.MaxTraceDistance = 512;
		}

		// If targetting (and rendering), keep position on the unit.
		if( bRenderIcon )
		{
//			RingColorModifier.Color.A = CurrentAlpha;

			if( bTweenRingScale )
			{
				ScaleProportion = Sin( FClamp(( Level.UniversalTimeSeconds - TweenRingScaleTimeStart ) / TweenRingScaleDuration, 0.0, 1.0 ));
				RingProjector.SetDrawScale( TweenRingScaleStart + ScaleProportion * ( TweenRingScaleEnd - TweenRingScaleStart ) );
			}
			else
			{
				RingProjector.SetDrawScale( TweenRingScaleEnd );
			}

			if( TargetIcon != None )
			{
				SetLocation( TargetIcon.Location );
				MyIconBack.PivotV = default.MyIconBack.PivotV + AttachToEdgeVOffset;
			}
		}
	}
}

simulated function SetAssaulting( bool bIsAssaulting )
{
	// Sets what order this unit currenty has stored up against said enemy
	bIsAssaultCommand = bIsAssaulting;	
}

// Replace this with a different accessor when you have more than just two commands.
simulated function bool IsAssaultCommand()
{
	return bIsAssaultCommand;
}


/////////////////////////////////////////////////////////////////////////////////
// States
/////////////////////////////////////////////////////////////////////////////////

simulated state Appearing
{
	simulated function BeginState()
	{
		Super.BeginState();

		bTweenRingScale = true;

		TweenRingScaleStart = RingMaxScale;
		TweenRingScaleEnd = RingMinScale;
		TweenRingScaleDuration = DurationAppear;
		TweenRingScaleTimeStart = Level.UniversalTimeSeconds;
		RingProjector.SetDrawScale( TweenRingScaleStart );
	}
}

defaultproperties
{
	MyIconBack=(Icon=Texture't_interface_mb.hud.interface_comp',U=480,V=186,UL=32,VL=50,DrawColor=(R=255,G=255,B=255,A=255),ScaleX=0.9,ScaleY=0.9,PivotU=0.5,PivotV=1.0)	// command_tab
	MyIconInvalid=(Icon=Texture't_interface_mb.HUD.dead_x',U=0,V=0,UL=64,VL=64,DrawColor=(R=255,G=255,B=255,A=255),ScaleX=1.0,ScaleY=1.0,PivotU=0.5,PivotV=0.5)	// invalid-X

	LocationOffset=(Z=0.0)
	RingMinScale=1
	RingMaxScale=2

	AttachToEdgeVOffset=1.5
}
class InWorldOrderIconBase extends InWorldIcon
	abstract
	transient;

// This class is responsible for managing the display of the in-world order icon UI element.

#exec OBJ LOAD FILE=..\texture\t_interface_mb.utx

var() float RingMinScale;
var() float RingMaxScale;

var() float AttachToEdgeVOffset;
var() float PeerOffsetDistance;

var bool bIsAssaultCommand;	// Replace this with an enum in Object.uc when you need more than two squad commands.

var() Color		UnitBackgroundColors[ 3 ];	// normal high targetted
var() Canvas.CanvasIcon	UnitIcons[ 3 ];
var() Canvas.CanvasIcon	TargetPawnIcon;
var() Canvas.CanvasIcon AssaultIcon;  //NAC: added for new assault icon
//var() Canvas.CanvasIcon	AttackAssaultIcon;  //NAC: added for assault

var() float ExecutingLingerTime;

var float TweenSpinStart;
var float TweenSpinEnd;

var float DeltaUniversalTime;
var float LastUniversalTimeSeconds;

var()	protected Material	MyArrowMaterial;
var()	int					ArrowMaterialWidth;
var()	int					ArrowMaterialHeight;
var()	int					ArrowMaterialU;
var()	int					ArrowMaterialV;

//var Unit TargetUnit;
var InWorldIcon TargetIcon;
var gbxPawn TargetPawn;

var byte iOrderedUnit;
var int  iOrderedUnitSlot;
var InWorldIcon ReplacedOrderIcon;

// State "local" variables.
var int iCount;

var const float AssaultSwellScale;	// The factor to "swell" the order icon by when it indicates an "assault" command.

var PlayerController PlayerOwner;	// PSV: 8/3/2004 Added member variable because rendering code needs Owner to point to player pawn.

/////////////////////////////////////////////////////////////////////////////////
// API functions
/////////////////////////////////////////////////////////////////////////////////

simulated function bool IsShownInternal()
{
	return Super.IsShownInternal() || IsInState( 'Attaching' );
}

simulated function SetPlayerOwner( PlayerController PC )
{
	PlayerOwner = PC;
}

simulated function bool MarkValid( bool isValid )
{
	return isValid;
}

simulated function Update( 
	int ndxOrderedUnitSlot,
	byte ndxOrderedUnit, 
	bool IsAtValidPosition, 
	vector AimLocation, 
	InWorldIcon aTargetIcon, 
	gbxPawn aTargetPawn, 
	Vector GroundNormal )
{
/*	Log( name $ "<" $ GetStateName() $ ">.Update( " $ 
		ndxOrderedUnitSlot $ ", " $ 
		ndxOrderedUnit $ ", " $ 
		IsAtValidPosition $ ", " $ 
		AimLocation $ ", " $ 
		aTargetIcon $ ", " $ 
		aTargetPawn $ ", " $ 
		GroundNormal $ ", " $ 
		" )", 'jmw' );
*/
	if( bShow )
	{
		if( MarkValid( IsAtValidPosition ))
		{
			ShowInternal();

			// Should we highlight the target or the move order location?

			if( aTargetIcon == None && aTargetPawn == None && ( IsInState( 'Attaching' ) || IsInState( 'AttachedToParent' )))
			{
				GotoState( 'Shown' );
			}

			TargetIcon = aTargetIcon;
			TargetPawn = aTargetPawn;
			iOrderedUnitSlot = ndxOrderedUnitSlot;
			iOrderedUnit = ndxOrderedUnit;

			
		}
		else
		{
			HideInternal();
		}

		UpdateIcons( AimLocation );
	}

	// Has anything changed about my attachment? Have I changed what unit icon I'm attached to or what slot I'm in?
	if( AttachedParent != TargetIcon || iAttachedParentSlot != iOrderedUnitSlot )
	{
		// Reinstate my current replacement, if any. In any case, detach.
		if( ReplacedOrderIcon != None )
		{
			// This will detach me from the parent and nullify AttachedParent.				
			AttachedParent.AttachIcon( ReplacedOrderIcon, ReplacedOrderIcon.iAttachedParentSlot, true );
			ReplacedOrderIcon = None;
		}
		else
		{
			DetachFromParent( true );
		}

		if( TargetIcon != None )
		{
			// Stow away the order icon I'm about to replace.
			if( TargetIcon.AttachedIcons.Length >= iOrderedUnitSlot )
			{
				ReplacedOrderIcon = TargetIcon.AttachedIcons[ iOrderedUnitSlot ];
				if( ReplacedOrderIcon != None )
				{
					ReplacedOrderIcon.GotoState( 'StowedAway' );
				}
			}

			// Attach myself.
			TargetIcon.AttachIcon( Self, iOrderedUnitSlot, true );
			GotoState( 'Attaching' );
		}
	}
}

simulated function Destroyed()
{
	if( ReplacedOrderIcon != None )
	{
		if( AttachedParent != None )
		{
			// This will detach me from the parent and nullify AttachedParent.				
			AttachedParent.AttachIcon( ReplacedOrderIcon, ReplacedOrderIcon.iAttachedParentSlot, true );
		}
		else
		{
			ReplacedOrderIcon.Destroy();
		}
	}

	TargetIcon = None;  // prevent references to/in destroyed objects
	TargetPawn = None;
	ReplacedOrderIcon = None;
	PlayerOwner = None;

	Super.Destroyed();
}

simulated function UpdateIcons( vector AimLocation )
{
	// Implemented in subclasses.
}

simulated function DoTweenCalculations()
{
	local float TweenProportion; 

	Super.DoTweenCalculations();

//	Log( name $ "<" $ GetStateName() $ ">.DoTweenCalculations(): TargetPawn==" $ TargetPawn, 'jmw' );

	if( TargetPawn != None && ( IsInState( 'Appearing' ) || IsInState( 'Disappearing' )) )
	{
		TweenProportion = Sin( FClamp(( Level.UniversalTimeSeconds - TweenTimeStart ) / TweenDuration, 0.0, 1.0 ));

		IconRotation.Yaw = TweenSpinStart + TweenProportion * ( TweenSpinEnd - TweenSpinStart );
	}
}

simulated function Hide()
{
	Log( name $ "<" $ GetStateName() $ ">.Hide()", 'jmw' );
	Super.Hide();
}

simulated function Execute()
{
	// Flicker the icon, then hide.

	Log( name $ "<" $ GetStateName() $ ">.Execute()", 'jmw' );

	// Already gone or on its way out?
	if( !IsShown() )
	{
		return;
	}
	else
	{
		if( TargetPawn != None )
		{
			bShow = false;
			GotoState( 'ExecutingTargetPawn' );
		}
		else if( TargetIcon == None )
		{
			bShow = false;
			GotoState( 'Executing' );
		}
		else
		{
			bShow = true;
			GotoState( 'Targetting' );
		}
	}
}

/////////////////////////////////////////////////////////////////////////////////
// Implementation functions
/////////////////////////////////////////////////////////////////////////////////

simulated function RenderAssaultArrows( Canvas aCanvas, gbxHUD Hud )
{
	aCanvas.DrawTile3D(
		MyArrowMaterial,
		TargetIcon.GetWorldLocation( aCanvas ),
		2.0 * ArrowMaterialWidth * TargetIcon.CurrentScaleX * TargetIcon.FalsePerspectiveScale * TargetIcon.ScreenScaleX * Hud.flMinScaleX,
		2.0 * ArrowMaterialHeight * TargetIcon.CurrentScaleY * TargetIcon.FalsePerspectiveScale * TargetIcon.ScreenScaleY * Hud.flMinScaleY,
		0, 0, 
		ArrowMaterialWidth, ArrowMaterialWidth );
}

simulated function SetAssaulting( bool bIsAssaulting )
{
	// Sets what order this unit currenty has stored up against said enemy
	bIsAssaultCommand = bIsAssaulting;	
}

// Replace this with a different accessor when you have more than just two commands.
simulated function bool IsAssaultCommand()
{
	return bIsAssaultCommand;
}

simulated function ShowRing( bool bShow )
{
	// Implemented in subclasses.
}



/////////////////////////////////////////////////////////////////////////////////
// States
/////////////////////////////////////////////////////////////////////////////////

simulated state Appearing
{
	simulated function BeginState()
	{
		Super.BeginState();

		TweenSpinStart = 0;
		TweenSpinEnd = 0x3fff;
	}

	simulated function StartTween()
	{
		Super.StartTween();
		ShowRing( true );
	}

}

simulated state Shown
{
	simulated function BeginState()
	{
		Super.BeginState();

		ShowRing( true );
	}
}

simulated state Disappearing
{
	simulated function BeginState()
	{
		Super.BeginState();

		if( TargetPawn != None )
		{
			TweenSpinStart = IconRotation.Yaw;
			TweenSpinEnd = IconRotation.Yaw - 0xffff;

			TweenScaleXEnd = RingMaxScale;
			TweenScaleYEnd = TweenScaleXEnd;
		}
	}
Begin:
	//Log(self $ " InWorldIcon::State Code[Disappearing] begin", 'BeaconsIcons');
	Sleep( TweenDuration );
	//Log(self $ " InWorldIcon::State Code[Disappearing] end, going to Hidden state", 'BeaconsIcons');
	GotoState( 'Hidden' );

}

simulated state Executing
{
	simulated function BeginState()
	{
		// Fully show the icon and ring, as with the shown state.

		Global.BeginState();

		bRenderIcon = true;

		bTweening = false;

		CurrentAlpha = MaxAlpha;
		CurrentScaleX = 1;
		CurrentScaleY = CurrentScaleX;

		MyIcon = UnitIcons[ iOrderedUnit ];

		//if( TargetUnit == None )
		if( TargetIcon == None )
		{
			// Move Order
			MyIconBack.DrawColor = UnitBackgroundColors[0];
		}
		else
		{
			// Target Order
			MyIconBack.DrawColor = UnitBackgroundColors[2];
		}
	}

	simulated function Highlight()
	{
		MyIconBack.DrawColor = UnitBackgroundColors[1];
	}

	simulated function DeHighlight()
	{
		if (TargetIcon == None)
			MyIconBack.DrawColor = UnitBackgroundColors[0];
		else
			MyIconBack.DrawColor = UnitBackgroundColors[2];
	}

Begin:

	// Flash the highlights a few times.
	for( iCount = 0; iCount < 6; ++iCount )
	{
		if(( iCount & 1 ) == 0 )	// Even number
		{
			Highlight();
		}
		else
		{
			DeHighlight();
		}

		Sleep( 0.06 );
	}

	// Tween to pale, then wait a moment.
	bTweening = true;

	TweenTimeStart = Level.UniversalTimeSeconds;
	TweenDuration  = DurationDisappear;

	TweenAlphaStart = CurrentAlpha;
	TweenScaleXStart = CurrentScaleX;
	TweenScaleYStart = CurrentScaleY;

	TweenAlphaEnd = 128;
	TweenScaleXEnd = CurrentScaleX;
	TweenScaleYEnd = TweenScaleXEnd;

	Sleep( ExecutingLingerTime );

	GotoState( 'Disappearing' );
}

simulated state ExecutingTargetPawn extends Executing
{
	simulated function BeginState()
	{
		Global.BeginState();

		bRenderIcon = true;

		bTweening = false;

		CurrentAlpha = MaxAlpha;
		CurrentScaleX = 1;
		CurrentScaleY = CurrentScaleX;
	}

	simulated function DrawGBXHud(canvas aCanvas, gbxHud Hud, FontInfo Fonts, int nPass)
	{
		// Target pawn order

		if( LastUniversalTimeSeconds == 0 )
		{
			LastUniversalTimeSeconds = Level.UniversalTimeSeconds;
		}

		DeltaUniversalTime = Level.UniversalTimeSeconds - LastUniversalTimeSeconds;

		// Update icon rotation.
		IconRotation.Yaw += DeltaUniversalTime * 6000;

		super.DrawGBXHud( aCanvas, Hud, Fonts, nPass );
		//RenderTag(aCanvas,Hud);

		LastUniversalTimeSeconds = Level.UniversalTimeSeconds;
	}

Begin:

	// Flash the highlights a few times.
	if (bIsAssaultCommand){
		MyIconBack = AssaultIcon; //NAC: added new assault icon
	}
	for( iCount = 0; iCount < 6; ++iCount )
	{
		if(( iCount & 1 ) == 0 )	// Even number
		{
			MyIcon.DrawColor = UnitBackgroundColors[1];
			MyIconBack.DrawColor = UnitBackgroundColors[1];
		}
		else
		{
			MyIcon.DrawColor = UnitBackgroundColors[2];
			MyIconBack.DrawColor = UnitBackgroundColors[2];
		}

		Sleep( 0.06 );
	}

	// If assault order, use the bright color.
	if( bIsAssaultCommand )
	{
		MyIcon.DrawColor = UnitBackgroundColors[1];
		MyIconBack.DrawColor = UnitBackgroundColors[1];
	}

	// Tween to pale, then wait a moment.
	bTweening = true;

	TweenTimeStart = Level.UniversalTimeSeconds;
	TweenDuration  = DurationDisappear;

	TweenAlphaStart = CurrentAlpha;
	TweenScaleXStart = CurrentScaleX;
	TweenScaleYStart = CurrentScaleY;

	TweenAlphaEnd = 128;
	TweenScaleXEnd = CurrentScaleX;
	TweenScaleYEnd = TweenScaleXEnd;

	Sleep( ExecutingLingerTime );

	GotoState( 'Disappearing' );
}

simulated state AttachedToParent
{
	simulated function BeginState()
	{
		Global.BeginState();
		ShowRing( false );
	}

	simulated function vector GetWorldLocation( Canvas aCanvas )
	{
		local vector baseLoc, rightVec, camLocation;
		local float offsetSign, distCamera;

		if( AttachedParent == None )
		{
			Log( name $ "<" $ GetStateName() $ ">.GetWorldLocation( " $ aCanvas $ " ): WARNING: AttachedParent == None.", 'JMW' );
		}

		if( AttachedParent != None && AttachedParent.GetNumAttachedIcons() > 1 )
		{
			if(( iOrderedUnitSlot & 1 ) == 0 )
			{
				offsetSign = 1;
			}
			else
			{
				offsetSign = -1;
			}
		}
		else
		{
			offsetSign = 0;
		}

		//Log( name $ "<" $ GetStateName() $ ">.GetWorldLocation( " $ aCanvas $ " ): iOrderedUnit=" $ iOrderedUnit $ ", offsetSign=" $ offsetSign, 'JMW' );

		camLocation = GetCameraLocation( aCanvas );
		baseLoc = Super.GetWorldLocation( aCanvas );
		rightVec = Normal(( baseLoc - camLocation ) cross vect(0,0,1));

		distCamera = VSize( CamLocation - baseLoc );

		return baseLoc + GetScreenToWorldDelta( rightVec * ( offsetSign * PeerOffsetDistance ), distCamera );
	}

	// GBX:naj - added 2/23/04
	simulated function RenderIcon( Canvas aCanvas, gbxHud Hud )
	{
		if ( bIsAssaultCommand )
		{
			CurrentScaleX *= 1.2;
			CurrentScaleY *= 1.2;
			RenderAssaultArrows( aCanvas, Hud );
		}

		Super.RenderIcon( aCanvas, Hud );
	}
}

simulated state Attaching extends AttachedToParent
{

	simulated function BeginState()
	{
		Global.BeginState();

		bRenderIcon = true;

		bTweening = false;

		CurrentAlpha = MaxAlpha;

		MyIcon = UnitIcons[ iOrderedUnit ];

		ShowRing( false );

		// Target Order
		MyIconBack.DrawColor = UnitBackgroundColors[1];
	}

/*	function BeginState()
	{
		Super.BeginState();		
	}
*/

	simulated function UpdateIcons( vector AimLocation )
	{
		// Target Order
	}

	// GBX:naj - added 2/23/04
	simulated function RenderIcon( Canvas aCanvas, gbxHud Hud )
	{
		if ( bIsAssaultCommand )
		{
			CurrentScaleX *= AssaultSwellScale;
			CurrentScaleY *= AssaultSwellScale;
		}

		Super.RenderIcon( aCanvas, Hud );
	}

Begin:

	// Flicker the ring a few times toward target color

	for( iCount = 0; iCount < 7; ++iCount )
	{
		if(( iCount & 1 ) == 0 )	// Even number
		{
			MyIconBack.DrawColor = UnitBackgroundColors[1];
		}
		else
		{
			MyIconBack.DrawColor = UnitBackgroundColors[0];
		}

		Sleep( 0.08 );
	}

	GotoState( 'AttachedToParent' );
}

state Hidden
{
	simulated function BeginState()
	{
		ShowRing( false );
		bShow = false;
		Super.BeginState();
	}
}

state StowedAway extends Hidden
{
	simulated function Update(
		int ndxOrderedUnitSlot,
		byte ndxOrderedUnit, 
		bool IsAtValidPosition, 
		vector AimLocation, 
		InWorldIcon aTargetIcon, 
		gbxPawn aTargetPawn, 
		Vector GroundNormal )
	{
	}

	simulated function Show()
	{
	}

	simulated function Hide()
	{
	}

	simulated function ShowInternal()
	{
	}

	simulated function HideInternal()
	{
	}
}

simulated state Targetting extends AttachedToParent
{
	simulated function BeginState()
	{
		Global.BeginState();

		bRenderIcon = true;

		bTweening = false;

		CurrentAlpha = MaxAlpha;

		MyIcon = UnitIcons[ iOrderedUnit ];

		ShowRing( false );

		MyIconBack.DrawColor = UnitBackgroundColors[2];
	}

	simulated function Highlight()
	{
		MyIconBack.DrawColor = UnitBackgroundColors[1];
	}

	simulated function DeHighlight()
	{
		MyIconBack.DrawColor = UnitBackgroundColors[2];
	}

Begin:

	// Flash the highlights a few times.
	for( iCount = 0; iCount < 6; ++iCount )
	{
		if(( iCount & 1 ) == 0 )	// Even number
		{
			Highlight();
		}
		else
		{
			DeHighlight();
		}

		Sleep( 0.06 );
	}

	// Tween to pale
	bTweening = true;

	TweenTimeStart = Level.UniversalTimeSeconds;
	TweenDuration  = DurationDisappear;

	TweenAlphaStart = CurrentAlpha;
	TweenScaleXStart = CurrentScaleX;
	TweenScaleYStart = CurrentScaleY;
	TweenScaleXEnd = CurrentScaleX;
	TweenScaleYEnd = CurrentScaleY;

	TweenAlphaEnd = 128;

	GotoState( 'AttachedToParent' );
}

defaultproperties
{
	MyIconBack=(Icon=Texture't_interface_mb.hud.interface_comp',U=480,V=186,UL=32,VL=50,DrawColor=(R=255,G=255,B=255,A=255),ScaleX=0.9,ScaleY=0.9,PivotU=0.5,PivotV=1.0)	// command_tab
	
	UnitBackgroundColors(0)=(R=99,G=117,B=165,A=255)	// normal
	UnitBackgroundColors(1)=(R=250,G=218,B=77,A=255)	// hi
	UnitBackgroundColors(2)=(R=176,G=57,B=30,A=255)		// red (target)

	UnitIcons(0)=(Icon=Texture't_interface_mb.hud.interface_comp',U=132,V=93,UL=40,VL=36,DrawColor=(R=0,G=0,B=0,A=255),ScaleX=0.5,ScaleY=0.5,PivotU=0.5,PivotV=0.9)	// icon_team_assault
	UnitIcons(1)=(Icon=Texture't_interface_mb.hud.interface_comp',U=214,V=105,UL=40,VL=24,DrawColor=(R=0,G=0,B=0,A=255),ScaleX=0.45,ScaleY=0.45,PivotU=0.5,PivotV=1.0)	// icon_team_fire
	UnitIcons(2)=(Icon=Texture't_interface_mb.hud.interface_comp',U=174,V=106,UL=40,VL=23,DrawColor=(R=0,G=0,B=0,A=255),ScaleX=0.45,ScaleY=0.45,PivotU=0.5,PivotV=1.0)	// icon_team_tank

	TargetPawnIcon=(Icon=Texture't_interface_mb.hud.team_fire',U=0,V=0,UL=64,VL=64,DrawColor=(R=176,G=57,B=30,A=255),ScaleX=1,ScaleY=1,PivotU=0.5,PivotV=0.5)  //NAC: changed for new icon
	AssaultIcon=(Icon=Texture't_interface_mb.hud.team_assault',U=0,V=0,UL=64,VL=64,DrawColor=(R=176,G=57,B=30,A=255),ScaleX=1,ScaleY=1,PivotU=0.5,PivotV=0.5)  //NAC: added for new assault icon
	//AttackAssaultIcon=(Icon=Texture't_interface_mb.hud.interface_comp',U=480,V=186,UL=32,VL=50,DrawColor=(R=255,G=255,B=255,A=255),ScaleX=0.9,ScaleY=0.9,PivotU=0.5,PivotV=1.0)	// command_tab NAC

	MaterialWidth=32
	MaterialHeight=64
	MaterialCenterU=0.5
	MaterialCenterV=1.0

	ScreenScaleX=0.9
	ScreenScaleY=0.9


// GBX:PAD: We can't set a value in DefaultProperties to an enum, so setting this up as such is a problem.  For now,
// I just going to let it use the render style that is set before trying to draw it.
//	RenderStyle=ERenderStyle.STY_Alpha
	CurrentDrawColor=(R=255,B=255,G=255,A=255)
	MaxAlpha=255
	DurationAppear=0.3
	DurationDisappear=0.2
	AppearScaleMultiplier=4
	DisappearScaleMultiplier=1.0

	LocationOffset=(Z=0.008)

	MinDistShow=0
	MaxDistShow=-1

	MaxDistClip=0
	MinSizeScalar=0.4
	MaxSizeScalar=1.0
	DistAtMaxSize=500
	DistAtMinSize=3000
	
	ExecutingLingerTime=2.0

	UpdateInterval=0
	OcclusionUpdateInterval=0

	RingMinScale=0.5
	RingMaxScale=2

	AttachToEdgeVOffset=0.5

	PeerOffsetDistance=0.006

	AssaultSwellScale=1.2


	MyArrowMaterial=material't_interface_mb.debug.AssaultIcon'
	ArrowMaterialWidth=64
	ArrowMaterialHeight=64
	ArrowMaterialU=0
	ArrowMaterialV=0


}
class InWorldSoldierIcon extends InWorldIcon;

#exec OBJ LOAD FILE=..\texture\t_interface_mb.utx



defaultproperties
{
	bAlwaysTick=true
	bStatic=false
	bHidden=true
	bNoDelete=false
	CollisionRadius=+00024.000000
	CollisionHeight=+00024.000000

	MyMaterial=Texture't_interface_mb.hud.interface_comp'
	MaterialWidth=46
	MaterialHeight=46

// GBX:PAD: We can't set a value in DefaultProperties to an enum, so setting this up as such is a problem.  For now,
// I just going to let it use the render style that is set before trying to draw it.
//	RenderStyle=ERenderStyle.STY_Alpha
	CurrentDrawColor=(R=255,B=255,G=255,A=255)
	MaxAlpha=196
	DurationAppear=0.5
	DurationDisappear=0.5
	AppearScaleMultiplier=4
	DisappearScaleMultiplier=0.1

	MinDistShow=0
	MaxDistShow=-1

	MaxDistClip=0
	MinSizeScalar=0.4
	MaxSizeScalar=0.5
	DistAtMaxSize=2000
	DistAtMinSize=3000

	FalsePerspectiveScale=1.0

	OcclusionUpdateInterval=0.5

	LocationOffset=(Z=0.008)
	bDisabled=false
}
class InWorldTurretIcon extends InWorldAttachTarget
	native;

//#exec OBJ LOAD FILE=..\texture\t_interface_mb.utx

var TurretWeapon MyTurret;

function SetTurret( TurretWeapon aTurret )
{
	MyTurret = aTurret;
}

simulated function Actor GetAssociatedActor() 
{ 
	return MyTurret; 
}

simulated function bool CanAcceptAttachmentsFrom( Pawn Attacher ) 
{ 
	return true; 
}

// TEMP DEBUG - Remove this when you want turret icons to show up again.
simulated function Show()
{
}


defaultproperties
{
	LocationOffset=(Z=0.008)
}
class InWorldUnitIcon extends InWorldAttachTarget
	native;

#exec OBJ LOAD FILE=..\texture\t_interface_mb.utx



var   Unit  MyUnit;
var() Color ClockColorUnsuppressed;
var() Color ClockColorSuppressed;
var   Color CurrentClockColor;
var() Color BackgroundColor;
var   Color CurrentBackgroundColor;
var   float ClockPercentage;
var   int   ReplicatedClockPercentage;
var   bool  ShouldFlashClock;
var   int   ReplicatedShouldFlashClock;
var   int   LastReplicatedShouldFlashClock;
var() Color FlashColor;
var() float FlashLerpAlpha;

var	  bool	bOrderMode;
var   bool  bIsSuppressed;

var()	protected Material	MyClockMaterial;
var()	int					ClockMaterialWidth;		// TODO make private and internally calculated.
var()	int					ClockMaterialHeight;		// TODO make private and internally calculated.
var()	int					ClockMaterialU;
var()	int					ClockMaterialV;

var()	Canvas.CanvasIcon	IconClock;
var()	Canvas.CanvasIcon	IconUSUnit;
var()	Canvas.CanvasIcon	IconGermanUnit;
var()	Canvas.CanvasIcon	IconUnitBack;

//NAC+: added the following variables for targeted UnitIcon attachment
var	Canvas.CanvasIcon	AttackAssaultIcon;  //NAC: added for assault
var byte	bTargeted;			//NAC: is this unit targeted?
var float	PeerOffsetDistance;
var   Color UnitAttacking;
var   Color UnitAssaulting;
//NAC-

var()	Color				BackgroundUSColor;
var()	Color				BackgroundGermanColor;

replication
{
	reliable if( bNetDirty && (Role==ROLE_Authority) )
        MyUnit, bIsSuppressed;
        
	unreliable if( bNetDirty && (Role==ROLE_Authority) )
        ReplicatedClockPercentage, ReplicatedShouldFlashClock;
}


simulated function SetOrderMode( bool bOrdering )
{
	bOrderMode = bOrdering;

	if( bOrderMode )
	{
		MinDistShow = 0;
		Show();
	}
	else
	{
		MinDistShow = default.MinDistShow;
		Hide();
	}
}

simulated function SetSuppressed( bool bSuppressed )
{
	// The first time the unit goes from unsuppressed to suppressed, take all of the "red" out of the color.
	if ( !bIsSuppressed && bSuppressed )
	{
		CurrentClockColor.R = 255;
		CurrentClockColor.G = 255;
		CurrentClockColor.B = 255;
	}

	if (bIsSuppressed != bSuppressed)
	{
		bIsSuppressed = bSuppressed;
	}
}

simulated function DoRenderCalculations( Canvas aCanvas )
{	
	if( MyUnit != None &&
		aCanvas.Viewport.Actor != None &&
		aCanvas.Viewport.Actor.Pawn != None &&
		gbxPawn( aCanvas.Viewport.Actor.Pawn ).MyUnit != None )
	{
		// If the unit is empty, don't even think about showing it.
		// (If we show an empty unit, what team do we give it? -- it will show up as american even if its previous occupants were German.
		if( !MyUnit.AnyLivingMembers() )
		{
			bRenderIcon = false;
		}
		else if( gbxPlayerController( aCanvas.Viewport.Actor ).ShowUnitIcon( self ))
		{
			Show();
		}
		else
		{
			Hide();
		}
	}
	else
	{
		bRenderIcon = false;
	}

	Super.DoRenderCalculations( aCanvas );
}

simulated function DrawGBXHud(canvas aCanvas, gbxHud Hud, FontInfo Fonts, int nPass)
{
	if (nPass == 0)
	{
		DoRenderCalculations( aCanvas );

		if( bRenderIcon )
		{

			if( gbxPlayerController( aCanvas.Viewport.Actor ) != None && 
				gbxPlayerController( aCanvas.Viewport.Actor ).ShouldShowSuppressionClockForUnitIcon( self ) )
			{
				if (ShouldFlashClock == true)
				{
					CurrentClockColor = FlashColor;
					ShouldFlashClock = false;
				}
								
				// Render the clock.
				if ( bIsSuppressed )
				{
					CurrentClockColor.R = Lerp( FlashLerpAlpha, CurrentClockColor.R, ClockColorSuppressed.R );
					CurrentClockColor.G = Lerp( FlashLerpAlpha, CurrentClockColor.G, ClockColorSuppressed.G );
					CurrentClockColor.B = Lerp( FlashLerpAlpha, CurrentClockColor.B, ClockColorSuppressed.B );
				}
				else
				{
					CurrentClockColor.R = Lerp( FlashLerpAlpha, CurrentClockColor.R, ClockColorUnsuppressed.R );
					CurrentClockColor.G = Lerp( FlashLerpAlpha, CurrentClockColor.G, ClockColorUnsuppressed.G );
					CurrentClockColor.B = Lerp( FlashLerpAlpha, CurrentClockColor.B, ClockColorUnsuppressed.B );
				}

				CurrentClockColor.A = CurrentAlpha * fOpacityMultiplier;

				CurrentBackgroundColor.A = Min( CurrentAlpha * fOpacityMultiplier, BackgroundColor.A );

				RenderClockBackground( aCanvas, Hud );

				RenderClock( MyClockMaterial, ClockMaterialU, ClockMaterialV, ClockMaterialWidth, ClockMaterialHeight, GetWorldLocation( aCanvas ), 0.5 * 54 * CurrentScaleX * FalsePerspectiveScale * ScreenScaleX * Hud.flMinScaleX, ClockPercentage, aCanvas );
				
				if (bTargeted > 0){ //NAC: If we are targeted then we need to render the appropriate targeted unit tags above the suppression clock
					if (GetNumAttachedIcons() >0){
						RenderTag(aCanvas,Hud);
					}
				}

				MyIcon = IconClock;
				MyIconBack = default.MyIconBack;

				// Ensure that the clock "ring" is set as the normal icon to render.
				MaterialWidth = default.MaterialWidth;
				MaterialHeight = default.MaterialHeight;
				MaterialU = default.MaterialU;
				MaterialV = default.MaterialV;

				ScreenScaleX = default.ScreenScaleX;
				ScreenScaleY = default.ScreenScaleY;

				RenderIcon( aCanvas, Hud );




			}
		}
		
		ShouldFlashClock = false;
	}
}

simulated function RenderClockBackground( Canvas aCanvas, gbxHud Hud )
{
	local Color canvasOldColor;

	canvasOldColor = aCanvas.DrawColor;

	// Render the clock background.
	aCanvas.DrawColor = CurrentBackgroundColor;

	aCanvas.DrawTile3D(
		Material't_interface_mb.hud.interface_comp',
		GetWorldLocation( aCanvas ),
		MaterialWidth * CurrentScaleX * FalsePerspectiveScale * ScreenScaleX * Hud.flMinScaleX,
		MaterialHeight * CurrentScaleY * FalsePerspectiveScale * ScreenScaleY * Hud.flMinScaleY,
		192, 132,
		46, 46,
		MaterialCenterU, MaterialCenterV );

	aCanvas.DrawColor = canvasOldColor;
}

//NAC+ added functions: setTargeted, setUntargeted, RenderTag, and GetTagWorldLocation for rendering attached target tags
//NAC: this function sets the unit to being targeted and will then attach icons necessary
simulated function setTargeted(Unit u)
{
	local   InWorldIcon			TargetTag;
	local int i, aIdx;
	local bool bAlreadyAttached;
	local byte myType;
	
	aIdx = AttachedIcons.Length;

	for( i = 0; i < AttachedIcons.Length; i++ )
	{
		if( AttachedIcons[ i ] == None )
		{
			aIdx = i;
			continue;
		}

		if( AttachedIcons[ i ].TargetingUnit == u )
		{
			bAlreadyAttached = true;
			break;
		}
	}

	if( !bAlreadyAttached )
	{
		if (TargetTag == None)
		{
			TargetTag = Spawn( class'InWorldOrderIcon');
			TargetTag.TargetingUnit = u;
		}

		TargetTag.MyIconBack = AttackAssaultIcon;
		TargetTag.MyIcon = u.TargetOrderIcon.UnitIcons[ u.UnitType ];

		AttachIcon( TargetTag, aIdx );

		myType = aIdx << 1;

  		if( myType == 0 )
		{
			myType = 1;
		}

		bTargeted = bTargeted | myType;
	}
}

//NAC: this function will remove the an attached icon of type passed in from the suppression clock
simulated function setUntargeted(Unit u)
{
	local int i;
	local byte myType;

	for( i = 0; i < AttachedIcons.Length; i++ )
	{
		if( AttachedIcons[ i ].TargetingUnit == u )
		{
			DetachIcon( i, false );

			myType = i << 1;

  			if( myType == 0 )
			{
				myType = 1;
			}
			
			bTargeted = bTargeted & ~myType;

			break;
		}
	}
}

//NAC: this function renders the unit target tag above the suppression clock
simulated function RenderTag( Canvas aCanvas, gbxHud Hud )
{
	local vector screenPos;
	local float ScaleX, ScaleY;
	local int i, count;
	local byte j;
	local float XL,YL;

	count = 0;
	screenPos = aCanvas.ScreenProject(GetWorldLocation( aCanvas ));
	if (screenPos.Z < 1.0)
	{
		ScaleX = CurrentScaleX * FalsePerspectiveScale * Hud.flMinScaleX;
		ScaleY = CurrentScaleY * FalsePerspectiveScale * Hud.flMinScaleY;

		if (GetNumAttachedIcons()>0){
			if (GetNumAttachedIcons()==1){
				screenPos = aCanvas.ScreenProject(GetTagWorldLocation( aCanvas,i ));
				j=bTargeted>>1;
				if (AttachedIcons[j].TargetingUnit.GetNumLivingMembers()>0 ){
					if (AttachedIcons[j].TargetingUnit.bAssaultingTargetUnit){
						
						AttachedIcons[j].MyIconBack.DrawColor = UnitAssaulting;
					}
					else{
						AttachedIcons[j].MyIconBack.DrawColor = UnitAttacking;
					
					}
					aCanvas.CanvasIconSize(AttachedIcons[j].MyIconBack,  XL, YL, ScaleX, ScaleY/1.5);
					aCanvas.DrawCanvasIconComposite(	
							ScreenPos.X, ScreenPos.Y-YL,
							ScaleX,
							ScaleY,
							AttachedIcons[j].MyIcon, 
							AttachedIcons[j].MyIconBack,
							IconRotation,
							BackRotation );				
				}
			}
			else{
				for (i=0;i<AttachedIcons.Length;i++){
					if (AttachedIcons[i] != None && AttachedIcons[i].TargetingUnit.GetNumLivingMembers()>0){ //&& AttachedIcons[i].TargetingUnit.AssignedTargetUnit !=None
						screenPos = aCanvas.ScreenProject(GetTagWorldLocation( aCanvas,count ));
						aCanvas.CanvasIconSize(AttachedIcons[i].MyIconBack,  XL, YL, ScaleX, ScaleY/1.5);
						++count;
						if (AttachedIcons[i].TargetingUnit.bAssaultingTargetUnit){
							AttachedIcons[i].MyIconBack.DrawColor = UnitAssaulting;
						}
						else
							AttachedIcons[i].MyIconBack.DrawColor = UnitAttacking;

						aCanvas.DrawCanvasIconComposite(	
							ScreenPos.X, ScreenPos.Y - YL,
							ScaleX,
							ScaleY,
							AttachedIcons[i].MyIcon, 
							AttachedIcons[i].MyIconBack,
							IconRotation,
							BackRotation );
					}
				}
			}
			
		}
	}
}

simulated function vector GetTagWorldLocation( Canvas aCanvas, int iOrderedUnitSlot )
{
		local vector baseLoc, rightVec, camLocation;
		local float offsetSign, distCamera,FOV;
		local gbxPlayerController myPlayerController;

		if( GetNumAttachedIcons() > 1 )
		{
			if(( iOrderedUnitSlot & 1 ) == 0 )
			{
				
				offsetSign = 1;
			}
			else
			{
				
				offsetSign = -1;
			}
		}
		else
		{			
			offsetSign = 0;
		}
		
		camLocation = GetCameraLocation( aCanvas );

		baseLoc = GetWorldLocation( aCanvas );
		rightVec = Normal(( baseLoc - camLocation ) cross vect(0,0,1));

		distCamera = VSize( CamLocation - baseLoc );
		
		myPlayerController = gbxPlayerController( aCanvas.Viewport.Actor );
		FOV =gbxWeapon(myPlayerController.Pawn.Weapon).ZoomFovMod;
		//special cases for weapons with sniper zoom
		if(FOV>35 && (myPlayerController.Pawn.Weapon.ClientState == WS_ZoomIn || myPlayerController.IsZoomed()) && myPlayerController.Pawn.Weapon.ClientState != WS_ZoomOut ){
			return baseLoc + GetScreenToWorldDelta( rightVec * ( offsetSign * (PeerOffsetDistance - 0.0045) ), distCamera );
		}
		else{
			
			return baseLoc + GetScreenToWorldDelta( rightVec * ( offsetSign * PeerOffsetDistance ), distCamera );
		}
}
//NAC-

simulated native final function RenderClock( material Mat, float U, float V, float UL, float VL, vector Center, float Radius, float Percentage, Canvas aCanvas );

function FlashPlayerSuppression( float amount )
{
	ShouldFlashClock = true;
	ReplicatedShouldFlashClock++;
}

simulated function Actor GetAssociatedActor() 
{ 
	return MyUnit; 
}

simulated function bool CanAcceptAttachmentsFrom( Pawn Attacher ) 
{ 
	return !MyUnit.SameTeamAs( Attacher ); 
}

simulated event PostNetReceive()
{	
	Super.PostNetReceive();
	
	if (Role < ROLE_Authority)
	{
		ClockPercentage = ReplicatedClockPercentage;
		
		if (ReplicatedShouldFlashClock != LastReplicatedShouldFlashClock)
		{
			ShouldFlashClock = true;
		}
		LastReplicatedShouldFlashClock = ReplicatedShouldFlashClock;
	}
}

defaultproperties
{
	LocationOffset=(Z=0.008)

	MaterialWidth=58
	MaterialHeight=58

	MyClockMaterial=material't_interface_mb.hud.interface_comp'		// solid_white
	ClockMaterialWidth=5
	ClockMaterialHeight=5
	ClockMaterialU=97
	ClockMaterialV=180

	IconClock=(Icon=Texture't_interface_mb.hud.interface_comp',U=412,V=147,UL=58,VL=58,DrawColor=(R=0,G=0,B=0,A=255),ScaleX=1.0,ScaleY=1.0,PivotU=0.5,PivotV=0.5)	// suppression_circle
	IconUSUnit=(Icon=Texture't_interface_mb.hud.interface_comp',U=276,V=99,UL=29,VL=29,DrawColor=(R=255,G=255,B=255,A=255),ScaleX=1.5,ScaleY=1.5,PivotU=0.5,PivotV=0.5)	// icon_us_star
	IconGermanUnit=(Icon=Texture't_interface_mb.hud.interface_comp',U=305,V=99,UL=29,VL=29,DrawColor=(R=0,G=0,B=0,A=255),ScaleX=1.5,ScaleY=1.5,PivotU=0.5,PivotV=0.5)	// icon_de_cross
	IconUnitBack=(Icon=Texture't_interface_mb.hud.interface_comp',U=192,V=131,UL=46,VL=46,DrawColor=(R=255,G=255,B=255,A=255),ScaleX=1.5,ScaleY=1.5,PivotU=0.5,PivotV=0.5)	// bg_unit
	BackgroundUSColor=(R=88,G=108,B=47,A=255)
	BackgroundGermanColor=(R=181,G=56,B=41,A=255)

	ScreenScaleX=1.0
	ScreenScaleY=1.0

// GBX:PAD: We can't set a value in DefaultProperties to an enum, so setting this up as such is a problem.  For now,
// I just going to let it use the render style that is set before trying to draw it.
//	RenderStyle=ERenderStyle.STY_Alpha
	CurrentDrawColor=(R=255,B=255,G=255,A=255)
	MaxAlpha=255
	DurationAppear=0.3
	DurationDisappear=0.2
	AppearScaleMultiplier=4
	DisappearScaleMultiplier=1

	MinDistShow=400
	MaxDistShow=12000

	MaxDistClip=500
	MinSizeScalar=0.4
	MaxSizeScalar=0.6
	DistAtMaxSize=0
	DistAtMinSize=3000

	ClockColorSuppressed=(R=48,G=48,B=48,A=192)
	ClockColorUnsuppressed=(R=185,G=48,B=38,A=192)
	CurrentClockColor=(R=185,G=48,B=38,A=192)
	FlashColor=(R=255,B=255,G=255,A=255)
	FlashLerpAlpha=0.1
	ShouldFlashClock=false

	OcclusionUpdateInterval=0.5

	BackgroundColor=(R=255,G=255,B=255,A=64)
	CurrentBackgroundColor=(R=255,G=255,B=255,A=64)
	
	ReplicatedClockPercentage=0
	ReplicatedShouldFlashClock=0
	LastReplicatedShouldFlashClock=0
	bNetNotify=True
	bAlwaysRelevant=True
	RemoteRole=ROLE_AutonomousProxy

	bSkipActorPropertyReplication=true
	bOnlyDirtyReplication=true

	//NAC+ set the default values of stuff used for attached icons
	AttackAssaultIcon=(Icon=Texture't_interface_mb.hud.interface_comp',U=480,V=186,UL=32,VL=50,DrawColor=(R=255,G=255,B=255,A=255),ScaleX=0.9,ScaleY=0.9,PivotU=0.5,PivotV=1.0)	// command_tab NAC
	bTargeted=0; 
	PeerOffsetDistance=0.006 
	TargetingUnit = None;
	UnitAttacking=(R=176,G=57,B=30,A=255)
	UnitAssaulting=(R=250,G=218,B=77,A=255)
	//NAC-
}

//=============================================================================
// ItemPawnAnimInfo
//
//	This contains a class for storing the specific animation names a pawn must
//	run for the various actions that are dependant on the type of weapon a pawn
//	is carrying
//
//=============================================================================
class ItemPawnAnimInfo extends Info;



var		name	FireStandingSighted;
var		name	FireStandingWallFacing;
var		name	FireStandingWallFacingUrban;

var		name	FireCrouchedSighted;
var		name	FireCornerStandingLeft;
var		name	FireCornerStandingRight;
var		name	FireCornerCrouchedLeft;
var		name	FireCornerCrouchedRight;

var		name	FireCornerStandingLeftUrban;
var		name	FireCornerStandingRightUrban;

var		name	CycleStanding;
var		name	CycleCrouched;
var		name	CycleCrouchedCornerFiringLeft;
var		name	CycleCrouchedCornerFiringRight;

var		name	TurnLeftRelaxed;
var		name	TurnRightRelaxed;
var		name	TurnLeftCombatRelaxed;
var		name	TurnRightCombatRelaxed;
var		name	TurnLeftSighted;
var		name	TurnRightSighted;

var		name	WalkingForwardRelaxed;
var		name	WalkingForwardSighted;
var		name	WalkingForwardLimpLeft;
var		name	WalkingForwardLimpRight;
var		name	WalkingLeftRelaxed;
var		name	WalkingLeftSighted;
var		name	WalkingRightRelaxed;
var		name	WalkingRightSighted;
var		name	WalkingBackRelaxed;
var		name	WalkingBackSighted;

var		name	RunningForwardRelaxed;
var		name	RunningForwardSighted;
var		name	RunningForwardLimpLeft;
var		name	RunningForwardLimpRight;
var		name	RunningLeftRelaxed;
var		name	RunningLeftSighted;
var		name	RunningRightRelaxed;
var		name	RunningRightSighted;
var		name	RunningBackRelaxed;
var		name	RunningBackSighted;

var		name	StandingSprint;

var		name	CrouchedTurnLeftSighted;
var		name	CrouchedTurnRightSighted;

var		name	CrouchedCreepForwardRelaxed;
var		name	CrouchedCreepForwardSighted;
var		name	CrouchedCreepLeftRelaxed;
var		name	CrouchedCreepLeftSighted;
var		name	CrouchedCreepRightRelaxed;
var		name	CrouchedCreepRightSighted;
var		name	CrouchedCreepBackRelaxed;
var		name	CrouchedCreepBackSighted;

var		name	CrouchedSprint;

var		array<name>	MeleeAttack;

var 	name	ReloadStanding;
var		name	ReloadCrouched;
var		name	ReloadWallFacingCrouched;
var		name	ReloadWallFacingCrouchedLeft;
var		name	ReloadWallFacingCrouchedRight;
var		name	ReloadWallFacingStandingLeft;
var		name	ReloadWallFacingStandingRight;
var		name	ReloadCoverUrban;

var 	name	DeployStanding;
var		name	DeployCrouched;

var 	name	HolsterStanding;
var		name	HolsterCrouched;

var		array<name>	FlinchStanding;
var		array<name>	FlinchCrouched;

var		array<name>	IdleStandingNoCombat;
var		array<name>	IdleStandingAlert;
var		array<name>	IdleStandingSighted;
var		name	IdleStandingWallLeanPeekLeft;
var		name	IdleStandingWallLeanPeekRight;
var		name	IdleStandingWallLeanFireLeft;
var		name	IdleStandingWallLeanFireRight;
var		name	IdleStandingWallLeanFireLeftUrban;
var		name	IdleStandingWallLeanFireRightUrban;
var		array<name>	IdleStandingWallLeanLeft;
var		array<name>	IdleStandingWallLeanRight;
var		name	IdleStandingWallFacing;
var		name	IdleStandingWallFacingUrban;
var		name	IdleStandingBackToWall;

var		array<name>	IdleCrouchedNoCombat;
var		array<name>	IdleCrouchedRelaxed;
var		array<name>	IdleCrouchedSighted;
var		name	IdleCrouchedWallLeanPeekLeft;
var		name	IdleCrouchedWallLeanPeekRight;
var		name	IdleCrouchedWallLeanFireLeft;
var		name	IdleCrouchedWallLeanFireRight;
var		array<name>	IdleCrouchedWallLeanLeft;
var		array<name>	IdleCrouchedWallLeanRight;
var		array<name>	IdleCrouchedWallFacing;

var		name	IdleWallFacingPeek;

var		name	IdleFeedingMG42Idle;
var		name	IdleFeedingMG42Firing;
var		name	IdleSpottingMG42;

var		array<name>		IdleFlakVGunner;
var		array<name>		IdleFlakvLoaderLeft;
var		array<name>		IdleFlakvLoaderRight;

var		array<name>		IdlePak36Gunner;
var		array<name>		IdlePak36Loader;

var		name		IdlePak88Gunner;
var		name		IdlePak88Loader;
var		name		IdlePak88FuseSetter;
var		name		IdlePak88Spotter;

var		array<name>		IdleMortarGunner;
var		array<name>		IdleMortarLoaderLeft;
var		array<name>		IdleMortarLoaderRight;

var		name	ReloadFlakvLeft;
var		name	ReloadFlakvRight;

var		name	ReloadPak88FuseSetter;

var		name	ReloadPak36_;

var		name	StandingToCrouch;
var		name	StandingCoverFireToCrouchLeft;
var		name	StandingCoverFireToCrouchRight;
var		name	StandingPeekToCrouch;
var		name	StandingToCrouchFacingWall;
var		name	StandingToCrouchFacingWallUrban;

var		name	CrouchToStanding;
var		name	CrouchToStandingCoverFireLeft;
var		name	CrouchToStandingCoverFireRight;
var		name	CrouchToStandingPeek;
var		name	CrouchToStandingFacingWall;
var		name	CrouchToStandingFacingWallUrban;

var		array<name>	ReactToBulletsStanding;
var		array<name>	ReactToBulletsCrouched;
var		array<name>	ReactToBulletsLeftCornerCrouched;
var		array<name>	ReactToBulletsRightCornerCrouched;
var		array<name>	ReactToBulletsLeftCornerStanding;
var		array<name>	ReactToBulletsRightCornerStanding;

var		array<name> CombatReadyTransitions;
var		int		CurCombatReadyNdx;

// These are deprecated.
var		name	ThrowGrenadeStanding;
var		name	ThrowGrenadeCrouched;
var		name	ThrowGermanGrenadeStanding;
var		name	ThrowGermanGrenadeCrouched;

var		name	GrenadeStandingToCower;
var		name	GrenadeCrouchedToCower;
var		name	GrenadeStandingFromCower;
var		name	GrenadeCrouchedFromCower;
var		name	GrenadeCowering;

var		name	GrenadeReturnCrouched;
var		name	GrenadeReturnStanding;

var		name	WallFacingPeekIdle;

var		name	MountPeekLeftStanding;
var		name	MountPeekLeftCrouched;
var		name	MountPeekRightStanding;
var		name	MountPeekRightCrouched;
var		name	MountFireLeftCrouched;
var		name	MountFireRightCrouched;
var		name	MountFireLeftStanding;
var		name	MountFireRightStanding;

var		name	MountMG42Gunner;

var		name	DismountPeekLeftCrouched;
var		name	DismountPeekRightCrouched;
var		name	DismountPeekLeftStanding;
var		name	DismountPeekRightStanding;
var		name	DismountFireLeftCrouched;
var		name	DismountFireLeftStanding;
var		name	DismountFireRightCrouched;
var		name	DismountFireRightStanding;

var		name	DismountMG42Gunner;
var		name	DismountMG42GunnerTurn;

var		name	DismountFlakVGunner;
var		name	DismountFlakVLeftLoader;
var		name	DismountFlakVRightLoader;

var		name	DismountPak36Gunner;
var		name	DismountPak36Loader;

var		name	DismountPak88Gunner;
var		name	DismountPak88Loader;
var		name	DismountPak88FuseSetter;

var		name	DismountMortarGunner;
var		name	DismountMortarLeftLoader;
var		name	DismountMortarRightLoader;

var		name	SpottingMG42Point;

var		name	MountTankStuart30cal;
var		name	DismountTankStuart30cal;
var		name	MountTankSherman50cal;
var		name	DismountTankSherman50cal;

var		name	WallLeanCrouchedToStandingLeft;
var		name	WallLeanCrouchedToStandingRight;
var		name	WallLeanStandingToCrouchedLeft;
var		name	WallLeanStandingToCrouchedRight;
var		name	WallLeanStandingToStandingLeft;
var		name	WallLeanStandingToStandingRight;
var		name	WallLeanCrouchedToCrouchedLeft;
var		name	WallLeanCrouchedToCrouchedRight;
var		name	WallLeanCrouchedToStandingBack;
var		name	WallLeanStandingToStandingBack;

var		name	DismountWallLeanCrouchedToCrouchedLeft;
var		name	DismountWallLeanCrouchedToCrouchedRight;
var		name	DismountWallLeanCrouchedToStandingLeft;
var		name	DismountWallLeanCrouchedToStandingRight;
var		name	DismountWallLeanStandingToCrouchedLeft;
var		name	DismountWallLeanStandingToCrouchedRight;
var		name	DismountWallLeanStandingToStandingLeft;
var		name	DismountWallLeanStandingToStandingRight;

var		name	JumpInPlace;
var		name	RunningJump;

var		name	TNTMountAnim;
var		name	TNTPlantingAnim;
var		name	TNTDismountAnim;

var		array<name>	PlayerBlownDown;

var		string	WeaponAnimSet;

var		bool	m_fPlayCycleAnim;
var		bool	m_fReloadHandSwitch;

var		float	OffsetXFlakVGunnerDismount;
var		float	OffsetYFlakVGunnerDismount;
var		float	OffsetXFlakVLeftLoaderDismount;
var		float	OffsetYFlakVLeftLoaderDismount;
var		float	OffsetXFlakVRightLoaderDismount;
var		float	OffsetYFlakVRightLoaderDismount;

var		float	OffsetXPak36GunnerDismount;
var		float	OffsetYPak36GunnerDismount;
var		float	OffsetXPak36LoaderDismount;
var		float	OffsetYPak36LoaderDismount;

var		float	OffsetXMortarGunnerDismount;
var		float	OffsetYMortarGunnerDismount;
var		float	OffsetXMortarLeftLoaderDismount;
var		float	OffsetYMortarLeftLoaderDismount;
var		float	OffsetXMortarRightLoaderDismount;
var		float	OffsetYMortarRightLoaderDismount;

static function name PawnFireAnim( Pawn aPawn )
{
	local gbxPawn gbxP;

	gbxP = gbxPawn( aPawn );

	if (aPawn.bIsCrouched)
	{
		if ( gbxP.m_bCornerFiring )
		{
			if ( gbxP.m_MyLeanDirection == CDIR_Left )
				return Default.FireCornerCrouchedLeft;
			else
				return Default.FireCornerCrouchedRight;
		}

				return Default.FireCrouchedSighted;
		}
	else
	{
		if ( gbxP.m_bCornerFiring )
		{
			if (gbxP.Level.bUrbanCover)
			{
				if ( gbxP.m_MyLeanDirection == CDIR_Left )
					return Default.FireCornerStandingLeftUrban;
				else
					return Default.FireCornerStandingRightUrban;
			}
			else
			{
				if ( gbxP.m_MyLeanDirection == CDIR_Left )
					return Default.FireCornerStandingLeft;
				else
					return Default.FireCornerStandingRight;
			}
		}
		else if ( gbxP.m_bUsingCrouchedCover )
		{
			if (gbxP.Level.BaseUnitSkillLevel > SKILL_Intermediate)
			{
				if (gbxP.Level.NetMode != NM_StandAlone)
				{
					return Default.FireStandingWallFacing;
				}
				else
				{
					return Default.FireStandingWallFacingUrban;
				}
			}
			else
			{
				return Default.FireStandingWallFacing;
			}
		}

		return Default.FireStandingSighted;
	}

	return '';
}

static function bool PawnHasCycleAnim( Pawn aPawn )
{
	return Default.m_fPlayCycleAnim;
}

static function name PawnCycleAnim( Pawn aPawn )
{
	local gbxPawn gbxP;
	
	gbxP = gbxPawn( aPawn );

	if ( gbxP != None && gbxP.m_bCornerFiring && gbxP.bIsCrouched )
	{
		if ( gbxP.m_MyLeanDirection == CDIR_Left )
			return Default.CycleCrouchedCornerFiringLeft;
		else
			return Default.CycleCrouchedCornerFiringRight;
	}
	else
	if ( aPawn.bIsCrouched )
		return Default.CycleCrouched;
	else
		return Default.CycleStanding;
}

static function bool PawnReloadHandSwitch( Pawn aPawn )
{
	return Default.m_fReloadHandSwitch;
}

static function name PawnReloadAnim( Pawn aPawn )
{
	local gbxPawn gbxP;

	gbxP = gbxPawn( aPawn );

	if ( gbxP.Job == Job_Flakv_LeftLoader )
	{
		return Default.ReloadFlakvLeft;
	}
	else if ( gbxP.Job == Job_Flakv_RightLoader )
	{
		return Default.ReloadFlakvRight;
	}
	else if ( gbxP.Job == Job_Pak36_Loader )
	{
		return Default.ReloadPak36_;
	}
	else if (gbxP.Job == Job_PAK88_FuseSetter)
	{
		return Default.ReloadPak88FuseSetter;
	}
	else if ( gbxP.Job == Job_Mortar_Gunner || gbxP.Job == Job_Mortar_LeftLoader || gbxP.Job == Job_Mortar_RightLoader )
	{
		return '';	// Shouldn't call this function if on a Mortar--but hey!
	}

	if (gbxP.bIsCrouched)
	{
		if ( gbxP.m_bUsingCrouchedCover )
		{
			return Default.ReloadWallFacingCrouched;
		}
		else if ( gbxP.m_bCornerHunkered )
		{
			if ( gbxP.m_MyLeanDirection == CDIR_Left )
				return Default.ReloadWallFacingCrouchedLeft;
			else
				return Default.ReloadWallFacingCrouchedRight;
		}
		else
			return Default.ReloadCrouched;
	}
	else
	{
		if ( gbxP.m_bCornerHunkered && !gbxP.m_bStandingOverCorner )
		{
			if ( gbxP.m_bCornerFiring )
			{
				// Reloading while leaned out to fire (op-bursting).
				return Default.ReloadStanding;
			}
			else
			if ( gbxP.m_MyLeanDirection == CDIR_Left )
				return Default.ReloadWallFacingStandingLeft;
			else
				return Default.ReloadWallFacingStandingRight;
		}
		else if ((gbxP.Level.BaseUnitSkillLevel > SKILL_Intermediate) && gbxP.m_bUsingCrouchedCover)
		{
			if (gbxP.Level.NetMode != NM_StandAlone)
			{
				return Default.ReloadStanding;
			}
			else
			{
				return Default.ReloadCoverUrban;
			}
		}
		else
			return Default.ReloadStanding;
	}
}

static function name PawnDeployAnim( Pawn aPawn )
{
	local gbxPawn gbxP;

	gbxP = gbxPawn( aPawn );

	if (gbxP.bIsCrouched)
	{
		return Default.DeployCrouched;
	}
	else
	{
		return Default.DeployStanding;
	}
}

static function name PawnHolsterAnim( Pawn aPawn )
{
	local gbxPawn gbxP;

	gbxP = gbxPawn( aPawn );

	if (gbxP.bIsCrouched)
	{
		return Default.HolsterCrouched;
	}
	else
	{
		return Default.HolsterStanding;
	}
}

static function name PawnFlinchAnim( Pawn aPawn )
{
	local int nFlinch;

	// GBX:naj - no flinches while corner hunkered (yet).
	if ( gbxPawn( aPawn ).m_bCornerHunkered )
		return '';

	nFlinch = Rand( 8 ) % Default.FlinchCrouched.Length;
	if (aPawn.bIsCrouched)
		return Default.FlinchCrouched[nFlinch];
	else
		return Default.FlinchStanding[nFlinch];
}

static function name PawnIdleAnim( Pawn aPawn )
{
	local int nRandom, nIdle;
	local gbxPawn WGPawn;

	WGPawn = gbxPawn( aPawn );
	if (WGPawn == None)
		return Default.IdleStandingAlert[0];
		
	if (WGPawn.bIsLookingAtPlayer)
	{
		nRandom = Rand( 100 );
		if (nRandom <= 75)
		{
			if ((WGPawn.m_bCurIdleAnim == 0) && (WGPawn.m_bNumIdlePlays >= 5))
				nIdle = Rand( 1 );
			else
				nIdle = 0;
		}
		else if (nRandom <= 90)
		{
			if ((WGPawn.m_bCurIdleAnim == 1) && (WGPawn.m_bNumIdlePlays >= 5))
				nIdle = 0;
			else
				nIdle = 1;
		}
		else
		{
			if ((WGPawn.m_bCurIdleAnim == 2) && (WGPawn.m_bNumIdlePlays >= 5))
				nIdle = 0;
			else
				nIdle = 2;
		}
	}
	else
	{
		nRandom = Rand( 100 );
		if (nRandom <= 75)
		{
			nIdle = Rand( 100 ) % 3;
			if ((WGPawn.m_bCurIdleAnim == nIdle) && (WGPawn.m_bNumIdlePlays >= 5))
				nIdle = 0;
		}
		else if (nRandom <= 90)
		{
			if ((WGPawn.m_bCurIdleAnim == 3) && (WGPawn.m_bNumIdlePlays >= 5))
				nIdle = Rand( 2 );
			else
				nIdle = 3;
		}
		else
		{
			if ((WGPawn.m_bCurIdleAnim == 4) && (WGPawn.m_bNumIdlePlays >= 5))
				nIdle = Rand( 2 );
			else
				nIdle = 4 + Rand( 2 );
		}
	}

	if (WGPawn.m_bCurIdleAnim != nIdle)
		WGPawn.m_bNumIdlePlays = 1;
	else
		WGPawn.m_bNumIdlePlays++;
	WGPawn.m_bCurIdleAnim = nIdle;
	
	if ( WGPawn.m_bIsCowering )
	{
		return Default.GrenadeCowering;
	}
	else if ( WGPawn.m_bStandingOverCorner )
	{
		return Default.IdleStandingWallLeanFireLeft;
	}
	else if ( WGPawn.m_bStandPeeking )
	{
		return Default.IdleWallFacingPeek;
	}

	//NAC+
	//else if (aPawn.bIs88Special)
	//{
	//	if ( WGPawn.Job == Job_PAK88_Spotter )
	//	{
	//		return Default.IdlePak88Spotter;
	//	}
	//}
	//NAC-
	else if ( aPawn.bIsManningTurret )
	{		
		if ( WGPawn.Job == Job_Flakv_Gunner )
		{
			nIdle = Rand(3);
			return Default.IdleFlakvGunner[nIdle];
		}
		else
		if ( WGPawn.Job == Job_Flakv_LeftLoader )
		{
			nIdle = Rand(3);
			return Default.IdleFlakvLoaderLeft[nIdle];
		}
		else
		if ( WGPawn.Job == Job_Flakv_RightLoader )
		{
			nIdle = Rand(3);
			return Default.IdleFlakvLoaderRight[nIdle];
		}
		else
		if ( WGPawn.Job == Job_Pak36_Gunner )
		{
			return Default.IdlePak36Gunner[0];
		}
		else
		if ( WGPawn.Job == Job_Pak36_Loader )
		{
			nIdle = Rand(2);
			return Default.IdlePak36Loader[nIdle];
		}
		else
		if ( WGPawn.Job == Job_PAK88_FuseSetter )
		{
			return Default.IdlePak88FuseSetter;
		}

		else
		if ( WGPawn.Job == Job_PAK88_Gunner )
		{
			return Default.IdlePak88Gunner;
		}
		else
		if ( WGPawn.Job == Job_Mortar_Gunner )
		{			
			nIdle = Rand(3);
			return Default.IdleMortarGunner[nIdle];
		}
		else
		if ( WGPawn.Job == Job_Mortar_LeftLoader )
		{
			nIdle = Rand(3);
			return Default.IdleMortarLoaderLeft[nIdle];
		}
		else
		if ( WGPawn.Job == Job_Mortar_RightLoader )
		{
			nIdle = Rand(3);
			return Default.IdleMortarLoaderRight[nIdle];
		}		
		else
		{
			// Error.
			return '';
		}
	}
	
	if (aPawn.bIsCrouched)
	{
		if ( WGPawn.m_bCornerPeeking )
		{
			if ( WGPawn.m_MyLeanDirection == CDIR_Left )
				return Default.IdleCrouchedWallLeanPeekLeft;
			else
				return Default.IdleCrouchedWallLeanPeekRight;
		}
		else if ( WGPawn.m_bCornerFiring )
		{
			if ( WGPawn.m_MyLeanDirection == CDIR_Left )
				return Default.IdleCrouchedWallLeanFireLeft;
			else
				return Default.IdleCrouchedWallLeanFireRight;
		}
		else if ( WGPawn.m_bCornerHunkered )
		{
			nRandom = Rand(100);
			if (nRandom > 75)
			{
				if ( WGPawn.m_MyLeanDirection == CDIR_Left )
					nIdle = Rand(Default.IdleCrouchedWallLeanLeft.Length - 1);
				else
					nIdle = Rand(Default.IdleCrouchedWallLeanRight.Length - 1);
			}
			else
				nIdle = 0;

			if ( WGPawn.m_MyLeanDirection == CDIR_Left )
				return Default.IdleCrouchedWallLeanLeft[nIdle];
			else
				return Default.IdleCrouchedWallLeanRight[nIdle];
		}
		else if ( WGPawn.m_bUsingCrouchedCover )
		{
			nIdle = Rand(5);
			return Default.IdleCrouchedWallFacing[nIdle];
		}
		
		switch( aPawn.eWeaponAimedState )
		{
			case WAS_Relaxed:
				return Default.IdleCrouchedNoCombat[nIdle];
			case WAS_CombatRelaxed:
				return Default.IdleCrouchedRelaxed[nIdle];
			case WAS_AimedHip:
			case WAS_Sighted:
				return Default.IdleCrouchedSighted[nIdle];
		}
	}
	else
	{	
		if ( WGPawn.m_bCornerPeeking )
		{
			if ( WGPawn.m_MyLeanDirection == CDIR_Left )
				return Default.IdleStandingWallLeanPeekLeft;
			else
				return Default.IdleStandingWallLeanPeekRight;
		}
		else if ( WGPawn.m_bCornerFiring )
		{
			if ( WGPawn.Level.bUrbanCover )
			{
				if ( WGPawn.m_MyLeanDirection == CDIR_Left )
					return Default.IdleStandingWallLeanFireLeftUrban;
				else
					return Default.IdleStandingWallLeanFireRightUrban;
			}
			else
			{
				if ( WGPawn.m_MyLeanDirection == CDIR_Left )
					return Default.IdleStandingWallLeanFireLeft;
				else
					return Default.IdleStandingWallLeanFireRight;
			}
		}
		else if ( WGPawn.m_bCornerHunkered )
		{
			nRandom = Rand(100);
			if (nRandom > 75)
			{
				if ( WGPawn.m_MyLeanDirection == CDIR_Left )
					nIdle = Rand(Default.IdleStandingWallLeanLeft.Length - 1);
				else
					nIdle = Rand(Default.IdleStandingWallLeanRight.Length - 1);
			}
			else
				nIdle = 0;

			if ( WGPawn.m_MyLeanDirection == CDIR_Left )
				return Default.IdleStandingWallLeanLeft[nIdle];
			else
				return Default.IdleStandingWallLeanRight[nIdle];
		}
		else if ( WGPawn.m_bUsingCrouchedCover )
		{
			if (WGPawn.Level.BaseUnitSkillLevel > SKILL_Intermediate)
			{
				if (WGPawn.Level.NetMode != NM_StandAlone)
				{
					return Default.IdleStandingWallFacing;
				}
				else
				{
					return Default.IdleStandingWallFacingUrban;
				}
			}
			else
			{
				return Default.IdleStandingWallFacing;
			}
		}

		switch( aPawn.eWeaponAimedState )
		{
			case WAS_Relaxed:
				return Default.IdleStandingNoCombat[nIdle];
			case WAS_CombatRelaxed:
				return Default.IdleStandingAlert[nIdle];
			case WAS_AimedHip:
			case WAS_Sighted:
				return Default.IdleStandingSighted[nIdle];
		}
	}

	return '';
}

// GBX:naj - added 11/24/03
static function GetHunkeredTurnAnims( Pawn aPawn, out Name TurnLeftAnim, out Name TurnRightAnim )
{
	if ( gbxPawn( aPawn ).m_bCornerHunkered )
	{
		if ( aPawn.bIsCrouched )
		{
			if ( gbxPawn( aPawn ).m_MyLeanDirection == CDIR_Left )
			{
				TurnLeftAnim = Default.IdleCrouchedWallLeanLeft[0];
				TurnRightAnim = Default.IdleCrouchedWallLeanLeft[0];
			}
			else
			{
				TurnLeftAnim = Default.IdleCrouchedWallLeanRight[0];
				TurnRightAnim = Default.IdleCrouchedWallLeanRight[0];
			}
		}
		else
		{
			if ( gbxPawn( aPawn ).m_MyLeanDirection == CDIR_Left )
			{
				TurnLeftAnim = Default.IdleStandingWallLeanLeft[0];
				TurnRightAnim = Default.IdleStandingWallLeanLeft[0];
			}
			else
			{
				TurnLeftAnim = Default.IdleStandingWallLeanRight[0];
				TurnRightAnim = Default.IdleStandingWallLeanRight[0];
			}
		}
	}
}

static function name PawnCoverMountAnim( Pawn aPawn, int Direction, bool bStartCrouched, bool bEndCrouched )
{
	if ( Direction == 0 )
	{
		// Left
		if ( bStartCrouched && bEndCrouched )
			return Default.WallLeanCrouchedToCrouchedLeft;
		else
		if ( bStartCrouched && !bEndCrouched )
			return Default.WallLeanCrouchedToStandingLeft;
		else
		if ( !bStartCrouched && bEndCrouched )
			return Default.WallLeanStandingToCrouchedLeft;
		else
		{
			return Default.WallLeanStandingToStandingLeft;
		}
	}
	else
	{
		// Right
		if ( bStartCrouched && bEndCrouched )
			return Default.WallLeanCrouchedToCrouchedRight;
		else
		if ( bStartCrouched && !bEndCrouched )
			return Default.WallLeanCrouchedToStandingRight;
		else
		if ( !bStartCrouched && bEndCrouched )
			return Default.WallLeanStandingToCrouchedRight;
		else
		{
			return Default.WallLeanStandingToStandingRight;
		}
	}
}

static function name PawnCoverDismountAnim( int Direction, bool bStartCrouched, bool bEndCrouched )
{
	if ( Direction == 0 )
	{
		// Left
		if ( bStartCrouched && bEndCrouched )
			return Default.DismountWallLeanCrouchedToCrouchedLeft;
		else
		if ( bStartCrouched && !bEndCrouched )
			return Default.DismountWallLeanCrouchedToStandingLeft;
		else
		if ( !bStartCrouched && bEndCrouched )
			return Default.DismountWallLeanStandingToCrouchedLeft;
		else
		{
			return Default.DismountWallLeanStandingToStandingLeft;
		}
	}
	else
	{
		// Right
		if ( bStartCrouched && bEndCrouched )
			return Default.DismountWallLeanCrouchedToCrouchedRight;
		else
		if ( bStartCrouched && !bEndCrouched )
			return Default.DismountWallLeanCrouchedToStandingRight;
		else
		if ( !bStartCrouched && bEndCrouched )
			return Default.DismountWallLeanStandingToCrouchedRight;
		else
		{
			return Default.DismountWallLeanStandingToStandingRight;
		}
	}
}

static function name PawnPeekMountAnim( Pawn aPawn, int Direction )
{
	if ( Direction == 0 )
	{
		// Left
		if ( aPawn.bIsCrouched )
		{
			return Default.MountPeekLeftCrouched;
		}
		else
		{
			return Default.MountPeekLeftStanding;
		}
	}
	else
	{
		// Right
		if ( aPawn.bIsCrouched )
		{
			return Default.MountPeekRightCrouched;
		}
		else
		{
			return Default.MountPeekRightStanding;
		}
	}
}

static function name PawnCornerFireMountAnim( Pawn aPawn )
{
	if ( gbxPawn( aPawn ).m_MyLeanDirection == CDIR_Left )
	{
		// Left
		if ( aPawn.bIsCrouched )
		{
			return Default.MountFireLeftCrouched;
		}
		else
		{
			return Default.MountFireLeftStanding;
		}
	}
	else
	{
		// Right
		if ( aPawn.bIsCrouched )
		{
			return Default.MountFireRightCrouched;
		}
		else
		{
			return Default.MountFireRightStanding;
		}
	}
}

static function name PawnCornerFireDismountAnim( Pawn aPawn )
{
	if ( gbxPawn( aPawn ).m_MyLeanDirection == CDIR_Left )
	{
		// Left
		if ( aPawn.bIsCrouched )
		{
			return Default.DismountFireLeftCrouched;
		}
		else
		{
			return Default.DismountFireLeftStanding;
		}
	}
	else
	{
		// Right
		if ( aPawn.bIsCrouched )
		{
			return Default.DismountFireRightCrouched;
		}
		else
		{
			return Default.DismountFireRightStanding;
		}
	}
}

static function name PawnPeekDismountAnim( Pawn aPawn )
{
	if ( gbxPawn( aPawn ).m_MyLeanDirection == CDIR_Left )
	{
		if ( gbxPawn( aPawn ).bIsCrouched )
		{
			return Default.DismountPeekLeftCrouched;
		}
		else
		{
			return Default.DismountPeekLeftStanding;
		}
	}
	else
	{
		// Right
		if ( gbxPawn( aPawn ).bIsCrouched )
		{
			return Default.DismountPeekRightCrouched;
		}
		else
		{
			return Default.DismountPeekRightStanding;
		}
	}
}

static function bool SetPawnStandingSprintAnim( Pawn	aPawn )
{
	if (Default.StandingSprint == '')
		return false;

	if (gbxPawn( aPawn ) == None)
		return false;

	if (aPawn.MovementAnims[0] != Default.StandingSprint)
	{
		aPawn.bInitializeAnimation = false;
	}
	
	aPawn.MovementAnims[0] = Default.StandingSprint;
	aPawn.MovementAnims[2] = Default.StandingSprint;
	aPawn.MovementAnims[1] = Default.StandingSprint;
	aPawn.MovementAnims[3] = Default.StandingSprint;

	aPawn.TurnLeftAnim = Default.TurnLeftSighted;
	aPawn.TurnRightAnim = Default.TurnRightSighted;

	return true;
}

static function bool SetPawnRunningAnim( Pawn	aPawn )
{
	if (gbxPawn(aPawn) == None)
		return false;

	switch (aPawn.eWeaponAimedState)
	{
		case WAS_Relaxed:
			if (aPawn.MovementAnims[0] != Default.RunningForwardRelaxed)
			{
				aPawn.bInitializeAnimation = false;
			}
			aPawn.MovementAnims[0] = Default.RunningForwardRelaxed;
			aPawn.MovementAnims[2] = Default.RunningLeftRelaxed;
			aPawn.MovementAnims[1] = Default.RunningBackRelaxed;
			aPawn.MovementAnims[3] = Default.RunningRightRelaxed;
			aPawn.TurnLeftAnim = Default.TurnLeftRelaxed;
			aPawn.TurnRightAnim = Default.TurnRightRelaxed;
			break;

		case WAS_CombatRelaxed:
			if (aPawn.MovementAnims[0] != Default.RunningForwardRelaxed)
			{
				aPawn.bInitializeAnimation = false;
			}
			aPawn.MovementAnims[0] = Default.RunningForwardRelaxed;
			aPawn.MovementAnims[2] = Default.RunningLeftRelaxed;
			aPawn.MovementAnims[1] = Default.RunningBackRelaxed;
			aPawn.MovementAnims[3] = Default.RunningRightRelaxed;
			aPawn.TurnLeftAnim = Default.TurnLeftCombatRelaxed;
			aPawn.TurnRightAnim = Default.TurnRightCombatRelaxed;
			break;

		case WAS_AimedHip:
		case WAS_Sighted:
			if (aPawn.MovementAnims[0] != Default.RunningForwardSighted)
			{
				aPawn.bInitializeAnimation = false;
			}
			aPawn.MovementAnims[0] = Default.RunningForwardSighted;
			aPawn.MovementAnims[2] = Default.RunningLeftSighted;
			aPawn.MovementAnims[1] = Default.RunningBackSighted;
			aPawn.MovementAnims[3] = Default.RunningRightSighted;
			aPawn.TurnLeftAnim = Default.TurnLeftSighted;
			aPawn.TurnRightAnim = Default.TurnRightSighted;
			break;
	}

	if ( aPawn.GroundSpeed < aPawn.Default.GroundSpeed )
	{
		if (gbxPawn(aPawn).LimpState == 0)
			gbxPawn(aPawn).LimpState = (Rand( 6 ) % 3) + 1;
		if (gbxPawn(aPawn).LimpState == 1)
		{
			if (Default.RunningForwardLimpLeft == '')
				return false;
			if (aPawn.MovementAnims[0] != Default.RunningForwardLimpLeft)
			{
				aPawn.bInitializeAnimation = false;
			}
			aPawn.MovementAnims[0] = Default.RunningForwardLimpLeft;
		}
		else
		{
			if (Default.RunningForwardLimpRight == '')
				return false;
			if (aPawn.MovementAnims[0] != Default.RunningForwardLimpRight)
			{
				aPawn.bInitializeAnimation = false;
			}
			aPawn.MovementAnims[0] = Default.RunningForwardLimpRight;
		}
	}

	return true;
}

static function bool SetPawnWalkingAnim( Pawn	aPawn )
{
	if (gbxPawn( aPawn ) == None)
		return false;

	switch (aPawn.eWeaponAimedState)
	{
		case WAS_Relaxed:
			if (aPawn.MovementAnims[0] != Default.WalkingForwardRelaxed)
			{
				aPawn.bInitializeAnimation = false;
			}
			aPawn.MovementAnims[0] = Default.WalkingForwardRelaxed;
			aPawn.MovementAnims[2] = Default.WalkingLeftRelaxed;
			aPawn.MovementAnims[1] = Default.WalkingBackRelaxed;
			aPawn.MovementAnims[3] = Default.WalkingRightRelaxed;
			aPawn.TurnLeftAnim = Default.TurnLeftRelaxed;
			aPawn.TurnRightAnim = Default.TurnRightRelaxed;
			break;

		case WAS_CombatRelaxed:
			if (aPawn.MovementAnims[0] != Default.WalkingForwardRelaxed)
			{
				aPawn.bInitializeAnimation = false;
			}
			aPawn.MovementAnims[0] = Default.WalkingForwardRelaxed;
			aPawn.MovementAnims[2] = Default.WalkingLeftRelaxed;
			aPawn.MovementAnims[1] = Default.WalkingBackRelaxed;
			aPawn.MovementAnims[3] = Default.WalkingRightRelaxed;
			aPawn.TurnLeftAnim = Default.TurnLeftCombatRelaxed;
			aPawn.TurnRightAnim = Default.TurnRightCombatRelaxed;
			break;

		case WAS_AimedHip:
		case WAS_Sighted:
			if (aPawn.MovementAnims[0] != Default.WalkingForwardSighted)
			{
				aPawn.bInitializeAnimation = false;
			}
			aPawn.MovementAnims[0] = Default.WalkingForwardSighted;
			aPawn.MovementAnims[2] = Default.WalkingLeftSighted;
			aPawn.MovementAnims[1] = Default.WalkingBackSighted;
			aPawn.MovementAnims[3] = Default.WalkingRightSighted;
			aPawn.TurnLeftAnim = Default.TurnLeftSighted;
			aPawn.TurnRightAnim = Default.TurnRightSighted;
			break;
	}

	if ( aPawn.GroundSpeed < aPawn.Default.GroundSpeed )
	{
		if (gbxPawn(aPawn).LimpState == 0)
			gbxPawn(aPawn).LimpState = (Rand( 6 ) % 3) + 1;
		if (gbxPawn(aPawn).LimpState == 1)
		{
			if (Default.WalkingForwardLimpLeft == '')
				return false;
			if (aPawn.MovementAnims[0] != Default.WalkingForwardLimpLeft)
			{
				aPawn.bInitializeAnimation = false;
			}
			aPawn.MovementAnims[0] = Default.WalkingForwardLimpLeft;
		}
		else
		{
			if (Default.WalkingForwardLimpRight == '')
				return false;
			if (aPawn.MovementAnims[0] != Default.WalkingForwardLimpRight)
			{
				aPawn.bInitializeAnimation = false;
			}
			aPawn.MovementAnims[0] = Default.WalkingForwardLimpRight;
		}
	}

	if ( gbxPawn( aPawn ).m_bCornerHunkered && !gbxPawn( aPawn ).m_bStandingOverCorner )
	{
		aPawn.TurnLeftAnim = 'standing_wall_lean_idle';
		aPawn.TurnRightAnim = 'standing_wall_lean_idle';
	}

	return true;
}

static function bool SetPawnCrouchedSprintAnim( Pawn	aPawn )
{
	if (gbxPawn( aPawn ) == None)
		return false;

	if (Default.CrouchedSprint == '')
		return false;
	if (aPawn.MovementAnims[0] != Default.CrouchedSprint)
	{
		aPawn.bInitializeAnimation = false;
	}
	aPawn.MovementAnims[0] = Default.CrouchedSprint;
	aPawn.MovementAnims[2] = Default.CrouchedSprint;
	aPawn.MovementAnims[1] = Default.CrouchedSprint;
	aPawn.MovementAnims[3] = Default.CrouchedSprint;

	aPawn.TurnLeftAnim = Default.CrouchedTurnLeftSighted;
	aPawn.TurnRightAnim = Default.CrouchedTurnRightSighted;

	aPawn.bInitializeAnimation = false;
	
	return true;
}

static function bool SetPawnCrouchWalkingAnim( Pawn	aPawn )
{
	switch (aPawn.eWeaponAimedState)
	{
		case WAS_Relaxed:
		case WAS_CombatRelaxed:
			if (aPawn.MovementAnims[0] != Default.CrouchedCreepForwardRelaxed)
			{
				aPawn.bInitializeAnimation = false;
			}
			aPawn.MovementAnims[0] = Default.CrouchedCreepForwardRelaxed;
			aPawn.MovementAnims[2] = Default.CrouchedCreepLeftRelaxed;
			aPawn.MovementAnims[1] = Default.CrouchedCreepBackRelaxed;
			aPawn.MovementAnims[3] = Default.CrouchedCreepRightRelaxed;
			break;

		case WAS_AimedHip:
		case WAS_Sighted:
			if (aPawn.MovementAnims[0] != Default.CrouchedCreepForwardSighted)
			{
				aPawn.bInitializeAnimation = false;
			}
			aPawn.MovementAnims[0] = Default.CrouchedCreepForwardSighted;
			aPawn.MovementAnims[2] = Default.CrouchedCreepLeftSighted;
			aPawn.MovementAnims[1] = Default.CrouchedCreepBackSighted;
			aPawn.MovementAnims[3] = Default.CrouchedCreepRightSighted;
			break;
	}

	if ( gbxPawn( aPawn ).m_bCornerHunkered )
	{
		GetHunkeredTurnAnims( aPawn, aPawn.TurnLeftAnim, aPawn.TurnRightAnim );
	}
	else
	{
		aPawn.TurnLeftAnim = Default.CrouchedTurnLeftSighted;
		aPawn.TurnRightAnim = Default.CrouchedTurnRightSighted;
	}

	return true;
}

static function name PawnReactToBulletsAnim( Pawn	aPawn )
{
	local int nReaction;
	local gbxPawn gbxP;

	gbxP = gbxPawn( aPawn );
	if( aPawn.bIsManningTurret )
	{
		return '';
	}
	else if (aPawn.bIsCrouched)
	{		
		if ( gbxP.m_bCornerHunkered )
		{
			if ( !gbxP.m_bCornerFiring && !gbxP.m_bStandingOverCorner )
			{
				if ( gbxP.m_MyLeanDirection == CDIR_Left )
				{
					nReaction = Rand( 8 ) % Default.ReactToBulletsLeftCornerCrouched.Length;
					return Default.ReactToBulletsLeftCornerCrouched[nReaction];
				}
				else
				{
					nReaction = Rand( 8 ) % Default.ReactToBulletsRightCornerCrouched.Length;
					return Default.ReactToBulletsRightCornerCrouched[nReaction];
				}
			}
			else
			{
				return '';
			}
		}
		else
		{
			nReaction = Rand( 8 ) % Default.ReactToBulletsCrouched.Length;
			return Default.ReactToBulletsCrouched[nReaction];
		}
	}
	else
	{
		if ( gbxP.m_bCornerHunkered )
		{
			if ( !gbxP.m_bCornerFiring && !gbxP.m_bStandingOverCorner )
			{
				nReaction = Rand( 8 ) % Default.ReactToBulletsLeftCornerStanding.Length;
				if ( gbxP.m_MyLeanDirection == CDIR_Left )
				{
					nReaction = Rand( 8 ) % Default.ReactToBulletsLeftCornerStanding.Length;
					return Default.ReactToBulletsLeftCornerStanding[nReaction];
				}
				else
				{
					nReaction = Rand( 8 ) % Default.ReactToBulletsRightCornerStanding.Length;
					return Default.ReactToBulletsRightCornerStanding[nReaction];
				}
			}
			else
			{
				return '';
			}
		}
	else
	{
		nReaction = Rand( 8 ) % Default.ReactToBulletsStanding.Length;
		return Default.ReactToBulletsStanding[nReaction];
	}
}
}

/// These are deprecated
static function name PawnThrowGrenadeAnim( Pawn	aPawn )
{
	// For now, lets just use the standing animation to see how it works out.
//	if (aPawn.bIsCrouched)
//		return Default.ThrowGrenadeCrouched;
//	else
		return Default.ThrowGrenadeStanding;
}

static function name PawnThrowGermanGrenadeAnim( Pawn	aPawn )
{
	if (aPawn.bIsCrouched)
		return Default.ThrowGermanGrenadeCrouched;
	else
		return Default.ThrowGermanGrenadeStanding;
}
////

static function name PawnReturnGrenadeAnim( Pawn aPawn )
{
	if(aPawn.bIsCrouched)
		return Default.GrenadeReturnCrouched;
	else
		return Default.GrenadeReturnStanding;
}

static function name PawnGrenadeToCowerAnim( Pawn aPawn )
{
	if (aPawn.bIsCrouched)
		return Default.GrenadeCrouchedToCower;
	else
		return Default.GrenadeStandingToCower;
}

static function name PawnGrenadeFromCowerAnim( Pawn aPawn )
{
	if (aPawn.bIsCrouched)
		return Default.GrenadeCrouchedFromCower;
	else
		return Default.GrenadeStandingFromCower;
}

static function name PlayerBlownDownAnim()
{
	return Default.PlayerBlownDown[Rand(100) % Default.PlayerBlownDown.Length];
}

static function name PawnStandToCrouchAnim( Pawn aPawn, optional bool bFacingWall )
{
	if ( gbxPawn( aPawn ).m_bStandingOverCorner )
	{
		if ( gbxPawn( aPawn ).m_MyLeanDirection == CDIR_Left )
			return Default.StandingCoverFireToCrouchLeft;
		else
			return Default.StandingCoverFireToCrouchRight;
	}
	else if ( gbxPawn( aPawn ).m_bStandPeeking )
	{
		return Default.StandingPeekToCrouch;
	}
	else if ( bFacingWall || gbxPawn( aPawn ).m_bUsingCrouchedCover )
	{
		if (aPawn.Level.BaseUnitSkillLevel > SKILL_Intermediate)
		{
			if (aPawn.Level.NetMode != NM_StandAlone)
			{
				return Default.StandingToCrouchFacingWall;
			}
			else
			{
				return Default.StandingToCrouchFacingWallUrban;
			}
		}
		else
		{
			return Default.StandingToCrouchFacingWall;
		}
	}
	else
		return Default.StandingToCrouch;
}

static function name PawnCrouchToStandAnim( Pawn aPawn, optional bool bFacingWall )
{
	if ( gbxPawn( aPawn ).m_bStandingOverCorner )
	{
		if ( gbxPawn( aPawn ).m_MyLeanDirection == CDIR_Left )
			return Default.CrouchToStandingCoverFireLeft;
		else
			return Default.CrouchToStandingCoverFireRight;
	}
	else if ( gbxPawn( aPawn ).m_bStandPeeking )
	{
		return Default.CrouchToStandingPeek;
	}
	else if ( bFacingWall || gbxPawn( aPawn ).m_bUsingCrouchedCover )
	{
		if (aPawn.Level.BaseUnitSkillLevel > SKILL_Intermediate)
		{
			if (aPawn.Level.NetMode != NM_StandAlone)
			{
				return Default.CrouchToStandingFacingWall;
			}
			else
			{
				return Default.CrouchToStandingFacingWallUrban;
			}
		}
		else
		{
			return Default.CrouchToStandingFacingWall;
		}
	}
	else
		return Default.CrouchToStanding;
}

static function name PawnCrouchToStandingCoverAnim( Pawn aPawn )
{
	return Default.WallLeanCrouchedToStandingBack;
}

static function name PawnStandToStandingCoverAnim( Pawn aPawn )
{
	return Default.WallLeanStandingToStandingBack;
}

static function name MG42GunnerAnim( bool bIsMount, optional bool bNeedsTurn )
{
	if ( bIsMount )
		return Default.MountMG42Gunner;
	else if ( bNeedsTurn )
		return Default.DismountMG42GunnerTurn;
	else
		return Default.DismountMG42Gunner;
}

static function name MeleeAttackAnim( Pawn aPawn )
{
	local int RandInt;

	RandInt = Rand(Default.MeleeAttack.Length - 1);
	return Default.MeleeAttack[RandInt];
}

static function name TankStuart30calAnim( bool bIsMount )
{
	if ( bIsMount )
		return Default.MountTankStuart30cal;
	else
		return Default.DismountTankStuart30cal;
}

static function name TankSherman50calAnim( bool bIsMount )
{
	if ( bIsMount )
		return Default.MountTankSherman50cal;
	else
		return Default.DismountTankSherman50cal;
}

static function name FlakVGunnerDismountAnim( out float XOffset, out float YOffset, out Rotator RotOffset )
{
	XOffset = Default.OffsetXFlakVGunnerDismount;
	YOffset = Default.OffsetYFlakVGunnerDismount;
	RotOffset = Rot( 0, 32768, 0 );
	return Default.DismountFlakVGunner;
}

static function name FlakVLoaderDismountAnim( bool bIsLeftLoader, out float XOffset, out float YOffset, out Rotator RotOffset )
{
	if ( bIsLeftLoader )
	{
		XOffset = Default.OffsetXFlakVLeftLoaderDismount;
		YOffset = Default.OffsetYFlakVLeftLoaderDismount;
		RotOffset = Rot( 0, 32768, 0 );
		return Default.DismountFlakVLeftLoader;
	}
	else
	{
		XOffset = Default.OffsetXFlakVRightLoaderDismount;
		YOffset = Default.OffsetYFlakVRightLoaderDismount;
		RotOffset = Rot( 0, 32768, 0 );
		return Default.DismountFlakVRightLoader;
	}
}

static function name Pak88GunnerDismountAnim( out float XOffset, out float YOffset, out Rotator RotOffset )
{
	return Default.DismountPak88Gunner;
}

static function name Pak88LoaderDismountAnim(out float XOffset, out float YOffset, out Rotator RotOffset )
{

		return Default.DismountPak88Loader;

}

static function name Pak88FuseSetterDismountAnim(out float XOffset, out float YOffset, out Rotator RotOffset )
{

		return Default.DismountPak88FuseSetter;

}

static function name Pak36GunnerDismountAnim( out float XOffset, out float YOffset )
{
	XOffset = Default.OffsetXPak36GunnerDismount;
	YOffset = Default.OffsetYPak36GunnerDismount;
	return Default.DismountPak36Gunner;
}

static function name Pak36LoaderDismountAnim( out float XOffset, out float YOffset )
{
	XOffset = Default.OffsetXPak36LoaderDismount;
	YOffset = Default.OffsetYPak36LoaderDismount;
	return Default.DismountPak36Loader;
}


static function name MortarGunnerDismountAnim( out float XOffset, out float YOffset )
{
	XOffset = Default.OffsetXMortarGunnerDismount;
	YOffset = Default.OffsetYMortarGunnerDismount;
	return Default.DismountMortarGunner;
}

static function name MortarLoaderDismountAnim( bool bIsLeftLoader, out float XOffset, out float YOffset, out Rotator RotOffset )
{
	if ( bIsLeftLoader )
	{
		XOffset = Default.OffsetXMortarLeftLoaderDismount;
		YOffset = Default.OffsetYMortarLeftLoaderDismount;
		RotOffset = Rot( 0, 32768, 0 );
		return Default.DismountMortarLeftLoader;
	}
	else
	{
		XOffset = Default.OffsetXMortarRightLoaderDismount;
		YOffset = Default.OffsetYMortarRightLoaderDismount;
		RotOffset = Rot( 0, 32768, 0 );
		return Default.DismountMortarRightLoader;
	}
}

static function name PawnJumpInPlaceAnim()
{
	return Default.JumpInPlace;
}

static function name PawnRunningJumpAnim()
{
	return Default.RunningJump;
}

static function name PawnTNTMountAnim()
{
	return Default.TNTMountAnim;
}

static function name PawnTNTPlantingAnim()
{
	return Default.TNTPlantingAnim;
}

static function name PawnTNTDismountAnim()
{
	return Default.TNTDismountAnim;
}

static function name RelaxedTransitionAnim()
{
	// TBD: put this in TwoHand.uc
	return 'standing_combat_to_relaxed';
}

static function name CombatReadyTransitionAnim()
{
	// When randomly-chosen isn't good enough: seed a random index value, then increment it with each call,
	// to guarantee that three soldiers in the same unit do not play the same animation.
	local int ndx;
		
	// Seed the initial value.
	if ( Default.CurCombatReadyNdx == -1 )
	{
		Default.CurCombatReadyNdx = Rand( Default.CombatReadyTransitions.Length );
	}

	ndx = Default.CurCombatReadyNdx;
	Default.CurCombatReadyNdx = ( Default.CurCombatReadyNdx + 1 ) % Default.CombatReadyTransitions.Length;
	
	return Default.CombatReadyTransitions[ ndx ];	
}


defaultproperties
{
	CurCombatReadyNdx=-1
}

//=============================================================================
// Object to facilitate storing an bit mask to test against and an event to fire when matched
//
// << GBX/PAD:created -- entire file
//
//=============================================================================

class MaskTestInfo extends Object;



var (MaskTestInfo) int			m_nTestMask;
var (MaskTestInfo) name			m_szMaskEvent;
//*********************************************************
// MaterialImpact.uc
//
// Author: Neil Johnson
// 5/14/2003
//
// Base class for material impact handlers.  Each subclass
// of MaterialImpact is responsible for spawning visual/sound
// effects for a particular material type, such as metal or wood.
//
//*********************************************************
class MaterialImpact extends Actor
	transient
	native;

cpptext
{
	void HandleBulletImpact(AActor* HitActor, AActor* Spawner, BYTE WeaponCategory, const FVector& ImpactLoc, const FRotator& ImpactRot, UBOOL bLowDetail);
	class UMaterial* GetImpactDecal() { return ImpactDecals[ appRand()%4 ]; }
}

//---------------------------------------------------------
// Variables
//---------------------------------------------------------
var SoundProxy		Proxy;
//var transient Emitter		ImpactEffect;	// Keep track of the emitter in order to play a sound effect on it.
var transient Material		ImpactDecals[4];

var String			ImpactSoundFile;
var String			MeleeImpactSoundFile;
var String			FootStepSoundFile;
var String			FootTurnSoundFile;
var String			GrenadeBounceSoundFile;


var Cue				ImpactSoundCue;
var Cue				MeleeImpactSoundCue;
var Cue				FootStepSoundCue;
var Cue				StereoFootStepSoundCue;
var Cue				FootTurnSoundCue;
var Cue				StereoFootTurnSoundCue;

var Cue				GrenadeBounceSoundCue;

var bool			bDisableEmitters, bDisableSounds;
var bool			bFootStepSoundsLoaded;
var bool			bFootTurnSoundsLoaded;
var bool			bGrenadeBounceSoundLoaded;
var bool			bMeleeImpactSoundLoaded;

//---------------------------------------------------------
//	Initialize
//---------------------------------------------------------
function Initialize()
{
	local string stereoName;
	local int idx;

	if ( ImpactSoundFile != "" )
		ImpactSoundCue = LoadSound( ImpactSoundFile );

	// PSV: 3/30/2004 Footsteps sound now use cues
	/*
	if ( FootStepSoundFile != "" )
		FootStepSound = Sound( DynamicLoadObject( FootStepSoundFile, class'Sound' ) );
	*/

	// Load cue if it hasn't been loaded already
	if ( !bFootStepSoundsLoaded )
	{
		if ( FootStepSoundFile != "" )
		{
			bFootStepSoundsLoaded = true;
		
			// Call DLO on Sound if Xbox or Cue if other platform
			FootStepSoundCue = LoadSound( FootStepSoundFile );

			// Stereo name is like PLAYER.FOOTSTEP_ST_BLAHBLAHBLAH
			idx = InStr( FootStepSoundFile, "_", true );

			if( idx >= 0 )
			{
				stereoName = Left( FootStepSoundFile, idx + 1 )$"ST"$Mid( FootStepSoundFile, idx );
				StereoFootStepSoundCue = LoadSound( stereoName );
			}
		}

		// Set this to true even if FootStepSoundFile is empty so we don't keep trying to load 
		bFootStepSoundsLoaded = true;
	}

	// Load cue if it hasn't been loaded already
	if ( !bFootTurnSoundsLoaded )
	{
		if ( FootTurnSoundFile != "" )
		{
			bFootTurnSoundsLoaded = true;
		
			// Call DLO on Sound if Xbox or Cue if other platform
			FootTurnSoundCue = LoadSound( FootTurnSoundFile );

			// Stereo name is like PLAYER.FOOTSTEP_ST_BLAHBLAHBLAH
			idx = InStr( FootTurnSoundFile, "_", true );

			if( idx >= 0 )
			{
				stereoName = Left( FootTurnSoundFile, idx + 1 )$"ST"$Mid( FootTurnSoundFile, idx );
				StereoFootTurnSoundCue = LoadSound( stereoName );
			}
		}

		// Set this to true even if FootTurnSoundFile is empty so we don't keep trying to load 
		bFootTurnSoundsLoaded = true;
	}
	
	if ( !bGrenadeBounceSoundLoaded )
	{
		if( GrenadeBounceSoundFile != "" )
		{
			GrenadeBounceSoundCue = LoadSound( GrenadeBounceSoundFile );
		}

		bGrenadeBounceSoundLoaded = true;
	}

	// Load melee impact sound cue
	if ( !bMeleeImpactSoundLoaded )
	{
		if( MeleeImpactSoundFile != "" )
		{
			MeleeImpactSoundCue = LoadSound( MeleeImpactSoundFile );
		}

		bMeleeImpactSoundLoaded = true;
	}
}

function HandleExplosionImpact(Actor Spawner, EWeaponCategory WeaponCategory, Vector ImpactLoc, Rotator ImpactRot);
function HandleMeleeImpact( Actor Spawner, Material HitMaterial, Vector ImpactLoc, Rotator ImpactRot);

//---------------------------------------------------------
//	HandleBulletImpact
//---------------------------------------------------------
event HandleBulletImpact(Actor HitActor, Actor Spawner, EWeaponCategory WeaponCategory, Vector ImpactLoc, Rotator ImpactRot, bool bLowDetail)
{
	if ( Proxy == None )
	{
		Proxy = Spawner.Spawn( class'SoundProxy' );
	}
}

//---------------------------------------------------------
// PlayGrenadeBounceSound
//---------------------------------------------------------
event PlayGrenadeBounceSound( Actor Sponsor )
{
	if ( bDisableSounds )
		return;

	if ( GrenadeBounceSoundCue != None && !GrenadeBounceSoundCue.IsEmpty() && Sponsor != None )
	{
		Sponsor.PlaySoundCue( GrenadeBounceSoundCue, SLOT_None,,,,,);	
	}	
}

//---------------------------------------------------------
//	PlayMeleeImpactSound
//---------------------------------------------------------
event PlayMeleeImpactSound(Actor Sponsor, Vector ImpactLoc )
{

	if ( bDisableSounds)
		return;

	if ( ImpactSoundCue != None )
	{
		Sponsor.PlaySoundCue( MeleeImpactSoundCue, SLOT_None,,,,,);	
	}
}


//---------------------------------------------------------
//	PlayBulletImpactSound
//---------------------------------------------------------
event PlayBulletImpactSound(EWeaponCategory WeaponCategory, Vector ImpactLoc )
{
	if ( bDisableSounds || Proxy == None )
		return;

	if ( ImpactSoundCue != None )
	{
		Proxy.SetLocation( ImpactLoc );
		Proxy.PlaySoundCue( ImpactSoundCue, SLOT_None,,,,, );
	}
}

//---------------------------------------------------------
//	PlayFootStepSound
//---------------------------------------------------------
simulated function PlayFootStepSound( Actor Sponsor )
{
	if ( FootStepSoundCue != None && !FootStepSoundCue.IsEmpty() && Sponsor != None )
	{
		// Don't play footsteps in splitscreen
		if ( !Sponsor.IsSplitscreen() )
		{
			if( Pawn(Sponsor) != None && Pawn(Sponsor).IsFirstPerson() )
			{
				Sponsor.PlayLocalSoundCue(StereoFootStepSoundCue, SLOT_None, false);
			}
			else
			{
				Sponsor.PlaySoundCue( FootStepSoundCue, SLOT_None,,,,,);	
			}
		}
	}	
}

//---------------------------------------------------------
//	PlayFootTurnSound
//---------------------------------------------------------
simulated function PlayFootTurnSound( Actor Sponsor )
{
	if ( FootTurnSoundCue != None && !FootTurnSoundCue.IsEmpty() && Sponsor != None )
	{
		// Don't play footsteps in splitscreen
		if ( !Sponsor.IsSplitscreen() )
		{
			if( Pawn(Sponsor) != None && Pawn(Sponsor).IsFirstPerson() )
			{
				Sponsor.PlayLocalSoundCue(StereoFootTurnSoundCue, SLOT_None, false);
			}
			else
			{
				Sponsor.PlaySoundCue( FootTurnSoundCue, SLOT_None,,,,,);	
			}
		}
	}	
}

//---------------------------------------------------------
//	GetImpactDecal
//---------------------------------------------------------
function Material GetImpactDecal()
{
	local int nRand;
	
	nRand = Rand(4);
	return ImpactDecals[ nRand ];
}

function CreateHudDirtEffect( PlayerController PC, vector ImpactLoc, float MaxDistanceSquared, range ParticleCountRange, bool bScaleByDistance, bool bImpactMustBeVisible )
{
	local float SquaredDist, fAngle;
	local int numParticles;

	// Throw dirt on the screen
	if( PC !=None && PC.Pawn != None )
	{
		if( bImpactMustBeVisible )
		{
			fAngle = PC.Pawn.GetFacingAngleToLocation( ImpactLoc );

			if( !(fAngle > (360.0 - PC.DesiredFOV / 2) || fAngle < (PC.DesiredFOV / 2)) )
				return;
		}

		SquaredDist = VSizeSquared( ImpactLoc - Pc.Pawn.Location );

		if( SquaredDist <= MaxDistanceSquared )
		{
			if( bScaleByDistance )
			{
				numParticles = Lerp( 1.0 - SquaredDist/MaxDistanceSquared, ParticleCountRange.Min, ParticleCountRange.Max );
			}
			else
			{	
				numParticles = RandRange( ParticleCountRange.Min, ParticleCountRange.Max );
			}
			
			PC.CreateHudDirtEffect( numParticles );
		}
	}
}

function CreateHudWaterEffect( PlayerController PC, vector ImpactLoc, float MaxDistanceSquared, range ParticleCountRange, bool bScaleByDistance, bool bImpactMustBeVisible )
{
	local float SquaredDist, fAngle;
	local int numParticles;

	// Throw dirt on the screen
	if( PC !=None && PC.Pawn != None )
	{
		if( bImpactMustBeVisible )
		{
			fAngle = PC.Pawn.GetFacingAngleToLocation( ImpactLoc );

			if( !(fAngle > (360.0 - PC.DesiredFOV / 2) || fAngle < (PC.DesiredFOV / 2)) )
				return;
		}

		SquaredDist = VSizeSquared( ImpactLoc - Pc.Pawn.Location );

		if( SquaredDist <= MaxDistanceSquared )
		{
			if( bScaleByDistance )
			{
				numParticles = Lerp( 1.0 - SquaredDist/MaxDistanceSquared, ParticleCountRange.Min, ParticleCountRange.Max );
			}
			else
			{	
				numParticles = RandRange( ParticleCountRange.Min, ParticleCountRange.Max );
			}
			
			PC.CreateHudRainEffect( numParticles );
		}
	}
}


//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
	bFootStepSoundsLoaded=false
	bHidden=true
}
class MG42Trigger extends gbxContextUseTrigger;

var Actor		m_aAngleTarget;
var float		facingAngle;


function Touch( Actor Other )
{
	local Pawn TouchedBy;

	if (bDisabled)
		return;

	if (bDontDisplayMessage)
		return;

	TouchedBy = Pawn( Other );

	if ( TouchedBy == None || !TouchedBy.IsHumanControlled() )
		return;

	m_fMessageActive = false;

	m_aTouchedBy = TouchedBy;

	if (m_aUseTarget == None)
	{
		if (m_szUseTarget != '')
		{
			foreach AllActors( class'Actor', m_aUseTarget, m_szUseTarget )
				break;
		}
	}

	if( (Other.Instigator != None) )
	{
		if (m_aTouchedBy == None)
			return;


		if (m_aAngleTarget != None)
		{
			if (isBehind(m_aTouchedBy, m_aAngleTarget, facingAngle) == false)
			{
				m_aTouchedBy.ReceiveLocalizedMessage(class'gbxContextUseHUDMessage', -1);  // remove the message from the HUD
				return;
			}
		}

		m_aTouchedBy.ReceiveLocalizedMessage(class'gbxContextUseHUDMessage', m_eUseType);  // display the USE message
		m_fMessageActive = true;
	}
}

function UnTouch( Actor Other )
{
	local Pawn User;
	local Pawn UnTouchedBy;

	UnTouchedBy = Pawn( Other );

	if ( UnTouchedBy == None || UnTouchedBy != m_aTouchedBy )
		return;

	m_aTouchedBy = None;

	bDontDisplayMessage = false;  //NAC: you've walked out of the trigger zone, so make sure that you allow the message to display again no matter what.

	if( (Other.Instigator != None) )
	{
		User = Pawn(Other);

		if (m_fMessageActive)
		{
			User.ReceiveLocalizedMessage(class'gbxContextUseHUDMessage', -1);  // remove the message from the HUD
			m_fMessageActive = false;
		}
	}
}

function bool isBehind(Actor Main, Actor Other, float dotProduct)
{
	local vector vRotOther;
	local vector vRotAngle;
	local float dotResult;

	vRotOther = Vector(Other.Rotation);

	vRotAngle = normal(Other.Location - Main.Location);

	dotResult = vRotAngle dot vRotOther;

	if (dotResult > dotProduct)
		return true;

	return false;
}

function Tick( float deltaTime )
{
	Super.Tick( deltaTime );

	if (m_aTouchedBy != None)
	{
		if (m_aAngleTarget != None)
		{
			if (isBehind(m_aTouchedBy, m_aAngleTarget, facingAngle) == false)
			{
				if (m_fMessageActive)
				{
					m_aTouchedBy.ReceiveLocalizedMessage(class'gbxContextUseHUDMessage', -1);  // remove the message from the HUD
					m_fMessageActive = false;
				}
			}
			else if (!m_fMessageActive)
			{
				m_aTouchedBy.ReceiveLocalizedMessage(class'gbxContextUseHUDMessage', m_eUseType);  // display the USE message
				m_fMessageActive = true;
			}
		}
	}
}

event bool UsedBy( Pawn User )
{
	local PlayerController	aPlayer;

	if (bDisabled)
		return false;

	if (m_aTouchedBy == None)
		return false;

	if (m_aTouchedBy != None)
	{
		if (m_aAngleTarget != None)
		{
			if (isBehind(m_aTouchedBy, m_aAngleTarget, facingAngle) == false)
			{
				return false;
			}
		}
	}

	if( (User != None) )
	{
		aPlayer = PlayerController(User.Controller);
		if (aPlayer != None)
		{
			bDontDisplayMessage = true;
			User.ReceiveLocalizedMessage(class'gbxContextUseHUDMessage', -2);  // remove the message from the HUD
		}
	}

	// make SURE TriggerEvent is called with 'self' as second parameter (this is necessary for tanks
	// which have multiple triggers and the tank weapon code needs to know which gbxContextUseTrigger
	// was used to trigger it, since 2 or more triggers can trigger the same actor).
	TriggerEvent(Event, self, User);

	return true;
}


defaultproperties
{
	facingAngle = 0.5 // Within 45 deg each way.
}class MPGameMessages extends LocalMessage;

var localized string ReinforcementsArriveString;

static function string GetString(
	optional int Switch,
	optional PlayerReplicationInfo RelatedPRI_1,
	optional PlayerReplicationInfo RelatedPRI_2,
	optional Object OptionalObject
	)
{
	switch(Switch)
	{
	case 0:
		return Default.ReinforcementsArriveString;
		break;
	}
}

defaultproperties
{
	bBeep=false
	bFadeMessage=True
	bIsSpecial=True
	bIsUnique=True
	Lifetime=5

	DrawColor=(R=0,G=160,B=255,A=255)
	FontSize=1

	YPos=240

	ReinforcementsArriveString="Reinforcements have arrived!"

}class MultiplayerUnit extends Unit
	placeable
	native;

var () ETeamMemberID TeamMemberID;

var bool shouldTryToJoinSuperUnit;
var	name mpSuperUnitName;

var() ETeamIdentifier Team;

var UnitReplicationInfo UnitReplicationInfo;

replication
{
	reliable if( bNetDirty && (Role==ROLE_Authority) )
        Team;
}

simulated function bool SameTeamAsUnit(Unit aUnit)
{
	local MultiplayerUnit mpUnit; // this is pretty hacky
	mpUnit = MultiplayerUnit(aUnit);

	if (mpUnit != None && Team == mpUnit.Team)
	{
		return true;
	}
	else
	{
		return false;
	}
}

function PostBeginPlay()
{
	mpSuperUnitName = SuperUnitName;
	shouldTryToJoinSuperUnit = true;
	
	SuperUnitName = 'None';	
	
	Super.PostBeginPlay();
}

function AddMember( gbxPawn newMember )
{
	local IGbxPawnList PawnList;
	
	if ((shouldTryToJoinSuperUnit == true) && (SuperUnit == None))
	{
		if( mpSuperUnitName != 'None' )
		{
			// Find the SuperUnit.
			foreach DynamicActors( class'Unit', SuperUnit, mpSuperUnitName )
			{
				break;
			}

			if( SuperUnit != None )
			{
				SuperUnit.AddSubUnit( self );

				if( bFallInOnStartup )
					AttachToSuperUnit();
			}
		}
	}

	PawnList = Level.GetPawnList();
			
	gbxPawnList(PawnList).UnRegisterGbxPawn( newMember );
	Super.AddMember( newMember );
	gbxPawnList(PawnList).RegisterGbxPawnByTeam( newMember, Team );

	CreateUnitReplicationInfoIfNeeded();
}

function bool AllowPawnToJoin(Pawn pawn)
{
	local bool rslt;
	local PlayerReplicationInfo pri;
	
	log(self $ " MultiplayerUnit::AllowPawnToJoin(): pawn = " $ pawn, 'MP');
	
	rslt = false;
	
	if (pawn.Controller != None)
	{
		pri = pawn.Controller.PlayerReplicationInfo;
		if ((pri != None) && (pri.Team != None))
		{
			log(self $ " MultiplayerUnit::AllowPawnToJoin(): Team = " $ Team $ ", TeamMemberID = " $ TeamMemberID, 'MP');
			log(self $ " MultiplayerUnit::AllowPawnToJoin(): pri.Team.TeamIndex = " $ pri.Team.TeamIndex $ ", pri.TeamID = " $ pri.TeamID, 'MP');
			
			if ((pri.Team.TeamIndex == Team) && (pri.TeamID == TeamMemberID))
			{
				rslt = true;
			}
		}
	}
	
	log(self $ " MultiplayerUnit::AllowPawnToJoin(): rslt = " $ rslt, 'MP');

	return rslt;
}

private function CreateUnitReplicationInfoIfNeeded()
{
	if (UnitReplicationInfo == None && SuperUnit != None)
	{
		UnitReplicationInfo = Spawn(class'UnitReplicationInfo', Self,,vect(0,0,0),rot(0,0,0));

		UnitReplicationInfo.Type = UnitType;
		UnitReplicationInfo.Team = SuperUnit.Leader.Controller.PlayerReplicationInfo.Team;
		UnitReplicationInfo.TeamID = SuperUnit.Leader.Controller.PlayerReplicationInfo.TeamID;

		Log(self $ " created URI " $ UnitReplicationInfo $ " from SuperUnit Leader " $ SuperUnit.Leader $ " Team " $ UnitReplicationInfo.Team $ " TeamID " $ UnitReplicationInfo.TeamID, 'JWS');
	}
}

simulated function UnitReplicationInfo GetUnitReplicationInfo()
{
	return UnitReplicationInfo;
}

function SpeakAbout(Name SpeechGroupName)
{
	local int i;

	for( i = 0; i < NumMembers; ++i )
	{
		if (!Members[i].IsHumanControlled())
		{
			Log(self $ " SpeakAbout(" $ SpeechGroupName $ ") telling speech manager to have " $ Members[i] $ " speak", 'MPBattleDialogue');

			Level.TheAISpeechManager.PlaySpeech(
				Members[i],	
				SuperUnit.Leader,
				SpeechGroupName, 
				,
				, 
				1.0,	
				, 
				3.0, 
				2.0
			);
		}
	}
}

simulated function String GetHumanReadableName()
{
	if ((SuperUnit == None) && Leader.PlayerReplicationInfo.IsA('TeamPlayerReplicationInfo'))
		return Leader.PlayerReplicationInfo.GetHumanReadableName();
	else if ((SuperUnit == None) && Leader.IsHumanControlled())
		return Leader.GetHumanReadableName();
	else
		return class'UnitTypeInfo'.Static.GetUnitTitle( Title );	
}

defaultproperties
{
	Team = TEAM_US
	BaseSkillLevel = SKILL_Veteran
	
	shouldTryToJoinSuperUnit = false
	mpSuperUnitName = 'None'

	myInspectorClass=class'gbxInspectorUnitMP'

	MyInWorldIconClass="gbxBase.InWorldUnitIcon"
}
//=============================================================================
// MultiplayerUnitCentroid.
//=============================================================================
class MultiplayerUnitCentroid extends MultiplayerUnit
	placeable;

//---------------------------------------------------------
//     CalculateUnitCentroid
//---------------------------------------------------------

simulated function int CalculateUnitCentroid()
{
	local int totalWeight;

	totalWeight = Super.CalculateUnitCentroid();

	if( totalWeight > 0 )
		Self.SetLocation( UnitCentroid );

	return totalWeight;
}

defaultproperties
{
    bCanTeleport=True
    bBlockNonZeroExtentTraces=True
    bCollideActors=True
    CollisionHeight=1.0
    CollisionRadius=1.0
}
// ====================================================================
//  Class:  WarfareGame.MuzzleFlashAttachment
//
//	These are attached to WeaponAttachments and are flashed
//	when a shot is fired
//
// (c) 2001, Epic Games, Inc - All Rights Reserved
// ====================================================================

class MuzzleFlashAttachment extends InventoryAttachment;



var int TickCount;	// How long to display it

var(MuzzleFlash) ELightType FlashLightType;
var(MuzzleFlash) ELightEffect FlashLightEffect;

simulated event Timer()
{
	bHidden=true;
}

simulated function Flash()
{
	GotoState('Visible');
}

simulated state Visible
{
	simulated event Tick(float Delta)
	{
		if (TickCount>2)
			gotoState('');

		TickCount++;
	}

	simulated function EndState()
	{
		bHidden=true;
		LightEffect=LE_None;
		LightType=LT_None;
	}

	simulated function BeginState()
	{
		local Rotator R;
		local vector V;

		TickCount=0;
		R = RelativeRotation;
		R.Pitch = FRand() * 65535;
		SetRelativeRotation(R);

		V=Default.DrawScale3D;
//		V.Z += frand() - 0.5;
		V.X += frand() - 0.5;
		V.Y += frand() - 0.5;

		SetDrawScale3D(v);
		bHidden=false;

		LightEffect=FlashLightEffect;
		LightType=FlashLightType;
	}

}


defaultproperties
{
	bAcceptsProjectors=false
	bHidden=true
	bDynamicLight=true
	FlashLightEffect=LE_None
	FlashLightType=LT_None
}
class OracleCamera extends Object within gbxPlayerController
	native
	transient;

#exec OBJ LOAD FILE=..\texture\t_interface_mb.utx

struct native SelectionIcon
{
	var Material		Icon;
	var int				U,V,UL,VL;
};

enum ESelectionIconType
{
	SIT_UNIT_MOVE,
	SIT_UNIT_FIRE,
	SIT_UNIT_TANK,
	SIT_UNIT_US_SOLDIER,
	SIT_UNIT_GERMAN_SOLDIER,
	SIT_BEACON,
	SIT_NONE,
};

enum ESelectionBackType
{
	SBT_US,
	SBT_DE,
	SBT_BEACON,
	SBT_NONE,
};

enum ETargetRank
{
	ET_Player,
	ET_FriendlyUnit,
	ET_KnownEnemyUnit,
	ET_Beacon,
	ET_Invalid
};

var protected gbxPlayerController	MyPlayerController;				// gbxPlayerController this camera is associated with
var protected gbxPawn				MyGbxPawn;
var protected Unit					MyUnit;

var array<Actor>	arrTargets;
var int			iTarget;		// Index to keep track of which unit is currently being viewed

var float		PreOracleFOV;		// Save the FOV that we were at before activating
var() float		FOVNormal;
var() float		FOVLessThanNormal;
var() float		FOVCloseUp;
var() float		FOVUnitFudge;
var() float		FOVLerp;
var() float		MaxFOVTargetDist;
var float		CurrentFOV;
var float		RealTimeBuffer;		// Save universaltimeseconds to calculate real delta time
var float		InitArcOffset;
var float		FooterOffset;
var float		SplitScreenFooterOffset;
var float		ArcVScale;
var float		SplitScreenArcVScale;
var float		CurHudTransTime;
var float		ActivateStartTime;
var float		TargetChangeTime;
var float		IconTransitionDirection;
var float		LastCalcViewTime;				// Used to calculate deltatime in SpecialCalcView
var float		LastaStrafe;					// these need to be saved for SpecialCalcView to be able to use them
var float		LastaForward;

const TIME_ACTIVATE_SECONDS = 1.5;
const TIME_ICON_SLIDE = 0.4;
const ICON_FULL_ALPHA_WINDOW = 35;
const ICON_ZERO_ALPHA_WINDOW = 55;

var bool		bWantOracleCamMode;
var bool		bActivatingUp;
var bool		bDrawHud;
var bool		bActivating;				// If true, the oracle cam is in the middle of activating OR deactivating.
var bool		bZoom;
var bool		bSimplified;				// Multiplayer wants to use a simplified version at the end of the game. 2004-06-24 JWS
var bool		bIsTrainingTextDisplayed;
var bool		bIsTransitioning;
var bool		bIsOccluded;
var bool		bIsInLevel;
var bool		bSitViewStartSoundStarted;
var bool		bFirstPassRotating;

var() Vector	ZenithOffsetCentered;		// Defines the offset from the player's camera to place the oracle cam, assuming no "float"
var Vector		ZenithFloatOffset;
var() float     ZenithOffsetLerp;
var Vector		CurrentZenithOffset;
var Vector		PreviousZenithOffset;

var() float		HudTransitionTime;	// Time it takes to transition HUD elements to full visibility/invisiblity

var() float		MaxOrbitRadius;
var() float		MaxOrbitTheta;
var() float		MaxFloatDistanceZ;
var() float		CameraGroundClearance;

var float		UnitLabelX;
var float		UnitLabelY;
var float		UnitLabelScaleX;
var float		UnitLabelScaleY;
var float		LastTimeSecs;
var float		GroundClearanceBuffer;

var string		SelectionFooterText;
const			ORACLE_HEADER_SCALE = 1.0;
const			ORACLE_FOOTER_SCALE = 0.9;
const			SELECTION_FOOTER_ICON_SCALE_FACTOR = 0.75;

var Cue			SitViewStart;
var Cue			SitViewEnd;
var Cue			SitViewLoop;
var Cue			ClickCue;
var int			iLoopHandle;

var transient gbxInspectorMan		selectionInspector;
var Canvas.CanvasIcon	selectionFooterIcons[6];
var Canvas.CanvasIcon	selectionFooterBacks[3];
var int					selectionFooterIconSize;

const			MAX_AFORWARD = 500;
const			MAX_ASTRAFE = 500;

const			BUTTON_INPUT_THRESH = 0.25;
const			STICK_BUTTON_INTERVAL = 0.5;

const			ARROW_FLASH_LENGTH = 0.15;

var float NextLeftRightButtonTime;
var float NextForwardBackButtonTime;
var float LeftArrowFlashTime;
var float RightArrowFlashTime;
var float ThetaBuffer;
var float MaxThetaRate;
var float ThetaAccelRate;
var float ThetaAccel;
var float MaxFloatRate;
var float FloatAccelRate;
var float FloatAccel;
var float GoalFOV;
var float OcclusionTestInterval;
var float NextOcclusionTestTime;

var float CameraRotSlerpScale;
var float CamSnapAccelRate;

var float CycleTargetFloatTime;
var float CycleTargetTime;
var float CycleTargetStartTime;

var config bool			bUseInspector;
var bool		bInitializedExecution;

var rotator SavedPlayerRotation;
var transient gbxPawn SavedGbxPawn;

var localized string FieldPromotionHeader;
var localized string FieldPromotionFooter;

var Rotator CamRotationalRateMP; // Rotator that defines how fast the camera is allowed to rotate about each axis
var Rotator CamRotationalRate; // Rotator that defines how fast the camera is allowed to rotate about each axis
var Rotator LastCameraRotation;
var Vector LastZenithOffset;
var Vector LastTargetLocation;
var Vector TargetOcclusionExtent;	// Box used for occlusion trace
var Actor	LastTargetActor;

var const int HorizFieldUU;
var const int VertFieldUU;

native function InitExecution();

simulated function bool IsActive()
{
	return bWantOracleCamMode || bActivating;
}

simulated function bool IsSimplified()
{
	return bSimplified;
}

simulated function bool IsInFieldPromotion()
{
	return false;
}

simulated function SetOwnerPlayerController( gbxPlayerController PC )
{
	MyPlayerController = PC;
	if( MyPlayerController == None )
	{
		Warn( self $ ".SetOwnerPlayerController() assigned None gbxPlayerController" );
	}
	else
	{
		MyGbxPawn = gbxPawn( MyPlayerController.Pawn );

		if( MyGbxPawn == None )
		{
			Warn( self $ ".SetOwnerPlayerController( " $ MyPlayerController $ " ) found None gbxPawn." );
		}
		else
		{
			MyUnit = MyGbxPawn.MyUnit;

			if( MyUnit == None )
			{
				Warn( self $ ".SetOwnerPlayerController( " $ MyPlayerController $ " ) found None Unit." );
			}
		}
	}

	log("SetOwnerPlayerController(): MyPlayerController = " $ MyPlayerController $ ", MyGbxPawn = " $ MyGbxPawn $ ", MyUnit = " $ MyUnit, 'MP');
}

simulated function Reactivate(optional bool simplified)
{
	bSimplified = simplified;

	if (bActivating)
	{
		bWantOracleCamMode = true;
		Level.Game.bOracleCamActive = bWantOracleCamMode;
	}
}

simulated function EnterFieldPromotionMode()
{
	//Log( " OracleCamera::EnterFieldPromotionMode()", 'MP' );
	if ( !bInitializedExecution )
	{
		InitExecution();
		bInitializedExecution = true;
	}

	GotoState('FieldPromotion');
}

simulated function LeaveFieldPromotionMode()
{
	//Log( " OracleCamera::LeaveFieldPromotionMode()", 'MP' );
	GotoState('');
}

simulated function ToggleActive(optional bool simplified)
{
	//Log(self $ " OracleCamera::ToggleActive() called", 'BeaconsIcons');

	//if ( Level.NetMode != NM_LISTENSERVER && Level.NetMode != NM_CLIENT )

	if ( Level.GetLocalPlayerController().GameReplicationInfo.GameType != GT_MULTIPLAYER )
	{
		if( bActivating )			// Refuse to toggle when in mid-activation sweep.
		{
			return;
		}
	}

	CameraRotSlerpScale = 1.0f;

	bWantOracleCamMode = !bWantOracleCamMode;
	if ((Level != None) && (Level.Game != None))
		Level.Game.bOracleCamActive = bWantOracleCamMode;		// TODO Get rid of global oracle cam setting, for split screen.

	if( bWantOracleCamMode )
	{
		StartActivate(simplified);
	}
	else
	{
		StartDeactivate();
	}

	log("ToggleActive(): bWantOracleCamMode = " $ bWantOracleCamMode $ ", bActivating = " $ bActivating, 'MP');
}

simulated function ToggleZoom()
{
	// Only works when oracle cam is "stable" -- not when it's absent or in the middle of activating or deactivating.
	if( bWantOracleCamMode && !bActivating )
	{
		bZoom = !bZoom;
	}
}

simulated function Actor GetCamTargetActor()
{
	local Actor TargetActor;

	if( iTarget < 0 || iTarget >= arrTargets.Length )
	{
		iTarget = 0;
		// GBX:PAD: These are really annoying in spectator mode in multiplayer, so lets ditch them.
//		Warn( self $ ".GetCamTargetActor() found iTarget out of range." );
		TargetActor = None;
	}
	else
	{
		TargetActor = arrTargets[ iTarget ];
	}

	return TargetActor;
}

simulated function vector GetCamTargetLocation()
{
	local Vector vecTarget;
	local Actor TargetActor;
	local Unit u;
	local Pawn TargetPawn;

	TargetActor = GetCamTargetActor();

	if( TargetActor == None )
	{
		// GBX:PAD: These are really annoying in spectator mode in multiplayer, so lets ditch them.
//		Warn( "OracleCamera.GetCamTargetLocation() found GetCamTargetActor() == None" );
		vecTarget = MyGbxPawn.Location;
	}

	// Don't use the unit centroid if it's an enemy player unit, because it includes the sub-unit weighting.
	// This causes the focus to be in strange places when you are trying to look at the other player.
	if( TargetActor.IsA('Unit') )
	{
		if( Level.NetMode != NM_StandAlone )
		{
			u = Unit( TargetActor );

			if( u.Members[ 0 ] != None && u.Members[ 0 ].IsA('gbxPlayerPawn') )
			{
				vecTarget = u.Members[ 0 ].Location;
			}
			else
			{
				Unit(TargetActor).CalculateUnitCentroid();
				vecTarget = Unit(TargetActor).GetUnitCentroid();
			}
		}
		else
		{
			vecTarget = Unit(TargetActor).GetUnitCentroid();
		}
	}
	else
	{
		vecTarget = TargetActor.Location;

		TargetPawn = Pawn(TargetActor);

		if (TargetPawn != None)
		{
			if (TargetPawn.bIsCrouched)
				vecTarget = TargetPawn.Location - (vect(0,0,1) * TargetPawn.CrouchHeight) + (vect(0,0,1) * TargetPawn.default.CollisionHeight);

			vecTarget += vect(0,0,1) * (TargetPawn.default.BaseEyeHeight / 2);
		}
	}

	return vecTarget;
}

simulated function StartActivate(optional bool simplified)
{
	local float DesiredTheta;
	local int i, j;
	local Unit TargetUnit;

	bSimplified = simplified;
	bActivating = true;
	bActivatingUp = true;
	bZoom = false;
	bFirstPassRotating = true;

	SavedPlayerRotation = MyPlayerController.Rotation;
	SavedGbxPawn = MyGbxPawn;

	if (!bSimplified)
	{
		if( SitViewStart == None )
		{
			if ( ( Level.NetMode == NM_ListenServer || Level.NetMode == NM_Client ) && !bSimplified )
				SitViewStart = LoadSound( "UI.SIT_VIEW_START_FAST" );
			else
				SitViewStart = LoadSound( "UI.SIT_VIEW_START" );
		}
		if( SitViewEnd == None )
		{
			if ( ( Level.NetMode == NM_ListenServer || Level.NetMode == NM_Client ) && !bSimplified )
				SitViewEnd = LoadSound( "UI.SIT_VIEW_END_FAST" );
			else
				SitViewEnd = LoadSound( "UI.SIT_VIEW_END" );
		}
		if( SitViewLoop == None )
		{
			SitViewLoop = LoadSound( "UI.SIT_VIEW_LOOP" );
		}
	}

	// PSV: 7/16/2005 No longer needed
	if ( Level.NetMode == NM_StandAlone )
		PauseAllSounds(true, false, true);

	ActivateStartTime = Level.UniversalTimeSeconds;
	LastCalcViewTime = Level.UniversalTimeSeconds;

	// Remember what the distance fade parameters were for the player's current zone.
	gbxHUD(MyPlayerController.MyHUD).ResetInspectors();
	selectionInspector = gbxHUD(MyPlayerController.MyHUD).GetNewInspector();
	selectionInspector.bNoSelfDelete = true;

	// Make sure the FOV is default
	if( MyPlayerController != None )
	{
		PreOracleFOV = MyPlayerController.DesiredFOV;
		MyPlayerController.DesiredFOV = FOVNormal;
		MyPlayerController.bBehindView = true;
		CurrentFOV = FOVNormal;
	}

	CurHudTransTime = 0;

	BuildTargetActorList();

	// turn off alpha fogging on all targets so that they don't fade out because of distance
	for (i=0; i < arrTargets.Length; i++)
	{
		if (Unit(arrTargets[i]) != None)
		{
			TargetUnit = Unit(arrTargets[i]);

			for (j=0; j < TargetUnit.MAX_MEMBERS; j++)
			{
				if (TargetUnit.Members[j] != None)
					TargetUnit.Members[j].bAlphaFogable = false;
			}
		}
		else if (Pawn(arrTargets[i]) != None)
		{
			arrTargets[i].bAlphaFogable = false;
		}
	}

	iTarget = 0;
	SelectSelf();  // always start with self as target (per Brian Martel 8/16/05)

	// If it's not in the list any longer, just use the player.
	// This used to find the closest objective in MP, but we decided we don't really want that behavior any longer 2005-02-07 JWS
	if( iTarget < 0 )
	{
		iTarget = 0;
	}

	OnTargetChanged();

	RealTimeBuffer = 0;

	CurrentZenithOffset = GetDesiredZenithOffset();

	// Setup desaturation effect
	MyPlayerController.BeginCamSituationalAwareness();
	MyPlayerController.SetOraclePause( true );

	// Init the max orbit

	if( Level.m_flSAViewOrbitTheta > 0.0 )
	{
		DesiredTheta = FClamp( Level.m_flSAViewOrbitTheta, 0.0, 180.0 ) * ( Pi / 180.0 );
		MaxOrbitTheta = FMin( DesiredTheta, default.MaxOrbitTheta );
	}

	LastTargetActor = GetCamTargetActor();
	LastTargetLocation = LastTargetActor.Location;

	CameraRotSlerpScale = 1.0f;

	GoalFOV = FOVNormal;
	ResetZenithOffset();

	// Trigger an event for LD's to hook into
	TriggerEvent( 'OracleStart', MyGbxPawn, MyGbxPawn );
}

simulated function StartDeactivate()
{
	local int i, j;
	local Unit TargetUnit;

	bActivating = true;
	bActivatingUp = false;
	bZoom = false;
	bSimplified = false;

	bSitViewStartSoundStarted = false;

	if( MyPlayerController != None)
		MyPlayerController.EndCamSituationalAwareness();

	DeactivateTeamShadows();

	// set alpha fogging on all targets back to their default value
	for (i=0; i < arrTargets.Length; i++)
	{
		if (Unit(arrTargets[i]) != None)
		{
			TargetUnit = Unit(arrTargets[i]);

			for (j=0; j < TargetUnit.MAX_MEMBERS; j++)
			{
				if (TargetUnit.Members[j] != None)
					TargetUnit.Members[j].bAlphaFogable = TargetUnit.Members[j].default.bAlphaFogable;
			}
		}
		else if (Pawn(arrTargets[i]) != None)
		{
			arrTargets[i].bAlphaFogable = arrTargets[i].default.bAlphaFogable;
		}
	}

	ActivateStartTime = Level.UniversalTimeSeconds;

	selectionInspector.bNoSelfDelete = false;
	selectionInspector.Hide();

	if( iLoopHandle != 0 )
	{
		StopSound( iLoopHandle );
		iLoopHandle = 0;
	}

	if (!bSimplified && !IsInFieldPromotion())
	{
		PlaySoundCue( SitViewEnd, SLOT_None,,true );
	}

	// PSV: 7/16/2005 No longer needed
	if ( Level.NetMode == NM_StandAlone )
		UnpauseAllSounds( true );

	GoalFOV =  MyPlayerController.DefaultFOV;
}

simulated function ResetZenithOffset()
{
	ThetaBuffer = 0.0;
	ThetaAccel = 0.0;
	FloatAccel = 0.0;
	ZenithFloatOffset *= vect(0,0,1);
}

simulated function DeactivateImmediately()
{
	bWantOracleCamMode = false;
	Level.Game.bOracleCamActive = false;

	StartDeactivate();

	OnDeactivateFinished();
}

simulated function AddTarget( Actor newTarget )
{
	// Returns true if the "new" target is actually an old one.
	local int ndxTarget;

	ndxTarget = -1;

	if( newTarget != None && !newTarget.bDeleteMe )
	{
		ndxTarget = FindTargetInArray( newTarget );
		if( ndxTarget < 0 )
		{
			// The target really is new. Add it.
			arrTargets.Length = arrTargets.Length + 1;
			ndxTarget = arrTargets.Length - 1;

			if (ndxTarget >= 0)
			{
				arrTargets[ ndxTarget ] = newTarget;
			}

			// GBX:naj - Had to put this here in order to get the S.A. Training stuff to work.
			iTarget = ndxTarget;
		}
	}
}

/* DEPRECATED.
simulated function ETargetRank GetTargetRank( Actor aTarget )
{
	if( gbxBeacons( aTarget ) != None )
	{
		return ET_Beacon;
	}
	else if( Unit( aTarget ) != None )
	{
		if( MyUnit.MyUnitController.IsUnitKnown( Unit( aTarget )))
		{
			return ET_KnownEnemyUnit;
		}
		else if( MyUnit.IsSubUnit( Unit( aTarget ) ))
		{
			return ET_FriendlyUnit;
		}
	}
	else if( aTarget == MyGbxPawn )
	{
		return ET_Player;
	}
	else
	{
		return ET_Invalid;
	}
}
*/

simulated function int GetClosestBeaconIndex()
{
	local int i, bIndex;
	local float bDist, lDist;

	lDist = -1.0f;
	bIndex = -1;

	for( i = 0; i < arrTargets.Length; ++i )
	{
		if( arrTargets[ i ].IsA('gbxBeacons') )
		{
			bDist = VSize( arrTargets[ i ].Location - MyGbxPawn.Location ) ;

			if( bIndex < 0 || lDist < 0.0f || bDist < lDist )
			{
				bIndex = i;
				lDist = bDist;
			}
		}
	}

	return bIndex;
}

simulated function int FindTargetInArray( Actor aTarget )
{
	local int i;

	for( i = 0; i < arrTargets.Length; ++i )
	{
		if( arrTargets[ i ] == aTarget )
		{
			return i;
		}
	}

	return -1;
}

simulated function CleanseTargetActorList()
{
	arrTargets.Length = 0;

/*	local int i;

	for( i = 0; i < arrTargets.Length; ++i )
	{
		if( arrTargets[ i ] == None || arrTargets[ i ].bDeleteMe )
		{
			arrTargets.Remove( i, 1 );
			--i;
		}
	}
*/
}

simulated function BuildTargetActorList()
{
	// Search through all actors finding ones that should be look targets for the oracle camera.
	local gbxBeacons aBeacon;
	local int i, j;
	local gbxPawn aNPCFriendly;
	local ETeamIdentifier myTeam;
	local MultiplayerUnit mpUnit;

	iTarget = 0;

	CleanseTargetActorList();

	// Add the player himself
	AddTarget( MyGbxPawn );
	MyGbxPawn.EnteringTacticalView();

	// Add enabled beacons.
	foreach AllActors( class'gbxBeacons', aBeacon )
	{
		if( !aBeacon.bNotInSAView && aBeacon.bEnabled && aBeacon.VisibleToPlayer(MyPlayerController) && !aBeacon.bExcludeFromOracleCam )
		{
			AddTarget( aBeacon );
		}
	}

	// Single player only needs to add the local player's enemy and friendly units
	if ( Level.NetMode != NM_LISTENSERVER && Level.NetMode != NM_CLIENT )
	{
		if( MyUnit != None )
		{
			// Add enemy units
			for( i = 0; i < MyUnit.MyUnitController.KnownEnemyUnits.Length; ++i )
			{
				if( MyUnit.MyUnitController.KnownEnemyUnits[ i ].EnemyUnit != None &&
					MyUnit.MyUnitController.KnownEnemyUnits[ i ].EnemyUnit.AnyLivingMembers() &&
					!MyUnit.MyUnitController.KnownEnemyUnits[ i ].EnemyUnit.bExcludeFromOracleCam )
				{
					AddTarget( MyUnit.MyUnitController.KnownEnemyUnits[ i ].EnemyUnit );
					for ( j = 0; j < MyUnit.MyUnitController.KnownEnemyUnits[ i ].EnemyUnit.GetNumLivingMembers(); j++ )
					{
						MyUnit.MyUnitController.KnownEnemyUnits[ i ].EnemyUnit.Members[j].EnteringTacticalView();
					}
				}
			}

			// Add friendly units
			for( i = 0; i < MyUnit.MAX_SUBUNITS; ++i )
			{
				if( MyUnit.SubUnits[ i ] != None )
				{
					if ( MyUnit.SubUnits[ i ].AnyLivingMembers() && !MyUnit.SubUnits[ i ].bExcludeFromOracleCam )
					{
						AddTarget( MyUnit.SubUnits[ i ] );
						for ( j = 0; j < MyUnit.SubUnits[ i ].GetNumLivingMembers(); j++ )
						{
							MyUnit.SubUnits[i].Members[j].EnteringTacticalView();
						}
					}
				}
			}

			// Add NPC friendlies/units not already added
			ForEach DynamicActors( class'gbxPawn', aNPCFriendly )
			{
				if( MyGbxPawn.SameTeamAs(aNPCFriendly) && aNPCFriendly.PawnTeam != TEAM_None && !aNPCFriendly.IsDead() && aNPCFriendly != MyGbxPawn && !aNPCFriendly.bExcludeFromOracleCam )
				{
					// If he's in a unit, add the unit.  If not, add the individual.
					if( aNPCFriendly.MyUnit != None  )
					{
						if( FindTargetInArray( aNPCFriendly.MyUnit ) < 0 )
						{
							AddTarget( aNPCFriendly.MyUnit );

							for ( j = 0; j < aNPCFriendly.MyUnit.GetNumLivingMembers(); j++ )
							{
								aNPCFriendly.MyUnit.Members[j].EnteringTacticalView();
							}
						}
					}
					else if( FindTargetInArray( aNPCFriendly ) < 0 )
					{
						AddTarget( aNPCFriendly );
						aNPCFriendly.EnteringTacticalView();
					}
				}
			}
		}
	}
	else
	{
		myTeam = MyGbxPawn.PawnTeam;

		// TODO Add ally enemy units; currently only local player's enemies are added
		if ( MyUnit != None )
		{
			// Add enemy units
			for( i = 0; i < MyUnit.MyUnitController.KnownEnemyUnits.Length; ++i )
			{
				if( MyUnit.MyUnitController.KnownEnemyUnits[ i ].EnemyUnit != None &&
					MyUnit.MyUnitController.KnownEnemyUnits[ i ].EnemyUnit.AnyLivingMembers() &&
					!MyUnit.MyUnitController.KnownEnemyUnits[ i ].EnemyUnit.bExcludeFromOracleCam )
				{
					AddTarget( MyUnit.MyUnitController.KnownEnemyUnits[ i ].EnemyUnit );
				}
			}
		}

		// Add friendly units
		ForEach DynamicActors(class'MultiplayerUnit', mpUnit)
		{
			if ( mpUnit != MyUnit && !mpUnit.bExcludeFromOracleCam )	// Don't add local player's unit
			{
				if ( mpUnit.AnyLivingMembers() )
				{
					if (mpUnit.SameTeamAsUnit(MyUnit))
					{
						AddTarget( mpUnit );
						for( j = 0; j<mpUnit.MAX_MEMBERS; j++ )
						{
							mpUnit.Members[j].EnteringTacticalView();
						}
					}
				}
			}
		}
	}

	OnTargetChanged();
}

simulated function DeactivateTeamShadows()
{
	local int i, j, len;
	local Unit aUnit;

	len = arrTargets.Length;

	for( i = 0; i < len; ++i )
	{
		if( arrTargets[i].IsA('Unit') )
		{
			aUnit = Unit( arrTargets[i] );

			for ( j = 0; j < aUnit.GetNumLivingMembers(); j++ )
			{
				aUnit.Members[j].LeavingTacticalView();
			}
		}
		else if( arrTargets[i].IsA('gbxPawn') )
		{
			gbxPawn( arrTargets[i] ).LeavingTacticalView();
		}
	}
}

simulated function UpdateTargetActorList()
{
	// Search through all actors finding ones that should be look targets for the oracle camera.
	local int i, len;
	local Actor CurrentTarget, oldTarget;
	//local Unit targetUnit;
	local MultiplayerUnit mpUnit;
	local gbxBeacons aBeacon;
	//local gbxPawn playerPawn;

	CurrentTarget = GetCamTargetActor();
	oldTarget = CurrentTarget;
	len = arrTargets.Length;

    /* Uncomment for debugging...
	for( i = 0; i < len; ++i )
	{
		targetUnit = Unit(arrTargets[i]);

		if ( targetUnit != None )
			Log("OracleCamera::UpdateTargetActorList() [Before update] arrTargets[" $i$ "] = " $targetUnit, 'PSV');
		else if ( gbxBeacons(arrTargets[i]) != None )
		{
			aBeacon = gbxBeacons(arrTargets[i]);
			Log("OracleCamera::UpdateTargetActorList() [Before update] arrTargets[" $i$ "] = " $aBeacon, 'PSV');
		}
		else
		{
			// must be a player
			playerPawn = gbxPawn(arrTargets[i]);
			Log("OracleCamera::UpdateTargetActorList() [Before update] arrTargets[" $i$ "] = " $playerPawn, 'PSV');
		}
	}
    */

	CleanseTargetActorList();

	// Add the player himself
	AddTarget( MyGbxPawn );

	// Add enabled beacons.
	foreach AllActors( class'gbxBeacons', aBeacon )
	{
		if ( MyGbxPawn != None )
		{
			if( !aBeacon.bNotInSAView && aBeacon.bEnabled && aBeacon.VisibleToPlayer(MyPlayerController) )
			{
				AddTarget( aBeacon );
			}
		}
	}

	if( MyUnit != None )
	{
		// Add enemy units
		for( i = 0; i < MyUnit.MyUnitController.KnownEnemyUnits.Length; ++i )
		{
			if( MyUnit.MyUnitController.KnownEnemyUnits[ i ].EnemyUnit != None &&
				MyUnit.MyUnitController.KnownEnemyUnits[ i ].EnemyUnit.AnyLivingMembers() )
			{
				AddTarget( MyUnit.MyUnitController.KnownEnemyUnits[ i ].EnemyUnit );
			}
		}
	}

	// Add friendly units
	ForEach DynamicActors(class'MultiplayerUnit', mpUnit)
	{
		if ( mpUnit != MyUnit )	// Don't add local player's unit
		{
			if ( mpUnit.AnyLivingMembers() )
			{
				if (mpUnit.SameTeamAsUnit(MyUnit))
				{
					AddTarget( mpUnit );
				}
			}
		}
	}

	len = arrTargets.Length;

	/* Uncomment for debugging...
        for( i = 0; i < len; ++i )
	{
		targetUnit = Unit(arrTargets[i]);

		if ( targetUnit != None )
			Log("OracleCamera::UpdateTargetActorList() [End update] arrTargets[" $i$ "] = " $targetUnit, 'PSV');
		else if ( gbxBeacons(arrTargets[i]) != None )
		{
			aBeacon = gbxBeacons(arrTargets[i]);
			Log("OracleCamera::UpdateTargetActorList() [End update] arrTargets[" $i$ "] = " $aBeacon, 'PSV');
		}
		else
		{
			// must be a player
			playerPawn = gbxPawn(arrTargets[i]);
			Log("OracleCamera::UpdateTargetActorList() [End update] arrTargets[" $i$ "] = " $playerPawn, 'PSV');
		}
	}
        */

	// Check to see if we need to fix up current target index
	for ( i = 0; i < arrTargets.Length; ++i )
	{
		if ( arrTargets[i] == CurrentTarget )
		{
			if ( i != iTarget )
			{
				iTarget = i;

				UpdateTargetsOpacity();
			}
		}
	}

	// Check to see if the current target no longer valid
	CurrentTarget = GetCamTargetActor();

	// make sure the current target is still in the list
	for ( i = 0; i < arrTargets.Length; ++i )
	{
		if ( arrTargets[i] == oldTarget )
			break;
	}

	if (i == arrTargets.Length)
		CycleNextTarget();

	if ( gbxBeacons(CurrentTarget) != None )
	{
		if ( !gbxBeacons(CurrentTarget).bEnabled )
		{
			// If the beacon we were watching gets disabled, cycle to another target.
			CycleNextTarget();
			//Log("OracleCamera::UpdateTargetActorList CurrentTarget: " $CurrentTarget$ " beacon is no longer enabled, cycling to next target.", 'PSV');
		}
	}
	else if ( Unit(CurrentTarget) != None )
	{
		if ( Unit(CurrentTarget).GetNumLivingMembers() <= 0 )
		{
			// If the unit we were watching gets totally wiped out, cycle to another target.
			CycleNextTarget();
			//Log("OracleCamera::UpdateTargetActorList CurrentTarget: " $CurrentTarget$ " unit is empty, cycling to next target.", 'PSV');
		}
	}
	else if ( gbxPawn(CurrentTarget) != None )
	{
		if ( gbxPawn(CurrentTarget).IsDead() )
		{
			// If the player we were watching gets killed, cycle to another target.
			CycleNextTarget();
			//Log("OracleCamera::UpdateTargetActorList CurrentTarget: " $CurrentTarget$ " player is dead, cycling to next target.", 'PSV');
		}
	}
	else
	{
		// CurrentTarget is no longer valid
		CycleNextTarget();
		//Log("OracleCamera::UpdateTargetActorList CurrentTarget: " $CurrentTarget$ " unit is no longer valid, cycling to next target.", 'PSV');
	}
}

simulated function OnTargetChanged( optional float direction )
{
	local float x, y, r;

	// Click the arrows if necessary

	if( direction < 0.0 )
	{
		LeftArrowFlashTime = Level.UniversalTimeSeconds + ARROW_FLASH_LENGTH;
	}
	else if( direction > 0.0 )
	{
		RightArrowFlashTime = Level.UniversalTimeSeconds + ARROW_FLASH_LENGTH;;
	}

	PlayClickSound();

	// Immediately hide the previous inspector if it's still visible
	if (selectionInspector != None && selectionInspector.IsVisible())
	{
		selectionInspector.Hide();
	}

	SelectionFooterText = GetCamTargetActor().GetHumanReadableName();

	TargetChangeTime = Level.UniversalTimeSeconds;
	IconTransitionDirection = direction;

	// Update opacity values for each item in target list
	UpdateTargetsOpacity();

	bIsTransitioning = true;

	// Reset the offset if we're out of bounds
	r = GetOrbitalRadius();

	CalculateOrbit( r, ThetaBuffer, x, y );

	if( abs( y ) > MaxOrbitRadius || abs( x ) > MaxOrbitRadius )
	{
		ResetZenithOffset();
	}

	CycleTargetStartTime = Level.UniversalTimeSeconds;
}

simulated function UpdateTargetsOpacity( optional float forceValue )
{
	local int itr;
	local gbxHUD myHUD;

	// Pass in forceValue > 0 to force an alpha value. Pass in forceValue < 0 to force an alpha value of 0.0.
	// Pass in forceValue == 0 (the default) to not force a value.

	myHUD = gbxHUD(MyPlayerController.MyHUD);

	// The current target is full opacity, others are 1/3 opaque
	for( itr=0; itr < MyHUD.InWorldIcons.Length; itr++ )
	{
		if ( iTarget >= arrTargets.Length )
		{
			continue;
		}
		if ( arrTargets[iTarget].IsA( 'gbxBeacons' ) )
		{
			if( forceValue != 0 )
			{
				if( forceValue > 0 )
				{
					myHUD.InWorldIcons[itr].fOpacityMultiplier = forceValue;
				}
				else
				{
					myHUD.InWorldIcons[itr].fOpacityMultiplier = 0;
				}
			}
			else
			{
				if ( myHUD.InWorldIcons[itr] == gbxBeacons(arrTargets[iTarget]).MyIcon )
					myHUD.InWorldIcons[itr].fOpacityMultiplier = 1.0;
				else
					myHUD.InWorldIcons[itr].fOpacityMultiplier = 0.33;
			}
		}
		else if ( arrTargets[iTarget].IsA( 'Unit' ) )
		{
			if( forceValue != 0 )
			{
				if( forceValue > 0 )
				{
					myHUD.InWorldIcons[itr].fOpacityMultiplier = forceValue;
				}
				else
				{
					myHUD.InWorldIcons[itr].fOpacityMultiplier = 0;
				}
			}
			else
			{
				if ( myHUD.InWorldIcons[itr] == Unit(arrTargets[iTarget]).MyInWorldIcon )
					myHUD.InWorldIcons[itr].fOpacityMultiplier = 1.0;
				else
					myHUD.InWorldIcons[itr].fOpacityMultiplier = 0.33;
			}
		}
		else
		{
			// Most likely a player...just set all to 1/3 opaque
			if( forceValue != 0 )
			{
				if( forceValue > 0 )
				{
					myHUD.InWorldIcons[itr].fOpacityMultiplier = forceValue;
				}
				else
				{
					myHUD.InWorldIcons[itr].fOpacityMultiplier = 0;
				}
			}
			else
			{
				myHUD.InWorldIcons[itr].fOpacityMultiplier = 0.33;
			}
		}
	}
}

simulated function SelectionInspectorUpdate(gbxHud Hud)
{
	local Actor TargetActor;
	local float showTime;

	if( selectionInspector.myHud == None)
	{
		selectionInspector.myHud = Hud;
	}

	if( !selectionInspector.IsVisible() )
	{
		TargetActor = GetCamTargetActor();

		if( bActivating )
		{
			// If just appearing, go slowly.
			showTime = TIME_ACTIVATE_SECONDS;
		}

		if( gbxPawn( TargetActor ) != None )
		{
			selectionInspector.ShowPanel(TargetActor,gbxPawn( TargetActor ).myInspectorClass,showTime,-1);
		}
		else if( Unit( TargetActor ) != None )
		{
			selectionInspector.ShowPanel(TargetActor,Unit(TargetActor).myInspectorClass,showTime,-1);
		}
		else if( (gbxBeacons( TargetActor ) != None) && ((Level.NetMode == NM_StandAlone) || (Hud.PlayerOwner.GameReplicationInfo.GameType == GT_SKIRMISH)))
		{
			selectionInspector.ShowPanel(TargetActor,class'gbxInspectorBeacon',showTime,-1);
		}
	}
}

simulated function GetUnitFooterIconType(out int footerIcon, out int footerBack, optional Actor TargetActor)
{
	local Unit lUnit;
	local ETeamIdentifier myTeam;	// PSV: 5/24/2004 Added "be-friendly-with-MP" support
	local ESelectionIconType resultIcon;
	local ESelectionBackType resultBack;

	if (TargetActor == None)
		TargetActor = GetCamTargetActor();

	myTeam = MyGbxPawn.PawnTeam;

	if( gbxPawn( TargetActor ) != None )
	{
		if ( myTeam == TEAM_US )
		{
			resultIcon = SIT_UNIT_US_SOLDIER;
			resultBack = SBT_US;
		}
		else
		{
			resultIcon = SIT_UNIT_GERMAN_SOLDIER;
			resultBack = SBT_DE;
		}
	}
	else if( Unit( TargetActor ) != None )
	{
		lUnit = Unit(TargetActor);

		if( !lUnit.AnyLivingMembers() )
		{
			// Everyone in this unit is dead.
			resultIcon = SIT_NONE;
			resultBack = SBT_NONE;
		}
		else if ( lUnit.UnitType == UnitType_Vehicle )
		{
			if (lUnit.SameTeamAsUnit(MyUnit))
			{
				resultIcon = SIT_UNIT_TANK;

				if ( myTeam == TEAM_US )
				{
					resultBack = SBT_US;
				}
				else
				{
					resultBack = SBT_DE;
				}
			}
			else
			{
				if ( myTeam == TEAM_US )
				{
					resultBack = SBT_DE;
				}
				else
				{
					resultBack = SBT_US;
				}
			}
		}
		else
		{
			// TODO empty unit
			if (lUnit.SameTeamAsUnit(MyUnit))
			{
				if (lUnit.UnitType == UnitType_Assault)
				{
					resultIcon = SIT_UNIT_MOVE;
				}
				else
				{
					resultIcon = SIT_UNIT_FIRE;
				}

				// TODO movement type for same-team units
				if ( myTeam == TEAM_US )
				{
					resultBack = SBT_US;
				}
				else
				{
					resultBack = SBT_DE;
				}
			}
			else
			{
				if ( myTeam == TEAM_US )
				{
					resultIcon = SIT_UNIT_GERMAN_SOLDIER;
					resultBack = SBT_DE;
				}
				else
				{
					resultIcon = SIT_UNIT_US_SOLDIER;
					resultBack = SBT_US;
				}
			}
		}
	}
	else if( gbxBeacons( TargetActor ) != None )
	{
		resultIcon = SIT_BEACON;
		resultBack = SBT_BEACON;
	}
	else if( OracleCamLookTarget( TargetActor ) != None )
	{
		resultIcon = SIT_UNIT_US_SOLDIER;
		resultBack = SBT_US;
	}
	else
	{
		resultIcon = SIT_NONE;
		resultBack = SBT_NONE;
	}

	footerIcon = int(resultIcon);
	footerBack = int(resultBack);
}

simulated function UnitSelect()
{
	local int i, currentUnit, newTarget;

	if( !bWantOracleCamMode || bActivating || MyGbxPawn == None)
		return;

	// see if the selection is in MyUnit
	currentUnit = -1;
	for (i=0; i<MyUnit.NumSubUnits; i++)
	{
		if (iTarget >= arrTargets.Length)
		{
			continue;
		}
		if (MyUnit.SubUnits[i] == arrTargets[iTarget])
		{
			currentUnit = i;
			break;
		}
	}

	if (currentUnit == -1)
	{
		// not found, just select the first one that's in the list
		for (i=0; i<MyUnit.NumSubUnits; i++)
		{
			newTarget = FindTargetInArray(MyUnit.SubUnits[i]);
			if (newTarget != -1 && iTarget != newTarget )
			{
				iTarget = newTarget;
				OnTargetChanged();
				break;
			}
		}
	}
	else
	{
		// found one, cycle through our units
		i = currentUnit + 1;

		while (true)
		{
			newTarget = FindTargetInArray(MyUnit.SubUnits[i]);
			if (newTarget != -1 && iTarget != newTarget )
			{
				iTarget = newTarget;
				OnTargetChanged();
				break;
			}

			i++;
			if (i >= MyUnit.NumSubUnits)
				i = 0;

			if (i == currentUnit)
				break;
		}
	}

//	MyUnit
}

simulated function SelectObjective()
{
	local int i, start;
	local int num_passes;

	if( !bWantOracleCamMode || bActivating || MyGbxPawn == None )
		return;

	// find the starting point
	i = 0;
	if ((iTarget < arrTargets.Length) && (gbxBeacons(arrTargets[iTarget]) != None))
	{
		i = iTarget + 1;
	}

	start = i;
	num_passes = 0;
	while (true)
	{
		if (gbxBeacons(arrTargets[i]) != None && iTarget != i )
		{
			iTarget = i;
			OnTargetChanged();
			break;
		}

		i++;
		if (i >= arrTargets.Length)
		{
			i = 0;
			num_passes++;

			if (num_passes >= 2)  // not found?
				break;
		}

		if (i == start)
			break;
	}
}

simulated function SelectSelf()
{
	local int i, start;
	local int num_passes;

	if( !bWantOracleCamMode || bActivating || MyGbxPawn == None )
		return;

	// find the starting point
	i = 0;
	if ((iTarget < arrTargets.Length) && (gbxPawn(arrTargets[iTarget]) != None))
	{
		i = iTarget + 1;
	}

	start = i;
	num_passes = 0;
	while (true)
	{
		if (gbxPawn(arrTargets[i]) != None && iTarget != i )
		{
			iTarget = i;
			OnTargetChanged();
			break;
		}

		i++;

		if (i >= arrTargets.Length)
		{
			i = 0;
			num_passes++;

			if (num_passes >= 2)  // not found?
				break;
		}

		if (i == start)
			break;
	}
}

simulated function CycleNextTarget()
{
	if ( Level.NetMode == NM_LISTENSERVER || Level.NetMode == NM_CLIENT )
	{
		if( MyGbxPawn == None)
		{
			return;
		}
	}
	else
	{
		if( !bWantOracleCamMode || bActivating || MyGbxPawn == None)
		{
			return;
		}
	}

	++iTarget;

	if( iTarget >= arrTargets.Length )
	{
		iTarget = 0;
	}

	OnTargetChanged( 1.0 );
}

simulated function CyclePrevTarget()
{
	if ( Level.NetMode == NM_LISTENSERVER || Level.NetMode == NM_CLIENT )
	{
		if( MyGbxPawn == None)
		{
			return;
		}
	}
	else
	{
		if( !bWantOracleCamMode || bActivating || MyGbxPawn == None)
		{
			return;
		}
	}

	--iTarget;

	if( iTarget < 0 )
	{
		iTarget = arrTargets.Length - 1;
	}

	OnTargetChanged( -1.0 );
}

simulated function bool ShouldDrawFooterIcons()
{
	local bool rslt;

	if (!bSimplified)
	{
		rslt = true;
	}
	else
	{
		rslt = false;
	}

	return rslt;
}

simulated function DrawGBXHud( canvas Canvas, gbxHud Hud, FontInfo Fonts, int nPass )
{
	local float RealDeltaTime;
	local float TransDelta;
	local float xPos, yPos, xArPos, yArPos, xArRotPos, yArRotPos, XL, YL, fIconScale, flScreenScaleX, flScreenScaleY;
	local int nNumIconsToDraw, nNumIconsRight, nNumIconsLeft, nCurrentIcon, footerIcon, footerBack;
	local float flHudTransitionTime, IconTransitionProportion, IconXSpacing, IconEdgeness;
	local float normalIconAlpha;
	local gbxBeacons beacon;

	if( Hud.bIsSplitScreen )
	{
		flScreenScaleX = Hud.flSplitScreenScale;
		flScreenScaleY = Hud.flSplitScreenScale;
	}
	else
	{
		flScreenScaleX = Hud.flMinScaleX;
		flScreenScaleY = Hud.flMinScaleY;
	}

	if( RealTimeBuffer == 0.0 )
		RealTimeBuffer = Level.UniversalTimeSeconds;

	if( Level.NetMode == NM_ListenServer || Level.NetMode == NM_Client )
		flHudTransitionTime = (HudTransitionTime/3.0);
	else
		flHudTransitionTime = HudTransitionTime;

	RealDeltaTime = Level.UniversalTimeSeconds - RealTimeBuffer;
	RealTimeBuffer = Level.UniversalTimeSeconds;

	if( bActivatingUp )
		CurHudTransTime = FMin(CurHudTransTime + RealDeltaTime, flHudTransitionTime);
	else
		CurHudTransTime = FMax(CurHudTransTime - RealDeltaTime, 0.0);

	TransDelta = CurHudTransTime / flHudTransitionTime;

	if( (!bActivatingUp && TransDelta == 0.0) || (bActivatingUp && TransDelta == 3.0) )
		bDrawHud = false;
	else
		bDrawHud = true;

	if (nPass == 0)
	{
		Canvas.SetDrawColor( 0, 0, 0, Lerp(TransDelta,1,127) );
		Canvas.SetPos(Canvas.ClipX - (64 * Hud.ScaleX),0);

		Canvas.DrawTile(material't_interface_mb.hud.pause_grime', 64 * Hud.ScaleX, Canvas.ClipY, 0, 0, 64, 256);

		Canvas.SetPos(0,0);
		Canvas.DrawTile(material't_interface_mb.hud.pause_grime', 64 * Hud.ScaleX, Canvas.ClipY, 64, 0, -64, 256);

		Canvas.SetDrawColor(0,0,0,204);

		if( !Hud.bIsSplitScreen )
		{
			Canvas.SetPos(0, Lerp(TransDelta, Canvas.ClipY - InitArcOffset, Canvas.ClipY - 64 * Hud.ScaleY * ArcVScale) );
			Canvas.DrawTile(material't_interface_mb.hud.pause_arc', Canvas.ClipX, 64 * Hud.ScaleY * ArcVScale, 1, 1, 512, 64);

			Canvas.SetPos(0, Lerp(TransDelta, Canvas.ClipY - InitArcOffset, Canvas.ClipY - 64 * Hud.ScaleY * ArcVScale) );
			Canvas.DrawTileRotated(material't_interface_mb.hud.pause_arc', Canvas.ClipX, 64 * Hud.ScaleY * ArcVScale, 1, 1, 512, 64, Canvas.ClipX/2, Canvas.ClipY/2, Rot(0,32768,0) );
		}
		else
		{
			if (Canvas.SafeOffY > 0)
			{
				Canvas.SetPos(0, 0);
				Canvas.DrawTile(material't_interface_mb.hud.pause_arc', Canvas.ClipX, Canvas.SafeOffY, 1, 64, 512, -32);
			}

			Canvas.SetPos(0, Canvas.SafeOffY);
			Canvas.DrawTile(material't_interface_mb.hud.pause_arc', Canvas.ClipX, 64 * Hud.ScaleY * SplitScreenArcVScale, 1, 64, 512, -64);

			// GBX:PAD: This is a bit weird, but here's the deal.  In a horizontal split screen, the safe zone offset
			// of the top of the screen will be 0, thus making SafeOffY zero, but the safe zone on the bottom is figured
			// by the fact that the safesize is less than the window clip area.  This should work out nicely.
			Canvas.SetPos(0, Canvas.SafeOffY + Canvas.SafeSizeY );
			Canvas.DrawTile(material't_interface_mb.hud.pause_arc', Canvas.ClipX, Canvas.ClipY - (Canvas.SafeOffY + Canvas.SafeSizeY), 1, 33, 512, 64);
			Canvas.SetPos(0, (Canvas.SafeOffY + Canvas.SafeSizeY) - (64 * Hud.ScaleY * SplitScreenArcVScale) );
			Canvas.DrawTile(material't_interface_mb.hud.pause_arc', Canvas.ClipX, 64 * Hud.ScaleY * SplitScreenArcVScale, 1, 1, 512, 64);
		}

		// draw the selection footer icon(s)
		if ( TransDelta == 1.0 && ShouldDrawFooterIcons() )
		{
			// How far through the icons "slide" transition are we?
			IconTransitionProportion = FClamp(( Level.UniversalTimeSeconds - TargetChangeTime ) / TIME_ICON_SLIDE, 0.0, 1.0 );
			IconTransitionProportion = Sin( IconTransitionProportion * PI * 0.5 );

			IconXSpacing = (12+selectionFooterIconSize)*flScreenScaleX;

			Canvas.SetDrawColor(255, 255, 255, 255);
			Canvas.Font = Hud.WargameFont;
			Canvas.StrLen( "W", XL, YL, ORACLE_FOOTER_SCALE*flScreenScaleX, ORACLE_FOOTER_SCALE*flScreenScaleY );

			nNumIconsRight = (arrTargets.Length-1) / 2;
			nNumIconsLeft = (arrTargets.Length-1) - nNumIconsRight;

			// first, draw the current icon
			if( IconTransitionDirection != 0 )
			{
				fIconScale = SELECTION_FOOTER_ICON_SCALE_FACTOR + IconTransitionProportion * ( 1.0 - SELECTION_FOOTER_ICON_SCALE_FACTOR );
			}
			else
			{
				fIconScale = 1.0;
			}
			nCurrentIcon = iTarget;

			if( !Hud.bIsSplitScreen )
			{
				xPos = Canvas.ClipX / 2 + ( IconTransitionDirection * ( 1.0 - IconTransitionProportion ) * IconXSpacing );
				yPos = Canvas.ClipY - ( FooterOffset * Hud.ScaleY ) - YL - 0.5 * selectionFooterIconSize * flScreenScaleY;
			}
			else
			{
				xPos = Canvas.ClipX / 2 + ( IconTransitionDirection * ( 1.0 - IconTransitionProportion ) * IconXSpacing );
				yPos = Canvas.SafeOffY + Canvas.SafeSizeY - ( SplitScreenFooterOffset * Hud.ScaleY ) - YL - 0.5 * selectionFooterIconSize * flScreenScaleY;
			}

			// Draw a custom texture for gbxbeacons
			beacon = gbxBeacons( arrTargets[nCurrentIcon] );
			if (beacon != None && beacon.CustomTexture.Icon != None )
			{
				Canvas.DrawCanvasIcon(	xPos, yPos,
									flScreenScaleX*fIconScale,
									flScreenScaleY*fIconScale,
									beacon.CustomTexture);
			}
			else // Drawn normally
			{
				GetUnitFooterIconType(footerIcon, footerBack, arrTargets[nCurrentIcon]);
				Canvas.DrawCanvasIconComposite(	xPos, yPos,
								flScreenScaleX*fIconScale,
								flScreenScaleY*fIconScale,
								selectionFooterIcons[footerIcon],
								selectionFooterBacks[footerBack] );

			}
			// Draw the selection arrows

			xArPos = Canvas.ClipX / 2 - 10.5 * flScreenScaleX;
			yArPos = yPos - 3.25 * selectionFooterIconSize * flScreenScaleY - 7 * flScreenScaleY;
			xArRotPos = Canvas.ClipX / 2;
			yArRotPos = yPos;

			if( RightArrowFlashTime > Level.UniversalTimeSeconds )
			{
				Canvas.SetDrawColor( 255, 255, 255, 255 );
			}
			else
			{
				Canvas.DrawColor = Hud.WhiteColor;
				Canvas.DrawColor.A = 127;
			}

			Canvas.SetPos( xArPos, yArPos );

			Canvas.DrawTileRotated( material't_interface_mb.hud.interface_comp',
								21 * flScreenScaleX, 14 * flScreenScaleY,
								52, 208, 21, 14,
								xArRotPos, yArRotPos, Rot(0,16384,0) );

			if( LeftArrowFlashTime > Level.UniversalTimeSeconds )
			{
				Canvas.SetDrawColor( 255, 255, 255, 255 );
			}
			else
			{
				Canvas.DrawColor = Hud.WhiteColor;
				Canvas.DrawColor.A = 127;
			}

			Canvas.SetPos( xArPos, yArPos );

			Canvas.DrawTileRotated( material't_interface_mb.hud.interface_comp',
								21 * flScreenScaleX, 14 * flScreenScaleY,
								52, 208, 21, 14,
								xArRotPos, yArRotPos, Rot(0,-16384,0) );


			// draw the icons to the right
			nNumIconsToDraw = nNumIconsRight;
			nCurrentIcon = iTarget + 1;
			if (nCurrentIcon >= arrTargets.Length)
				nCurrentIcon = 0;

			// Scale down the icon that was just previously central.
			if( IconTransitionDirection < 0 )	// Was it on the right?
			{
				fIconScale = SELECTION_FOOTER_ICON_SCALE_FACTOR + ( 1.0 - IconTransitionProportion ) * ( 1.0 - SELECTION_FOOTER_ICON_SCALE_FACTOR );
			}
			else
			{
				fIconScale = SELECTION_FOOTER_ICON_SCALE_FACTOR;
			}

			while(nNumIconsToDraw > 0)
			{
				// get the new position, scale
				fIconScale *= SELECTION_FOOTER_ICON_SCALE_FACTOR;
				xPos += IconXSpacing;

				// Alpha out icons near the edge.
				IconEdgeness = 1.0 - FClamp( ( Abs( xPos - Canvas.ClipX / 2 ) - ICON_FULL_ALPHA_WINDOW * flScreenScaleX ) / ( ICON_ZERO_ALPHA_WINDOW * flScreenScaleX ), 0.0, 1.0 );

				// Draw a custom texture for gbxbeacons
				beacon = gbxBeacons( arrTargets[nCurrentIcon] );
				if (beacon != None && beacon.CustomTexture.Icon != None )
				{
					normalIconAlpha = beacon.CustomTexture.DrawColor.A;
					beacon.CustomTexture.Drawcolor.A = IconEdgeness * 255;

					Canvas.DrawCanvasIcon(	xPos, yPos,
										flScreenScaleX*fIconScale,
										flScreenScaleY*fIconScale,
										beacon.CustomTexture);

					beacon.CustomTexture.DrawColor.A = normalIconAlpha;
				}
				else // Drawn normally
				{

					GetUnitFooterIconType(footerIcon, footerBack, arrTargets[nCurrentIcon]);

					selectionFooterIcons[footerIcon].DrawColor.A = IconEdgeness * 255;
					selectionFooterBacks[footerBack].DrawColor.A = IconEdgeness * 255;

					Canvas.DrawCanvasIconComposite(	xPos, yPos,
										flScreenScaleX*fIconScale,
										flScreenScaleY*fIconScale,
										selectionFooterIcons[footerIcon],
										selectionFooterBacks[footerBack] );

					selectionFooterIcons[footerIcon].DrawColor.A = default.selectionFooterIcons[footerIcon].DrawColor.A;
					selectionFooterBacks[footerBack].DrawColor.A = default.selectionFooterBacks[footerBack].DrawColor.A;
				}

				if( nNumIconsToDraw < nNumIconsRight )
				{
					fIconScale = SELECTION_FOOTER_ICON_SCALE_FACTOR;
				}
				else
				{
					fIconScale *= SELECTION_FOOTER_ICON_SCALE_FACTOR;
				}

				nNumIconsToDraw--;
				nCurrentIcon++;
				if (nCurrentIcon >= arrTargets.Length)
					nCurrentIcon = 0;

			}

			// draw the ones to the left

			nNumIconsToDraw = nNumIconsLeft;
			nCurrentIcon = iTarget - 1;
			if (nCurrentIcon < 0)
				nCurrentIcon = arrTargets.Length - 1;

			if( !Hud.bIsSplitScreen )
			{
				xPos = Canvas.ClipX / 2 + ( IconTransitionDirection * ( 1.0 - IconTransitionProportion ) * IconXSpacing );
				yPos = Canvas.ClipY - ( FooterOffset * Hud.ScaleY ) - YL - 0.5 * selectionFooterIconSize*flScreenScaleY;
			}
			else
			{
				xPos = Canvas.ClipX / 2 + ( IconTransitionDirection * ( 1.0 - IconTransitionProportion ) * IconXSpacing );
				yPos = Canvas.SafeOffY + Canvas.SafeSizeY - ( SplitScreenFooterOffset * Hud.ScaleY ) - YL - 0.5 * selectionFooterIconSize * flScreenScaleY;
			}

			// Scale down the icon that was just previously central.
			if( IconTransitionDirection > 0 )	// Was it on the left?
			{
				fIconScale = SELECTION_FOOTER_ICON_SCALE_FACTOR + ( 1.0 - IconTransitionProportion ) * ( 1.0 - SELECTION_FOOTER_ICON_SCALE_FACTOR );
			}
			else
			{
				fIconScale = SELECTION_FOOTER_ICON_SCALE_FACTOR;
			}

			while(nNumIconsToDraw > 0)
			{
				// compute new position, scale
				xPos -= IconXSpacing;

				IconEdgeness = 1.0 - FClamp( ( Abs( xPos - Canvas.ClipX / 2 ) - ICON_FULL_ALPHA_WINDOW * flScreenScaleX ) / ( ICON_ZERO_ALPHA_WINDOW * flScreenScaleX ), 0.0, 1.0 );

				// Draw a custom texture for gbxbeacons
				beacon = gbxBeacons( arrTargets[nCurrentIcon] );
				if (beacon != None && beacon.CustomTexture.Icon != None )
				{
					normalIconAlpha = beacon.CustomTexture.DrawColor.A;
					beacon.CustomTexture.DrawColor.A = IconEdgeness * 255;

					Canvas.DrawCanvasIcon(	xPos, yPos,
										flScreenScaleX*fIconScale,
										flScreenScaleY*fIconScale,
										beacon.CustomTexture);

					beacon.CustomTexture.DrawColor.A = normalIconAlpha;
				}
				else // Drawn normally
				{
					GetUnitFooterIconType(footerIcon, footerBack, arrTargets[nCurrentIcon]);

					selectionFooterIcons[footerIcon].DrawColor.A = IconEdgeness * 255;
					selectionFooterBacks[footerBack].DrawColor.A = IconEdgeness * 255;

					Canvas.DrawCanvasIconComposite(	xPos, yPos,
										flScreenScaleX*fIconScale,
										flScreenScaleY*fIconScale,
										selectionFooterIcons[footerIcon], selectionFooterBacks[footerBack] );

					selectionFooterIcons[footerIcon].DrawColor.A = default.selectionFooterIcons[footerIcon].DrawColor.A;
					selectionFooterBacks[footerBack].DrawColor.A = default.selectionFooterBacks[footerBack].DrawColor.A;
				}

				if( nNumIconsToDraw < nNumIconsLeft )
				{
					fIconScale = SELECTION_FOOTER_ICON_SCALE_FACTOR;
				}
				else
				{
					fIconScale *= SELECTION_FOOTER_ICON_SCALE_FACTOR;
				}

				nNumIconsToDraw--;
				nCurrentIcon--;
				if (nCurrentIcon < 0)
					nCurrentIcon = arrTargets.Length - 1;
			}
		}
	}

	if (bUseInspector && !bSimplified && bWantOracleCamMode )
	{
		SelectionInspectorUpdate(Hud);
	}

	// draw the header, footer and inspector when fully shown
	if ( TransDelta == 1.0 && !bSimplified )
	{
		if (nPass == 1)
		{
			Canvas.Style = ERenderStyle.STY_Alpha;
			Canvas.DrawColor = Hud.WhiteColor;

			if (!bIsTrainingTextDisplayed)
			{
				if( !Hud.bIsSplitScreen || ( Hud.bIsSplitScreen && Canvas.SafeOffY > 0.0 ) )
				{
					// Draw the level title
					Canvas.Font = Hud.WargameFont2;
					Canvas.StrLen( GetHeaderText(), XL, YL, ORACLE_HEADER_SCALE*flScreenScaleX, ORACLE_HEADER_SCALE*flScreenScaleY );
					Canvas.SetPos( Canvas.SafeOffX + ((Canvas.SafeSizeX - XL) / 2), max( Canvas.SafeOffY, 40 * Hud.ScaleY ) );
					Canvas.DrawText( GetHeaderText(), false, flScreenScaleX * ORACLE_HEADER_SCALE, flScreenScaleY * ORACLE_HEADER_SCALE );
				}
			}

			// draw the selection footer
			Canvas.Font = Hud.WargameFont;
			Canvas.StrLen( GetFooterText(), XL, YL, ORACLE_FOOTER_SCALE * flScreenScaleX, ORACLE_FOOTER_SCALE * flScreenScaleY );

			if( !Hud.bIsSplitScreen )
			{
				Canvas.SetPos( ((Canvas.ClipX - XL) / 2), Canvas.ClipY - ( FooterOffset * Hud.ScaleY ) - YL );
				Canvas.DrawText( GetFooterText(), false, flScreenScaleX * ORACLE_FOOTER_SCALE, flScreenScaleY * ORACLE_FOOTER_SCALE );
			}
			else
			{
				Canvas.SetPos( ((Canvas.ClipX - XL) / 2), Canvas.SafeOffY + Canvas.SafeSizeY - ( SplitScreenFooterOffset * Hud.ScaleY ) - YL );
				Canvas.DrawText( GetFooterText(), false, flScreenScaleX * ORACLE_FOOTER_SCALE, flScreenScaleY * ORACLE_FOOTER_SCALE );
			}
		}
	}
}

simulated function string GetHeaderText()
{
	return Level.Title;
}

simulated function string GetFooterText()
{
	return SelectionFooterText;
}

simulated function float GetOrbitalRadius()
{
	local vector CamTargetLocation2D, MyLocation2D, ZOffset2D;

	CamTargetLocation2D = GetCamTargetLocation() * vect(1,1,0);
	MyLocation2D = MyGbxPawn.Location * vect(1,1,0);
	ZOffset2D = ( GetZenithOffsetCentered() >> GetCoarseTargetRotation() ) * vect(1,1,0);

	return VSize( CamTargetLocation2D - MyLocation2D - ZOffset2D );
}

simulated function rotator GetCoarseTargetRotation()
{
	local vector targetDelta;

	targetDelta = GetCamTargetLocation() - MyGbxPawn.Location;
	targetDelta.Z = 0;

	if( VSizeSquared( targetDelta ) < 0.0001 )
	{
		return MyGbxPawn.Rotation;
	}

	return rotator( targetDelta );
}

simulated function vector GetZenithOffsetCentered()
{
	return ZenithOffsetCentered;
}

simulated function vector GetDesiredZenithOffset()
{
	return ( GetZenithOffsetCentered() + ZenithFloatOffset ) >> GetCoarseTargetRotation();
}

simulated function vector GetZenithOffset( float DeltaTime )
{
	local vector Offset;
	Offset = CurrentZenithOffset + ( GetDesiredZenithOffset() - CurrentZenithOffset ) * ZenithOffsetLerp * DeltaTime * FClamp( (Level.UniversalTimeSeconds - CycleTargetStartTime) / CycleTargetFloatTime, 0.0, 1.0 );
	return Offset;
}

simulated function bool IsPlayerLookingAtHisPawn()
{
	local bool rslt;

	if( MyPlayerController == None || MyPlayerController.ViewTarget != MyGbxPawn )		// TODO not sure how this applies for oracle cam
	{
		rslt = false;
	}
	else
	{
		rslt = true;
	}

	return rslt;
}

simulated function bool SpecialCalcView( out actor ViewActor, out vector CameraLocation, out rotator CameraRotation )
{
	local float	DeltaTime;

	if( Level.UniversalTimeSeconds - LastTimeSecs < 0.00001 )
		return true;

	// skip if the player is not looking at us
	if( !IsPlayerLookingAtHisPawn() )		// TODO not sure how this applies for oracle cam
	{
		return false;
	}

	ViewActor = MyPlayerController;
	DeltaTime = Level.UniversalTimeSeconds - LastCalcViewTime;
	LastCalcViewTime = Level.UniversalTimeSeconds;

	if( bWantOracleCamMode )
	{
		if( bActivating )
		{
			UpdateViewActivating( DeltaTime, CameraLocation, CameraRotation );
		}
		else
		{
			UpdateViewZenith( DeltaTime, CameraLocation, CameraRotation );
		}

		LastTimeSecs = Level.UniversalTimeSeconds;

		return true;
	}
	else
	{
		if( bActivating )
		{
			UpdateViewDeactivating( DeltaTime,CameraLocation, CameraRotation );
			LastTimeSecs = Level.UniversalTimeSeconds;
			return true;
		}
		else
		{
			return false;
		}
	}
}

simulated function UpdateViewActivating( float DeltaTime, out vector CameraLocation, out rotator CameraRotation )
{
	local vector CamStartLocation, ZenithOffset;
	local float	TimePct, TimeCurved;
	local float timeActivateSeconds;

	CamStartLocation = MyGbxPawn.Location + MyGbxPawn.EyePosition();
	timeActivateSeconds = TIME_ACTIVATE_SECONDS;

	// Camera zooming up
	if ( ( Level.NetMode == NM_ListenServer || Level.NetMode == NM_Client ) && !bSimplified )
		timeActivateSeconds = (TIME_ACTIVATE_SECONDS/3.0);

	TimePct = FClamp( (Level.UniversalTimeSeconds - ActivateStartTime) / timeActivateSeconds, 0, 1 );

	TimeCurved = sin( TimePct * PI * 0.5 );

	// Slow the game down while activating.
/*	if ( Level.NetMode != NM_LISTENSERVER && Level.NetMode != NM_CLIENT )
	{
		Level.TimeDilation = Lerp( TimeCurved, 1.0, 0.0 );
	}
*/

	ZenithOffset = GetZenithOffset( DeltaTime );

	CameraLocation.X = Lerp( TimeCurved, CamStartLocation.X, CamStartLocation.X + ZenithOffset.X );
	CameraLocation.Y = Lerp( TimeCurved, CamStartLocation.Y, CamStartLocation.Y + ZenithOffset.Y );
	CameraLocation.Z = Lerp( TimeCurved, CamStartLocation.Z, CamStartLocation.Z + ZenithOffset.Z );

	// We need a little time after the start of activation before we play the start sound, or it gets paused.

	if (!bSimplified && !bSitViewStartSoundStarted && !IsInFieldPromotion())
	{
		if( ActivateStartTime + 0.1 < Level.UniversalTimeSeconds)
		{
			PlaySoundCue( SitViewStart, SLOT_None,,true );
			bSitViewStartSoundStarted = true;
		}
	}


	// Are we done activating?
	if( ActivateStartTime + timeActivateSeconds < Level.UniversalTimeSeconds)
	{
		bActivating = false;

/*		if (MyPlayerController != None)
		{
			MyPlayerController.SetOraclePause( true );
		}
*/
		// Play the loop sound.
		if (!bSimplified && !IsInFieldPromotion())
		{
			iLoopHandle = PlaySoundCue( SitViewLoop, SLOT_Misc,,true );
		}
	}

	if( GetCamTargetLocation() != MyGbxPawn.Location )
	{
		CameraRotation = RotSlerp( rotator( GetCamTargetLocation() - CameraLocation ), MyPlayerController.GetViewRotation(), TimeCurved );
	}
	else
	{
		CameraRotation = rotator( ( MyGbxPawn.Location + ( MyGbxPawn.EyePosition() * ( 1.0 - TimeCurved ) ) + Vector( MyPlayerController.GetViewRotation() ) * (CamStartLocation.Z + ZenithOffset.Z - CameraLocation.Z) * ( 1.0 - TimeCurved ) ) - CameraLocation );
	}

	LastCameraRotation = CameraRotation;

	MyPlayerController.SetRotation(CameraRotation);

	UpdateCameraEffects( DeltaTime );
}

function int GetRotDiff(int A, int B)
{
	local int comp;

	comp = (A - B) & 65535;
	if (comp > 32768)
		comp -= 65536;

	return comp;
}

simulated function UpdateViewZenith( float DeltaTime, out vector CameraLocation, out rotator CameraRotation )
{
	local vector CamStartLocation,CamTarget, ZenithOffset, HitLocation, HitNormal, PlaneNormal, P1, P2, PlaneOrigin;
	local Actor TargetActor, HitActor;
	local float Slerpy, CalcFov, CosAngle, DistToGround;
	local Quat PreQuat, PostQuat, FinalQuat;
	local int m;
	local Unit tUnit;
	local rotator TargetRotation, ControllerRot;
	local int PitchDiff, YawDiff;
	local float MoveDist;
	local float DotProduct;

	// Camera at the zenith.

	if (MyGbxPawn.bIsCrouched)
		CamStartLocation = MyGbxPawn.Location - (vect(0,0,1) * MyGbxPawn.CrouchHeight) + (vect(0,0,1) * MyGbxPawn.default.CollisionHeight);
	else
		CamStartLocation = MyGbxPawn.Location;

	TargetActor = GetCamTargetActor();

	if( TargetActor == None )
	{
		CycleNextTarget();
	}

	CamTarget = GetCamTargetLocation();

	ZenithOffset = GetZenithOffset( DeltaTime );

	CameraLocation.X = CamStartLocation.X + ZenithOffset.X;
	CameraLocation.Y = CamStartLocation.Y + ZenithOffset.Y;
	CameraLocation.Z = CamStartLocation.Z + ZenithOffset.Z;

	// Keep the camera a minimum distance off of the ground

	HitActor = Trace( HitLocation, HitNormal, CameraLocation - vect(0,0,1) * 10000.0, CameraLocation, false );

	if( HitActor != None )
	{
		if ( HitActor.IsA( 'TerrainInfo' ) )
		{
			DistToGround = VSize( CameraLocation - HitLocation );

			if( DistToGround < CameraGroundClearance )
			{
				GroundClearanceBuffer += CameraGroundClearance - DistToGround;
				ZenithFloatOffset.Z += CameraGroundClearance - DistToGround;
			}
			else if( GroundClearanceBuffer > 0 )
			{
				ZenithFloatOffset.Z -= FMin( DistToGround - CameraGroundClearance, GroundClearanceBuffer );
				GroundClearanceBuffer -= FMin( DistToGround - CameraGroundClearance, GroundClearanceBuffer );
			}
		}

		bIsInLevel = true;
	}
	else
	{
		// We hit nothing, therefore we have already fallen through the level somehow.  Let's find the floor again
		HitActor = Trace( HitLocation, HitNormal, CameraLocation, CameraLocation + vect(0,0,1) * 10000.0, false );

		if( HitLocation != vect(0,0,0) )
		{
			ZenithFloatOffset.Z = FClamp( HitLocation.Z - GetZenithOffsetCentered().Z + CameraGroundClearance, MaxFloatDistanceZ, -MaxFloatDistanceZ );
		}
		else
		{
			// As a last resort, reset the float offset
			// ZenithFloatOffset.Z = 0.0;
		}

		bIsInLevel = false;
	}

	if( TargetActor != LastTargetActor )
	{
		// Find the point in space where the camera was last looking.  If not on a target specifically, assume a point somewhere
		// on the flat plane where the last target was located.
		// the line between the two.

		// Define two points that make a line from the curent camera location to some far off point in space in the direction of the camera rotation
		P1 = CameraLocation;
		P2 = CameraLocation + Vector( LastCameraRotation ) * 1000000.0;

		PlaneNormal = vect( 0, 0, 1 );
		PlaneOrigin = LastTargetActor.Location;

		LastTargetLocation = P1 + ( P2 - P1 ) * (((PlaneOrigin - P1) dot PlaneNormal) / ((P2 - P1) dot PlaneNormal));

		LastTargetActor = TargetActor;
	}

	if( bIsTransitioning )
	{
		Slerpy = SmoothTime( FClamp( ( Level.UniversalTimeSeconds - CycleTargetStartTime ) / CycleTargetTime, 0.0, 1.0 ) );

		PreQuat = QuatFromRotator( Rotator(LastTargetLocation - CameraLocation) );
		FinalQuat = QuatFromRotator( Rotator(CamTarget - CameraLocation) );
		PostQuat = QuatSlerp( PreQuat, FinalQuat, Sqrt( Slerpy ) );

		CameraRotation = QuatToRotator( PostQuat );

		MyPlayerController.SetRotation( CameraRotation );

		if( Slerpy >= 1.0 )
		{
			bIsTransitioning = false;

			CameraRotSlerpScale = 0.0f;
		}
	}
	else
	{
		TargetRotation = Rotator(CamTarget - CameraLocation);
		ControllerRot = MyPlayerController.Rotation;

		MoveDist = VSize(CurrentZenithOffset - PreviousZenithOffset);  // how much has the camera moved in the last frame?

		// is there any key/button input to rotate camera around target or is camera still in motion?
		if ((abs(LastaStrafe) > 0.0f) || (abs(LastaForward) > 0.0f) || (MoveDist > 1.0f))
		{
			if (bFirstPassRotating)
			{
				bFirstPassRotating = false;

				PitchDiff = GetRotDiff(ControllerRot.Pitch, TargetRotation.Pitch);
				YawDiff = GetRotDiff(ControllerRot.Yaw, TargetRotation.Yaw);

				// if already looking at target, keep PlayerController rotation nailed to target
				if ((abs(PitchDiff) < 1000) && (abs(YawDiff) < 1000))
					CameraRotSlerpScale = 0.5f;
			}

			CameraRotSlerpScale = FClamp( CameraRotSlerpScale + (CamSnapAccelRate * DeltaTime), 0.0f, 1.0f );

			PreQuat = QuatFromRotator( ControllerRot );
			FinalQuat = QuatFromRotator( TargetRotation );
			PostQuat = QuatSlerp( PreQuat, FinalQuat, CameraRotSlerpScale );

			ControllerRot = QuatToRotator( PostQuat );
		}
		else
		{
			// Restrict Pitch
			PitchDiff = GetRotDiff(ControllerRot.Pitch, TargetRotation.Pitch);
			if (PitchDiff > VertFieldUU)
				ControllerRot.Pitch = (TargetRotation.Pitch + VertFieldUU) & 65535;
			else if (PitchDiff < -VertFieldUU)
				ControllerRot.Pitch = (TargetRotation.Pitch - VertFieldUU) & 65535;

			// Restrict Yaw
			YawDiff = GetRotDiff(ControllerRot.Yaw, TargetRotation.Yaw);
			if (YawDiff > HorizFieldUU)
				ControllerRot.Yaw = (TargetRotation.Yaw + HorizFieldUU) & 65535;
			else if (YawDiff < -HorizFieldUU)
				ControllerRot.Yaw = (TargetRotation.Yaw - HorizFieldUU) & 65535;

			CameraRotSlerpScale = 0.0f;

			bFirstPassRotating = true;
		}

		CameraRotation = ControllerRot;

		MyPlayerController.SetRotation( CameraRotation );
	}

	LastCameraRotation = CameraRotation;
	PreviousZenithOffset = CurrentZenithOffset;

	// check dot product between CameraRotation and Target direction...
	DotProduct = Normal(CamTarget - CameraLocation) dot Vector( CameraRotation );

	if ((!bZoom && (DotProduct > 0.992)) || (bZoom && (DotProduct > 0.995)))
	{
		// Check for camera obstruction
		if( Level.UniversalTimeseconds >= NextOcclusionTestTime )
		{
			HitActor = Trace( HitLocation, HitNormal, CameraLocation, CamTarget, true, TargetOcclusionExtent );

			if( HitActor != None )
			{
				bIsOccluded = true;
			}
			else
			{
				bIsOccluded = false;
			}

			NextOcclusionTestTime = Level.UniversalTimeSeconds + OcclusionTestInterval;
		}

		if( bIsOccluded )
		{
			MyPlayerController.UpdateSituationalAwarenessCamOverlayAlpha( DeltaTime, true );
		}
		else
		{
			MyPlayerController.UpdateSituationalAwarenessCamOverlayAlpha( DeltaTime, false );
		}
	}
	else
	{
		MyPlayerController.UpdateSituationalAwarenessCamOverlayAlpha( DeltaTime, false );  // no overlay if not looking directly at target
	}

	// FOV changes.
	if( bZoom )
	{
		CalcFov = 0.0;

		if( TargetActor.IsA('Unit') )
		{
			tUnit = Unit( TargetActor );

			for( m = 0; m < tUnit.MAX_MEMBERS; m++ )
			{
				if( tUnit.Members[ m ] == None )
					continue;

				CosAngle = Normal( tUnit.Members[ m ].Location - CameraLocation ) dot Vector( CameraRotation );

				if( CosAngle <= 1.0 )
				{
					CalcFov = FMax( CalcFov, ACos( CosAngle ) * ( 180 / Pi ) * 2.0 + FOVUnitFudge );
				}
			}
		}
		else
		{
			CosAngle = Normal( TargetActor.Location - CameraLocation ) dot Vector( CameraRotation );

			if( CosAngle <= 1.0 )
			{
				CalcFov = FMax( CalcFov, ACos( CosAngle ) * ( 180 / Pi ) * 2.0 );
			}
		}

		GoalFov = FClamp( CalcFov, FOVCloseUp, FOVLessThanNormal );
	}
	else
	{
		GoalFOV = FOVNormal;
	}
}

simulated function float SmoothTime( float t )
{
	local float curveStart, curveEnd, curveRange, traveledBit, doubleT, variableT;

	curveStart = 3 * Pi / 2;
	curveEnd = Pi / 2;
	curveRange = curveEnd - curveStart;
	traveledBit = ( t * curveRange ) + curveStart;
	doubleT = Sin( traveledBit );
	variableT = ( doubleT + 1.0 ) * 0.5;

	return variableT;
}

simulated function UpdateViewDeactivating( float DeltaTime, out vector CameraLocation, out rotator CameraRotation )
{
	// Camera zooming down.
	local vector CamStartLocation, ZenithOffset;
	local float TimePct, TimeCurved;
	local float timeActivateSeconds;

	CamStartLocation = MyGbxPawn.Location + MyGbxPawn.EyePosition();

	timeActivateSeconds = TIME_ACTIVATE_SECONDS;
	if ( ( Level.NetMode == NM_ListenServer || Level.NetMode == NM_Client ) && !bSimplified )
		timeActivateSeconds = (TIME_ACTIVATE_SECONDS/3.0);

	TimePct = FClamp( (timeActivateSeconds - (Level.UniversalTimeSeconds - ActivateStartTime)) / timeActivateSeconds, 0, 1 );
	TimeCurved = sin( TimePct * PI * 0.5 );

	// Speed the game up while activating in.
/*	if ( Level.NetMode != NM_LISTENSERVER && Level.NetMode != NM_CLIENT )
	{
		Level.TimeDilation = Lerp( TimeCurved, 1.0, 0.0 );
	}
*/

	ZenithOffset = GetZenithOffset( DeltaTime );

	CameraLocation.X = Lerp( TimeCurved, CamStartLocation.X, CamStartLocation.X + ZenithOffset.X );
	CameraLocation.Y = Lerp( TimeCurved, CamStartLocation.Y, CamStartLocation.Y + ZenithOffset.Y );
	CameraLocation.Z = Lerp( TimeCurved, CamStartLocation.Z, CamStartLocation.Z + ZenithOffset.Z );

	// Rotate camera to face the target location on the way down,
	// OR if the target location is right below us, lift our view up to point straight by the time we hit the bottom

	if( GetCamTargetLocation() != MyGbxPawn.Location )
	{
		CameraRotation = RotSlerp( rotator( GetCamTargetLocation() - CameraLocation ), MyPlayerController.GetViewRotation(), TimeCurved );
	}
	else
	{
		CameraRotation = rotator( ( MyGbxPawn.Location + ( MyGbxPawn.EyePosition() * ( 1.0 - TimeCurved ) ) + Vector( MyPlayerController.GetViewRotation() ) * (CamStartLocation.Z + ZenithOffset.Z - CameraLocation.Z) * ( 1.0 - TimeCurved ) ) - CameraLocation );
	}

	// Check for end of deactivation time.
	if (ActivateStartTime + timeActivateSeconds < Level.UniversalTimeSeconds)
	{
		// Finished deactivating.

		bActivating = false;

		OnDeactivateFinished();
	}

	UpdateCameraEffects( DeltaTime );
}

simulated event Tick( float DeltaTime )
{
	local float TargetDist;
	local float r, t, x, y, z;
	local vector PawnLocation;

	if( !IsActive() )
	{
		return;
	}

	if (MyGbxPawn.bIsCrouched)
		PawnLocation = MyGbxPawn.Location - (vect(0,0,1) * MyGbxPawn.CrouchHeight) + (vect(0,0,1) * MyGbxPawn.default.CollisionHeight);
	else
		PawnLocation = MyGbxPawn.Location;

	TargetDist = VSize( GetCamTargetLocation() - ( PawnLocation + GetZenithOffsetCentered() ));

	if( !bActivating )
	{
		z = ZenithFloatOffset.Z;

		if (!bIsInLobby && !bIsInDebriefing)  // don't allow movement or camera rotation while in Lobby or Debriefing
			ProcessInput( DeltaTime, t, z );

		// Only update the Z offset if the ground clearance is ok, or if the user wants to increase their height
		if( z - ZenithFloatOffset.Z > 0.0 )
		{
			GroundClearanceBuffer = 0.0;
		}

		if( GroundClearanceBuffer < 0.00001 )
		{
			ZenithFloatOffset.Z = z;
		}

		/* Orbit around the camera target */

		// Clamp theta
		t = FClamp( t, -MaxOrbitTheta, MaxOrbitTheta );


		// Wrap theta
		if( t >= Pi )
		{
			t = -Pi;
		}
		else if( t <= -Pi )
		{
			t = Pi;
		}

		// Calculate orbit
		r = GetOrbitalRadius();

		if( r > 0.0 )
		{
			CalculateOrbit( r, t, x, y );

			ZenithFloatOffset.X = x;
			ZenithFloatOffset.Y = y;
			ThetaBuffer = t;
		}
	}
	else
	{
		ZenithFloatOffset = vect(0,0,0);
	}

	CurrentZenithOffset = GetZenithOffset( DeltaTime );

	CurrentFOV = Lerp( FOVLerp * DeltaTime, CurrentFOV, GoalFOV );
	MyPlayerController.DesiredFOV = CurrentFOV;
	MyPlayerController.FOVAngle = MyPlayerController.DesiredFOV;

	// PSV: 5/28/2004 In MP, we need to constantly refresh our friendly target list.
	if ( Level.NetMode == NM_LISTENSERVER || Level.NetMode == NM_CLIENT )
	{
		UpdateTargetActorList();
	}
}

simulated function CalculateOrbit( float radius, float theta, out float x, out float y )
{
	if( radius > 0.0 )
	{
		x = radius - radius * Cos( theta );
		y = radius * Sin( theta );
	}
}

simulated function float CalculateTheta( float radius, float x, float y )
{
	local float theta;

	if( radius > 0.0 )
	{
		if ( x <= radius )
		{
			theta = ASin( y / radius );
		}
		else
		{
			theta = ACos( (radius - x)/radius );

			if( y < 0.0 && x > radius )
			{
				theta *= -1;
			}
		}
	}

	return theta;
}

simulated function UpdatePlayerControllerRotation(float DeltaTime)
{
	local rotator ViewRotation;

	ViewRotation = MyPlayerController.Rotation;
	MyPlayerController.DesiredRotation = ViewRotation; //save old rotation

	MyPlayerController.TurnTarget = None;
	MyPlayerController.bRotateToDesired = false;
	MyPlayerController.bSetTurnRot = false;

	ViewRotation.Yaw += DeltaTime * MyPlayerController.aTurn;
	ViewRotation.Pitch += DeltaTime * MyPlayerController.aLookUp;

	ViewRotation.Pitch = ViewRotation.Pitch & 65535;
	ViewRotation.Yaw = ViewRotation.Yaw & 65535;

	MyPlayerController.SetRotation(ViewRotation);
}

simulated function ProcessInput( float DeltaTime, out float Theta, out float VerticalFloat )
{
	local float PCYawInputVal, PCVertInputVal;

	if( abs(aStrafe) > 0.00001f )
	{
		PCYawInputVal = aStrafe / abs( aStrafe );
	}

	if( abs(aForward) > 0.00001f )
	{
		PCVertInputVal = aForward / abs( aForward );
	}

	// Theta

	if( abs( PCYawInputVal ) > 0.000001 )
	{
		if( ( PCYawInputVal > 0 && ThetaAccel < 0 ) || ( PCYawInputVal < 0 && ThetaAccel > 0 ) )
		{
			ThetaAccel = 0;
		}

		ThetaAccel = FClamp( ThetaAccel + PCYawInputVal * ThetaAccelRate * DeltaTime, -MaxThetaRate, MaxThetaRate );
	}
	else
	{
		if( ThetaAccel > 0 )
		{
			ThetaAccel = FMax( 0.0, ThetaAccel - ThetaAccelRate * 3.0 * DeltaTime );
		}
		else if( ThetaAccel < 0 )
		{
			ThetaAccel = Fmin( 0.0, ThetaAccel + ThetaAccelRate * DeltaTime );
		}
	}

	Theta = ThetaBuffer + ThetaAccel * DeltaTime;

	// Vertical float

	if( abs( PCVertInputVal ) > 0.000001 )
	{
		if( ( PCVertInputVal > 0 && FloatAccel < 0 ) || ( PCVertInputVal < 0 && FloatAccel > 0 ) )
		{
			FloatAccel = 0;
		}

		FloatAccel = FClamp( FloatAccel + PCVertInputVal * FloatAccelRate * DeltaTime, -MaxFloatRate, MaxFloatRate );
	}
	else
	{
		if( FloatAccel > 0 )
		{
			FloatAccel = FMax( 0.0, FloatAccel - FloatAccelRate * 3.0 * DeltaTime );
		}
		else if( FloatAccel < 0 )
		{
			FloatAccel = Fmin( 0.0, FloatAccel + FloatAccelRate * DeltaTime );
		}
	}

	VerticalFloat = FClamp( VerticalFloat + FloatAccel * DeltaTime, MaxFloatDistanceZ, -MaxFloatDistanceZ );

	// update the PlayerController so that it will rotate based on input controls (mouse/joystick)
	UpdatePlayerControllerRotation(DeltaTime);

	LastaStrafe = aStrafe;
	LastaForward = aForward;
}


simulated function StickButtonLeft()
{
	CyclePrevTarget();
}

simulated function StickButtonRight()
{
	CycleNextTarget();
}

simulated function StickButtonForward()
{
	SelectObjective();
}

simulated function StickButtonBack()
{
	SelectSelf();
}

simulated function PlayClickSound()
{
	if( bActivating )
		return;

	if( ClickCue == None )
	{
		ClickCue = LoadSound( "UI.CLICK" );
	}

	if( ClickCue != None )
	{
		PlaySoundCue( ClickCue, SLOT_Interface );
	}
}

simulated function OnDeactivateFinished()
{
	if( MyPlayerController != None)
	{
		MyPlayerController.SetOraclePause( false );
		MyPlayerController.DesiredFOV = PreOracleFOV;
		MyPlayerController.EndCamDesaturation();

		if (!MyPlayerController.IsDead() && !MyGbxPawn.bIsManningTurret)
		{
			MyPlayerController.bBehindView = false;
		}

		// if we are going back into the body of the same pawn we came out of when SA was activated, restore original controller rotation...
		if (SavedGbxPawn == MyGbxPawn)
			MyPlayerController.SetRotation(SavedPlayerRotation);
		else  // otherwise, we must have promoted to a new body in multiplayer, so set the controller's rotation to the new pawn's rotation...
			MyPlayerController.SetRotation(GetCamTargetActor().Rotation);
	}

	UpdateTargetsOpacity( 1.0 );		// Force all icons to have their normal opacity.

	// Trigger an event for LD's to hook into
	TriggerEvent( 'OracleEnd', MyGbxPawn, MyGbxPawn );
}


state FieldPromotion
{
	function BeginState()
	{
		log(self $ " OracleCamera::BeginState() FieldPromotion", 'MP');
		MyGbxPawn = None;
	}

	function EndState()
	{
		log(self $ " OracleCamera::EndState() FieldPromotion", 'MP');
		MyGbxPawn = None;
	}

	simulated function bool IsInFieldPromotion()
	{
		return true;
	}

	function SetOwnerPlayerController( gbxPlayerController PC )
	{
		local gbxPawn PreviousGbxPawn;

		PreviousGbxPawn = MyGbxPawn;
		MyPlayerController = PC;

		if( MyPlayerController == None )
		{
			Warn( self $ ".SetOwnerPlayerController() assigned None gbxPlayerController" );
		}
		else
		{
			MyGbxPawn = gbxPawn( MyPlayerController.Pawn );
			if( MyGbxPawn == None )
			{
				MyGbxPawn = gbxPawn( MyPlayerController.ViewTarget );
				if (MyGbxPawn == None)
				{
					MyGbxPawn = PreviousGbxPawn;
				}
			}

			if (MyGbxPawn != PreviousGbxPawn)
			{
				log(self $ " OracleCamera::SetOwnerPlayerController() FieldPromotion: MyGbxPawn changed from = " $ PreviousGbxPawn $ ", to = " $ MyGbxPawn, 'MP');
				OnTargetChanged();
			}

			if( MyGbxPawn == None )
			{
				Warn( self $ ".SetOwnerPlayerController( " $ MyPlayerController $ " ) found None gbxPawn." );
			}
			else
			{
				MyUnit = MyGbxPawn.MyUnit;

				if( MyUnit == None )
				{
					Warn( self $ ".SetOwnerPlayerController( " $ MyPlayerController $ " ) found None Unit." );
				}
			}
		}
	}

	function BuildTargetActorList()
	{
		iTarget = 0;
		CleanseTargetActorList();

		SetTeamShadows(true);
	}

	function UpdateTargetActorList()
	{
	}

	simulated function Actor GetCamTargetActor()
	{
		return MyGbxPawn;
	}

	simulated function OnTargetChanged( optional float direction )
	{
		PlayClickSound();

		// Immediately hide the previous inspector if it's still visible
		if (selectionInspector != None && selectionInspector.IsVisible())
		{
			selectionInspector.Hide();
		}
	}

	function bool IsPlayerLookingAtHisPawn()
	{
		return true;
	}

	function bool ShouldDrawFooterIcons()
	{
		return false;
	}

	function string GetHeaderText()
	{
		return FieldPromotionHeader;
	}

	function string GetFooterText()
	{
		return FieldPromotionFooter;
	}

	function CycleNextTarget()
	{
		log(self $ " OracleCamera::CycleNextTarget() FieldPromotion: MyGbxPawn = " $ MyGbxPawn $ ", TargetActor = " $ GetCamTargetActor(), 'MP');

		if( bWantOracleCamMode && !bActivating )
		{
			ServerViewNextPlayer();
		}
	}

	function CyclePrevTarget()
	{
		if( bWantOracleCamMode && !bActivating )
		{
			ServerViewPreviousPlayer();
		}
	}

	function DeactivateTeamShadows()
	{
		SetTeamShadows(false);
	}

	function SetTeamShadows(bool shadowState)
	{
		local int j;
		local ETeamIdentifier myTeam;
		local MultiplayerUnit mpUnit;

		myTeam = MyGbxPawn.PawnTeam;

		// Add friendly soldiers
		ForEach DynamicActors(class'MultiplayerUnit', mpUnit)
		{
			if ( mpUnit.AnyLivingMembers() )
			{
				if (mpUnit.SameTeamAsUnit(MyUnit))
				{
					for( j = 0; j<mpUnit.NumMembers; j++ )
					{
						if (shadowState == true)
						{
							mpUnit.Members[j].EnteringTacticalView();
						}
						else
						{
							mpUnit.Members[j].LeavingTacticalView();
						}
					}
				}
			}
		}
	}

	simulated function UpdateViewDeactivating( float DeltaTime, out vector CameraLocation, out rotator CameraRotation )
	{
		MyPlayerController.bBehindView = true;

		Global.UpdateViewDeactivating( DeltaTime, CameraLocation, CameraRotation );
	}

	simulated function OnDeactivateFinished()
	{
		Global.OnDeactivateFinished();

		bActivating = false;
		GotoState('');
	}
}

// Return true if AngleA is to the 'Right' of AngleB
function bool AngleSubtract( int AngleA, int AngleB, out int AngleDiff )
{
	local bool bDidSubtract;
	local bool bIsNegative;

	AngleDiff = AngleA - AngleB;

	bIsNegative = ( AngleDiff < 0 );

	AngleDiff = Abs( AngleDiff );

	if ( AngleDiff > 32768 )
	{
		AngleDiff = 65536 - AngleDiff;
		bDidSubtract = true;
	}

	if ( ( bDidSubtract && bIsNegative ) || ( !bDidSubtract && !bIsNegative ) )
	{
		return true;
	}

	return false;
}

function rotator RotSlerp( Rotator rotA, Rotator rotB, float slerp )
{
	local int angleDiff;
	local rotator outRot;

	rotA.pitch = rotA.pitch & 65535;
	rotB.pitch = rotB.pitch & 65535;
	rotA.yaw = rotA.yaw & 65535;
	rotB.yaw = rotB.yaw & 65535;

	if( AngleSubtract( rotA.pitch, rotB.pitch, angleDiff ) )
	{
		outRot.pitch = rotB.pitch + angleDiff * slerp;
	}
	else
	{
		outRot.pitch = rotB.pitch - angleDiff * slerp;
	}

	if( AngleSubtract( rotA.yaw, rotB.yaw, angleDiff ) )
	{
		outRot.yaw = rotB.yaw + angleDiff * slerp;
	}
	else
	{
		outRot.yaw = rotB.yaw - angleDiff * slerp;
	}

	return outRot;
}

defaultproperties
{
	ZenithOffsetCentered=(X=-2000,Y=0,Z=2250.0)
	ZenithOffsetLerp=5.0
	FOVLerp=8.0
	MaxFOVTargetDist=4000
	TargetOcclusionExtent=(X=50,Y=50,Z=50)

	MaxOrbitRadius=6000
	MaxFloatDistanceZ=-2000

	HudTransitionTime=1.5
	InitArcOffset=48.0
	SplitScreenArcVScale=1.5
	ArcVScale=1.5

	FOVCloseUp=10
	FOVNormal=40
	FOVLessThanNormal=30
	FOVUnitFudge=2.0

	UnitLabelX=230
	UnitLabelY=390
	UnitLabelScaleX=.8
	UnitLabelScaleY=.8

	selectionFooterIcons[0]=(Icon=Texture't_interface_mb.hud.interface_comp',U=132,V=93,UL=40,VL=36,DrawColor=(R=0,G=0,B=0,A=255),ScaleX=0.7,ScaleY=0.7,PivotU=0.5,PivotV=0.5)	// SIT_UNIT_MOVE (icon_team_move)
	selectionFooterIcons[1]=(Icon=Texture't_interface_mb.hud.interface_comp',U=214,V=105,UL=40,VL=24,DrawColor=(R=0,G=0,B=0,A=255),ScaleX=0.6,ScaleY=0.6,PivotU=0.5,PivotV=0.5)	// SIT_UNIT_FIRE (icon_team_fire)
	selectionFooterIcons[2]=(Icon=Texture't_interface_mb.hud.interface_comp',U=176,V=106,UL=40,VL=23,DrawColor=(R=0,G=0,B=0,A=255),ScaleX=0.7,ScaleY=0.7,PivotU=0.5,PivotV=0.5)	// SIT_UNIT_TANK (icon_team_tank)
	selectionFooterIcons[3]=(Icon=Texture't_interface_mb.hud.interface_comp',U=276,V=99,UL=29,VL=29,DrawColor=(R=255,G=255,B=255,A=255),ScaleX=0.8,ScaleY=0.8,PivotU=0.5,PivotV=0.5)	// SIT_UNIT_US_SOLDIER (icon_us_star)
	selectionFooterIcons[4]=(Icon=Texture't_interface_mb.hud.interface_comp',U=305,V=99,UL=29,VL=29,DrawColor=(R=0,G=0,B=0,A=255),ScaleX=0.8,ScaleY=0.8,PivotU=0.5,PivotV=0.5)	// SIT_UNIT_GERMAN_SOLDIER (icon_de_cross)
	selectionFooterIcons[5]=(Icon=Texture't_interface_mb.hud.interface_comp',U=94,V=100,UL=40,VL=29,DrawColor=(R=0,G=0,B=0,A=255),ScaleX=0.8,ScaleY=0.8,PivotU=0.5,PivotV=0.5)	// SIT_BEACON (icon_obj_primary)

	selectionFooterBacks[0]=(Icon=Texture't_interface_mb.hud.interface_comp',U=192,V=131,UL=46,VL=46,DrawColor=(R=88,G=108,B=47,A=255),ScaleX=0.8,ScaleY=0.8,PivotU=0.5,PivotV=0.5)	// SIT_BACK_US (bg_unit)
	selectionFooterBacks[1]=(Icon=Texture't_interface_mb.hud.interface_comp',U=192,V=131,UL=46,VL=46,DrawColor=(R=181,G=56,B=41,A=255),ScaleX=0.8,ScaleY=0.8,PivotU=0.5,PivotV=0.5)	// SIT_BACK_DE (bg_unit)
	selectionFooterBacks[2]=(Icon=Texture't_interface_mb.hud.interface_comp',U=238,V=131,UL=46,VL=46,DrawColor=(R=217,G=173,B=46,A=255),ScaleX=0.8,ScaleY=0.8,PivotU=0.5,PivotV=0.5)	// SIT_BACK_BEACON (bg_objective)

	selectionFooterIconSize=32
	bUseInspector=true
	bInitializedExecution=false
	bIsTrainingTextDisplayed=false

	FieldPromotionHeader="Field Promotion"
	FieldPromotionFooter="Select Soldier To Promote"

	FooterOffset=36.0
	SplitScreenFooterOffset=8.0
	CamRotationalRate=(pitch=3,yaw=6,roll=0)
	CamRotationalRateMP=(pitch=10,yaw=18,roll=0)
	ThetaBuffer=0
	MaxThetaRate=2.5
	ThetaAccel = 0
	ThetaAccelRate = 3.1415
	MaxFloatRate = 5000
	FloatAccelRate = 20000
	MaxOrbitTheta=3.2/// 1.74532 // About 100 degrees. Set to a little larger than Pi for a full orbit!
	CycleTargetTime=1.5
	CycleTargetFloatTime=0.5
	OcclusionTestInterval=0.25
	CameraGroundClearance=160.0

	HorizFieldUU=10922  // +/-60 degrees = 120 degrees range
	VertFieldUU=4096  // +/-45 degrees = 90 degrees range

	CamSnapAccelRate=2.0
}
class OracleCameraXbox extends OracleCamera;

simulated function ProcessInput( float DeltaTime, out float Theta, out float VerticalFloat )
{
	/*
		Process L/R & F/B button 
		This must be done first!  It could possibly modify ThetaBuffer, which we need up to date for the theta calculation.
	*/

	// Theta

	Theta = ThetaBuffer + FClamp( aStrafe / MAX_ASTRAFE, -1.0, 1.0 ) * MaxThetaRate * DeltaTime;

	// Vertical float

	VerticalFloat += FClamp( aForward / MAX_AFORWARD, -1.0, 1.0 ) * FloatAccelRate * DeltaTime;
	VerticalFloat = FClamp( VerticalFloat, MaxFloatDistanceZ, -MaxFloatDistanceZ );

	// update the PlayerController so that it will rotate based on input controls (mouse/joystick)
	UpdatePlayerControllerRotation(DeltaTime);

	LastaStrafe = aStrafe;
	LastaForward = aForward;
}

defaultproperties
{
	ZenithOffsetLerp=5.0
	MaxThetaRate=1.57
	ThetaAccelRate = 3.1415
	MaxFloatRate = 5000
	FloatAccelRate = 5000
	MaxOrbitTheta=3.2/// 1.74532 // About 100 degrees. Set to a little larger than Pi for a full orbit!
	CycleTargetTime=1.25
}class OracleCamLookTarget extends LookTarget;

var() localized	string	TitleString;


function SetTextLabel( String NewTitleString )
{
	TitleString = NewTitleString;
}

simulated function String GetHumanReadableName()
{
	return TitleString;
}


defaultproperties
{
	TitleString=""
}//=============================================================================
// PawnLookAtPoint.
//=============================================================================
class PawnLookAtPoint extends Keypoint;



defaultproperties
{
     bDirectional=False
}
//
// OptionalObject is an Inventory
//
class PickupMessagePlus extends LocalMessage;




static function float GetOffset(int Switch, float YL, float ClipY )
{
	return ClipY - YL - (64.0/768)*ClipY;
}

defaultproperties
{
	bFadeMessage=True
	bIsSpecial=True
	bIsUnique=True
	Lifetime=3

	DrawColor=(R=181,G=181,B=153,A=255)
	bCenter=True
	FontSize=1
}
class PlayerGrenadeTargetVolume extends Volume;

var() float MinimumPlayerRange;

defaultproperties
{
	MinimumPlayerRange=512.0
	bBlockZeroExtentTraces=true
	bProjTarget=true
}class SayMessagePlus extends StringMessagePlus;



var color USColor, DEColor;

static function RenderComplexMessage(
	Canvas Canvas,
	out float XL,
	out float YL,
	optional string MessageString,
	optional int Switch,
	optional PlayerReplicationInfo RelatedPRI_1,
	optional PlayerReplicationInfo RelatedPRI_2,
	optional Object OptionalObject
	)
{
	if (RelatedPRI_1 == None)
		return;

	Canvas.SetDrawColor(0,255,0);
	Canvas.DrawText( RelatedPRI_1.GetHumanReadableName() $ ": ", False );
	Canvas.SetPos( Canvas.CurX, Canvas.CurY - YL );
	Canvas.SetDrawColor(0,128,0);
	Canvas.DrawText( MessageString, False );
}

static function string AssembleString(
	HUD myHUD,
	optional int Switch,
	optional PlayerReplicationInfo RelatedPRI_1,
	optional String MessageString
	)
{
	local string PlayerName;

	if ( RelatedPRI_1 == None )  // unknown user (perhaps server Admin?)
		return MessageString;

	PlayerName = RelatedPRI_1.GetHumanReadableName();

	if ( PlayerName == "" )
		return "";
	return PlayerName $ ": " $ MessageString;
}

static function color GetConsoleColor( PlayerReplicationInfo RelatedPRI_1 )
{
	if ( (RelatedPRI_1 == None) || (RelatedPRI_1.Team == None) )
		return default.DrawColor;

	if ( ETeamIdentifier(RelatedPRI_1.Team.TeamIndex) == TEAM_US )
	{
		return default.USColor;
	}
	else if ( ETeamIdentifier(RelatedPRI_1.Team.TeamIndex) == TEAM_German )
	{
		return default.DEColor;
	}
	else
	{
		return default.DrawColor;
	}
}

defaultproperties
{
	bBeep=true
	bComplexString=True
	DrawColor=(R=181,G=181,B=153,A=255)
	USColor=(R=107,G=186,B=74,A=255)
	DEColor=(R=214,G=81,B=41,A=255)
	LifeTime=6
}
class SeeAndSuppressCache extends ISeeAndSuppressCache
	native
	noexport
	transient;

//---------------------------------------------------------
// Variables
//---------------------------------------------------------
var byte padding[24];	// for m_CSSCache (12 bytes), m_VantageCache (12 bytes).
var int NumVantageRecords;
var float ExpireThresh;
var float MaxImpactDistance;
var float MinSuppressionDist;
var float CornerTargetOffset;
var bool bDisableCaching;		// GBX:naj - used to debug at runtime

struct native CSSCacheRecord
{
	var float Timestamp;
	var bool CanSee, CanSuppress;
	var bool CanHeadShot;
	var Vector SeeLoc, SuppressLoc, FailLoc;
};

//---------------------------------------------------------
// Initialize
//---------------------------------------------------------
function Initialize()
{
	NativeInitialize();
}

native function NativeInitialize();
native function bool NeedNewRecord( gbxPawn Looker, gbxPawn Target, int Posture, out CSSCacheRecord HashRecord, out int bRecordExists );
native function AddToCache( gbxPawn Looker, gbxPawn Target, int Posture, CSSCacheRecord pHashRecord, bool bRecordExists );


//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
	MaxImpactDistance=1000.0
	MinSuppressionDist=700.0
}class ShellDEFG42Lite extends gbxWeaponShells;

#exec OBJ LOAD FILE=..\texture\t_effect.utx

defaultproperties
{
   Begin Object Class=SpriteEmitter Name=SpriteEmitter7
	   SecondsBeforeInactive=0
       Acceleration=(Z=-900.000000)
       UseCollision=False
       DampingFactorRange=(X=(Min=0.500000,Max=0.500000),Y=(Min=0.500000,Max=0.500000),Z=(Min=0.500000,Max=0.500000))
       UseMaxCollisions=True
       MaxCollisions=(Min=3.000000,Max=5.000000)
       ColorScale(0)=(Color=(B=255,G=255,R=255,A=255))
       ColorScale(1)=(RelativeTime=1.000000,Color=(B=255,G=255,R=255,A=255))
       FadeOutStartTime=3.200000
       FadeOut=True
       MaxParticles=30
       RespawnDeadParticles=False
       UseRotationFrom=PTRS_Offset
       SpinParticles=True
       StartSpinRange=(X=(Max=1.000000))
       StartSizeRange=(X=(Min=5.000000,Max=5.000000),Y=(Min=5.000000,Max=5.000000),Z=(Min=5.000000,Max=5.000000))
       UniformSize=True
       InitialParticlesPerSecond=0.000000
       AutomaticInitialSpawning=False
       DrawStyle=PTDS_AlphaBlend
       Texture=Texture't_effect.particle.casing_m1'
       TextureUSubdivisions=4
       TextureVSubdivisions=8
       BlendBetweenSubdivisions=True
       SubdivisionEnd=31
       LifetimeRange=(Min=2.000000)
       StartVelocityRange=(X=(Min=-20.000000,Max=20.000000),Y=(Min=100.000000,Max=150.000000),Z=(Min=150.000000,Max=250.000000))
   End Object
   Emitters(0)=SpriteEmitter'SpriteEmitter7'

	//EmitterSoundName="W_BAR.SHELL"
	EmitterSoundName="GEAR.SHELL"	// GBX:naj - bug 11544
	PlaySoundPct = 0.8
}
class ShellUSColt1911Lite extends gbxWeaponShells;

#exec OBJ LOAD FILE=..\texture\t_effect.utx

defaultproperties
{
   Begin Object Class=SpriteEmitter Name=SpriteEmitter8
	   SecondsBeforeInactive=0
       Acceleration=(Z=-900.000000)
       UseCollision=False
       DampingFactorRange=(X=(Min=0.500000,Max=0.500000),Y=(Min=0.500000,Max=0.500000),Z=(Min=0.500000,Max=0.500000))
       UseMaxCollisions=True
       MaxCollisions=(Min=3.000000,Max=5.000000)
       ColorScale(0)=(Color=(B=255,G=255,R=255,A=255))
       ColorScale(1)=(RelativeTime=1.000000,Color=(B=255,G=255,R=255,A=255))
       FadeOutStartTime=3.200000
       FadeOut=True
       MaxParticles=30
       RespawnDeadParticles=False
       UseRotationFrom=PTRS_Offset
       SpinParticles=True
       StartSpinRange=(X=(Max=1.000000))
       StartSizeRange=(X=(Min=5.000000,Max=5.000000),Y=(Min=5.000000,Max=5.000000),Z=(Min=5.000000,Max=5.000000))
       UniformSize=True
       InitialParticlesPerSecond=0.000000
       AutomaticInitialSpawning=False
       DrawStyle=PTDS_AlphaBlend
       Texture=Texture't_effect.particle.casing_m1'
       TextureUSubdivisions=4
       TextureVSubdivisions=8
       BlendBetweenSubdivisions=True
       SubdivisionEnd=31
       LifetimeRange=(Min=2.000000)
       StartVelocityRange=(X=(Min=-20.000000,Max=20.000000),Y=(Min=100.000000,Max=150.000000),Z=(Min=150.000000,Max=250.000000))
   End Object
   Emitters(0)=SpriteEmitter'SpriteEmitter8'

	//EmitterSoundName="W_COLT.SHELL"
	EmitterSoundName="GEAR.SHELL"	// GBX:naj - bug 11544
	PlaySoundPct = 1.0
}
class ShellUSM1Lite extends gbxWeaponShells;

#exec OBJ LOAD FILE=..\texture\t_effect.utx

defaultproperties
{
   Begin Object Class=SpriteEmitter Name=SpriteEmitter9
	   SecondsBeforeInactive=0
       Acceleration=(Z=-900.000000)
       UseCollision=False
       DampingFactorRange=(X=(Min=0.500000,Max=0.500000),Y=(Min=0.500000,Max=0.500000),Z=(Min=0.500000,Max=0.500000))
       UseMaxCollisions=True
       MaxCollisions=(Min=3.000000,Max=5.000000)
       ColorScale(0)=(Color=(B=255,G=255,R=255,A=255))
       ColorScale(1)=(RelativeTime=1.000000,Color=(B=255,G=255,R=255,A=255))
       FadeOutStartTime=3.200000
       FadeOut=True
       MaxParticles=10
       RespawnDeadParticles=False
       UseRotationFrom=PTRS_Offset
       SpinParticles=True
       StartSpinRange=(X=(Max=1.000000))
       StartSizeRange=(X=(Min=5.000000,Max=5.000000),Y=(Min=5.000000,Max=5.000000),Z=(Min=5.000000,Max=5.000000))
       UniformSize=True
       InitialParticlesPerSecond=0.000000
       AutomaticInitialSpawning=False
       DrawStyle=PTDS_AlphaBlend
       Texture=Texture't_effect.particle.casing_m1'
       TextureUSubdivisions=4
       TextureVSubdivisions=8
       BlendBetweenSubdivisions=True
       SubdivisionEnd=31
       LifetimeRange=(Min=2.000000)
       StartVelocityRange=(X=(Min=75.000000,Max=100.000000),Y=(Min=75.000000,Max=125.000000),Z=(Min=250.000000,Max=275.000000))
   End Object
   Emitters(0)=SpriteEmitter'SpriteEmitter9'

	//EmitterSoundName="W_M1GARAND.SHELL"
	EmitterSoundName="GEAR.SHELL"	// GBX:naj - bug 11544
	PlaySoundPct = 1.0

}class ShellUSThompsonLite extends gbxWeaponShells;

#exec OBJ LOAD FILE=..\texture\t_effect.utx

defaultproperties
{
   Begin Object Class=SpriteEmitter Name=SpriteEmitter10
	   SecondsBeforeInactive=0
       Acceleration=(Z=-900.000000)
       UseCollision=False
       DampingFactorRange=(X=(Min=0.500000,Max=0.500000),Y=(Min=0.500000,Max=0.500000),Z=(Min=0.500000,Max=0.500000))
       UseMaxCollisions=True
       MaxCollisions=(Min=3.000000,Max=5.000000)
       ColorScale(0)=(Color=(B=255,G=255,R=255,A=255))
       ColorScale(1)=(RelativeTime=1.000000,Color=(B=255,G=255,R=255,A=255))
       FadeOutStartTime=3.200000
       FadeOut=True
       MaxParticles=30
       RespawnDeadParticles=False
       UseRotationFrom=PTRS_Offset
       SpinParticles=True
       StartSpinRange=(X=(Max=1.000000))
       StartSizeRange=(X=(Min=5.000000,Max=5.000000),Y=(Min=5.000000,Max=5.000000),Z=(Min=5.000000,Max=5.000000))
       UniformSize=True
       InitialParticlesPerSecond=0.000000
       AutomaticInitialSpawning=False
       DrawStyle=PTDS_AlphaBlend
       Texture=Texture't_effect.particle.casing_m1'
       TextureUSubdivisions=4
       TextureVSubdivisions=8
       BlendBetweenSubdivisions=True
       SubdivisionEnd=31
       LifetimeRange=(Min=2.000000)
       StartVelocityRange=(X=(Min=-20.000000,Max=20.000000),Y=(Min=100.000000,Max=150.000000),Z=(Min=150.000000,Max=250.000000))
   End Object
   Emitters(0)=SpriteEmitter'SpriteEmitter10'

	//EmitterSoundName="W_THOMPSON.SHELL"
	EmitterSoundName="GEAR.SHELL"	// GBX:naj - bug 11544
}
class StartupMessage extends CriticalEventPlus;



var localized string Stage[8], NotReady, SinglePlayer;
var sound	Riff;

static simulated function ClientReceive(
	PlayerController P,
	optional int Switch,
	optional PlayerReplicationInfo RelatedPRI_1,
	optional PlayerReplicationInfo RelatedPRI_2,
	optional Object OptionalObject
	)
{
	Super.ClientReceive(P, Switch, RelatedPRI_1, RelatedPRI_2, OptionalObject);
	if ( Switch < 7 )
	{
		P.Level.FillPrecacheMaterialsArray();
		P.Level.FillPrecacheStaticMeshesArray();
		P.Level.FillPrecacheMeshesArray();
	}
	// don't play sound if quickstart=true, so no 'play' voiceover at start of tutorials
//	if ( Switch == 5 && P != none && P.Level != none && P.Level.Game != none && (!P.Level.Game.IsA('Deathmatch') || !DeathMatch(P.Level.Game).bQuickstart) )
//		P.PlayAnnouncement(sound'AnnouncerMain.Play',1,true);
//	else if ( (Switch > 1) && (Switch < 5) )
//		P.PlayBeepSound();
//	else if ( Switch == 7 )
//		P.ClientPlaySound(Default.Riff);
}

static function string GetString(
	optional int Switch,
	optional PlayerReplicationInfo RelatedPRI_1,
	optional PlayerReplicationInfo RelatedPRI_2,
	optional Object OptionalObject
	)
{
	if ( (RelatedPRI_1 != None) && (RelatedPRI_1.Level.NetMode == NM_Standalone) )
	{
		if ( Switch < 2 )
			return Default.SinglePlayer;
	}
	else if ( switch == 1 )
	{
		if ( (RelatedPRI_1 == None) || !RelatedPRI_1.bWaitingPlayer )
			return Default.Stage[0];
		else if ( RelatedPRI_1.bReadyToPlay )
			return Default.Stage[1];
		else
			return Default.NotReady;
	}
	return Default.Stage[Switch];
}

defaultproperties
{
	bIsConsoleMessage=false
	bIsUnique=true
	bBeep=False
	DrawColor=(R=32,G=64,B=255)
	Stage(0)="Waiting for other players."
	Stage(1)="Waiting for ready signals. You are READY."
	Stage(2)="The match is about to begin...3"
	Stage(3)="The match is about to begin...2"
	Stage(4)="The match is about to begin...1"
	Stage(5)="The match has begun!"
	Stage(6)="The match has begun!"
	Stage(7)="OVER TIME!"
	NotReady="You are NOT READY. Press Fire!"
	SinglePlayer="Press FIRE to start!"

//    Riff=sound'GameSounds.UT2K3Fanfare11'
}
class StaticMeshActorDynamic extends StaticMeshActor
	placeable;



defaultproperties
{
	bStatic=false
	bNoDelete=false
}
class StaticMeshActorExplodeable extends StaticMeshActor;

var() const staticMesh		BrokenMesh;

event TakeDamage( int Damage, Pawn EventInstigator,	vector HitLocation,	vector Momentum, class<DamageType> DamageType, optional	name HitBoxName)
{
	if ( ClassIsChildOf( DamageType, Class'gbxDamageExploded' ) )
	{
		SetStaticMesh( BrokenMesh );
	}
}

event Trigger( Actor Other, Pawn EventInstigator )
{
	SetStaticMesh( BrokenMesh );
}

defaultproperties
{
}//=============================================================================
// StaticMeshActorSwitch.
//=============================================================================
class StaticMeshActorSwitch extends StaticMeshActorDynamic
	placeable;

var(Events) const StaticMesh SM_Switch;

event Trigger( Actor Other, Pawn EventInstigator )
{
	SetStaticMesh( SM_Switch );
}class StringMessagePlus extends LocalMessage;



static function string AssembleString(
	HUD myHUD,
	optional int Switch,
	optional PlayerReplicationInfo RelatedPRI_1,
	optional String MessageString
	)
{
	return MessageString;
}

defaultproperties
{
    bIsSpecial=false
	DrawColor=(R=255,G=255,B=255,A=255)
}
//=============================================================================
// TankCornerPoint
//
// CornerPoint nodes spawned around tanks that move when the tank moves
//=============================================================================

class TankCornerPoint extends CornerPoint
	native;


native function SetCoverBits(byte low, byte crouched, byte standing);


defaultproperties
{
	bStatic=false  // can't be static and must be deletable for tank cover nodes to work
	bNoDelete=false
}
class TankGrenadeTrigger extends gbxContextUseTrigger;

var gbxPawn m_aTouchedByPawn;


event Destroyed()
{
	m_aTouchedBy = m_aTouchedByPawn;
	Super.Destroyed();
}

function Touch( Actor Other )
{
	if (bDisabled)
		return;

	if (bDontDisplayMessage)
		return;

	m_fMessageActive = false;

	m_aTouchedByPawn = gbxPawn( Other );

	if (m_aUseTarget == None)
	{
		if (m_szUseTarget != '')
		{
			foreach AllActors( class'Actor', m_aUseTarget, m_szUseTarget )
				break;
		}
	}

	if (Other.Instigator != None)
	{
		if (m_aTouchedByPawn == None)
			return;

		if ( !m_aTouchedByPawn.CanGrenadeTank() )
		{
			m_aTouchedByPawn = None;  // clear this out so Tick() won't display the message
			return;
		}

		if (m_aUseTarget != None)
		{
			if (m_aTouchedByPawn.IsPawnLookingAtActor(m_aUseTarget, UseAngleCos) == false)  // about 60 degrees from straight ahead
			{
				m_aTouchedByPawn.ReceiveLocalizedMessage(class'gbxContextUseHUDMessage', -1);  // remove the message from the HUD
				return;
			}
		}

		m_aTouchedByPawn.ReceiveLocalizedMessage(class'gbxContextUseHUDMessage', m_eUseType);  // display the USE message
		m_fMessageActive = true;
	}
}

function UnTouch( Actor Other )
{
	local Pawn User;

	m_aTouchedByPawn = None;

	// the Use message should always be enabled if you've untouched the trigger
	bDontDisplayMessage = false;

	if( (Other.Instigator != None) )
	{
		User = Pawn(Other);

		if (m_fMessageActive)
		{
			User.ReceiveLocalizedMessage(class'gbxContextUseHUDMessage', -1);  // remove the message from the HUD
			m_fMessageActive = false;
		}
	}
}

event bool UsedBy( Pawn User )
{
	local gbxPawn PlayerPawn;

	if (bDisabled)
		return false;

	if (m_aUseTarget == None)
	{
		if (m_szUseTarget != '')
		{
			foreach AllActors( class'Actor', m_aUseTarget, m_szUseTarget )
				break;
			if (m_aUseTarget != None)
			{
				if (User.IsPawnLookingAtActor(m_aUseTarget, UseAngleCos) == false)  // about 60 degrees from straight ahead
				{
					return false;
				}
			}
		}
	}

	if( (User != None) )
	{
		PlayerPawn = gbxPawn( User );
		if (PlayerPawn != None)
		{
			if ( !PlayerPawn.CanGrenadeTank() )
				return false;

			User.ReceiveLocalizedMessage(class'gbxContextUseHUDMessage', -2);  // remove the message from the HUD
			bDisabled = true;

			if (Level.NetMode != NM_Client)
			{
				if( !PlayerPawn.bUnloaded ) {	// RSC: added for infinte ammo cheat
					if (gbxUsableItem(PlayerPawn.SecondaryWeapon).bCanHaveMultipleCopies)
						gbxUsableItem(PlayerPawn.SecondaryWeapon).NumCopies -= 1;
				}
			}

			PlayerPawn.GrenadeTank( gbxPawn(m_aUseTarget) );

			if (gbxSVehicle(Owner) != None)
			{
				gbxSVehicle(Owner).GrenadeHasBeenPlanted(User);
			}

			return true;
		}
	}

	return false;
}

event Trigger(actor Other, Pawn EventInstigator)
{
	bDisabled = !bDisabled;
}

function Tick( float deltaTime )
{
	Super.Tick( deltaTime );

	if (m_aTouchedByPawn != None)
	{
		if (m_aUseTarget != None)
		{
			if (m_aTouchedByPawn.IsPawnLookingAtActor(m_aUseTarget, UseAngleCos) == false)  // about 60 degrees from straight ahead
			{
				if (m_fMessageActive)
				{
					m_aTouchedByPawn.ReceiveLocalizedMessage(class'gbxContextUseHUDMessage', -1);  // remove the message from the HUD
					m_fMessageActive = false;
				}
			}
			else if (!m_fMessageActive)
			{
				m_aTouchedByPawn.ReceiveLocalizedMessage(class'gbxContextUseHUDMessage', m_eUseType);  // display the USE message
				m_fMessageActive = true;
			}
		}
	}
}


defaultproperties
{
	m_eUseType=UseTankGrenade
	UseAngleCos=0.0  // +/- 60 degrees
}class TeamSayMessagePlus extends StringMessagePlus;

var color USColor, DEColor;


static function RenderComplexMessage(
	Canvas Canvas,
	out float XL,
	out float YL,
	optional string MessageString,
	optional int Switch,
	optional PlayerReplicationInfo RelatedPRI_1,
	optional PlayerReplicationInfo RelatedPRI_2,
	optional Object OptionalObject
	)
{
	local string LocationName;

	if (RelatedPRI_1 == None)
		return;

	Canvas.SetDrawColor(0,255,0);
	Canvas.DrawText( RelatedPRI_1.GetHumanReadableName() $ " ", False );
	Canvas.SetPos( Canvas.CurX, Canvas.CurY - YL );
	LocationName = RelatedPRI_1.GetLocationName();

	if (LocationName != "")
	{
		Canvas.SetDrawColor(0,128,255);
		Canvas.DrawText( " ("$LocationName$"):", False );
	}
	else
		Canvas.DrawText( ": ", False );
	Canvas.SetPos( Canvas.CurX, Canvas.CurY - YL );
	Canvas.SetDrawColor(0,128,0);
	Canvas.DrawText( MessageString, False );
}

static function string AssembleString(
	HUD myHUD,
	optional int Switch,
	optional PlayerReplicationInfo RelatedPRI_1,
	optional String MessageString
	)
{
	local string PlayerName;
	local string TeamName;

	if ( RelatedPRI_1 == None )
		return "";

	PlayerName = RelatedPRI_1.GetHumanReadableName();
	TeamName = RelatedPRI_1.Team.GetHumanReadableName();

	if ( PlayerName == "" || TeamName == "")
		return "";

	return PlayerName $ " (" $ TeamName $ "): " $ MessageString;
}

static function color GetConsoleColor( PlayerReplicationInfo RelatedPRI_1 )
{
	if ( (RelatedPRI_1 == None) || (RelatedPRI_1.Team == None) )
		return default.DrawColor;

	if ( ETeamIdentifier(RelatedPRI_1.Team.TeamIndex) == TEAM_US )
	{
		return default.USColor;
	}
	else if ( ETeamIdentifier(RelatedPRI_1.Team.TeamIndex) == TEAM_German )
	{
		return default.DEColor;
	}
	else
	{
		return default.DrawColor;
	}
}

defaultproperties
{
	bBeep=true
	bComplexString=True
	DrawColor=(R=181,G=181,B=153,A=255)
	USColor=(R=107,G=186,B=74,A=255)
	DEColor=(R=214,G=81,B=41,A=255)
	LifeTime=6
}
class TimeMessage extends CriticalEventPlus;



//#exec OBJ LOAD FILE=..\Sounds\announcer.uax

var localized string TimeMessage[16];
var Sound TimeSound[16];

static function string GetString(
	optional int N,
	optional PlayerReplicationInfo RelatedPRI_1,
	optional PlayerReplicationInfo RelatedPRI_2,
	optional Object OptionalObject
	)
{
	N = Static.TranslateSwitch(N);
	if ( N > 0 )
		return Default.TimeMessage[N];
}

/* Translate the number of seconds passed in to the appropriate message index
*/
static function int TranslateSwitch(int N)
{
	if ( N <= 10 )
		return (N-1);

	if ( N == 30 )
		return 10;

	N = N/60;
	if ( (N > 0) && (N < 6) )
		return (N + 10);

	return -1;
}

static simulated function ClientReceive(
	PlayerController P,
	optional int N,
	optional PlayerReplicationInfo RelatedPRI_1,
	optional PlayerReplicationInfo RelatedPRI_2,
	optional Object OptionalObject
	)
{
	N = Static.TranslateSwitch(N);
	if ( N > 0 )
		P.ViewTarget.PlaySound(Default.TimeSound[N],,4.0,,,,false);
}

defaultproperties
{
	 bBeep=False
	 TimeMessage(15)="5 minutes left in the game!"
	 TimeMessage(14)="4 minutes left in the game!"
	 TimeMessage(13)="3 minutes left in the game!"
	 TimeMessage(12)="2 minutes left in the game!"
	 TimeMessage(11)="1 minute left in the game!"
	 TimeMessage(10)="30 seconds left!"
	 TimeMessage(9)="10 seconds left!"
	 TimeMessage(8)="9..."
	 TimeMessage(7)="8..."
	 TimeMessage(6)="7..."
	 TimeMessage(5)="6..."
	 TimeMessage(4)="5 seconds and counting..."
	 TimeMessage(3)="4..."
	 TimeMessage(2)="3..."
	 TimeMessage(1)="2..."
	 TimeMessage(0)="1..."
//	 TimeSound(15)=sound'Announcer.CD5Min'
	 TimeSound(14)=None
//	 TimeSound(13)=sound'Announcer.CD3Min'
	 TimeSound(12)=None
//	 TimeSound(11)=sound'Announcer.CD1Min'
//	 TimeSound(10)=sound'Announcer.CD30Sec'
//	 TimeSound(9)=sound'Announcer.CD10'
//	 TimeSound(8)=sound'Announcer.CD9'
//	 TimeSound(7)=sound'Announcer.CD8'
//	 TimeSound(6)=sound'Announcer.CD7'
//	 TimeSound(5)=sound'Announcer.CD6'
//	 TimeSound(4)=sound'Announcer.CD5'
//	 TimeSound(3)=sound'Announcer.CD4'
//	 TimeSound(2)=sound'Announcer.CD3'
//	 TimeSound(1)=sound'Announcer.CD2'
//	 TimeSound(0)=sound'Announcer.CD1'
}
class TNTTrigger extends gbxContextUseTrigger;

var() bool	bCanPlantTNTHere;
var() bool	bAutoDestroy;	// should this trigger destroy itself after it's USED?
var() bool	bAutoEnable;	// should this trigger auto re-enable itself after being used?
var bool bTNTExplodedProperly;
var() float fAutoEnableTime;	// how long to wait before auto re-enabling this trigger
var() string TNTClassName;
var	float	AutoEnableAtTime;
var gbxExplosive LastSatchel;
var Pawn	ExplosionInstigator;
var Vector	FakeExplodeLoc;

// GBX:RSC - add TNT polling
var TurretWeapon AttachedTurret;

//DHW +
//These vars keep track of the TNTs timer and force that master timer onto the TNT object
var float	flFuseTime;
var int		iReplicatedFuseTime;
//DHW -

// GBX:RSC - add TNT polling
function NotifyTNTPlanted( bool IsPlanted )
{
	if( AttachedTurret != None ) 
	{
		log( "TNTTrigger::NotifyTNTPlanted() - " $ IsPlanted, 'RSC' );
		AttachedTurret.NotifyTNTPlanted(IsPlanted);
	}
}

function SetAttachedTurret( TurretWeapon Gun )
{
	if( Gun != None )
	{
		log( "TNTTrigger::SetAttachedTurret() - " $ Gun $ " attached", 'RSC' );
		AttachedTurret = Gun;
	}
}

function bool IsPawnLookingAtUseTarget( Pawn aPawn )
{
	local vector vRot, vDir;
	local float dotResult;

	vRot = Vector(aPawn.GetViewRotation());
	vDir = (m_aUseTarget.Location - (aPawn.Location + aPawn.EyePosition()));
	
	vRot.Z = 0;
	vDir.Z = 0;
	vRot = Normal(vRot);
	vDir = Normal(vDir);

	dotResult = vRot dot vDir;

	if ( dotResult > UseAngleCos )
		return true;

	return false;
}

event bool UsedBy( Pawn User )
{
	local gbxPawn PlayerPawn;

	if (bDisabled)
		return false;

	if (m_aUseTarget == None)
	{
		if (m_szUseTarget != '')
		{
			foreach AllActors( class'Actor', m_aUseTarget, m_szUseTarget )
				break;
			if (m_aUseTarget != None)
			{
				if ( !IsPawnLookingAtUseTarget( User ) )
				{
					return false;
				}
			}
		}
	}

	if( (User != None) )
	{
		PlayerPawn = gbxPawn( User );
		if (PlayerPawn != None)
		{
			if ( !PlayerPawn.CanPlaceTNT() )
				return false;

			User.ReceiveLocalizedMessage(class'gbxContextUseHUDMessage', -1);  // remove the message from the HUD			
			bDisabled = true;
			bDontDisplayMessage = true;

			PlayerPawn.PlaceTNT( m_aUseTarget, Self );

			return true;
		}
	}	

	return false;
}

function bool PlantTNT( Vector PlantLocation, Rotator PlayerRotation, Pawn TheInstigator )
{
	local gbxExplosive Satchel;
	
	FakeExplodeLoc = PlantLocation;		// Used later in case the spawn fails.

	Satchel = TryToSpawnTNT( PlantLocation, PlayerRotation, TheInstigator );

	if ( Satchel != None )
	{
		ExplosionInstigator = TheInstigator;
		Satchel.Instigator = ExplosionInstigator;
		Satchel.TheTrigger = Self;

		Satchel.Event = Self.Event;
		Satchel.Trigger( Self, TheInstigator );		

		bDisabled = true;

		LastSatchel = Satchel;		
		
		//DHW +
		//disabled backup timer as all the fuse timer code is now in the TNTTrigger
		//SetTimer( 12.0f, false );
		flFuseTime			= Satchel.flFuseTime;
		iReplicatedFuseTime = Satchel.flFuseTime;
		//DHW -
		
		NotifyTNTPlanted( true );	// GBX:RSC - add TNT polling
		return true;
	}
	else
	{
		bDisabled = false;
		bDontDisplayMessage = false;

		NotifyTNTPlanted( false );	// GBX:RSC - add TNT polling
		return false;
	}

	// GBX:RSC - added for correctness
	NotifyTNTPlanted( false );	// GBX:RSC - add TNT polling
	return false;
}

function Timer()
{
	local IImpactManager ImpactMgr;
	local Rotator DummyRot;
	local gbxExplosive FakeSatchel;

	if ( !bTNTExplodedProperly )
	{
		// Okay, we were somehow unsuccessful in our attempt to spawn TNT.  Our backup timer has expired,
		// so spawn another satchel way up in the sky (it will be invisible anyway), and then explode it immediately
		// at the location we need.
		FakeSatchel = TryToSpawnTNT( FakeExplodeLoc + Vect(0,0,2000.0f ), Self.Rotation, None );
		if ( FakeSatchel != None )
		{
			FakeSatchel.Explosion( FakeExplodeLoc );
		}
		else
		{
			// Wow, even that didn't work.  Okay, this is the best we can do: spawn an explosion effect (it will not cause damage).
			ImpactMgr = class'ImpactManager'.static.GetInstance( Level.Outer, self );
			if (ImpactMgr != None)
				ImpactMgr.HandleExplosionImpact( Self, None,	WC_Grenade, FakeExplodeLoc, DummyRot );
		}

		NotifyExploded();
	}

	TriggerEvent( Event, Self, ExplosionInstigator );
}

function gbxExplosive TryToSpawnTNT( Vector PlantLocation, Rotator PlayerRotation, Pawn TheInstigator )
{
	local gbxExplosive Satchel;
	local Vector NewLocation, X,Y,Z;
	local Rotator TNTRotation;
	local class<gbxExplosive> TNTClass;

	TNTClass = class<gbxExplosive>( DynamicLoadObject( TNTClassName, class'Class' ) );

	//log("NAJ**** TRYING TO SPAWN TNT ****************************", 'naj' );

	if ( TNTClass != None )
	{
		TNTRotation = PlayerRotation;
		TNTRotation.Pitch = 0;
		TNTRotation.Yaw = ( TNTRotation.Yaw-16384 ) & 65535;

		// make SURE the TNT is owned by the Instigator (tanks use this!!!)
		Satchel = Spawn( TNTClass, TheInstigator,, PlantLocation, TNTRotation );

		if ( Satchel != None )
			return Satchel;					

		//log("NAJ**** TryToSpawnTNT: Failed [1].", 'naj' );
		GetAxes( PlayerRotation, X,Y,Z );

		NewLocation = PlantLocation + 25.0 * X;
		Satchel = Spawn( TNTClass, TheInstigator,, NewLocation, TNTRotation );

		if ( Satchel != None )
			return Satchel;	

		//log("NAJ**** TryToSpawnTNT: Failed [2].", 'naj' );
		NewLocation = PlantLocation + 50.0 * X;
		Satchel = Spawn( TNTClass, TheInstigator,, NewLocation, TNTRotation );

		if ( Satchel != None )
			return Satchel;

		//log("NAJ**** TryToSpawnTNT: Failed [3].", 'naj' );
		NewLocation = PlantLocation + 75.0 * X;
		Satchel = Spawn( TNTClass, TheInstigator,, NewLocation, TNTRotation );

		if ( Satchel != None )
			return Satchel;

		//log("NAJ**** TryToSpawnTNT: Failed [4].", 'naj' );
		NewLocation = PlantLocation + 25.0 * Y;
		Satchel = Spawn( TNTClass, TheInstigator,, NewLocation, TNTRotation );

		if ( Satchel != None )
			return Satchel;

		//log("NAJ**** TryToSpawnTNT: Failed [5].", 'naj' );
		NewLocation = PlantLocation + 50.0 * Y;
		Satchel = Spawn( TNTClass, TheInstigator,, NewLocation, TNTRotation );

		if ( Satchel != None )
			return Satchel;

		//log("NAJ**** TryToSpawnTNT: Failed [5].", 'naj' );
		NewLocation = PlantLocation - 25.0 * Y;
		Satchel = Spawn( TNTClass, TheInstigator,, NewLocation, TNTRotation );

		if ( Satchel != None )
			return Satchel;

		//log("NAJ**** TryToSpawnTNT: Failed [6].", 'naj' );
		NewLocation = PlantLocation - 50.0 * Y;
		Satchel = Spawn( TNTClass, TheInstigator,, NewLocation, TNTRotation );

		if ( Satchel != None )
			return Satchel;

		//log("NAJ**** TryToSpawnTNT: Failed [7].", 'naj' );
		NewLocation = PlantLocation + 100.0 * Y;
		Satchel = Spawn( TNTClass, TheInstigator,, NewLocation, TNTRotation );

		if ( Satchel != None )
			return Satchel;

		//log("NAJ**** TryToSpawnTNT: Failed [8].", 'naj' );
		NewLocation = PlantLocation - 100.0 * Y;
		Satchel = Spawn( TNTClass, TheInstigator,, NewLocation, TNTRotation );

		if ( Satchel != None )
			return Satchel;

		//log("NAJ**** TryToSpawnTNT: Failed [9].", 'naj' );
		NewLocation = PlantLocation + 125.0 * Y;
		Satchel = Spawn( TNTClass, TheInstigator,, NewLocation, TNTRotation );

		if ( Satchel != None )
			return Satchel;

		//log("NAJ**** TryToSpawnTNT: Failed [10].", 'naj' );
		NewLocation = PlantLocation - 125.0 * Y;
		Satchel = Spawn( TNTClass, TheInstigator,, NewLocation, TNTRotation );

		if ( Satchel != None )
			return Satchel;

		//log("NAJ**** TryToSpawnTNT: Failed [11].", 'naj' );
	}

	return None;
}

function NotifyFellThroughWorld()
{
	bDisabled = false;
}

//DHW + -- This function is intended to allow the LDs to know before an explosion goes off
function NotifyPreExplosion()
{
	log("*********************EXPLOSION PENDING**********");
}
//DHW -

function NotifyExploded()
{
	bTNTExplodedProperly = true;

	if (bAutoDestroy)
	{
		Self.Destroy();
	}
	else if (bAutoEnable)
	{
		AutoEnableAtTime = Level.TimeSeconds + fAutoEnableTime;
	}

	if(AttachedTurret != None)  //NAC:If there is a turret, make sure that no matter what this thing blows up.
	{
		AttachedTurret.BlowUp(ExplosionInstigator);
	}

}

// GBX:naj - This logic should perhaps be in the parent class (gbxContextUseTrigger), but I don't want to risk breaking gbxContextUseTrigger just yet,
// so I'll duplicate it here (slightly modified) for now.
function Tick( float deltaTime )
{
	Super( Trigger ).Tick( deltaTime );


	//DHW + -- This block of code is intended to move all the explosion timer code into a centralized location

	//Update the master fuse timer
	if ( flFuseTime > 0.0 )
	{
		flFuseTime				-= DeltaTime;
		iReplicatedFuseTime		= Ceil(flFuseTime);
	}
	else
	{
		flFuseTime = 0.0;
		iReplicatedFuseTime = 0;
	}

	//If the satchel exists update it
	if ( LastSatchel != None )
	{
		LastSatchel.flFuseTime			= flFuseTime;
		LastSatchel.iReplicatedFuseTime	= iReplicatedFuseTime;
	}

	//This code is to guard against the TNT disapearing prematurely
	//if the TNT does not exist and there is still time on the fuse than the TNT shoudl be respawned
	else if ( flFuseTime > 0.0 )
	{
		log("******ERROR: TNT disappeared prematurely creating backup TNT*****");
		LastSatchel = TryToSpawnTNT( FakeExplodeLoc + Vect(0,0,2000.0f ), Self.Rotation, None );
		if ( LastSatchel != None )
		{
			LastSatchel.flFuseTime			= flFuseTime;
			LastSatchel.iReplicatedFuseTime	= iReplicatedFuseTime;
		}
	}
	//DHW -

	
	if (m_aTouchedBy != None)
	{
		if (m_aUseTarget != None && !bDisabled )
		{
			if ( !IsPawnLookingAtUseTarget( m_aTouchedBy ) )
			{
				if (m_fMessageActive)
				{
					m_aTouchedBy.ReceiveLocalizedMessage(class'gbxContextUseHUDMessage', -1);  // remove the message from the HUD
					m_fMessageActive = false;
				}
			}
			else if (!m_fMessageActive)
			{
				m_aTouchedBy.ReceiveLocalizedMessage(class'gbxContextUseHUDMessage', m_eUseType);  // display the USE message
				m_fMessageActive = true;
			}
		}
	}

	if ((AutoEnableAtTime > 0.0) && (AutoEnableAtTime < Level.TimeSeconds))
	{
		AutoEnableAtTime = -1.0;
		bDisabled = false;
		bDontDisplayMessage = false;
	}
}

function SetTNTVisible()
{
	if ( LastSatchel != None )
		LastSatchel.bHidden = false;
}

defaultproperties
{	
	Texture=Texture'Engine.S_TriggerContextUse'
	m_eUseType=TNT
	bAutoDestroy=true
	bAutoEnable=false
	fAutoEnableTime=15.0
	AutoEnableAtTime=-1.0
	TNTClassName="gbxInventory.TNT"

	AttachedTurret=None;
}class TurretVolume extends Volume;



var TurretWeapon Turret;


function PostNetBeginPlay()
{
	Super(Brush).PostNetBeginPlay();
	//Log( " TurretVolume::PostNetBeginPlay() AssociatedActorTag="$AssociatedActorTag, 'MP' );

	if ( AssociatedActorTag != '' )
	{
		ForEach AllActors(class'Actor',AssociatedActor, AssociatedActorTag)
		{
			if ( AssociatedActor.IsA( 'TurretWeapon' ) )
			break;
		}
	}

	//Log( " TurretVolume::PostNetBeginPlay() AssociatedActor="$AssociatedActor, 'MP' );

	if ( AssociatedActor != None )
	{
		Turret = TurretWeapon( AssociatedActor );
		//Log( " TurretVolume::PostNetBeginPlay() Turret="$Turret, 'MP' );

		GotoState('AssociatedTouch');
		InitialState = GetStateName();
	}
}


State AssociatedTouch
{
	event touch( Actor Other )
	{
		//log( self$" TurretVolume::AssociatedTouch:touch("$Other$") Turret="$Turret );
		
		if ( Turret != None && Other.IsA( 'gbxPawn' ) )
			Turret.CandidateAcquired( gbxPawn( Other ) );
	}

	event untouch( Actor Other )
	{
		//log( self$" TurretVolume::AssociatedTouch:untouch("$Other$")" );
		
		if ( Turret != None && Other.IsA( 'gbxPawn' ) )
			Turret.CandidateLost( gbxPawn( Other ) );
	}

	function BeginState()
	{
		local gbxPawn gbxP;

		//log( self$" TurretVolume::AssociatedTouch:BeginState()" );

		ForEach TouchingActors(class'gbxPawn', gbxP)
		{
			//log( self$" TurretVolume::AssociatedTouch:BeginState() Calling CandidateAcquired with gbxPawn="$gbxP );
			Turret.CandidateAcquired( gbxP );
		}
	}
}
//=============================================================================
// Base class for stationary turret-mounted weapons such as the MG42 and
// the Browning .30 cal.
//
// Author: Neil Johnson, Gearbox Software.
//=============================================================================
class TurretWeapon extends gbxWeapon
	abstract
	native;


//---------------------------------------------------------
// Variables
//---------------------------------------------------------
var EJobType		PlayersJob;
var Sound			FireLoopSound;
var String			FireLoopSoundName;
var Sound			StereoFireLoopSound;
var String			StereoFireLoopSoundName;
var	int				FireLoopSoundHandle;
var Sound			FireOneBulletSound;
var String			FireOneBulletSoundName;
var Sound			StereoFireOneBulletSound;
var String			StereoFireOneBulletSoundName;

var	bool			bIgnoreSuppression;
var bool			bTurretEnabled;
var bool			bHasBlownUp;
var bool			bUseShotProtection;
var float			Zone1OuterRadius,				// Distances defining three 'kill zones' for the turret.
					Zone2OuterRadius,				// (Zone 1 == closest to turret; Zone 3 == farthest).
					Zone3OuterRadius;
var float			NoShotProtectionDist;			// Distance outside of which attackers cannot hit the gunner.
var float			ShotProtectionCosTheta;
var float			EnemyTooCloseDist;
var const float		DistanceThresh;					// Max acceptable distance from the mount point before mounting.
var const Vector	MountOffset;					// Location relative to this weapon at which a Pawn should be in order to mount the weapon.

var EMountAction	MyMountAction, MyDismountAction;

var gbxContextUseTrigger	MyTNTTrigger;
var bool					bIsTNTPlanted;	// GBX:RSC - add TNT polling

// GBX:RSC - add TNT polling
function bool HasTNTBeenPlanted()
{
	log( "TurretWeapon::HasTNTBeenPlanted() returned " $ bIsTNTPlanted, 'RSC' );
	return bIsTNTPlanted;
}

function NotifyTNTPlanted( bool IsPlanted )
{
	log( "TurretWeapon::NotifyTNTPlanted() - " $ IsPlanted, 'RSC' );
	bIsTNTPlanted = IsPlanted;
}

function EJobType GetPlayerJobName()
{
	return PlayersJob;
}

// Has this turret been claimed by someone?
function bool HasPendingGunner();

// Is this turret being used?
function bool IsInUse();

// Claim the turret.
//function ClaimAsGunner( gbxPawn gbxP );

// Claimed successfully?
function bool HasClaimedAsGunner( gbxPawn gbxP );

// Make the turret weapon rotate to face a particular rotation.
function FaceRotation( Rotator Rot );

// Set up a pawn in preparation to mount this weapon.
function PreparePawnToMount(gbxPawn gbxP);

// Perform the actual mounting (after the mount animation has finished).
function CompleteMount( gbxPawn gbxP );

// Do weapon-specific logic to undo setup actions if the mount failed.
function MountFailed( gbxPawn gbxP );

// Set up a pawn in preparation to dismount this weapon.
function PreparePawnToDismount( gbxPawn gbxP );

// Clean up after dismounting.
function CompleteDismount( gbxPawn gbxP );

// Report that the pawn manning this weapon has died.
function GunnerDied( gbxPawn gbxP );

// Return the mount point in worldspace.
//function Vector GetMountPoint();

function ActorLite GetMountPoint();

function bool TryToPlaceGunner( gbxPawn TheGunner ) { return false; }

// Determine if close enough to begin mount.
function bool IsCloseEnoughToMount( Vector PawnLocation );

// Determine if facing correct direction to begin mount.
function bool IsFacingRightDirection( gbxPawn gbxP );

simulated function SpecialCalcView( gbxPawn thePawn, out actor ViewActor, out vector CameraLocation, out rotator CameraRotation );

// For use with player pawns; get the current direction of fire.
function Rotator GetFireRotation();

// Adjust the aim vector for error.
function Rotator AdjustAimSpecial( Ammunition Ammo, Vector ProjStart, Rotator AimRotator, int WeaponAimError );

// Called by TurretVolumes when pawns enter and leave the volumes.
function CandidateAcquired( gbxPawn Candidate );
function CandidateLost( gbxPawn Candidate );

function EMountAction GetMountAction() { return MyMountAction; }
function EMountAction GetDismountAction() { return MyDismountAction; }

event bool IsZoomed();

function Vector GetBaseVector();

function NotifyCrewMemberDied( gbxPawn gbxP );
function NotifyForceDismount( optional bool bDoNothingIfHumanControlled );
function PostRender( Canvas TheCanvas );

function ForceCrewDismount( optional Pawn InstigatedBy );

function bool PawnIsInCrew( Pawn P ) { return false; }

function bool NeverAllowShotProtectionFor( class<DamageType> DamageType ) { return true; }
function bool CanBeDestroyedBy( class<DamageType> DamageType ) { return false; }

//---------------------------------------------------------
//	EnableTurret
//---------------------------------------------------------
function EnableTurret( bool bEnabled )
{
	//Log( " TurretWeapon::EnableTurret() bEnabled="$bEnabled, 'MP' );
	bTurretEnabled = bEnabled;
}

//---------------------------------------------------------
//	IsEnabled
//---------------------------------------------------------
function bool IsEnabled()
{
	//Log( " TurretWeapon::IsEnabled() bTurretEnabled="$bTurretEnabled, 'MP' );
	return bTurretEnabled;
}

//---------------------------------------------------------
//	BlowUp
//---------------------------------------------------------
function SetBlownUp()
{
	bHasBlownUp = true;
	if ( MyTNTTrigger != None )
		MyTNTTrigger.Destroy();
}

//---------------------------------------------------------
//	BlowUp
//---------------------------------------------------------
function BlowUp( Pawn EventInstigator )
{
	bHasBlownUp = true;
	if ( MyTNTTrigger != None )
		MyTNTTrigger.Destroy();
}

//---------------------------------------------------------
//	HasBlownUp
//---------------------------------------------------------
function bool HasBlownUp()
{
	return bHasBlownUp;
}

//---------------------------------------------------------
//	AttachToPawn
//---------------------------------------------------------
simulated function AttachToPawn(Pawn P, optional bool bDontInitAttachment)
{
	// Most of the code here is copied as is from Inventory::AttachToPawn().
	// However, it skips over the AttachToPawn() stuff, because turret weapons
	// can't be attached.
	//
	if ( ThirdPersonActor == None )
	{
		ThirdPersonActor = Spawn(AttachmentClass,Owner);
		InventoryAttachment(ThirdPersonActor).InitFor(self);
	}

	ThirdPersonActor.SetLocation(P.Location);
	ThirdPersonActor.SetBase(P);

	gbxWeaponAttachment(ThirdPersonActor).SetAmmoType(FireMode[0].AmmoClass, FireMode[0].FlashEmitterClass);
}

//---------------------------------------------------------
//	TakeDamage
//---------------------------------------------------------
event TakeDamage( int Damage, Pawn EventInstigator, vector HitLocation, vector Momentum, class<DamageType> DamageType, optional name HitBoxName)
{
	if ( CanBeDestroyedBy( DamageType ) )
	{
		BlowUp( EventInstigator );
	}
}

//---------------------------------------------------------
//	RejectDamageRequest
//---------------------------------------------------------
function bool RejectDamageRequest( Pawn Shooter, Pawn Victim, class<DamageType> DamageType ) 
{ 
	local float DotVal;

	if ( !bUseShotProtection )
		return false;

	if ( !PawnIsInCrew( Victim ) )
		return false;

	// No rejection for heavy explosives.
	if ( NeverAllowShotProtectionFor( DamageType ) )
		return false;
	
	// Only reject requests for AI-controlled crew members.
	if ( !Victim.IsHumanControlled() )
	{		
		DotVal = Vector( Rotation ) Dot Normal( Shooter.Location - Victim.Location );
		if ( DotVal > ShotProtectionCosTheta && 
			 VSize( Shooter.Location - Victim.Location ) > NoShotProtectionDist )
		{
			return true;
		}
		else
		{
			return false;
		}
	}
	else
	{
		return false;
	}
}

function GetBestBurstLength( ESuppressionLevel SuppressionLevel, out float MinLen, out float MaxLen );
function GetBestPauseTime( ESuppressionLevel SuppressionLevel, out float MinLen, out float MaxLen );

function Vector GetViewOrigin()
{
	if ( Instigator != None )
		return Instigator.Location;
	else
		return Vect(0,0,0);
}

function ReloadFinished() {}

simulated function bool AttachBombToTurret(Pawn User, Vector AttachVector, Rotator AttachDir);

simulated function bool CanPlantBomb( Pawn User )
{
	return false;
}

function bool IsMachineGun() { return false; }
function bool IsAntiTank() { return false; }
function bool IsAntiAir() { return false; }
function bool IsPak88() { return false; }
function bool IsMortar() { return false; }
event bool TargetIsInMyConeOfFire( gbxPawn aTarget, optional bool bUseNarrowHysteresis ) { return false; }
function bool PointIsInMyConeOfFire( Vector TargetLoc, optional bool bUseNarrowHysteresis ) { return false; }

simulated function CalcOffsetWeaponCollision()
{
	local vector X,Y,Z, vecStart;
	
	GetAxes(Instigator.GetViewRotation(),X,Y,Z);
	vecStart = Location;
	vecStart.Z = GetFireStart(X, Y, Z).Z;
	OffsetWeaponCollision( vecStart, X, false );
//	OffsetWeaponCollision( Instigator.Location, X );

	if (m_fZoomed && (ClientState != WS_ZoomOut))
	{
		m_flDrawOffset = 0.0f;
	}
}

//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
	bHidden=false
	bOnlyOwnerSee=false
	bStationary=true

	bCollideActors=false
	bBlockActors=false
	bBlockPlayers=false
	bBlockKarma=false

	bWorldGeometry=false
	bHardAttach=true
	Physics=PHYS_Rotating

	m_eWeaponType=WeaponPrimary
	bSniping=false
	bCanThrow=false

	bTurretEnabled=true
	bIgnoreSuppression=false

	DistanceThresh=(X=0,Y=0,Z=0)
	ShotProtectionCosTheta=0.7071
	
	bIsTNTPlanted=false;
}
//=============================================================================
// Container class representing a single fire team.
// Intercepts squad commands, manages unit formation centers, and 
// handles member registration/removal.
//
// Gearbox Software.
//=============================================================================
class Unit extends Actor
	placeable
	native;

enum EUnitTitle
{
	UnitTitleNone,
	UnitTitle01,
	UnitTitle02,
	UnitTitle03,
	UnitTitle04,
	UnitTitle05,
	UnitTitle06,
	UnitTitle07,
	UnitTitle08,
	UnitTitle09,
	UnitTitle10,
	UnitTitle11,
	UnitTitle12,
	UnitTitle13,
	UnitTitle14,
	UnitTitle15,
	UnitTitle16,
	UnitTitle17,
	UnitTitle18,
	UnitTitle19,
	UnitTitle20,
	UnitTitle21,
	MP_GERMANASSAULT,
	MP_GERMANFIRE,
	MP_GERMANSNIPER,
	MP_USASSAULT,
	MP_USFIRE,
	MP_USSNIPER,
	SKR_HARTSOCK,
	SKR_BAKER,
	UnitTitle22,
	UnitDoyle,
	UnitTitle23,
	UnitTitle24,
	UnitTitle25,
};

//---------------------------------------------------------
//	Variables / Constants
//---------------------------------------------------------
var EUnitType					Job;

var()   EUnitTitle				Title;
var()	Name					SuperUnitName;				// Used to string units together when the level loads.
var		Name					PawnToWatch;
var		Unit					SuperUnit;

var		gbxPawn					Leader;						// The leader of this unit. He must also be in the Members array.
const							MAX_MEMBERS = 3;			
var		gbxPawn					Members[MAX_MEMBERS];
var		gbxPawn					MeleeTargets[MAX_MEMBERS];
var		int						NumMembers;

const							MAX_SUBUNITS = 3;
var		Unit					SubUnits[MAX_SUBUNITS];
var		int						NumSubUnits;
var		bool					bAttachedToSuperUnit;		// Is this unit following it's parent

var()	class<Unit>				NormalSubUnitClass;

var()	bool					bPullPlayerIn;
var()	bool					bMakePlayerLeader;			// If true, bPullPlayerIn is ignored (taken to be true).
var()	bool					bFallInOnStartup;			// Causes this unit to attach to it's super unit when created
var		bool					bLogSelect;
var		bool					bAssaultingTargetUnit;		// If an AssignedTargetUnit is set, and this is set, then this unit is assaulting, not attacking the unit
var		bool					bKnowsAllies;				// Flags whether this Unit knows about all of its allied units yet.
var()	bool					bDontRemoveEmptyUnit;
var		bool					bDontDisplay;

var		Unit					AssignedTargetUnit;			// The unit that members of this unit should try to attack.
var		array<Unit>				AlliedUnits;				// GBX:naj - 6/27/04 - Caching known friendly units to avoid expensive iterator code in UnitControllerAI::IsUnitTargettedByAlly().

var		UnitController			MyUnitController;

var()	Texture					Icon;						// The icon with which to represent this unit in the hub.

var()	string					MyInWorldIconClass;
var()	InWorldUnitIcon			MyInWorldIcon;
var()	Color					MyInWorldIconBaseColor;

var		transient				InWorldOrderIconBase	TargetOrderIcon;

var()	edfindable ActorLite	FormationCenter;
var		ActorLite				PreviousFormationCenter;	// so we know what the previous one was after a 'NotifyFormationCenterChange' order
var		int						FormationYaw;				// direction formation is facing
var		int						PreviousFormationYaw;		// so we know what the previous direction was after a 'NotifyFormationCenterChange' order
var		int						NumMachineGunsInUnit;
var()	float					FormationRadius;
var()	float					MinFormationRadius;
var()	float					MinFormationRadiusCombine;
var()	float					FormationRadiusMemberScale;
var()	float					FormationRadiusMemberScaleCombine;
var()	float					FORMCExpansionSize;
var()	float					MaxFormationRadius;
var()	float					RemainHereCloseEnoughDist;
var()	float					TooFarFromSuperUnitDist;
var		float					TargetOrderTime;
var		float					MachineGunBoldnessMultiplier;
var()	EUnitFormationType		FormationType;
var		array<ActorLite>		FormationPath;				// path that Unit members should stay close to when navigating

var()	byte					bUnitID;
var		byte					bMaxUnitCount;				// Maximum number of guys in this unit that didn't leave voluntarily (e.g. weren't dead when they left)

var		vector					UnitCentroid;
var		vector					DummyThreatLocation;

var()	ESkillLevel				BaseSkillLevel;				// The base skill level of the unit.

var()	class<gbxInspectorPanel>	myInspectorClass;			// HUD inspector class (static)
var 	string		TitleString;				// String displayed when browed in the Oracle camera.

var()	EUnitType				UnitType;

const CLIENT_CENTROID_CALC_INTERVAL = 0.33; //SDJ 05/15/2004: Added for client specific items recalculated with the hud draw.
var float						m_flNextClientRecalcTime;
var float fReinforcementsEffectTimeRemaining;	// How much longer the unit icon will scale on the compass after reinforcing.
var float fReinforcementsEffectDuration;		// How long the unit icon will scale on the compass after reinforcing.
var int   iReplicatedReinforcements;		
var int	  iLastReplicatedReinforcements;

var array<Actor> NotifyOrderTargetActors;		// a list of Actors to be notified when OrderTarget or OrderAssault is issued
var array<Actor> NotifyOrderAssaultActors;		// a list of Actors to be notified when OrderAssault is issued
var array<Actor> NotifyOrderFallInActors;		// a list of Actors to be notified when Fall-in is issued

replication
{
	reliable if( bNetDirty && (Role==ROLE_Authority) )
        MyUnitController, Leader, NumMembers, Members, NumSubUnits, SubUnits, bUnitID, UnitType, bAttachedToSuperUnit, 
		SuperUnit, bMaxUnitCount, iReplicatedReinforcements, MyInWorldIcon, bAssaultingTargetUnit;

	reliable if( bNetInitial && (Role==ROLE_Authority) )
		Title;
}

native function CalculateDummyThreat( ActorLite FORMC );

//--------------------------------------------------------------------
// GetControllingPlayerController
//--------------------------------------------------------------------
simulated function gbxPlayerController GetControllingPlayerController()
{
	local gbxPlayerController PC;

	for( PC = gbxPlayerController(Level.PlayerControllerList); PC != None; PC = gbxPlayerController(PC.nextPlayerController) )
	{
		if (PC.LastPlayerUnit == SuperUnit || PC.LastPlayerUnit == self)
		{
			break;
		}
	}

	return PC;
}

simulated function Tick(float DeltaTime)
{
	//Log( self$ " Unit::Tick() DeltaTime " $DeltaTime$ " iReplicatedReinforcements " $iReplicatedReinforcements$ " iLastReplicatedReinforcements " $iLastReplicatedReinforcements, 'PSV' );
	
	if (iReplicatedReinforcements != iLastReplicatedReinforcements)
	{
		//Log( self$ " Unit::Tick() Activating reinforcements effect!", 'PSV' );
		ActivateReinforcementsEffect( GetControllingPlayerController() );

		iLastReplicatedReinforcements = iReplicatedReinforcements;
	}

	// Tick the time scale if necessary
	if ( fReinforcementsEffectTimeRemaining > 0.0 )
	{
		fReinforcementsEffectTimeRemaining -= DeltaTime;
		fReinforcementsEffectTimeRemaining = FMax( 0.0, fReinforcementsEffectTimeRemaining );
	}
}	

//---------------------------------------------------------
//	LogSelective
//---------------------------------------------------------
// Selective logging function.  Use this in place of Log() wherever possible.
// Using the "logselect" console command at runtime causes only those log messages
// that pertain to an individual pawn to be printed out.
//
function LogSelective( String msg )
{
	local int nMembers, i;

	if ( bLogSelect )
	{ 
		if ( PawnToWatch == '' )
		{
			log( "UNIT: NAJ**** "$Self.Name$" ["$GetStateName()$"]: "$msg, 'naj');
			return;
		}
		else
		if ( PawnToWatch == 'InfantryUSA' && Members[0].IsA( 'InfantryUSA' ) )
		{
			log( "UNIT: NAJ**** InfantryUSA ("$Self.Name$") ["$GetStateName()$"]: "$msg, 'naj' );
			return;
		}
		else
		if ( PawnToWatch == 'InfantryGermany' && Members[0].IsA( 'InfantryGermany' ) )
		{
			log( "UNIT: NAJ**** InfantryGermany ("$Self.Name$") ["$GetStateName()$"]: "$msg, 'naj' );
			return;
		}

		nMembers = NumMembers;
		for( i = 0; i < nMembers; ++i )
		{			
			if ( PawnToWatch == Members[ i ].Name )
			{
				log( "UNIT: NAJ**** "$Members[ i ].Name$" ["$GetStateName()$"]: "$msg, 'naj');
				return;
			}			
		}
	}
}

//---------------------------------------------------------
//	SetPawnToWatch
//---------------------------------------------------------
function SetPawnToWatch( Name APawnToWatch )
{
	if ( APawnToWatch != '' )
	{
		bLogSelect = true;
		Default.bLogSelect = true;
		PawnToWatch = APawnToWatch;		
		Default.PawnToWatch = APawnToWatch;
	}
	else
	{
		bLogSelect = false;
		Default.bLogSelect = false;
	}
}

//---------------------------------------------------------
//	PostBeginPlay
//---------------------------------------------------------
function PostBeginPlay()
{
	local ActorLite closestNavPoint;

	Super.PostBeginPlay();

	if( SuperUnitName != 'None' )
	{
		// Find the SuperUnit.
		foreach DynamicActors( class'Unit', SuperUnit, SuperUnitName )
		{
			break;
		}

		if( SuperUnit != None )
		{
			SuperUnit.AddSubUnit( self );

			if( bFallInOnStartup )
				AttachToSuperUnit();
		}
	}

	if( FormationCenter == None )
	{
		closestNavPoint = GetNearestNavpoint( Location, -1.0f, false, true );

		FormationYaw = 0;  // just assign an arbitrary facing direction
		PreviousFormationYaw = FormationYaw;

		SetFormationCenter( closestNavPoint );
	}

	// Set the title string
	TitleString = class'UnitTypeInfo'.Static.GetUnitTitle( Title );
}


//---------------------------------------------------------
//	FindAlliedUnits
//---------------------------------------------------------
// Cache all units in the world that are on the same team as this one.
// Note: This function is designed to be called lazily by player-controller units, 
// so only player-controlled units will ever populate their AlliedUnits array.  
// AI-controlled units will never call this function.
//
function FindAlliedUnits()
{
	local Unit aUnit;

	// Maybe this unit doesn't even have a leader yet--in which case, how would you know who your allies are?
	if ( Leader == None )
		return;

	foreach DynamicActors( class'Unit', aUnit )
	{
		// Check if this unit has actually been initialized with a leader.  If not, 
		// then there's no way of telling if this unit is actually on our side.  We'll have
		// to come back and run this code again later.
		//		
		if( aUnit != Self && aUnit.Leader != None && aUnit.SameTeamAsUnit( Self ) )
		{
			AlliedUnits[ AlliedUnits.Length ] = aUnit;		// Implicitly adds a new element to the array.
		}
	}

	bKnowsAllies = true;
}

function bool RequestMeleeTarget( gbxPawn Member, gbxPawn Target )
{
	local int ndx, MemberNdx;

	if ( Member == None || Target == None )
		return false;

	for( MemberNdx = 0; MemberNdx < MAX_MEMBERS; ++MemberNdx )
	{
		if ( Members[ MemberNdx ] == Member )
		{
			break;
		}
	}

	if ( MemberNdx < MAX_MEMBERS )
	{
		for( ndx = 0; ndx < MAX_MEMBERS; ++ndx )
		{
			if ( ndx != MemberNdx )
				if ( MeleeTargets[ ndx ] == Target && !MeleeTargets[ ndx ].IsDead() )
					return false;
		}
		
		MeleeTargets[ MemberNdx ] = Target;
		return true;
	}

	return false;
}

function StopMeleeTarget( gbxPawn Member )
{
	local int ndx;

	for( ndx = 0; ndx < MAX_MEMBERS; ++ndx )
	{
		if ( Members[ ndx ] == Member )
		{
			MeleeTargets[ ndx ] = None;
		}
	}
}

//---------------------------------------------------------
//	OrderMove
//---------------------------------------------------------
function OrderMove( ActorLite FORMC, optional bool bAddToQueue )
{
	if( MyUnitController != None )
	{
		MyUnitController.OrderMove( FORMC, bAddToQueue );
	}
	else
	{
		SetFormationCenter( FORMC );
	}

	if( TargetOrderIcon != None )
	{
		TargetOrderIcon.Destroy();
		//TargetOrderIcon = None;
		SetTargetOrderIcon( None );
	}

	bAssaultingTargetUnit = false;  //NAC: added if it is an ordered move, then we need to make sure that this flag is set to false.
}

//---------------------------------------------------------
//	HasTargetOrder
//---------------------------------------------------------
function bool HasTargetOrder( /*out Unit targetUnit*/ )
{
	if ( AssignedTargetUnit != None )
	{
		//targetUnit = AssignedTargetUnit;
		return AssignedTargetUnit.AnyLivingMembers();
	}

	return false;
}

//---------------------------------------------------------
//	IsInTargetUnit
//---------------------------------------------------------
function bool IsInTargetUnit( gbxPawn TestPawn )
{
	return ( TestPawn != None && AssignedTargetUnit != None && TestPawn.MyUnit == AssignedTargetUnit );
}

//---------------------------------------------------------
//	TimeSinceTargetOrderGiven
//---------------------------------------------------------
function float TimeSinceTargetOrderGiven()
{
	local float Result;

	if ( AssignedTargetUnit == None )
		return -1.0f;

	Result = Level.TimeSeconds - TargetOrderTime;
	return FClamp( Result, 0.0, Result );
}

//---------------------------------------------------------
//	NotifyMemberDoingOpBurst
//---------------------------------------------------------
function NotifyMemberDoingOpBurst( gbxPawn aMember )
{
	MyUnitController.NotifyMemberDoingOpBurst( aMember );
}

//---------------------------------------------------------
//	HasFreeOpBurst
//---------------------------------------------------------
function bool HasFreeOpBurst()
{
	return MyUnitController != None && MyUnitController.HasFreeOpBurst();
}

//---------------------------------------------------------
//	OrderTarget
//---------------------------------------------------------
function OrderTarget( Unit targetUnit )
{
	local int index;

	bAssaultingTargetUnit = false;  //if we are doing a targeting order, then we definately are not assaulting

	// notify TriggeredScript about the OrderTarget command...
	for (index=0; index < NotifyOrderTargetActors.Length; index++)
	{
		if (NotifyOrderTargetActors[index] != None)
			NotifyOrderTargetActors[index].Signal(self, 1 /*1 means OrderTarget*/, targetUnit, 0, 0.0);
	}

	if( MyUnitController != None )
	{
		MyUnitController.OrderTarget( targetUnit );
	}
	else
	{
		SetTargetUnit( targetUnit );
	}

	if( TargetOrderIcon != None )
	{
		TargetOrderIcon.Destroy();
		//TargetOrderIcon = None;
		SetTargetOrderIcon( None );
	}
}

//---------------------------------------------------------
//	OrderAssault
//---------------------------------------------------------
function OrderAssault( Unit targetUnit )
{
	local int index;

	bAssaultingTargetUnit = true;

	// notify TriggeredScript about the OrderAssault command...
	for (index=0; index < NotifyOrderAssaultActors.Length; index++)
	{
		if (NotifyOrderTargetActors[index] != None)
			NotifyOrderAssaultActors[index].Signal(self, 2 /*2 means OrderAssault*/, targetUnit, 0, 0.0);
	}
	
	if( MyUnitController != None )
	{
		MyUnitController.OrderAssault( targetUnit );
	}
	
	if( TargetOrderIcon != None )
	{
		TargetOrderIcon.Destroy();
		//TargetOrderIcon = None;
		SetTargetOrderIcon( None );
	}
}

//---------------------------------------------------------
//	OrderFallIn
//---------------------------------------------------------
function OrderFallIn()
{
	local int index;

	// Refuse this order if this unit is empty.
	if( !AnyLivingMembers() )
	{
		return;
	}

	// notify TriggeredScript about the OrderAssault command...
	for (index=0; index < NotifyOrderFallInActors.Length; index++)
	{
		if (NotifyOrderFallInActors[index] != None)
			NotifyOrderFallInActors[index].Signal(self, 3 /*3 means OrderFallIn*/, None, 0, 0.0);
	}

	if( MyUnitController != None )
	{
		MyUnitController.OrderFallIn();
	}
	else
	{
		AttachToSuperUnit();
	}

	if( TargetOrderIcon != None )
	{
		TargetOrderIcon.Destroy();
		//TargetOrderIcon = None;
		SetTargetOrderIcon( None );
	}

	bAssaultingTargetUnit = false;
}

//---------------------------------------------------------
//	OrderAllFallIn
//---------------------------------------------------------
function OrderAllFallIn()
{
	if( MyUnitController != None )
	{
		MyUnitController.OrderAllFallIn();
	}
	else
	{
		AttachAllSubUnits();
	}

	if( TargetOrderIcon != None )
	{
		TargetOrderIcon.Destroy();
		//TargetOrderIcon = None;
		SetTargetOrderIcon( None );
	}
}

//---------------------------------------------------------
//	OrderManTurret
//---------------------------------------------------------
function OrderManTurret( TurretWeapon Turret )
{
	if( MyUnitController != None )
	{
		MyUnitController.OrderManTurret( Turret );
	}

	if( TargetOrderIcon != None )
	{
		TargetOrderIcon.Destroy();
		//TargetOrderIcon = None;
		SetTargetOrderIcon( None );
	}
}

//---------------------------------------------------------
//	SetFormationCenterWithMinimalMovement
//---------------------------------------------------------
function SetFormationCenterWithMinimalMovement( vector newCenter, optional bool bThisIsAnOrder )
{
	local ActorLite nearestNav;
	local vector FCLoc;

	if (FormationCenter.bIsNavigationPoint)
		FCLoc = NavigationPoint(FormationCenter).Location;
	else if (FormationCenter.bIsNavigationPointLite)
		FCLoc = NavigationPointLite(FormationCenter).Location;

	if( FormationCenter == None || VSize( newCenter - FCLoc ) > RemainHereCloseEnoughDist )
	{
		nearestNav = GetNearestNavpoint( newCenter, -1.0f, false, true );

		if( nearestNav != None )
		{
			if( bThisIsAnOrder )
			{
				OrderMove( nearestNav );
			}
			else
			{
				SetFormationCenter( nearestNav );
			}
		}
	}
}

//---------------------------------------------------------
//	SetFormationCenterNearCurrentCentroid
//---------------------------------------------------------
function SetFormationCenterNearCurrentCentroid( optional bool bThisIsAnOrder )
{
	// Overrides the unit's existing formation center in order to try to keep the unit basically where it now is.
	// If the formation center is close to where the unit now is, it goes unchanged.
	// Otherwise, the formation center is set to the navpoint nearest the unit centroid.

	SetFormationCenterWithMinimalMovement( GetUnitCentroid(), bThisIsAnOrder );
}

//---------------------------------------------------------
//	Awaken
//---------------------------------------------------------
function Awaken()
{
	local class<UnitController> UnitControllerClass;
	local class<InWorldUnitIcon>	InWorldIconClass;

	CalculateUnitCentroid();

	if ((MyUnitController == None) && (Leader != None))
	{
		if (Leader.IsA('Infantry'))
			UnitControllerClass = class<UnitController>( DynamicLoadObject("gbxAI.UnitControllerAIInfantry", class'Class'));
		else if (Leader.IsA('Tank'))
			UnitControllerClass = class<UnitController>( DynamicLoadObject("gbxAI.UnitControllerAITank", class'Class'));

		if (UnitControllerClass != None)
		{
			MyUnitController = Spawn( UnitControllerClass );
			MyUnitController.Possess( Self );
		}
	}

	// GBX:PAD: It appears that the game type is not set right off the bat in the game, so sometimes a German squad might
	// be spawned in before the GameType field is set, so this check will fail.  Instead, since this is server only, I'm
	// going to check to see that the game actor is actually a WargameSkirmish actor.
//	if ((Level.NetMode == NM_StandAlone) || (Level.GetLocalPlayerController().GameReplicationInfo.GameType == GT_Skirmish))
	if ((Level.NetMode == NM_StandAlone) || (Level.Game.IsA('WargameSkirmish')))
	{
		if( MyInWorldIcon == None && MyInWorldIconClass != "" )
		{
			InWorldIconClass = class<InWorldUnitIcon>( DynamicLoadObject( MyInWorldIconClass, class'Class' ));
			MyInWorldIcon = Spawn( InWorldIconClass,,, GetUnitCentroid() );
			MyInWorldIcon.MyUnit = self;
			MyInWorldIcon.ClockColorUnsuppressed=MyInWorldIconBaseColor;
		}
	}
}

//---------------------------------------------------------
//	GoToSleep
//---------------------------------------------------------
function GoToSleep()
{
	if( MyUnitController != None )
	{
		MyUnitController.Destroy();
		MyUnitController = None;
	}

	if( MyInWorldIcon != None )
	{
		MyInWorldIcon.HideAndDestroy();
		MyInWorldIcon = None;
	}

	if( TargetOrderIcon != None )
	{
		TargetOrderIcon.HideAndDestroy();
		//TargetOrderIcon = None;
		SetTargetOrderIcon( None );
	}

}

//---------------------------------------------------------
//	IsLeaderHumanPlayer
//---------------------------------------------------------
simulated function bool IsLeaderHumanPlayer()
{
	local bool rslt;
	
	rslt = false;
	if (Leader != None)
	{
		if (Level.NetMode != NM_Client)
		{
			rslt = (gbxPlayerController( Leader.Controller ) != None);
		}
		else
		{
			//SDJ 05/29/2004: It sucks, but without replicating controllers the client has no other way to tell if this pawn is a player.
			rslt = Leader.IsA('gbxPlayerPawn');
		}
	}
	
	return rslt;
}

//---------------------------------------------------------
//	SameTeamAs
//---------------------------------------------------------
simulated function bool SameTeamAs( Pawn aPawn )
{
	return Leader == None || Leader.SameTeamAs( aPawn );
}

//---------------------------------------------------------
//	SameTeamAsIgnoreNeutrals
//---------------------------------------------------------
// GBX:naj - Wanted to provide a version of SameTeamAs() that required strong membership, not considering TEAM_None to be on the same team as TEAM_USA.
simulated function bool SameTeamAsIgnoreNeutrals( Pawn aPawn )
{
	return Leader != None && Leader.PawnTeam != TEAM_None && aPawn.PawnTeam != TEAM_None && Leader.SameTeamAs( aPawn );
}

//---------------------------------------------------------
//	SameTeamAsUnit
//---------------------------------------------------------
simulated function bool SameTeamAsUnit( Unit aUnit )
{
	return Leader == None || Leader.SameTeamAs( aUnit.Leader );
}

//---------------------------------------------------------
//	SameTeamAsUnitIgnoreNeutrals
//---------------------------------------------------------
// GBX:naj - Wanted to provide a version of SameTeamAs() that required strong membership, not considering TEAM_None to be on the same team as TEAM_USA.
simulated function bool SameTeamAsUnitIgnoreNeutrals( Unit aUnit )
{
	return Leader != None && Leader.PawnTeam != TEAM_None && aUnit.Leader.PawnTeam != TEAM_None && Leader.SameTeamAs( aUnit.Leader );
}

//---------------------------------------------------------
//	IsUnitKnown
//---------------------------------------------------------
function bool IsUnitKnown( Unit aUnit )
{
	return MyUnitController.IsUnitKnown( aUnit );
}

//---------------------------------------------------------
//	IsAttachedToSuperUnit
//---------------------------------------------------------
simulated function bool IsAttachedToSuperUnit()
{
	return bAttachedToSuperUnit;
}

//---------------------------------------------------------
//	AttachToSuperUnit
//---------------------------------------------------------
function AttachToSuperUnit()
{
	if( SuperUnit != None )
		bAttachedToSuperUnit = true;
}

//---------------------------------------------------------
//	DetachFromSuperUnit
//---------------------------------------------------------
function DetachFromSuperUnit()
{
	bAttachedToSuperUnit = false;
}

//---------------------------------------------------------
//	DetachFromSuperUnitComplete
//---------------------------------------------------------
function AttachToSuperUnitComplete( Unit aSuperUnit )
{
	local	int	nIdx;

	if ((aSuperUnit == None) || (aSuperUnit == SuperUnit) || (aSuperUnit.NumSubUnits == MAX_SUBUNITS))
	{
		return;
	}

	for (nIdx = 0; nIdx < aSuperUnit.NumSubUnits; nIdx++)
	{
		if (aSuperUnit.SubUnits[ nIdx ] == self)
		{
			return;
		}
	}

	if (SuperUnit != None)
	{
		DetachFromSuperUnitComplete();
	}

	aSuperUnit.AddSubUnit( self );

	if( bFallInOnStartup )
		AttachToSuperUnit();
}

//---------------------------------------------------------
//	DetachFromSuperUnitComplete
//---------------------------------------------------------
function DetachFromSuperUnitComplete()
{
	local	int	nIdx, nIdxSubUnit;
	
	if (SuperUnit == None)
	{
		return;
	}
	for (nIdx = 0; nIdx < SuperUnit.NumSubUnits; nIdx++)
	{
		if (SuperUnit.SubUnits[ nIdx ] == self)
		{
			nIdxSubUnit = nIdx;
			break;
		}
	}
	if (nIdx == SuperUnit.NumSubUnits)
	{
		return;
	}
	if (nIdx < (SuperUnit.NumSubUnits - 1))
	{
		for (nIdx = nIdxSubUnit; nIdx < SuperUnit.NumSubUnits; nIdx++)
		{
			SuperUnit.SubUnits[ nIdx ] = SuperUnit.SubUnits[ nIdx + 1 ];
		}
	}
	SuperUnit.SubUnits[ SuperUnit.NumSubUnits - 1 ] = None;
	SuperUnit.NumSubUnits = SuperUnit.NumSubUnits - 1;
	bAttachedToSuperUnit = false;
}

//---------------------------------------------------------
//	AttachAllSubUnits
//---------------------------------------------------------
function AttachAllSubUnits()
{
	local int i;

	for( i = 0; i < MAX_SUBUNITS; ++i )
	{
		if( SubUnits[i] != None )
		{
			if ( (SubUnits[i].MyUnitController == None) || SubUnits[i].MyUnitController.ShouldAttachToSuperUnit() )
			{
				SubUnits[i].AttachToSuperUnit();
			}
		}
	}
}

//---------------------------------------------------------
//	DetachAllSubUnits
//---------------------------------------------------------
function DetachAllSubUnits()
{
	local int i;

	for( i = 0; i < MAX_SUBUNITS; ++i )
	{
		if( SubUnits[i] != None )
		{
			SubUnits[i].DetachFromSuperUnit();
		}
	}
}
//---------------------------------------------------------
//	GetNumLivingMembers
//---------------------------------------------------------
simulated function int GetNumLivingMembers( optional bool bCountSubunitMembers )
{
	local int i, nLiving;

	nLiving = 0;

	for( i = 0; i < NumMembers; i++ )
	{
		if( Members[i] != None && !Members[i].IsDead() )
		{
			++nLiving;
		}
	}

	if( bCountSubunitMembers )
	{
		for( i = 0; i < NumSubUnits; i++ )
		{
			if( SubUnits[ i ] != None )
			{
				nLiving += SubUnits[ i ].GetNumLivingMembers( bCountSubunitMembers );
			}
		}
	}

	return nLiving;
}

//---------------------------------------------------------
//	IsTooFarFromSuperUnit
//---------------------------------------------------------
function bool IsTooFarFromSuperUnit( Vector MemberLoc )
{
	if ( !bAttachedToSuperUnit )
		return false;

	return ( VSize( MemberLoc - SuperUnit.Leader.Location ) > TooFarFromSuperUnitDist );
}

//---------------------------------------------------------
//	AnyLivingMembers
//---------------------------------------------------------
simulated function bool AnyLivingMembers()
{
	return GetNumLivingMembers() > 0;
}

simulated function bool AnyStaticMembers()
{
	local int index;
	
	// find the formation position for this new member...
	for (index = 0; index < NumMembers; index++ )
	{
		if (Members[index] != None)
		{
			if (Members[Index].StaticMesh != None)
				return true;
		}
	}
	return false;
}

//---------------------------------------------------------
//	AddDeadMember
//---------------------------------------------------------
function AddDeadMember()
{
	if (bMaxUnitCount < MAX_MEMBERS)
	{
		bMaxUnitCount = bMaxUnitCount + 1;
	}
}

//---------------------------------------------------------
//	AddMember
//---------------------------------------------------------
function AddMember( gbxPawn newMember )
{
	local int index;
	local int formation_position;
	local int max_formation_position;
	local ActorLite closestNavPoint;

	if( newMember == None )
	{
		Warn( "WARNING: " $ class $ ".AddMember( None ) attempted to add NULL member." );
		return;
	}

	if( Leader != None )
	{
		if (!newMember.SameTeamAs(Leader))
		{
			Warn( "WARNING: Attempting to add a new member on a different team than the Unit's leader: newMember=" $ newMember.name $ ", leader=" $ Leader.name);
			return;
		}
	}

	if( FindMember( newMember ) < 0 )
	{
		if ( numMembers >= MAX_MEMBERS )
		{
			Warn( "WARNING: Attempted to add a new member("$newMember.Tag$") to a full unit. NumMembers = " $ NumMembers $ ", MAX_MEMBERS = " $ MAX_MEMBERS);
			return;
		}
	
		// GBX:PAD: There was a problem where, when guys at a later checkpoint were assigned to the same unit as a
		// previous checkpoint, they would run back to that unit location.  I'm putting this in to force the unit location to
		// update to the location of the first member added to the unit, and to face in his direction.
		if (numMembers == 0)
		{
			SetLocation( newMember.Location );
			closestNavPoint = GetNearestNavpoint( Location, -1.0f, false, true );

			FormationYaw = newMember.Rotation.Yaw;  // just assign an arbitrary facing direction
			PreviousFormationYaw = FormationYaw;

			SetFormationCenter( closestNavPoint );
		}
	
		max_formation_position = -1;

		// find the formation position for this new member...
		for (index = 0; index < NumMembers; index++ )
		{
			if (Members[index] != None)
			{
				formation_position = Members[index].GetFormationPosition();

				if (formation_position > max_formation_position)
					max_formation_position = formation_position;
			}
		}

		newMember.SetFormationPosition(max_formation_position + 1);

		NumMembers = NumMembers + 1;
		if (bMaxUnitCount < MAX_MEMBERS)
		{
			bMaxUnitCount = bMaxUnitCount + 1;
		}
		
		Members[ NumMembers - 1 ] = newMember;

		newMember.MyUnit = self;
	}

	// If no leader yet chosen, force this guy to be leader.
	if( Leader == None )
	{
		SetLeader( newMember );
	}

	// GBX:naj - Now is a good opportunity to find out if this is a U.S. unit.
	// If so, make them the highest possible skill level.
	// Only do this for singleplayer games 2004-04-20 JWS
	// Moved code from PostBeginPlay here 2004-08-25 NAJ
	//
	log( self$ "Unit::AddMember() About to set BaseSkillLevel...", 'MP' );
	if ((Level != None) && ((Level.NetMode == NM_Standalone) || (Level.NetMode != NM_Standalone && Level.Game.IsA('WargameSkirmish'))) )
	{
		// GBX:PAD: I've changed this around a little to use the PawnOnSameTeam check rather than checking against TEAM_US
		// when setting a unit with the map unit skill level.  This should make sure that the "opposing team" in multiplayer
		// will be set correctly.
		if ( Level.Game.IsPawnOnSameTeamAsPlayerByEnum(newMember.PawnTeam) )
		{
			if ( BaseSkillLevel != SKILL_Invincible )
			{
				log( self$ "Unit::AddMember() setting BaseSkillLevel to SKILL_Invincible", 'MP' );
				BaseSkillLevel = SKILL_Invincible;
			}
		}
		else if (Level.bUseLevelUnitSkillLevel)
		{
			log( self$ "Unit::AddMember() setting BaseSkillLevel to Level.BaseUnitSkillLevel: "$Level.BaseUnitSkillLevel, 'MP' );
			BaseSkillLevel = Level.BaseUnitSkillLevel;
		}
	}

	Awaken();

	if( MyUnitController != None )
	{
		MyUnitController.NotifyMemberAdded( newMember );
	}

	// GBX:PAD: Make sure the member being added doesn't need to "slow down the group".
//	PropegateEncumberance();
}

//---------------------------------------------------------
//	RemoveMember
//---------------------------------------------------------
function RemoveMember( gbxPawn Member )
{
	local int ndx;
	local int index;
	local int formation_position, member_position;

	ndx = FindMember( Member );

	if( ndx >= 0 )
	{
		// shuffle all remaining formation positions up 1 or 2 slots (depending on current formation)...

		if (Member != Leader)  // leader being removed is handled separately
		{
			if (FormationType == Formation_Column)
			{
				formation_position = Member.GetFormationPosition();

				// shuffle all members up in the formation up 1 position...
				for (index = 0; index < NumMembers; index++ )
				{
					if (Members[index] != None)
					{
						member_position = Members[index].GetFormationPosition();

						// is this member higher in the formation?
						if (member_position > formation_position)
						{
							Members[index].SetFormationPosition(member_position - 1);
						}
					}
				}
			}
			else if ((FormationType == Formation_Line) || (FormationType ==	Formation_Wedge) ||
					 (FormationType == Formation_Vee))
			{
				formation_position = Member.GetFormationPosition();

				// shuffle the members on the same side of leader up in the formation...
				for (index = 0; index < NumMembers; index++ )
				{
					if (Members[index] != None)
					{
						member_position = Members[index].GetFormationPosition();

						// is this member higher in the formation and on the same side of leader?
						if ((member_position > formation_position) &&
							((formation_position % 2) == (member_position % 2)))
						{
							Members[index].SetFormationPosition(member_position - 2);
						}
					}
				}
			}
		}

		Member.MyUnit = None;
		RemoveMemberFromArray( ndx );
	}

	// Tell the super unit to remove me if I've become empty
	if( NumSubUnits == 0 && NumMembers == 0 && SuperUnit != None && !bDontRemoveEmptyUnit)
	{
		if (Level.Game.GameReplicationInfo.GameType == GT_Multiplayer)
		{
			bMaxUnitCount = 0;
		}
		SuperUnit.RemoveSubUnit( self );
		GoToSleep();
	}

	if( Member == Leader )
	{
		Leader = None;
		PickNewLeader();
	}

	// GBX:PAD: Make sure the member that was removed wasn't "slowing down the group".
//	PropegateEncumberance();
}

//---------------------------------------------------------
//	RemoveMemberFromArray
//---------------------------------------------------------
function RemoveMemberFromArray( int indexToRemove )
{
	local int i;
	
	if ((indexToRemove >= 0) && (indexToRemove < MAX_MEMBERS))
	{	
		Members[indexToRemove] = None;
		for( i = indexToRemove + 1; i < NumMembers; ++i )
		{
			Members[ i - 1 ] = Members[ i ];
			Members[ i ] = None;
		}
		
		NumMembers--;
	}
}

//---------------------------------------------------------
//	PickNewLeader
//---------------------------------------------------------
function PickNewLeader()
{
	local gbxPawn newLeader;
	local int index;
	local int formation_position, member_position;
	local float OneRank, MaxRank;
	
	if( Leader == None && NumMembers > 0 )
	{
		// GBX:naj - modified to pick the new leader based on his rank (See bug 7714).
		MaxRank = -1.0f;
		for ( index = 0; index < NumMembers; index++ )
		{
			if (Members[index] != None)
			{
				OneRank = Members[index].GetCharacterRank();
				if ( OneRank > MaxRank )
				{
					MaxRank = OneRank;
					newLeader = Members[index];
				}
			}
		}

		if (FormationType == Formation_Column)
		{
			// get the new leader's current formation position...
			formation_position = newLeader.GetFormationPosition();

			newLeader.SetFormationPosition(0);

			// shuffle all members up in the formation up 1 position...
			for (index = 0; index < NumMembers; index++ )
			{
				if (Members[index] != None)
				{
					member_position = Members[index].GetFormationPosition();

					// is this member higher in the formation?
					if (member_position > formation_position)
					{
						Members[index].SetFormationPosition(member_position - 1);
					}
				}
			}
		}
		else if ((FormationType == Formation_Line) || (FormationType ==	Formation_Wedge) ||
			 (FormationType == Formation_Vee))
		{
			// get the new leader's current formation position...
			formation_position = newLeader.GetFormationPosition();

			newLeader.SetFormationPosition(0);

			// shuffle the members on the same side as new leader up in the formation...
			for (index = 0; index < NumMembers; index++ )
			{
				if (Members[index] != None)
				{
					member_position = Members[index].GetFormationPosition();

					// is this member higher in the formation and on the same side of leader?
					if ((member_position > formation_position) &&
						((formation_position % 2) == (member_position % 2)))
					{
						Members[index].SetFormationPosition(member_position - 2);
					}
				}
			}
		}

		SetLeader( newLeader );
	}
}

//---------------------------------------------------------
//	SetLeader
//---------------------------------------------------------
function SetLeader( gbxPawn newLeader )
{
	local int index;
	local int formation_position;
	local int max_formation_position;

	if( newLeader == None )
	{
		Log( "WARNING: " $ class $ ".SetLeader( None ) attempted to set NULL leader.", 'Unit' );
		return;
	}

	if (newLeader == Leader)
		return;  // trying to set the leader to the pawn who's already the leader

	newLeader.SetFormationPosition(0);  // new leader will be in position 0

	// is there already a leader (and it's not me)?
	if (Leader != None)
	{
		max_formation_position = -1;

		// find the max formation position...
		for (index = 0; index < NumMembers; index++ )
		{
			if (Members[index] != None)
			{
				formation_position = Members[index].GetFormationPosition();

				if (formation_position > max_formation_position)
					max_formation_position = formation_position;
			}
		}

		Leader.SetFormationPosition(max_formation_position + 1);
	}

	Leader = newLeader;

	AddMember( newLeader );	// This is conditional, so won't add anything if leader is already a member.

	Leader.BecomingLeader( self );
}

//---------------------------------------------------------
//	SetFormationCenter
//---------------------------------------------------------
function SetFormationCenter( ActorLite navPoint )
{
	local Unit OtherUnit;
	local float distance;
	local int NumMembersInRadius;
	local vector OtherUnitFCLoc;
	local vector UnitFCLoc;
	local int i;

	if ((FormationCenter != navPoint) && (navPoint != None))
	{
		NumMembersInRadius = NumMembers;

		// save the previous formation center and direction before overwriting it...
		PreviousFormationCenter = FormationCenter;

		FormationCenter = navPoint;

		// set the size of my FormationRadius based on number of members in my unit...
		FormationRadius = MinFormationRadius + (NumMembers * FormationRadiusMemberScale);

		// if this unit gets within FormationRadius of another unit, increase this unit's FormationRadius...
		ForEach DynamicActors( class'Unit', OtherUnit )
		{
			if ((OtherUnit != self) && SameTeamAsUnit(OtherUnit))
			{
				if (OtherUnit.FormationCenter != None)
				{
					if (OtherUnit.FormationCenter.bIsNavigationPoint)
						OtherUnitFCLoc = NavigationPoint(OtherUnit.FormationCenter).Location;
					else if (OtherUnit.FormationCenter.bIsNavigationPointLite)
						OtherUnitFCLoc = NavigationPointLite(OtherUnit.FormationCenter).Location;

					if (FormationCenter.bIsNavigationPoint)
						UnitFCLoc = NavigationPoint(FormationCenter).Location;
					else if (FormationCenter.bIsNavigationPointLite)
						UnitFCLoc = NavigationPointLite(FormationCenter).Location;

					distance = VSize(OtherUnitFCLoc- UnitFCLoc);

					if ((distance < FormationRadius) || (distance < OtherUnit.FormationRadius))
					{
						NumMembersInRadius = NumMembers + OtherUnit.NumMembers;
						FormationRadius = MinFormationRadiusCombine + (NumMembersInRadius * FormationRadiusMemberScaleCombine);
					}
				}
			}
		}

		CalculateDummyThreat( navPoint );
		
		if( MyUnitController != None )
		{
			MyUnitController.NotifyFormationCenterChange(NumMembersInRadius);
		}

		// notify any attached subunits that the formation center has changed...
		for ( i = 0; i < MAX_SUBUNITS; ++i )
		{
			if ( (SubUnits[i] != None) && SubUnits[i].IsAttachedToSuperUnit() )
			{
				if (SubUnits[i].MyUnitController != None)
				{
					SubUnits[i].MyUnitController.NotifyFormationCenterChange(NumMembersInRadius);
				}
			}
		}
	}
}

//---------------------------------------------------------
//	ExpandFormationRadius
//---------------------------------------------------------
function bool ExpandFormationRadius()
{
	LogSelective( "ExpandFormationRadius()." );

	if ( FormationRadius >= MaxFormationRadius )
	{
		LogSelective( "ExpandFormationRadius(): FormationRadius "$FormationRadius$" is already maxed out.  Returning false." );
		return false;
	}
	else
	{		
		FormationRadius = Clamp( FormationRadius + FORMCExpansionSize, 0, MaxFormationRadius );
		LogSelective( "ExpandFormationRadius(): FormationRadius has been expanded to "$FormationRadius$"." );
		MyUnitController.NotifyFormationRadiusIncreased();
		return true;
	}
}

//---------------------------------------------------------
//	SetFormationDirection
//---------------------------------------------------------
function SetFormationDirection(int FormationDir)
{
	PreviousFormationYaw = FormationYaw;  // save the current direction as previous direction
	FormationYaw = FormationDir;
}

//---------------------------------------------------------
//	SetTargetUnit
//---------------------------------------------------------
simulated function SetTargetUnit( Unit targetUnit )
{
	local int i;

	if (Role < ROLE_Authority)
	{
		ClientSetTargetUnit_Hack( targetUnit );
		return;
	}

	if ( AssignedTargetUnit != None && targetUnit == None )
	{
		AssignedTargetUnit.NotifyUnTargetedBy( Self );

		for( i = 0; i < NumMembers; ++i )
		{
			if ( Members[ i ].Controller.IsA('gbxAIController'))
				gbxAIController( Members[ i ].Controller ).NotifyTargetOrderRemoved();
		}
	}

	AssignedTargetUnit = targetUnit;
	TargetOrderTime = Level.TimeSeconds;
}

simulated function ClientSetTargetUnit_Hack( Unit targetUnit )
{
	local gbxPlayerController PC;
	
	if ( Role < ROLE_Authority )
	{
		PC = GetControllingPlayerController();
		if ( PC != None && PC.GameReplicationInfo.GameType == GT_SKIRMISH )
		{
			if ( AssignedTargetUnit != None && targetUnit == None )
			{
				AssignedTargetUnit.NotifyUnTargetedBy( Self );
			}

			AssignedTargetUnit = targetUnit;
			TargetOrderTime = Level.TimeSeconds;
		}
	}
}


simulated function SetTargetOrderIcon( InWorldOrderIconBase NewOrderIcon )
{
	TargetOrderIcon = NewOrderIcon; 
	if ( TargetOrderIcon != None )
	{
		if ( AssignedTargetUnit != None )
		{
			AssignedTargetUnit.NotifyTargetedBy( Self );
		}
	}	
	else
	{
		if (AssignedTargetUnit!=None)
		{
			AssignedTargetUnit.NotifyUnTargetedBy(Self);
		}
	}
}

simulated function NotifyTargetedBy( Unit TargetingUnit )
{
	if (MyInWorldIcon != None)
	{
		MyInWorldIcon.setTargeted(TargetingUnit);
/*		if (TargetingUnit.bAssaultingTargetUnit)
			MyInWorldIcon.bUnderAssault=true;
		else
			MyInWorldIcon.bUnderAssault=false;
*/	
	}
}

simulated function NotifyUnTargetedBy( Unit TargetingUnit )
{
	if (MyInWorldIcon != None)
	{
		MyInWorldIcon.setUntargeted(TargetingUnit);
	}
}


//---------------------------------------------------------
//	FindMember
//---------------------------------------------------------
function int FindMember( gbxPawn possibleMember )
{
	local int i;
	for( i = 0; i < NumMembers; ++i )
	{
		if( Members[ i ] == possibleMember )
		{
			return i;
		}
	}
	return -1;
}

//---------------------------------------------------------
//	IsPawnWithinUnit
//---------------------------------------------------------
simulated function bool IsPawnWithinUnit( gbxPawn possibleSubordinate )
{
	// Returns true if the given pawn is within this unit or a subunit.

	local int i;
	for( i = 0; i < NumMembers; ++i )
	{
		if( (Members[ i ] == possibleSubordinate) || (Members[ i ].ContainsPawn(possibleSubordinate)) )
		{
			return true;
		}
	}

	for( i = 0; i < NumSubUnits; ++i )
	{
		if( SubUnits[ i ] != None && SubUnits[ i ].IsPawnWithinUnit( possibleSubordinate ))
		{
			return true;
		}
	}

	return false;
}

//---------------------------------------------------------
//	IsSubUnit
//---------------------------------------------------------
simulated function bool IsSubUnit( Unit aUnit )
{
	local int i;

	if( aUnit == None )
	{
		return false;
	}

	if( NumSubUnits > MAX_SUBUNITS )
	{
		Warn( "WARNING: " $ class $ ".IsSubUnit( " $ aUnit $ " ) failed: too many sub-units." );
	}

	for( i = 0; i < NumSubUnits; ++i )
	{
		if( SubUnits[ i ] == aUnit )
		{
			return true;
		}
		else if( SubUnits[ i ] != None && SubUnits[ i ].IsSubUnit( aUnit ))
		{
			return true;
		}
	}

	return false;
}

//---------------------------------------------------------
//	AddSubUnit
//---------------------------------------------------------
function AddSubUnit( Unit subUnit )
{
	if( NumSubUnits >= MAX_SUBUNITS )
	{
		Warn( "WARNING: " $ class $ ".AddSubUnit( " $ subUnit $ " ) failed: too many sub-units." );
	}
	else
	{
		SubUnits[ NumSubUnits ] = subUnit;
		++NumSubUnits;

		subUnit.SuperUnit = self;
		Awaken();
	}
}

//---------------------------------------------------------
//	RemoveSubUnit
//---------------------------------------------------------
function RemoveSubUnit( Unit subUnit )
{
	local int i;
	local bool bCopyDown;
	local gbxPlayerController PC;

	bCopyDown = false;

	PC = GetControllingPlayerController();

	for( i = 0; i < NumSubUnits; ++i )
	{
		if( SubUnits[ i ] == subUnit )
		{
			bCopyDown = true;
			SubUnits[ i ].SuperUnit = None;
			SubUnits[ i ] = None;

			PC.ClientSubUnitRemoved(i);

			// Adjust the player's addressee unit if necessary
			if( PC != None && PC.iAddresseeUnit > 0 && PC.iAddresseeUnit >= i )
				--PC.iAddresseeUnit;
		}
		else if( bCopyDown )
		{
			SubUnits[ i - 1 ] = SubUnits[ i ];
			SubUnits[ i ] = None;
		}
	}

	if( bCopyDown )
	{
		// The removal did actually take place.
		--NumSubUnits;
	}

	if( NumSubUnits == 0 && NumMembers == 0 )
	{
		GoToSleep();
	}
}

//---------------------------------------------------------
//	MoveMembersFromUnit
//---------------------------------------------------------
function MoveMembersFromUnit( Unit otherUnit, optional int nMembersToMove, optional bool bSkipLeader )
{
	local int i;

	// Moves nMembersToMove (0 means "all") from otherUnit to this unit, except the leader if requested.

	for( i = 0; i < otherUnit.NumMembers; ++i )
	{
		if( !bSkipLeader || otherUnit.Members[ i ] != otherUnit.Leader )
		{
			AddMember( otherUnit.Members[ i ] );
			otherUnit.RemoveMemberFromArray( i );
			--i;
			--nMembersToMove;

			if( nMembersToMove == 0 )
			{
				break;
			}
		}
	}
}

//---------------------------------------------------------
//	PromoteSubUnit
//---------------------------------------------------------
function PromoteSubUnit( int iSubUnit )
{
	// Move the index-specified subunit up into the members list and get rid of the unit.

	SubUnits[ iSubUnit ].PromoteAllSubUnits();
	MoveMembersFromUnit( SubUnits[ iSubUnit ],, false );
	RemoveSubUnit( SubUnits[ iSubUnit ] );
}

//---------------------------------------------------------
//	PromoteAllSubUnits
//---------------------------------------------------------
function PromoteAllSubUnits()
{
	// Recursively moves the members of all sub-units into this unit.

	local int i;

	for( i = 0; i < NumSubUnits; ++i )
	{
		SubUnits[ i ].PromoteAllSubUnits();
		MoveMembersFromUnit( SubUnits[ i ],, false );
		RemoveSubUnit( SubUnits[ i ] );
	}
}

//---------------------------------------------------------
//	DemoteMembersToNewSubUnit
//---------------------------------------------------------
function DemoteMembersToNewSubUnit()
{
	// Remove all members except the leader to a newly created sub unit.

	local Unit newSubUnit;

	if( NumSubUnits >= MAX_SUBUNITS )
	{
		Log( "WARNING: " $ class $ ".DemoteMembersToNewSubUnit() failed: too many sub-units." );
	}
	else
	{
		newSubUnit = Spawn( NormalSubUnitClass );

		newSubUnit.MoveMembersFromUnit( Self,, true );

		AddSubUnit( newSubUnit );
	}
}

//---------------------------------------------------------
//	TacticalSplit
//---------------------------------------------------------
function TacticalSplit( optional bool bSkipLeader )
{
	// Split this unit into sub-teams for tactical purposes.
	// Derived classes will no doubt override this function for greater tactical intelligence.

	// Arbitrarily put 30% (no less than 1 member) of the members into one sub unit,
	// 70% (no less than 1 member) into the other.

	local int nMembers, nMembersTeamA, nMembersTeamB;
	local Unit teamA, teamB;

	nMembers = NumMembers;
	if( bSkipLeader )
	{
		--nMembers;
	}

	// Can't do the split unless this unit has no subunits, and has enough members.
	if( NumSubUnits == 0 && nMembers >= 2 )
	{
		nMembersTeamA = Max( int( nMembers * 0.3 ), 1 );
		nMembersTeamB = Max( int( nMembers * 0.7 ), 1 );

		teamA = Spawn( NormalSubUnitClass );
		teamB = Spawn( NormalSubUnitClass );

		teamA.MoveMembersFromUnit( Self, nMembersTeamA, bSkipLeader );
		teamB.MoveMembersFromUnit( Self, nMembersTeamB, bSkipLeader );

		AddSubUnit( teamA );
		AddSubUnit( teamB );
	}
}

//---------------------------------------------------------
//	GetUnitCentroid
//---------------------------------------------------------
simulated function vector GetUnitCentroid()
{
	local Vector vecCentroid;	

	vecCentroid = UnitCentroid;

	if ((Role > ROLE_None) && (Role < ROLE_Authority))
	{
		if (m_flNextClientRecalcTime < Level.TimeSeconds)
		{
			//SDJ 05/15/2004: This is the only way a client recalculates a unit's centroid.
			CalculateUnitCentroid();
			m_flNextClientRecalcTime = Level.TimeSeconds + CLIENT_CENTROID_CALC_INTERVAL;
		}
	}
	
	return vecCentroid;
}

//---------------------------------------------------------
//	CalculateUnitCentroid
//---------------------------------------------------------
simulated function int CalculateUnitCentroid()
{
	local int i, totalWeight;
	local vector newUnitCentroid;

	totalWeight = 0;

	// Find subunit centroids.
	for( i = 0; i < NumSubUnits; ++i )
	{
		if( SubUnits[ i ] == None )
		{
			continue;
		}

		totalWeight += SubUnits[ i ].CalculateUnitCentroid();
		newUnitCentroid += SubUnits[ i ].GetUnitCentroid();
	}

	// Add member positions.
	for( i = 0; i < NumMembers; ++i )
	{
		if( Members[ i ] == None )
		{
			continue;
		}

		newUnitCentroid += Members[ i ].GetLocationAsIfStanding();
		++totalWeight;
	}

	if( totalWeight > 0 )
	{
		// Only update the unit centroid iff there are some members. Otherwise leave it where it was.
		newUnitCentroid /= totalWeight;
		UnitCentroid = newUnitCentroid;
	}

	return totalWeight;
}

//---------------------------------------------------------
//	GetUnitLeaderPosition
//---------------------------------------------------------
function vector GetUnitLeaderPosition()
{
	if( Leader != None )
	{
		return Leader.Location;
	}
	else
	{
		Log( name $ ".GetUnitLeaderPosition() called when Leader == None.", 'Unit' );
		return vect(0,0,0);
	}
}

//---------------------------------------------------------
//	PossessedBy
//---------------------------------------------------------
function PossessedBy( UnitController aUnitController )
{
	MyUnitController = aUnitController;
}

//---------------------------------------------------------
//	Destroyed
//---------------------------------------------------------
function Destroyed()
{
	local Controller C;
	local PlayerController PC;
	local gbxHUD myHUD;

	// remove this inspector from all HUDs (could be split screen on Xbox)...
	for ( C=Level.ControllerList; C!=None; C=C.NextController )
	{
		PC = PlayerController(C);
		if (PC != None)
		{
			myHUD = gbxHUD(PC.myHUD);

			if (myHUD != None)
			{
				MyHUD.RemoveInspector(self);
			}
		}
	}

	NotifyOrderTargetActors.Length = 0;
	NotifyOrderAssaultActors.Length = 0;
	NotifyOrderFallInActors.Length = 0;

	if( MyUnitController != None )
	{
		MyUnitController.Destroy();
	}

	if( MyInWorldIcon != None )
	{
		MyInWorldIcon.HideAndDestroy();
	}

	if( TargetOrderIcon != None )
	{
		TargetOrderIcon.HideAndDestroy();
	}

	Super.Destroyed();
}

//---------------------------------------------------------
//	ReceiveGBXMessage
//---------------------------------------------------------
function bool ReceiveGBXMessage( gbxMessage msg )
{
	local gbxMessageUnitMove move;
	local gbxMessageUnitTarget target;
	local Unit aUnit;

	move = gbxMessageUnitMove( msg );

	if( move != None )
	{
		OrderMove( move.MoveLocation );
	}
	else
	{
		target = gbxMessageUnitTarget( msg );
		if( target != None )
		{
			// Find the unit specified by the message.
			foreach DynamicActors( class'Unit', aUnit, target.TargetUnitTag )
			{
				break;
			}

			OrderTarget( aUnit );
		}
	}

	return false;	// Not storing this message away.
}

//---------------------------------------------------------
//	GetUnitEffectiveness
//---------------------------------------------------------
simulated function int GetUnitEffectiveness()
{
	local int	nHealth, nMemberHealth, i;

	if ((NumMembers <= 0) || (bMaxUnitCount == 0))
		return 0;

	nHealth = 0;
	for( i = 0; i < NumMembers; ++i )
	{
		nMemberHealth = 100.0 * (float(Members[i].Health) / float(Members[i].Default.Health));
		if (nMemberHealth >= 80)
			nHealth += 3;
		else if (nMemberHealth >= 50)
			nHealth += 2;
		else if (nMemberHealth >= 30)
			nHealth += 1;
	}

	nHealth = nHealth / bMaxUnitCount;

	return nHealth;
}

//---------------------------------------------------------
//	PropegateEncumberance
//---------------------------------------------------------
// GBX:PAD: Propegate the encumberance of the slowest unit member to all other unit members.  This will get called when
// any unit member switches weapons, or when a new character is assigned to or removed from the unit.
simulated function PropegateEncumberance()
{
	local int	i;
	local float	flMaxEncumberance;
	local bool	fCanSprint;

	if ((NumMembers <= 0) || (bMaxUnitCount == 0))
		return;

	flMaxEncumberance = 1.0;
	fCanSprint = true;
	for( i = 0; i < NumMembers; ++i )
	{
		if (Members[i].Weapon != None)
		{
			if (Members[i].Weapon.m_flEncumberance < flMaxEncumberance)
				flMaxEncumberance = Members[i].Weapon.m_flEncumberance;
		
			if (fCanSprint && (Members[i].Weapon.m_fCanSprint == false))
				fCanSprint = false;
		}
	}

	for( i = 0; i < NumMembers; ++i )
	{
		Members[i].m_flEncumberance = flMaxEncumberance;
		Members[i].m_fCanSprint = fCanSprint;
	}
}

//---------------------------------------------------------
//	MemberGainedMachineGun
//---------------------------------------------------------
function MemberGainedMachineGun( gbxPawn Member )
{
	NumMachineGunsInUnit++;
}

//---------------------------------------------------------
//	MemberLostMachineGun
//---------------------------------------------------------
function MemberLostMachineGun( gbxPawn Member )
{
	NumMachineGunsInUnit--;
}

//---------------------------------------------------------
//	HasVehicles
//---------------------------------------------------------
simulated function bool HasVehicles()
{
	local int i;

	for( i = 0; i < NumMembers; ++i )
	{
		if( Members[ i ].IsA( 'gbxSVehicle' ))
		{
			return true;
		}
	}

	return false;
}

//---------------------------------------------------------
//	HasMachineGun
//---------------------------------------------------------
simulated function bool HasMachineGun()
{
	return ( NumMachineGunsInUnit > 0 );
}

//---------------------------------------------------------
//	HasMortar
//---------------------------------------------------------
simulated function bool HasMortar()
{
	local int i;

	for( i = 0; i < NumMembers; ++i )
	{
		if( Members[ i ].bIsManningTurret && Members[ i ].Turret.IsMortar() )
		{
			return true;
		}
	}

	return false;
}

//---------------------------------------------------------
//	HasArtillery
//---------------------------------------------------------
simulated function bool HasArtillery()
{
	local int i;

	for( i = 0; i < NumMembers; ++i )
	{
		if( Members[ i ].bIsManningTurret && Members[ i ].Turret.IsAntiTank() ||
			Members[ i ].bIsManningTurret && Members[ i ].Turret.IsAntiAir() ||
			Members[ i ].bIsManningTurret && Members[ i ].Turret.IsMortar() ||
			Members[ i ].bIsManning88 && Members[ i ].Turret.IsPak88() )
		{
			return true;
		}
	}

	return false;
}

//---------------------------------------------------------
//	GetHumanReadableName
//---------------------------------------------------------
simulated function String GetHumanReadableName()
{
	if ( TitleString == "" )
		return Super.GetHumanReadableName();
	return TitleString;
}

//---------------------------------------------------------
//	AllowPawnToJoin
//---------------------------------------------------------
//SDJ 03/12/2004: Interface giving the unit an oportunity to reject a pawn.  Used in MP to limit player's to specific units.
function bool AllowPawnToJoin(Pawn pawn)
{
	return true;
}

//---------------------------------------------------------
//	DoSuppressionGrenade
//---------------------------------------------------------
function DoSuppressionGrenade()
{
	MyUnitController.DoSuppressionGrenade();
}

//---------------------------------------------------------
//	DoGradedSuppressionGrenade
//---------------------------------------------------------
function DoGradedSuppressionGrenade( float Intensity )
{
	MyUnitController.DoGradedSuppressionGrenade( Intensity );
}

//---------------------------------------------------------
//	NotifyGrenadeExploded
//---------------------------------------------------------
function NotifyGrenadeExploded( Pawn Thrower )
{
	if ( MyUnitController != None )
	{
		MyUnitController.NotifyGrenadeExploded( gbxPawn( Thrower ) );
	}
}

//---------------------------------------------------------
//	ClientClearTargetOrderIcon
//---------------------------------------------------------
simulated function ClientClearTargetOrderIcon()
{
	if (Role < ROLE_Authority)
	{
		if( TargetOrderIcon != None )
		{
			TargetOrderIcon.Destroy();
			TargetOrderIcon = None;
		}
	}
}

// For MP hud reinforcement effects 
simulated function ActivateReinforcementsEffect( gbxPlayerController PC )
{
	local MultiplayerUnit mpUnit;
	mpUnit = MultiplayerUnit(self);

	// Make sure we only activate this for the controller who owns this guy
	if ( PC.PlayerReplicationInfo != None )
	{
		if ( (mpUnit.Team == PC.PlayerReplicationInfo.Team.TeamIndex) && 
			 (mpUnit.TeamMemberId == PC.PlayerReplicationInfo.TeamID) )
		{
			// We care about this unit so do what you came to do...	
			// Reset timer
			fReinforcementsEffectTimeRemaining = fReinforcementsEffectDuration;

			// Play sound
			PC.ActivateReinforcementsEffect();
		}
	}
}

simulated function float GetReinforcementsEffectTimeRemaining()
{
	return fReinforcementsEffectTimeRemaining;
}

simulated function float GetReinforcementsEffectDuration()
{
	return fReinforcementsEffectDuration;
}

function bool TryToStealTeammatesNavPoint( gbxPawn aMember, out gbxPawn Teammate, out ActorLite NewNavPoint )
{
	if ( MyUnitController != None )
		return MyUnitController.TryToStealTeammatesNavPoint( aMember, Teammate, NewNavPoint );
	else
		return false;
}

function KillMembers(bool processSubUnits)
{
	local int i;

	if (processSubUnits)
	{
		for( i = NumSubUnits-1; i >= 0; --i )
		{
			if (SubUnits[i] != None)
			{
				SubUnits[i].KillMembers(false);
			}
		}
	}

	// Do it backwards to avoid leaving a guy behind
	for( i = NumMembers-1; i >= 0; --i )
	{
		Members[i].KilledBy(Members[i]);
	}
}

function NotifyTeammatesOfTarget( gbxPawn Sender, gbxPawn Target )
{
	MyUnitController.NotifyTeammatesOfTarget( Sender, Target );
}

function float GetBoldnessModifier()
{
	// TBD: If any of our members have an MG42 or similar machine gun, this causes them to feel "bolder," and less suppressible.
	if ( HasMachineGun() )
		return MachineGunBoldnessMultiplier;
	else
		return 1.0;
}

function SpawnPerceptionPlayerHit( gbxPawn PlayerPawn )
{
	if ( MyUnitController != None )
		MyUnitController.SpawnPerceptionPlayerHit( PlayerPawn );
}

function SpawnPerceptionPlayerWarningShot( gbxPawn PlayerPawn )
{
	if ( MyUnitController != None )
		MyUnitController.SpawnPerceptionPlayerWarningShot( PlayerPawn );
}

simulated function UnitReplicationInfo GetUnitReplicationInfo()
{
	return None;
}

simulated event string GetUnitTypeName()
{
	return class'UnitTypeInfo'.Static.GetUnitTypeName( UnitType );
}

function SetFearCost( gbxPawn Member, int FearCostIndex )
{
	If ( MyUnitController != None )
		MyUnitController.SetFearCost( Member, FearCostIndex );
}

function AddNotifyOrderTarget(Actor Other)
{
	NotifyOrderTargetActors.Length = NotifyOrderTargetActors.Length + 1;

	NotifyOrderTargetActors[NotifyOrderTargetActors.Length - 1] = Other;
}

function RemoveNotifyOrderTarget(Actor Other)
{
	local int i;

	// find this Actor in the list and remove it...
	for (i = 0; i < NotifyOrderTargetActors.Length; i++)
	{
		if (NotifyOrderTargetActors[i] == Other)
		{
			NotifyOrderTargetActors.Remove(i, 1);
		}
	}
}

function AddNotifyOrderAssault(Actor Other)
{
	NotifyOrderAssaultActors.Length = NotifyOrderAssaultActors.Length + 1;

	NotifyOrderAssaultActors[NotifyOrderAssaultActors.Length - 1] = Other;
}

function RemoveNotifyOrderAssault(Actor Other)
{
	local int i;

	// find this Actor in the list and remove it...
	for (i = 0; i < NotifyOrderAssaultActors.Length; i++)
	{
		if (NotifyOrderAssaultActors[i] == Other)
		{
			NotifyOrderAssaultActors.Remove(i, 1);
		}
	}
}

function AddNotifyOrderFallIn(Actor Other)
{
	NotifyOrderFallInActors.Length = NotifyOrderFallInActors.Length + 1;

	NotifyOrderFallInActors[NotifyOrderFallInActors.Length - 1] = Other;
}

function RemoveNotifyOrderFallIn(Actor Other)
{
	local int i;

	// find this Actor in the list and remove it...
	for (i = 0; i < NotifyOrderFallInActors.Length; i++)
	{
		if (NotifyOrderFallInActors[i] == Other)
		{
			NotifyOrderFallInActors.Remove(i, 1);
		}
	}
}


//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
	bHidden=true
	bStatic=false
	bBlockNonZeroExtentTraces=false
	bBlockZeroExtentTraces=false
	bHardAttach=true
	Texture=Texture'Engine.S_Unit'
	DrawScale=1
	
	NumMembers=0

	NumSubUnits=0
	NormalSubUnitClass=class'Unit'

	MyInWorldIconClass="gbxBase.InWorldUnitIcon"

	FormationType=Formation_Wedge
	FormationRadius=700.0
	MinFormationRadius=400.0  // miniumum size of FormationRadius
	FormationRadiusMemberScale=50.0  // amount to add to MinFormationRadius per unit member (min + X*scale)
	MinFormationRadiusCombine=500.0  // miniumum size of FormationRadius when near another unit
	FormationRadiusMemberScaleCombine=100.0  // amount to add to min per unit member when near another unit
	FORMCExpansionSize=300.0
	MaxFormationRadius=1000.0

	bAttachedToSuperUnit=false
	bDontRemoveEmptyUnit=false

	TooFarFromSuperUnitDist=1100

	MyInWorldIconBaseColor=(R=255,B=0,G=0,A=192)

	bMaxUnitCount = 0; //SDJ 05/15/2004: Assigning to MAX_MEMBERS doesn't seem to work?

	RemainHereCloseEnoughDist=40

	bAlwaysRelevant=True
	RemoteRole=ROLE_SimulatedProxy

	myInspectorClass=class'gbxInspectorUnit'
	m_flNextClientRecalcTime=0
	fReinforcementsEffectTimeRemaining = 0.0
	fReinforcementsEffectDuration = 1.0
	iReplicatedReinforcements=0
	iLastReplicatedReinforcements=0

	MachineGunBoldnessMultiplier=0.3
	
	bSkipActorPropertyReplication=true
	bOnlyDirtyReplication=true

	Title=UnitTitleNone	
}
//=============================================================================
// UnitCentroid.
//=============================================================================
class UnitCentroid extends Unit
	placeable;

//---------------------------------------------------------
//	CalculateUnitCentroid
//---------------------------------------------------------
simulated function int CalculateUnitCentroid()
{
	local int totalWeight;

	totalWeight = Super.CalculateUnitCentroid();

	if( totalWeight > 0 )
		Self.SetLocation( UnitCentroid );

	return totalWeight;
}

defaultproperties
{
    bCanTeleport=True
    bBlockNonZeroExtentTraces=True
    bCollideActors=True
    CollisionHeight=1.0
    CollisionRadius=1.0
}
//=============================================================================
// Abstract base class of Unit AI Controllers.  These controllers handle all
// squad-level behavior, which mainly includes the behavior necessary to 
// carry out squad commands (move/target/assault).
//
// Gearbox Software.
//=============================================================================
class UnitController extends Actor
	notplaceable
	native
	abstract;


cpptext
{
	virtual FLOAT GetSuppressionLevelAnalog() { return 0.0f; }
	virtual BYTE GetSuppressionLevel() { return 0; }
	virtual UBOOL IsBerserk() { return 0; }
}

//---------------------------------------------------------
//	Variables / Constants
//---------------------------------------------------------
struct native KnownEnemyUnitEntry
{
	var Unit	EnemyUnit;
	var float	TimeStamp;
};

var Unit MyUnit;
var array< KnownEnemyUnitEntry > KnownEnemyUnits;

struct native NavPointCacheEntry
{
	var ActorLite		NavPoint;
	var float			DistanceLinear;
	var bool			bCanSeeFormationCenter;
};

var array< NavPointCacheEntry > FormationNavPointCache;

var array< ActorLite > OrderMoveQueue;	// Queue of move orders.
var bool	bLogSelect;
var Name	PawnToWatch;

var() int	FearCostIncrease;
var() float FearCostRadius;
var float	SuppressionSway;		// GBX:naj - (0.0 to 1.0): Power of suppression shots to affect the average suppression direction.
var Vector	AverageSuppressionDir;	// GBX:naj - Keep track of the average direction to the source of our suppression.

replication
{
	reliable if( bNetDirty && (Role==ROLE_Authority) )
        MyUnit;
}


//---------------------------------------------------------
//	SetPawnToWatch
//---------------------------------------------------------
function SetPawnToWatch( Name APawnToWatch )
{
	if ( APawnToWatch != '' )
	{
		bLogSelect = true;
		Default.bLogSelect = true;
		PawnToWatch = APawnToWatch;		
		Default.PawnToWatch = APawnToWatch;
	}
	else
	{
		bLogSelect = false;
		Default.bLogSelect = false;
	}
}

//---------------------------------------------------------
//	LogSelective
//---------------------------------------------------------
// Selective logging function.  Use this in place of Log() wherever possible.
// Using the "logselect" console command at runtime causes only those log messages
// that pertain to an individual pawn to be printed out.
//
function LogSelective( String msg )
{
	local int nMembers, i;

	if ( bLogSelect )
	{ 
		if ( PawnToWatch == '' )
		{
			log( "UNITCONTROLLER: NAJ**** "$Self.Name$" ["$GetStateName()$"]: "$msg, 'naj');
			return;
		}
		else
		if ( PawnToWatch == 'InfantryUSA' && MyUnit.Members[0].IsA( 'InfantryUSA' ) )
		{
			log( "UNITCONTROLLER: NAJ**** InfantryUSA ("$Self.Name$") ["$GetStateName()$"]: "$msg, 'naj' );
			return;
		}
		else
		if ( PawnToWatch == 'InfantryGermany' && MyUnit.Members[0].IsA( 'InfantryGermany' ) )
		{
			log( "UNITCONTROLLER: NAJ**** InfantryGermany ("$Self.Name$") ["$GetStateName()$"]: "$msg, 'naj' );
			return;
		}

		nMembers = MyUnit.NumMembers;
		for( i = 0; i < nMembers; ++i )
		{			
			if ( PawnToWatch == MyUnit.Members[ i ].Name )
			{
				log( "UNITCONTROLLER: NAJ**** "$MyUnit.Members[ i ].Name$" ["$GetStateName()$"]: "$msg, 'naj');
				return;
			}			
		}
	}
}

//---------------------------------------------------------
//	Possess
//---------------------------------------------------------
function Possess( Unit aUnit )
{
	// Unpossess my current unit.
	if( MyUnit != None )
	{
		MyUnit.PossessedBy( None );
	}

	if( aUnit != None )
	{
		// Let the unit's old controller know to let go.
		if( aUnit.MyUnitController != None )
		{
			aUnit.MyUnitController.Possess( None );
		}

		// Possess the new unit.
		aUnit.PossessedBy( Self );
	}

	MyUnit = aUnit;

	// build an initial FormationNavPointCache...
	NotifyFormationCenterChange(1);
}

//---------------------------------------------------------
//	GetSuppressionLevel
//---------------------------------------------------------
// Overridden in UnitControllerAI to provide actual behavior.
function ESuppressionLevel GetSuppressionLevel()
{
	return SL_UNSUPPRESSED;
}

//---------------------------------------------------------
//	GetSuppressionLevelAnalog
//---------------------------------------------------------
// Overridden in UnitControllerAI to provide actual behavior.
function float GetSuppressionLevelAnalog()
{
	return 0.0;
}

function ResetSuppressionLevelAnalog()
{
}
//---------------------------------------------------------
//	GetUnsuppressionDuration
//---------------------------------------------------------
function float GetUnsuppressionDuration()
{
	return 0.0;
}

//---------------------------------------------------------
//	NotifyFormationCenterChange
//---------------------------------------------------------
function NotifyFormationCenterChange( int NumMembersInRadius )
{
}

//---------------------------------------------------------
//	NotifyFormationRadiusIncreased
//---------------------------------------------------------
function NotifyFormationRadiusIncreased()
{
}

//---------------------------------------------------------
//	NotifyTeammatesOfTarget
//---------------------------------------------------------
function NotifyTeammatesOfTarget( gbxPawn Sender, gbxPawn Target )
{
}

//---------------------------------------------------------
//	NotifyStoppingAssault
//---------------------------------------------------------
function NotifyStoppingAssault()
{
}

//---------------------------------------------------------
//	UnitMemberUpdatedTarget
//---------------------------------------------------------
function UnitMemberUpdatedTarget( gbxPawn NewTarget )
{
}

//---------------------------------------------------------
//	RefreshKnownEnemyUnits
//---------------------------------------------------------
function RefreshKnownEnemyUnits()
{
}

//---------------------------------------------------------
//	NotifyMemberAdded
//---------------------------------------------------------
function NotifyMemberAdded( gbxPawn newMember )
{
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// COMMAND ////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//---------------------------------------------------------
//	BreakRelaxation
//---------------------------------------------------------
function BreakRelaxation() {}

//---------------------------------------------------------
//	OrderMove
//---------------------------------------------------------
function OrderMove( ActorLite FORMC, optional bool bAddToQueue )
{
	LogSelective( "OrderMove: FORMC=="$FORMC );

	if( FORMC == None )
	{
		return;
	}

	//Log( Self $ ".OrderMove( " $ FORMC $ ", " $ bAddToQueue $ " )", 'jmw' );

	if( !bAddToQueue )
	{
		// Just execute the move immediately.

		// Empty the move order queue, if it isn't already empty.
		OrderMoveQueue.Length = 0;

		ExecuteMove( FORMC );
	}
	else
	{
		AddMoveToQueue( FORMC );
	}
}

//---------------------------------------------------------
//	AddMoveToQueue
//---------------------------------------------------------
function AddMoveToQueue( ActorLite FORMC )
{
	if( FORMC == None )
	{
		return;
	}

	OrderMoveQueue.Length = OrderMoveQueue.Length + 1;
	OrderMoveQueue[ OrderMoveQueue.Length - 1 ] = FORMC;
}

//---------------------------------------------------------
//	IsCurrentMoveComplete
//---------------------------------------------------------
function bool IsCurrentMoveComplete()
{
	local int i, nMembers, nMembersCloseToFORMC;
	local float memberDistFromFORMC;
	local gbxPawn aPawn;

	nMembers = MyUnit.NumMembers;

	nMembersCloseToFORMC = 0;

	for( i = 0; i < nMembers; ++i )
	{
		// Is this member already at his chosen navpoint within the FORM?
		aPawn = MyUnit.Members[i];

		if (MyUnit.FormationCenter.bIsNavigationPoint)
		{
			memberDistFromFORMC = VSizeSquared( aPawn.Location - NavigationPoint( MyUnit.FormationCenter ).Location);
		}
		else if (MyUnit.FormationCenter.bIsNavigationPointLite)
		{
			memberDistFromFORMC = VSizeSquared( aPawn.Location - NavigationPointLite( MyUnit.FormationCenter ).Location);
		}

		if( memberDistFromFORMC <= MyUnit.FormationRadius * MyUnit.FormationRadius * 4 )
		{
			++nMembersCloseToFORMC;
		}
	}

	// Are at least half of the members close to the FORMC?
	return float( nMembersCloseToFORMC ) / nMembers >= 0.5;
}

//---------------------------------------------------------
//	ExecuteQueuedMove
//---------------------------------------------------------
function ExecuteQueuedMove()
{
	if( OrderMoveQueue.Length > 0 )
	{
		ExecuteMove( OrderMoveQueue[ 0 ] );
	}
}

//---------------------------------------------------------
//	UpdateMoveOrderQueue
//---------------------------------------------------------
function UpdateMoveOrderQueue()
{
	// Maintain the move order queue.	// TODO this doesn't really need to be called every tick, but the timer interval of 1 second is too slow a response time. Needs somewhere in between.
	// If there is a move queued up and the current move is essentially "done" (as defined by IsCurrentMoveComplete()), then execute the next queued move order.
	if( OrderMoveQueue.Length > 0 && IsCurrentMoveComplete() )
	{
		if( MyUnit.FormationCenter == OrderMoveQueue[ 0 ] )
		{
			OrderMoveQueue.Remove( 0, 1 );		// Pop the existing move order.
		}
		ExecuteQueuedMove();
	}
}

//---------------------------------------------------------
//	ExecuteMove
//---------------------------------------------------------
function ExecuteMove( ActorLite FORMC )
{
//	Log( Self $ ".ExecuteMove( " $ FORMC $ " )", 'jmw' );
}

//---------------------------------------------------------
//	OrderTarget
//---------------------------------------------------------
function OrderTarget( Unit targetUnit )
{
}

//---------------------------------------------------------
//	OrderAssault
//---------------------------------------------------------
function OrderAssault( Unit targetUnit )
{
}

//---------------------------------------------------------
//	DebugFinishAssault
//---------------------------------------------------------
function DebugFinishAssault();	// Debug; remove when Assault logic is complete.

//---------------------------------------------------------
//	OrderFallIn
//---------------------------------------------------------
function OrderFallIn()
{
}

//---------------------------------------------------------
//	OrderAllFallIn
//---------------------------------------------------------
function OrderAllFallIn()
{
}

function bool ShouldAttachToSuperUnit()
{
	// ShouldAttachToSuperUnit is called by Unit.AttachAllSubUnits(), give the UnitController a chance to prevent this (player's riding on tank)
	return true;
}

//---------------------------------------------------------
//	OrderManTurret
//---------------------------------------------------------
function OrderManTurret( TurretWeapon Turret )
{
	// GBX:naj - This feature will probably not make it into the game.
}

//---------------------------------------------------------
//	IsUnitKnown
//---------------------------------------------------------
function bool IsUnitKnown( Unit TestUnit )
{
	return false;
}

//---------------------------------------------------------
//	IsUnitTargettedByAlly
//---------------------------------------------------------
function bool IsUnitTargettedByAlly( Unit TestUnit )
{
	return false;
}

//---------------------------------------------------------
//	IsAnyGrenadeAttackAllowed
//---------------------------------------------------------
function bool IsAnyGrenadeAttackAllowed()
{
	return false;
}

//---------------------------------------------------------
//	MemberThrowingGrenade
//---------------------------------------------------------
function MemberThrowingGrenade( gbxPawn aMember, bool bIsThrowing );

//---------------------------------------------------------
//	NotifyGrenadeExploded
//---------------------------------------------------------
function NotifyGrenadeExploded( gbxPawn Thrower );

//---------------------------------------------------------
//	IsGrenadeAttackAllowed
//---------------------------------------------------------
// Unit members will ask permission to attack a target with a grenade
function bool IsGrenadeAttackAllowed( Vector AttackLocation )
{
	return false;
}

//---------------------------------------------------------
//	DoSuppressionGrenade
//---------------------------------------------------------
function DoSuppressionGrenade() {}


//---------------------------------------------------------
//	DoFleeTNT
//---------------------------------------------------------
function DoFleeTNT(gbxExplosive Tnt) {}

//---------------------------------------------------------
//	TNTResumeCombat
//---------------------------------------------------------
function TNTResumeCombat(){}

//---------------------------------------------------------
//	DoGradedSuppressionGrenade
//---------------------------------------------------------
function DoGradedSuppressionGrenade( float Intensity ) {}

function bool IsAssaulting( optional Unit AssaultedUnit );
	// Pass AssaultedUnit==None to determine whether any unit is being assaulted by this team.

function NotifyBeingAssaulted( Unit AssaultingUnit );

function bool TryToStealTeammatesNavPoint( gbxPawn aMember, out gbxPawn Teammate, out ActorLite NewNavPoint ) { return false; }

function NotifyMemberDoingOpBurst( gbxPawn aMember );

function bool HasFreeOpBurst() { return false; }

function SpawnPerceptionPlayerHit( gbxPawn PlayerPawn );
function SpawnPerceptionPlayerWarningShot( gbxPawn PlayerPawn );

function bool IsTerrified() { return false; }
function bool PawnIsOnUnitFlank( gbxPawn ThePawn ) { return false; }

event MemberSurprisedByAttacker( gbxPawn instigator, gbxPawn Notifier );


native function SetFearCost( gbxPawn Member, int FearCostIndex );

//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
	bHidden=true
	bStatic=false
	
	bAlwaysRelevant=True
	RemoteRole=ROLE_SimulatedProxy

	FearCostIncrease=800.0
	FearCostRadius=300.0
}
class UnitTypeInfo extends Actor;

var localized string			UnitTypeNameNone;
var localized string			UnitTypeNameAssault;
var localized string			UnitTypeNameBase;
var localized string			UnitTypeNameVehicle;

var localized string UnitTitleNone;
var localized string UnitTitle01;
var localized string UnitTitle02;
var localized string UnitTitle03;
var localized string UnitTitle04;
var localized string UnitTitle05;
var localized string UnitTitle06;
var localized string UnitTitle07;
var localized string UnitTitle08;
var localized string UnitTitle09;
var localized string UnitTitle10;
var localized string UnitTitle11;
var localized string UnitTitle12;
var localized string UnitTitle13;
var localized string UnitTitle14;
var localized string UnitTitle15;
var localized string UnitTitle16;
var localized string UnitTitle17;
var localized string UnitTitle18;
var localized string UnitTitle19;
var localized string UnitTitle20;
var localized string UnitTitle21;
var localized string UnitTitle22;
var localized string UnitTitle23;
var localized string UnitTitle24;
var localized string UnitTitle25;
var localized string MP_GERMANASSAULT;
var localized string MP_GERMANFIRE;
var localized string MP_GERMANSNIPER;
var localized string MP_USASSAULT;
var localized string MP_USFIRE;
var localized string MP_USSNIPER;
var localized string SKR_HARTSOCK;
var localized string SKR_BAKER;
var localized string UnitDoyle;

simulated static function string GetUnitTitle( Unit.EUnitTitle eTitle )
{
	switch (eTitle)
	{
		case UnitTitle01:
			return Default.UnitTitle01;
		case UnitTitle02:
			return Default.UnitTitle02;
		case UnitTitle03:
			return Default.UnitTitle03;
		case UnitTitle04:
			return Default.UnitTitle04;
		case UnitTitle05:
			return Default.UnitTitle05;
		case UnitTitle06:
			return Default.UnitTitle06;
		case UnitTitle07:
			return Default.UnitTitle07;
		case UnitTitle08:
			return Default.UnitTitle08;
		case UnitTitle09:
			return Default.UnitTitle09;
		case UnitTitle10:
			return Default.UnitTitle10;
		case UnitTitle11:
			return Default.UnitTitle11;
		case UnitTitle12:
			return Default.UnitTitle12;
		case UnitTitle13:
			return Default.UnitTitle13;
		case UnitTitle14:
			return Default.UnitTitle14;
		case UnitTitle15:
			return Default.UnitTitle15;
		case UnitTitle16:
			return Default.UnitTitle16;
		case UnitTitle17:
			return Default.UnitTitle17;
		case UnitTitle18:
			return Default.UnitTitle18;
		case UnitTitle19:
			return Default.UnitTitle19;
		case UnitTitle20:
			return Default.UnitTitle20;
		case UnitTitle21:
			return Default.UnitTitle21;
		case UnitTitle22:
			return Default.UnitTitle22;
		case UnitTitle23:
			return Default.UnitTitle23;
		case UnitTitle24:
			return Default.UnitTitle24;
		case UnitTitle25:
			return Default.UnitTitle25;
		case MP_GERMANASSAULT:
			return Default.MP_GERMANASSAULT;
		case MP_GERMANFIRE:
			return Default.MP_GERMANFIRE;
		case MP_GERMANSNIPER:
			return Default.MP_GERMANSNIPER;
		case MP_USASSAULT:
			return Default.MP_USASSAULT;
		case MP_USFIRE:
			return Default.MP_USFIRE;
		case MP_USSNIPER:
			return Default.MP_USSNIPER;
		case SKR_HARTSOCK:
			return Default.SKR_HARTSOCK;
		case SKR_BAKER:
			return Default.SKR_BAKER;
		case UnitDoyle:
			return Default.UnitDoyle;
	}

	return Default.UnitTitleNone;
}

simulated static function string GetUnitTypeName( EUnitType eType )
{
	switch (eType)
	{
		case EUnitType.UnitType_Assault:
			return Default.UnitTypeNameAssault;
		case EUnitType.UnitType_Base:
			return Default.UnitTypeNameBase;
		case EUnitType.UnitType_Vehicle:
			return Default.UnitTypeNameVehicle;
	}
	return Default.UnitTypeNameNone;
}

//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
	UnitTypeNameNone=""
	UnitTypeNameAssault="Assault Team"
	UnitTypeNameBase="Fire Team"
	UnitTypeNameVehicle="Vehicle Team"

	UnitTitleNone=""
	UnitTitle01="Sgt. Joe Hartsock - 3rd Plt, Fox, 502 PIR"
	UnitTitle02="Assault Team - 3rd Plt, Fox, 502 PIR"
	UnitTitle03="Fire Team - 3rd Plt, Fox, 502 PIR"
	UnitTitle04="3rd Plt, Fox, 502 PIR"
	UnitTitle05="1st Battalion, 502 PIR"
	UnitTitle06="2nd Battalion, 502 PIR"
	UnitTitle07="3rd Battalion, 502 PIR"
	UnitTitle08="3rd Battalion, 506 PIR"
	UnitTitle09="1st Battalion, 508 PIR"
	UnitTitle10="327th Glider Infantry Regiment"
	UnitTitle11="M5A1 Stuart - 4th Infantry Division"
	UnitTitle12="M4A3 Sherman - 2nd Armored Division"
	UnitTitle13="M4A3 Sherman - 4th Infantry Division"
	UnitTitle14="709th Infanterie Division"
	UnitTitle15="91st Infanterie Division"
	UnitTitle16="6th Fallschirmjger Regiment"
	UnitTitle17="17th SS-Panzer Grenadier Division"
	UnitTitle18="StuG III A - 100th Panzer Battalion"
	UnitTitle19="StuG III F - 100th Panzer Battalion"
	UnitTitle20="PzKpfw IV G - 100th Panzer Battalion"
	UnitTitle21="PzKpfw IV G - 17th SS-Panzer Grenadier Division"
	UnitTitle22="Cpl. Joe Hartsock - 3rd Plt, Fox, 502 PIR"
	UnitTitle23="M10 Wolverine TD 899th TD BN"
	UnitTitle24="2/2/C/205 PIR, 82d ABN"
	UnitTitle25="501st PIR, 101st ABN"
	MP_GERMANASSAULT="German Assault Team"
	MP_GERMANFIRE="German Fire Team"
	MP_GERMANSNIPER="German Sniper Team"
	MP_USASSAULT="US Assault Team"
	MP_USFIRE="US Fire Team"
	MP_USSNIPER="US Sniper Team"
	SKR_HARTSOCK="Hartsock"
	SKR_BAKER="Baker"
	UnitDoyle="Doyle"
}
//=============================================================================
// Object to facilitate storing information about Weapon loadouts in crates
//
// << GBX/PAD:created -- entire file
//
//=============================================================================

class UsableLoadoutInfo extends Object
	editinlinenew;

var()		class<gbxUsableItem>	m_UsableClass;
var()		int				m_nMaxCharQuantity;

defaultproperties
{
}
class UsableProjectile extends gbxUsableItem;



var     vector	FireOffset;			// Offset from first person eye position for projectile to launch
var class<Projectile> ProjectileClass;

simulated function vector GetFireStart(vector X, vector Y, vector Z)
{
	if (Pawn(Owner) != None)
		return (Owner.Location + Pawn(Owner).EyePosition() + FireOffset.X * X + FireOffset.Y * Y + FireOffset.Z * Z);
	return Owner.Location;
}

function SpawnProjectile(vector Start, rotator Dir)
{
	Spawn(ProjectileClass, self,, Start,Dir);
}

function ProjectileFire()
{
	local Vector Start, X,Y,Z;

	Owner.MakeNoise(1.0);
	GetAxes(Pawn(Owner).GetViewRotation(),X,Y,Z);
	Start = GetFireStart(X,Y,Z);
	SpawnProjectile(Start,Pawn(Owner).GetViewRotation());
}
class VehicleKarmaWakeTrigger extends Trigger;

var gbxSVehicle MyVehicle;
var array<gbxSVehicle> touchers;


function Touch( Actor Other )
{
	local int num;

	if ((MyVehicle == None) || (gbxSVehicle(Other) == None))
		return;

	if (Other == MyVehicle)
		return;  // we don't touch ourselves (THAT'S PREVERTED!!!)

	num = touchers.Length;
	touchers.Length = touchers.Length + 1;
	touchers[num] = gbxSVehicle(Other);  // add this vehicle to the list of touchers

	MyVehicle.SetPhysics(PHYS_Karma);
	MyVehicle.KWake();  // make sure we're awake

	MyVehicle.KarmaSleepTime = -999.0f;  // don't go to sleep until UnTouch happens
}


defaultproperties
{
    bHidden=true
	bHardAttach=true
	bCollideActors=true
    bStatic=false
	bCollideWhenPlacing=false
    RemoteRole=ROLE_None

	touchers=0
}
class VoiceType extends Object
	config( user )
	transient;

// TODO replication/multiplayer

struct SpeechSoundInfo
{
	var Name	GroupName;
	var Name	KeyName;
	var	String	SoundName;
	var Sound	Sound;
	var float	Volume;
	var float	Pitch;
	var float	Radius;
	var bool	bPreload;

	// System calculated values
	var int		NumRequests;
};

struct SpeechGroupInfo
{
	var name		GroupName;
	var int			SpeechLastPlayed;
	var array<int>	SpeechList;
};

var bool bSpeechesSorted;

var String ClassString;

const MAX_SPEECH_SOUND_INFOS=350;
var array<SpeechSoundInfo> SpeechSoundInfos;
var array<SpeechGroupInfo> GroupList;

var Cue		PlayerSayingMyName;
var Cue		Player2SayingMyName;
var String	PlayerSayingMyNameString;
var String	Player2SayingMyNameString;

var	String	PackageName;	// GBX:RSC - package that all dialogue for this voicetype can be found in

var int ndxLastSpeechSoundInfo;

var globalconfig bool bPlayRandomBattleDialogue;


function Initialize( Actor LoaderActor )
{
	//log( "Voicetype::Initialize() called on " $ self, 'RSC' );
	if ( PlayerSayingMyNameString != "" )
	{
		PlayerSayingMyName = LoaderActor.LoadSound( PlayerSayingMyNameString );
	}

	// sort the sounds
	//SortSpeeches();
}

//
// sort all the sounds into groups so we can randomize the playback
//
function SortSpeeches()
{
	local int speech;

	//log( "Voicetype::SortSpeeches() called on " $ self $ " SpeechSoundInfos.Length=" $ SpeechSoundInfos.Length, 'RSC' );

	if( bSpeechesSorted )
	{
		return;
	}

	for( speech=0; speech<SpeechSoundInfos.Length; ++speech )
	{
		// if the group exists, add the speech to it
		if( GroupExists( speech ) )
		{
			AddSpeech( speech );
		}
		else	// if not, add the group, then the speech
		{
			AddGroup( speech );
			AddSpeech( speech );
		}
	}

	bSpeechesSorted=true;
}

// 
// return true if the group exists
//
function bool GroupExists( int speechIndex )
{
	local int groupIndex;

	for( groupIndex=0; groupIndex<GroupList.Length; ++groupIndex )
	{
		if( GroupList[groupIndex].GroupName == SpeechSoundInfos[speechIndex].GroupName )
		{
			return true;
		}
	}

	return false;
}

// 
// add the given group to the group list
//
function AddGroup( int speechIndex )
{
	local int groupIndex;

	groupIndex=GroupList.Length;
	GroupList.Length=groupIndex+1;

	GroupList[groupIndex].GroupName = SpeechSoundInfos[speechIndex].GroupName;
	//log( "Voicetype::AddGroup() - " $ self $ ": " $ GroupList[groupIndex].GroupName $ "[" $ groupIndex $ "] ADDED", 'RSC' );
}

//
// add the given speech to the speech list
//
function AddSpeech( int speechIndex )
{
	local int groupIndex, SpeechListIndex;

	for( groupIndex=0; groupIndex<GroupList.Length; ++groupIndex )
	{
		// if the group name matches, add the speech
		if( GroupList[groupIndex].GroupName == SpeechSoundInfos[speechIndex].GroupName )
		{
			SpeechListIndex = GroupList[groupIndex].SpeechList.Length;
			GroupList[groupIndex].SpeechList.Length = GroupList[groupIndex].SpeechList.Length + 1;

			GroupList[groupIndex].SpeechList[SpeechListIndex] = speechIndex;
			//log( "Voicetype::AddSpeech() - " $ self $ ": " $ SpeechSoundInfos[speechIndex].KeyName $ "[" $ speechIndex $ "] ADDED to " $ GroupList[groupIndex].GroupName $ "[" $ SpeechListIndex $ "]", 'RSC' );
			return;
		}
	}
			
	// if we get here, something happened where we didn't find the group...BAAADDDD!!!
	//log( "Voicetype::AddSpeech() - " $ self $ ": ~WARNING~ " $ SpeechSoundInfos[speechIndex].GroupName $ " NOT FOUND!", 'RSC' );
	return;
}

//
// preload all the audio for this voicetype so they will show up in the preload files
//
function Preload()
{
	local int i;
	local string strSound;
	local sound sndHandle;

	//log( "VoiceType::Preload() - Preloading Sounds For " $ self, 'RSC' );

	for( i=0; i<SpeechSoundInfos.Length; ++i )
	{
		// dont preload if the sound is blank or flagged
		if( SpeechSoundInfos[i].SoundName == "" || !SpeechSoundInfos[i].bPreload )
			continue;

		// load the soft version of the sound
		sndHandle=None;
		strSound="";
		strSound = GetPackage() $ ".S" $ Right( SpeechSoundInfos[i].SoundName, Len(SpeechSoundInfos[i].SoundName)-1 );
		sndHandle = sound( DynamicLoadObject( strSound, class'Sound' ) );

		// double check that the sound loaded
		//if( sndHandle != None )
		//	log( "VoiceType::Preload() - " $ strSound $ " Loaded SUCCESSFULLY!", 'RSC' );
		//else
		//	log( "VoiceType::Preload() - " $ strSound $ " Load FAILED!", 'RSC' );

		// load the medium version of the sound
		sndHandle=None;
		strSound="";
		strSound = GetPackage() $ ".M" $ Right( SpeechSoundInfos[i].SoundName, Len(SpeechSoundInfos[i].SoundName)-1 );
		sndHandle = sound( DynamicLoadObject( strSound, class'Sound' ) );

		// double check that the sound loaded
		//if( sndHandle != None )
		//	log( "VoiceType::Preload() - " $ strSound $ " Loaded SUCCESSFULLY!", 'RSC' );
		//else
		//	log( "VoiceType::Preload() - " $ strSound $ " Load FAILED!", 'RSC' );

		// load the loud version of the sound
		sndHandle=None;
		strSound="";
		strSound = GetPackage() $ ".L" $ Right( SpeechSoundInfos[i].SoundName, Len(SpeechSoundInfos[i].SoundName)-1 );
		sndHandle = sound( DynamicLoadObject( strSound, class'Sound' ) );

		// double check that the sound loaded
		//if( sndHandle != None )
		//	log( "VoiceType::Preload() - " $ strSound $ " Loaded SUCCESSFULLY!", 'RSC' );
		//else
		//	log( "VoiceType::Preload() - " $ strSound $ " Load FAILED!", 'RSC' );
	}
}

function string GetPackage()
{
	return PackageName;
}

function sound GetSound( name keyName )
{
	local SpeechSoundInfo ssInfo;
	ssInfo = FindSpeechSoundInfo( keyName );

	return ssInfo.Sound;
}

function string GetSoundName( name keyName )
{
	local SpeechSoundInfo ssInfo;
	ssInfo = FindSpeechSoundInfo( keyName );

	return ssInfo.SoundName;
}

function float GetVolume( name keyName )
{
	local SpeechSoundInfo ssInfo;
	ssInfo = FindSpeechSoundInfo( keyName );

	return ssInfo.Volume;
}


function float GetRadius( name keyName )
{
	local SpeechSoundInfo ssInfo;
	ssInfo = FindSpeechSoundInfo( keyName );

	return ssInfo.Radius;
}


function float GetPitch( name keyName )
{
	local SpeechSoundInfo ssInfo;
	ssInfo = FindSpeechSoundInfo( keyName );

	return ssInfo.Pitch;
}

function SpeechSoundInfo FindSpeechSoundInfo( name keyName )
{
	local int i;

	// Check the cached value.
	if( ndxLastSpeechSoundInfo >= 0 && SpeechSoundInfos[ ndxLastSpeechSoundInfo ].KeyName == keyName )
	{
		return SpeechSoundInfos[ ndxLastSpeechSoundInfo ];
	}

	for( i = 0; i < SpeechSoundInfos.Length; ++i )
	{
		if( SpeechSoundInfos[ i ].KeyName == keyName )
		{
			// Cache this return value.
			ndxLastSpeechSoundInfo = i;

			//Log( "WARNING: " $ class $ ".FindSpeechSoundInfo( " $ keyName $ " ) found a keyName=" $ SpeechSoundInfos[ i ].KeyName, 'speech' );
			return SpeechSoundInfos[ i ];
		}
	}

	//Log( "WARNING: " $ class $ ".FindSpeechSoundInfo( " $ keyName $ " ) could not find keyName", 'speech' );
	return SpeechSoundInfos[ 0 ];
}

function SpeechSoundInfo GetSpeechSoundInfo( int i )
{
	return SpeechSoundInfos[i];
}

function name GetKeyName( int i )
{
	return SpeechSoundInfos[i].keyName;
}

function name GetGroupMember( name KeyGroupName )
{
	if( bPlayRandomBattleDialogue )
	{
		//log( "Voicetype::GetGroupMember() - GetRandomGroupMember() called.", 'RSC' );
		return GetRandomGroupMember( KeyGroupName );
	}
	else
	{
		//log( "Voicetype::GetGroupMember() - GetOrderedGroupMember() called.", 'RSC' );
		return GetOrderedGroupMember( KeyGroupName );
	}
}

//
// get a random group member from the given group
//
function name GetRandomGroupMember( name KeyGroupName )
{
	local int groupIndex, memberIndex, randomIndex, loopCount;

	memberIndex=-1;
	loopCount=0;

	for( groupIndex=0; groupIndex<GroupList.Length; ++groupIndex )
	{
		if( GroupList[groupIndex].GroupName == KeyGroupName )
		{
			if( GroupList[groupIndex].SpeechList.Length == 0 )
				return '';

			// if our list has more than 3 entries, get a random one
			if( GroupList[groupIndex].SpeechList.Length > 3 )
			{
				// never play the same speech twice in a row, but don't do the loop more than 5 times
				do
				{
					randomIndex = RandRange( 0, GroupList[groupIndex].SpeechList.Length-1 );
					memberIndex = GroupList[groupIndex].SpeechList[ randomIndex ];
					//log("VoiceType::GetRandomGroupMember() - " $ self $ ": memberIndex=" $ memberIndex $ ", randomIndex=" $ randomIndex $ ", SpeechLastPlayed=" $ GroupList[groupIndex].SpeechLastPlayed, 'RSC');
				} until( memberIndex != GroupList[groupIndex].SpeechLastPlayed || ++loopCount > 5 );
				
				//log("VoiceType::GetRandomGroupMember() - " $ self $ ": randomly returned " $ memberIndex, 'RSC');
			}
			else	// just get the ordered member since this group only has a few entries
			{
				return GetOrderedGroupMember( KeyGroupName );
			}
			
			GroupList[groupIndex].SpeechLastPlayed = memberIndex;
			break;
		}
	}

	if( memberIndex < 0 )
	{
		//log( "Voicetype::GetRandomGroupMember() - " $ self $ ": Group " $ KeyGroupName $ " NOT FOUND!", 'VoiceType' );
		return '';
	}

	SpeechSoundInfos[ memberIndex ].NumRequests++;
	//log("VoiceType::GetRandomGroupMember() - " $ self $ ": " $ SpeechSoundInfos[ memberIndex ].KeyName $ " has been used " $ SpeechSoundInfos[ memberIndex ].NumRequests $ " times.", 'RSC');
	return SpeechSoundInfos[ memberIndex ].KeyName;
}

function name GetOrderedGroupMember( Name KeyGroupName )
{
	local int i, j, UseIndex;

	j = -1;
	UseIndex = 0;

	// Find sounds in the group
	for( i = 0; i < SpeechSoundInfos.Length; ++i )
	{
		if( SpeechSoundInfos[ i ].GroupName == 'None' )
		{
			// Reached illegal struct.
			//break;
		}
		else if( SpeechSoundInfos[ i ].GroupName == KeyGroupName && (SpeechSoundInfos[ i ].NumRequests < j || j < 0) )
		{
			UseIndex = i;
			j = SpeechSoundInfos[ i ].NumRequests;
		}
	}

	if( j < 0 )
		return '';

	// Keep track of how many times this sound was requested
	SpeechSoundInfos[ UseIndex ].NumRequests++;

	//log("VoiceType::GetOrderedGroupMember() - " $ SpeechSoundInfos[ UseIndex ].KeyName $ " has been used " $ SpeechSoundInfos[ UseIndex ].NumRequests $ " times.", 'VoiceType');
	return SpeechSoundInfos[ UseIndex ].KeyName;
}

function Cue GetCuePlayerSayingMyName()
{
	return PlayerSayingMyName;
}

function String GetStringPlayerSayingMyName()
{
	return PlayerSayingMyNameString;
}

function Name GetGroupFromSoundName( String strSoundName )
{
	local int i;
	for( i=0; i<SpeechSoundInfos.Length; ++i )
	{
		if( SpeechSoundInfos[i].SoundName ~= strSoundName )
		{
			return SpeechSoundInfos[i].GroupName;
		}
	}

	//log( "WARNING: VoiceType::GetGroupFromSoundName() could not find SoundName - " $ strSoundName, 'RSC' );
	return '';
}

defaultproperties
{
	//bHidden=true
	//bStatic=false

	ndxLastSpeechSoundInfo=-1

	bSpeechesSorted=false
	bPlayRandomBattleDialogue=true
}
class WDamage extends DamageType
	abstract;



//FIXME - remove if not used

defaultproperties
{
}
//=============================================================================
// Object to facilitate storing information about Weapon loadouts in crates
//
// << GBX/PAD:created -- entire file
//
//=============================================================================

class WeaponLoadoutInfo extends Object
	editinlinenew;

var()		class<gbxWeapon>	m_WeaponClass;

defaultproperties
{
}
