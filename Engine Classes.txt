//=============================================================================
// AccessControl.
//
// AccessControl is a helper class for GameInfo.
// The AccessControl class determines whether or not the player is allowed to
// login in the PreLogin() function, and also controls whether or not a player
// can enter as a spectator or a game administrator.
//
//=============================================================================
class AccessControl extends Info;



var globalconfig string     IPPolicies[50];
var	localized string          IPBanned;
var	localized string	      WrongPassword;
var	localized string          NeedPassword;
var class<Admin> AdminClass;

var private globalconfig string AdminPassword;	    // Password to receive bAdmin privileges.
var private globalconfig string GamePassword;		    // Password to enter game.

var bool bDontAddDefaultAdmin;


function SetAdminPassword(string P)
{
	AdminPassword = P;
}

function SetGamePassword(string P)
{
	GamePassword = P;
}

function bool RequiresPassword()
{
	return GamePassword != "";
}

function Kick( string S )
{
	local PlayerController P;

	ForEach DynamicActors(class'PlayerController', P)
		if ( P.PlayerReplicationInfo.GetHumanReadableName() ~= S
			&&	(NetConnection(P.Player)!=None) )
		{
			P.ClientNetworkMessage("Kicked", "");

			if (P != None)
			P.Destroy();
			return;
		}
}

function KickBan( string S )
{
	local PlayerController P;
	local string IP;
	local int j;

	ForEach DynamicActors(class'PlayerController', P)
		if ( P.PlayerReplicationInfo.GetHumanReadableName() ~= S
			&&	(NetConnection(P.Player)!=None) )
		{
			IP = P.GetPlayerNetworkAddress();
			if( CheckIPPolicy(IP) )
			{
				IP = Left(IP, InStr(IP, ":"));
				Log("Adding IP Ban for: "$IP);
				for(j=0;j<50;j++)
					if( IPPolicies[j] == "" )
						break;
				if(j < 50)
					IPPolicies[j] = "DENY,"$IP;
				SaveConfig();
			}

			P.ClientNetworkMessage("Kicked", ""); // TODO change to Banned if this is ever fully implemented

			if (P != None)
			P.Destroy();
			return;
		}
}

function bool AdminLogin( PlayerController P, string Password )
{
	if (AdminPassword == "")
		return false;

	if (Password == AdminPassword)
	{
		Log("Administrator logged in.");
		Level.Game.Broadcast( P, P.PlayerReplicationInfo.PlayerName$"logged in as a server administrator." );
		return true;
	}
	return false;
}

//
// Accept or reject a player on the server.
// Fails login if you set the Error to a non-empty string.
//
event PreLogin
(
	string Options,
	string Address,
	out string Error,
	out string FailCode,
	bool bSpectator
)

{
	// Do any name or password or name validation here.
	local string InPassword;

	Error="";
	InPassword = Level.Game.ParseOption( Options, "Password" );

	if( (Level.NetMode != NM_Standalone) && Level.Game.AtCapacity(bSpectator, true) )
	{
		Error=class'gbxNetworkErrors'.Default.ErrorCodeServerFull;
	}
	else if
	(	GamePassword!=""
	&&	caps(InPassword)!=caps(GamePassword)
	&&	(AdminPassword=="" || caps(InPassword)!=caps(AdminPassword)) )
	{
		if( InPassword == "" )
		{
			Error = NeedPassword;
			FailCode = "NEEDPW";
		}
		else
		{
			Error = WrongPassword;
			FailCode = "WRONGPW";
		}
	}

	if(!CheckIPPolicy(Address))
		Error = IPBanned;
}


function bool CheckIPPolicy(string Address)
{
	local int i, j, LastMatchingPolicy;
	local string Policy, Mask;
	local bool bAcceptAddress, bAcceptPolicy;

	// strip port number
	j = InStr(Address, ":");
	if(j != -1)
		Address = Left(Address, j);

	bAcceptAddress = True;
	for(i=0; i<50 && IPPolicies[i] != ""; i++)
	{
		j = InStr(IPPolicies[i], ",");
		if(j==-1)
			continue;
		Policy = Left(IPPolicies[i], j);
		Mask = Mid(IPPolicies[i], j+1);
		if(Policy ~= "ACCEPT")
			bAcceptPolicy = True;
		else
		if(Policy ~= "DENY")
			bAcceptPolicy = False;
		else
			continue;

		j = InStr(Mask, "*");
		if(j != -1)
		{
			if(Left(Mask, j) == Left(Address, j))
			{
				bAcceptAddress = bAcceptPolicy;
				LastMatchingPolicy = i;
			}
		}
		else
		{
			if(Mask == Address)
			{
				bAcceptAddress = bAcceptPolicy;
				LastMatchingPolicy = i;
			}
		}
	}

	if(!bAcceptAddress)
		Log("Denied connection for "$Address$" with IP policy "$IPPolicies[LastMatchingPolicy]);

	return bAcceptAddress;
}

defaultproperties
{
	WrongPassword="The password you entered is incorrect."
	NeedPassword="You need to enter a password to join this game."
	IPBanned="Your IP address has been banned on this server."
	IPPolicies(0)="ACCEPT,*"
	AdminClass=class'Engine.Admin'
}
//=============================================================================
// ActionMoveCamera:
//
// Moves the camera to a specified interpolation point.
//=============================================================================
class ActionMoveCamera extends MatAction
	native;



var(Path) config enum EPathStyle
{
	PATHSTYLE_Linear,
	PATHSTYLE_Bezier,
} PathStyle;

defaultproperties
{
	PathStyle=PATHSTYLE_Linear
}
//=============================================================================
// ActionPause:
//
// Pauses for X seconds.
//=============================================================================
class ActionPause extends MatAction
	native;



defaultproperties
{
}
//=============================================================================
// Actor: The base class of	all	actors.
// Actor is	the	base class of all gameplay objects.
// A large number of properties, behaviors and interfaces are implemented in Actor,	including:
//
// -	Display
// -	Animation
// -	Physics	and	world interaction
// -	Making sounds
// -	Networking properties
// -	Actor creation and destruction
// -	Triggering and timers
// -	Actor iterator functions
// -	Message	broadcasting
//
// This	is a built-in Unreal class and it shouldn't	be modified.
//=============================================================================
class Actor	extends	ActorLite
	abstract
	native
	nativereplication;

const MAXSTEPHEIGHT	= 35.0;	// Maximum step	height walkable	by pawns
const MINFLOORZ	= 0.7; // minimum z	value for floor	normal (if less, not a walkable	floor) 0.7 ~= 45 degree	angle for floor
					   
enum ELightType
{
	LT_None,
	LT_Steady,
	LT_Pulse,
	LT_Blink,
	LT_Flicker,
	LT_Strobe,
	LT_BackdropLight,
	LT_SubtlePulse,
	LT_TexturePaletteOnce,
	LT_TexturePaletteLoop,
	LT_FadeOut
};

enum ELightEffect
{
	LE_None,
	LE_ObsoleteA,
	LE_ObsoleteB,
	LE_ObsoleteC,
	LE_Searchlight,
	LE_SlowWave,
	LE_FastWave,
	LE_ObsoleteD,
	LE_StaticSpot,
	LE_Shock,
	LE_Disco,
	LE_ObsoleteE,
	LE_Spotlight,
	LE_NonIncidence,
	LE_Shell,
	LE_ObsoleteF,
	LE_Interference,
	LE_Cylinder,
	LE_Rotor,
	LE_Sunlight,
	LE_QuadraticNonIncidence,
};

enum EPhysics
{
	PHYS_None,
	PHYS_Walking,
	PHYS_Falling,
	PHYS_Swimming,
	PHYS_Flying,
	PHYS_Rotating,
	PHYS_Projectile,
	PHYS_Interpolating,
	PHYS_MovingBrush,
	PHYS_Spider,
	PHYS_Trailer,
	PHYS_Ladder,
	PHYS_RootMotion,
	PHYS_Karma,
	PHYS_KarmaRagDoll
};

enum EDrawType
{
	DT_None,
	DT_Sprite,
	DT_Mesh,
	DT_Brush,
	DT_RopeSprite,
	DT_VerticalSprite,
	DT_Terraform,
	DT_SpriteAnimOnce,
	DT_StaticMesh,
	DT_DrawType,
	DT_Particle,
	DT_AntiPortal,
	DT_FluidSurface,
	DT_GbxFluidSurface,
	DT_GbxWires,
	DT_StaticMeshSorted,
};

enum EFilterState
{
	FS_Maybe,
	FS_Yes,
	FS_No
};

enum EDetailMode
{
	DM_Low,
	DM_High,
	DM_SuperHigh
};

enum ENetRole
{
	ROLE_None,				// No role at all.
	ROLE_DumbProxy,			// Dumb	proxy of this actor.
	ROLE_SimulatedProxy,	// Locally simulated proxy of this actor.
	ROLE_AutonomousProxy,	// Locally autonomous proxy	of this	actor.
	ROLE_Authority,			// Authoritative control over the actor.
};

enum ERenderStyle
{
	STY_None,
	STY_Normal,
	STY_Masked,
	STY_Translucent,
	STY_Modulated,
	STY_Alpha,
	STY_Additive,
	STY_Subtractive,
	STY_Particle,
	STY_AlphaZ,
};

enum ESoundOcclusion
{
	OCCLUSION_Default,
	OCCLUSION_None,
	OCCLUSION_BSP,
	OCCLUSION_StaticMeshes,
};

enum ESoundSlot
{
	SLOT_None,
	SLOT_Misc,
	SLOT_Pain,
	SLOT_Interact,
	SLOT_Ambient,
	SLOT_Talk,
	SLOT_Interface,
	SLOT_WeaponFire1,
	SLOT_WeaponFire2
};

enum ESoundCategory
{
    SC_MUSIC,
    SC_AMBIENT,
    SC_CINEMATIC,
    SC_SOUNDFX,
};

enum EMusicTransition
{
	MTRAN_None,
	MTRAN_Instant,
	MTRAN_Segue,
	MTRAN_Fade,
	MTRAN_FastFade,
	MTRAN_SlowFade,
};

enum EForceType
{
	FT_None,
	FT_DragAlong,
};

enum ETravelType
{
	TRAVEL_Absolute,	// Absolute	URL.
	TRAVEL_Partial,		// Partial (carry name,	reset server).
	TRAVEL_Relative,	// Relative	URL.
};

enum EDoubleClickDir
{
	DCLICK_None,
	DCLICK_Left,
	DCLICK_Right,
	DCLICK_Forward,
	DCLICK_Back,
	DCLICK_Active,
	DCLICK_Done
};

enum eKillZType
{
	KILLZ_None,
	KILLZ_Lava,
	KILLZ_Suicide
};

enum EUnitType
{
	UnitType_Assault,
	UnitType_Base,
	UnitType_Vehicle,
	UnitType_None
};

enum ESpecialSort
{
    SS_Default,
    SS_SkyDome,
    SS_SkyTerrainOuter,
    SS_Normal,
    SS_Wires,
    SS_Water,
    SS_SkyTerrainInner,
    SS_SkyDistantObjects,
};

struct ActorRenderDataPtr {	var	int	Ptr; };
struct LightRenderDataPtr {	var	int	Ptr; };
struct ProjectorRenderInfoPtr {	var	int	Ptr; };	// Hack	to to fool C++ header generation...
struct StaticMeshProjectorRenderInfoPtr	{ var int Ptr; };

struct BatchReference
{
	var	int	BatchIndex;
	var	int	ElementIndex;
};

struct PointRegion
{
	var	zoneinfo	Zone;		// Zone.
	var	int			iLeaf;		// Bsp leaf.
	var	byte		ZoneNumber;	// Zone	number.
};

struct native export XboxAddr
{
	var	int		ina;
	var	int		inaOnline;
	var	int		wPortOnline;
	var	int		VoiceChatterHandle;
	var int		VoiceChannel;
	var	byte	abEnet[6];
	var	byte	abOnline[20];
	var	String	Gamertag;
};

struct KRBVec
{
	var	float	X;
	var	float	Y;
	var	float	Z;
};

struct KRigidBodyState
{
	var	KRBVec	Position;
	var	Quat	Quaternion;
	var	KRBVec	LinVel;
	var	KRBVec	AngVel;
};

struct KCarState
{
	var	KRBVec ChassisPosition;
	var	Quat   ChassisQuaternion;
	var	KRBVec ChassisLinVel;
	var	KRBVec ChassisAngVel;
	var	float  WheelHeight[4]; // FL, FR, RL, RR
	var	float  FrontWheelAng[2]; //	FL,	FR
	var	float  WheelVertVel[4];
	var	float  ServerSteering;
	var	float  ServerTorque;
	var	bool   ServerBrake;
	var	bool   ServerHandbrakeOn;
	var	bool   bNewState; // Set to	true whenever a	new	state is received and should be	processed
};

// Scary internal params used by Karma. BE VERY CAREFUL!!
// NB. These take affect until you quit the game! Make sure you reset them to defaults when leaving mod etc.

struct KSimParams
{
	var	float	GammaPerSec; // Relaxation constant. Making it larger pushes things apart harder when they penetrate.
	var	float	Epsilon; // Global constraint compliance. Making it larger makes contacts/joints softer.
	var	float	PenetrationOffset; // Resting penetration. Making this larger can reduce jiggling.
	var	float	PenetrationScale; // Artificially increase penetration - makes contacts 'stiffer'
	var	float	ContactSoftness; // Softness of just contact constraints.
	var	float	MaxPenetration; // Maximum penetration allowed.
	var	float	MaxTimestep; // Maximum timestep ever used to advance rigid body simulation.
};

struct AnimRep
{
	var	name AnimSequence;
	var	bool bAnimLoop;
	var	byte AnimRate;		// note	that with compression, max replicated animrate is 4.0
	var	byte AnimFrame;
	var	byte TweenRate;		// note	that with compression, max replicated tweentime	is 4 seconds
};

// GEARBOX: GBX:naj: Flags are a kind of 'smart bool.'  In addition to maintaining a binary statement,
// they also mark the time that they were set to true or false ('raised' and 'lowered' time, respectively).
// When set to true, they also can be set with an optional time-out value; when the time-out expires, the flag
// is set to false automatically.  The time-out is updated lazily, that is, only when one of the flag's functions 
// are called, so there's no need for an expensive update loop to maintain the flags.
struct native export Flag
{
	var byte Value;
	var byte Raised;
	var byte Lowered;
	var float RaisedTime;
	var float LoweredTime;
	var float Duration;
};

//
//// BEGIN POINTERS
//////
var				const Actor							Owner;				// Owner actor.
var				const Actor							Base;				// Actor we're standing	on.
var				const LevelInfo						Level;				// Level this actor	is on.
var				transient const	Level				XLevel;				// Level object.
var(Display)	mesh								Mesh;				// Mesh	if DrawType=DT_Mesh.
var(Display)	const StaticMesh					StaticMesh;			// StaticMesh if DrawType=DT_StaticMesh
var				transient MeshInstance				MeshInstance;		// Mesh	instance.
var				const native ActorRenderDataPtr		ActorRenderData;
var				const native LightRenderDataPtr		LightRenderData;
var				Pawn								Instigator;			// Pawn	responsible	for	damage caused by this actor.
var(Sound)		sound								AmbientSound;		// Ambient sound effect.
var				Inventory							Inventory;			// Inventory chain.
var(Display)	Material							Texture;			// Sprite texture.if DrawType=DT_Sprite
var				StaticMeshInstance					StaticMeshInstance;	// Contains	per-instance static	mesh data, like	static lighting	data.
var				const export model					Brush;				// Brush if	DrawType=DT_Brush.
var				const PhysicsVolume					PhysicsVolume;		// physics volume this actor is	currently in
var(Display)	ConvexVolume						AntiPortal;			// Convex volume used for DT_AntiPortal
var				Material							RepSkin;			// replicated skin (sets Skins[0] if not none)
var				const actor							Deleted;			// Next	actor in just-deleted chain.
var				Actor								PendingTouch;		// Actor touched during	move which wants to	add	an effect after	the	movement completes
var(Karma)		export editinline KarmaParamsCollision KParams;			// Parameters for Karma	Collision/Dynamics.
var				class<LocalMessage>					MessageClass;
var(Display)	transient mesh						EditorMesh;			// Mesh	if DrawType=DT_Mesh.
var(Display)	string								EditorMeshName;		// mesh name to be loaded in the editor when Mesh == None
var(Display)	transient StaticMesh				EditorStaticMesh;	// Mesh	if DrawType=DT_StaticMesh.
var(Display)	string								EditorStaticMeshName;	// mesh name to be loaded in the editor when StaticMesh == None
//////
//// END POINTERS
//

var(Movement)	const vector				Location;			// Actor's location; use Move to set.
var(Movement)	const rotator				Rotation;			// Rotation.
var(Movement)	vector						Velocity;			// Velocity.
var				vector						Acceleration;		// Acceleration.
var				vector						CachedLocation;
var				rotator						CachedRotation;		// Temporarily leaving in for being	able to	test bad coherency of LocalToWorld() and WorldToLocal()
var				transient const	Matrix		CachedLocalToWorld;	// Cached for lookups to LocalToWorld()	calls
var				transient const	Matrix		CachedWorldToLocal;	// Cached for lookups to WorldToLocal()	calls
var				const Matrix				HardRelMatrix;		// Transform of	actor in base's	ref	frame. Doesn't change after	SetBase.

//
//// BEGIN BOOLS
//////
var(Advanced)	bool						bStatic;				// Does	not	move or	change over	time. Don't	let	L.D.s change this -	screws up net play
var(Advanced)	bool						bHidden;				// Is hidden during	gameplay.
var(Advanced)	const bool					bNoDelete;				// Cannot be deleted during	play.
var				const bool					bDeleteMe;				// About to	be deleted.
var				const bool					bKeepOnClient;			// Keep around on the client when spawned during level loading...needed since you can't spawn something with bNoDelete 2005-02-04 JWS
var(Lighting)	bool						bDynamicLight;			// This	light is dynamic.
var				bool						bTimerLoop;				// Timer loops (else is	one-shot).
var				bool						bOnlyOwnerSee;			// Only	owner can see this actor.
var(Advanced)	bool						bHighDetail;			// Only	show up	in high	or super high detail mode.
var(Advanced)	bool						bSuperHighDetail;		// Only	show up	in super high detail mode.
var				bool						bOnlyDrawIfAttached;	// don't draw this actor if	not	attached (useful for net clients where attached	actors and their bases'	replication	may	not	be synched)
var(Advanced)	bool						bStasis;				// In StandAlone games,	turn off if	not	in a recently rendered zone	turned off if  bStasis	and	physics	= PHYS_None	or PHYS_Rotating.
var				bool						bTrailerAllowRotation;	// If PHYS_Trailer and want	independent	rotation control.
var				bool						bTrailerSameRotation;	// If PHYS_Trailer and true, have same rotation	as owner.
var				bool						bTrailerPrePivot;		// If PHYS_Trailer and true, offset	from owner by PrePivot.
var				bool						bWorldGeometry;			// Collision and Physics treats	this actor as world	geometry
var(Display)	bool						bAcceptsProjectors;		// Projectors can project onto this	actor
var				bool						bAcceptsShadowProjectors;   // ZONER: OBSOLETE DUE TO bProjFlag system below (bool kept for conversion with ucc pkgxform tool)
var				bool						bOrientOnSlope;			// when	landing, orient	base on	slope of floor
var				const bool					bOnlyAffectPawns;		// Optimisation	- only test	ovelap against pawns. Used for influences etc.
var(Display)	bool						bDisableSorting;		// Manual override for translucent material	sorting.
var(Movement)	bool						bIgnoreEncroachers;		// Ignore collisions between movers	and
var				bool						bShowOctreeNodes;
var				bool						bWasSNFiltered;				// Mainly for debugging	- the way this actor was inserted into Octree.
var				const bool					bNetTemporary;				// Tear-off	simulation in network play.
var				bool						bOnlyRelevantToOwner;		// this	actor is only relevant to its owner.
var				bool						bAlwaysRelevant;			// Always relevant for network.
var				bool						bReplicateInstigator;		// Replicate instigator	to client (used	by bNetTemporary projectiles).
var				bool						bReplicateMovement;			// if true,	replicate movement/location	related	properties
var				bool						bSkipActorPropertyReplication; // if true, don't replicate actor class variables for this actor
var				bool						bUpdateSimulatedPosition;	// if true,	update velocity/location after initialization for simulated	proxies
var				bool						bTearOff;					// if true,	this actor is no longer	replicated to new clients, and is "torn	off" (becomes a	ROLE_Authority)	on clients to which	it was being replicated.
var				bool						bOnlyDirtyReplication;		// if true,	only replicate actor if	bNetDirty is true -	useful if no C++ changed attributes	(such as physics) bOnlyDirtyReplication	only used with bAlwaysRelevant actors
var				bool						bReplicateAnimations;		// Should replicate	SimAnim
var	const		bool						bNetInitialRotation;		// Should replicate	initial	rotation
var				bool						bCompressedPosition;		// used	by networking code to flag compressed position replication
var				bool						bAlwaysZeroBoneOffset;		// if true,	offset always zero when	attached to	skeletalmesh
var(Display)	bool						bOpaqueForSituationalAwarenessView;	// GBX:PAD:	If set to true,	this can be	seen through in	situational	awareness view
var(Display)	bool						bAlphaFogBlend;			// GBX:ZONER: This actor should	dynamically	turn on	alpha blending and fade	out	(aka alpha fog)
var(Display)	bool						bDontFrustumCull;		// GBX:jlb:	Don't do frustum culling (needed sometimes when	mesh needs to be rendered when location	is outside frustum)
var(Display)	bool						bIgnoreFarPlane;		// GBX:ZONER: Ignore far plane defined by zone fog,	or zone	distance fade (alpha fog)
var(Display)	bool						bDoInverseDistanceFade;	// For (some) skybox actors, they should use the inverse distancefade ranges from their	zoneinfo instead of	the	normal distancefade	for	alpha fog
var(Display)    bool                        bRenderAttachmentsFirst;    // GBX:ZONER: Forces the attachments to render before the actor (only affects emitters since static/skelmesh attachments are batched up via other methods)
var(Display)    bool                        bRenderExtendedFirst;    // GBX:ZONER: Forces the attachments to render before the actor (only affects emitters since static/skelmesh attachments are batched up via other methods)
var(Material)	bool						GetSurfTypeFromTexture;	// GBX:naj - added 5/23/03
var(Lighting)	bool						bSpecialLit;			// Only	affects	special-lit	surfaces.
var(Lighting)	bool						bIgnoreZoneAmbient;		// GBX:ZONER: Actor does not receive zone ambient lighting
var(Lighting)	bool						bActorShadows;			// Light casts actor shadows.
var(Lighting)	bool						bSelfShadowing;			// actor casts shadows on itself
var(Lighting)	bool						bCorona;				// Light uses Skin as a	corona.
var(Lighting)	bool						bBloom;					// Light generates bloom
var(Lighting)	bool						bLightingVisibility;	// Calculate lighting visibility for this actor	with line checks.
var(Lighting)	bool						bUseDynamicLights;
var				bool						bLightChanged;			// Recalculate this	light's	lighting now.
var(Movement)	bool						bHardAttach;			// Uses	'hard' attachment code.	bBlockActor	and	bBlockPlayer must also be false.  This actor cannot	then move relative to base (setlocation	etc.). Dont	set	while currently	based on something!
var(Lighting)	bool						bUnlit;					// Lights don't	affect actor.
var(Lighting)	bool						bUseAmbientForUnlit;	// Actor's AmbientLight/AmbientAlpha is used when bUnlit is true instead of hardcoded (127/127/127/255)
var(Lighting)	bool						bShadowCast;			// Casts static	shadows.
var(Lighting)	bool						bStaticLighting;		// Uses	raytraced lighting.
var(Lighting)	bool						bUseLightingFromBase;	// Use Unlit/AmbientGlow from Base
var(Display)	bool						bAlphaFogable;			// Should calculate	and	set	alphafog/alpharefscale
var				bool						bHurtEntry;				// keep	HurtRadius from	being reentrant
var(Advanced)	bool						bGameRelevant;			// Always relevant for game
var(Advanced)	bool						bCollideWhenPlacing;	// This	actor collides with	the	world when placing.
var				bool						bTravel;				// Actor is	capable	of travelling among	servers.
var(Advanced)	bool						bMovable;				// Actor can be	moved.
var				bool						bDestroyInPainVolume;	// destroy this	actor if it	enters a pain volume
var				bool						bCanBeDamaged;			// can take	damage
var(Advanced)	bool						bShouldBaseAtStartup;	// if true,	find base for this actor at	level startup, if collides with	world and PHYS_None	or PHYS_Rotating
var				bool						bPendingDelete;			// set when	actor is about to be deleted (since	endstate and other functions called	during deletion	process	before bDeleteMe is	set).
var				bool						bAnimByOwner;			// Animation dictated by owner.
var				bool						bOwnerNoSee;			// Everything but the owner	can	see	this actor.
var(Advanced)	bool						bCanTeleport;			// This	actor can be teleported.
var				bool						bClientAnim;			// Don't replicate any animations -	animation done client-side
var				bool						bDisturbFluidSurface;	// Cause ripples when in contact with FluidSurface.
var				const bool					bAlwaysTick;			// Update even when	players-only.
var(Sound)		bool						bFullVolume;			// Whether to apply	ambient	attenuation.
var(Collision)	const bool					bCollideActors;			// Collides	with other actors.
var(Collision)	bool						bCollideWorld;			// Collides	with the world.
var(Collision)	bool						bBlockActors;			// Blocks other	nonplayer actors.
var(Collision)	bool						bBlockPlayers;			// Blocks other	player actors.
var(Collision)	bool						bBlockPlayersUS;		// Blocks other	player actors but only if they are on the US team
var(Collision)	bool						bBlockPlayersGerman;	// Blocks other	player actors but only if they are on the German team
var(Collision)	bool						bBlockPlayersSpecial;	// Uses	a callback to block	players	(only valid	if bBlockPlayersUS or bBlockPlayersGerman is true)
var(Collision)	bool						bProjTarget;			// Projectiles should potentially target this actor.
var(Collision)	bool						bBlockZeroExtentTraces;	// block zero extent actors/traces
var(Collision)	bool						bBlockNonZeroExtentTraces;	  // block non-zero	extent actors/traces
var(Collision)	bool						bAutoAlignToTerrain;	// Auto-align to terrain in	the	editor
var(Collision)	bool						bUseCylinderCollision;	// Force axis aligned cylinder collision (useful for static	mesh pickups, etc.)
var(Collision)	const bool					bBlockKarma;			// Block actors	being simulated	with Karma.
var(Collision)	bool						bCollideSkeletalMesh;	// Collide with	BoneCollisionSphere	or BoneCollisionBoxes of skeletal meshes
var(Collision)	const bool					bTraceListener;			// This	actor would	like to	be notified	(via event TraceTouch) of traces that penetrate	it.	bCollideActors must	also be	true.
var(Collision)	const bool					bVisBlockingVolume;		// This	actor is a VisBlockingVolume (blocks visibility of AI Pawns)
var				bool						bNetNotify;				// actor wishes	to be notified of replication events
var				bool						bIgnoreOutOfWorld;		// Don't destroy if	enters zone	zero
var(Movement)	bool						bBounce;				// Bounces when	hits ground	fast.
var(Movement)	bool						bFixedRotationDir;		// Fixed direction of rotation.
var(Movement)	bool						bRotateToDesired;		// Rotate to DesiredRotation.
var				bool						bInterpolating;			// Performing interpolating.
var				const bool					bJustTeleported;		// Used	by engine physics -	not	valid for scripts.
var				bool						bMessageListener;		//GEARBOX/jmw:add -	FEATURE: Messaging System
var				const bool					bNetInitial;			// Initial network update.
var				const bool					bNetOwner;				// Player owns this	actor.
var				const bool					bNetRelevant;			// Actor is	currently relevant.	Only valid server side,	only when replicating variables.
var				const bool					bDemoRecording;			// True	we are currently demo recording
var				const bool					bClientDemoRecording;	// True	we are currently recording a client-side demo
var				const bool					bRepClientDemo;			// True	if remote client is	recording demo
var				const bool					bClientDemoNetFunc;		// True	if we're client-side demo recording	and	this call originated from the remote.
var				const bool					bDemoOwner;				// Demo	recording driver owns this actor.
var				bool						bNoRepMesh;				// don't replicate mesh
var(Advanced)	bool						bHiddenEd;				// Is hidden during	editing.
var(Advanced)	bool						bHiddenEdGroup;			// Is hidden by	the	group brower.
var(Advanced)	bool						bDirectional;			// Actor shows direction arrow during editing.
var				const bool					bSelected;				// Selected	in UnrealEd.
var(Advanced)	bool						bEdShouldSnap;			// Snap	to grid	in editor.
var				bool						bObsolete;				// actor is	obsolete - warn	level designers	to remove it
var(Collision)	bool						bPathColliding;			// this	actor should collide (if bWorldGeometry	&& bBlockActors	is true) during	path building (ignored if bStatic is true, as actor	will always	collide	during path	building)
var				bool						bScriptInitialized;		// set to prevent re-initializing of actors	spawned	during level startup
var(Advanced)	bool						bLockLocation;			// Prevent the actor from being	moved in the editor.
var				bool						m_bUseRootRotation;		// Is root motion translation turned on	for	this Pawn?
var				bool						m_fNoCalcBones;			// If set, do not calculate	bones in GetFrame.	Just use whatever was last in the cache.
var				bool						m_fAutoSetFrameOffset;	// If set, then	GetFrame will automatically	figure out a good frame	offset to which	to throttle	the	animation rate.
var(Display)    bool                        bPlanarSort;            // Actor is a XY axis aligned sheet (aka water) and should alpha sort based on Z distance to camera 
var(Oracle)		bool						bExcludeFromOracleCam;	// This actor is always excluded from situational awareness view
var				bool						bTraceWater;			// if true, trace() by this actor returns collisions with water volumes -BB
var				bool						bUnloaded;				// RSC: added for unlimited ammo cheat
var(Display)    bool                        bUseSpecialZoneClipPlanes;
var				const bool					bDeleteSimple;			// We know this has no references to it, so go ahead and free up the memory without iterating through all actors to clear properties.
var				const bool					bKillPoolableEarly;		// If this flag is set, we are saying that Spawn can create a new instance using a still active instance of the actor in the pool.


//////
//// END BOOLS
//

var				float						flActorCreateTime;		// At what time was this actor spawned?  Used to grab the most convenient and oldest poolable actor.

//
//// BEGIN ENUMS AND BYTES
//////
var(Lighting)	ELightType					LightType;
var(Lighting)	ELightEffect				LightEffect;
var(Movement)	const EPhysics				Physics;
var(Material)	ESurfaceTypes				SurfaceType;			// GBX:naj - added 5/22/03
var(Display)	const EDrawType				DrawType;
var				const native EFilterState	StaticFilterState;
var				ENetRole					RemoteRole;
var				ENetRole					Role;
var(Display)	ERenderStyle				Style;
var(Sound)		ESoundOcclusion				SoundOcclusion;			// Sound occlusion approach.
var(Force)		EForceType					ForceType;
var(Display)    ESpecialSort                SpecialSort;
var(LightColor)	byte						LightHue;
var(LightColor)	byte						LightSaturation;
var(Lighting)	byte						LightPeriod;
var(Lighting)	byte						LightPhase;
var(Lighting)	byte						LightCone;
var(AmbientColor)	byte					AmbientGlow;		// ZONER: deprecated, favor	using AmbientHue/AmbientSaturation/AmbientBrightness instead
var(AmbientColor)	byte					AmbientHue;
var(AmbientColor)	byte					AmbientSaturation;
var(AmbientColor)	byte					AmbientBrightness;
var(AmbientColor)   byte                    AmbientAlpha;
var(Lighting)	byte						MaxLights;			// Limit to	hardware lights	active on this primitive.
var(Sound)		byte						SoundVolume;			// Volume of ambient sound.
var(Sound)		byte						SoundPitch;				// Sound pitch shift, 64.0=none.
var				byte						m_bBoneCalcFrameOffset;		   // If >0, then wait every set frame before recalculating	bones in GetFrame, otherwise use what was last in the cache.
var				byte						m_bMaxBoneCalcFrameOffset;	   // If >0, then wait every set frame before recalculating	bones in GetFrame, otherwise use what was last in the cache.
var				byte						m_bCurBoneCalcFrameOffset;	   // Countdown	of how many	frames to go before	we calculate bones again.
//////
//// END ENUMS AND BYTES
//

//
////
////// TRANSIENT BOOLS
var				transient const	bool		bTicked;				// Actor has been updated.
var				transient const	bool		bNetDirty;					// set when	any	attribute is assigned a	value in unrealscript, reset when the actor	is replicated
var				transient bool				bLocalToWorldCached;	// Zoner: used for caching LocalToWorld() and WorldToLocal()
var				transient bool				bWorldToLocalCached;	// Zoner: used for caching LocalToWorld() and WorldToLocal()
var				transient bool				bEdSnap;				// Should snap to grid in UnrealEd.
var				transient const	bool		bTempEditor;			// Internal	UnrealEd.
var				transient bool				bPathTemp;				// Internal/path building
var				transient const bool		bShouldStopKarma;		// Internal.
////// END TRANSIENT BOOLS
////
//

var				color						MyLighting;
var(LightColor)	float						LightBrightness;
var(Lighting)	float						LightRadius;
var				const native int			RenderRevision;
var(Display)	const name					ForcedVisibilityZoneTag; //	Makes the visibility code treat	the	actor as if	it was in the zone with	the	given tag.
var				transient const	int			NetTag;
var				float						NetUpdateTime;		// time of last update
var				float						NetUpdateFrequency;	// How many	seconds	between	net	updates.
var				float						NetPriority;		// Higher priorities means update it more frequently.
var				const name					AttachmentBone;		// name	of bone	to which actor is attached (if attached	to center of base, =='')
var(Advanced)	float						LifeSpan;			// How old the object lives	before dying, 0=forever.
var				const PointRegion			Region;			// Region this actor is	in.
var				float						TimerRate;		// Timer event,	0=no timer.
var				transient float				LastRenderTime;	// last	time this actor	was	rendered.
var(Events)		name						Tag;			// Actor's tag name.
var				transient array<int>		Leaves;			// BSP leaves this actor is	in.
var(Events)		name						Event;			// The event this actor	causes.
var				const float					TimerCounter;	// Counts up until it reaches TimerRate.
var(Object)		name						InitialState;
var(Object)		name						Group;
var				const array<Actor>			Touching;		// List	of touching	actors.
var				transient const	array<int>	OctreeNodes;	// Array of	nodes of the octree	Actor is currently in. Internal	use	only.
var				transient const	Box			OctreeBox;		// Actor bounding box cached when added	to Octree. Internal	use	only.
var				transient const	vector		OctreeBoxCenter;
var				transient const	vector		OctreeBoxRadii;
var				const float					LatentFloat;	// Internal	latent function	use.
var				const native int			CollisionTag;
var				transient const	int			JoinedTag;
var(Movement)	name						AttachTag;
var				const array<Actor>			Attached;			// array of	actors attached	to this	actor.
var				const vector				RelativeLocation;	// location	relative to	base/bone (valid if	base exists)
var				const rotator				RelativeRotation;	// rotation	relative to	base/bone (valid if	base exists)
var				const native array<ProjectorRenderInfoPtr>				Projectors;			// Projected textures on this actor
var				const native array<StaticMeshProjectorRenderInfoPtr>	StaticMeshProjectors;
var				Vector						VecLightOffset;		// GBX:PAD:	added this to set an offset	from the actor location	at which dlights should	be applied
var(Display)	const float					DrawScale;			// Scaling factor, 1.0=normal size.
var(Display)	const vector				DrawScale3D;		// Scaling vector, (1.0,1.0,1.0)=normal	size.
var(Display)	vector						PrePivot;			// Offset from box center for drawing.
var(Display)	array<Material>				Skins;				// Multiple	skin support - not replicated.
var(Display)	float						CullDistance;		// 0 ==	no distance	cull, <	0 only drawn at	distance > 0 cull at distance
var(Display)	float						ScaleGlow;
var(Sound)		float						SoundRadius;			// Radius of ambient sound.
var(Sound)		float						TransientSoundVolume;  // default sound	volume for regular sounds (can be overridden in	playsound)
var(Sound)		float						TransientSoundRadius;  // default sound	radius for regular sounds (can be overridden in	playsound)
var(Collision)	const float					CollisionRadius;		// Radius of collision cyllinder.
var(Collision)	const float					CollisionHeight;		// Half-height cyllinder.
var(Movement)	float						Mass;				// Mass	of this	actor.
var(Movement)	float						Buoyancy;			// Water buoyancy.
var(Movement)	rotator						RotationRate;		// Change in rotation per second.
var(Movement)	rotator						DesiredRotation;	// Physics will	smoothly rotate	actor to this rotation if bRotateToDesired.
var				const vector				ColLocation;		// Actor's old location	one	move ago. Only for debugging
var				const native int			KStepTag;
var				float						AccumKarmaAngleError;
var				transient AnimRep			SimAnim;		 //	only replicated	if bReplicateAnimations	is true
var				vector						m_vecRootMotionOffset;	 //	Offset to allow	control	of translation direction of	the	root bone
var				const array<byte>			m_ExcludeSkeletalBranch; //	Array of bones that	are	the	root of	branches to	exclude	from skeletal calculations and blending.
var				float						m_fAmbientSoundFadeInTime;
var				float						m_fAmbientSoundFadeOutTime;
var				float						RagdollStartTime;  // time when KInitSkeletonKarma() was called on this Actor

////
// ZONER: HACK: Projector permission flags, for Projectors this is the kind of projector it is, for other Actors its what kind of projectors can hit it
// ZONER: HACK: Limited to 32 bits, these variables are cast to int and used as a bitmask to determine projector flags
// ZONER: DO NOT TOUCH THIS SECTION WITHHOUT UNDERSTANDING WHATS GOING ON IN C++!
// ZONER: Projectors should set the single-most best flag for the job (multiple are allowable but if any single mask to true it will project!)
// ZONER: If the projector doesn't set ANY FLAGS then bAcceptsProjectors is used at face-value like in original Unreal
//
var(Force)		float						ForceRadius;
var(Force)		float						ForceScale;
//
// Zoner: C++ CODE USES &ForceScale to calculate offset to bitfields (since we dont have a union here which is the normal way of doing things mixing int/bitfield operations)
//
var(ProjectorFlags)	bool    bProjFlag_Shadow;       // Pawn Shadows
var(ProjectorFlags) bool    bProjFlag_VehicleShadow;// Vehicle Shadows
var(ProjectorFlags) bool    bProjFlag_LevelShadow;  // Level Designer Projector
var(ProjectorFlags) bool    bProjFlag_Blood;        // Blood 
var(ProjectorFlags) bool    bProjFlag_Bullet;       // Small arms fire
var(ProjectorFlags) bool    bProjFlag_Blast;        // Grenades, Tank Shells, Panzerfust, Bazooka
var(ProjectorFlags)	bool    bProjFlag_SAVIcon;      // Situational Awareness View icons
var(ProjectorFlags) bool    bProjFlag_ObjectiveIcon;// Possible SAV Objective Icons
var(ProjectorFlags) bool    bProjFlag_CommandRing;  // Possible Command Ring Icons
var                 bool    bProjFlag_Unused_9;     // UNUSED
var                 bool    bProjFlag_Unused10;     // UNUSED
var                 bool    bProjFlag_Unused11;     // UNUSED
var                 bool    bProjFlag_Unused12;     // UNUSED
var                 bool    bProjFlag_Unused13;     // UNUSED
var                 bool    bProjFlag_Unused14;     // UNUSED
var                 bool    bProjFlag_Unused15;     // UNUSED
var                 bool    bProjFlag_Unused16;     // UNUSED
var                 bool    bProjFlag_Unused17;     // UNUSED
var                 bool    bProjFlag_Unused18;     // UNUSED
var                 bool    bProjFlag_Unused19;     // UNUSED
var                 bool    bProjFlag_Unused20;     // UNUSED
var                 bool    bProjFlag_Unused21;     // UNUSED
var                 bool    bProjFlag_Unused22;     // UNUSED
var                 bool    bProjFlag_Unused23;     // UNUSED
var                 bool    bProjFlag_Unused24;     // UNUSED
var                 bool    bProjFlag_Unused25;     // UNUSED
var                 bool    bProjFlag_Unused26;     // UNUSED
var                 bool    bProjFlag_Unused27;     // UNUSED
var                 bool    bProjFlag_Unused28;     // UNUSED
var                 bool    bProjFlag_Unused29;     // UNUSED
var                 bool    bProjFlag_Unused30;     // UNUSED
var                 bool    bProjFlag_Unused31;     // UNUSED
//
// ZONER: HACK: SEE ABOVE COMMENTS
////


//-----------------------------------------------------------------------------
// natives.

// Execute a console command in	the	context	of the current level and game engine.
native function	string ConsoleCommand( string Command );
native function IncRenderRevision();

// GBX:PAD:	Adding in support for extended attachments created by Robert Morgan.
simulated native function ExtendedAttachmentNamedGroup(	Actor anActor, String strGroupName );
simulated native function Mesh GetExtendedAttachment( Name nmSocketName, Name nmPartName );
simulated native function ExtendedAttachment( Actor	anActor, Name nmSocketName,	Name nmPartName	);
simulated native function ExtendedDetachment( Actor	anActor	);

// GBX:PAD:	This function allows one to	define the root	of a branch	in the skeleton	of a skeletal mesh where
// calculations	will not be	performed on that branch (basically	it will	save a few CPU cycles and just use the reference
// pose).
simulated native function SetSkeletalBranchExclusion( name nmBranchRoot	);
simulated native function UnsetSkeletalBranchExclusion(	name nmBranchRoot );

//-----------------------------------------------------------------------------
// Network replication.

replication
{
	// Location
	unreliable if (	(!bSkipActorPropertyReplication	|| bNetInitial)	&& bReplicateMovement
					&& (((RemoteRole ==	ROLE_AutonomousProxy) && bNetInitial)
						|| ((RemoteRole	== ROLE_SimulatedProxy)	&& (bNetInitial	|| bUpdateSimulatedPosition) &&	((Base == None)	|| Base.bWorldGeometry))
						|| ((RemoteRole	== ROLE_DumbProxy) && ((Base ==	None) || Base.bWorldGeometry)))	)
		Location;

	unreliable if (	(!bSkipActorPropertyReplication	|| bNetInitial)	&& bReplicateMovement
					&& ((DrawType == DT_Mesh) || (DrawType == DT_StaticMesh))
					&& (((RemoteRole ==	ROLE_AutonomousProxy) && bNetInitial)
						|| ((RemoteRole	== ROLE_SimulatedProxy)	&& (bNetInitial	|| bUpdateSimulatedPosition) &&	((Base == None)	|| Base.bWorldGeometry))
						|| ((RemoteRole	== ROLE_DumbProxy) && ((Base ==	None) || Base.bWorldGeometry)))	)
		Rotation;

	unreliable if (	(!bSkipActorPropertyReplication	|| bNetInitial)	&& bReplicateMovement
					&& RemoteRole<=ROLE_SimulatedProxy )
		Base,bOnlyDrawIfAttached;

	unreliable if( (!bSkipActorPropertyReplication || bNetInitial) && bReplicateMovement
					&& RemoteRole<=ROLE_SimulatedProxy && (Base	!= None) &&	!Base.bWorldGeometry)
		RelativeRotation, RelativeLocation,	AttachmentBone;

	// Physics
	unreliable if( (!bSkipActorPropertyReplication || bNetInitial) && bReplicateMovement
					&& (((RemoteRole ==	ROLE_SimulatedProxy) &&	(bNetInitial ||	bUpdateSimulatedPosition))
						|| ((RemoteRole	== ROLE_DumbProxy) && (Physics == PHYS_Falling))) )
		Velocity;

	unreliable if( (!bSkipActorPropertyReplication || bNetInitial) && bReplicateMovement
					&& (((RemoteRole ==	ROLE_SimulatedProxy) &&	bNetInitial)
						|| (RemoteRole == ROLE_DumbProxy)) )
		Physics;

	unreliable if( (!bSkipActorPropertyReplication || bNetInitial) && bReplicateMovement
					&& (RemoteRole <= ROLE_SimulatedProxy) && (Physics == PHYS_Rotating) )
		bFixedRotationDir, bRotateToDesired, RotationRate, DesiredRotation;

	// Ambient sound.
	unreliable if( (!bSkipActorPropertyReplication || bNetInitial) && (Role==ROLE_Authority) &&	(!bNetOwner	|| !bClientAnim) )
		AmbientSound;

	unreliable if( (!bSkipActorPropertyReplication || bNetInitial) && (Role==ROLE_Authority) &&	(!bNetOwner	|| !bClientAnim)
					&& (AmbientSound!=None)	)
		SoundRadius, SoundVolume, SoundPitch;

	// Animation.
	unreliable if( (!bSkipActorPropertyReplication || bNetInitial)
				&& (Role==ROLE_Authority) && (DrawType==DT_Mesh) &&	bReplicateAnimations )
		SimAnim;

	unreliable if (	(!bSkipActorPropertyReplication	|| bNetInitial)	&& (Role==ROLE_Authority) )
		bHidden, bOwnerNoSee, bHardAttach;

	// Properties changed using	accessor functions (Owner, rendering, and collision)
	unreliable if (	(!bSkipActorPropertyReplication	|| bNetInitial)	&& (Role==ROLE_Authority) && bNetDirty )
		Owner, DrawScale, DrawType,	bCollideActors,bCollideWorld,bOnlyOwnerSee,Texture,Style, RepSkin;

	unreliable if (	(!bSkipActorPropertyReplication	|| bNetInitial)	&& (Role==ROLE_Authority) && bNetDirty
					&& (bCollideActors || bCollideWorld) )
		bProjTarget, bBlockActors, bBlockPlayers, CollisionRadius, CollisionHeight;

	// Properties changed only when	spawning or	in script (relationships, rendering, lighting)
	unreliable if (	(!bSkipActorPropertyReplication	|| bNetInitial)	&& (Role==ROLE_Authority) )
		Role,RemoteRole,bNetOwner,LightType,bTearOff;

	unreliable if (	(!bSkipActorPropertyReplication	|| bNetInitial)	&& (Role==ROLE_Authority)
					&& bNetDirty &&	bNetOwner )
		Inventory;

	unreliable if (	(!bSkipActorPropertyReplication	|| bNetInitial)	&& (Role==ROLE_Authority)
					&& bNetDirty &&	bReplicateInstigator )
		Instigator;

	// Infrequently	changed	mesh properties
	unreliable if (	(!bSkipActorPropertyReplication	|| bNetInitial)	&& (Role==ROLE_Authority)
					&& bNetDirty &&	(DrawType == DT_Mesh) )
		AmbientGlow,bUnlit,PrePivot;

	unreliable if (	(!bSkipActorPropertyReplication	|| bNetInitial)	&& (Role==ROLE_Authority)
					&& bNetDirty &&	!bNoRepMesh	&& (DrawType ==	DT_Mesh) )
		Mesh;

	unreliable if (	(!bSkipActorPropertyReplication	|| bNetInitial)	&& (Role==ROLE_Authority)
				&& bNetDirty &&	(DrawType == DT_StaticMesh)	)
		StaticMesh;

	// Infrequently	changed	lighting properties.
	unreliable if (	(!bSkipActorPropertyReplication	|| bNetInitial)	&& (Role==ROLE_Authority)
					&& bNetDirty &&	(LightType != LT_None) )
		LightEffect, LightBrightness, LightHue,	LightSaturation,
		LightRadius, LightPeriod, LightPhase, bSpecialLit;

	// replicated functions
	unreliable if( bDemoRecording )
		DemoPlaySound;

	reliable if ( bNetDirty && Role==ROLE_Authority )
		bInterpolating;
}

//=============================================================================
// Actor error handling.

// Handle an error and kill	this one actor.
native(233)	final function Error( coerce string	S );

//=============================================================================
// General functions.

// Latent functions.
native(256)	final latent function Sleep( float Seconds );

// Collision.
native(262)	final function SetCollision( optional bool NewColActors, optional bool NewBlockActors, optional	bool NewBlockPlayers );
native(283)	final function bool	SetCollisionSize( float	NewRadius, float NewHeight );
native final function SetDrawScale(float NewScale);
native final function SetDrawScale3D(vector	NewScale3D);
native final function SetStaticMesh(StaticMesh NewStaticMesh);
native final function SetDrawType(EDrawType	NewDrawType);

// Movement.
native(266)	final function bool	Move( vector Delta );
native(267)	final function bool	SetLocation( vector	NewLocation	);
native(299)	final function bool	SetRotation( rotator NewRotation );

// SetRelativeRotation() sets the rotation relative	to the actor's base
native final function bool SetRelativeRotation(	rotator	NewRotation	);
native final function bool SetRelativeLocation(	vector NewLocation );

native(3969) final function	bool MoveSmooth( vector	Delta );
native(3971) final function	AutonomousPhysics(float	DeltaSeconds);

// Relations.
native(298)	final function SetBase(	actor NewBase, optional	vector NewFloor	);
native(272)	final function SetOwner( actor NewOwner	);

//=============================================================================
// Animation.

native final function string GetMeshName();

// Animation functions.
native(259)	final function PlayAnim( name Sequence,	optional float Rate, optional float	TweenTime, optional	int	Channel, optional bool bRootMotionBlend, optional byte bTeleportRootType );
native(260)	final function LoopAnim( name Sequence,	optional float Rate, optional float	TweenTime, optional	int	Channel, optional bool bRootMotionBlend, optional byte bTeleportRootType );
native(294)	final function TweenAnim( name Sequence, float Time, optional int Channel, optional	bool bRootMotionBlend, optional	byte bTeleportRootType );
native(282)	final function bool	IsAnimating(optional int Channel);
native(261)	final latent function FinishAnim(optional int Channel);
native(263)	final function bool	HasAnim( name Sequence );
native final function StopAnimating( optional bool ClearAllButBase );
native final function FreezeAnimAt(	float Time,	optional int Channel);
native final function SetAnimFrame(	float Time,	optional int Channel, optional int UnitFlag	);
native final function GetNextAnimName( name	Sequence, out name NextSequence	);	// GBX:jlb - add for gbxAnimationCycler
native final function PauseAnim();	// pause the currently playing animation
native final function ResumeAnim();	 //	resume the currently paused	animation

native final function bool IsTweening(int Channel);

// Animation notifications.
event AnimEnd( int Channel );
native final function EnableChannelNotify (	int	Channel, int Switch	);
native final function int GetNotifyChannel();

// Skeletal	animation.
simulated native final function	bool LinkSkelAnim( MeshAnimation Anim, optional	mesh NewMesh );
simulated native final function	Object GetSkelAnimByName( string szAnimName	);
simulated native final function	UnlinkSkelAnim(	MeshAnimation Anim,	bool bUnlinkDefault	);
simulated native final function	Object UnlinkSkelAnimByName( string	szAnimName,	bool bUnlinkDefault	);
simulated native final function	DumpSkelAnim();
simulated native final function	DestroySkelAnimByIndex(	int	nAnimIdx );
simulated native final function	DestroySkelAnimByName( string szAnimName );
simulated native final function	float AnimLength( name Sequence	);
simulated native final function	LinkMesh( mesh NewMesh,	optional bool bKeepAnim	);
native final function BoneRefresh();

native final function AnimBlendParams( int Stage, optional float BlendAlpha, optional float	InTime,	optional float OutTime,	optional name BoneName,	optional bool bGlobalPose);
native final function AnimBlendToAlpha(	int	Stage, float TargetAlpha, float	TimeInterval );

// GEARBOX:	SJP
native final function coords  GetTagCoords(	name TagName );

native final function bool    BoneTagExists( name BoneName );
native final function coords  GetBoneCoords(   name	BoneName );
native final function rotator GetBoneRotation( name	BoneName, optional int Space );

native final function vector  GetRootLocation();
native final function rotator GetRootRotation();
native final function vector  GetRootLocationDelta();
native final function rotator GetRootRotationDelta();

native final function bool	AttachToBone( actor	Attachment,	name BoneName );
native final function bool	DetachFromBone(	actor Attachment );

native final function LockRootMotion( int Lock );
native final function SetBoneScale(	int	Slot, optional vector BoneScale, optional name BoneName	);

native final function SetBoneDirection(	name BoneName, rotator BoneTurn, optional vector BoneTrans,	optional float Alpha, optional int Space );
native final function SetBoneLocation( name	BoneName, optional vector BoneTrans, optional float	Alpha );
native final function SetBoneRotation( name	BoneName, optional rotator BoneTurn, optional int Space, optional float	Alpha );
native final function GetAnimParams( int Channel, out name OutSeqName, out float OutAnimFrame, out float OutAnimRate );
native final function bool AnimIsInGroup( int Channel, name	GroupName );

//=========================================================================
// Rendering.

native final function plane	GetRenderBoundingSphere();
native final function DrawDebugLine( vector	LineStart, vector LineEnd, byte	R, byte	G, byte	B);	// SLOW! Use for debugging only!

//=========================================================================
// Physics.

native final function DebugClock();
native final function DebugUnclock();

// Physics control.
native(301)	final latent function FinishInterpolation();
native(3970) final function	SetPhysics(	EPhysics newPhysics	);

native final function OnlyAffectPawns(bool B);

// ifdef WITH_KARMA

// NB. These take affect until you quit the game! Make sure you reset them to defaults when leaving mod etc.
native final function KGetSimParams(out KSimParams SimParams);
native final function KSetSimParams(KSimParams SimParams);

native final function quat KGetRBQuaternion();

native final function KGetRigidBodyState(out KRigidBodyState RBstate);
native final function KDrawRigidBodyState(KRigidBodyState RBState, bool	AltColour);	// SLOW! Use for debugging only!
native final function vector KRBVecToVector(KRBVec RBvec);
native final function KRBVec KRBVecFromVector(vector v);

native final function KSetMass(	float mass );
native final function float	KGetMass();

// Set inertia tensor assuming a mass of 1.	Scaled by mass internally to calculate actual inertia tensor.
native final function KSetInertiaTensor( vector	it1, vector	it2	);
native final function KGetInertiaTensor( out vector	it1, out vector	it2	);

native final function KSetDampingProps(	float lindamp, float angdamp );
native final function KGetDampingProps(	out	float lindamp, out float angdamp );

native final function KSetFriction(	float friction );
native final function float	KGetFriction();

native final function KSetRestitution( float rest );
native final function float	KGetRestitution();

native final function KSetCOMOffset( vector	offset );
native final function KGetCOMOffset( out vector	offset );
native final function KGetCOMPosition( out vector pos ); //	get	actual position	of actors COM in world space

native final function KSetImpactThreshold( float thresh	);
native final function float	KGetImpactThreshold();

native final function KWake();
native final function bool KIsAwake();
native final function KAddImpulse( vector Impulse, vector Position, optional name BoneName ); // A position of (0,0,0) applies impulse at COM (ie no angular component)
native final function KAddAngularImpulse( vector AngImpulse );

native final function KSetStayUpright( bool	stayUpright, bool allowRotate );
native final function KSetStayUprightParams( float stiffness, float	damping	);

native final function KSetBlockKarma( bool newBlock	);

native final function KSetActorGravScale( float	ActorGravScale );
native final function float	KGetActorGravScale();

// Disable/Enable Karma	contact	generation between this	actor, and another actor.
// Collision is	on by default.
native final function KDisableCollision( actor Other );
native final function KEnableCollision(	actor Other	);

// Ragdoll-specific	functions
native final function KSetSkelVel( vector Velocity,	optional vector	AngVelocity, optional bool AddToCurrent	);
native final function float	KGetSkelMass();
native final function KFreezeRagdoll();
native final function KScaleJointLimits(float scale, float stiffness);

// You MUST	turn collision off (KSetBlockKarma)	before using bone lifters!
native final function KAddBoneLifter( name BoneName, InterpCurve LiftVel, float	LateralFriction, InterpCurve Softness );
native final function KRemoveLifterFromBone( name BoneName );
native final function KRemoveAllBoneLifters();

// Used	for	only allowing a	fixed maximum number of	ragdolls in	action.
native final function KMakeRagdollAvailable();
native final function bool KIsRagdollAvailable();

// event called	when Karmic	actor hits with	impact velocity	over KImpactThreshold
event KImpact(actor	other, vector pos, vector impactVel, vector	impactNorm);

// event called	when karma actor's velocity	drops below	KVelDropBelowThreshold;
event KVelDropBelow();

// event called	when a ragdoll convulses (see KarmaParamsSkel)
event KSkelConvulse();

// event called	just before	sim	to allow user to
// NOTE: you should	ONLY put numbers into Force	and	Torque during this event!!!!
event KApplyForce(out vector Force,	out	vector Torque);

// This	is called from inside C++ physKarma	at the appropriate time	to update state	of Karma rigid body.
// If you return true, newState	will be	set	into the rigid body. Return	false and it will do nothing.
event bool KUpdateState(out	KRigidBodyState	newState);

// endif

native final function string GetLanguage();

// Timing
native final function Clock(out	float time);
native final function UnClock(out float	time);

native final function Perf_Begin(string	PerfMessage);
native final function Perf_End();
native final function Perf_End_us();
native final function Perf_Start();
native final function float Perf_Stop();  // returns the time in ms since Perf_Start() was called

//=========================================================================
// Music

native final function int PlayMusic( string	Song, float	FadeInTime, optional out float duration, optional bool bLooping );
native final function StopMusic( int SongHandle, float FadeOutTime );
native final function StopAllMusic(	float FadeOutTime );


//=========================================================================
// Engine notification functions.

//
// Major notifications.
//
simulated event Destroyed()
{
	local int i;

	if ( Level.NetMode != NM_Client )
	{
		// see if this Actor that we are about to destroy is in the Level.MoveTowardArray...
		for (i=0; i < Level.MoveTowardArray.Length; i++)
		{
			if (Level.MoveTowardArray[i].MyViewFocus == self)
				Level.MoveTowardArray[i].MyViewFocus = None;  // don't reference destroyed actors
		}
	}
}
event GainedChild( Actor Other );
event LostChild( Actor Other );
simulated event	Tick( float	DeltaTime );
simulated event	PostNetReceive();

//
// Triggers.
//
event Trigger( Actor Other,	Pawn EventInstigator );
event UnTrigger( Actor Other, Pawn EventInstigator );
event BeginEvent();
event EndEvent();

//
// Physics & world interaction.
//
event Timer();
event HitWall( vector HitLocation, vector HitNormal, actor HitWall );
event Falling();
event Landed( vector HitLocation, vector HitNormal );
event ZoneChange( ZoneInfo NewZone );
event PhysicsVolumeChange( PhysicsVolume NewVolume );
event Touch( Actor Other );
event PostTouch( Actor Other );	// called for PendingTouch actor after physics completes
event UnTouch( Actor Other );
event Bump(	Actor Other	);
event BaseChange();
event Attach( Actor	Other );
event Detach( Actor	Other );
event Actor	SpecialHandling(Pawn Other);
event bool EncroachingOn( actor	Other );
event EncroachedBy(	actor Other	);
event RanInto( Actor Other );	// called for encroaching actors which successfully	moved the other	actor out of the way
event FinishedInterpolation()
{
	bInterpolating = false;
}
// << GEARBOX/jmw:add -	FEATURE: Trace Listeners
event TraceTouch( Actor	Other, vector TouchLocation, vector	TouchNormal, vector	End, vector	Start, vector Extent, int TraceFlags );
// GEARBOX >>

event EndedRotation();			// called when rotation	completes
event bool UsedBy( Pawn	user )	// called if this Actor	was	touching a Pawn	who	pressed	Use
{
	return false;
}

simulated event	FellOutOfWorld(eKillZType KillType)
{
	SetPhysics(PHYS_None);
	Destroy();
}

//
// Damage and kills.
//
event KilledBy(	Pawn EventInstigator );
event TakeDamage( int Damage, Pawn EventInstigator,	vector HitLocation,	vector Momentum, class<DamageType> DamageType, optional	name HitBoxName);

//
// Trace a line	and	see	what it	collides with first.
// Takes this actor's collision	properties into	account.
// Returns first hit actor,	Level if hit level,	or None	if hit nothing.
//
native(277)	final function Actor Trace
(
	out	vector		HitLocation,
	out	vector		HitNormal,
	vector			TraceEnd,
	optional vector	TraceStart,
	optional bool	bTraceActors,
	optional vector	Extent,
	optional out material Material,
	optional bool	bTraceCollisionBoxes,
	optional bool	bNotifyListeners,		// GEARBOX/jmw:add - FEATURE: Trace	Listeners
	optional out name HitBoxName,
	optional actor	TraceActor,
	optional bool	bVisBlockingTest
);

// returns true	if did not hit world geometry
native(548)	final function bool	FastTrace
(
	vector			TraceEnd,
	optional vector	TraceStart,
	optional bool	bVisBlockingTest
);

// Line check just against this actor.
// Returns true if did not hit this actor.
native final function bool TraceThisActor
(
 out vector      HitLocation,
 out vector      HitNormal,
 vector          TraceEnd,
 vector          TraceStart,
 optional vector Extent
);

native final function bool TraceHitBackDrop(vector TraceEnd, vector TraceStart);  // did this trace hit a PF_FakeBackdrop surface?


//
// Spawn an	actor. Returns an actor	of the specified class,	not
// of class	Actor (this	is hardcoded in	the	compiler). Returns None
// if the actor	could not be spawned (either the actor wouldn't	fit	in
// the specified location, or the actor	list is	full).
// Defaults	to spawning	at the spawner's location.
//
native(278)	final function actor Spawn
(
	class<actor>	  SpawnClass,
	optional actor	  SpawnOwner,
	optional name	  SpawnTag,
	optional vector	  SpawnLocation,
	optional rotator  SpawnRotation
);

//
// Respawn an actor. Returns an	actor of the specified class, not
// of class	Actor (this	is hardcoded in	the	compiler). Returns None
// if the actor	could not be spawned (either the actor wouldn't	fit	in
// the specified location, or the actor	list is	full).
// Defaults	to spawning	at the spawner's location.
//
native(666)	final function actor Respawn
(
	actor			  SpawnActor,
	optional actor	  SpawnOwner,
	optional name	  SpawnTag,
	optional vector	  SpawnLocation,
	optional rotator  SpawnRotation
);

//
// Destroy this	actor. Returns true	if destroyed, false	if indestructable.
// Destruction is latent. It occurs	at the end of the tick.
//
native(279)	final function bool	Destroy();

// Networking -	called on client when actor	is torn	off	(bTearOff==true)
event TornOff();

//=============================================================================
// Timing.

// Causes Timer() events every NewTimerRate	seconds.
native(280)	final function SetTimer( float NewTimerRate, bool bLoop	);

//=============================================================================
// Sound functions.

// GEARBOX:	PSV: 4/6/2004 Added	to support Cues	
native function	Cue	LoadSound( String soundName	);

/* Play	a sound	effect.
*/
native(264)	final function int PlaySound  // modified to return	Sound ID that can be used to stop this sound
(
	sound				Sound,
	optional ESoundSlot	Slot,
	optional float		Volume,
	optional bool		bNoOverride,
	optional float		Radius,
	optional float		Pitch,
	optional bool		Attenuate,
	optional bool		bLipSync,
	optional name		BoneForLocation
);

/* Play	a sound	effect.
*/
native final function int PlaySoundCue	// modified	to return Sound	ID that	can	be used	to stop	this sound
(
	Cue					SoundCue,
	optional ESoundSlot	Slot,
	optional float		Volume,
	optional bool		bNoOverride,
	optional float		Radius,
	optional float		Pitch,
	optional bool		Attenuate,
	optional bool		bLipSync,
	optional name		BoneForLocation
);

native final function StopSound(int	SoundID, optional float	fadeOutDuration);  // added	to stop	sounds using Sound ID returned by PlaySound
native final function StopAllSounds(optional float fadeOutDuration);
native final function PauseAllSounds(optional bool IncludeAmbients,	optional bool IncludeMusic, optional bool Ingame);
native final function UnpauseAllSounds(optional bool Ingame);
native final function StopCurrentStereoAmbientSound();

native final function EnableSoundCategory( int category, bool bEnable, float fadeTime );	// Function to enable sounds of a certain type from playing

/* Control cinematic playback
*/
native final function SetCinematicFadeInTime( FLOAT	fadeInTime );
native final function SetCinematicFadeOutTime( FLOAT fadeOutTime );
native final function SetSoundGainDuringCinematic( FLOAT gain );

/* play	a sound	effect,	but	don't propagate	to a remote	owner
 (he is	playing	the	sound clientside)
 */
native simulated final function	int	PlayOwnedSound	// modified	to return Sound	ID that	can	be used	to stop	this sound
(
	sound				Sound,
	optional ESoundSlot	Slot,
	optional float		Volume,
	optional bool		bNoOverride,
	optional float		Radius,
	optional float		Pitch,
	optional bool		Attenuate,
	optional bool		bLipSync,
	optional name		BoneForLocation
);

native simulated final function	int	PlayOwnedSoundCue  // modified to return Sound ID that can be used to stop this	sound
(
	Cue					SoundCue,
	optional ESoundSlot	Slot,
	optional float		Volume,
	optional bool		bNoOverride,
	optional float		Radius,
	optional float		Pitch,
	optional bool		Attenuate,
	optional bool		bLipSync,
	optional name		BoneForLocation
);

native simulated final function int PlayLocalSoundCue  
(
	Cue					SoundCue,
	optional ESoundSlot Slot,
	optional bool		Attenuate
);

native simulated final function int PlayLocalSound
(
	sound				Sound,
	optional ESoundSlot Slot,
	optional bool		Attenuate
);

native simulated final function int PlayRemoteSoundCue  
(
	Cue					SoundCue,
	optional ESoundSlot Slot,
	optional bool		Attenuate,
	optional bool		bLipSync,
	optional name		BoneForLocation
);

native simulated final function int PlayRemoteSound
(
	Sound				Sound,
	optional ESoundSlot Slot,
	optional bool		Attenuate,
	optional bool		bLipSync,
	optional name		BoneForLocation
);

native simulated event DemoPlaySound
(
	sound				Sound,
	optional ESoundSlot	Slot,
	optional float		Volume,
	optional bool		bNoOverride,
	optional float		Radius,
	optional float		Pitch,
	optional bool		Attenuate,
	optional bool		bLipSync,
	optional int		SoundHandle,
	optional name		BoneForLocation
);

native simulated final function	bool IsSplitscreen();

/* Get a sound duration.
*/
native final function float	GetSoundDuration( sound	Sound );

/* Get a music clip duration.
*/
native final function float	GetMusicDuration( String Song, INT SongHandle );

/* Set an I3DL2	sound effect.
*/
native final function SetScriptedAudioEffect
(
	string					EffectClassName,
	optional float			EffectDurationSeconds,
	optional float			EffectFadeInSeconds,
	optional float			EffectFadeOutSeconds
);

/* Clear an	I3DL2 sound	effect.
*/
native final function ClearScriptedAudioEffect();

native final function Sound GetCueVariationFromSound( Sound SoundObject );

//=============================================================================
// Force Feedback.
// jdf ---
native(566)	final function PlayFeedbackEffect( String EffectName );
native(567)	final function StopFeedbackEffect( optional	String EffectName ); //	Pass no	parameter or ""	to stop	all
native(568)	final function bool	ForceFeedbackSupported();
// --- jdf

//=============================================================================
// AI functions.

/* Inform other	creatures that you've made a noise
 they might	hear (they are sent	a HearNoise	message)
 Senders of	MakeNoise should have an instigator	if they	are	not	pawns.
*/
native(512)	final function MakeNoise( float	Loudness );

/* PlayerCanSeeMe returns true if any player (server) or the local player (standalone
or client) has a line of sight to actor's location.
*/
native(532)	final function bool	PlayerCanSeeMe();

native final function vector SuggestFallVelocity(vector	Destination, vector	Start, float MaxZ, float MaxXYSpeed);

native final function ActorLite	GetNearestNavpoint(	vector Loc,	optional float radius, optional	bool bIgnoreZ, optional	bool bEnsureVisible, optional bool bOnlyClaimableNavpoints,	optional bool bOnlyUnclaimedNavpoints, optional	Pawn SomePawn );

//=============================================================================
// Regular engine functions.

// Teleportation.
event bool PreTeleport(	Teleporter InTeleporter	);
event PostTeleport(	Teleporter OutTeleporter );

// Level state.
event BeginPlay();

// rss: used for adding new packages to ServerPackages (only call between GameInfo::InitGame and GameInfo::SetInitialState
native final function AddToPackageMap(optional string PackageName);

//========================================================================
// Disk	access.

// Find	files.
native(539)	final function string GetMapName( string NameEnding, string	MapName, int Dir );
native(545)	final function GetNextSkin(	string Prefix, string CurrentSkin, int Dir,	out	string SkinName, out string	SkinDesc );
native(547)	final function string GetURLMap();
native final function string GetNextInt( string	ClassName, int Num );
native final function GetNextIntDesc( string ClassName,	int	Num, out string	Entry, out string Description );
native final function bool GetCacheEntry( int Num, out string GUID,	out	string Filename	);
native final function bool MoveCacheEntry( string GUID,	optional string	NewFilename	);

//=============================================================================
// Iterator	functions.

// Iterator	functions for dealing with sets	of actors.

/* AllActors() - avoid using AllActors() too often as it iterates through the whole	actor list and is therefore	slow
*/
native(304)	final iterator function	AllActors	  (	class<actor> BaseClass,	out	actor Actor, optional name MatchTag	);

/* DynamicActors() only	iterates through the non-static	actors on the list (still relatively slow, bu
 much better than AllActors).  This	should be used in most cases and replaces AllActors	in most	of
 Epic's	game code.
*/
native(313)	final iterator function	DynamicActors	  (	class<actor> BaseClass,	out	actor Actor, optional name MatchTag	);

/* ChildActors() returns all actors	owned by this actor.  Slow like	AllActors()
*/
native(305)	final iterator function	ChildActors	  (	class<actor> BaseClass,	out	actor Actor	);

/* BasedActors() returns all actors	based on the current actor (slow, like AllActors)
*/
native(306)	final iterator function	BasedActors	  (	class<actor> BaseClass,	out	actor Actor	);

/* TouchingActors()	returns	all	actors touching	the	current	actor (fast)
*/
native(307)	final iterator function	TouchingActors(	class<actor> BaseClass,	out	actor Actor	);

/* TraceActors() return	all	actors along a traced line.	 Reasonably	fast (like any trace)
*/
native(309)	final iterator function	TraceActors	  (	class<actor> BaseClass,	out	actor Actor, out vector	HitLoc,	out	vector HitNorm,	vector End,	optional vector	Start, optional	vector Extent );

/* RadiusActors() returns all actors within	a give radius.	Slow like AllActors().	Use	CollidingActors() or VisibleCollidingActors() instead if desired actor types are visible
(not bHidden) and in the collision hash	(bCollideActors	is true)
*/
native(310)	final iterator function	RadiusActors  (	class<actor> BaseClass,	out	actor Actor, float Radius, optional	vector Loc );

/* VisibleActors() returns all visible actors within a radius.	Slow like AllActors().	Use	VisibleCollidingActors() instead if	desired	actor types	are
in the collision hash (bCollideActors is true)
*/
native(311)	final iterator function	VisibleActors (	class<actor> BaseClass,	out	actor Actor, optional float	Radius,	optional vector	Loc	);

/* VisibleCollidingActors()	returns	visible	(not bHidden) colliding	(bCollideActors==true) actors within a certain radius.
Much faster	than AllActors() since it uses the collision hash
*/
native(312)	final iterator function	VisibleCollidingActors ( class<actor> BaseClass, out actor Actor, float	Radius,	optional vector	Loc, optional bool bIgnoreHidden );

/* CollidingActors() returns colliding (bCollideActors==true) actors within	a certain radius.
Much faster	than AllActors() for reasonably	small radii	since it uses the collision	hash
*/
native(321)	final iterator function	CollidingActors	( class<actor> BaseClass, out actor	Actor, float Radius, optional vector Loc );

//=============================================================================
// Color functions
native(549)	static final operator(20) color	-	  (	color A, color B );
native(550)	static final operator(16) color	*	  (	float A, color B );
native(551)	static final operator(20) color	+	  (	color A, color B );
native(552)	static final operator(16) color	*	  (	color A, float B );
//=============================================================================
// Scripted	Actor functions.

native final function float LuminosityFromColor( color InColor );

native final function class<Actor> FindClassFromString( string ClassString );

/* RenderOverlays()
called by player's hud to request drawing of actor specific	overlays onto canvas
*/
function RenderOverlays(Canvas Canvas);

//
// Called immediately before gameplay begins.
//
event PreBeginPlay()
{
	// Handle autodestruction if desired.
	if(	!bGameRelevant && (Level.NetMode !=	NM_Client) && !Level.Game.BaseMutator.CheckRelevance(Self) )
		Destroy();
}

//
// Broadcast a localized message to	all	players.
// Most	message	deal with 0	to 2 related PRIs.
// The LocalMessage	class defines how the PRI's	and	optional actor are used.
//
event BroadcastLocalizedMessage( class<LocalMessage> MessageClass, optional	int	Switch,	optional PlayerReplicationInfo RelatedPRI_1, optional PlayerReplicationInfo	RelatedPRI_2, optional Object OptionalObject )
{
	Level.Game.BroadcastLocalized( self, MessageClass, Switch, RelatedPRI_1, RelatedPRI_2, OptionalObject );
}


//
// Broadcast an objective update to all players.
// Most	message	deal with 0	to 2 related PRIs.
// The LocalMessage	class defines how the PRI's	and	optional actor are used.
//
event BroadcastObjectiveUpdate( class<Info> Objective, Name szObjectiveTag, EObjectiveComplete nStatus, int nObjectiveIdx, bool bDisplayMessage, float flLifeTime, optional PlayerReplicationInfo RelatedPRI_1, optional PlayerReplicationInfo	RelatedPRI_2 )
{
	Level.Game.BroadcastObjective( self, Objective, szObjectiveTag, nStatus, nObjectiveIdx, bDisplayMessage, flLifeTime, RelatedPRI_1, RelatedPRI_2 );
}


// << GEARBOX/jmw:add -	FEATURE: Messaging System
//-----------------------------------------------------------------------------
// Gearbox Messaging system

event PostGBXMessage( gbxMessage	msg	)
{
	// Posted messages are queued by the message manager and will be distributed at	the	next
	// distribution	phase.

	if (Level.MessageManager ==	None)
		return;
	msg.Sender = self;
	msg.TimeSent = Level.TimeSeconds;
	Level.MessageManager.PostMessage( msg );
}

function SendGBXMessage( gbxMessage	msg	)
{
	// Sent	messages are sent by the message manager to	their recipients immediately.
	// No duplication checking is performed	for	sent messages.

	msg.Sender = self;
	msg.TimeSent = Level.TimeSeconds;
	Level.MessageManager.SendMessage( msg );
}

// True	== Message has been	stored away	for	later use; caller should not delete	it after calling this function.
// False ==	Message	has	*not* been stored away;	caller may delete msg if necessary after calling this function.
function bool ReceiveGBXMessage( gbxMessage	msg	)
{
	// Override	me.
	return false;
}

// GEARBOX >>


// << GEARBOX/sjp:add
// Overridable functions to	interface bone/tag native functions
simulated function Coords GetAttachmentTagWorldCoords( Name	TagName	)
{
	return GetTagCoords( TagName );
}

function Coords	GetBoneTagWorldCoords( Name	TagName	)
{
	return GetBoneCoords( TagName );
}
// GEARBOX >>

// Called immediately after	gameplay begins.
//
event PostBeginPlay();

event PreSaveGame();
event PostSaveGame();
event PreLoadGame();
event PostLoadGame();

// GBX:PAD:	Called at the same time	as PostBeginPlay, but only for actors that are being reused
event PostRespawnPlay();

// Called after	PostBeginPlay.
//
simulated event	SetInitialState()
{
	bScriptInitialized = true;
	if(	InitialState!='' )
		GotoState( InitialState	);
	else
		GotoState( 'Auto' );
}

event PostLinearize(); // sjs -- after lin //SDJ 12/28/2004: From UC.

// called after	PostBeginPlay.	On a net client, PostNetBeginPlay()	is spawned after replicated	variables have been	initialized	to
// their replicated	values
event PostNetBeginPlay();

simulated function UpdatePrecacheMaterials()
{
	local int i;

	for	( i=0; i<Skins.Length; i++ )
		Level.AddPrecacheMaterial(Skins[i]);
}

simulated function UpdatePrecacheStaticMeshes()
{
	if ( (DrawType == DT_StaticMesh) &&	!bStatic &&	!bNoDelete )
		Level.AddPrecacheStaticMesh(StaticMesh);
}

simulated function UpdatePrecacheMeshes()
{
	if ( (DrawType == DT_Mesh) && !bStatic && !bNoDelete )
		Level.AddPrecacheMesh(Mesh);
}

/* HurtRadius()
 Hurt locally authoritative	actors within the radius.
*/
simulated function HurtRadius( float DamageAmount, float DamageRadius, class<DamageType> DamageType, float Momentum, vector	HitLocation	)
{
	local actor	Victims;
	local float	damageScale, dist;
	local vector dir;
	local Vector HitLoc, HitNormal;
	local name HitBoxName;

	if(	bHurtEntry )
		return;

	bHurtEntry = true;
	foreach	VisibleCollidingActors(	class 'Actor', Victims,	DamageRadius, HitLocation )
	{
		if(	(Victims !=	self) && (Victims.Role == ROLE_Authority))
		{
			dir	= Victims.Location - HitLocation;
			dist = FMax(1,VSize(dir));
			dir	= dir/dist;
			damageScale	= 1	- FMax(0,(dist - Victims.CollisionRadius)/DamageRadius);

			Trace( HitLoc, HitNormal, Victims.Location,	HitLocation, true,,,true,, HitBoxName );

			Victims.TakeDamage
			(
				damageScale	* DamageAmount,
				Instigator,
				Victims.Location - 0.5 * (Victims.CollisionHeight +	Victims.CollisionRadius) * dir,
				(damageScale * Momentum	* dir),
				DamageType,
				HitBoxName
			);
		}
	}
	bHurtEntry = false;
}

// Called when carried onto	a new level, before	AcceptInventory.
//
event TravelPreAccept();

// Called when carried into	a new level, after AcceptInventory.
//
event TravelPostAccept();

// Called by PlayerController when this	actor becomes its ViewTarget.
//
function BecomeViewTarget();

// Returns the string representation of	the	name of	an object without the package
// prefixes.
//
function String	GetItemName( string	FullName )
{
	local int pos;

	pos	= InStr(FullName, ".");
	While (	pos	!= -1 )
	{
		FullName = Right(FullName, Len(FullName) - pos - 1);
		pos	= InStr(FullName, ".");
	}

	return FullName;
}

// Returns the human readable string representation	of an object.
//
simulated event String GetHumanReadableName()
{
	return GetItemName(string(class));
}

final function ReplaceText(out string Text,	string Replace,	string With)
{
	local int i;
	local string Input;

	Input =	Text;
	Text = "";
	i =	InStr(Input, Replace);
	while(i	!= -1)
	{
		Text = Text	$ Left(Input, i) $ With;
		Input =	Mid(Input, i + Len(Replace));
		i =	InStr(Input, Replace);
	}
	Text = Text	$ Input;
}

// Set the display properties of an	actor.	By setting them	through	this function, it allows
// the actor to	modify other components	(such as a Pawn's weapon) or to	adjust the result
// based on	other factors (such	as a Pawn's	other inventory	wanting	to affect the result)
function SetDisplayProperties(ERenderStyle NewStyle, Material NewTexture, bool bLighting )
{
	Style =	NewStyle;
	texture	= NewTexture;
	bUnlit = bLighting;
}

function SetDefaultDisplayProperties()
{
	Style =	Default.Style;
	texture	= Default.Texture;
	bUnlit = Default.bUnlit;
}

// Get localized message string	associated with	this actor
static function	string GetLocalString(
	optional int Switch,
	optional PlayerReplicationInfo RelatedPRI_1,
	optional PlayerReplicationInfo RelatedPRI_2
	)
{
	return "";
}

function MatchStarting(); // called	when gameplay actually starts
function SetGRI(GameReplicationInfo	GRI);

function String	GetDebugName()
{
	return GetItemName(string(self));
}

/* DisplayDebug()
list important actor variable on canvas.  HUD will call	DisplayDebug() on the current ViewTarget when
the	ShowDebug exec is used
*/
simulated NotInShip	function DisplayDebug(Canvas Canvas, out float YL, out float YPos)
{
	//local	string T;
	local float	XL;
	//local	int	i;
	//local	Actor A;
	//local	name anim;
	//local	float frame,rate;

	Canvas.Style = ERenderStyle.STY_Normal;
	Canvas.StrLen("TEST", XL, YL);

	// GBX:naj - added 9/18/03
	YL *= 0.7;

	/*
	YPos = YPos	+ YL;
	Canvas.SetPos(4,YPos);
	Canvas.SetDrawColor(255,0,0);
	T =	GetDebugName();
	if ( bDeleteMe )
		T =	T$"	DELETED	(bDeleteMe == true)";

	Canvas.DrawText(T, false, 0.9, 0.9);
	YPos +=	YL;
	Canvas.SetPos(4,YPos);
	Canvas.SetDrawColor(255,255,255);

	if ( Level.NetMode != NM_Standalone	)
	{
		// networking attributes
		T =	"ROLE ";
		Switch(Role)
		{
			case ROLE_None:	T=T$"None";	break;
			case ROLE_DumbProxy: T=T$"DumbProxy"; break;
			case ROLE_SimulatedProxy: T=T$"SimulatedProxy";	break;
			case ROLE_AutonomousProxy: T=T$"AutonomousProxy"; break;
			case ROLE_Authority: T=T$"Authority"; break;
		}
		T =	T$"	REMOTE ROLE	";
		Switch(RemoteRole)
		{
			case ROLE_None:	T=T$"None";	break;
			case ROLE_DumbProxy: T=T$"DumbProxy"; break;
			case ROLE_SimulatedProxy: T=T$"SimulatedProxy";	break;
			case ROLE_AutonomousProxy: T=T$"AutonomousProxy"; break;
			case ROLE_Authority: T=T$"Authority"; break;
		}
		if ( bTearOff )
			T =	T$"	Tear Off";
		Canvas.DrawText(T, false, 0.9, 0.9);
		YPos +=	YL;
		Canvas.SetPos(4,YPos);
	}
	T =	"Physics ";
	Switch(PHYSICS)
	{
		case PHYS_None:	T=T$"None";	break;
		case PHYS_Walking: T=T$"Walking"; break;
		case PHYS_Falling: T=T$"Falling"; break;
		case PHYS_Swimming:	T=T$"Swimming";	break;
		case PHYS_Flying: T=T$"Flying";	break;
		case PHYS_Rotating:	T=T$"Rotating";	break;
		case PHYS_Projectile: T=T$"Projectile";	break;
		case PHYS_Interpolating: T=T$"Interpolating"; break;
		case PHYS_MovingBrush: T=T$"MovingBrush"; break;
		case PHYS_Spider: T=T$"Spider";	break;
		case PHYS_Trailer: T=T$"Trailer"; break;
		case PHYS_Ladder: T=T$"Ladder";	break;
	}
	T =	T$"	in physicsvolume "$GetItemName(string(PhysicsVolume))$"	on base	"$GetItemName(string(Base));
	if ( bBounce )
		T =	T$"	- will bounce";
	Canvas.DrawText(T, false, 0.9, 0.9);
	YPos +=	YL;
	Canvas.SetPos(4,YPos);

	Canvas.DrawText("Location: "$Location$"	Rotation "$Rotation, false,	0.9, 0.9);
	YPos +=	YL;
	Canvas.SetPos(4,YPos);
	Canvas.DrawText("Velocity: "$Velocity$"	Speed "$VSize(Velocity), false,	0.9, 0.9);
	YPos +=	YL;
	Canvas.SetPos(4,YPos);
	Canvas.DrawText("Acceleration: "$Acceleration, false, 0.9, 0.9);
	YPos +=	YL;
	Canvas.SetPos(4,YPos);

	Canvas.DrawColor.B = 0;
	Canvas.DrawText("Collision Radius "$CollisionRadius$" Height "$CollisionHeight,	false, 0.9,	0.9);
	YPos +=	YL;
	Canvas.SetPos(4,YPos);

	Canvas.DrawText("Collides with Actors "$bCollideActors$", world	"$bCollideWorld$", proj. target	"$bProjTarget, false, 0.9, 0.9);
	YPos +=	YL;
	Canvas.SetPos(4,YPos);
	Canvas.DrawText("Blocks	Actors "$bBlockActors$", players "$bBlockPlayers, false, 0.9, 0.9);
	YPos +=	YL;
	Canvas.SetPos(4,YPos);

	T =	"Touching ";
	ForEach	TouchingActors(class'Actor', A)
		T =	T$GetItemName(string(A))$" ";
	if ( T == "Touching	")
		T =	"Touching nothing";
	Canvas.DrawText(T, false, 0.9, 0.9);
	YPos +=	YL;
	Canvas.SetPos(4,YPos);

	Canvas.DrawColor.R = 0;
	T =	"Rendered: ";
	Switch(Style)
	{
		case STY_None: T=T;	break;
		case STY_Normal: T=T$"Normal"; break;
		case STY_Masked: T=T$"Masked"; break;
		case STY_Translucent: T=T$"Translucent"; break;
		case STY_Modulated:	T=T$"Modulated"; break;
		case STY_Alpha:	T=T$"Alpha"; break;
	}

	Switch(DrawType)
	{
		case DT_None: T=T$"	None"; break;
		case DT_Sprite:	T=T$" Sprite ";	break;
		case DT_Mesh: T=T$"	Mesh ";	break;
		case DT_Brush: T=T$" Brush "; break;
		case DT_RopeSprite:	T=T$" RopeSprite ";	break;
		case DT_VerticalSprite:	T=T$" VerticalSprite ";	break;
		case DT_Terraform: T=T$" Terraform "; break;
		case DT_SpriteAnimOnce:	T=T$" SpriteAnimOnce ";	break;
		case DT_StaticMesh:	T=T$" StaticMesh ";	break;
	}

	if ( DrawType == DT_Mesh )
	{
		T =	T$GetItemName(string(Mesh));
		if ( Skins.length >	0 )
		{
			T =	T$"	skins: ";
			for	( i=0; i<Skins.length; i++ )
			{
				if ( skins[i] == None )
					break;
				else
					T =T$GetItemName(string(skins[i]))$", ";
			}
		}

		Canvas.DrawText(T, false, 0.9, 0.9);
		YPos +=	YL;
		Canvas.SetPos(4,YPos);

		// mesh	animation
		GetAnimParams(0,Anim,frame,rate);
		T =	"AnimSequence "$Anim$" Frame "$frame$" Rate	"$rate;
		if ( bAnimByOwner )
			T= T$" Anim	by Owner";
	}
	else if	( (DrawType	== DT_Sprite) || (DrawType == DT_SpriteAnimOnce) )
		T =	T$Texture;
	else if	( DrawType == DT_Brush )
		T =	T$Brush;

	Canvas.DrawText(T, false, 0.9, 0.9);
	YPos +=	YL;
	Canvas.SetPos(4,YPos);

	Canvas.DrawColor.B = 255;
	Canvas.DrawText("Tag: "$Tag$" Event: "$Event$" STATE: "$GetStateName(),	false, 0.9,	0.9);
	YPos +=	YL;
	Canvas.SetPos(4,YPos);

	Canvas.DrawText("Instigator	"$GetItemName(string(Instigator))$"	Owner "$GetItemName(string(Owner)),	false, 0.9,	0.9);
	YPos +=	YL;
	Canvas.SetPos(4,YPos);

	Canvas.DrawText("Timer:	"$TimerCounter$" LifeSpan "$LifeSpan$" AmbientSound	"$AmbientSound,	false, 0.9,	0.9);
	YPos +=	YL;
	Canvas.SetPos(4,YPos);
	*/
}

NotInShip function LogSelective( String	msg	)
{
	// do nothing by default
}

// NearSpot() returns true is spot is within collision cylinder
simulated final	function bool NearSpot(vector Spot)
{
	local vector Dir;

	Dir	= Location - Spot;

	if ( abs(Dir.Z)	> CollisionHeight )
		return false;

	Dir.Z =	0;
	return ( VSize(Dir)	<= CollisionRadius );
}

simulated final	function bool TouchingActor(Actor A)
{
	local vector Dir;

	Dir	= Location - A.Location;

	if ( abs(Dir.Z)	> CollisionHeight +	A.CollisionHeight )
		return false;

	Dir.Z =	0;
	return ( VSize(Dir)	<= CollisionRadius + A.CollisionRadius );
}

/* StartInterpolation()
when this function is called, the actor	will start moving along	an interpolation path
beginning at Dest
*/
simulated function StartInterpolation()
{
	GotoState('');
	SetCollision(True,false,false);
	bCollideWorld =	False;
	bInterpolating = true;
	SetPhysics(PHYS_None);
}

/* Reset()
reset actor	to initial state - used	when restarting	level without reloading.
*/
function Reset();

/*
Trigger	an event
*/
event TriggerEvent(	Name EventName,	Actor Other, Pawn EventInstigator )
{
	local Actor	A;

	if ( EventName == '' )
		return;

	ForEach	DynamicActors( class 'Actor', A, EventName )
	{
		A.Trigger(Other, EventInstigator);
	}
}

/*
Untrigger an event
*/
function UntriggerEvent( Name EventName, Actor Other, Pawn EventInstigator )
{
	local Actor	A;

	if ( EventName == '' )
		return;

	ForEach	DynamicActors( class 'Actor', A, EventName )
		A.Untrigger(Other, EventInstigator);
}

function Signal(Actor Sender, int command, Actor ActorData, int IntegerData, float FloatData)
{
	// allows for more sophisticated signalling mechanism than the Trigger() function
	// command value is arbitrary and is agreed upon by the sender and receiver of the signal
}

function bool IsInVolume(Volume	aVolume)
{
	local Volume V;

	ForEach	TouchingActors(class'Volume',V)
		if ( V == aVolume )
			return true;
	return false;
}

function bool IsInPain()
{
	local PhysicsVolume	V;

	ForEach	TouchingActors(class'PhysicsVolume',V)
		if ( V.bPainCausing	&& (V.DamagePerSec > 0)	)
			return true;
	return false;
}

function PlayTeleportEffect(bool bOut, bool	bSound);

function bool CanSplash()
{
	return false;
}

function vector	GetCollisionExtent()
{
	local vector Extent;

	Extent = CollisionRadius * vect(1,1,0);
	Extent.Z = CollisionHeight;
	return Extent;
}

simulated function bool	EffectIsRelevant(vector	SpawnLocation, bool	bForceDedicated	)
{
	local PlayerController P;
	local bool bResult;

	if ( Level.NetMode == NM_DedicatedServer )
		bResult	= bForceDedicated;
	else if	( Level.NetMode	== NM_Client )
		bResult	= true;
	else if	( (Instigator != None) && Instigator.IsHumanControlled() )
		bResult	=  true;
	else if	( SpawnLocation	== Location	)
		bResult	= (	Level.TimeSeconds -	LastRenderTime < 3 );
	else if	( (Instigator != None) && (Level.TimeSeconds - Instigator.LastRenderTime < 3) )
		bResult	= true;
	else
	{
		P =	Level.GetLocalPlayerController();
		if ( P == None )
			bResult	= false;
		else
			bResult	= (	(Vector(P.Rotation)	Dot	(SpawnLocation - P.ViewTarget.Location)) > 0.0 );
	}
	return bResult;
}

///	GEARBOX: SJP - Useful function for computing a floating	point attenuation.
function float ComputeAttenuation( float threshold,	float variable,	float maximum, optional	bool invert	)
{
	local float	minimum;

	if(	invert )
	{
		minimum	= threshold	* maximum;

		if (variable>=minimum) return 1.0f;
		if (variable<0.0) return 0.0f;

		return variable/minimum;
	}
	else
	{
		minimum	= threshold	* maximum;

		if (variable>=maximum) return 0.0f;
		if (variable<=minimum) return 1.0f;

		return (maximum	- variable)/(maximum - minimum);
	}
}

event PreRenderActor();

function GameProfile GetCurrentGameProfile()
{
	if (Level.Game == None)
		return None;
	return Level.CurrentGameProfile;
}

function PlayerController FindPlayer(bool bNeedsPawn)
{
	local Controller c;
	local PlayerController pc;
	for	( c=Level.ControllerList; c!=None; c=c.NextController )
	{
		pc = PlayerController(c);
		if (pc != None && (!bNeedsPawn || pc.Pawn != None))
			return pc;
	}
	return None;
}

// Convenience function.
function Vector	GetLocation( ActorLite NavPoint	)
{
	if ( NavPoint == None )
		return Vect(0,0,0);
	else if	( NavPoint.bIsNavigationPoint )
		return NavigationPoint(	NavPoint ).Location;
	else if	( NavPoint.bIsNavigationPointLite )
		return NavigationPointLite(	NavPoint ).Location;
}

// Convenience function.
function Rotator GetRotation( ActorLite	NavPoint )
{
	local Rotator Dummy;
	
	if ( NavPoint == None )
		return Dummy;
	else if	( NavPoint.bIsNavigationPoint )
		return NavigationPoint(	NavPoint ).Rotation;
	else if	( NavPoint.bIsNavigationPointLite )
		return NavigationPointLite(	NavPoint ).Rotation;
}

simulated event	PreSaveCallback();
simulated event	PostSaveCallback();

//////////////////////////////////////////////////////////
// GBX:naj - GEARBOX Flag helper functions
//
function bool IsTrue( out Flag theFlag )
{
	CheckFlagForDuration( theFlag );
	return theFlag.Value > 0;
}

function bool IsFalse( out Flag theFlag )
{
	CheckFlagForDuration( theFlag );
	return theFlag.Value == 0;
}

function SetFlagValue( out Flag theFlag, bool bNewValue )
{
	local byte OldValue;

	OldValue = theFlag.Value;
	if ( bNewValue )
		theFlag.Value = 1;
	else
		theFlag.Value = 0;

	if ( theFlag.Value > OldValue )
	{
		theFlag.Raised = 1;
		theFlag.Lowered = 0;
		theFlag.RaisedTime = Level.TimeSeconds;
		theFlag.LoweredTime = 0.0f;
	}
	else if ( theFlag.Value < OldValue )
	{
		theFlag.Raised = 0;
		theFlag.Lowered = 1;
		theFlag.LoweredTime = Level.TimeSeconds;
		theFlag.RaisedTime = 0.0f;
	}
	
	theFlag.Duration = 0.0f;
}

function SetFlagTrueTimed( out Flag theFlag, float Duration )
{
	SetFlagValue( theFlag, true );
	theFlag.Duration = Duration;
}

function SetInitialFlagValue( out Flag theFlag, bool bNewValue )
{
	if ( bNewValue )
		theFlag.Value = 1;
	else
		theFlag.Value = 0;
	theFlag.Raised = 0;
	theFlag.Lowered = 0;
	theFlag.LoweredTime = 0.0f;
	theFlag.RaisedTime = 0.0f;
	theFlag.Duration = 0.0f;
}

function bool IsRaised( out Flag theFlag )
{
	local byte Result;
	CheckFlagForDuration( theFlag );
	
	Result = theFlag.Raised;
	theFlag.Raised = 0;

	return ( Result > 0 );
}

function bool IsLowered( out Flag theFlag )
{
	local byte Result;
	CheckFlagForDuration( theFlag );
	
	Result = theFlag.Lowered;
	theFlag.Lowered = 0;

	return ( Result > 0 );
}

function float TimeSinceRaised( out Flag theFlag )
{
	CheckFlagForDuration( theFlag );
	if ( theFlag.Value > 0 && Level.TimeSeconds > theFlag.RaisedTime )
	{
		return ( Level.TimeSeconds - theFlag.RaisedTime );
	}
	else
		return 0.0f;
}

function float TimeSinceLowered( out Flag theFlag )
{
	CheckFlagForDuration( theFlag );
	if ( theFlag.Value == 0 && Level.TimeSeconds > theFlag.LoweredTime )
	{
		return ( Level.TimeSeconds - theFlag.LoweredTime );
	}
	else
		return 0.0f;
}

function CheckFlagForDuration( out Flag theFlag )
{
	if ( theFlag.Value > 0 && theFlag.Duration > 0.00001f )
	{
		if ( ( Level.TimeSeconds - theFlag.RaisedTime ) > theFlag.Duration )
		{
			SetFlagValue( theFlag, false );
		}
	}
}
//////////////////////////////////////////////////////////

defaultproperties
{
	DrawType=DT_Sprite
	Texture=Texture'Engine.S_Actor'
	SurfaceType=EST_Default
	GetSurfTypeFromTexture=true
	DrawScale=+00001.000000
	MaxLights=4
	DrawScale3D=(X=1,Y=1,Z=1)
	ScaleGlow=1.0
	TransientSoundVolume=0.3
	TransientSoundRadius=300.0
	CollisionRadius=+00022.000000
	CollisionHeight=+00022.000000
	bJustTeleported=True
	Mass=+00100.000000
	Role=ROLE_Authority
	RemoteRole=ROLE_DumbProxy
	NetPriority=+00001.000000
	Style=STY_Normal
	bMovable=True
	bHighDetail=False
	bSuperHighDetail=False
	InitialState=None
	NetUpdateFrequency=100
	MessageClass=class'LocalMessage'
	bHiddenEdGroup=False
	bBlockZeroExtentTraces=true
	bBlockNonZeroExtentTraces=true
	bReplicateMovement=true
	CullDistance=0.0
	bAcceptsProjectors=True
	bLightingVisibility=True
	StaticFilterState=FS_Maybe
	bUseDynamicLights=True
	m_vecRootMotionOffset=(X=1,Y=1,Z=0)
	bMessageListener=false

	SoundRadius=1000
	SoundVolume=255
	SoundPitch=64.0
	SoundOcclusion=OCCLUSION_None

	MyLighting=(R=255,G=255,B=255,A=255)

	bOpaqueForSituationalAwarenessView=false
	
	AmbientAlpha=255

	bUnloaded=false

	m_fAmbientSoundFadeInTime=0.0f
	m_fAmbientSoundFadeOutTime=0.0f
}
//=============================================================================
// ActorLite: The base class of Actor.
//=============================================================================
class ActorLite extends Object
	abstract
	native;

// ActorLite is currently used for NavigationPointLite classes.  This allows
// for a lightweight (small memory footprint) object that has the same variables
// and functions that a NavigationPoint object would have (without having to
// include all the unnecessary stuff from the bloated Actor class).

// store a boolean indicating whether this object is a NavigationPointLite object or
// a NavigationPoint object (this keeps us from having to do a IsA() or Cast<> on
// this object at run-time which can be a performance problem).
var bool bIsNavigationPointLite;
var bool bIsNavigationPoint;

var const array<ReachSpec> PathList; //index of reachspecs (used by C++ Navigation code)
var const ActorLite nextNavigationPoint;


defaultproperties
{
}
class Admin extends PlayerController;



replication
{
	reliable if( Role<ROLE_Authority )
		RestartMap, Switch, Kick, KickBan, Admin;
}

event PostBeginPlay()
{
	Super.PostBeginPlay();
	AddCheats();
}

// Execute an administrative console command on the server.
exec function Admin( string CommandLine )
{
	local string Result;

	Result = ConsoleCommand( CommandLine );
	if( Result!="" )
		ClientMessage( Result );
}

exec function KickBan( string S )
{
	Level.Game.KickBan(S);
}

// center print admin messages which start with #
exec function Say( string Msg )
{
	local controller C;

	if ( left(Msg,1) == "#" )
	{
		Msg = right(Msg,len(Msg)-1);
		for( C=Level.ControllerList; C!=None; C=C.nextController )
			if( C.IsA('PlayerController') )
			{
				PlayerController(C).ClearProgressMessages();
				PlayerController(C).SetProgressTime(6);
				PlayerController(C).SetProgressMessage(0, Msg, class'Canvas'.Static.MakeColor(255,255,255));
			}
		return;
	}
	Super.Say(Msg);
}

exec function Kick( string S )
{
	Level.Game.Kick(S);
}

exec function PlayerList()
{
	local PlayerReplicationInfo PRI;

	log("Player List:");
	ForEach DynamicActors(class'PlayerReplicationInfo', PRI)
		log(PRI.PlayerName@"( ping"@PRI.Ping$")");
}

exec function RestartMap()
{
	ClientTravel( "?restart", TRAVEL_Relative, false );
}

exec function Switch( string URL )
{
	Level.ServerTravel( URL, false );
}

defaultproperties
{
}
//=============================================================================
// AIController, the base class of AI.
//
// Controllers are non-physical actors that can be attached to a Pawn to control
// its actions.  AIControllers implement the artificial intelligence for the pawns they control.
//
// This is a built-in Unreal class and it shouldn't be modified.
//=============================================================================
class AIController extends Controller
	native;



var		bool		bHunting;			// tells navigation code that Pawn is hunting another Pawn,
										//	so fall back to finding a path to a visible pathnode if none
										//	are reachable
var		bool		bAdjustFromWalls;	// auto-adjust around corners, with no hitwall notification for controller or Pawn
										// if wall is hit during a MoveTo() or MoveToward() latent execution.

var		AIScript MyScript;
var     float		Skill;				// skill, scaled by game difficulty (add difficulty to this value)

native(510) final latent function WaitToSeeEnemy(); // return when looking directly at visible enemy

event PreBeginPlay()
{
	Super.PreBeginPlay();
	if ( bDeleteMe )
		return;

	if ( Level.Game != None )
		Skill += Level.Game.GameDifficulty;
	Skill = FClamp(Skill, 0, 3);
}

/* Reset()
reset actor to initial state - used when restarting level without reloading.
*/
function Reset()
{
	Super.Reset();

	// by default destroy bots (let game re-create)
	if ( bIsPlayer )
		Destroy();
}

function Trigger( actor Other, Pawn EventInstigator )
{
	TriggerScript(Other,EventInstigator);
}

/* WeaponFireAgain()
Notification from weapon when it is ready to fire (either just finished firing,
or just finished coming up/reloading).
Returns true if weapon should fire.
If it returns false, can optionally set up a weapon change
*/
function bool WeaponFireAgain(float RefireRate, bool bFinishedFire)
{
	if ( Pawn.PressingFire() && (FRand() < RefireRate) )
	{
		Pawn.Weapon.BotFire(bFinishedFire);
		return true;
	}
	StopFiring();
	return false;
}

/* TriggerScript()
trigger AI script (this may enable it)
*/
function bool TriggerScript( actor Other, Pawn EventInstigator )
{
	if ( MyScript != None )
	{
		MyScript.Trigger(EventInstigator,Pawn);
		return true;
	}
	return false;
}

/* DisplayDebug()
list important controller attributes on canvas
*/
function DisplayDebug(Canvas Canvas, out float YL, out float YPos)
{
	local int i;
	local string T;

	Super.DisplayDebug(Canvas,YL, YPos);

	Canvas.DrawColor.B = 255;
	Canvas.DrawText("     Skill "$Skill$" NAVIGATION MoveTarget "$GetItemName(String(MoveTarget))$" PendingMover "$PendingMover$" MoveTimer "$MoveTimer, false);
	YPos += YL;
	Canvas.SetPos(4,YPos);

	Canvas.DrawText("      Destination "$Destination$" Focus "$GetItemName(string(Focus))$" Preparing Move "$bPreparingMove, false);
	YPos += YL;
	Canvas.SetPos(4,YPos);

	Canvas.DrawText("     RouteGoal "$GetItemName(string(RouteGoal))$" RouteDist "$RouteDist, false);
	YPos += YL;
	Canvas.SetPos(4,YPos);

	for ( i=0; i<16; i++ )
	{
		if ( RouteCache[i] == None )
		{
			if ( i > 5 )
				T = T$"--"$GetItemName(string(RouteCache[i-1]));
			break;
		}
		else if ( i < 5 )
			T = T$GetItemName(string(RouteCache[i]))$"-";
	}

	Canvas.DrawText("     RouteCache: "$T, false);
	YPos += YL;
	Canvas.SetPos(4,YPos);
}

// GBX:naj - added 8/13/03
NotInShip function DisplayDebugSpecial( HUD H ) {}

function float AdjustDesireFor(Pickup P)
{
	return 0;
}

/* GetFacingDirection()
returns direction faced relative to movement dir

0 = forward
16384 = right
32768 = back
49152 = left
*/
function int GetFacingDirection()
{
	local float strafeMag;
	local vector Focus2D, Loc2D, Dest2D, Dir, LookDir, Y;

	// check for strafe or backup
	Focus2D = FocalPoint;
	Focus2D.Z = 0;
	Loc2D = Pawn.Location;
	Loc2D.Z = 0;
	Dest2D = Destination;
	Dest2D.Z = 0;
	lookDir = Normal(Focus2D - Loc2D);
	Dir = Normal(Dest2D - Loc2D);
	strafeMag = lookDir dot Dir;
	Y = (lookDir Cross vect(0,0,1));
	if ((Y Dot (Dest2D - Loc2D)) < 0)
		return ( 49152 + 16384 * strafeMag );
	else
		return ( 16384 - 16384 * strafeMag );
}

// AdjustView() called if Controller's Pawn is viewtarget of a player
function AdjustView(float DeltaTime)
{
	local float TargetYaw, TargetPitch;
	local rotator OldViewRotation,ViewRotation;

	Super.AdjustView(DeltaTime);
	if( !Pawn.bUpdateEyeHeight )
		return;

	// update viewrotation
	ViewRotation = Rotation;
	OldViewRotation = Rotation;

	if ( Enemy == None )
	{
		ViewRotation.Roll = 0;
		if ( DeltaTime < 0.2 )
		{
			OldViewRotation.Yaw = OldViewRotation.Yaw & 65535;
			OldViewRotation.Pitch = OldViewRotation.Pitch & 65535;
			TargetYaw = float(Rotation.Yaw & 65535);
			if ( Abs(TargetYaw - OldViewRotation.Yaw) > 32768 )
			{
				if ( TargetYaw < OldViewRotation.Yaw )
					TargetYaw += 65536;
				else
					TargetYaw -= 65536;
			}
			TargetYaw = float(OldViewRotation.Yaw) * (1 - 5 * DeltaTime) + TargetYaw * 5 * DeltaTime;
			ViewRotation.Yaw = int(TargetYaw);

			TargetPitch = float(Rotation.Pitch & 65535);
			if ( Abs(TargetPitch - OldViewRotation.Pitch) > 32768 )
			{
				if ( TargetPitch < OldViewRotation.Pitch )
					TargetPitch += 65536;
				else
					TargetPitch -= 65536;
			}
			TargetPitch = float(OldViewRotation.Pitch) * (1 - 5 * DeltaTime) + TargetPitch * 5 * DeltaTime;
			ViewRotation.Pitch = int(TargetPitch);
			SetRotation(ViewRotation);
		}
	}
}

function SetOrders(name NewOrders, Controller OrderGiver);

function actor GetOrderObject()
{
	return None;
}

function name GetOrders()
{
	return 'None';
}

/* PrepareForMove()
Give controller a chance to prepare for a move along the navigation network, from
Anchor (current node) to Goal, given the reachspec for that movement.

Called if the reachspec doesn't support the Pawn's current configuration.
By default, the Pawn will crouch when it hits an actual obstruction. However,
Pawns with complex behaviors for setting up their smaller collision may want
to call that behavior from here
*/
event PrepareForMove(ActorLite Goal, ReachSpec Path);

/* WaitForMover()
Wait for Mover M to tell me it has completed its move
*/
function WaitForMover(Mover M)
{
	if ( (Enemy != None) && (Level.TimeSeconds - LastSeenTime < 3.0) )
		Focus = Enemy;
    PendingMover = M;
	bPreparingMove = true;
	Pawn.Acceleration = vect(0,0,0);
}

/* MoverFinished()
Called by Mover when it finishes a move, and this Pawn has the mover
set as its PendingMover
*/
function MoverFinished()
{
	if ( PendingMover.MyMarker.ProceedWithMove(Pawn) )
	{
		PendingMover = None;
		bPreparingMove = false;
	}
}

/* UnderLift()
called by mover when it hits a Pawn with that mover as its pendingmover while moving to its destination
*/
function UnderLift(Mover M)
{
	local ActorLite AL;

	bPreparingMove = false;
	PendingMover = None;

	// find nearest lift exit and go for that
	if ( (MoveTarget == None) || MoveTarget.IsA('LiftCenter') )
	{
		for ( AL=Level.NavigationPointList; AL!=None; AL=AL.NextNavigationPoint )
		{
			if ( AL.IsA('LiftExit') && (LiftExit(AL).LiftTag == M.Tag)
				&& ActorReachable( LiftExit(AL) ) )
			{
				MoveTarget = NavigationPoint(AL);
				return;
			}
		}
	}
}

function bool PriorityObjective()
{
	return false;
}

function Startle(Actor A);

defaultproperties
{
	bHidden=true
	 bAdjustFromWalls=true
	 PlayerReplicationInfoClass=Class'Engine.PlayerReplicationInfo'
     bCanOpenDoors=true
	 bCanDoSpecial=true
	 MinHitWall=-0.5f
}
//=============================================================================
// AIMarker.
//=============================================================================
class AIMarker extends SmallNavigationPoint
	native;



cpptext
{
	virtual UBOOL IsIdentifiedAs(FName ActorName);
}

var AIScript markedScript;

defaultproperties
{
     bCollideWhenPlacing=False
	 bHiddenEd=true
}
//=============================================================================
// AIScript - used by Level Designers to specify special AI scripts for pawns
// placed in a level, and to change which type of AI controller to use for a Pawn.
// AIScripts can be shared by one or many pawns.
// Game specific subclasses of AIScript will have editable properties defining game specific behavior and AI
// This is a built-in Unreal class and it shouldn't be modified.
//=============================================================================
class AIScript extends Keypoint
	native
	placeable;



var()	class<AIController> ControllerClass;
var()	bool		bNavigate;				// if true, put an associated path in the navigation network
var()	bool		bLoggingEnabled;
var		AIMarker	MyMarker;

cpptext
{
	virtual INT AddMyMarker(AActor *S);
	virtual void ClearMarker();
}

/* SpawnController()
Spawn and initialize an AI Controller (called by a non-player controlled Pawn at level startup)
*/
function SpawnControllerFor(Pawn P)
{
	local AIController C;

	if ( ControllerClass == None )
	{
		if ( P.ControllerClass == None )
			return;
		C = Spawn(P.ControllerClass,,,P.Location, P.Rotation);
	}
	else
		C = Spawn(ControllerClass,,,P.Location, P.Rotation);
	C.MyScript = self;
	C.Possess(P);
}

function ActorLite GetMoveTarget()
{
	if ( MyMarker != None )
		return MyMarker;
	return self;
}

function TakeOver(Pawn P);

defaultproperties
{
     Texture=Texture'Engine.S_AIScript'
}
//=============================================================================
// Ambient sound, sits there and emits its sound.  This class is no different
// than placing any other actor in a level and setting its ambient sound.
//=============================================================================
class AmbientSound extends Keypoint;

function PostBeginPlay()
{
	local Sound NewSound;

	Super.PostBeginPlay();
	
	// Replace the ambient sound with a cue variation
	if( AmbientSound != None )
	{
		NewSound = GetCueVariationFromSound( AmbientSound );

		if( NewSound != None )
		{
			Log( "*****SJP: Replacing my AmbientSound with '"$NewSound$"'", 'SJP' );
			AmbientSound = NewSound;
		}
	}
}

defaultproperties
{
	 Texture=Texture'Engine.S_Ambient'
	 //SoundRadius=64
	 SoundVolume=255
	 //SoundPitch=64
     RemoteRole=ROLE_None
}
//=============================================================================
// Ammo.
//=============================================================================
class Ammo extends Pickup
	abstract
	native;



var() int AmmoAmount;

/* DetourWeight()
value of this path to take a quick detour (usually 0, used when on route to distant objective, but want to grab inventory for example)
*/
function float DetourWeight(Pawn Other,float PathWeight)
{
	local Ammunition AlreadyHas;

	if ( Other.Weapon.AIRating >= 0.5 )
		return 0;
	AlreadyHas = Ammunition(Other.FindInventoryType(InventoryType));
	if ( AlreadyHas == None )
		return 0;
	if ( AlreadyHas.AmmoAmount == 0 )
		return MaxDesireability/PathWeight;
	return 0;
}

function float BotDesireability(Pawn Bot)
{
	local Ammunition AlreadyHas;

	if ( Bot.Controller.bHuntPlayer )
		return 0;
	AlreadyHas = Ammunition(Bot.FindInventoryType(InventoryType));
	if ( AlreadyHas == None )
		return (0.35 * MaxDesireability);
	if ( AlreadyHas.AmmoAmount == 0 )
		return MaxDesireability;
	if (AlreadyHas.AmmoAmount >= AlreadyHas.MaxAmmo)
		return -1;

	return ( MaxDesireability * FMin(1, 0.15 * AmmoAmount/AlreadyHas.AmmoAmount) );
}

function inventory SpawnCopy( Pawn Other )
{
	local Inventory Copy;

	Copy = Super.SpawnCopy(Other);
	Ammunition(Copy).AmmoAmount = AmmoAmount;
	return Copy;
}

function Destroyed()
{
	Instigator = None;  // prevent references to/in destroyed objects

	super.Destroyed();
}


defaultproperties
{
     PickupMessage="You picked up some ammo."
     RespawnTime=+00030.000000
     MaxDesireability=+00000.200000
     Texture=Texture'Engine.S_Ammo'
     CollisionRadius=22.000000
     AmbientGlow=255
}
//=============================================================================
// Ammunition: the base class of weapon ammunition
//
// This is a built-in Unreal class and it shouldn't be modified.
//=============================================================================

class Ammunition extends Inventory
	abstract
	native
	nativereplication;



var travel int MaxAmmo;						// Max amount of ammo
var travel int AmmoAmount;
var int InitialAmount; // sjs					// Amount of Ammo current available
var travel int PickupAmmo;					// Amount of Ammo to give when this is picked up for the first time

// Used by Bot AI

var		bool	bRecommendSplashDamage;
var		bool	bTossed;
var		bool	bTrySplash;
var		bool	bLeadTarget;
var		bool	bInstantHit;
var		bool	bSplashDamage;
var     bool    bCanTargetTeammates;  // for auto-aiming. might as well be bIsLinkGun

// Damage and Projectile information

var class<Projectile> ProjectileClass;
var class<DamageType> MyDamageType;
var float WarnTargetPct;
var float RefireRate;

var Sound FireSound;

var float AutoAim;  //jjs
var float MaxRange; //amb: for autoaim
var bool  bTryHeadShot; //amb

var class<Projectile> ComboTargetClass;

// Network replication
//

replication
{
	// Things the server should send to the client.
	reliable if( bNetOwner && bNetDirty && (Role==ROLE_Authority) )
		AmmoAmount;
}

// amb ---
simulated function CheckOutOfAmmo()
{
    if (AmmoAmount <= 0)
        Pawn(Owner).Weapon.OutOfAmmo();
}

simulated function PostNetReceive()
{
    CheckOutOfAmmo();
}

simulated function bool UseAmmo(int AmountNeeded, optional bool bAmountNeededIsMax)
{
    if (bAmountNeededIsMax && AmmoAmount < AmountNeeded)
        AmountNeeded = AmmoAmount;

	if (AmmoAmount < AmountNeeded)
	{
		CheckOutOfAmmo();
        return false;   // Can't do it
    }

    AmmoAmount -= AmountNeeded;
    NetUpdateTime = Level.TimeSeconds - 1;

    if (Level.NetMode == NM_StandAlone || Level.NetMode == NM_ListenServer)
        CheckOutOfAmmo();

    return true;
}
// --- amb

simulated function bool HasAmmo()
{
	return ( AmmoAmount > 0 );
}

function float RateSelf(Pawn Shooter, out byte RecommendedFiringMode)
{
	return 0.5;
}

function WarnTarget(Actor Target,Pawn P ,vector FireDir)
{
	if ( bInstantHit )
		return;
	if ( (FRand() < WarnTargetPct) && (Pawn(Target) != None) && (Pawn(Target).Controller != None) )
		Pawn(Target).Controller.ReceiveWarning(P, ProjectileClass.Default.Speed, FireDir);
}

function SpawnProjectile(vector Start, rotator Dir)
{
	AmmoAmount -= 1;
	Spawn(ProjectileClass, self,, Start,Dir);
}

function ProcessTraceHit(Weapon W, Actor Other, Vector HitLocation, Vector HitNormal, Vector X, Vector Y, Vector Z, optional Material HitMaterial)
{
	AmmoAmount -= 1;
}

simulated function DisplayDebug(Canvas Canvas, out float YL, out float YPos)
{
	Canvas.DrawText("Ammunition "$GetItemName(string(self))$" amount "$AmmoAmount$" Max "$MaxAmmo);
	YPos += YL;
	Canvas.SetPos(4,YPos);
}

function bool HandlePickupQuery( pickup Item )
{
    local int AdjustedAmount;
	if ( class == item.InventoryType )
	{
		if (AmmoAmount==MaxAmmo)
			return true;
        AddAmmo(Ammo(item).AmmoAmount);
        AdjustedAmount = Ammo(item).AmmoAmount;
        if( MaxAmmo > default.MaxAmmo ) // ammo affinity
        {
            AdjustedAmount = Ceil(float(AdjustedAmount) * MaxAmmo / default.MaxAmmo);
        }
        item.SetRespawn(); //amb
		return true;
	}
	if ( Inventory == None )
		return false;

	return Inventory.HandlePickupQuery(Item);
}

// If we can, add ammo and return true.
// If we are at max ammo, return false
//
function bool AddAmmo(int AmmoToAdd)
{
    if( MaxAmmo > default.MaxAmmo ) // ammo affinity
    {
        //log("AmmoToAdd increased due to affinity:"@AmmoToAdd);
        AmmoToAdd = Ceil(float(AmmoToAdd) * MaxAmmo / default.MaxAmmo);
        //log("AmmoToAdd now:"@AmmoToAdd);
    }

	AmmoAmount = Min(MaxAmmo, AmmoAmount+AmmoToAdd);

	return true;
}

function float GetDamageRadius()
{
	if ( ProjectileClass != None )
		return ProjectileClass.Default.DamageRadius;

	return 0;
}

defaultproperties
{
    bNetNotify=true
	MyDamageType=class'DamageType'
    RefireRate=0.500000
    InitialAmount=10
	WarnTargetPct=+0.5
    AutoAim=0.95
}
class AnimNotify extends Object
	native
	abstract
	editinlinenew
	hidecategories(Object)
	collapsecategories;



var transient int Revision;

cpptext
{
	// AnimNotify interface.
	virtual void Notify( UMeshInstance *Instance, AActor *Owner ) {};
	// UObject interface.
	virtual void PostEditChange();
}
class AnimNotify_AttachStaticMesh extends AnimNotify_Scripted;



var() StaticMesh	StaticMesh;
var() name			BoneName;

simulated function AttachToPawn(AnimPawn P)
{
	if (P != None)
	{
		P.AttachScriptedAttachment( StaticMesh, BoneName );
	}
}

event Notify( Actor Owner )
{
	if (Owner.IsA('AnimPawn'))
	{
		AttachToPawn( AnimPawn(Owner) );
	}
}
class AnimNotify_DestroyEffect extends AnimNotify
	native;



var() name DestroyTag;
var() bool bExpireParticles;

cpptext
{
	// AnimNotify interface.
	virtual void Notify( UMeshInstance *Instance, AActor *Owner );
}

defaultproperties
{
	bExpireParticles=True
}
class AnimNotify_DetachStaticMesh extends AnimNotify_Scripted;



var() StaticMesh	StaticMesh;
var() name			BoneName;

simulated function DetachFromPawn(AnimPawn P)
{
	if (P != None)
	{
		P.DetachScriptedAttachment( StaticMesh, BoneName );
	}
}

event Notify( Actor Owner )
{
	if (Owner.IsA('AnimPawn'))
	{
		DetachFromPawn( AnimPawn(Owner) );
	}
}
class AnimNotify_DetachWeapon extends AnimNotify_Scripted;



var() name		BoneName;

simulated function DetachWeaponFromPawn(AnimPawn P)
{
	if (P != None)
	{
		P.DetachWeapon( BoneName );
	}
}

event Notify( Actor Owner )
{
	if (Owner.IsA('AnimPawn'))
	{
		DetachWeaponFromPawn( AnimPawn(Owner) );
	}
}
class AnimNotify_DisarmWeapon extends AnimNotify_Scripted;



var() name		BoneName;

simulated function DisarmWeaponFromPawn(AnimPawn P)
{
	if (P != None)
	{
		P.DisarmWeapon( BoneName );
	}
}

event Notify( Actor Owner )
{
	if (Owner.IsA('AnimPawn'))
	{
		DisarmWeaponFromPawn( AnimPawn(Owner) );
	}
}
class AnimNotify_Effect extends AnimNotify
	native;



var() class<Actor> EffectClass;
var() name Bone;
var() vector OffsetLocation;
var() rotator OffsetRotation;
var() bool Attach;
var() name Tag;
var() float DrawScale;
var() vector DrawScale3D;

var private transient Actor LastSpawnedEffect;	// Valid only in the editor.

cpptext
{
	// AnimNotify interface.
	virtual void Notify( UMeshInstance *Instance, AActor *Owner );
}

defaultproperties
{
	 DrawScale3D=(X=1,Y=1,Z=1)
     DrawScale=+00001.000000
}
class AnimNotify_MatSubAction extends AnimNotify
	native;



var() editinline MatSubAction	SubAction;

cpptext
{
	// AnimNotify interface.
	virtual void Notify( UMeshInstance *Instance, AActor *Owner );
}
class AnimNotify_RearmWeapon extends AnimNotify_Scripted;



var() name		BoneName;

simulated function RearmWeaponFromPawn(AnimPawn P)
{
	if (P != None)
	{
		P.RearmWeapon( BoneName );
	}
}

event Notify( Actor Owner )
{
	if (Owner.IsA('AnimPawn'))
	{
		RearmWeaponFromPawn( AnimPawn(Owner) );
	}
}
class AnimNotify_ReattachWeapon extends AnimNotify_Scripted;



var() name		BoneName;

simulated function ReattachWeaponFromPawn(AnimPawn P)
{
	if (P != None)
	{
		P.ReattachWeapon( BoneName );
	}
}

event Notify( Actor Owner )
{
	if (Owner.IsA('AnimPawn'))
	{
		ReattachWeaponFromPawn( AnimPawn(Owner) );
	}
}

defaultproperties
{
	BoneName="weapon_bone"
}
class AnimNotify_Script extends AnimNotify
	native;



var() name NotifyName;

cpptext
{
	// AnimNotify interface.
	virtual void Notify( UMeshInstance *Instance, AActor *Owner );
}
class AnimNotify_Scripted extends AnimNotify
	native
	abstract;



event Notify( Actor Owner );

cpptext
{
	// AnimNotify interface.
	virtual void Notify( UMeshInstance *Instance, AActor *Owner );
}
class AnimNotify_Sound extends AnimNotify
	native;



var() sound Sound;
var() Cue SoundCue;
var() float Volume;
var() int Radius;

cpptext
{
	// AnimNotify interface.
	virtual void Notify( UMeshInstance *Instance, AActor *Owner );
}

defaultproperties
{
	Radius=0
	Volume=1.0
}
class AnimNotify_Trigger extends AnimNotify_Scripted;



var() name EventName;

event Notify( Actor Owner )
{
	Owner.TriggerEvent( EventName, Owner, Pawn(Owner) );
}

//=============================================================================
// AnimPawn.uc: Script to go with C++ for controlling Pawn animation well
// Revision history:
//		* Created by Chris Linder of Demiurge Studios 12/2/02
//=============================================================================

class AnimPawn extends Pawn
	native
	dependson(CharacterSetup);


const SCRIPTED_ANIM_QUEUE_PRIORITY = 8888;
const SCRIPTED_ANIM_QUEUE_LOOP_PRIORITY = 8887;

//Animation Channels
const FACE_CHANNEL = 10;
const VISEME_CHANNEL = 30;
const BLINK_CHANNEL = 40;
const THROW_CHANNEL = 8;

const TR_None = 0;
const TR_AnimStart = 1;
const TR_AnimStartNoRotation = 2;
const TR_AnimEnd = 3;
const TR_AnimEndNoRotation = 4;

//Debug
var bool LOG_DEBUG;

//Physics based animation
var byte ViewPitch;					// jjs - something to replicate so we can see which way remote clients are looking
var bool bIsIdle;					// true when standing still on the ground, Physics can be used for determining other states
var bool bWaitForAnim;				// true if the Pawn is playing an important non-looping animation (eg. landing/dodge) and doesn't feel like being interrupted
var bool bReadyForNewIdleAnim;		//Idle anim finished and ready to pick new random one.
var const bool bReverseRun;
var bool bDoTorsoTwist;
var bool bDoHeadTurn;
var bool RotateFeetWhileStanding;
var bool bScriptedCamInHead;			
var bool FootTurning;
var bool FootStill;
var const bool EyesLookAt;
var const bool HeadLookAt;
var const bool TorsoLookAt;
var const bool bIsAimingAtActor;
var const bool bIsLookingAtActor;
var const bool bIsAtLooking;
var() bool bFriendlyFireListen;
var() const bool bIsUSCharacter;
var bool bPlayingFace;				//Don't change this, use this to get status - call AnimateFace to set
var bool bPlayingViseme;			//Don't change this, use this to get status - call AnimateViseme to set
var bool bPlayingBlink;				//Don't change this, use this to get status - call AnimateBlink to set
var() bool bPawnBlinks;
var() bool bUsesHoldRifleAnim;
var bool bPawnInfoIconOnly;
var int IdleAnimIndex;				//The current idle animation index;
var const Vector OldVelocity;
var float IdleTime;

//Torso twisting/looking
var	bool bIsAtAiming;
var const int  FootRot;
var const int  OldFootRot;
var const int  TurnDir;
var const float EyesLookAtAlpha;
var const float HeadLookAtAlpha;
var const float TorsoLookAtAlpha;
var const Vector EyesLookAtPoint;
var const Vector HeadLookAtPoint;
var const Vector TorsoLookAtPoint;
var const Vector MeshEyePosition;		// GBX:PAD: This is used to stash off the median eye coordinate of the pawn
var const Rotator LeftEyeCurRotation;
var const Rotator RightEyeCurRotation;
var const Rotator HeadCurRotation;
var const Rotator TorsoCurRotation;
var const Rotator RootCurRotation;
var float EyesTurnRate;
var float HeadTurnRate;
var float TorsoTurnRate;
var const float LookAtAlphaFadeRate;
var const Actor LookAtTarget;
var const Actor AimAtTarget;
var Rotator LookAtDeltaRotation;	// for Pawns that have a non-standard Rotation, this delta adjusts their LookAt rotation
var bool	bFlipPitchAndRoll;		// exchange (and invert) the pitch and roll of head when looking at things in the world
var bool	bLookDirNotReset;		// this gets set to 'true' in UpdateLookDir() so that UpdateTwistLook() knows if it needs to reset bone rotations or not

var() int HeadMinPitch;
var() int HeadMaxPitch;
var() int HeadMinYaw;
var() int HeadMaxYaw;

//Face and Talking
var int NumFaceChannels;
var int NumBlinkChannels;
var float HoldFaceTime;				//Don't change this - set by PlayFaceAnim
var float HoldBlinkTime;			//Don't change this - set by PlayBlink
var float VisemeScaleTopLip;		// Scale of viseme animations (0.0 - 1.0), 0.5=less exaggerated
var float VisemeScaleJaw;			// Scale of viseme animations (0.0 - 1.0), 0.5=less exaggerated

//Eyes
var() int EyeMaxDeltaInside;		//Max eye can turn towards nose
var() int EyeMaxDeltaOutside;		//Max eye can turn towards ear
var() int EyeMaxDeltaUp;			//Max eye can look up
var() int EyeMaxDeltaDown;			//Max eye can look down
var() int LeftEyeYawOffset;			//An offset to apply to the left eye to get it to line up correctly
var() int LeftEyePitchOffset;		//An offset to apply to the eyes to get them to line up correctly
var() int RightEyeYawOffset;		//An offset to apply to the right eye to get it to line up correctly
var() int RightEyePitchOffset;		//An offset to apply to the eyes to get them to line up correctly

//Anim Names
//var name WalkAnims[4];				// 0=forward, 1=backwards, 2=left, 3=right
//var name CrouchAnims[4];
//var name SwimAnims[4];
//var name CrouchTurnRightAnim;
//var name CrouchTurnLeftAnim;
//var name IdleCrouchAnim;
//var name IdleSwimAnim;
//var name IdleAnim;
//var name IdleRestAnim[10];
var name IdleFaceAnim;
var name BlinkAnim;
//var name TakeoffStillAnim;
//var name TakeoffAnims[4];
//var name AirStillAnim;
//var name AirAnims[4];
//var name LandStillAnim;
//var name LandAnims[4];

//Bone names
var name RootBone;
var name HeadBone;
var name SpineBone1;
var name SpineBone2;
var name LeftEye;
var name RightEye;

var float PawnBlinkDelayBase;  // time delay between each eye blink
var float PawnBlinkDelayDelta;  // random offset to add to PawnBlinkDeltaBase
var float PawnBlinkTime;  // next time blick should occur
var int PawnDoubleBlinkCount;

// LipSync variables  (these should be UDOUBLE, but since UnrealScript doesn't support double, make array of 2 floats...
var int LipSyncData;				// this should really be a 'void *', but since UnrealScript doesn't support 'void *', use int
var float LipSyncOffsetTime[2];
var float LipSyncStartTime[2];		// the game time of the first lipsync viseme
var float LipSyncUpdateTime[2];		// the game time when the viseme animation needs to be updated
var float LipSyncBeginTime[2];		// game time when this viseme animation started
var float LipSyncEndTime[2];
var float LipSyncDuration[2];
var float LipSyncPausedTime[2];		// time when lipsync animations were paused (used when animation resumes)
var int LipSyncIndex;
var int LipSyncVisemeIndex;
var int LipSyncPhonemeCount;
const MAX_VISEME = 11;
var name VisemeAnimNames[MAX_VISEME];		// animations that play visemes for the lipsync phonemes

var bool m_bDisableAnimQueue;		// Shut down the animqueue for a time, so that mappers can run scripted animations with no interferance.

struct native export AnimQueueElement
{
	var name		szAnimName;
	var float		flRate;
	var float		flTween;
	var int			nChannel;
	var byte		bLoop;
	var name		szBlendBone;
	var	int			nPriority;
	var float		flBlendAlpha;
	var	float		flInTime;
	var float		flOutTime;
	var byte		bPlaying;
	var byte		bPlayFull;
	var byte		bRootMotion;
	var byte		bResetWhenComplete;
	var byte		bRestartWhenComplete;
	var byte		bTeleportRootType;
	var byte		bEndAnimCalled;
	var	class<PawnAnimExtra> PawnAnimExtraClass;
};

var array<AnimQueueElement> AnimQueue;

// GBX:PAD: This is used to define an array of extended attachments to an Actor (e.g. swapped out heads, arms, wheels, etc)
var()	export editinline	array<ExtendedAttachmentInfo>	ExtendedAttachments;	// A list of extended attachments to this mesh
var() array<Material> ExtendedSkins;				// Skins to be copied over to extended attachments

var()	export editinline	array<ScriptedAttachmentInfo>	ScriptedAttachments;	// A list of scripted static mesh attachments on this mesh

var()	MeshAnimation		MeshAnim;
var()	string				MeshAnimName;
var		string				CurMeshAnimName;

struct native export IdleQueueAnim
{
	var name		szAnimName;
	var byte		bAnimHasBeenPlayed;
};

var array<IdleQueueAnim> IdleQueue;
var bool		m_fRandomIdleQueue;
var bool		m_fRunNextQueueIdle;
var int			m_nNextIdleQueueAnim;

var name	m_szLookBoneName;

const CHAR_INFO_STARTFADE = 0.5f;
const CHAR_INFO_ENDFADE = 0.75f;
const FRIENDLY_NAME_FONT_SCALE = 0.9;// CEK-FONT 0.7;

var float			m_flLastDisplayPawnInfo;
var float			m_flLastDisplayPawnNoShoot;

var FriendlyListener MyFriendlyListener;

var (AnimPawn)  CharacterSetup.EUSCharacterTypes	m_eCharacterType;
var int				m_nNewCharType;
var int				m_nCharType;
var class<CharacterSetup> CharacterSetupClass; // used to configure the pawn's head and facial package

var name		ScriptedViewBoneName;
var vector		ScriptedViewOffset;

var float		m_flRank;

//DHW+ 
var bool		bhasWeaponName;	//-- This flag acts as a blocker for the weaponpickup touch function so it displays the name 
								//-- of the first weapon touched not the last.

var float		bthrowWeapon;	//-- This flag keeps track of whether the user wants to throw their weapon during the next
								//-- weapon pickup touch.  It is a float so that stale throw commands are not cared over.
//DHW-

//Replication
// GBX:PAD: I've taken out the bulk of these variables I was replicating.  We should probably just start adding them back as needed,
// if they are even needed.
replication
{
//    reliable if (bNetDirty && (Role==ROLE_Authority))
//		bDoTorsoTwist, EyesLookAt, EyesLookAtPoint, HeadLookAt, HeadLookAtPoint, TorsoLookAt, TorsoLookAtPoint, MeshAnimName;
    reliable if (bNetDirty && (Role==ROLE_Authority))
		bDoTorsoTwist, MeshAnimName, TorsoLookAt, TorsoLookAtPoint, bIsAtAiming, m_nNewCharType, CharacterSetupClass,
		bIsAimingAtActor, AimAtTarget, m_nCharType;
	reliable if (bNetInitial && (Role==ROLE_Authority))
		bPawnBlinks;
}

//Native Functions
simulated native function int Get4WayDirection( );
simulated native function int Get4WayDirectionVel( Vector InVelocity );
simulated native function SetAimAtPoint(Vector point, optional bool Torso);
simulated native function SetLookAtPoint(Vector point, optional bool Eyes, optional bool Head);
simulated native function SetAimAtTarget(Actor aTarget, optional bool Torso);
simulated native function SetLookAtTarget(Actor aTarget, optional bool Eyes, optional bool Head);
simulated native function StopLookAt(optional bool Eyes, optional bool Head, optional bool Torso);
simulated native function ResetLookAt(optional bool Eyes, optional bool Head, optional bool Torso);
simulated native function ResetLookAtImmediate(optional bool Eyes, optional bool Head, optional bool Torso);
simulated native function SetCharacterRank(float nRank);
simulated native function ResetRootRotation( );

simulated native function DrawSelfForGBXHudC(canvas Canvas, Hud Hud, FontInfo Fonts, int nPass);

simulated function PostBeginPlay()
{
	local int		i, j;

	Super.PostBeginPlay();

//	log("Loading extended attachments", 'Pawn');
	for( i = 0; i < ExtendedAttachments.Length; i++ )
	{
		if (ExtendedAttachments[i] != None)
		{
			ExtendedAttachments[i].m_AttachedPart = Spawn( class'AttachedPart', self );
			if (ExtendedSkins.Length > 0)
			{
				for (j = 0; j < ExtendedSkins.Length; j++)
				{
					if (ExtendedSkins[j] != None)
					{
						ExtendedAttachments[i].m_AttachedPart.Skins[j] = ExtendedSkins[j];
					}
				}
			}
			if (ExtendedAttachments[i].m_szGroupName != "")
				ExtendedAttachmentNamedGroup( ExtendedAttachments[i].m_AttachedPart, ExtendedAttachments[i].m_szGroupName );
			else
				ExtendedAttachment( ExtendedAttachments[i].m_AttachedPart, ExtendedAttachments[i].m_nmSocketName, ExtendedAttachments[i].m_nmPartName );
		}
	}

	VisemeAnimNames[0]='viseme_NULL';
	VisemeAnimNames[1]='viseme_A';
	VisemeAnimNames[2]='viseme_AH';
	VisemeAnimNames[3]='viseme_E';
	VisemeAnimNames[4]='viseme_F';
	VisemeAnimNames[5]='viseme_M';
	VisemeAnimNames[6]='viseme_O';
	VisemeAnimNames[7]='viseme_R';
	VisemeAnimNames[8]='viseme_S';
	VisemeAnimNames[9]='viseme_SH';
	VisemeAnimNames[10]='viseme_U';
}

simulated event PostNetBeginPlay()
{
	local MeshAnimation	aMeshAnim;
	
	Super.PostNetBeginPlay();

	//Log(self $ " AnimPawn::PostNetBeginPlay() checking to see if we need to load, MeshAnimName " $ MeshAnimName $ " CurMeshAnimName = " $ CurMeshAnimName, 'AnimPawn');

	// GBX:PAD: I feel really dirty right now, but there was a flag that SHOULD have been set in the maps to say
	// that some AnimPawns should not default to a rifle hold animation set.  It wasn't done, so now I have to check
	// to see if certain character packages can actually use the rifle hold set.
	if (Mesh != None)
	{
		if (bUsesHoldRifleAnim && (Mesh.Outer.Name != 'K_character_us') && (Mesh.Outer.Name != 'K_character_de') && (Mesh.Outer.Name != 'mp_k_character_us') && (Mesh.Outer.Name != 'mp_k_character_de'))
		{
			log(self$".PostNetBeginPlay() - Setting "$Mesh$" bUsesHoldRifleAnim to false");
			bUsesHoldRifleAnim = false;
		}
		if ((MeshAnimName != "") && (CurMeshAnimName != MeshAnimName))
		{
			aMeshAnim = MeshAnimation(DynamicLoadObject(MeshAnimName,class'MeshAnimation'));
			if (aMeshAnim != None)
			{
				if (MeshAnim != None)
					UnlinkSkelAnim(MeshAnim, false);
				if (LinkSkelAnim(aMeshAnim))
				{
					//Log(self $ " AnimPawn::PostNetBeginPlay() loaded, linking up", 'AnimPawn');

					MeshAnim = aMeshAnim;
					CurMeshAnimName = MeshAnimName;
				}
				bInitializeAnimation = false;
			}
		}
		else // re-enabling this fallback for Paris... 2004-07-21 JWS
		{
			//Log(self $ " AnimPawn::PostNetBeginPlay() don't need to load", 'AnimPawn');

			if ((MeshAnim == None) && (bUsesHoldRifleAnim))
			{
				//Log(self $ " AnimPawn::PostNetBeginPlay() fallback to a_hold_rifle", 'AnimPawn');

				if (Level.bUrbanCover)
				{
					aMeshAnim = MeshAnimation(DynamicLoadObject("a_corner_city.a_corner_city",class'MeshAnimation'));
				}
				else
				{
					aMeshAnim = MeshAnimation(DynamicLoadObject("a_corner_standard.a_hold_rifle",class'MeshAnimation'));
				}
				if (aMeshAnim != None)
				{
					LinkSkelAnim(aMeshAnim);
				}
				
				aMeshAnim = MeshAnimation(DynamicLoadObject("a_hold_rifle.a_hold_rifle",class'MeshAnimation'));
				if (aMeshAnim != None)
				{
					if (MeshAnim != None)
						UnlinkSkelAnim(MeshAnim, false);
					if (LinkSkelAnim(aMeshAnim))
					{
						MeshAnim = aMeshAnim;
						MeshAnimName = "a_hold_rifle.a_hold_rifle";
						CurMeshAnimName = "a_hold_rifle.a_hold_rifle";
					}
				}
				bInitializeAnimation = false;

				PlayWaiting();
				PlayMoving();
			}
		}
	}

	if ( bIsUSCharacter || bFriendlyFireListen )
	{
		CharacterSetupClass = class'CharacterSetupUSA';
		SetCharacterType( m_eCharacterType );
	}
	
	if ( bFriendlyFireListen && (Role == ROLE_Authority) )
	{
		CreateFriendlyListener(); // Only the server needs bullet listeners now, since the client hears about whizzes from the server
	}
}

simulated event Tick(float Delta)
{
	Super.Tick( Delta );

	//DHW +
	// -- This zeros out a flag every tick so that the user will pick up the right weapon when weapons are stacked
	bhasWeaponName = false;
	
	// -- This decrements the throwflags every tick so that stale throws are not executed late
	if (bthrowWeapon > 0.0f)
	{
		bthrowWeapon -= 1.0f;
	}
	//DHW -

	if ((bPawnBlinks) && (PawnBlinkTime < Level.TimeSeconds))
	{
		// 10 percent of the time check if we can double blink...
		if ((Rand(100) < 10) && (PawnDoubleBlinkCount > 3))
		{
			// double blink times are very short...
			PawnBlinkTime = Level.TimeSeconds + 0.5 + 0.5 * FRand();
			PawnDoubleBlinkCount = 0;  // don't double blink again for at least 3 normal blinks
		}
		else
		{
			PawnBlinkTime = Level.TimeSeconds + PawnBlinkDelayBase + PawnBlinkDelayDelta * FRand();
			PawnDoubleBlinkCount++;
		}

		AnimateBlink(true);
		PlayBlink(0.0, 0.0);
	}
	
	// GBX:PAD: If the animpawn has an auto-list of animations to play, then if this flag is set it means one of the
	// animations has finished and the next should be played.
	if (m_fRunNextQueueIdle)
	{
		if (m_fRandomIdleQueue)
		{
			m_nNextIdleQueueAnim = Rand( IdleQueue.Length );
		}

		if (LOG_DEBUG)
			log(self$".Tick() - "$Tag$" - "$m_nNextIdleQueueAnim$" - "$IdleQueue[ m_nNextIdleQueueAnim ].szAnimName, 'AnimPawn');
		AddAnimToQueue(IdleQueue[ m_nNextIdleQueueAnim ].szAnimName, 7777, false, true,,,, class'PawnAnimIdleListCallback');
		
		m_nNextIdleQueueAnim += 1;
		if (m_nNextIdleQueueAnim >= IdleQueue.Length)
		{
			m_nNextIdleQueueAnim = 0;
		}
		m_fRunNextQueueIdle = false;
	}
}

simulated event PostNetReceive()
{
	local MeshAnimation	aMeshAnim;
	
	//Log(self $ " AnimPawn::PostNetReceive() is it time to change the anims? MeshAnimName = " $ MeshAnimName $ " CurMeshAnimName =" $ CurMeshAnimName, 'AnimPawn');
	
	if ((Mesh != None) && (MeshAnimName != "") && (MeshAnimName != CurMeshAnimName))
	{
		//Log(self $ " AnimPawn::PostNetReceive() time to change the anims!! MeshAnimName = " $ MeshAnimName $ " CurMeshAnimName =" $ CurMeshAnimName, 'AnimPawn');

		aMeshAnim = MeshAnimation(DynamicLoadObject(MeshAnimName,class'MeshAnimation'));
		if (aMeshAnim != None)
		{
			//Log(self $ " AnimPawn::PostNetReceive() DynamicLoadObject worked", 'AnimPawn');

			if (MeshAnim != None)
				UnlinkSkelAnim(MeshAnim, false);
			if (LinkSkelAnim(aMeshAnim))
			{
				//Log(self $ " AnimPawn::PostNetReceive() LinkSkelAnim worked", 'AnimPawn');

				CurMeshAnimName = MeshAnimName;
				MeshAnim = aMeshAnim;
				bInitializeAnimation = false;

				// Since we're changing animation sets, make sure to flush the animation queue so we don't get
				// stuck on an idle that is no longer valid.
				FlushAnimQueueChannel( 0,, true );

				PlayWaiting();
				PlayMoving();
			}
		}
	}
}

function name GetWeaponBoneFor(Inventory I)
{
	return 'rifle_hold';
}


simulated function AnimateFace(bool bAnimate)
{
	if(LOG_DEBUG)
		log("AnimateFace "$bAnimate, 'AnimPawn');

	if(bPlayingFace != bAnimate)
	{
		bPlayingFace = bAnimate;

		if(bPlayingFace)
			StartFace();
		else
			StopFace();
	}
}


simulated function AnimateBlink(bool bAnimate)
{
	if(LOG_DEBUG)
		log("AnimateBlink "$bAnimate, 'AnimPawn');

	if(bPlayingBlink != bAnimate)
	{
		bPlayingBlink = bAnimate;

		if(bPlayingBlink)
			StartBlink();
		else
			StopBlink();
	}
}


simulated function PlayFaceAnim(name Sequence, float TweenInTime, float TweenOutTime)
{
	local int i;
	
	if (DrawType == DT_StaticMesh)
	{
		return;
	}
	
	for(i = 0; i < NumFaceChannels; i++)
	{
		PlayAnim(Sequence,, TweenInTime, FACE_CHANNEL+i);
	}

	HoldFaceTime = TweenOutTime;
}


simulated function PlayBlink(float TweenInTime, float TweenOutTime)
{
	PrivatePlayBlink(BlinkAnim, TweenInTime, TweenOutTime);
}


simulated function PrivatePlayBlink(name Sequence, float TweenInTime, float TweenOutTime)
{
	local int i;

	if (DrawType == DT_StaticMesh)
	{
		return;
	}
	
	for(i = 0; i < NumBlinkChannels; i++)
	{
		PlayAnim(Sequence,, TweenInTime, BLINK_CHANNEL+i);
	}

	HoldBlinkTime = TweenOutTime;
}

event DisableAutoFacialExpression( bool bDisable );

simulated event AnimEnd( int Channel )
{
	local int		i;

	for( i = 0; i < AnimQueue.Length; ++i )
	{
		if ((AnimQueue[ i ].nChannel == Channel) && (AnimQueue[ i ].bPlaying == 1))
		{
			if ( AnimQueue[ i ].bEndAnimCalled != 1 )
			{
				AnimQueue[ i ].bEndAnimCalled = 1;		// Prevents EndAnim() from being indirectly called by itself.

				if (AnimQueue[ i ].PawnAnimExtraClass != None)
					AnimQueue[ i ].PawnAnimExtraClass.Static.EndAnim( self, false, false );

				if ( AnimQueue[ i ].bLoop == 1 )		// Looping animations: EndAnim() will need to get called again next time it cycles.
					AnimQueue[ i ].bEndAnimCalled = 0;

				if(LOG_DEBUG)
					log(self$".EndAnim( "$self$", false, false ) - "$Tag$" - "$AnimQueue[ i ].szAnimName$" - "$Level.TimeSeconds$" - "$Channel, 'AnimPawn');
			}
			if (AnimQueue[ i ].bResetWhenComplete == 1)
			{
				AnimBlendToAlpha(Channel, 0, 0.0);
				if(LOG_DEBUG)
					log(self$".AnimQueue[ "$i$" ].bResetWhenComplete = "$AnimQueue[ i ].bResetWhenComplete, 'AnimPawn');
			}
			break;
		}
	}

	// If the current animation is looping, don't bother to play it again.
	if (i < AnimQueue.Length)
	{
		if ((AnimQueue[ i ].bLoop != 1) || (AnimQueue[ i ].bRestartWhenComplete == 1))
			PlayAnimFromQueue( Channel, false, false );
		else
		{
			if (AnimQueue[ i ].PawnAnimExtraClass != None)
				AnimQueue[ i ].PawnAnimExtraClass.Static.BeginAnim( self );
			if(LOG_DEBUG)
				log(self$".BeginAnim( "$self$" ) - "$Tag$" - "$AnimQueue[ i ].szAnimName$" - "$Level.TimeSeconds$" - "$Channel, 'AnimPawn');
		}
	}

	if(Channel == FACE_CHANNEL)
	{
		PlayFaceAnim(IdleFaceAnim,HoldFaceTime, 99999);
	}
	else if(Channel == BLINK_CHANNEL)
	{
		AnimateBlink(false);
	}
}



simulated function StartFace()
{
	if(LOG_DEBUG)
		log("StartFace", 'AnimPawn');

	AnimBlendParams(FACE_CHANNEL+0, 1.0, 0.0, 0.5, 'LLBrow01');
	AnimBlendParams(FACE_CHANNEL+1, 1.0, 0.0, 0.5, 'LMBrow01');
	AnimBlendParams(FACE_CHANNEL+2, 1.0, 0.0, 0.5, 'LRBrow01');
	AnimBlendParams(FACE_CHANNEL+3, 1.0, 0.0, 0.5, 'LEye01');
	AnimBlendParams(FACE_CHANNEL+4, 1.0, 0.0, 0.5, 'LCheek01');
	AnimBlendParams(FACE_CHANNEL+5, 1.0, 0.0, 0.5, 'LLUpperLip01');
	AnimBlendParams(FACE_CHANNEL+6, 1.0, 0.0, 0.5, 'LMUpperLip01');
	AnimBlendParams(FACE_CHANNEL+7, 1.0, 0.0, 0.5, 'JawBone01');
	AnimBlendParams(FACE_CHANNEL+8, 1.0, 0.0, 0.5, 'RLBrow01');
	AnimBlendParams(FACE_CHANNEL+9, 1.0, 0.0, 0.5, 'RMBrow01');
	AnimBlendParams(FACE_CHANNEL+10, 1.0, 0.0, 0.5, 'RRBrow01');
	AnimBlendParams(FACE_CHANNEL+11, 1.0, 0.0, 0.5, 'REye01');
	AnimBlendParams(FACE_CHANNEL+12, 1.0, 0.0, 0.5, 'RCheek01');
	AnimBlendParams(FACE_CHANNEL+13, 1.0, 0.0, 0.5, 'RRUpperLip01');
	AnimBlendParams(FACE_CHANNEL+14, 1.0, 0.0, 0.5, 'RMUpperLip01');

	NumFaceChannels = 15;
}



simulated function StopFace()
{
	if(LOG_DEBUG)
		log("StopFace", 'AnimPawn');

	AnimBlendToAlpha(FACE_CHANNEL+0, 0, 0.4);
	AnimBlendToAlpha(FACE_CHANNEL+1, 0, 0.4);
	AnimBlendToAlpha(FACE_CHANNEL+2, 0, 0.4);
	AnimBlendToAlpha(FACE_CHANNEL+3, 0, 0.4);
	AnimBlendToAlpha(FACE_CHANNEL+4, 0, 0.4);
	AnimBlendToAlpha(FACE_CHANNEL+5, 0, 0.4);
	AnimBlendToAlpha(FACE_CHANNEL+6, 0, 0.4);
	AnimBlendToAlpha(FACE_CHANNEL+7, 0, 0.4);
	AnimBlendToAlpha(FACE_CHANNEL+8, 0, 0.4);
	AnimBlendToAlpha(FACE_CHANNEL+9, 0, 0.4);
	AnimBlendToAlpha(FACE_CHANNEL+10, 0, 0.4);
	AnimBlendToAlpha(FACE_CHANNEL+11, 0, 0.4);
	AnimBlendToAlpha(FACE_CHANNEL+12, 0, 0.4);
	AnimBlendToAlpha(FACE_CHANNEL+13, 0, 0.4);
	AnimBlendToAlpha(FACE_CHANNEL+14, 0, 0.4);
}


simulated function StartBlink()
{
	if(LOG_DEBUG)
		log("StartBlink", 'AnimPawn');

	AnimBlendParams(BLINK_CHANNEL+0, 1.0, 0.0, 0.5, 'eyelids');

	NumBlinkChannels = 1;
}


simulated function StopBlink()
{
	if(LOG_DEBUG)
		log("StopBlink", 'AnimPawn');

	AnimBlendToAlpha(BLINK_CHANNEL+0, 0, 0.1);
}


simulated event UpdateNinePointBlend( float DeltaTime, Rotator NewRotation )
{
}


simulated event UpdateTorsoRotation( float DeltaTime, Rotator NewRotation )
{
}


simulated function Rotator HeadViewRotation()
{
	local	Rotator	ViewRotation;

	ViewRotation = Rotation;
	// GBX:PAD: These multiplayers take off some multipliers added on to the rotation when it's passed on to the bone.
	// In order to make this rotation correct for the world, I'm taking the modifiers back off.
	ViewRotation.Yaw -= (HeadCurRotation.Yaw * 6);
	ViewRotation.Pitch = (HeadCurRotation.Roll * 2);

	return ViewRotation;
}

simulated function Rotator TorsoViewRotation()
{
	local	Rotator	ViewRotation;

	ViewRotation = Rotation;
	// GBX:PAD: These multiplayers take off some multipliers added on to the rotation when it's passed on to the bone.
	// In order to make this rotation correct for the world, I'm taking the modifiers back off.
	ViewRotation.Yaw -= (TorsoCurRotation.Yaw * 2);
	ViewRotation.Pitch = (TorsoCurRotation.Roll * 2);

	return ViewRotation;
}

simulated event float GetAimingSourceHeight()
{
	if (Weapon != None)
	{
		return (Weapon.GetMuzzleLocationWorld().Z - Location.Z);
	}
	return (EyePosition().Z);
}

simulated function bool PlayAnimFromQueue( int	nChannel, bool fInterrupt, bool fReplayAnim )
{
	local	int		i;
	local	bool	fRootMotion;
	local	byte	bTeleportRootType;

	bTeleportRootType = TR_None;
	for( i = 0; i < AnimQueue.Length; ++i )
	{
		if ( (AnimQueue[ i ].nChannel == nChannel) && (AnimQueue[ i ].bPlaying == 1) )
		{
			if (fInterrupt)
			{
				if ( AnimQueue[ i ].bEndAnimCalled != 1 )
				{
					AnimQueue[ i ].bEndAnimCalled = 1;

					if (AnimQueue[ i ].PawnAnimExtraClass != None)
						AnimQueue[ i ].PawnAnimExtraClass.Static.EndAnim( self, false, true );

					if ( AnimQueue[ i ].bLoop == 1 )		// Looping animations: EndAnim() will need to get called again next time it cycles.
						AnimQueue[ i ].bEndAnimCalled = 0;
				}
			}
			if (AnimQueue[ i ].bRootMotion == 1)
				LockRootMotion( 2 );
			if (AnimQueue[ i ].bResetWhenComplete == 1)
			{
				AnimBlendToAlpha(nChannel, 0, 0.0);
				if(LOG_DEBUG)
					log(self$".AnimQueue[ "$i$" ].bResetWhenComplete = "$AnimQueue[ i ].bResetWhenComplete, 'AnimPawn');
			}
			if ((AnimQueue[ i ].bTeleportRootType == TR_AnimStart) || (AnimQueue[ i ].bTeleportRootType == TR_AnimStartNoRotation))
				bTeleportRootType = AnimQueue[ i ].bTeleportRootType;
			if ((AnimQueue[ i ].bLoop == 1) || fReplayAnim)
			{
				AnimQueue[ i ].bPlaying = 0;
			}
			else
			{
				AnimQueue.Remove( i, 1 );
			}
			break;
		}
	}

	for( i = 0; i < AnimQueue.Length; ++i )
	{
		if( AnimQueue[ i ].nChannel == nChannel )
		{
			if (AnimQueue[ i ].bRootMotion == 1)
				LockRootMotion( 0 );
// GBX:PAD: I'm going to comment this out for now since I don't think it's necessary any more with other fixes that have
// happened
//			if (AnimQueue[ i ].bTeleportRootType == 1)
//			{
//				m_fDispositionAnimPlaying = true;
//			}
			if ((AnimQueue[ i ].bTeleportRootType == TR_AnimEnd) || (AnimQueue[ i ].bTeleportRootType == TR_AnimEndNoRotation))
				bTeleportRootType = AnimQueue[ i ].bTeleportRootType;
			if (AnimQueue[ i ].flBlendAlpha > 0.0)
			{
				AnimBlendParams(nChannel, AnimQueue[ i ].flBlendAlpha, AnimQueue[ i ].flInTime, AnimQueue[ i ].flOutTime, AnimQueue[ i ].szBlendBone, false);
				if (AnimQueue[ i ].bLoop == 1)
				{
					LoopAnim(AnimQueue[ i ].szAnimName, AnimQueue[ i ].flRate, AnimQueue[ i ].flTween, AnimQueue[ i ].nChannel,, bTeleportRootType);
					AnimQueue[ i ].bRestartWhenComplete = 0;
				}
				else
					PlayAnim(AnimQueue[ i ].szAnimName, AnimQueue[ i ].flRate, AnimQueue[ i ].flTween, AnimQueue[ i ].nChannel,, bTeleportRootType);
			}
			else
			{
				if (AnimQueue[ i ].bRootMotion == 1)
					fRootMotion = true;
				if (AnimQueue[ i ].bLoop == 1)
				{
					LoopAnim( AnimQueue[ i ].szAnimName, AnimQueue[ i ].flRate, AnimQueue[ i ].flTween, 0, fRootMotion, bTeleportRootType );
					AnimQueue[ i ].bRestartWhenComplete = 0;
				}
				else
					PlayAnim( AnimQueue[ i ].szAnimName, AnimQueue[ i ].flRate, AnimQueue[ i ].flTween, 0, fRootMotion, bTeleportRootType );
			}
			if(LOG_DEBUG)
				log (self$".PlayAnimFromQueue( "$nChannel$", "$fInterrupt$", "$fReplayAnim$" ) - "$AnimQueue[ i ].szAnimName$" - "$AnimQueue[ i ].bLoop$" - "$Level.TimeSeconds$" - "$bTeleportRootType, 'AnimPawn');
// GBX:PAD: I'm going to comment this out for now since I don't think it's necessary any more with other fixes that have
// happened
//			if (bTeleportRootType == 1)
//				m_fDispositionAnimPlaying = false;
			AnimQueue[ i ].bPlaying = 1;
			if (AnimQueue[ i ].PawnAnimExtraClass != None)
				AnimQueue[ i ].PawnAnimExtraClass.Static.BeginAnim( self );
			return true;
		}
	}

	return false;
}

simulated function bool AddAnimToQueue( name szAnimName, int nPriority, bool fPlayFull, optional bool fLoop,
									    optional bool fRootMotion, optional float flRate, optional float flTween,
										optional class<PawnAnimExtra> PawnAnimExtraClass, optional int nChannel,
										optional name szBlendBone, optional float flBlendAlpha,	optional float flInTime,
										optional float flOutTime, optional bool fResetWhenComplete, optional byte bTeleportRootType )
{
	local	int		i;
	local	bool	fPlaying, fReturn, fInterrupt, fUpdate;
	local	AnimQueueElement	anElement;
	local	int		nLoopSlot, nUpdateSlot;

	if ((Controller != None) && Controller.bControlAnimations)
	{
		return false;
	}

	// This means the guy is dead and has been set to not accept other input to his body.  By the time this flag is
	// set, the guy should have been put into either a death animation, or a Karma death state and should NOT play
	// ANY animations after that point.  Also, if the guy is dead and you're trying to play an animation on any
	// channel other than the main one, don't animate him.
	if ((Health <= 0) && (nChannel > 0))
	{
		return false;
	}
	
	if (m_bDisableAnimQueue)
	{
		return false;
	}

	if ((DrawType == DT_StaticMesh) || (Mesh == None))
	{
		log(self$".AddAnimToQueue - Error: Called with no mesh set");
		if (PawnAnimExtraClass != None)
		{
			PawnAnimExtraClass.Static.EndAnim( self, true, false );
		}
		return false;
	}

	if (szAnimName == '')
	{
		log(self$".AddAnimToQueue - Error: Called with no anim name");
		return false;
	}

	if (!HasAnim( szAnimName ))
	{
		log(self$".AddAnimToQueue - Error: Animation "$szAnimName$" does not exist in this set");
		if (PawnAnimExtraClass != None)
		{
			PawnAnimExtraClass.Static.EndAnim( self, true, false );
		}
		return false;
	}
	
	fPlaying = false;
	fInterrupt = false;
	nLoopSlot = -1;
	nUpdateSlot = -1;
	if(LOG_DEBUG)
		log(self$".AddAnimToQueue( "$szAnimName$", "$nPriority$", "$flRate$", "$flTween$", "$nChannel$", "$szBlendBone$", "$flBlendAlpha$", "$flInTime$", "$flOutTime$", "$PawnAnimExtraClass$", "$fLoop$", "$bTeleportRootType$" ) - "$Tag, 'AnimPawn');
	fReturn = false;
	for( i = 0; i < AnimQueue.Length; ++i )
	{
		if (AnimQueue[ i ].nChannel == nChannel)
		{
			if(LOG_DEBUG)
				log(self$".AddAnimToQueueTest() "$Tag$" - "$AnimQueue[ i ].szAnimName$", "$AnimQueue[ i ].nPriority$", "$AnimQueue[ i ].bLoop, 'AnimPawn');

			if (AnimQueue[ i ].szAnimName == szAnimName)
			{
				if (flRate == 0.0f)
				{
					AnimQueue[ i ].flRate = 1.0f;
				}
				else
				{
					AnimQueue[ i ].flRate = flRate;
				}
				AnimQueue[ i ].flTween = flTween;
				AnimQueue[ i ].nPriority = nPriority;
				if (AnimQueue[ i ].bPlaying == 0)
				{
					if (PawnAnimExtraClass != None)
					{
						PawnAnimExtraClass.Static.EndAnim( self, true, false );
					}
				}
				else if (AnimQueue[ i ].bPlayFull == 0)
				{
					PlayAnimFromQueue( nChannel, true, true );
				}
				fUpdate = true;
				fReturn = true;
				nUpdateSlot = i;
			}

			if (fLoop)
			{
				if ((AnimQueue[ i ].nPriority > nPriority) && (AnimQueue[ i ].bLoop == 1))
				{
					fReturn = true;
				}
			}
			else
			{
				if ((AnimQueue[ i ].nPriority > nPriority) && (AnimQueue[ i ].bLoop != 1))
				{
					fReturn = true;
				}
			}

			if (fReturn)
			{
				if (PawnAnimExtraClass != None)
				{
					PawnAnimExtraClass.Static.EndAnim( self, true, false );
				}

				return false;
			}

			if (AnimQueue[ i ].bPlaying == 1)
			{
				fPlaying = true;
				if (AnimQueue[ i ].bLoop != 1)
				{
					if ((AnimQueue[ i ].bPlayFull == 0) && !fLoop)
					{
						fInterrupt = true;
					}
				}
				else
				{
//					if (!fLoop && (nPriority > AnimQueue[ i ].nPriority))
					if (nPriority > AnimQueue[ i ].nPriority)
					{
						fInterrupt = true;
					}
				}
			}

			if (AnimQueue[ i ].bLoop == 1)
				nLoopSlot = i;
		}
	}

	// GBX:PAD: Even if we're just updating an existing queue entry, I want to do some other checks on it later on, but
	// all the queue entry creation logic needs to be blown off in that case.
	if (!fUpdate)
	{
		anElement.bEndAnimCalled = 0;

		if(LOG_DEBUG)
			log(self$".AddAnimToQueue( "$szAnimName$", "$nPriority$", "$flRate$", "$flTween$", "$nChannel$", "$szBlendBone$", "$flBlendAlpha$", "$flInTime$", "$flOutTime$", "$PawnAnimExtraClass$", "$fLoop$" ) - "$Tag$" - "$Level.TimeSeconds, 'AnimPawn');
		anElement.szAnimName = szAnimName;
		if (flRate == 0.0)
			anElement.flRate = 1.0;
		else
			anElement.flRate = flRate;
		anElement.flTween = flTween;
		anElement.nChannel = nChannel;
		if (fLoop)
			anElement.bLoop = 1;
		else
			anElement.bLoop = 0;
		anElement.szBlendBone = szBlendBone;
		anElement.nPriority = nPriority;
		anElement.flBlendAlpha = flBlendAlpha;
		// GBX:PAD: I'm putting this in here for now as an experiment to see if forcing a uniform blend for all
		// channel 0 animations will smooth out some of our abrupt popping.
		if (nChannel == 0)
		{
			anElement.flInTime = 0.3;
		}
		else
		{
			anElement.flInTime = flInTime;
		}
		anElement.flOutTime = flOutTime;
		anElement.PawnAnimExtraClass = PawnAnimExtraClass;
		anElement.bPlaying = 0;
		if (fPlayFull)
			anElement.bPlayFull = 1;
		else
			anElement.bPlayFull = 0;
		if (fRootMotion)
			anElement.bRootMotion = 1;
		else
			anElement.bRootMotion = 0;
		if (fResetWhenComplete)
			anElement.bResetWhenComplete = 1;
		else
			anElement.bResetWhenComplete = 0;
		anElement.bTeleportRootType = bTeleportRootType;
		if (nLoopSlot >= 0)
		{
			if (fLoop)
			{
				// GBX:PAD: Make sure this looping animation inherits the status of the animation it's replacing, otherwise it
				// causes issues with the animend checks.
				anElement.bPlaying = AnimQueue[ nLoopSlot ].bPlaying;
				if (AnimQueue[ nLoopSlot ].bPlaying == 1)
					anElement.bRestartWhenComplete = 1;
				AnimQueue.Remove( nLoopSlot, 1 );
				AnimQueue.Length = AnimQueue.Length + 1;
				AnimQueue[ AnimQueue.Length - 1 ] = anElement;
			}
			else
			{
				AnimQueue.Length = AnimQueue.Length + 1;
				AnimQueue[ AnimQueue.Length - 1 ] = AnimQueue[ nLoopSlot ];
				AnimQueue[ nLoopSlot ] = anElement;
			}
		}
		else
		{
			AnimQueue.Length = AnimQueue.Length + 1;
			AnimQueue[ AnimQueue.Length - 1 ] = anElement;
		}

		i = 0;
		do
		{
			if ((AnimQueue[ i ].nChannel == nChannel) && (AnimQueue[ i ].nPriority < nPriority) && (AnimQueue[ i ].bLoop != 1) && ((AnimQueue[ i ].bPlaying == 0) || (AnimQueue[ i ].bPlayFull == 0)))
			{
				if (AnimQueue[ i ].PawnAnimExtraClass != None && AnimQueue[ i ].bEndAnimCalled != 1 )
				{
					AnimQueue[ i ].bEndAnimCalled = 1;

					if (AnimQueue[ i ].bPlaying == 0)
					{						
						AnimQueue[ i ].PawnAnimExtraClass.Static.EndAnim( self, true, false );
					}
					else
					{
						AnimQueue[ i ].PawnAnimExtraClass.Static.EndAnim( self, false, true );
					}				
				}
				if ((AnimQueue[ i ].bPlaying == 1) && (AnimQueue[ i ].bResetWhenComplete == 1))
				{
					AnimBlendToAlpha(nChannel, 0, 0.0);
					if(LOG_DEBUG)
						log(self$".AnimQueue[ "$i$" ].bResetWhenComplete = "$AnimQueue[ i ].bResetWhenComplete, 'AnimPawn');
				}
				AnimQueue.Remove( i, 1 );
			}
			i++;
		}
		until (i >= AnimQueue.Length);
	}
	
	if (!fPlaying || fInterrupt)
	{
		if(LOG_DEBUG)
			log(self$".AddAnimToQueuePlay() "$fPlaying$", "$fInterrupt, 'AnimPawn');
		PlayAnimFromQueue( nChannel, fInterrupt, false );
	}
}

simulated function FlushAnimQueueChannel( int nChannel, optional bool bLoopingOnly, optional bool bDeleteAll )
{
	local	int		i;

	i = 0;
	while( i < AnimQueue.Length )
	{
		if (AnimQueue[ i ].nChannel == nChannel)
		{
			if (!bDeleteAll)
			{
				if (bLoopingOnly)
				{
					if (AnimQueue[ i ].bLoop == 1)
					{
						if (AnimQueue[ i ].bPlaying == 1)
						{
							AnimQueue[ i ].bLoop = 0;
						}
						else
						{
							if ( AnimQueue[ i ].bEndAnimCalled != 1 )
							{
								AnimQueue[ i ].bEndAnimCalled = 1;

								if (AnimQueue[ i ].PawnAnimExtraClass != None)
									AnimQueue[ i ].PawnAnimExtraClass.Static.EndAnim( self, true, false );
							}
							AnimQueue.Remove( i, 1 );							
						}
					}
					else
					{
						i++;
						continue;
					}
				}
				if (AnimQueue[ i ].bPlaying == 1)
				{
					AnimQueue[ i ].bLoop = 0;
					i++;
				}
				else
				{
					if ( AnimQueue[ i ].bEndAnimCalled != 1 )
					{
						AnimQueue[ i ].bEndAnimCalled = 1;

						if (AnimQueue[ i ].PawnAnimExtraClass != None)
							AnimQueue[ i ].PawnAnimExtraClass.Static.EndAnim( self, true, false );
					}
					AnimQueue.Remove( i, 1 );					
				}
			}
			else
			{
				if (AnimQueue[ i ].PawnAnimExtraClass != None && AnimQueue[ i ].bEndAnimCalled != 1 )
				{
					AnimQueue[ i ].bEndAnimCalled = 1;

					if (AnimQueue[ i ].bPlaying == 1)
					{
						AnimQueue[ i ].PawnAnimExtraClass.Static.EndAnim( self, false, false );
					}
					else
					{
						AnimQueue[ i ].PawnAnimExtraClass.Static.EndAnim( self, true, false );
					}
				}
				
				
				// GBX:naj - This channel check fixes bug 11400, but it's just a hacky band-aid.
				// A better long-term solution would have been to require that EndAnim() callbacks NOT be able to 
				// call queue functions themselves, directly or indirectly.
				if (  AnimQueue[ i ].nChannel == nChannel )	
				{
					AnimQueue.Remove( i, 1 );
				}
				else
				{
					log(self$".FlushAnimQueueChannel: ERROR! Flushing channel "$nChannel$" but accidentally removing animation "$AnimQueue[ i ].szAnimName$" on channel "$AnimQueue[ i ].nChannel );
				}											
			}
		}
		else
		{
			i++;
		}
	}
	if (nChannel > 0)
		AnimBlendToAlpha(nChannel, 0, 0.0);
}

// GBX:PAD: When we're loading a saved game, this animation queue list is also saved, however any animations that
// were "playing" are not actually still playing for this pawn.  So, reset all the play flags in the queue so
// that new animations know to start playing immediately.
simulated function RestartAnimQueue()
{
	local	int		i;

	i = 0;
	while( i < AnimQueue.Length )
	{
		if (AnimQueue[ i ].bPlaying == 1)
		{
			PlayAnimFromQueue( AnimQueue[ i ].nChannel, false, true );
		}
		i++;
	}
}

simulated function bool AttachScriptedAttachment( StaticMesh aMesh, name nmAttachBone )
{
	local ScriptedAttachmentInfo	anAttachment;
	local	int		i;

	// GBX:PAD: First go ahead and see if a blank attachment already exists.  I did it this way since the memory use
	// of these records is nominal, so why keep doing "new" on new records and rather just keep them around since, if
	// this guy used an attachment once, they probably will again.
	i = 0;
	while( i < ScriptedAttachments.Length )
	{
		if ( (ScriptedAttachments[ i ].m_Attachment != None) && (ScriptedAttachments[ i ].m_Attachment.StaticMesh == aMesh) && (ScriptedAttachments[ i ].m_nmAttachBone == nmAttachBone) )
		{
			log(self$".AttachScriptedAttachment( "$aMesh$", "$nmAttachBone$" ) - "$Tag$" - "$ScriptedAttachments[ i ].m_Attachment$" - Static Mesh already attached.");
			return false;
		}

		if ( ScriptedAttachments[ i ].m_Attachment == None )
		{
			break;
		}
		else
		{
			i++;
		}
	}

	if (i < ScriptedAttachments.Length)
	{
		ScriptedAttachments[ i ].m_Attachment = Spawn( class'ScriptedInventoryAttachment', self );
		if (ScriptedAttachments[ i ].m_Attachment != None)
		{
			ScriptedAttachments[ i ].m_Attachment.SetStaticMesh( aMesh );
			ScriptedAttachments[ i ].m_nmAttachBone = nmAttachBone;
			if (AttachToBone(ScriptedAttachments[ i ].m_Attachment,ScriptedAttachments[ i ].m_nmAttachBone))
				log(self$".AttachScriptedAttachment( "$aMesh$", "$nmAttachBone$" ) - "$Tag$" - "$ScriptedAttachments[ i ].m_Attachment$" - Success", 'AnimPawn');
			else
				log(self$".AttachScriptedAttachment( "$aMesh$", "$nmAttachBone$" ) - "$Tag$" - "$ScriptedAttachments[ i ].m_Attachment$" - Failed");
		}
		else
		{
			log(self$".AttachScriptedAttachment( "$aMesh$", "$nmAttachBone$" ) - "$Tag$" - Failed to Spawn for Replacement");
			return false;
		}
	}
	else
	{
		anAttachment = new( Level.Outer ) class'ScriptedAttachmentInfo';
		if (anAttachment != None)
		{
			anAttachment.m_Attachment = Spawn( class'ScriptedInventoryAttachment', self );
			if (anAttachment.m_Attachment != None)
			{
				anAttachment.m_Attachment.SetStaticMesh( aMesh );
				anAttachment.m_nmAttachBone = nmAttachBone;
				ScriptedAttachments.Length = ScriptedAttachments.Length + 1;
				ScriptedAttachments[ ScriptedAttachments.Length - 1 ] = anAttachment;
				AttachToBone(anAttachment.m_Attachment,anAttachment.m_nmAttachBone);
				log(self$".AttachScriptedAttachment( "$aMesh$", "$nmAttachBone$" ) - "$Tag$" - "$anAttachment, 'AnimPawn');
			}
			else
			{
				log(self$".AttachScriptedAttachment( "$aMesh$", "$nmAttachBone$" ) - "$Tag$" - Failed to Spawn for Addition");
				return false;
			}
		}
		else
		{
			log(self$".AttachScriptedAttachment( "$aMesh$", "$nmAttachBone$" ) - "$Tag$" - Failed to create new record");
			return false;
		}
	}

	return true;
}

simulated function bool DetachScriptedAttachment( StaticMesh aMesh, name nmAttachBone )
{
	local	int		i;

	i = 0;
	while( i < ScriptedAttachments.Length )
	{
		if ( ((ScriptedAttachments[ i ].m_Attachment.StaticMesh == aMesh) || (aMesh == None)) && (ScriptedAttachments[ i ].m_nmAttachBone == nmAttachBone) )
		{
			DetachFromBone( ScriptedAttachments[ i ].m_Attachment );
			log(self$".DetachScriptedAttachment( "$ScriptedAttachments[ i ].m_Attachment.StaticMesh$", "$nmAttachBone$" ) - "$Tag, 'AnimPawn');
			ScriptedAttachments[ i ].m_Attachment.Destroy();
			ScriptedAttachments[ i ].m_Attachment = None;
			ScriptedAttachments[ i ].m_nmAttachBone = '';
			if (aMesh == None)
			{
				i++;
			}
			else
			{
				return true;
			}
		}
		else
		{
			i++;
		}
	}

	return false;
}

simulated function bool DropScriptedAttachment( StaticMesh aMesh, name nmAttachBone )
{
	local	int		i;

	i = 0;
	while( i < ScriptedAttachments.Length )
	{
		if ( ((ScriptedAttachments[ i ].m_Attachment.StaticMesh == aMesh) || (aMesh == None)) && (ScriptedAttachments[ i ].m_nmAttachBone == nmAttachBone) )
		{
			DetachFromBone( ScriptedAttachments[ i ].m_Attachment );
			ScriptedAttachments[ i ].m_Attachment.DropFrom( ScriptedAttachments[ i ].m_Attachment.Location );
			ScriptedAttachments[ i ].m_Attachment = None;
			ScriptedAttachments[ i ].m_nmAttachBone = '';
			log(self$".DropScriptedAttachment( "$ScriptedAttachments[ i ].m_Attachment.StaticMesh$", "$nmAttachBone$" ) - "$Tag, 'AnimPawn');
			if (aMesh == None)
			{
				i++;
			}
			else
			{
				return true;
			}
		}
		else
		{
			i++;
		}
	}

	return false;
}

simulated function bool DetachWeapon( name nmAttachBone )
{
	if ((Weapon != None) && (Weapon.ThirdPersonActor != None))
	{
		log(self$".DetachWeapon( "$nmAttachBone$" ) - "$Tag);
		DetachFromBone( Weapon.ThirdPersonActor );
		if (nmAttachBone != '')
			AttachToBone( Weapon.ThirdPersonActor, nmAttachBone );
		return true;
	}

	return false;
}

simulated function bool ReattachWeapon( name nmAttachBone )
{
	if ((Weapon != None) && (Weapon.ThirdPersonActor != None))
	{
		log(self$".ReattachWeapon( "$nmAttachBone$" ) - "$Tag);
		DetachFromBone( Weapon.ThirdPersonActor );
		if (nmAttachBone == '')
		{
			AttachToBone( Weapon.ThirdPersonActor, GetWeaponBoneFor( Weapon ) );
		}
		else
		{
			AttachToBone( Weapon.ThirdPersonActor, nmAttachBone );
		}
		return true;
	}
	return false;
}

simulated event Destroyed()
{
	local	int	i;


	for( i = 0; i < ExtendedAttachments.Length; i++ )
	{
		if (ExtendedAttachments[i] != None)
		{
			if (ExtendedAttachments[i].m_AttachedPart != None)
			{
				ExtendedDetachment( ExtendedAttachments[i].m_AttachedPart );
				ExtendedAttachments[i].m_AttachedPart.Destroy();
				ExtendedAttachments[i].m_AttachedPart = None;
			}
		}
	}

	for( i = 0; i < ScriptedAttachments.Length; i++ )
	{
		if (ScriptedAttachments[i] != None)
		{
			if (ScriptedAttachments[i].m_Attachment != None)
			{
				ScriptedAttachments[i].m_Attachment.Destroy();
			}
		}
	}
	
	if (MyFriendlyListener != None)
	{
		MyFriendlyListener.Destroy();
	}
	
	Super.Destroyed();
}

function AddExtendedAttachment( name nmSocket, name nmPart )
{
	local ExtendedAttachmentInfo	anEAInfo;
	local int		i, j, nAttachIdx;

	nAttachIdx = -1;
	for( i = 0; i < ExtendedAttachments.Length; i++ )
	{
		if ((ExtendedAttachments[i] == None) || (ExtendedAttachments[i].m_AttachedPart == None))
		{
			nAttachIdx = i;
			break;
		}
	}
	
	if (nAttachIdx == -1)
	{
		nAttachIdx = ExtendedAttachments.Length;
		ExtendedAttachments.Length = ExtendedAttachments.Length + 1;
	}
		
	if (ExtendedAttachments[nAttachIdx] == None)
	{
		anEAInfo = new( Level.Outer ) class'ExtendedAttachmentInfo';
		ExtendedAttachments[nAttachIdx] = anEAInfo;
	}
	ExtendedAttachments[nAttachIdx].m_nmSocketName = nmSocket;
	ExtendedAttachments[nAttachIdx].m_nmPartName = nmPart;

	ExtendedAttachments[nAttachIdx].m_AttachedPart = Spawn( class'AttachedPart', self );
	if (ExtendedSkins.Length > 0)
	{
		for (j = 0; j < ExtendedSkins.Length; j++)
		{
			if (ExtendedSkins[j] != None)
			{
				ExtendedAttachments[nAttachIdx].m_AttachedPart.Skins[j] = ExtendedSkins[j];
			}
		}
	}
	if (ExtendedAttachments[nAttachIdx].m_szGroupName != "")
		ExtendedAttachmentNamedGroup( ExtendedAttachments[nAttachIdx].m_AttachedPart, ExtendedAttachments[nAttachIdx].m_szGroupName );
	else
		ExtendedAttachment( ExtendedAttachments[nAttachIdx].m_AttachedPart, ExtendedAttachments[nAttachIdx].m_nmSocketName, ExtendedAttachments[nAttachIdx].m_nmPartName );
}

function RemoveExtendedAttachment( name nmSocket, name nmPart )
{
	local int		i;

	for( i = 0; i < ExtendedAttachments.Length; i++ )
	{
		if (ExtendedAttachments[i] != None)
		{
			if ((ExtendedAttachments[i].m_nmSocketName == nmSocket) && (ExtendedAttachments[i].m_nmPartName == nmPart))
			{
				ExtendedDetachment( ExtendedAttachments[i].m_AttachedPart );
				ExtendedAttachments[i].m_AttachedPart.Destroy();
				ExtendedAttachments[i].m_AttachedPart = None;
			}
		}
	}
}
/*
struct native export IdleQueueAnim
{
	var name		szAnimName;
	var byte		bTeleportRootType;
};

var array<IdleQueueAnim> IdleQueue;
*/
function ClearIdleQueue()
{
	AnimQueue.Remove( 0, AnimQueue.Length );
	IdleQueue.Remove( 0, IdleQueue.Length );
}

function AddAnimToIdleQueue( name szAnimName )
{
	local	IdleQueueAnim	anElement;

	anElement.szAnimName = szAnimName;
	anElement.bAnimHasBeenPlayed = 0;

	IdleQueue.Length = IdleQueue.Length + 1;
	IdleQueue[ IdleQueue.Length - 1 ] = anElement;
}

function PlayAnimFromIdleQueue( bool fRandom )
{
	m_fRandomIdleQueue = fRandom;
	m_nNextIdleQueueAnim = 0;

	if (m_fRandomIdleQueue)
	{
		m_nNextIdleQueueAnim = Rand( IdleQueue.Length );
	}
	AddAnimToQueue( IdleQueue[ m_nNextIdleQueueAnim ].szAnimName, 7777, false, true,,, 0.15f, class'PawnAnimIdleListCallback' );
	
	m_nNextIdleQueueAnim += 1;
	if (m_nNextIdleQueueAnim >= IdleQueue.Length)
	{
		m_nNextIdleQueueAnim = 0;
	}
	m_fRunNextQueueIdle = false;
}

simulated function CreateFriendlyListener()
{
	if (MyFriendlyListener == None)
	{	
		MyFriendlyListener = Spawn( class'FriendlyListener' );
		MyFriendlyListener.SetLocation(Location);
//		MyFriendlyListener.SetBase(self);
//		MyFriendlyListener.SetRelativeLocation(vect(0,0,0));
		AttachToBone(MyFriendlyListener, 'Bip01');
		MyFriendlyListener.NotifyPawn = self;
	}
	log(self$".CreateFriendlyFireListener() - "$Tag$" - "$MyFriendlyListener);
}

function NotifyNearbyTrace( Actor Other, vector TouchLocation, vector TouchNormal, vector End, vector Start, vector Extent, int TraceFlags )
{
	if (bHidden)
	{
		m_flLastDisplayPawnInfo = -1.0;
		return;
	}
		
	if (Other.IsA('gbxPlayerPawn'))
	{
		m_flLastDisplayPawnInfo = Level.TimeSeconds;
		bPawnInfoIconOnly = false;
	}
}

function SetCharacterType( int nCharType )
{
	m_nCharType = nCharType;
	m_nNewCharType = nCharType;
	m_flRank = GetCharacterRank();
	log(self$".SetCharacterType( "$nCharType$" ) - "$m_nCharType$" - "$m_flRank);
}

simulated function String GetCharacterFacialPackage()
{
	if (CharacterSetupClass != None)
		return CharacterSetupClass.Static.GetCharacterFacialPackage(m_nCharType);
}

simulated function Name GetCharacterHead()
{
//	if ((CharacterSetupClass != None) && ((Level.NetMode != NM_StandAlone) || (m_eCharacterType != USCharNone)))
	if (CharacterSetupClass != None)
		return CharacterSetupClass.Static.GetCharacterHead(m_nCharType);
	else
		return '';
}
simulated function string GetCharacterVoiceType( optional bool bIsDemoBuild )
{
	//log( "AnimPawn::GetCharacterVoiceType() - bIsDemoBuild=" $ bIsDemoBuild, 'RSC' );
	if (CharacterSetupClass != None)
		return CharacterSetupClass.Static.GetCharacterVoiceType(m_nCharType,bIsDemoBuild);
	else
		return "";
}
simulated function float GetCharacterScale()
{
	if (CharacterSetupClass != None)
	{
		return CharacterSetupClass.Static.GetCharacterScale(m_nCharType);
	}
	else
		return 1.0f;
}
simulated function float GetCharacterRank()
{
	if (CharacterSetupClass != None)
		return CharacterSetupClass.Static.GetCharacterRank(m_nCharType);
	else
		return 0.0f;
}
simulated function string GetCharacterName()
{
	if (CharacterSetupClass != None)
		return CharacterSetupClass.Static.GetCharacterName(m_nCharType);
}

simulated event string GetCharacterRankName()
{
	if (CharacterSetupClass != None)
		return CharacterSetupClass.Static.GetCharacterRankName(m_nCharType);
}

simulated function name GetCharacterFName()
{
	if ( CharacterSetupClass != None )
	{
		return CharacterSetupClass.Static.GetCharacterFName(m_nCharType);
	}
	else
	{
		return '';
	}
}

simulated function string GetCharacterPortrait()
{
	if (CharacterSetupClass != None)
		return CharacterSetupClass.Static.GetCharacterPortrait(m_nCharType);
}

simulated event bool TargetFriendly( Vector aHitLoc, Pawn SourcePawn, bool bFiring )
{
	if (!bHidden && bFriendlyFireListen && (Level.NetMode == NM_Standalone))
	{
		m_flLastDisplayPawnInfo = Level.TimeSeconds;
		bPawnInfoIconOnly = false;

		if (bFiring)
			m_flLastDisplayPawnNoShoot = Level.TimeSeconds;
		return true;
	}
	return false;
}

simulated event PostRespawnPlay()
{
	Super.PostRespawnPlay();
	
	m_flLastDisplayPawnInfo = -1.0;
}

function TakeDamage( int Damage, Pawn instigatedBy, Vector hitlocation,
						Vector momentum, class<DamageType> damageType, optional name HitBoxName)
{
	if (!bFriendlyFireListen)
		Super.TakeDamage( Damage, instigatedBy, hitlocation, momentum, damageType, HitBoxName );
}

defaultproperties
{
	GroundSpeed=310.000000
	WaterSpeed=220.000000
	AirSpeed=440.000000
	WalkingPct=0.250000
	SprintPct=2.000000
	bCanCrouch=True
	JumpZ=340.000000
	RotationRate=(Pitch=3072)
	BaseEyeHeight=30.000000
	EyeHeight=30.000000
	bPhysicsAnimUpdate=True
	bActorShadows=True
	bNetNotify=True
	bReadyForNewIdleAnim=True

	bDoTorsoTwist=True
	bDoHeadTurn=True
	RotateFeetWhileStanding=False
	bPlayingFace=False
	bPlayingViseme=False
	bPlayingBlink=False
	EyesTurnRate=0.003
	HeadTurnRate=0.006
	TorsoTurnRate=0.015
	LookAtAlphaFadeRate=4.0

	IdleFaceAnim="emotion_NULL"
	BlinkAnim="emotion_blink"

	RootBone="Bip01 Spine"
	HeadBone="Bip01 Head"
	SpineBone1="Bip01 Spine1"
	SpineBone2="bip01 Spine2"
	LeftEye="l_eye"
	RightEye="r_eye"

	HeadMinPitch=-8000
	HeadMaxPitch=8000
	HeadMinYaw=-9000
	HeadMaxYaw=9000

	VisemeScaleTopLip=1.0
	VisemeScaleJaw=1.0

	EyeMaxDeltaInside=2000
	EyeMaxDeltaOutside=4000
	EyeMaxDeltaUp=1000
	EyeMaxDeltaDown=900
	LeftEyeYawOffset=-50
	LeftEyePitchOffset=0
	RightEyeYawOffset=0
	RightEyePitchOffset=0

	bPawnBlinks=false
	PawnBlinkDelayBase=4.0
	PawnBlinkDelayDelta=2.0
	PawnDoubleBlinkCount=0

	bUsesHoldRifleAnim=true

	LOG_DEBUG=false

	LookAtDeltaRotation=(Pitch=0,Yaw=0,Roll=0)
	bFlipPitchAndRoll=true

	ScriptedViewBoneName="c_eyebrow"
	ScriptedViewOffset=(X=0,Y=0,Z=32.0)
	m_flLastDisplayPawnInfo=-1.0
	m_flLastDisplayPawnNoShoot=-1.0f

	CollisionHeight=84.0
	CollisionRadius=28.0

	m_eCharacterType=CharacterSetup.EUSCharacterTypes.USCharNone
	bLookDirNotReset = false;
}
//=============================================================================
// AntiPortalActor.
//=============================================================================

class AntiPortalActor extends Actor
	native
	placeable;



//
//	TriggerControl
//

state() TriggerControl
{
	// Trigger

	event Trigger(Actor Other,Pawn EventInstigator)
	{
		SetDrawType(DT_None);
	}

	// UnTrigger

	event UnTrigger(Actor Other,Pawn EventInstigator)
	{
		SetDrawType(DT_AntiPortal);
	}
}

//
//	TriggerToggle
//

state() TriggerToggle
{
	// Trigger

	event Trigger(Actor Other,Pawn EventInstigator)
	{
		if(DrawType == DT_AntiPortal)
			SetDrawType(DT_None);
		else if(DrawType == DT_None)
			SetDrawType(DT_AntiPortal);
	}
}

//
//	Default properties
//

defaultproperties
{
	bNoDelete=true
	RemoteRole=ROLE_None
	DrawType=DT_AntiPortal
	bEdShouldSnap=True
	bCollideActors=False
	bBlockActors=False
	bBlockPlayers=False
}
class Armor extends Powerups
	abstract;



var() class<DamageType>		  ProtectionType;	  // Protects against DamageType (None if non-armor).
var() int		  ArmorAbsorption;	  // Percent of damage item absorbs 0-100.
var() int		  AbsorptionPriority; // Which items absorb damage first (higher=first).
var   armor		  NextArmor;		  // Temporary list created by Armors to prioritize damage absorption.

//
// Absorb damage.
//
function int ArmorAbsorbDamage(int Damage, class<DamageType> DamageType, vector HitLocation)
{
	local int ArmorDamage;

	if ( DamageType.default.bArmorStops )
		ArmorImpactEffect(HitLocation);
	if( (DamageType!=None) && (ProtectionType==DamageType) )
		return 0;

	if ( !DamageType.default.bArmorStops ) Return Damage;

	ArmorDamage = (Damage * ArmorAbsorption) / 100;
	if( ArmorDamage >= Charge )
	{
		ArmorDamage = Charge;
		Destroy();
	}
	else
		Charge -= ArmorDamage;
	return (Damage - ArmorDamage);
}

//
// Return armor value.
//
function int ArmorPriority(class<DamageType> DamageType)
{
	if ( DamageType.default.bArmorStops )
		return 0;
	if( (DamageType!=None) && (ProtectionType==DamageType) )
		return 1000000;

	return AbsorptionPriority;
}

//
// This function is called by ArmorAbsorbDamage and displays a visual effect
// for an impact on an armor.
//
function ArmorImpactEffect(vector HitLocation);

state Activated
{
	function BeginState()
	{
		Super.BeginState();
		if ( ProtectionType != None )
			Pawn(Owner).ReducedDamageType = ProtectionType;
	}

	function EndState()
	{
		Super.EndState();
		if ( (Pawn(Owner) != None) && (ProtectionType != Pawn(Owner).ReducedDamageType) )
			Pawn(Owner).ReducedDamageType = None;
	}
}

//
// Return the best armor to use.
//
function armor PrioritizeArmor( int Damage, class<DamageType> DamageType, vector HitLocation )
{
	local Armor FirstArmor, InsertAfter;

	if ( Inventory != None )
		FirstArmor = Inventory.PrioritizeArmor(Damage, DamageType, HitLocation);
	else
		FirstArmor = None;

	if ( FirstArmor == None )
	{
		nextArmor = None;
		return self;
	}

	// insert this armor into the prioritized armor list
	if ( FirstArmor.ArmorPriority(DamageType) < ArmorPriority(DamageType) )
	{
		nextArmor = FirstArmor;
		return self;
	}
	InsertAfter = FirstArmor;
	while ( (InsertAfter.nextArmor != None)
		&& (InsertAfter.nextArmor.ArmorPriority(DamageType) > ArmorPriority(DamageType)) )
		InsertAfter = InsertAfter.nextArmor;

	nextArmor = InsertAfter.nextArmor;
	InsertAfter.nextArmor = self;

	return FirstArmor;
}

defaultproperties
{
}
class ArmorPickup extends Pickup
	abstract;



function float BotDesireability( Pawn Bot )
{
	local Inventory AlreadyHas;
	local Armor AlreadyHasArmor;
	local float desire;
	local bool bChecked;

	desire = MaxDesireability;

	if ( RespawnTime < 10 )
	{
		bChecked = true;
		AlreadyHas = Bot.FindInventoryType(InventoryType);
		if ( AlreadyHas != None )
		{
			if ( Inventory != None )
			{
				if( Inventory.Charge <= AlreadyHas.Charge )
					return -1;
			}
			else if ( InventoryType.Default.Charge <= AlreadyHas.Charge )
				return -1;
		}
	}

	if ( !bChecked )
		AlreadyHasArmor = Armor(Bot.FindInventoryType(InventoryType));
	if ( AlreadyHasArmor != None )
		desire *= (1 - AlreadyHasArmor.Charge * AlreadyHasArmor.ArmorAbsorption * 0.00003);

	if ( Armor(Inventory) != None )
	{
		// pointing to specific, existing item
		desire *= (Inventory.Charge * 0.005);
		desire *= (Armor(Inventory).ArmorAbsorption * 0.01);
	}
	else
	{
		desire *= (InventoryType.default.Charge * 0.005);
		desire *= (class<Armor>(InventoryType).default.ArmorAbsorption * 0.01);
	}
	return desire;
}
class AttachedPart extends Actor;


simulated event Destroyed()
{
	SetOwner( None );
	Super.Destroyed();
}

defaultproperties
{
	bStatic=False
	DrawType=DT_Mesh
	SoundOcclusion=OCCLUSION_None
	
	RemoteRole=Role_NONE
}
/*=============================================================================
// AutoDoor - automatically placed Door
============================================================================= */

class AutoDoor extends Door
	notplaceable
	native;



defaultproperties
{
	bCollideWhenPlacing=false
}
/*=============================================================================
// AutoLadder - automatically placed at top and bottom of LadderVolume
============================================================================= */

class AutoLadder extends Ladder
	notplaceable
	native;



cpptext
{
	virtual UBOOL IsIdentifiedAs(FName ActorName);
}

defaultproperties
{
	bCollideWhenPlacing=false
}
//=============================================================================
// AvoidMarker.
// Creatures will tend to back away when near this spot
//=============================================================================
class AvoidMarker extends Triggers
	native
	notPlaceable;



function Touch( actor Other )
{
	if ( (Pawn(Other) != None) && (Pawn(Other).Controller != None) )
		Pawn(Other).Controller.FearThisSpot(self);
}

function StartleBots()
{
	local Pawn P;

	ForEach CollidingActors(class'Pawn', P, CollisionRadius)
	{
		if ( AIController(P.Controller) != None )
			AIController(P.Controller).Startle(self);
	}
}

defaultproperties
{
	bStatic=false
	CollisionRadius=+100.000
	RemoteRole=ROLE_None
}
// ====================================================================
//  Class:  Engine.BaseGUIController
//
//  This is just a stub class that should be subclassed to support menus.
//
//  Written by Joe Wilcox
//  (c) 2002, Epic Games, Inc.  All Rights Reserved
// ====================================================================

class BaseGUIController extends Interaction
		Native;



#exec TEXTURE IMPORT NAME=MenuWhite FILE=Textures\White.tga     MIPS=OFF COMPRESS=DXT1
#exec TEXTURE IMPORT NAME=MenuBlack FILE=Textures\Black.tga     MIPS=OFF COMPRESS=DXT1
#exec TEXTURE IMPORT NAME=MenuGray  FILE=Textures\Gray.tga      MIPS=OFF COMPRESS=DXT1

cpptext
{
		virtual void InitializeController();
}


var	Material	DefaultPens[3]; 	// Contain to hold some default pens for drawing purposes

// Delegates
Delegate OnAdminReply(string Reply);	// Called By PlayerController

// ================================================
// OpenMenu - Opens a new menu and places it on top of the stack


event bool OpenMenu(string NewMenuName, optional string Param1, optional string Param2, optional bool bAvoidDuplicates)
{
	return false;
}

// ================================================
// Create a bunch of menus at start up

event AutoLoadMenus();	// Subclass me

// ================================================
// Replaces a menu in the stack.  returns true if success

event bool ReplaceMenu(string NewMenuName, optional string Param1, optional string Param2, optional bool bAvoidDuplicates)
{
	return false;
}

event bool CloseMenu(optional bool bCanceled)	// Close the top menu.  returns true if success.
{
	return true;
}
event CloseAll(bool bCancel, optional bool bLeaveTopMost);

event bool MenuIsOpen(string MenuClassName)
{
	return false;
}

simulated function PreloadMenu(string Menu);

function SetControllerStatus(bool On)
{
	bActive = On;
	bVisible = On;
	bRequiresTick=On;

	// Add code to pause/unpause/hide/etc the game here.

}

event InitializeController();	// Should be subclassed.

event bool NeedsMenuResolution(); // Big Hack that should be subclassed
event SetRequiredGameResolution(string GameRes);

function ChatMessageReceived(PlayerReplicationInfo ChattingPRI, string Message);

defaultproperties
{
	bNativeEvents=True
	bActive=False
	bRequiresTick=False
	bVisible=False
	DefaultPens(0)=MenuWhite
	DefaultPens(1)=MenuBlack
	DefaultPens(2)=MenuGray
}

//=============================================================================
// BeamEmitter: An Unreal Beam Particle Emitter.
//=============================================================================
class BeamEmitter extends ParticleEmitter
	native;




enum EBeamEndPointType
{
	PTEP_Velocity,
	PTEP_Distance,
	PTEP_Offset,
	PTEP_Actor,
	PTEP_TraceOffset,
	PTEP_OffsetAsAbsolute
};

struct ParticleBeamData
{
	var vector	Location;
	var float	t;
};

struct ParticleBeamEndPoint
{
	var () name			ActorTag;
	var () rangevector	Offset;
	var () float		Weight;
};

struct ParticleBeamScale
{
	var () vector		FrequencyScale;
	var () float		RelativeLength;
};

var (Beam)			range						BeamDistanceRange;
var (Beam)			array<ParticleBeamEndPoint>	BeamEndPoints;
var (Beam)			EBeamEndPointType			DetermineEndPointBy;
var (Beam)			float						BeamTextureUScale;
var (Beam)			float						BeamTextureVScale;
var (Beam)			int							RotatingSheets;
var (Beam)			bool						TriggerEndpoint;

var (BeamNoise)		rangevector					LowFrequencyNoiseRange;
var (BeamNoise)		int							LowFrequencyPoints;
var (BeamNoise)		rangevector					HighFrequencyNoiseRange;
var (BeamNoise)		int							HighFrequencyPoints;
var (BeamNoise)		array<ParticleBeamScale>	LFScaleFactors;
var (BeamNoise)		array<ParticleBeamScale>	HFScaleFactors;
var (BeamNoise)		float						LFScaleRepeats;
var (BeamNoise)		float						HFScaleRepeats;
var (BeamNoise)		bool						UseHighFrequencyScale;
var (BeamNoise)		bool						UseLowFrequencyScale;
var (BeamNoise)		bool						NoiseDeterminesEndPoint;
var (BeamNoise)		rangevector					DynamicHFNoiseRange;
var (BeamNoise)		range						DynamicHFNoisePointsRange;
var (BeamNoise)		range						DynamicTimeBetweenNoiseRange;

var (BeamBranching) bool						UseBranching;
var (BeamBranching)	range						BranchProbability;
var	(BeamBranching) range						BranchHFPointsRange;
var (BeamBranching)	int							BranchEmitter;
var (BeamBranching) range						BranchSpawnAmountRange;
var (BeamBranching) bool						LinkupLifetime;

var	transient		int							SheetsUsed;
var transient		int							VerticesPerParticle;
var transient		int							IndicesPerParticle;
var transient		int							PrimitivesPerParticle;
var transient		float						BeamValueSum;
var transient		array<ParticleBeamData>		HFPoints;
var transient		array<vector>				LFPoints;
var transient		array<actor>				HitActors;
var transient		float						TimeSinceLastDynamicNoise;

defaultproperties
{
	HighFrequencyPoints=10
	LowFrequencyPoints=3
	BeamTextureUScale=1
	BeamTextureVScale=1
	BranchEmitter=-1
	BranchHFPointsRange=(Min=0,Max=1000)
}
class Bitmap extends Object;



// Deprecated

class BitmapMaterial extends RenderedMaterial
	abstract
	native
	noexport;



var(Texture) const editconst enum ETextureFormat
{
	TEXF_P8,
	TEXF_RGBA7,
	TEXF_RGB16,
	TEXF_DXT1,
	TEXF_RGB8,
	TEXF_RGBA8,
	TEXF_NODATA,
	TEXF_DXT3,
	TEXF_DXT5,
	TEXF_L8,							// || GEARBOX/ZONER:modify: adding support for A8/L8/AL8 formats
	TEXF_G16,
	TEXF_RRRGGGBBB,
	TEXF_A8,						   	// || GEARBOX/ZONER:modify: adding support for A8/L8/AL8 formats
	TEXF_AL8,						   	// || GEARBOX/ZONER:modify: adding support for A8/L8/AL8 formats
	TEXF_DXT1A,						   	// || GEARBOX/ZONER:modify: adding DXT1A so we can tell when DXT textures have alpha mask (most of the time)
} Format;

var(Texture) enum ETexClampMode
{
	TC_Wrap,
	TC_Clamp,
} UClampMode, VClampMode;

var(Texture) enum ETexFilterMode
{
    TF_Default,         // Whatever the d3ddrv code used to do (linear or anisotropic depending on ini settings)
	TF_None,
	TF_Point,
    TF_Linear,
    TF_Anisotropic,
} MinFilterMode, MagFilterMode, MipFilterMode;

var const byte  UBits, VBits;
var const int   USize, VSize;
var(Texture) const int UClamp, VClamp;
var(Texture) float MipMapLodBias;
var(Texture) byte XBOX_UseNumMips;
var(Texture) byte LowDetailMipNum;
var(Surface) bool bAlphaKill;
var(Texture) bool bUseMipMapLodBias;
var	bool bNoFlushMipMaps;				// If set, UnloadAllMips will do nothing for this texture
//=============================================================================
// BlockingVolume:  a bounding volume
// used to block certain classes of actors
// primary use is to provide collision for non-zero extent traces around static meshes

//=============================================================================

class BlockingVolume extends Volume
	native;

defaultproperties
{
	 bBlockZeroExtentTraces=false
	 bWorldGeometry=true
     bCollideActors=True
     bBlockActors=True
     bBlockPlayers=True
     bBlockKarma=True
}
class BlockingVolumeTeamSpecific extends BlockingVolume;

defaultproperties
{
	bStatic=false
	bWorldGeometry=false
	bBlockPlayers=false
	bBlockKarma=false
	bPathColliding=false
	bBlockActors=false

	bNoDelete=true
	RemoteRole=Role_NONE
}
class BlockingVolumeTeamSpecificToggleable extends BlockingVolume;

function Trigger( Actor Other, Pawn EventInstigator )
{
	//Log( " BlockingVolumeTeamSpecificToggleable::Trigger() bCollideActors="$bCollideActors$" bBlockActors="$bBlockActors$" bBlockPlayers="$bBlockPlayers );
	
	// Toggle between blocking and not blocking.
	SetCollision( bCollideActors, !bBlockActors, !bBlockPlayers );
    //KSetBlockKarma( !bBlockKarma );
}

defaultproperties
{
	bStatic=false
	bWorldGeometry=false
	bBlockPlayers=false
	bBlockKarma=false
	bPathColliding=false
	bBlockActors=false

	bCollideActors=true

	bNoDelete=true
	
	bSkipActorPropertyReplication=false
	RemoteRole=ROLE_AutonomousProxy
}// PSV: 7/19/2005	New intermediatory class for gbxBloodEffect class.  This was needed because we need to replicate
//					the hit direction vector to be used for blood decals and gbxBloodEffect can't be referenced from within Engine.

class BloodEffectEmitter extends Emitter;

var Class<Actor>    BloodDecalClass;

var float HitX;
var float HitY;
var float HitZ;

replication 
{
	reliable if (bNetInitial && Role==ROLE_Authority)
		HitX, HitY, HitZ;
}

defaultproperties
{
   	HitX = 0.0
	HitY = 0.0
	HitZ = 0.0
	
	bDeleteSimple=true
	AutoDestroy=True
	
    RemoteRole=ROLE_SimulatedProxy
	bNetTemporary=true
	bGameRelevant=true

	bNoDelete=false
	bCollideWorld=false
	bCollideWhenPlacing=false
}
//=============================================================================
// BroadcastHandler
//
// Message broadcasting is delegated to BroadCastHandler by the GameInfo.
// The BroadCastHandler handles both text messages (typed by a player) and
// localized messages (which are identified by a LocalMessage class and id).
// GameInfos produce localized messages using their DeathMessageClass and
// GameMessageClass classes.
//
// This is a built-in Unreal class and it shouldn't be modified.
//=============================================================================
class BroadcastHandler extends Info;



var	int			    SentText;
var config bool		bMuteSpectators;			// Whether spectators are allowed to speak.
var config bool		bPartitionSpectators;			// Whether spectators are can only speak to spectators.

function UpdateSentText()
{
	SentText = 0;
}

/* Whether actor is allowed to broadcast messages now.
*/
function bool AllowsBroadcast( actor broadcaster, int Len )
{
	if ( bMuteSpectators && (PlayerController(Broadcaster) != None)
		&& !PlayerController(Broadcaster).PlayerReplicationInfo.bAdmin
		&& (PlayerController(Broadcaster).PlayerReplicationInfo.bOnlySpectator
			|| PlayerController(Broadcaster).PlayerReplicationInfo.bOutOfLives)  )
		return false;

	SentText += Len;
	return ( (Level.IsPaused()) || (SentText < 400) );
}


function BroadcastText( PlayerReplicationInfo SenderPRI, PlayerController Receiver, coerce string Msg, optional name Type )
{
	Receiver.TeamMessage( SenderPRI, Msg, Type );
}

function BroadcastLocalized( Actor Sender, PlayerController Receiver, class<LocalMessage> Message, optional int Switch, optional PlayerReplicationInfo RelatedPRI_1, optional PlayerReplicationInfo RelatedPRI_2, optional Object OptionalObject )
{
	Receiver.ReceiveLocalizedMessage( Message, Switch, RelatedPRI_1, RelatedPRI_2, OptionalObject );
}

function BroadcastObjective( Actor Sender, PlayerController Receiver, class<Info> Objective, Name szObjectiveTag, EObjectiveComplete nStatus, int nObjectiveIdx, bool bDisplayMessage, float flLifeTime, optional PlayerReplicationInfo RelatedPRI_1, optional PlayerReplicationInfo	RelatedPRI_2 )
{
	Receiver.ReceiveObjectiveUpdate( Objective, szObjectiveTag, nStatus, nObjectiveIdx, bDisplayMessage, flLifeTime, RelatedPRI_1, RelatedPRI_2 );
}

function Broadcast( Actor Sender, coerce string Msg, optional name Type )
{
	local Controller C;
	local PlayerController P;
	local PlayerReplicationInfo PRI;

	// see if allowed (limit to prevent spamming)
	if ( !AllowsBroadcast(Sender, Len(Msg)) )
		return;

	if ( Pawn(Sender) != None )
		PRI = Pawn(Sender).PlayerReplicationInfo;
	else if ( Controller(Sender) != None )
		PRI = Controller(Sender).PlayerReplicationInfo;

	if ( bPartitionSpectators && (PRI != None) && (PRI.bOnlySpectator || PRI.bOutOfLives) )
	{
		For ( C=Level.ControllerList; C!=None; C=C.NextController )
		{
			P = PlayerController(C);
			if ( (P != None) && (P.PlayerReplicationInfo.bOnlySpectator || P.PlayerReplicationInfo.bOutOfLives) )
				BroadcastText(PRI, P, Msg, Type);
		}
	}
	else
	{
		For ( C=Level.ControllerList; C!=None; C=C.NextController )
		{
			P = PlayerController(C);
			if ( P != None )
			BroadcastText(PRI, P, Msg, Type);
		}
	}
}

function BroadcastTeam( Controller Sender, coerce string Msg, optional name Type )
{
	local Controller C;
	local PlayerController P;

	// see if allowed (limit to prevent spamming)
	if ( !AllowsBroadcast(Sender, Len(Msg)) )
		return;

	if ( bPartitionSpectators && (Sender != None) && (Sender.PlayerReplicationInfo.bOnlySpectator || Sender.PlayerReplicationInfo.bOutOfLives) )
	{
		For ( C=Level.ControllerList; C!=None; C=C.NextController )
		{
			P = PlayerController(C);
			if ( (P != None) && (P.PlayerReplicationInfo.Team == Sender.PlayerReplicationInfo.Team)
				&& (P.PlayerReplicationInfo.bOnlySpectator || P.PlayerReplicationInfo.bOutOfLives) )
				BroadcastText(Sender.PlayerReplicationInfo, P, Msg, Type);
		}
	}
	else
	{
		For ( C=Level.ControllerList; C!=None; C=C.NextController )
		{
			P = PlayerController(C);
			if ( (P != None) && (P.PlayerReplicationInfo.Team == Sender.PlayerReplicationInfo.Team) )
				BroadcastText(Sender.PlayerReplicationInfo, P, Msg, Type);
		}
	}
}

/*
 Broadcast a localized message to all players.
 Most messages deal with 0 to 2 related PRIs.
 The LocalMessage class defines how the PRI's and optional actor are used.
*/
event AllowBroadcastLocalized( actor Sender, class<LocalMessage> Message, optional int Switch, optional PlayerReplicationInfo RelatedPRI_1, optional PlayerReplicationInfo RelatedPRI_2, optional Object OptionalObject )
{
	local Controller C;
	local PlayerController P;

	For ( C=Level.ControllerList; C!=None; C=C.NextController )
	{
		P = PlayerController(C);
		if ( P != None )
		BroadcastLocalized(Sender, P, Message, Switch, RelatedPRI_1, RelatedPRI_2, OptionalObject);
	}
}

/*
 Broadcast a localized objective update to all players.
 Most messages deal with 0 to 2 related PRIs.
 The LocalMessage class defines how the PRI's and optional actor are used.
*/
event AllowBroadcastObjective( actor Sender, class<Info> Objective, Name szObjectiveTag, EObjectiveComplete nStatus, int nObjectiveIdx, bool bDisplayMessage, float flLifeTime, optional PlayerReplicationInfo RelatedPRI_1, optional PlayerReplicationInfo	RelatedPRI_2 )
{
	local Controller C;
	local PlayerController P;

	For ( C=Level.ControllerList; C!=None; C=C.NextController )
	{
		P = PlayerController(C);
		if ( P != None )
		BroadcastObjective(Sender, P, Objective, szObjectiveTag, nStatus, nObjectiveIdx, bDisplayMessage, flLifeTime, RelatedPRI_1, RelatedPRI_2);
	}
}

defaultproperties
{
}
//=============================================================================
// The brush class.
// This is a built-in Unreal class and it shouldn't be modified.
//=============================================================================
class Brush extends Actor
	native;



//-----------------------------------------------------------------------------
// Variables.

// CSG operation performed in editor.
var() enum ECsgOper
{
	CSG_Active,			// Active brush.
	CSG_Add,			// Add to world.
	CSG_Subtract,		// Subtract from world.
	CSG_Intersect,		// Form from intersection with world.
	CSG_Deintersect,	// Form from negative intersection with world.
} CsgOper;

// Outdated.
var const object UnusedLightMesh;
var vector  PostPivot;

// Scaling.
// Outdated : these are only here to allow the "ucc mapconvert" commandlet to work.
//            They are NOT used by the engine/editor for anything else.
var scale MainScale;
var scale PostScale;
var scale TempScale;

// Information.
var() color BrushColor;
var() int	PolyFlags;
var() bool  bColored;

defaultproperties
{
     MainScale=(Scale=(X=1,Y=1,Z=1),SheerRate=0,SheerAxis=SHEER_None)
     PostScale=(Scale=(X=1,Y=1,Z=1),SheerRate=0,SheerAxis=SHEER_None)
     TempScale=(Scale=(X=1,Y=1,Z=1),SheerRate=0,SheerAxis=SHEER_None)
     bStatic=True
	 bHidden=True
     bNoDelete=True
     bEdShouldSnap=True
     DrawType=DT_Brush
     bFixedRotationDir=True
}
class CamBlur extends CameraEffect
	native
	editinlinenew
	collapsecategories;


var transient const editconst BuiltInRenderTargetPtr RenderTargetA;
var transient const editconst BuiltInRenderTargetPtr RenderTargetB;
var color	BlurColor;      // Alpha is used as a percentage of color vs the scene
var float   BlurOffset;     // delta in percentage of screen (0.0 - 1.0)
var float   BlurDownsample; // what percentage of original screen to use for a downsampled version
var float   BlurAmount;     // What percentage of blurred frame should be blended in with the original

var float			TargetBlurOffset;
var float			BlurOffsetRate;
var float			TargetBlurAmount;
var float			BlurAmountRate;
var color			TargetBlurColor;
var float			CurBlurAlpha;
var float			BlurAlphaRate;
var float			BlurStartTime;
var float			BlurTime;



simulated function bool UpdateCameraEffect(float DeltaTime)
{
    local bool rval;
    local float Pct;
    
	if (Level.TimeSeconds < (BlurStartTime + BlurTime))
	{
		if (BlurOffsetRate != 0.0f)
		{
			Pct = DeltaTime * BlurOffsetRate;
			BlurOffset = BlurOffset + Pct;
		}
		if (BlurAmountRate != 0.0f)
		{
			Pct = DeltaTime * BlurAmountRate;
			BlurAmount = BlurAmount + Pct;
		}
		if (BlurAlphaRate != 0.0f)
		{
			Pct = DeltaTime * BlurAlphaRate;
			CurBlurAlpha = CurBlurAlpha + Pct;
			BlurColor.A = CurBlurAlpha;
		}
	}
	else
	{
		BlurOffset = TargetBlurOffset;
		BlurAmount = TargetBlurAmount;
		BlurColor.A = TargetBlurColor.A;
		
		if ((BlurOffset == 0.0) && (BlurAmount == 0.0))
		{
		    rval = true;
		}
	}
	
	return rval;
}	


defaultproperties
{
	BlurColor=(R=255,G=255,B=255,A=64) // Interpolate the rgb color vs the blurred frame buffer (0 = texture, 255 = color)
	BlurOffset=0.01
	BlurDownsample=1.0
	BlurAmount=0.75
}
class CamDesaturation extends CameraEffect
	native
	editinlinenew
	collapsecategories;


var transient const editconst BuiltInRenderTargetPtr RenderTargetA;
var color	        GlobalColor;

var float			SaturationStartTime;
var float			DesaturationRate;
var byte			MaxDesaturation;
var bool			bDesaturate;
var bool			bDesaturateUpdate;


simulated function bool UpdateCameraEffect(float DeltaTime)
{
    local bool rval;
    local float Pct;
    
	Pct = (Level.UniversalTimeSeconds - SaturationStartTime) * DesaturationRate;

	if (bDesaturateUpdate)
	{
		if( Pct < 1.0f )
		{
			GlobalColor.A = Lerp( Pct, GlobalColor.A, MaxDesaturation );
		}
	}
	else if (bDesaturate)
	{
		if( Pct < 1.0f )
		{
			GlobalColor.A = Lerp( Pct, 0, MaxDesaturation );
		}
	}
	else
	{
		if( Pct < 1.0f )
		{
			GlobalColor.A = Lerp( Pct, MaxDesaturation, 0 );
		}
		else
		{
			bDesaturateUpdate = false;
			rval = true;
		}
	}
	return rval;
}


defaultproperties
{
	MaxDesaturation = 150
	DesaturationRate = 2.0

	GlobalColor=(R=127,G=127,B=127,A=0) // GBX Color 127 = 1x, 255 = 2x, Alpha is monocrhome: 0 = full color, 255 = black & white
}
//=============================================================================
// A camera, used in UnrealEd.
//=============================================================================
class Camera extends PlayerController
	native;



defaultproperties
{
     Location=(X=-500.000000,Y=-300.000000,Z=300.000000)
     Texture=Texture'Engine.S_Camera'
     CollisionRadius=+00016.000000
     CollisionHeight=+00039.000000
     LightBrightness=100
     LightRadius=16
	 bDirectional=1
}

class CameraEffect extends Object
	abstract
	native
	noteditinlinenew;
	
struct BuiltInRenderTargetPtr
{
    var int RenderTarget;
};

var LevelInfo        Level;
var float	         Alpha;			// Used to transition camera effects. 0 = no effect, 1 = full effect
var bool             bShouldRenderBlooms;

simulated function bool UpdateCameraEffect(float DeltaTime)
{
    return false;   // return true if the effect is 'done'
}

//
//	Default properties
//

defaultproperties
{
	Alpha=1.0
	bShouldRenderBlooms=true
}
class CameraEffectManager extends Object
	native
	noteditinlinenew;

var transient   CameraEffect	            CurrentCameraEffect;        // Primarily needed by c++ code

var	transient	CamRenderTarget		        CamRenderTargetEffect;
var	transient	CamMotionBlur			    CamMotionBlurEffect;
var	transient	CamDesaturation		        CamDesaturationEffect;
var	transient	CamOldMovie					CamOldMovie;
var	transient	CamHighDynamicRange         CamHighDynamicRangeEffect;
var transient   CamBlur                     CamBlurEffect;
var transient   CamSituationalAwareness     CamSituationalAwarenessEffect;
var transient   CamOverlay                  CamOverlayEffect;
var transient   CameraEffect                CustomCameraEffect;

var CameraMode  CurrentCameraMode;
var CameraMode  DefaultCameraMode;

//
//	Default properties
//

simulated event SetCustomCameraEffect(CameraEffect InCustomCameraEffect)
{
    CustomCameraEffect = InCustomCameraEffect;
    if (InCustomCameraEffect != None)
    {
        CurrentCameraEffect = InCustomCameraEffect;
        CurrentCameraMode = CAM_OverlayCustom;
    }
}

simulated function SetCameraEffect(CameraMode NewMode, optional bool IsDefault)
{
    switch (NewMode)
    {
    case CAM_None:
        CurrentCameraEffect = CamRenderTargetEffect;
        break;
    case CAM_Default:
        CurrentCameraEffect = CamRenderTargetEffect;
        break;
    case CAM_MotionBlur:
        CurrentCameraEffect = CamMotionBlurEffect;
        break;
    case CAM_Desaturation:
        CurrentCameraEffect = CamDesaturationEffect;
        break;
    case CAM_HighDynamicRange:
        CurrentCameraEffect = CamHighDynamicRangeEffect;
        break;
    case CAM_Blur:
        CurrentCameraEffect = CamBlurEffect;
        break;
    case CAM_SituationalAwareness:
        CurrentCameraEffect = CamSituationalAwarenessEffect;
        break;
    case CAM_Overlay:
        CurrentCameraEffect = CamOverlayEffect;
        break;
    case CAM_OverlayCustom:
        CurrentCameraEffect = CustomCameraEffect;
        break;	
	case CAM_OldMovie:
        CurrentCameraEffect = CamOldMovie;
        break;
    default:
        CurrentCameraEffect = CamRenderTargetEffect;
        break;
    }
    
    // log("!!! CameraEffectManager::SetCameraEffect("$NewMode$","$IsDefault$")", 'SDC');
    // log("!!! CurrentCameraEffect.Name="$CurrentCameraEffect.Name, 'SDC');
    
    CurrentCameraMode = NewMode;

    if (IsDefault)
    {
        DefaultCameraMode = NewMode;
    }
}

simulated event RestoreDefaultEffect()
{
    SetCameraEffect(DefaultCameraMode);
}

simulated function bool UpdateCameraEffect( float DeltaTime )
{
    local bool rval;

    if (CurrentCameraEffect != None)
    {
        rval = CurrentCameraEffect.UpdateCameraEffect(DeltaTime);
        if (rval)
        {
            SetCameraEffect(DefaultCameraMode);
        }
    }
    
    return rval;
}

simulated function Initialize(LevelInfo Level)
{
    CamMotionBlurEffect             = new(self)class'CamMotionBlur';
    CamDesaturationEffect           = new(self)class'CamDesaturation';
	CamOldMovie			            = new(self)class'CamOldMovie';
    CamHighDynamicRangeEffect       = new(self)class'CamHighDynamicRange';
    CamBlurEffect                   = new(self)class'CamBlur';
    CamSituationalAwarenessEffect   = new(self)class'CamSituationalAwareness';
    CamRenderTargetEffect           = new(self)class'CamRenderTarget';
    CamOverlayEffect                = new(self)class'CamOverlay';
    
    CamMotionBlurEffect.Level              = Level;
    CamDesaturationEffect.Level            = Level;
    CamOldMovie.Level					   = Level;
    CamHighDynamicRangeEffect.Level        = Level;
    CamBlurEffect.Level                    = Level;
    CamSituationalAwarenessEffect.Level    = Level;
    CamRenderTargetEffect.Level            = Level;
    CamOverlayEffect.Level                 = Level;
    
    SetCameraEffect(CAM_Default, true);
}

defaultproperties
{
}
class CameraOverlay extends CamOverlay
	native
	editinlinenew
	collapsecategories;
class CamHighDynamicRange extends CameraEffect
	native
	editinlinenew
	collapsecategories;

var transient const editconst BuiltInRenderTargetPtr RenderTargetA;
var transient const editconst BuiltInRenderTargetPtr RenderTargetB;
var Color	EarlyColor;
var Color	LateColor;

var float FilterScale[ 3 ];

simulated function bool UpdateCameraEffect(float DeltaTime)
{
    return false;   // return true if the effect is 'done'
}

defaultproperties
{
	EarlyColor=(R=255,G=255,B=255,A=255) // GBX Color 127 = 1x, 255 = 2x, Alpha is monocrhome: 0 = full color, 255 = black & white
	LateColor=(R=192,G=192,B=255,A=255) // GBX Color 127 = 1x, 255 = 2x, Alpha is monocrhome: 0 = full color, 255 = black & white
	FilterScale(0)=1.15
	FilterScale(1)=1.15
	FilterScale(2)=1.15
}
class CamMotionBlur extends CameraEffect
	native
	editinlinenew
	collapsecategories;


var transient const editconst BuiltInRenderTargetPtr RenderTargetA;
var transient const editconst BuiltInRenderTargetPtr RenderTargetB;
var transient const editconst float	LastFrameTime;
var color		    RenderColor;
var color		    ClearColor;
var color			TargetSrcColor;
var color			TargetDstColor;
var float			RealTimeBuffer;
var float			TimeScale;
var float			FadeRate;
var float			FadeStartTime;
var byte			Blur;
var byte            BlurAlpha;
var bool			bFade;
var bool		    bDoClear;			// If set true, PreRender will clear to Clear color, then set false


simulated function bool UpdateCameraEffect(float DeltaTime)
{
    local bool rval;
	local float RealDeltaTime;
	local float FadePct;
    
	if( RealTimeBuffer == 0 )
		RealTimeBuffer = Level.UniversalTimeSeconds;

	RealDeltaTime = Level.UniversalTimeSeconds - RealTimeBuffer;
	RealTimeBuffer = Level.UniversalTimeSeconds;

	if( bFade )
	{
		FadePct = (Level.UniversalTimeSeconds - FadeStartTime) * FadeRate;

		if( FadePct < 1.0f )
		{
			// reduce blur
			BlurAlpha = Lerp( FadePct, Blur, 255 );

			// interpolate color
			RenderColor = InterpolateColor( FadePct, TargetSrcColor, TargetDstColor );

			// Bring back the saturation
			RenderColor.A = Lerp( FadePct, TargetDstColor.A, 0 );

			// Bring back time
			Level.Game.SetGameSpeed( Lerp( FadePct, TimeScale, 1.0f ) );
		}
		else
		{
			Level.Game.SetGameSpeed( 1.0f );
			bFade = false;
			rval = true;
		}
	}
	return rval;
}


defaultproperties
{
	ClearColor=(R=255,G=255,B=255,A=255) // Clear color of white
	RenderColor=(R=127,G=127,B=127,A=0) // GBX Color 127 = 1x, 255 = 2x, Alpha is monocrhome: 0 = full color, 255 = black & white
	BlurAlpha=64
    FadeRate=0.25
	TimeScale=0.5
	bShouldRenderBlooms=false
}
class CamOldMovie extends CameraEffect
	native
	editinlinenew
	collapsecategories;


var transient const editconst BuiltInRenderTargetPtr RenderTargetA;
var color	        GlobalColor;

simulated function bool UpdateCameraEffect(float DeltaTime)
{
	return false;
}

defaultproperties
{
	GlobalColor=(R=200,G=177,B=182,A=200) // GBX Color 127 = 1x, 255 = 2x, Alpha is monocrhome: 0 = full color, 255 = black & white
}
class CamOverlay extends CameraEffect
	native
	editinlinenew
	collapsecategories;


var() color		OverlayColor;
var() Material	OverlayMaterial;

simulated function bool UpdateCameraEffect(float DeltaTime)
{
    return false;   // return true if the effect is 'done'
}

defaultproperties
{
	OverlayColor=(R=255,G=255,B=255,A=255)
}
class CamRenderTarget extends CameraEffect
	native
	editinlinenew
	collapsecategories;

var transient const editconst BuiltInRenderTargetPtr RenderTargetA;

simulated function bool UpdateCameraEffect(float DeltaTime)
{
    return false;   // return true if the effect is 'done'
}

defaultproperties
{
}
class CamSituationalAwareness extends CameraEffect
	native
	editinlinenew
	collapsecategories;
	
#exec Texture Import File=Textures\SituationalAwareness.tga               MIPS=OFF MASKED=0 ALPHATEXTURE=1 COMPRESS=A8 PRECACHE

var transient const editconst BuiltInRenderTargetPtr RenderTargetA;
var transient const editconst BuiltInRenderTargetPtr RenderTargetB;
var Color	        GlobalColor;
var Texture         Texture;

var float			SaturationStartTime;
var float			DesaturationRate;
var float			OverlayAlphaFloat;
var byte            OverlayAlpha;
var byte			MaxOverlayAlpha;
var byte			MaxDesaturation;
var bool			bDesaturate;


simulated function bool UpdateCameraEffect( float DeltaTime )
{
    local bool rval;
	local float Pct;

	Pct = ( ( Level.UniversalTimeSeconds - SaturationStartTime ) * DesaturationRate ) / MaxDesaturation;

	Pct = FClamp( Pct, 0.0, 1.0 );

	if( bDesaturate )
	{
		GlobalColor.A = Lerp( Pct, 0, MaxDesaturation );
		
		UpdateOverlayAlpha( DeltaTime, true );
	}
	else
	{
		GlobalColor.A = Lerp( Pct, MaxDesaturation, 0 );
		
		UpdateOverlayAlpha( DeltaTime, false );

		if( Pct == 1.0  )
		{
			rval = true;
		}
	}
	
	return rval;
}

simulated function UpdateOverlayAlpha( float DeltaTime, bool bDoDesaturate )
{
	if( bDoDesaturate )
	{
		OverlayAlphaFloat = FCLamp( OverlayAlphaFloat + DesaturationRate * 2.0 * DeltaTime, 0.0, MaxOverlayAlpha );
	}
	else
	{
		OverlayAlphaFloat = FCLamp( OverlayAlphaFloat - DesaturationRate * 2.0 * DeltaTime, 0.0, MaxOverlayAlpha );
	}

	OverlayAlpha = OverlayAlphaFloat;
}


defaultproperties
{
	MaxDesaturation = 192
	DesaturationRate = 250.0

	GlobalColor=(R=127,G=127,B=127,A=0) // GBX Color 127 = 1x, 255 = 2x, Alpha is monocrhome: 0 = full color, 255 = black & white
	OverlayAlphaFloat=200
	OverlayAlpha=200
	MaxOverlayAlpha=200
	
	Texture=Texture'SituationalAwareness'
}
//=============================================================================
// Canvas: A drawing canvas.
// This is a built-in Unreal class and it shouldn't be modified.
//
// Notes.
//   To determine size of a drawable object, set Style to STY_None,
//   remember CurX, draw the thing, then inspect CurX and CurYL.
//=============================================================================
class Canvas extends Object
	native
	noexport;


struct native CanvasIcon
{
	var Material					Icon;
	var int							U,V,UL,VL;
	var Color						DrawColor;
	var float						ScaleX, ScaleY;
	var float						PivotU, PivotV;
};


// Modifiable properties.
var font    Font;            // Font for DrawText.
var float   SpaceX, SpaceY;  // Spacing for after Draw*.
var float   OrgX, OrgY;      // Origin for drawing.
var float   ClipX, ClipY;    // Bottom right clipping region.
var float   CurX, CurY;      // Current position for drawing.
var float   Z;               // Z location. 1=no screenflash, 2=yes screenflash.
var byte    Style;           // Drawing style STY_None means don't draw.
var float   CurYL;           // Largest Y size since DrawText.
var color   DrawColor;       // Color for drawing.
var bool    bCenter;         // Whether to center the text.
var bool    bNoSmooth;       // Don't bilinear filter.
var const int SizeX, SizeY;  // Zero-based actual dimensions.
var const int SafeOffX, SafeOffY;
var const int SafeSizeX, SafeSizeY;

// Stock fonts.
var font TinyFont, SmallFont, MedFont;
var string TinyFontName, SmallFontName, MedFontName;

// Internal.
var const viewport Viewport; // Viewport that owns the canvas.
var const byte     LastStyle;
var const int	   LastMaterial;
var const int      MyFinalBlend;
var const int      nViewportIdx;
var const int      pCanvasUtil;

// native functions.
native(464) final function StrLen( coerce string String, out float XL, out float YL, optional float ScaleX, optional float ScaleY ); // Wrapped!
native(465) final function DrawText( coerce string Text, optional bool CR, optional float ScaleX, optional float ScaleY, optional bool bCheckHotKey );
native(466) final function DrawTile( material Mat, float XL, float YL, float U, float V, float UL, float VL );

// GBX:naj - added 8/26/03 - Allows caller to draw a HUD bitmap positioned over a worldspace location.
native final function DrawTile3D(
	material Mat,
	vector worldSpaceLocation,
	float XL, float YL,
	float U, float V,
	float UL, float VL,
	optional float TexCenterU, optional float TexCenterV );
// GBX:naj - end added 8/26/03

native(467) final function DrawActor( Actor A, optional float DisplayFOV );
native(468) final function DrawTileClipped( Material Mat, float XL, float YL, float U, float V, float UL, float VL );
native(469) final function DrawTextClipped( coerce string Text, optional bool bCheckHotKey, optional float ScaleX, optional float ScaleY );
native(470) final function TextSize( coerce string String, out float XL, out float YL ); // Clipped!
native(480) final function DrawPortal( int X, int Y, int Width, int Height, actor CamActor, vector CamLocation, rotator CamRotation, optional int FOV, optional bool ClearZ );

native final function WrapStringToArray(string Text, out array<string> OutArray, float dx, string EOL);

// jmw - These are two helper functions.  The use the whole texture only.  If you need better support, use DrawTile
native final function DrawTileStretched(material Mat, float XL, float YL);
native final function DrawTileJustified(material Mat, byte Justification, float XL, float YL);
native final function DrawTileScaled(material Mat, float XScale, float YScale);
native final function DrawTextJustified(coerce string String, byte Justification, float x1, float y1, float x2, float y2, optional float ScaleX, optional float ScaleY);
// gbx:pad: Added this for rotating hud art.
native final function DrawTileRotated( material Mat , float XL, float YL, float U, float V, float UL, float VL, float XC, float YC, Rotator R );
native final function DrawTextRotated(  coerce string Text, float XL, float YL, float XC, float YC, Rotator R );

native final function DrawTileStretchedClip(material Mat, float XL, float YL, float U, float V, float UL, float VL);
native final function DrawTileTiledClip(material Mat, float XL, float YL, float U, float V, float UL, float VL, optional float BU, optional float BV, optional float sX, optional float sY, optional bool bHollow);
native final function vector ScreenProject( vector worldSpaceLocation );	// gbx:cek : Factored out screen projection code from DrawTile3D

// draw text bounded within the rect (x1,y1), (x2, y2)
// 0 for x2 or y2 means unbounded on that axis
// justify codes: 0 = left, 1 = center, 2 = right
native final function DrawTextBounded(coerce string String, byte JustX, byte JustY, out float x1, out float y1, out float x2, out float y2, optional float ScaleX, optional float ScaleY, optional bool bTestOnly);

native final function SetDrawColor(byte R, byte G, byte B, optional byte A);
native final function SetPos( float X, float Y );

// LCD Functions
native final function DrawLCDIcon(int ScreenNumber, texture Texture, int ScreenX, int ScreenY);
native final function DrawLCDNumber(int ScreenNumber, int Number, int ScreenX, int ScreenY);
native final function DrawLCDText(int ScreenNumber, coerce string Text, int ScreenX, int ScreenY);
native final function SetLCDFontSize(int FontSize);
native final function ResetLCDFontSize();

// UnrealScript functions.
event Reset()
{
	Font        = Default.Font;
	SpaceX      = Default.SpaceX;
	SpaceY      = Default.SpaceY;
	OrgX        = Default.OrgX;
	OrgY        = Default.OrgY;
	CurX        = Default.CurX;
	CurY        = Default.CurY;
	Style       = Default.Style;
	DrawColor   = Default.DrawColor;
	CurYL       = Default.CurYL;
	bCenter     = false;
	bNoSmooth   = false;
	Z           = 1.0;
}
final function SetOrigin( float X, float Y )
{
	OrgX = X;
	OrgY = Y;
}
final function SetClip( float X, float Y )
{
	ClipX = X;
	ClipY = Y;
}
final function DrawPattern( material Tex, float XL, float YL, float Scale )
{
	DrawTile( Tex, XL, YL, (CurX-OrgX)*Scale, (CurY-OrgY)*Scale, XL*Scale, YL*Scale );
}
final function DrawIcon( texture Tex, float Scale )
{
	if ( Tex != None )
		DrawTile( Tex, Tex.USize*Scale, Tex.VSize*Scale, 0, 0, Tex.USize, Tex.VSize );
}
final function DrawRect( texture Tex, float RectX, float RectY )
{
	DrawTile( Tex, RectX, RectY, 0, 0, Tex.USize, Tex.VSize );
}

static final function Color MakeColor(byte R, byte G, byte B, optional byte A)
{
	local Color C;

	C.R = R;
	C.G = G;
	C.B = B;
	if ( A == 0 )
		A = 255;
	C.A = A;
	return C;
}

// Draw a vertical line
final function DrawVertical(float X, float height)
{
    SetPos( X, CurY);
    DrawRect(Texture'engine.WhiteSquareTexture', 2, height);
}

// Draw a horizontal line
final function DrawHorizontal(float Y, float width)
{
    SetPos(CurX, Y);
    DrawRect(Texture'engine.WhiteSquareTexture', width, 2);
}

// Draw Line is special as it saves it's original position

final function DrawLine(int direction, float size)
{
    local float X, Y;

    // Save current position
    X = CurX;
    Y = CurY;

    switch (direction)
    {
      case 0:
		  SetPos(X, Y - size);
		  DrawRect(Texture'engine.WhiteSquareTexture', 2, size);
		  break;

      case 1:
		  DrawRect(Texture'engine.WhiteSquareTexture', 2, size);
		  break;

      case 2:
		  SetPos(X - size, Y);
		  DrawRect(Texture'engine.WhiteSquareTexture', size, 2);
		  break;

	  case 3:
		  DrawRect(Texture'engine.WhiteSquareTexture', size, 2);
		  break;
    }
    // Restore position
    SetPos(X, Y);
}

final simulated function DrawBracket(float width, float height, float bracket_size)
{
    local float X, Y;
    X = CurX;
    Y = CurY;

	Width  = max(width,5);
	Height = max(height,5);

    DrawLine(3, bracket_size);
    DrawLine(1, bracket_size);
    SetPos(X + width, Y);
    DrawLine(2, bracket_size);
    DrawLine(1, bracket_size);
    SetPos(X + width, Y + height);
    DrawLine(0, bracket_size);
    DrawLine(2, bracket_size);
    SetPos(X, Y + height);
    DrawLine(3, bracket_size);
    DrawLine( 0, bracket_size);

    SetPos(X, Y);
}

final simulated function DrawBox(canvas canvas, float width, float height)
{
	local float X, Y;
	X = canvas.CurX;
	Y = canvas.CurY;
	canvas.DrawRect(Texture'engine.WhiteSquareTexture', 2, height);
	canvas.DrawRect(Texture'engine.WhiteSquareTexture', width, 2);
	canvas.SetPos(X + width, Y);
	canvas.DrawRect(Texture'engine.WhiteSquareTexture', 2, height);
	canvas.SetPos(X, Y + height);
	canvas.DrawRect(Texture'engine.WhiteSquareTexture', width+1, 2);
	canvas.SetPos(X, Y);
}

final simulated function DrawCanvasIcon( out float Xc, out float Yc, float ScaleX, float ScaleY, out CanvasIcon IconFront, optional rotator rotation )
{
	local float W, H;
	if (IconFront.Icon != None)
	{
		W = IconFront.UL * IconFront.ScaleX * ScaleX;
		H = IconFront.VL * IconFront.ScaleY * ScaleY;

		Xc -= (W * IconFront.PivotU);
		Yc -= (H * IconFront.PivotV);

		SetPos(Xc, Yc);
		DrawColor = IconFront.DrawColor;
		if( rotation.Yaw != 0 || rotation.Pitch != 0 || rotation.Roll != 0 )
		{
			DrawTileRotated(IconFront.Icon, W, H, IconFront.U, IconFront.V, IconFront.UL, IconFront.VL,
				Xc + (W * IconFront.PivotU),
				Yc + (H * IconFront.PivotV),
				rotation);
		}
		else
		{
			DrawTile(IconFront.Icon, W, H,
						IconFront.U, IconFront.V, IconFront.UL, IconFront.VL );
		}

		Xc += 0.5*W;
		Yc += 0.5*H;
	}
}

final simulated function DrawCanvasIconComposite( float Xc, float Yc, float ScaleX, float ScaleY, out CanvasIcon IconFront, out CanvasIcon IconBack, optional rotator iconRotation, optional rotator backRotation )
{
	DrawCanvasIcon(Xc, Yc, ScaleX, ScaleY, IconBack,iconRotation);
	DrawCanvasIcon(Xc, Yc, ScaleX, ScaleY, IconFront,backRotation);
}

final simulated static function CanvasIconSize(out Canvas.CanvasIcon icon, out float XL, out float YL, float ScaleX, float ScaleY)
{
	XL = icon.UL * icon.ScaleX * ScaleX;
	YL = icon.VL * icon.ScaleY * ScaleY;
}


final simulated static function CanvasIconSetColor( out CanvasIcon icon, byte R, byte G, byte B, byte A)
{
	icon.DrawColor.R = R;
	icon.DrawColor.G = G;
	icon.DrawColor.B = B;
	icon.DrawColor.A = A;
}


defaultproperties
{
     Style=1
	 Z=1
     DrawColor=(R=127,G=127,B=127,A=255)
	 TinyFontName="Engine.MonoFont"
     SmallFontName="Engine.MonoFont"
     MedFontName="Engine.MonoFont"
	 Font=Font'Engine.DefaultFont'
}
class CarriedObject extends Actor
    native nativereplication abstract notplaceable;



cpptext
{
	INT* GetOptimizedRepList( BYTE* Recent, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel );
}

var bool            bHome;
var bool            bHeld;

var PlayerReplicationInfo HolderPRI;
var Pawn      Holder;

var const ActorLite LastAnchor;		// recent nearest path
var		float	LastValidAnchorTime;	// last time a valid anchor was found

replication
{
    reliable if (Role == ROLE_Authority)
        bHome, bHeld, HolderPRI;
}

function Actor Position()
{
    if (bHeld)
        return Holder;

    return self;
}

defaultproperties
{
    Physics=PHYS_None
	bUseCylinderCollision=true
	bAlwaysZeroBoneOffset=true
     DrawType=DT_Mesh
	 bOrientOnSlope=true
}
class CharacterSetup extends Object
	abstract;

const CHAR_RANK_OFFICER = 34.0f;
const CHAR_RANK_PRIVATE = 34.0f;
const CHAR_RANK_PRIVATEFC = 51.0f;
const CHAR_RANK_CORPORAL = 68.0f;
const CHAR_RANK_SEARGENT = 102.0f;
const CHAR_RANK_MASTERSEARGENT = 118.0f;

// I moved these enums here from InfantryUSA/InfantryGerman/CharacterSpawner as part of a revised means of determining chracters 2004-04-09 JWS
enum EUSCharacterTypes
{
	USCharNone,
	USCharLocke,
	USCharJameson,
	USCharGarnett,
	USCharAllen,
	USCharCorrion,
	USCharLeggett,
	USCharBaker,
	USCharMuzza,
	USCharHartsockCpl,
	USCharCole,
	USCharYork,
	USCharWheaton,
	USCharHooper,
	USCharDoe,
	USCharMcCreary,
	USCharRivas,
	USCharDesola,
	USCharZanovich,
	USCharObrieski,
	USCharCourtland,
	USCharMac,
	USCharCombs,
	USCharRisner,
	USCharTankCommanderRisner,
	USCharTankCommanderA,
	USCharTankCommanderB,
	USCharLewis,
	USCharScott,
	USCharBoyd,
	USCharMarshall,
	USCharDoyle,
	USCharPaddock,
	USCharCassidy,
	USCharFriar,
	USCharCampbell,
	USCharMcConnel,
	USCharPaige,
	USCharMarsh,
	USCharJohnson,
	USCharHersh,
	USCharHartsockSgt,
	USCharTankCommanderC,
	USCharTankCommanderD,
	USCharDoyleSgt,
	USCharHartsockSgtFinger,
};

enum EDECharacterTypes
{
	DECharNone,
	DECharMikey,
	DECharPalmer,
	DECharGunter,
	DECharD,
	DECharE,
	DECharF,
	DECharTankCommander,
};

enum EMPCharacterTypes
{
	MPPlayer1US,
	MPPlayer2US,

	MPCharUSA,
	MPCharUSB,
	MPCharUSC,

	MPPlayer1DE,	// speaking German
	MPPlayer2DE,	// speaking German
	MPPlayer1EG,	// speaking English w/ German Accent
	MPPlayer2EG,	// speaking English w/ German Accent

	MPCharDEA,		// these character types speak german
	MPCharDEB,	
	MPCharDEC,

	MPCharEGA,		// these character types speak english with german accent
	MPCharEGB,	
	MPCharEGC,

	SKHartsock,		// player controlling fire team
	SKBaker,		// player controlling assault team

	SKCharUSA,
	SKCharUSB,
	SKCharUSC,
	SKCharUSD,

	SKHansDE,		// player controlling german fire team - speaking German
	SKFransDE,		// player controlling german assault team - speaking German
	SKHansEG,		// player controlling german fire team - speaking English w/ German Accent
	SKFransEG,		// player controlling german assault team - speaking English w/ German Accent

	SKCharDEA,		// these character types speak german
	SKCharDEB,	
	SKCharDEC,
	SKCharDED,

	SKCharEGA,		// these character types speak english with german accent
	SKCharEGB,	
	SKCharEGC,	
	SKCharEGD
};

simulated static function Name GetCharacterHead(int characterType);

simulated static function String GetCharacterFacialPackage(int characterType);

simulated static function string GetCharacterVoiceType(int characterType,optional bool bIsDemoBuild);

simulated static function float GetCharacterScale(int characterType);

simulated static function float GetCharacterRank(int characterType);

simulated static function string GetCharacterName(int characterType, optional bool bIsTanker);
simulated static function name GetCharacterFName(int characterType);
simulated static function string GetCharacterRankName(int characterType);
simulated static function string GetCharacterPortrait(int characterType, optional bool bIsTanker);

simulated static function string GetTankPortrait(int TankType);
simulated static function string GetTankName(int TankType);class CharacterSetupGermany extends CharacterSetup;

var int portraitCounter;
var int tank_portraitCounter;

simulated static function Name GetCharacterHead(int characterType)
{
	local Name head;

	switch (characterType)
	{
		case EDECharacterTypes.DECharMikey:
			head = 'de_infantry_mikey';
			break;
		case EDECharacterTypes.DECharPalmer:
			head = 'de_infantry_palmer';
			break;
		case EDECharacterTypes.DECharGunter:
			head = 'de_infantry_gunter';
			break;
		case EDECharacterTypes.DECharD:
			head = 'heinrick';
			break;
		case EDECharacterTypes.DECharE:
			head = 'hans';
			break;
		case EDECharacterTypes.DECharF:
			head = 'lars';
			break;
		case EDECharacterTypes.DECharTankCommander:
			head = 'palmer';
			break;
		default:
			head = 'de_infantry_gunter';
			break;
	}
	
	return head;
}

simulated static function String GetCharacterFacialPackage(int characterType)
{
//	local String face;

//	face = "a_ev_german.a_ev_german";

//	return face;
	return "";
}

simulated static function String GetCharacterVoiceType(int characterType, optional bool bIsDemoBuild )
{
//	local int RandVal;

	//log( "CharacterSetupGermany::GetCharacterVoiceType() - bIsDemoBuild=" $ bIsDemoBuild, 'RSC' );
	if( !bIsDemoBuild )
	{
		switch ( characterType )
		{
		case EDECharacterTypes.DECharPalmer:
			return "gbxCharacters.VoiceTypeSPGermanA";
		case EDECharacterTypes.DECharMikey:	
			return "gbxCharacters.VoiceTypeSPGermanB";
		case EDECharacterTypes.DECharGunter:
			return "gbxCharacters.VoiceTypeSPGermanC";
		case EDECharacterTypes.DECharD:
			return "gbxCharacters.VoiceTypeSPGermanD";
		case EDECharacterTypes.DECharE:	
			return "gbxCharacters.VoiceTypeSPGermanE";
		case EDECharacterTypes.DECharF:
			return "gbxCharacters.VoiceTypeSPGermanF";
		default:
			return "gbxCharacters.VoiceTypeSPGermanA";
		//	RandVal = Rand(6);
		//	switch( RandVal )
		//	{
		//	case 0: 
		//		return "gbxCharacters.VoiceTypeSPGermanA";
		//	case 1:
		//		return "gbxCharacters.VoiceTypeSPGermanB";
		//	case 2:
		//		return "gbxCharacters.VoiceTypeSPGermanC";
		//	case 3: 
		//		return "gbxCharacters.VoiceTypeSPGermanD";
		//	case 4:
		//		return "gbxCharacters.VoiceTypeSPGermanE";
		//	case 5:
		//		return "gbxCharacters.VoiceTypeSPGermanF";
		}
	}

	// if this is the demo, only use one voicetype
	return "gbxCharacters.VoiceTypeSPGermanA";
}

simulated static function float GetCharacterScale(int characterType)
{
	local float flScale;

	// GBX:naj - Returning 1.0 for all Germans because we don't use this feature anymore
	// and it causes a bug in APawn::Crouch() and ::UnCrouch() where it uses different
	// HeightAdjust values in either case, causing a slow ratcheting downward of the eyeheight.
	return 1.0f;
	//////////////////////

	flScale = 1.0f;	
	switch (characterType)
	{
		case EDECharacterTypes.DECharMikey:
		case EDECharacterTypes.DECharD:
			flScale = 1.0f;
			break;
		case EDECharacterTypes.DECharPalmer:
		case EDECharacterTypes.DECharE:
			flScale = 1.04f;
			break;
		case EDECharacterTypes.DECharGunter:
		case EDECharacterTypes.DECharF:
			flScale = 1.02f;
			break;
		default:
			flScale = 1.0f;
			break;
	}
	
	return flScale;
}

simulated static function float GetCharacterRank(int characterType)
{
	switch (characterType)
	{
		case EDECharacterTypes.DECharMikey:
			return 0;
		case EDECharacterTypes.DECharPalmer:
			return 0;
		case EDECharacterTypes.DECharGunter:
			return 0;
		case EDECharacterTypes.DECharD:
			return 0;
		case EDECharacterTypes.DECharE:
			return 0;
		case EDECharacterTypes.DECharF:
			return 0;
		default:
			return 0;
	}
	return 0;
}

simulated static function string GetTankPortrait( int TankType )
{
	switch( TankType )
	{
		case ETankType.German_PanzerIV:
			return "t_interface_mb.tank_panzer";
		case ETankType.German_Stug:
			return "t_interface_mb.tank_stug";
		case ETankType.German_StugLongGun:
			return "t_interface_mb.tank_stug";
		case ETankType.German_PanzerIVLongGun:
			return "t_interface_mb.tank_panzer";
	}

	return "Unknown";
}

simulated static function string GetTankName( int tankType )
{
	switch( tankType )
	{
		case ETankType.German_PanzerIV:
			return "PzKpfw IV Ausf F";
		case ETankType.German_Stug:
			return "StuG III Ausf A";
		case ETankType.German_StugLongGun:
			return "StuG III Ausf F";
		case ETankType.German_PanzerIVLongGun:
			return "PzKpfw IV Ausf G";
	}

	return "Unknown";
}

simulated static function string GetCharacterName( int BaseSkillLevel, optional bool bIsTanker )
{
	if( bIsTanker )
	{
		return "Panzertruppen";
	}

	switch (BaseSkillLevel)
	{
		case 0:		//SKILL_Novice:
			return "Osttruppen";
		case 1:		//SKILL_Intermediate:
			return "Infanterie";
		case 2:		//SKILL_Advanced:
			return "Fallschirmjger";
		case 3:		//SKILL_Veteran:
			return "Panzergrenadier";
	}
	
	return "Unknown";
}

simulated static function string GetCharacterPortrait( int BaseSkillLevel, optional bool bIsTanker )
{
	local int iRandom;
	local string portrait;
	
	if( bIsTanker )
	{
		iRandom = default.tank_portraitCounter;

		switch (iRandom)
		{
			case 0:
				portrait = "t_interface_mb.tanker_hans";
				break;
			case 1:
				portrait = "t_interface_mb.tanker_heinrick";
				break;
			case 2:
				portrait = "t_interface_mb.tanker_lars";
				break;
			default:
				portrait = "";
		}

		default.tank_portraitCounter++;

		if( default.tank_portraitCounter > 2 )
		{
			default.tank_portraitCounter = 0;
		}

		return portrait;
	}

	// German currently has three heads
//	iRandom = rand(3) + 1;
	iRandom = default.portraitCounter;
	
	switch (BaseSkillLevel)
	{
		case 0:		//SKILL_Novice:
			portrait = "t_interface_mb.conscript_"$iRandom;
			break;
		case 1:		//SKILL_Intermediate:
			portrait = "t_interface_mb.german_infantry_"$iRandom;
			break;
		case 2:		//SKILL_Advanced:
			portrait = "t_interface_mb.german_para_"$iRandom;
			break;
		case 3:		//SKILL_Veteran:
			portrait = "t_interface_mb.panzer_"$iRandom;
			break;
		default:
			portrait = "";
	}
	
	default.portraitCounter++;

	if( default.portraitCounter > 3 )
	{
		default.portraitCounter = 1;
	}
	
	return portrait;
}

defaultproperties
{
	portraitCounter = 1
}class CharacterSetupUSA extends CharacterSetup;

simulated static function Name GetCharacterHead(int characterType)
{
	//log(self$".GetCharacterHead() - "$m_nCharType);
	switch (characterType)
	{
		case EUSCharacterTypes.USCharAllen:
			return 'allen';
		case EUSCharacterTypes.USCharLocke:
			return 'locke';		// FIXME: Replace this eventually with someone elses head.  For now I don't want to do that since it will mess up the order of things.
		case EUSCharacterTypes.USCharHartsockCpl:
		case EUSCharacterTypes.USCharHartsockSgt:
			return 'hartsock';
		case EUSCharacterTypes.USCharHartsockSgtFinger:
			return 'hartsock_wounded';
		case EUSCharacterTypes.USCharJameson:
			return 'jameson';
		case EUSCharacterTypes.USCharGarnett:
			return 'garnett';
		case EUSCharacterTypes.USCharCorrion:
			return 'corrion';
		case EUSCharacterTypes.USCharLeggett:
			return 'leggett';
		case EUSCharacterTypes.USCharBaker:
			return 'baker';
		case EUSCharacterTypes.USCharMuzza:
			return 'yeats';
		case EUSCharacterTypes.USCharCole:
			return 'cole';
		case EUSCharacterTypes.USCharYork:
			return 'york';
		case EUSCharacterTypes.USCharWheaton:
			return 'wheaton';
		case EUSCharacterTypes.USCharHooper:
			return 'hooper';
		case EUSCharacterTypes.USCharDoe:
			return 'doe';
		case EUSCharacterTypes.USCharMcCreary:
			return 'mccreary';
		case EUSCharacterTypes.USCharRivas:
			return 'rivas';
		case EUSCharacterTypes.USCharDesola:
			return 'desola';
		case EUSCharacterTypes.USCharZanovich:
			return 'zanovich';
		case EUSCharacterTypes.USCharObrieski:
			return 'obrieski';
		case EUSCharacterTypes.USCharCourtland:
			return 'courtland';
		case EUSCharacterTypes.USCharMac:
			return 'mac';
		case EUSCharacterTypes.USCharCombs:
			return 'combs';
		case EUSCharacterTypes.USCharRisner:
			return 'risner';
		case EUSCharacterTypes.USCharTankCommanderRisner:
			return 'risner_helmet';
		case EUSCharacterTypes.USCharTankCommanderA:
			return 'random';
		case EUSCharacterTypes.USCharTankCommanderB:
			return 'random2';
		case EUSCharacterTypes.USCharTankCommanderC:
			return 'random3';
		case EUSCharacterTypes.USCharTankCommanderD:
			return 'random4';
		case EUSCharacterTypes.USCharLewis:
			return 'lewis';
		case EUSCharacterTypes.USCharScott:
			return 'Doe';
		case EUSCharacterTypes.USCharBoyd:
			return 'York';
		case EUSCharacterTypes.USCharDoyle:
		case EUSCharacterTypes.USCharDoyleSgt:
			return 'Doyle';
		case EUSCharacterTypes.USCharPaddock:
			return 'Paddock';
		case EUSCharacterTypes.USCharCassidy:
			return 'Cassidy';
		case EUSCharacterTypes.USCharFriar:
			return 'Friar';
		case EUSCharacterTypes.USCharCampbell:
			return 'Campbell';
		case EUSCharacterTypes.USCharMcConnel:
			return 'McConnel';
		case EUSCharacterTypes.USCharPaige:
			return 'Paige';
		case EUSCharacterTypes.USCharMarsh:
			return 'Marsh';
		case EUSCharacterTypes.USCharJohnson:
			return 'Johnson';
		case EUSCharacterTypes.USCharHersh:
			return 'Hersh';
		case EUSCharacterTypes.USCharMarshall:
			return 'slaMarshall';
	}
	
//	if (Level.NetMode == NM_StandAlone)
//	{
//		return '';
//	}
//	else
//	{
		return 'allen';
//	}
}

simulated static function String GetCharacterFacialPackage(int characterType)
{
	//log(self$".GetCharacterFacialPackage() - "$m_nCharType);
	return "a_ev_all.a_ev_corrion";
}

simulated static function string GetCharacterVoiceType(int characterType,optional bool bIsDemoBuild)
{
	switch (characterType)
	{
		case EUSCharacterTypes.USCharHartsockCpl:
		case EUSCharacterTypes.USCharHartsockSgt:
		case EUSCharacterTypes.USCharHartsockSgtFinger:
			return "gbxCharacters.VoiceTypeHartsock";
		case EUSCharacterTypes.USCharBaker:
			if( bIsDemoBuild )
				return "gbxCharacters.VoiceTypeHartsock";
			else
				return "gbxCharacters.VoiceTypeBaker";
			break;
		case EUSCharacterTypes.USCharAllen:
			return "gbxCharacters.VoiceTypeAllen";
		case EUSCharacterTypes.USCharCampbell:
			return "gbxCharacters.VoiceTypeCampbell";
		case EUSCharacterTypes.USCharCorrion:
			return "gbxCharacters.VoiceTypeCorrion";
		case EUSCharacterTypes.USCharDesola:
			return "gbxCharacters.VoiceTypeDesola";
		case EUSCharacterTypes.USCharDoyle:
		case EUSCharacterTypes.USCharDoyleSgt:
			return "gbxCharacters.VoiceTypeDoyle";
		case EUSCharacterTypes.USCharFriar:
			return "gbxCharacters.VoiceTypeFriar";
		case EUSCharacterTypes.USCharGarnett:
			return "gbxCharacters.VoiceTypeGarnett";
		case EUSCharacterTypes.USCharMarsh:
			return "gbxCharacters.VoiceTypeMarsh";
		case EUSCharacterTypes.USCharMcConnel:
			return "gbxCharacters.VoiceTypeMcConnel";
		case EUSCharacterTypes.USCharPaddock:
			return "gbxCharacters.VoiceTypePaddock";
		case EUSCharacterTypes.USCharPaige:
			return "gbxCharacters.VoiceTypePaige";
		case EUSCharacterTypes.USCharLocke:
		case EUSCharacterTypes.USCharJameson:
		case EUSCharacterTypes.USCharLeggett:
		case EUSCharacterTypes.USCharMuzza:
		case EUSCharacterTypes.USCharCole:
		case EUSCharacterTypes.USCharYork:
		case EUSCharacterTypes.USCharWheaton:
		case EUSCharacterTypes.USCharHooper:
		case EUSCharacterTypes.USCharDoe:
		case EUSCharacterTypes.USCharMcCreary:
		case EUSCharacterTypes.USCharRivas:
		case EUSCharacterTypes.USCharZanovich:
		case EUSCharacterTypes.USCharObrieski:
		case EUSCharacterTypes.USCharCourtland:
		case EUSCharacterTypes.USCharMac:
		case EUSCharacterTypes.USCharCombs:
		case EUSCharacterTypes.USCharRisner:
		case EUSCharacterTypes.USCharTankCommanderA:
		case EUSCharacterTypes.USCharTankCommanderB:
		case EUSCharacterTypes.USCharTankCommanderC:
		case EUSCharacterTypes.USCharTankCommanderD:
		case EUSCharacterTypes.USCharLewis:
		case EUSCharacterTypes.USCharScott:
		case EUSCharacterTypes.USCharBoyd:
		case EUSCharacterTypes.USCharCassidy:
		case EUSCharacterTypes.USCharJohnson:
		case EUSCharacterTypes.USCharHersh:
		case EUSCharacterTypes.USCharMarshall:
		default:
			return "gbxCharacters.VoiceTypeDefault";
	}
	
	return "gbxCharacters.VoiceTypeDefault";
}

simulated static function float GetCharacterScale(int characterType)
{
	local float flScale;
	
	// GBX:naj - Returning 1.0 for all U.S. pawns because we don't use this feature anymore
	// and it causes a bug in APawn::Crouch() and ::UnCrouch() where it uses different
	// HeightAdjust values in either case, causing a slow ratcheting downward of the eyeheight.
	return 1.0f;
	//////////////////////

	flScale = 1.0f;
	switch (characterType)
	{
		case EUSCharacterTypes.USCharAllen:
			flScale = 1.02f;
			break;
		case EUSCharacterTypes.USCharLocke:
			flScale = 1.0f;
			break;
		case EUSCharacterTypes.USCharHartsockCpl:
		case EUSCharacterTypes.USCharHartsockSgt:
		case EUSCharacterTypes.USCharHartsockSgtFinger:
			flScale = 1.01f;
			break;
		case EUSCharacterTypes.USCharJameson:
			flScale = 1.0f;
			break;
		case EUSCharacterTypes.USCharGarnett:
			flScale = 1.03f;
			break;
		case EUSCharacterTypes.USCharCorrion:
			flScale = 1.01f;
			break;
		case EUSCharacterTypes.USCharLeggett:
			flScale = 1.04f;
			break;
		case EUSCharacterTypes.USCharBaker:
			flScale = 1.0f;
			break;
		case EUSCharacterTypes.USCharMuzza:
			flScale = 1.02f;
			break;
		case EUSCharacterTypes.USCharCole:
			flScale = 1.01f;
			break;
	}
	
	return flScale;
}

simulated static function float GetCharacterRank(int characterType)
{
	switch (characterType)
	{
		case EUSCharacterTypes.USCharAllen:
			return CHAR_RANK_PRIVATE;
		case EUSCharacterTypes.USCharLocke:
			return CHAR_RANK_PRIVATE;
		case EUSCharacterTypes.USCharHartsockCpl:
			return CHAR_RANK_CORPORAL;
		case EUSCharacterTypes.USCharHartsockSgt:
		case EUSCharacterTypes.USCharHartsockSgtFinger:
			return CHAR_RANK_SEARGENT;
		case EUSCharacterTypes.USCharJameson:
			return CHAR_RANK_OFFICER;
		case EUSCharacterTypes.USCharGarnett:
			return CHAR_RANK_PRIVATE;
		case EUSCharacterTypes.USCharCorrion:
			return CHAR_RANK_CORPORAL;
		case EUSCharacterTypes.USCharLeggett:
			return CHAR_RANK_PRIVATEFC;
		case EUSCharacterTypes.USCharBaker:
			return CHAR_RANK_SEARGENT;
		case EUSCharacterTypes.USCharMuzza:
			return CHAR_RANK_PRIVATE;
		case EUSCharacterTypes.USCharCole:
			return CHAR_RANK_OFFICER;
		case EUSCharacterTypes.USCharYork:
			return CHAR_RANK_PRIVATE;
		case EUSCharacterTypes.USCharWheaton:
			return CHAR_RANK_PRIVATEFC;
		case EUSCharacterTypes.USCharHooper:
			return CHAR_RANK_PRIVATE;
		case EUSCharacterTypes.USCharDoe:
			return CHAR_RANK_PRIVATE;
		case EUSCharacterTypes.USCharMcCreary:
			return CHAR_RANK_PRIVATE;
		case EUSCharacterTypes.USCharRivas:
			return CHAR_RANK_PRIVATE;
		case EUSCharacterTypes.USCharDesola:
			return CHAR_RANK_PRIVATE;
		case EUSCharacterTypes.USCharZanovich:
			return CHAR_RANK_PRIVATEFC;
		case EUSCharacterTypes.USCharObrieski:
			return CHAR_RANK_PRIVATEFC;
		case EUSCharacterTypes.USCharCourtland:
			return CHAR_RANK_PRIVATEFC;
		case EUSCharacterTypes.USCharMac:
			return CHAR_RANK_MASTERSEARGENT;
		case EUSCharacterTypes.USCharCombs:
			return CHAR_RANK_OFFICER;
		case EUSCharacterTypes.USCharLewis:
			return CHAR_RANK_SEARGENT;
		case EUSCharacterTypes.USCharScott:
			return CHAR_RANK_SEARGENT;
		case EUSCharacterTypes.USCharBoyd:
			return CHAR_RANK_OFFICER;
		case EUSCharacterTypes.USCharTankCommanderRisner:
			return CHAR_RANK_SEARGENT;
		case EUSCharacterTypes.USCharTankCommanderA:
			return CHAR_RANK_SEARGENT;
		case EUSCharacterTypes.USCharTankCommanderB:
			return CHAR_RANK_SEARGENT;
		case EUSCharacterTypes.USCharTankCommanderC:
			return CHAR_RANK_SEARGENT;
		case EUSCharacterTypes.USCharTankCommanderD:
			return CHAR_RANK_SEARGENT;
		case EUSCharacterTypes.USCharDoyle:
			return CHAR_RANK_CORPORAL;
		case EUSCharacterTypes.USCharPaddock:
			return CHAR_RANK_CORPORAL;
		case EUSCharacterTypes.USCharCassidy:
			return CHAR_RANK_OFFICER;
		case EUSCharacterTypes.USCharFriar:
			return CHAR_RANK_PRIVATE;
		case EUSCharacterTypes.USCharCampbell:
			return CHAR_RANK_CORPORAL;
		case EUSCharacterTypes.USCharMcConnel:
			return CHAR_RANK_PRIVATE;
		case EUSCharacterTypes.USCharPaige:
			return CHAR_RANK_PRIVATE;
		case EUSCharacterTypes.USCharMarsh:
			return CHAR_RANK_PRIVATE;
		case EUSCharacterTypes.USCharJohnson:
			return CHAR_RANK_OFFICER;
		case EUSCharacterTypes.USCharHersh:
			return CHAR_RANK_PRIVATE;
		case EUSCharacterTypes.USCharMarshall:
			return CHAR_RANK_OFFICER;
		case EUSCharacterTypes.USCharDoyleSgt:
			return CHAR_RANK_SEARGENT;
		default:
			return 1.0f;
	}
	return 1.0f;
}

simulated static function string GetCharacterName(int characterType, optional bool bIsTanker)
{
	switch (characterType)
	{
		case EUSCharacterTypes.USCharAllen:
			return "Allen";
		case EUSCharacterTypes.USCharLocke:
			return "Locke";		
		case EUSCharacterTypes.USCharHartsockCpl:
		case EUSCharacterTypes.USCharHartsockSgt:
		case EUSCharacterTypes.USCharHartsockSgtFinger:
			return "Hartsock";
		case EUSCharacterTypes.USCharJameson:
			return "Jameson";
		case EUSCharacterTypes.USCharGarnett:
			return "Garnett";
		case EUSCharacterTypes.USCharCorrion:
			return "Corrion";
		case EUSCharacterTypes.USCharLeggett:
			return "Leggett";
		case EUSCharacterTypes.USCharBaker:
			return "Baker";
		case EUSCharacterTypes.USCharMuzza:
			return "Muzza";
		case EUSCharacterTypes.USCharCole:
			return "Cole";
		case EUSCharacterTypes.USCharYork:
			return "York";
		case EUSCharacterTypes.USCharWheaton:
			return "Wheaton";
		case EUSCharacterTypes.USCharHooper:
			return "Hooper";
		case EUSCharacterTypes.USCharDoe:
			return "Doe";
		case EUSCharacterTypes.USCharMcCreary:
			return "McCreary";
		case EUSCharacterTypes.USCharRivas:
			return "Rivas";
		case EUSCharacterTypes.USCharDesola:
			return "Desola";
		case EUSCharacterTypes.USCharZanovich:
			return "Zanovich";
		case EUSCharacterTypes.USCharObrieski:
			return "Obrieski";
		case EUSCharacterTypes.USCharCourtland:
			return "Courtland";
		case EUSCharacterTypes.USCharMac:
			return "Hassay";
		case EUSCharacterTypes.USCharCombs:
			return "Combs";
		case EUSCharacterTypes.USCharLewis:
			return "Lewis";
		case EUSCharacterTypes.USCharScott:
			return "Scott";
		case EUSCharacterTypes.USCharBoyd:
			return "Boyd";
		case EUSCharacterTypes.USCharTankCommanderRisner:
			return "Risner";
		case EUSCharacterTypes.USCharTankCommanderA:
			return "Andrews";
		case EUSCharacterTypes.USCharTankCommanderB:
			return "Tucker";
		case EUSCharacterTypes.USCharTankCommanderC:
			return "Bradley";
		case EUSCharacterTypes.USCharTankCommanderD:
			return "Kelly";
		case EUSCharacterTypes.USCharDoyle:
		case EUSCharacterTypes.USCharDoyleSgt:
			return "Doyle";
		case EUSCharacterTypes.USCharPaddock:
			return "Paddock";
		case EUSCharacterTypes.USCharCassidy:
			return "Cassidy";
		case EUSCharacterTypes.USCharFriar:
			return "Friar";
		case EUSCharacterTypes.USCharCampbell:
			return "Campbell";
		case EUSCharacterTypes.USCharMcConnel:
			return "McConnel";
		case EUSCharacterTypes.USCharPaige:
			return "Paige";
		case EUSCharacterTypes.USCharMarsh:
			return "Marsh";
		case EUSCharacterTypes.USCharJohnson:
			return "Johnson";
		case EUSCharacterTypes.USCharHersh:
			return "Hersh";
		case EUSCharacterTypes.USCharMarshall:
			return "Marshall";
	}

	return "Soldier";
}

simulated static function name GetCharacterFName(int characterType)
{
	switch (characterType)
	{
		case EUSCharacterTypes.USCharAllen:
			return 'Allen';
		case EUSCharacterTypes.USCharLocke:
			return 'Locke';		
		case EUSCharacterTypes.USCharHartsockCpl:
		case EUSCharacterTypes.USCharHartsockSgt:
		case EUSCharacterTypes.USCharHartsockSgtFinger:
			return 'Hartsock';
		case EUSCharacterTypes.USCharJameson:
			return 'Jameson';
		case EUSCharacterTypes.USCharGarnett:
			return 'Garnett';
		case EUSCharacterTypes.USCharCorrion:
			return 'Corrion';
		case EUSCharacterTypes.USCharLeggett:
			return 'Leggett';
		case EUSCharacterTypes.USCharBaker:
			return 'Baker';
		case EUSCharacterTypes.USCharMuzza:
			return 'Muzza';
		case EUSCharacterTypes.USCharCole:
			return 'Cole';
		case EUSCharacterTypes.USCharYork:
			return 'York';
		case EUSCharacterTypes.USCharWheaton:
			return 'Wheaton';
		case EUSCharacterTypes.USCharHooper:
			return 'Hooper';
		case EUSCharacterTypes.USCharDoe:
			return 'Doe';
		case EUSCharacterTypes.USCharMcCreary:
			return 'Mccreary';
		case EUSCharacterTypes.USCharRivas:
			return 'Rivas';
		case EUSCharacterTypes.USCharDesola:
			return 'Desola';
		case EUSCharacterTypes.USCharZanovich:
			return 'Zanovich';
		case EUSCharacterTypes.USCharObrieski:
			return 'Obrieski';
		case EUSCharacterTypes.USCharCourtland:
			return 'Courtland';
		case EUSCharacterTypes.USCharMac:
			return 'Hassay';
		case EUSCharacterTypes.USCharCombs:
			return 'Combs';
		case EUSCharacterTypes.USCharLewis:
			return 'Lewis';
		case EUSCharacterTypes.USCharScott:
			return 'Scott';
		case EUSCharacterTypes.USCharBoyd:
			return 'Boyd';
		case EUSCharacterTypes.USCharTankCommanderRisner:
			return 'Risner';
		case EUSCharacterTypes.USCharTankCommanderA:
			return 'Andrews';
		case EUSCharacterTypes.USCharTankCommanderB:
			return 'Tucker';
		case EUSCharacterTypes.USCharTankCommanderC:
			return 'Bradley';
		case EUSCharacterTypes.USCharTankCommanderD:
			return 'Kelly';
		case EUSCharacterTypes.USCharDoyle:
		case EUSCharacterTypes.USCharDoyleSgt:
			return 'Doyle';
		case EUSCharacterTypes.USCharPaddock:
			return 'Paddock';
		case EUSCharacterTypes.USCharCassidy:
			return 'Cassidy';
		case EUSCharacterTypes.USCharFriar:
			return 'Friar';
		case EUSCharacterTypes.USCharCampbell:
			return 'Campbell';
		case EUSCharacterTypes.USCharMcConnel:
			return 'McConnel';
		case EUSCharacterTypes.USCharPaige:
			return 'Paige';
		case EUSCharacterTypes.USCharMarsh:
			return 'Marsh';
		case EUSCharacterTypes.USCharJohnson:
			return 'Johnson';
		case EUSCharacterTypes.USCharHersh:
			return 'Hersh';
		case EUSCharacterTypes.USCharMarshall:
			return 'Marshall';
	}

	return 'Soldier';
}

simulated static function string GetCharacterRankName(int characterType)
{
	switch (characterType)
	{
		case EUSCharacterTypes.USCharAllen:
			return "Pvt. Allen";
		case EUSCharacterTypes.USCharLocke:
			return "Pvt. Locke";		
		case EUSCharacterTypes.USCharHartsockCpl:
			return "Cpl. Joe Hartsock";
		case EUSCharacterTypes.USCharHartsockSgt:
		case EUSCharacterTypes.USCharHartsockSgtFinger:
			return "Sgt. Joe Hartsock";
		case EUSCharacterTypes.USCharJameson:
			return "Pvt. Jameson";
		case EUSCharacterTypes.USCharGarnett:
			return "Pvt. Garnett";
		case EUSCharacterTypes.USCharCorrion:
			return "Cpl. Corrion";
		case EUSCharacterTypes.USCharLeggett:
			return "Pfc. Leggett";
		case EUSCharacterTypes.USCharBaker:
			return "Sgt. Baker";
		case EUSCharacterTypes.USCharMuzza:
			return "Pvt. Muzza";
		case EUSCharacterTypes.USCharCole:
			return "Lt. Col. Cole";
		case EUSCharacterTypes.USCharYork:
			return "Pvt. York";
		case EUSCharacterTypes.USCharWheaton:
			return "Pfc. Wheaton";
		case EUSCharacterTypes.USCharHooper:
			return "Pvt. Hooper";
		case EUSCharacterTypes.USCharDoe:
			return "Pvt. Doe";
		case EUSCharacterTypes.USCharMcCreary:
			return "Pvt. McCreary";
		case EUSCharacterTypes.USCharRivas:
			return "Pvt. Rivas";
		case EUSCharacterTypes.USCharDesola:
			return "Pvt. Desola";
		case EUSCharacterTypes.USCharZanovich:
			return "Pfc. Zanovich";
		case EUSCharacterTypes.USCharObrieski:
			return "Pfc. Obrieski";
		case EUSCharacterTypes.USCharCourtland:
			return "Pfc. Courtland";
		case EUSCharacterTypes.USCharMac:
			return "Plt. Sgt. Hassay";
		case EUSCharacterTypes.USCharCombs:
			return "Lt. Combs";
		case EUSCharacterTypes.USCharLewis:
			return "Sgt. Lewis";
		case EUSCharacterTypes.USCharScott:
			return "Sgt. Scott";
		case EUSCharacterTypes.USCharBoyd:
			return "Pvt. Boyd";
		case EUSCharacterTypes.USCharTankCommanderRisner:
			return "Sgt. Risner";
		case EUSCharacterTypes.USCharTankCommanderA:
			return "Sgt. Andrews";
		case EUSCharacterTypes.USCharTankCommanderB:
			return "Sgt. Tucker";
		case EUSCharacterTypes.USCharTankCommanderC:
			return "Sgt. Bradley";
		case EUSCharacterTypes.USCharTankCommanderD:
			return "Sgt. Kelly";
		case EUSCharacterTypes.USCharDoyle:
			return "Cpl. Doyle";
		case EUSCharacterTypes.USCharPaddock:
			return "Cpl. Paddock";
		case EUSCharacterTypes.USCharCassidy:
			return "Lt. Col. Cassidy";
		case EUSCharacterTypes.USCharFriar:
			return "Pvt. Friar";
		case EUSCharacterTypes.USCharCampbell:
			return "Cpl. Campbell";
		case EUSCharacterTypes.USCharMcConnel:
			return "Pvt. McConnel";
		case EUSCharacterTypes.USCharPaige:
			return "Pvt. Paige";
		case EUSCharacterTypes.USCharMarsh:
			return "Pvt. Marsh";
		case EUSCharacterTypes.USCharJohnson:
			return "Col. Johnson";
		case EUSCharacterTypes.USCharHersh:
			return "Pvt. Hersh";
		case EUSCharacterTypes.USCharMarshall:
			return "Col. Marshall";
		case EUSCharacterTypes.USCharDoyleSgt:
			return "Sgt. Doyle";
	}

	return "Pvt. Soldier";
}

simulated static function string GetCharacterPortrait(int characterType, optional bool bIsTanker)
{
	switch (characterType)
	{
		case EUSCharacterTypes.USCharAllen:
			return "t_interface_mb.allen_side";
		case EUSCharacterTypes.USCharLocke:
			return "t_interface_mb.locke_side";		
		case EUSCharacterTypes.USCharHartsockCpl:
		case EUSCharacterTypes.USCharHartsockSgt:
		case EUSCharacterTypes.USCharHartsockSgtFinger:
			return "t_interface_mb.hartsock_side";
		case EUSCharacterTypes.USCharJameson:
			return "t_interface_mb.jameson_side";
		case EUSCharacterTypes.USCharGarnett:
			return "t_interface_mb.garnett_side";
		case EUSCharacterTypes.USCharCorrion:
			return "t_interface_mb.corrion_side";
		case EUSCharacterTypes.USCharLeggett:
			return "t_interface_mb.leggett_side";
		case EUSCharacterTypes.USCharBaker:
			return "t_interface_mb.baker_side";
		case EUSCharacterTypes.USCharMuzza:
			return "t_interface_mb.muzza_side";
		case EUSCharacterTypes.USCharCole:
			return "t_interface_mb.cole_side";
		case EUSCharacterTypes.USCharYork:
			return "t_interface_mb.york_side";
		case EUSCharacterTypes.USCharWheaton:
			return "t_interface_mb.wheaton_side";
		case EUSCharacterTypes.USCharHooper:
			return "t_interface_mb.hooper_side";
		case EUSCharacterTypes.USCharDoe:
			return "t_interface_mb.doe_side";
		case EUSCharacterTypes.USCharMcCreary:
			return "t_interface_mb.mccreary_side";
		case EUSCharacterTypes.USCharRivas:
			return "t_interface_mb.rivas_side";
		case EUSCharacterTypes.USCharDesola:
			return "t_interface_mb.desola_side";
		case EUSCharacterTypes.USCharZanovich:
			return "t_interface_mb.zanovich_side";
		case EUSCharacterTypes.USCharObrieski:
			return "t_interface_mb.obrieski_side";
		case EUSCharacterTypes.USCharCourtland:
			return "t_interface_mb.courtland_side";
		case EUSCharacterTypes.USCharMac:
			return "t_interface_mb.mac_side";
		case EUSCharacterTypes.USCharCombs:
			return "t_interface_mb.combs_side";
		case EUSCharacterTypes.USCharTankCommanderRisner:
			return "t_interface_mb.risner_side";
		case EUSCharacterTypes.USCharTankCommanderA:
			return "t_interface_mb.tanker_1_side";
		case EUSCharacterTypes.USCharTankCommanderB:
			return "t_interface_mb.tanker_2_side";
		case EUSCharacterTypes.USCharTankCommanderC:
			return "t_interface_mb.us_tanker_random3";
		case EUSCharacterTypes.USCharTankCommanderD:
			return "t_interface_mb.us_tanker_random4";
		case EUSCharacterTypes.USCharDoyle:
		case EUSCharacterTypes.USCharDoyleSgt:
			return "t_interface_mb.doyle_side";
		case EUSCharacterTypes.USCharPaddock:
			return "t_interface_mb.paddock_side";
		case EUSCharacterTypes.USCharCassidy:
			return "t_interface_mb.cassidy_side";
		case EUSCharacterTypes.USCharFriar:
			return "t_interface_mb.friar_side";
		case EUSCharacterTypes.USCharCampbell:
			return "t_interface_mb.campbell_side";
		case EUSCharacterTypes.USCharMcConnel:
			return "t_interface_mb.mcconnel_side";
		case EUSCharacterTypes.USCharPaige:
			return "t_interface_mb.paige_side";
		case EUSCharacterTypes.USCharMarsh:
			return "t_interface_mb.marsh_side";
		case EUSCharacterTypes.USCharJohnson:
			return "t_interface_mb.johnson_side";
		case EUSCharacterTypes.USCharHersh:
			return "t_interface_mb.mac_side";
		case EUSCharacterTypes.USCharMarshall:
			return "t_interface_mb.mac_side";
		case EUSCharacterTypes.USCharBoyd:
			return "t_interface_mb.york_side";
	}

	return "";
}

simulated static function string GetTankPortrait( int TankType )
{
	switch( TankType )
	{
		case ETankType.US_ShermanTank:
			return "t_interface_mb.tank_sherman";
		case ETankType.US_StuartTank:
			return "t_interface_mb.tank_stuart";
		case ETankType.US_M10:
			return "t_interface_mb.tank_m10";
	}

	return "Unknown";
}

simulated static function string GetTankName( int TankType )
{
	switch( TankType )
	{
		case ETankType.US_ShermanTank:
			return "M4 Sherman";
		case ETankType.US_StuartTank:
			return "M5A1 Stuart";
		case ETankType.US_M10:
			return "M10";
	}

	return "Unknown";
}
//=============================================================================
// CheatManager
// Object within playercontroller that manages "cheat" commands
// only spawned in single player mode
//=============================================================================

class CheatManager extends Object within PlayerController
	native;



var rotator LockedRotation;

/* Used for correlating game situation with log file
*/

exec function ReviewJumpSpots(name TestLabel)
{
	if ( TestLabel == 'Transloc' )
		TestLabel = 'Begin';
	else if ( TestLabel == 'Jump' )
		TestLabel = 'Finished';
	else if ( TestLabel == 'Combo' )
		TestLabel = 'FinishedJumping';
	else if ( TestLabel == 'LowGrav' )
		TestLabel = 'FinishedComboJumping';
	log("TestLabel is "$TestLabel);
	Level.Game.ReviewJumpSpots(TestLabel);
}

exec function ListDynamicActors()
{
	local Actor A;
	local int i;

	ForEach DynamicActors(class'Actor',A)
	{
		i++;
		log(i@A);
	}
	log("Num dynamic actors: "$i);
}

exec function FreezeFrame(float delay)
{
	Level.Game.SetPause(true,outer);
	Level.PauseDelay = Level.TimeSeconds + delay;
}

exec function WriteToLog()
{
	log("NOW!");
}

exec function SetFlash(float F)
{
	FlashScale.X = F;
}

exec function SetFogR(float F)
{
	FlashFog.X = F;
}

exec function SetFogG(float F)
{
	FlashFog.Y = F;
}

exec function SetFogB(float F)
{
	FlashFog.Z = F;
}

exec function KillViewedActor()
{
	if ( ViewTarget != None )
	{
		if ( (Pawn(ViewTarget) != None) && (Pawn(ViewTarget).Controller != None) )
			Pawn(ViewTarget).Controller.Destroy();
		ViewTarget.Destroy();
		SetViewTarget(None);
	}
}

/* LogScriptedSequences()
Toggles logging of scripted sequences on and off
*/
exec function LogScriptedSequences(bool flag)
{
	local AIScript S;

	ForEach AllActors(class'AIScript',S)
	{
		if (flag)
			Log("turning on logging for " $ S);
		else
			Log("turning off logging for " $ S);

		S.bLoggingEnabled = flag;
	}
}

/* Teleport()
Teleport to surface player is looking at
*/
exec function Teleport()
{
	local actor HitActor;
	local vector HitNormal, HitLocation;

	HitActor = Trace(HitLocation, HitNormal, ViewTarget.Location + 10000 * vector(Rotation),ViewTarget.Location, true);
	if ( HitActor == None )
		HitLocation = ViewTarget.Location + 10000 * vector(Rotation);
	else
		HitLocation = HitLocation + ViewTarget.CollisionRadius * HitNormal;

	ViewTarget.SetLocation(HitLocation);
}

/*
Scale the player's size to be F * default size
*/
exec function ChangeSize( float F )
{
	if ( Pawn.SetCollisionSize(Pawn.Default.CollisionRadius * F,Pawn.Default.CollisionHeight * F) )
	{
		Pawn.SetDrawScale(F);
		Pawn.SetLocation(Pawn.Location);
	}
}

exec function LockCamera()
{
	local vector LockedLocation;
	local rotator LockedRot;
	local actor LockedActor;

	if ( !bCameraPositionLocked )
	{
		PlayerCalcView(LockedActor,LockedLocation,LockedRot);
		Outer.SetLocation(LockedLocation);
		LockedRotation = LockedRot;
		SetViewTarget(outer);
	}
	else
		SetViewTarget(Pawn);

	bCameraPositionLocked = !bCameraPositionLocked;
	bBehindView = bCameraPositionLocked;
	bFreeCamera = false;
}

exec function SetCameraDist( float F )
{
	CameraDist = FMax(F,2);
}

/* Stop interpolation
*/
exec function EndPath()
{
}

/*
Camera and Pawn aren't rotated together in behindview when bFreeCamera is true
*/
exec function FreeCamera( bool B )
{
	bFreeCamera = B;
	bBehindView = B;
}


exec function CauseEvent( name EventName )
{
	TriggerEvent( EventName, Pawn, Pawn);
}

exec function Amphibious()
{
	Pawn.UnderwaterTime = +999999.0;
}

exec function Fly()
{
	if ( Pawn == None )
		return;
	Pawn.UnderWaterTime = Pawn.Default.UnderWaterTime;
	ClientMessage("You feel much lighter");
	Pawn.SetCollision(true, true , true);
	Pawn.bCollideWorld = true;
	bCheatFlying = true;
	Outer.GotoState('PlayerFlying');
}

exec function Walk()
{
	if ( Pawn != None )
	{
		bCheatFlying = false;
		Pawn.UnderWaterTime = Pawn.Default.UnderWaterTime;
		Pawn.SetCollision(true, true , true);
		if (Pawn.bUseRootMotion)
			Pawn.SetPhysics(PHYS_RootMotion);
		else
			Pawn.SetPhysics(PHYS_Walking);
		Pawn.bCollideWorld = true;
		ClientReStart(Pawn);
	}
}

exec function Ghost()
{
	if( Pawn != None && !Pawn.IsA('Vehicle') )
	{
		Pawn.UnderWaterTime = -1.0;
		ClientMessage("You feel ethereal");
		Pawn.SetCollision(false, false, false);
		Pawn.bCollideWorld = false;
		bCheatFlying = true;
		Outer.GotoState('PlayerFlying');
	}
	else
		Log("Can't Ghost In Vehicles");
}

exec function GhostToggle()
{
	if (bCheatFlying)
		Walk();
	else
		Ghost();
}

exec function AllAmmo()
{
	local Inventory Inv;

	for( Inv=Pawn.Inventory; Inv!=None; Inv=Inv.Inventory )
		if (Ammunition(Inv)!=None)
		{
			Ammunition(Inv).AmmoAmount  = 999;
			Ammunition(Inv).MaxAmmo  = 999;
		}
}

exec function Invisible(bool B)
{
	Pawn.bHidden = B;

	if (B)
		Pawn.Visibility = 0;
	else
		Pawn.Visibility = Pawn.Default.Visibility;
}

exec function God()
{
	if ( bGodMode )
	{
		bGodMode = false;
		ClientMessage("God mode off");
		return;
	}

	bGodMode = true;
	ClientMessage("God Mode on");
}

exec function SloMo( float T )
{
	Level.Game.SetGameSpeed(T);
	Level.Game.SaveConfig();
	Level.Game.GameReplicationInfo.SaveConfig();
}

exec function SetJumpZ( float F )
{
	Pawn.JumpZ = F;
}

exec function SetGravity( float F )
{
	PhysicsVolume.Gravity.Z = F;
}

exec function SetSpeed( float F )
{
	Pawn.GroundSpeed = Pawn.Default.GroundSpeed * f;
	Pawn.WaterSpeed = Pawn.Default.WaterSpeed * f;
}

exec function KillAll(class<actor> aClass)
{
	local Actor A;

	if ( ClassIsChildOf(aClass, class'AIController') )
	{
		Level.Game.KillBots(Level.Game.NumBots);
		return;
	}
	if ( ClassIsChildOf(aClass, class'Pawn') )
	{
		KillAllPawns(class<Pawn>(aClass));
		return;
	}
	ForEach DynamicActors(class 'Actor', A)
		if ( ClassIsChildOf(A.class, aClass) )
			A.Destroy();
}

// Kill non-player pawns and their controllers
function KillAllPawns(class<Pawn> aClass)
{
	local Pawn P;

	Level.Game.KillBots(Level.Game.NumBots);
	ForEach DynamicActors(class'Pawn', P)
		if ( ClassIsChildOf(P.Class, aClass)
			&& !P.IsPlayerPawn() )
		{
			if ( P.Controller != None )
				P.Controller.Destroy();
			P.Destroy();
		}
}

exec function KillPawns()
{
	KillAllPawns(class'Pawn');
}

/* Avatar()
Possess a Pawn of the requested class
*/
exec function Avatar( string ClassName )
{
	local class<actor> NewClass;
	local Pawn P;

	NewClass = class<actor>( DynamicLoadObject( ClassName, class'Class' ) );
	if( NewClass!=None )
	{
		Foreach DynamicActors(class'Pawn',P)
		{
			if ( (P.Class == NewClass) && (P != Pawn) )
			{
				if ( Pawn.Controller != None )
					Pawn.Controller.PawnDied(Pawn);
				Possess(P);
				break;
			}
		}
	}
}

exec function Summon( string ClassName )
{
	local class<actor> NewClass;
	local vector SpawnLoc;

	log( "Fabricate " $ ClassName );
	NewClass = class<actor>( DynamicLoadObject( ClassName, class'Class' ) );
	if( NewClass!=None )
	{
		if ( Pawn != None )
			SpawnLoc = Pawn.Location;
		else
			SpawnLoc = Location;
		Spawn( NewClass,,,SpawnLoc + 72 * Vector(Rotation) + vect(0,0,1) * 15 );
	}
}

exec function PlayersOnly()
{
	Level.bPlayersOnly = !Level.bPlayersOnly;
}

exec function CheatView( class<actor> aClass, optional bool bQuiet )
{
	ViewClass(aClass,bQuiet,true);
}

// ***********************************************************
// Navigation Aids (for testing)

// remember spot for path testing (display path using ShowDebug)
exec function RememberSpot()
{
	if ( Pawn != None )
		Destination = Pawn.Location;
	else
		Destination = Location;
}

// ***********************************************************
// Changing viewtarget

exec function ViewSelf(optional bool bQuiet)
{
	if ( !Pawn.bIsManningTurret )
		bBehindView = false;

	bViewBot = false;
	if ( Pawn != None )
		SetViewTarget(Pawn);
	else
		SetViewtarget(outer);
	if (!bQuiet )
		ClientMessage(OwnCamera, 'Event');
	FixFOV();
}

exec function ViewPlayer( string S )
{
	local Controller P;

	for ( P=Level.ControllerList; P!=None; P= P.NextController )
		if ( P.bIsPlayer && (P.PlayerReplicationInfo.PlayerName ~= S) )
			break;

	if ( P.Pawn != None )
	{
		ClientMessage(ViewingFrom@P.PlayerReplicationInfo.PlayerName, 'Event');
		SetViewTarget(P.Pawn);
	}

	bBehindView = ( ViewTarget != Pawn );
	if ( bBehindView )
		ViewTarget.BecomeViewTarget();
}

exec function ViewActor( name ActorName)
{
	local Actor A;

	ForEach AllActors(class'Actor', A)
		if ( A.Name == ActorName )
		{
			SetViewTarget(A);
			bBehindView = true;
			return;
		}
}

exec function ViewFlag()
{
	local Controller C;

	For ( C=Level.ControllerList; C!=None; C=C.NextController )
		if ( C.IsA('AIController') && (C.PlayerReplicationInfo != None) && (C.PlayerReplicationInfo.HasFlag != None) )
		{
			SetViewTarget(C.Pawn);
			return;
		}
}

exec function ViewBot()
{
	local actor first;
	local bool bFound;
	local Controller C;

	bViewBot = true;
	For ( C=Level.ControllerList; C!=None; C=C.NextController )
		if ( C.IsA('AIController') && (C.Pawn != None) )
	{
		if ( bFound || (first == None) )
		{
			first = C.Pawn;
			if ( bFound )
				break;
		}
		if ( C.Pawn == ViewTarget )
			bFound = true;
	}

	if ( first != None )
	{
		SetViewTarget(first);
		bBehindView = true;
		ViewTarget.BecomeViewTarget();
		FixFOV();
	}
	else
		ViewSelf(true);
}

exec function ViewClass( class<actor> aClass, optional bool bQuiet, optional bool bCheat )
{
	local actor other, first;
	local bool bFound;

	if ( !bCheat && (Level.Game != None) && !Level.Game.bCanViewOthers )
		return;

	first = None;

	ForEach AllActors( aClass, other )
	{
		if ( bFound || (first == None) )
		{
			first = other;
			if ( bFound )
				break;
		}
		if ( other == ViewTarget )
			bFound = true;
	}

	if ( first != None )
	{
		if ( !bQuiet )
		{
			if ( Pawn(first) != None )
				ClientMessage(ViewingFrom@First.GetHumanReadableName(), 'Event');
			else
				ClientMessage(ViewingFrom@first, 'Event');
		}
		SetViewTarget(first);
		bBehindView = ( ViewTarget != outer );

		if ( bBehindView )
			ViewTarget.BecomeViewTarget();

		FixFOV();
	}
	else
		ViewSelf(bQuiet);
}

exec function Loaded()
{
	if( Level.Netmode!=NM_Standalone )
		return;

    AllWeapons();
    AllAmmo();
}

exec function OldMovie()
{			
	local int playerindex;		

	playerindex = 0;
	if (Player != None)
	    playerindex = Player.SplitIndex;
	if(Level.CameraEffectManager[playerindex].CurrentCameraMode == CAM_HighDynamicRange)
		Level.CameraEffectManager[playerindex].SetCameraEffect(CAM_OldMovie, true);
	else if (Level.CameraEffectManager[playerindex].CurrentCameraMode == CAM_OldMovie)
		Level.CameraEffectManager[playerindex].SetCameraEffect(CAM_HighDynamicRange, true);
}

// RSC: added 1/17/04 for infinite ammo cheat
exec function Unloaded()
{
	if( Level.Netmode != NM_Standalone || Pawn == None )
		return;
	
	Pawn.bUnloaded = !Pawn.bUnloaded;
}

// RSC: added 1/22/04 for super squad cheat
exec function SuperSquad()
{
	local Pawn pUnit;

	//log( "CheatManager::SuperSquad()", 'RSC' );

	if( Level.NetMode != NM_Standalone ) {
		//log( "CheatManager::SuperSquad() - Single Player Only", 'RSC' );
		return;
	}

	// set the health of all allied soldiers and tanks to 500, but not the player
	ForEach DynamicActors( class'Pawn', pUnit )
	{
		//log( "***** Pawn: " $ pUnit.name $ " - health=" $ pUnit.health, 'RSC' );
		if( pUnit.IsA( 'InfantryUSA' ) && !pUnit.IsA( 'gbxPlayerPawn' ) || pUnit.IsA('TankStuart') || pUnit.IsA('TankSherman') ) {
			if( !pUnit.IsDead() )
				pUnit.Health = 500;
			//log( "***** Pawn: " $ pUnit.name $ " - health=" $ pUnit.health, 'RSC' );
		}
	}
}

exec function AllWeapons()
{
	if( (Level.Netmode!=NM_Standalone) || (Pawn == None) )
		return;

//	Pawn.GiveWeapon("WarClassLight.WeapCOGAssaultRifle");
//	Pawn.GiveWeapon("WarClassLight.WeapCOGLightPlasma");
//	Pawn.GiveWeapon("WarClassLight.WeapCOGPistol");
//	Pawn.GiveWeapon("WarClassHeavy.WeapCOGMinigun");
//	Pawn.GiveWeapon("WarClassLight.WeapGeistSniperRifle");
//	Pawn.GiveWeapon("WarClassLight.WeapGeistGrenadeLauncher");

	// GEARBOX: PSV 4/14/2004 Add our weapons in here to make testing easier
	// Note: Syntax for weaponClassName is PackageName.ClassName
	// All weapons, use this format: "gbxInventory.<Name>"
	// WeapDEK98_
	// WeapDEMP40_
	// WeapUSBar
	// WeapUSColt1911_
	// WeapUSM1_
	// WeapUSThompson
	Pawn.GiveWeapon("gbxInventory.WeapDEK98_");
	Pawn.GiveWeapon("gbxInventory.WeapDEMP40_");
	Pawn.GiveWeapon("gbxInventory.WeapUSBar");
	Pawn.GiveWeapon("gbxInventory.WeapUSColt1911_");
	Pawn.GiveWeapon("gbxInventory.WeapUSM1_");
	Pawn.GiveWeapon("gbxInventory.WeapUSThompson");
}

exec function BFG()
{
	Level.bWeaponsAreBFG = !Level.bWeaponsAreBFG;
}

defaultproperties
{
}
//=============================================================================
// ClipMarker.
//
// These are markers for the brush clip mode.  You place 2 or 3 of these in
// the level and that defines your clipping plane.
//
// These should NOT be manually added to the level.  The editor adds and
// deletes them on it's own.
//
//=============================================================================
class ClipMarker extends Keypoint
	placeable
	native;



defaultproperties
{
     bEdShouldSnap=True
     Texture=Texture'Engine.S_ClipMarker'
	 bStatic=True
// << GEARBOX/jmw:add - Making ClipMarkers more visible.
	DrawScale=5.0
// GEARBOX >>
}
class ColorModifier extends Modifier
	noteditinlinenew
	native;



var() color Color;
var() bool	RenderTwoSided;
var() bool	AlphaBlend;

defaultproperties
{
	Color=(R=255,G=255,B=255,A=255)
	RenderTwoSided=true
	AlphaBlend=true
}
//=============================================================================
// Console - A quick little command line console that accepts most commands.

//=============================================================================
class Console extends Interaction;



#exec TEXTURE IMPORT NAME=ConsoleBK		FILE=Textures\Black.tga    MIPS=OFF COMPRESS=DXT1
#exec TEXTURE IMPORT NAME=ConsoleBdr	FILE=Textures\White.tga    MIPS=OFF COMPRESS=DXT1

// Constants.
const MaxHistory=16;		// # of command histroy to remember.

// Variables

var globalconfig byte ConsoleKey;			// Key used to bring up the console

var int HistoryTop, HistoryBot, HistoryCur;
var string TypedStr, History[MaxHistory]; 	// Holds the current command, and the history
var int TypedStrPos;		                // Current position in TypedStr
var bool bTyping;							// Turn when someone is typing on the console
var bool bIgnoreKeys;						// Ignore Key presses until a new KeyDown is received

var Font ConsoleFont;
var Color ConsoleColor;

event Initialized()
{
	Super.Initialized();

	ConsoleFont = Font(DynamicLoadObject("t_gbxfonts.WargameFont", class'Font'));
}

event NativeConsoleOpen()
{
}

//-----------------------------------------------------------------------------
// Exec functions accessible from the console and key bindings.

// Begin typing a command on the console.
exec function Type()
{
	if (ViewportOwner.Actor.GameReplicationInfo.bAllowTextChat)
	{
		TypedStr="";
		TypedStrPos=0;
		TypingOpen();
	}
}

exec function Talk()
{
	if (ViewportOwner.Actor.GameReplicationInfo.bAllowTextChat)
	{
		TypedStr="Say ";
		TypedStrPos=4;
		TypingOpen();
	}
}

exec function TeamTalk()
{
	if (ViewportOwner.Actor.GameReplicationInfo.bAllowTextChat)
	{
		TypedStr="TeamSay ";
		TypedStrPos=8;
		TypingOpen();
	}
}

event NotifyLevelChange()
{
}

//-----------------------------------------------------------------------------
// Message - By default, the console ignores all output.
//-----------------------------------------------------------------------------

event Message( coerce string Msg, float MsgLife);

//-----------------------------------------------------------------------------
// Check for the console key.

function bool KeyEvent( EInputKey Key, EInputAction Action, FLOAT Delta )
{
	if( Action!=IST_Press )
		return false;
	else if( Key==ConsoleKey )
	{
		TypingOpen();
		return true;
	}
	else
		return false;

}

//-----------------------------------------------------------------------------
// State used while typing a command on the console.

function TypingOpen()
{
	bTyping = true;

    if( (ViewportOwner != None) && (ViewportOwner.Actor != None) )
	    ViewportOwner.Actor.Typing( bTyping );

	//TypedStr = "";

	GotoState('Typing');
}

function TypingClose()
{
	bTyping = false;

    if( (ViewportOwner != None) && (ViewportOwner.Actor != None) )
	    ViewportOwner.Actor.Typing( bTyping );

	TypedStr="";
	TypedStrPos=0;

    if( GetStateName() == 'Typing' )
        GotoState( '' );
}

state Typing
{
	exec function Type()
	{
		TypedStr="";
		TypedStrPos=0;
		TypingClose();
	}
	function bool KeyType( EInputKey Key, optional string Unicode )
	{
		if (bIgnoreKeys)
			return true;

		if( Key>=0x20 )
		{
			if( Unicode != "" )
				TypedStr = Left(TypedStr, TypedStrPos) $ Unicode $ Right(TypedStr, Len(TypedStr) - TypedStrPos);
			else
				TypedStr = Left(TypedStr, TypedStrPos) $ Chr(Key) $ Right(TypedStr, Len(TypedStr) - TypedStrPos);
			TypedStrPos++;
            return true;
		}

		return false;
	}

	function bool KeyEvent( EInputKey Key, EInputAction Action, FLOAT Delta )
	{
		local string Temp;

		if (Action== IST_PRess)
		{
			bIgnoreKeys=false;
		}

		if( Key==IK_Escape )
		{
			if( TypedStr!="" )
			{
				TypedStr="";
				TypedStrPos=0;
				HistoryCur = HistoryTop;
                return true;
			}
			else
			{
				TypingClose();
			}
		}
		else if( global.KeyEvent( Key, Action, Delta ) )
		{
			return true;
		}
		else if( Action != IST_Press )
		{
			return false;
		}
		else if( Key==IK_Enter )
		{
			if( TypedStr!="" )
			{
				// Print to console.
				Message( TypedStr, 6.0 );

				History[HistoryTop] = TypedStr;
				HistoryTop = (HistoryTop+1) % MaxHistory;

				if ( ( HistoryBot == -1) || ( HistoryBot == HistoryTop ) )
					HistoryBot = (HistoryBot+1) % MaxHistory;

				HistoryCur = HistoryTop;

				// Make a local copy of the string.
				Temp=TypedStr;
				TypedStr="";
				TypedStrPos=0;

				if( !ConsoleCommand( Temp ) )
					Message( Localize("Errors","Exec","Core"), 6.0 );

				Message( "", 6.0 );
			}

			TypingClose();

			return true;
		}
		else if( Key==IK_Up )
		{
			if ( HistoryBot >= 0 )
			{
				if (HistoryCur == HistoryBot)
					HistoryCur = HistoryTop;
				else
				{
					HistoryCur--;
					if (HistoryCur<0)
						HistoryCur = MaxHistory-1;
				}

				TypedStr = History[HistoryCur];
				TypedStrPos = Len(TypedStr);
			}
			return True;
		}
		else if( Key==IK_Down )
		{
			if ( HistoryBot >= 0 )
			{
				if (HistoryCur == HistoryTop)
					HistoryCur = HistoryBot;
				else
					HistoryCur = (HistoryCur+1) % MaxHistory;

				TypedStr = History[HistoryCur];
				TypedStrPos = Len(TypedStr);
			}

		}
		else if( Key==IK_Backspace )
		{
			if( TypedStrPos > 0 )
			{
				TypedStr = Left(TypedStr,TypedStrPos-1)$Right(TypedStr, Len(TypedStr) - TypedStrPos);
				TypedStrPos--;
			}
            return( true );
		}
		else if ( Key==IK_Delete )
		{
			if ( TypedStrPos < Len(TypedStr) )
				TypedStr = Left(TypedStr,TypedStrPos)$Right(TypedStr, Len(TypedStr) - TypedStrPos - 1);
			return true;
		}
		else if ( Key==IK_Left )
		{
			TypedStrPos = Max(0, TypedStrPos - 1);
			return true;
		}
		else if ( Key==IK_Right )
		{
			TypedStrPos = Min(Len(TypedStr), TypedStrPos + 1);
			return true;
		}
		else if ( Key==IK_Home )
		{
			TypedStrPos = 0;
			return true;
		}
		else if ( Key==IK_End )
		{
			TypedStrPos = Len(TypedStr);
			return true;
		}
        return( true );
	}

	function PostRender(Canvas Canvas)
	{
		local float xl,yl;
		local string OutStr;

		// Blank out a space

		Canvas.Style = 1;

		Canvas.Font	 = ConsoleFont;
		OutStr = "(>" @ Left(TypedStr, TypedStrPos) $ "&";
		
		if (TypedStrPos < Len(TypedStr))
		{
			OutStr = OutStr $ Mid(TypedStr, TypedStrPos);
		}
		else
		{
			OutStr = OutStr $ "_";
		}

		Canvas.Strlen(OutStr,xl,yl, 0.7, 0.7);

		Canvas.SetPos(0,Canvas.ClipY-6-yl);
		Canvas.DrawTile( texture 'ConsoleBk', Canvas.ClipX, yl+6,0,0,32,32);

		Canvas.SetPos(0,Canvas.ClipY-8-yl);
		Canvas.DrawColor = ConsoleColor;
		Canvas.DrawTile( texture 'ConsoleBdr', Canvas.ClipX, 2,0,0,32,32);

		Canvas.SetPos(0,Canvas.ClipY-3-yl);
		Canvas.bCenter = False;
		Canvas.DrawText( OutStr, false, 0.7, 0.7, true );
	}

	function BeginState()
	{
		bTyping = true;
		bVisible= true;
		bIgnoreKeys = true;
		HistoryCur = HistoryTop;
	}
	function EndState()
	{
		bTyping = false;
		bVisible = false;
	}
}


defaultproperties
{
	bActive=True
	bVisible=False
	bRequiresTick=True
	HistoryBot=-1

	ConsoleColor = (R=181,G=181,B=153,A=255)
}
//=============================================================================
// Controller, the base class of players or AI.
//
// Controllers are non-physical actors that can be attached to a Pawn to control
// its actions.  PlayerControllers are used by human players to control pawns, while
// AIControFllers implement the artificial intelligence for the pawns they control.
// Controllers take control of a Pawn using their Possess() method, and relinquish
// control of the Pawn by calling UnPossess().
//
// Controllers receive notifications for many of the events occuring for the Pawn they
// are controlling.  This gives the controller the opportunity to implement the behavior
// in response to this event, intercepting the event and superceding the Pawn's default
// behavior.
//
// This is a built-in Unreal class and it shouldn't be modified.
//=============================================================================
class Controller extends Actor
	native
	nativereplication
	abstract;



var Pawn Pawn;

var const int		PlayerNum;			// The player number - per-match player number.

var float			WeaponAccuracyModifierSP_Novice;
var float			WeaponAccuracyModifierSP_Interm;
var float			WeaponAccuracyModifierSP_Advanced;
var float			WeaponAccuracyModifierSP_Veteran;

var		float		SightCounter;		// Used to keep track of when to check player visibility
var		float		FovAngle;			// X field of view angle in degrees, usually 90.
var globalconfig float	Handedness;
var		bool        bIsPlayer;			// Pawn is a player or a player-bot.
var		bool		bGodMode;			// cheat - when true, can't be killed or hurt
var		bool		bGodAllies;			// cheat - when true, player's allies can't be killed or hurt
var		bool		bDemigod;			// GEARBOX/jmw:add - pawns in "Demigod" mode take damage but won't go below 0 health.
var		bool		bIsHumanPlayer;		// Pawn is controlled by a human player, not AI


//AI flags
var const bool		bLOSflag;			// used for alternating LineOfSight traces
var		bool		bAdvancedTactics;	// serpentine movement between pathnodes
var		bool		bCanOpenDoors;
var		bool		bCanDoSpecial;
var		bool		bAdjusting;			// adjusting around obstacle
var		bool		bPreparingMove;		// set true while Pawn sets up for a latent move
var		bool		bControlAnimations;	// take control of animations from Pawn (don't let Pawn play animations based on notifications)
var		bool		bEnemyInfoValid;	// false when change enemy, true when LastSeenPos etc updated
var		bool		bNotifyApex;		// event NotifyJumpApex() when at apex of jump
var		bool		bUsePlayerHearing;
var		bool		bJumpOverWall;		// true when jumping to clear obstacle
var		bool		bEnemyAcquired;
var		bool		bSoaking;			// pause and focus on this bot if it encounters a problem
var		bool		bHuntPlayer;		// hunting player
var		bool		bAllowedToTranslocate;
var		bool		bAllowedToImpactJump;

// Input buttons.
var input byte
	bMeleeFire, bRun, bDuck, bFire, bAltFire, bHoldBreath;

var		vector		AdjustLoc;			// location to move to while adjusting around obstacle

var const Controller	nextController; // chained Controller list

var		float 		Stimulus;			// Strength of stimulus - Set when stimulus happens

// Navigation AI
var 	float		MoveTimer;
var 	ActorLite	MoveTarget;		// actor being moved toward
var		vector	 	Destination;	// location being moved toward
var	 	vector		FocalPoint;		// location being looked at
var		ActorLite	Focus;			// actor being looked at
var		Mover		PendingMover;	// mover Pawn is waiting for to complete its move
var		ActorLite	GoalList[4];	// used by navigation AI - list of intermediate goals
var NavigationPoint home;			// set when begin play, used for retreating and attitude checks
var	 	float		MinHitWall;		// Minimum HitNormal dot Velocity.Normal to get a HitWall event from the physics
var		float		RespawnPredictionTime;	// how far ahead to predict respawns when looking for inventory
var		int			AcquisitionYawRate;

// Enemy information
var	 	Pawn    	Enemy;
var		Actor		Target;
var		vector		LastSeenPos; 	// enemy position when I last saw enemy (auto updated if EnemyNotVisible() enabled)
var		vector		LastSeeingPos;	// position where I last saw enemy (auto updated if EnemyNotVisible enabled)
var		float		LastSeenTime;

var string	VoiceType;			// for speech
var float	OldMessageTime;		// to limit frequency of voice messages

// Route Cache for Navigation
var ActorLite	RouteCache[16];
var ReachSpec	CurrentPath;
var vector		CurrentPathDir;
var ReachSpec	NextRoutePath;
var ActorLite	RouteGoal; //final destination for current route
var float		RouteDist;	// total distance for current route
var	float		LastRouteFind;	// time at which last route finding occured

// Replication Info
var() class<PlayerReplicationInfo> PlayerReplicationInfoClass;
var PlayerReplicationInfo PlayerReplicationInfo;

var class<Pawn> PawnClass;			// class of Pawn to spawn (for players)
var class<Pawn> PreviousPawnClass;	// Holds the player's previous class

var float GroundPitchTime;
var vector ViewX, ViewY, ViewZ;	// Viewrotation encoding for PHYS_Spider

var NavigationPoint StartSpot;  // where player started the match

// for monitoring the position of a Pawn
var		vector		MonitorStartLoc;	// used by latent function MonitorPawn()
var		Pawn		MonitoredPawn;		// used by latent function MonitorPawn()
var		float		MonitorMaxDistSq;

var		AvoidMarker	FearSpots[2];	// avoid these spots when moving

var const ActorLite LastFailedReach;	// cache to avoid trying failed actorreachable more than once per frame
var const float FailedReachTime;
var const vector FailedReachLocation;

var class<Weapon> LastPawnWeapon;				// used by game stats

// PSV: 6/10/2004 MP field
var PlayerStart LastStartSpot;	// used for reinforcement spawning

const LATENT_MOVETOWARD = 503; // LatentAction number for Movetoward() latent function

// GBX:PAD: These values are used to apply the concept of fatigue to any AI or player controlled object
var float m_flFatigue;					// Amount of fatigue (e.g. factor of how long they've been running, if crouching, etc) the player has
//var float m_flNextFatigueAddTime;		// Next time we can add to the fatigue value
//var float m_flNextFatigueSubTime;		// Next time we can subtract from the fatigue value

//const FATIGUE_INCREMENT_DELAY=0.1;
//const FATIGUE_DECREMENT_DELAY=0.3;

const ACCURATE_FIRST_SHOT_INTERVAL = 0.5;
var float LastAccurateFirstShotTime;

replication
{
	reliable if( bNetDirty && (Role==ROLE_Authority) )
		PlayerReplicationInfo, Pawn;
	reliable if( bNetDirty && (Role== ROLE_Authority) && bNetOwner )
		PawnClass;

	// Functions the server calls on the client side.
	reliable if( RemoteRole==ROLE_AutonomousProxy )
		ClientGameEnded, ClientDying, ClientSetRotation, ClientSetLocation,
		ClientSwitchToBestWeapon, ClientSetWeapon;
	reliable if ( (!bDemoRecording || (bClientDemoRecording && bClientDemoNetFunc)) && Role == ROLE_Authority )
		ClientVoiceMessage;

	// Functions the client calls on the server.
	unreliable if( Role<ROLE_Authority )
		SendVoiceMessage;
	reliable if ( Role < ROLE_Authority )
		ServerRestartPlayer, SetPawnClass;
}

// Latent Movement.
// Note that MoveTo sets the actor's Destination, and MoveToward sets the
// actor's MoveTarget.  Actor will rotate towards destination unless the optional ViewFocus is specified.

native(500) final latent function MoveTo( vector NewDestination, optional ActorLite ViewFocus, optional bool bShouldWalk);
native(502) final latent function MoveToward(ActorLite NewTarget, optional ActorLite ViewFocus, optional float DestinationOffset, optional bool bUseStrafing, optional bool bShouldWalk);
native(508) final latent function FinishRotation();


// native AI functions
/* LineOfSightTo() returns true if any of several points of Other is visible
  (origin, top, bottom)
*/
native(514) final function bool LineOfSightTo(ActorLite Other);

// << GEARBOX/jmw:add - FEATURE: Line-of-sight and peripheral vision checking for arbitrary point in space.
native final function bool CanSeeLocation(vector Loc);
// GEARBOX >>


/* CanSee() similar to line of sight, but also takes into account Pawn's peripheral vision
*/
native(533) final function bool CanSee(Pawn Other);

//Navigation functions - return the next path toward the goal
native(518) final function ActorLite FindPathTo(vector aPoint);
native(517) final function ActorLite FindPathToward(ActorLite anActor, optional bool bWeightDetours);
native final function ActorLite FindPathToIntercept(Pawn P, ActorLite RouteGoal, optional bool bWeightDetours);
native final function ActorLite FindPathTowardNearest(class<ActorLite> GoalClass, optional bool bWeightDetours);
native(525) final function ActorLite FindRandomDest();

native(523) final function vector EAdjustJump(float BaseZ, float XYSpeed);

//Reachable returns whether direct path from Actor to aPoint is traversable
//using the current locomotion method
native(521) final function bool pointReachable(vector aPoint);
native(520) final function bool actorReachable(ActorLite anActor);

/* PickWallAdjust()
Check if could jump up over obstruction (only if there is a knee height obstruction)
If so, start jump, and return current destination
Else, try to step around - return a destination 90 degrees right or left depending on traces
out and floor checks
*/
native(526) final function bool PickWallAdjust(vector HitNormal);

/* WaitForLanding()
latent function returns when Pawn is on ground (no longer falling)
*/
native(527) final latent function WaitForLanding();

native(540) final function ActorLite FindBestInventoryPath(out float MinWeight);

native(529) final function AddController();
native(530) final function RemoveController();

// Pick best Pawn target
native(531) final function Pawn PickTarget(out float bestAim, out float bestDist, vector FireDir, vector projStart, float MaxRange);
native(534) final function actor PickAnyTarget(out float bestAim, out float bestDist, vector FireDir, vector projStart);

native final function bool InLatentExecution(int LatentActionNumber); //returns true if controller currently performing latent action specified by LatentActionNumber
// Force end to sleep
native function StopWaiting();
native function EndClimbLadder();
native function bool IsFacingFocus();

event MayFall(); //return true if allowed to fall - called by engine when Pawn is about to fall

function PendingStasis()
{
	bStasis = true;
	Pawn = None;
}

/* DisplayDebug()
list important controller attributes on canvas
*/
function DisplayDebug(Canvas Canvas, out float YL, out float YPos)
{
	if ( Pawn == None )
	{
		Super.DisplayDebug(Canvas,YL,YPos);
		return;
	}

	Canvas.SetDrawColor(255,0,0);
	Canvas.DrawText("CONTROLLER "$GetItemName(string(self))$" Pawn "$GetItemName(string(Pawn)));
	YPos += YL;
	Canvas.SetPos(4,YPos);

	if ( Enemy != None )
		Canvas.DrawText("     STATE: "$GetStateName()$" Timer: "$TimerCounter$" Enemy " $ Enemy $ " (" $ Enemy.GetHumanReadableName() $ ")", false);
	else
		Canvas.DrawText("     STATE: "$GetStateName()$" Timer: "$TimerCounter$" NO Enemy ", false);
	YPos += YL;
	Canvas.SetPos(4,YPos);

	if ( PlayerReplicationInfo == None )
		Canvas.DrawText("     NO PLAYERREPLICATIONINFO", false);
	else
		PlayerReplicationInfo.DisplayDebug(Canvas,YL,YPos);

	YPos += YL;
	Canvas.SetPos(4,YPos);

	if ( Level.TheAISpeechManager != None )
	{
		Level.TheAISpeechManager.DisplayDebug( Canvas, YL, YPos );
	}
}

simulated function String GetHumanReadableName()
{
	if ( PlayerReplicationInfo != None )
		return PlayerReplicationInfo.PlayerName;
	return GetItemName(String(self));
}

event rotator GetViewRotation()
{
	return Rotation;
}

/* Reset()
reset actor to initial state
*/
function Reset()
{
	Super.Reset();
	Enemy = None;
	LastSeenTime = 0;
	StartSpot = None;
}

function bool AvoidCertainDeath()
{
	return false;
}

/* ClientSetLocation()
replicated function to set location and rotation.  Allows server to force new location for
teleports, etc.
*/
function ClientSetLocation( vector NewLocation, rotator NewRotation )
{
	SetRotation(NewRotation);
	If ( (Rotation.Pitch > RotationRate.Pitch)
		&& (Rotation.Pitch < 65536 - RotationRate.Pitch) )
	{
		If (Rotation.Pitch < 32768)
			NewRotation.Pitch = RotationRate.Pitch;
		else
			NewRotation.Pitch = 65536 - RotationRate.Pitch;
	}
	if ( Pawn != None )
	{
		NewRotation.Roll  = 0;
		Pawn.SetRotation( NewRotation );
		Pawn.SetLocation( NewLocation );
	}
}

/* ClientSetRotation()
replicated function to set rotation.  Allows server to force new rotation.
*/
function ClientSetRotation( rotator NewRotation )
{
	SetRotation(NewRotation);
	if ( Pawn != None )
	{
		NewRotation.Pitch = 0;
		NewRotation.Roll  = 0;
		Pawn.SetRotation( NewRotation );
	}
}

function ClientDying(class<DamageType> DamageType, vector HitLocation)
{
	//Log( " Controller::ClientDying()", 'MP' );
	if ( Pawn != None )
	{
		Pawn.PlayDying(DamageType, HitLocation);
		Pawn.GotoState('Dying');
	}
}

/* AIHearSound()
Called when AI controlled Pawn would hear a sound.  Default AI implementation uses MakeNoise()
interface for hearing appropriate sounds instead
*/
event AIHearSound (
	actor Actor,
	int Id,
	sound S,
	vector SoundLocation,
	vector Parameters,
	bool Attenuate
);

event SoakStop(string problem);

function Possess(Pawn aPawn)
{
	aPawn.PossessedBy(self);
	Pawn = aPawn;
	if ( PlayerReplicationInfo != None )
		PlayerReplicationInfo.bIsFemale = Pawn.bIsFemale;
	// preserve Pawn's rotation initially for placed Pawns
	FocalPoint = Pawn.Location + 512*vector(Pawn.Rotation);
	Restart();
}

// unpossessed a Pawn (not because Pawn was killed)
function UnPossess()
{
	//Log( " Controller::UnPossess()", 'MP' );
    if ( Pawn != None )
        Pawn.UnPossessed();
    Pawn = None;
}

function WasKilledBy(Controller Other);

function class<Weapon> GetLastWeapon()
{
	if ( (Pawn == None) || (Pawn.Weapon == None) )
		return LastPawnWeapon;
	return Pawn.Weapon.Class;
}

/* PawnDied()
 unpossess a Pawn (because Pawn was killed)
 */
function PawnDied(Pawn P)
{
	//Log( " Controller::PawnDied()", 'MP' );
	
	if ( Pawn != P )
		return;

	if ( Pawn != None )
	{
		SetLocation(Pawn.Location);
		Pawn.UnPossessed();
	}
	Pawn = None;
	PendingMover = None;
	if ( bIsPlayer )
    {
        if ( !IsInState('GameEnded') )
		GotoState('Dead'); // can respawn
    }
	else
		Destroy();
}

function Restart()
{
	Enemy = None;
}

event LongFall(); // called when latent function WaitForLanding() doesn't return after 4 seconds

// notifications of Pawn events (from C++)
// if return true, then Pawn won't get notified
event bool NotifyPhysicsVolumeChange(PhysicsVolume NewVolume);
event bool NotifyHeadVolumeChange(PhysicsVolume NewVolume);
event bool NotifyLanded(vector HitNormal);
event bool NotifyHitWall(vector HitNormal, actor Wall);
event bool NotifyBump(Actor Other);
event NotifyHitMover(vector HitNormal, mover Wall);
event NotifyJumpApex();
event NotifyMissedJump();

// notifications called by Pawn in script
function NotifyAddInventory(inventory NewItem);
function NotifyTakeHit(Pawn InstigatedBy, vector HitLocation, int Damage, class<DamageType> damageType, vector Momentum)
{
	if ( (instigatedBy != None) && (instigatedBy != Pawn) )
		damageAttitudeTo(instigatedBy, Damage);
}

function SetFall();	//about to fall
function PawnIsInPain(PhysicsVolume PainVolume);	// called when Pawn is taking pain volume damage

event PreBeginPlay()
{
	AddController();
	Super.PreBeginPlay();
	if ( bDeleteMe )
		return;

	SightCounter = 0.2 * FRand();  //offset randomly
}

event PostBeginPlay()
{
	Super.PostBeginPlay();
	if ( !bDeleteMe && bIsPlayer && (Role == ROLE_Authority) )
	{
		PlayerReplicationInfo = Spawn(PlayerReplicationInfoClass, Self,,vect(0,0,0),rot(0,0,0));
		InitPlayerReplicationInfo();
	}
}

function InitPlayerReplicationInfo()
{
	if (PlayerReplicationInfo.PlayerName == "")
		PlayerReplicationInfo.SetPlayerName(class'GameInfo'.Default.DefaultPlayerName);
}

function bool SameTeamAs(Controller C)
{
	if ( (PlayerReplicationInfo == None) || (C == None) || (C.PlayerReplicationInfo == None)
		|| (PlayerReplicationInfo.Team == None) )
		return false;
	return Level.Game.IsOnTeam(C,PlayerReplicationInfo.Team.TeamIndex);
}

function HandlePickup(Pickup pick, optional int Amount)
{
	if ( MoveTarget == pick )
	{
		if ( pick.MyMarker != None )
		{
			MoveTarget = pick.MyMarker;
			Pawn.Anchor = pick.MyMarker;
			MoveTimer = 0.5;
		}
		else
		MoveTimer = -1.0;
}
}

simulated event Destroyed()
{
	if ( Role < ROLE_Authority )
    {
    	Super.Destroyed();
		return;
    }

	RemoveController();

	if ( bIsPlayer && (Level.Game != None) )
		Level.Game.logout(self);
	if ( PlayerReplicationInfo != None )
	{
		if ( !PlayerReplicationInfo.bOnlySpectator && (PlayerReplicationInfo.Team != None) )
			PlayerReplicationInfo.Team.RemoveFromTeam(self);
		PlayerReplicationInfo.Destroy();
		PlayerReplicationInfo = None;
	}
	Super.Destroyed();
}

event bool AllowDetourTo(ActorLite N)
{
	return true;
}

simulated function bool AllowFire()
{
	return true;
}

/* AdjustView()
by default, check and see if Pawn still needs to update eye height
(only if some playercontroller still has Pawn as its viewtarget)
Overridden in playercontroller
*/
function AdjustView( float DeltaTime )
{
	local Controller C;

	for ( C=Level.ControllerList; C!=None; C=C.NextController )
		if ( C.IsA('PlayerController') && (PlayerController(C).ViewTarget == Pawn) )
			return;

	Pawn.bUpdateEyeHeight =false;
	Pawn.Eyeheight = Pawn.BaseEyeheight;
}

function bool WantsSmoothedView()
{
	return ( (Pawn != None) && ((Pawn.Physics==PHYS_Walking) || (Pawn.Physics==PHYS_Spider)) && !Pawn.bJustLanded );
}

function GameHasEnded()
{
	if ( Pawn != None )
		Pawn.bNoWeaponFiring = true;
	GotoState('GameEnded');
}

function ClientGameEnded()
{
	GotoState('GameEnded');
}

simulated event RenderOverlays( canvas Canvas );

/* GetFacingDirection()
returns direction faced relative to movement dir

0 = forward
16384 = right
32768 = back
49152 = left
*/
function int GetFacingDirection()
{
	return 0;
}

//------------------------------------------------------------------------------
// Speech related

function byte GetMessageIndex(name PhraseName)
{
	return 0;
}

function SendMessage(PlayerReplicationInfo Recipient, name MessageType, byte MessageID, float Wait, name BroadcastType)
{
	SendVoiceMessage(PlayerReplicationInfo, Recipient, MessageType, MessageID, BroadcastType);
}

function bool AllowVoiceMessage(name MessageType)
{
	if ( Level.TimeSeconds - OldMessageTime < 10 )
		return false;
	else
		OldMessageTime = Level.TimeSeconds;

	return true;
}

function SendVoiceMessage(PlayerReplicationInfo Sender, PlayerReplicationInfo Recipient, name messagetype, byte messageID, name broadcasttype)
{
	local Controller P;

	if ( !AllowVoiceMessage(MessageType) )
		return;

	for ( P=Level.ControllerList; P!=None; P=P.NextController )
	{
		if ( PlayerController(P) != None )
		{
				if ( (broadcasttype == 'GLOBAL') || !Level.Game.bTeamGame )
					P.ClientVoiceMessage(Sender, Recipient, messagetype, messageID);
				else if ( Sender.Team == P.PlayerReplicationInfo.Team )
					P.ClientVoiceMessage(Sender, Recipient, messagetype, messageID);
			}
		else if ( (messagetype == 'ORDER') && ((Recipient == None) || (Recipient == P.PlayerReplicationInfo)) )
			P.BotVoiceMessage(messagetype, messageID, self);
	}
}

function ClientVoiceMessage(PlayerReplicationInfo Sender, PlayerReplicationInfo Recipient, name messagetype, byte messageID);
function BotVoiceMessage(name messagetype, byte MessageID, Controller Sender);

//***************************************************************
// interface used by ScriptedControllers to query pending controllers

function bool WouldReactToNoise( float Loudness, Actor NoiseMaker)
{
	return false;
}

function bool WouldReactToSeeing(Pawn Seen)
{
	return false;
}

//***************************************************************
// AI related

/* AdjustToss()
return adjustment to Z component of aiming vector to compensate for arc given the target
distance
*/
function vector AdjustToss(float TSpeed, vector Start, vector End, bool bNormalize)
{
	local vector Dest2D, Result, Vel2D;
	local float Dist2D;

	if ( Start.Z > End.Z + 64 )
	{
		Dest2D = End;
		Dest2D.Z = Start.Z;
		Dist2D = VSize(Dest2D - Start);
		TSpeed *= Dist2D/VSize(End - Start);
		Result = SuggestFallVelocity(Dest2D,Start,TSpeed,TSpeed);
		Vel2D = result;
		Vel2D.Z = 0;
		Result.Z = Result.Z + (End.Z - Start.Z) * VSize(Vel2D)/Dist2D;
	}
	else
	{
		Result = SuggestFallVelocity(End,Start,TSpeed,TSpeed);
	}
	if ( bNormalize )
		return TSpeed * Normal(Result);
	else
		return Result;
}

event PrepareForMove(ActorLite Goal, ReachSpec Path);
function WaitForMover(Mover M);
function MoverFinished();
function UnderLift(Mover M);

function FearThisSpot(AvoidMarker aSpot)
{
	local int i;

	if ( Pawn == None )
		return;
	if ( !LineOfSightTo(aSpot) )
		return;
	for ( i=0; i<2; i++ )
		if ( FearSpots[i] == None )
		{
			FearSpots[i] = aSpot;
			return;
		}
	for ( i=0; i<2; i++ )
		if ( VSize(Pawn.Location - FearSpots[i].Location) > VSize(Pawn.Location - aSpot.Location) )
		{
			FearSpots[i] = aSpot;
			return;
		}
}

event float Desireability(Pickup P)
{
	return P.BotDesireability(Pawn);
}

/* called before start of navigation network traversal to allow setup of transient navigation flags
*/
event SetupSpecialPathAbilities();

event HearNoise( float Loudness, Actor NoiseMaker);
event SeePlayer( Pawn Seen );	// called when a player (bIsPlayer==true) Pawn is seen
event EnemyNotVisible();

function ShakeView( float shaketime, float RollMag, vector OffsetMag, float RollRate, vector OffsetRate, float OffsetTime);

function NotifyKilled(Controller Killer, Controller Killed, Pawn Other)
{
	if ( Enemy == Other )
		Enemy = None;
}

function damageAttitudeTo(Pawn Other, float Damage);
function float AdjustDesireFor(Pickup P);
function bool FireWeaponAt(Actor A);

function StopFiring()
{
	bFire = 0;
	bAltFire = 0;
	bMeleeFire = 0;
}

simulated function float RateWeapon(Weapon w)
{
    return 0.0;
}

function float WeaponPreference(Weapon W)
{
	return 0.0;
}

// Override this function.
function Rotator AdjustAimNew(Ammunition Ammo, Vector ProjStart, Rotator AimRotator, optional out int bSkipDoTrace)
{
//	return Rotation;
	// GBX:PAD: This is actually a better default since it "should" be a more accurate rotation to fire at.  The
	// old code would cause the scripted pawns to fire straight out, rather than at an angle.
	return AimRotator;
}

// Used by AdjustAimNew() in WargamePlayerController.
function int CalculateHumanWeaponError( bool bIsSighted, Weapon TheWeapon, out int ConeOfFire )
{
	local int MinError, MaxError, FinalError;
	local bool bIsMultiplayer;	
	local float RandVal;

	bIsMultiplayer = ( Level.NetMode != NM_Standalone );

	MaxError = 0;

	// Set the min / max depending on whether this pawn is human- or AI-controlled, what the pawn's posture is, etc.	
	MinError = TheWeapon.FireMode[0].AimErrorMin_Human;
	
	if ( VSize( Pawn.Velocity ) <= 0.01 )
	{
		// stationary (non-moving).
		if( Pawn.bIsCrouched )
			MaxError += TheWeapon.FireMode[0].AimErrorMax_Human_Crouched;
		else
			MaxError += TheWeapon.FireMode[0].AimErrorMax_Human_Standing;
	}
	else
	{
		// moving.
		if ( Pawn.bIsCrouched )
			MaxError += TheWeapon.FireMode[0].AimErrorMax_Human_MovingSlow;
		else
			MaxError += TheWeapon.FireMode[0].AimErrorMax_Human_MovingFast;
	}

	// Human-controlled weapons behave differently when zoomed in.  They have one simple, fixed rating for error.
	// The viewmodel's bob-and-weave accounts for fatigue differences.
	if ( bIsSighted )
	{
		// Some weapons (machine guns) have an accurate first shot
		// MP decided it doesn't want this behavior 2005-02-05 JWS
		if( !Level.m_bMPStyleWeapons && TheWeapon.FireMode[0].bAccurateFirstShot && TheWeapon.FireMode[0].HoldTime > 0.0 && Level.TimeSeconds - LastAccurateFirstShotTime  > ACCURATE_FIRST_SHOT_INTERVAL )
		{
			MinError = TheWeapon.FireMode[0].AimErrorMin_Human_FirstShot;
			MaxError = TheWeapon.FireMode[0].AimErrorMax_Human_FirstShot;
			
			LastAccurateFirstShotTime = Level.TimeSeconds;
		}
		else
		{
			MaxError = TheWeapon.FireMode[0].AimErrorMax_Human_Zoomed;
			MinError = TheWeapon.FireMode[0].AimErrorMin_Human_Zoomed;
			RandVal = FRand();
		}
	}

	// Sanity check.
	if ( MinError > MaxError )
		MaxError = MinError;

	// Apply fatigue to find the Cone of Fire.
	// SJP 9/6/2004: For players, the zoomed view rotation is affected by fatigue now; shouldn't compound the error to the cone
	if( bIsSighted )
	{
		ConeOfFire = MinError;
	}
	else
	{
		ConeOfFire = MinError + m_flFatigue * ( MaxError - MinError );
	}


	// Use a random number to find the Final Error.	
	RandVal = FRand();
	FinalError = RandVal * ConeOfFire;

	return FinalError;
}

// Apply our final error value to the aim-rotator to determine
// where the shot will actually travel.
function ApplyAccuracy( out Rotator AimRotator, int FinalError )
{
	local Vector NewAimVect;
	local Rotator NewAimRot, NewAimRot2;

	// Use "polar coordinates" to determine the new aim rotator:
	// Pitch the input rotator upwards by the FinalError,
	// then roll the resulting rotator around some random amount (0 to 360 degrees).
	// The resulting vector will fall somewhere within a circle centered around the
	// starting rotator and having a radius of FinalError.
	//
	NewAimRot.Pitch = FinalError;
	NewAimRot2.Roll = FRand() * 65535;
	
	NewAimVect = Vector( NewAimRot ) >> NewAimRot2;
	AimRotator = Rotator( NewAimVect >> AimRotator );	
}


/* ReceiveWarning()
 AI controlled creatures may duck
 if not falling, and projectile time is long enough
 often pick opposite to current direction (relative to shooter axis)
*/
function ReceiveWarning(Pawn shooter, float projSpeed, vector FireDir)
{
}

exec function SwitchToBestWeapon()
{
	local float rating;

	if ( Pawn == None || Pawn.Inventory == None )
		return;

    if ( (Pawn.PendingWeapon == None) || (AIController(self) != None) )
    {
		Pawn.PendingWeapon = Pawn.Inventory.RecommendWeapon(rating);
		if ( Pawn.PendingWeapon == Pawn.Weapon )
		{
			Pawn.PendingWeapon = None;
		}
		if ( Pawn.PendingWeapon == None )
		{
			return;
		}
    }

	StopFiring();

	if ( Pawn.Weapon == None )
		Pawn.ChangedWeapon();
	else if ( Pawn.Weapon != Pawn.PendingWeapon )
    {
		Pawn.Weapon.PutDown();
    }
}

// server calls this to force client to switch
function ClientSwitchToBestWeapon()
{
    SwitchToBestWeapon();
}

function ClientSetWeapon( class<Weapon> WeaponClass )
{
    local Inventory Inv;
	local int Count;

    for( Inv = Pawn.Inventory; Inv != None; Inv = Inv.Inventory )
    {
		Count++;
		if ( Count > 1000 )
			return;
        if( !ClassIsChildOf( Inv.Class, WeaponClass ) )
            continue;

	    if( Pawn.Weapon == None )
        {
            Pawn.PendingWeapon = Weapon(Inv);
    		Pawn.ChangedWeapon();
        }
	    else if ( Pawn.Weapon != Weapon(Inv) )
        {
    		Pawn.PendingWeapon = Weapon(Inv);
			Pawn.Weapon.PutDown();
		}

        return;
    }
}

simulated function bool CanFire()
{
    return true;
}

function SetPawnClass(string inClass, string inCharacter)
{
    local class<Pawn> pClass;
    pClass = class<Pawn>(DynamicLoadObject(inClass, class'Class'));
    if ( pClass != None )
        PawnClass = pClass;
}

function bool CheckFutureSight(float DeltaTime)
{
	return true;
}

function ChangedWeapon()
{
	if ( Pawn.Weapon != None )
		LastPawnWeapon = Pawn.Weapon.Class;
}

function ServerReStartPlayer()
{
	if ( Level.NetMode == NM_Client )
		return;
	if ( Pawn != None )
		ServerGivePawn();
}

function ServerGivePawn();

event MonitoredPawnAlert();

function StartMonitoring(Pawn P, float MaxDist)
{
	MonitoredPawn = P;
	MonitorStartLoc = P.Location;
	MonitorMaxDistSq = MaxDist * MaxDist;
}

function bool AutoTaunt()
{
	return false;
}

function bool DontReuseTaunt(int T)
{
	return false;
}

function bool CanSeeOrSuppress( Pawn Other, out Vector SeeLocation, out int bIsHeadShot, out Vector SuppressLocation, out Vector FailLoc, optional int Posture );
function bool CanSeeOrSuppressFromPoint( Pawn Other, Vector FromLocation, out Vector SeeLocation, out int bIsHeadShot, out Vector SuppressLocation, out Vector FailLoc, optional int Posture );
function bool ApproveShot( Rotator AimRotator ) { return true; }	// Override me.

// **********************************************
// Controller States

State Dead
{
ignores SeePlayer, HearNoise, KilledBy;

	function PawnDied(Pawn P)
	{
		if ( Level.NetMode != NM_Client )
			warn(self$" Pawndied while dead");
	}

	function ServerReStartPlayer()
	{
		if ( Level.NetMode == NM_Client )
			return;
		Level.Game.RestartPlayer(self);
	}
}

state GameEnded
{
ignores SeePlayer, HearNoise, KilledBy, NotifyBump, HitWall, NotifyPhysicsVolumeChange, NotifyHeadVolumeChange, Falling, TakeDamage, ReceiveWarning;

	function BeginState()
	{
		if ( Pawn != None )
		{
			if ( Pawn.Weapon != None )
				Pawn.Weapon.HolderDied();
			Pawn.bPhysicsAnimUpdate = false;
			Pawn.StopAnimating();
			Pawn.SimAnim.AnimRate = 0;
			Pawn.SetCollision(true,false,false);
			Pawn.Velocity = vect(0,0,0);
			Pawn.SetPhysics(PHYS_None);
			Pawn.UnPossessed();
			Pawn.bIgnoreForces = true;
		}
		if ( !bIsPlayer )
			Destroy();
	}
}

// GBX:PAD: These functions are used to maintain the fatigue values for this controller
/*
function AddFatigue( float flFatiguePercent )
{
	if (Level.TimeSeconds > m_flNextFatigueAddTime)
	{
		m_flFatigue = m_flFatigue + flFatiguePercent;
		
		m_flFatigue = FClamp( m_flFatigue, 0.0, 1.0 );
		
		m_flNextFatigueAddTime = Level.TimeSeconds + FATIGUE_INCREMENT_DELAY;
		if (Pawn.Weapon != None)
			Pawn.Weapon.SetFatigue( m_flFatigue );
	}
}
*/

// GBX:naj - this function is a wrapper for the IncreaseFatigue function, but with a
// major difference: The fatigue rate is modified in proportion to the direction that 
// the pawn is moving relative to some actor.  If the pawn is moving "in line" with
// the actor (i.e. directly towards or away it), less fatigue is applied than if
// the pawn was moving laterally to the actor.
function IncreaseFatigueMovement( float FatigueRate, float DeltaTime, Actor FocusActor )
{
	local float dotProd;

	dotProd = Normal( FocusActor.Location - Pawn.Location ) dot Normal( Pawn.Velocity );
	
	FatigueRate *= 1.0 - FClamp( dotProd, 0.0, 0.99 );	// Using .99 to ensure that the fatigue rate is always > 0.
	IncreaseFatigue( FatigueRate, DeltaTime );
}

// GBX:naj - this function is used to increase fatigue continuously (e.g. while sprinting)
function IncreaseFatigue( float FatigueRate, float DeltaTime )
{
	m_flFatigue += ( FatigueRate * DeltaTime );
	m_flFatigue = FClamp( m_flFatigue, 0.0, 1.0 );

	// Set the weapon fatigue to match the Controller's.
	if (Pawn.Weapon != None)
	{
		Pawn.Weapon.SetFatigue( m_flFatigue );
	}
}

// GBX:naj - this function is used for one-time fatigue increases (e.g. changing posture or becoming suppressed)
native function JogFatigue( float JogAmount );

/*
function SubtractFatigue( float flFatiguePercent )
{
	if ((m_flFatigue > 0.0) && (Level.TimeSeconds > m_flNextFatigueSubTime))
	{
		m_flFatigue = m_flFatigue - flFatiguePercent;
		
		m_flFatigue = FClamp( m_flFatigue, 0.0, 1.0 );

		m_flNextFatigueSubTime = Level.TimeSeconds + FATIGUE_DECREMENT_DELAY;
		if (Pawn.Weapon != None)
			Pawn.Weapon.SetFatigue( m_flFatigue );
	}
}
*/

function float GetFatigue()
{
	return m_flFatigue;
}

function DoFatigueRecovery( float RecoveryRate, float DeltaTime )
{
	// GBX:PAD: For now, just double the recovery rate on fatigue if the player is holding their breath.
	if (bHoldBreath > 0)
	{
		RecoveryRate = RecoveryRate * 2.0f;
	}
	m_flFatigue -= ( RecoveryRate * DeltaTime );
	//m_flFatigue = FClamp( m_flFatigue, 0.0, 1.0 );
	ClampFatigueSpecial();

	// Set the weapon fatigue to match the Controller's.
	if (Pawn.Weapon != None)
	{
		Pawn.Weapon.SetFatigue( m_flFatigue );
	}
}

function ClampFatigueSpecial()
{
	// Override this function in Mind to provide suppression-specific clamping.
	m_flFatigue = FClamp( m_flFatigue, 0.0, 1.0 );
}

simulated function bool ReloadAfterWeaponFire()
{
	return false;
}

defaultproperties
{
	RotationRate=(Pitch=3072,Yaw=30000,Roll=2048)
	AcquisitionYawRate=20000
	FovAngle=+00090.000000
	bHidden=true
	bHiddenEd=true
	PlayerReplicationInfoClass=Class'Engine.PlayerReplicationInfo'
	MinHitWall=-1.f
	bIsHumanPlayer=false

	WeaponAccuracyModifierSP_Novice=1.0
	WeaponAccuracyModifierSP_Interm=1.0
	WeaponAccuracyModifierSP_Advanced=1.0
	WeaponAccuracyModifierSP_Veteran=1.0
}
class Crushed extends DamageType
	abstract;



defaultproperties
{
	DeathString="%o was crushed by %k."
	MaleSuicide="%o was crushed."
	FemaleSuicide="%o was crushed."

   bAlwaysGibs=true
}
class Cubemap extends Texture
	native
	noexport;



var() Texture Faces[6];


var transient int	CubemapRenderInterface;
//=============================================================================
// Cue: Sound cue object
// This is a built-in Unreal class and it shouldn't be modified.
//
// Notes.
//
//	PLAYLIST_SHUFFLE, PLAYLIST_PARAMETER_CONTROLLED, and PLAYLIST_ORDERED_FROM_RANDOM
//	are not supported.
//
// 	Pitch variation is clamped 0.5 - 2.0
//	Volume variation is clamped 0.0 - 1.0
//=============================================================================
class Cue extends Object
	editinlinenew
	native;

// Generic axis enum.
enum EPlaylist
{
	PLAYLIST_RANDOM_NO_REPEATS,  
	PLAYLIST_ORDERED,			 		
	PLAYLIST_SHUFFLE,            
	PLAYLIST_PARAMETER_CONTROLLED,
	PLAYLIST_RANDOM,
	PLAYLIST_ORDERED_FROM_RANDOM
};

struct native CueSound
{
	var ()	sound	Sound;
	var ()	float	Weight;
};

var (Cue)	array<CueSound>	Sounds;			
var (Cue)	EPlaylist		VariationType;
var (Cue)	float			MasterPitch;
var (Cue)	float			PitchLow;
var (Cue)	float			PitchHigh;
var (Cue)	float			MasterVolume;
var (Cue)	float			VolumeLow;
var (Cue)	float			VolumeHigh;
var (Cue)	byte			UsePitchVariation;
var (Cue)	byte			UseVolumeVariation;
var (Cue)   float           MinimumDistance;
var (Cue)   float           MaximumDistance;
var			int				iPlaylistFlags;		
var			int				iNumSoundsPlayed;

function bool IsEmpty()
{
	return (Sounds.Length == 0);
}

function sound GetFirstSound()
{
	return (Sounds[0]).Sound;
}

cpptext
{
	void Serialize(FArchive& Ar);
	void PostLoad();
	void Destroy();
	void PostEditChange();
	FLOAT GetPitchRange( void );
	FLOAT GetVolumeRange( void );
	USound* GetNextSound( void );
	FLOAT GetNextPitch( FLOAT pitch = 1.0f );
	FLOAT GetNextVolume( FLOAT vol = 1.0f );
}

defaultproperties
{
	VariationType = PLAYLIST_ORDERED
	MasterPitch = 1.0
	PitchLow = 0
	PitchHigh = 0
	MasterVolume = 0.0	// 0db by default
	VolumeLow = 0
	VolumeHigh = 0
	UsePitchVariation = 0
	UseVolumeVariation = 0
	MinimumDistance = 1.0
	MaximumDistance = 100000.0
	iPlaylistFlags = 0
	iNumSoundsPlayed = 0
}
//=============================================================================
// DamageType, the base class of all damagetypes.
// this and its subclasses are never spawned, just used as information holders
//=============================================================================
class DamageType extends Actor
	native
	abstract;



// Description of a type of damage.
var() localized string     DeathString;	 					// string to describe death by this type of damage
var() localized string		FemaleSuicide, MaleSuicide;
var() float                ViewFlash;    					// View flash to play.
var() vector               ViewFog;      					// View fog to play.
var() class<effects>       DamageEffect; 					// Special effect.
var() string			   DamageWeaponName; 				// weapon that caused this damage
var() bool					bArmorStops;					// does regular armor provide protection against this damage
var() bool					bInstantHit;					// done by trace hit weapon
var() bool					bFastInstantHit;				// done by fast repeating trace hit weapon
var() bool                  bAlwaysGibs;
var() bool                  bNoSpecificLocation;
var() bool                  bSkeletize;         // swap model to skeleton
var() bool					bCausesBlood;
var() bool					bKUseOwnDeathVel;	// For ragdoll death. Rather than using default - use death velocity specified in this damage type.
var() bool					m_bDamagesArmor;
var() bool					m_bExplosiveDamage;
var() bool					m_bBulletDamage;

var() float					GibModifier;

// these effects should be none if should use the Pawn's blood effects
var() class<Effects>		PawnDamageEffect;	// effect to spawn when pawns are damaged by this damagetype
var() class<Emitter>		PawnDamageEmitter;	// effect to spawn when pawns are damaged by this damagetype
var() class<Emitter>		PawnDamageHeadshotEmitter;	// effect to spawn when pawns are damaged by this damagetype // GBX:jlb
var() class<Emitter>		PawnDamageLittleEmitter;	// effect to spawn when pawns are damaged by this damagetype // GBX:jlb
var() array<Sound>			PawnDamageSounds;	// Sound Effect to Play when Damage occurs

var() class<Effects>		LowGoreDamageEffect; 	// effect to spawn when low gore
var() class<Emitter>		LowGoreDamageEmitter;	// Emitter to use when it's low gore
var() class<Emitter>		LowGoreDamageHeadshotEmitter;	// Emitter to use when it's low gore  // GBX:jlb
var() class<Emitter>		LowGoreDamageLittleEmitter;	// Emitter to use when it's low gore  // GBX:jlb
var() array<Sound>			LowGoreDamageSounds;	// Sound Effects to play with Damage occurs with low gore

var() class<Effects>		LowDetailEffect;		// Low Detail effect
var() class<Emitter>		LowDetailEmitter;		// Low Detail emitter
var() class<Emitter>		LowDetailHeadshotEmitter;		// Low Detail emitter  // GBX:jlb
var() class<Emitter>		LowDetailLittleEmitter;		// Low Detail emitter  // GBX:jlb

var class<Projector> BloodDecal;  // GBX:jlb

var() float					FlashScale;		//for flashing victim's screen
var() vector				FlashFog;

var() int					DamageDesc;			// Describes the damage
var() int					DamageThreshold;	// How much damage much occur before playing effects
var() vector				DamageKick;

var(Karma)	float			KDamageImpulse;		// magnitude of impulse applied to KActor due to this damage type.
var(Karma)  float			KDeathVel;			// How fast ragdoll moves upon death
var(Karma)  float			KDeathUpKick;		// Amount of upwards kick ragdolls get when they die

var int						m_nTrauma;			// How much trauma does this add to the character it hit?

static function IncrementKills(Controller Killer);

static function string DeathMessage(PlayerReplicationInfo Killer, PlayerReplicationInfo Victim)
{
	return Default.DeathString;
}

static function string SuicideMessage(PlayerReplicationInfo Victim)
{
	if ( Victim.bIsFemale )
		return Default.FemaleSuicide;
	else
		return Default.MaleSuicide;
}

static function class<Effects> GetPawnDamageEffect( vector HitLocation, float Damage, vector Momentum, Pawn Victim, bool bLowDetail )
{
	if ( class'GameInfo'.static.UseLowGore() )
	{
		if ( Default.LowGoreDamageEffect != None )
			return Default.LowGoreDamageEffect;
		else
			return Victim.LowGoreBlood;
	}
	else if ( bLowDetail )
	{
		if ( Default.LowDetailEffect != None )
			return Default.LowDetailEffect;
		else
		{
			return Victim.BloodEffect;
		}
	}
	else
	{
		if ( Default.PawnDamageEffect != None )
			return Default.PawnDamageEffect;
		else
		{
			return Victim.BloodEffect;
		}
	}
}

static function class<Emitter> GetPawnDamageEmitter( vector HitLocation, float Damage, vector Momentum, Pawn Victim, bool bLowDetail )
{
	if ( class'GameInfo'.static.UseLowGore() )
	{
		if ( Default.LowGoreDamageEmitter != None )
			return Default.LowGoreDamageEmitter;
		else
			return none;
	}
	else if ( bLowDetail )
	{
		if ( Default.LowDetailEmitter != None )
			return Default.LowDetailEmitter;
		else
			return none;
	}
	else
	{
		if ( Default.PawnDamageEmitter != None )
			return Default.PawnDamageEmitter;
		else
			return none;
	}
}

static function class<Emitter> GetPawnDamageHeadShotEmitter( vector HitLocation, float Damage, vector Momentum, Pawn Victim, bool bLowDetail )
{
	if ( class'GameInfo'.static.UseLowGore() )
	{
		if ( Default.LowGoreDamageHeadShotEmitter != None )
			return Default.LowGoreDamageHeadShotEmitter;
		else
			return none;
	}
	else if ( bLowDetail )
	{
		if ( Default.LowDetailHeadShotEmitter != None )
			return Default.LowDetailHeadShotEmitter;
		else
			return none;
	}
	else
	{
		if ( Default.PawnDamageHeadShotEmitter != None )
			return Default.PawnDamageHeadShotEmitter;
		else
			return none;
	}
}

static function class<Emitter> GetPawnDamageLittleEmitter( vector HitLocation, float Damage, vector Momentum, Pawn Victim, bool bLowDetail )
{
	if ( class'GameInfo'.static.UseLowGore() )
	{
		if ( Default.LowGoreDamageLittleEmitter != None )
			return Default.LowGoreDamageLittleEmitter;
		else
			return none;
	}
	else if ( bLowDetail )
	{
		if ( Default.LowDetailLittleEmitter != None )
			return Default.LowDetailLittleEmitter;
		else
			return none;
	}
	else
	{
		if ( Default.PawnDamageLittleEmitter != None )
			return Default.PawnDamageLittleEmitter;
		else
			return none;
	}
}

static function class<Projector> GetPawnBloodDecal( vector HitLocation, float Damage, vector Momentum, Pawn Victim, bool bLowDetail )
{
	return Default.BloodDecal;
}


static function Sound GetPawnDamageSound()
{
	if ( class'GameInfo'.static.UseLowGore() )
	{
		if (Default.LowGoreDamageSounds.Length>0)
			return Default.LowGoreDamageSounds[Rand(Default.LowGoreDamageSounds.Length)];
		else
			return none;
	}
	else
	{
		if (Default.PawnDamageSounds.Length>0)
			return Default.PawnDamageSounds[Rand(Default.PawnDamageSounds.Length)];
		else
			return none;
	}
}

static function bool IsOfType(int Description)
{
	local int result;

	result = Description & Default.DamageDesc;
	return (result == Description);
}

static function string GetWeaponClass()
{
	return "";
}

defaultproperties
{
     DeathString="%o was killed by %k."
	 FemaleSuicide="%o killed herself."
	 MaleSuicide="%o killed himself."
	 bArmorStops=true
	 GibModifier=+1.0
    FlashScale=0.3
    FlashFog=(X=900.00000,Y=0.000000,Z=0.00000)
	 DamageDesc=1
	 DamageThreshold=0
    bNoSpecificLocation=false
    bCausesBlood=true
    KDamageImpulse=8000

	m_bDamagesArmor=false
	m_bExplosiveDamage=false
}
class DamTypeTelefragged extends DamageType
	abstract;



defaultproperties
{
	DeathString="%o was telefragged by %k"
	MaleSuicide="%o was telefragged by %k"
	FemaleSuicide="%o was telefragged by %k"

    bAlwaysGibs=true
    bNoSpecificLocation=true
    bArmorStops=false
}
class Decal extends Actor;



// DEPRECATED
//=============================================================================
// Decoration.
//=============================================================================
class Decoration extends Actor
	abstract
	placeable
	native;



// If set, the pyrotechnic or explosion when item is damaged.
var()  class<actor> EffectWhenDestroyed;
var() bool bPushable;
var() bool bDamageable;
var bool bPushSoundPlaying;
var bool bSplash;

var() sound PushSound, EndPushSound;
var const int	 numLandings;		// Used by engine physics.
var() class<inventory> contents;	// spawned when destroyed

var()	int		NumFrags;		// number of fragments to spawn when destroyed
var()	texture	FragSkin;		// skin to use for fragments
var()	class<Fragment> FragType;	// type of fragment to use
var		vector FragMomentum;		// momentum to be imparted to frags when destroyed
var()	int		Health;
var()	float  SplashTime;

function bool CanSplash()
{
	if ( (Level.TimeSeconds - SplashTime > 0.25)
		&& (Physics == PHYS_Falling)
		&& (Abs(Velocity.Z) > 100) )
	{
		SplashTime = Level.TimeSeconds;
		return true;
	}
	return false;
}

function Drop(vector newVel);

function Landed(vector HitLocation, vector HitNormal)
{
	local rotator NewRot;

	if (Velocity.Z<-500)
		TakeDamage(100,Pawn(Owner),HitNormal,HitNormal*10000,class'Crushed');
	Velocity = vect(0,0,0);
	NewRot = Rotation;
	NewRot.Pitch = 0;
	NewRot.Roll = 0;
	SetRotation(NewRot);
}

function HitWall (vector HitLocation, vector HitNormal, actor Wall)
{
	Landed(HitLocation, HitNormal);
}

function TakeDamage( int NDamage, Pawn instigatedBy, Vector hitlocation,
					Vector momentum, class<DamageType> damageType, optional name HitBoxName)
{
	Instigator = InstigatedBy;
	if (!bDamageable || (Health<0) )
		Return;
	if ( Instigator != None )
		MakeNoise(1.0);
	Health -= NDamage;
	FragMomentum = Momentum;
	if (Health <0)
		Destroy();
	else
	{
		SetPhysics(PHYS_Falling);
		Momentum.Z = 1000;
		Velocity=Momentum/Mass;
	}
}

singular function PhysicsVolumeChange( PhysicsVolume NewVolume )
{
	if( NewVolume.bWaterVolume )
	{
		if( bSplash && !PhysicsVolume.bWaterVolume && Mass<=Buoyancy
			&& ((Abs(Velocity.Z) < 100) || (Mass == 0)) && (FRand() < 0.05) && !PlayerCanSeeMe() )
		{
			bSplash = false;
			SetPhysics(PHYS_None);
		}
	}
	if( PhysicsVolume.bWaterVolume && (Buoyancy > Mass) )
	{
		if( Buoyancy > 1.1 * Mass )
			Buoyancy = 0.95 * Buoyancy; // waterlog
		else if( Buoyancy > 1.03 * Mass )
			Buoyancy = 0.99 * Buoyancy;
	}
}

function Trigger( actor Other, Pawn EventInstigator )
{
	Instigator = EventInstigator;
	TakeDamage( 1000, Instigator, Location, Vect(0,0,1)*900, class'Crushed');
}

singular function BaseChange()
{
	if( Velocity.Z < -500 )
		TakeDamage( (1-Velocity.Z/30),Instigator,Location,vect(0,0,0) , class'Crushed');

	if( base == None )
	{
		if ( !bInterpolating && bPushable && (Physics == PHYS_None) )
			SetPhysics(PHYS_Falling);
	}
	else if( Pawn(Base) != None )
	{
		Base.TakeDamage( (1-Velocity.Z/400)* mass/Base.Mass,Instigator,Location,0.5 * Velocity , class'Crushed');
		Velocity.Z = 100;
		if (FRand() < 0.5)
			Velocity.X += 70;
		else
			Velocity.Y += 70;
		SetPhysics(PHYS_Falling);
	}
	else if( Decoration(Base)!=None && Velocity.Z<-500 )
	{
		Base.TakeDamage((1 - Mass/Base.Mass * Velocity.Z/30), Instigator, Location, 0.2 * Velocity, class'Crushed');
		Velocity.Z = 100;
		if (FRand() < 0.5)
			Velocity.X += 70;
		else
			Velocity.Y += 70;
		SetPhysics(PHYS_Falling);
	}
	else
		instigator = None;
}

simulated function Destroyed()
{
	local inventory dropped;
	local int i;
	local Fragment s;
	local float BaseSize;

	if ( Role == ROLE_Authority )
	{
		if( (Contents!=None) && !Level.bStartup )
		{
			dropped = Spawn(Contents);
			dropped.DropFrom(Location);
		}

		TriggerEvent( Event, Self, None);

		if ( bPushSoundPlaying )
			PlaySound(EndPushSound, SLOT_Misc);
	}

	if ( (Level.NetMode != NM_DedicatedServer )
		&& !PhysicsVolume.bDestructive
		&& (NumFrags > 0) && (FragType != None) )
	{
		// spawn fragments
		BaseSize = 0.8 * sqrt(CollisionRadius*CollisionHeight)/NumFrags;
		for ( i=0; i<numfrags; i++ )
		{
			s = Spawn( FragType, Owner,,Location + CollisionRadius * VRand());
			s.CalcVelocity(FragMomentum);
			if ( FragSkin != None )
				s.Skins[0] = FragSkin;
			s.SetDrawScale(BaseSize * (0.5+0.7*FRand()));
		}
	}

	Super.Destroyed();
}

function Timer()
{
	PlaySound(EndPushSound, SLOT_Misc);
	bPushSoundPlaying=False;
}

function Bump( actor Other )
{
	local float speed, oldZ;
	if( bPushable && (Pawn(Other)!=None) && (Other.Mass > 40) )
	{
		oldZ = Velocity.Z;
		speed = VSize(Other.Velocity);
		Velocity = Other.Velocity * FMin(120.0, 20 + speed)/speed;
		if ( Physics == PHYS_None )
		{
			Velocity.Z = 25;
			if (!bPushSoundPlaying)
			{
				PlaySound(PushSound, SLOT_Misc);
				bPushSoundPlaying = True;
			}
		}
		else
			Velocity.Z = oldZ;
		SetPhysics(PHYS_Falling);
		SetTimer(0.3,False);
		Instigator = Pawn(Other);
	}
}

defaultproperties
{
     bStatic=True
     bStasis=True
     Mass=100.000000
     DrawType=DT_Mesh
	 bOrientOnSlope=true
	 bShouldBaseAtStartup=true
	 NetUpdateFrequency=10
}
//=============================================================================
// DecorationList:  Defines a list of decorations which can be attached to volumes
//=============================================================================

class DecorationList extends KeyPoint
	placeable
	native;



struct DecorationType
{
	var() StaticMesh	StaticMesh;
	var() range			Count;
	var() range			DrawScale;
	var() int			bAlign;
	var() int			bRandomPitch;
	var() int			bRandomYaw;
	var() int			bRandomRoll;
};

var(List) array<DecorationType> Decorations;

defaultproperties
{
	 Texture=Texture'Engine.S_DecorationList'
}
//=============================================================================
// DecoVolumeObject.
//
// A class that allows staticmesh actors to get spawned inside of
// deco volumes.  These are the actors that you actually see in the level.
//=============================================================================
class DecoVolumeObject extends Actor
	native;



defaultproperties
{
	bStatic=False
	DrawType=DT_StaticMesh
	bWorldGeometry=false
	bCollideActors=false
	bBlockActors=false
	bBlockPlayers=false
	CollisionRadius=0
	CollisionHeight=0
}
//=============================================================================
// DefaultPhysicsVolume:  the default physics volume for areas of the level with
// no physics volume specified
//=============================================================================
class DefaultPhysicsVolume extends PhysicsVolume
	native
	notplaceable;



function Destroyed()
{
	log(self$" destroyed!");
	assert(false);
}

defaultproperties
{
	bStatic=false
	bNoDelete=false
}
//=============================================================================
// DemoRecSpectator - spectator for demo recordings to replicate ClientMessages
//=============================================================================

class DemoRecSpectator extends PlayerController;


var bool bTempBehindView;
var bool bFoundPlayer;


event PostBeginPlay()
{
	local class<HUD> HudClass;
	local class<Scoreboard> ScoreboardClass;

	// We're currently doing demo recording
	if( Role == ROLE_Authority && Level.Game != None )
	{
		HudClass = class<HUD>(DynamicLoadObject(Level.Game.HUDType, class'Class'));
		if( HudClass == None )
			log( "Can't find HUD class "$Level.Game.HUDType, 'Error' );
        ScoreboardClass = class<Scoreboard>(DynamicLoadObject(Level.Game.ScoreBoardType, class'Class'));
		if( ScoreboardClass == None )
			log( "Can't find HUD class "$Level.Game.ScoreBoardType, 'Error' );
		ClientSetHUD( HudClass, ScoreboardClass );
	}

	Super.PostBeginPlay();

	if ( PlayerReplicationInfo != None )
		PlayerReplicationInfo.bOutOfLives = true;
}

function InitPlayerReplicationInfo()
{
	Super.InitPlayerReplicationInfo();
	PlayerReplicationInfo.PlayerName="DemoRecSpectator";
	PlayerReplicationInfo.bIsSpectator = true;
	PlayerReplicationInfo.bOnlySpectator = true;
	PlayerReplicationInfo.bOutOfLives = true;
	PlayerReplicationInfo.bWaitingPlayer = false;
}

exec function ViewClass( class<actor> aClass, optional bool bQuiet, optional bool bCheat )
{
	local actor other, first;
	local bool bFound;

	first = None;

	ForEach AllActors( aClass, other )
	{
		if ( bFound || (first == None) )
		{
			first = other;
			if ( bFound )
				break;
		}
		if ( other == ViewTarget )
			bFound = true;
	}

	if ( first != None )
	{
		SetViewTarget(first);
		bBehindView = ( ViewTarget != self );

		if ( bBehindView )
			ViewTarget.BecomeViewTarget();
	}
	else
		SetViewTarget(self);
}

//==== Called during demo playback ============================================

exec function DemoViewNextPlayer()
{
    local Controller C, Pick;
    local bool bFound;

    // view next player
    if ( PlayerController(RealViewTarget) != None )
		PlayerController(RealViewTarget).DemoViewer = None;

	foreach DynamicActors(class'Controller', C)
		if ( (C == self) || (PlayerController(C) == None) || !PlayerController(C).IsSpectating() )
		{
			if ( (GameReplicationInfo == None) && (PlayerController(C) != None) )
				GameReplicationInfo = PlayerController(C).GameReplicationInfo;
			if ( Pick == None )
				Pick = C;
			if ( bFound )
			{
				Pick = C;
				break;
			}
			else
				bFound = ( (RealViewTarget == C) || (ViewTarget == C) );
		}

    SetViewTarget(Pick);
    if ( PlayerController(RealViewTarget) != None )
		PlayerController(RealViewTarget).DemoViewer = self;
}

auto state Spectating
{
    exec function Fire( optional float F )
    {
        bBehindView = false;
        demoViewNextPlayer();
    }

    exec function AltFire( optional float F )
    {
        bBehindView = !bBehindView;
    }

	event PlayerTick( float DeltaTime )
	{
		Super.PlayerTick( DeltaTime );

		// attempt to find a player to view.
		if( Role == ROLE_AutonomousProxy && (RealViewTarget==None || RealViewTarget==Self) && !bFoundPlayer )
		{
			DemoViewNextPlayer();
			if( RealViewTarget!=None && RealViewTarget!=Self )
				bFoundPlayer = true;
		}

		// hack to go to 3rd person during deaths
		if( RealViewTarget!=None && RealViewTarget.Pawn==None )
		{
			if( !bTempBehindView )
			{
				bTempBehindView = true;
				bBehindView = true;
			}
		}
		else
		if( bTempBehindView )
		{
			bBehindView = false;
			bTempBehindView = false;
		}
	}
}

event PlayerCalcView(out actor ViewActor, out vector CameraLocation, out rotator CameraRotation )
{
	local Rotator R;

	if( RealViewTarget != None )
	{
		R = RealViewTarget.Rotation;
	}

	Super.PlayerCalcView(ViewActor, CameraLocation, CameraRotation );

	if( RealViewTarget != None )
	{
		if ( !bBehindView )
		{
			CameraRotation = R;
			if ( Pawn(ViewTarget) != None )
				CameraLocation.Z += Pawn(ViewTarget).BaseEyeHeight; // FIXME TEMP
		}

		RealViewTarget.SetRotation(R);
	}
}


defaultproperties
{
	RemoteRole=ROLE_AutonomousProxy
	bDemoOwner=1
}

/*=============================================================================
 Door.
 Used to mark a door on the Navigation network (a door is a mover that may act
 as an obstruction).
=============================================================================
*/
class Door extends NavigationPoint
	placeable
	native;



var() name DoorTag;				// tag of mover associated with this node
var	 mover MyDoor;
var() name DoorTrigger;			// recommended trigger to use (if door is triggerable)
var actor RecommendedTrigger;
var() bool bInitiallyClosed;	// if true, means that the initial position of the mover blocks navigation
var() bool bBlockedWhenClosed;	// don't even try to go through this path if door is closed
var bool bDoorOpen;
var bool bTempNoCollide;		// used during path building

function PostBeginPlay()
{
	local vector Dist;

	if ( DoorTrigger != '' )
	{
		ForEach AllActors(class'Actor', RecommendedTrigger, DoorTrigger )
			break;
		// ignore recommended trigger if door is within its radius
		// (DoorTrigger shouldn't have been set)
		if ( RecommendedTrigger != None )
		{
			Dist = Location - RecommendedTrigger.Location;
			if ( abs(Dist.Z) < RecommendedTrigger.CollisionHeight )
			{
				Dist.Z = 0;
				if ( VSize(Dist) < RecommendedTrigger.CollisionRadius )
					RecommendedTrigger = None;
			}
		}
	}
	bCodeBlocked = ( bInitiallyClosed && bBlockedWhenClosed );
	bDoorOpen = !bInitiallyClosed;
	Super.PostBeginPlay();
}

function MoverOpened()
{
	bCodeBlocked = ( !bInitiallyClosed && bBlockedWhenClosed );
	bDoorOpen = bInitiallyClosed;
}

function MoverClosed()
{
	bCodeBlocked = ( bInitiallyClosed && bBlockedWhenClosed );
	bDoorOpen = !bInitiallyClosed;
}

/* SpecialHandling is called by the navigation code when the next path has been found.
It gives that path an opportunity to modify the result based on any special considerations
*/

function Actor SpecialHandling(Pawn Other)
{
	if ( MyDoor == None )
		return self;

	if ( MyDoor.BumpType == BT_PlayerBump && !Other.IsPlayerPawn() )
		return None;

	if ( bInitiallyClosed == (bDoorOpen || MyDoor.bOpening || MyDoor.bDelaying) )
		return self;

	if ( RecommendedTrigger != None )
		return RecommendedTrigger;

	return self;
}

function bool ProceedWithMove(Pawn Other)
{
	if ( MyDoor.bDamageTriggered && (Other.Controller.Focus == MyDoor) )
		Other.Controller.StopFiring();

	if ( bDoorOpen || !MyDoor.bDamageTriggered )
		return true;

	// door still needs to be shot
	Other.SetRotation(rotator(MyDoor.Location - Other.Location));
	Other.Controller.Focus = MyDoor;
	Other.ShootSpecial(MyDoor);
	MyDoor.Trigger(Other,Other);
	Other.Controller.WaitForMover(MyDoor);
	return false;
}

event bool SuggestMovePreparation(Pawn Other)
{
	if ( bDoorOpen )
		return false;
	if ( MyDoor.bOpening || MyDoor.bDelaying )
	{
		Other.Controller.WaitForMover(MyDoor);
		return true;
	}
	if ( MyDoor.bDamageTriggered )
	{
		// handle shootable doors
		Other.SetRotation(rotator(MyDoor.Location - Other.Location));
		Other.Controller.Focus = MyDoor;
		Other.ShootSpecial(MyDoor);
		MyDoor.Trigger(Other,Other);
		Other.Controller.WaitForMover(MyDoor);
		return true;
	}

	return false;
}

defaultproperties
{
	Texture=Texture'Engine.S_Door'
	RemoteRole=ROLE_None
	bNoDelete=true
	ExtraCost=100
	bInitiallyClosed=true
	bSpecialMove=true
}
//=============================================================================
// The dynamic light class.
// Used to create lights that need to move or should be treated as moveable
//=============================================================================
class DynamicLight extends Light
	placeable;



defaultproperties
{
     bStatic=False
     bDynamicLight=True
	 bNoDelete=False
}
class DynamicProjector extends Projector;

var transient Vector  OldLocation;
var transient rotator OldRotation;

simulated function Tick(float DeltaTime)
{
	if ((Location != OldLocation) || (OldRotation != Rotation))
	{
		DetachProjector(True);
		AttachProjector();
	}
	OldLocation = Location;
	OldRotation = Rotation;
}

defaultproperties
{
	Texture=Texture'Engine.S_ProjectorDynamic'
	bDynamicAttach=True
	bStatic=False
	bLevelStatic=False

	bProjFlag_Shadow=False
	bProjFlag_VehicleShadow=False
	bProjFlag_LevelShadow=False
	bProjFlag_Blood=False
	bProjFlag_Bullet=False
	bProjFlag_Blast=False
	bProjFlag_SAVIcon=False
	bProjFlag_ObjectiveIcon=False
	bProjFlag_CommandRing=False
}
class EditorIcons extends Object;



// Referenced from NATIVE CODE (Stock Unreal Icons)
#exec Texture Import File=Textures\S_LockLocation.tga           MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_AutoAlignToTerrain.tga     MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_Vertex.tga                 MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_WhiteCircle.tga            MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_ClipMarker.tga             MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_ClipMarker1.tga            MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_ClipMarker2.tga            MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_ClipMarker3.tga            MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5

// Karma Bullshit (Stock Unreal Icons)
#exec Texture Import File=Textures\S_KBSJoint.tga               MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_KConeLimit.tga             MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_KConstraint.tga            MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_KHinge.tga                 MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5

// Matinee (Stock Unreal Icons)
#exec Texture Import File=Textures\S_MatineeIP.tga              MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_MatineeIPSel.tga           MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_MatineeTimeMarker.tga      MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_MatineeSubAction.tga       MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_ActionCamMove.tga          MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_ActionCamPause.tga         MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_PathLinear.tga             MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_PathBezier.tga             MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_BezierHandle.tga           MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_PolyMarker.tga             MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5

// Stock Unreal Icons
#exec Texture Import File=Textures\S_AIScript.tga               MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_Ammo.tga                   MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_Camera.tga                 MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_DecorationList.tga         MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_Dispatcher.tga             MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_Door.tga                   MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_Inventory.tga              MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_Keypoint.tga               MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_Ladder.tga                 MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_LiftCenter.tga             MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_LiftExit.tga               MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_SpecialEvent.tga           MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_Teleport.tga               MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_TerrainInfo.tga            MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_Weapon.tga                 MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5

// Wargame Revised Icons
#exec Texture Import File=Textures\S_Actor.tga                  MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_Ambient.tga                MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_Emitter.tga                MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_Interp.tga                 MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_LookTarget.tga             MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_FluidSurf.tga              MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_FluidSurfOsc.tga           MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_ExplosionTrigger.tga       MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_Light.tga                  MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_LightSpot.tga              MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_LightSun.tga               MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_Note.tga                   MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_Pawn.tga                   MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_Player.tga                 MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_PathNode.tga               MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_PathNode_blue.tga          MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_PathNode_green.tga         MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_PathNode_yellow.tga        MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_PathNodeGerman.tga         MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_PathNodeUS.tga             MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_PlayerStartTriggered.tga   MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_Projector.tga              MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_ProjectorDynamic.tga       MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_SceneManager.tga           MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_Trigger.tga                MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_TriggerContextUse.tga      MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_TriggerCounter.tga         MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_TriggerMaterial.tga        MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_TriggerMessage.tga         MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_TriggerMusic.tga           MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_TriggerRedirection.tga     MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_TriggerViewShaker.tga      MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_TriggerLineOfSight.tga     MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_TriggerCondition.tga       MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_TriggerRandom.tga          MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_TriggerScript.tga          MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_TriggerTimed.tga           MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_TriggerUse.tga             MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_TriggerZone.tga            MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_Unit.tga                   MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_ZoneInfo.tga               MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_ZoneParallax.tga           MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_ZoneSky.tga                MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_ZoneWarp.tga               MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_ZoneWater.tga              MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_ZoneSlime.tga              MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_ZoneLava.tga               MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_CharacterSpawnerGerman.tga MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_CharacterSpawnerUS.tga     MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5
#exec Texture Import File=Textures\S_VehicleSpawner.tga         MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=DXT5

// LCD Textures
#exec Texture Import File=Textures\LCD_Ammo.bmp				        MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=RGBA
#exec Texture Import File=Textures\LCD_Clip.bmp				        MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=RGBA
#exec Texture Import File=Textures\LCD_Grenade.bmp			        MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=RGBA
#exec Texture Import File=Textures\LCD_Vehicle.bmp			        MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=RGBA
#exec Texture Import File=Textures\LCD_Assault.bmp			        MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=RGBA
#exec Texture Import File=Textures\LCD_Base.bmp				        MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=RGBA
#exec Texture Import File=Textures\LCD_Circle.bmp			        MIPS=OFF MASKED=1 ALPHATEXTURE=0 COMPRESS=RGBA

defaultproperties
{
}
//=============================================================================
// Effects, the base class of all gratuitous special effects.
//
//=============================================================================
class Effects extends Actor;



defaultproperties
{
     DrawType=DT_Sprite
     Physics=PHYS_None
     bUnlit=True
	 bNetTemporary=true
	 bGameRelevant=true
	 CollisionRadius=+0.00000
	 CollisionHeight=+0.00000
     RemoteRole=ROLE_None
     bNetInitialRotation=true
}
//=============================================================================
// EFFECT_WaterVolume
//=============================================================================

class EFFECT_WaterVolume extends I3DL2Listener
	editinlinenew;

defaultproperties
{
	EnvironmentSize=1.8;
	EnvironmentDiffusion=1.0;
	Room=-1000;
	RoomHF=-4000;
	DecayTime=1.49;
	DecayHFRatio=0.1;
	Reflections=-449;
	ReflectionsDelay=0.007;
	Reverb=1700;
	ReverbDelay=0.011;
	RoomRolloffFactor=0.0;
	AirAbsorptionHF=-5;
	bDecayTimeScale=true;
	bReflectionsScale=true;
	bReflectionsDelayScale=true;
	bReverbScale=true;
	bReverbDelayScale=true;
	bDecayHFLimit=true;
}//=============================================================================
// Emitter: An Unreal Emitter Actor.
//=============================================================================
class Emitter extends Actor
	native
	placeable;



var()	export	editinline	array<ParticleEmitter>	Emitters;

var		(Global)	bool				AutoDestroy;
var		(Global)	bool				AutoReset;
var		(Global)	bool				DisableFogging;
var		(Global)	rangevector			GlobalOffsetRange;
var		(Global)	range				TimeTillResetRange;

var		transient	int					Initialized;
var		transient	box					BoundingBox;
var		transient	float				EmitterRadius;
var		transient	float				EmitterHeight;
var		transient	bool				ActorForcesEnabled;
var		transient	vector				GlobalOffset;
var		transient	float				TimeTillReset;
var		transient	bool				DeleteParticleEmitters;

// shutdown the emitter and make it auto-destroy when the last active particle dies.
native function Kill();

simulated function PostBeginPlay()
{
	Super.PostBeginPlay();
	
	log("Emitter Type "$class$" and tag "$Tag$" Used.", 'EmitterCreate');
}

simulated function UpdatePrecacheMaterials()
{
	local int i;
	for( i=0; i<Emitters.Length; i++ )
	{
		if( Emitters[i] != None )
		{
			if( Emitters[i].Texture != None )
				Level.AddPrecacheMaterial(Emitters[i].Texture);
		}
	}
}

event Trigger( Actor Other, Pawn EventInstigator )
{
	local int i;
	for( i=0; i<Emitters.Length; i++ )
	{
		if( Emitters[i] != None )
		{
			log(self$".Trigger( "$Other$", "$EventInstigator$" ) - "$Emitters[i].Texture, 'EmitterCreate');
			Emitters[i].Trigger();
		}
	}
}


defaultproperties
{
	RemoteRole=ROLE_None
	Style=STY_Particle
	DrawType=DT_Particle
	Texture=Texture'Engine.S_Emitter'
	bNoDelete=true
	bUnlit=true

	bAlphaFogable=True
    bAlphaFogBlend=true
}
//=============================================================================
// Engine: The base class of the global application object classes.
// This is a built-in Unreal class and it shouldn't be modified.
//=============================================================================
class Engine extends Subsystem
	native
	noexport
	transient;



// Variables.
var primitive Cylinder;
var const client Client;
var const audiosubsystem Audio;
var const renderdevice GRenDev;

// Stats.
var int bShowFrameRate;
var int bShowRenderStats;
var int bShowHardwareStats;
var int bShowGameStats;
var int bShowNavigationStats;
var int bShowNetStats;
var int bShowAnimStats;		 // Show animation statistics.
var int bShowHistograph;
var int bShowXboxMemStats;
var int bShowMatineeStats;	// Show Matinee specific information
var int bShowAudioStats;
var int bShowLightStats;
var int bShowMemStats;
var int bShowMemStatsSimple;

var int TickCycles, GameCycles, ClientCycles;
var(Settings) config int CacheSizeMegs;
var(Settings) config bool UseSound;
var(Settings) config bool bSlowRefChecking; // toggle object ref checking on cleanupdestroyed
var(Settings) float CurrentTickRate;

var int ActiveControllerId;	// The ID of the active controller

// Color preferences.
var(Colors) config color
	C_WorldBox,
	C_GroundPlane,
	C_GroundHighlight,
	C_BrushWire,
	C_Pivot,
	C_Select,
	C_Current,
	C_AddWire,
	C_SubtractWire,
	C_GreyWire,
	C_BrushVertex,
	C_BrushSnap,
	C_Invalid,
	C_ActorWire,
	C_ActorHiWire,
	C_Black,
	C_White,
	C_Mask,
	C_SemiSolidWire,
	C_NonSolidWire,
	C_WireBackground,
	C_WireGridAxis,
	C_ActorArrow,
	C_ScaleBox,
	C_ScaleBoxHi,
	C_ZoneWire,
	C_OrthoBackground,
	C_VolumeBrush,
	C_ConstraintLine,
	C_Terrain,
	C_StaticMesh,
	C_StaticMeshHighlight,
	C_SkeletalMesh,
	C_SkeletalMeshHighlight,
	C_Mover,
	C_MoverHighlight,
	C_Deco,
	C_kDOPCollision;

// GBX:naj - added 3/18/04 - Filter for a specific Actor with STAT ANIM.
var Actor StatAnimActor;

defaultproperties
{
	CacheSizeMegs=2
	UseSound=True
	C_WorldBox=(R=0,G=0,B=107,A=255)
	C_GroundPlane=(R=0,G=0,B=63,A=255)
	C_GroundHighlight=(R=0,G=0,B=127,A=255)
	C_BrushWire=(R=255,G=63,B=63,A=255)
	C_Pivot=(R=0,G=255,B=0,A=255)
	C_Select=(R=0,G=0,B=127,A=255)
	C_AddWire=(R=127,G=127,B=255,A=255)
	C_SubtractWire=(R=255,G=192,B=63,A=255)
	C_GreyWire=(R=163,G=163,B=163,A=255)
	C_Invalid=(R=163,G=163,B=163,A=255)
	C_ActorWire=(R=127,G=63,B=0,A=255)
	C_ActorHiWire=(R=255,G=127,B=0,A=255)
	C_White=(R=255,G=255,B=255,A=255)
	C_SemiSolidWire=(R=127,G=255,B=0,A=255)
	C_NonSolidWire=(R=63,G=192,B=32,A=255)
	C_WireGridAxis=(R=119,G=119,B=119,A=255)
	C_ActorArrow=(R=163,G=0,B=0,A=255)
	C_ScaleBox=(R=151,G=67,B=11,A=255)
	C_ScaleBoxHi=(R=223,G=149,B=157,A=255)
	C_OrthoBackground=(R=163,G=163,B=163,A=255)
	C_Current=(R=0,G=0,B=0,A=255)
	C_BrushVertex=(R=0,G=0,B=0,A=255)
	C_BrushSnap=(R=0,G=0,B=0,A=255)
	C_Black=(R=0,G=0,B=0,A=255)
	C_Mask=(R=0,G=0,B=0,A=255)
	C_WireBackground=(R=0,G=0,B=0,A=255)
	C_ZoneWire=(R=0,G=0,B=0,A=255)
	C_VolumeBrush=(R=255,G=196,B=225,A=255)
	C_ConstraintLine=(R=0,G=255,B=0,A=255)
	C_Terrain=(R=255,G=255,B=255,A=255)
	C_StaticMesh=(R=0,G=255,B=255,A=255)
    C_StaticMeshHighlight=(R=0,G=255,R=0,A=255)
	C_SkeletalMesh=(R=221,G=221,B=28,A=255)
    C_SkeletalMeshHighlight=(R=0,G=255,B=0,A=255)
	C_Mover=(R=255,G=0,B=255,A=255)
    C_MoverHighlight=(R=0,G=255,R=0,A=255)
    C_Deco=(R=255,G=0,B=192,A=255)
	C_kDOPCollision=(R=64,G=240,B=180,A=255)
}
//=============================================================================
// Object to facilitate storing information about an extended attachment to a model
//
// << GBX/PAD:created -- entire file
//
//=============================================================================

class ExtendedAttachmentInfo extends Object
	editinlinenew;



var		AttachedPart		m_AttachedPart;		// The actor containing the reference information of the part being attached
var	()	name				m_nmSocketName;		// The name of the socket used to attach these two meshs.
var	()	name				m_nmPartName;		// The name of the part to attach to this socket.
var ()  string				m_szGroupName;		// The string containing the name of the attachment group to use.
var ()	bool				bUseSmirkFacialExpressions;  // display smirk facial expressions on this attachment (head)
var ()	bool				bUseScowlFacialExpressions;  // display scowl facial expressions on this attachment (head)

defaultproperties
{
}
class FailedConnect extends LocalMessage
	abstract;



var localized string FailMessage[4];

static function int GetFailSwitch(string FailString)
{
	if ( FailString ~= "NEEDPW" )
		return 0;

	if ( FailString ~= "WRONGPW" )
		return 1;

	if ( FailString ~="GAMESTARTED" )
		return 2;

	return 3;
}

static function string GetString(
	optional int Switch,
	optional PlayerReplicationInfo RelatedPRI_1,
	optional PlayerReplicationInfo RelatedPRI_2,
	optional Object OptionalObject
	)
{
	return Default.FailMessage[Clamp(Switch,0,3)];
}

defaultproperties
{
	bBeep=false
	bFadeMessage=True
	bIsUnique=True

	DrawColor=(R=255,G=0,B=128,A=255)
	FontSize=1

	FailMessage(0)="FAILED TO JOIN GAME.  NEED PASSWORD."
	FailMessage(1)="FAILED TO JOIN GAME.  WRONG PASSWORD."
	FailMessage(2)="FAILED TO JOIN GAME.  GAME HAS STARTED."
	FailMessage(3)="FAILED TO JOIN GAME."
}
class Fell extends DamageType
	abstract;



defaultproperties
{
	DeathString="%o left a small crater"
	MaleSuicide="%o left a small crater"
	FemaleSuicide="%o left a small crater"

    GibModifier=2.0
    bNoSpecificLocation=true
}
class FellLava extends Fell
	abstract;



defaultproperties
{
	DeathString="%o crashed and burnt"
	MaleSuicide="%o crashed and burnt"
	FemaleSuicide="%o crashed and burnt"

	bSkeletize=true
    GibModifier=2.0
    bNoSpecificLocation=true
}
// ====================================================================
//  Class:  Engine.FileLog
//  Parent: Engine.Info
//
//  Creates a log device.
// ====================================================================

class FileLog extends Info
		Native;



// Internal
var int LogAr; // FArchive*

// File Names
var string LogFileName;

// File Manipulation
native final function OpenLog(string FName);	// No extension, .txt is auto appended
native final function CloseLog();
native final function Logf( string LogString );

event Destroyed()
{
	CloseLog();
}

defaultproperties
{
}
class FinalBlend extends Modifier
	showcategories(Material)
	native
	dependson(GbxShader);

enum EFrameBufferBlending
{
	FB_Overwrite,
	FB_Modulate,
	FB_AlphaBlend,
	FB_AlphaModulate_MightNotFogCorrectly,
	FB_Translucent,
	FB_Darken,
	FB_Brighten,
	FB_Invisible,
	FB_ShadowBlend,
	FB_Custom
};

var() bool ZWrite;
var() bool ZTest;
var() bool AlphaTest;
var() bool TwoSided;
var() bool ForceFogDisabled;
var() color ForcedFogColor;
var() byte AlphaRef;
var() EFrameBufferBlending FrameBufferBlending;
var() GbxShader.EGbxBlendEquation BlendEquation;
var() GbxShader.EGbxBlendFunction BlendSrcFunction;
var() GbxShader.EGbxBlendFunction BlendDstFunction;

defaultproperties
{
	FrameBufferBlending=FB_Overwrite
	ZWrite=True
	ZTest=True
	TwoSided=False
	ForceFogDisabled=False
	BlendEquation=blendequation_Add
	BlendSrcFunction=blend_SrcAlpha
	BlendDstFunction=blend_OneMinusSrcAlpha
}
class FontInfo extends Object
	native;



// simple default font, so various stuff doesn't crash

#exec new TrueTypeFontFactory PACKAGE="Engine" Name=MonoFont        FontName="Courier New Bold"   USize=1024 Height=8         AntiAlias=0 CharactersPerPage=256 Wildcard="FontChars_EN_US.txt" Path="."
#exec new TrueTypeFontFactory PACKAGE="Engine" Name=ConsoleFont     FontName="Courier New Bold"   USize=1024 Height=10        AntiAlias=0 CharactersPerPage=256 Wildcard="FontChars_EN_US.txt" Path="."
#exec new TrueTypeFontFactory PACKAGE="Engine" Name=DefaultFont     FontName="Franklin Gothic Medium"   USize=1024 Height=14   AntiAlias=0 CharactersPerPage=256 Wildcard="FontChars_EN_US.txt" Path="."
//#exec new TrueTypeFontFactory PACKAGE="Engine" Name=WargameFont     FontName="Typical Writer"   USize=1024 Height=16 	AntiAlias=1 CharactersPerPage=256 Wildcard="FontChars_EN_US.txt" Path="."
//#exec new TrueTypeFontFactory PACKAGE="Engine" Name=WargameFont2     FontName="Franklin Gothic Medium"   USize=1024 Height=16 Style=700  AntiAlias=1 CharactersPerPage=256 Wildcard="FontChars_EN_US.txt" Path="."
//#exec new TrueTypeFontFactory PACKAGE="Engine" Name=WargameFontNumbers     FontName="Distress"   USize=128 Height=18  AntiAlias=1 CharactersPerPage=256 Wildcard="FontChars_Num.txt" Path="."

//#exec new TrueTypeFontFactory PACKAGE="Engine" Name=TahomaNormal		FontName="Tahoma" USize=1024 Height=8             AntiAlias=0 CharactersPerPage=256 Wildcard="FontChars_EN_US.txt" Path="."
//#exec new TrueTypeFontFactory PACKAGE="Engine" Name=TahomaNormalBold	FontName="Tahoma" USize=1024 Height=8 Style=700   AntiAlias=0 CharactersPerPage=256 Wildcard="FontChars_EN_US.txt" Path="."

defaultproperties
{
}

//=============================================================================
// Fragment.
//=============================================================================
class Fragment extends Effects;



var() MESH Fragments[11];
var int numFragmentTypes;
var bool bFirstHit;
var() sound    ImpactSound, AltImpactSound;
var()	float  SplashTime;

function bool CanSplash()
{
	if ( (Level.TimeSeconds - SplashTime > 0.25)
		&& (Physics == PHYS_Falling)
		&& (Abs(Velocity.Z) > 100) )
	{
		SplashTime = Level.TimeSeconds;
		return true;
	}
	return false;
}


simulated function CalcVelocity(vector Momentum)
{
	local float ExplosionSize;

	ExplosionSize = 0.011 * VSize(Momentum);
	Velocity = 0.0033 * Momentum + 0.7 * VRand()*(ExplosionSize+FRand()*100.0+100.0);
	Velocity.z += 0.5 * ExplosionSize;
}

simulated function HitWall (vector HitLocation, vector HitNormal, actor HitWall)
{
	local float speed;

	Velocity = 0.5*(( Velocity dot HitNormal ) * HitNormal * (-2.0) + Velocity);   // Reflect off Wall w/damping
	speed = VSize(Velocity);
	if (bFirstHit && speed<400)
	{
		bFirstHit=False;
		bRotatetoDesired=True;
		bFixedRotationDir=False;
		DesiredRotation.Pitch=0;
		DesiredRotation.Yaw=FRand()*65536;
		DesiredRotation.roll=0;
	}
	RotationRate.Yaw = RotationRate.Yaw*0.75;
	RotationRate.Roll = RotationRate.Roll*0.75;
	RotationRate.Pitch = RotationRate.Pitch*0.75;
	if ( (speed < 60) && (HitNormal.Z > 0.7) )
	{
		SetPhysics(PHYS_none);
		bBounce = false;
		GoToState('Dying');
	}
	else if (speed > 80)
	{
		if ((FRand()<0.5) && (ImpactSound != None))
			PlaySound(ImpactSound, SLOT_None,,, 300, 0.85+FRand()*0.3,true);
		else if (AltImpactSound != None)
			PlaySound(AltImpactSound, SLOT_None,,, 300, 0.85+FRand()*0.3,true);
	}
}

simulated final function RandSpin(float spinRate)
{
	DesiredRotation = RotRand();
	RotationRate.Yaw = spinRate * 2 *FRand() - spinRate;
	RotationRate.Pitch = spinRate * 2 *FRand() - spinRate;
	RotationRate.Roll = spinRate * 2 *FRand() - spinRate;
}

auto state Flying
{
	simulated function timer()
	{
		GoToState('Dying');
	}

	simulated singular function PhysicsVolumeChange( PhysicsVolume NewVolume )
	{
		if ( NewVolume.bWaterVolume )
		{
			Velocity = 0.2 * Velocity;
			if (bFirstHit)
			{
				bFirstHit=False;
				bRotatetoDesired=True;
				bFixedRotationDir=False;
				DesiredRotation.Pitch=0;
				DesiredRotation.Yaw=FRand()*65536;
				DesiredRotation.roll=0;
			}

			RotationRate = 0.2 * RotationRate;
			GotoState('Dying');
		}
	}

	simulated function BeginState()
	{
		RandSpin(125000);
		if (abs(RotationRate.Pitch)<10000)
			RotationRate.Pitch=10000;
		if (abs(RotationRate.Roll)<10000)
			RotationRate.Roll=10000;
		LinkMesh(Fragments[int(FRand()*numFragmentTypes)]);
		if ( Level.NetMode == NM_Standalone )
			LifeSpan = 20 + 40 * FRand();
		SetTimer(5.0,True);
	}
}

state Dying
{
	function TakeDamage( int Dam, Pawn instigatedBy, Vector hitlocation,
							Vector momentum, class<DamageType> damageType, optional name HitBoxName)
	{
		Destroy();
	}

	simulated function timer()
	{
		if ( !PlayerCanSeeMe() )
			Destroy();
	}

	simulated function BeginState()
	{
		SetTimer(1 + FRand(),True);
		SetCollision(true, false, false);
	}
}

defaultproperties
{
	 bDestroyInPainVolume=true
     bFirstHit=True
     CollisionRadius=+00018.000000
     CollisionHeight=+00004.000000
     Physics=PHYS_Falling
     bBounce=True
     bFixedRotationDir=True
	 bCollideActors=false
     bCollideWorld=True
     LifeSpan=+00020.000000
     DrawType=DT_Mesh
     SoundVolume=0
	 RemoteRole=ROLE_None
}

class FriendlyListener extends Actor;



var AnimPawn NotifyPawn;


event TraceTouch( Actor Other, vector TouchLocation, vector TouchNormal, vector End, vector Start, vector Extent, int TraceFlags )
{
	if( NotifyPawn != None )
	{
		NotifyPawn.NotifyNearbyTrace( Other, TouchLocation, TouchNormal, End, Start, Extent, TraceFlags );
	}
}

defaultproperties
{
	bStatic=false
	bNoDelete=false
	bHidden=true

	DrawType=DT_None
	DrawScale=5.0

	bCollideActors=true
	bCollideWorld=false
	bBlockActors=false
	bBlockPlayers=false
	bBlockZeroExtentTraces=false
	bBlockNonZeroExtentTraces=false
	bBlockKarma=false
	bTraceListener=true

	CollisionHeight=85.0
	CollisionRadius=29.0

	RemoteRole=ROLE_None
}
//=============================================================================
// GameEngine: The game subsystem.
// This is a built-in Unreal class and it shouldn't be modified.
//=============================================================================
class GameEngine extends Engine
	native
	noexport
	transient;



// URL structure.
struct URL
{
	var string			Protocol,	// Protocol, i.e. "unreal" or "http".
						Host;		// Optional hostname, i.e. "204.157.115.40" or "unreal.epicgames.com", blank if local.
	var int				Port;		// Optional host port.
	var string			Map;		// Map name, i.e. "SkyCity", default is "Index".
	var array<string>	Op;			// Options.
	var string			Portal;		// Portal to enter through, default is "".
	var int 			Valid;
};

var Level			GLevel,
					GEntry;
var PendingLevel	GPendingLevel;
var PlayerController LevelLoadingController; // Added by Demiurge (LevelLoading)
var	int					LevelLoadingTotalActorCount; // Added by Demiurge (LevelLoading)
var int					LevelLoadingActorCount; // Added by Demiurge (LevelLoading)
var URL				LastURL;
var config array<string>	ServerActors,
					ServerPackages;

var int	LTEMusicHandle;			// PSV: 3/31/2005 Added for LTE music playback on PC

var array<object> DummyArray;	// Do not modify
var object        DummyObject;  // Do not modify

var bool		  bCheatProtection;

var config String MainMenuClass;			// Menu that appears when you first start
var config String InitialMenuClass;			// The initial menu that should appear
var config String ConnectingMenuClass;		// Menu that appears when you are connecting
var config String DisconnectMenuClass;		// Menu that appears when you are disconnected
var config String DisconnectMenuArg;		// Passed along as MENUARG1 when disconnected
var config String LoadingClass;				// Loading screen that appears
var config String PopupSPMenuClass;			// Single player in-game popup menu
var config String PopupMPMenuClass;			// Multiplayer in-game popup menu
var config String PopupMPServerMenuClass;	// Multiplayer server in-game popup menu
var config String SuccessMenuClass;			// displays when a SP mission is completed successfully
var config String FailedMenuClass;			// displays when a SP mission is failed
var config String ModName;
var config String ConnectErrorMenuClass;	// Menu that appears when connection errors occur
var config String LinkLostMenuClass;


defaultproperties
{
    MainMenuClass=""
    InitialMenuClass=""
    ConnectingMenuClass=""
    DisconnectMenuClass=""
	DisconnectMenuArg=""
    LoadingClass=""

	PopupSPMenuClass=""
	PopupMPMenuClass=""
	PopupMPServerMenuClass=""

	SuccessMenuClass="GUI.gbx_SPMissionBriefing"
	FailedMenuClass="GUI.gbx_SPMissionFailed"

	ConnectErrorMenuClass="GUI.gbx_DlgConnectError"
	LinkLostMenuClass="GUI.gbx_DlgLinkLost"
}
//=============================================================================
// GameInfo.
//
// The GameInfo defines the game being played: the game rules, scoring, what actors
// are allowed to exist in this game type, and who may enter the game.  While the
// GameInfo class is the public interface, much of this functionality is delegated
// to several classes to allow easy modification of specific game components.  These
// classes include GameInfo, AccessControl, Mutator, BroadcastHandler, and GameRules.
// A GameInfo actor is instantiated when the level is initialized for gameplay (in
// C++ UGameEngine::LoadMap() ).  The class of this GameInfo actor is determined by
// (in order) either the DefaultGameType if specified in the LevelInfo, or the
// DefaultGame entry in the game's .ini file (in the Engine.Engine section), unless
// its a network game in which case the DefaultServerGame entry is used.
//
//=============================================================================
class GameInfo extends Info
	native;


cpptext
{
	void AGameInfo::AddFearedNode( UActorLite* pNode );
}

//-----------------------------------------------------------------------------
// Variables.

var bool				bRestartLevel;			// Level should be restarted when player dies
var bool				bPauseable;				// Whether the game is pauseable.
var bool				bOraclePauseable;		// GEARBOX/jmw:add - Oracle cam semi-pause mode.
var config bool			bWeaponStay;			// Whether or not weapons stay when picked up.
var	bool				bCanChangeSkin;			// Allow player to change skins in game.
var bool				bTeamGame;				// This is a team game.
var	bool				bGameEnded;				// set when game ends
var	bool				bOverTime;
var localized bool		bAlternateMode;
var	bool				bCanViewOthers;
var bool				bDelayedStart;
var bool				bWaitingToStartMatch;
var globalconfig bool	bChangeLevels;
var	bool				bAlreadyChanged;
var bool				bLoggingGame;			// Does this gametype log?
var globalconfig bool	bEnableStatLogging;		// If True, games will log
var config bool			bAllowWeaponThrowing;
var config bool			bAllowBehindView;
var globalconfig bool	bAdminCanPause;
var bool				bGameRestarted;
var bool				bKeepSamePlayerStart;	// used in post login
var bool				bDestroyVisibleDeadBodies; // Should the game avoid removing dead bodies that are in the player's view?
var globalconfig bool	bNoShadows;				// If true, then don't render shadows for characters
var globalconfig bool	bBlobShadowsOnly;		// Don't do stencil shadows, just blobs
var globalconfig bool	bCheatsEnabled;			// GBX:naj - Set this to true to enable cheats.  Yatta!
var bool				bWasCycle;
var bool				bNoLobby;
var config bool			bHoldFire;				// don't fire until the player has fired

var float				DestroyDeadBodyTimer;	// How long to wait before removing bodies from the world
var float				fHoldFireTime;			// last time the player fired his weapon or last time a pawn was fired upon

var globalconfig float	GameDifficulty;
var globalconfig int	GoreLevel;				// 0=Normal, increasing values=less gore
var globalconfig float	AutoAim;				// How much autoaiming to do (1 = none, 0 = always).
												// (cosine of max error to correct)
var globalconfig float	GameSpeed;				// Scale applied to game rate.
var float				StartTime;

var string				DefaultPlayerClassName;

// user interface
var string			ScoreBoardType;			// Type of class<Menu> to use for scoreboards. (gam)
var string			BotMenuType;			// Type of bot menu to display.
var string			RulesMenuType;			// Type of rules menu to display.
var string			SettingsMenuType;		// Type of settings menu to display.
var string			GameUMenuType;			// Type of Game dropdown to display.
var string			MultiplayerUMenuType;	// Type of Multiplayer dropdown to display.
var string			GameOptionsMenuType;	// Type of options dropdown to display.
var config string	HUDType;				// HUD class this game uses.
var string			MapListType;			// Maplist this game uses.
var string			MapPrefix;				// Prefix characters for names of maps for this game type.
var string			BeaconName;				// Identifying string used for finding LAN servers.
var string			activemutators;			///JER
var config string	ServerName;			// rss: made config for ini setting
var config string	ShortName;			// rss: made config for ini setting

var globalconfig int	MaxSpectators;			// Maximum number of spectators.
var int					NumSpectators;			// Current number of spectators.
var globalconfig int	MaxPlayers;
var int					NumPlayers;				// number of human players
//SDJ 04/09/2004: From UC.
// gam: Xbox Live! ---
var()   globalconfig int	NumReservedSlots;	// number of spaces to keep for invited players
var()   int					NumInvitedPlayers;	// number of invited players connected
// --- gam
var	int					NumBots;				// number of non-human players (AI controlled but participating as a player)
var int					CurrentID;
var localized string	DefaultPlayerName;
var localized string	GameName;
var float				FearCostFallOff;		// how fast the FearCost in NavigationPoints falls off
var int					MaxFearCost;			// maximum allowed value for FearCost in NavigationPoints

var config int			GoalScore;				// what score is needed to end the match
var config int			MaxLives;				// max number of lives for match, unless overruled by level's GameDetails
var config int			TimeLimit;				// time limit in minutes

var array<ActorLite>	FearedNodes;

// Message classes.
var class<LocalMessage>		DeathMessageClass;
var class<GameMessage>		GameMessageClass;
var	name					OtherMesgGroup;

//-------------------------------------
// GameInfo components
var string MutatorClass;
var Mutator BaseMutator;				// linked list of Mutators (for modifying actors as they enter the game)
var globalconfig string AccessControlClass;
var AccessControl AccessControl;		// AccessControl controls whether players can enter and/or become admins
var GameRules GameRulesModifiers;		// linked list of modifier classes which affect game rules
var string BroadcastHandlerClass;
var BroadcastHandler BroadcastHandler;	// handles message (text and localized) broadcasts

var class<PlayerController> PlayerControllerClass;	// type of player controller to spawn for players logging in
var string PlayerControllerClassName;

// ReplicationInfo
var() class<GameReplicationInfo> GameReplicationInfoClass;
var GameReplicationInfo GameReplicationInfo;
var bool bWelcomePending;

// Stats - jmw
var GameStats                   GameStats;				// Holds the GameStats actor
var globalconfig string				GameStatsClass;			// Type of GameStats actor to spawn

// jij ---
// Voice chatters & channels
struct VoiceChatter
{
	var PlayerController Chatter;
	var XboxAddr xbAddr;
	var int PortNo;
};

struct VoiceChannel
{
    var() int NumChatters;
};

var array<VoiceChatter> VoiceChatters;
var() array<VoiceChannel> VoiceChannels;
var() int NumVoiceChannels;

const VoiceChannelAllPlayers=2;
const VoiceChannelUS=3;
const VoiceChannelGerman=4;
// --- jij

// Cheat Protection
var globalconfig string			SecurityClass;

var() String ScreenShotName;
var() String DecoTextName;
var() String Acronym;

// localized PlayInfo descriptions & extra info
var private localized string GIPropsDisplayText[11];
var private localized string GIPropsExtras[2];

// GBX:naj - added 10/28/03 - Suppression Cache interface pointer.
var transient ISeeAndSuppressCache CSSCache;

// GBX:sjp - oracle cam flag
var bool	bOracleCamActive;		// TODO remove globalized oracle system.

native function UpdateFearCostFallOff();


function SetCurrentGameProfile(GameProfile gProfile)
{
    local Manifest savedGameManifest;
    local int i;
    local string gameName;

    Level.CurrentGameProfile = gProfile;

    if (gProfile == None)
    {
        savedGameManifest = Level.SaveGameGetManifest();
        for (i=0; i < savedGameManifest.ManifestEntries.Length; ++i)
        {
            if (savedGameManifest.ManifestEntries[i].gProfile != None)
            {
                gameName = GameProfile(savedGameManifest.ManifestEntries[i].gProfile).GetGameName();
                Level.SaveGameUnloadPackage(gameName);
            }
        }
    }
}
// --- sjs, amb

function PreBeginPlay()
{
	StartTime = 0;
	SetGameSpeed(GameSpeed);
	GameReplicationInfo = Spawn(GameReplicationInfoClass);
	InitGameReplicationInfo();
	// Create stat logging actor.
    InitLogging();
}

function UpdatePrecacheMaterials()
{
	PrecacheGameTextures(Level);
}

function UpdatePrecacheStaticMeshes()
{
	PrecacheGameStaticMeshes(Level);
}

static function PrecacheGameTextures(LevelInfo myLevel);
static function PrecacheGameStaticMeshes(LevelInfo myLevel);
static function PrecacheGameMeshes(LevelInfo myLevel);

function string FindPlayerByID( int PlayerID )
{
    local int i;

    for( i=0; i<GameReplicationInfo.PRIArray.Length; i++ )
    {
        if( GameReplicationInfo.PRIArray[i].PlayerID == PlayerID )
            return GameReplicationInfo.PRIArray[i].PlayerName;
    }
    return "";
}

static function bool UseLowGore()
{
	return ( Default.bAlternateMode || (Default.GoreLevel > 0) );
}

function PostBeginPlay()
{
	if (GameStats!=None)
	{
		GameStats.NewGame();
		GameStats.ServerInfo();
	}

	if (Level.NetMode != NM_Standalone)
		bHoldFire = false;  // if this game is NOT single player, turn the "hold fire" feature off
}

/* Reset()
reset actor to initial state - used when restarting level without reloading.
*/
function Reset()
{
	Super.Reset();
	bGameEnded = false;
	bOverTime = false;
	bWaitingToStartMatch = true;
	InitGameReplicationInfo();
}

/* InitLogging()
Set up statistics logging
*/
function InitLogging()
{
	local class <GameStats> MyGameStatsClass;

    if ( !bEnableStatLogging || !bLoggingGame || (Level.NetMode == NM_Standalone) || (Level.NetMode == NM_ListenServer) )
		return;

	MyGameStatsClass=class<GameStats>(DynamicLoadObject(GameStatsClass,class'class'));
    if (MyGameStatsClass!=None)
    {
		GameStats = spawn(MyGameStatsClass);
        if (GameStats==None)
        	log("Could to create Stats Object");
    }
    else
    	log("Error loading GameStats ["$GameStatsClass$"]");
}

function Timer()
{
	local int i;

    // If we are a server, broadcast a welcome message.
    if( bWelcomePending )
    {
		bWelcomePending = false;
		if ( Level.NetMode != NM_Standalone )
		{
			for ( i=0; i<GameReplicationInfo.PRIArray.Length; i++ )
				if ( (GameReplicationInfo.PRIArray[i] != None)
					&& !GameReplicationInfo.PRIArray[i].bWelcomed )
				{
					GameReplicationInfo.PRIArray[i].bWelcomed = true;
					if ( !GameReplicationInfo.PRIArray[i].bOnlySpectator )
						BroadcastLocalizedMessage(GameMessageClass, 1, GameReplicationInfo.PRIArray[i]);
				}
		}
	}

	BroadcastHandler.UpdateSentText();

	UpdateFearCostFallOff();
}

// Called when game shutsdown.
event GameEnding()
{
	EndLogging("serverquit");
}

//------------------------------------------------------------------------------
// Replication

function InitGameReplicationInfo()
{
	GameReplicationInfo.bTeamGame = bTeamGame;
	GameReplicationInfo.GameName = GameName;
	GameReplicationInfo.GameClass = string(Class);
    GameReplicationInfo.MaxLives = MaxLives;
    GameReplicationInfo.MaxPlayers = MaxPlayers;
    GameReplicationInfo.mutators = activemutators; //JER
	if (ServerName != "")
		GameReplicationInfo.ServerName = ServerName;
	if (ShortName != "")
		GameReplicationInfo.ShortName = ShortName;
}

native function string GetNetworkNumber();

//------------------------------------------------------------------------------
// Server/Game Querying.

function GetServerInfo( out ServerResponseLine ServerState )
{
	ServerState.ServerName		= GameReplicationInfo.ServerName;
	ServerState.MapName			= Level.GetLevelFileName();//Left(string(Level), InStr(string(Level), "."));
	ServerState.GameType		= Mid( string(Class), InStr(string(Class), ".")+1);
	ServerState.CurrentPlayers	= GetNumPlayers();
	ServerState.MaxPlayers		= MaxPlayers;
	ServerState.IP				= ""; // filled in at the other end.
	ServerState.Port			= GetServerPort();

	ServerState.ServerInfo.Length = 0;
	ServerState.PlayerInfo.Length = 0;
}

function int GetNumPlayers()
{
	return NumPlayers + NumSpectators;
}

function GetServerDetails( out ServerResponseLine ServerState )
{
	local int i;
	local Mutator M;
	local GameRules G;

	i = ServerState.ServerInfo.Length;

	// servermode
	ServerState.ServerInfo.Length = i+1;
	ServerState.ServerInfo[i].Key = "servermode";
	if( Level.NetMode==NM_ListenServer )
		ServerState.ServerInfo[i++].Value = "non-dedicated";
    else
		ServerState.ServerInfo[i++].Value = "dedicated";

	// adminname
	ServerState.ServerInfo.Length = i+1;
	ServerState.ServerInfo[i].Key = "adminname";
	ServerState.ServerInfo[i++].Value = GameReplicationInfo.AdminName;

	// adminemail
	ServerState.ServerInfo.Length = i+1;
	ServerState.ServerInfo[i].Key = "adminemail";
	ServerState.ServerInfo[i++].Value = GameReplicationInfo.AdminEmail;

	// adminemail
	ServerState.ServerInfo.Length = i+1;
	ServerState.ServerInfo[i].Key = "ServerVersion";
	ServerState.ServerInfo[i++].Value = level.EngineVersion;

	// has password
	if( AccessControl.RequiresPassword() )
		{
		ServerState.ServerInfo.Length = i+1;
		ServerState.ServerInfo[i].Key = "password";
		ServerState.ServerInfo[i++].Value = "true";
	}

	// has stats enabled
	ServerState.ServerInfo.Length = i+1;
	ServerState.ServerInfo[i].Key = "gamestats";
	if( GameStats!=None )
		ServerState.ServerInfo[i++].Value = "true";
	else
		ServerState.ServerInfo[i++].Value = "false";

	// game speed
	if( GameSpeed != 1.0 )
			{
		ServerState.ServerInfo.Length = i+1;
		ServerState.ServerInfo[i].Key = "gamespeed";
		ServerState.ServerInfo[i++].Value = string( int(GameSpeed*100)/100.0 );
	}

	// Ask the mutators if they have anything to add.
	for (M = BaseMutator.NextMutator; M != None; M = M.NextMutator)
		M.GetServerDetails(ServerState);

	// Ask the gamerules if they have anything to add.
	for ( G=GameRulesModifiers; G!=None; G=G.NextGameRules )
		G.GetServerDetails(ServerState);
}

function GetServerPlayers( out ServerResponseLine ServerState )
{
    local Mutator M;
	local Controller C;
	local PlayerReplicationInfo PRI;
	local int i;

	i = ServerState.PlayerInfo.Length;

	for( C=Level.ControllerList;C!=None;C=C.NextController )
        {
			PRI = C.PlayerReplicationInfo;
			if( (PRI != None) && !PRI.bBot && MessagingSpectator(C) == None )
            {
			ServerState.PlayerInfo.Length = i+1;
			ServerState.PlayerInfo[i].PlayerNum  = C.PlayerNum;
			ServerState.PlayerInfo[i].PlayerName = PRI.PlayerName;
			ServerState.PlayerInfo[i].Score		 = PRI.Score;
			ServerState.PlayerInfo[i].Ping		 = PRI.Ping;
			i++;
		}
	}

	// Ask the mutators if they have anything to add.
	for (M = BaseMutator.NextMutator; M != None; M = M.NextMutator)
		M.GetServerPlayers(ServerState);
}

//------------------------------------------------------------------------------
// Misc.

// Return the server's port number.
function int GetServerPort()
{
	local string S;
	local int i;

	// Figure out the server's port.
	S = Level.GetAddressURL();
	i = InStr( S, ":" );
	assert(i>=0);
	return int(Mid(S,i+1));
}

function bool SetPause( BOOL bPause, PlayerController P )
{
    if( bPauseable || (bAdminCanPause && (P.IsA('Admin') || P.PlayerReplicationInfo.bAdmin)) || Level.Netmode==NM_Standalone )
	{
		if( bPause )
			Level.Pauser=P.PlayerReplicationInfo;
		else
			Level.Pauser=None;
		return True;
	}
	else return False;
}

// << GEARBOX/jmw:add - Oracle cam special semi-pause mode.
function bool SetOraclePause( BOOL bPause, PlayerController P )
{
    if( bOraclePauseable || Level.Netmode==NM_Standalone )
	{
		if( bPause )
			Level.OraclePauser=P.PlayerReplicationInfo;
		else
			Level.OraclePauser=None;
		return true;
	}
	else return false;
}
// GEARBOX >>

//------------------------------------------------------------------------------
// Voice chat.
// jij ---
function InitializeVoiceChannels()
{
    local int i;

    log("Voice --- Initializing " $ NumVoiceChannels $ " voice channels.");

    VoiceChannels.Insert(0,NumVoiceChannels);
	VoiceChatters.Insert(0,4);

    // initialize each channel
    for(i = 0; i < VoiceChannels.Length; i++)
    {
        VoiceChannels[i].NumChatters = 0;
    }

    // initialize each channel
    for(i = 0; i < VoiceChatters.Length; i++)
    {
        VoiceChatters[i].Chatter = None;
    }
}

function JoinBestVoiceChannel( PlayerController Client, XboxAddr xbAddr, int PortNo, bool InfoValid )
{
    local int i;

    // find the first non-full voice channel
    for(i = 0; i < VoiceChannels.Length; i++)
    {
        if (VoiceChannels[i].NumChatters < 4 && IsVoiceChannelValid(Client,i))
            break;
    }

	if (i != VoiceChannels.Length)
	{
		JoinVoiceChannel(client, xbAddr, PortNo, i, InfoValid);
	}
}

function LeaveVoiceChannel( PlayerController Client, XboxAddr xbAddr, int PortNo, int Channel, bool InfoValid )
{
    local int i;

    if (Channel < 0)
        Channel = Client.VoiceChannel;
    if (Channel < 0)
        return;

    for(i = 0; i < 4; i++)
    {
        if (VoiceChatters[i].Chatter == Client)
        {
            if (!InfoValid)
            {
                xbAddr = VoiceChatters[i].xbAddr;
                PortNo = VoiceChatters[i].PortNo;
            }

            break;
        }
    }

    if (i == 4)
        return;

	VoiceChannels[Channel].NumChatters--;

    // tell this player about everyone else in the channel, and tell everyone else in the channel
    // about this player
    for(i = 0; i < VoiceChatters.Length; i++)
    {
        if (VoiceChatters[i].Chatter != None)
        {
            VoiceChatters[i].Chatter.ClientChangeVoiceChatter( XbAddr, PortNo, false );

			if (VoiceChatters[i].Chatter == Client)
			{
				VoiceChatters[i].Chatter = None;
			}
        }
    }

    Client.bHasVoice = false;
    Client.PlayerReplicationInfo.bHasVoice = false;

    Client.VoiceChannel = -1;
    Client.PlayerReplicationInfo.VoiceChannel = -1;

    if( InfoValid )
        Client.ClientChangeChannel(-1);
}

function bool IsVoiceChannelValid(PlayerController Client, int Channel)
{
    // in non-team games, a player may join any channel
    return true;
}

function bool JoinVoiceChannel( PlayerController Client, XboxAddr xbAddr, int PortNo, int Channel, bool InfoValid )
{
    local int i;

	log(self $ " GameInfo::JoinVoiceChannel(): Client = " $ Client $ ", Channel = " $ Channel, 'MP');

    // fail on invalid channel requests
    if (Channel < 0 || Channel >= VoiceChannels.Length)
        return false;

    // fail if the requested channel is full
    if (VoiceChannels[Channel].NumChatters == 4)
        return false;

    // fail if game conditions prevent this player to join this channel
    if (!IsVoiceChannelValid(Client,Channel))
        return false;

    if (!InfoValid)
    {
        if (Client.VoiceChannel < 0)
            return false;

        // find this player in their current channel
        for(i = 0; i < 4; i++)
        {
            if (VoiceChatters[i].Chatter == Client)
            {
                xbAddr = VoiceChatters[i].xbAddr;
                PortNo = VoiceChatters[i].PortNo;
                break;
            }
        }

        if (i == 4)
            return false;
    }

    // leave the channel the player is currently in
    if (Client.bHasVoice && Client.VoiceChannel >= 0)
        LeaveVoiceChannel(Client,xbAddr,PortNo,Client.VoiceChannel,true);

	xbAddr.VoiceChannel = Channel;

    // join the new channel
	VoiceChannels[Channel].NumChatters++;

    // tell this player about everyone else, and tell everyone else about this player
	for(i = 0; i < VoiceChatters.Length; i++)
	{
		if (VoiceChatters[i].Chatter != None)
		{
			Client.ClientChangeVoiceChatter( VoiceChatters[i].XbAddr, VoiceChatters[i].PortNo, true );
			VoiceChatters[i].Chatter.ClientChangeVoiceChatter( XbAddr, PortNo, true );
		}
	}
	Client.ClientChangeVoiceChatter( XbAddr, PortNo, true, true );

	for(i = 0; i < VoiceChatters.Length; i++)
    {
        if (VoiceChatters[i].Chatter == None)
        {
			VoiceChatters[i].Chatter = Client;
            VoiceChatters[i].xbAddr = xbAddr;
            VoiceChatters[i].PortNo = PortNo;

            break;
        }
    }

    Client.bHasVoice = true;
    Client.PlayerReplicationInfo.bHasVoice = true;

    Client.VoiceChannel = Channel;
    Client.PlayerReplicationInfo.VoiceChannel = Channel;

    Client.ClientChangeChannel(Channel);

    return true;
}
// --- jij

//------------------------------------------------------------------------------
// Game parameters.

//
// Set gameplay speed.
//
function SetGameSpeed( Float T )
{
	local float OldSpeed;

	OldSpeed = GameSpeed;
	GameSpeed = FMax(T, 0.1);
	Level.TimeDilation = GameSpeed;
	if ( GameSpeed != OldSpeed )
    {
		Default.GameSpeed = GameSpeed;
		class'GameInfo'.static.StaticSaveConfig();
	}
	SetTimer(Level.TimeDilation, true);
}

//
// Called after setting low or high detail mode.
//
event DetailChange()
{
	local actor A;
	local zoneinfo Z;

    if( Level.DetailMode == DM_Low )
	{
		foreach DynamicActors(class'Actor', A)
		{
            if( (A.bHighDetail || A.bSuperHighDetail) && !A.bGameRelevant )
                A.Destroy();
        }
    }
    else if( Level.DetailMode == DM_High )
    {
        foreach DynamicActors(class'Actor', A)
        {
            if( A.bSuperHighDetail && !A.bGameRelevant )
				A.Destroy();
		}
	}
	foreach AllActors(class'ZoneInfo', Z)
		Z.LinkToSkybox();
}

//------------------------------------------------------------------------------
// Player start functions

//
// Grab the next option from a string.
//
static function bool GrabOption( out string Options, out string Result )
{
	if( Left(Options,1)=="?" )
	{
		// Get result.
		Result = Mid(Options,1);
		if( InStr(Result,"?")>=0 )
			Result = Left( Result, InStr(Result,"?") );

		// Update options.
		Options = Mid(Options,1);
		if( InStr(Options,"?")>=0 )
			Options = Mid( Options, InStr(Options,"?") );
		else
			Options = "";

		return true;
	}
	else return false;
}

//
// Break up a key=value pair into its key and value.
//
static function GetKeyValue( string Pair, out string Key, out string Value )
{
	if( InStr(Pair,"=")>=0 )
	{
		Key   = Left(Pair,InStr(Pair,"="));
		Value = Mid(Pair,InStr(Pair,"=")+1);
	}
	else
	{
		Key   = Pair;
		Value = "";
	}
}

/* ParseOption()
 Find an option in the options string and return it.
*/
static function string ParseOption( string Options, string InKey )
{
	local string Pair, Key, Value;
	while( GrabOption( Options, Pair ) )
	{
		GetKeyValue( Pair, Key, Value );
		if( Key ~= InKey )
			return Value;
	}
	return "";
}

//
// HasOption - return true if the option is specified on the command line.
//
function bool HasOption( string Options, string InKey )
{
    local string Pair, Key, Value;
    while( GrabOption( Options, Pair ) )
    {
        GetKeyValue( Pair, Key, Value );
        if( Key ~= InKey )
            return true;
    }
    return false;
}

/* Initialize the game.
 The GameInfo's InitGame() function is called before any other scripts (including
 PreBeginPlay() ), and is used by the GameInfo to initialize parameters and spawn
 its helper classes.
 Warning: this is called before actors' PreBeginPlay.
*/
event InitGame( string Options, out string Error )
{
	local string InOpt, LeftOpt;
	local int pos;
	local class<AccessControl> ACClass;
	local class<GameRules> GRClass;
	local class<BroadcastHandler> BHClass;

	log( "InitGame:" @ Options );

    MaxPlayers = Clamp(GetIntOption( Options, "MaxPlayers", MaxPlayers ),0,32);
    MaxSpectators = Clamp(GetIntOption( Options, "MaxSpectators", MaxSpectators ),0,32);
//    GameDifficulty = FMax(0,GetIntOption(Options, "Difficulty", GameDifficulty));

	InOpt = ParseOption( Options, "ServerName" );
	if (InOpt != "")
		ServerName = InOpt;
	InOpt = ParseOption( Options, "ShortName" );
	if (InOpt != "")
		ShortName = InOpt;

	// set up the game difficulty for single player
	if (Level.NetMode == NM_Standalone)
	{
		InOpt = ParseOption( Options, "Difficulty");
		if( InOpt != "" )
		{
			GameDifficulty = FClamp(int(InOpt), EDifficulty.DIFF_Easy, EDifficulty.DIFF_Authentic);

			Level.DifficultyLevel = EDifficulty(GameDifficulty);
			log("Applied difficulty=" $ Level.DifficultyLevel );
		}
		InOpt = ParseOption( Options, "Checkpoint");
		if( InOpt != "" )
		{
			Level.CheckpointID = int(InOpt);
			log("Applied checkpoint id=" $ Level.CheckpointID );
		}
		InOpt = ParseOption( Options, "DebugCheckpoint");
		if( InOpt != "" )
		{
			Level.DebugCheckpointID = int(InOpt);
			log("Applied debug checkpoint id=" $ Level.DebugCheckpointID );
		}
	}

	NumReservedSlots = Min( 32,GetIntOption( Options, "ReservedSlots", NumReservedSlots )); //SDJ 07/21/2004: From UC.

	InOpt = ParseOption( Options, "GameSpeed");
	if( InOpt != "" )
	{
		log("GameSpeed"@InOpt);
		SetGameSpeed(float(InOpt));
	}

    AddMutator(MutatorClass);

	BHClass = class<BroadcastHandler>(DynamicLoadObject(BroadcastHandlerClass,Class'Class'));
	BroadcastHandler = spawn(BHClass);

	InOpt = ParseOption( Options, "AccessControl");
	if( InOpt != "" )
		ACClass = class<AccessControl>(DynamicLoadObject(InOpt, class'Class'));
    if ( ACClass == None )
	{
		ACClass = class<AccessControl>(DynamicLoadObject(AccessControlClass, class'Class'));
		if (ACClass == None)
			ACClass = class'Engine.AccessControl';
	}

	LeftOpt = ParseOption( Options, "AdminName" );
	InOpt = ParseOption( Options, "AdminPassword");
	if( LeftOpt!="" && InOpt!="" )
		ACClass.default.bDontAddDefaultAdmin = true;

	AccessControl = Spawn(ACClass);
//FIXME_MERGE	if (AccessControl != None && LeftOpt!="" && InOpt!="" )
//        AccessControl.SetAdminFromURL(LeftOpt, InOpt);

	InOpt = ParseOption( Options, "GameRules");
	if ( InOpt != "" )
	{
		log("Game Rules"@InOpt);
		while ( InOpt != "" )
		{
			pos = InStr(InOpt,",");
			if ( pos > 0 )
			{
				LeftOpt = Left(InOpt, pos);
				InOpt = Right(InOpt, Len(InOpt) - pos - 1);
			}
			else
			{
				LeftOpt = InOpt;
				InOpt = "";
			}
			log("Add game rules "$LeftOpt);
			GRClass = class<GameRules>(DynamicLoadObject(LeftOpt, class'Class'));
			if ( GRClass != None )
			{
				if ( GameRulesModifiers == None )
					GameRulesModifiers = Spawn(GRClass);
				else
					GameRulesModifiers.AddGameRules(Spawn(GRClass));
			}
		}
	}

	log("Base Mutator is "$BaseMutator);

	InOpt = ParseOption( Options, "Mutator");
	if ( InOpt != "" )
	{
		log("Mutators"@InOpt);

		activemutators = InOpt;//JER

		while ( InOpt != "" )
		{
			pos = InStr(InOpt,",");
			if ( pos > 0 )
			{
				LeftOpt = Left(InOpt, pos);
				InOpt = Right(InOpt, Len(InOpt) - pos - 1);
			}
			else
			{
				LeftOpt = InOpt;
				InOpt = "";
			}
			log("Add mutator "$LeftOpt);
            AddMutator(LeftOpt, true);
		}
	}

	InOpt = ParseOption( Options, "GamePassword");
	if( InOpt != "" )
	{
		AccessControl.SetGamePassWord(InOpt);
		log( "GamePassword" @ InOpt );
	}

    InOpt = ParseOption( Options,"AllowThrowing");
    if ( InOpt != "" )
    	bAllowWeaponThrowing = bool (InOpt);

	InOpt = ParseOption( Options,"AllowBehindview");
    if ( InOpt != "" )
    	bAllowBehindview = bool ( InOpt);

	InOpt = ParseOption(Options, "GameStats");
	if ( InOpt != "")
		bEnableStatLogging = bool(InOpt);
	else
		bEnableStatLogging = false;

	log("GameInfo::InitGame : bEnableStatLogging"@bEnableStatLogging);

	if( HasOption(Options, "DemoRec") )
		Log( Level.ConsoleCommand("demorec"@ParseOption(Options, "DemoRec")) );

    bWasCycle = HasOption( Options,"wascycle" );
    bNoLobby = HasOption( Options,"NoLobby" );

	log("GameInfo::InitGame : bWasCycle="$bWasCycle @"bNoLobby="$bNoLobby);
    // jij ---
    InitializeVoiceChannels();
    // --- jij
}

function AddMutator(string mutname, optional bool bUserAdded)
{
    local class<Mutator> mutClass;
    local Mutator mut;

    mutClass = class<Mutator>(DynamicLoadObject(mutname, class'Class'));
    if (mutClass == None)
        return;

	if ( (mutClass.Default.GroupName != "") && (BaseMutator != None) )
	{
		// make sure no mutators with same groupname
		for ( mut=BaseMutator; mut!=None; mut=mut.NextMutator )
			if ( mut.GroupName == mutClass.Default.GroupName )
				return;
	}

    mut = Spawn(mutClass);
	// mc, beware of mut being none
	if (mut == None)
		return;

	// Meant to verify if this mutator was from Command Line parameters or added from other Actors
	mut.bUserAdded = bUserAdded;

    if (BaseMutator == None)
        BaseMutator = mut;
    else
        BaseMutator.AddMutator(mut);
}

//
// Return beacon text for serverbeacon.
//
event string GetBeaconText()
{
	// GBX:CEK: 5/11/2004 - merged from UC
    local String BeaconText;
    local String MapName;
    local PlayerController PC;
    local String HostName;

    HostName = ServerName;

	for( PC = Level.PlayerControllerList; PC != None; PC = PC.nextPlayerController )
    {
        if( (NetConnection(PC.Player) == None) && (PC.PlayerReplicationInfo != None) )
        {
            HostName = PC.PlayerReplicationInfo.PlayerName;
// PlayerControllerList is in the opposite direction            break;
        }
    }

    MapName = Level.GetLevelFileName();//String(Level);
//    MapName = Left( MapName, InStr(MapName, ".") );
    
    BeaconText = 
        "###" @
        "\"" $ HostName $ "\""  @
		Class @
//        Acronym @
        "\"" $ MapName $ "\"" @
        GetNumPlayers() @
        MaxPlayers @
        "###";

    return( BeaconText );        
}

/* ProcessServerTravel()
 Optional handling of ServerTravel for network games.
*/
function ProcessServerTravel( string URL, bool bItems )
{
	local playercontroller P, LocalPlayer;

    // Pass it along
    BaseMutator.ServerTraveling(URL,bItems);

	EndLogging("mapchange");

	// Notify clients we're switching level and give them time to receive.
	// We call PreClientTravel directly on any local PlayerPawns (ie listen server)
	log("ProcessServerTravel:"@URL);
	foreach DynamicActors( class'PlayerController', P )
		if( NetConnection( P.Player)!=None )
			P.ClientTravel( URL, TRAVEL_Relative, bItems );
		else
		{
			LocalPlayer = P;
			P.PreClientTravel();
		}

	if ( (Level.NetMode == NM_ListenServer) && (LocalPlayer != None) )
        Level.NextURL = Level.NextURL
					 $"?Team="$LocalPlayer.GetDefaultURL("Team")
					 $"?Name="$LocalPlayer.GetDefaultURL("Name")
                     $"?Class="$LocalPlayer.GetDefaultURL("Class")
                     $"?Character="$LocalPlayer.GetDefaultURL("Character");

	// Switch immediately if not networking.
	if( Level.NetMode!=NM_DedicatedServer && Level.NetMode!=NM_ListenServer )
		Level.NextSwitchCountdown = 0.0;
}

native final function bool PreServerTravel(string URL); // gam // GEARBOX - stuff from UC to support rebooting and network games 2004-06-06 JWS

//
// Accept or reject a player on the server.
// Fails login if you set the Error to a non-empty string.
//
event PreLogin
(
	string Options,
	string Address,
	out string Error,
	out string FailCode
)
{
	local bool bSpectator;

    bSpectator = ( ParseOption( Options, "SpectatorOnly" ) ~= "true" );
	AccessControl.PreLogin(Options, Address, Error, FailCode, bSpectator);
}

function int GetIntOption( string Options, string ParseString, int CurrentValue)
{
	local string InOpt;

	InOpt = ParseOption( Options, ParseString );
	if ( InOpt != "" )
	{
		log(ParseString@InOpt);
		return int(InOpt);
	}
	return CurrentValue;
}

// gam ---
event bool AtCapacity( bool bSpectator, bool bInvited )
{
	if ( Level.NetMode == NM_Standalone )
		return false;

	return ((NumPlayers + NumSpectators) >= MaxPlayers);
}

function UpdateCapacity()
{
    local String S;
    
    if( GameReplicationInfo == None )
        return;

    GameReplicationInfo.bJoinable = !AtCapacity(false,false);
    GameReplicationInfo.bInvitable = !AtCapacity(false,true);

    S = "Capacity updated:";
    
    if( GameReplicationInfo.bJoinable )
        S = S @ "joinable,";
    else
        S = S @ "not joinable,";
    
    if( GameReplicationInfo.bInvitable )
        S = S @ "invitable.";
    else
        S = S @ "not invitable.";

    log( S );
}

// --- gam

//
// Log a player in.
// Fails login if you set the Error string.
// PreLogin is called before Login, but significant game time may pass before
// Login is called, especially if content is downloaded.
//
event PlayerController Login
(
	string Portal,
	string Options,
	out string Error
)
{
	local NavigationPoint StartSpot;
	local PlayerController NewPlayer;
	local Pawn      TestPawn;
    local string          InName, InAdminName, InPassword, InChecksum, InClass, InCharacter;
	local byte            InTeam;
    local bool bSpectator, bAdmin;
    local class<Security> MySecurityClass;
	local vector startloc;
	local rotator startrot;
	local bool bInvited;
	local bool bIsSplitPlayer;
	local int	i;

	bSpectator = ( ParseOption( Options, "SpectatorOnly" ) ~= "true" );
//FIXME_MERGE	bAdmin = AccessControl.CheckOptionsAdmin(Options);

	//SDJ 07/21/2004: From UC.
	// gam ---
    bInvited = bool(ParseOption( Options, "WasInvited" ) );
	bIsSplitPlayer = bool(ParseOption( Options, "IsSplitPlayer" ) );
    
    if( bInvited )
        log( "Logging in invited player." );
    // --- gam    

    // Make sure there is capacity except for admins. (This might have changed since the PreLogin call).
    if ( !bAdmin && AtCapacity(bSpectator, bInvited) )
	{
		if (!bIsSplitPlayer)
		{
			Error=class'gbxNetworkErrors'.Default.ErrorCodeServerFull;
		}
		else
		{
			Error=class'gbxNetworkErrors'.Default.ErrorCodeServerFullForYou;
		}
		return None;
	}

	// If admin, force spectate mode if the server already full of reg. players
	if ( bAdmin && AtCapacity(false, true))
		bSpectator = true;

	BaseMutator.ModifyLogin(Portal, Options);

	// Get URL options.
	InName     = Left(ParseOption ( Options, "Name"), 20);
	InTeam     = GetIntOption( Options, "Team", 255 ); // default to "no team"
    InAdminName= ParseOption ( Options, "AdminName");
	InPassword = ParseOption ( Options, "Password" );
	InChecksum = ParseOption ( Options, "Checksum" );

	log( "Login:" @ InName );

	//CTL - save/load game fix: begin move
	// Try to match up to existing unoccupied player in level,
	// for savegames and coop level switching.
	ForEach DynamicActors(class'Pawn', TestPawn )
	{
		if ( (TestPawn!=None) && (PlayerController(TestPawn.Controller)!=None) &&
			(PlayerController(TestPawn.Controller).Player==None) && (TestPawn.Health > 0)
			&& (TestPawn.OwnerName~=InName) )
		{
			TestPawn.SetRotation(TestPawn.Controller.Rotation);
			TestPawn.bInitializeAnimation = false; // FIXME - temporary workaround for lack of meshinstance serialization
			TestPawn.PlayWaiting();
			bWaitingToStartMatch = true; //CTL - save/load game fix: added
			bDelayedStart=false; //CTL - save/load game fix: added
			return PlayerController(TestPawn.Controller);
		}
	}
	//CTL - save/load game fix: end move

	// Pick a team (if need teams)
    InTeam = PickTeam(InTeam,None);

	// Find a start spot.
	StartSpot = FindPlayerStart( None, InTeam, Portal );

	if( StartSpot == None )
	{
		Error = GameMessageClass.Default.FailedPlaceMessage;
		return None;
	}
	else
	{
		startloc = StartSpot.Location;
		startrot = StartSpot.Rotation;

		GetModifiedPlayerStartView( StartSpot, startloc, startrot );
	}

		if ( PlayerControllerClass == None )
			PlayerControllerClass = class<PlayerController>(DynamicLoadObject(PlayerControllerClassName, class'Class'));

		NewPlayer = spawn(PlayerControllerClass,,,startloc,startrot);

	// Handle spawn failure.
	if( NewPlayer == None )
	{
		log("Couldn't spawn player controller of class "$PlayerControllerClass);
		Error = GameMessageClass.Default.FailedSpawnMessage;
		return None;
	}

	NewPlayer.StartSpot = StartSpot;

    // Init player's replication info
    NewPlayer.GameReplicationInfo = GameReplicationInfo;
	NewPlayer.GotoState('Spectating');

	if (StartSpot.Skins.Length > 0)
	{
		for( i = 0; i < StartSpot.Skins.Length; i++ )
		{
			NewPlayer.Pawn.Skins[i] = startSpot.Skins[i];
		}
	}

	// Apply security to this controller

	MySecurityClass=class<Security>(DynamicLoadObject(SecurityClass,class'class'));
    if (MySecurityClass!=None)
	{
		NewPlayer.PlayerSecurity = spawn(MySecurityClass,NewPlayer);
	    if (NewPlayer.PlayerSecurity==None)
			log("Could not spawn security for player "$NewPlayer,'Security');
	}
	else
	    log("Unknown security class ["$SecurityClass$"] -- System is no secure.",'Security');

	// Init player's name
	if( InName=="" )
		InName=DefaultPlayerName;
	if( Level.NetMode!=NM_Standalone || NewPlayer.PlayerReplicationInfo.PlayerName==DefaultPlayerName )
		ChangeName( NewPlayer, InName, false );

    if ( bSpectator || NewPlayer.PlayerReplicationInfo.bOnlySpectator )
	{
        NewPlayer.PlayerReplicationInfo.bOnlySpectator = true;
		NewPlayer.PlayerReplicationInfo.bIsSpectator = true;
        NewPlayer.PlayerReplicationInfo.bOutOfLives = true;
		NumSpectators++;
		return NewPlayer;
	}

	// Change player's team.
    if ( !ChangeTeam(newPlayer, InTeam, false) )
	{
		Error = GameMessageClass.Default.FailedTeamMessage;
		return None;
	}
	newPlayer.StartSpot = StartSpot;

    // Init player's administrative privileges and log it
/*FIXME_MERGE    if (AccessControl.AdminLogin(NewPlayer, InAdminName, InPassword))
    {
		AccessControl.AdminEntered(NewPlayer, InAdminName);
    }
*/
	// Set the player's ID.
	NewPlayer.PlayerReplicationInfo.PlayerID = CurrentID++;

	// set the player's lobby client number
	NewPlayer.PlayerReplicationInfo.LobbyClientNum = GetLobbyClientNum();

	InClass = ParseOption( Options, "Class" );

    if (InClass == "")
        InClass = DefaultPlayerClassName;
    InCharacter = ParseOption(Options, "Character");
    NewPlayer.SetPawnClass(InClass, InCharacter);

	NumPlayers++;
    bWelcomePending = true;

	//SDJ 07/21/2004: From UC.
	// gam ---
    newPlayer.bWasInvited = bInvited;
    if( newPlayer.bWasInvited )
    {
        log( "NumInvitedPlayers++" );
        NumInvitedPlayers++;
    }
    // --- gam

	// if delayed start, don't give a Pawn to the player yet
	// Normal for multiplayer games
	if ( bDelayedStart )
	{
		NewPlayer.GotoState('PlayerWaiting');
		return NewPlayer;
	}

/*	Moved to earlier in this function. See https://udn.epicgames.com/lists/showpost.php?list=unprog&id=35548&lessthan=&show=20.
	// Try to match up to existing unoccupied player in level,
	// for savegames and coop level switching.
	ForEach DynamicActors(class'Pawn', TestPawn )
	{
		if ( (TestPawn!=None) && (PlayerController(TestPawn.Controller)!=None) && (PlayerController(TestPawn.Controller).Player==None) && (TestPawn.Health > 0)
			&&  (TestPawn.OwnerName~=InName) )
		{
			NewPlayer.Destroy();
			TestPawn.SetRotation(TestPawn.Controller.Rotation);
			TestPawn.bInitializeAnimation = false; // FIXME - temporary workaround for lack of meshinstance serialization
			TestPawn.PlayWaiting();
			return PlayerController(TestPawn.Controller);
		}
	}
*/
	return newPlayer;
}

function int GetLobbyClientNum()
{
	local Controller P;
	local int i, nextClientNum;

	nextClientNum = 0;
	for (i=1; (i<=4) && (nextClientNum == 0); i++)
	{
		nextClientNum = i;
		for (P=Level.ControllerList; P!=None; P=P.NextController )
		{
			if ( P.IsA('PlayerController') && (P.PlayerReplicationInfo != None))
			{
				if (i == P.PlayerReplicationInfo.LobbyClientNum)
				{
					nextClientNum = 0;
					break;
				}
			}
		}
	}

	if (nextClientNum == 0)
		nextClientNum = 1;

	return nextClientNum;
}

/* StartMatch()
Start the game - inform all actors that the match is starting, and spawn player pawns
*/
function StartMatch()
{
	local Controller P;
	local Actor A;

	if (GameStats!=None)
		GameStats.StartGame();

	// tell all actors the game is starting
	ForEach AllActors(class'Actor', A)
		A.MatchStarting();

	// start human players first
	for ( P = Level.ControllerList; P!=None; P=P.nextController )
		if ( P.IsA('PlayerController') && (P.Pawn == None) )
		{
            if ( bGameEnded )
                return; // telefrag ended the game with ridiculous frag limit
            else if ( PlayerController(P).CanRestartPlayer()  )
				RestartPlayer(P);
		}

	// start AI players
/*	for ( P = Level.ControllerList; P!=None; P=P.nextController )
		if ( P.bIsPlayer && !P.IsA('PlayerController') )
        {
			if ( Level.NetMode == NM_Standalone )
				RestartPlayer(P);
        	else
				P.GotoState('Dead','MPStart');
		}
*/		// TODO testing jmw

	bWaitingToStartMatch = false;
	GameReplicationInfo.bMatchHasBegun = true;
}

//
// Restart a player.
//
function RestartPlayer( Controller aPlayer )
{
	local NavigationPoint startSpot;
	local int TeamNum, i;
	local class<Pawn> DefaultPlayerClass;
	local vector startloc;
	local rotator startrot;

	log( self$ " GameInfo::RestartPlayer() aPlayer: "$aPlayer$ " bRestartLevel: " $bRestartLevel$ " Level.NetMode: " $Level.NetMode, 'MP');

	if( bRestartLevel && Level.NetMode!=NM_DedicatedServer && Level.NetMode!=NM_ListenServer )
	{
		log( self$ " GameInfo::RestartPlayer() About to call restart game :(", 'MP');
		RestartGame();
		return;
	}

	if ( (aPlayer.PlayerReplicationInfo == None) || (aPlayer.PlayerReplicationInfo.Team == None) )
		TeamNum = 255;
	else
		TeamNum = aPlayer.PlayerReplicationInfo.Team.TeamIndex;

	startSpot = FindPlayerStart(aPlayer, TeamNum);
	if( startSpot == None )
	{
		log( self$ " GameInfo::RestartPlayer() No player start found!", 'MP');
		log(" Player start not found!!!");
		return;
	}
	else
	{
		startloc = StartSpot.Location;
		startrot = StartSpot.Rotation;

		GetModifiedPlayerStartView( StartSpot, startloc, startrot );
	}

	if (aPlayer.PreviousPawnClass!=None && aPlayer.PawnClass != aPlayer.PreviousPawnClass)
		BaseMutator.PlayerChangedClass(aPlayer);

	if ( aPlayer.PawnClass != None )
		aPlayer.Pawn = Spawn(aPlayer.PawnClass,,,startloc,startrot);

	log( self$ " GameInfo::RestartPlayer() aPlayer.Pawn: "$aPlayer.Pawn, 'MP');

	if( aPlayer.Pawn==None )
	{
		log("Couldn't spawn player of type "$aPlayer.PawnClass$" at "$StartSpot);
        DefaultPlayerClass = GetDefaultPlayerClass(aPlayer);
		aPlayer.Pawn = Spawn(DefaultPlayerClass,,,startloc,startrot);
	}
	if ( aPlayer.Pawn == None )
	{
		log("Couldn't spawn player of type "$DefaultPlayerClass$" at "$StartSpot);
		aPlayer.GotoState('Dead');
		return;
	}
    aPlayer.Pawn.Anchor = startSpot;
	aPlayer.Pawn.LastStartSpot = PlayerStart(startSpot);
	// PSV: 6/10/2004 Let's also save it in the controller for MP
	aPlayer.LastStartSpot = aPlayer.Pawn.LastStartSpot;
	aPlayer.Pawn.LastStartTime = Level.TimeSeconds;

	// PreviousPawnClass used to be set here, see below... 2005-01-19 JWS

	aPlayer.Possess(aPlayer.Pawn);
	aPlayer.PawnClass = aPlayer.Pawn.Class;
	if (startSpot.Skins.Length > 0)
	{
		for( i = 0; i < startSpot.Skins.Length; i++ )
		{
			aPlayer.Pawn.Skins[i] = startSpot.Skins[i];
		}
	}

    aPlayer.Pawn.PlayTeleportEffect(true, true);
	aPlayer.ClientSetRotation(aPlayer.Pawn.Rotation);
	AddDefaultInventory(aPlayer.Pawn);
	log( self$ " GameInfo::RestartPlayer() About to trigger player start event!", 'MP');
	TriggerEvent( StartSpot.Event, StartSpot, aPlayer.Pawn);

	// ... lame hack to fix Bug 9040: this is set on every spawn, but it is None until the first spawn completes.
	// The MP fireteam spawn controller, which is triggered by the TriggerEvent() call above, checks to see if the spawn is None,
	// and if so, then it uses special rules to affect the reinforcement count. Yeah. 2005-01-19 JWS
	aPlayer.PreviousPawnClass = aPlayer.Pawn.Class;
}

function class<Pawn> GetDefaultPlayerClass(Controller C)
{
    local PlayerController PC;
    local String PawnClassName;
    local class<Pawn> PawnClass;

    PC = PlayerController( C );

    if( PC != None )
{
        PawnClassName = PC.GetDefaultURL( "Class" );
        PawnClass = class<Pawn>( DynamicLoadObject( PawnClassName, class'Class') );

        if( PawnClass != None )
            return( PawnClass );
}

    return( class<Pawn>( DynamicLoadObject( DefaultPlayerClassName, class'Class' ) ) );
}

//
// Called after a successful login. This is the first place
// it is safe to call replicated functions on the PlayerPawn.
//
event PostLogin( PlayerController NewPlayer )
{
    local class<HUD> HudClass;
    local class<Scoreboard> ScoreboardClass;
    local String SongName;

	UpdateCapacity();

    // Log player's login.
	if (GameStats!=None)
	{
		GameStats.ConnectEvent(NewPlayer.PlayerReplicationInfo);
		GameStats.GameEvent("NameChange",NewPlayer.PlayerReplicationInfo.playername,NewPlayer.PlayerReplicationInfo);
	}

	if ( !bDelayedStart )
	{
		// start match, or let player enter, immediately
		bRestartLevel = false;	// let player spawn once in levels that must be restarted after every death
		bKeepSamePlayerStart = true;
		if ( bWaitingToStartMatch )
			StartMatch();
		else
			RestartPlayer(newPlayer);
		bKeepSamePlayerStart = false;
		bRestartLevel = Default.bRestartLevel;
	}

	// Start player's music.
    SongName = Level.Song;
    if( SongName != "" && SongName != "None" )
        NewPlayer.ClientSetMusic( SongName, MTRAN_Fade );

	// tell client what hud and scoreboard to use

    if( HUDType != "" )
	{
        HudClass = class<HUD>(DynamicLoadObject(HUDType, class'Class'));
	}

    if( ScoreBoardType != "" )
	{
        ScoreboardClass = class<Scoreboard>(DynamicLoadObject(ScoreBoardType, class'Class'));
	}
    NewPlayer.ClientSetHUD( HudClass, ScoreboardClass );
    // --- gam

	NewPlayer.RequestForceFeedbackProperties(); // jdf

	if ( NewPlayer.Pawn != None )
		NewPlayer.Pawn.ClientSetRotation(NewPlayer.Pawn.Rotation);

    // gam ---
    if( NewPlayer.PlayerReplicationInfo == None )
        log( "Can't set gamertag/xuid yet -- no PRI!!!", 'Error' );
    else
    {
        NewPlayer.PlayerReplicationInfo.Gamertag = NewPlayer.Gamertag;
        NewPlayer.PlayerReplicationInfo.xuid = NewPlayer.xuid;
        NewPlayer.PlayerReplicationInfo.Skill = NewPlayer.Skill;
        NewPlayer.PlayerReplicationInfo.bIsGuest = NewPlayer.bIsGuest;
    }
    // --- gam

	UpdateCapacity();
}

//
// Player exits.
//
function Logout( Controller Exiting )
{
	local bool bMessage;
	local PlayerController PC;
    local XBoxAddr xbAddr; // jij
    local int PortNo; // jij

	bMessage = true;

    PC = PlayerController(Exiting); // gam

	if ( PC != None )
	{
//FIXME_MERGE		if ( AccessControl.AdminLogout( PlayerController(Exiting) ) )
//			AccessControl.AdminExited( PlayerController(Exiting) );

        if ( PC.PlayerReplicationInfo.bOnlySpectator )
		{
			bMessage = false;
				NumSpectators--;
		}
		else
        {
			NumPlayers--;

			//SDJ 07/21/2004: From UC.
			// gam ---
            if( PC.bWasInvited )
                NumInvitedPlayers--;
            // --- gam
        }

		// jij ---
		if ( Level.NetMode == NM_DedicatedServer || Level.NetMode == NM_ListenServer )
        {
            if (PC.bHasVoice && PC.VoiceChannel >= 0)
                LeaveVoiceChannel(PC,xbAddr,PortNo,PC.VoiceChannel,false);
        }
        // --- jij
	}

	// AI guys shouldn't generate quit messages 2005-03-23 JWS
	if (Exiting.PlayerReplicationInfo != None && Exiting.PlayerReplicationInfo.bBot == true)
		bMessage = false;

	if( bMessage && (Level.NetMode==NM_DedicatedServer || Level.NetMode==NM_ListenServer) )
		BroadcastLocalizedMessage(GameMessageClass, 4, Exiting.PlayerReplicationInfo);

	if ( GameStats!=None)
		GameStats.DisconnectEvent(Exiting.PlayerReplicationInfo);

	UpdateCapacity();
}

//
// Examine the passed player's inventory, and accept or discard each item.
// AcceptInventory needs to gracefully handle the case of some inventory
// being accepted but other inventory not being accepted (such as the default
// weapon).  There are several things that can go wrong: A weapon's
// AmmoType not being accepted but the weapon being accepted -- the weapon
// should be killed off. Or the player's selected inventory item, active
// weapon, etc. not being accepted, leaving the player weaponless or leaving
// the HUD inventory rendering messed up (AcceptInventory should pick another
// applicable weapon/item as current).
//
event AcceptInventory(Pawn PlayerPawn, bool bAccept)
{
	//default accept all inventory except default weapon (spawned explicitly)
}

function AddGameSpecificInventory(Pawn p)
{
    local Weapon newWeapon;
    local class<Weapon> WeapClass;
    local Inventory Inv;

    // Spawn default weapon.
    WeapClass = BaseMutator.GetDefaultWeapon();
    if( (WeapClass!=None) && (p.FindInventoryType(WeapClass)==None) )
    {
        newWeapon = Spawn(WeapClass,,,p.Location);
        if( newWeapon != None )
        {
            Inv = None;
            // search Pawn's inventory for a bCanThrowWeapon==false, if we find one, don't call Bringup
            for( Inv=Inventory; Inv!=None; Inv=Inv.Inventory )
            {
                if ( Inv.IsA('Weapon') && Weapon(Inv).bCanThrow==false )
                    break;
            }
            newWeapon.GiveTo(p);
            newWeapon.bCanThrow = false; // don't allow default weapon to be thrown out
        }
    }
}

//
// Spawn any default inventory for the player.
//
function AddDefaultInventory( Pawn PlayerPawn )
{
	local Weapon newWeapon;
	local class<Weapon> WeapClass;

	// Spawn default weapon.
	WeapClass = BaseMutator.GetDefaultWeapon();
	if( (WeapClass!=None) && (PlayerPawn.FindInventoryType(WeapClass)==None) )
	{
		newWeapon = Spawn(WeapClass,,,PlayerPawn.Location);
		if( newWeapon != None )
		{
			newWeapon.GiveTo(PlayerPawn);
            //newWeapon.BringUp();
			newWeapon.bCanThrow = false; // don't allow default weapon to be thrown out
		}
	}
	SetPlayerDefaults(PlayerPawn);
}

/* SetPlayerDefaults()
 first make sure Pawn properties are back to default, then give mutators an opportunity
 to modify them
*/
function SetPlayerDefaults(Pawn PlayerPawn)
{
	PlayerPawn.AirControl = PlayerPawn.Default.AirControl;
    PlayerPawn.GroundSpeed = PlayerPawn.Default.GroundSpeed;
    PlayerPawn.WaterSpeed = PlayerPawn.Default.WaterSpeed;
    PlayerPawn.AirSpeed = PlayerPawn.Default.AirSpeed;
    PlayerPawn.Acceleration = PlayerPawn.Default.Acceleration;
    PlayerPawn.JumpZ = PlayerPawn.Default.JumpZ;
	BaseMutator.ModifyPlayer(PlayerPawn);
}

function NotifyKilled(Controller Killer, Controller Killed, Pawn KilledPawn )
{
	local Controller C;

	for ( C=Level.ControllerList; C!=None; C=C.nextController )
		C.NotifyKilled(Killer, Killed, KilledPawn);
}

function KillEvent(string Killtype, PlayerReplicationInfo Killer, PlayerReplicationInfo Victim, class<DamageType> Damage)
{
	if ( GameStats != None )
		GameStats.KillEvent(KillType, Killer, Victim, Damage);
}

function Killed( Controller Killer, Controller Killed, Pawn KilledPawn, class<DamageType> damageType )
{
    if ( (Killed != None) && Killed.bIsPlayer )
	{
		Killed.PlayerReplicationInfo.Deaths += 1;
        Killed.PlayerReplicationInfo.NetUpdateTime = FMin(Killed.PlayerReplicationInfo.NetUpdateTime, Level.TimeSeconds + 0.3 * FRand());
		BroadcastDeathMessage(Killer, Killed, damageType);

		if ( (Killer == Killed) || (Killer == None) )
		{
			if ( Killer == None )
				KillEvent("K", None, Killed.PlayerReplicationInfo, DamageType);	//"Kill"
			else
				KillEvent("K", Killer.PlayerReplicationInfo, Killed.PlayerReplicationInfo, DamageType);	//"Kill"
		}
		else
		{
			if ( bTeamGame && (Killer.PlayerReplicationInfo != None)
				&& (Killer.PlayerReplicationInfo.Team == Killed.PlayerReplicationInfo.Team) )
				KillEvent("TK", Killer.PlayerReplicationInfo, Killed.PlayerReplicationInfo, DamageType);	//"Teamkill"
			else
				KillEvent("K", Killer.PlayerReplicationInfo, Killed.PlayerReplicationInfo, DamageType);	//"Kill"
		}
	}
    if ( Killed != None )
	ScoreKill(Killer, Killed);
	DiscardInventory(KilledPawn);
    NotifyKilled(Killer,Killed,KilledPawn);
}

function bool PreventDeath(Pawn Killed, Controller Killer, class<DamageType> damageType, vector HitLocation)
{
	if ( GameRulesModifiers == None )
		return false;
	return GameRulesModifiers.PreventDeath(Killed,Killer, damageType,HitLocation);
}

function bool PreventSever(Pawn Killed,  Name boneName, int Damage, class<DamageType> DamageType)
{
    if ( GameRulesModifiers == None )
        return false;
    return GameRulesModifiers.PreventSever(Killed, boneName, Damage, DamageType);
}

function BroadcastDeathMessage(Controller Killer, Controller Other, class<DamageType> damageType)
{
	if ( (Killer == Other) || (Killer == None) )
        BroadcastLocalized(self,DeathMessageClass, 1, None, Other.PlayerReplicationInfo, damageType);
	else
        BroadcastLocalized(self,DeathMessageClass, 0, Killer.PlayerReplicationInfo, Other.PlayerReplicationInfo, damageType);
}


// %k = Owner's PlayerName (Killer)
// %o = Other's PlayerName (Victim)
// %w = Owner's Weapon ItemName
static native function string ParseKillMessage( string KillerName, string VictimName, string DeathMessage );

exec function Kick( string S )
{
	AccessControl.Kick(S);
}

// This could be implemented by marking it as exec. However, we don't currently have enough text
// to support banning in a nice way. In addition, the built-in support for banning isn't very robust.
// If someone were to implement banning, I suggest integrating the UT2k4 solution for managing all of this
// as it has a lot of features and has been well tested. 2005-03-23 JWS
function KickBan( string S )
{
	AccessControl.KickBan(S);
}

function bool IsOnTeam(Controller Other, int TeamNum)
{
    if ( bTeamGame && (Other != None) && Other.bIsPlayer
		&& (Other.PlayerReplicationInfo.Team != None)
		&& (Other.PlayerReplicationInfo.Team.TeamIndex == TeamNum) )
		return true;
	return false;
}

//-------------------------------------------------------------------------------------
// Level gameplay modification.

//
// Return whether Viewer is allowed to spectate from the
// point of view of ViewTarget.
//
function bool CanSpectate( PlayerController Viewer, bool bOnlySpectator, actor ViewTarget )
{
	return true;
}

/* Use reduce damage for teamplay modifications, etc.
*/
function int ReduceDamage( int Damage, Pawn injured, Pawn instigatedBy, vector HitLocation, out vector Momentum, class<DamageType> DamageType )
{
	local int OriginalDamage;
	local armor FirstArmor;

	OriginalDamage = Damage;

	if( injured.PhysicsVolume.bNeutralZone )
		Damage = 0;
	else if ( injured.InGodMode() ) // God mode
		return 0;
	else if ( (injured.Inventory != None) && (damage > 0) ) //then check if carrying armor
	{
		FirstArmor = injured.inventory.PrioritizeArmor(Damage, DamageType, HitLocation);
		while( (FirstArmor != None) && (Damage > 0) )
		{
			Damage = FirstArmor.ArmorAbsorbDamage(Damage, DamageType, HitLocation);
			FirstArmor = FirstArmor.nextArmor;
		}
	}

// << GEARBOX/jmw:add - Demigod mode
	if( injured.InDemigodMode() )
	{
		// A pawn in Demigod mode can take damage, but never enough to kill him.
		Damage = Min( Damage, injured.Health - 1 );
		Log( self $ ".ReduceDamage( " $ OriginalDamage $ ", " $ injured $ ", " $ instigatedBy $ ", ... ): reducing damage to demigod (Health=" $ injured.Health $ " to " $ Damage, 'jmw' );
	}
// GEARBOX >>

	if ( GameRulesModifiers != None )
		return GameRulesModifiers.NetDamage( OriginalDamage, Damage,injured,instigatedBy,HitLocation,Momentum,DamageType );

	return Damage;
}

//
// Return whether an item should respawn.
//
function bool ShouldRespawn( Pickup Other )
{
	if( Level.NetMode == NM_StandAlone )
		return false;

	return Other.ReSpawnTime!=0.0;
}

/* Called when Pawn has a chance to pick Item up (i.e. when
   the Pawn touches a weapon pickup). Should return true if
   he wants to pick it up, false if he does not want it.
*/
function bool PickupQuery( Pawn Other, Pickup item )
{
	local byte bAllowPickup;

	if ( (GameRulesModifiers != None) && GameRulesModifiers.OverridePickupQuery(Other, item, bAllowPickup) )
		return (bAllowPickup == 1);

	if ( Other.Inventory == None )
		return true;
	else
		return !Other.Inventory.HandlePickupQuery(Item);
}

/* Discard a player's inventory after he dies.
*/
function DiscardInventory( Pawn Other )
{
	Other.Weapon = None;
	Other.SelectedItem = None;
    while ( Other.Inventory != None )
        Other.Inventory.Destroy();
}

/* Try to change a player's name.
*/
function ChangeName( Controller Other, coerce string S, bool bNameChange )
{
	local Controller C;

	if( S == "" )
		return;

	Other.PlayerReplicationInfo.SetPlayerName(S);
    // notify local players
    if ( bNameChange )
		for ( C=Level.ControllerList; C!=None; C=C.NextController )
			if ( (PlayerController(C) != None) && (Viewport(PlayerController(C).Player) != None) )
				PlayerController(C).ReceiveLocalizedMessage( class'GameMessage', 2, Other.PlayerReplicationInfo );
}

/* Return whether a team change is allowed.
*/
function bool ChangeTeam(Controller Other, int N, bool bNewTeam)
{
	return true;
}

/* Return a picked team number if none was specified
*/
function byte PickTeam(byte Current, Controller C)
{
	return Current;
}

/* Send a player to a URL.
*/
function SendPlayer( PlayerController aPlayer, string URL )
{
	aPlayer.ClientTravel( URL, TRAVEL_Relative, true );
}

/* Restart the game.
*/
function RestartGame()
{
	local string NextMap;
    local MapList MyList;

	if ( (GameRulesModifiers != None) && GameRulesModifiers.HandleRestartGame() )
		return;

	if ( bGameRestarted )
		return;
    bGameRestarted = true;

	// these server travels should all be relative to the current URL
	if ( bChangeLevels && !bAlreadyChanged && (MapListType != "") )
	{
		// open a the nextmap actor for this game type and get the next map
		bAlreadyChanged = true;
        MyList = GetMapList(MapListType);
		if (MyList != None)
		{
			NextMap = MyList.GetNextMap();
			MyList.Destroy();
		}
		if ( NextMap == "" )
			NextMap = GetMapName(MapPrefix, NextMap,1);

		if ( NextMap != "" )
		{
			Level.ServerTravel(NextMap, false);
			return;
		}
	}

	Level.ServerTravel( "?Restart", false );
}

function MapList GetMapList(string MapListType)
{
local class<MapList> MapListClass;

	if (MapListType != "")
	{
        MapListClass = class<MapList>(DynamicLoadObject(MapListType, class'Class'));
		if (MapListClass != None)
			return Spawn(MapListClass);
	}
	return None;
}

//==========================================================================
// Message broadcasting functions (handled by the BroadCastHandler)

event Broadcast( Actor Sender, coerce string Msg, optional name Type )
{
	BroadcastHandler.Broadcast(Sender,Msg,Type);
}

function BroadcastTeam( Controller Sender, coerce string Msg, optional name Type )
{
	BroadcastHandler.BroadcastTeam(Sender,Msg,Type);
}

/*
 Broadcast a localized message to all players.
 Most message deal with 0 to 2 related PRIs.
 The LocalMessage class defines how the PRI's and optional actor are used.
*/
event BroadcastLocalized( actor Sender, class<LocalMessage> Message, optional int Switch, optional PlayerReplicationInfo RelatedPRI_1, optional PlayerReplicationInfo RelatedPRI_2, optional Object OptionalObject )
{
	BroadcastHandler.AllowBroadcastLocalized(Sender,Message,Switch,RelatedPRI_1,RelatedPRI_2,OptionalObject);
}

/*
 Broadcast a localized objective update to all players.
 Most message deal with 0 to 2 related PRIs.
 The LocalMessage class defines how the PRI's and optional actor are used.
*/
event BroadcastObjective( actor Sender, class<Info> Objective, Name szObjectiveTag, EObjectiveComplete nStatus, int nObjectiveIdx, bool bDisplayMessage, float flLifeTime, optional PlayerReplicationInfo RelatedPRI_1, optional PlayerReplicationInfo	RelatedPRI_2 )
{
	BroadcastHandler.AllowBroadcastObjective(Sender, Objective, szObjectiveTag, nStatus, nObjectiveIdx, bDisplayMessage, flLifeTime, RelatedPRI_1, RelatedPRI_2);
}

//==========================================================================

function bool CheckEndGame(PlayerReplicationInfo Winner, string Reason)
{
	local Controller P;

	Log(self $ " GameInfo::CheckEndGame() called with Winner=" $ Winner $ " and Reason=" $ Reason, 'JWS');

	if ( (GameRulesModifiers != None) && !GameRulesModifiers.CheckEndGame(Winner, Reason) )
		return false;

	// all player cameras focus on winner or final scene (picked by gamerules)
	for ( P=Level.ControllerList; P!=None; P=P.NextController )
	{
		P.ClientGameEnded();
        P.GameHasEnded();
	}
	return true;
}

/* End of game.
*/
function EndGame( PlayerReplicationInfo Winner, string Reason )
{
	Log(self $ " GameInfo::EndGame() called with Winner=" $ Winner $ " and Reason=" $ Reason, 'JWS');

	// don't end game if not really ready
	if ( !CheckEndGame(Winner, Reason) )
	{
		bOverTime = true;
		return;
	}

	bGameEnded = true;
	TriggerEvent('EndGame', self, None);
	EndLogging(Reason);
}

function EndLogging(string Reason)
{

	if (GameStats == None)
		return;

	GameStats.EndGame(Reason);
	GameStats.Destroy();
	GameStats = None;
}

/* Modify the player start location and rotation if desired. GEARBOX - 2004-06-30 JWS
 */
function bool GetModifiedPlayerStartView( NavigationPoint Start, out vector Loc, out rotator Rot )
{
	return false;
}

/* Return the 'best' player start for this player to start from.
 */
function NavigationPoint FindPlayerStart( Controller Player, optional byte InTeam, optional string incomingName )
{
	local ActorLite AL;
	local NavigationPoint N, BestStart;
	local Teleporter Tel;
	local float BestRating, NewRating;
	local byte Team;
	local int	nCheckpointID;

	// always pick StartSpot at start of match
    if ( (Player != None) && (Player.StartSpot != None) && (Level.NetMode == NM_Standalone)
		&& (bKeepSamePlayerStart || bWaitingToStartMatch || ((Player.PlayerReplicationInfo != None) && Player.PlayerReplicationInfo.bWaitingPlayer))  )
	{
		return Player.StartSpot;
	}

	if ( GameRulesModifiers != None )
	{
		N = GameRulesModifiers.FindPlayerStart(Player,InTeam,incomingName);
		if ( N != None )
		    return N;
	}

	// if incoming start is specified, then just use it
	if( incomingName!="" )
		foreach AllActors( class 'Teleporter', Tel )
			if( string(Tel.Tag)~=incomingName )
				return Tel;

	// use InTeam if player doesn't have a team yet
	if ( (Player != None) && (Player.PlayerReplicationInfo != None) )
	{
		if ( Player.PlayerReplicationInfo.Team != None )
			Team = Player.PlayerReplicationInfo.Team.TeamIndex;
		else
			Team = InTeam; //SDJ 03/10/2004: Use the provided team instead of 0.
	}
	else
		Team = InTeam;

	// This is very slow, and has no meaning for MP anyways. So only do this stuff in SP games. 2004-12-02 JWS
	if (Level.NetMode == NM_Standalone)
	{
		nCheckpointID = Level.MissionManager.GetCheckpointID();
	}
	else
	{
		if (CanUseCheckpoints(-1))
		{
			nCheckpointID = Level.MissionManager.SkirmishGetCheckpointID();
		}
		else
		{
			nCheckpointID = 0;
		}
	}

	for ( AL=Level.NavigationPointList; AL!=None; AL=AL.NextNavigationPoint )
	{
		if (AL.bIsNavigationPoint)
		{
			NewRating = RatePlayerStart(NavigationPoint(AL),Team,Player,nCheckpointID); //SDJ 03/10/2004: Use the Team not InTeam.
			if ( NewRating > BestRating )
			{
				BestRating = NewRating;
				BestStart = NavigationPoint(AL);
			}
		}
	}

	if ( BestStart == None )
	{
		log("Warning - PATHS NOT DEFINED or NO PLAYERSTART");
		foreach AllActors( class 'NavigationPoint', N )
		{
			NewRating = RatePlayerStart(N,Team,Player,nCheckpointID); //SDJ 03/10/2004: Use the Team not 0.
			if ( NewRating > BestRating )
			{
				BestRating = NewRating;
				BestStart = N;
			}
		}
	}

	return BestStart;
}

/* Rate whether player should choose this NavigationPoint as its start
default implementation is for single player game
*/
function float RatePlayerStart(NavigationPoint N, byte Team, Controller Player, int nCheckpointID)
{
	local PlayerStart P;

	P = PlayerStart(N);
	if ( P != None )
	{
		if ( P.bSinglePlayerStart )
		{
			if ( P.bEnabled )
				return 1000;
			return 20;
		}
		return 10;
	}
	return 0;
}

function ScoreObjective(PlayerReplicationInfo Scorer, Int Score)
{
	if ( Scorer != None )
	{
		Scorer.Score += Score;
        /*
		if ( Scorer.Team != None )
			Scorer.Team.Score += Score;
        */
	}
	if ( GameRulesModifiers != None )
		GameRulesModifiers.ScoreObjective(Scorer,Score);

	CheckScore(Scorer);
}

/* CheckScore()
see if this score means the game ends
*/
function CheckScore(PlayerReplicationInfo Scorer)
{
	Log(self $ " GameInfo::CheckScore() called with Scorer=" $ Scorer, 'JWS');

	if ( (GameRulesModifiers != None) && GameRulesModifiers.CheckScore(Scorer) )
		return;
}

function ScoreEvent(PlayerReplicationInfo Who, float Points, string Desc)
{
	if (GameStats!=None)
		GameStats.ScoreEvent(Who,Points,Desc);
}

function TeamScoreEvent(int Team, float Points, string Desc)
{
	if ( GameStats != None )
		GameStats.TeamScoreEvent(Team, Points, Desc);
}

function ScoreKill(Controller Killer, Controller Other)
{
	if( (killer == Other) || (killer == None) )
	{
    	if (Other!=None)
        {
			Other.PlayerReplicationInfo.Score -= 1;
			ScoreEvent(Other.PlayerReplicationInfo,-1,"self_frag");
        }
	}
	else if ( killer.PlayerReplicationInfo != None )
	{
		Killer.PlayerReplicationInfo.Score += 1;
		Killer.PlayerReplicationInfo.Kills++;
		ScoreEvent(Killer.PlayerReplicationInfo,1,"frag");
	}

	if ( GameRulesModifiers != None )
		GameRulesModifiers.ScoreKill(Killer, Other);

    if ( (Killer != None) || (MaxLives > 0) )
	CheckScore(Killer.PlayerReplicationInfo);
}

function bool TooManyBots(Controller botToRemove)
{
	return false;
}

static function string FindTeamDesignation(GameReplicationInfo GRI, actor A)	// Should be subclassed in various team games
{
	return "";
}

// - Parse out % vars for various messages

static function string ParseMessageString(Mutator BaseMutator, Controller Who, String Message)
{
	return Message;
}

function ReviewJumpSpots(name TestLabel);

function TeamInfo OtherTeam(TeamInfo Requester)
{
	return None;
}

exec notinship function KillBots(int num);

exec function AdminSay(string Msg)
{
	local controller C;

	for( C=Level.ControllerList; C!=None; C=C.nextController )
		if( C.IsA('PlayerController') )
		{
			PlayerController(C).ClearProgressMessages();
			PlayerController(C).SetProgressTime(6);
			PlayerController(C).SetProgressMessage(0, Msg, class'Canvas'.Static.MakeColor(255,255,255));
		}
}

function RegisterVehicle(Vehicle V);

function bool SlowMotionDeath()
{
	return false;
}

static simulated function String ParseToken(out String Str)
{
    local String Ret;
    local int len;

    Ret = "";
    len = 0;

	// Skip spaces and tabs.
	while( Left(Str,1)==" " || Asc(Left(Str,1))==9 )
		Str = Mid(Str, 1);

	if( Asc(Left(Str,1)) == 34 )
	{
		// Get quoted String.
		Str = Mid(Str, 1);
		while( Str!="" && Asc(Left(Str,1))!=34 )
		{
			Ret = Ret $ Mid(Str,0,1);
            Str = Mid(Str, 1);
		}
		if( Asc(Left(Str,1))==34 )
			Str = Mid(Str, 1);
	}
	else
	{
		// Get unquoted String.
		for( len=0; (Str!="" && Left(Str,1)!=" " && Asc(Left(Str,1))!=9); Str = Mid(Str, 1) )
            Ret = Ret $ Mid(Str,0,1);
	}

	return Ret;
}

function CallInReinforcements( Controller C )
{
	//Log( self$ " GameInfo::CallInReinforcements()", 'PSV');
}

function bool IsPawnOnSameTeamAsPlayer(Pawn p)
{
	return false;
}

function bool IsPawnOnSameTeamAsPlayerByEnum(ETeamIdentifier team)
{
	return false;
}

function bool CanUseCheckpoints( int nCheckpointID )
{
	return false;
}

function SaveCheckpointID( int nCheckpointID );
function SaveCheckpointIDCustom( int nCheckpointID, string szCustomMapName );
function ClearCachedValues();
function bool GetCachedValue( name szValueName, out int nValue )
{
	return false;
}
function LoadCheckpointInLevel( int nCheckpointID, optional name szPreSaveTrigger, optional name szPostSaveTrigger );

defaultproperties
{
	bAdminCanPause=true
    bDelayedStart=false
	HUDType="gbxHUD.WargameHUD"
	bWaitingToStartMatch=false
	bLoggingGame=False
	MaxPlayers=16
    GameDifficulty=+1.0
    bRestartLevel=True
    bPauseable=True
	bOraclePauseable=True
    bCanChangeSkin=True
	bCanViewOthers=true
    bChangeLevels=True
    AutoAim=0.930000
    GameSpeed=1.000000
    MaxSpectators=2
    DefaultPlayerName="Player"
	GameName="Game"
	MutatorClass="Engine.Mutator"
	BroadcastHandlerClass="Engine.BroadcastHandler"
	DeathMessageClass=class'LocalMessage'
	GameStatsClass="Engine.GameStats"
	bEnableStatLogging=false
	bCheatsEnabled=false
	bAllowWeaponThrowing=true
	AccessControlClass="Engine.AccessControl"
	PlayerControllerClassName="Engine.PlayerController"
	GameMessageClass=class'GameMessage'
	GameReplicationInfoClass=class'GameReplicationInfo'
    SecurityClass="Engine.Security"
    FearCostFalloff=+0.95
	MaxFearCost=2000
    Acronym="???"
	DestroyDeadBodyTimer = 40;
	bDestroyVisibleDeadBodies = false;

    NumVoiceChannels=6

	bHoldFire=false
	fHoldFireTime=-9999.9
}
class GameMessage extends LocalMessage;



var localized string	      SwitchLevelMessage;
var localized string	      LeftMessage;
var localized string	      FailedTeamMessage;
var localized string	      FailedPlaceMessage;
var localized string	      FailedSpawnMessage;
var localized string	      EnteredMessage;
var	localized string	      MaxedOutMessage;
var localized string OvertimeMessage;
var localized string GlobalNameChange;
var localized string NewTeamMessage;
var localized string NewTeamMessageTrailer;
var localized string	NoNameChange;
var localized string VoteStarted;
var localized string VotePassed;
var localized string MustHaveStats;

var localized string NewPlayerMessage;

//
// Messages common to GameInfo derivatives.
//
static function string GetString(
	optional int Switch,
	optional PlayerReplicationInfo RelatedPRI_1,
	optional PlayerReplicationInfo RelatedPRI_2,
	optional Object OptionalObject
	)
{
	switch (Switch)
	{
		case 0:
			return Default.OverTimeMessage;
			break;
		case 1:
			if (RelatedPRI_1 == None)
                return Default.NewPlayerMessage;

			return RelatedPRI_1.playername$Default.EnteredMessage;
			break;
		case 2:
			if (RelatedPRI_1 == None)
				return "";

			return RelatedPRI_1.OldName@Default.GlobalNameChange@RelatedPRI_1.PlayerName;
			break;
		case 3:
			if (RelatedPRI_1 == None)
				return "";
			if (OptionalObject == None)
				return "";

            return RelatedPRI_1.playername@Default.NewTeamMessage@TeamInfo(OptionalObject).GetHumanReadableName()$Default.NewTeamMessageTrailer;
			break;
		case 4:
			if (RelatedPRI_1 == None)
				return "";

			return RelatedPRI_1.GetHumanReadableName()$Default.LeftMessage;
			break;
		case 5:
			return Default.SwitchLevelMessage;
			break;
		case 6:
			return Default.FailedTeamMessage;
			break;
		case 7:
			return Default.MaxedOutMessage;
			break;
		case 8:
			return Default.NoNameChange;
			break;
        case 9:
            return RelatedPRI_1.playername@Default.VoteStarted;
            break;
        case 10:
            return Default.VotePassed;
            break;
        case 11:
			return Default.MustHaveStats;
			break;
	}
	return "";
}

defaultproperties
{
	NewPlayerMessage="A new player entered the game."
	OverTimeMessage="Score tied at the end of regulation. Sudden Death Overtime!!!"
	GlobalNameChange="changed name to"
	NewTeamMessage="is now on"
	NewTeamMessageTrailer=""
    SwitchLevelMessage="Switching Levels"
    MaxedOutMessage="Server is already at capacity."
    EnteredMessage=" entered the game."
	FailedTeamMessage="Could not find team for player"
	FailedPlaceMessage="Could not find a starting spot"
	FailedSpawnMessage="Could not spawn player"
    LeftMessage=" left the game."
    NoNameChange="Name is already in use."
    MustHaveStats="Must have stats enabled to join this server."
    VoteStarted="started a vote."
    VotePassed="Vote passed."
    bIsSpecial=false
	bIsConsoleMessage=true
}
class GameProfile extends ProfileBase;

struct MissionStats_s
{
	var byte	bCompleted[4];	// one for each difficulty level
	var float	BestMissionTime;
	var float	MissionTime;
	var int		TotalSquadMembersInMap;
	var int		SquadMembersInMap;
	var float	PlayerShotsFired;
	var float	PlayerShotsHit;
	var float	PlayerShotsSuppression;
	var float	AIShotsFired;
	var float	AIShotsHit;
	var float	AIShotsSuppression;
	var float	PlayerKills;
	var float	SquadKills;
};

const MAX_MISSION_COUNT	= 20;

var string						GameName;
var bool						bDisplayedVictory;
var int							LastMissionCompleted;
var EDifficulty					LastDifficultyCompleted;
var name						MenuCameraView;

var MissionStats_s				MissionStats[MAX_MISSION_COUNT];
var int							MissionCount;					// the real number of missions in the game

// GBX:PAD: This is new information for the new checkpoint save system
var string						SaveMissionName;
var EDifficulty					SaveMissionDifficulty;
var int							SaveMissionCheckpoint;

// GBX:PAD: This is new information for the new checkpoint save system for Skirmish mode
var string						SkirmishMissionName;
var int							SkirmishMissionCheckpoint;
var bool						SkirmishPawnRespawn;

var bool						SquadmateHasDied;

var int							SkirmishToDLevelSolo[2];	// US/DE
var int							SkirmishToDLevelCoop[2];

struct SavedPawnInfo
{
	var		name	Tag;
	var		int		Health;
	var		int		default_Health;  // because not all Pawns have the same default.Health (tanks for example)
	var		bool	bFriendly;
};

struct SkirmishSavedPawnInfo
{
	var		int		nCharOwner;
	var		int		Health;
	var		int		nType;
	var		bool	bFriendly;
};

struct SkirmishSavedPlayerInfo
{
	var		int		nCharOwner;
	var		int		Health;
	var		int		Score;
};

struct SavedWeaponInfo
{
	var		class<Weapon>	WeaponClass;
	var		int		TotalAmmo;
	var		int		ClipAmmo;
	var		bool	bActive;
};

struct SkirmishSavedWeaponInfo
{
	var		int		nCharOwner;
	var		class<Weapon>	WeaponClass;
	var		int		TotalAmmo;
	var		int		ClipAmmo;
	var		bool	bActive;
};

struct SavedInventoryInfo
{
	var		class<Inventory>	InventoryClass;
	var		int		Quantity;
};

struct SkirmishSavedInventoryInfo
{
	var		int		nCharOwner;
	var		class<Inventory>	InventoryClass;
	var		int		Quantity;
};

struct SavedValueInfo
{
	var		name	ValueName;
	var		int		nValue;
};

var		int						nCheckpointReloads;
var		array<SavedPawnInfo>	SavedPawns;
var		int						PlayerHealth;
var		array<SavedWeaponInfo>	SavedWeapons;
var		array<SavedInventoryInfo>	SavedInventory;
var		array<SavedInventoryInfo>	SavedSecondaryInventory;
var		array<SavedValueInfo>	SavedValues;

var		int						nSkirmishCheckpointReloads;
var		array<SkirmishSavedPawnInfo>	SkirmishSavedPawns;
var		array<SkirmishSavedPlayerInfo>	SkirmishPlayerHealth;
var		array<SkirmishSavedWeaponInfo>	SkirmishSavedWeapons;
var		array<SkirmishSavedInventoryInfo>	SkirmishSavedInventory;
var		array<SkirmishSavedInventoryInfo>	SkirmishSavedSecondaryInventory;
var		array<SavedValueInfo>	SkirmishSavedValues;

struct SkirmishMapStats
{
	var		string		MapName;
	var		int			nMaxWaves;
	var		int			flBestTime[4];
	var		int			HighestDifficulty;
};

var		array<SkirmishMapStats>		SkirmishMapStatsSaved;

simulated function SetGameName(string inName)
{
    GameName = CapStringLen(inName);
}

simulated function string GetGameName()
{
    return GameName;
}

simulated function SetMissionStat( int nIdx, MissionStats_s aStat )
{
	local int	nIdx2;
	
	for (nIdx2 = 0; nIdx2 < 4; nIdx2++)
	{
		MissionStats[nIdx].bCompleted[nIdx2] = aStat.bCompleted[nIdx2];
	}
	MissionStats[nIdx].BestMissionTime = aStat.BestMissionTime;
	MissionStats[nIdx].MissionTime = aStat.MissionTime;
	MissionStats[nIdx].TotalSquadMembersInMap = aStat.TotalSquadMembersInMap;
	MissionStats[nIdx].SquadMembersInMap = aStat.SquadMembersInMap;
	MissionStats[nIdx].PlayerShotsFired = aStat.PlayerShotsFired;
	MissionStats[nIdx].PlayerShotsHit = aStat.PlayerShotsHit;
	MissionStats[nIdx].PlayerShotsSuppression = aStat.PlayerShotsSuppression;
	MissionStats[nIdx].AIShotsFired = aStat.AIShotsFired;
	MissionStats[nIdx].AIShotsHit = aStat.AIShotsHit;
	MissionStats[nIdx].AIShotsSuppression = aStat.AIShotsSuppression;
	MissionStats[nIdx].PlayerKills = aStat.PlayerKills;
	MissionStats[nIdx].SquadKills = aStat.SquadKills;
}

// =======================================================================================================================================================
// Game Profile helper functions
// =======================================================================================================================================================
static simulated function CreateGameProfile(LevelInfo Level, string inProfileName)
{
    local GameProfile   gProfile;
	local int i;

	inProfileName = CapStringLen(inProfileName);

	gProfile = Level.SaveGameCreateObject(class'GameProfile', "#TEMP#");

    gProfile.SetGameName(inProfileName);
	gProfile.MenuCameraView = '';

	// store the mission count
	gProfile.MissionCount = Level.MissionManager.Missions.Length;

	// if we have any "disabled" chapters, unlock the ones that are not disabled
	for (i=0; i<gProfile.MissionCount; i++)
	{
		if (Level.MissionManager.MissionExists(i) && !Level.MissionManager.MissionEnabled(i))
			break;
	}
	if (i != gProfile.MissionCount)
	{
		for (i=0; i<gProfile.MissionCount; i++)
		{
			if (Level.MissionManager.MissionExists(i) && Level.MissionManager.MissionEnabled(i))
			{
				gProfile.MissionCompleted(i, DIFF_Authentic);
			}
		}
	}

	gProfile.LastMissionCompleted = -1;
	gProfile.LastDifficultyCompleted = DIFF_Easy;

	gProfile.SkirmishToDLevelSolo[0] = 0;
	gProfile.SkirmishToDLevelSolo[1] = 0;
	gProfile.SkirmishToDLevelCoop[0] = 0;
	gProfile.SkirmishToDLevelCoop[1] = 0;

	inProfileName = FormatGameName(inProfileName);

	Level.SaveGameSavePackage(inProfileName, true );
	Level.SaveGameUnloadPackage(inProfileName);

	// RSC: if this profile name is entered, unlock all content - CHEAT CODE
		if( inProfileName ~= "2NDSQUAD" ) {
		UnlockProfile( Level, inProfileName, false );
	}
}

static simulated function bool CreateDefaultGameProfile(LevelInfo Level, string inProfileName)
{
//    local GameProfile   gProfile;

	if (CreatePlayerProfile(Level, inProfileName))
	{
		return true;
/*
// CEK:FIRSTBOOT
		gProfile = LoadGameProfile(Level, inProfileName);
		if (gProfile != None)
		{
			gProfile.MissionCompleted(0, DIFF_Easy);
			UnloadProfile(Level, gProfile, true);

			return true;
		}
*/
	}

	return false;
}

static simulated function int GetProfileCount(LevelInfo Level, optional bool bValidOnly)
{
	if (bValidOnly)
		return int( Level.ConsoleCommand("LOADSAVE PROFILE VALID_COUNT") );
	else
		return int( Level.ConsoleCommand("LOADSAVE PROFILE COUNT") );
}

static simulated function string GetCurrentGameProfile(LevelInfo Level)
{
	return Level.ConsoleCommand("LOADSAVE PROFILE GETCURRENTPLAYER DEVICE=0");
}

static simulated function bool VerifyProfile(LevelInfo Level, string inProfileName)
{
	return int( Level.ConsoleCommand("LOADSAVE VERIFY_PROFILE NAME=\"" $inProfileName $"\"") ) == 1;
}

static simulated function bool ProfileExists(LevelInfo Level, optional string inProfileName)
{
	if (GetProfileCount(Level) == 0)
		return false;

	return int( Level.ConsoleCommand("LOADSAVE PROFILE INLIST NAME=\"" $inProfileName $"\"") ) != 0;
}

static simulated function GameProfile LoadCurrentGameProfile(LevelInfo Level)
{
	local GameProfile	gProfile;
	
	gProfile = LoadGameProfile( Level, GetCurrentGameProfile(Level) );
	log("LoadCurrentGameProfile() - "$gProfile$" - "$gProfile.GetGameName()$" - "$GetCurrentGameProfile(Level));
//	return LoadGameProfile( Level, GetCurrentGameProfile(Level) );
	return gProfile;
}

static simulated function GameProfile LoadGameProfile(LevelInfo Level, string inProfileName)
{
	local GameProfile	gProfile;
	
	if (!ProfileExists(Level, inProfileName))
		return None;

	gProfile = Level.SaveGameLoadPackage( FormatGameName(inProfileName) );
	if (gProfile != None)
	{
		Level.MissionManager.CacheGameProfile( gProfile );
	}
	
	return gProfile;
}

static simulated function UnloadProfile(LevelInfo Level, GameProfile profile, optional bool bSave)
{
	local string S;

	if (profile != None)
	{
		S = FormatGameName(profile.GetGameName());

		if (bSave)
			Level.SaveGameSavePackage(S, false );

		Level.SaveGameUnloadPackage( S );
	}
}

static simulated function string FormatGameName(string inProfileName)
{
	return inProfileName;
}

static simulated function name GetProfileCameraView(LevelInfo Level, string inProfileName)
{
    local GameProfile   gProfile;
	local name result;

	gProfile = LoadGameProfile(Level, inProfileName);
	if (gProfile != None)
	{
		result = gProfile.MenuCameraView;
		UnloadProfile(Level, gProfile);
	}

	if (result == '')
	{
		result = class'Engine.gbxMissionMan'.Static.GetCameraView(0);
	}

	return result;
}

// =======================================================================================================================================================
// Player Profile helper functions
// =======================================================================================================================================================
static simulated function bool CreatePlayerProfile(LevelInfo Level, string inProfileName)
{
	if (!ProfileNameValid(Level, inProfileName))
		return false;

	if ( bool(Level.ConsoleCommand("LOADSAVE PROFILE NEW DEVICE=0 NAME=\"" $inProfileName $"\"")) )
	{
		CreateGameProfile(Level, inProfileName);
		return true;
	}

	return false;
}

static simulated function DeletePlayerProfile(LevelInfo Level, string inProfileName, optional bool bDelCurrent)
{
	// delete the gameprofile
	Level.SaveGameDeletePackage( FormatGameName(inProfileName), false );

	// delete the player profile
	Level.ConsoleCommand( "LOADSAVE PROFILE DELETE DEVICE=0 NAME=\"" $inProfileName $"\" CURRENT=" $int(bDelCurrent) );
}

static simulated function bool ProfileNameValid(LevelInfo Level, string inProfileName)
{
	if (InProfileName == "")
		return false;

	if (Level.ConsoleCommand("LOADSAVE CHECK_NAME NAME=" $inProfileName) ~= inProfileName)
		return true;

	return false;
}

simulated static function ProfileCheckpoints(LevelInfo Level, string operation, optional string inProfileName)
{
/*
	if (inProfileName == "")
		inProfileName = GetCurrentGameProfile(Level);

	Level.ConsoleCommand( "LOADSAVE PROFILE CHECKPOINT NUM=1 NAME=\"" $inProfileName $"\" CMD=" $operation );
*/
}

static function bool ProfileHasCheckpoint(LevelInfo Level, bool bSkirmish, optional string inProfileName)
{
	local GameProfile gProfile;
	local bool result;

	if (inProfileName == "")
		gProfile = class'GameProfile'.Static.LoadCurrentGameProfile( Level );
	else
		gProfile = class'GameProfile'.Static.LoadGameProfile( Level, inProfileName );

	if (gProfile != None)
	{
		if (bSkirmish)
			result = gProfile.SkirmishMissionName != "";
		else
			result = gProfile.SaveMissionName != "";

		class'GameProfile'.Static.UnloadProfile( Level, gProfile );
	}

	return result;
}

static function ClearProfileCheckpoint(LevelInfo Level, bool bSkirmish, optional string inProfileName)
{
	local GameProfile	gProfile;

	if (inProfileName == "")
		gProfile = class'GameProfile'.Static.LoadCurrentGameProfile( Level );
	else
		gProfile = class'GameProfile'.Static.LoadGameProfile( Level, inProfileName );

	if (gProfile != None)
	{
		if (bSkirmish)
			Level.MissionManager.SkirmishClearCheckpointData( gProfile );
		else
			Level.MissionManager.ClearCheckpointData( gProfile );

		Level.MissionManager.CacheGameProfile(gProfile);
		class'GameProfile'.Static.UnloadProfile( Level, gProfile, true );
	}
}

/*
// =======================================================================================================================================================
// Mission stats functions
// =======================================================================================================================================================
function SetMissionInfoBaselines( int nMissionIdx, float flBestMissionTime, int nTotalSquadMembersInMap )
{
	MissionStats[nMissionIdx].BestMissionTime = flBestMissionTime;
	MissionStats[nMissionIdx].TotalSquadMembersInMap = nTotalSquadMembersInMap;
}

function GetMissionInfoBaseLines( int nMissionIdx, out float flBestMissionTime, out int nTotalSquadMembersInMap )
{
	flBestMissionTime = MissionStats[nMissionIdx].BestMissionTime;
	nTotalSquadMembersInMap = MissionStats[nMissionIdx].TotalSquadMembersInMap;
}

function SetMissionTime( int nMissionIdx, float flMissionTime )
{
	MissionStats[nMissionIdx].MissionTime = flMissionTime;
}

function float GetMissionTime( int nMissionIdx )
{
	return MissionStats[nMissionIdx].MissionTime;
}

function SetMissionSquadMembersInMap( int nMissionIdx, int nSquadMembersInMap )
{
	MissionStats[nMissionIdx].SquadMembersInMap = nSquadMembersInMap;
}

function int GetMissionSquadMembersInMap( int nMissionIdx )
{
	return MissionStats[nMissionIdx].SquadMembersInMap;
}

function SetMissionPlayerShotsFired( int nMissionIdx, float flPlayerShotsFired )
{
	MissionStats[nMissionIdx].PlayerShotsFired = flPlayerShotsFired;
}

function float GetMissionPlayerShotsFired( int nMissionIdx )
{
	return MissionStats[nMissionIdx].PlayerShotsFired;
}

function SetMissionPlayerShotsHit( int nMissionIdx, float flPlayerShotsHit )
{
	MissionStats[nMissionIdx].PlayerShotsHit = flPlayerShotsHit;
}

function float GetMissionPlayerShotsHit( int nMissionIdx )
{
	return MissionStats[nMissionIdx].PlayerShotsHit;
}

function SetMissionPlayerShotsSuppression( int nMissionIdx, float flPlayerShotsSuppression )
{
	MissionStats[nMissionIdx].PlayerShotsSuppression = flPlayerShotsSuppression;
}

function float GetMissionPlayerShotsSuppression( int nMissionIdx )
{
	return MissionStats[nMissionIdx].PlayerShotsSuppression;
}

function SetMissionAIShotsFired( int nMissionIdx, float flAIShotsFired )
{
	MissionStats[nMissionIdx].AIShotsFired = flAIShotsFired;
}

function float GetMissionAIShotsFired( int nMissionIdx )
{
	return MissionStats[nMissionIdx].AIShotsFired;
}

function SetMissionAIShotsHit( int nMissionIdx, float flAIShotsHit )
{
	MissionStats[nMissionIdx].AIShotsHit = flAIShotsHit;
}

function float GetMissionAIShotsHit( int nMissionIdx )
{
	return MissionStats[nMissionIdx].AIShotsHit;
}

function SetMissionAIShotsSuppression( int nMissionIdx, float flAIShotsSuppression )
{
	MissionStats[nMissionIdx].AIShotsSuppression = flAIShotsSuppression;
}

function float GetMissionAIShotsSuppression( int nMissionIdx )
{
	return MissionStats[nMissionIdx].AIShotsSuppression;
}
*/
// =======================================================================================================================================================
// Mission progression functions
// =======================================================================================================================================================
simulated function string MissionCompleted( int nMissionIdx, EDifficulty completedDiff )
{
	local string result;
	local EDifficulty diff;

	// result is a number if any medals were awarded for this completion.
	if (!CompletedMissionDifficulty(nMIssionIdx, completedDiff))
	{
		result = String(int(completedDiff));
	}

	// if the next chapter is a film chapter, unlock the same levels in that chapter.
	if (class'gbxMissionMan'.static.sGetMissionStyle(nMissionIdx+1) == ECIS_Film)
	{
		MissionCompleted(nMissionIdx+1, completedDiff);
	}

	// unlock all difficulties for the first chapter when it is completed.
	if (nMissionIdx == 0)
		diff = DIFF_Authentic;
	else
		diff = completedDiff;

	// mark as completed - also mark any missions in lower difficulty as complete
	switch( diff ) {
		case DIFF_Easy:
			MissionStats[nMissionIdx].bCompleted[ int(diff) ] = 1;
		break;

		case DIFF_Normal:
			MissionStats[nMissionIdx].bCompleted[ int(diff)-1 ] = 1;
			MissionStats[nMissionIdx].bCompleted[ int(diff) ] = 1;
		break;

		case DIFF_Hard:
			MissionStats[nMissionIdx].bCompleted[ int(diff)-2 ] = 1;
			MissionStats[nMissionIdx].bCompleted[ int(diff)-1 ] = 1;
			MissionStats[nMissionIdx].bCompleted[ int(diff) ] = 1;
		break;

		case DIFF_Authentic:
			MissionStats[nMissionIdx].bCompleted[ int(diff)-3 ] = 1;
			MissionStats[nMissionIdx].bCompleted[ int(diff)-2 ] = 1;
			MissionStats[nMissionIdx].bCompleted[ int(diff)-1 ] = 1;
			MissionStats[nMissionIdx].bCompleted[ int(diff) ] = 1;
		break;
	};

	log(self$".MissionCompleted( "$nMissionIdx$", "$diff$" )");
	LastMissionCompleted = nMissionIdx;
	LastDifficultyCompleted = completedDiff;

	MenuCameraView = class'Engine.gbxMissionMan'.Static.GetCameraView(nMissionIdx + 1);

	// mark bDisplayedVictory if this is the last mission
	if (nMissionIdx == MissionCount-1)
	{
		bDisplayedVictory = true;
		LastMissionCompleted = -1;	// force a restart from the top
	}

	return result;
}

simulated function int FindFirstIncompleteMission()
{
	local int i;
	
	for (i=0; i<MissionCount; i++)
	{
		if (CompletedMission(i) == 0)
			return i;
	}

	return -1;
}

simulated function int CompletedMission(int nMissionIdx)
{
	local int diff, count;
	
	count = 0;
	if ((nMissionIdx >= 0) && (nMissionIdx < MissionCount))
	{
		for (diff=EDifficulty.DIFF_Easy; diff<=EDifficulty.DIFF_Authentic; diff++)
		{
			if (MissionStats[nMissionIdx].bCompleted[diff] != 0)
				count++;
		}
	}
		
	return count;
}

simulated function int CompletedDifficulty(EDifficulty diff, optional bool bOnlyFilmChapters)
{
	local int i, count;

	count = 0;
	for (i=0; i<MissionCount; i++)
	{
		if (MissionStats[i].bCompleted[int(diff)] != 0)
		{
			if (!bOnlyFilmChapters || (class'gbxMissionMan'.static.sGetMissionStyle(i) == ECIS_Film))
				count++;
		}
	}

	return count;
}

simulated function int HighestCompletedDifficulty(int nMissionIdx)
{
	local int diff;
	
	if ((nMissionIdx >= 0) && (nMissionIdx < MissionCount))
	{
		for (diff=EDifficulty.DIFF_Authentic; diff>=EDifficulty.DIFF_Easy; diff--)
		{
			if (MissionStats[nMissionIdx].bCompleted[diff] != 0)
				return diff;
		}
	}
		
	return -1;
}

simulated function bool IsAuthenticUnlocked()
{
	return (CompletedDifficulty(DIFF_Easy) == MissionCount) && (CompletedDifficulty(DIFF_Normal) == MissionCount) && (CompletedDifficulty(DIFF_Hard) == MissionCount);
}

simulated function bool CompletedMissionDifficulty(int nMissionIdx, EDifficulty diff)
{
	if ((nMissionIdx >= 0) && (nMissionIdx < MissionCount))
	{
		return MissionStats[nMissionIdx].bCompleted[ int(diff) ] != 0;
	}

	return false;
}

simulated function bool IsMissionUnlocked(int nMissionIdx)
{
	local int i;
	local bool result;

	if ((nMissionIdx >= 0) && (nMissionIdx < MissionCount))
	{
		result = true;
		for (i=0; i<nMissionIdx; i++)
		{
			if (CompletedMission(i) == 0)
			{
				result = false;
				break;
			}
		}
	}
	else
	{
		result = false;
	}

	return result;
}

simulated function int GetContinueMission()
{
	if ((LastMissionCompleted == -1) || (LastMissionCompleted == MissionCount-1))
	{
		return 0;
	}
	else
		return LastMissionCompleted+1;
}

simulated function SetMissionComplete(int nMissionIdx, EDifficulty diff, byte bComplete)
{
	MissionStats[nMissionIdx].bCompleted[ int(diff) ] = bComplete;
}

static simulated function UnlockProfile(LevelInfo Level, string inProfileName, optional bool bRandom)
{
    local GameProfile gProfile;
	local int i, diff;

	gProfile = LoadGameProfile(Level, inProfileName);
	if (gProfile != None)
	{
		for (i=0; i<Level.MissionManager.Missions.Length; i++)
		{
			for (diff=EDifficulty.DIFF_Easy; diff<=EDifficulty.DIFF_Authentic; diff++)
			{
				if (!bRandom || (gProfile.IsMissionUnlocked(i) && (Rand(2) == 1)))
				{
					gProfile.SetMissionComplete(i, EDifficulty(diff), 1);
				}
				else
				{
					gProfile.SetMissionComplete(i, EDifficulty(diff), 0);
				}
			}
		}

		gProfile.bDisplayedVictory = false;
		UnloadProfile(Level, gProfile, true);
	}
}

function ClearPawnSaveList()
{
	if (SavedPawns.Length > 0)
	{
		SavedPawns.Remove( 0, SavedPawns.Length );
	}
}

function SkirmishClearPawnSaveList()
{
	if (SkirmishSavedPawns.Length > 0)
	{
		SkirmishSavedPawns.Remove( 0, SkirmishSavedPawns.Length );
	}
}

function SkirmishClearPlayerSaveList()
{
	if (SkirmishPlayerHealth.Length > 0)
	{
		SkirmishPlayerHealth.Remove( 0, SkirmishPlayerHealth.Length );
	}
}

function ClearInventorySaveLists()
{
	if (SavedWeapons.Length > 0)
	{
		SavedWeapons.Remove( 0, SavedWeapons.Length );
	}
	if (SavedInventory.Length > 0)
	{
		SavedInventory.Remove( 0, SavedInventory.Length );
	}
	if (SavedSecondaryInventory.Length > 0)
	{
		SavedSecondaryInventory.Remove( 0, SavedSecondaryInventory.Length );
	}
}

function SkirmishClearInventorySaveLists()
{
	if (SkirmishSavedWeapons.Length > 0)
	{
		SkirmishSavedWeapons.Remove( 0, SkirmishSavedWeapons.Length );
	}
	if (SkirmishSavedInventory.Length > 0)
	{
		SkirmishSavedInventory.Remove( 0, SkirmishSavedInventory.Length );
	}
	if (SkirmishSavedSecondaryInventory.Length > 0)
	{
		SkirmishSavedSecondaryInventory.Remove( 0, SkirmishSavedSecondaryInventory.Length );
	}
}

function ClearValueSaveList()
{
	if (SavedValues.Length > 0)
	{
		SavedValues.Remove( 0, SavedValues.Length );
	}
}

function SkirmishClearValueSaveList()
{
	if (SkirmishSavedValues.Length > 0)
	{
		SkirmishSavedValues.Remove( 0, SkirmishSavedValues.Length );
	}
}

function AddSavedPlayer( int nHealth )
{
	PlayerHealth = nHealth;
}

function SkirmishAddSavedPlayer( Controller PlayerOwner, int nHealth, int nScore )
{
	local	int	nCharType;
	
	if (AnimPawn(PlayerOwner.Pawn) != None)
	{
		nCharType = AnimPawn(PlayerOwner.Pawn).m_nCharType;
	}
	SkirmishPlayerHealth.Length = SkirmishPlayerHealth.Length + 1;
	SkirmishPlayerHealth[SkirmishPlayerHealth.Length - 1].nCharOwner = nCharType;
	SkirmishPlayerHealth[SkirmishPlayerHealth.Length - 1].Health = nHealth;
	SkirmishPlayerHealth[SkirmishPlayerHealth.Length - 1].Score = nScore;
}

function AddSavedPawn( name szTag, int nHealth, int default_Health, bool bFriendly )
{
	local int	nIdx;

	if (szTag == '')
	{
		return;
	}	
	for (nIdx = 0; nIdx < SavedPawns.Length; nIdx++)
	{
		if (SavedPawns[nIdx].Tag == szTag)
		{
			SavedPawns[nIdx].Health = nHealth;
			SavedPawns[nIdx].default_Health = default_Health;
			SavedPawns[nIdx].bFriendly = bFriendly;
			return;
		}
	}
	SavedPawns.Length = SavedPawns.Length + 1;
	SavedPawns[SavedPawns.Length - 1].Tag = szTag;
	SavedPawns[SavedPawns.Length - 1].Health = nHealth;
	SavedPawns[SavedPawns.Length - 1].default_Health = default_Health;
	SavedPawns[SavedPawns.Length - 1].bFriendly = bFriendly;
}

function SkirmishAddSavedPawn( Controller PlayerOwner, int nHealth, int nType, bool bFriendly )
{
	local	int	nCharType;
	
	if (AnimPawn(PlayerOwner.Pawn) != None)
	{
		nCharType = AnimPawn(PlayerOwner.Pawn).m_nCharType;
	}
	SkirmishSavedPawns.Length = SkirmishSavedPawns.Length + 1;
	SkirmishSavedPawns[SkirmishSavedPawns.Length - 1].nCharOwner = nCharType;
	SkirmishSavedPawns[SkirmishSavedPawns.Length - 1].Health = nHealth;
	SkirmishSavedPawns[SkirmishSavedPawns.Length - 1].nType = nType;
	SkirmishSavedPawns[SkirmishSavedPawns.Length - 1].bFriendly = bFriendly;
}

function AddSavedWeapon( class<Weapon> aClass, int nTotalAmmo, int nClipAmmo, bool bActive )
{
	SavedWeapons.Length = SavedWeapons.Length + 1;
	SavedWeapons[SavedWeapons.Length - 1].WeaponClass = aClass;
	SavedWeapons[SavedWeapons.Length - 1].TotalAmmo = nTotalAmmo;
	SavedWeapons[SavedWeapons.Length - 1].ClipAmmo = nClipAmmo;
	SavedWeapons[SavedWeapons.Length - 1].bActive = bActive;
}

function SkirmishAddSavedWeapon( Controller PlayerOwner, class<Weapon> aClass, int nTotalAmmo, int nClipAmmo, bool bActive )
{
	local	int	nCharType;
	
	if (AnimPawn(PlayerOwner.Pawn) != None)
	{
		nCharType = AnimPawn(PlayerOwner.Pawn).m_nCharType;
	}
	SkirmishSavedWeapons.Length = SkirmishSavedWeapons.Length + 1;
	SkirmishSavedWeapons[SkirmishSavedWeapons.Length - 1].nCharOwner = nCharType;
	SkirmishSavedWeapons[SkirmishSavedWeapons.Length - 1].WeaponClass = aClass;
	SkirmishSavedWeapons[SkirmishSavedWeapons.Length - 1].TotalAmmo = nTotalAmmo;
	SkirmishSavedWeapons[SkirmishSavedWeapons.Length - 1].ClipAmmo = nClipAmmo;
	SkirmishSavedWeapons[SkirmishSavedWeapons.Length - 1].bActive = bActive;
}

function AddSavedInventory( class<Inventory> aClass, int nQuantity )
{
	SavedInventory.Length = SavedInventory.Length + 1;
	SavedInventory[SavedInventory.Length - 1].InventoryClass = aClass;
	SavedInventory[SavedInventory.Length - 1].Quantity = nQuantity;
}

function SkirmishAddSavedInventory( Controller PlayerOwner, class<Inventory> aClass, int nQuantity )
{
	local	int	nCharType;
	
	if (AnimPawn(PlayerOwner.Pawn) != None)
	{
		nCharType = AnimPawn(PlayerOwner.Pawn).m_nCharType;
	}
	SkirmishSavedInventory.Length = SkirmishSavedInventory.Length + 1;
	SkirmishSavedInventory[SkirmishSavedInventory.Length - 1].nCharOwner = nCharType;
	SkirmishSavedInventory[SkirmishSavedInventory.Length - 1].InventoryClass = aClass;
	SkirmishSavedInventory[SkirmishSavedInventory.Length - 1].Quantity = nQuantity;
}

function AddSavedSecondaryInventory( class<Inventory> aClass, int nQuantity )
{
	SavedSecondaryInventory.Length = SavedSecondaryInventory.Length + 1;
	SavedSecondaryInventory[SavedSecondaryInventory.Length - 1].InventoryClass = aClass;
	SavedSecondaryInventory[SavedSecondaryInventory.Length - 1].Quantity = nQuantity;
}

function SkirmishAddSavedSecondaryInventory( Controller PlayerOwner, class<Inventory> aClass, int nQuantity )
{
	local	int	nCharType;
	
	if (AnimPawn(PlayerOwner.Pawn) != None)
	{
		nCharType = AnimPawn(PlayerOwner.Pawn).m_nCharType;
	}
	SkirmishSavedSecondaryInventory.Length = SkirmishSavedSecondaryInventory.Length + 1;
	SkirmishSavedSecondaryInventory[SkirmishSavedSecondaryInventory.Length - 1].nCharOwner = nCharType;
	SkirmishSavedSecondaryInventory[SkirmishSavedSecondaryInventory.Length - 1].InventoryClass = aClass;
	SkirmishSavedSecondaryInventory[SkirmishSavedSecondaryInventory.Length - 1].Quantity = nQuantity;
}

function AddSavedValue( name szValueName, int nValue )
{
	SavedValues.Length = SavedValues.Length + 1;
	SavedValues[SavedValues.Length - 1].ValueName = szValueName;
	SavedValues[SavedValues.Length - 1].nValue = nValue;
}

function SkirmishAddSavedValue( name szValueName, int nValue )
{
	SkirmishSavedValues.Length = SkirmishSavedValues.Length + 1;
	SkirmishSavedValues[SkirmishSavedValues.Length - 1].ValueName = szValueName;
	SkirmishSavedValues[SkirmishSavedValues.Length - 1].nValue = nValue;
}

function bool ShouldHelpWithCheckpoint( LevelInfo Level)
{
	local int	i;
	local int	nReloadsToTest;
	
	switch( Level.DifficultyLevel )
	{
		case DIFF_Easy:
			nReloadsToTest = 1;
			break;
		case DIFF_Normal:
			nReloadsToTest = 2;
			break;
		case DIFF_Hard:
			nReloadsToTest = 3;
			break;
		default:
			nReloadsToTest = 2;
			break;
	}
	if (nCheckpointReloads >= nReloadsToTest)
	{
		if (Level.DifficultyLevel <= DIFF_Hard)
		{
			if (PlayerHealth < 100)
			{
				return true;
			}
			for( i = 0; i < SavedPawns.Length; i++ )
			{
				if (SavedPawns[ i ].bFriendly)
				{
					if (SavedPawns[ i ].Health < SavedPawns[ i ].default_Health)
					{
						return true;
					}
				}
			}
		}
	}
	return false;
}

function bool SkirmishShouldHelpWithCheckpoint( LevelInfo Level)
{
	local int	i;
	
	if (nSkirmishCheckpointReloads >= 2)
	{
		for( i = 0; i < SkirmishPlayerHealth.Length; i++ )
		{
			if (SkirmishPlayerHealth[i].Health < 100)
			{
				return true;
			}
		}
		// GBX:PAD: OK.  This is fucked up, but since pawns aren't necessarily saved in Skirmish, I need to make some
		// assumptions, so if the length of this list is less than 4, it pretty much means at least one guy is dead,
		// so flag this for help.
		if (SkirmishSavedPawns.Length < 4)
		{
			return true;
		}
		for( i = 0; i < SkirmishSavedPawns.Length; i++ )
		{
			if (SkirmishSavedPawns[ i ].bFriendly)
			{
				if (SkirmishSavedPawns[ i ].Health < 100)
				{
					return true;
				}
			}
		}
	}
	return false;
}

function HelpWithCheckpoint( LevelInfo Level )
{
	local	int	nPlayerHealth, i;
	
	nPlayerHealth = 100;
	
	if (PlayerHealth < nPlayerHealth)
	{
		PlayerHealth = nPlayerHealth;
	}

	for( i = 0; i < SavedWeapons.Length; i++ )
	{
		if (SavedWeapons[i].TotalAmmo < SavedWeapons[i].WeaponClass.Default.DefaultAmmoCount[0])
		{
			SavedWeapons[i].TotalAmmo = SavedWeapons[i].WeaponClass.Default.DefaultAmmoCount[0];
			SavedWeapons[i].ClipAmmo = SavedWeapons[i].WeaponClass.Default.AmmoClipSize;
		}
	}

	for( i = 0; i < SavedPawns.Length; i++ )
	{
		if (SavedPawns[ i ].bFriendly)
		{
			if (SavedPawns[ i ].Health < SavedPawns[ i ].default_Health)
			{
				SavedPawns[ i ].Health = SavedPawns[ i ].default_Health;
			}
		}
	}

	SquadmateHasDied = false;
}

function SkirmishHelpWithCheckpoint( LevelInfo Level )
{
	local	int	nPlayerHealth, nPawnHealth, i;
	
	nPlayerHealth = 100;
	nPawnHealth = 100;
	
	for( i = 0; i < SkirmishPlayerHealth.Length; i++ )
	{
		if (SkirmishPlayerHealth[i].Health < nPlayerHealth)
		{
			SkirmishPlayerHealth[i].Health = nPlayerHealth;
		}
	}

	for( i = 0; i < SkirmishSavedWeapons.Length; i++ )
	{
		if (SkirmishSavedWeapons[i].TotalAmmo < SkirmishSavedWeapons[i].WeaponClass.Default.DefaultAmmoCount[0])
		{
			SkirmishSavedWeapons[i].TotalAmmo = SkirmishSavedWeapons[i].WeaponClass.Default.DefaultAmmoCount[0];
			SkirmishSavedWeapons[i].ClipAmmo = SkirmishSavedWeapons[i].WeaponClass.Default.AmmoClipSize;
		}
	}
	
	for( i = 0; i < SkirmishSavedPawns.Length; i++ )
	{
		if (SkirmishSavedPawns[ i ].bFriendly)
		{
			if (SkirmishSavedPawns[ i ].Health < nPawnHealth)
			{
				SkirmishSavedPawns[ i ].Health = nPawnHealth;
			}
		}
	}

	SkirmishPawnRespawn = true;
}

function IncrementCheckpointReload()
{
	if (nCheckpointReloads != -1)
		nCheckpointReloads++;
}

function SkirmishIncrementCheckpointReload()
{
	if (nSkirmishCheckpointReloads != -1)
		nSkirmishCheckpointReloads++;
}

function DisableCheckpointReload()
{
	nCheckpointReloads = -1;
}

function SkirmishDisableCheckpointReload()
{
	nSkirmishCheckpointReloads = -1;
}

function ClearCheckpointReload()
{
	nCheckpointReloads = 0;
}

function SkirmishClearCheckpointReload()
{
	nSkirmishCheckpointReloads = 0;
}

// =======================================================================================================================================================
// skirmish scoring
// =======================================================================================================================================================
static function SetToDLevelForProfile(LevelInfo Level, string profileName, bool bWantCoop, int newLevel)
{
	local GameProfile gProfile;
	local bool bSave;
	local int index;

	newLevel++;
	gProfile = LoadGameProfile( Level, profileName );
	if (gProfile != None)
	{
		index = 0;
		if ( Left(Level.GetLevelFileName(), 6) ~= "SKR_DE" )
			index++;

		if (bWantCoop)
		{
			if (newLevel > gProfile.SkirmishToDLevelCoop[index])
			{
				bSave = true;
				gProfile.SkirmishToDLevelCoop[index] = newLevel;
			}
		}
		else
		{
			if (newLevel > gProfile.SkirmishToDLevelSolo[index])
			{
				bSave = true;
				gProfile.SkirmishToDLevelSolo[index] = newLevel;
			}
		}
	}
	UnloadProfile( Level, gProfile, bSave );
}

function bool SkirmishSetCompleted( LevelInfo Level, int difficulty )
{
	local	int		nIdx;
	local	bool	fFound, result;
	
	fFound = false;
	for( nIdx = 0; nIdx < SkirmishMapStatsSaved.Length; nIdx++ )
	{
		if (SkirmishMapStatsSaved[nIdx].MapName == Level.GetLevelFileName())
		{
			fFound = true;
			break;
		}
	}
	
	if (fFound)
	{
		if (difficulty > SkirmishMapStatsSaved[nIdx].HighestDifficulty)
		{
			SkirmishMapStatsSaved[nIdx].HighestDifficulty = difficulty;
			result = true;
		}
	}
	else
	{
		nIdx = SkirmishMapStatsSaved.Length;
		SkirmishMapStatsSaved.Length = nIdx + 1;
		SkirmishMapStatsSaved[nIdx].HighestDifficulty = difficulty;
		SkirmishMapStatsSaved[nIdx].MapName = Level.GetLevelFileName();
		result = true;
	}

	return result;
}

function bool SkirmishSaveMapStats( LevelInfo Level, int nMaxWaves, float flBestTime, optional int skillLevel )
{
	local	int		nIdx;
	local	bool	fFound, result;
	
	fFound = false;
	for( nIdx = 0; nIdx < SkirmishMapStatsSaved.Length; nIdx++ )
	{
		if (SkirmishMapStatsSaved[nIdx].MapName == Level.GetLevelFileName())
		{
			fFound = true;
			break;
		}
	}
	
	if (fFound)
	{
		if (nMaxWaves > SkirmishMapStatsSaved[nIdx].nMaxWaves)
		{
			SkirmishMapStatsSaved[nIdx].nMaxWaves = nMaxWaves;
			result = true;
		}
		if (flBestTime > SkirmishMapStatsSaved[nIdx].flBestTime[skillLevel])
		{
			SkirmishMapStatsSaved[nIdx].flBestTime[skillLevel] = flBestTime;
			result = true;
		}
	}
	else
	{
		nIdx = SkirmishMapStatsSaved.Length;
		SkirmishMapStatsSaved.Length = nIdx + 1;
		SkirmishMapStatsSaved[nIdx].nMaxWaves = nMaxWaves;
		SkirmishMapStatsSaved[nIdx].flBestTime[skillLevel] = flBestTime;
		SkirmishMapStatsSaved[nIdx].MapName = Level.GetLevelFileName();
		result = true;
	}

	return result;
}

function bool SkirmishGetMapStats( LevelInfo Level, out int nMaxWaves, out float flBestTime, optional int skillLevel )
{
	local	int		nIdx;
	local	bool	fFound;
	
	fFound = false;
	for( nIdx = 0; nIdx < SkirmishMapStatsSaved.Length; nIdx++ )
	{
		if (SkirmishMapStatsSaved[nIdx].MapName == Level.GetLevelFileName())
		{
			nMaxWaves = SkirmishMapStatsSaved[nIdx].nMaxWaves;
			flBestTime = SkirmishMapStatsSaved[nIdx].flBestTime[skillLevel];
			return true;
		}
	}
	
	return false;
}

function bool CompletedSkirmishMission()
{
	 return (SkirmishMapStatsSaved.Length != 0)
		|| (SkirmishToDLevelSolo[0] != 0) 
		|| (SkirmishToDLevelSolo[1] != 0) 
		|| (SkirmishToDLevelCoop[0] != 0) 
		|| (SkirmishToDLevelCoop[1] != 0);
}

defaultproperties
{
}
//=============================================================================
// GameReplicationInfo.
//=============================================================================
class GameReplicationInfo extends ReplicationInfo
	native nativereplication;


// Which game info class is currently running?
enum EGameType
{
	GT_SINGLEPLAYER,
	GT_MULTIPLAYER,
	GT_SKIRMISH
};

var string GameName;						// Assigned by GameInfo.
var string GameClass;						// Assigned by GameInfo.
var string mutators;                        //Assigned by GameInfo JER
var bool bTeamGame;							// Assigned by GameInfo.
var EGameType GameType;						// Assigned by GameInfo.
var bool bStopCountDown;
var bool bAllowTextChat;

//SDJ 04/12/2004: From UC.
var bool bJoinable;                         // gam -- joinable by anybody
var bool bInvitable;                        // gam -- joinable by invite

var bool bMatchHasBegun;
var bool bTeamSymbolsUpdated;

var int LobbyCountdownTime;

// skirmish lobby setting replication
var int Skirmish_Team;
var int Skirmish_Mode;
var int Skirmish_Skill;
var int Skirmish_Skills[3];
var string Skirmish_Mission;
var int Skirmish_ToDSkills[2];

var int  RemainingTime, ElapsedTime, RemainingMinute;
var float SecondCount;
var int GoalScore;
var int TimeLimit;
var int MaxLives;
var int MaxPlayers;							// CEK: need to replicate this for the lobby
var int FinalScore;							// holds -1 if final scores have not yet been updated, otherwise gametype specific "score" value
var int TotalKills;

var TeamInfo Teams[2];

var() globalconfig string ServerName;		// Name of the server, i.e.: Bob's Server.
var() globalconfig string ShortName;		// Abbreviated name of server, i.e.: B's Serv (stupid example)
var() globalconfig string AdminName;		// Name of the server admin.
var() globalconfig string AdminEmail;		// Email address of the server admin.
var() globalconfig int	  ServerRegion;		// Region of the game server.

var() globalconfig string MOTDLine1;		// Message
var() globalconfig string MOTDLine2;		// Of
var() globalconfig string MOTDLine3;		// The
var() globalconfig string MOTDLine4;		// Day

var Actor Winner;			// set by gameinfo when game ends
var byte WinningTeam;		// this is lame, but it helps to solve Bug 9280
var string WinReason;		// GEARBOX - set by the gameinfo when the game ends 2003-06-22 JWS
var string NextMapName;		// GEARBOX - set by the debriefing screen when game ends 2004-06-22 JWS

var() array<PlayerReplicationInfo> PRIArray;
var() array<UnitReplicationInfo> URIArray;

var vector FlagPos;	// replicated 2D position of one object

enum ECarriedObjectState
{
    COS_Home,
    COS_HeldFriendly,
    COS_HeldEnemy,
    COS_Down,
};
var ECarriedObjectState CarriedObjectState[2];

// stats
var int MatchID;

replication
{
	reliable if ( bNetDirty && (Role == ROLE_Authority) )
		RemainingMinute, bStopCountDown, Winner, WinningTeam, WinReason, NextMapName, Teams, LobbyCountdownTime,
		FlagPos, CarriedObjectState, bMatchHasBegun, MatchID, bInvitable, bJoinable,
		Skirmish_Team, Skirmish_Mode, Skirmish_Skill, Skirmish_Skills, Skirmish_Mission,
		GameType, Skirmish_ToDSkills, FinalScore, TotalKills;

	reliable if ( bNetInitial && (Role==ROLE_Authority) )
		GameName, GameClass, bTeamGame,
		RemainingTime, ElapsedTime,MOTDLine1, MOTDLine2,
		MOTDLine3, MOTDLine4, ServerName, ShortName, AdminName,
		AdminEmail, ServerRegion, GoalScore, MaxLives, TimeLimit, MaxPlayers, bAllowTextChat, mutators; //JER
}

simulated function SetCarriedObjectState(int Team, name NewState)
{
	switch( NewState )
	{
		case 'Down':
			CarriedObjectState[Team] = COS_Down;
			break;
		case 'HeldEnemy ':
			CarriedObjectState[Team] = COS_HeldEnemy;
			break;
		case 'Home ':
			CarriedObjectState[Team] = COS_Home;
			break;
		case 'HeldFriendly ':
			CarriedObjectState[Team] = COS_HeldFriendly;
			break;
	}
}

simulated function name GetCarriedObjectState(int Team)
{
	switch( CarriedObjectState[Team] )
	{
		case COS_Down:
			return 'Down';
		case COS_HeldEnemy:
			return 'HeldEnemy';
		case COS_Home:
			return 'Home';
		case COS_HeldFriendly:
			return 'HeldFriendly';
	}
	return '';
}

simulated function PostNetBeginPlay()
{
	local PlayerReplicationInfo PRI;
	local UnitReplicationInfo URI;

	ForEach DynamicActors(class'PlayerReplicationInfo',PRI)
	{
		AddPRI(PRI);
	}

	ForEach DynamicActors(class'UnitReplicationInfo',URI)
	{
		AddURI(URI);
	}

	if ( Level.NetMode == NM_Client )
		TeamSymbolNotify();
}

simulated function TeamSymbolNotify()
{
	local Actor A;

	if ( (Teams[0] == None) || (Teams[1] == None)
		|| (Teams[0].TeamIcon == None) || (Teams[1].TeamIcon == None) )
		return;
	bTeamSymbolsUpdated = true;
	ForEach AllActors(class'Actor', A)
		A.SetGRI(self);
}

simulated function PostBeginPlay()
{
	if( Level.NetMode == NM_Client )
	{
		// clear variables so we don't display our own values if the server has them left blank
		ServerName = "";
		AdminName = "";
		AdminEmail = "";
		MOTDLine1 = "";
		MOTDLine2 = "";
		MOTDLine3 = "";
		MOTDLine4 = "";
	}

	SecondCount = Level.TimeSeconds;
	SetTimer(1, true);
}

/* Reset()
reset actor to initial state - used when restarting level without reloading.
*/
function Reset()
{
	Super.Reset();
	Winner = None;
	WinningTeam = 0;
}

simulated function Timer()
{
	if ( Level.NetMode == NM_Client )
	{
		if (Level.TimeSeconds - SecondCount >= Level.TimeDilation)
		{
			ElapsedTime++;
			if ( RemainingMinute != 0 )
			{
				RemainingTime = RemainingMinute;
				RemainingMinute = 0;
			}
			if ( (RemainingTime > 0) && !bStopCountDown )
				RemainingTime--;
			SecondCount += Level.TimeDilation;
		}
		if ( !bTeamSymbolsUpdated )
			TeamSymbolNotify();
	}
}

simulated function AddPRI(PlayerReplicationInfo PRI)
{
    PRIArray[PRIArray.Length] = PRI;
}

simulated function RemovePRI(PlayerReplicationInfo PRI)
{
    local int i;

    for (i=0; i<PRIArray.Length; i++)
    {
        if (PRIArray[i] == PRI)
            break;
    }

    if (i == PRIArray.Length)
    {
        log("GameReplicationInfo::RemovePRI() pri="$PRI$" not found.", 'Error');
        return;
    }

    PRIArray.Remove(i,1);
	}

simulated function GetPRIArray(out array<PlayerReplicationInfo> pris)
{
    local int i;
    local int num;

    pris.Remove(0, pris.Length);
    for (i=0; i<PRIArray.Length; i++)
    {
        if (PRIArray[i] != None)
            pris[num++] = PRIArray[i];
    }
}

simulated function AddURI(UnitReplicationInfo URI)
{
    URIArray[URIArray.Length] = URI;
}

simulated function RemoveURI(UnitReplicationInfo URI)
{
    local int i;

    for (i=0; i<URIArray.Length; i++)
    {
        if (URIArray[i] == URI)
            break;
    }

    if (i == URIArray.Length)
    {
        log("GameReplicationInfo::RemoveURI() URI="$URI$" not found.", 'Error');
        return;
    }

    URIArray.Remove(i,1);
}

simulated function GetURIArray(out array<UnitReplicationInfo> URIs)
{
    local int i;
    local int num;

    URIs.Remove(0, URIs.Length);
    for (i=0; i<URIArray.Length; i++)
    {
        if (URIArray[i] != None)
            URIs[num++] = URIArray[i];
    }
}

defaultproperties
{
	CarriedObjectState[0]=FLAG_Home
	CarriedObjectState[1]=FLAG_Home
	bStopCountDown=true
	RemoteRole=ROLE_SimulatedProxy
	bAlwaysRelevant=True
	ServerName="Another Server"
	ShortName="Server"
	MOTDLine1=""
	MOTDLine2=""
	MOTDLine3=""
	MOTDLine4=""

	LobbyCountdownTime=-1
	FinalScore=-1
	TotalKills=0

	bNetNotify=true
	GameType=GT_SINGLEPLAYER
}
//=============================================================================
// GameRules.
//
// The GameRules class handles game rule modifications for the GameInfo such as scoring,
// finding player starts, and damage modification.
//
//=============================================================================
class GameRules extends Info;



var GameRules NextGameRules;

function AddGameRules(GameRules GR)
{
	if ( NextGameRules == None )
		NextGameRules = GR;
	else
		NextGameRules.AddGameRules(GR);
}

/* Override GameInfo FindPlayerStart() - called by GameInfo.FindPlayerStart()
if a NavigationPoint is returned, it will be used as the playerstart
*/
function NavigationPoint FindPlayerStart( Controller Player, optional byte InTeam, optional string incomingName )
{
	if ( NextGameRules != None )
		return NextGameRules.FindPlayerStart(Player,InTeam,incomingName);

	return None;
}

/* return string containing game rules information
*/
function string GetRules()
{
	local string ResultSet;

	if ( NextGameRules == None )
		ResultSet = ResultSet$NextGameRules.GetRules();

	return ResultSet;
}

//
// server querying
// append the mutator name- only used if mutator adds me and deletes itself.
function GetServerDetails( out GameInfo.ServerResponseLine ServerState );

//
// Restart the game.
//
function bool HandleRestartGame()
{
	if ( (NextGameRules != None) && NextGameRules.HandleRestartGame() )
		return true;
	return false;
}

/* CheckEndGame()
Allows modification of game ending conditions.  Return false to prevent game from ending
*/
function bool CheckEndGame(PlayerReplicationInfo Winner, string Reason)
{
	if ( NextGameRules != None )
		return NextGameRules.CheckEndGame(Winner,Reason);

	return true;
}

/* CheckScore()
see if this score means the game ends
return true to override gameinfo checkscore, or if game was ended (with a call to Level.Game.EndGame() )
*/
function bool CheckScore(PlayerReplicationInfo Scorer)
{
	if ( NextGameRules != None )
		return NextGameRules.CheckScore(Scorer);

	return false;
}

/* OverridePickupQuery()
when Pawn wants to pickup something, gamerules given a chance to modify it.  If this function
returns true, bAllowPickup will determine if the object can be picked up.
*/
function bool OverridePickupQuery(Pawn Other, Pickup item, out byte bAllowPickup)
{
	if ( (NextGameRules != None) &&  NextGameRules.OverridePickupQuery(Other, item, bAllowPickup) )
		return true;
	return false;
}

function bool PreventDeath(Pawn Killed, Controller Killer, class<DamageType> damageType, vector HitLocation)
{
	if ( (NextGameRules != None) && NextGameRules.PreventDeath(Killed,Killer, damageType,HitLocation) )
		return true;
	return false;
}

function bool PreventSever(Pawn Killed, Name boneName, int Damage, class<DamageType> DamageType)
{
	if ( (NextGameRules != None) && NextGameRules.PreventSever(Killed, boneName, Damage, DamageType) )
		return true;
	return false;
}

function ScoreObjective(PlayerReplicationInfo Scorer, Int Score)
{
	if ( NextGameRules != None )
		NextGameRules.ScoreObjective(Scorer,Score);
}

function ScoreKill(Controller Killer, Controller Killed)
{
	if ( NextGameRules != None )
		NextGameRules.ScoreKill(Killer,Killed);
}

function bool CriticalPlayer(Controller Other)
{
	if ( (NextGameRules != None) && (NextGameRules.CriticalPlayer(Other)) )
		return true;

	return false;
}

function int NetDamage( int OriginalDamage, int Damage, Pawn injured, Pawn instigatedBy, vector HitLocation, out vector Momentum, class<DamageType> DamageType )
{
	if ( NextGameRules != None )
		return NextGameRules.NetDamage( OriginalDamage,Damage,injured,instigatedBy,HitLocation,Momentum,DamageType );
	return Damage;
}

defaultproperties
{
}
// ====================================================================
//  Class:  Engine.GameStats
//  Parent: Engine.Info
//
//  the GameStats object is used to send individual stat events to the
//  stats server.  Each game should spawn a GameStats object if it
//  wishes to have stat logging.
//
// ====================================================================

class GameStats extends Info
		Native;



var FileLog TempLog;
var GameReplicationInfo GRI;
var bool bShowBots;

native final function string GetStatsIdentifier( Controller C );
native final function string GetMapFileName();	// Returns the name of the current map

/////////////////////////////////////
// GameStats interface

function Init()
{
	TempLog = spawn(class 'FileLog');
	if (TempLog!=None)
	{
		TempLog.OpenLog("Stats");
		log("Output Game stats to: STATS.TXT");
	}
	else
	{
		log("Could not spawn Temporary Stats log");
		Destroy();
	}
}
function Shutdown()
{
	if (TempLog!=None)
		TempLog.Destroy();
}
function Logf(string LogString)
{
	if (TempLog!=None)
		TempLog.Logf(LogString);
}

/////////////////////////////////////
// Internals

event PostBeginPlay()
{
	Super.PostBeginPlay();
	Init();
}

event Destroyed()
{
	Shutdown();
	Super.Destroyed();
}

function string TimeStamp()
{
	local string seconds;
	seconds = ""$Level.TimeSeconds;

	// Remove the centiseconds
	if( InStr(seconds,".") != -1 )
		seconds = Left( seconds, InStr(seconds,".") );

	return seconds;
}

function string Header()
{
	return ""$TimeStamp()$chr(9);
}

function String FullTimeDate()		// Date/Time in MYSQL format
{
	return ""$Level.Year$"-"$Level.Month$"-"$Level.Day$" "$Level.Hour$":"$Level.Minute$":"$Level.Second;
}

function String TimeZone()			// Timezone (offset) of game server's local time to GTM, e.g. -4 or +5
{
	return "0";						// FIXME Jack - currently pretending GMT
}

function String MapName()
{
	local string mapname;
	local string tab;
	tab = ""$Chr(9);
	mapname = ""$GetMapFileName();

	// Remove the file name extention .ut2
	if( InStr(mapname,".ut2") != -1 )
		mapname = Left( mapname, InStr(mapname,".ut2") );

	ReplaceText(mapname, tab, "_");

	return mapname;
}


// Stat Logging functions
function NewGame()
{
	local string out, tmp;
	local string tab, ngTitle, ngAuthor, ngGameGameName;
	local int i;
	local mutator MyMutie;
	local GameRules MyRules;

	tab				= ""$Chr(9);
	ngTitle			= Level.Title;			// Making local copies
	ngAuthor		= Level.Author;
	ngGameGameName	= Level.Game.GameName;
	ReplaceText(ngTitle,		tab, "_");	// Replacing tabs with _
	ReplaceText(ngAuthor,		tab, "_");
	ReplaceText(ngGameGameName, tab, "_");

	GRI = Level.Game.GameReplicationInfo;
	out = Header()$"NG"$chr(9);				// "NewGame"
	out = out$FullTimeDate()$Chr(9);		// Game server's local time
	out = out$TimeZone()$Chr(9);			// Game server's time zone (offset to GMT)
	out = out$MapName()$Chr(9);				// Map file name without map extention .ut2
	out = out$ngTitle$chr(9);
	out = out$ngAuthor$chr(9);
	out = out$Level.Game.Class$chr(9);
	out = out$ngGameGameName;

	tmp = "";
	i = 0;
	foreach AllActors(class'Mutator',MyMutie)
	{
		if (tmp!="")
			tmp=tmp$"|"$MyMutie.Class;
		else
	 		tmp=""$MyMutie.Class;

		i++;
	}
	foreach AllActors(class'GameRules',MyRules)
	{
		if (tmp!="")
			tmp=tmp$"|"$MyRules.Class;
		else
			tmp=""$MyRules.Class;

		i++;
	}

	if (i>0)
	{
		ReplaceText(tmp, tab, "_");
		out = out$chr(9)$"Mutators="$tmp;
	}
	Logf(out);
}

function ServerInfo()
{
	local string out, flags;
	local string tab, siServerName, siAdminName, siAdminEmail;
	local GameInfo.ServerResponseLine ServerState;
	local int i;

	tab = ""$Chr(9);
	siServerName	= GRI.ServerName;	// Making local copies
	siAdminName		= GRI.AdminName;
	siAdminEmail	= GRI.AdminEmail;
	ReplaceText(siServerName,	tab, "_");
	ReplaceText(siAdminName,	tab, "_");
	ReplaceText(siAdminEmail,	tab, "_");

	out = Header()$"SI"$chr(9);			// "SeverInfo"
	out = out$siServerName$chr(9);		// Server name
	out = out$TimeZone()$chr(9);		// Timezone
	out = out$siAdminName$chr(9);		// Admin name
	out = out$siAdminEmail$chr(9);		// Admin email
	out = out$chr(9);					// IP:port (filled in by Master Server)

	flags = "";							// Server flag / key combos
	Level.Game.GetServerDetails( ServerState );
	for( i=0;i<ServerState.ServerInfo.Length;i++ )
		flags = flags$"\\"$ServerState.ServerInfo[i].Key$"\\"$ServerState.ServerInfo[i].Value;

	ReplaceText(flags, tab, "_");
	out	= out$flags;
	Logf(out);
}

function StartGame()
{
	Logf( ""$Header()$"SG" );			// "StartGame"
}


// Send stats for the end of the game
function EndGame(string Reason)
{
	local string out;
	local int i,j;
	local GameReplicationInfo GRI;
	local array<PlayerReplicationInfo> PRIs;
	local PlayerReplicationInfo PRI,t;

	out = Header()$"EG"$Chr(9)$Reason;	// "EndGame"

	GRI = Level.Game.GameReplicationInfo;

	// Quick cascade sort.
	for (i=0;i<GRI.PRIArray.Length;i++)
	{
		PRI = GRI.PRIArray[i];
		if ( !PRI.bOnlySpectator && !PRI.bBot )
		{
			PRIs.Length = PRIs.Length+1;
			for (j=0;j<Pris.Length-1;j++)
			{
				if (PRIs[j].Score < PRI.Score ||
				   (PRIs[j].Score == PRI.Score && PRIs[j].Deaths > PRI.Deaths) )
				{
					t = PRIs[j];
					PRIs[j] = PRI;
					PRI = t;
				}
			}
			PRIs[j] = PRI;
		}
	}

	// Minimal scoreboard, shows Playernumbers in order of Score
	for (i=0;i<PRIs.Length;i++)
		out = out$chr(9)$Controller(PRIs[i].Owner).PlayerNum;

	Logf(out);
}


// Connect Events get fired every time a player connects to a server
function ConnectEvent(PlayerReplicationInfo Who)
{
	local string out;
	if ( Who.bBot || Who.bOnlySpectator )			// Spectators should never show up in stats!
		return;

	// C	0	11d8944d9e138a5aa688d503e0e4c3e0
	out = ""$Header()$"C"$Chr(9)$Controller(Who.Owner).PlayerNum$Chr(9);

	// Login identifier
	out = out$GetStatsIdentifier(Controller(Who.Owner));

	Logf(out);
}

// Connect Events get fired every time a player connects or leaves from a server
function DisconnectEvent(PlayerReplicationInfo Who)
{
	local string out;
	if ( Who.bBot || Who.bOnlySpectator )			// Spectators should never show up in stats!
		return;

	// D	0
	out = ""$Header()$"D"$Chr(9)$Controller(Who.Owner).PlayerNum;	//"Disconnect"

	Logf(out);
}


// Scoring Events occur when a player's score changes
function ScoreEvent(PlayerReplicationInfo Who, float Points, string Desc)
{
	if ( Who.bBot || Who.bOnlySpectator )			// Just to be totally safe Spectators sends nothing
		return;
	Logf( ""$Header()$"S"$chr(9)$Controller(Who.Owner).PlayerNum$chr(9)$Points$chr(9)$Desc );	//"Score"
}


function TeamScoreEvent(int Team, float Points, string Desc)
{
	Logf( ""$Header()$"T"$Chr(9)$Team$Chr(9)$Points$Chr(9)$Desc );	//"TeamScore"
}


// KillEvents occur when a player kills, is killed, suicides
function KillEvent(string Killtype, PlayerReplicationInfo Killer, PlayerReplicationInfo Victim, class<DamageType> Damage)
{
	local string out;

	if ( Victim.bBot || Victim.bOnlySpectator || ((Killer != None) && Killer.bBot) )
		return;

	out = ""$Header()$Killtype$Chr(9);

	// KillerNumber and KillerDamagetype
	if (Killer!=None)
	{
		out = out$Controller(Killer.Owner).PlayerNum$Chr(9);
		// KillerWeapon no longer used, using damagetype
		out = out$GetItemName(string(Damage))$Chr(9);
	}
	else
		out = out$"-1"$chr(9)$GetItemName(string(Damage))$Chr(9);	// No PlayerNum -> -1, Environment "deaths"

	// VictimNumber and VictimWeapon
	out = out$Controller(Victim.Owner).PlayerNum$chr(9)$GetItemName(string(Controller(Victim.Owner).GetLastWeapon()));

	// Type killers tracked as player event (redundant Typing, removed from kill line)
	if ( PlayerController(Victim.Owner)!= None && PlayerController(Victim.Owner).bIsTyping)
	{
		if ( PlayerController(Killer.Owner) != PlayerController(Victim.Owner) )
			SpecialEvent(Killer, "type_kill");						// Killer killed typing victim
	}

	Logf(out);
}


// Special Events are everything else regarding the player
function SpecialEvent(PlayerReplicationInfo Who, string Desc)
{
	local string out;
	if (Who != None)
	{
		if ( Who.bBot || Who.bOnlySpectator )		// Avoid spectator suicide on console "type_kill"
			return;
		out = ""$Controller(Who.Owner).PlayerNum;
	}
	else
		out = "-1";

	Logf( ""$Header()$"P"$Chr(9)$out$Chr(9)$Desc );					//"PSpecial"
}


// Special events regarding the game
function GameEvent(string GEvent, string Desc, PlayerReplicationInfo Who)
{
	local string out, tab, geDesc;

	if (Who != None)
	{
		if ( Who.bBot || Who.bOnlySpectator )		// Specator could cause NameChange, TeamChange! No longer.
			return;
		out = ""$Controller(Who.Owner).PlayerNum;
	}
	else
		out = "-1";

	geDesc	= Desc;
	tab		= ""$Chr(9);
	ReplaceText(geDesc, tab, "_");									// geDesc, can be the nickname!

	Logf( ""$Header()$"G"$Chr(9)$GEvent$Chr(9)$out$Chr(9)$geDesc );	//"GSpecial"
}

defaultproperties
{
}
//////////////////////////////////////////////////////////////////////////////////////////
// * gbxCharacterSpawner *
// This class can be used within a level to create characters, i.e. pawns at runtime.
// Trigger this actor to make it spawn a character.
//////////////////////////////////////////////////////////////////////////////////////////

class gbxCharacterSpawner extends Actor
	hidecategories(Collision,Lighting,LightColor,Karma,Force)
	native
	notplaceable;



var() bool bWaitForTrigger;			// If false, Pawn is spawned when level loaded. Otherwise, the Pawn is spawned when this actor is triggered.
var() bool bDestroyAfterSpawn;		// If true, this actor self-destructs after spawning its Pawn. Otherwise, it stays around and can spawn additional pawns when triggered again.
var() bool bUseRootMotion;			// Set this Pawn to use root motion
var	bool	bWaitForSpawn;
var	bool	bSpawnDisabled;

var bool	bPlaySpawnAnimation;
var bool	bSwitchToBestWeapon;
var bool	bHideWeaponAfterSwitch;
var bool	bSpawnAnimInGodMode;

var Pawn newPawn;

var(CharPawn) class<Pawn>			PawnClass;
var(CharPawn) name					PawnTag;

var(CharController) class<AIController>	ControllerClass;
var(CharController) name				ControllerTag;

var(AI) name AIScriptTag;

var MeshAnimation aMeshAnim;
var string	SpawnAnimPackage;
var array<name>	SpawnAnims;  // played on the spawned Pawn before the Controller possesses it
var AIController TempC;

var int		nSpawnHealth;


function PostLinearize()
{
    Super.PostLinearize();

	if( !bWaitForTrigger )
	{
		SpawnPawn( true );

		if (bPlaySpawnAnimation)
			GotoState('PlaySpawnAnimation');
	}
}

function Trigger( actor Other, Pawn EventInstigator )
{
	Super.Trigger( Other, EventInstigator );

	if (!bSpawnDisabled)
	{
		SpawnPawn( false );
	}

	if (bPlaySpawnAnimation)
		GotoState('PlaySpawnAnimation');
}

function Pawn GetRespawnedPawn()
{
	return Spawn( PawnClass,,, Location, Rotation );
}

function DeadPawnJoinUnit();

function Pawn SpawnPawn( bool bSpawnNow )
{
	local IGbxPawnList PawnList;
	local float			flDelay;
	local int			nHealth;
	local Pawn			SpawnedPawn;

	if( PawnClass == None )
	{
		Log( "WARNING: " $ class $ ".SpawnPawn() failing due to NULL PawnClass." );
		return None;
	}

	nHealth = -1;

	// This is very slow, and has no meaning for MP anyways. So only do this stuff in SP games. 2004-12-02 JWS
	if (Level.NetMode == NM_Standalone)
	{
		if (Level.MissionManager.GetCheckpointPawnHealth( PawnTag, nHealth))
		{
			if (nHealth <= 0)
			{
				Log( "Pawn "$PawnTag$" not created because it is dead according to the checkpoint." );
				
				DeadPawnJoinUnit();
				
				return None;
			}
		}
	}
	
	if (Level.bPoolPawns && (Level.NetMode == NM_StandAlone))
	{
		PawnList = Level.GetPawnList();
		if (!bSpawnNow && !PawnList.CanSpawnNow())
		{
			PawnList.IncrementRespawnDelay();
			bWaitForSpawn = true;
			flDelay = PawnList.GetRespawnDelay();
			SetTimer(flDelay, false);
			return None;
		}

		newPawn = GetRespawnedPawn();
		if (newPawn != None)
		{
			Respawn(newPawn,,, Location, Rotation );
		}
		else
		{	
			newPawn = Spawn( PawnClass,,, Location, Rotation );
		}
	}
	else
	{
		newPawn = Spawn( PawnClass,,, Location, Rotation );
	}

	if (bPlaySpawnAnimation)
	{
		// hide this pawn until the animation actually starts (to reduce visual popping)
		// (AnimNotify_Unhide should un-hide the Pawn)
		newPawn.bHidden = true;
	}

	if( newPawn == None )
	{
		Log( "WARNING: " $ class $ ".SpawnPawn() unable to spawn Pawn of class '" $ PawnClass $ "'." );
	}
	else
	{
		bWaitForSpawn = false;
		SpawnedPawn = newPawn;

		if (nHealth > 0)
		{
			newPawn.Health = nHealth;
		}

		ConfigurePawn( newPawn );

		if (!bPlaySpawnAnimation)
		{
			// give derived class a chance to be returned to...
			if (bDestroyAfterSpawn)
				SetTimer(0.1, false);
		}
	}

	//log(self$".SpawnPawn( "$bSpawnNow$" ) - "$PawnTag$" - "$newPawn$" - "$newPawn.Health$" - "$nHealth);
	if (!bPlaySpawnAnimation)
		newPawn = None;  // to prevent references to things that have been destroyed later

	return SpawnedPawn;
}

function Timer()
{
	if (bWaitForSpawn)
	{
		SpawnPawn( true );
	}

	if (!bWaitForSpawn && bDestroyAfterSpawn)
	{
		Destroy();
	}
}

function ConfigurePawn( Pawn SomePawn )
{
	local AIScript		A;
	local int			i;

	if( PawnTag != 'None' )
	{
		SomePawn.Tag = PawnTag;
	}

	if (!bPlaySpawnAnimation)
	{
		SpawnControllerFor(SomePawn);
	}

	if (StaticMesh != None)
	{
		SomePawn.SetStaticMesh(StaticMesh);
		SomePawn.SetDrawType( DT_STATICMESH );
//		SomePawn.Mesh = None;
//		LinkMesh( None );
//		SomePawn.SetPhysics( PHYS_None );
	}
	else
	{
		if (Mesh != None)
		{
			SomePawn.Mesh = Mesh;
		}
		if (Skins.Length > 0)
		{
			for (i = 0; i < Skins.Length; i++)
			{
				SomePawn.Skins[i] = Skins[i];
			}
		}
	}

	SomePawn.bUseRootMotion = bUseRootMotion;

	if ( AIScriptTag != '' )
	{
		SomePawn.AIScriptTag = AIScriptTag;
		ForEach AllActors(class'AIScript', A, SomePawn.AIScriptTag)
			break;
		// let the AIScript spawn and init my controller
		if ( A != None )
		{
			A.SpawnControllerFor(SomePawn);
			if ( SomePawn.Controller != None )
				return;
		}
	}
}

function SpawnControllerFor(Pawn SomePawn)
{
	local AIController newController;

	if( ControllerClass != None )
	{
		newController = Spawn( ControllerClass,,, SomePawn.Location, SomePawn.Rotation );

		if( newController == None )
		{
			Log( "WARNING: " $ class $ ".SpawnControllerFor() unable to spawn controller of class '" $ ControllerClass $ "'." );
		}
		else
		{
			newController.Possess( SomePawn );

			ConfigureController( newController );
		}
	}
}

function ConfigureController( AIController C )
{
	if( ControllerTag != 'None' )
	{
		C.Tag = ControllerTag;
	}
}

// In the ConfigurePawn function we might need to set the body mesh before doing all the head attachment and animation set
// stuff, but after the unit is assigned.
function SetCustomBodyMesh( Pawn SomePawn );

function StartAnimOnPawn()
{
	local int anim_index;

	if (SpawnAnimPackage != "")
	{
		aMeshAnim = MeshAnimation(DynamicLoadObject(SpawnAnimPackage, class'MeshAnimation'));
		if (aMeshAnim != None)
		{
			newPawn.LinkSkelAnim(aMeshAnim);
		}
	}

	newPawn.SetMovementPhysics();
	if (newPawn.Physics != PHYS_Walking)
		newPawn.SetPhysics(PHYS_Falling);

	newPawn.bRotateToDesired = false;  // don't let the controller rotate this pawn

	TempC = spawn(class'AIController',,, newPawn.Location, newPawn.Rotation);
	TempC.Possess( newPawn );

	if (bSwitchToBestWeapon)
	{
		TempC.ClientSwitchToBestWeapon();

		if (bHideWeaponAfterSwitch)
			newPawn.Weapon.ThirdPersonActor.bHidden = true;
	}

	if (bSpawnAnimInGodMode)
		TempC.bGodMode = true;

	if (AnimPawn(newPawn) != None)
	{
		AnimPawn(newPawn).bWaitForAnim = true;
		anim_index = Rand(SpawnAnims.Length);
		AnimPawn(newPawn).PlayAnim(SpawnAnims[anim_index], 1.0, 0.0);  // sequence and rate

		newPawn.bHasStartedMountAnim = true;  // don't let other animations (flinch, etc) interrupt this one
	}

	newPawn.bHidden = false;
}


auto state Idle
{
	// do nothing
}

// PlaySpawnAnimation allows you to play an animation after the pawn is spawned, but before the Controller possess the Pawn
state PlaySpawnAnimation
{

Begin:

	if (AnimPawn(newPawn) != None)
	{
		StartAnimOnPawn();

		while (AnimPawn(newPawn).bWaitForAnim)
		{
			Sleep(0.1);
		}
	}

	if (bSwitchToBestWeapon)
	{
		if (bHideWeaponAfterSwitch)
			newPawn.Weapon.ThirdPersonActor.bHidden = false;
	}

	newPawn.bHasStartedMountAnim = false;

	SpawnControllerFor(newPawn);

	TempC.Destroy();

	// give derived class a chance to be returned to...
	if (bDestroyAfterSpawn)
		SetTimer(0.1, false);

	newPawn = None;  // to prevent references to things that have been destroyed later

	GotoState('Idle');
}


defaultproperties
{
	bHidden=true
	bStatic=false
	bDirectional=true
	CollisionHeight=90

	bWaitForTrigger=false
	bDestroyAfterSpawn=true
	
	bWaitForSpawn=false
}

class GbxEditTexture extends Object
    native;



var() array<Material> Textures;

defaultproperties
{
}
class GbxFluidSurface extends Actor
	showcategories(Movement,Collision,Lighting,LightColor,Karma,Force)
	native
	noexport
	placeable;

var(GbxFluidSurface) GbxShaderMaterial		ProceduralShader;	// The shader used to procedurally generate the texture.

defaultproperties
{
	DrawType=DT_GbxFluidSurface
	Texture=Texture'Engine.S_FluidSurf'

	bStatic=True
	bStaticLighting=True
	bPlanarSort=True
	SpecialSort=SS_Water
}//=============================================================================
// The light class.
//=============================================================================
class GbxLightBloom extends Light
	placeable
	native;

var(Bloom) Material LightBloomTexture;
var(Bloom) int		RayLength;

defaultproperties
{
	bBloom=True
    bStatic=True
    bHidden=True
    bNoDelete=True
	LightType=LT_None
	bMovable=False
	RayLength=16
}
class gbxMessage extends Object
	hidecategories(Object)
	editinlinenew
	native
	poolable(20,0);



var(MessageData) int UserData;			// Arbitrary value set by the LD, possibly to identify the message uniquely without needing to subclass.

// SENDER INFO ///////////////////////////////////////////////////////////////////////////////////////////////

var Actor	Sender;
var float	TimeSent;
var Pawn	Instigator;    // Pawn that caused this message to be created (not used in all cases of gbxMessage)

// LOCATION INFO /////////////////////////////////////////////////////////////////////////////////////////////

var(MessageLocation) bool bUseSenderLocation;	// If true, all following location vars are ignored.
var(MessageLocation) Actor aLocation;
var(MessageLocation) Vector vLocation;		// Used if aLocation==None
var(MessageLocation) bool bHasLocation;
var(MessageLocation) bool bNoDelete;			// Do not delete this message as its owner wants to reuse it.

// BROADCAST DIRECTIVES //////////////////////////////////////////////////////////////////////////////////////

var(MessageBroadcast) bool bBroadcastAll;				// If true, broadcasts to all actors that are message listeners.
														// Overrides following broadcast directives.

var(MessageBroadcast) bool bBroadcastRecipientsOnly;	// Overrides following broadcast directives.

// If a listener actor isn't specified as a recipient and bBroadcastAll and bBroadcastRecipientsOnly == false, send this message
// to the actor based on these spatial considerations (but only if this message is localized).
var(MessageBroadcast) bool bBroadcastLOSBlocked;
var(MessageBroadcast) bool bBroadcastRadially;
var(MessageBroadcast) float BroadcastRadius;

// RECIPIENTS ////////////////////////////////////////////////////////////////////////////////////////////////

// You can specify particular recipients that the message should definitely go to. Spatial considerations
// will be ignored for these recipients: unless they aren't listening for messages at all (Actor.bMessageListener == false)
// they will definitely get the message.

// IMPORTANT: Only actors in the gbxMessageManager's Listeners array will receive messages at all.

var(MessageBroadcast) name RecipientTag;				// Broadcast to actors with this tag.
var(MessageBroadcast) editinline array< Actor > Recipients;		// Broadcast to these specific actors.

// DUPE CONTROL //////////////////////////////////////////////////////////////////////////////////////////////

var(MessageDuplication) bool bDupable;
var(MessageDuplication) float DupeRadius;					// Set this to -1 to ignore radius.
var(MessageDuplication) float DupeTime;					// Set this to -1 to ignore time.

var int NumDupes;						// The number of duplications of this message that this message represents.



// FUNKTIONS /////////////////////////////////////////////////////////////////////////////////////////////////

function bool HasLocation()
{
	return bHasLocation || ( bUseSenderLocation && Sender != None );
}

function Vector GetLocation()
{
	if( !HasLocation() )
	{
		Log( class $ ".GetLocation() called with non-located message" );
	}

	if( bUseSenderLocation )
	{
		return Sender.Location;
	}

	if( aLocation != None )
	{
		return aLocation.Location;
	}
	else
	{
		return vLocation;
	}
}

function bool IsDupe( gbxMessage msg )
{
	// Returns true if msg is a dupe of this message.

	local bool found;
	local int i, j;
	local float dist, timeDelta;

	if( msg == Self )
	{
		return true;
	}

	// Check dupability.
	if( !bDupable || !msg.bDupable )
	{
		return false;
	}

	// Make sure the messages are similar. They should at least be a similar class.
	if( !IsA( msg.Class.Name ))
	{
		return false;
	}

	//
	// Ensure that desired recipients are generally the same (not a precise check).
	//

	if( bBroadcastAll != msg.bBroadcastAll )
	{
		return false;
	}

	if( !bBroadcastAll )
	{

		// Check tagged recipients.
		if( RecipientTag != msg.RecipientTag )
		{
			return false;
		}

		// Check specified recipients.
		if( Recipients.Length != msg.Recipients.Length )
		{
			return false;
		}

		for( i = 0; i < Recipients.Length; ++i )
		{
			found = false;

			for( j = 0; j < msg.Recipients.Length; ++j )
			{
				if( Recipients[ i ] == msg.Recipients[ j ] )
				{
					found = true;
					break;
				}
			}

			if( !found )
			{
				// Didn't share recipient.
				return false;
			}
		}

		if( bBroadcastRecipientsOnly != msg.bBroadcastRecipientsOnly )
		{
			return false;
		}

		if( !bBroadcastRecipientsOnly )
		{
			if( bBroadcastLOSBlocked != msg.bBroadcastLOSBlocked )
			{
				return false;
			}

			if( bBroadcastRadially != msg.bBroadcastRadially )
			{
				return false;
			}

			if( bBroadcastRadially && Abs( BroadcastRadius - msg.BroadcastRadius ) > 10 )	// TODO arbitrary
			{
				return false;
			}
		}
	}

	// Check proximity.
	if( DupeRadius >= 0 && HasLocation() && msg.HasLocation() )
	{
		dist = VSize( GetLocation() - msg.GetLocation() );

		if( dist > DupeRadius )
		{
			// New message is outside of DupeRadius.
			return false;
		}
	}

	// Check times.
	if( DupeTime >= 0 )
	{
		timeDelta = Abs( TimeSent - msg.TimeSent );

		if( timeDelta > DupeTime )
		{
			return false;
		}
	}

	return true;
}

function bool ShouldBeDeliveredTo( Actor actor )
{
	local Pawn P;
	local Controller C;
	local int i;
	local vector loc;

	if( !actor.bMessageListener )
	{
		return false;
	}

	if( bBroadcastAll )
	{
		return true;
	}

	// Is this listener one of my tagged recipients?
	if( actor.Tag == RecipientTag )
	{
		return true;
	}

	// Is this listener one of my specified recipients?
	for( i = 0; i < Recipients.Length; ++i )
	{
		if( Recipients[ i ] == actor )
		{
			return true;
		}
	}

	if( bBroadcastRecipientsOnly )
	{
		// Don't broadcast based on anything we haven't checked already.
		return false;
	}

	if( HasLocation() )
	{
		loc = GetLocation();

		if( bBroadcastRadially )
		{
			if( VSize( actor.Location - loc ) > BroadcastRadius )
			{
				// Actor too far away.
				return false;
			}
		}

		if( bBroadcastLOSBlocked )
		{
			P = Pawn( actor );
			C = Controller( actor );

			// Don't deliver if actor doesn't have line-of-sight to message location.
			if( P != None )
			{
				if( !P.CanSeeLocation( loc ))
				{
					return false;
				}
			}
			else if( C != None )
			{
				if( !C.CanSeeLocation( loc ))
				{
					return false;
				}
			}
			else if( !actor.FastTrace( loc ))
			{
				// Actor Line-Of-Sight to message location blocked.
				return false;
			}
		}

		return true;
	}

	return false;
}


event bool ActorWasDeleted( Actor anActor )
{
	return false;
}

// DEFAULT PROPERTIES ////////////////////////////////////////////////////////////////////////////////////////

defaultproperties
{
	RecipientTag=None

	bUseSenderLocation=true
	bHasLocation=false

	bBroadcastAll=false
	bBroadcastRecipientsOnly=false
	bBroadcastLOSBlocked=false
	bBroadcastRadially=false

	bDupable=false
	NumDupes=0
}
class gbxMessageManager extends Actor
	native;

var array< Actor >		Listeners;
var array< gbxMessage > MessageQueue;

var() float DistributionInterval;		// Seconds that pass between distribution of messages.


function int FindListener( Actor listener )
{
	local int i;
	for( i = 0; i < Listeners.Length; ++i )
	{
		if( Listeners[ i ] == listener )
		{
			return i;
		}
	}
	return -1;
}

function AddListener( Actor listener )
{
	// Make sure the listener hasn't already been added.

	if( listener == None || listener.bDeleteMe )
	{
		Log( class $ ".AddListener( " $ listener $ " ): attempted to add illegal listener." );
		return;
	}

	if( FindListener( listener ) < 0 )
	{
		Listeners.Length = Listeners.Length + 1;
		Listeners[ Listeners.Length - 1 ] = listener;

		listener.bMessageListener = true;
	}
}

function RemoveListener( Actor listener )
{
	local int ndx;

	ndx = FindListener( listener );

	if( ndx >= 0 )
	{
		listener.bMessageListener = false;

		Listeners.Remove( ndx, 1 );
	}
}

function PostMessage( gbxMessage msg )
{
	local int i;

	if (msg == None)
	{
		Log(name $ ".PostMessage() - Trying to post a NULL message!!!");
		return;
	}

	if( msg.bDupable )
	{
		// Look for dupes.

		for( i = 0; i < MessageQueue.Length; ++i )
		{
			if( MessageQueue[i] != None && MessageQueue[ i ].IsDupe( msg ))
			{
				// It's a dupe. Record it and discard.
				MessageQueue[ i ].NumDupes++;

				if ( msg != MessageQueue[ i ] && !msg.bNoDelete )
					delete( msg );

				return;
			}
		}
	}

	MessageQueue.Length = MessageQueue.Length + 1;
	MessageQueue[ MessageQueue.Length - 1 ] = msg;
}

function SendMessage( gbxMessage msg )
{
	local int i;

	for( i = 0; i < Listeners.Length; ++i )
	{
		if (Listeners[ i ] == None)
			Log(name $ ".SendMessage() - Trying to send a message to NULL Listener (at index = "$i$")");
		else if( msg.ShouldBeDeliveredTo( Listeners[ i ] ))
		{
			Listeners[ i ].ReceiveGBXMessage( msg );
		}
	}

	if ( !msg.bNoDelete )
		delete( msg );
}

function PostBeginPlay()
{
	Super.PostBeginPlay();

	SetTimer( DistributionInterval, true );
}

event Timer()
{
	DistributeMessages();
}

function DistributeMessages()
{
	local int i, j;

	// TODO: this function will need optimization as the numbers of messages and recipients grow larger
	// and shift relative to each other.

	// Distribute messages.
	for( i = 0; i < MessageQueue.Length; ++i )
	{
		// Consider each actor in the listeners array as potential recipients.

		if ( MessageQueue[ i ] != None )
		{
			for( j = 0; j < Listeners.Length; ++j )
			{
				if (Listeners[ j ] == None || Listeners[ j ].bDeleteMe )
				{
					Log(name $ ".DistributeMessages() - Trying to send a message to NULL or deleted Listener (at index = "$j$")");
				}
				else if( MessageQueue[ i ].ShouldBeDeliveredTo( Listeners[ j ] ))
				{
					Listeners[ j ].ReceiveGBXMessage( MessageQueue[ i ] );
				}
			}

			if ( !MessageQueue[ i ].bNoDelete )
			{
				delete( MessageQueue[ i ] );
				MessageQueue[i] = None;
			}
		}
	}

	// Messages delivered (and in some cases, deleted). Clear the message queue.
	MessageQueue.Remove( 0, MessageQueue.Length );
}

function Destroyed()
{
	MessageQueue.Remove( 0, MessageQueue.Length );
	Super.Destroyed();
}

// GBX:PAD: This is dumb, but since Dorian has created subclasses of gbxMessageSI in maps themselves, I can't reliably
// run this code unless the mappers go through and recompile script in every map.  So, by putting in this check, I
// can work around the situation (and the gbxMessageSI didn't actually have any custom code for cleanup anyway).
event bool ShouldCleanupMessage( gbxMessage aMessage )
{
	if (aMessage.IsA('gbxMessageSI'))
	{
		return false;
	}
	return true;
}

defaultproperties
{
	bHidden=true
	bHiddenEd=true
	bStatic=false

	DistributionInterval=0.1
}
//=============================================================================
// gbxMissionMan
// Handles mission map / mini-map cycling and stats collection
//=============================================================================
class gbxMissionMan extends Actor
	Config(storyline)
	notplaceable;


enum EChapterIconStyle
{
	ECIS_Normal,
	ECIS_Film,
	ECIS_Disabled,
};

struct MissionMapInfo
{
	var string							Map;
	var EChapterIconStyle				Style;
};

var config array<MissionMapInfo>		Missions;

var localized string					HartsockBornDate;
var string								PlayerRankName;		// filled in when the correct ranked name is determined by the gamecode

struct CachedValueInfo
{
	var		name	ValueName;
	var		int		nValue;
};
var		array<CachedValueInfo>	CachedValues;

var transient GameProfile							CachedGameProfile;

var transient bool						bSquadmateHasDied;

function CacheGameProfile( GameProfile gProfile )
{
	local int			nIdx;
//	local int			nIdx2;

	if (gProfile != None)
	{
		if (CachedGameProfile == None)
		{
			CachedGameProfile = new( Level.Outer ) class'GameProfile';
		}
		CachedGameProfile.GameName = gProfile.GameName;
		CachedGameProfile.bDisplayedVictory = gProfile.bDisplayedVictory;
		CachedGameProfile.LastMissionCompleted = gProfile.LastMissionCompleted;
		CachedGameProfile.LastDifficultyCompleted = gProfile.LastDifficultyCompleted;
		CachedGameProfile.MenuCameraView = gProfile.MenuCameraView;
		CachedGameProfile.SaveMissionName = gProfile.SaveMissionName;
		CachedGameProfile.SaveMissionDifficulty = gProfile.SaveMissionDifficulty;
		CachedGameProfile.SaveMissionCheckpoint = gProfile.SaveMissionCheckpoint;
		
		CachedGameProfile.SquadmateHasDied = gProfile.SquadmateHasDied;
		if (gProfile.SquadmateHasDied)
		{
			bSquadmateHasDied = gProfile.SquadmateHasDied;
		}
		
		CachedGameProfile.nCheckpointReloads = gProfile.nCheckpointReloads;
		CachedGameProfile.SavedPawns.Length = gProfile.SavedPawns.Length;
		for (nIdx = 0; nIdx < gProfile.SavedPawns.Length; nIdx++)
		{
			CachedGameProfile.SavedPawns[nIdx].Tag = gProfile.SavedPawns[nIdx].Tag;
			CachedGameProfile.SavedPawns[nIdx].Health = gProfile.SavedPawns[nIdx].Health;
			CachedGameProfile.SavedPawns[nIdx].default_Health = gProfile.SavedPawns[nIdx].default_Health;
			CachedGameProfile.SavedPawns[nIdx].bFriendly = gProfile.SavedPawns[nIdx].bFriendly;
		}
		CachedGameProfile.PlayerHealth = gProfile.PlayerHealth;
		CachedGameProfile.SavedWeapons.Length = gProfile.SavedWeapons.Length;
		for (nIdx = 0; nIdx < gProfile.SavedWeapons.Length; nIdx++)
		{
			CachedGameProfile.SavedWeapons[nIdx].WeaponClass = gProfile.SavedWeapons[nIdx].WeaponClass;
			CachedGameProfile.SavedWeapons[nIdx].TotalAmmo = gProfile.SavedWeapons[nIdx].TotalAmmo;
			CachedGameProfile.SavedWeapons[nIdx].ClipAmmo = gProfile.SavedWeapons[nIdx].ClipAmmo;
			CachedGameProfile.SavedWeapons[nIdx].bActive = gProfile.SavedWeapons[nIdx].bActive;
		}
		CachedGameProfile.SavedInventory.Length = gProfile.SavedInventory.Length;
		for (nIdx = 0; nIdx < gProfile.SavedInventory.Length; nIdx++)
		{
			CachedGameProfile.SavedInventory[nIdx].InventoryClass = gProfile.SavedInventory[nIdx].InventoryClass;
			CachedGameProfile.SavedInventory[nIdx].Quantity = gProfile.SavedInventory[nIdx].Quantity;
		}
		CachedGameProfile.SavedSecondaryInventory.Length = gProfile.SavedSecondaryInventory.Length;
		for (nIdx = 0; nIdx < gProfile.SavedSecondaryInventory.Length; nIdx++)
		{
			CachedGameProfile.SavedSecondaryInventory[nIdx].InventoryClass = gProfile.SavedSecondaryInventory[nIdx].InventoryClass;
			CachedGameProfile.SavedSecondaryInventory[nIdx].Quantity = gProfile.SavedSecondaryInventory[nIdx].Quantity;
		}
		CachedGameProfile.SavedValues.Length = gProfile.SavedValues.Length;
		for (nIdx = 0; nIdx < gProfile.SavedValues.Length; nIdx++)
		{
			log("CacheGameProfile() - "$gProfile.SavedValues[nIdx].ValueName$" - "$gProfile.SavedValues[nIdx].nValue);
			CachedGameProfile.SavedValues[nIdx].ValueName = gProfile.SavedValues[nIdx].ValueName;
			CachedGameProfile.SavedValues[nIdx].nValue = gProfile.SavedValues[nIdx].nValue;
		}
		
		CachedGameProfile.SkirmishMissionName = gProfile.SkirmishMissionName;
		CachedGameProfile.SkirmishMissionCheckpoint = gProfile.SkirmishMissionCheckpoint;
		CachedGameProfile.SkirmishPawnRespawn = gProfile.SkirmishPawnRespawn;
		
		CachedGameProfile.nSkirmishCheckpointReloads = gProfile.nSkirmishCheckpointReloads;
		CachedGameProfile.SkirmishSavedPawns.Length = gProfile.SkirmishSavedPawns.Length;
		for (nIdx = 0; nIdx < gProfile.SkirmishSavedPawns.Length; nIdx++)
		{
			CachedGameProfile.SkirmishSavedPawns[nIdx].nCharOwner = gProfile.SkirmishSavedPawns[nIdx].nCharOwner;
			CachedGameProfile.SkirmishSavedPawns[nIdx].Health = gProfile.SkirmishSavedPawns[nIdx].Health;
			CachedGameProfile.SkirmishSavedPawns[nIdx].nType = gProfile.SkirmishSavedPawns[nIdx].nType;
			CachedGameProfile.SkirmishSavedPawns[nIdx].bFriendly = gProfile.SkirmishSavedPawns[nIdx].bFriendly;
		}
		CachedGameProfile.SkirmishPlayerHealth.Length = gProfile.SkirmishPlayerHealth.Length;
		for (nIdx = 0; nIdx < gProfile.SkirmishPlayerHealth.Length; nIdx++)
		{
			CachedGameProfile.SkirmishPlayerHealth[nIdx].nCharOwner = gProfile.SkirmishPlayerHealth[nIdx].nCharOwner;
			CachedGameProfile.SkirmishPlayerHealth[nIdx].Health = gProfile.SkirmishPlayerHealth[nIdx].Health;
			CachedGameProfile.SkirmishPlayerHealth[nIdx].Score = gProfile.SkirmishPlayerHealth[nIdx].Score;
		}
		CachedGameProfile.SkirmishSavedWeapons.Length = gProfile.SkirmishSavedWeapons.Length;
		for (nIdx = 0; nIdx < gProfile.SkirmishSavedWeapons.Length; nIdx++)
		{
			CachedGameProfile.SkirmishSavedWeapons[nIdx].nCharOwner = gProfile.SkirmishSavedWeapons[nIdx].nCharOwner;
			CachedGameProfile.SkirmishSavedWeapons[nIdx].WeaponClass = gProfile.SkirmishSavedWeapons[nIdx].WeaponClass;
			CachedGameProfile.SkirmishSavedWeapons[nIdx].TotalAmmo = gProfile.SkirmishSavedWeapons[nIdx].TotalAmmo;
			CachedGameProfile.SkirmishSavedWeapons[nIdx].ClipAmmo = gProfile.SkirmishSavedWeapons[nIdx].ClipAmmo;
			CachedGameProfile.SkirmishSavedWeapons[nIdx].bActive = gProfile.SkirmishSavedWeapons[nIdx].bActive;
		}
		CachedGameProfile.SkirmishSavedInventory.Length = gProfile.SkirmishSavedInventory.Length;
		for (nIdx = 0; nIdx < gProfile.SkirmishSavedInventory.Length; nIdx++)
		{
			CachedGameProfile.SkirmishSavedInventory[nIdx].nCharOwner = gProfile.SkirmishSavedInventory[nIdx].nCharOwner;
			CachedGameProfile.SkirmishSavedInventory[nIdx].InventoryClass = gProfile.SkirmishSavedInventory[nIdx].InventoryClass;
			CachedGameProfile.SkirmishSavedInventory[nIdx].Quantity = gProfile.SkirmishSavedInventory[nIdx].Quantity;
		}
		CachedGameProfile.SkirmishSavedSecondaryInventory.Length = gProfile.SkirmishSavedSecondaryInventory.Length;
		for (nIdx = 0; nIdx < gProfile.SkirmishSavedSecondaryInventory.Length; nIdx++)
		{
			CachedGameProfile.SkirmishSavedSecondaryInventory[nIdx].nCharOwner = gProfile.SkirmishSavedSecondaryInventory[nIdx].nCharOwner;
			CachedGameProfile.SkirmishSavedSecondaryInventory[nIdx].InventoryClass = gProfile.SkirmishSavedSecondaryInventory[nIdx].InventoryClass;
			CachedGameProfile.SkirmishSavedSecondaryInventory[nIdx].Quantity = gProfile.SkirmishSavedSecondaryInventory[nIdx].Quantity;
		}
		CachedGameProfile.SkirmishSavedValues.Length = gProfile.SkirmishSavedValues.Length;
		for (nIdx = 0; nIdx < gProfile.SkirmishSavedValues.Length; nIdx++)
		{
			CachedGameProfile.SkirmishSavedValues[nIdx].ValueName = gProfile.SkirmishSavedValues[nIdx].ValueName;
			CachedGameProfile.SkirmishSavedValues[nIdx].nValue = gProfile.SkirmishSavedValues[nIdx].nValue;
		}
	}
}

function UncacheGameProfile( GameProfile gProfile )
{
	local int			nIdx;
//	local int			nIdx2;

	if (gProfile != None)
	{
		gProfile.GameName = CachedGameProfile.GameName;
		gProfile.bDisplayedVictory = CachedGameProfile.bDisplayedVictory;
		gProfile.LastMissionCompleted = CachedGameProfile.LastMissionCompleted;
		gProfile.LastDifficultyCompleted = CachedGameProfile.LastDifficultyCompleted;
		gProfile.MenuCameraView = CachedGameProfile.MenuCameraView;
//		for (nIdx = 0; nIdx < MISSION_COUNT; nIdx++)
//		{
//			gProfile.SetMissionStat( nIdx, CachedGameProfile.MissionStats[nIdx] );
//		}
		gProfile.SaveMissionName = CachedGameProfile.SaveMissionName;
		gProfile.SaveMissionDifficulty = CachedGameProfile.SaveMissionDifficulty;
		gProfile.SaveMissionCheckpoint = CachedGameProfile.SaveMissionCheckpoint;
		
		gProfile.SquadmateHasDied = CachedGameProfile.SquadmateHasDied;
		
		gProfile.nCheckpointReloads = CachedGameProfile.nCheckpointReloads;
		gProfile.SavedPawns.Length = CachedGameProfile.SavedPawns.Length;
		for (nIdx = 0; nIdx < CachedGameProfile.SavedPawns.Length; nIdx++)
		{
			gProfile.SavedPawns[nIdx].Tag = CachedGameProfile.SavedPawns[nIdx].Tag;
			gProfile.SavedPawns[nIdx].Health = CachedGameProfile.SavedPawns[nIdx].Health;
			gProfile.SavedPawns[nIdx].default_Health = CachedGameProfile.SavedPawns[nIdx].default_Health;
			gProfile.SavedPawns[nIdx].bFriendly = CachedGameProfile.SavedPawns[nIdx].bFriendly;
		}
		gProfile.PlayerHealth = CachedGameProfile.PlayerHealth;
		gProfile.SavedWeapons.Length = CachedGameProfile.SavedWeapons.Length;
		for (nIdx = 0; nIdx < CachedGameProfile.SavedWeapons.Length; nIdx++)
		{
			gProfile.SavedWeapons[nIdx].WeaponClass = CachedGameProfile.SavedWeapons[nIdx].WeaponClass;
			gProfile.SavedWeapons[nIdx].TotalAmmo = CachedGameProfile.SavedWeapons[nIdx].TotalAmmo;
			gProfile.SavedWeapons[nIdx].ClipAmmo = CachedGameProfile.SavedWeapons[nIdx].ClipAmmo;
			gProfile.SavedWeapons[nIdx].bActive = CachedGameProfile.SavedWeapons[nIdx].bActive;
		}
		gProfile.SavedInventory.Length = CachedGameProfile.SavedInventory.Length;
		for (nIdx = 0; nIdx < CachedGameProfile.SavedInventory.Length; nIdx++)
		{
			gProfile.SavedInventory[nIdx].InventoryClass = CachedGameProfile.SavedInventory[nIdx].InventoryClass;
			gProfile.SavedInventory[nIdx].Quantity = CachedGameProfile.SavedInventory[nIdx].Quantity;
		}
		gProfile.SavedSecondaryInventory.Length = CachedGameProfile.SavedSecondaryInventory.Length;
		for (nIdx = 0; nIdx < CachedGameProfile.SavedSecondaryInventory.Length; nIdx++)
		{
			gProfile.SavedSecondaryInventory[nIdx].InventoryClass = CachedGameProfile.SavedSecondaryInventory[nIdx].InventoryClass;
			gProfile.SavedSecondaryInventory[nIdx].Quantity = CachedGameProfile.SavedSecondaryInventory[nIdx].Quantity;
		}
		gProfile.SavedValues.Length = CachedGameProfile.SavedValues.Length;
		for (nIdx = 0; nIdx < CachedGameProfile.SavedValues.Length; nIdx++)
		{
			gProfile.SavedValues[nIdx].ValueName = CachedGameProfile.SavedValues[nIdx].ValueName;
			gProfile.SavedValues[nIdx].nValue = CachedGameProfile.SavedValues[nIdx].nValue;
		}

		gProfile.SkirmishMissionName = CachedGameProfile.SkirmishMissionName;
		gProfile.SkirmishMissionCheckpoint = CachedGameProfile.SkirmishMissionCheckpoint;
		gProfile.SkirmishPawnRespawn = CachedGameProfile.SkirmishPawnRespawn;
		
		gProfile.nSkirmishCheckpointReloads = CachedGameProfile.nSkirmishCheckpointReloads;
		gProfile.SkirmishSavedPawns.Length = CachedGameProfile.SkirmishSavedPawns.Length;
		for (nIdx = 0; nIdx < CachedGameProfile.SkirmishSavedPawns.Length; nIdx++)
		{
			gProfile.SkirmishSavedPawns[nIdx].nCharOwner = CachedGameProfile.SkirmishSavedPawns[nIdx].nCharOwner;
			gProfile.SkirmishSavedPawns[nIdx].Health = CachedGameProfile.SkirmishSavedPawns[nIdx].Health;
			gProfile.SkirmishSavedPawns[nIdx].nType = CachedGameProfile.SkirmishSavedPawns[nIdx].nType;
			gProfile.SkirmishSavedPawns[nIdx].bFriendly = CachedGameProfile.SkirmishSavedPawns[nIdx].bFriendly;
		}
		gProfile.SkirmishPlayerHealth.Length = CachedGameProfile.SkirmishPlayerHealth.Length;
		for (nIdx = 0; nIdx < CachedGameProfile.SkirmishPlayerHealth.Length; nIdx++)
		{
			gProfile.SkirmishPlayerHealth[nIdx].nCharOwner = CachedGameProfile.SkirmishPlayerHealth[nIdx].nCharOwner;
			gProfile.SkirmishPlayerHealth[nIdx].Health = CachedGameProfile.SkirmishPlayerHealth[nIdx].Health;
			gProfile.SkirmishPlayerHealth[nIdx].Score = CachedGameProfile.SkirmishPlayerHealth[nIdx].Score;
		}
		gProfile.SkirmishSavedWeapons.Length = CachedGameProfile.SkirmishSavedWeapons.Length;
		for (nIdx = 0; nIdx < CachedGameProfile.SkirmishSavedWeapons.Length; nIdx++)
		{
			gProfile.SkirmishSavedWeapons[nIdx].nCharOwner = CachedGameProfile.SkirmishSavedWeapons[nIdx].nCharOwner;
			gProfile.SkirmishSavedWeapons[nIdx].WeaponClass = CachedGameProfile.SkirmishSavedWeapons[nIdx].WeaponClass;
			gProfile.SkirmishSavedWeapons[nIdx].TotalAmmo = CachedGameProfile.SkirmishSavedWeapons[nIdx].TotalAmmo;
			gProfile.SkirmishSavedWeapons[nIdx].ClipAmmo = CachedGameProfile.SkirmishSavedWeapons[nIdx].ClipAmmo;
			gProfile.SkirmishSavedWeapons[nIdx].bActive = CachedGameProfile.SkirmishSavedWeapons[nIdx].bActive;
		}
		gProfile.SkirmishSavedInventory.Length = CachedGameProfile.SkirmishSavedInventory.Length;
		for (nIdx = 0; nIdx < CachedGameProfile.SkirmishSavedInventory.Length; nIdx++)
		{
			gProfile.SkirmishSavedInventory[nIdx].nCharOwner = CachedGameProfile.SkirmishSavedInventory[nIdx].nCharOwner;
			gProfile.SkirmishSavedInventory[nIdx].InventoryClass = CachedGameProfile.SkirmishSavedInventory[nIdx].InventoryClass;
			gProfile.SkirmishSavedInventory[nIdx].Quantity = CachedGameProfile.SkirmishSavedInventory[nIdx].Quantity;
		}
		gProfile.SkirmishSavedSecondaryInventory.Length = CachedGameProfile.SkirmishSavedSecondaryInventory.Length;
		for (nIdx = 0; nIdx < CachedGameProfile.SkirmishSavedSecondaryInventory.Length; nIdx++)
		{
			gProfile.SkirmishSavedSecondaryInventory[nIdx].nCharOwner = CachedGameProfile.SkirmishSavedSecondaryInventory[nIdx].nCharOwner;
			gProfile.SkirmishSavedSecondaryInventory[nIdx].InventoryClass = CachedGameProfile.SkirmishSavedSecondaryInventory[nIdx].InventoryClass;
			gProfile.SkirmishSavedSecondaryInventory[nIdx].Quantity = CachedGameProfile.SkirmishSavedSecondaryInventory[nIdx].Quantity;
		}
		gProfile.SkirmishSavedValues.Length = CachedGameProfile.SkirmishSavedValues.Length;
		for (nIdx = 0; nIdx < CachedGameProfile.SkirmishSavedValues.Length; nIdx++)
		{
			gProfile.SkirmishSavedValues[nIdx].ValueName = CachedGameProfile.SkirmishSavedValues[nIdx].ValueName;
			gProfile.SkirmishSavedValues[nIdx].nValue = CachedGameProfile.SkirmishSavedValues[nIdx].nValue;
		}
	}
}

function LaunchCreditsMovie(optional bool bNoSkip)
{
	//DLEVY try captioned video playback
/*
CEK: removing threaded playback, reverting to old method until the movies render properly
	if (bNoSkip)
		ConsoleCommand("PLAYMOVIECAPTIONED ..\\media\\opening_credits.bik 0 0 0 0 0 640 480");
	else
		ConsoleCommand("PLAYMOVIECAPTIONED ..\\media\\opening_credits.bik 0 1 0 0 0 640 480");
*/
	if (bNoSkip)
		ConsoleCommand("PLAYMOVIE ..\\media\\opening_credits.bik 0 0 0 0 0 640 480");
	else
		ConsoleCommand("PLAYMOVIE ..\\media\\opening_credits.bik 0 1 0 0 0 640 480");
}

static function name GetCameraView(int currentMap)
{
	return '';
}

function int GetCheckpointID()
{
	local GameProfile	gProfile;
	
	if (Level.NetMode != NM_StandAlone)
	{
		return 0;
	}
	if (Level.DebugCheckpointID >= 0)
	{
		return Level.DebugCheckpointID;
	}
	if (Level.CheckpointID < 0)
	{
		return 0;
	}
	if (CachedGameProfile == None)
	{
		gProfile = class'GameProfile'.Static.LoadCurrentGameProfile( Level );
		if (gProfile != None)
		{
			CacheGameProfile( gProfile );
			class'GameProfile'.Static.UnloadProfile( Level, gProfile, false );
		}
	}
	if ((Level.GetLevelFileName() == CachedGameProfile.SaveMissionName) && (Level.DifficultyLevel == CachedGameProfile.SaveMissionDifficulty))
		return CachedGameProfile.SaveMissionCheckpoint;
	else
		return 0;
}

function int SkirmishGetCheckpointID()
{
	local GameProfile	gProfile;
	
	if (!Level.Game.IsA('WargameSkirmish'))
	{
		return 0;
	}
	log(self$".SkirmishGetCheckpointID1()");
	if (Level.SkirmishDebugCheckpointID >= 0)
	{
		return Level.SkirmishDebugCheckpointID;
	}
	log(self$".SkirmishGetCheckpointID2()");
	if (Level.SkirmishCheckpointID < 0)
	{
		return 0;
	}
	log(self$".SkirmishGetCheckpointID3()");
	if (!(Level.Game.CanUseCheckpoints( -1 )))
	{
		return 0;
	}
	log(self$".SkirmishGetCheckpointID4()");
	
	if (CachedGameProfile == None)
	{
		gProfile = class'GameProfile'.Static.LoadCurrentGameProfile( Level );
		if (gProfile != None)
		{
			CacheGameProfile( gProfile );
			class'GameProfile'.Static.UnloadProfile( Level, gProfile, false );
		}
	}
	if (Level.GetLevelFileName() == CachedGameProfile.SkirmishMissionName)
	{
		log(self$".SkirmishGetCheckpointID5()");
		return CachedGameProfile.SkirmishMissionCheckpoint;
	}
	else
	{
		log(self$".SkirmishGetCheckpointID6() - "$Level.GetLevelFileName()$" - "$CachedGameProfile.SkirmishMissionName);
		return 0;
	}
}

function int SkirmishLastSavedCheckpointID()
{
	local GameProfile	gProfile;
	
	if (!Level.Game.IsA('WargameSkirmish'))
	{
		return 0;
	}
	if (CachedGameProfile == None)
	{
		gProfile = class'GameProfile'.Static.LoadCurrentGameProfile( Level );
		if (gProfile != None)
		{
			CacheGameProfile( gProfile );
			class'GameProfile'.Static.UnloadProfile( Level, gProfile, false );
		}
	}
	if (Level.GetLevelFileName() == CachedGameProfile.SkirmishMissionName)
		return CachedGameProfile.SkirmishMissionCheckpoint;
	else
		return 0;
}

function ClearCheckpointData( GameProfile gProfile )
{
	if (Level.NetMode != NM_StandAlone)
	{
		return;
	}
	
	if (gProfile != None)
	{
		CachedGameProfile.ClearCheckpointReload();
		if (CachedGameProfile == None)
		{
			CacheGameProfile( gProfile );
		}
		CachedGameProfile.ClearPawnSaveList();
		CachedGameProfile.ClearInventorySaveLists();
		CachedGameProfile.ClearValueSaveList();

		CachedGameProfile.SaveMissionName = "";
		CachedGameProfile.SaveMissionCheckpoint = 0;
		CachedGameProfile.SquadmateHasDied = false;
		
		UncacheGameProfile( gProfile );
	}
}

function SkirmishClearCheckpointData( GameProfile gProfile )
{
	if (gProfile != None)
	{
		CachedGameProfile.SkirmishClearCheckpointReload();
		if (CachedGameProfile == None)
		{
			CacheGameProfile( gProfile );
		}
		CachedGameProfile.SkirmishClearPawnSaveList();
		CachedGameProfile.SkirmishClearPlayerSaveList();
		CachedGameProfile.SkirmishClearInventorySaveLists();
		CachedGameProfile.SkirmishClearValueSaveList();

		CachedGameProfile.SkirmishMissionName = "";
		CachedGameProfile.SkirmishMissionCheckpoint = 0;
		CachedGameProfile.SkirmishPawnRespawn = false;
		
		UncacheGameProfile( gProfile );
	}
}

function SaveCheckpointID( int nCheckpointID )
{
	local GameProfile	gProfile;
	local Pawn			aPawn;
	local int			nIdx, nIdx2;
	local Inventory		aWeapon;
	local bool			bFound, bActive;

	if (Level.NetMode != NM_StandAlone)
	{
		return;
	}
	gProfile = class'GameProfile'.Static.LoadCurrentGameProfile( Level );
	if (gProfile != None)
	{
		if (CachedGameProfile == None)
		{
			CacheGameProfile( gProfile );
		}
		nIdx = 0;
		if ((Level.GetLevelFileName() != CachedGameProfile.SaveMissionName) || (Level.DifficultyLevel != CachedGameProfile.SaveMissionDifficulty))
		{
			CachedGameProfile.ClearPawnSaveList();
		}
		CachedGameProfile.ClearInventorySaveLists();
		foreach DynamicActors( class'Pawn', aPawn )
		{
			if (aPawn.IsA('gbxPawn'))
			{
				if (aPawn.Controller.IsA('PlayerController'))
				{
					CachedGameProfile.AddSavedPlayer( aPawn.Health );
					aWeapon = aPawn.Inventory;
					while (aWeapon != None)
					{
						if (aWeapon.IsA('Weapon'))
						{
							if (aWeapon == aPawn.Weapon)
								bActive = true;
							else
								bActive = false;
							CachedGameProfile.AddSavedWeapon( Weapon(aWeapon).Class, Weapon(aWeapon).Ammo[0].AmmoAmount, Weapon(aWeapon).ClipAmt, bActive );
						}
						else if (aWeapon.IsA('Powerups'))
						{
							CachedGameProfile.AddSavedInventory( aWeapon.Class, Powerups(aWeapon).NumCopies );
						}
						aWeapon = aWeapon.Inventory;
					}
					for (nIdx2 = 0; nIdx2 < 4; nIdx2++)
					{
						aWeapon = aPawn.SecondaryInventory[nIdx2];
						while (aWeapon != None)
						{
							if (aWeapon.IsA('Powerups'))
							{
								CachedGameProfile.AddSavedSecondaryInventory( aWeapon.Class, Powerups(aWeapon).NumCopies );
							}
							else
							{
								CachedGameProfile.AddSavedSecondaryInventory( aWeapon.Class, 1 );
							}
							aWeapon = aWeapon.Inventory;
						}
					}
				}
				else
				{
					if (aPawn.PawnTeam == TEAM_US)
					{
						CachedGameProfile.AddSavedPawn( aPawn.Tag, aPawn.Health, aPawn.default.Health, true );
					}
					else
					{
						CachedGameProfile.AddSavedPawn( aPawn.Tag, aPawn.Health, aPawn.default.Health, false );
					}
				}
				nIdx++;
			}
		}

		for (nIdx = 0; nIdx < CachedValues.Length; nIdx++)
		{
			bFound = false;
			for (nIdx2 = 0; nIdx2 < CachedGameProfile.SavedValues.Length; nIdx2++)
			{
				if (CachedValues[nIdx].ValueName == CachedGameProfile.SavedValues[nIdx2].ValueName)
				{
					CachedGameProfile.SavedValues[nIdx2].nValue = CachedValues[nIdx].nValue;
					bFound = true;
					break;
				}
			}
			if (!bFound)
			{
				CachedGameProfile.SavedValues.Length = CachedGameProfile.SavedValues.Length + 1;
				CachedGameProfile.SavedValues[CachedGameProfile.SavedValues.Length - 1].ValueName = CachedValues[nIdx].ValueName;
				CachedGameProfile.SavedValues[CachedGameProfile.SavedValues.Length - 1].nValue = CachedValues[nIdx].nValue;
			}
		}
		
		CachedGameProfile.SaveMissionName = Level.GetLevelFileName();
		CachedGameProfile.SaveMissionDifficulty = Level.DifficultyLevel;
		CachedGameProfile.SaveMissionCheckpoint = nCheckpointID;
		if (bSquadmateHasDied)
		{
			CachedGameProfile.SquadmateHasDied = true;
		}
		CachedGameProfile.ClearCheckpointReload();
		
		UncacheGameProfile( gProfile );
		class'GameProfile'.Static.UnloadProfile( Level, gProfile, true );
	}
}

function SaveCheckpointIDCustom( int nCheckpointID, string szCustomMapName )
{
	local GameProfile	gProfile;
	local Pawn			aPawn;
	local int			nIdx, nIdx2;
	local Inventory		aWeapon;
	local bool			bFound, bActive;

	if (Level.NetMode != NM_StandAlone)
	{
		return;
	}
	gProfile = class'GameProfile'.Static.LoadCurrentGameProfile( Level );
	if (gProfile != None)
	{
		if (CachedGameProfile == None)
		{
			CacheGameProfile( gProfile );
		}
		nIdx = 0;
		if ((Level.GetLevelFileName() != CachedGameProfile.SaveMissionName) || (Level.DifficultyLevel != CachedGameProfile.SaveMissionDifficulty))
		{
			CachedGameProfile.ClearPawnSaveList();
		}
		CachedGameProfile.ClearInventorySaveLists();
		foreach DynamicActors( class'Pawn', aPawn )
		{
			if (aPawn.IsA('gbxPawn'))
			{
				if (aPawn.Controller.IsA('PlayerController'))
				{
					CachedGameProfile.AddSavedPlayer( aPawn.Health );
					aWeapon = aPawn.Inventory;
					while (aWeapon != None)
					{
						if (aWeapon.IsA('Weapon'))
						{
							if (aWeapon == aPawn.Weapon)
								bActive = true;
							else
								bActive = false;
							// GBX:PAD: Saving a turret weapon is not so good, so filter these out.
							if (!(aWeapon.IsA('TurretWeapon')))
							{
								CachedGameProfile.AddSavedWeapon( Weapon(aWeapon).Class, Weapon(aWeapon).Ammo[0].AmmoAmount, Weapon(aWeapon).ClipAmt, bActive );
							}
						}
						else if (aWeapon.IsA('Powerups'))
						{
							CachedGameProfile.AddSavedInventory( aWeapon.Class, Powerups(aWeapon).NumCopies );
						}
						aWeapon = aWeapon.Inventory;
					}
					for (nIdx2 = 0; nIdx2 < 4; nIdx2++)
					{
						aWeapon = aPawn.SecondaryInventory[nIdx2];
						while (aWeapon != None)
						{
							if (aWeapon.IsA('Powerups'))
							{
								CachedGameProfile.AddSavedSecondaryInventory( aWeapon.Class, Powerups(aWeapon).NumCopies );
							}
							else
							{
								CachedGameProfile.AddSavedSecondaryInventory( aWeapon.Class, 1 );
							}
							aWeapon = aWeapon.Inventory;
						}
					}
				}
				else
				{
					if (aPawn.PawnTeam == TEAM_US)
					{
						CachedGameProfile.AddSavedPawn( aPawn.Tag, aPawn.Health, aPawn.default.Health, true );
					}
					else
					{
						CachedGameProfile.AddSavedPawn( aPawn.Tag, aPawn.Health, aPawn.default.Health, false );
					}
				}
				nIdx++;
			}
		}

		for (nIdx = 0; nIdx < CachedValues.Length; nIdx++)
		{
			bFound = false;
			for (nIdx2 = 0; nIdx2 < CachedGameProfile.SavedValues.Length; nIdx2++)
			{
				if (CachedValues[nIdx].ValueName == CachedGameProfile.SavedValues[nIdx2].ValueName)
				{
					CachedGameProfile.SavedValues[nIdx2].nValue = CachedValues[nIdx].nValue;
					bFound = true;
					break;
				}
			}
			if (!bFound)
			{
				CachedGameProfile.SavedValues.Length = CachedGameProfile.SavedValues.Length + 1;
				CachedGameProfile.SavedValues[CachedGameProfile.SavedValues.Length - 1].ValueName = CachedValues[nIdx].ValueName;
				CachedGameProfile.SavedValues[CachedGameProfile.SavedValues.Length - 1].nValue = CachedValues[nIdx].nValue;
			}
		}
		
		CachedGameProfile.SaveMissionName = szCustomMapName;
		CachedGameProfile.SaveMissionDifficulty = Level.DifficultyLevel;
		CachedGameProfile.SaveMissionCheckpoint = nCheckpointID;
		if (bSquadmateHasDied)
		{
			CachedGameProfile.SquadmateHasDied = true;
		}
		CachedGameProfile.ClearCheckpointReload();
		
		UncacheGameProfile( gProfile );
		class'GameProfile'.Static.UnloadProfile( Level, gProfile, true );
	}
}

function SkirmishSaveCheckpointID( int nCheckpointID )
{
	local GameProfile	gProfile;
	local Pawn			aPawn, aLeaderPawn;
	local int			nIdx, nIdx2;
	local Inventory		aWeapon;
	local bool			bFound, bActive;

	if (!(Level.Game.IsA('WargameSkirmish')))
	{
		return;
	}
	gProfile = class'GameProfile'.Static.LoadCurrentGameProfile( Level );
	if (gProfile != None)
	{
		if (CachedGameProfile == None)
		{
			CacheGameProfile( gProfile );
		}
		
		nIdx = 0;
		CachedGameProfile.SkirmishClearPlayerSaveList();
		CachedGameProfile.SkirmishClearPawnSaveList();
		CachedGameProfile.SkirmishClearInventorySaveLists();
		foreach DynamicActors( class'Pawn', aPawn )
		{
			if (aPawn.IsA('gbxPawn'))
			{
				if (aPawn.Controller.IsA('PlayerController'))
				{
					if (aPawn.Controller.PlayerReplicationInfo == None)
					{
						CachedGameProfile.SkirmishAddSavedPlayer( aPawn.Controller, aPawn.Health, 0 );
					}
					else
					{
						CachedGameProfile.SkirmishAddSavedPlayer( aPawn.Controller, aPawn.Health, aPawn.Controller.PlayerReplicationInfo.Score );
					}
					aWeapon = aPawn.Inventory;
					while (aWeapon != None)
					{
						if (aWeapon.IsA('Weapon'))
						{
							if (aWeapon == aPawn.Weapon)
								bActive = true;
							else
								bActive = false;
							// GBX:PAD: Saving a turret weapon is not so good, so filter these out.
							if (!(aWeapon.IsA('TurretWeapon')))
							{
								CachedGameProfile.SkirmishAddSavedWeapon( aPawn.Controller, Weapon(aWeapon).Class, Weapon(aWeapon).Ammo[0].AmmoAmount, Weapon(aWeapon).ClipAmt, bActive );
							}
						}
						else if (aWeapon.IsA('Powerups'))
						{
							CachedGameProfile.SkirmishAddSavedInventory( aPawn.Controller, aWeapon.Class, Powerups(aWeapon).NumCopies );
						}
						aWeapon = aWeapon.Inventory;
					}
					for (nIdx2 = 0; nIdx2 < 4; nIdx2++)
					{
						aWeapon = aPawn.SecondaryInventory[nIdx2];
						while (aWeapon != None)
						{
							if (aWeapon.IsA('Powerups'))
							{
								CachedGameProfile.SkirmishAddSavedSecondaryInventory( aPawn.Controller, aWeapon.Class, Powerups(aWeapon).NumCopies );
							}
							else
							{
								CachedGameProfile.SkirmishAddSavedSecondaryInventory( aPawn.Controller, aWeapon.Class, 1 );
							}
							aWeapon = aWeapon.Inventory;
						}
					}
				}
				else
				{
					aLeaderPawn = aPawn.GetPlayerLeader();
					if (aLeaderPawn != None)
					{
						if (Level.Game.IsPawnOnSameTeamAsPlayer( aPawn ))
						{
							CachedGameProfile.SkirmishAddSavedPawn( aLeaderPawn.Controller, aPawn.Health, aPawn.GetFireTeamType(), true );
						}
					}
				}
				nIdx++;
			}
		}

		for (nIdx = 0; nIdx < CachedValues.Length; nIdx++)
		{
			bFound = false;
			for (nIdx2 = 0; nIdx2 < CachedGameProfile.SkirmishSavedValues.Length; nIdx2++)
			{
				if (CachedValues[nIdx].ValueName == CachedGameProfile.SkirmishSavedValues[nIdx2].ValueName)
				{
					CachedGameProfile.SkirmishSavedValues[nIdx2].nValue = CachedValues[nIdx].nValue;
					bFound = true;
					break;
				}
			}
			if (!bFound)
			{
				CachedGameProfile.SkirmishSavedValues.Length = CachedGameProfile.SkirmishSavedValues.Length + 1;
				CachedGameProfile.SkirmishSavedValues[CachedGameProfile.SkirmishSavedValues.Length - 1].ValueName = CachedValues[nIdx].ValueName;
				CachedGameProfile.SkirmishSavedValues[CachedGameProfile.SkirmishSavedValues.Length - 1].nValue = CachedValues[nIdx].nValue;
			}
		}
		
		CachedGameProfile.SkirmishMissionName = Level.GetLevelFileName();
		CachedGameProfile.SkirmishMissionCheckpoint = nCheckpointID;
		CachedGameProfile.SkirmishPawnRespawn = false;
		CachedGameProfile.SkirmishClearCheckpointReload();
		
		UncacheGameProfile( gProfile );
		class'GameProfile'.Static.UnloadProfile( Level, gProfile, true );
	}
}

function bool GetCheckpointPawnHealth( name szTag, out int nHealth )
{
	local GameProfile	gProfile;
	local int			nIdx;
	local bool			bReturn;

	if (Level.NetMode != NM_StandAlone)
	{
		return false;
	}
	if (CachedGameProfile == None)
	{
		gProfile = class'GameProfile'.Static.LoadCurrentGameProfile( Level );
		if (gProfile != None)
		{
			CacheGameProfile( gProfile );
			class'GameProfile'.Static.UnloadProfile( Level, gProfile, false );
		}
	}
	if ((Level.DebugCheckpointID >= 0) || (CachedGameProfile.SaveMissionCheckpoint <= 0))
	{
		return false;
	}
	bReturn = false;
	
	if ((Level.GetLevelFileName() == CachedGameProfile.SaveMissionName) && (Level.DifficultyLevel == CachedGameProfile.SaveMissionDifficulty))
	{
		for( nIdx = 0; nIdx < CachedGameProfile.SavedPawns.Length; nIdx++ )
		{
			if (CachedGameProfile.SavedPawns[nIdx].Tag == szTag)
			{
				nHealth = CachedGameProfile.SavedPawns[nIdx].Health;
				bReturn = true;
			}
		}
	}
	return bReturn;
}

function bool SkirmishGetCheckpointPawnHealth( AnimPawn PlayerPawn, int nDesiredIdx, int nType, out int nHealth )
{
	local GameProfile	gProfile;
	local int			nIdx, nListIdx;
	local bool			bReturn;
	local int			nCharType;
	
	if (!(Level.Game.IsA('WargameSkirmish')))
	{
		return false;
	}
	if (CachedGameProfile == None)
	{
		gProfile = class'GameProfile'.Static.LoadCurrentGameProfile( Level );
		if (gProfile != None)
		{
			CacheGameProfile( gProfile );
			class'GameProfile'.Static.UnloadProfile( Level, gProfile, false );
		}
	}
	if ((Level.SkirmishDebugCheckpointID >= 0) || (CachedGameProfile.SkirmishMissionCheckpoint <= 0))
	{
		return false;
	}
	bReturn = false;
	
	if (PlayerPawn != None)
	{
		nCharType = PlayerPawn.m_nCharType;
	}

	nListIdx = 0;
	if (Level.GetLevelFileName() == CachedGameProfile.SkirmishMissionName)
	{
		for( nIdx = 0; nIdx < CachedGameProfile.SkirmishSavedPawns.Length; nIdx++ )
		{
			if (CachedGameProfile.SkirmishSavedPawns[nIdx].nType == nType)
			{
				if (nListIdx == nDesiredIdx)
				{
					nHealth = CachedGameProfile.SkirmishSavedPawns[nIdx].Health;
					bReturn = true;
					break;
				}
				else
				{
					nListIdx++;
				}
			}
		}
	}
	return bReturn;
}

function bool GetCheckpointPlayerHealth( out int nHealth )
{
	local GameProfile	gProfile;
	local bool			bReturn;

	bReturn = false;
	if (Level.NetMode != NM_StandAlone)
	{
		return false;
	}
	if (CachedGameProfile == None)
	{
		gProfile = class'GameProfile'.Static.LoadCurrentGameProfile( Level );
		if (gProfile != None)
		{
			CacheGameProfile( gProfile );
			class'GameProfile'.Static.UnloadProfile( Level, gProfile, false );
		}
	}
	if ((Level.DebugCheckpointID >= 0) || (CachedGameProfile.SaveMissionCheckpoint <= 0))
	{
		return false;
	}
	bReturn = false;
	
	if ((Level.GetLevelFileName() == CachedGameProfile.SaveMissionName) && (Level.DifficultyLevel == CachedGameProfile.SaveMissionDifficulty))
	{
		nHealth = CachedGameProfile.PlayerHealth;
		bReturn = true;
	}
	return bReturn;
}

function bool DidSquadmateDie()
{
	local GameProfile	gProfile;

	if (bSquadmateHasDied)
	{
		return true;
	}
	if (Level.NetMode != NM_StandAlone)
	{
		return false;
	}
	if (CachedGameProfile == None)
	{
		gProfile = class'GameProfile'.Static.LoadCurrentGameProfile( Level );
		if (gProfile != None)
		{
			CacheGameProfile( gProfile );
			class'GameProfile'.Static.UnloadProfile( Level, gProfile, false );
		}
	}
	
	if ((Level.DebugCheckpointID >= 0) || (CachedGameProfile.SaveMissionCheckpoint <= 0))
	{
		return false;
	}
	
	if ((Level.GetLevelFileName() == CachedGameProfile.SaveMissionName) && (Level.DifficultyLevel == CachedGameProfile.SaveMissionDifficulty))
	{
		return CachedGameProfile.SquadmateHasDied;
	}
	return false;
}

function bool SkirmishGetCheckpointPlayerHealth( AnimPawn PlayerPawn, out int nHealth, out int nScore )
{
	local GameProfile	gProfile;
	local bool			bReturn;
	local int			nCharType, nIdx;
	
	bReturn = false;
	if (!(Level.Game.IsA('WargameSkirmish')))
	{
		return false;
	}

	if (CachedGameProfile == None)
	{
		gProfile = class'GameProfile'.Static.LoadCurrentGameProfile( Level );
		if (gProfile != None)
		{
			CacheGameProfile( gProfile );
			class'GameProfile'.Static.UnloadProfile( Level, gProfile, false );
		}
	}
	if ((Level.SkirmishDebugCheckpointID >= 0) || (CachedGameProfile.SkirmishMissionCheckpoint <= 0))
	{
		return false;
	}
	bReturn = false;
	
	if (PlayerPawn != None)
	{
		nCharType = PlayerPawn.m_nCharType;
	}
	
	if (Level.GetLevelFileName() == CachedGameProfile.SkirmishMissionName)
	{
		for( nIdx = 0; nIdx < CachedGameProfile.SkirmishPlayerHealth.Length; nIdx++ )
		{
			if (CachedGameProfile.SkirmishPlayerHealth[nIdx].nCharOwner == nCharType)
			{
				nHealth = CachedGameProfile.SkirmishPlayerHealth[nIdx].Health;
				nScore = CachedGameProfile.SkirmishPlayerHealth[nIdx].Score;
				bReturn = true;
				break;
			}
		}
		if (!bReturn)
		{
			nHealth = 100;
			nScore = 0;
			bReturn = true;
		}
	}
	return bReturn;
}

function bool EquipCheckpointPlayerInventory( Pawn aPlayerPawn )
{
	local GameProfile	gProfile;
	local Inventory		aWeapon, aSelectedWeapon;
	local bool			bReturn;
	local int			nIdx, nIdx2, nIdxEquipped, nQuantity;

	if (Level.NetMode != NM_StandAlone)
	{
		return false;
	}
	if (CachedGameProfile == None)
	{
		gProfile = class'GameProfile'.Static.LoadCurrentGameProfile( Level );
		if (gProfile != None)
		{
			CacheGameProfile( gProfile );
			class'GameProfile'.Static.UnloadProfile( Level, gProfile, false );
		}
	}
	if ((Level.DebugCheckpointID >= 0) || (CachedGameProfile.SaveMissionCheckpoint <= 0))
	{
		return false;
	}
	bReturn = false;

	nIdx = -1;
	nIdxEquipped = -1;
	if ((Level.GetLevelFileName() == CachedGameProfile.SaveMissionName) && (Level.DifficultyLevel == CachedGameProfile.SaveMissionDifficulty))
	{
		for (nIdx = 0; nIdx < CachedGameProfile.SavedWeapons.Length; nIdx++)
		{
		    aWeapon = Weapon(aPlayerPawn.FindInventoryType(CachedGameProfile.SavedWeapons[nIdx].WeaponClass));
		    if (aWeapon == None)
		    {
				aWeapon = Spawn(CachedGameProfile.SavedWeapons[nIdx].WeaponClass);
				if ( aWeapon != None )
				{
					if (aWeapon.GiveTo(aPlayerPawn))
					{
						aWeapon.PickupFunction(aPlayerPawn);
					}
				}
			}
			if ( aWeapon != None )
			{
				Weapon(aWeapon).Ammo[0].AmmoAmount = CachedGameProfile.SavedWeapons[nIdx].TotalAmmo;
				Weapon(aWeapon).ClipAmt = CachedGameProfile.SavedWeapons[nIdx].ClipAmmo;
				aWeapon.Instigator = aPlayerPawn;
				if ((CachedGameProfile.SavedWeapons[nIdx].TotalAmmo > 0) || (CachedGameProfile.SavedWeapons[nIdx].ClipAmmo > 0))
				{
					if ((CachedGameProfile.SavedWeapons[nIdx].bActive) || (nIdxEquipped == -1))
					{
						nIdxEquipped = nIdx;
						aSelectedWeapon = aWeapon;
					}
				}
			}
		}
		
		if (nIdxEquipped >= 0)
		{
			if (aPlayerPawn.Weapon.Class != CachedGameProfile.SavedWeapons[nIdxEquipped].WeaponClass)
			{
				aPlayerPawn.Weapon.ClientState = WS_ReadyToFire;

				aPlayerPawn.PendingWeapon = Weapon(aSelectedWeapon);
				aPlayerPawn.ChangedWeapon();
			}
		}
		
		for (nIdx = 0; nIdx < CachedGameProfile.SavedInventory.Length; nIdx++)
		{
			nQuantity = CachedGameProfile.SavedInventory[nIdx].Quantity;
			
			for (nIdx2 = 0; nIdx2 < nQuantity; nIdx2++)
			{
				aWeapon = Spawn(CachedGameProfile.SavedInventory[nIdx].InventoryClass);
				if ( aWeapon != None )
				{
					if (aWeapon.GiveTo(aPlayerPawn))
					{
						aWeapon.PickupFunction(aPlayerPawn);
					}
					aWeapon.Instigator = aPlayerPawn;
				}
			}
		}
		
		for (nIdx = 0; nIdx < CachedGameProfile.SavedSecondaryInventory.Length; nIdx++)
		{
			nQuantity = CachedGameProfile.SavedSecondaryInventory[nIdx].Quantity;
			
			for (nIdx2 = 0; nIdx2 < nQuantity; nIdx2++)
			{
				aWeapon = Spawn(CachedGameProfile.SavedSecondaryInventory[nIdx].InventoryClass);
				if ( aWeapon != None )
				{
					if (aWeapon.GiveTo(aPlayerPawn))
					{
						aWeapon.PickupFunction(aPlayerPawn);
					}
					aWeapon.Instigator = aPlayerPawn;
				}
			}
		}
		
		bReturn = true;
	}
	return bReturn;
}

function bool SkirmishEquipCheckpointPlayerInventory( Pawn aPawn )
{
	local GameProfile	gProfile;
	local AnimPawn		aPlayerPawn;
	local Inventory		aWeapon, aSelectedWeapon;
	local bool			bReturn;
	local int			nIdx, nIdx2, nIdxEquipped, nQuantity;
	local int			nCharType;
	
	if (Level.NetMode == NM_Client)
	{
		return false;
	}
	if (!(Level.Game.IsA('WargameSkirmish')))
	{
		return false;
	}
	if (CachedGameProfile == None)
	{
		gProfile = class'GameProfile'.Static.LoadCurrentGameProfile( Level );
		if (gProfile != None)
		{
			CacheGameProfile( gProfile );
			class'GameProfile'.Static.UnloadProfile( Level, gProfile, false );
		}
	}
	if ((Level.SkirmishDebugCheckpointID >= 0) || (CachedGameProfile.SkirmishMissionCheckpoint <= 0))
	{
		return false;
	}
	bReturn = false;

	aPlayerPawn = AnimPawn( aPawn );
	if (aPlayerPawn == None)
	{
		return false;
	}
	
	nCharType = aPlayerPawn.m_nCharType;
	
	nIdx = -1;
	nIdxEquipped = -1;
	if (Level.GetLevelFileName() == CachedGameProfile.SkirmishMissionName)
	{
		for (nIdx = 0; nIdx < CachedGameProfile.SkirmishSavedWeapons.Length; nIdx++)
		{
			if (CachedGameProfile.SkirmishSavedWeapons[nIdx].nCharOwner == nCharType)
			{
				aWeapon = Weapon(aPlayerPawn.FindInventoryType(CachedGameProfile.SkirmishSavedWeapons[nIdx].WeaponClass));
				if (aWeapon == None)
				{
					aWeapon = Spawn(CachedGameProfile.SkirmishSavedWeapons[nIdx].WeaponClass, aPlayerPawn);
					if ( aWeapon != None )
					{
						if (aWeapon.GiveTo(aPlayerPawn))
						{
							aWeapon.PickupFunction(aPlayerPawn);
						}
					}
				}
				if ( aWeapon != None )
				{
					Weapon(aWeapon).Ammo[0].AmmoAmount = CachedGameProfile.SkirmishSavedWeapons[nIdx].TotalAmmo;
					Weapon(aWeapon).ClipAmt = CachedGameProfile.SkirmishSavedWeapons[nIdx].ClipAmmo;
//					aWeapon.Instigator = aPlayerPawn;
					if ((CachedGameProfile.SkirmishSavedWeapons[nIdx].TotalAmmo > 0) || (CachedGameProfile.SkirmishSavedWeapons[nIdx].ClipAmmo > 0))
					{
						if ((CachedGameProfile.SkirmishSavedWeapons[nIdx].bActive) || (nIdxEquipped == -1))
						{
							nIdxEquipped = nIdx;
							aSelectedWeapon = aWeapon;
						}
					}
				}
				bReturn = true;
			}
		}
/*
		if (nIdxEquipped >= 0)
		{
			if (aPlayerPawn.Weapon.Class != CachedGameProfile.SkirmishSavedWeapons[nIdxEquipped].WeaponClass)
			{
				aPlayerPawn.Weapon.ClientState = WS_ReadyToFire;

				aPlayerPawn.PendingWeapon = Weapon(aSelectedWeapon);
				aPlayerPawn.ChangedWeapon();
			}
		}
*/
		for (nIdx = 0; nIdx < CachedGameProfile.SkirmishSavedInventory.Length; nIdx++)
		{
			if (CachedGameProfile.SkirmishSavedSecondaryInventory[nIdx].nCharOwner == nCharType)
			{
				nQuantity = CachedGameProfile.SkirmishSavedInventory[nIdx].Quantity;
				
				for (nIdx2 = 0; nIdx2 < nQuantity; nIdx2++)
				{
					aWeapon = Spawn(CachedGameProfile.SkirmishSavedInventory[nIdx].InventoryClass, aPlayerPawn);
					if ( aWeapon != None )
					{
						if (aWeapon.GiveTo(aPlayerPawn))
						{
							aWeapon.PickupFunction(aPlayerPawn);
						}
//						aWeapon.Instigator = aPlayerPawn;
					}
				}
				bReturn = true;
			}
		}
		
		for (nIdx = 0; nIdx < CachedGameProfile.SkirmishSavedSecondaryInventory.Length; nIdx++)
		{
			if (CachedGameProfile.SkirmishSavedSecondaryInventory[nIdx].nCharOwner == nCharType)
			{
				nQuantity = CachedGameProfile.SkirmishSavedSecondaryInventory[nIdx].Quantity;
				
				for (nIdx2 = 0; nIdx2 < nQuantity; nIdx2++)
				{
					aWeapon = Spawn(CachedGameProfile.SkirmishSavedSecondaryInventory[nIdx].InventoryClass, aPlayerPawn);
					if ( aWeapon != None )
					{
						if (aWeapon.GiveTo(aPlayerPawn))
						{
							aWeapon.PickupFunction(aPlayerPawn);
						}
//						aWeapon.Instigator = aPlayerPawn;
					}
				}
				bReturn = true;
			}
		}
	}
	return bReturn;
}

function ClearCachedValues()
{
	local GameProfile	gProfile;
	
	if (Level.NetMode != NM_StandAlone)
	{
		return;
	}
	if (CachedGameProfile == None)
	{
		gProfile = class'GameProfile'.Static.LoadCurrentGameProfile( Level );
		if (gProfile != None)
		{
			CacheGameProfile( gProfile );
			class'GameProfile'.Static.UnloadProfile( Level, gProfile, false );
		}
	}
	CachedGameProfile.SavedValues.Remove( 0, CachedGameProfile.SavedValues.Length );
	CachedValues.Remove( 0, CachedValues.Length );
}

function SkirmishClearCachedValues()
{
	local GameProfile	gProfile;
	
	if (!(Level.Game.IsA('WargameSkirmish')))
	{
		return;
	}
	if (CachedGameProfile == None)
	{
		gProfile = class'GameProfile'.Static.LoadCurrentGameProfile( Level );
		if (gProfile != None)
		{
			CacheGameProfile( gProfile );
			class'GameProfile'.Static.UnloadProfile( Level, gProfile, false );
		}
	}
	CachedGameProfile.SkirmishSavedValues.Remove( 0, CachedGameProfile.SkirmishSavedValues.Length );
	CachedValues.Remove( 0, CachedValues.Length );
}

function AddCachedValue( name szValueName, int nValue )
{
//	local GameProfile	gProfile;
	local int	nIdx;
	
	if (!(Level.Game.CanUseCheckpoints(-1)))
	{
		return;
	}
//	if (CachedGameProfile == None)
//	{
//		gProfile = class'GameProfile'.Static.LoadCurrentGameProfile( Level );
//		if (gProfile != None)
//		{
//			CacheGameProfile( gProfile );
//			class'GameProfile'.Static.UnloadProfile( Level, gProfile, false );
//		}
//	}
	for (nIdx = 0; nIdx < CachedValues.Length; nIdx++)
	{
		if (CachedValues[nIdx].ValueName == szValueName)
		{
			CachedValues[nIdx].nValue = nValue;
			return;
		}
	}
	
	CachedValues.Length = CachedValues.Length + 1;
	CachedValues[CachedValues.Length - 1].ValueName = szValueName;
	CachedValues[CachedValues.Length - 1].nValue = nValue;
}

function LoadSavedValues()
{
	local GameProfile	gProfile;
	
	if (CachedGameProfile == None)
	{
		gProfile = class'GameProfile'.Static.LoadCurrentGameProfile( Level );
		if (gProfile != None)
		{
			CacheGameProfile( gProfile );
			class'GameProfile'.Static.UnloadProfile( Level, gProfile, false );
		}
	}
}

function bool GetCachedValue( name szValueName, out int nValue )
{
	local GameProfile	gProfile;
	local int	nIdx;
	
	if (Level.NetMode != NM_StandAlone)
	{
		return false;
	}
	if (CachedGameProfile == None)
	{
		gProfile = class'GameProfile'.Static.LoadCurrentGameProfile( Level );
		if (gProfile != None)
		{
			CacheGameProfile( gProfile );
			class'GameProfile'.Static.UnloadProfile( Level, gProfile, false );
		}
	}
	if ((Level.DebugCheckpointID >= 0) || (CachedGameProfile.SaveMissionCheckpoint <= 0))
	{
		return false;
	}
	for (nIdx = 0; nIdx < CachedGameProfile.SavedValues.Length; nIdx++)
	{
		if (CachedGameProfile.SavedValues[nIdx].ValueName == szValueName)
		{
			nValue = CachedGameProfile.SavedValues[nIdx].nValue;
			return true;
		}
	}
	return false;
}

function bool SkirmishGetCachedValue( name szValueName, out int nValue )
{
	local GameProfile	gProfile;
	local int	nIdx;
	
	if (!(Level.Game.IsA('WargameSkirmish')))
	{
		return false;
	}
	if (CachedGameProfile == None)
	{
		gProfile = class'GameProfile'.Static.LoadCurrentGameProfile( Level );
		if (gProfile != None)
		{
			CacheGameProfile( gProfile );
			class'GameProfile'.Static.UnloadProfile( Level, gProfile, false );
		}
	}
	if ((Level.SkirmishDebugCheckpointID >= 0) || (CachedGameProfile.SkirmishMissionCheckpoint <= 0))
	{
		return false;
	}
	for (nIdx = 0; nIdx < CachedGameProfile.SkirmishSavedValues.Length; nIdx++)
	{
		if (CachedGameProfile.SkirmishSavedValues[nIdx].ValueName == szValueName)
		{
			nValue = CachedGameProfile.SkirmishSavedValues[nIdx].nValue;
			return true;
		}
	}
	return false;
}

function bool ShouldHelpWithCheckpoint()
{
	local GameProfile	gProfile;
	
	if ((Level.NetMode != NM_StandAlone) || (Level.DifficultyLevel == DIFF_Authentic))
	{
		return false;
	}
	if (CachedGameProfile == None)
	{
		gProfile = class'GameProfile'.Static.LoadCurrentGameProfile( Level );
		if (gProfile != None)
		{
			CacheGameProfile( gProfile );
			class'GameProfile'.Static.UnloadProfile( Level, gProfile, false );
		}
	}
	return CachedGameProfile.ShouldHelpWithCheckpoint( Level );
}

function bool SkirmishShouldHelpWithCheckpoint()
{
	local GameProfile	gProfile;
	
	if (!(Level.Game.IsA('WargameSkirmish')))
	{
		return false;
	}
	if (CachedGameProfile == None)
	{
		gProfile = class'GameProfile'.Static.LoadCurrentGameProfile( Level );
		if (gProfile != None)
		{
			CacheGameProfile( gProfile );
			class'GameProfile'.Static.UnloadProfile( Level, gProfile, false );
		}
	}
	return CachedGameProfile.SkirmishShouldHelpWithCheckpoint( Level );
}

function HelpWithCheckpoint()
{
	local GameProfile	gProfile;
	
	if (Level.NetMode != NM_StandAlone)
	{
		return;
	}
	if (CachedGameProfile == None)
	{
		gProfile = class'GameProfile'.Static.LoadCurrentGameProfile( Level );
		if (gProfile != None)
		{
			CacheGameProfile( gProfile );
			class'GameProfile'.Static.UnloadProfile( Level, gProfile, false );
		}
	}
	CachedGameProfile.HelpWithCheckpoint( Level );
}

function SkirmishHelpWithCheckpoint()
{
	local GameProfile	gProfile;
	
	if (!(Level.Game.IsA('WargameSkirmish')))
	{
		return;
	}
	if (CachedGameProfile == None)
	{
		gProfile = class'GameProfile'.Static.LoadCurrentGameProfile( Level );
		if (gProfile != None)
		{
			CacheGameProfile( gProfile );
			class'GameProfile'.Static.UnloadProfile( Level, gProfile, false );
		}
	}
	CachedGameProfile.SkirmishHelpWithCheckpoint( Level );
}

function IncrementCheckpointReload()
{
	local GameProfile	gProfile;
	
	if (Level.NetMode != NM_StandAlone)
	{
		return;
	}
	if (CachedGameProfile == None)
	{
		gProfile = class'GameProfile'.Static.LoadCurrentGameProfile( Level );
		if (gProfile != None)
		{
			CacheGameProfile( gProfile );
			class'GameProfile'.Static.UnloadProfile( Level, gProfile, false );
		}
	}
	CachedGameProfile.IncrementCheckpointReload();
}

function SkirmishIncrementCheckpointReload()
{
	local GameProfile	gProfile;
	
	if (!(Level.Game.IsA('WargameSkirmish')))
	{
		return;
	}
	if (CachedGameProfile == None)
	{
		gProfile = class'GameProfile'.Static.LoadCurrentGameProfile( Level );
		if (gProfile != None)
		{
			CacheGameProfile( gProfile );
			class'GameProfile'.Static.UnloadProfile( Level, gProfile, false );
		}
	}
	CachedGameProfile.SkirmishIncrementCheckpointReload();
}

function DisableCheckpointReload()
{
	local GameProfile	gProfile;
	
	if (Level.NetMode != NM_StandAlone)
	{
		return;
	}
	if (CachedGameProfile == None)
	{
		gProfile = class'GameProfile'.Static.LoadCurrentGameProfile( Level );
		if (gProfile != None)
		{
			CacheGameProfile( gProfile );
			class'GameProfile'.Static.UnloadProfile( Level, gProfile, false );
		}
	}
	CachedGameProfile.DisableCheckpointReload();
}

function SkirmishDisableCheckpointReload()
{
	local GameProfile	gProfile;
	
	if (!(Level.Game.IsA('WargameSkirmish')))
	{
		return;
	}
	if (CachedGameProfile == None)
	{
		gProfile = class'GameProfile'.Static.LoadCurrentGameProfile( Level );
		if (gProfile != None)
		{
			CacheGameProfile( gProfile );
			class'GameProfile'.Static.UnloadProfile( Level, gProfile, false );
		}
	}
	CachedGameProfile.SkirmishDisableCheckpointReload();
}

function ClearCheckpointReload()
{
	local GameProfile	gProfile;
	
	if (Level.NetMode != NM_StandAlone)
	{
		return;
	}
	if (CachedGameProfile == None)
	{
		gProfile = class'GameProfile'.Static.LoadCurrentGameProfile( Level );
		if (gProfile != None)
		{
			CacheGameProfile( gProfile );
			class'GameProfile'.Static.UnloadProfile( Level, gProfile, false );
		}
	}
	CachedGameProfile.ClearCheckpointReload();
}

function SkirmishClearCheckpointReload()
{
	local GameProfile	gProfile;
	
	if (!(Level.Game.IsA('WargameSkirmish')))
	{
		return;
	}
	if (CachedGameProfile == None)
	{
		gProfile = class'GameProfile'.Static.LoadCurrentGameProfile( Level );
		if (gProfile != None)
		{
			CacheGameProfile( gProfile );
			class'GameProfile'.Static.UnloadProfile( Level, gProfile, false );
		}
	}
	CachedGameProfile.SkirmishClearCheckpointReload();
}

function SkirmishSaveMapStats( int nMaxWaves, float flBestTime )
{
	local GameProfile	gProfile;
	
	if (!(Level.Game.IsA('WargameSkirmish')))
	{
		return;
	}
	if (CachedGameProfile == None)
	{
		gProfile = class'GameProfile'.Static.LoadCurrentGameProfile( Level );
		if (gProfile != None)
		{
			CacheGameProfile( gProfile );
			class'GameProfile'.Static.UnloadProfile( Level, gProfile, false );
		}
	}
	CachedGameProfile.SkirmishSaveMapStats( Level, nMaxWaves, flBestTime );
}

function bool SkirmishGetMapStats( out int nMaxWaves, out float flBestTime )
{
	local GameProfile	gProfile;
	
	if (!(Level.Game.IsA('WargameSkirmish')))
	{
		return false;
	}
	if (CachedGameProfile == None)
	{
		gProfile = class'GameProfile'.Static.LoadCurrentGameProfile( Level );
		if (gProfile != None)
		{
			CacheGameProfile( gProfile );
			class'GameProfile'.Static.UnloadProfile( Level, gProfile, false );
		}
	}
	return CachedGameProfile.SkirmishGetMapStats( Level, nMaxWaves, flBestTime );
}

function bool SkirmishPawnRespawn()
{
	local GameProfile	gProfile;
	
	if (!(Level.Game.IsA('WargameSkirmish')))
	{
		return true;
	}
	if (CachedGameProfile == None)
	{
		gProfile = class'GameProfile'.Static.LoadCurrentGameProfile( Level );
		if (gProfile != None)
		{
			CacheGameProfile( gProfile );
			class'GameProfile'.Static.UnloadProfile( Level, gProfile, false );
		}
	}
	return CachedGameProfile.SkirmishPawnRespawn;
}

// =======================================================================================================================================================
// Mission list functionality
// =======================================================================================================================================================
function int FindCurrentMission()
{
    return FindMission( Level.GetLevelFileName() );
}

function int FindMission(string MapName)
{
	local int i;
	
	for (i=0; i<Missions.Length; i++)
	{
		if (MapName ~= Missions[i].Map)
			return i;
	}

	log("WARNING: gbxMissionMan unknown map " $MapName);

	return -1;
}

function bool MissionExists(int nMissionIdx)
{
	return (nMissionIdx >= 0) && (nMissionIdx < Missions.Length);
}

function bool MissionEnabled(int nMissionIdx)
{
	return GetMissionStyle(nMissionIdx) != ECIS_Disabled;
}

function string GetMissionName( int nMissionIdx )
{
	if (MissionExists(nMissionIdx))
	{
		return Missions[nMissionIdx].Map;
	}

	return "";
}

static function EChapterIconStyle sGetMissionStyle( int nMissionIdx )
{
	if ((nMissionIdx >= 0) && (nMissionIdx < default.Missions.Length))
	{
		return default.Missions[nMissionIdx].Style;
	}

	return ECIS_Disabled;
}

function EChapterIconStyle GetMissionStyle( int nMissionIdx )
{
	if (MissionExists(nMissionIdx))
	{
		return Missions[nMissionIdx].Style;
	}

	return ECIS_Disabled;
}

function string GetNextMission()
{
	return GetContinueMission( FindCurrentMission() );
}

function string GetContinueMission(int current, optional bool bWrap)
{
	local int i;
	local string result;

	i = GetContinueMissionIndex(current, bWrap);
	if (i != -1)
		result = Missions[i].Map;

	return result;
}

function int GetContinueMissionIndex(int current, optional bool bWrap)
{
	local int i, result;

	result = -1;
	for (i=current+1; i<Missions.Length; i++)
	{
		if (MissionEnabled(i))
		{
			result = i;
			break;
		}
	}

	if ((result == -1) && bWrap)
	{
		for (i=0; i<=current; i++)
		{
			if (MissionEnabled(i))
			{
				result = i;
				break;
			}
		}
	}

	return result;
}

function string GetFirstMission(int Difficulty)
{
	return GetContinueMission(-1);
}

function string MissionCompleted(optional bool bNoClearCheckpoint)
{
	local int i;
	local GameProfile gProfile;
	local string result;
	local BaseGUIController GUIController;
	local PlayerController PC;

	
	// Added for UTS Tracking.
	PC = Level.PlayerControllerList;
	if (PC != None)
	{
		GUIController = PC.GetGUIController();
	
		if (GUIController.bIsDemoVersion)
		{
			if (PC.Level.GetLevelFileName() == "D15_1130_BOOKENDS")
				ConsoleCommand("DEMO_LEVEL_END_INTRO");
		}
	}
	
	gProfile = class'GameProfile'.Static.LoadCurrentGameProfile( Level );
	if (gProfile != None)
	{
		i = FindCurrentMission();
		if (i != -1)
		{
			result = gProfile.MissionCompleted( i, Level.DifficultyLevel );
			CacheGameProfile( gProfile );
			//gProfile.SetMissionInfoBaselines( i, Level.BestMissionTime, Level.TotalSquadMembersInMap );
			//gProfile.SetMissionTime( i, Level.TimeSeconds - Level.MissionStartTime );
			//gProfile.SetMissionSquadMembersInMap( i, Level.TotalSquadMembersInMap - Level.SquadMembersKilled );
			//gProfile.SetMissionPlayerShotsFired( i, Level.NumShotsFired );
			//gProfile.SetMissionPlayerShotsHit( i, Level.NumShotsHit );
			//gProfile.SetMissionPlayerShotsSuppression( i, Level.NumShotsSuppression );
			//gProfile.SetMissionAIShotsFired( i, Level.NumAIShotsFired );
			//gProfile.SetMissionAIShotsHit( i, Level.NumAIShotsHit );
			//gProfile.SetMissionAIShotsSuppression( i, Level.NumAIShotsSuppression );
		}

		if (!bNoClearCheckpoint)
			ClearCheckpointData( gProfile );

		class'GameProfile'.Static.UnloadProfile( Level, gProfile, true );
	}

	return result;
}

// rss: added new optional argument for mutator support
function LoadSPMap(string mapName, optional int difficulty, optional string mutNames)
{
	// get the map and maybe difficulty if we don't specify mapname...
	if (mapName == "")
	{
		mapName = GetNextMission();

		if (difficulty == EDifficulty.DIFF_Easy)
			difficulty = Level.DifficultyManager.GetDifficulty();
	}
    // rss: added support for mutators
	if ((mapName == CachedGameProfile.SaveMissionName) && (difficulty == CachedGameProfile.SaveMissionDifficulty))
		mapName = "open" @mapName $"?Difficulty=" $difficulty$"?Checkpoint=" $CachedGameProfile.SaveMissionDifficulty $mutNames;
	else
		mapName = "open" @mapName $"?Difficulty=" $difficulty $mutNames;
	
	log("=================================================");
	log("LoadSPMap (" $mapName $")");
	log("=================================================");
	ConsoleCommand(mapName);
}

function string GetLocalizedMissionString(int index, string key)
{
	local string result;

	if ((index >= 0) && (index < Missions.Length))
	{
		result = Localize("LevelInfo", key, Missions[index].Map);

		if (Left(result, 2) ~= "<?")
		{
			result = "";
			log("Unable to load mission string for index=" $index $", key=" $key, 'guilog');
		}
	}

	return result;
}

function string GetMissionTitle(int index)
{
	return GetLocalizedMissionString(index, "Title");
}
function string GetMissionDate(int index)
{
	return GetLocalizedMissionString(index, "TitleDate");
}
function string GetMissionCaption(int index)
{
	return GetLocalizedMissionString(index, "TitleCaption");
}
function string GetMissionImage(int index)
{
	return GetLocalizedMissionString(index, "TitleImage");
}

defaultproperties
{
	HartsockBornDate="July 26, 1922"
	PlayerRankName="Joe Hartsock"

	bHidden=true
}
//=============================================================================
// gbxNetworkErrors
// Central location for error definition.
//=============================================================================
class gbxNetworkErrors extends Object;

var public string ErrorCodeServerFull;
var public string ErrorCodeServerFullForYou;
var public string ErrorCodeServerDown;
var public string ErrorCodeMD5Failed;
var public string ErrorCodeAuthFailed;
var public string ErrorCodeServerOutdated;
var public string ErrorCodeUpgradeClient;
var public string ErrorCodeKicked;

var private localized String ErrorMessageAuthFailed;
var private localized String ErrorMessageServerFull;
var private localized String ErrorMessageServerFullForYou;
var private localized String ErrorMessageMD5Failed;
var private localized String ErrorMessageServerOutdated;
var private localized String ErrorMessageUpgradeClient;
var private localized String ErrorMessageUnknownError;

var private localized String ErrorMessageServerDown;
var private localized string ErrorMessageKicked;

static function string GetErrorMessageForErrorCode(string errorCode)
{
	local string errorMessage;
	
	//Translate the error code into a localized error message.
	if (errorCode == default.ErrorCodeServerFull)
	{
		errorMessage = default.ErrorMessageServerFull;
	}
	else if (errorCode == default.ErrorCodeServerFullForYou)
	{
		errorMessage = default.ErrorMessageServerFullForYou;
	}
	else if (errorCOde == default.ErrorCodeServerDown)
	{
		errorMessage = default.ErrorMessageServerDown;
	}
	else if (errorCOde == default.ErrorCodeAuthFailed)
	{
		errorMessage = default.ErrorMessageAuthFailed;
	}
	else if (errorCode == default.ErrorCodeMD5Failed)
	{
		errorMessage = default.ErrorMessageMD5Failed;
	}
	else if (errorCode == default.ErrorCodeServerOutdated)
	{
		errorMessage = default.ErrorMessageServerOutdated;
	}
	else if (errorCode == default.ErrorCodeUpgradeClient)
	{
		errorMessage = default.ErrorMessageUpgradeClient;
	}
	else if (errorCode == default.ErrorCodeKicked)
	{
		errorMessage = default.ErrorMessageKicked;
	}
	else
	{
		errorMessage = default.ErrorMessageUnknownError;
	}
	
	return errorMessage;
}

defaultproperties
{
	ErrorCodeAuthFailed = "AuthFailed"
	ErrorMessageAuthFailed="Failed to authenticate with master server.  Check your CD-Key."

	ErrorCodeServerFull = "ServerFull"
	ErrorMessageServerFull="The server is full."

	ErrorCodeServerFullForYou = "ServerFullForYou"
	ErrorMessageServerFullForYou="The game does not have enough openings. Press ENTER to continue."

	ErrorCodeServerDown = "ServerDown"
	ErrorMessageServerDown="This game session is no longer available. Press ENTER to continue." //from Xbox_Terminology_List.xls

	ErrorCodeMD5Failed = "MD5Failed"
	ErrorMessageMD5Failed = "Incompatible game files."

	ErrorCodeServerOutdated = "ServerOutdated"
	ErrorMessageServerOutdated = "Server's version is outdated."

	ErrorCodeUpgradeClient = "UpgradeClient"
	ErrorMessageUpgradeClient = "You need a newer version to play on this server."

	ErrorCodeKicked = "Kicked"
	ErrorMessageKicked="The game operator has kicked you out of the game session. Press ENTER to continue."

	ErrorMessageUnknownError="Unknown error."
}
class GbxPixelShader extends Object
    native
    dependson(GbxShader);


// Mirrors GbxShaderVariable
struct native GbxPixelShaderVariable
{
    var editconst Name                    Name;       // friendly name
    var editconst byte                    Register;   // which register slot
    var editconst GbxShader.EGbxShaderRegisterType Type;       // what kind of data is it (for editor primarily)
    var editconst plane                   Value;      // the value
};

var editconst string                              Filename;   // raw DX vertex shader program
var editconst array<GbxPixelShaderVariable>       Registers;  // constant registers
var editconst array<GbxShader.EGbxTextureType>    Textures;   // texture types required for the texture slots
var transient const editconst int                 PixelShader;
var           array<BYTE>                         ShaderCode_PC;  // shader script (to be bytecode . . .)
var           array<BYTE>                         ShaderCode_XBOX;// shader script (to be bytecode . . .)
class GbxShader extends Object
    native;


// Updating this enum requires updating the list in UnrealEd/UnEdSrv.cpp
enum EGbxShaderRegisterType
{
    SR_Unused,
    SR_Color,     // Like VSR_Vector4 but normalized color information (for editor conveniences)
    SR_Vector1,   // (x, 0.0, 0.0, 1.0)
    SR_Vector2,   // (x, y,   0.0, 1.0)
    SR_Vector3,   // (x, y,   z,   1.0)
    SR_Vector4,   // (x, y,   z,   w)
    SR_Matrix3x2, // First row of a 3x2 Matrix (4th col is typically 1.0 or 0.0)
    SR_Matrix3x3, // First row of a 3x3 Matrix (4th col is typically 1.0 or 0.0)
    SR_Matrix4x2, // First row of a 4x2 Matrix
    SR_Matrix4x3, // First row of a 4x3 Matrix
    SR_Matrix4x4, // First row of a 4x4 Matrix
    SR_MatrixContd, // Ancillary rows to a full matrix
    
    SR_MatrixModel,        // 4x4 matrix of (Model)
    SR_MatrixModelI,       // 4x4 matrix of Inverse(Model)
    SR_MatrixModelIT,      // 4x4 matrix of Transpose(Inverse(Model))

    SR_MatrixView,         // 4x4 matrix of (View)
    SR_MatrixViewI,        // 4x4 matrix of Inverse(View)
    SR_MatrixViewIT,       // 4x4 matrix of Transpose(Inverse(View))

    SR_MatrixModelView,    // 4x4 matrix of (Model * View)
    SR_MatrixModelViewI,   // 4x4 matrix of Inverse(ModelView)
    SR_MatrixModelViewIT,  // 4x4 matrix of Transpose(Inverse(ModelView))

    SR_MatrixProj,         // 4x4 matrix of (Proj)
    SR_MatrixViewProj,     // 4x4 matrix of (View * Projection)
    SR_MatrixModelViewProj,// 4x4 matrix of (Model * View * Projection)
    
    // Cubemap rotations
    SR_MatrixCube,         // 3x3 matrix of (Cube)
    SR_MatrixCubeI,        // 3x3 matrix of Inverse(Cube)
    SR_MatrixCubeIT,       // 3x3 matrix of Transpose(Inverse(Cube))

    // Model to Cubemap Basis
    SR_MatrixModelCube,    // 4x3 matrix of ( Transpose(Inverse(Model)) * Inverse(Cube) )
    SR_MatrixModelCubeI,   // 4x3 matrix of Inverse( Transpose(Inverse(Model)) * Inverse(Cube) )
    SR_MatrixModelCubeIT,  // 4x3 matrix of Transpose(Inverse( Transpose(Inverse(Model)) * Inverse(Cube) ))
    
    // Eye to Cubemap
    SR_MatrixEyeCube,      // 4x3 matrix of (ModelView * -1) * Inverse(Cube)
    SR_MatrixEyeCubeI,     // 4x3 matrix of Inverse((ModelView * -1) * Inverse(Cube))
    SR_MatrixEyeCubeIT,    // 4x3 matrix of Transpose(Inverse((ModelView * -1) * Inverse(Cube)))
    
    SR_EyeWorld,           // Eye position in 'world' coordinates
    SR_EyeModel,           // Eye position in 'model' coordinates
    SR_EyeCubemap,         // Eye position in 'cubemap' coordinates

    SR_TimeX,
    SR_TimeXcos,
    SR_TimeXsin,
    SR_TimeXtan,
    SR_TimeXall,           // X= time, Y=cos(time), Z=sin(time), W=tan(time), cycled over 120 seconds

    SR_Time2PI,
    SR_Time2PIcos,
    SR_Time2PIsin,
    SR_Time2PItan,
    SR_Time2PIall,

    SR_Light_Ambient_Color,
    SR_Light_Sun_Color,
    SR_Light_Sun_Vector,

    SR_Light0_Position,
    SR_Light1_Position,
    SR_Light2_Position,
    SR_Light3_Position,
    SR_Light4_Position,
    SR_Light5_Position,
    SR_Light6_Position,
    SR_Light7_Position,

    SR_Light0_Attenuation,
    SR_Light1_Attenuation,
    SR_Light2_Attenuation,
    SR_Light3_Attenuation,
    SR_Light4_Attenuation,
    SR_Light5_Attenuation,
    SR_Light6_Attenuation,
    SR_Light7_Attenuation,

    SR_Light0_Color,
    SR_Light1_Color,
    SR_Light2_Color,
    SR_Light3_Color,
    SR_Light4_Color,
    SR_Light5_Color,
    SR_Light6_Color,
    SR_Light7_Color,

    SR_Address_Register,
    SR_FirstBone,
    SR_FogRange,
    SR_XBOX_ScreenspaceScale,
    SR_XBOX_ScreenspaceOffset,
    SR_TextureFactor,
    SR_FogColor,       // xy = colorfog, zw = alphafog  (fog = dist * x + y)

    SR_DecodePosition,
    SR_DecodeTexCoord0,
    SR_DecodeTexCoord1,
    SR_DecodeTexCoord2,
    SR_DecodeTexCoord3,
    SR_DecodeTexCoord4,
    SR_DecodeTexCoord5,
    SR_DecodeTexCoord6,
    SR_DecodeTexCoord7,

    SR_MatrixTexture0,
    SR_MatrixTexture1,
    SR_MatrixTexture2,
    SR_MatrixTexture3,
    SR_MatrixTexture4,
    SR_MatrixTexture5,
    SR_MatrixTexture6,
    SR_MatrixTexture7,

    SR_Wind,
    SR_WindCycles,
    SR_BlastFactor,
    SR_BlastEpicenter0,
    SR_BlastEpicenter1,
    SR_FadeInFadeOut,

    SR_Texture0Info,   // width, height, # of mips, IsLinearFormat [XBOX!!!]
    SR_Texture1Info,   // width, height, # of mips, IsLinearFormat [XBOX!!!]
    SR_Texture2Info,   // width, height, # of mips, IsLinearFormat [XBOX!!!]
    SR_Texture3Info,   // width, height, # of mips, IsLinearFormat [XBOX!!!]
    SR_Texture4Info,   // width, height, # of mips, IsLinearFormat [XBOX!!!]
    SR_Texture5Info,   // width, height, # of mips, IsLinearFormat [XBOX!!!]
    SR_Texture6Info,   // width, height, # of mips, IsLinearFormat [XBOX!!!]
    SR_Texture7Info,   // width, height, # of mips, IsLinearFormat [XBOX!!!]

    SR_Light0123_Radius,
    SR_Light4567_Radius,
    SR_Light0123_InvRadius,
    SR_Light4567_InvRadius,

    SR_MatrixProjector,

    SR_VertexAlphaMask,    // Hack for running projectors onto US soldier helmet shader, because the mask source uses the same UV channel as another texture, and is selected by vertex alpha
    SR_CharacterHeadHands, // For lefthand/righthand/head (gore) selection on german models
    SR_CharacterRank,      // US Solider rank insignia
    SR_TransparentFactor,  // Controls lerp factor for particles so they can go transparent correctly
    SR_TransparentColor,   // Controls lerp factor for particles so they can go transparent correctly
    SR_ProjectorVector,    // Projector Normal in XYZ, and 0/1 mask in W for PRF_ProjectOnBackfaces/bProjectOnBackfaces handling
    SR_ProjectorPosition,  // Projector Position in XYZ, and 0/1 mask in W for PRF_Gradient/bGradient handling
};


enum EGbxTextureType
{
    TX_Undefined,       // Undefined/Uninitialized value
    
    TX_Texture2D,       // User defined 2d texture
    TX_TextureCube,     // User defined cube texture
    TX_TextureVolume,   // User defined volume texture
    
    TX_LightMap,        // Engine provided lightmap texture (Might be used if BSP surfaces are made to work with GbxShader)
    TX_EnvMap,          // Engine provided envmap texture (ZONER: 7/9/2004: UNUSED)
    TX_DiffuseCubeMap,  // Engine provided diffuse lighting cubemap texture (ZONER: 7/9/2004: UNUSED)
    TX_SpecularCubeMap, // Engine provided specular lighting cubemap texture (ZONER: 7/9/2004: UNUSED)

    TX_ProjectorTexture,
    TX_ProjectorAlphaMap,
};


enum EGbxZWrite      // ZWriteEnable
{
    zwrite_Undefined,
    zwrite_On,
    zwrite_Off,
};

enum EGbxColorWrite
{
	colorWrite_Undefined,
	colorWrite_Alpha,
	colorWrite_Color,
	colorWrite_All,
	colorWrite_None,
};

enum EGbxAlphaBlend     //
{
    alphablend_Undefined,
    alphablend_On,
    alphablend_Off,
};

enum EGbxDepthFunction  // Matches D3DCMPFUNC
{
    depth_Undefined,
    depth_Never,
    depth_Less,
    depth_Equal,
    depth_LessEqual,
    depth_Greater,
    depth_NotEqual,
    depth_GreaterEqual,
    depth_Always,
};

enum EGbxBlendEquation  // Matches D3DBLENDOP
{
    blendequation_Undefined,
    blendequation_Add,
    blendequation_Subtract,
    blendequation_ReverseSubtract,
    blendequation_Min,
    blendequation_Max,
};

enum EGbxBlendFunction  // Matches D3DBLEND
{
    blend_Undefined,
    blend_Zero,
    blend_One,
    blend_SrcColor,
    blend_OneMinusSrcColor,
    blend_SrcAlpha,
    blend_OneMinusSrcAlpha,
    blend_DstAlpha,
    blend_OneMinusDstAlpha,
    blend_DstColor,
    blend_OneMinusDstColor,
    blend_XBOX_CONSTANTCOLOR,
    blend_XBOX_INVCONSTANTCOLOR,
    blend_XBOX_CONSTANTALPHA,
    blend_XBOX_INVCONSTANTALPHA,
};

enum EGbxAlphaFunction  // Matches D3DCMPFUNC
{
    alpha_Undefined,
    alpha_Never,
    alpha_Less,
    alpha_Equal,
    alpha_LessEqual,
    alpha_Greater,
    alpha_NotEqual,
    alpha_GreaterEqual,
    alpha_Always,       // automagically disables alpha test if this is set
};

enum EGbxCullMode       // Matches D3DCULL
{
    cull_Undefined,
    cull_None,
    cull_CW,
    cull_CCW,
};

enum EGbxSpecularMode   // controlls XBOX specular enable which disables the secondary color interpolator for a fillrate improvement
{
    specular_Undefined,
    specular_Enabled,
    specular_Disabled,
};

enum EShaderArchetype
{
    SA_Undefined,
    SA_STM,
    SA_SKL,
    SA_TER,
    SA_PRJ,
    SA_SCR,
    SA_RTE,
    SA_DEC,
    SA_BSP,
};

struct native GbxRenderState
{
    var   byte                Wireframe;
    var() EGbxZWrite          DepthWrite;
    var() EGbxDepthFunction   DepthFunction;
    var() EGbxAlphaFunction   AlphaFunction;
    var() byte                AlphaRef;
    var() EGbxBlendEquation   BlendEquation;
    var() EGbxAlphaBlend      BlendEnable;
    var() EGbxBlendFunction   BlendSrcFunction;
    var() EGbxBlendFunction   BlendDstFunction;
    var   EGbxSpecularMode    SpecularMode;
    var   EGbxColorWrite      ColorWriteFlags;
    var() EGbxCullMode        CullMode;
};

struct native GbxShaderVariable
{
    var editconst Name                    Name;       // friendly name
    var editconst byte                    Register;   // which register slot
    var editconst GbxShader.EGbxShaderRegisterType Type;// what kind of data is it
    var editconst plane                   Value;      // the value
};

var() editconst int                    NumPasses;
var() editconst array<GbxRenderState>  RenderState;
var() editconst array<GbxVertexShader> VertexShader;
var() editconst array<GbxPixelShader>  PixelShader;
var() editconst bool                   bHidden;                     // Hidden from GbxShaderBrowser (i.e. for projector based shaders that designers don't need to see)
var() editconst bool                   bDeprecated;                 // Deprecated and hidden from GbxShaderBrowser
var() editconst bool                   bMaskedMaterial;             // Used to tell projectors if the material is masked and needs a masked projector
var() editconst bool                   bSpecialVertexAlphaMaskMaterial; // Hack for US helmet shader which shares UVs with the alphatexture which confuses projectors without some massaging
var() editconst int                    MaskedMaterialPass;          // Which pass the mask texture comes from for masked projectors
var() editconst int                    MaskedMaterialIndex;         // Which texture from the pass is the alpha mask source
var() editconst int                    MaskedMaterialTexCoordIndex; // Which texture coordinate stream is used to access the alpha mask source texture
var() editconst byte                   UVMask;                      // Bitmask of which uv channels are required for the vertex shader(s)
var() editconst EShaderArchetype       ShaderArchetype;

defaultproperties
{
    NumPasses = 1;
}
class GbxShaderMaterial extends RenderedMaterial
    native
    dontcollapsecategories
    dependson(GbxShader);


struct native GbxShaderRegister
{
    var byte            Slotmask;   // bitmask for the 1-4 vectors for partial override supoort
    var int             Slot;       // which register is overridden
    var name            Name;       // sanity/resync check for register names
    var plane           Value;      // custom value
};

struct native GbxShaderRegisterArray
{
    var array<GbxShaderRegister> R;
};

struct native GbxTextureList
{
    var array<Material> T;
};

var()         editconst GbxShader                     Shader;
var           editconst array<GbxShaderRegisterArray> VertexShaderValues;   // This array should be the same size as Shader->NumPasses in size at all times
var           editconst array<GbxShaderRegisterArray> PixelShaderValues;    // This array should be the same size as Shader->NumPasses in size at all times
var           array<GbxTextureList>                   Textures;             // This array should be the same size as Shader->NumPasses in size at all times
var()         GbxShader.GbxRenderState                CustomRenderState;    // User defined render state (used in all passes if multipass)
var()         bool bSelfAlphaSorting;                                       // Model is not world-sorted due to alpha blending, only render sorted with itself
var()         bool bAlwaysAlphaSort;                                        // Model always is placed in alpha list for sorting
var()         bool bDoNotColorFog;                                          // Sets distance fog range to 0/0 (disabled)
var()         bool bDoNotAlphaFog;                                          // Sets alpha fog range to 0/0 (disabled)
var()         bool bOverrideFogColor;                                       // material uses a fixed hardcoded fog color instead of zoneinfo's color
var()         bool bAllowDynamicAlphaBlend;                                 // Material should switch to normal alpha blend when RI is set to force it on (used for alpha fogging objects)
var()         color OverriddenFogColor;                                     // The custom hardcoded fog color to use (alpha is irrelevant here)
class GbxVertexShader extends Object
    native
    dependson(GbxShader);


// Mirrors GbxShaderVariable
struct native GbxVertexShaderVariable
{
    var editconst Name                    Name;       // friendly name
    var editconst byte                    Register;   // which register slot
    var editconst GbxShader.EGbxShaderRegisterType Type;// what kind of data is it
    var editconst plane                   Value;      // the value
};

struct native GbxVertexShaderByteCode
{
    var array<byte> ByteCode;
};

var editconst string                          Filename;           // raw DX vertex shader program
var editconst array<GbxVertexShaderVariable>  Registers;          // constant registers
var editconst array<byte>                     StreamMapping;      // stream mappings (This is really an array of EFixedVertexFunction)
var editconst int                             NumLights;          // Up to how many dynamic lights the shader supports
var transient array<int>                      VertexShaders;      // Array should be NumLights+1 in size, contains all combinations of vertex shaders for 0..N lights
var           array<GbxVertexShaderByteCode>  ShaderCode_PC;      // shader script (to be bytecode . . .)
var           array<GbxVertexShaderByteCode>  ShaderCode_XBOX;    // shader script (to be bytecode . . .)
class Gibbed extends DamageType
	abstract;



defaultproperties
{
	DeathString="%o exploded in a shower of body parts"
	MaleSuicide="%o exploded in a shower of body parts"
	FemaleSuicide="%o exploded in a shower of body parts"

    bAlwaysGibs=true
    bNoSpecificLocation=true
    bArmorStops=false
}
//=============================================================================
// HUD: Superclass of the heads-up display.
//=============================================================================
class HUD extends Actor
	native
	config(user)
	transient;

//=============================================================================
// Variables.

#exec Texture Import File=Textures\Border.tga MIPS=OFF COMPRESS=DXT1

var string HUDConfigWindowType;
var HUD nextHUD;	// list of huds which render to the canvas
var PlayerController PlayerOwner; // always the actual owner

var localized string ProgressFontName;
var Font ProgressFontFont;
var float ProgressFadeTime;
var Color MOTDColor;

var ScoreBoard Scoreboard;
var bool bHideHUD;
var bool bSpectatingHUD;
var bool	bShowScores;
var bool	bShowDebugInfo;				// if true, show properties of current ViewTarget
var bool	bHideCenterMessages;		// don't draw centered messages (screen center being used)
var bool    bBadConnectionAlert;	// display warning about bad connection
var config bool bMessageBeep;

var globalconfig float HudCanvasScale;    // Specifies amount of screen-space to use (for TV's).

var localized string LoadingMessage;
var localized string SavingMessage;
var localized string ConnectingMessage;
var localized string PausedMessage;
var localized string PrecachingMessage;

// Added by Demiurge Studios (Movie)
var const transient Movie Movie;
var int MoviePosX;
var int MoviePosY;
var float TexMovieTop;
var float TexMovieLeft;
var float TexMovieBottom;
var float TexMovieRight;
var bool TexMovieTranslucent;
var MovieTexture TextureMovie;
// End Demiurge Studios (Movie)

var pawn DebugPawn;	//NAC

var Color ConsoleColor;
var globalconfig int ConsoleMessageCount;
var globalconfig int ConsoleFontSize;
var globalconfig int MessageFontOffset;

struct native HUDLocalizedMessage
{
	var Class<LocalMessage> Message;
	var int Switch;
	var PlayerReplicationInfo RelatedPRI;
	var Object OptionalObject;
	var float EndOfLife;
	var float LifeTime;
	var bool bDrawing;
	var int numLines;
	var string StringMessage;
	var color DrawColor;
	var font StringFont;
	var float XL, YL;
	var float YPos;
};

struct native ConsoleMessage
{
	var string Text;
	var color TextColor;
	var float MessageLife;
	var PlayerReplicationInfo PRI;
};
var ConsoleMessage TextMessages[8];

var() float ConsoleMessagePosX, ConsoleMessagePosY; // DP_LowerLeft

var Font FontArrayFonts[9];
var int FontScreenWidthMedium[9];
var int FontScreenWidthSmall[9];

// GBX:PAD: I've moved these in here from gbxHUD because it will make things easier when dealing with drawing HUD
// elements on a more generic level in C++ code.
var float ScaleX;
var float ScaleY;
var float flMinScaleX;
var float flMinScaleY;
var float flSplitScreenMinScaleX;
var float flSplitScreenMinScaleY;
var float flSplitScreenScale;
var float flScaleRatio;
var bool  bIsSplitScreen;
var Material matCurHudComposite;
var Material matCurHudNoShoot;

var array<AnimPawn>	m_ScriptedPawns;

/* Draw3DLine()
draw line in world space. Should be used when engine calls RenderWorldOverlays() event.
*/
native final function Draw3DLine(vector Start, vector End, color LineColor);

simulated event PostBeginPlay()
{
	Super.PostBeginPlay();
	PlayerOwner = PlayerController(Owner);
}

function SpawnScoreBoard(class<Scoreboard> ScoringType)
{
	if ( ScoringType != None )
		Scoreboard = Spawn(ScoringType, PlayerOwner);
}

simulated event Destroyed()
{
    if( ScoreBoard != None )
    {
        ScoreBoard.Destroy();
        ScoreBoard = None;
    }
	Super.Destroyed();
}


//=============================================================================
// Execs

/* toggles displaying scoreboard
*/
exec function ShowScores()
{
	bShowScores = !bShowScores;
}

/* toggles displaying properties of player's current viewtarget
*/
exec function ShowDebug(optional name debugPawnName)
{
	local Pawn tmp;
	bShowDebugInfo = !bShowDebugInfo;
	if (debugPawnName!='')
	{
		foreach AllActors( class'Pawn', tmp )
		{
			if(tmp.Name == debugPawnName)
			{		
				DebugPawn=tmp;
				break;
			}
		}
	}

}

simulated event WorldSpaceOverlays()
{
    if ( bShowDebugInfo && (Pawn(PlayerOwner.ViewTarget) != None || DebugPawn!=None))
        DrawRoute();
}

function CheckCountdown(GameReplicationInfo GRI);

event ConnectFailure(string FailCode, string URL)
{
	PlayerOwner.ReceiveLocalizedMessage(class'FailedConnect', class'FailedConnect'.Static.GetFailSwitch(FailCode));
}
/* ShowUpgradeMenu()
Event called when the engine version is less than the MinNetVer of the server you are trying
to connect with.
*/
event ShowUpgradeMenu();

function PlayStartupMessage(byte Stage);

//=============================================================================
// Message manipulation

function ClearMessage(out HUDLocalizedMessage M)
{
	M.Message = None;
	M.Switch = 0;
	M.RelatedPRI = None;
	M.OptionalObject = None;
	M.EndOfLife = 0;
	M.StringMessage = "";
	M.DrawColor = class'Canvas'.Static.MakeColor(255,255,255);
	M.XL = 0;
	M.bDrawing = false;
}

function CopyMessage(out HUDLocalizedMessage M1, HUDLocalizedMessage M2)
{
	M1.Message = M2.Message;
	M1.Switch = M2.Switch;
	M1.RelatedPRI = M2.RelatedPRI;
	M1.OptionalObject = M2.OptionalObject;
	M1.EndOfLife = M2.EndOfLife;
	M1.StringMessage = M2.StringMessage;
	M1.DrawColor = M2.DrawColor;
	M1.XL = M2.XL;
	M1.YL = M2.YL;
	M1.YPos = M2.YPos;
	M1.bDrawing = M2.bDrawing;
	M1.LifeTime = M2.LifeTime;
	M1.numLines = M2.numLines;
}

//=============================================================================
// Status drawing.
simulated event ViewRender( canvas Canvas )
{
	local Pawn P;

	if (PlayerOwner != None)
	{
		P = Pawn(PlayerOwner.ViewTarget);

		if (P != None)
		{
			if ( !PlayerOwner.bBehindView || P.bIsManningTurret )
			{
				if (P.Weapon != None)
					P.Weapon.RenderOverlays(Canvas);
			}
		}
	}
}

simulated event PostRender( canvas Canvas )
{
	local float XPos,YPos;
	local Pawn P;

	if( PlayerOwner != None )
	{
		CheckCountDown( PlayerOwner.GameReplicationInfo );
		P = Pawn( PlayerOwner.ViewTarget );
	}

//FIXMEJOE
/*
	if ( PlayerConsole.bNoDrawWorld )
	{
		Canvas.SetPos(0,0);
		Canvas.DrawPattern( Texture'Border', Canvas.ClipX, Canvas.ClipY, 1.0 );
	}
*/

	bHideCenterMessages = DrawLevelAction(Canvas);

	if ( (PlayerOwner != None) && !bHideCenterMessages && (PlayerOwner.ProgressTimeOut > Level.TimeSeconds) )
		DisplayProgressMessage(Canvas);

	if ( bBadConnectionAlert )
		DisplayBadConnectionAlert();

	if ( P != None && P.bSpecialHUD )
		P.DrawHud(Canvas);

    if ( bShowDebugInfo )
    {
        Canvas.Font = GetConsoleFont(Canvas);
        Canvas.Style = ERenderStyle.STY_Alpha;
        Canvas.DrawColor = ConsoleColor;

		XPos = 0;  // hack to prevent ucc warning about "unused variable" for XPos, YPos when "ucc -ship"
		YPos = 0;

		if ((PlayerOwner != None) && (PlayerOwner.ViewTarget != None))
		{
			if (DebugPawn!=None)
				DebugPawn.DisplayDebug (Canvas, XPos, YPos);
			else
			PlayerOwner.ViewTarget.DisplayDebug (Canvas, XPos, YPos);
                }
    }
	else if( !bHideHud )
    {
        if ( bShowScores )
        {
            if (ScoreBoard != None)
            {
                ScoreBoard.DrawScoreboard(Canvas, ScaleX, ScaleY, false);
				if ( Scoreboard.bDisplayMessages )
					DisplayMessages(Canvas);
			}
        }
        else
        {
            if ( (PlayerOwner == None) || (P == None) || (P.PlayerReplicationInfo == None) || PlayerOwner.IsSpectating() || PlayerOwner.IsViewingDeadBody() )
            {
				if ( PlayerOwner.IsSpectating() || PlayerOwner.IsViewingDeadBody() )
				{
					bSpectatingHUD = true;
					DrawSpectatingHud(Canvas);
					bSpectatingHUD = false;
				}
				else
				{
					//Don't draw anything in this case.
				}
			}
            else if( !P.bHideRegularHUD )
            {
                DrawHud(Canvas);
			}

//            if ( !DrawLevelAction(Canvas) )
//            {
//                if ((PlayerOwner != None) && (PlayerOwner.ProgressTimeOut > Level.TimeSeconds))
//                    DisplayProgressMessage(Canvas);
//            }

            DisplayMessages(Canvas);
        }
    }

	if (PlayerOwner != None)
		PlayerOwner.RenderOverlays (Canvas);

	// Added by Demiurge Studios (Movie)
	if(TextureMovie != NONE && TextureMovie.Movie != NONE && TextureMovie.Movie.IsPlaying())
	{
		if(TexMovieTranslucent)
			canvas.Style = ERenderStyle.STY_Translucent;
		else
			canvas.Style = ERenderStyle.STY_Normal;
		canvas.SetDrawColor(255,255,255);
		canvas.SetPos( TexMovieLeft*canvas.SizeX, TexMovieTop*canvas.SizeY );
		canvas.DrawTile(TextureMovie, (TexMovieRight-TexMovieLeft)*canvas.SizeX, (TexMovieBottom-TexMovieTop)*canvas.SizeY, 0, 0, TextureMovie.Movie.GetWidth(), TextureMovie.Movie.GetHeight());
	}
	// End Demiurge Studios (Movie)
}

function DrawSpectatingHud (Canvas C);

simulated function DrawRoute()
{
	local int i;
	local Controller C;
	local vector Start, End, RealStart;;
	local bool bPath;

	if (DebugPawn !=None)
		C = DebugPawn.Controller;
	else
	   C = Pawn(PlayerOwner.ViewTarget).Controller;
	if ( C == None )
		return;
	if ( C.CurrentPath != None )
	{
		if (C.CurrentPath.Start.bIsNavigationPoint)
			Start = NavigationPoint(C.CurrentPath.Start).Location;
		else if (C.CurrentPath.Start.bIsNavigationPointLite)
			Start = NavigationPointLite(C.CurrentPath.Start).Location;
	}
	else
		Start = PlayerOwner.ViewTarget.Location;
	RealStart = Start;

	if ( C.bAdjusting )
	{
		Draw3DLine(C.Pawn.Location, C.AdjustLoc, class'Canvas'.Static.MakeColor(255,0,255));
		Start = C.AdjustLoc;
	}

	// show where Pawn is going
	if ( (C == PlayerOwner)
		|| (C.MoveTarget == C.RouteCache[0]) && (C.MoveTarget != None) )
	{
		if ( (C == PlayerOwner) && (C.Destination != vect(0,0,0)) )
		{
			if ( C.PointReachable(C.Destination) )
			{
				Draw3DLine(C.Pawn.Location, C.Destination, class'Canvas'.Static.MakeColor(255,255,255));
				return;
			}
			C.FindPathTo(C.Destination);
		}
		for ( i=0; i<16; i++ )
		{
			if ( C.RouteCache[i] == None )
				break;
			bPath = true;
			if (!C.RouteCache[i].bIsNavigationPointLite)
			{
				Draw3DLine(Start,Actor(C.RouteCache[i]).Location,class'Canvas'.Static.MakeColor(0,255,0));
				Start = Actor(C.RouteCache[i]).Location;
			}
			else
			{
				Draw3DLine(Start,NavigationPointLite(C.RouteCache[i]).Location,class'Canvas'.Static.MakeColor(0,255,0));
				Start = NavigationPointLite(C.RouteCache[i]).Location;
			}
		}
		if ( bPath )
			Draw3DLine(RealStart,C.Destination,class'Canvas'.Static.MakeColor(255,255,255));
	}
	else if ( PlayerOwner.ViewTarget.Velocity != vect(0,0,0) )
		Draw3DLine(RealStart,C.Destination,class'Canvas'.Static.MakeColor(255,255,255));

	if ( C == PlayerOwner )
		return;

	// show where Pawn is looking
	if ( C.Focus != None )
	{
		if (C.Focus.bIsNavigationPoint)
			End = NavigationPoint(C.Focus).Location;
		else if (C.Focus.bIsNavigationPointLite)
			End = NavigationPointLite(C.Focus).Location;
	}
	else
		End = C.FocalPoint;
	Draw3DLine(PlayerOwner.ViewTarget.Location + Pawn(PlayerOwner.ViewTarget).BaseEyeHeight * vect(0,0,1),End,class'Canvas'.Static.MakeColor(255,0,0));

	// GBX:naj - added 8/13/03
	if (C.IsA('AIController'))
		AIController(C).DisplayDebugSpecial( Self );
}

/* DrawHUD() Draw HUD elements on canvas.
*/
function DrawHUD(canvas Canvas);

/*  Print a centered level action message with a drop shadow.
*/
function PrintActionMessage( Canvas C, string BigMessage )
{
	local float XL, YL;

	C.bCenter = false;
	C.StrLen( BigMessage, XL, YL );
	C.SetPos(0.5 * (C.ClipX - XL) + 1, 0.66 * C.ClipY - YL * 0.5 + 1);
	C.SetDrawColor(0,0,0);
	C.DrawText( BigMessage, false );
	C.SetPos(0.5 * (C.ClipX - XL), 0.66 * C.ClipY - YL * 0.5);
	C.SetDrawColor(74,99,61);;
	C.DrawText( BigMessage, false );
}

simulated function bool IsDisplayingMultiplayerTitleCard()
{
	local bool rslt;

	if (PlayerOwner.ProgressMessage[0] != "")
	{
		rslt = true;
	}

	return rslt;
}

/* Display Progress Messages
display progress messages in center of screen
*/
simulated function DisplayProgressMessage(Canvas C)
{
    local int i, LineCount;
    local GameReplicationInfo GRI;
    local float FontDX, FontDY;
    local float X, Y;
    local int Alpha;
    local float TimeLeft;

    TimeLeft = PlayerOwner.ProgressTimeOut - Level.TimeSeconds;

    if( TimeLeft >= ProgressFadeTime )
        Alpha = 255;
    else
        Alpha = (255 * TimeLeft) / ProgressFadeTime;

    GRI = PlayerOwner.GameReplicationInfo;

    LineCount = 0;

    for (i = 0; i < ArrayCount (PlayerOwner.ProgressMessage); i++)
    {
        if (PlayerOwner.ProgressMessage[i] == "")
            continue;

        LineCount++;
    }

    if (GRI != None)
    {
        if( GRI.MOTDLine1 != "" ) LineCount++;
        if( GRI.MOTDLine2 != "" ) LineCount++;
        if( GRI.MOTDLine3 != "" ) LineCount++;
        if( GRI.MOTDLine4 != "" ) LineCount++;
    }

    C.Font = GetConsoleFont(C);

    C.Style = ERenderStyle.STY_Alpha;

    C.TextSize ("A", FontDX, FontDY);

    X = (0.5 * HudCanvasScale * C.SizeX) + (((1.0 - HudCanvasScale) / 2.0) * C.SizeX);
    Y = (0.5 * HudCanvasScale * C.SizeY) + (((1.0 - HudCanvasScale) / 2.0) * C.SizeY);

    Y -= FontDY * (float (LineCount) / 2.0);

    for (i = 0; i < ArrayCount (PlayerOwner.ProgressMessage); i++)
    {
        if (PlayerOwner.ProgressMessage[i] == "")
            continue;

        C.DrawColor = PlayerOwner.ProgressColor[i];
        C.DrawColor.A = Alpha;

        C.TextSize (PlayerOwner.ProgressMessage[i], FontDX, FontDY);
        C.SetPos (X - (FontDX / 2.0), Y);
        C.DrawText (PlayerOwner.ProgressMessage[i]);

        Y += FontDY;
    }

    if( (GRI != None) && (Level.NetMode != NM_StandAlone) )
    {
        C.DrawColor = MOTDColor;
        C.DrawColor.A = Alpha;

        if( GRI.MOTDLine1 != "" )
        {
            C.TextSize (GRI.MOTDLine1, FontDX, FontDY);
            C.SetPos (X - (FontDX / 2.0), Y);
            C.DrawText (GRI.MOTDLine1);
            Y += FontDY;
        }

        if( GRI.MOTDLine2 != "" )
        {
            C.TextSize (GRI.MOTDLine2, FontDX, FontDY);
            C.SetPos (X - (FontDX / 2.0), Y);
            C.DrawText (GRI.MOTDLine2);
            Y += FontDY;
        }

        if( GRI.MOTDLine3 != "" )
        {
            C.TextSize (GRI.MOTDLine3, FontDX, FontDY);
            C.SetPos (X - (FontDX / 2.0), Y);
            C.DrawText (GRI.MOTDLine3);
            Y += FontDY;
        }

        if( GRI.MOTDLine4 != "" )
        {
            C.TextSize (GRI.MOTDLine4, FontDX, FontDY);
            C.SetPos (X - (FontDX / 2.0), Y);
            C.DrawText (GRI.MOTDLine4);
            Y += FontDY;
        }
    }
}


/* Draw the Level Action
*/
function bool DrawLevelAction( canvas C )
{
	local string BigMessage;

	if (Level.LevelAction == LEVACT_None )
	{
		if ( (Level.Pauser != None) && (Level.TimeSeconds > Level.PauseDelay + 0.2) )
			BigMessage = PausedMessage; // Add pauser name?
		else
		{
			BigMessage = "";
			return false;
		}
	}
	else if ( Level.LevelAction == LEVACT_Loading )
		BigMessage = LoadingMessage;
//	else if ( Level.LevelAction == LEVACT_Saving )
//		BigMessage = SavingMessage;
	else if ( Level.LevelAction == LEVACT_Connecting )
		BigMessage = ConnectingMessage;
	else if ( Level.LevelAction == LEVACT_Precaching )
		BigMessage = PrecachingMessage;

	if ( BigMessage != "" )
	{
		C.Style = ERenderStyle.STY_Normal;
		PrintActionMessage(C, BigMessage);
		return true;
	}
	return false;
}

/* DisplayBadConnectionAlert()
Warn user that net connection is bad
*/
function DisplayBadConnectionAlert();


// Added by Demiurge Studios (Movie)
function PlayMovieDirect(String MovieFilename, int XPos, int YPos, bool UseSound, bool LoopMovie)
{
	StopMovie();	

	MoviePosX = XPos;
	MoviePosY = YPos;
	Movie.Play(MovieFilename, UseSound, LoopMovie);
}


function PlayMovieScaled(MovieTexture InMovie, float Left, float Top, float Right, float Bottom, bool UseSound, bool LoopMovie, optional bool Translucent)
{
	StopMovie();

	if(Top < 0)
		Top = 0;
	if(Top > 1)
		Top = 1;

	if(Left < 0)
		Left = 0;
	if(Left > 1)
		Left = 1;

	if(Bottom < 0)
		Bottom = 0;
	if(Bottom > 1)
		Bottom = 1;

	if(Right < 0)
		Right = 0;
	if(Right > 1)
		Right = 1;	

	TexMovieTop = Top;
	TexMovieLeft = Left;
	TexMovieBottom = Bottom;
	TexMovieRight = Right;
	TexMovieTranslucent = Translucent;

	TextureMovie = InMovie;
	TextureMovie.InitializeMovie();
	TextureMovie.Movie.Play(TextureMovie.MovieFilename, UseSound, LoopMovie);
}

//DLEVY add new function to draw scaled movie from a filename
function PlayMovieScaledDirect(String MovieFilename, float Left, float Top, float Right, float Bottom, bool UseSound, bool LoopMovie, optional bool Translucent)
{
	StopMovie();

	if(Top < 0)
		Top = 0;
	if(Top > 1)
		Top = 1;

	if(Left < 0)
		Left = 0;
	if(Left > 1)
		Left = 1;

	if(Bottom < 0)
		Bottom = 0;
	if(Bottom > 1)
		Bottom = 1;

	if(Right < 0)
		Right = 0;
	if(Right > 1)
		Right = 1;	

	TexMovieTop = Top;
	TexMovieLeft = Left;
	TexMovieBottom = Bottom;
	TexMovieRight = Right;
	TexMovieTranslucent = Translucent;

	TextureMovie.MovieFilename = MovieFilename;
	TextureMovie.InitializeMovie();
	TextureMovie.Movie.Play(TextureMovie.MovieFilename, UseSound, LoopMovie);
}


function bool IsMoviePlaying()
{
	return Movie.IsPlaying() || TextureMovie.Movie.IsPlaying();
}


function PauseMovie(bool Pause)
{
	Movie.Pause(Pause);
	TextureMovie.Movie.Pause(Pause);
}


function bool IsMoviePaused()
{
	if(Movie.IsPlaying())
		return Movie.IsPaused();

	if(TextureMovie.Movie.IsPlaying())
		return TextureMovie.Movie.IsPaused();

	return false;
}


function StopMovie()
{
	Movie.StopNow();
	TextureMovie.Movie.StopNow();
}
// End Demiurge Studios (Movie)



//=============================================================================
// Messaging.

simulated function Message( PlayerReplicationInfo PRI, coerce string Msg, name MsgType )
{
	if ( bMessageBeep )
		PlayerOwner.PlayBeepSound();
	if ( (MsgType == 'Say') || (MsgType == 'TeamSay') )
		Msg = PRI.PlayerName$": "$Msg;
	AddTextMessage(Msg,class'LocalMessage',PRI);
}

function DisplayPortrait(PlayerReplicationInfo PRI);

simulated function LocalizedMessage( class<LocalMessage> Message, optional int Switch, optional PlayerReplicationInfo RelatedPRI_1, optional PlayerReplicationInfo RelatedPRI_2, optional Object OptionalObject, optional string CriticalString );

simulated function PlayReceivedMessage( string S, string PName, ZoneInfo PZone )
{
	PlayerOwner.ClientMessage(S);
	if ( bMessageBeep )
		PlayerOwner.PlayBeepSound();
}

function bool ProcessKeyEvent( int Key, int Action, FLOAT Delta )
{
	if ( NextHud != None )
		return NextHud.ProcessKeyEvent(Key,Action,Delta);
	return false;
}

/* DisplayMessages() - display current messages
*/
function DisplayMessages(Canvas C)
{
    local int i, j, XPos, YPos,MessageCount;
    local float XL, YL;
	local float ConsoleMessageScale;

    for( i = 0; i < ConsoleMessageCount; i++ )
    {
        if ( TextMessages[i].Text == "" )
            break;
        else if( TextMessages[i].MessageLife < Level.TimeSeconds )
        {
            TextMessages[i].Text = "";

            if( i < ConsoleMessageCount - 1 )
            {
                for( j=i; j<ConsoleMessageCount-1; j++ )
                    TextMessages[j] = TextMessages[j+1];
            }
            TextMessages[j].Text = "";
            break;
        }
        else
			MessageCount++;
    }

	// re-scale HUD console messages to 95% of HudCanvasScale...
	ConsoleMessageScale = HudCanvasScale * 0.95;

    XPos = (ConsoleMessagePosX * ConsoleMessageScale * C.SizeX) + (((1.0 - ConsoleMessageScale) / 2.0) * C.SizeX);
    YPos = (ConsoleMessagePosY * ConsoleMessageScale * C.SizeY) + (((1.0 - ConsoleMessageScale) / 2.0) * C.SizeY);

    C.Font = GetConsoleFont(C);
    C.DrawColor = ConsoleColor;

    C.TextSize ("A", XL, YL);

    YPos -= YL * MessageCount+1; // DP_LowerLeft
    YPos -= YL; // Room for typing prompt

    for( i=0; i<MessageCount; i++ )
    {
        if ( TextMessages[i].Text == "" )
            break;

        C.StrLen( TextMessages[i].Text, XL, YL );
        C.SetPos( XPos, YPos );
        C.DrawColor = TextMessages[i].TextColor;
        C.DrawText( TextMessages[i].Text, false );
        YPos += YL;
    }
}

function AddTextMessage(string M, class<LocalMessage> MessageClass, PlayerReplicationInfo PRI)
{
	local int i;


	if( bMessageBeep && MessageClass.Default.bBeep )
		PlayerOwner.PlayBeepSound();

    for( i=0; i<ConsoleMessageCount; i++ )
    {
        if ( TextMessages[i].Text == "" )
            break;
    }

    if( i == ConsoleMessageCount )
    {
        for( i=0; i<ConsoleMessageCount-1; i++ )
            TextMessages[i] = TextMessages[i+1];
    }

    TextMessages[i].Text = M;
    TextMessages[i].MessageLife = Level.TimeSeconds + MessageClass.Default.LifeTime;
    TextMessages[i].TextColor = MessageClass.static.GetConsoleColor(PRI);
    TextMessages[i].PRI = PRI;
}

function GetConsoleMessagesOldestFirst(out array<string> Messages)
{
	local int i;

    for( i=0; i<ConsoleMessageCount; i++ )
	{
		if ( TextMessages[i].Text == "" )
		{
			break;
		}
		else if (TextMessages[i].MessageLife >= Level.TimeSeconds)
		{
			Messages[i] = TextMessages[i].Text;
		}
	}
}

//=============================================================================
// Font Selection.

static function Font LoadFontStatic(int i)
{
//	if( default.FontArrayFonts[i] == None )
//	{
//		default.FontArrayFonts[i] = Font(DynamicLoadObject(default.FontArrayNames[i], class'Font'));
//		if( default.FontArrayFonts[i] == None )
//			Log("Warning: "$default.Class$" Couldn't dynamically load font "$default.FontArrayNames[i]);
//	}

	return default.FontArrayFonts[i];
}

simulated function Font LoadFont(int i)
{
//	if( FontArrayFonts[i] == None )
//	{
//		FontArrayFonts[i] = Font(DynamicLoadObject(FontArrayNames[i], class'Font'));
//		if( FontArrayFonts[i] == None )
//			Log("Warning: "$Self$" Couldn't dynamically load font "$FontArrayNames[i]);
//	}
	return FontArrayFonts[i];
}


static function font GetConsoleFont(Canvas C)
{
	local int FontSize;

	FontSize = Default.ConsoleFontSize;
	if ( C.ClipX < 640 )
		FontSize++;
	if ( C.ClipX < 800 )
		FontSize++;
	if ( C.ClipX < 1024 )
		FontSize++;
	if ( C.ClipX < 1280 )
		FontSize++;
	if ( C.ClipX < 1600 )
		FontSize++;
	return LoadFontStatic(Min(8,FontSize));
}

static function Font LargerFontThan(Font aFont)
{
	local int i;

	for ( i=0; i<7; i++ )
		if ( LoadFontStatic(i) == aFont )
			return LoadFontStatic(Max(0,i-4));
	return LoadFontStatic(5);
}

simulated function font LoadProgressFont()
{
	if( ProgressFontFont == None )
	{
		ProgressFontFont = Font(DynamicLoadObject(ProgressFontName, class'Font'));
		if( ProgressFontFont == None )
		{
			Log("Warning: "$Self$" Couldn't dynamically load font "$ProgressFontName);
			ProgressFontFont = Font'Engine.DefaultFont';
		}
	}
	return ProgressFontFont;
}

simulated function DrawTargeting( Canvas C );

simulated function SetFadeOverride( bool bFadeOverride );
simulated function SetPersistantFadeOverride( bool bFadeOverride );

defaultproperties
{
	bMessageBeep=true
	bHidden=True
	RemoteRole=ROLE_None

    ConsoleColor=(R=153,G=216,B=253,A=255)

    ProgressFontName="Engine.DefaultFont"
    MOTDColor=(R=255,G=255,B=255,A=255)
    ProgressFadeTime=1.0

    HudCanvasScale=0.95

	LoadingMessage="LOADING"
	SavingMessage="SAVING"
	ConnectingMessage="CONNECTING"
	PausedMessage="PAUSED"
	PrecachingMessage=""

	FontArrayFonts(0)=Font'Engine.DefaultFont'
	FontArrayFonts(1)=Font'Engine.DefaultFont'
	FontArrayFonts(2)=Font'Engine.DefaultFont'
	FontArrayFonts(3)=Font'Engine.DefaultFont'
	FontArrayFonts(4)=Font'Engine.DefaultFont'
	FontArrayFonts(5)=Font'Engine.DefaultFont'
	FontArrayFonts(6)=Font'Engine.DefaultFont'
	FontArrayFonts(7)=Font'Engine.DefaultFont'
	FontArrayFonts(8)=Font'Engine.DefaultFont'

    ConsoleMessageCount=6
    ConsoleFontSize=5
    MessageFontOffset=0
    
    bSpectatingHUD = false;
    
	// Added by Demiurge Studios (Movie)
	MoviePosX=100
	MoviePosY=100
	TexMovieTop=0.0
	TexMovieLeft=0.0
	TexMovieBottom=1.0
	TexMovieRight=1.0
	// End Demiurge Studios (Movie)
}
//=============================================================================
// Hud Effect: things attached to APlayerController and rendered as part of
//   the hud, either before or after the viewmodel
class HudEffect extends Object
	native;

struct native HudParticle
{
    var float   WakeupTime; // when was it created (might be in the future!)
    var float   ImpactTime; // how long until particle 'hits the wall' and stops translating
    var float   ZoomInTime; // how long until particle is at 100% size
    var float   PreImpactDistance;  // how far the object moves between wakeuptime and impacttime
    var float   PostImpactDistance; // how far the object moves between impacttime and global 'duraction'
    var float   FadeInTime; // linear interp from wakeup to fadein time, alpha
    var float   FadeOutTime;// linear interp from fadeout to global 'duration'
    var float   DripTime;   
    var float   DripScale;  // 0.0 = no drip, 1.0 = 100% drip
    var float   Size;       // size of particle
    var float   Alpha;
    var float   Brightness;
    var float   Angle;
    var float   StreakScale;
    var vector  Position;   // starting position
    var float   UVs[4];     // texture coordinates since its a subimage (UV upper left, UV upper right)
};

struct native HudParticleParameters
{
    var float    AlphaMax;
    var float    AlphaMin;
    var float    BrightnessMax;
    var float    BrightnessMin;
    var float    DripScale;
    var float    DripTime;
    var float    FadeInTime;     // How long after wakeup until the particle is full alpha
    var float    FadeInVariance;  // random scale for fade-in time
    var float    FadeOutTime;    // How long after SPAWN (NOT WAKEUP) time should alpha start fading out
    var float    FadeOutVariance; // random offset for fade-out time
    var float    ImpactTime;     // How long after WakeUp time should it 'hit the screen'
    var float    ImpactVariance;
    var float    SizeMax;        // Largest particle ize
    var float    SizeMin;        // Smallest particle size
    var float    PostImpactDistance; // How fast does the blood slide down after impact
    var float    PreImpactDistance;  // How fast does the blood move before impact
    var float    WakeUpDistanceFactor;  // Scale wakeup time by distance from spawn point
    var float    WakeUpVariance;      // random scale for wake-up time
    var float    ZoomInTime;          // How long after wake up until particle hits 100% size
    var float    ZoomInVariance;
    var float    OrientationFactor;   // How strongly oriented are they from the damage vector/position
    var float    StreakScale;         // How stretched are they
    var float    StreakScaleVariance; // How much can the streak length vary
    var float    PostImpactVariance;
    var float    PostImpactVarianceScaledBySize;
    var float    DistanceScaleA;
    var float    DistanceScaleB;
    var float    DistanceScaleC;
    var float    DistanceScaleMax;
    var float    DistanceScaleMin;
};
	
enum ERenderTime
{
	ERT_BeforeHUD,
	ERT_AfterHUD,
};

var int						MaxParticles;	// Maximum number of particles visible at any time
var vector                  DamageVector;   // The vector the damage is coming from
var vector                  LookAtVector;   // The vector the player was looking at when the damage was received
var int                     RandomSeed;     // For making things deterministic (for testing primarily)
var float                   Duration;       // How long the effect takes to execute

var material                Texture;        // Our beautiful texture
var int                     TextureTilesX;  // number subimage slots in X axis of texture
var int                     TextureTilesY;  // number subimage slots in Y axis of texture

var (HudEffect) ERenderTime WhenToRender;
var PlayerController Owner;

// NOTE: Run-time variables follow, should not be set directly except in the effect creating/rendering
var vector                  ScreenDamageVector;     // Vector in screen space the damage is coming from
var vector                  ScreenDamageTangent;    // Tangent vector to screen damage
var array<HudParticle> Particles;
var array<HudParticle> ActiveParticles;

native final function Initialize();
native final function CreateParticles( int Amount );
native final function ClearParticles();
native final function DrawHudEffect( Canvas Canvas );
native final function bool IsActive();

defaultproperties
{
	WhenToRender = ERT_BeforeHUD;
}
class HudEffectBlood extends HudEffect
    native;

var HudParticleParameters SplatParameters;

defaultproperties
{
    TextureTilesX = 4
    TextureTilesY = 4
}
class HudEffectDirt extends HudEffect
	native;

var HudParticleParameters SplatParameters;

defaultproperties
{
    TextureTilesX=4
    TextureTilesY=4
}class HudEffectRain extends HudEffect
	native;

var HudParticleParameters SplatParameters;

defaultproperties
{
    TextureTilesX=4
    TextureTilesY=4
}//=============================================================================
// I3DL2Listener: Base class for I3DL2 room effects.
//=============================================================================

class I3DL2Listener extends Object
	editinlinenew
	native;




var()			float		EnvironmentSize;
var()			float		EnvironmentDiffusion;
var()			int			Room;
var()			int			RoomHF;
var()			int			RoomLF;
var()			float		DecayTime;
var()			float		DecayHFRatio;
var()			float		DecayLFRatio;
var()			int			Reflections;
var()			float		ReflectionsDelay;
var()			vector		ReflectionsPan;
var()			int			Reverb;
var()			float		ReverbDelay;
var()			vector		ReverbPan;
var()			float		EchoTime;
var()			float		EchoDepth;
var()			float		ModulationTime;
var()			float		ModulationDepth;
var()			float		RoomRolloffFactor;
var()			float		AirAbsorptionHF;
var()			float		HFReference;
var()			float		LFReference;
var()			bool		bDecayTimeScale;
var()			bool		bReflectionsScale;
var()			bool		bReflectionsDelayScale;
var()			bool		bReverbScale;
var()			bool		bReverbDelayScale;
var()			bool		bEchoTimeScale;
var()			bool		bModulationTimeScale;
var()			bool		bDecayHFLimit;

var	transient	int			Environment;
var transient	int			Updated;

defaultproperties
{
	EnvironmentSize=100.0
	EnvironmentDiffusion=1.0
	Room=0
	RoomHF=-1831
	RoomLF=-1127
	DecayTime=0.94
	DecayHFRatio=0.1
	DecayLFRatio=2.00
	Reflections=-3943
	ReflectionsDelay=0.01
	Reverb=2000
	ReverbDelay=0.0
	EchoTime=0.25
	EchoDepth=1.0
	ModulationTime=0.03
	ModulationDepth=0.0
	RoomRolloffFactor=10.0
	AirAbsorptionHF=-22.54
	HFReference=1000
	LFReference=213.2
	bDecayTimeScale=true
	bReflectionsScale=true
	bReflectionsDelayScale=true
	bReverbScale=true
	bReverbDelayScale=true
	bEchoTimeScale=true
	bDecayHFLimit=true
}
class IAISpeechManager extends Actor
	abstract
	notplaceable
	transient
	native;

// Enable/disable the speech system; useful for LDs to turn off combat dialogue while scripted sequences are playing.
function EnableSpeech();
function DisableSpeech();
function EnableSpeechForCharacter( Pawn P );
function DisableSpeechForCharacter( Pawn P );

// Make a speech request (it will be queued up and the system will decide whether to play it later on).
function PlaySpeech(
	Pawn Speaker,						// The Pawn saying the speech.
	Pawn Listener,						// The Pawn hearing the speech.
	name speechName,				// The speech to be played.
	optional name repetitionSpeechName,	// The speech to be played if this request turns out to be a repetition.
	optional String keyName,			// specify a keyName if desired
	optional float timeDelay,		// How long the Pawn should wait before actually speaking.
	optional Object oRegarding,		// The object this speech is in reference to.
	optional float timeout,			// How long the request should wait before giving up. (0 for infinite)
	optional float timeBlockRedundancies // How long after finishing playing the speech continues to block other speeches that say the same thing.
);

// Tell the Speech Manager not to allow any speeches related to flanking the enemy
// (useful for maps like ChurchTower, where it's impossible for the player to flank).
function EnableFlankingSpeeches( bool bEnable );

// Tell the Speech Manager not to allow any speeches warning the player to "watch out!"
// This is used when the player mounts a turret weapon, in which case it would be confusing for his
// allies to be telling him to get down.
function EnablePlayerWarningSpeeches( bool bEnable );

// Pass in a Regarding object if you want to only remove speeches of regarding that object; otherwise,
// pass in nothing to remove all speeches of the supplied group name.
function RemoveSpeeches( name speechName, optional Object Regarding );

// Remove all speeches for a particular speaker.  This should be called when the speaker dies, for instance.
// Alternatively, supply a speechName to only remove speeches of that type.
function RemoveSpeechesForSpeaker( Pawn Speaker, optional name speechName, optional bool bKillPlayingSpeeches );

function ShoutNameOf( 
	Pawn Speaker, 
	Pawn Listener,
	Pawn Named, 
	name AlternateSpeech, 
	optional float timeDelay, 
	optional float timeout, 
	optional float timeBlockRedundancies 
);

defaultproperties
{
	DrawType=DT_None
	bHidden=true
	bHiddenEd=true
}
	
//=============================================================================
// Interface class for gbxBase.DifficultyManager.  
// See gbxBase/DifficultyManager.uc for more details.
//
// Author: Neil Johnson, Gearbox Software.
//=============================================================================
class IDifficultyManager extends Actor
	abstract
	notplaceable;

function SetDifficulty( EDifficulty NewDifficulty );
function EDifficulty GetDifficulty();
function bool CanDoOpBursts( ESkillLevel SkillLevel );
function float AdjustDamage( int Damage, Pawn DamagedPawn, class<DamageType> DamageType );

defaultproperties
{
	DrawType=DT_None
	bHidden=true
}class IGbxPawnList extends Actor
	native
	abstract
	notplaceable;



function Reset();

function bool CanSpawnNow()
{
	return true;
}
function Pawn GetRespawnPawn( class<Pawn> pawnType )
{
	return None;
}
function float GetRespawnDelay()
{
	return 0.0f;
}
function IncrementRespawnDelay();
//*********************************************************
// IImpactManager.uc
//
// Author: Neil Johnson
// 5/20/2003
//
// Declares the interface for gbxEffects.ImpactManager.
// Basically this class is no more than a stub that allows
// the Engine package to use ImpactManager (since Engine is
// declared above gbxEffects in the hierarchy, it could not
// use it otherwise.
//
//*********************************************************
class IImpactManager extends Object
	native
	abstract
	transient;



static function IImpactManager GetInstance( optional Object InOuter, optional Actor Spawner );

function HandleExplosionImpact(
		Actor						Spawner,
		Material					HitMaterial,
		EWeaponCategory				WeaponCategory,
		Vector						ImpactLoc,
		Rotator						ImpactRot);

function HandleMeleeImpact( 
		Actor						Spawner, 
		Material					HitMaterial, 
		bool						HitWater, 
		Vector						ImpactLoc, 
		Rotator						ImpactRot);

event HandleBulletImpact(
        Actor                       HitActor,
		Actor						Spawner,
		Material					HitMaterial,
		Bool						HitWater,
		EWeaponCategory				WeaponCategory,
		Vector						ImpactLoc,
		Rotator						ImpactRot);

function Initialize( Actor Spawner );
function HandleFootStep( Material FloorMat, Actor Sponsor );
function HandleFootTurn( Material FloorMat, Actor Sponsor );
function HandleGrenadeBounce( Material FloorMat, Actor Sponsor, bool bInWater );
//=============================================================================
// Abstract base class for gbxInventory.MG42Factory.  This abstract class is
// necessary so that UnrealEd can display kill-zone radii in the editor.
//
// Author: Neil Johnson, Gearbox Software.
//=============================================================================
class IMG42Factory extends Actor
	native
	abstract
	notplaceable;



var (MG42Factory)	float	Zone1OuterRadius,			// Distances defining three 'kill zones' for the MG42.
							Zone2OuterRadius,			// (Zone 1 == closest to turret; Zone 3 == farthest).
							Zone3OuterRadius;
var (MG42Factory)	float	NoShotProtectionDist;
//=============================================================================
// Info, the root of all information holding classes.
//=============================================================================
class Info extends Actor
	abstract
	hidecategories(Movement,Collision,Lighting,LightColor,Karma,Force)
	native;



//------------------------------------------------------------------------------
// Structs for reporting server state data

struct native export KeyValuePair
{
	var() string Key;
	var() string Value;
};

struct native export PlayerResponseLine
{
	var() int PlayerNum;
	var() int PlayerID;
	var() string PlayerName;
	var() int Ping;
	var() int Score;
	var() int StatsID;
	var() array<KeyValuePair> PlayerInfo;

};

struct native export ServerResponseLine
{
	var() int ServerID;
	var() string IP;
	var() int Port;
	var() int QueryPort;
	var() string ServerName;
	var() string MapName;
	var() string GameType;
	var() int CurrentPlayers;
	var() int MaxPlayers;
	var() int Ping;

	var() array<KeyValuePair> ServerInfo;
	var() array<PlayerResponseLine> PlayerInfo;
};


static function ClientReceiveObjective(
	PlayerController P,
	Name szObjectiveTag,
	EObjectiveComplete nStatus,
	int nObjectiveIdx,
	bool bDisplayMessage,
	float flLifeTime,
	optional PlayerReplicationInfo RelatedPRI_1,
	optional PlayerReplicationInfo RelatedPRI_2
	);

defaultproperties
{
	RemoteRole=ROLE_None
	NetUpdateFrequency=10
     bHidden=True
	 bOnlyDirtyReplication=true
	 bSkipActorPropertyReplication=true
}
// ====================================================================
//  Class:  Engine.Interaction
//
//  Each individual Interaction is a jumping point in UScript.  The should
//  be the foundatation for any subsystem that requires interaction with
//  the player (such as a menu).
//
//  Interactions take on two forms, the Global Interaction and the Local
//  Interaction.  The GI get's to process data before the LI and get's
//  render time after the LI, so in essence the GI wraps the LI.
//
//  A dynamic array of GI's are stored in the InteractionMaster while
//  each Viewport contains an array of LIs.
//
//
// (c) 2001, Epic Games, Inc.  All Rights Reserved
// ====================================================================

class Interaction extends Interactions
	native;



var bool bActive;			// Is this interaction Getting Input
var bool bVisible;			// Is this interaction being Displayed
var bool bRequiresTick; 	// Does this interaction require game TICK
var bool bNativeEvents;		// This interaction requests native events

var	bool bIsConsole;		// If True, we are running on a console
var bool bIsDemoVersion;	// If True, we are running a demo version of the game
var bool bIsPreviewVersion;	// If True, we are running a demo version of the game

// These entries get filled out upon creation.

var Player ViewportOwner;		// Pointer to the ViewPort that "Owns" this interaction or none if it's Global
var InteractionMaster Master;	// Pointer to the Interaction Master

//-----------------------------------------------------------------------------
// natives.

native function Initialize();							// setup the state system and stack frame
native function bool ConsoleCommand( coerce string S );	// Executes a console command

// WorldToScreen converts a vector in the world

// ====================================================================
// WorldToScreen - Returns the X/Y screen coordinates in to a viewport of a given vector
// in the world.
// ====================================================================
native function vector WorldToScreen(vector Location, optional vector CameraLocation, optional rotator CameraRotation);

// ====================================================================
// ScreenToWorld - Converts an X/Y screen coordinate in to a world vector
// ====================================================================
native function vector ScreenToWorld(vector Location, optional vector CameraLocation, optional rotator CameraRotation);

// ====================================================================
// Initialized - Called directly after an Interaction Object has been created
// and Initialized.  Should be subclassed
// ====================================================================

event Initialized();


// ====================================================================
// Message - This event allows interactions to receive messages
// ====================================================================

function Message( coerce string Msg, float MsgLife)
{
} // Message

// ====================================================================
// ====================================================================
// Input Routines - These two routines are the entry points for input.  They both
// return true if the data has been processed and should now discarded.

// Both functions should be handled in a subclass of Interaction
// ====================================================================
// ====================================================================

function bool KeyType( out EInputKey Key, optional string Unicode )
{
	return false;
}


function bool KeyEvent( out EInputKey Key, out EInputAction Action, FLOAT Delta )
{
	return false;
}

// ====================================================================
// ====================================================================
// Render Routines - All Interactions recieve both PreRender and PostRender
// calls.

// Both functions should be handled in a subclass of Interaction
// ====================================================================
// ====================================================================


function PreRender( canvas Canvas );
function PostRender( canvas Canvas );

// ====================================================================
// SetFocus - This function cases the Interaction to gain "focus" in the interaction
// system.  Global interactions's focus superceed locals.
// ====================================================================

function SetFocus()
{
	Master.SetFocusTo(self,ViewportOwner);

} // SetFocus

// ====================================================================
// Tick - By default, Interactions do not get ticked, but you can
// simply turn on bRequiresTick.
// ====================================================================

function Tick(float DeltaTime);

// ====================================================================
// WantsMergedInput - If true, the input system should send merged input
// to the interaction master to process
// ====================================================================

function bool WantsMergedInput()
{
	return false;
}

defaultproperties
{
	bActive=True
	bRequiresTick=False
	bVisible=False
	bNativeEvents=False
}
// ====================================================================
//  Class:  Engine.InteractionMaster
//
//  The InteractionMaster controls the entire interaction system.  It's
//  job is to take input and Pre/PostRender call and route them to individual
//  Interactions and/or viewports.
//
// 	The stubs here in script are for just the GlobalInteracations as those
// 	are the only Interactions the IM routes directly too.  A new stub is
// 	created in order to limit the number of C++ -> Uscript switches.
//
// (c) 2001, Epic Games, Inc.  All Rights Reserved
// ====================================================================

class InteractionMaster extends Interactions
	    transient
		Native;



var transient Client Client;

var transient const Interaction BaseMenu;	// Holds a pointer to the base menu system
var transient const Interaction Console;	// Holds the special Interaction that acts as the console
var transient array<Interaction> GlobalInteractions;	// Holds a listing of all global Interactions
var transient bool bRequireRawJoystick;

native function Travel(string URL);	// Setup a travel to a new map

// ====================================================================
// Control functions
// ====================================================================

event Interaction AddInteraction(string InteractionName, optional Player AttachTo) 	// Adds an Interaction
{
	local Interaction NewInteraction;
	local class<Interaction> NewInteractionClass;

	NewInteractionClass = class<Interaction>(DynamicLoadObject(InteractionName, class'Class'));

	if (NewInteractionClass!=None)
	{
		NewInteraction = new( None ) NewInteractionClass;
		if (NewInteraction != None)
		{
			// Place the Interaction in the proper array

			if (AttachTo != None)	// Handle location Interactions
			{
				AttachTo.LocalInteractions.Length = AttachTo.LocalInteractions.Length + 1;
				AttachTo.LocalInteractions[AttachTo.LocalInteractions.Length-1] = NewInteraction;
				NewInteraction.ViewportOwner = AttachTo;
			}
			else	// Handle Global Interactions
			{
				GlobalInteractions.Length = GlobalInteractions.Length + 1;
				GlobalInteractions[GlobalInteractions.Length-1] = NewInteraction;
			}

			// Initialize the Interaction

			NewInteraction.Initialize();
			NewInteraction.Master = Self;

			return NewInteraction;

		}
		else
  			Log("Could not create interaction ["$InteractionName$"]",'IMaster');

	}
	else
		Log("Could not load interaction ["$InteractionName$"]",'IMaster');

	return none;

} // AddInteraction

event RemoveInteraction(interaction RemoveMe)			// Removes a Interaction
{
	local int Index;

	// Grab the array to work with

	if (RemoveMe.ViewportOwner != None)
	{
		for (Index = 0; Index < RemoveMe.ViewPortOwner.LocalInteractions.Length; Index++)
		{
			if ( RemoveMe.ViewPortOwner.LocalInteractions[Index] == RemoveMe )
			{
				RemoveMe.ViewPortOwner.LocalInteractions.Remove(Index,1);
				return;
			}
		}
	}
	else
	{
		for (Index = 0; Index < GlobalInteractions.Length; Index++)
		{
			if ( GlobalInteractions[Index] == RemoveMe )
			{
				GlobalInteractions.Remove(Index,1);
				return;
			}
		}
	}


	// Find the Interaction to delete

	Log("Could not remove interaction ["$RemoveMe$"] (Not Found)", 'IMaster');

} // RemoveInteraction

// ====================================================================
// SetFocusTo - This function will cause a window to adjust it's position
// in it's array so that it processes input first and displays last.
// ====================================================================

event SetFocusTo(Interaction Inter, optional Player ViewportOwner)
{
	local array<Interaction> InteractionArray;
	local Interaction temp;
	local int i,iIndex;


	if (ViewportOwner != none)
		InteractionArray = ViewportOwner.LocalInteractions;
	else
		InteractionArray = GlobalInteractions;

	if (InteractionArray.Length == 0)
	{
		Log("Attempt to SetFocus on an empty Array.",'IMaster');
		return;
	}

	// Search for the Interaction

	iIndex = -1;
	for ( i=0; i<InteractionArray.Length; i++ )
	{
		if (InteractionArray[i] == Inter)
		{
			iIndex = i;
			break;
		}
	}

	// Was it found?

	if (iIndex<0)
	{
		log("Interaction "$Inter$" is not in "$ViewportOwner$".",'IMaster');
		return;
	}
	else if (iIndex==0)
		return;					// Already has focus


	// Move it to the top.

	temp = InteractionArray[iIndex];
	for ( i=0; i<iIndex; i++)
		InteractionArray[i+1] = InteractionArray[i];

	InteractionArray[0] = temp;
	InteractionArray[0].bActive = true;		// Give it Input
	InteractionArray[0].bVisible = true;	// Make it visible

// << GEARBOX/jmw:modify - (see http://mail.epicgames.com/listarchive/showpost.php?list=unprog&id=28164)
	if (ViewportOwner != none)
		ViewportOwner.LocalInteractions = InteractionArray;
	else
		GlobalInteractions = InteractionArray;
// GEARBOX >>

} // SetFocusTo

// ====================================================================
// Input Functions
//
// The Process functions are here to limit the # of switches from C++ to Script.
// ====================================================================

event bool Process_KeyType( array<Interaction> InteractionArray, out EInputKey Key, optional string Unicode ) // Process a single key press
{
	local int Index;

	// Chain through the Interactions

	for ( Index=0; Index<InteractionArray.Length; Index++)
	{
		// Give each Interaction the chance to process the key event

		if ( ( InteractionArray[Index].bActive ) && (!InteractionArray[Index].bNativeEvents) && ( InteractionArray[Index].KeyType(key,Unicode) ) )
			return true;				// and break the chain if processed

	}
	return false;	// Keep processing

} // Process_KeyType

event bool Process_KeyEvent( array<Interaction> InteractionArray,
				out EInputKey Key, out EInputAction Action, FLOAT Delta ) // Process the range of input events
{
	local int Index;

	// Chain through the Interactions

	for ( Index=0; Index<InteractionArray.Length; Index++)
	{
		// Give each Interaction the chance to process the key event

		if ( ( InteractionArray[Index].bActive ) && (!InteractionArray[Index].bNativeEvents) && ( InteractionArray[Index].KeyEvent(Key, Action, Delta ) ) )
		{
			return true;						// and break the chain if processed
		}

	}
	return false;

} // Process_KeyEvent

// ====================================================================
// Render functions only occure on local interactions.  The process
// the array in reverse order so that the objects that have focus
// are drawn last.
// ====================================================================

event Process_PreRender( array<Interaction> InteractionArray, canvas Canvas )
{
	local int index;

	// Chain through the Interactions

	for ( Index=InteractionArray.Length; Index>0; Index--)	// Give each Interaction PreRender time
	{
		if ( (InteractionArray[Index-1].bVisible ) && (!InteractionArray[Index-1].bNativeEvents) )
			InteractionArray[Index-1].PreRender(canvas);
	}

} // Process_PreRender

event Process_PostRender( array<Interaction> InteractionArray, canvas Canvas )
{
	local int index;

	// Chain through the Interactions

	for ( Index=InteractionArray.Length; Index>0; Index--)	// Give each Interaction PreRender time
	{
		if ( (InteractionArray[Index-1].bVisible ) && (!InteractionArray[Index-1].bNativeEvents) )
			InteractionArray[Index-1].PostRender(canvas);
	}

} // Process_PostRender

// ====================================================================
// Tick - Interactions can request access to be ticked.
// ====================================================================

event Process_Tick( array<Interaction> InteractionArray, float DeltaTime )
{
	local int Index;

	// Chain through the Interactions

	for ( Index=0; Index<InteractionArray.Length; Index++)
	{
		// Give each Interaction that requires it tick

		if ( (InteractionArray[Index].bRequiresTick ) && (!InteractionArray[Index].bNativeEvents) )
			InteractionArray[Index].Tick(DeltaTime);
	}

}

// ====================================================================
// Message - The IM is responsible for sending Message events to all
// interactions.
// ====================================================================

event Process_Message( coerce string Msg, float MsgLife, array<Interaction> InteractionArray)
{
	local int Index;

	// Chain through the Interactions

	for ( Index=0; Index<InteractionArray.Length; Index++)
	{
		// Give each Interaction the message

		InteractionArray[Index].Message(Msg, MsgLife);
	}

} // Message

event bool WantsMergedInput(array<Interaction> InteractionArray)
{
	local int Index;
	for ( Index=0; Index<InteractionArray.Length; Index++)
	{
		if (InteractionArray[Index].WantsMergedInput())
			return true;
	}

	return false;
}

defaultproperties
{

}
// ====================================================================
//  Class:  Engine.Interactions
//
//  This is an abstract class for the interaction sub-system.  This new
//  sub-system is responsible for tunneling input and Pre/Post rendering
//  time to individual viewports and interactions.
//
// (c) 2001, Epic Games, Inc.  All Rights Reserved
// ====================================================================

class Interactions extends Object
		abstract
		native;



//-----------------------------------------------------------------------------
// Input.


// Input system states.
enum EInputAction
{
	IST_None,    // Not performing special input processing.
	IST_Press,   // Handling a keypress or button press.
	IST_Hold,    // Handling holding a key or button.
	IST_Release, // Handling a key or button release.
	IST_Axis,    // Handling analog axis movement.
    IST_Repeat,	 // This is a repeat Key in the Interactions
};

// Input keys.
enum EInputKey
{
/*00*/	IK_None			,IK_LeftMouse	,IK_RightMouse	,IK_Cancel		,
/*04*/	IK_MiddleMouse	,IK_Unknown05	,IK_Unknown06	,IK_Unknown07	,
/*08*/	IK_Backspace	,IK_Tab         ,IK_Unknown0A	,IK_Unknown0B	,
/*0C*/	IK_Unknown0C	,IK_Enter	    ,IK_Unknown0E	,IK_Unknown0F	,
/*10*/	IK_Shift		,IK_Ctrl	    ,IK_Alt			,IK_Pause       ,
/*14*/	IK_CapsLock		,IK_Unknown15	,IK_Unknown16	,IK_Unknown17	,
/*18*/	IK_Unknown18	,IK_Unknown19	,IK_Unknown1A	,IK_Escape		,
/*1C*/	IK_Unknown1C	,IK_Unknown1D	,IK_Unknown1E	,IK_Unknown1F	,
/*20*/	IK_Space		,IK_PageUp      ,IK_PageDown    ,IK_End         ,
/*24*/	IK_Home			,IK_Left        ,IK_Up          ,IK_Right       ,
/*28*/	IK_Down			,IK_Select      ,IK_Print       ,IK_Execute     ,
/*2C*/	IK_PrintScrn	,IK_Insert      ,IK_Delete      ,IK_Help		,
/*30*/	IK_0			,IK_1			,IK_2			,IK_3			,
/*34*/	IK_4			,IK_5			,IK_6			,IK_7			,
/*38*/	IK_8			,IK_9			,IK_Unknown3A	,IK_Unknown3B	,
/*3C*/	IK_Unknown3C	,IK_Unknown3D	,IK_Unknown3E	,IK_Unknown3F	,
/*40*/	IK_Unknown40	,IK_A			,IK_B			,IK_C			,
/*44*/	IK_D			,IK_E			,IK_F			,IK_G			,
/*48*/	IK_H			,IK_I			,IK_J			,IK_K			,
/*4C*/	IK_L			,IK_M			,IK_N			,IK_O			,
/*50*/	IK_P			,IK_Q			,IK_R			,IK_S			,
/*54*/	IK_T			,IK_U			,IK_V			,IK_W			,
/*58*/	IK_X			,IK_Y			,IK_Z			,IK_Unknown5B	,
/*5C*/	IK_Unknown5C	,IK_Unknown5D	,IK_Unknown5E	,IK_Unknown5F	,
/*60*/	IK_NumPad0		,IK_NumPad1     ,IK_NumPad2     ,IK_NumPad3     ,
/*64*/	IK_NumPad4		,IK_NumPad5     ,IK_NumPad6     ,IK_NumPad7     ,
/*68*/	IK_NumPad8		,IK_NumPad9     ,IK_GreyStar    ,IK_GreyPlus    ,
/*6C*/	IK_Separator	,IK_GreyMinus	,IK_NumPadPeriod,IK_GreySlash   ,
/*70*/	IK_F1			,IK_F2          ,IK_F3          ,IK_F4          ,
/*74*/	IK_F5			,IK_F6          ,IK_F7          ,IK_F8          ,
/*78*/	IK_F9           ,IK_F10         ,IK_F11         ,IK_F12         ,
/*7C*/	IK_F13			,IK_F14         ,IK_F15         ,IK_F16         ,
/*80*/	IK_F17			,IK_F18         ,IK_F19         ,IK_F20         ,
/*84*/	IK_F21			,IK_F22         ,IK_F23         ,IK_F24         ,
/*88*/	IK_Unknown88	,IK_Unknown89	,IK_Unknown8A	,IK_Unknown8B	,
/*8C*/	IK_Unknown8C	,IK_Unknown8D	,IK_Unknown8E	,IK_Unknown8F	,
/*90*/	IK_NumLock		,IK_ScrollLock  ,IK_Unknown92	,IK_Unknown93	,
/*94*/	IK_Unknown94	,IK_Unknown95	,IK_Unknown96	,IK_Unknown97	,
/*98*/	IK_Unknown98	,IK_Unknown99	,IK_Unknown9A	,IK_Unknown9B	,
/*9C*/	IK_Unknown9C	,IK_Unknown9D	,IK_Unknown9E	,IK_Unknown9F	,
/*A0*/	IK_LShift		,IK_RShift      ,IK_LControl    ,IK_RControl    ,
/*A4*/	IK_UnknownA4	,IK_UnknownA5	,IK_UnknownA6	,IK_UnknownA7	,
/*A8*/	IK_UnknownA8	,IK_UnknownA9	,IK_UnknownAA	,IK_UnknownAB	,
/*AC*/	IK_UnknownAC	,IK_UnknownAD	,IK_UnknownAE	,IK_UnknownAF	,
/*B0*/	IK_UnknownB0	,IK_UnknownB1	,IK_UnknownB2	,IK_UnknownB3	,
/*B4*/	IK_UnknownB4	,IK_UnknownB5	,IK_UnknownB6	,IK_UnknownB7	,
/*B8*/	IK_UnknownB8	,IK_Unicode		,IK_Semicolon	,IK_Equals		,
/*BC*/	IK_Comma		,IK_Minus		,IK_Period		,IK_Slash		,
/*C0*/	IK_Tilde		,IK_Mouse4		,IK_Mouse5		,IK_Mouse6		,
/*C4*/	IK_Mouse7		,IK_Mouse8		,IK_UnknownC6	,IK_UnknownC7	,
/*C8*/	IK_Joy1	        ,IK_Joy2	    ,IK_Joy3	    ,IK_Joy4	    ,
/*CC*/	IK_Joy5	        ,IK_Joy6	    ,IK_Joy7	    ,IK_Joy8	    ,
/*D0*/	IK_Joy9	        ,IK_Joy10	    ,IK_Joy11	    ,IK_Joy12		,
/*D4*/	IK_Joy13		,IK_Joy14	    ,IK_Joy15	    ,IK_Joy16	    ,
/*D8*/	IK_UnknownD8	,IK_UnknownD9	,IK_UnknownDA	,IK_LeftBracket	,
/*DC*/	IK_Backslash	,IK_RightBracket,IK_SingleQuote	,IK_UnknownDF	,
/*E0*/  IK_JoyX			,IK_JoyY		,IK_JoyZ		,IK_JoyR		,
/*E4*/	IK_MouseX		,IK_MouseY		,IK_MouseZ		,IK_MouseW		,
/*E8*/	IK_JoyU			,IK_JoyV		,IK_JoySlider1	,IK_JoySlider2	,
/*EC*/	IK_MouseWheelUp ,IK_MouseWheelDown,IK_Unknown10E,UK_Unknown10F  ,
/*F0*/	IK_JoyPovUp     ,IK_JoyPovDown	,IK_JoyPovLeft	,IK_JoyPovRight	,
/*F4*/	IK_UnknownF4	,IK_UnknownF5	,IK_Attn		,IK_CrSel		,
/*F8*/	IK_ExSel		,IK_ErEof		,IK_Play		,IK_Zoom		,
/*FC*/	IK_NoName		,IK_PA1			,IK_OEMClear
};



defaultproperties
{

}
//=============================================================================
// InternetInfo: Parent class for Internet connection classes
//=============================================================================
class InternetInfo extends Info
	native
	transient;



function string GetBeaconAddress( int i );
function string GetBeaconText( int i );

defaultproperties
{
}
//=============================================================================
// InterpolationPoint.
// Used as destinations to move the camera to in Matinee scenes.
//=============================================================================
class InterpolationPoint extends Keypoint
	native;



defaultproperties
{
     bDirectional=True
	 Texture=Texture'Engine.S_Interp'
}
//=============================================================================
// Inventory
//
// Inventory is the parent class of all actors that can be carried by other actors.
// Inventory items are placed in the holding actor's inventory chain, a linked list
// of inventory actors.  Each inventory class knows what pickup can spawn it (its
// PickupClass).  When tossed out (using the DropFrom() function), inventory items
// replace themselves with an actor of their Pickup class.
//
//=============================================================================
class Inventory extends Actor
	abstract
	native
	nativereplication;



//-----------------------------------------------------------------------------

var	 byte			InventoryGroup;     // The weapon/inventory set, 0-9.
var	 byte			GroupOffset;		// position within inventory group. (used by prevweapon and nextweapon)
var	 bool	 		bDisplayableInv;	// Item displayed in HUD.
var	 bool			bTossedOut;			// true if weapon/inventory was tossed out (so players can't cheat w/ weaponstay)
var  bool           bDropOnPawnDeath;   // GEARBOX - added so that multiplayer can drop game-important items on death 2004-05-10 JWS
var  bool			bCanHaveMultipleCopies;		// GBX:PAD: Moved this from Powerups because it makes life easier, and it doesn't cost any extra space
var	 class<Pickup>  PickupClass;		// what class of pickup is associated with this inventory item
var() travel int	Charge;				// Charge (for example, armor remaining if an armor)

//-----------------------------------------------------------------------------
// Rendering information.

// Player view rendering info.
var(FirstPerson)	 vector      PlayerViewOffset;   // Offset from view center.
var(FirstPerson)    rotator     PlayerViewPivot;    // additive rotation offset for tweaks
var() bool bDrawingFirstPerson;
var	 float		 BobDamping;		 // how much to damp view bob
var	 float		 ZoomBobDamping;	 // how much to damp view bob in zoomed view

// 3rd person mesh.
var actor 	ThirdPersonActor;
var class<InventoryAttachment> AttachmentClass;

//-----------------------------------------------------------------------------
// HUD graphics.

var	 Material Icon;
var  int		nIconX;
var  int		nIconY;
var  int		nIconW;
var  int		nIconH;

var	 Material StatusIcon;         // Icon used with ammo/charge/power count on HUD.
var	 localized string	 ItemName;
var	 localized string	 ItemDesc;

// Network replication.
replication
{
	// Things the server should send to the client.
	reliable if( bNetOwner && bNetDirty && (Role==ROLE_Authority) )
		Charge,ThirdPersonActor;
}

simulated function AttachToPawn(Pawn P, optional bool bDontInitAttachment)
{
	local name BoneName;

	// If the ThirdPersonActor is not set and we're a client in a multiplayer game, don't try to spawn this thing.
	if ((Level.NetMode == NM_Client) && (ThirdPersonActor == None))
	{
		return;
	}
	
	if ( ThirdPersonActor == None )
	{
		ThirdPersonActor = Spawn(AttachmentClass,Owner);
		InventoryAttachment(ThirdPersonActor).InitFor(self);
	}
	else
		ThirdPersonActor.NetUpdateTime = Level.TimeSeconds - 1;
	BoneName = P.GetWeaponBoneFor(self);
	if ( BoneName == '' )
	{
		ThirdPersonActor.SetLocation(P.Location);
		ThirdPersonActor.SetBase(P);
	}
	else
	{
		P.AttachToBone(ThirdPersonActor,BoneName);
	}
}

/* UpdateRelative()
For tweaking weapon positioning.  Pass in a new relativerotation, and use the weapon editactor
properties sheet to modify the relativelocation
*/
exec function updaterelative(int pitch, int yaw, int roll)
{
	local rotator NewRot;

	NewRot.Pitch = pitch;
	NewRot.Yaw = yaw;
	NewRot.Roll = roll;
	ThirdPersonActor.SetRelativeLocation(ThirdPersonActor.Default.RelativeLocation);
	ThirdPersonActor.SetRelativeRotation(NewRot);
}

simulated function DetachFromPawn(Pawn P)
{
	if ( ThirdPersonActor != None )
	{
		ThirdPersonActor.Destroy();
		ThirdPersonActor = None;
	}
}

/* RenderOverlays() - Draw first person view of inventory
Most Inventory actors are never rendered.  The common exception is Weapon actors.
Inventory actors may be rendered in the first person view of the player holding them
using the RenderOverlays() function.
*/
simulated event RenderOverlays( canvas Canvas )
{
	if ( (Instigator == None) || (Instigator.Controller == None))
		return;
	SetLocation( Instigator.Location + Instigator.CalcDrawOffset(self) );
	SetRotation( Instigator.GetViewRotation() );
	Canvas.DrawActor(self);
}

simulated function String GetHumanReadableName()
{
	if ( ItemName == "" )
		ItemName = GetItemName(string(Class));

	return ItemName;
}

function PickupFunction(Pawn Other);

//=============================================================================
// AI inventory functions.
simulated function Weapon RecommendWeapon( out float rating, optional bool bForceIfLast )
{
	if ( inventory != None )
		return inventory.RecommendWeapon(rating, bForceIfLast);
	else
	{
		rating = -1;
		return None;
	}
}

//=============================================================================
// Inventory travelling across servers.

//
// Called after a travelling inventory item has been accepted into a level.
//
event TravelPreAccept()
{
	Super.TravelPreAccept();
	GiveTo( Pawn(Owner) );
}

function TravelPostAccept()
{
	Super.TravelPostAccept();
	PickupFunction(Pawn(Owner));
}

//=============================================================================
// General inventory functions.

//
// Called by engine when destroyed.
//
function Destroyed()
{
	// Remove from owner's inventory.
	if( Pawn(Owner) != None )
		Pawn(Owner).DeleteInventory( Self );

	if ( ThirdPersonActor != None )
		ThirdPersonActor.Destroy();

	Instigator = None;

	super.Destroyed();
}

//
// Give this inventory item to a Pawn.
//
function bool GiveTo( Pawn Other, optional Pickup Pickup )
{
	Instigator = Other;
	if ( Other.AddInventory( Self ) )
	{
		GotoState('');
		return true;
	}
	else
	{
		Destroy();
		return false;
	}
}

//
// Function which lets existing items in a Pawn's inventory
// prevent the Pawn from picking something up. Return true to abort pickup
// or if item handles pickup, otherwise keep going through inventory list.
//
function bool HandlePickupQuery( pickup Item )
{
	if ( Item.InventoryType == Class )
		return true;
	if ( Inventory == None )
		return false;

	return Inventory.HandlePickupQuery(Item);
}

//
// Select first activatable powerup.
//
function Powerups SelectNext()
{
	if ( Inventory != None )
		return Inventory.SelectNext();
	else
		return None;
}

//
// Toss this item out.
//
function DropFrom(vector StartLocation)
{
	local Pickup P;

	if ( Instigator != None )
	{
		DetachFromPawn(Instigator);
		Instigator.DeleteInventory(self);
	}
	
	SetDefaultDisplayProperties();
	Instigator = None;
	StopAnimating();
	GotoState('');

	if( PickupClass != None )
	{
		P = spawn(PickupClass,,,StartLocation);
		if ( P == None )
		{
			Log(self $ " Inventory::DropFrom() Uhoh, failed to spawn!!!!!!!!!", 'JWS');
			destroy();
			return;
		}

		P.InitDroppedPickupFor(self);
		P.Velocity = Velocity;
	}
	
	Velocity = vect(0,0,0);
}

//=============================================================================
// Using.

function Use( float Value );

//=============================================================================
// Weapon functions.

// Find a weapon in inventory that has an Inventory Group matching F.

simulated function Weapon WeaponChange( byte F, bool bSilent, optional Inventory LastCheck )
{
    if ( LastCheck == self )
        return None;
	else if( Inventory == None)
		return None;
	else
		return Inventory.WeaponChange( F, bSilent, LastCheck );
}

// Find the previous weapon (using the Inventory group)
simulated function Weapon PrevWeapon(Weapon CurrentChoice, Weapon CurrentWeapon)
{
	if ( Inventory == None )
		return CurrentChoice;
	else
		return Inventory.PrevWeapon(CurrentChoice,CurrentWeapon);
}

// Find the next weapon (using the Inventory group)
simulated function Weapon NextWeapon(Weapon CurrentChoice, Weapon CurrentWeapon)
{
	if ( Inventory == None )
		return CurrentChoice;
	else
		return Inventory.NextWeapon(CurrentChoice,CurrentWeapon);
}

//=============================================================================
// Armor functions.

//
// Return the best armor to use.
//
function armor PrioritizeArmor( int Damage, class<DamageType> DamageType, vector HitLocation )
{
	local Armor FirstArmor;

	if ( Inventory != None )
		FirstArmor = Inventory.PrioritizeArmor(Damage, DamageType, HitLocation);
	else
		FirstArmor = None;

	return FirstArmor;
}

//
// Used to inform inventory when owner event occurs (for example jumping or weapon change)
//
function OwnerEvent(name EventName)
{
	if( Inventory != None )
		Inventory.OwnerEvent(EventName);
}

// used to ask inventory if it needs to affect its owners display properties
function SetOwnerDisplay()
{
	if( Inventory != None )
		Inventory.SetOwnerDisplay();
}

static function string StaticItemName()
{
	return Default.ItemName;
}


defaultproperties
{
	bOnlyDirtyReplication=true
	bOnlyRelevantToOwner=true
	AttachmentClass=class'InventoryAttachment'
    BobDamping=0.960000
    bTravel=True
    DrawType=DT_None
    AmbientGlow=0
    RemoteRole=ROLE_SimulatedProxy
	NetPriority=1.4
	bOnlyOwnerSee=true
	bHidden=true
	bClientAnim=true
	Physics=PHYS_None
	bReplicateMovement=false
	bAcceptsProjectors=True
    bDrawingFirstPerson=false
	bDropOnPawnDeath=false // GEARBOX - 2004-05-10 JWS
	bCanHaveMultipleCopies=false
}

class InventoryAttachment extends Actor
	native
	nativereplication;

cpptext
{
	INT* GetOptimizedRepList( BYTE* Recent, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel );
}

var bool bFastAttachmentReplication; // only replicates the subset of actor properties needed by basic attachments whose 
									 // common properties don't vary from their defaults

// ====================================================================
// GetFOVLocation - Returns a 3D world space coordinate for the given
// Location in the current FOV if the instigators view were a different FOV
// ====================================================================
simulated native function vector GetFOVLocation( vector Location, float NewFOV );

function InitFor(Inventory I)
{
	Instigator = I.Instigator;
}

defaultproperties
{
	bOnlyDrawIfAttached=true
	NetUpdateFrequency=10
	DrawType=DT_Mesh
	RemoteRole=ROLE_SimulatedProxy
	bAcceptsProjectors=True
	bUseLightingFromBase=True
    bOnlyDirtyReplication=true
    bDisableSorting=true
	bFastAttachmentReplication=true
}
//=============================================================================
// InventorySpot.
//=============================================================================
class InventorySpot extends SmallNavigationPoint
	native;



cpptext
{
	virtual UBOOL IsIdentifiedAs(FName ActorName);
    virtual AInventorySpot* GetAInventorySpot() { return this; }
}

var Pickup markedItem;

/* GetMoveTargetFor()
Possibly return pickup rather than self as movetarget
*/
function ActorLite GetMoveTargetFor(AIController B, float MaxWait)
{
	if ( (markedItem != None) && markedItem.ReadyToPickup(MaxWait) && (B.Desireability(markedItem) > 0) )
		return markedItem;

	return self;
}

/* DetourWeight()
value of this path to take a quick detour (usually 0, used when on route to distant objective, but want to grab inventory for example)
*/
event float DetourWeight(Pawn Other,float PathWeight)
{
	if ( (markedItem != None) && markedItem.ReadyToPickup(0) )
		return markedItem.DetourWeight(Other,PathWeight);
}

defaultproperties
{
     bCollideWhenPlacing=False
	 bHiddenEd=true
}
class ISeeAndSuppressCache extends Object
	native
	transient;


cpptext
{
	virtual void NativeInitialize();
}
//=============================================================================
// JumpDest.
// specifies positions that can be reached with greater than normal jump
// forced paths will check for greater than normal jump capability
// NOTE these have NO relation to JumpPads
//=============================================================================
class JumpDest extends NavigationPoint
	native;



cpptext
{
	virtual void SetupForcedPath(APawn* Scout, UReachSpec* Path);
	void ClearPaths();
	UBOOL ReviewPath(APawn* Scout);
}

var bool bOptionalJumpDest;
var int NumUpstreamPaths;
var ReachSpec UpstreamPaths[8];
var vector NeededJump[8];
var float CalculatedGravityZ[8];

function int GetPathIndex(ReachSpec Path)
{
	local int i;

	if ( Path == None )
		return 0;

	for ( i=0; i<4; i++ )
		if ( UpstreamPaths[i] == Path )
			return i;
	return 0;
}

event int SpecialCost(Pawn Other, ReachSpec Path)
{
	local int Num;

	Num = GetPathIndex(Path);
	if ( Abs(Other.JumpZ/Other.PhysicsVolume.Gravity.Z) >= Abs(NeededJump[Num].Z/CalculatedGravityZ[Num]) )
		return 100;

	return 10000000;
}

function DoJump(Pawn Other)
{
	Other.bWantsToCrouch = false;
	Other.Controller.MoveTarget = self;
	Other.Controller.Destination = Location;
	Other.bNoJumpAdjust = true;
	Other.Velocity = Other.Controller.EAdjustJump(0,Other.GroundSpeed);
	Other.Acceleration = vect(0,0,0);
	Other.SetPhysics(PHYS_Falling);
	Other.Controller.SetFall();
	Other.DestinationOffset = CollisionRadius;
}

event bool SuggestMovePreparation(Pawn Other)
{
	local int Num;
	if ( Other.Controller == None )
		return false;

	Num = GetPathIndex(Other.Controller.CurrentPath);
	if ( Abs(Other.JumpZ/Other.PhysicsVolume.Gravity.Z) < Abs(NeededJump[Num].Z/CalculatedGravityZ[Num]) )
		return false;

	DoJump(Other);
	return false;
}

defaultproperties
{
	bSpecialForced=true
}
//=============================
// Jumppad - bounces players/bots up
// not directly placeable.  Make a subclass with appropriate sound effect etc.
//
class JumpPad extends NavigationPoint
	native;



var vector JumpVelocity;
var Actor JumpTarget;
var() float JumpZModifier;	// for tweaking Jump, if needed
var() sound JumpSound;

cpptext
{
	void addReachSpecs(APawn * Scout, UBOOL bOnlyChanged);
	void RenderEditorSelected(FLevelSceneNode* SceneNode,FRenderInterface* RI, FDynamicActor* FDA);
}

function PostBeginPlay()
{
	local NavigationPoint N;

	Super.PostBeginPlay();
	ForEach AllActors(class'NavigationPoint', N)
		if ( (N != self) && NearSpot(N.Location) )
			N.ExtraCost += 1000;
}

event Touch(Actor Other)
{
	if ( Pawn(Other) == None )
		return;

	PendingTouch = Other.PendingTouch;
	Other.PendingTouch = self;
}

event PostTouch(Actor Other)
{
	local Pawn P;

	P = Pawn(Other);
	if ( P == None )
		return;

	if ( AIController(P.Controller) != None )
	{
		P.Controller.Movetarget = JumpTarget;
		P.Controller.Focus = JumpTarget;
		if ( P.Physics != PHYS_Flying )
		P.Controller.MoveTimer = 2.0;
		P.DestinationOffset = JumpTarget.CollisionRadius;
	}
	if ( P.Physics == PHYS_Walking )
		P.SetPhysics(PHYS_Falling);
	P.Velocity =  JumpVelocity;
	P.Acceleration = vect(0,0,0);
	if ( JumpSound != None )
		P.PlaySound(JumpSound);
}

defaultproperties
{
	bDestinationOnly=true
	bCollideActors=true
	JumpVelocity=(x=0.0,y=0.0,z=1200.0)
	JumpZModifier=+1.0
}
//*********************************************************
// KarmaActor.uc
//
// Author: Epic
//
// Just a handy class to derive off to make physics objects.
//
//*********************************************************
class KActor extends Actor
	native
	placeable;


cpptext
{
	virtual void Spawned();
}

//---------------------------------------------------------
// Properties
//---------------------------------------------------------
var (Karma)		bool		bKTakeShot;
var (Karma)		bool		bTriggerOnce;
var (Sound)		String		ImpactCueName;
var (Karma)		float		ImpactVelocityThreshold;
var (Sound)		float		ImpactSoundInterval;

var Cue		ImpactCue;
var float	NextImpactTime;
var bool	bTriggered;

//*********************************************************
//	PostBeginPlay
//*********************************************************
function PostBeginPlay()
{
	Super.PostBeginPlay();
}

//*********************************************************
//	TakeDamage
//*********************************************************
// Default behaviour when shot is to apply an impulse and kick the KActor.
//
function TakeDamage(int Damage, Pawn instigatedBy, Vector hitlocation,
						Vector momentum, class<DamageType> damageType, optional name HitBoxName)
{
	local vector ApplyImpulse;

	//Log("TakeDamage: "$self);

	if (Event != '')
	{
		if (!bTriggerOnce || !bTriggered)
		{
			bTriggered = true;

			TriggerEvent(Event, self, None);
		}
	}

	if(bKTakeShot && damageType.default.KDamageImpulse > 0)
	{
		if(VSize(momentum) < 0.001)
		{
			// DEBUG
			//Log("Zero momentum to KActor.TakeDamage");
			// END DEBUG
			return;
		}

		ApplyImpulse = Normal(momentum) * damageType.default.KDamageImpulse;
		KAddImpulse(ApplyImpulse, hitlocation);
	}
}

//*********************************************************
//	Trigger
//*********************************************************
//
// Default behaviour when triggered is to wake up the physics.
function Trigger( actor Other, Pawn EventInstigator )
{
	KWake();
}

//*********************************************************
//	KImpact
//*********************************************************
event KImpact(actor other, vector pos, vector impactVel, vector impactNorm)
{
	if( VSize(impactVel) > ImpactVelocityThreshold )
	{
		if( ImpactCue == None && ImpactCueName != "" )
		{
			ImpactCue = LoadSound( ImpactCueName );
		}

		if( ImpactCue != None && Level.TimeSeconds + ImpactSoundInterval > NextImpactTime )
		{
			NextImpactTime = Level.TimeSeconds + ImpactSoundInterval;
			PlaySoundCue( ImpactCue, SLOT_None,,,,,);
		}
	}
}

//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
	bKTakeShot=true;
	DrawType=DT_StaticMesh
	//StaticMesh=StaticMesh'MiscPhysicsMeshes.Barrels.Barrel1'
    Physics=PHYS_Karma
	bEdShouldSnap=True
	bStatic=False
	bShadowCast=False
	bCollideActors=True
	bCollideWorld=False
    bProjTarget=True
	bBlockActors=True
	bBlockNonZeroExtentTraces=True
	bBlockZeroExtentTraces=True
	bBlockPlayers=True
	bWorldGeometry=False
	bBlockKarma=True
	bAcceptsProjectors=True
    CollisionHeight=+000001.000000
	CollisionRadius=+000001.000000
	bNoDelete=true
	RemoteRole=ROLE_None
	bTriggerOnce=true
	bTriggered=false
	ImpactSoundInterval=0.5
	ImpactVelocityThreshold=100.0
}

//=============================================================================
// The Karma physics parameters class.
// This provides 'extra' parameters needed by Karma physics to the Actor class.
// Need one of these (or a subclass) to set Physics to PHYS_Karma.
// (see Actor.uc)
// NB: All parameters are in KARMA scale!
//=============================================================================

class KarmaParams extends KarmaParamsCollision
	editinlinenew
	native;



cpptext
{
#ifdef WITH_KARMA
    void PostEditChange();
	void Destroy();
#endif
}

// Used internally for Karma stuff - DO NOT CHANGE!
var transient const int		KAng3;
var transient const int		KTriList;
var transient const float   KLastVel;

var()    float   KMass;						// Mass used for Karma physics
var()    float   KLinearDamping;			// Linear velocity damping (drag)
var()    float   KAngularDamping;			// Angular velocity damping (drag)

var()	 float   KBuoyancy;					// Applies in water volumes. 0 = no buoyancy. 1 = neutrally buoyant

var()    bool    KStartEnabled;				// Start simulating body as soon as PHYS_Karma starts
var()    vector  KStartLinVel;				// Initial linear velocity for actor
var()    vector  KStartAngVel;              // Initial angular velocity for actor

var()	 bool	 bKNonSphericalInertia;		// Simulate body without using sphericalised inertia tensor

var()	 float   KActorGravScale;		    // Scale how gravity affects this actor.

var()	 float   KVelDropBelowThreshold;    // Threshold that when actor drops below, KVelDropBelow event is triggered.

var()    float   KMaxSpeed;                 // Maximum allowed speed (unreal units)
var()	 float	 KMaxAngularSpeed;			// Maximum allowed angular velocity (radians per sec).

// NB - the below settings only apply to PHYS_Karma (not PHYS_KarmaRagDoll)
var()	 bool    bHighDetailOnly;			// Only turn on karma physics for this actor if the level PhysicsDetailLevel is PDL_High
var      bool    bClientOnly;				// Only turn on karma physics for this actor on the client (not server).
var() const bool bKDoubleTickRate;			// Allows higher karma sim rate (double normal) for some objects.

var()	 bool	 bKStayUpright;				// Stop this object from being able to rotate (using Angular3 constraint)
var()	 bool	 bKAllowRotate;				// Allow this object to rotate about a vertical axis. Ignored unless KStayUpright == true.
var		 bool	 bDestroyOnSimError;		// If there is a problem with the physics, destroy, or leave around to be fixed (eg. by network).
var()	 bool	 bDestroyOnWorldPenetrate;  // If the center of this object passes through the world, destroy it.
var()	 bool	 bDoSafetime;				// If true, do extra checks to avoid object passing through world.
var()	 float	 SafetimeVelThresholdSquared; // Squared velocity where safe time will begin to be applied.  Required bDoSafetime = true.

var()	 float   StayUprightStiffness;
var()	 float   StayUprightDamping;

var()	array<KRepulsor>	Repulsors;

// default is sphere with mass 1 and radius 1
defaultproperties
{
    KMass=1
    KAngularDamping=0.2
    KLinearDamping=0.2
	KStartEnabled=false
	bKStayUpright=false
	bKAllowRotate=false
	bKNonSphericalInertia=false
	bKDoubleTickRate=true
	KBuoyancy=0
	KMaxSpeed=2500.0
	KMaxAngularSpeed=10.0
	bClientOnly=1
	bHighDetailOnly=1
	KActorGravScale=1
	KVelDropBelowThreshold=1000000
	bDestroyOnSimError=True
	bDestroyOnWorldPenetrate=False
	StayUprightStiffness=50
	StayUprightDamping=0
	SafetimeVelThresholdSquared=65536.0
}
//=============================================================================
// The Karma Collision parameters class.
// This provides 'extra' parameters needed to create Karma collision for this Actor.
// You can _only_ turn on collision, not dynamics.
// NB: All parameters are in KARMA scale!
//=============================================================================

class KarmaParamsCollision extends Object
	editinlinenew
	native;

cpptext
{
#ifdef WITH_KARMA
	void CalcContactRegion();
#endif
}

// Used internally for Karma stuff - DO NOT CHANGE!
var const transient int				KarmaData;

var const float				KScale;  // Usually kept in sync with actor's DrawScale, this is how much to scale moi/com-offset (but not mass!)
var const vector			KScale3D;

var      vector  KAcceleration;      // Instantaneous acceleration.

var()    float   KFriction;          // Multiplied pairwise to get contact friction
var()    float   KRestitution;       // 'Bouncy-ness' - Normally between 0 and 1. Multiplied pairwise to get contact restitution.
var()    float   KImpactThreshold;   // threshold velocity magnitude to call KImpact event

var	  const bool bContactingLevel;	 // This actor currently has contacts with some level geometry (bsp, static mesh etc.). OUTPUT VARIABLE.

// OUTPUT. The 'contact region' below refers to collision against the world, not between dynamics bodies. Use CalcContactRegion to update.
var		 const vector	 ContactRegionCenter;
var		 const vector  ContactRegionNormal;
var		 const float	 ContactRegionRadius;
var		 const float	 ContactRegionNormalForce;

native function CalcContactRegion(); // Fills in ContactRegion variables above. Will do nothing if bContactingLevel is false.

// default is sphere with mass 1 and radius 1
defaultproperties
{
    KFriction=0
	KRestitution=0
    KImpactThreshold=1000000
	KScale=1
	KScale3D=(X=1,Y=1,Z=1)
}
//=============================================================================
// This is the full set of Karma parameters, including inertia tensor and
// centre-of-mass position, which are normally stored with the StaticMesh.
// This gives you a chance to overrids these values.
// NB: All parameters are in KARMA scale!
//=============================================================================

class KarmaParamsRBFull extends KarmaParams
	editinlinenew
	native;



// Inertia tensor of object assuming a mass of 1 - symmetric so just store 6 elements:
// (0 1 2)
// (1 3 4)
// (2 4 5)
// This will be scaled by the mass of the object to work out its actual inertia tensor.
var()    float   KInertiaTensor[6];
var()    vector  KCOMOffset;         // Position of centre of mass in body ref. frame

// default is sphere with radius 1
defaultproperties
{
    KInertiaTensor(0)=0.4
    KInertiaTensor(1)=0.0
    KInertiaTensor(2)=0.0
    KInertiaTensor(3)=0.4
    KInertiaTensor(4)=0.0
    KInertiaTensor(5)=0.4
    KCOMOffset=(X=0,Y=0,Z=0)
}
//=============================================================================
// The Karma physics parameter specific to skeletons.
// NB: All parameters are in KARMA scale!
//=============================================================================

class KarmaParamsSkel extends KarmaParams
	editinlinenew
	native;



var() string KSkeleton;				// Karma Asset to use for this skeleton.

var() bool   bKDoConvulsions;
var() bool	 bRubbery; 
var() range  KConvulseSpacing;		// Time between convulsions.

// When the skeletal physics starts up, we check this line against the skeleton,
// and apply an impulse with magnitude KShotStrength if we hit a bone.
// This has to be deferred  because ragdoll-startup is.
var transient vector KShotStart;
var transient vector KShotEnd;
var transient float  KShotStrength;
var transient bool	 bKImportantRagdoll; // This indicates this ragdoll will not be recycled during KMakeRagdollAvailable

defaultproperties
{
	KConvulseSpacing=(Min=0.5,Max=1.5)
	bKDoConvulsions=False
	KMaxSpeed=2500.0
}
//=============================================================================
// The Ball-and-Socket joint class.
//=============================================================================

class KBSJoint extends KConstraint
    native
    placeable;



defaultproperties
{
    Texture=Texture'Engine.S_KBSJoint'
}
// Base class for 4-wheeled vehicles using Karma
// Assumes negative-X is forward, negative-Y is right
class KCar extends KVehicle
	native
	abstract;



var KTire frontLeft, frontRight, rearLeft, rearRight;
var (KCar) class<KTire> FrontTireClass;
var (KCar) class<KTire> RearTireClass;

// Wheel positions
var const float WheelFrontAlong;
var const float WheelFrontAcross;
var const float WheelRearAlong;
var const float WheelRearAcross;
var const float WheelVert;

var (KCar) float       MaxSteerAngle;   // (65535 = 360 deg)
var (KCar) float       MaxBrakeTorque;  // Braking torque applied to all four wheels. Positive only.
var (KCar) float       TorqueSplit;     // front/rear drive torque split. 1 is fully RWD, 0 is fully FWD. 0.5 is standard 4WD.


// KCarWheelJoint setting for steering (see KCarWheelJoint). Duplicated here for handiness.
var (KCar) float       SteerPropGap;
var (KCar) float       SteerTorque;
var (KCar) float       SteerSpeed;

// KCarWheelSuspension setting
var (KCar) float       SuspStiffness;
var (KCar) float       SuspDamping;
var (KCar) float       SuspHighLimit;
var (KCar) float       SuspLowLimit;
var (KCar) float       SuspRef;

// KTire settings. Duplicated here for handy tuning.
var (KCar) float       TireRollFriction;
var (KCar) float       TireLateralFriction;
var (KCar) float       TireRollSlip;
var (KCar) float       TireLateralSlip;
var (KCar) float       TireMinSlip;
var (KCar) float       TireSlipRate;
var (KCar) float       TireSoftness;
var (KCar) float       TireAdhesion;
var (KCar) float       TireRestitution;
var (KCar) float       TireMass;

var (KCar) float	   HandbrakeThresh; // speed above which handbrake comes on =]
var (KCar) float	   TireHandbrakeSlip; // Additional lateral slip when handbrake engaged
var (KCar) float	   TireHandbrakeFriction; // Additional lateral friction when handbrake engaged

var (KCar) float       ChassisMass;

var (KCar) float	   StopThreshold; // Forward velocity under which brakes become drive.

var (KCar) InterpCurve	TorqueCurve; // Engine RPM in, Torque out.

var (KCar) float		FlipTorque;
var (KCar) float		FlipTime;

var (KCar) float		MaxNetUpdateInterval;

var int      Gear;  // 1 is forward, -1 is backward. Currently symmetric power/torque curve

// Car output
var float              WheelSpinSpeed;  // Current (averaged) RPM of rear wheels
var float			   ForwardVel;		// Component of cars velocity in its forward direction.
var bool			   bIsInverted;     // Updated in Tick - indicates if car is not upright.

// Internal
var bool			   IsDriving;
var float			   FlipTimeLeft;
var float			   NextNetUpdateTime;	// Next time we should force an update of vehicles state.

// Low-level drive data (this is replicated)
var bool			   OutputBrake;
var float			   OutputTorque;
var bool			   OutputHandbrakeOn;


// Networking
var KRigidBodyState		ChassisState;

var KCarState			CarState; // This is replicated to the car, and processed to update all the parts.
var bool				bNewCarState; // Indicated there is new data processed, and chassis RBState should be updated.

replication
{
	// We replicate the Gear for brake-lights etc.
	unreliable if(Role == ROLE_Authority)
		CarState, Gear;

	reliable if(Role == ROLE_Authority)
		FlipTimeLeft;
}

// When new information is received, see if its new. If so, pass bits off the the wheels.
// Each part will then update its rigid body position via the KUpdateState event.
// JTODO: This is where clever unpacking would happen.
simulated event VehicleStateReceived()
{
	local vector ChassisY, SteerY, ChassisZ, calcPos, WheelY, lPos;
	local vector chassisPos, chassisLinVel, chassisAngVel, WheelLinVel, wPosRel;
	local Quat relQ, WheelQ;

	if(!CarState.bNewState)
		return;

	// Don't do anything if car isn't started up.
	if(frontLeft == None || frontRight == None || rearLeft == None || rearRight == None)
		return;

	// Get root chassis info
	ChassisState.Position = CarState.ChassisPosition;
	ChassisState.Quaternion = CarState.ChassisQuaternion;
	ChassisState.LinVel = CarState.ChassisLinVel;
	ChassisState.AngVel = CarState.ChassisAngVel;

	chassisPos = KRBVecToVector(CarState.ChassisPosition);
	chassisLinVel = KRBVecToVector(CarState.ChassisLinVel);
	chassisAngVel = KRBVecToVector(CarState.ChassisAngVel);

	// Calc chassis state axes
	ChassisY = QuatRotateVector(CarState.ChassisQuaternion, vect(0, 1, 0));
	ChassisZ = QuatRotateVector(CarState.ChassisQuaternion, vect(0, 0, 1));

	// Get root chassis info
	ChassisState.Position = CarState.ChassisPosition;
	ChassisState.Quaternion = CarState.ChassisQuaternion;
	ChassisState.LinVel = CarState.ChassisLinVel;
	ChassisState.AngVel = CarState.ChassisAngVel;


	// Figure out new state of wheels

	// Wheel positions are only supplied with a chassis-space Z (vertical) value - X and Y are assumed no to change
	// Rear wheel orientations are not supplied. The only constraint is their Y-axis (axle) is parallel to
	// the chassis Y-axis. A quaternion is calculated to go from current orientation to fulfil that criteria, which
	// should produce minimum difference to the 'roll' of the wheel - which is allowed to differ on server and client.
	// For front wheel we do send the current 'steering' angle. That is added after the above process as a quaternion
	// around chassis Z (up).
	// For linear velocity of wheels - calculate based on linear and angular velocity of chassis, and add on vertical
	// component sent over the net.

	////////////////////////// FRONT LEFT //////////////////////////
	frontLeft.KGetRigidBodyState(frontLeft.ReceiveState);

	// Position
	lPos.X = WheelFrontAlong;
	lPos.Y = WheelFrontAcross;
	lPos.Z = CarState.WheelHeight[0];
	calcPos = chassisPos + QuatRotateVector(CarState.ChassisQuaternion, lPos); // Convert from chassis state to world space
	frontLeft.ReceiveState.Position = KRBVecFromVector(calcPos);

	// Rotation
	wheelQ = frontLeft.KGetRBQuaternion();
	WheelY = QuatRotateVector(wheelQ, vect(0, 1, 0));
	SteerY = QuatRotateVector( QuatFromAxisAndAngle(ChassisZ, CarState.FrontWheelAng[0]), ChassisY );
	relQ = QuatFindBetween(WheelY, SteerY);
	frontLeft.ReceiveState.Quaternion = QuatProduct(relQ, wheelQ);

	// Velocity
	wPosRel = calcPos - chassisPos;
	WheelLinVel = chassisLinVel + (chassisAngVel Cross wPosRel);
	WheelLinVel += CarState.WheelVertVel[0] * ChassisZ;
	frontLeft.ReceiveState.LinVel = KRBVecFromVector(WheelLinVel);

	//frontLeft.ReceiveState.AngVel = KRBVecFromVector(chassisAngVel + (WheelY * CarState.WheelSpinVel[0]));

	frontLeft.bReceiveStateNew = true;

	////////////////////////// FRONT RIGHT //////////////////////////
	frontRight.KGetRigidBodyState(frontRight.ReceiveState);

	// Position
	lPos.X = WheelFrontAlong;
	lPos.Y = -WheelFrontAcross;
	lPos.Z = CarState.WheelHeight[1];
	calcPos = chassisPos + QuatRotateVector(CarState.ChassisQuaternion, lPos);
	frontRight.ReceiveState.Position = KRBVecFromVector(calcPos);


	// Rotation
	wheelQ = frontRight.KGetRBQuaternion();
	WheelY = QuatRotateVector(wheelQ, vect(0, 1, 0));
	SteerY = QuatRotateVector( QuatFromAxisAndAngle(ChassisZ, CarState.FrontWheelAng[1]), ChassisY );
	relQ = QuatFindBetween(WheelY, SteerY);
	frontRight.ReceiveState.Quaternion = QuatProduct(relQ, wheelQ);

	// Velocity
	wPosRel = calcPos - chassisPos;
	WheelLinVel = chassisLinVel + (chassisAngVel Cross wPosRel);
	WheelLinVel += CarState.WheelVertVel[1] * ChassisZ;
	frontRight.ReceiveState.LinVel = KRBVecFromVector(WheelLinVel);

	//frontRight.ReceiveState.AngVel = KRBVecFromVector(chassisAngVel + (WheelY * CarState.WheelSpinVel[1]));

	frontRight.bReceiveStateNew = true;

	////////////////////////// REAR LEFT //////////////////////////
	rearLeft.KGetRigidBodyState(rearLeft.ReceiveState);

	// Position
	lPos.X = WheelRearAlong;
	lPos.Y = WheelFrontAcross;
	lPos.Z = CarState.WheelHeight[2];
	calcPos = chassisPos + QuatRotateVector(CarState.ChassisQuaternion, lPos);
	rearLeft.ReceiveState.Position = KRBVecFromVector(calcPos);


	// Rotation
	wheelQ = rearLeft.KGetRBQuaternion();
	WheelY = QuatRotateVector(wheelQ, vect(0, 1, 0));
	relQ = QuatFindBetween(WheelY, ChassisY);
	rearLeft.ReceiveState.Quaternion = QuatProduct(relQ, wheelQ);

	// Velocity
	wPosRel = calcPos - chassisPos;
	WheelLinVel = chassisLinVel + (chassisAngVel Cross wPosRel);
	WheelLinVel += CarState.WheelVertVel[2] * ChassisZ;
	rearLeft.ReceiveState.LinVel = KRBVecFromVector(WheelLinVel);

	//rearLeft.ReceiveState.AngVel = KRBVecFromVector(chassisAngVel + (WheelY * CarState.WheelSpinVel[2]));

	rearLeft.bReceiveStateNew = true;

	////////////////////////// REAR RIGHT //////////////////////////
	rearRight.KGetRigidBodyState(rearRight.ReceiveState);

	// Position
	lPos.X = WheelRearAlong;
	lPos.Y = -WheelFrontAcross;
	lPos.Z = CarState.WheelHeight[3];
	calcPos = chassisPos + QuatRotateVector(CarState.ChassisQuaternion, lPos);
	rearRight.ReceiveState.Position = KRBVecFromVector(calcPos);

	// Rotation
	wheelQ = rearRight.KGetRBQuaternion();
	WheelY = QuatRotateVector(wheelQ, vect(0, 1, 0));
	relQ = QuatFindBetween(WheelY, ChassisY);
	rearRight.ReceiveState.Quaternion = QuatProduct(relQ, wheelQ);

	// Velocity
	wPosRel = calcPos - chassisPos;
	WheelLinVel = chassisLinVel + (chassisAngVel Cross wPosRel);
	WheelLinVel += CarState.WheelVertVel[3] * ChassisZ;
	rearRight.ReceiveState.LinVel = KRBVecFromVector(WheelLinVel);

	//rearRight.ReceiveState.AngVel = KRBVecFromVector(chassisAngVel + (WheelY * CarState.WheelSpinVel[3]));

	rearRight.bReceiveStateNew = true;

	////// OTHER //////

	// Update control inputs
	Steering = CarState.ServerSteering;
	OutputTorque = CarState.ServerTorque;
	OutputBrake = CarState.ServerBrake;
	OutputHandbrakeOn = CarState.ServerHandbrakeOn;

	// Update flags
	CarState.bNewState = false;
	bNewCarState = true;

	// For debugging...
	//KDrawRigidBodyState(ChassisState, false);
	//KDrawRigidBodyState(frontLeft.ReceiveState, false);
	//KDrawRigidBodyState(frontRight.ReceiveState, false);
	//KDrawRigidBodyState(rearLeft.ReceiveState, false);
	//KDrawRigidBodyState(rearRight.ReceiveState, false);
}

// This only update the chassis. The wheels update themselves.
simulated event bool KUpdateState(out KRigidBodyState newState)
{
	// This should never get called on the server - but just in case!
	if(Role == ROLE_Authority || !bNewCarState)
		return false;

	// Apply received data as new position of car chassis.
	newState = ChassisState;
	bNewCarState = false;

	return true;
	//return false;
}

// Pack current state of whole car into the state struct, to be sent to the client.
// Should only get called on the server.
function PackState()
{
	local vector lPos, wPos, chassisPos, chassisLinVel, chassisAngVel, wPosRel, WheelLinVel;
	local vector ChassisX, ChassisZ, WheelY, OldPos, OldLinVel;
	local KRigidBodyState ChassisState, WheelState;

	// Get chassis state.
	KGetRigidBodyState(ChassisState);

	chassisPos = KRBVecToVector(ChassisState.Position);
	chassisLinVel = KRBVecToVector(ChassisState.LinVel);
	chassisAngVel = KRBVecToVector(ChassisState.AngVel);

	// Last position we sent
	OldPos = KRBVectoVector(CarState.ChassisPosition);
	OldLinVel = KRBVectoVector(CarState.ChassisLinVel);

	// See if state has changed enough, or enough time has passed, that we
	// should send out another update by updating the state struct.
	if( !KIsAwake() )
	{
		return; // Never send updates if physics is at rest
	}

	if( VSize(OldPos - chassisPos) > 5 ||
		VSize(OldLinVel - chassisLinVel) > 1 ||
		Abs(CarState.ServerTorque - OutputTorque) > 0.1 ||
		Abs(CarState.ServerSteering - Steering) > 0.1 ||
		Level.TimeSeconds > NextNetUpdateTime )
	{
		NextNetUpdateTime = Level.TimeSeconds + MaxNetUpdateInterval;
	}
	else
	{
		return;
		//NextNetUpdateTime = Level.TimeSeconds + MaxNetUpdateInterval;
	}

	CarState.ChassisPosition = ChassisState.Position;
	CarState.ChassisQuaternion = ChassisState.Quaternion;
	CarState.ChassisLinVel = ChassisState.LinVel;
	CarState.ChassisAngVel = ChassisState.AngVel;


	ChassisX = QuatRotateVector(CarState.ChassisQuaternion, vect(1, 0, 0));
	ChassisZ = QuatRotateVector(CarState.ChassisQuaternion, vect(0, 0, 1));
	// Get each wheel state.

	////////////////////////// FRONT LEFT //////////////////////////
	frontLeft.KGetRigidBodyState(WheelState);
	wPos = KRBVecToVector(WheelState.Position);
	lPos = QuatRotateVector(QuatInvert(CarState.ChassisQuaternion), wPos - chassisPos); // Convert from world to chassis state space
	CarState.WheelHeight[0] = lPos.Z; // X should be WheelFrontAlong, Y should be WheelFrontAcross

	// For front wheels - we store their current angle around Z as well.
	WheelY = QuatRotateVector(WheelState.Quaternion, vect(0, 1, 0));
	CarState.FrontWheelAng[0] = -ASin(ChassisX Dot WheelY);

	// Find component of relative wheel linear velocity along suspension travel (chassisZ).
	wPosRel = KRBVecToVector(WheelState.Position) - chassisPos;
	WheelLinVel = chassisLinVel + (chassisAngVel Cross wPosRel);

	CarState.WheelVertVel[0] =
		((WheelState.LinVel.X - WheelLinVel.X)* ChassisZ.X) +
		((WheelState.LinVel.Y - WheelLinVel.Y)* ChassisZ.Y) +
		((WheelState.LinVel.Z - WheelLinVel.Z)* ChassisZ.Z);

	//CarState.WheelSpinVel[0] = KRBVecToVector(WheelState.AngVel) Dot WheelY;

	////////////////////////// FRONT RIGHT //////////////////////////
	frontRight.KGetRigidBodyState(WheelState);
	wPos = KRBVecToVector(WheelState.Position);
	lPos = QuatRotateVector(QuatInvert(CarState.ChassisQuaternion), wPos - chassisPos);
	CarState.WheelHeight[1] = lPos.Z;

	WheelY = QuatRotateVector(WheelState.Quaternion, vect(0, 1, 0));
	CarState.FrontWheelAng[1] = -ASin(ChassisX Dot WheelY);

	CarState.WheelVertVel[1] =
		((WheelState.LinVel.X - WheelLinVel.X)* ChassisZ.X) +
		((WheelState.LinVel.Y - WheelLinVel.Y)* ChassisZ.Y) +
		((WheelState.LinVel.Z - WheelLinVel.Z)* ChassisZ.Z);

	//CarState.WheelSpinVel[1] = KRBVecToVector(WheelState.AngVel) Dot WheelY;

	////////////////////////// REAR LEFT //////////////////////////
	rearLeft.KGetRigidBodyState(WheelState);
	wPos = KRBVecToVector(WheelState.Position);
	lPos = QuatRotateVector(QuatInvert(CarState.ChassisQuaternion), wPos - chassisPos);
	CarState.WheelHeight[2] = lPos.Z;

	wPosRel = KRBVecToVector(WheelState.Position) - chassisPos;
	WheelLinVel = chassisLinVel + (chassisAngVel Cross wPosRel);

	CarState.WheelVertVel[2] =
		((WheelState.LinVel.X - WheelLinVel.X)* ChassisZ.X) +
		((WheelState.LinVel.Y - WheelLinVel.Y)* ChassisZ.Y) +
		((WheelState.LinVel.Z - WheelLinVel.Z)* ChassisZ.Z);

	WheelY = QuatRotateVector(WheelState.Quaternion, vect(0, 1, 0));
	//CarState.WheelSpinVel[2] = KRBVecToVector(WheelState.AngVel) Dot WheelY;

	////////////////////////// REAR RIGHT //////////////////////////
	rearRight.KGetRigidBodyState(WheelState);
	wPos = KRBVecToVector(WheelState.Position);
	lPos = QuatRotateVector(QuatInvert(CarState.ChassisQuaternion), wPos - chassisPos);
	CarState.WheelHeight[3] = lPos.Z;

	wPosRel = KRBVecToVector(WheelState.Position) - chassisPos;
	WheelLinVel = chassisLinVel + (chassisAngVel Cross wPosRel);

	CarState.WheelVertVel[3] =
		((WheelState.LinVel.X - WheelLinVel.X)* ChassisZ.X) +
		((WheelState.LinVel.Y - WheelLinVel.Y)* ChassisZ.Y) +
		((WheelState.LinVel.Z - WheelLinVel.Z)* ChassisZ.Z);

	WheelY = QuatRotateVector(WheelState.Quaternion, vect(0, 1, 0));
	//CarState.WheelSpinVel[3] = KRBVecToVector(WheelState.AngVel) Dot WheelY;

	// OTHER
	CarState.ServerSteering = Steering;
	CarState.ServerTorque = OutputTorque;
	CarState.ServerBrake = OutputBrake;
	CarState.ServerHandbrakeOn = OutputHandbrakeOn;

	// This flag lets the client know this data is new.
	CarState.bNewState = true;
}

simulated function PostNetBeginPlay()
{
	local vector RotX, RotY, RotZ, lPos;

    Super.PostNetBeginPlay();

    // Set up suspension graphics

    GetAxes(Rotation,RotX,RotY,RotZ);

    // Spawn wheels, and flip graphics where necessary
    frontLeft = spawn(FrontTireClass, self,, Location + WheelFrontAlong*RotX + WheelFrontAcross*RotY + WheelVert*RotZ, Rotation);
    //frontLeft.SetDrawScale(1);
    frontLeft.SetDrawScale3D(vect(1, 1, 1));

    frontRight = spawn(FrontTireClass, self,, Location + WheelFrontAlong*RotX - WheelFrontAcross*RotY + WheelVert*RotZ, Rotation);
    frontRight.SetDrawScale3D(vect(1, -1, 1));

    rearLeft = spawn(RearTireClass, self,, Location + WheelRearAlong*RotX + WheelRearAcross*RotY + WheelVert*RotZ, Rotation);
    //rearLeft.SetDrawScale(1);
    rearLeft.SetDrawScale3D(vect(1, 1, 1));

    rearRight = spawn(RearTireClass, self,, Location + WheelRearAlong*RotX - WheelRearAcross*RotY + WheelVert*RotZ, Rotation);
    rearRight.SetDrawScale3D(vect(1, -1, 1));

    // Create joints
	lPos.X = WheelFrontAlong;
	lPos.Y = WheelFrontAcross;
	lPos.Z = WheelVert;
    frontLeft.WheelJoint = spawn(class'KCarWheelJoint', self);
    frontLeft.WheelJoint.KPos1 = lPos/50;
    frontLeft.WheelJoint.KPriAxis1 = vect(0, 0, 1);
    frontLeft.WheelJoint.KSecAxis1 = vect(0, 1, 0);
    frontLeft.WheelJoint.KConstraintActor1 = self;
    frontLeft.WheelJoint.KPos2 = vect(0, 0, 0);
    frontLeft.WheelJoint.KPriAxis2 = vect(0, 0, 1);
    frontLeft.WheelJoint.KSecAxis2 = vect(0, 1, 0);
    frontLeft.WheelJoint.KConstraintActor2 = frontLeft;
    frontLeft.WheelJoint.SetPhysics(PHYS_Karma);

	lPos.Y = -WheelFrontAcross;
    frontRight.WheelJoint = spawn(class'KCarWheelJoint', self);
    frontRight.WheelJoint.KPos1 = lPos/50;
    frontRight.WheelJoint.KPriAxis1 = vect(0, 0, 1);
    frontRight.WheelJoint.KSecAxis1 = vect(0, 1, 0);
    frontRight.WheelJoint.KConstraintActor1 = self;
    frontRight.WheelJoint.KPos2 = vect(0, 0, 0);
    frontRight.WheelJoint.KPriAxis2 = vect(0, 0, 1);
    frontRight.WheelJoint.KSecAxis2 = vect(0, 1, 0);
    frontRight.WheelJoint.KConstraintActor2 = frontRight;
    frontRight.WheelJoint.SetPhysics(PHYS_Karma);

	lPos.X = WheelRearAlong;
	lPos.Y = WheelRearAcross;
    rearLeft.WheelJoint = spawn(class'KCarWheelJoint', self);
    rearLeft.WheelJoint.KPos1 = lPos/50;
    rearLeft.WheelJoint.KPriAxis1 = vect(0, 0, 1);
    rearLeft.WheelJoint.KSecAxis1 = vect(0, 1, 0);
    rearLeft.WheelJoint.KConstraintActor1 = self;
    rearLeft.WheelJoint.KPos2 = vect(0, 0, 0);
    rearLeft.WheelJoint.KPriAxis2 = vect(0, 0, 1);
    rearLeft.WheelJoint.KSecAxis2 = vect(0, 1, 0);
    rearLeft.WheelJoint.KConstraintActor2 = rearLeft;
    rearLeft.WheelJoint.SetPhysics(PHYS_Karma);

    lPos.Y = -WheelRearAcross;
	rearRight.WheelJoint = spawn(class'KCarWheelJoint', self);
    rearRight.WheelJoint.KPos1 = lPos/50;
    rearRight.WheelJoint.KPriAxis1 = vect(0, 0, 1);
    rearRight.WheelJoint.KSecAxis1 = vect(0, 1, 0);
    rearRight.WheelJoint.KConstraintActor1 = self;
    rearRight.WheelJoint.KPos2 = vect(0, 0, 0);
    rearRight.WheelJoint.KPriAxis2 = vect(0, 0, 1);
    rearRight.WheelJoint.KSecAxis2 = vect(0, 1, 0);
    rearRight.WheelJoint.KConstraintActor2 = rearRight;
    rearRight.WheelJoint.SetPhysics(PHYS_Karma);

	// Initially make sure parameters are sync'ed with Karma
	KVehicleUpdateParams();
}

// Clean up wheels etc.
simulated event Destroyed()
{
	// Destroy joints holding wheels to car
	if (frontLeft.WheelJoint != None)
		frontLeft.WheelJoint.Destroy();
	if (frontRight.WheelJoint != None)
		frontRight.WheelJoint.Destroy();
	if (rearLeft.WheelJoint != None)
		rearLeft.WheelJoint.Destroy();
	if (rearRight.WheelJoint != None)
		rearRight.WheelJoint.Destroy();

	// Destroy wheels themselves.
	frontLeft.Destroy();
	frontRight.Destroy();
	rearLeft.Destroy();
	rearRight.Destroy();

	Super.Destroyed();
}

// Call this if you change any parameters (tire, suspension etc.) and they
// will be passed down to each wheel/joint.

simulated event KVehicleUpdateParams()
{
	Super.KVehicleUpdateParams();

	if (rearLeft.WheelJoint != None)
	    rearLeft.WheelJoint.bKSteeringLocked = true;
	if (rearRight.WheelJoint != None)
	    rearRight.WheelJoint.bKSteeringLocked = true;

	if (frontLeft.WheelJoint != None)
	{
	    frontLeft.WheelJoint.bKSteeringLocked = false;
    	frontLeft.WheelJoint.KProportionalGap = SteerPropGap;
	    frontLeft.WheelJoint.KMaxSteerTorque = SteerTorque;
    	frontLeft.WheelJoint.KMaxSteerSpeed = SteerSpeed;
	}

	if (frontRight.WheelJoint != None)
	{
	    frontRight.WheelJoint.bKSteeringLocked = false;
    	frontRight.WheelJoint.KProportionalGap = SteerPropGap;
	    frontRight.WheelJoint.KMaxSteerTorque = SteerTorque;
    	frontRight.WheelJoint.KMaxSteerSpeed = SteerSpeed;
	}

	if (frontLeft.WheelJoint != None)
	{
	    frontLeft.WheelJoint.KSuspHighLimit = SuspHighLimit;
    	frontLeft.WheelJoint.KSuspLowLimit = SuspLowLimit;
	    frontLeft.WheelJoint.KSuspStiffness = SuspStiffness;
    	frontLeft.WheelJoint.KSuspDamping = SuspDamping;
	}

	if (frontRight.WheelJoint != None)
	{
    	frontRight.WheelJoint.KSuspHighLimit = SuspHighLimit;
	    frontRight.WheelJoint.KSuspLowLimit = SuspLowLimit;
    	frontRight.WheelJoint.KSuspStiffness = SuspStiffness;
	    frontRight.WheelJoint.KSuspDamping = SuspDamping;
	}

	if (rearLeft.WheelJoint != None)
	{
	    rearLeft.WheelJoint.KSuspHighLimit = SuspHighLimit;
    	rearLeft.WheelJoint.KSuspLowLimit = SuspLowLimit;
	    rearLeft.WheelJoint.KSuspStiffness = SuspStiffness;
    	rearLeft.WheelJoint.KSuspDamping = SuspDamping;
	}

	if (rearRight.WheelJoint != None)
	{
	    rearRight.WheelJoint.KSuspHighLimit = SuspHighLimit;
    	rearRight.WheelJoint.KSuspLowLimit = SuspLowLimit;
	    rearRight.WheelJoint.KSuspStiffness = SuspStiffness;
    	rearRight.WheelJoint.KSuspDamping = SuspDamping;
	}

	// Sync params with Karma.
	if (frontLeft.WheelJoint != None)
		frontLeft.WheelJoint.KUpdateConstraintParams();
	if (frontRight.WheelJoint != None)
		frontRight.WheelJoint.KUpdateConstraintParams();
	if (rearLeft.WheelJoint != None)
		rearLeft.WheelJoint.KUpdateConstraintParams();
	if (rearRight.WheelJoint != None)
		rearRight.WheelJoint.KUpdateConstraintParams();

    // Mass
    KSetMass(ChassisMass);
    frontLeft.KSetMass(TireMass);
    frontRight.KSetMass(TireMass);
    rearLeft.KSetMass(TireMass);
    rearRight.KSetMass(TireMass);

    // Tire params handy tuning
    frontLeft.RollFriction = TireRollFriction;
    frontLeft.LateralFriction = TireLateralFriction;
    frontLeft.RollSlip = TireRollSlip;
    frontLeft.LateralSlip = TireLateralSlip;
    frontLeft.MinSlip = TireMinSlip;
    frontLeft.SlipRate = TireSlipRate;
    frontLeft.Softness = TireSoftness;
    frontLeft.Adhesion = TireAdhesion;
    frontLeft.Restitution = TireRestitution;

    frontRight.RollFriction = TireRollFriction;
    frontRight.LateralFriction = TireLateralFriction;
    frontRight.RollSlip = TireRollSlip;
    frontRight.LateralSlip = TireLateralSlip;
    frontRight.MinSlip = TireMinSlip;
    frontRight.SlipRate = TireSlipRate;
    frontRight.Softness = TireSoftness;
    frontRight.Adhesion = TireAdhesion;
    frontRight.Restitution = TireRestitution;

    rearLeft.RollFriction = TireRollFriction;
    rearLeft.LateralFriction = TireLateralFriction;
    rearLeft.RollSlip = TireRollSlip;
    rearLeft.LateralSlip = TireLateralSlip;
    rearLeft.MinSlip = TireMinSlip;
    rearLeft.SlipRate = TireSlipRate;
    rearLeft.Softness = TireSoftness;
    rearLeft.Adhesion = TireAdhesion;
    rearLeft.Restitution = TireRestitution;

    rearRight.RollFriction = TireRollFriction;
    rearRight.LateralFriction = TireLateralFriction;
    rearRight.RollSlip = TireRollSlip;
    rearRight.LateralSlip = TireLateralSlip;
    rearRight.MinSlip = TireMinSlip;
    rearRight.SlipRate = TireSlipRate;
    rearRight.Softness = TireSoftness;
    rearRight.Adhesion = TireAdhesion;
    rearRight.Restitution = TireRestitution;
}

// Possibly apply force to flip car over.
simulated event KApplyForce(out vector Force, out vector Torque)
{
	local float torqueScale;
	local vector worldForward, worldUp, worldRight, torqueAxis;

	if (FlipTimeLeft == 0)
		return;

	worldForward = vect(-1, 0, 0) >> Rotation;
	worldUp = vect(0, 0, 1) >> Rotation;
	worldRight = vect(0, 1, 0) >> Rotation;

	torqueAxis = Normal(worldUp Cross vect(0, 0, 1));

	// Torque scaled by how far over we are.
	// This will be between 0 and PI - so convert to between 0 and 1.
	torqueScale = Acos(worldUp Dot vect(0, 0, 1))/3.1416;

	Torque = FlipTorque * torqueScale * torqueAxis;
}

function StartFlip(Pawn Pusher)
{
	//local vector toPusher, worldUp;

	// if we are already flipping the car - dont do it again!
	if(FlipTimeLeft > 0)
		return;

	// Dont let you push the car if you are going to be underneath it!
  	//worldUp = vect(0, 0, 1) >> Rotation;
	//toPusher = Pusher.Location - Location;
	//if( (worldUp Dot toPusher) < 0)
	//	return;

	FlipTimeLeft = FlipTime; // Start the flip on the server
}

// Tell it your current throttle, and it will give you an output torque
// This is currently like an electric motor
function float Engine(float Throttle)
{
    local float torque;

	torque = Abs(Throttle) * Gear * InterpCurveEval(TorqueCurve, WheelSpinSpeed);

	GraphData("SpinSpeed", WheelSpinSpeed);
	GraphData("Torque", torque);

    return -1 * torque;
}

function ProcessCarInput()
{
	local vector worldForward, worldUp;

	//Log("PCI S:"$Steering$" T:"$Throttle);

  	worldForward = vect(-1, 0, 0) >> Rotation;
  	worldUp = vect(0, 0, 1) >> Rotation;

  	ForwardVel = Velocity Dot worldForward;

	bIsInverted = worldUp.Z < 0.2;

	// 'ForwardVel' isn't very helpful if we are inverted, so we just pretend its positive.
	if(bIsInverted)
		ForwardVel = 2 * StopThreshold;

	//Log("F:"$ForwardVel$"IsI:"$bIsInverted);

	if( Driver == None )
	{
		if(bAutoDrive == true)
		{
			Gear = 1;
			OutputBrake = false;

			Throttle = 0.4;
			Steering = 1;

			//log("Thr:"$Throttle);

			KWake();
		}
		else if (Controller != None)
		{
			// the scripted controller will set the throttle and steering

			KWake();
		}
		else
		{
			Gear = 0;
			OutputBrake = true;
		}
	}
	else
	{
		if(Throttle > 0.01) // pressing forwards
		{
			if(ForwardVel < -StopThreshold && Gear != 1) // going backwards - so brake first
			{
				//Log("F - Brake");
				Gear = 0;
				OutputBrake = true;
				IsDriving = false;
			}
			else // stopped or going forwards, so drive
			{
				//Log("F - Drive");
				Gear = 1;
				OutputBrake = false;
				IsDriving = true;
			}
		}
		else if(Throttle < -0.01) // pressing backwards
		{
			// We have to release the brakes and then press reverse again to go into reverse
			if(ForwardVel < StopThreshold && IsDriving == false)
			{
				//Log("B - Drive");
				Gear = -1;
				OutputBrake = false;
				IsDriving = false;
			}
			else // otherwise, we are going forwards, or still holding brake, so just brake
			{
				//Log("B - Brake");
				Gear = 0;
				OutputBrake = true;
				IsDriving = true;
			}
		}
		else // not pressing either
		{
			// If stationary, stick brakes on
			if(Abs(ForwardVel) < StopThreshold)
			{
				//Log("B - Brake");
				Gear = 0;
				OutputBrake = true;
				IsDriving = false;
				OutputHandbrakeOn = false; // force handbrake off if stopped.
			}
			else // otherwise, coast
			{
				//Log("Coast");
				Gear = 0;
				OutputBrake = false;
				IsDriving = false;
			}
		}

		KWake(); // currently, never let the car go to sleep whilst being driven.
	}

	// If we are going forwards, steering, and pressing the brake,
	// enable extra-slippy handbrake.
	if((ForwardVel > HandbrakeThresh || OutputHandbrakeOn == true) && Abs(Steering) > 0.01 && OutputBrake == true)
		OutputHandbrakeOn = true;
	else
		OutputHandbrakeOn = false;

	// Engine model
    OutputTorque = Engine(Throttle);
}

// Car Simulation
simulated function Tick(float Delta)
{
	local float tana, sFactor;

	Super.Tick(Delta);

    WheelSpinSpeed = (rearLeft.SpinSpeed + rearRight.SpinSpeed)/2;
    //log("WheelSpinSpeed:"$WheelSpinSpeed);

	// if we are in the process of flipping the car, keep it enabled!
	if( FlipTimeLeft > 0  )
		KWake();

    // If the server, process input and pack updated car info into struct.
    if(Role == ROLE_Authority)
	{
		ProcessCarInput();
		PackState();
	}

    // Motor

	// FRONT
	if (frontLeft.WheelJoint != None)
	    frontLeft.WheelJoint.KMotorTorque = 0.5 * OutputTorque * (1-TorqueSplit);
	if (frontRight.WheelJoint != None)
    	frontRight.WheelJoint.KMotorTorque = 0.5 * OutputTorque * (1-TorqueSplit);

	// REAR
	if (rearLeft.WheelJoint != None)
	    rearLeft.WheelJoint.KMotorTorque = 0.5 * OutputTorque * TorqueSplit;
	if (rearRight.WheelJoint != None)
	    rearRight.WheelJoint.KMotorTorque = 0.5 * OutputTorque * TorqueSplit;

    // Braking

	if(OutputBrake)
	{
		if (frontLeft.WheelJoint != None)
			frontLeft.WheelJoint.KBraking = MaxBrakeTorque;
		if (frontRight.WheelJoint != None)
			frontRight.WheelJoint.KBraking = MaxBrakeTorque;
		if (rearLeft.WheelJoint != None)
			rearLeft.WheelJoint.KBraking = MaxBrakeTorque;
		if (rearRight.WheelJoint != None)
			rearRight.WheelJoint.KBraking = MaxBrakeTorque;
	}
	else
	{
		if (frontLeft.WheelJoint != None)
			frontLeft.WheelJoint.KBraking = 0.0;
		if (frontRight.WheelJoint != None)
			frontRight.WheelJoint.KBraking = 0.0;
		if (rearLeft.WheelJoint != None)
			rearLeft.WheelJoint.KBraking = 0.0;
		if (rearRight.WheelJoint != None)
			rearRight.WheelJoint.KBraking = 0.0;
	}

	// Steering

	tana = Tan(6.283/65536 * Steering * MaxSteerAngle);

    sFactor = 0.5 * tana * (2 * WheelFrontAcross) / Abs(WheelFrontAlong - WheelRearAlong);
	if (frontLeft.WheelJoint != None)
	    frontLeft.WheelJoint.KSteerAngle = 65536/6.283 * Atan(tana, (1-sFactor));
	if (frontRight.WheelJoint != None)
	    frontRight.WheelJoint.KSteerAngle = 65536/6.283 * Atan(tana, (1+sFactor));

	// Handbrake

	if(OutputHandbrakeOn == true)
	{
		//Log("HANDBRAKE!!");
		rearLeft.LateralFriction = TireLateralFriction + TireHandbrakeFriction;
		rearLeft.LateralSlip = TireLateralSlip + TireHandbrakeSlip;

		rearRight.LateralFriction = TireLateralFriction + TireHandbrakeFriction;
		rearRight.LateralSlip = TireLateralSlip + TireHandbrakeSlip;
	}
	else
	{
		rearLeft.LateralFriction = TireLateralFriction;
		rearLeft.LateralSlip = TireLateralSlip;

		rearRight.LateralFriction = TireLateralFriction;
		rearRight.LateralSlip = TireLateralSlip;
	}

	// Flipping
	if(FlipTimeLeft > 0)
	{
		FlipTimeLeft -= Delta;
		FlipTimeLeft = FMax(FlipTimeLeft, 0.0); // Make sure it doesn't go negative
	}

}


defaultproperties
{
    OutputBrake=0
    Gear=1
	bAutoDrive=false

	WheelFrontAlong=-180
	WheelFrontAcross=140
	WheelRearAlong=160
	WheelRearAcross=140
	WheelVert=-0.5

	StopThreshold=100

    TorqueSplit=0.5
    SteerPropGap=1000
    SteerTorque=1000
    SteerSpeed=15000

    TireMass=0.5
    ChassisMass=4

	FlipTorque=350
	FlipTime=3

    MaxSteerAngle=3900
    MaxBrakeTorque=50

	TorqueCurve=(Points=((InVal=0,OutVal=150),(InVal=245756,OutVal=150),(InVal=491512,OutVal=0)))

    TireRollFriction=1.0
    TireLateralFriction=1.0
    TireRollSlip=0.085
    TireLateralSlip=0.06
    TireMinSlip=0.001
    TireSlipRate=0.0005
    TireSoftness=0.0002
    TireAdhesion=0
    TireRestitution=0

	HandbrakeThresh=1000
	TireHandbrakeSlip=0.06
	TireHandbrakeFriction=-0.5

    SuspStiffness=50
    SuspDamping=5
    SuspHighLimit=1
    SuspLowLimit=-1
    SuspRef=0

	MaxNetUpdateInterval=0.4
}
//=============================================================================
// The Car Wheel joint class.
//=============================================================================

class KCarWheelJoint extends KConstraint
    native
    placeable;



cpptext
{
#ifdef WITH_KARMA
    virtual void KUpdateConstraintParams();
	virtual void preKarmaStep(FLOAT DeltaTime);
#endif
}

// STEERING
var(KarmaConstraint) float KSteerAngle;       // desired steering angle to achieve using controller (65535 = 360 deg)
var(KarmaConstraint) float KProportionalGap;  // for steering controller (65535 = 360 deg)
var(KarmaConstraint) float KMaxSteerTorque;   // for steering controller
var(KarmaConstraint) float KMaxSteerSpeed;    // for steering controller (65535 = 1 rotation per second)
var(KarmaConstraint) bool  bKSteeringLocked;   // steering 'locked' in straight ahead direction

// MOTOR
var(KarmaConstraint) float KMotorTorque;      // torque applied to drive this wheel (can be negative)
var(KarmaConstraint) float KMaxSpeed;         // max speed to try and reach using KMotorTorque (65535 = 1 rotation per second)
var(KarmaConstraint) float KBraking;          // torque applied to brake wheel

// SUSPENSION
var(KarmaConstraint) float KSuspLowLimit;
var(KarmaConstraint) float KSuspHighLimit;
var(KarmaConstraint) float KSuspStiffness;
var(KarmaConstraint) float KSuspDamping;
var(KarmaConstraint) float KSuspRef;

// Other output
var const float KWheelHeight; // height of wheel relative to suspension centre

native final function float KGetWheelAngle(float Angle);  // GBX:jlb - added to get wheel's angle for steering wheel

defaultproperties
{
    KProportionalGap=8200
    KMaxSteerTorque=1000
    KMaxSteerSpeed=2600
    bKSteeringLocked=true
    KMaxSpeed=1310700

    KSuspLowLimit=-1
    KSuspHighLimit=1
    KSuspStiffness=50
    KSuspDamping=5
    KSuspRef=0
	bNoDelete=false
}
//=============================================================================
// The Cone Limit joint class.
//=============================================================================

class KConeLimit extends KConstraint
    native
    placeable;



cpptext
{
#ifdef WITH_KARMA
    virtual void KUpdateConstraintParams();
#endif
}

var(KarmaConstraint) float KHalfAngle; // ( 65535 = 360 deg )
var(KarmaConstraint) float KStiffness;
var(KarmaConstraint) float KDamping;

//native final function KSetHalfAngle(float HalfAngle);
//native final function KSetStiffness(float Stiffness);
//native final function KSetDamping(float Damping);


defaultproperties
{
    KHalfAngle=8200 // about 45 deg
    KStiffness=50

    Texture=Texture'Engine.S_KConeLimit'
    bDirectional=True
}
//=============================================================================
// The Basic constraint class.
//=============================================================================

class KConstraint extends KActor
    abstract
	placeable
	native;



cpptext
{
#ifdef WITH_KARMA
    virtual MdtConstraintID getKConstraint() const;
    virtual McdModelID getKModel() const;

	virtual void physKarma(FLOAT DeltaTime);

	virtual void PostEditChange();
	virtual void PostEditMove();

    virtual void KUpdateConstraintParams();

	virtual void CheckForErrors(); // used for checking that this constraint is valid buring map build
	virtual void RenderEditorSelected(FLevelSceneNode* SceneNode,FRenderInterface* RI, FDynamicActor* FDA);
	virtual UBOOL CheckOwnerUpdated();

	virtual void preKarmaStep(FLOAT DeltaTime) {};
	virtual void postKarmaStep() {};
#endif
}

// Used internally for Karma stuff - DO NOT CHANGE!
var transient const int KConstraintData;

// Actors joined effected by this constraint (could be NULL for 'World')
var(KarmaConstraint) edfindable Actor KConstraintActor1;
var(KarmaConstraint) edfindable Actor KConstraintActor2;

// If an KConstraintActor is a skeletal thing, you can specify which bone inside it
// to attach the constraint to. If left blank (the default) it picks the nearest bone.
var(KarmaConstraint) name KConstraintBone1;
var(KarmaConstraint) name KConstraintBone2;

// Disable collision between joined
var(KarmaConstraint) const bool bKDisableCollision;

// Constraint position/orientation, as defined in each body's local reference frame
// These are in KARMA scale!

// Body1 ref frame
var vector KPos1;
var vector KPriAxis1;
var vector KSecAxis1;

// Body2 ref frame
var vector KPos2;
var vector KPriAxis2;
var vector KSecAxis2;

// Force constraint to re-calculate its position/axis in local ref frames
// Usually true for constraints saved out of UnrealEd, false for everything else
var const bool bKForceFrameUpdate;

// [see KForceExceed below]
var(KarmaConstraint) float KForceThreshold;


// This function is used to re-sync constraint parameters (eg. stiffness) with Karma.
// Call when you change a parameter to get it to actually take effect.
native function KUpdateConstraintParams();

native final function KGetConstraintForce(out vector Force);
native final function KGetConstraintTorque(out vector Torque);

// Event triggered when magnitude of constraint (linear) force exceeds KForceThreshold
event KForceExceed(float forceMag);

defaultproperties
{
    KPos1=(X=0,Y=0,Z=0)
    KPriAxis1=(X=1,Y=0,Z=0)
    KSecAxis1=(X=0,Y=1,Z=0)

    KPos2=(X=0,Y=0,Z=0)
    KPriAxis2=(X=1,Y=0,Z=0)
    KSecAxis2=(X=0,Y=1,Z=0)

    bKForceFrameUpdate=False
    bKDisableCollision=True

    bHidden=True
    Texture=Texture'Engine.S_KConstraint'
    DrawType=DT_Sprite

    //Physics=PHYS_None
	bStatic=False

	bCollideActors=False
    bProjTarget=False
	bBlockActors=False
	bWorldGeometry=False
	bBlockKarma=False

    CollisionHeight=+000001.000000
	CollisionRadius=+000001.000000
}
//=============================================================================
// Keypoint, the base class of invisible actors which mark things.
//=============================================================================
class Keypoint extends Actor
	abstract
	placeable
	native;



defaultproperties
{
     bStatic=True
     bHidden=True
     SoundVolume=0
     CollisionRadius=+00010.000000
     CollisionHeight=+00010.000000
	 Texture=Texture'Engine.S_Keypoint'
}
//=============================================================================
// The Hinge joint class.
//=============================================================================

class KHinge extends KConstraint
    native
    placeable;



cpptext
{
#ifdef WITH_KARMA
    virtual void KUpdateConstraintParams();
	virtual void preKarmaStep(FLOAT DeltaTime);
#endif
}

// Spatial light effect to use.
var(KarmaConstraint) enum EHingeType
{
	HT_Normal,
	HT_Springy,
	HT_Motor,
    HT_Controlled
} KHingeType;


// SPRINGY - around hinge axis, default position being KDesiredAngle (below)
var(KarmaConstraint) float KStiffness;
var(KarmaConstraint) float KDamping;

// MOTOR - tries to achieve angular velocity
var(KarmaConstraint) float KDesiredAngVel; // 65535 = 1 rotation per second
var(KarmaConstraint) float KMaxTorque;

// CONTROLLED - achieve a certain angle
// Uses AngularVelocity and MaxForce from above.
// Within 'ProportionalGap' of DesiredAngle,
var(KarmaConstraint) float KDesiredAngle; // 65535 = 360 degrees
var(KarmaConstraint) float KProportionalGap; // 65535 = 360 degrees

// This is the alternative 'desired' angle, and the bool that indicates whether to use it.
// See ToggleDesired and ControlDesired below.
var(KarmaConstraint) float KAltDesiredAngle; // 65535 = 360 degrees
var					 bool  KUseAltDesired;

// output - current angular position of joint // 65535 = 360 degrees
var const float KCurrentAngle;

// In this state nothing will happen if this hinge is triggered or untriggered.
auto state Default
{
ignores Trigger, Untrigger;

}

// In this state, Trigger will cause the hinge type to change to HT_Motor.
// Another trigger will toggle it to HT_Controlled, and it will try and maintain its current angle.
state() ToggleMotor
{
ignores Untrigger;
	function Trigger( actor Other, Pawn EventInstigator )
	{
		//Log("ToggleMotor - Trigger");
		if(KHingeType == HT_Motor)
		{
			KDesiredAngle = KCurrentAngle;
			KUseAltDesired = False;
			KHingeType = HT_Controlled;
		}
		else
			KHingeType = HT_Motor;

		KUpdateConstraintParams();
		KConstraintActor1.KWake(); // force re-enable of simulation on this actor.
	}

Begin:
	KHingeType = HT_Controlled;
	KUseAltDesired = False;
	KUpdateConstraintParams();
}

// In this state, Trigger will turn motor on.
// Untrigger will turn toggle it to HT_Controlled, and it will try and maintain its current angle.
state() ControlMotor
{
	function Trigger( actor Other, Pawn EventInstigator )
	{
		//Log("ControlMotor - Trigger");
		if(KHingeType != HT_Motor)
		{
			KHingeType = HT_Motor;
			KUpdateConstraintParams();
			KConstraintActor1.KWake();
		}
	}

	function Untrigger( actor Other, Pawn EventInstigator )
	{
		//Log("ControlMotor - Untrigger");
		if(KHingeType == HT_Motor)
		{
			KDesiredAngle = KCurrentAngle;
			KUseAltDesired = False;
			KHingeType = HT_Controlled;
			KUpdateConstraintParams();
			KConstraintActor1.KWake();
		}
	}

Begin:
	KHingeType = HT_Controlled;
	KUseAltDesired = False;
	KUpdateConstraintParams();
}

// In this state a trigger will toggle the hinge between using KDesiredAngle and KAltDesiredAngle.
// It will use whatever the current KHingeType is to achieve this, so this is only useful with HT_Controlled and HT_Springy.
state() ToggleDesired
{
ignores Untrigger;

	function Trigger( actor Other, Pawn EventInstigator )
	{
		//Log("ToggleDesired - Trigger");
		if(KUseAltDesired)
			KUseAltDesired = False;
		else
			KUseAltDesired = True;
		//Log("UseAlt"$KUseAltDesired);
		KUpdateConstraintParams();
		KConstraintActor1.KWake();
	}
}

// In this state, trigger will cause the hinge to use KAltDesiredAngle, untrigger will caus it to use KAltDesiredAngle
state() ControlDesired
{
	function Trigger( actor Other, Pawn EventInstigator )
	{
		//Log("ControlDesired - Trigger");
		KUseAltDesired = True;
		//Log("UseAlt"$KUseAltDesired);
		KUpdateConstraintParams();
		KConstraintActor1.KWake();
	}

	function Untrigger( actor Other, Pawn EventInstigator )
	{
		//Log("ControlDesired - Untrigger");
		KUseAltDesired = False;
		//Log("UseAlt"$KUseAltDesired);
		KUpdateConstraintParams();
		KConstraintActor1.KWake();
	}
}

defaultproperties
{
    KHingeType=HT_Normal
    KStiffness=50
    KProportionalGap=8200
	KUseAltDesired=False

    bDirectional=True
    Texture=Texture'Engine.S_KHinge'
}
class KRepulsor extends Actor
	native;

cpptext
{
#ifdef WITH_KARMA
	void Destroy();
#endif
}

var()	bool	bEnableRepulsion;
var		bool	bRepulsorInContact; // Repulsor is currently contacting something.
var()	vector	CheckDir; // In owner ref frame
var()	float	CheckDist;
var()	float	Softness;
var()	float	PenScale;
var()	float	PenOffset;
var transient color TraceColor; // Last color returned by TRACE_GatherLighting

// Used internally for Karma stuff - DO NOT CHANGE!
var		transient const int		KContact;



defaultproperties
{
    bEnableRepulsion=true
	CheckDir=(X=0.0,Y=0.0,Z=-1.0)
	CheckDist=50
	Softness=0.1
	PenScale=1.0
	PenOffset=0.0

	bCollideActors=false
	bCollideWorld=false
	bBlockActors=false
	bBlockNonZeroExtentTraces=false
	bBlockZeroExtentTraces=false
	bProjTarget=false
	bHardAttach=true
    RemoteRole=ROLE_None
	bNoDelete=false
}
class KTire extends KActor
    native
    abstract;



cpptext
{
#ifdef WITH_KARMA
	// Actor interface.
	virtual void preContactUpdate();
#endif
}

var KCarWheelJoint  WheelJoint;         // joint holding this wheel to chassis etc.

// TYRE MODEL

// FRICTION
var float           RollFriction;       // friction coeff. in tyre direction
var float           LateralFriction;    // friction coeff. in sideways direction

// SLIP
// slip = min(maxSlip, minSlip + (slipRate * angular vel))
var float           RollSlip;           // max first-order (force ~ vel) slip in tyre direction
var float           LateralSlip;        // max first-order (force ~ vel) slip in sideways direction
var float           MinSlip;            // minimum slip (both directions)
var float           SlipRate;           // amount of extra slip per unit velocity

// NORMAL
var float           Softness;           // 'softness' in the normal dir
var float           Adhesion;           // 'stickyness' in the normal dir
var float           Restitution;        // 'bouncyness' in the normal dir

// Other Output information

var const bool      bTireOnGround;		// If this tire is currently in contact with something.

var const float     GroundSlipVel;      // relative tangential velocity of wheel against ground (0 for static, >0 for slipping)
                                        // could use this to trigger squeeling noises/smoke
var const vector	GroundSlipVec;		// full vector version of above (ie GroundSlipVel is magnitude of this vector).

var const float     SpinSpeed;			// current speed (65535 = 1 rev/sec) of this wheel spinning about its axis

var const material		GroundMaterial;		// material that tyre is touching
//var const ESurfaceTypes GroundSurfaceType;	// surface type that the tyre is touching

// This is filled in by VehicleStateReceived in KVehicle.
var KRigidBodyState	ReceiveState;
var bool			bReceiveStateNew;

// This even is for updating the state (position, velocity etc.) of the tire's karma
// body when we get new information from the network.
event bool KUpdateState(out KRigidBodyState newState)
{
	if(!bReceiveStateNew)
		return false;

	newState = ReceiveState;
	bReceiveStateNew = false;

	return true;
	//return false;
}

// By default, nothing happens if you shoot a tire
function TakeDamage(int Damage, Pawn instigatedBy, Vector hitlocation,
						Vector momentum, class<DamageType> damageType, optional name HitBoxName)
{

}

defaultproperties
{
    RollFriction=0.3
    LateralFriction=0.3

    RollSlip=0.085
    LateralSlip=0.06
    MinSlip=0.001
    SlipRate=0.0005

    Softness=0.0002
    Restitution=0.1
    Adhesion=0

	bDisturbFluidSurface=true
    RemoteRole=ROLE_None
	bNoDelete=false
}
// Generic 'Karma Vehicle' base class that can be controlled by a Pawn.

class KVehicle extends Pawn
    native
    abstract;



cpptext
{
#ifdef WITH_KARMA
	virtual void PostNetReceive();
    virtual void PostEditChange();
	virtual void setPhysics(BYTE NewPhysics, AActor *NewFloor, FVector NewFloorV);
	virtual void TickSimulated( FLOAT DeltaSeconds );
	virtual void TickAuthoritative( FLOAT DeltaSeconds );
#endif

}

// generic controls (set by controller, used by concrete derived classes)
var (KVehicle) float    Steering; // between -1 and 1
var (KVehicle) float    Throttle; // between -1 and 1
var (KVehicle) float	ScriptedSpeedScale;
var (KVehicle) float	ScriptedDistanceCheck;
var (KVehicle) float	ScriptedThrottleSlow;
var (KVehicle) float	ScriptedThrottleVerySlow;
var ActorLite			ScriptedDestPoint;
var ActorLite			ScriptedNextPoint;

var			   Pawn     Driver;

var (KVehicle) array<vector>	ExitPositions;		// Positions (rel to vehicle) to try putting the player when exiting.

var (KVehicle) vector	DrivePos;		// Position (rel to vehicle) to put player while driving.
var (KVehicle) rotator	DriveRot;		// Rotation (rel to vehicle) to put driver while driving.

// Effect spawned when vehicle is destroyed
var (KVehicle) class<Actor>	DestroyEffectClass;

// Simple 'driving-in-rings' logic.
var (KVehicle) bool		bAutoDrive;

var			   bool     bGetOut;

// The factory that created this vehicle.
var			   KVehicleFactory	ParentFactory;

// Weapon system
var				bool	bVehicleIsFiring, bVehicleIsAltFiring;

const					FilterFrames = 5;
var				vector	CameraHistory[FilterFrames];
var				int		NextHistorySlot;
var				bool	bHistoryWarmup;

// Useful function for plotting data to real-time graph on screen.
native final function GraphData(string DataName, float DataValue);

replication
{
	reliable if(Role==ROLE_Authority)
		ClientKDriverEnter, ClientKDriverLeave;

	reliable if(Role < ROLE_Authority)
		VehicleFire, VehicleCeaseFire;
}

// Really simple at the moment!
function TakeDamage(int Damage, Pawn instigatedBy, Vector hitlocation,
						Vector momentum, class<DamageType> damageType, optional name HitBoxName)
{
	local PlayerController pc;

	Health -= Damage;

	//Log("Ouch! "$Health);

	// The vehicle is dead!
	if(Health <= 0)
	{
		if ( Controller != None )
		{
			pc = PlayerController(Controller);

			if( Controller.bIsPlayer && pc != None )
			{
				ClientKDriverLeave(pc); // Just to reset HUD etc.

				// THIS WAS HOW IT WAS IN UT2003, DONT KNOW ABOUT WARFARE...
				// pc.PawnDied(self); // This should unpossess the controller and let the player respawn
			}
			else
				Controller.Destroy();
		}

		Destroy(); // Destroy the vehicle itself (see Destroyed below)
	}

    //KAddImpulse(momentum, hitlocation);
}

// Vehicles dont get telefragged.
event EncroachedBy( actor Other )
{
	Log("KVehicle("$self$") Encroached By: "$Other$".");
}

// You got some new info from the server (ie. VehicleState has some new info).
event VehicleStateReceived();

// Called when a parameter of the overall articulated actor has changed (like PostEditChange)
// The script must then call KUpdateConstraintParams or Actor Karma mutators as appropriate.
simulated event KVehicleUpdateParams();

// Do some server-side vehicle firing stuff
function VehicleFire(bool bWasAltFire)
{
	if(bWasAltFire)
		bVehicleIsAltFiring = true;
	else
		bVehicleIsFiring = true;
}

function VehicleCeaseFire(bool bWasAltFire)
{
	if(bWasAltFire)
		bVehicleIsAltFiring = false;
	else
		bVehicleIsFiring = false;
}


// The Pawn Driver has tried to take control of this vehicle
function TryToDrive(Pawn p)
{
	local Controller C;
	C = p.Controller;

    if ( (Driver == None) && (C != None) && C.bIsPlayer && !C.IsInState('PlayerDriving') && p.IsHumanControlled() )
	{
		KDriverEnter(p);
    }
}

// Events called on driver entering/leaving vehicle

simulated function ClientKDriverEnter(PlayerController pc)
{
	//log("Enter: "$pc.Pawn);

	//pc.myHUD.bCrosshairShow = false;
	//pc.myHUD.bShowWeaponInfo = false;
	//pc.myHUD.bShowPersonalInfo = false;
	//pc.myHUD.bShowPoints = false;

	pc.bBehindView = true;
	pc.bFixedCamera = false;
	pc.bFreeCamera = true;

    pc.SetRotation(rotator( vect(-1, 0, 0) >> Rotation ));
}

function KDriverEnter(Pawn p)
{
	local PlayerController pc;

    //log("KVehicle KDriverEnter");

	// Set pawns current controller to control the vehicle Pawn instead
	Driver = p;

	// Move the driver into position, and attach to car.
	Driver.SetCollision(false, false, false);
	Driver.bCollideWorld = false;
	Driver.bPhysicsAnimUpdate = false;
	Driver.Velocity = vect(0,0,0);
	Driver.SetPhysics(PHYS_None);
	Driver.SetBase(self);

	pc = PlayerController(p.Controller);
	//pc.ClientSetBehindView(true);
	//pc.ClientSetFixedCamera(false);

	// Disconnect PlyaerController from Driver and connect to KVehicle.
	pc.Unpossess();
	Driver.SetOwner(pc); // This keeps the driver relevant.
	pc.Possess(self);

	pc.ClientSetViewTarget(self); // Set playercontroller to view the vehicle

	// Change controller state to driver
    pc.GotoState('PlayerDriving');

	ClientKDriverEnter(pc);
}

simulated function ClientKDriverLeave(PlayerController pc)
{
	//local vector exitLookDir;

	//log("Leave: "$pc.Pawn);

	pc.bBehindView = false;
	pc.bFixedCamera = true;
	pc.bFreeCamera = false;
	// This removes any 'roll' from the look direction.
	//exitLookDir = Vector(pc.Rotation);
	//pc.SetRotation(Rotator(exitLookDir));

    //pc.myHUD.bCrosshairShow = pc.myHUD.default.bCrosshairShow;
	//pc.myHUD.bShowWeaponInfo = pc.myHUD.default.bShowWeaponInfo;
	//pc.myHUD.bShowPersonalInfo = pc.myHUD.default.bShowPersonalInfo;
	//pc.myHUD.bShowPoints = pc.myHUD.default.bShowPoints;

	// Reset the view-smoothing
	NextHistorySlot = 0;
	bHistoryWarmup = true;
}

// Called from the PlayerController when player wants to get out.
function bool KDriverLeave(bool bForceLeave)
{
	local PlayerController pc;
	local int i;
	local bool havePlaced;
	local vector HitLocation, HitNormal, tryPlace;

    //log("KVehicle KDriverLeave");

	// Do nothing if we're not being driven
	if(Driver == None)
		return false;

	// Before we can exit, we need to find a place to put the driver.
	// Iterate over array of possible exit locations.

	Driver.bCollideWorld = true;
	Driver.SetCollision(true, true, true);

	havePlaced = false;
	for(i=0; i < ExitPositions.Length && havePlaced == false; i++)
	{
		//Log("Trying Exit:"$i);

		tryPlace = Location + (ExitPositions[i] >> Rotation);

		// First, do a line check (stops us passing through things on exit).
		if( Trace(HitLocation, HitNormal, tryPlace, Location, false) != None )
			continue;

		// Then see if we can place the player there.
		if( !Driver.SetLocation(tryPlace) )
			continue;

		havePlaced = true;

		//Log("SUCCESS!");
	}

	// If we could not find a place to put the driver, leave driver inside as before.
	if(!havePlaced && !bForceLeave)
	{
		Log("Could not place driver.");

		Driver.bCollideWorld = false;
		Driver.SetCollision(false, false, false);

		return false;
	}

	pc = PlayerController(Controller);

	//Log("Pre ClientKDriverLeave");
	ClientKDriverLeave(pc);
	//Log("Post ClientKDriverLeave");

	// Reconnect PlayerController to Driver.
	pc.Unpossess();
	pc.Possess(Driver);

	pc.ClientSetViewTarget(Driver); // Set playercontroller to view the persone that got out

	Controller = None;

	Driver.PlayWaiting();
	Driver.bPhysicsAnimUpdate = Driver.Default.bPhysicsAnimUpdate;

	// Do stuff on client
	//pc.ClientSetBehindView(false);
	//pc.ClientSetFixedCamera(true);

    Driver.Acceleration = vect(0, 0, 24000);
	Driver.SetPhysics(PHYS_Falling);
	Driver.SetBase(None);

	// Car now has no driver
	Driver = None;

	// Put brakes on before you get out :)
    Throttle=0;
    Steering=0;

	// Stop firing when you get out!
	bVehicleIsFiring = false;
	bVehicleIsAltFiring = false;

    return true;
}

// Special calc-view for vehicles
simulated function bool SpecialCalcView(out actor ViewActor, out vector CameraLocation, out rotator CameraRotation )
{
	local vector CamLookAt, HitLocation, HitNormal;
	local PlayerController pc;
	local int i, averageOver;

	pc = PlayerController(Controller);

	// Only do this mode we have a playercontroller viewing this vehicle
	if(pc == None || pc.ViewTarget != self)
		return false;

	ViewActor = self;
	CamLookAt = Location + (vect(-100, 0, 100) >> Rotation);

	//////////////////////////////////////////////////////
	// Smooth lookat position over a few frames.
	CameraHistory[NextHistorySlot] = CamLookAt;
	NextHistorySlot++;

	if(bHistoryWarmup)
		averageOver = NextHistorySlot;
	else
		averageOver = FilterFrames;

	CamLookAt = vect(0, 0, 0);
	for(i=0; i<averageOver; i++)
		CamLookAt += CameraHistory[i];

	CamLookAt /= float(averageOver);

	if(NextHistorySlot == FilterFrames)
	{
		NextHistorySlot = 0;
		bHistoryWarmup=false;
	}
	//////////////////////////////////////////////////////

	CameraLocation = CamLookAt + (vect(-600, 0, 0) >> CameraRotation);

	if( Trace( HitLocation, HitNormal, CameraLocation, CamLookAt, false, vect(10, 10, 10) ) != None )
	{
		CameraLocation = HitLocation;
	}

	return true;
}

simulated function Destroyed()
{
	//Log("KVehicle Destroyed");

	// If there was a driver in the vehicle, destroy him too
	if(Driver != None)
		Driver.Destroy();

	// Decrease number of cars active out of parent factory
	if(ParentFactory != None)
		ParentFactory.VehicleCount--;

	// Trigger any effects for destruction
	if(DestroyEffectClass != None)
		spawn(DestroyEffectClass, , , Location, Rotation);

	Super.Destroyed();
}

// Just to intercept 'getting out' request.
simulated event Tick(float deltaSeconds)
{
	local bool gotOut;
	if(bGetOut && ROLE==Role_Authority)
	{
		gotOut = KDriverLeave(false);
		if(!gotOut )
		{
			Log("Couldn't Leave - staying in!");
		}
	}
	bGetOut = false;
}

// Includes properties from KActor
defaultproperties
{
    Steering=0
    Throttle=0

	ExitPositions(0)=(X=0,Y=0,Z=0)

	DrivePos=(X=0,Y=0,Z=0)
	DriveRot=()

	bHistoryWarmup = true;


    Physics=PHYS_Karma
	bEdShouldSnap=True
	bStatic=False
	bShadowCast=False
	bCollideActors=True
	bCollideWorld=False
    bProjTarget=True
	bBlockActors=True
	bBlockNonZeroExtentTraces=True
	bBlockZeroExtentTraces=True
	bBlockPlayers=True
	bWorldGeometry=False
	bBlockKarma=True
    CollisionHeight=+000001.000000
	CollisionRadius=+000001.000000
	bAcceptsProjectors=True
	bCanBeBaseForPawns=True
	bAlwaysRelevant=True
	RemoteRole=ROLE_SimulatedProxy
	bNetInitialRotation=True
	bSpecialCalcView=True
	//bSpecialHUD=true
	ScriptedSpeedScale=20.0
	ScriptedDistanceCheck=100.0
	ScriptedThrottleSlow=0.5
	ScriptedThrottleVerySlow=0.2
}
//=============================================================================
// KVehicle spawner location.
//=============================================================================
class KVehicleFactory extends Actor
	placeable;



var()	class<KVehicle>		VehicleClass;
var()	int					MaxVehicleCount;

var		int					VehicleCount;

event Trigger( Actor Other, Pawn EventInstigator )
{
	local KVehicle CreatedVehicle;

	if(VehicleCount >= MaxVehicleCount)
		return;

	if(VehicleClass != None)
	{
		CreatedVehicle = spawn(VehicleClass, , , Location, Rotation);
		VehicleCount++;
		CreatedVehicle.ParentFactory = self;
	}
}


defaultproperties
{
	bHidden=true
	Texture=Texture'Engine.S_VehicleSpawner'
	RemoteRole=ROLE_None
	bNoDelete=True
	bDirectional=true
}
/*=============================================================================
// Ladders are associated with the LadderVolume that encompasses them, and provide AI navigation
// support for ladder volumes.  Direction should be the direction that climbing pawns
// should face
============================================================================= */

class Ladder extends SmallNavigationPoint
	placeable
	native;



var LadderVolume MyLadder;
var Ladder LadderList;

/*
Check if ladder is already occupied
*/
event bool SuggestMovePreparation(Pawn Other)
{
	if ( MyLadder == None )
		return false;

	if ( !MyLadder.InUse(Other) )
	{
		MyLadder.PendingClimber = Other;
		return false;
	}

	Other.Controller.bPreparingMove = true;
	Other.Acceleration = vect(0,0,0);
	return true;
}

defaultproperties
{
	Texture=Texture'Engine.S_Ladder'
	bSpecialMove=true
	bNotBased=true
	bDirectional=true
}
/*=============================================================================
// LadderVolumes, when touched, cause ladder supporting actors to use Phys_Ladder.
// note that underwater ladders won't be waterzones (no breathing problems)
============================================================================= */

class LadderVolume extends PhysicsVolume
	native;



var() name ClimbingAnimation, TopAnimation;	// name of animation to play when climbing this ladder
var() rotator WallDir;
var vector LookDir;
var vector ClimbDir;	// Pawn can move in this direction (or reverse)
var const Ladder LadderList;		// list of Ladder actors associated with this LadderVolume
var() bool	bNoPhysicalLadder;	// if true, won't push into/keep player against geometry in lookdir
var() bool	bAutoPath;			// add top and bottom ladders automatically
var Pawn PendingClimber;

simulated function PostBeginPlay()
{
	local Ladder L, M;
	local vector Dir;

	Super.PostBeginPlay();
	LookDir = vector(WallDir);
	if ( !bAutoPath && (LookDir.Z != 0) )
	{
		ClimbDir = vect(0,0,1);
		for ( L=LadderList; L!=None; L=L.LadderList )
			for ( M=LadderList; M!=None; M=M.LadderList )
				if ( M != L )
				{
					Dir = Normal(M.Location - L.Location);
					if ( (Dir dot ClimbDir) < 0 )
						Dir *= -1;
					ClimbDir += Dir;
				}

		ClimbDir = Normal(ClimbDir);
		if ( (ClimbDir Dot vect(0,0,1)) < 0 )
			ClimbDir *= -1;
	}
}

function bool InUse(Pawn Ignored)
{
	local Pawn StillClimbing;

	ForEach TouchingActors(class'Pawn',StillClimbing)
	{
		if ( (StillClimbing != Ignored) && StillClimbing.bCollideActors && StillClimbing.bBlockActors )
			return true;
	}

	if ( PendingClimber != None )
	{
		if ( (PendingClimber.Controller == None)
			|| !PendingClimber.bCollideActors || !PendingClimber.bBlockActors
			|| (Ladder(PendingClimber.Controller.MoveTarget) == None)
			|| (Ladder(PendingClimber.Controller.MoveTarget).MyLadder != self) )
				PendingClimber = None;
	}
	return ( (PendingClimber != None) && (PendingClimber != Ignored) );
}

simulated event PawnEnteredVolume(Pawn P)
{
	local rotator PawnRot;

	Super.PawnEnteredVolume(P);
	if ( !P.CanGrabLadder() )
		return;

	PawnRot = P.Rotation;
	PawnRot.Pitch = 0;
	if ( (vector(PawnRot) Dot LookDir > 0.9)
		|| ((AIController(P.Controller) != None) && (Ladder(P.Controller.MoveTarget) != None)) )
		P.ClimbLadder(self);
	else if ( !P.bDeleteMe && (P.Controller != None) )
		spawn(class'PotentialClimbWatcher',P);
}

simulated event PawnLeavingVolume(Pawn P)
{
	local Controller C;

	if ( P.OnLadder != self )
		return;
	Super.PawnLeavingVolume(P);
	P.OnLadder = None;
	P.EndClimbLadder(self);
	if ( P == PendingClimber )
		PendingClimber = None;

	// tell all waiting pawns, if not in use
	if ( !InUse(P) )
	{
		for ( C=Level.ControllerList; C!=None; C=C.NextController )
			if ( C.bPreparingMove && (Ladder(C.MoveTarget) != None)
				&&(Ladder(C.MoveTarget).MyLadder == self) )
			{
				C.bPreparingMove = false;
				PendingClimber = C.Pawn;
				return;
			}
	}
}

simulated event PhysicsChangedFor(Actor Other)
{
	if ( (Other.Physics == PHYS_Falling) || (Other.Physics == PHYS_Ladder) || Other.bDeleteMe || (Pawn(Other) == None) || (Pawn(Other).Controller == None) )
		return;
	spawn(class'PotentialClimbWatcher',Other);
}

defaultproperties
{
	RemoteRole=ROLE_SimulatedProxy
	ClimbDir=(X=+0.0,Y=+0.0,Z=+1.0)
	bAutoPath=true
}
//=============================================================================
// LevelInfo contains information about the current level. There should
// be one per level and it should be actor 0. UnrealEd creates each level's
// LevelInfo automatically so you should never have to place one
// manually.
//
// The ZoneInfo properties in the LevelInfo are used to define
// the properties of all zones which don't themselves have ZoneInfo.
//=============================================================================
class LevelInfo extends ZoneInfo
	native
	nativereplication;



// Textures.
#exec Texture Import Name=WhiteSquareTexture File=Textures\White.tga MIPS=OFF COMPRESS=DXT1

var(SplitScreen) transient   CameraEffectManager         CameraEffectManager[2];
var(SplitScreen) transient   int                         CurrentCEM;

//Fade in screen/overlay/map-intro
var byte		m_bFadeScreen;
var float		m_flStartFadeTime;
var float		m_flFadeTime;
var byte		m_bFadeOverlay;
var float		m_flStartFadeOverlayTime;
var float		m_flFadeOverlayTime;
var float		m_flScreenOverlayU;
var float		m_flScreenOverlayV;
var int			m_nJustifyOverlayHorz;
var int			m_nJustifyOverlayVert;
var byte		m_bWideScreen;				// transplanted from wargamehud
var float		m_flStartWideScreenTime;

// CEK: displays date, time, map name for the pre-intro to a map
var byte		m_bFadeMapIntro;
var float		m_flMapIntroTime;
var float		m_flMapIntroStartTime;
var int			m_nMapIntroX;		// left
var int			m_nMapIntroY;		// bottom
var bool		m_bSimpleIntro;		// Display simple, title only, no black background intro text
var bool		m_bStatsAfterFade;	// Display the mission end stats after the fade is complete.
var bool		m_bMPStyleFatigue;	// If true, then use the multiplayer-style fatigue model even on SP games.
var bool		m_bMPStyleWeapons;	// If true, then use the mutlipalyer'style weapon damage, accuracy, etc.
var bool		bSystemPaused;
var bool		bNoAppFocus;		// Set if the game doesn't have focus.  Will be set no matter the game mode.
var bool		m_bInCinematic;		// simple override so mappers can designate non-interactive sequences.
//-----------------------------------------------------------------------------
// Level time.

// Time passage.
var() float TimeDilation;          // Normally 1 - scales real time passage.

// Current time.
var           float	TimeSeconds;   // Time in seconds since level began play.

//// GEARBOX: SJP - Added to keep track of time even when the game is paused
var			  float UniversalTimeSeconds; // Time in seconds since level began play, even if paused.
////

// << GEARBOX/SJP:add - variable: BuildLabel - copy of GBuildLabel from UnCorSc.cpp
var			  bool	 bShowBuildLabel;
var			  String BuildLabel;
// >> GEARBOX

var transient int   Year;          // Year.
var transient int   Month;         // Month.
var transient int   Day;           // Day of month.
var transient int   DayOfWeek;     // Day of week.
var transient int   Hour;          // Hour.
var transient int   Minute;        // Minute.
var transient int   Second;        // Second.
var transient int   Millisecond;   // Millisecond.
var			  float	PauseDelay;		// time at which to start pause

var() bool			bIsAtNight;

//-----------------------------------------------------------------------------
// Level Summary Info

var(LevelSummary) localized String 	Title;
var(LevelSummary)           String 	Author;
var(LevelSummary)			int 	RecommendedNumPlayers;
var(LevelSummary) String			TitleDate;		// constructed by reading "[TitleDay] [TitleDate]" from the map .int file.
var(LevelSummary) String			TitleLocation;	// "St. Come-du-Mont, France" for example

var() config enum EPhysicsDetailLevel
{
	PDL_Low,
	PDL_Medium,
	PDL_High
} PhysicsDetailLevel;

// Karma - jag
// GEARBOX:SJP - Exposed Auto-disable parameters from KarmaSupport.cpp
var(Karma) float KarmaTimeScale;		// Karma physics timestep scaling.
var(Karma) float RagdollTimeScale;		// Ragdoll physics timestep scaling. This is applied on top of KarmaTimeScale.
var(Karma) float KarmaGravScale;		// Allows you to make ragdolls use lower friction than normal.
var(Karma) float KAutoDisableVelocityThreshold;
var(Karma) float KAutoDisableAccelerationThreshold;
var(Karma) float KAutoDisableAngularVelocityThreshold;
var(Karma) float KAutoDisableAngularAccelerationThreshold;
var(Karma) int   MaxRagdolls;			// Maximum number of simultaneous rag-dolls.
var(Karma) bool  bKStaticFriction;		// Better rag-doll/ground friction model, but more CPU.


var()	   bool bKNoInit;				// Start _NO_ Karma for this level. Only really for the Entry level.
// jag

var config float	DecalStayScale;		// 0 to 2 - affects decal stay time

var() localized string LevelEnterText;  // Message to tell players when they enter.
var()           string LocalizedPkg;    // Package to look in for localizations.
var				PlayerReplicationInfo Pauser;          // If paused, name of person pausing the game.
var				PlayerReplicationInfo OraclePauser;		// GEARBOX/jmw:add - Oracle cam special semi-pause mode.
var		LevelSummary Summary;
var           string VisibleGroups;			// List of the group names which were checked when the level was last saved
var transient string SelectedGroups;		// A list of selected groups in the group browser (only used in editor)
//-----------------------------------------------------------------------------
// Flags affecting the level.

var(LevelSummary) bool HideFromMenus;
var() bool           bLonePlayer;     // No multiplayer coordination, i.e. for entranceways.
var bool             bBegunPlay;      // Whether gameplay has begun.
var bool             bPlayersOnly;    // Only update players.
var bool			 bFreezeKarma;    // Stop all Karma physics from being evolved.
var const EDetailMode	DetailMode;      // Client detail mode.
var bool			 bDropDetail;	  // frame rate is below DesiredFrameRate, so drop high detail actors
var bool			 bAggressiveLOD;  // frame rate is well below DesiredFrameRate, so make LOD more aggressive
var bool             bStartup;        // Starting gameplay.
var config bool		 bLowSoundDetail;
var	bool			 bPathsRebuilt;	  // True if path network is valid
var bool			 bHasPathNodes;
var globalconfig bool bCapFramerate;		// frame rate capped in net play if true (else limit number of servermove updates)
var	bool			bLevelChange;
var() bool           bNoSuppressionIcons;
var() bool			 bNoGore;
var(UnitSkill) bool			bUseLevelUnitSkillLevel;	// Use the level defined unit skill level, not the skill levels set per unit.
var	globalconfig bool	m_fIsDemo;
var globalconfig bool	m_fDisableCheckpointGC;
var globalconfig bool	m_fCapturePreloadLog;
var globalconfig bool	m_fFriendlyFire;
var() bool			bUrbanCover;	// If this is set, the cover in the map is more "urban" or city based.
var() bool			bHartsockWounded;	// This sucks, but I need to have a flag to tell if this should be the wounded view or hands.

//-----------------------------------------------------------------------------
// GEARBOX: GBX:naj - Using this variable to allow us to change how the Weapon.ReadyToFire() function 
// behaves without recompiling the source (requires a simple .INI file change).
var globalconfig bool	bUseLegacyReadyToFire;

//-----------------------------------------------------------------------------
// Renderer Management.
var config bool bNeverPrecache;

//
// Pawn pool mangement.
var config bool bPoolPawns;

//-----------------------------------------------------------------------------
// Legend - used for saving the viewport camera positions
var() vector  CameraLocationDynamic;
var() vector  CameraLocationTop;
var() vector  CameraLocationFront;
var() vector  CameraLocationSide;
var() rotator CameraRotationDynamic;

//-----------------------------------------------------------------------------
// Audio properties.

var(Audio) string	Song;			// Filename of the streaming song.
var(Audio) float	PlayerDoppler;	// Player doppler shift, 0=none, 1=full.
var(Audio) float	MusicVolumeOverride;
var(Audio) float	SpeedOfSoundModifier;	// GEARBOX: PSV 4/12/2004 1.0f - 10.0f (This is used when calculating the 
											// speed of sound in the level (world units per second).  For example,
											// a modifier of 1 = 340 meters per second and modifier of 10 = 34 meters per second.
											// The higher the number, the slower sound will travel.

//-----------------------------------------------------------------------------
// Miscellaneous information.

var() float Brightness;
var() texture Screenshot;
var texture DefaultTexture;
var texture WhiteSquareTexture;
var texture LargeVertex;
var int HubStackLevel;
var transient enum ELevelAction
{
	LEVACT_None,
	LEVACT_Loading,
	LEVACT_Saving,
	LEVACT_Connecting,
	LEVACT_Precaching
} LevelAction;

var transient GameReplicationInfo GRI;


// << GEARBOX/jmw:add - FEATURE: Messaging System

//-----------------------------------------------------------------------------
// Gearbox Messaging.

var (Messaging) class< gbxMessageManager > MessageManagerClass;
var gbxMessageManager MessageManager;

// GEARBOX >>

// << GEARBOX/SJP:add - FEATURE: Staggered AI thinking

//-----------------------------------------------------------------------------
// Gearbox AI

var (GearboxAI) float	AIMaxThinkInterval;
var				float	AILastThinkStart;
var				float	AIThinkFraction;
var (GearboxAI) config bool bUseAIDebugCam;

//-----------------------------------------------------------------------------
// Gearbox Impact Manager.

var IImpactManager	ImpactMgr;

//-----------------------------------------------------------------------------
// Gearbox Pawn Cache.

var IGbxPawnList		PawnList;

//-----------------------------------------------------------------------------
// Gearbox Difficulty Manager.

var class<IDifficultyManager>	DifficultyManagerClass;
var IDifficultyManager			DifficultyManager;
var EDifficulty					DifficultyLevel;
var (GearboxAI) bool			AllowLongDistanceAIShots;
var				int				CheckpointID;
var				int				DebugCheckpointID;
var				int				SkirmishCheckpointID;
var				int				SkirmishDebugCheckpointID;
var				float			LongDistanceShotCutoffDist;		// GBX:naj - see bug 10414.
var				float			LongDistanceAccuracyScalar;		// GBX:naj - see bug 10414.

//-----------------------------------------------------------------------------
// Gearbox AI Speech Manager.

var transient IAISpeechManager			TheAISpeechManager;

var transient IImpactManager			TheImpactManager;

//-----------------------------------------------------------------------------
// Gearbox Super-weapon for debugging & testing.
var bool	bWeaponsAreBFG;

//-----------------------------------------------------------------------------
// GBX:RSC - Enables all clients to hear Battle Dialogue in Multiplayer
var globalconfig bool bEnableClientBattleDialogue;
var globalconfig bool bPreloadBattleDialogue;


//-----------------------------------------------------------------------------
// Networking.

var enum ENetMode
{
	NM_Standalone,        // Standalone game.
	NM_DedicatedServer,   // Dedicated server, no local client.
	NM_ListenServer,      // Listen server.
	NM_Client             // Client only, no local server.
} NetMode;

//SDJ 04/09/2004: From UC.
var enum EAuthMode // sjs
{
    AM_None,            // no auth
	AM_SplitScreen,     // Split screen play
	AM_SystemLink,      // System link play
	AM_Live,            // authenticated to 'live'
} AuthMode;

var string ComputerName;  // Machine's name according to the OS.
var string EngineVersion; // Engine version.
var string MinNetVersion; // Min engine version that is net compatible.

//-----------------------------------------------------------------------------
// Gameplay rules

var() string DefaultGameType;
var() string PreCacheGame;
var GameInfo Game;
var float DefaultGravity;

//-----------------------------------------------------------------------------
// Navigation point and Pawn lists (chained using nextNavigationPoint and nextPawn).

var const ActorLite NavigationPointList;
var const Controller ControllerList;
var const PlayerController PlayerControllerList;
var private PlayerController LocalPlayerController;		// player who is client here

//-----------------------------------------------------------------------------
// Server related.

var string NextURL;
var bool bNextItems;
var float NextSwitchCountdown;

//-----------------------------------------------------------------------------
// Global object recycling pool.

var transient ObjectPool	ObjectPool;

//-----------------------------------------------------------------------------
// Additional resources to precache (e.g. Playerskins).

var transient array<material>	PrecacheMaterials;
var transient array<staticmesh> PrecacheStaticMeshes;
var transient array<mesh>		PrecacheMeshes;

//-----------------------------------------------------------------------------
// Replication
var float MoveRepSize;

// these two properties are valid only during replication
var const PlayerController ReplicationViewer;	// during replication, set to the playercontroller to
												// which actors are currently being replicated
var const Actor  ReplicationViewTarget;				// during replication, set to the viewtarget to
												// which actors are currently being replicated

// gam ---
var() bool bMergeGamepadInput;  // Set by attract-mode & live login/logout. !bMergeGamepadInput implies get mad if controller is removed.
// --- gam

// GBX:PAD: Additional value to determine what direction the compass on the HUD should orient toward.
var() Rotator aNorthDirection;

// GBX:PAD: Additional values to control fade in for this level when it's run.
var() bool		m_fStartBlack;			// Start the level faded to black
var() Material	m_aScreenOverlay;		// Start the level with this overlay drawing
var() float		m_flScreenOverlayX;
var() float		m_flScreenOverlayY;
var() Material  m_aKIAOverlay;

// GBX:PAD: Allow the designer to generically limit the visual distance of AI pawns in the map.  Can be used to simulate
// limited visibility in fog or darkness.
var() float		m_flSightRadius;

// GBX:SJP: Allow level designers to limit the orbit theta of oracle cam view per map.  Expressed in degrees from 0.0 to 180.0
var() float		m_flSAViewOrbitTheta;

struct native export PreloadObject
{
	var() string		  ObjectPath;
	var() class<Object>   ObjectClass;
};

var(Preload) editinline array<PreloadObject>	PreloadObjects;

// GBX:CEK: 6/1/2004 - Map list/stats tracker thingy
var() gbxMissionMan MissionManager;

// sjs, amb --- persistant game data management
var() transient GameProfile     CurrentGameProfile;

var(Stats)	int			BestMissionTime;
var(Stats)	int			TotalSquadMembersInMap;

var			int			SquadMembersKilled;
var			float		MissionStartTime;
var			float		NumShotsFired;
var			float		NumShotsHit;
var			float		NumShotsSuppression;
var			float		NumAIShotsFired;
var			float		NumAIShotsHit;
var			float		NumAIShotsSuppression;
var			float		NumKills;
var			float		NumAIKills;

var(UnitSkill)	ESkillLevel		BaseUnitSkillLevel;

var() string			MapFileName;	// storage for the filename since the map forgets its filename after a loadgame.  
var() string			LocalizationFileName;	// holds the name of the default .int file referenced by S_Localize	

var			Actor		m_aSaveCallbackActor;	// Provide an actor for which a precache event will be called so the
												// mapper can specify a list of new assets to load up after the garbage collection and save.
var			float		m_flDoSaveGame;

var			bool		bDefenseDiffHard;

//TriggeredScript ACTION_MoveToward array...
struct native MoveTowardStruct
{
	var Pawn		MyPawn;
	var	ActorLite	MyDest;
	var Actor		MyViewFocus;
	var ActorLite	MyNextNode;
	var byte		bHasReachedDest;	// can't use bools in Unreal script structs
	var float		fCheckBlockingPawnTime;
	var byte		bSteerAroundPawns;
};

//TriggeredScript ACTION_MoveToward array...
struct native VehicleMoveTowardStruct
{
	var Pawn		MyVehicle;
	var int			MyNextNodeIndex;
	var int			VehiclePathTagsPtr;  // this should REALLY be a pointer type not an 'int'
	var ActorLite	MyNextNode;
	var	ActorLite	MyDest;
	var byte		bHasReachedDest;	// can't use bools in Unreal script structs
};

var array<MoveTowardStruct> MoveTowardArray;
var array<VehicleMoveTowardStruct> VehicleMoveTowardArray;

//-----------------------------------------------------------------------------
// Functions.

native simulated function DetailChange(EDetailMode NewDetailMode);
native simulated function bool IsEntry();

native final function Object    SaveGameCreateObject(class objClass, string gameName);
native final function Manifest  SaveGameGetManifest();
native final function Object    SaveGameLoadPackage(string saveGameName);
native final function bool      SaveGameSavePackage(string saveGameName, bool bCreateNew);
native final function bool      SaveGameUnloadPackage(string saveGameName);
native final function bool      SaveGameDeletePackage(string saveGameName, bool bNewGame);
native final function bool      SaveGameIsDirty(string saveGameName);


simulated function PostBeginPlay()
{
	local int i;

    for (i=0; i<2; ++i)
    {
        if (CameraEffectManager[i] == None)
        {
	        CameraEffectManager[i] = new(Outer)class'CameraEffectManager';
	        CameraEffectManager[i].Initialize(self);
	    }
	}

	Super.PostBeginPlay();
	DecalStayScale = FClamp(DecalStayScale,0,2);

	for( i = 0; i < PreloadObjects.Length; ++i )
	{
		DynamicLoadObject( PreloadObjects[ i ].ObjectPath, PreloadObjects[ i ].ObjectClass );
	}
	PreloadObjects.Length = 0;

	MissionManager = Spawn(class'gbxMissionMan');
	MissionStartTime = TimeSeconds;

	Title = S_Localize( "Title", , "LevelInfo" );
	TitleDate = S_Localize( "TitleDay", , "LevelInfo" ) @ S_Localize( "TitleDate", , "LevelInfo" );
	TitleLocation = S_Localize( "TitleLocation", , "LevelInfo" );
}

simulated function PostLoadGame()
{
	local int i;
	local class<IAISpeechManager> AISpeechManagerClass;
	local class<IImpactManager> ImpactMgrClass;
	local string ProfileName;

	if ( TheAISpeechManager == None )
	{
		AISpeechManagerClass = class<IAISpeechManager>( DynamicLoadObject("gbxBase.AISpeechManager", class'Class' ) );
		TheAISpeechManager = Spawn( AISpeechManagerClass );
	}

	if ( ImpactMgr == None )
	{
		ImpactMgrClass = class<IImpactManager>( DynamicLoadObject("gbxBase.ImpactManager", class'Class' ) );
		ImpactMgr = ImpactMgrClass.static.GetInstance( Outer, self );
	}

	for (i=0; i<2; ++i)
    {
        if (CameraEffectManager[i] == None)
        {
	        CameraEffectManager[i] = new(Outer)class'CameraEffectManager';
	        CameraEffectManager[i].Initialize(self);
	    }
	}

	if (m_fCapturePreloadLog)
	{
		ConsoleCommand("PRELOADLOG ENABLE");
	}
	ProfileName = class'GameProfile'.Static.GetCurrentGameProfile(self);
	ConsoleCommand("LOADSAVE PROFILE LOAD DEVICE=0 NAME="$ProfileName);

	bSystemPaused = false;
}

function PostLinearize()
{
	local GameProfile	gProfile;

    Super.PostLinearize();

	if (Netmode == NM_StandAlone)
	{
		gProfile = class'GameProfile'.Static.LoadCurrentGameProfile( Level );
		if (gProfile != None)
		{
			MissionManager.CacheGameProfile( gProfile );
			class'GameProfile'.Static.UnloadProfile( Level, gProfile, false );
		}
		// GBX:PAD: I'm not quite ready to activate this code yet, but I have to check in other stuff, so lets
		// comment this out.
//		if (DifficultyManager != None)
//		{
//			if (DifficultyManager.IsA('DifficultyManagerMP') || DifficultyManager.IsA('DifficultyManagerSkirmish'))
//			{
//				DifficultyManager.destroy();
//				DifficultyManager = None;
//			}
//		}
	}
	else
	{
		// PSV: 4/7/2005  !NM_StandAlone can mean skirmish or multiplayer
        if ( Game != None )
		{
			if ( !Game.IsA('WargameSkirmish') )
			{
				log("Considering changing Level DifficultyManager for MP.  DifficultyManager = " $ DifficultyManager);

				if (DifficultyManager != None)
				{
					if (!DifficultyManager.IsA('DifficultyManagerMP'))
					{
						DifficultyManager.destroy();
						DifficultyManager = None;
					}
				}

				if (DifficultyManager == None)
				{
					// Multiplayer needs its own difficulty manager   2004-04-28 JWS
					DifficultyManagerClass = class<IDifficultyManager>( DynamicLoadObject("gbxAI.DifficultyManagerMP", class'Class' ) );
					DifficultyLevel = DIFF_Authentic; // Matt wants multiplayer to be hardcoded for the hardest setting for now. 2004-07-01 JWS
				
					DifficultyManager = Spawn( DifficultyManagerClass );
					DifficultyManager.SetDifficulty( DifficultyLevel );

					log("Level DifficultyManager set to: " $ DifficultyManager);
					log("Level Applied difficulty=" $ DifficultyManager.GetDifficulty() );
				}
			}
			else	// Skirmish game
			{
				log(self$"Considering changing Level DifficultyManager for Skirmish.  DifficultyManager = " $ DifficultyManager, 'PSV');

				if (DifficultyManager != None)
				{
					if (!DifficultyManager.IsA('DifficultyManagerSkirmish'))
					{
						DifficultyManager.destroy();
						DifficultyManager = None;
					}
				}

				if (DifficultyManager == None)
				{
					// PSV: 4/7/2005 Skirmish needs its own difficulty manager   
					DifficultyManagerClass = class<IDifficultyManager>( DynamicLoadObject("gbxAI.DifficultyManagerSkirmish", class'Class' ) );
					// Default to easy until told otherwise
					DifficultyLevel = DIFF_EASY; 
				
					DifficultyManager = Spawn( DifficultyManagerClass );
					DifficultyManager.SetDifficulty( DifficultyLevel );

					log(self$"Level DifficultyManager set to: " $ DifficultyManager, 'PSV');
					log(self$"Level Applied difficulty=" $ DifficultyManager.GetDifficulty(), 'PSV');
				}
			}
		}
		else
		{
			log(self$" LevelInfo::PostLinearize() Game == None so we don't know which DifficultyManager to spawn!", 'PSV');
		}
	}
}

simulated event UpdateDistanceFadeScale(bool UseSplitScreenDistanceFade)
{
	local ZoneInfo Zone;

	foreach AllActors(class'ZoneInfo', Zone)
	{
		if (UseSplitScreenDistanceFade)
		{
			Zone.DistanceFadeScale = Zone.SplitScreenDistanceFadeScale;
		}
		else
		{
			Zone.DistanceFadeScale = Zone.default.DistanceFadeScale;
		}
	}
}

simulated function class<GameInfo> GetGameClass()
{
	local class<GameInfo> G;

	if(Level.Game != None)
		return Level.Game.Class;

	if (GRI != None && GRI.GameClass != "")
		G = class<GameInfo>(DynamicLoadObject(GRI.GameClass,class'Class'));
	if(G != None)
		return G;

	if ( DefaultGameType != "" )
		G = class<GameInfo>(DynamicLoadObject(DefaultGameType,class'Class'));

	return G;
}

simulated event FillPrecacheMaterialsArray()
{
	local Actor A;
	local class<GameInfo> G;

	if ( NetMode == NM_DedicatedServer )
		return;
	if ( Level.Game == None )
	{
		if ( (GRI != None) && (GRI.GameClass != "") )
			G = class<GameInfo>(DynamicLoadObject(GRI.GameClass,class'Class'));
		if ( (G == None) && (DefaultGameType != "") )
			G = class<GameInfo>(DynamicLoadObject(DefaultGameType,class'Class'));
		if ( G == None )
			G = class<GameInfo>(DynamicLoadObject(PreCacheGame,class'Class'));
		if ( G != None )
			G.Static.PreCacheGameTextures(self);
	}
	ForEach AllActors(class'Actor',A)
	{
		A.UpdatePrecacheMaterials();
	}
}

simulated event FillPrecacheStaticMeshesArray()
{
	local Actor A;
	local class<GameInfo> G;

	if ( NetMode == NM_DedicatedServer )
		return;
	if ( Level.Game == None )
	{
		if ( (GRI != None) && (GRI.GameClass != "") )
			G = class<GameInfo>(DynamicLoadObject(GRI.GameClass,class'Class'));
		if ( (G == None) && (DefaultGameType != "") )
			G = class<GameInfo>(DynamicLoadObject(DefaultGameType,class'Class'));
		if ( G == None )
			G = class<GameInfo>(DynamicLoadObject(PreCacheGame,class'Class'));
		if ( G != None )
			G.Static.PreCacheGameStaticMeshes(self);
	}

	ForEach AllActors(class'Actor',A)
		A.UpdatePrecacheStaticMeshes();
}

simulated event FillPrecacheMeshesArray()
{
	local Actor A;
	local class<GameInfo> G;

	if ( NetMode == NM_DedicatedServer )
		return;
	if ( Level.Game == None )
	{
		if ( (GRI != None) && (GRI.GameClass != "") )
			G = class<GameInfo>(DynamicLoadObject(GRI.GameClass,class'Class'));
		if ( (G == None) && (DefaultGameType != "") )
			G = class<GameInfo>(DynamicLoadObject(DefaultGameType,class'Class'));
		if ( G == None )
			G = class<GameInfo>(DynamicLoadObject(PreCacheGame,class'Class'));
		if ( G != None )
			G.Static.PreCacheGameMeshes(self);
	}

	ForEach AllActors(class'Actor',A)
		A.UpdatePrecacheMeshes();
}

simulated function AddPrecacheMaterial(Material mat)
{
    local int Index;

	if ( NetMode == NM_DedicatedServer )
		return;
    if (mat == None)
        return;

    Index = Level.PrecacheMaterials.Length;
    PrecacheMaterials.Insert(Index, 1);
	PrecacheMaterials[Index] = mat;
}

simulated function AddPrecacheStaticMesh(StaticMesh stat)
{
    local int Index;

	if ( NetMode == NM_DedicatedServer )
		return;
    if (stat == None)
        return;

    Index = Level.PrecacheStaticMeshes.Length;
    PrecacheStaticMeshes.Insert(Index, 1);
	PrecacheStaticMeshes[Index] = stat;
}

simulated function AddPrecacheMesh(Mesh stat)
{
    local int Index;

	if ( NetMode == NM_DedicatedServer )
		return;
    if (stat == None)
        return;

    Index = Level.PrecacheMeshes.Length;
    PrecacheMeshes.Insert(Index, 1);
	PrecacheMeshes[Index] = stat;
}

//
// Return the URL of this level on the local machine.
//
native simulated function string GetLocalURL();

//
// Demo build flag
//
native simulated final function bool IsDemoBuild();  // True if this is a demo build.


//
// XBOX flag
//
native simulated static final function bool IsXbox();		// true if this is running on xbox

//
// Return the URL of this level, which may possibly
// exist on a remote machine.
//
native simulated function string GetAddressURL();

//
// Jump the server to a new level.
//
event ServerTravel( string URL, bool bItems )
{
    local PlayerController P;

	if( NextURL=="" )
	{
		// gam ---
		if( (Game != None) && ((NetMode == NM_DedicatedServer) || (NetMode == NM_ListenServer) ) )
		{
            if( !Game.PreServerTravel(URL) )
            {
                foreach DynamicActors( class'PlayerController', P )
                {
                    if( NetConnection(P.Player)!=None )
                        continue;

                    P.ClientTravel( "?failed", TRAVEL_Relative, false ); // TODO we need this 2004-06-07 JWS
                    return;
                }
                return;
            }
        }
        // --- gam

		bLevelChange = true;
		bNextItems          = bItems;
		NextURL             = URL;
		if( Game!=None )
			Game.ProcessServerTravel( URL, bItems );
		else
			NextSwitchCountdown = 0;
	}
}

//
// ensure the DefaultPhysicsVolume class is loaded.
//
function ThisIsNeverExecuted()
{
	local DefaultPhysicsVolume P;
	P = None;
}

/* Reset()
reset actor to initial state - used when restarting level without reloading.
*/
function Reset()
{
	// perform garbage collection of objects (not done during gameplay)
	ConsoleCommand("OBJ GARBAGE");
	if (m_fCapturePreloadLog)
	{
		ConsoleCommand("PRELOADLOG DISABLE");
	}
	Super.Reset();
}

//-----------------------------------------------------------------------------
// Network replication.

replication
{
	reliable if( bNetDirty && Role==ROLE_Authority )
		Pauser, OraclePauser, TimeDilation, DefaultGravity, AuthMode;

	reliable if( bNetInitial && Role==ROLE_Authority )
		RagdollTimeScale, KarmaTimeScale, KarmaGravScale;
}

//
//	PreBeginPlay
//

simulated event PreBeginPlay()
{
	local class<IImpactManager> ImpactMgrClass;
	local class<IAISpeechManager> AISpeechManagerClass;
	local String SelfName;

	// Create the object pool.

	ObjectPool = new( Outer ) class'ObjectPool';	// GBX:naj - modified 3/11/04

// << GEARBOX/jmw:add - FEATURE: Messaging System
	SelfName = String(Self);
	if( Role == ROLE_Authority && 
		InStr(SelfName, "Entry") < 0 && 
		InStr(SelfName, "Startup") < 0 && 
		InStr(SelfName, "legal") < 0 && 
		InStr(SelfName, "Menu_map") < 0 )
	{
		MessageManager = Spawn( MessageManagerClass );
	}
// GEARBOX >>

// << GEARBOX/SJP:add - FEATURE: AI think interval
	AILastThinkStart = 0.0;
	AIThinkFraction = AIMaxThinkInterval * 2;
// GEARBOX >>

	// GBX:naj - Create the Impact Manager.
	ImpactMgrClass = class<IImpactManager>( DynamicLoadObject("gbxBase.ImpactManager", class'Class' ) );
	ImpactMgr = ImpactMgrClass.static.GetInstance( Outer, self );

	// GBX:naj - Create the pawn cache.
	ResetPawnList();

	log( self$ " LevelInfo::PreBeginPlay() About to create difficulty manager...", 'PSV' );

	// GBX:naj - Create the Difficulty Manager.
	if (NetMode == NM_Standalone)
	{
		log( self$ " LevelInfo::PreBeginPlay() Creating gbxAI.DifficultyManager", 'PSV' );
		DifficultyManagerClass = class<IDifficultyManager>( DynamicLoadObject("gbxAI.DifficultyManager", class'Class' ) );
	}
	else // Multiplayer needs its own difficulty manager   2004-04-28 JWS
	{
		if ( Game.IsA('WargameSkirmish') )
		{
			log( self$ " LevelInfo::PreBeginPlay() Creating gbxAI.DifficultyManagerSkirmish", 'PSV' );
			DifficultyManagerClass = class<IDifficultyManager>( DynamicLoadObject("gbxAI.DifficultyManagerSkirmish", class'Class' ) );
		}
		else
		{
			log( self$ " LevelInfo::PreBeginPlay() Creating gbxAI.DifficultyManagerMP", 'PSV' );
			DifficultyManagerClass = class<IDifficultyManager>( DynamicLoadObject("gbxAI.DifficultyManagerMP", class'Class' ) );
			DifficultyLevel = DIFF_Authentic; // Matt wants multiplayer to be hardcoded for the hardest setting for now. 2004-07-01 JWS
		}
	}

	log( self$ " LevelInfo::PreBeginPlay() Setting difficultylevel to " $DifficultyLevel, 'PSV' );

	DifficultyManager = Spawn( DifficultyManagerClass );
	DifficultyManager.SetDifficulty( DifficultyLevel );

	log("Level DifficultyManager set to: " $ DifficultyManager, 'PSV');
	log("Level Applied difficulty=" $ DifficultyManager.GetDifficulty(), 'PSV' );

	// GBX:jmw - Create the AI Speech Manager.
	AISpeechManagerClass = class<IAISpeechManager>( DynamicLoadObject("gbxBase.AISpeechManager", class'Class' ) );
	TheAISpeechManager = Spawn( AISpeechManagerClass );

	// GBX:CEK stash away the map file name
	if (MapFileName == "")
	{
		MapFileName = String(self);
		MapFileName = Caps(Left( MapFileName, InStr(MapFileName, ".") ));
	}
}

simulated function Pawn GetLocalPlayerPawn()
{
	local PlayerController PC;

	// get the playerpawn
	PC = GetLocalPlayerController();
	if ( PC != None )
	{
		return PC.Pawn;
	}
	else
	{
		Log( "LevelInfo::GetLocalPlayerPawn(): PlayerController NOT Found", 'RSC' );
		return None;
	}
}

simulated function PlayerController GetLocalPlayerController()
{
	local PlayerController PC;

	if ( Level.NetMode == NM_DedicatedServer )
		return None;
	if ( LocalPlayerController != None )
		return LocalPlayerController;

	ForEach DynamicActors(class'PlayerController', PC)
	{
		if ( Viewport(PC.Player) != None )
		{
			LocalPlayerController = PC;
			break;
		}
	}
	return LocalPlayerController;
}

// << GEARBOX/SJP:add - FEATURE: AI think interval
simulated function float AIGetNextThinkStart()
{
	if( AILastThinkStart - AIThinkFraction <= 0.0f )
	{
		AIThinkFraction /= 2;
		AILastThinkStart = AIMaxThinkInterval - (AIThinkFraction / 2);
	}
	else
	{
		AILastThinkStart -= AIThinkFraction;
	}

	return AILastThinkStart;
}
// GEARBOX >>

// GBX:naj - added 11/19/03 - functions for the global pawn cache.
simulated event ResetPawnList()
{
	local class<IGbxPawnList> PawnListClass;

	if ( PawnList != None )
	{
		PawnList.Reset();
	}
	else
	{
		PawnListClass = class<IGbxPawnList>( DynamicLoadObject( "gbxBase.gbxPawnList", class'Class' ) );
		PawnList = Spawn( PawnListClass );
	}
}

simulated event IgbxPawnList GetPawnList()
{
	return PawnList;
}
// GBX:naj - end added 11/19/03

simulated function bool IsPaused()
{
	if (bSystemPaused)
		return true;
	return ( Pauser != None && ( TimeSeconds >= PauseDelay )) || OraclePauser != None;
}

simulated function string GetLevelFileName()
{
	return MapFileName;
}

simulated event bool IsMenuMap()
{
	return Left(GetLevelFileName(), 5) ~= "Menu_";
}

// Moved here from TriggeredScript.uc so that other parts of the code could use it easily 2004-09-28 JWS
simulated function string S_Localize(string KeyString, optional string IntFileName, optional string SectionName)
{
	if (SectionName == "")
	{
		SectionName = "LocalizedStrings";
	}

	if (IntFileName == "")
	{
		if (LocalizationFileName != "")
			IntFileName = LocalizationFileName;
		else
			IntFileName = "S_" $Caps(GetLevelFileName());

		Log( "S_Localize using int file " $IntFileName, 'TriggeredScript' );
	}

	return Localize(SectionName, KeyString, IntFileName);
}

simulated function bool UseMPStyleFatigue()
{
	local bool bUseMPStyle;

	if ( Level.m_bMPStyleFatigue )
		bUseMPStyle = true;
	else
		bUseMPStyle = false;

	return bUseMPStyle;
}

defaultproperties
{
	PreCacheGame="Engine.GameInfo"
    RemoteRole=ROLE_DumbProxy
	 bAlwaysRelevant=true
     TimeDilation=+00001.000000
	 Brightness=1
     bHiddenEd=True
	 DefaultTexture=DefaultTexture
	 WhiteSquareTexture=WhiteSquareTexture
	 LargeVertex=S_Vertex
	 HubStackLevel=0
	 DetailMode=DM_SuperHigh
	 PlayerDoppler=0
	 bWorldGeometry=true
	 VisibleGroups="None"
         KarmaTimeScale=0.9
         RagdollTimeScale=1
         MaxRagdolls=4
         bKStaticFriction=true
         KarmaGravScale=1
	 PhysicsDetailLevel=PDL_High
    DefaultGravity=-1500.0
	bCapFramerate=true

	DifficultyLevel=DIFF_Hard

     Title="Untitled"
    MoveRepSize=+64.0
    MusicVolumeOverride=-1
	SpeedOfSoundModifier=1.5

// << GEARBOX/jmw:add - FEATURE: Messaging System
	MessageManagerClass=class'gbxMessageManager'
// GEARBOX >>

// << GEARBOX/SJP:add - FEATURE: AI think interval
	AIMaxThinkInterval=+00000.500000
	AILastThinkStart=-000001.000000
// GEARBOX >>

// GBX:PAD: default m_flSightRadius to 0 so it won't override the regular sight distance by default.
	m_flSightRadius=0
	
	m_bFadeScreen=3	// Set to FADE_START_BLACK
	m_bFadeOverlay=3
	m_bFadeMapIntro=0

	BaseUnitSkillLevel=SKILL_Novice
	bUseLevelUnitSkillLevel=true

	m_flDoSaveGame=-1.0
	
	bPoolPawns=false
	
	CheckpointID=0
	DebugCheckpointID=-1
	SkirmishCheckpointID=0
	SkirmishDebugCheckpointID=-1

	// Defaults from KarmaSupport.cpp
	KAutoDisableVelocityThreshold=+00000.150000 //+00000.020000
	KAutoDisableAccelerationThreshold=+00000.150000 //+00000.050000
	KAutoDisableAngularVelocityThreshold=+00000.090000 //+00000.001000
	KAutoDisableAngularAccelerationThreshold=+00000.150000 //+00000.050000

	m_nMapIntroX=-1
	m_nMapIntroY=-1
	
	m_flSAViewOrbitTheta=0.0 // 0.0 lets the oracle camera set it's default

	bUseLegacyReadyToFire=false
	bEnableClientBattleDialogue=true
	bPreloadBattleDialogue=false
	bDefenseDiffHard = false;
	bNoGore=false
}
class LevelLoadingView extends SmallNavigationPoint
	placeable
	native;

defaultproperties
{
	bDirectional=true;
}//=============================================================================
// LevelSummary contains the summary properties from the LevelInfo actor.
// Designed for fast loading.
//=============================================================================
class LevelSummary extends Object
	native;



//-----------------------------------------------------------------------------
// Properties.

// From LevelInfo.
var() localized string Title;
var()           string Author;
var() int	IdealPlayerCount;
var() localized string LevelEnterText;

defaultproperties
{
}
//=============================================================================
// LiftCenter.
//=============================================================================
class LiftCenter extends NavigationPoint
	placeable
	native;



var() name LiftTag;
var	 mover MyLift;
var() name LiftTrigger;
var trigger RecommendedTrigger;
var float MaxDist2D;
var vector LiftOffset;	// starting vector between MyLift location and LiftCenter location

function PostBeginPlay()
{
	if ( LiftTrigger != '' )
		ForEach DynamicActors(class'Trigger', RecommendedTrigger, LiftTrigger )
			break;
	Super.PostBeginPlay();
}

/* SpecialHandling is called by the navigation code when the next path has been found.
It gives that path an opportunity to modify the result based on any special considerations

Here, we check if the mover needs to be triggered
*/

function Actor SpecialHandling(Pawn Other)
{
	// if no lift, no special handling
	if ( MyLift == None )
		return self;

	// check whether or not need to trigger the lift
	if ( !MyLift.IsInState('StandOpenTimed') )
	{
		if ( MyLift.bClosed
			&& (RecommendedTrigger != None) )
			return RecommendedTrigger;
	}
	else if ( MyLift.BumpType == BT_PlayerBump && !Other.IsPlayerPawn() )
		return None;

	return self;
}

/*
Check if mover is positioned to allow Pawn to get on
*/
function bool SuggestMovePreparation(Pawn Other)
{
	// if already on lift, no problem
	if ( Other.base == MyLift )
		return false;

	// make sure LiftCenter is correctly positioned on the lift
	SetLocation(MyLift.Location + LiftOffset);
	SetBase(MyLift);

	// if mover is moving, wait
	if ( MyLift.bInterpolating || !ProceedWithMove(Other) )
	{
		Other.Controller.WaitForMover(MyLift);
		return true;
	}

	return false;
}

function bool ProceedWithMove(Pawn Other)
{
	local LiftExit Start;
	local float dist2D;
	local vector dir;

	// see if mover is at appropriate location/keyframe
	Start = LiftExit(Other.Anchor);

	if ( (Start != None) && (Start.KeyFrame != 255) )
	{
		if ( MyLift.KeyNum == Start.KeyFrame )
			return true;
	}
	else
	{
		//check distance directly - make sure close
		dir = Location - Other.Location;
		dir.Z = 0;
		dist2d = vsize(dir);
		if ( (Location.Z - CollisionHeight < Other.Location.Z - Other.CollisionHeight + MAXSTEPHEIGHT)
			&& (Location.Z - CollisionHeight > Other.Location.Z - Other.CollisionHeight - 1200)
			&& ( dist2D < MaxDist2D) )
		{
			return true;
		}
	}

	// if mover not operating, need to start it
	if ( MyLift.bClosed )
	{
		Other.SetMoveTarget(SpecialHandling(Other));
		return true;
	}

	return false;
}

defaultproperties
{
	Texture=Texture'Engine.S_LiftCenter'
	RemoteRole=ROLE_None
	bStatic=false
	bSpecialMove=true
	ExtraCost=400
	MaxDist2D=+400.000
	bNeverUseStrafing=true
	bForceNoStrafing=true
}
//=============================================================================
// LiftExit.
//=============================================================================
class LiftExit extends NavigationPoint
	placeable
	native;



var() name LiftTag;
var	Mover MyLift;
var() byte SuggestedKeyFrame;	// mover keyframe associated with this exit - optional
var byte KeyFrame;

event bool SuggestMovePreparation(Pawn Other)
{
	local Controller C;

	if ( (MyLift == None) || (Other.Controller == None) )
		return false;
	if ( Other.Physics == PHYS_Flying )
	{
		if ( Other.AirSpeed > 0 )
			Other.Controller.MoveTimer = 2+ VSize(Location - Other.Location)/Other.AirSpeed;
		return false;
	}
	if ( (Other.Base == MyLift)
			|| ((LiftCenter(Other.Anchor) != None) && (LiftCenter(Other.Anchor).MyLift == MyLift)
				&& (Other.ReachedDestination(Other.Anchor))) )
	{
		// if Pawn is on the lift, see if it can get off and go to this lift exit
		if ( (Location.Z < Other.Location.Z + Other.CollisionHeight)
			 && Other.LineOfSightTo(self) )
			return false;

		// make Pawn wait on the lift
		Other.DesiredRotation = rotator(Location - Other.Location);
		Other.Controller.WaitForMover(MyLift);
		return true;
	}
	else
	{
		for ( C=Level.ControllerList; C!=None; C=C.nextController )
			if ( (C.Pawn != None) && (C.PendingMover == MyLift) && C.SameTeamAs(Other.Controller) && C.Pawn.ReachedDestination(self) )
			{
				Other.DesiredRotation = rotator(Location - Other.Location);
				Other.Controller.WaitForMover(MyLift);
				return true;
			}
	}
	return false;
}

defaultproperties
{
	Texture=Texture'Engine.S_LiftExit'
	SuggestedKeyFrame=255
	bSpecialMove=true
	bNeverUseStrafing=true
	bForceNoStrafing=true
}
//=============================================================================
// The light class.
//=============================================================================
class Light extends Actor
	placeable
	native;



var (Corona)	float	MinCoronaSize;
var (Corona)	float	MaxCoronaSize;
var (Corona)	float	CoronaRotation;
var (Corona)	float	CoronaRotationOffset;
var (Corona)	bool	UseOwnFinalBlend;

defaultproperties
{
     bStatic=True
     bHidden=True
     bNoDelete=True
     Texture=Texture'Engine.S_Light'
     CollisionRadius=+00024.000000
     CollisionHeight=+00024.000000
     LightType=LT_Steady
     LightBrightness=64
     LightSaturation=0
     LightRadius=64
     LightPeriod=32
     LightCone=128
	 bMovable=False
	 MinCoronaSize=0;
	 MaxCoronaSize=1000;
}
//=============================================================================
// LineOfSightTrigger
// triggers its event when player looks at it from close enough
// ONLY WORKS IN SINGLE PLAYER (or for the local client on a listen server)
// You could implement a multiplayer version using a tick function and PlayerCanSeeMe(),
// but that would have more performance cost
//=============================================================================
class LineOfSightTrigger extends Triggers
	native;



var() float MaxViewDist;	// maximum distance player can be from this trigger to trigger it
var   float OldTickTime;
var() bool  bEnabled;
var	  bool  bTriggered;
var() name	SeenActorTag;	// tag of actor which triggers this trigger when seen
var	  actor SeenActor;
var() int MaxViewAngle;		// how directly a player must be looking at SeenActor center (in degrees)
var float RequiredViewDir;	// how directly player must be looking at SeenActor - 1.0 = straight on, 0.75 = barely on screen

function PostBeginPlay()
{
	Super.PostBeginPlay();

	RequiredViewDir = cos(MaxViewAngle * PI/180);
	if ( SeenActorTag != '' )
		ForEach AllActors(class'Actor',SeenActor,SeenActorTag)
			break;
}

event PlayerSeesMe(PlayerController P)
{
	TriggerEvent(Event,self,P.Pawn);
	bTriggered = true;
}

function Trigger( actor Other, Pawn EventInstigator )
{
	bEnabled = true;
}

defaultproperties
{
	Texture=Texture'Engine.S_TriggerLineOfSight'
	MaxViewDist=+3000.0
	bEnabled=true
    bCollideActors=false
	MaxViewAngle=15
}
//=============================================================================
// LocalMessage
//
// LocalMessages are abstract classes which contain an array of localized text.
// The PlayerController function ReceiveLocalizedMessage() is used to send messages
// to a specific player by specifying the LocalMessage class and index.  This allows
// the message to be localized on the client side, and saves network bandwidth since
// the text is not sent.  Actors (such as the GameInfo) use one or more LocalMessage
// classes to send messages.  The BroadcastHandler function BroadcastLocalizedMessage()
// is used to broadcast localized messages to all the players.
//
//=============================================================================
class LocalMessage extends Info;



var bool	bComplexString;									// Indicates a multicolor string message class.
var bool	bIsSpecial;										// If true, don't add to normal queue.
var bool	bIsUnique;										// If true and special, only one can be in the HUD queue at a time.
var bool	bIsConsoleMessage;								// If true, put a GetString on the console.
var bool	bFadeMessage;									// If true, use fade out effect on message.
var bool	bBeep;											// If true, beep!
var bool	bOffsetYPos;									// If the YPos indicated isn't where the message appears.
var bool	bCenter;										// Whether or not to center the message.
var bool	bFromBottom;									// Subtract YPos.
var int		Lifetime;										// # of seconds to stay in HUD message queue.

var(Message) class<LocalMessage> ChildMessage;                      // In some cases, we need to refer to a child message.

var Color  DrawColor;
var float XPos, YPos;
var int FontSize;                                          // 0: Huge, 1: Big, 2: Small ...

static function RenderComplexMessage(
	Canvas Canvas,
	out float XL,
	out float YL,
	optional String MessageString,
	optional int Switch,
	optional PlayerReplicationInfo RelatedPRI_1,
	optional PlayerReplicationInfo RelatedPRI_2,
	optional Object OptionalObject
	);

static function string GetRelatedString(
    optional int Switch,
    optional PlayerReplicationInfo RelatedPRI_1,
    optional PlayerReplicationInfo RelatedPRI_2,
    optional Object OptionalObject
    )
{
    return static.GetString(Switch,RelatedPRI_1,RelatedPRI_2,OptionalObject);
}

static function string GetString(
	optional int Switch,
	optional PlayerReplicationInfo RelatedPRI_1,
	optional PlayerReplicationInfo RelatedPRI_2,
	optional Object OptionalObject
	)
{
	if ( class<Actor>(OptionalObject) != None )
		return class<Actor>(OptionalObject).static.GetLocalString(Switch, RelatedPRI_1, RelatedPRI_2);
	return "";
}

static function string AssembleString(
	HUD myHUD,
	optional int Switch,
	optional PlayerReplicationInfo RelatedPRI_1,
	optional String MessageString
	)
{
	return "";
}

static function ClientReceive(
	PlayerController P,
	optional int Switch,
	optional PlayerReplicationInfo RelatedPRI_1,
	optional PlayerReplicationInfo RelatedPRI_2,
	optional Object OptionalObject
	)
{
	if ( P.myHud != None )
	P.myHUD.LocalizedMessage( Default.Class, Switch, RelatedPRI_1, RelatedPRI_2, OptionalObject );

    if ( Default.bIsConsoleMessage && (P.Player != None) && (P.Player.Console != None) )
		P.Player.InteractionMaster.Process_Message( Static.GetString( Switch, RelatedPRI_1, RelatedPRI_2, OptionalObject ), 6.0, P.Player.LocalInteractions);
}

static function color GetConsoleColor( PlayerReplicationInfo RelatedPRI_1 )
{
    return Default.DrawColor;
}

static function color GetColor(
	optional int Switch,
	optional PlayerReplicationInfo RelatedPRI_1,
	optional PlayerReplicationInfo RelatedPRI_2
	)
{
	return Default.DrawColor;
}

static function float GetOffset(int Switch, float YL, float ClipY )
{
	return Default.YPos;
}

static function int GetFontSize( int Switch, PlayerReplicationInfo RelatedPRI1, PlayerReplicationInfo RelatedPRI2, PlayerReplicationInfo LocalPlayer )
{
    return default.FontSize;
}

static function float GetLifeTime(int Switch)
{
    return default.LifeTime;
}

defaultproperties
{
    bIsSpecial=true
    bIsUnique=False
	Lifetime=3
	bIsConsoleMessage=True

	DrawColor=(R=181,G=181,B=153,A=255)
    XPos=0.5
    YPos=0.7
}
//=============================================================================
// LookTarget
//
// A convenience actor that you can point a matinee camera at.
//
// Isn't bStatic so you can attach these to movers and such.
//
//=============================================================================
class LookTarget extends KeyPoint
	native;



// Sprite.
defaultproperties
{
     bStatic=false
	 bNoDelete=true
     bHidden=True
     SoundVolume=0
	 Texture=Texture'Engine.S_LookTarget'
}
class Manifest extends Object
    native;

struct native MaaSkirmishMapStats
{
	var		string		MapName;
	var		int			nMaxWaves;
	var		int			flBestTime[4];
	var		int			HighestDifficulty;
};

const cNumLadders = 4;

struct native ManifestEntry
{
    var Object  		gProfile;
    var string  		GameName;
    var string  		ProfileName;
	var byte			bCompleted[4];			// has entire difficulty been completed?
	var byte			bCompletedFilm[4];		// how many film chapters have been completed?
	var int				LastMissionCompleted;	// mirrors GetContinueMission from profile

    var int     		Size; 
    var string  		Date;
    var string  		Time;
    var int     		Corrupt;

	// skirmish high-scores
	var int				SkirmishToDLevelSolo[2];	// US/DE
	var int				SkirmishToDLevelCoop[2];
	var	array<MaaSkirmishMapStats>	SkirmishMapStatsSaved;
};

var() transient const array<ManifestEntry> ManifestEntries;

event FillSavedGameInfo(int manifestIndex)
{
    local GameProfile gProfile;
    local ManifestEntry entry;
	local int i;

    entry = ManifestEntries[manifestIndex];

    gProfile = GameProfile(entry.gProfile);

	entry.ProfileName = gProfile.GetGameName();
	entry.LastMissionCompleted = gProfile.LastMissionCompleted;
	for (i=0; i<4; i++)
	{
		entry.bCompleted[i] = gProfile.CompletedDifficulty(EDifficulty(i));
		entry.bCompletedFilm[i] = gProfile.CompletedDifficulty(EDifficulty(i), true);
	}

	// skirmish high-score cache
	entry.SkirmishToDLevelSolo[0] = gProfile.SkirmishToDLevelSolo[0];
	entry.SkirmishToDLevelSolo[1] = gProfile.SkirmishToDLevelSolo[1];
	entry.SkirmishToDLevelCoop[0] = gProfile.SkirmishToDLevelCoop[0];
	entry.SkirmishToDLevelCoop[1] = gProfile.SkirmishToDLevelCoop[1];

	entry.SkirmishMapStatsSaved.Length = gProfile.SkirmishMapStatsSaved.Length;
	for (i=0; i<gProfile.SkirmishMapStatsSaved.Length; i++)
	{
		entry.SkirmishMapStatsSaved[i].MapName = gProfile.SkirmishMapStatsSaved[i].MapName;
		entry.SkirmishMapStatsSaved[i].nMaxWaves = gProfile.SkirmishMapStatsSaved[i].nMaxWaves;
		entry.SkirmishMapStatsSaved[i].flBestTime[0] = gProfile.SkirmishMapStatsSaved[i].flBestTime[0];
		entry.SkirmishMapStatsSaved[i].flBestTime[1] = gProfile.SkirmishMapStatsSaved[i].flBestTime[1];
		entry.SkirmishMapStatsSaved[i].flBestTime[2] = gProfile.SkirmishMapStatsSaved[i].flBestTime[2];
		entry.SkirmishMapStatsSaved[i].flBestTime[3] = gProfile.SkirmishMapStatsSaved[i].flBestTime[3];
		entry.SkirmishMapStatsSaved[i].HighestDifficulty = gProfile.SkirmishMapStatsSaved[i].HighestDifficulty;
	}

	ManifestEntries[manifestIndex] = entry;
}

function bool GetManifestEntry(out ManifestEntry entry, string ProfileName)
{
	local int i;

	for (i=0; i<ManifestEntries.Length; i++)
	{
		if (ManifestEntries[i].ProfileName == ProfileName)
		{
			entry = ManifestEntries[i];
			return true;
		}
	}

	log("Failed to find profile " $ProfileName $" in manifest.", 'guilog');
	return false;
}
function bool FindMapScores(out MaaSkirmishMapStats MapStats, Manifest.ManifestEntry mEntry, string mapName)
{
	local int i;

	for (i=0; i<mEntry.SkirmishMapStatsSaved.Length; i++)
	{
		if (mapName ~= mEntry.SkirmishMapStatsSaved[i].MapName)
		{
//			log("FindMapScores found " $mapName, 'guilog');
			MapStats = mEntry.SkirmishMapStatsSaved[i];
			return true;
		}
	}

//	log("FindMapScores failed for " $mapName, 'guilog');
	return false;
}

function int GetScore(Manifest.ManifestEntry mEntry, int modeChoice, string mapName, optional bool bCoop, optional int ToDIndex)
{
	local int result;
	local MaaSkirmishMapStats MapStats;

	result = -1;
	switch(modeChoice)
	{
		case 1:	// SGT_TimeChallenge
			if ((ToDIndex >= 0) && (ToDIndex <= 3) && FindMapScores(MapStats, mEntry, mapName))
				result = MapStats.flBestTime[ToDIndex];
			else
				result = 0;
			break;
		case 2:	// SGT_Defense
			if (FindMapScores(MapStats, mEntry, mapName))
				result = MapStats.nMaxWaves;
			else
				result = 0;
			break;

		case 3:	// SGT_TourOfDuty
			if (ToDIndex == 0)
			{
				if ( Left(mapName, 6) ~= "SKR_DE" )
					ToDIndex = 2;
				else
					ToDIndex = 1;
			}

			ToDIndex--;

			if (bCoop)
				result = mEntry.SkirmishToDLevelCoop[ToDIndex];
			else
				result = mEntry.SkirmishToDLevelSolo[ToDIndex];

			break;

		case 0:	// SGT_Objective
			if (FindMapScores(MapStats, mEntry, mapName))
				result = MapStats.HighestDifficulty;
			else
				result = 0;

			break;

		default:
			break;
	}

	return result;
}
//=============================================================================
// MapList.
//
// contains a list of maps to cycle through
//
//=============================================================================
class MapList extends Info
	abstract;



var(Maps) config array<string> Maps;
var config int MapNum;

function string GetNextMap()
{
	local string CurrentMap;
	local int i;

	CurrentMap = GetURLMap();
	if ( CurrentMap != "" )
	{
		if ( Right(CurrentMap,4) ~= ".gbxmap" )
			CurrentMap = CurrentMap;
		else
			CurrentMap = CurrentMap$".gbxmap";

		for ( i=0; i<Maps.Length; i++ )
		{
			if ( CurrentMap ~= Maps[i] )
			{
				MapNum = i;
				break;
			}
		}
	}

	// search vs. w/ or w/out .gbxmap extension

	MapNum++;
	if ( MapNum > Maps.Length - 1 )
		MapNum = 0;
	if ( Maps[MapNum] == "" )
		MapNum = 0;

	SaveConfig();
	return Maps[MapNum];
}
//=============================================================================
// MatAction: Base class for Matinee actions.
//=============================================================================

class MatAction extends MatObject
	abstract
	native;



var()		interpolationpoint	IntPoint;	// The interpolation point that we want to move to/wait at.
var()		string				Comment;	// User can enter a comment here that will appear on the GUI viewport

var(Time)	float	Duration;		// How many seconds this action should take

var(Sub)	export	editinline	array<MatSubAction>	SubActions;		// Sub actions are actions to perform while the main action is happening

var(Path) bool		bSmoothCorner;			// true by default - when one control point is adjusted, other is moved to keep tangents the same
var(Path) vector	StartControlPoint;		// Offset from the current interpolation point
var(Path) vector	EndControlPoint;		// Offset from the interpolation point we're moving to (InPointName)
var(Path) bool		bConstantPathVelocity;
var(Path) float		PathVelocity;

var		float		PathLength;

var		transient array<vector> SampleLocations;
var		transient float	PctStarting;
var		transient float	PctEnding;
var		transient float	PctDuration;

defaultproperties
{
	bSmoothCorner=true
	StartControlPoint=(X=800,Y=800,Z=0)
	EndControlPoint=(X=-800,Y=-800,Z=0)
}
class MatchInfo extends Object;



var string LevelName;
var localized string MenuName;			// usually "", otherwise, override the name in the SP menus
var string EnemyTeamName;
var string SpecialEvent;
var float DifficultyModifier;
var float GoalScore;
var string URLString;
var string MenuDescription;
var int NumBots;				// number of bots in match, besides player
var string GameType;			// GameInfo class to use
var string ThumbName;			// name of a material (in form package.group.name) to use as the thumbnail
//============================================================================================
// MatDemoActor: Non-abstract class to hang animating meshes on in the in-editor preview mode.
//============================================================================================

class MatDemoActor extends Actor
	native;



defaultproperties
{
	bStatic=True
	DrawType=DT_Mesh
	SoundOcclusion=OCCLUSION_None
}
//=============================================================================
// Material: Abstract material class
// This is a built-in Unreal class and it shouldn't be modified.
//=============================================================================
class Material extends Object
	native
	hidecategories(Object)
	collapsecategories
	noexport;



#exec Texture Import File=Textures\DefaultTexture.dds MIPS=OFF COMPRESS=DXT1

var() Material FallbackMaterial;

var Material DefaultMaterial;
var const transient bool UseFallback;	// Render device should use the fallback.
var const transient bool Validated;		// Material has been validated as renderable.

var() ESurfaceTypes SurfaceType;			// GBX:naj - added 5/03


function Reset()
{
	if( FallbackMaterial != None )
		FallbackMaterial.Reset();
}

function Trigger( Actor Other, Actor EventInstigator )
{
	if( FallbackMaterial != None )
		FallbackMaterial.Trigger( Other, EventInstigator );
}

defaultproperties
{
	FallbackMaterial=None
	DefaultMaterial=DefaultTexture
}
class MaterialTrigger extends Triggers;



var() array<Material> MaterialsToTrigger;

function PostBeginPlay()
{
	local int i;
	for( i=0;i<MaterialsToTrigger.Length;i++ )
	{
		if( MaterialsToTrigger[i] != None )
			MaterialsToTrigger[i].Reset();
	}
}

function Trigger( Actor Other, Pawn EventInstigator )
{
	local int i;

	if( Other == None )
		Other = Self;

	for( i=0;i<MaterialsToTrigger.Length;i++ )
	{
		if( MaterialsToTrigger[i] != None )
			MaterialsToTrigger[i].Trigger( Other, EventInstigator );
	}
}

defaultproperties
{
	Texture=Texture'Engine.S_TriggerMaterial'
	bCollideActors=False
}
//=============================================================================
// MatObject
//
// A base class for all Matinee classes.  Just a convenient place to store
// common elements like enums.
//=============================================================================

class MatObject extends Object
	abstract
	native;



struct Orientation
{
	var() ECamOrientation	CamOrientation;
	var() actor LookAt;
	var() float EaseIntime;
	var() int bReversePitch;
	var() int bReverseYaw;
	var() int bReverseRoll;

	var int MA;
	var float PctInStart, PctInEnd, PctInDuration;
	var rotator StartingRotation;
};

defaultproperties
{
}
//=============================================================================
// MatSubAction: Base class for Matinee sub actions.
//
// A Matinee action can have any number of sub actions.  These sub actions
// are executed while the main action is running.
//=============================================================================

#exec Texture Import File=Textures\SubActionFOV.tga				MIPS=OFF COMPRESS=DXT1
#exec Texture Import File=Textures\SubActionTrigger.tga			MIPS=OFF COMPRESS=DXT1
#exec Texture Import File=Textures\SubActionOrientation.tga		MIPS=OFF COMPRESS=DXT1
#exec Texture Import File=Textures\SubActionFade.tga			MIPS=OFF COMPRESS=DXT1
#exec Texture Import File=Textures\SubActionGameSpeed.tga		MIPS=OFF COMPRESS=DXT1
#exec Texture Import File=Textures\SubActionSceneSpeed.tga		MIPS=OFF COMPRESS=DXT1
#exec Texture Import File=Textures\SubActionCameraShake.tga		MIPS=OFF COMPRESS=DXT1

class MatSubAction extends MatObject
	abstract
	native
	editinlinenew;



enum ESAStatus
{
	SASTATUS_Waiting,	// Waiting to execute
	SASTATUS_Running,	// Is currently executing
	SASTATUS_Ending,	// Is one tick away from expiring
	SASTATUS_Expired,	// Has executed and finished (ignore for rest of scene)
};

var(Time)		float		Delay;		// Seconds before it actually executes
var(Time)		float		Duration;	// How many seconds it should take to complete

var				texture		Icon;		// The icon to use in the matinee UI
var				ESAStatus	Status;		// The status of this subaction
var	localized	string		Desc;		// Desc used by the editor and engine stats

var				transient float		PctStarting;
var				transient float		PctEnding;
var				transient float		PctDuration;

defaultproperties
{
	Icon=None
	Status=SASTATUS_Waiting
	Desc="N/A"
}
//=============================================================================
// Emitter: An Unreal Mesh Particle Emitter.
//=============================================================================
class MeshEmitter extends ParticleEmitter
	native;




var (Mesh)		staticmesh		StaticMesh;
var (Mesh)		bool			UseMeshBlendMode;
var (Mesh)		bool			RenderTwoSided;
var (Mesh)		bool			UseParticleColor;
var (Mesh)      bool            IgnoreFarClippingPlane;

var	transient	vector			MeshExtent;

defaultproperties
{
	UseMeshBlendMode=True
	StartSizeRange=(X=(Min=1,Max=1),Y=(Min=1,Max=1),Z=(Min=1,Max=1))
    StaticMesh=None
}
//=============================================================================
// MeshObject
//
// A base class for all Animating-Mesh-editing classes.  Just a convenient place to store
// common elements like enums.
//=============================================================================

class MeshObject extends Object
	abstract
	native;




// Impostor render switches
enum EImpSpaceMode
{
	ISM_Sprite,
	ISM_Fixed,
	ISM_PivotVertical,
	ISM_PivotHorizontal,
};
enum EImpDrawMode
{
	IDM_Normal,
	IDM_Fading,
};
enum EImpLightMode
{
	ILM_Unlit,
	ILM_PseudoShaded,	// Lit by hardware, diverging normals.
	ILM_Uniform,	        // Lit by hardware, all normals pointing faceward.
};

// Mesh static-section extraction methods
enum EMeshSectionMethod
{
	MSM_SmoothOnly,    // Smooth (software transformed) sections only.
	MSM_RigidOnly,     // Only draw rigid parts, throw away anything that's not rigid.
	MSM_Mixed,         // Convert suitable mesh parts to rigid and draw remaining sections smoothly (software transformation).
	MSM_SinglePiece,   // Freeze all as a single static piece just as in the refpose.
	MSM_ForcedRigid,   // Convert all faces to rigid parts using relaxed criteria ( entire smooth sections forced rigid ).
};

// Animation (re-)compression methods.
enum EAnimCompressMethod
{
	ACM_Raw,            // Throws away only perfectly interpolatable keys.
	ACM_Classic,        // Throws away keys but don't quantize.
	ACM_Quantized16bit, // Quantized quaternions, taking up 3x16 bits each.
};

defaultproperties
{
}
//=============================================================================
// MessagingSpectator - spectator base class for game helper spectators which receive messages
//=============================================================================

class MessagingSpectator extends PlayerController
	abstract;



function PostBeginPlay()
{
	Super.PostBeginPlay();
	bIsPlayer = False;
}
class Modifier extends Material
	native
	editinlinenew
	hidecategories(Material)
	abstract;



var() editinlineuse Material Material;

function Reset()
{
	if( Material != None )
		Material.Reset();
	if( FallbackMaterial != None )
		FallbackMaterial.Reset();
}

function Trigger( Actor Other, Actor EventInstigator )
{
	if( Material != None )
		Material.Trigger( Other, EventInstigator );
	if( FallbackMaterial != None )
		FallbackMaterial.Trigger( Other, EventInstigator );
}
//=============================================================================
// The moving brush class.
// This is a built-in Unreal class and it shouldn't be modified.
// Note that movers by default have bNoDelete==true.  This makes movers and their default properties
// remain on the client side.  If a mover subclass has bNoDelete=false, then its default properties must
// be replicated
//=============================================================================
class Mover extends Actor
	native
	nativereplication;



// How the mover should react when it encroaches an actor.
var() enum EMoverEncroachType
{
	ME_StopWhenEncroach,	// Stop when we hit an actor.
	ME_ReturnWhenEncroach,	// Return to previous position when we hit an actor.
   	ME_CrushWhenEncroach,   // Crush the poor helpless actor.
   	ME_IgnoreWhenEncroach,  // Ignore encroached actors.
} MoverEncroachType;

// How the mover moves from one position to another.
var() enum EMoverGlideType
{
	MV_MoveByTime,			// Move linearly.
	MV_GlideByTime,			// Move with smooth acceleration.
} MoverGlideType;

// What classes can bump trigger this mover
var() enum EBumpType
{
	BT_PlayerBump,		// Can only be bumped by player.
	BT_PawnBump,		// Can be bumped by any Pawn
	BT_AnyBump,			// Can be bumped by any solid actor
} BumpType;

//-----------------------------------------------------------------------------
// Keyframe numbers.
var() byte       KeyNum;           // Current or destination keyframe.
var byte         PrevKeyNum;       // Previous keyframe.
var() const byte NumKeys;          // Number of keyframes in total (0-3).
var() const byte WorldRaytraceKey; // Raytrace the world with the brush here.
var() const byte BrushRaytraceKey; // Raytrace the brush here.

//-----------------------------------------------------------------------------
// Movement parameters.
var() float      MoveTime;         // Time to spend moving between keyframes.
var() float      StayOpenTime;     // How long to remain open before closing.
var() float      OtherTime;        // TriggerPound stay-open time.
var() int        EncroachDamage;   // How much to damage encroached actors.

//-----------------------------------------------------------------------------
// Mover state.
var() bool       bTriggerOnceOnly; // Go dormant after first trigger.
var() bool       bSlave;           // This brush is a slave.
var() bool		 bUseTriggered;		// Triggered by player grab
var() bool		 bDamageTriggered;	// Triggered by taking damage
var() bool       bDynamicLightMover; // Apply dynamic lighting to mover.
var() bool       bUseShortestRotation; // rot by -90 instead of +270 and so on.
var(ReturnGroup) bool bIsLeader;
var() name       PlayerBumpEvent;  // Optional event to cause when the player bumps the mover.
var() name       BumpEvent;			// Optional event to cause when any valid bumper bumps the mover.
var   actor      SavedTrigger;      // Who we were triggered by.
var() float		 DamageThreshold;	// minimum damage to trigger
var	  int		 numTriggerEvents;	// number of times triggered ( count down to untrigger )
var	  Mover		 Leader;			// for having multiple movers return together
var	  Mover		 Follower;
var(ReturnGroup) name		 ReturnGroup;		// if none, same as tag
var() float		 DelayTime;			// delay before starting to open

//-----------------------------------------------------------------------------
// Audio.
var(MoverSounds) sound      OpeningSound;     // When start opening.
var(MoverSounds) sound      OpenedSound;      // When finished opening.
var(MoverSounds) sound      ClosingSound;     // When start closing.
var(MoverSounds) sound      ClosedSound;      // When finish closing.
var(MoverSounds) sound      MoveAmbientSound; // Optional ambient sound when moving.
var(MoverSounds) sound		LoopSound;		  // Played on Loop

//-----------------------------------------------------------------------------
// Events

var(MoverEvents) name		OpeningEvent;	// Event to cause when opening
var(MoverEvents) name		OpenedEvent;	// Event to cause when opened
var(MoverEvents) name		ClosingEvent;	// Event to cause when closing
var(MoverEvents) name		ClosedEvent;	// Event to cause when closed
var(MoverEvents) name		LoopEvent;		// Event to cause when the mover loops
//-----------------------------------------------------------------------------
// Other stuff

//-----------------------------------------------------------------------------
// Internal.
var vector       KeyPos[24];
var rotator      KeyRot[24];
var vector       BasePos, OldPos, OldPrePivot, SavedPos;
var rotator      BaseRot, OldRot, SavedRot;
var           float       PhysAlpha;       // Interpolating position, 0.0-1.0.
var           float       PhysRate;        // Interpolation rate per second.

// AI related
var       NavigationPoint  MyMarker;
var		  bool			bOpening, bDelaying, bClientPause;
var		  bool			bClosed;	// mover is in closed position, and no longer moving
var		  bool			bPlayerOnly;
var(AI)	  bool			bAutoDoor;	// automatically setup Door NavigationPoint for this mover
var(AI)	  bool			bNoAIRelevance; // don't warn about this mover during path review

// for client side replication
var		vector			SimOldPos;
var		int				SimOldRotPitch, SimOldRotYaw, SimOldRotRoll;
var		vector			SimInterpolate;
var		vector			RealPosition;
var     rotator			RealRotation;
var		int				ClientUpdate;

// Used for controlling antiportals

var array<AntiPortalActor>	AntiPortals;
var() name					AntiPortalTag;

replication
{
	// Things the server should send to the client.
	reliable if( Role==ROLE_Authority )
		SimOldPos, SimOldRotPitch, SimOldRotYaw, SimOldRotRoll, SimInterpolate, RealPosition, RealRotation;
}

/* StartInterpolation()
when this function is called, the actor will start moving along an interpolation path
beginning at Dest
*/
simulated function StartInterpolation()
{
	GotoState('');
	bInterpolating = true;
	SetPhysics(PHYS_None);
}

simulated function Timer()
{
	if ( Velocity != vect(0,0,0) )
	{
		bClientPause = false;
		return;
	}
	if ( Level.NetMode == NM_Client )
	{
		if ( ClientUpdate == 0 ) // not doing a move
		{
			if ( bClientPause )
			{
				if ( VSize(RealPosition - Location) > 3 )
					SetLocation(RealPosition);
				else
					RealPosition = Location;
				SetRotation(RealRotation);
				bClientPause = false;
			}
			else if ( RealPosition != Location )
				bClientPause = true;
		}
		else
			bClientPause = false;
	}
	else
	{
		RealPosition = Location;
		RealRotation = Rotation;
	}
}

//-----------------------------------------------------------------------------
// Movement functions.

// Interpolate to keyframe KeyNum in Seconds time.
simulated final function InterpolateTo( byte NewKeyNum, float Seconds )
{
	NewKeyNum = Clamp( NewKeyNum, 0, ArrayCount(KeyPos)-1 );
	if( NewKeyNum==PrevKeyNum && KeyNum!=PrevKeyNum )
	{
		// Reverse the movement smoothly.
		PhysAlpha = 1.0 - PhysAlpha;
		OldPos    = BasePos + KeyPos[KeyNum];
		OldRot    = BaseRot + KeyRot[KeyNum];
	}
	else
	{
		// Start a new movement.
		OldPos    = Location;
		OldRot    = Rotation;
		PhysAlpha = 0.0;
	}

	// Setup physics.
	SetPhysics(PHYS_MovingBrush);
	bInterpolating   = true;
	PrevKeyNum       = KeyNum;
	KeyNum			 = NewKeyNum;
	PhysRate         = 1.0 / FMax(Seconds, 0.005);

	ClientUpdate++;
	SimOldPos = OldPos;
	SimOldRotYaw = OldRot.Yaw;
	SimOldRotPitch = OldRot.Pitch;
	SimOldRotRoll = OldRot.Roll;
	SimInterpolate.X = 100 * PhysAlpha;
	SimInterpolate.Y = 100 * FMax(0.01, PhysRate);
	SimInterpolate.Z = 256 * PrevKeyNum + KeyNum;
	NetUpdateTime = Level.TimeSeconds - 1;
}

// Set the specified keyframe.
final function SetKeyframe( byte NewKeyNum, vector NewLocation, rotator NewRotation )
{
	KeyNum         = Clamp( NewKeyNum, 0, ArrayCount(KeyPos)-1 );
	KeyPos[KeyNum] = NewLocation;
	KeyRot[KeyNum] = NewRotation;
}

// Interpolation ended.
simulated event KeyFrameReached()
{
	local byte OldKeyNum;

	OldKeyNum  = PrevKeyNum;
	PrevKeyNum = KeyNum;
	PhysAlpha  = 0;
	ClientUpdate--;

	// If more than two keyframes, chain them.
	if( KeyNum>0 && KeyNum<OldKeyNum )
	{
		// Chain to previous.
		InterpolateTo(KeyNum-1,MoveTime);
	}
	else if( KeyNum<NumKeys-1 && KeyNum>OldKeyNum )
	{
		// Chain to next.
		InterpolateTo(KeyNum+1,MoveTime);
	}
	else
	{
		// Finished interpolating.
		AmbientSound = None;
		if ( (ClientUpdate == 0) && (Level.NetMode != NM_Client) )
		{
			RealPosition = Location;
			RealRotation = Rotation;
		}
	}
}

//-----------------------------------------------------------------------------
// Mover functions.

// Notify AI that mover finished movement
function FinishNotify()
{
	local Controller C;

	for ( C=Level.ControllerList; C!=None; C=C.nextController )
		if ( (C.Pawn != None) && (C.PendingMover == self) )
			C.MoverFinished();
}

// Handle when the mover finishes closing.
function FinishedClosing()
{
	local Mover M;

	// Update sound effects.
	PlaySound( ClosedSound, SLOT_None, SoundVolume / 255.0, false, SoundRadius, SoundPitch / 64.0);

	// Handle Events

	TriggerEvent( ClosedEvent, Self, Instigator );

	// Notify our triggering actor that we have completed.
	if( SavedTrigger != None )
		SavedTrigger.EndEvent();

	SavedTrigger = None;
	Instigator = None;
	If ( MyMarker != None )
		MyMarker.MoverClosed();
	bClosed = true;
	FinishNotify();
	for ( M=Leader; M!=None; M=M.Follower )
		if ( !M.bClosed )
			return;
	UnTriggerEvent(OpeningEvent, Self, Instigator);
}

// Handle when the mover finishes opening.
function FinishedOpening()
{
	// Update sound effects.
	PlaySound( OpenedSound, SLOT_None, SoundVolume / 255.0, false, SoundRadius, SoundPitch / 64.0);

	// Trigger any chained movers / Events
	TriggerEvent(Event, Self, Instigator);
	TriggerEvent(OpenedEvent, Self, Instigator);

	If ( MyMarker != None )
		MyMarker.MoverOpened();
	FinishNotify();
}

// Open the mover.
function DoOpen()
{
	bOpening = true;
	bDelaying = false;
	InterpolateTo( 1, MoveTime );
	MakeNoise(1.0);
	PlaySound( OpeningSound, SLOT_None, SoundVolume / 255.0, false, SoundRadius, SoundPitch / 64.0);
	AmbientSound = MoveAmbientSound;
	TriggerEvent(OpeningEvent, Self, Instigator);
	if ( Follower != None )
		Follower.DoOpen();
}

// Close the mover.
function DoClose()
{
	bOpening = false;
	bDelaying = false;
	InterpolateTo( Max(0,KeyNum-1), MoveTime );
	MakeNoise(1.0);
	PlaySound( ClosingSound, SLOT_None, SoundVolume / 255.0, false, SoundRadius, SoundPitch / 64.0);
	UntriggerEvent(Event, self, Instigator);
	AmbientSound = MoveAmbientSound;
	TriggerEvent(ClosingEvent,Self,Instigator);
	if ( Follower != None )
		Follower.DoClose();
}

//-----------------------------------------------------------------------------
// Engine notifications.

// When mover enters gameplay.
simulated function BeginPlay()
{
	local AntiPortalActor AntiPortal;

	if(AntiPortalTag != '')
	{
		foreach AllActors(class'AntiPortalActor',AntiPortal,AntiPortalTag)
		{
			AntiPortals.Length = AntiPortals.Length + 1;
			AntiPortals[AntiPortals.Length - 1] = AntiPortal;
		}
	}

	// timer updates real position every second in network play
	if ( Level.NetMode != NM_Standalone )
	{
		if ( Level.NetMode == NM_Client )
			settimer(4.0, true);
		else
			settimer(1.0, true);
		if ( Role < ROLE_Authority )
			return;
	}

	if ( Level.NetMode != NM_Client )
	{
		RealPosition = Location;
		RealRotation = Rotation;
	}

	// Init key info.
	Super.BeginPlay();
	KeyNum         = Clamp( KeyNum, 0, ArrayCount(KeyPos)-1 );
	PhysAlpha      = 0.0;

	// Set initial location.
	Move( BasePos + KeyPos[KeyNum] - Location );

	// Initial rotation.
	SetRotation( BaseRot + KeyRot[KeyNum] );

	// find movers in same group
	if ( ReturnGroup == '' )
		ReturnGroup = tag;
	Leader = None;
	Follower = None;
}

// Immediately after mover enters gameplay.
function PostBeginPlay()
{
	local mover M;

	// Initialize all slaves.
	if( !bSlave )
	{
		foreach DynamicActors( class 'Mover', M, Tag )
		{
			if( M.bSlave )
			{
				M.GotoState('');
				M.SetBase( Self );
			}
		}
	}

	if ( bIsLeader )
	{
		Leader = self;
		ForEach DynamicActors( class'Mover', M )
			if ( (M != self) && (M.ReturnGroup == ReturnGroup) )
			{
				M.Leader = self;
				M.Follower = Follower;
				Follower = M;
			}
	}
	else if ( Leader == None )
	{
		// if no one in returngroup, I am the leader anyway
		ForEach DynamicActors( class'Mover', M )
		{
			if ( (M != self) && (M.ReturnGroup == ReturnGroup) )
				return;
		}
		Leader = self;
	}
}

function MakeGroupStop()
{
	// Stop moving immediately.
	bInterpolating = false;
	AmbientSound = None;
	GotoState( , '' );

	if ( Follower != None )
		Follower.MakeGroupStop();
}

function MakeGroupReturn()
{
	// Abort move and reverse course.
	bInterpolating = false;
	AmbientSound = None;

	if(bIsLeader || Leader==Self)
	{
	if( KeyNum<PrevKeyNum )
		GotoState( , 'Open' );
	else
		GotoState( , 'Close' );
	}

	if ( Follower != None )
		Follower.MakeGroupReturn();
}

// Return true to abort, false to continue.
function bool EncroachingOn( actor Other )
{
	local Pawn P;

	if ( Other == None )
		return false;
	if ( ((Pawn(Other) != None) && (Pawn(Other).Controller == None)) || Other.IsA('Decoration') )
	{
		Other.TakeDamage(10000, None, Other.Location, vect(0,0,0), class'Crushed');
		return false;
	}
	if ( Other.IsA('Pickup') )
	{
		if ( !Other.bAlwaysRelevant && (Other.Owner == None) )
			Other.Destroy();
		return false;
	}
	if ( Other.IsA('Fragment') || Other.IsA('Gib') || Other.IsA('Projectile') )
	{
		Other.Destroy();
		return false;
	}

	// Damage the encroached actor.
	if( EncroachDamage != 0 )
		Other.TakeDamage( EncroachDamage, Instigator, Other.Location, vect(0,0,0), class'Crushed' );

	// If we have a bump-player event, and Other is a Pawn, do the bump thing.
	P = Pawn(Other);
	if( P!=None && (P.Controller != None) && P.IsPlayerPawn() )
	{
		if ( PlayerBumpEvent!='' )
			Bump( Other );
		if ( (P != None) && (P.Controller != None) && (P.Base != self) && (P.Controller.PendingMover == self) )
			P.Controller.UnderLift(self);	// Pawn is under lift - tell him to move
	}

	// Stop, return, or whatever.
	if( MoverEncroachType == ME_StopWhenEncroach )
	{
		Leader.MakeGroupStop();
		return true;
	}
	else if( MoverEncroachType == ME_ReturnWhenEncroach )
	{
		Leader.MakeGroupReturn();
		if ( Other.IsA('Pawn') )
			Pawn(Other).PlayMoverHitSound();
		return true;
	}
	else if( MoverEncroachType == ME_CrushWhenEncroach )
	{
		// Kill it.
		Other.KilledBy( Instigator );
		return false;
	}
	else if( MoverEncroachType == ME_IgnoreWhenEncroach )
	{
		// Ignore it.
		return false;
	}
}

// When bumped by player.
function Bump( actor Other )
{
	local Pawn  P;

	P = Pawn(Other);
	if ( bUseTriggered && (P != None) && !P.IsHumanControlled() && P.IsPlayerPawn() )
	{
		Trigger(P,P);
		P.Controller.WaitForMover(self);
	}
	if ( (BumpType != BT_AnyBump) && (P == None) )
		return;
	if ( (BumpType == BT_PlayerBump) && !P.IsPlayerPawn() )
		return;
	if ( (BumpType == BT_PawnBump) && P.bAmbientCreature )
		return;
	TriggerEvent(BumpEvent, self, P);

	if ( (P != None) && P.IsPlayerPawn() )
		TriggerEvent(PlayerBumpEvent, self, P);
}

// When damaged
function TakeDamage( int Damage, Pawn instigatedBy, Vector hitlocation,
						Vector momentum, class<DamageType> damageType, optional name HitBoxName)
{
	if ( bDamageTriggered && (Damage >= DamageThreshold) )
	{
		if ( (AIController(instigatedBy.Controller) != None)
			&& (instigatedBy.Controller.Focus == self) )
			instigatedBy.Controller.StopFiring();
		self.Trigger(self, instigatedBy);
}
}

//========================================================================
// Master State for OpenTimed mover states (for movers that open and close)

state OpenTimedMover
{
	function DisableTrigger();
	function EnableTrigger();

Open:
	bClosed = false;
	DisableTrigger();
	if ( DelayTime > 0 )
	{
		bDelaying = true;
		Sleep(DelayTime);
	}
	DoOpen();
	FinishInterpolation();
	FinishedOpening();
	Sleep( StayOpenTime );
	if( bTriggerOnceOnly )
		GotoState('');
Close:
	DoClose();
	FinishInterpolation();
	FinishedClosing();
	EnableTrigger();
}

// Open when stood on, wait, then close.
state() StandOpenTimed extends OpenTimedMover
{
	function Attach( actor Other )
	{
		local Pawn  P;

		P = Pawn(Other);
		if ( (BumpType != BT_AnyBump) && (P == None) )
			return;
		if ( (BumpType == BT_PlayerBump) && !P.IsPlayerPawn() )
			return;
		if ( (BumpType == BT_PawnBump) && (Other.Mass < 10) )
			return;
		SavedTrigger = None;
		GotoState( 'StandOpenTimed', 'Open' );
	}

	function DisableTrigger()
	{
		Disable( 'Attach' );
	}

	function EnableTrigger()
	{
		Enable('Attach');
	}
}

// Open when bumped, wait, then close.
state() BumpOpenTimed extends OpenTimedMover
{
	function Bump( actor Other )
	{
		if ( (BumpType != BT_AnyBump) && (Pawn(Other) == None) )
			return;
		if ( (BumpType == BT_PlayerBump) && !Pawn(Other).IsPlayerPawn() )
			return;
		if ( (BumpType == BT_PawnBump) && (Other.Mass < 10) )
			return;
		Global.Bump( Other );
		SavedTrigger = None;
		Instigator = Pawn(Other);
		Instigator.Controller.WaitForMover(self);
		GotoState( 'BumpOpenTimed', 'Open' );
	}

	function DisableTrigger()
	{
		Disable( 'Bump' );
	}

	function EnableTrigger()
	{
		Enable('Bump');
	}
}

// When triggered, open, wait, then close.
state() TriggerOpenTimed extends OpenTimedMover
{
	function Trigger( actor Other, Pawn EventInstigator )
	{
		SavedTrigger = Other;
		Instigator = EventInstigator;
		if ( SavedTrigger != None )
			SavedTrigger.BeginEvent();
		GotoState( 'TriggerOpenTimed', 'Open' );
	}

	function DisableTrigger()
	{
		Disable( 'Trigger' );
	}

	function EnableTrigger()
	{
		Enable('Trigger');
	}
}

//=================================================================
// Other Mover States

// Toggle when triggered.
state() TriggerToggle
{
	function Trigger( actor Other, Pawn EventInstigator )
	{
		SavedTrigger = Other;
		Instigator = EventInstigator;
		if ( SavedTrigger != None )
			SavedTrigger.BeginEvent();
		if( KeyNum==0 || KeyNum<PrevKeyNum )
			GotoState( 'TriggerToggle', 'Open' );
		else
			GotoState( 'TriggerToggle', 'Close' );
	}
Open:
	bClosed = false;
	if ( DelayTime > 0 )
	{
		bDelaying = true;
		Sleep(DelayTime);
	}
	DoOpen();
	FinishInterpolation();
	FinishedOpening();
	if ( SavedTrigger != None )
		SavedTrigger.EndEvent();
	Stop;
Close:
	DoClose();
	FinishInterpolation();
	FinishedClosing();
}

// Open when triggered, close when get untriggered.
state() TriggerControl
{
	function Trigger( actor Other, Pawn EventInstigator )
	{
		numTriggerEvents++;
		SavedTrigger = Other;
		Instigator = EventInstigator;
		if ( SavedTrigger != None )
			SavedTrigger.BeginEvent();
		GotoState( 'TriggerControl', 'Open' );
	}
	function UnTrigger( actor Other, Pawn EventInstigator )
	{
		numTriggerEvents--;
		if ( numTriggerEvents <=0 )
		{
			numTriggerEvents = 0;
			SavedTrigger = Other;
			Instigator = EventInstigator;
			SavedTrigger.BeginEvent();
			GotoState( 'TriggerControl', 'Close' );
		}
	}

	function BeginState()
	{
		numTriggerEvents = 0;
	}

Open:
	bClosed = false;
	if ( DelayTime > 0 )
	{
		bDelaying = true;
		Sleep(DelayTime);
	}
	DoOpen();
	FinishInterpolation();
	FinishedOpening();
	SavedTrigger.EndEvent();
	if( bTriggerOnceOnly )
		GotoState('');
	Stop;
Close:
	DoClose();
	FinishInterpolation();
	FinishedClosing();
}

// Start pounding when triggered.
state() TriggerPound
{
	function Trigger( actor Other, Pawn EventInstigator )
	{
		numTriggerEvents++;
		SavedTrigger = Other;
		Instigator = EventInstigator;
		GotoState( 'TriggerPound', 'Open' );
	}
	function UnTrigger( actor Other, Pawn EventInstigator )
	{
		numTriggerEvents--;
		if ( numTriggerEvents <= 0 )
		{
			numTriggerEvents = 0;
			SavedTrigger = None;
			Instigator = None;
			GotoState( 'TriggerPound', 'Close' );
		}
	}
	function BeginState()
	{
		numTriggerEvents = 0;
	}

Open:
	bClosed = false;
	if ( DelayTime > 0 )
	{
		bDelaying = true;
		Sleep(DelayTime);
	}
	DoOpen();
	FinishInterpolation();
	Sleep(OtherTime);
Close:
	DoClose();
	FinishInterpolation();
	Sleep(StayOpenTime);
	if( bTriggerOnceOnly )
		GotoState('');
	if( SavedTrigger != None )
		goto 'Open';
}

//-----------------------------------------------------------------------------
// Bump states.


// Open when bumped, close when reset.
state() BumpButton
{
	function Bump( actor Other )
	{
		if ( (BumpType != BT_AnyBump) && (Pawn(Other) == None) )
			return;
		if ( (BumpType == BT_PlayerBump) && !Pawn(Other).IsPlayerPawn() )
			return;
		if ( (BumpType == BT_PawnBump) && (Other.Mass < 10) )
			return;
		Global.Bump( Other );
		SavedTrigger = Other;
		Instigator = Pawn( Other );
		Instigator.Controller.WaitForMover(self);
		GotoState( 'BumpButton', 'Open' );
	}
	function BeginEvent()
	{
		bSlave=true;
	}
	function EndEvent()
	{
		bSlave     = false;
		Instigator = None;
		GotoState( 'BumpButton', 'Close' );
	}
Open:
	bClosed = false;
	Disable( 'Bump' );
	if ( DelayTime > 0 )
	{
		bDelaying = true;
		Sleep(DelayTime);
	}
	DoOpen();
	FinishInterpolation();
	FinishedOpening();
	if( bTriggerOnceOnly )
		GotoState('');
	if( bSlave )
		Stop;
Close:
	DoClose();
	FinishInterpolation();
	FinishedClosing();
	Enable( 'Bump' );
}

defaultproperties
{
	 bNoDelete=true
	 bPathColliding=true
     MoverEncroachType=ME_ReturnWhenEncroach
     MoverGlideType=MV_GlideByTime
     NumKeys=2
	 BrushRaytraceKey=0
     MoveTime=+00001.000000
     StayOpenTime=+00004.000000
     bStatic=False
	 bDynamicLightMover=False
	 bHidden=false
     CollisionRadius=+00160.000000
     CollisionHeight=+00160.000000
     bCollideActors=True
     bBlockActors=True
     bBlockPlayers=True
     Physics=PHYS_MovingBrush
     InitialState=BumpOpenTimed
	 TransientSoundVolume=+00001.000000
     SoundVolume=228
	 NetPriority=2.7
	 bAlwaysRelevant=true
     RemoteRole=ROLE_SimulatedProxy
	 bClosed=true
	 bShadowCast=true
	 bEdShouldSnap=true
	 bAcceptsProjectors=true
	 bOnlyDirtyReplication=true
}
//=============================================================================
// Movie.uc: A movie that plays on a surface be that a texture or the canvas
//
// Created by Demiurge Studios 2002
//
// This is a built-in Unreal class and it shouldn't be modified.
//=============================================================================
class Movie extends Object
	native
	noexport;

var const transient int FMovie; //this is really an FMovie*

// native functions.
native final function Play( String MovieFilename, bool UseSound, bool LoopMovie);
native final function Pause( bool Pause );
native final function bool IsPaused();
native final function StopNow();
native final function StopAtEnd();
native final function bool IsPlaying();
native final function int GetWidth();
native final function int GetHeight();

//=============================================================================
// MovieTexture: A movie that plays on a texture
//
// Created by Demiurge Studios 2002
//
// This is a built-in Unreal class and it shouldn't be modified.
//=============================================================================
class MovieTexture extends Texture
	native;

// TODO Al: Make this extend UBitmapMaterial, if possible

var const transient Movie Movie;

var() String MovieFilename;
var() int FrameRate;

// native functions.
native final function InitializeMovie();

defaultproperties
{
	FrameRate = 30
}class MusicTrigger extends Triggers;



var()				string		Song;
var()				float		FadeInTime;
var()				float		FadeOutTime;
var()				bool		FadeOutAllSongs;

var 	transient	int			SongHandle;
var		transient	bool		Triggered;

function Trigger( Actor Other, Pawn EventInstigator )
{
	if( !Triggered )
	{
		Triggered	= true;

		if( FadeOutAllSongs )
		StopAllMusic( FadeOutTime );

		SongHandle	= PlayMusic( Song, FadeInTime );
	}
	else
	{
		Triggered	= false;

		if( SongHandle != -1 )
		{
			StopMusic( SongHandle, FadeOutTime );
		}
		else
		{
			Log("WARNING: invalid song handle");
		}
	}
}

defaultproperties
{
	Texture=Texture'Engine.S_TriggerMusic'
	bCollideActors=False
}
//=============================================================================
// Mutator.
//
// Mutators allow modifications to gameplay while keeping the game rules intact.
// Mutators are given the opportunity to modify player login parameters with
// ModifyLogin(), to modify player Pawn properties with ModifyPlayer(), to change
// the default weapon for players with GetDefaultWeapon(), or to modify, remove,
// or replace all other actors when they are spawned with CheckRelevance(), which
// is called from the PreBeginPlay() function of all actors except those (Decals,
// Effects and Projectiles for performance reasons) which have bGameRelevant==true.
//=============================================================================
class Mutator extends Info
	native
	dependson(GameInfo);



var Mutator NextMutator;
var class<Weapon> DefaultWeapon;
var string DefaultWeaponName;
var() string            GroupName; // Will only allow one mutator with this tag to be selected.
var() localized string  FriendlyName;
var() localized string  Description;
var bool bUserAdded;

/* Don't call Actor PreBeginPlay() for Mutator
*/
event PreBeginPlay()
{
	if ( !MutatorIsAllowed() )
		Destroy();
	AddToPackageMap();
}

function bool MutatorIsAllowed()
{
	return !Level.IsDemoBuild() || Class==class'Mutator';
}

function Destroyed()
{
	local Mutator M;

	// remove from mutator list
	if ( Level.Game.BaseMutator == self )
		Level.Game.BaseMutator = NextMutator;
	else
	{
		for ( M=Level.Game.BaseMutator; M!=None; M=M.NextMutator )
			if ( M.NextMutator == self )
			{
				M.NextMutator = NextMutator;
				break;
			}
	}
	Super.Destroyed();
}

function Mutate(string MutateString, PlayerController Sender)
{
	if ( NextMutator != None )
		NextMutator.Mutate(MutateString, Sender);
}

function ModifyLogin(out string Portal, out string Options)
{
	if ( NextMutator != None )
		NextMutator.ModifyLogin(Portal, Options);
}

/* called by GameInfo.RestartPlayer()
	change the players jumpz, etc. here
*/
function ModifyPlayer(Pawn Other)
{
	if ( NextMutator != None )
		NextMutator.ModifyPlayer(Other);
}

/* return what should replace the default weapon
   mutators further down the list override earlier mutators
*/
function Class<Weapon> GetDefaultWeapon()
{
	local Class<Weapon> W;

	if ( NextMutator != None )
	{
		W = NextMutator.GetDefaultWeapon();
		if ( W == None )
			W = MyDefaultWeapon();
	}
	else
		W = MyDefaultWeapon();
	return W;
}

/* GetInventoryClass()
return an inventory class - either the class specified by InventoryClassName, or a
replacement.  Called when spawning initial inventory for player
*/
function Class<Inventory> GetInventoryClass(string InventoryClassName)
{
	InventoryClassName = GetInventoryClassOverride(InventoryClassName);
	return class<Inventory>(DynamicLoadObject(InventoryClassName, class'Class'));
}

/* GetInventoryClassOverride()
return the string passed in, or a replacement class name string.
*/
function string GetInventoryClassOverride(string InventoryClassName)
{
	// here, in mutator subclass, change InventoryClassName if desired.  For example:
	// if ( InventoryClassName == "Weapons.DorkyDefaultWeapon"
	//		InventoryClassName = "ModWeapons.SuperDisintegrator"

	if ( NextMutator != None )
		return NextMutator.GetInventoryClassOverride(InventoryClassName);
	return InventoryClassName;
}

function class<Weapon> MyDefaultWeapon()
{
	if ( (DefaultWeapon == None) && (DefaultWeaponName != "") )
		DefaultWeapon = class<Weapon>(DynamicLoadObject(DefaultWeaponName, class'Class'));

	return DefaultWeapon;
}

function AddMutator(Mutator M)
{
	if ( NextMutator == None )
		NextMutator = M;
	else
		NextMutator.AddMutator(M);
}

/* ReplaceWith()
Call this function to replace an actor Other with an actor of aClass.
*/
function bool ReplaceWith(actor Other, string aClassName)
{
	local Actor A;
	local class<Actor> aClass;

	if ( aClassName == "" )
		return true;

	aClass = class<Actor>(DynamicLoadObject(aClassName, class'Class'));
	if ( aClass != None )
		A = Spawn(aClass,Other.Owner,Other.tag,Other.Location, Other.Rotation);
	if ( Other.IsA('Pickup') )
	{
		if ( Pickup(Other).MyMarker != None )
		{
			Pickup(Other).MyMarker.markedItem = Pickup(A);
			if ( Pickup(A) != None )
			{
				Pickup(A).MyMarker = Pickup(Other).MyMarker;
				A.SetLocation(A.Location
					+ (A.CollisionHeight - Other.CollisionHeight) * vect(0,0,1));
			}
			Pickup(Other).MyMarker = None;
		}
		else if ( A.IsA('Pickup') )
			Pickup(A).Respawntime = 0.0;
	}
	if ( A != None )
	{
		A.event = Other.event;
		A.tag = Other.tag;
		return true;
	}
	return false;
}

/* Force game to always keep this actor, even if other mutators want to get rid of it
*/
function bool AlwaysKeep(Actor Other)
{
	if ( NextMutator != None )
		return ( NextMutator.AlwaysKeep(Other) );
	return false;
}

function bool IsRelevant(Actor Other, out byte bSuperRelevant)
{
	local bool bResult;

	bResult = CheckReplacement(Other, bSuperRelevant);
	if ( bResult && (NextMutator != None) )
		bResult = NextMutator.IsRelevant(Other, bSuperRelevant);

	return bResult;
}

function bool CheckRelevance(Actor Other)
{
	local bool bResult;
	local byte bSuperRelevant;

	if ( AlwaysKeep(Other) )
		return true;

	// allow mutators to remove actors

	bResult = IsRelevant(Other, bSuperRelevant);

	return bResult;
}

function bool CheckReplacement(Actor Other, out byte bSuperRelevant)
{
	return true;
}

//
// Called when a player sucessfully changes to a new class
//
function PlayerChangedClass(Controller aPlayer)
{
	if ( NextMutator != None )
		NextMutator.PlayerChangedClass(aPlayer);
}

//
// server querying
//
function GetServerDetails( out GameInfo.ServerResponseLine ServerState )
{
	// append the mutator name.
	local int i;
	i = ServerState.ServerInfo.Length;
	ServerState.ServerInfo.Length = i+1;
	ServerState.ServerInfo[i].Key = "Mutator";
	ServerState.ServerInfo[i].Value = GetHumanReadableName();
}

function GetServerPlayers( out GameInfo.ServerResponseLine ServerState )
{
}

// jmw - Allow mod authors to hook in to the %X var parsing

function string ParseChatPercVar(Controller Who, string Cmd)
{
	if (NextMutator !=None)
		Cmd = NextMutator.ParseChatPercVar(Who,Cmd);

	return Cmd;
}

function ServerTraveling(string URL, bool bItems)
{
	if (NextMutator != None)
    	NextMutator.ServerTraveling(URL,bItems);
}

defaultproperties
{
    GroupName=""
    FriendlyName="Mutator"
    Description="Description"
}

//=============================================================================
// NavigationPoint.
//
// NavigationPoints are organized into a network to provide AIControllers
// the capability of determining paths to arbitrary destinations in a level
//
//=============================================================================
class NavigationPoint extends Actor
	hidecategories(Lighting,LightColor,Karma,Force)
	native;

//------------------------------------------------------------------------------
// NavigationPoint variables
var() name ProscribedPaths[4];	// list of names of NavigationPoints which should never be connected from this path
var() name ForcedPaths[4];		// list of names of NavigationPoints which should always be connected from this path
var() name JumpPaths[2];			// list of names of NavigationPoints which can be jumped to from here
var() name WallClimbPaths[2];	// list of names of NavigationPoints which can be reached by climbing over a wall
var() name WindowClimbThroughPath; // name of NavigationPoint which can be reached by climbing through a window

var int visitedWeight;
var const int bestPathWeight;
var const ActorLite nextOrdered;	// for internal use during route searches
var const ActorLite prevOrdered;	// for internal use during route searches
var const ActorLite previousPath;
var int cost;					// added cost to visit this pathnode
var() int ExtraCost;			// Extra weight added by level designer
var transient int TransientCost;	// added right before a path finding attempt, cleared afterward.
var	transient int FearCost[2];		// extra weight diminishing over time (used for example, to mark path where bot died) (one for each team)

var() bool bIsDoorwayOrChokePoint;  // true if this NavigationPoint is in a doorway or narrow opening
var() bool bDoNotUseAsDestinationPoint;  // true if point is for Navigation only (never used as DesiredDestination point)
var() bool bFormationPointSearchBlocker;  // true if you don't want this node (or nodes it connects to) included in Formation Point search
var bool taken;					// set when a creature is occupying this spot
var() bool bCodeBlocked;		// node blocked by code
var() bool bVehicleBlocked;		// node blocked by vechicle
var() bool bLevelDesignBlocked;	// node blocked by level designer
var() bool bPropagatesSound;	// this navigation point can be used for sound propagation (around corners)
var() bool bOneWayPath;			// reachspecs from this path only in the direction the path is facing (180 degrees)
var() bool bNeverUseStrafing;	// shouldn't use bAdvancedTactics going to this point
var() bool bAlwaysUseStrafing;	// shouldn't use bAdvancedTactics going to this point
var const bool bForceNoStrafing;// override any LD changes to bNeverUseStrafing
var const bool bAutoBuilt;		// placed during execution of "PATHS BUILD"
var	bool bSpecialMove;			// if true, Pawn will call SuggestMovePreparation() when moving toward this node
var	const bool	bNotBased;		// used by path builder - if true, no error reported if node doesn't have a valid base
var const bool  bPathsChanged;	// used for incremental path rebuilding in the editor
var bool		bDestinationOnly; // used by path building - means no automatically generated paths are sourced from this node
var	bool		bSourceOnly;	// used by path building - means this node is not the destination of any automatically generated path
var bool		bSpecialForced;	// paths that are forced should call the SpecialCost() and SuggestMovePreparation() functions
var bool		bMustBeReachable;	// used for PathReview code
var() bool	bTanksCanUse;		// Whether this pathnode can be used by a tank

var Pickup	InventoryCache;		// used to point to dropped weapons
var float	InventoryDist;

var int		UnitsThatHaveThisInCache;  // this is basically used as a semaphore to keep track of how to render the sprite

var() float CoverRadius;

var transient bool bEndPoint;	// used by C++ navigation code
var transient bool bTransientEndPoint; // set right before a path finding attempt, cleared afterward.

const NAV_MAX_VANTAGE_DIST = 10000;

const NAV_COVER_LOW    = 0;
const NAV_COVER_CROUCHED = 1;
const NAV_COVER_STANDING = 2;

// WARNING!!! - These MUST match the values defined in gbxCharacters\Infantry.uc...
const GBXPAWN_COLLISIONRADIUS = 28.0;
const GBXPAWN_COLLISIONHEIGHT = 84.0;  // 168 units high
//OLD const GBXPAWN_CROUCHHEIGHT    = 51.0;  // 102 units high
const GBXPAWN_CROUCHHEIGHT    = 45.0;  // 90 units high
//OLD const GBXPAWN_LOWHEIGHT     = 31.5;  // 63 units high
const GBXPAWN_LOWHEIGHT     = 24.0;  // 48 units high

var const byte CoverBits[3];  // 'byte' allows for 8 cover directions, index 0=low, index 1=crouched, index 2=standing

var Pawn Claimant;

var NavigationPointLite NavPointLite;

enum ETeamNavPoint
{
	NAV_TeamAny,
	NAV_TeamUS,
	NAV_TeamGerman
};

var() ETeamNavPoint TeamNavPoint;
var(Display) Material	Texture_US;			// Sprite texture.if DrawType=DT_Sprite
var(Display) Material	Texture_German;		// Sprite texture.if DrawType=DT_Sprite


function PostBeginPlay()
{
	bIsNavigationPoint = true;
	ExtraCost = Max(ExtraCost,0);
	Super.PostBeginPlay();
}

event int SpecialCost(Pawn Seeker, ReachSpec Path);

// Accept an actor that has teleported in.
// used for random spawning and initial placement of creatures
event bool Accept( actor Incoming, actor Source )
{
	// Move the actor here.
	taken = Incoming.SetLocation( Location );
	if (taken)
	{
		Incoming.Velocity = vect(0,0,0);
		Incoming.SetRotation(Rotation);
	}
	Incoming.PlayTeleportEffect(true, false);
	TriggerEvent(Event, self, Pawn(Incoming));
	return taken;
}

/* DetourWeight()
value of this path to take a quick detour (usually 0, used when on route to distant objective, but want to grab inventory for example)
*/
event float DetourWeight(Pawn Other,float PathWeight);

/* SuggestMovePreparation()
Optionally tell Pawn any special instructions to prepare for moving to this goal
(called by Pawn.PrepareForMove() if this node's bSpecialMove==true
*/
event bool SuggestMovePreparation(Pawn Other)
{
	return false;
}

/* ProceedWithMove()
Called by Controller to see if move is now possible when a mover reports to the waiting
Pawn that it has completed its move
*/
function bool ProceedWithMove(Pawn Other)
{
	return true;
}

/* MoverOpened() & MoverClosed() used by NavigationPoints associated with movers */
function MoverOpened();
function MoverClosed();

/* Used by FiringController to decide what posture will provide a vantage to the enemy at this point. */
native function bool ProvidesCoverFrom( Vector ThreatLocation, int Posture );

native function bool ProvidesDoubleCoverFrom( Vector ThreatLocation, int Posture );

native function ActorLite FindNearestUnclaimedNeighbor();

defaultproperties
{
	Texture=Texture'Engine.S_PathNode'
	bPropagatesSound=true
	bStatic=true
	bNoDelete=true
	bHidden=true
	bCollideWhenPlacing=true
	SoundVolume=0

	// this should be the twice the value as in gbxPawn...
	CollisionRadius=+00056.000000
	// this should be the same as gbxPawn...
	CollisionHeight=+00084.000000

	CoverRadius=300.0

	NavPointLite=None
	TeamNavPoint=NAV_TeamAny

	Texture_US=Texture'Engine.S_PathNodeUS'
	Texture_German=Texture'Engine.S_PathNodeGerman'
}
//=============================================================================
// NavigationPointLite.
//
// NavigationPoints are organized into a network to provide AIControllers
// the capability of determining paths to arbitrary destinations in a level
//
// A NavigationPointLite gets automatically created when a NavigationPoint
// is created.  The variables of NavigationPointLite get automatically modified
// when it's matching NavigationPoint actor is modified (in UnrealEd).
//
//=============================================================================
class NavigationPointLite extends ActorLite
	notplaceable
	native;


// *!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!
//
// KEEP THESE FIELDS ORDERED SO THAT THE STRUCTURE PACKING USES THE LEAST AMOUNT
// OF SPACE.  4 BYTES VARIABLES SHOULD BE FIRST, THEN 2 BYTE VARIABLES, THEN 1
// BYTE VARIABLES, THEN BITFIELDS.
//
// *!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!


// Actor variables...
//var Material	Texture;			// Sprite texture.if DrawType=DT_Sprite
//var bool		bHidden;			// Is hidden during gameplay.
var float 		CollisionRadius;	// Radius of collision cyllinder.
var float 		CollisionHeight;	// Half-height cyllinder.
var	const vector	Location;		// Actor's location; use Move to set.
var	const rotator 	Rotation;		// Rotation.
var const Actor	Base;           	// Actor we're standing on.
var name		Tag;				// Actor's tag name.
var const PhysicsVolume PhysicsVolume;	// physics volume this actor is currently in
var const byte 	Physics;


//------------------------------------------------------------------------------
// NavigationPoint variables
var const ActorLite nextOrdered;	// for internal use during route searches
var const ActorLite prevOrdered;	// for internal use during route searches
var const ActorLite previousPath;
var Pickup	InventoryCache;			// used to point to dropped weapons
var Pawn Claimant;

var float	InventoryDist;
var float	CoverRadius;

var int visitedWeight;
var const int bestPathWeight;
var int cost;			// added cost to visit this pathnode
var int ExtraCost;		// Extra weight added by level designer
var int		UnitsThatHaveThisInCache;  // this is basically used as a semaphore to keep track of how to render the sprite
var transient int TransientCost;	// added right before a path finding attempt, cleared afterward.
var	transient int FearCost[2];		// extra weight diminishing over time (used for example, to mark path where bot died) (one for each team)

var bool bIsDoorwayOrChokePoint;  // true if this NavigationPoint is in a doorway or narrow opening
var bool bDoNotUseAsDestinationPoint;  // true if point is for Navigation only (never used as DesiredDestination point)
var bool bFormationPointSearchBlocker;  // true if you don't want this node (or nodes it connects to) included in Formation Point search
var bool taken;					// set when a creature is occupying this spot
var() bool bCodeBlocked;		// node blocked by code
var() bool bVehicleBlocked;		// node blocked by vechicle
var() bool bLevelDesignBlocked;	// node blocked by level designer
var bool bPropagatesSound;		// this navigation point can be used for sound propagation (around corners)
var bool bNeverUseStrafing;		// shouldn't use bAdvancedTactics going to this point
var bool bAlwaysUseStrafing;	// shouldn't use bAdvancedTactics going to this point
var const bool bForceNoStrafing;// override any LD changes to bNeverUseStrafing
var	bool bSpecialMove;			// if true, Pawn will call SuggestMovePreparation() when moving toward this node
var const bool  bPathsChanged;	// used for incremental path rebuilding in the editor
var bool bSpecialForced;		// paths that are forced should call the SpecialCost() and SuggestMovePreparation() functions
var bool bTanksCanUse;			// Whether this pathnode can be used by a tank

var const byte CoverBits[3];  // 'byte' allows for 8 cover directions, index 0=low, index 1=crouched, index 2=standing

enum ETeamNavPointLite
{
	NAVL_TeamAnyLite,
	NAVL_TeamUSLite,
	NAVL_TeamGermanLite
};

var() ETeamNavPointLite TeamNavPoint;

var transient bool bEndPoint;	// used by C++ navigation code
var transient bool bTransientEndPoint; // set right before a path finding attempt, cleared afterward.


// Actor functions...
native final function bool SetLocation( vector NewLocation );


event PreBeginPlay()
{
	ExtraCost = Max(ExtraCost,0);
}

event int SpecialCost(Pawn Seeker, ReachSpec Path);


// Accept an actor that has teleported in.
// used for random spawning and initial placement of creatures
event bool Accept( actor Incoming, actor Source )
{
	// Move the actor here.
	taken = Incoming.SetLocation( Location );
	if (taken)
	{
		Incoming.Velocity = vect(0,0,0);
		Incoming.SetRotation(Rotation);
	}
	Incoming.PlayTeleportEffect(true, false);
//jlb	TriggerEvent(Event, self, Pawn(Incoming));
	return taken;
}

/* DetourWeight()
value of this path to take a quick detour (usually 0, used when on route to distant objective, but want to grab inventory for example)
*/
event float DetourWeight(Pawn Other,float PathWeight);

/* SuggestMovePreparation()
Optionally tell Pawn any special instructions to prepare for moving to this goal
(called by Pawn.PrepareForMove() if this node's bSpecialMove==true
*/
event bool SuggestMovePreparation(Pawn Other)
{
	return false;
}

/* ProceedWithMove()
Called by Controller to see if move is now possible when a mover reports to the waiting
Pawn that it has completed its move
*/
function bool ProceedWithMove(Pawn Other)
{
	return true;
}

/* MoverOpened() & MoverClosed() used by NavigationPoints associated with movers */
function MoverOpened();
function MoverClosed();

/* Used by FiringController to decide what posture will provide a vantage to the enemy at this point. */
native function bool ProvidesCoverFrom( Vector ThreatLocation, int Posture );

native function bool ProvidesDoubleCoverFrom( Vector ThreatLocation, int Posture );

native function ActorLite FindNearestUnclaimedNeighbor();

defaultproperties
{
//	Texture=Texture'Engine.S_PathNode';
//	bHidden=true;

	// this should be the twice the value as in gbxPawn...
	CollisionRadius=+00056.000000;
	// this should be the same as gbxPawn...
	CollisionHeight=+00084.000000;

	CoverRadius=300.0;
}
//=============================================================================
// A sticky note.  Level designers can place these in the level and then
// view them as a batch in the error/warnings window.
//=============================================================================
class Note extends Actor
	placeable
	native;



var() string Text;

defaultproperties
{
     bStatic=True
     bHidden=True
     bNoDelete=True
     Texture=Texture'Engine.S_Note'
	 bMovable=False
}
class ObjectPool extends Object;



var Array<Object>	Objects;

//
//	AllocateObject
//

simulated function Object AllocateObject(class ObjectClass, optional Object Outer ) // GBX:naj - modified 3/11/04
{
	local Object	Result;
	local int		ObjectIndex;

	for(ObjectIndex = 0;ObjectIndex < Objects.Length;ObjectIndex++)
	{
		if(Objects[ObjectIndex].Class == ObjectClass)
		{
			Result = Objects[ObjectIndex];
			Objects.Remove(ObjectIndex,1);
			break;
		}
	}

	if(Result == None)
		Result = new( Outer ) ObjectClass; // GBX:naj - modified 3/11/04

	return Result;
}

//
//	FreeObject
//

simulated function FreeObject(Object Obj)
{
	Objects.Length = Objects.Length + 1;
	Objects[Objects.Length - 1] = Obj;
}

//
//	Shrink
//

simulated function Shrink()
{
	while(Objects.Length > 0)
	{
		//delete Objects[Objects.Length - 1];
		Objects.Remove(Objects.Length - 1,1);
	};
}
//=============================================================================
// Palette: A 256-color Unreal palette.
// This is a built-in Unreal class and it shouldn't be modified.
//=============================================================================
class Palette extends Object
	native
	noexport;



var native const array<Color> Colors;

defaultproperties
{
}
//=============================================================================
// ParallaxSkyZoneInfo.
//=============================================================================
class ParallaxSkyZoneInfo extends SkyZoneInfo
	native;



var() edfindable Actor WorldCenterActor;	// An actor representing the center of your level.
											// When the player is at the location of this actor,
											// the sky zone is rendered from the position of SkyCenterActor.

var() edfindable Actor SkyCenterActor;

var() float ParallaxScale;					// Scales the movement of the SkyZoneInfo object
											// relative to the movement of the player.
											// Should be in the range [0,1].
											// If 0, kills parallax.
											// Generally, small values (e.g. 0.01) are best,
											// But it depends on the size of both your map
											// and your skybox.
											// Experiment! You won't hurt it.

var vector OriginalLoc;

defaultProperties
{
	Texture=Texture'Engine.S_ZoneParallax'
	bStatic=true
	ParallaxScale=0.05
}
//=============================================================================
// ParticleEmitter: Base class for sub- emitters.
//
// make sure to keep structs in sync in UnParticleSystem.h
//=============================================================================

class ParticleEmitter extends Object
	abstract
	editinlinenew
	native
	poolable(100,0);


enum EParticleDrawStyle
{
	PTDS_Regular,
	PTDS_AlphaBlend,
	PTDS_Modulated,
	PTDS_Translucent,
	PTDS_AlphaModulate_MightNotFogCorrectly,
	PTDS_Darken,
	PTDS_Brighten
};

enum EParticleCoordinateSystem
{
	PTCS_Independent,
	PTCS_Relative,
	PTCS_Absolute
};

enum EParticleRotationSource
{
	PTRS_None,
	PTRS_Actor,
	PTRS_Offset,
	PTRS_Normal
};

enum EParticleVelocityDirection
{
	PTVD_None,
	PTVD_StartPositionAndOwner,
	PTVD_OwnerAndStartPosition,
	PTVD_AddRadial
};

enum EParticleStartLocationShape
{
	PTLS_Box,
	PTLS_Sphere,
	PTLS_Polar,
	PTLS_All
};

enum EParticleEffectAxis
{
	PTEA_NegativeX,
	PTEA_PositiveZ
};

enum EParticleCollisionSound
{
	PTSC_None,
	PTSC_LinearGlobal,
	PTSC_LinearLocal,
	PTSC_Random
};

enum EParticleMeshSpawning
{
	PTMS_None,
	PTMS_Linear,
	PTMS_Random
};

enum ESkelLocationUpdate
{
	PTSU_None,
	PTSU_SpawnOffset,
	PTSU_Location
};

struct ParticleTimeScale
{
	var () float	RelativeTime;		// always in range [0..1]
	var () float	RelativeSize;
};

struct ParticleRevolutionScale
{
	var () float	RelativeTime;		// always in range [0..1]
	var () vector	RelativeRevolution;
};

struct ParticleColorScale
{
	var () float	RelativeTime;		// always in range [0..1]
	var () color	Color;
};

struct ParticleVelocityScale
{
	var () float	RelativeTime;		// always in range [0..1]
	var () vector	RelativeVelocity;
};

struct Particle
{
	var vector	Location;
	var vector	OldLocation;
	var vector	Velocity;
	var vector	StartSize;
	var vector	SpinsPerSecond;
	var vector	StartSpin;
	var vector  RevolutionCenter;
	var vector  RevolutionsPerSecond;
	var vector	RevolutionsMultiplier;
	var vector	Size;
	var vector  StartLocation;
	var vector  ColorMultiplier;
	var vector	VelocityMultiplier;
	var vector	OldMeshLocation;
	var color	Color;
	var float	Time;
	var float	MaxLifetime;
	var float	Mass;
	var int		HitCount;
	var int		Flags;
	var int		Subdivision;
	var int 	BoneIndex;
};

struct ParticleSound
{
	var () sound	Sound;
	var () range	Radius;
	var () range	Pitch;
	var () int		Weight;
	var () range	Volume;
	var () range	Probability;
};

// ZONER: Packed the bools together
var (Collision)		bool						UseCollision;
var (Collision)		bool						UseCollisionOnce;
var (Collision)		bool						UseCollisionPlanes;
var	(Collision)		bool						UseMaxCollisions;
var (Collision)		bool						UseSpawnedVelocityScale;
var (Color)			bool						UseColorScale;
var (Color)         bool                        bUseZoneParticleAmbient;
var (Fading)		bool						FadeOut;
var (Fading)		bool						FadeIn;
var (Force)			bool						UseActorForces;
var (General)		bool						ResetAfterChange;
var (Local)			bool						RespawnDeadParticles;
var (Local)			bool						AutoDestroy;
var (Local)			bool						AutoReset;
var (Local)			bool						Disabled;
var (Local)			bool						DisableFogging;
var (Local)			bool						bSuspendSpawning;	// GBX:naj - added 9/4/03
var (MeshSpawning)	bool						VelocityFromMesh;
var (MeshSpawning)	bool						UniformMeshScale;
var (MeshSpawning)	bool						UniformVelocityScale;
var (MeshSpawning)	bool						UseColorFromMesh;
var (MeshSpawning)	bool						SpawnOnlyInDirectionOfNormal;
var (Rendering)		bool						AlphaTest;
var (Rendering)		bool						AcceptsProjectors;
var (Rendering)		bool						ZTest;
var (Rendering)		bool						ZWrite;
var (Rendering)		bool						MustTickOnce; // GBX:sjp - added 12/31/2004 - for low-framerate situations, force this particle to tick at least once.  Rendertime is kept at 0 until particle has been ticked at least once.
var (Revolution)	bool						UseRevolution;
var (Revolution)	bool						UseRevolutionScale;
var (Rotation)		bool						SpinParticles;
var (Rotation)		bool						DampRotation;
var (Size)			bool						UseSizeScale;
var (Size)			bool						UseRegularSizeScale;
var (Size)			bool						UniformSize;
var (Sound)			bool						SpawnDelayedBySpeedOfSound;
var (Sound)			bool						CollisionDelayedBySpeedOfSound;
var (Spawning)		bool						AutomaticInitialSpawning;
var (Texture)		bool						BlendBetweenSubdivisions;
var	(Texture)		bool						UseSubdivisionScale;
var (Texture)		bool						UseRandomSubdivision;
var (Trigger)		bool						TriggerDisabled;
var (Trigger)		bool						ResetOnTrigger;
var (Velocity)		bool						UseVelocityScale;

var (Texture)		EParticleDrawStyle			DrawStyle;
var (General)		EParticleCoordinateSystem	CoordinateSystem;
var (Rotation)		EParticleRotationSource		UseRotationFrom;
var (Velocity)		EParticleVelocityDirection	GetVelocityDirectionFrom;
var (General)		EParticleEffectAxis			EffectAxis;
var (Location)		EParticleStartLocationShape StartLocationShape;
var (MeshSpawning)	EParticleMeshSpawning		MeshSpawning;
var (SkeletalMesh)	ESkelLocationUpdate			UseSkeletalLocationAs;
var (Sound)			EParticleCollisionSound		SpawningSound;
var (Sound)			EParticleCollisionSound		CollisionSound;

var (Acceleration)	vector						Acceleration;

var (Collision)		vector						ExtentMultiplier;
var (Collision)		rangevector					DampingFactorRange;
var (Collision)		array<plane>				CollisionPlanes;
var (Collision)		range						MaxCollisions;
var (Collision)		int							SpawnFromOtherEmitter;
var (Collision)		int							SpawnAmount;
var (Collision)		rangevector					SpawnedVelocityScaleRange;

var (Color)			array<ParticleColorScale>	ColorScale;
var (Color)			float						ColorScaleRepeats;
var (Color)			rangevector					ColorMultiplierRange;
var (Color)			float						Opacity; // Added by Demiurge (PSE)

var (Fading)		plane						FadeOutFactor;
var (Fading)		float						FadeOutStartTime;
var (Fading)		plane						FadeInFactor;
var (Fading)		float						FadeInEndTime;

var (General)		const int					MaxParticles;

var (Local)			range						AutoResetTimeRange;
var (Local)			string						Name;

var (Location)		vector						StartLocationOffset;
var (Location)		rangevector					StartLocationRange;
var (Location)		int							AddLocationFromOtherEmitter;
var (Location)		range						SphereRadiusRange;
var (Location)		rangevector					StartLocationPolarRange;

var (LOD)			float						LODDistance;
var (LOD)			float						CollisionLODDistance;
var (LOD)			float						MaxLODScale;

var (Mass)			range						StartMassRange;

var (MeshSpawning)	staticmesh					MeshSpawningStaticMesh;
var (MeshSpawning)	rangevector					VelocityScaleRange;
var (MeshSpawning)	rangevector					MeshScaleRange;
var (MeshSpawning)	vector						MeshNormal;
var (MeshSpawning)	range						MeshNormalThresholdRange;

var (Rendering)		int							AlphaRef;

var (Revolution)	rangevector					RevolutionCenterOffsetRange;
var (Revolution)	rangevector					RevolutionsPerSecondRange;
var (Revolution)	array<ParticleRevolutionScale> RevolutionScale;
var (Revolution)	float						RevolutionScaleRepeats;

var (Rotation)		rotator						RotationOffset;
var (Rotation)		vector						SpinCCWorCW;
var (Rotation)		rangevector					SpinsPerSecondRange;
var (Rotation)		rangevector					StartSpinRange;
var (Rotation)		rangevector					RotationDampingFactorRange;
var (Rotation)		vector						RotationNormal;

var (Size)			array<ParticleTimeScale>	SizeScale;
var (Size)			float						SizeScaleRepeats;
var (Size)			rangevector					StartSizeRange;

var	(SkeletalMesh)	actor						SkeletalMeshActor;
var (SkeletalMesh)	vector						SkeletalScale;
var (SkeletalMesh)	range						RelativeBoneIndexRange;

var (Sound)			array<ParticleSound>		Sounds;
var (Sound)			range						SpawningSoundIndex;
var (Sound)			range						SpawningSoundProbability;
var (Sound)			range						CollisionSoundIndex;
var (Sound)			range						CollisionSoundProbability;

var (Spawning)		float						ParticlesPerSecond;
var (Spawning)		float						InitialParticlesPerSecond;

var (Texture)		texture						Texture;
var (Texture)		int							TextureUSubdivisions;
var (Texture)		int							TextureVSubdivisions;
var (Texture)		array<float>				SubdivisionScale;
var (Texture)		int							SubdivisionStart;
var (Texture)		int							SubdivisionEnd;

var (Tick)			float						SecondsBeforeInactive;
var (Tick)			float						MinSquaredVelocity;

var	(Time)			range						InitialTimeRange;
var (Time)			range						LifetimeRange;
var (Time)			range						InitialDelayRange;

var (Trigger)		range						SpawnOnTriggerRange;
var (Trigger)		float						SpawnOnTriggerPPS;

var (Velocity)		rangevector					StartVelocityRange;
var (Velocity)		range						StartVelocityRadialRange;
var (Velocity)		vector						MaxAbsVelocity;
var (Velocity)		rangevector					VelocityLossRange;
var (Velocity)		int							AddVelocityFromOtherEmitter;
var (Velocity)		rangevector					AddVelocityMultiplierRange;
var (Velocity)		array<ParticleVelocityScale> VelocityScale;
var (Velocity)		float						VelocityScaleRepeats;

var (Warmup)		float						WarmupTicksPerSecond;
var (Warmup)		float						RelativeWarmupTime;

var (Collision)		float						CollisionDistTest;

var transient		emitter						Owner;
var transient		float						InactiveTime;
var transient		array<Particle>				Particles;
var transient		int							ParticleIndex;			// index into circular list of particles
var transient		int							ActiveParticles;		// currently active particles
var transient		float						PPSFraction;			// used to keep track of fractional PPTick
var transient		box							BoundingBox;

var transient		vector						RealExtentMultiplier;
var	transient		int							OtherIndex;
var transient		float						InitialDelay;
var transient		vector						GlobalOffset;
var transient		float						TimeTillReset;
var transient		int							PS2Data;
var transient		int							MaxActiveParticles;
var transient		int							CurrentCollisionSoundIndex;
var transient		int							CurrentSpawningSoundIndex;
var transient		int							CurrentMeshSpawningIndex;
var transient		float						MaxSizeScale;
var transient		int							DeferredParticles;
var transient		vector						RealMeshNormal;
var transient		array<vector>				MeshVertsAndNormals;
var transient		int							CurrentSpawnOnTrigger;

// ZONER: Moved transient bools to bottom, there is an unreal bug grouping them with non-transient bools
var transient		bool					    KillPending;
var	transient		bool						Initialized;
var transient		bool						Inactive;
var transient		bool						AllParticlesDead;
var transient		bool						WarmedUp;
var transient		bool						WasTicked;	// GBX:sjp - mark when the particle has been ticked

native function SpawnParticle( int Amount );
native function Trigger();

// GBX:naj - added 5/28/03
native function ResetMaxParticles( int NewMaxParticles );

// GBX:naj - added 9/25/03
native function SuspendSpawning();
native function UnSuspendSpawning();
// GBX:naj - end added 9/25/03

defaultproperties
{
	Texture=Texture'Engine.S_Emitter'
	SecondsBeforeInactive=1
	DrawStyle=PTDS_Translucent
	MaxParticles=10
	FadeOutFactor=(X=1,Y=1,Z=1,W=1)
	FadeInFactor=(X=1,Y=1,Z=1,W=1)
	SpinCCWorCW=(X=0.5,Y=0.5,Z=0.5)
	ExtentMultiplier=(X=1,Y=1,Z=1)
	AutomaticInitialSpawning=1
	UseRegularSizeScale=True
	RespawnDeadParticles=True
	StartSizeRange=(X=(Min=100,Max=100),Y=(Min=100,Max=100),Z=(Min=100,Max=100))
	DampingFactorRange=(X=(Min=1,Max=1),Y=(Min=1,Max=1),Z=(Min=1,Max=1))
	StartMassRange=(Min=1,Max=1)
	LifetimeRange=(Min=4,Max=4)
	AddLocationFromOtherEmitter=-1
	AddVelocityFromOtherEmitter=-1
	SpawnFromOtherEmitter=-1
	AlphaTest=1
	AcceptsProjectors=false
	ColorMultiplierRange=(X=(Min=1,Max=1),Y=(Min=1,Max=1),Z=(Min=1,Max=1))
	Opacity=1.0 // Added by Demiurge (PSE)
	ZTest=true
	ZWrite=false
	AddVelocityMultiplierRange=(X=(Min=1,Max=1),Y=(Min=1,Max=1),Z=(Min=1,Max=1))
	TriggerDisabled=true
	VelocityScaleRange=(X=(Min=1,Max=1),Y=(Min=1,Max=1),Z=(Min=1,Max=1))
	MeshScaleRange=(X=(Min=1,Max=1),Y=(Min=1,Max=1),Z=(Min=1,Max=1))
	UniformMeshScale=true
	UniformVelocityScale=true
	MeshNormal=(X=0,Y=0,Z=1)
	SkeletalScale=(X=1,Y=1,Z=1)
	RelativeBoneIndexRange=(Min=0,Max=1)
	MaxAbsVelocity=(X=10000,Y=10000,Z=10000) // Added by Demiurge (PSE)
	bSuspendSpawning=false	// GBX:naj - added 9/4/03
	CollisionDelayedBySpeedOfSound=true	// GEARBOX: PSV 4/12/2004 added
	SpawnDelayedBySpeedOfSound=false	// GEARBOX: PSV 4/12/2004 added
	WasTicked=false // GBX:sjp - added 12/31/2004
}
//=============================================================================
// PathNode.
//=============================================================================
class PathNode extends NavigationPoint
	placeable
	native;


var Material PathNodeTextures[4];

cpptext
{
	virtual void Modify();
	virtual void PostEditMove();
	virtual void PostEditChange();
	virtual void Spawned();
	virtual void Destroy();
	virtual void CheckForErrors();
	virtual UBOOL ReviewPath(APawn* Scout);
	virtual void CheckSymmetry(UActorLite* Other);
	virtual INT AddMyMarker(AActor *S);
}


defaultproperties
{
	SoundVolume=128
	Texture=Texture'Engine.S_PathNode'

	PathNodeTextures(0)=Texture'Engine.S_PathNode'
	PathNodeTextures(1)=Texture'Engine.S_PathNode_yellow'
	PathNodeTextures(2)=Texture'Engine.S_PathNode_blue'
	PathNodeTextures(3)=Texture'Engine.S_PathNode_green'
}
//=============================================================================
// PathNodeLite.
//=============================================================================
class PathNodeLite extends NavigationPointLite
	placeable
	native;


//var Material PathNodeTextures[4];

defaultproperties
{
//	Texture=Texture'Engine.S_PathNode'

//	PathNodeTextures(0)=Texture'Engine.S_PathNode'
//	PathNodeTextures(1)=Texture'Engine.S_PathNode_yellow'
//	PathNodeTextures(2)=Texture'Engine.S_PathNode_blue'
//	PathNodeTextures(3)=Texture'Engine.S_PathNode_green'
}
//=============================================================================
// Pawn, the base class of all actors that can be controlled by players or AI.
//
// Pawns are the physical representations of players and creatures in a level.
// Pawns have a mesh, collision, and physics.  Pawns can take damage, make sounds,
// and hold weapons and other inventory.  In short, they are responsible for all
// physical interaction between the player or AI and the world.
//
// This is a built-in Unreal class and it shouldn't be modified.
//=============================================================================
class Pawn extends Actor
	native
	placeable
	config(user)
	nativereplication;



//-----------------------------------------------------------------------------
// Pawn variables.

var Controller Controller;

// cache net relevancy test
var float NetRelevancyTime;
var playerController LastRealViewer;
var actor LastViewer;

// Physics related flags.
var bool		bJustLanded;		// used by eyeheight adjustment
var bool		bUpAndOut;			// used by swimming
var bool		bIsWalking;			// currently walking (can't jump, affects animations)
// GBX:PAD: Added a boolean to handle setting the character to a slow walking "creep"
var bool		bIsCreeping;		// currently walking at a very slow speed
var bool		bIsSprinting;		// Player is sprinting (very fast run and they can't shoot while in this state)
var bool		bWarping;			// Set when travelling through warpzone (so shouldn't telefrag)

var bool		bWantsToCrouch;		// if true crouched (physics will automatically reduce collision height to CrouchHeight)
var const bool	bIsCrouched;		// set by physics to specify that Pawn is currently crouched
var const bool	bTryToUncrouch;		// when auto-crouch during movement, continually try to uncrouch
var() bool		bCanCrouch;			// if true, this Pawn is capable of crouching
var bool		bNextCrouchState;	// Remembers the previous tick's crouch state.  Allows crouch toggle.

var bool		bWantsToGoProne;	// if true prone (physics will automatically reduce collision height to ProneHeight)
var const bool	bIsProne;			// set by physics to specify that Pawn is currently prone
var const bool	bTryToGoUnprone;	// when auto-prone during movement, continually try to go unprone
var() bool		bCanGoProne;		// if true, this Pawn is capable of going prone

var bool		bCrawler;			// crawling - pitch and roll based on surface Pawn is on
var const bool	bReducedSpeed;		// used by movement natives
var bool		bJumpCapable;
var	bool		bCanJump;			// movement capabilities - used by AI
var	bool 		bCanWalk;
var	bool		bCanSwim;
var	bool		bCanFly;
var	bool		bCanClimbLadders;
var	bool		bCanStrafe;
var	bool		bCanDoubleJump;
var	bool		bAvoidLedges;		// don't get too close to ledges
var	bool		bStopAtLedges;		// if bAvoidLedges and bStopAtLedges, Pawn doesn't try to walk along the edge at all
var	bool		bNoJumpAdjust;		// set to tell controller not to modify velocity of a jump/fall
var	bool		bCountJumps;		// if true, inventory wants message whenever this Pawn jumps
var const bool	bSimulateGravity;	// simulate gravity for this Pawn on network clients when predicting position (true if Pawn is walking or falling)
var	bool		bUpdateEyeheight;	// if true, UpdateEyeheight will get called every tick
var	bool		bIgnoreForces;		// if true, not affected by external forces
var const bool	bNoVelocityUpdate;	// used by C++ physics
var	bool		bCanWalkOffLedges;	// Can still fall off ledges, even when walking (for Player Controlled pawns)
var bool		bSteadyFiring;		// used for third person weapon anims/effects
var bool		bCanBeBaseForPawns;	// all your 'base', are belong to us
var bool		bClientCollision;	// used on clients when temporarily turning off collision
var const bool	bSimGravityDisabled;	// used on network clients
var bool		bDirectHitWall;		// always call Pawn hitwall directly (no controller notifyhitwall)
var bool		bIsManningTurret;	// GBX:naj - added 8/8/03
var bool		bNoTurnBody;		// GBX:naj - used to prevent Pawn rotation when firing around corners.
var bool		bUseRootMotion;		// GBX:PAD: Set this to enable using root motion for this Pawn.
var bool		bDontDropWeapon;	// GBX:PAD: When this guy dies, do not drop a weapon.
var bool		bHasStartedMountAnim;		// GBX:jlb - Whether the pawn has started his mount/dismount animation.
var bool		bIsManning88;		//GBX:NAC - added 6/15/05

//GBX:jlb added new animation state flags...
//var bool bWeaponDrawn;  // indicates whether the player has the weapon drawn up to fire position
var float	flLastAimedStateChange;	// Time the aimed state was last changed (so we can automatically relax posture after X seconds).
var EWeaponAimedStateTypes	eWeaponAimedState;		// What state is this guy in (0=relaxed, 1=ready, 2=aimed hip, 4=sighted)
var EWeaponAimedStateTypes	eLastWeaponAimedState;  // What was our weapon aimed state last frame?
var bool	bIsStrafing;

// used by dead pawns (for bodies landing and changing collision box)
var		bool	bThumped;
var		bool	bInvulnerableBody;

// AI related flags
var		bool	bIsFemale;
var		bool	bAutoActivate;			// if true, automatically activate Powerups which have their bAutoActivate==true
var		bool	bCanPickupInventory;	// if true, will pickup inventory when touching pickup actors
var		bool	bUpdatingDisplay;		// to avoid infinite recursion through inventory setdisplay
var		bool	bAmbientCreature;		// AIs will ignore me
var(AI) bool	bLOSHearing;			// can hear sounds from line-of-sight sources (which are close enough to hear)
										// bLOSHearing=true is like UT/Unreal hearing
var(AI) bool	bSameZoneHearing;		// can hear any sound in same zone (if close enough to hear)
var(AI) bool	bAdjacentZoneHearing;	// can hear any sound in adjacent zone (if close enough to hear)
var(AI) bool	bMuffledHearing;		// can hear sounds through walls (but muffled - sound distance increased to double plus 4x the distance through walls
var(AI) bool	bAroundCornerHearing;	// Hear sounds around one corner (slightly more expensive, and bLOSHearing must also be true)
var(AI) bool	bDontPossess;			// if true, Pawn won't be possessed at game start
var		bool	bAutoFire;				// used for third person weapon anims/effects
var		bool	bRollToDesired;			// Update roll when turning to desired rotation (normally false)
var		bool	bIgnorePlayFiring;		// if true, ignore the next PlayFiring() call (used by AnimNotify_FireWeapon)

var		bool	bCachedRelevant;		// network relevancy caching flag
var		bool	bUseCompressedPosition;	// use compressed position in networking - true unless want to replicate roll, or very high velocities
var		globalconfig bool bWeaponBob;
var     bool    bHideRegularHUD;
var		bool	bSpecialHUD;
var		bool    bSpecialCalcView;		// If true, the Controller controlling this Pawn will call 'SpecialCalcView' to find camera pos.
var		bool	bNoWeaponFiring;
var		bool	bIsTyping;
// GBX:PAD: I'm putting this bool here to show the weapon has changed, so run the code that indicates animations have
// changed.  I put this in this location in code to optimize bool's
var		bool	bWeaponChange;
var		bool	m_fDispositionAnimPlaying;
var		bool	m_fLerpMoveAnim;
var		bool	m_fFingerMissing;
var()	bool	m_fDontTakeDamage;

var		byte	m_bTeleportAtAnimEnd;

var		byte	FlashCount;				// used for third person weapon anims/effects
// AI basics.
var 	byte	Visibility;			//How visible is the Pawn? 0=invisible, 128=normal, 255=highly visible
var		float	DesiredSpeed;
var		float	MaxDesiredSpeed;
var(AI) name	AIScriptTag;		// tag of AIScript which should be associated with this Pawn
var(AI) float	HearingThreshold;	// max distance at which a makenoise(1.0) loudness sound can be heard
var(AI)	float	Alertness;			// -1 to 1 ->Used within specific states for varying reaction to stimuli
var(AI)	float	SightRadius;		// Maximum seeing distance.
var(AI)	float	PeripheralVision;	// Cosine of limits of peripheral vision.
var()	float	SkillModifier;			// skill modifier (same scale as game difficulty)
var const float	AvgPhysicsTime;		// Physics updating time monitoring (for AI monitoring reaching destinations)
var		float	MeleeRange;			// Max range for melee attack (not including collision radii)
var ActorLite	Anchor;			// current nearest path;
var const ActorLite LastAnchor;		// recent nearest path
var		float	FindAnchorFailedTime;	// last time a FindPath() attempt failed to find an anchor.
var		float	LastValidAnchorTime;	// last time a valid anchor was found
var		float	DestinationOffset;	// used to vary destination over NavigationPoints
var		float	NextPathRadius;		// radius of next path in route
var		vector	SerpentineDir;		// serpentine direction
var		float	SerpentineDist;
var		float	SerpentineTime;		// how long to stay straight before strafing again
var const float	UncrouchTime;		// when auto-crouch during movement, continually try to uncrouch once this decrements to zero
var const float	GoUnproneTime;		// when auto-prone during movement, continually try to gounprone once this decrements to zero
var		float	SpawnTime;
var		bool	bShowDesiredPosition;
var		vector	DesiredPosition;

// Movement.
var float   GroundSpeed;    // The maximum ground speed.
var float   WaterSpeed;     // The maximum swimming speed.
var float   AirSpeed;		// The maximum flying speed.
var float	LadderSpeed;	// Ladder climbing speed
var float	AccelRate;		// max acceleration rate
var float	DecelRate;		// GBX:PAD: max deceleration rate
var float	JumpZ;      	// vertical acceleration w/ jump
var float	MinJumpZ;      	// minimum vertical acceleration w/ jump
var float   AirControl;		// amount of AirControl available to the Pawn
var float	RunningStrafePct;	// pct. of running speed that run strafing is
var float	RunningBackPct;		// pct. of running speed that run backpeddling is
var float	WalkingPct;		// pct. of running speed that walking speed is
var float	WalkingStrafePct;	// pct. of running speed that strafing is
var float	WalkingBackPct;	// pct. of running speed that walk backpeddling is
var float	CrouchedPct;	// pct. of running speed that crouched walking speed is
var float	CrouchedStrafePct;	// pct. of running speed that crouch strafing is
var float	CrouchedBackPct;	// pct. of running speed that crouched backpeddling is
// GBX:PAD: Added the percentage of the regular movement distance that a creep represents per animation cycle
//var float	CreepingPct;	// pct. of running speed that a slow creep walking is
//var float	PronePct;		// pct. of running speed that prone crawling speed is
var float	SprintPct;		// pct. of running speed that sprint running speed is
var float	LimpingPct;		// pct. of running speed that limp speed is
//var float	CreepingThreshold;		// Percent of running speed at which to change from a creep animation to walking
var float	WalkingThreshold;		// Percent of running speed at which to change from a walking animation to running
var float	CrouchedThreshold;		// Maximum crouch walking speed as a percent of running speed
var float	StrafeThreshold;		// Maximum lateral movement speed, assuming zero forward or backward velocity
var float	BackwardThreshold;		// Maximum backward movement speed, assuming zero lateral movement
var float	MaxFallSpeed;	// max speed Pawn can land without taking damage (also limits what paths AI can use)
var vector	ConstantAcceleration;	// acceleration added to Pawn when falling
var int		m_nMovementFacingYaw;	// Yaw in which the pawns movement should be facing them.
var float	MaxMoveDistance;		// maximum movement distance (for APawn::physWalking) to clamp over-shooting the destination at low frame rates
var Vehicle DrivenVehicle;

// Player info.
var	string			OwnerName;		// Name of owning player (for save games, coop)
var travel Weapon	Weapon;			// The Pawn's current weapon.
var Weapon			PendingWeapon;	// Will become weapon once current weapon is put down
var travel Powerups	SelectedItem;	// currently selected inventory item
var float      		BaseEyeHeight; 	// Base eye height above collision center.
var float        	EyeHeight;     	// Current eye height, adjusted for bobbing and stairs.
var	const vector	Floor;			// Normal of floor Pawn is standing on (only used by PHYS_Spider and PHYS_Walking)
var float			SplashTime;		// time of last splash
var float			CrouchHeight;	// CollisionHeight when crouching
var float			CrouchRadius;	// CollisionRadius when crouching
var float			ProneHeight;	// CollisionHeight when prone
var float			ProneRadius;	// CollisionRadius when prone
var float			OldZ;			// Old Z Location - used for eyeheight smoothing
var PhysicsVolume	HeadVolume;		// physics volume of head
var travel int      Health;         // Health: 100 = normal maximum
var	float			BreathTime;		// used for getting BreathTimer() messages (for no air, etc.)
var float			UnderWaterTime; // how much time Pawn can go without air (in seconds)
var	float			LastPainTime;	// last time Pawn played a takehit animation (updated in PlayHit())
var class<DamageType> ReducedDamageType; // which damagetype this creature is protected from (used by AI)
var float			HeadScale;

// Sound and noise management
// remember location and position of last noises propagated
var const 	vector 		noise1spot;
var const 	float 		noise1time;
var const	Pawn		noise1other;
var const	float		noise1loudness;
var const 	vector 		noise2spot;
var const 	float 		noise2time;
var const	Pawn		noise2other;
var const	float		noise2loudness;
var			float		LastPainSound;

// view bob
var				globalconfig float Bob;
var				globalconfig float ZoomBob;
var				float				LandBob, AppliedBob;
var				float bobtime;
var				vector			WalkBob;

// zoom kicking...
var bool kick_zoom_active;
var bool kick_zooming_out;
var float DesiredZoomFOV;
var float PreZoomFOV;

var float SoundDampening;
var float DamageScaling;

var localized  string MenuName; // Name used for this Pawn type in menus (e.g. player selection)
var localized  string MenuNameBaker;
var localized  string MenuNameHans;
var localized  string MenuNameFrans;

// blood effect
var class<Effects> BloodEffect;
var class<Effects> LowGoreBlood;

var(AI) class<AIController> ControllerClass;	// default class to use when Pawn is controlled by AI (can be modified by an AIScript)

var PlayerReplicationInfo PlayerReplicationInfo;

var LadderVolume OnLadder;		// ladder currently being climbed

var name LandMovementState;		// PlayerControllerState to use when moving on land or air
var name WaterMovementState;	// PlayerControllerState to use when moving in water

var PlayerStart LastStartSpot;	// used to avoid spawn camping
var float LastStartTime;

// Animation status
var name AnimAction;			// use for replicating anims

// Animation updating by physics FIXME - this should be handled as an animation object
// Note that animation channels 2 through 11 are used for animation updating
var vector TakeHitLocation;		// location of last hit (for playing hit/death anims)
var class<DamageType> HitDamageType;	// damage type of last hit (for playing hit/death anims)
var vector TearOffMomentum;		// momentum to apply when torn off (bTearOff == true)
var bool bPhysicsAnimUpdate;
var bool bWasCrouched;
var bool bWasProne;
var bool bWasWalking;
var bool bWasSprinting;
var bool bWasOnGround;
var bool bWasStrafing;     // GBX:jlb - added new animation states
var bool bInitializeAnimation;
var bool bPlayedDeath;
var bool m_fCanSprint;		// GBX:PAD: Can this character sprint or not?
var EPhysics OldPhysics;
var float OldRotYaw;			// used for determining if Pawn is turning
var vector OldAcceleration;
var float BaseMovementRate;		// FIXME - temp - used for scaling movement
var name MovementAnimsDown[4];	// GBX:PAD: Forward Aim Up, Back Aim Up, Left Aim Up, Right Aim Up
var name MovementAnims[4];		// Forward, Back, Left, Right
var name MovementAnimsUp[4];	// GBX:PAD: Forward Aim Up, Back Aim Up, Left Aim Up, Right Aim Up
var name TurnLeftAnim;
var name TurnRightAnim;			// turning anims when standing in place (scaled by turn speed)
var(AnimTweaks) float BlendChangeTime;	// time to blend between movement animations
var float MovementBlendStartTime;	// used for delaying the start of run blending
var float ForwardStrafeBias;	// bias of strafe blending in forward direction
var float BackwardStrafeBias;	// bias of strafe blending in backward direction

var transient CompressedPosition PawnPosition;


// sjp --- Slow down crouch toggling
var float CrouchToggleIntervalCounter;				// Keeps track of how long the player has to wait before he can toggle his crouch state again
var globalconfig float MinCrouchToggleInterval;		// Crouch can only be toggled at this rate

var float m_flEncumberance;
var ETeamIdentifier PawnTeam;

var int LatentAction;			// This is used by the triggered script to see if it's waiting on an animation to end.
var int LatentActionChannel;	// What channel did this latent action end on?

const WALK_VELOCITY_COUNT_THRESHOLD = 5;
var byte WalkVelocityCount;		// GBX:PAD: Hackity hack, keep track of how many times this pawn has wanted to drop to a walk animation,
								// and only do so if it looks like it's really serious about walking.
var float WalkVelocityTime;

var		float				m_flLegScale;

var		float				m_flJumpEndurance;	// GBX:PAD: What percent of normal jump ability does the character still have?

const MAX_SECONDARY_BUCKETS	=	4;
var travel Inventory	SecondaryInventory[4];

var		float				m_flLastForwardPct;
var		float				m_flLastLeftPct;
var		float				m_flMinForwardLerpPerSec;
var		float				m_flMinLeftLerpPerSec;
var		float				m_flLastMoveRateAdjustForward;
var		float				m_flLastMoveRateAdjustBack;
var		float				m_flLastMoveRateAdjustLeft;

replication
{
	// Variables the server should send to the client.
	reliable if( bNetDirty && (Role==ROLE_Authority) )
        bSimulateGravity, bIsCrouched, bIsWalking, bIsCreeping, bIsSprinting, bIsTyping, PlayerReplicationInfo, AnimAction, HitDamageType, TakeHitLocation, HeadScale, bInitializeAnimation;
//        bSimulateGravity, bIsCrouched, bIsWalking, bIsCreeping, bIsSprinting, bIsTyping, PlayerReplicationInfo, AnimAction, HitDamageType, TakeHitLocation, HeadScale, bWantsToCrouch, bInitializeAnimation;
	reliable if( bTearOff && bNetDirty && (Role==ROLE_Authority) )
		TearOffMomentum;
	reliable if ( bNetDirty && !bNetOwner && (Role==ROLE_Authority) )
		bSteadyFiring, EyeHeight;
	reliable if( bNetDirty && bNetOwner && Role==ROLE_Authority )
         Controller,SelectedItem, GroundSpeed, WaterSpeed, AirSpeed, AccelRate, JumpZ, MinJumpZ, AirControl;
	reliable if( bNetDirty && Role==ROLE_Authority )
         Health, m_flEncumberance, PawnTeam;
    unreliable if ( !bNetOwner && Role==ROLE_Authority )
		PawnPosition;

	reliable if ( bNetDirty && Role == ROLE_Authority )
		bIsManningTurret;

	//reliable if ( bNetDirty && Role == ROLE_Authority )
	//	bIs88Special;

//	reliable if (ROLE==ROLE_Authority)
//		StartCrouch, EndCrouch, eWeaponAimedState;
	// GBX:PAD: It's possible that these replicated functions caused issues with crouching states between client
	// and server in multiplayer.  Try getting rid of them and see what happens.
	reliable if (ROLE==ROLE_Authority)
		eWeaponAimedState;

	// replicated functions sent to server by owning client
	reliable if( Role<ROLE_Authority )
		ServerChangedWeapon, SetSprinting;
		
	unreliable if ( (!bSkipActorPropertyReplication || bNetInitial) && (Role==ROLE_Authority)
					&& bNetDirty && bNetOwner )
		SecondaryInventory;
}

// << GEARBOX/jmw:add - IsDead() evaluates whether Pawn Health <= 0.
simulated function bool IsDead()
{
	return bDeleteMe || Health <= 0;
}
// GEARBOX >>

simulated event SetHeadScale(float NewScale);

native function bool ReachedDestination(ActorLite Goal);
native function ForceCrouch();
native function ForceGoProne();
native function ForceUnCrouch();  // forces a Pawn to instantly UnCrouch
native function bool CheckEncroachment( Vector InTestLocation, Rotator InTestRotation, out Actor EncroachedActor );	// GBX:naj - added 11/21/03
simulated native function vector CalcDrawOffset(Inventory Inv);

simulated function Weapon GetDemoRecordingWeapon()
{
	local inventory Inv;

	for ( Inv=Inventory; Inv!=None; Inv=Inv.Inventory )
	{
		if ( (Weapon(Inv) != None) && (Inv.ThirdPersonActor != None) )
		{
			Weapon = Weapon(Inv);
			PendingWeapon = Weapon;
			break;
		}
	}
	return Weapon;
}

/* Reset()
reset actor to initial state - used when restarting level without reloading.
*/
function Reset()
{
	if ( (Controller == None) || Controller.bIsPlayer )
		Destroy();
	else
		Super.Reset();
}

function Fire( optional float F )
{
    if( Weapon!=None )
        Weapon.Fire(F);
}

function DrawHUD(Canvas Canvas);

// If returns false, do normal calview anyway
function bool SpecialCalcView(out actor ViewActor, out vector CameraLocation, out rotator CameraRotation );

simulated function String GetHumanReadableName()
{
	local String strHumanName;
	
	strHumanName = MenuName;

	if ( Level != None && (Level.NetMode == NM_LISTENSERVER || Level.NetMode == NM_CLIENT) )
	{
		if (PlayerReplicationInfo != None)
		{
			strHumanName = PlayerReplicationInfo.GetHumanReadableName();
		}
	}

	return strHumanName;
}

function PlayTeleportEffect(bool bOut, bool bSound)
{
	MakeNoise(1.0);
}

/* PossessedBy()
 Pawn is possessed by Controller
*/
function PossessedBy(Controller C)
{
	Controller = C;
	NetPriority = 3;
	NetUpdateFrequency = 100;
	NetUpdateTime = Level.TimeSeconds - 1;

	if ( C.PlayerReplicationInfo != None )
	{
		PlayerReplicationInfo = C.PlayerReplicationInfo;
		OwnerName = PlayerReplicationInfo.PlayerName;
	}
	if ( C.IsA('PlayerController') )
	{
		if ( Level.NetMode != NM_Standalone )
			RemoteRole = ROLE_AutonomousProxy;
		BecomeViewTarget();
	}
	else
		RemoteRole = Default.RemoteRole;

	SetOwner(Controller);	// for network replication
	Eyeheight = BaseEyeHeight;
	ChangeAnimation();
}

function UnPossessed()
{
	NetUpdateTime = Level.TimeSeconds - 1;
	if ( DrivenVehicle != None )
		NetUpdateFrequency = 5;

	PlayerReplicationInfo = None;
	SetOwner(None);
	Controller = None;
}

/* PointOfView()
called by controller when possessing this Pawn
false = 1st person, true = 3rd person
*/
simulated function bool PointOfView()
{
	return false;
}

function BecomeViewTarget()
{
	bUpdateEyeHeight = true;
}

function DropToGround()
{
	bCollideWorld = True;
	bInterpolating = false;
	if ( Health > 0 )
	{
		SetCollision(true,true,true);
		SetPhysics(PHYS_Falling);
		AmbientSound = None;
		if ( IsHumanControlled() )
			Controller.GotoState(LandMovementState);
	}
}

function bool CanGrabLadder()
{
	return ( bCanClimbLadders
			&& (Controller != None)
			&& (Physics != PHYS_Ladder)
			&& ((Physics != Phys_Falling) || (abs(Velocity.Z) <= JumpZ)) );
}

event SetWalking(bool bNewIsWalking)
{
	if ( bNewIsWalking != bIsWalking )
	{
		bIsWalking = bNewIsWalking;
		ChangeAnimation();
	}
}

event SetSprinting(bool bNewIsSprinting)
{
	if( bNewIsSprinting != bIsSprinting )
	{
		if( bIsCrouched )
			bCanCrouch = false;

		bIsSprinting = bNewIsSprinting;
		ChangeAnimation();
	}
}

function bool CanSplash()
{
	if ( (Level.TimeSeconds - SplashTime > 0.25)
		&& ((Physics == PHYS_Falling) || (Physics == PHYS_Flying))
		&& (Abs(Velocity.Z) > 100) )
	{
		SplashTime = Level.TimeSeconds;
		return true;
	}
	return false;
}

function EndClimbLadder(LadderVolume OldLadder)
{
	if ( Controller != None )
		Controller.EndClimbLadder();
	if ( Physics == PHYS_Ladder )
		SetPhysics(PHYS_Falling);
}

function ClimbLadder(LadderVolume L)
{
	OnLadder = L;
	SetRotation(OnLadder.WallDir);
	SetPhysics(PHYS_Ladder);
	if ( IsHumanControlled() )
		Controller.GotoState('PlayerClimbing');
}

/* DisplayDebug()
list important actor variable on canvas.  Also show the Pawn's controller and weapon info
*/
simulated function DisplayDebug(Canvas Canvas, out float YL, out float YPos)
{
	//local string T;
	Super.DisplayDebug(Canvas, YL, YPos);

	/*
	Canvas.SetDrawColor(255,255,255);

	Canvas.DrawText("Animation Action "$AnimAction$" Health "$Health, false, 0.9, 0.9);
	YPos += YL;
	Canvas.SetPos(4,YPos);
	Canvas.DrawText("Anchor "$Anchor$" Serpentine Dist "$SerpentineDist$" Time "$SerpentineTime, false, 0.9, 0.9);
	YPos += YL;
	Canvas.SetPos(4,YPos);

	T = "Floor "$Floor$" DesiredSpeed "$DesiredSpeed$" Crouched "$bIsCrouched$" Try to uncrouch "$UncrouchTime;
	if ( (OnLadder != None) || (Physics == PHYS_Ladder) )
		T=T$" on ladder "$OnLadder;
	Canvas.DrawText(T, false, 0.9, 0.9);
	YPos += YL;
	Canvas.SetPos(4,YPos);
	Canvas.DrawText("EyeHeight "$Eyeheight$" BaseEyeHeight "$BaseEyeHeight$" Physics Anim "$bPhysicsAnimUpdate, false, 0.9, 0.9);
	YPos += YL;
	Canvas.SetPos(4,YPos);

	if ( Controller == None )
	{
		Canvas.SetDrawColor(255,0,0);
		Canvas.DrawText("NO CONTROLLER", false, 0.9, 0.9);
		YPos += YL;
		Canvas.SetPos(4,YPos);
	}
	else
		Controller.DisplayDebug(Canvas,YL,YPos);

	if ( Weapon == None )
	{
		Canvas.SetDrawColor(0,255,0);
		Canvas.DrawText("NO WEAPON", false, 0.9, 0.9);
		YPos += YL;
		Canvas.SetPos(4,YPos);
	}
	else
		Weapon.DisplayDebug(Canvas,YL,YPos);
	*/
}

// amb ---
event vector CameraShake()
{
    local vector x, y, z, shakevect;
    local PlayerController pc;

    pc = PlayerController(Controller);

    if (pc == None)
        return shakevect;

    GetAxes(pc.Rotation, x, y, z);

    shakevect = pc.ShakeOffset.X * x +
                pc.ShakeOffset.Y * y +
                pc.ShakeOffset.Z * z;

    return shakevect;
}
// --- amb

event vector ModifiedPlayerViewOffset(inventory Inv)
{
	return Inv.PlayerViewOffset;
}

event vector WeaponBob(float BobDamping)
{
	Local Vector WBob;

	WBob = BobDamping * WalkBob;
	WBob.Z = (0.45 + 0.55 * BobDamping) * WalkBob.Z;
	return WBob;
}

function CheckBob(float DeltaTime, vector Y)
{
	local float Speed2D;

    if( !bWeaponBob )
    {
		BobTime = 0;
		WalkBob = Vect(0,0,0);
        return;
    }

//	Bob = FClamp(Bob, -0.01, 0.01);
	Bob = FClamp(Bob, -0.5, 0.5);

	if (Physics == PHYS_Walking )
	{
		Speed2D = VSize(Velocity);
		if ( Speed2D < 10 )
			BobTime += 0.2 * DeltaTime;
		else
			BobTime += DeltaTime * (0.3 + 0.7 * Speed2D/GroundSpeed);
		WalkBob = Y * Bob * Speed2D * sin(8 * BobTime);
		AppliedBob = AppliedBob * (1 - FMin(1, 16 * deltatime));
		WalkBob.Z = AppliedBob;
		if ( Speed2D > 10 )
			WalkBob.Z = WalkBob.Z + 0.75 * Bob * Speed2D * sin(16 * BobTime);
		if ( LandBob > 0.01 )
		{
			AppliedBob += FMin(1, 16 * deltatime) * LandBob;
			LandBob *= (1 - 8*Deltatime);
		}
	}
	else if ( Physics == PHYS_Swimming )
	{
		Speed2D = Sqrt(Velocity.X * Velocity.X + Velocity.Y * Velocity.Y);
		WalkBob = Y * Bob *  0.5 * Speed2D * sin(4.0 * Level.TimeSeconds);
		WalkBob.Z = Bob * 1.5 * Speed2D * sin(8.0 * Level.TimeSeconds);
	}
	else
	{
		BobTime = 0;
		WalkBob = WalkBob * (1 - FMin(1, 8 * deltatime));
	}
}

//***************************************
// Vehicle driving
// StartDriving() and StopDriving() also called on client
// on transitions of bIsDriving setting

simulated event StartDriving(Vehicle V)
{
	DrivenVehicle = V;
	NetUpdateTime = Level.TimeSeconds - 1;
    AmbientSound = None;
//jlb    StopWeaponFiring();
	if (Weapon != None)
	{
		Weapon.StopFire(0);
		Weapon.StopFire(1);
	}
//jlb	DeactivateSpawnProtection();

	// Move the driver into position, and attach to car.
	ShouldCrouch(false);
	bIgnoreForces = true;
	Velocity = vect(0,0,0);
	Acceleration = vect(0,0,0);
	bCanTeleport = false;

	if ( !V.bRemoteControlled || V.bHideRemoteDriver )
    {
		SetCollision( False, False, False);
		bCollideWorld = false;
		V.AttachDriver( Self );
		if ( V.bDrawDriverinTP )
			CullDistance = 5000;
		else
		   	bHidden = true;
    }

	// set animation
	bPhysicsAnimUpdate = false;
//jlb	bWaitForAnim = false;
	if ( !V.bHideRemoteDriver && V.bDrawDriverinTP )
	{
		if ( HasAnim(DrivenVehicle.DriveAnim) )
			LoopAnim(DrivenVehicle.DriveAnim);
		else
			LoopAnim('Vehicle_Driving');
		SetAnimFrame(0.5);
//jlb		SmoothViewYaw = Rotation.Yaw;
//jlb		SetTwistLook(0,0);
	}
}

simulated event StopDriving(Vehicle V)
{
	if ( (Role == ROLE_Authority) && (PlayerController(Controller) != None) )
		V.PlayerStartTime = Level.TimeSeconds + 12;
	CullDistance = Default.CullDistance;
	NetUpdateTime = Level.TimeSeconds - 1;

	if (V != None && V.Weapon != None )
	{
//jlb    	V.Weapon.ImmediateStopFire();
    	V.Weapon.StopFire(0);
    	V.Weapon.StopFire(1);
	}

	if ( Physics == PHYS_Karma )
		return;

	DrivenVehicle	= None;
	bIgnoreForces	= false;
	bHardAttach	= false;
//jlb	bWaitForAnim	= false;
	bCanTeleport	= true;
	bCollideWorld	= true;
	PlayWaiting();
	//PrePivot = vect(0,0,0);

	if ( V != None )
		V.DetachDriver( Self );

	bPhysicsAnimUpdate = Default.bPhysicsAnimUpdate;
	SetCollision(True, True);

	if ( (Role == ROLE_Authority) && (Health > 0) )
	{
    	if ( !V.bRemoteControlled || V.bHideRemoteDriver )
        {
			Acceleration = vect(0, 0, 24000);
			SetPhysics(PHYS_Falling);
			SetBase(None);
			bHidden = false;
        }
	}

    bOwnerNoSee = default.bOwnerNoSee;

	if ( Weapon != None )
	{
		PendingWeapon = None;
		Weapon.BringUp();
	}
}

//***************************************
// Interface to Pawn's Controller

// return true if controlled by a Player (AI or human)
simulated function bool IsPlayerPawn()
{
	return ( (Controller != None) && Controller.bIsPlayer );
}

// return true if was controlled by a Player (AI or human)
simulated function bool WasPlayerPawn()
{
	return false;
}

// return true if controlled by a real live human
simulated function bool IsHumanControlled()
{
	if ( Controller != None )
		return Controller.bIsHumanPlayer;
	else
		return false;
}

// return true if controlled by local (not network) player
simulated event bool IsLocallyControlled()
{
	if ( Level.NetMode == NM_Standalone )
		return true;
	if ( Controller == None )
		return false;
	if ( PlayerController(Controller) == None )
		return true;

	return ( Viewport(PlayerController(Controller).Player) != None );
}

// return true if viewing this Pawn in first person pov. useful for determining what and where to spawn effects
simulated function bool IsFirstPerson()
{
    local PlayerController PC;

    PC = PlayerController(Controller);
    return ( PC != None && !PC.bBehindView && Viewport(PC.Player) != None );
}

// determine if this Pawn is facing some Actor, dotProduct is the value to compare
// against the dot product of the two vectors (i.e directly in front of the Pawn
// would be dotProduct=1.0, 30 degrees to the left or right of straight ahead
// (which is 60 degrees from left or right) would be 0.8660)
function bool IsPawnFacingActor(Actor Other, float dotProduct)
{
	local vector vRot, vDir;
	local float dotResult;

	vRot = Vector(Rotation);
	vDir = (Other.Location - Location);
	vDir = Normal(vDir);

	dotResult = vRot dot vDir;

	if (dotResult > dotProduct)
		return true;

	return false;
}

// determine if this Pawn is looking at some Actor, dotProduct is the value to compare
// against the dot product of the two vectors (i.e directly in front of the Pawn
// would be dotProduct=1.0, 30 degrees to the left or right of straight ahead
// (which is 60 degrees from left or right) would be 0.8660)
function bool IsPawnLookingAtActor(Actor Other, float dotProduct)
{
	local vector vRot, vDir;
	local float dotResult;

	vRot = Vector(GetViewRotation());
	vDir = (Other.Location - (Location + EyePosition()));
	vDir = Normal(vDir);

	dotResult = vRot dot vDir;

	if (dotResult > dotProduct)
		return true;

	return false;
}

simulated event rotator GetViewRotation()
{
	if ( Controller == None )
		return Rotation;
	return Controller.GetViewRotation();
}

simulated function SetViewRotation(rotator NewRotation )
{
	if ( Controller != None )
		Controller.SetRotation(NewRotation);
}

function bool InGodMode()
{
	return ( (Controller != None) && Controller.bGodMode );
}

// << GEARBOX/jmw:add - Demigod mode.
function bool InDemigodMode()
{
	return ( (Controller != None) && Controller.bDemigod );
}
// GEARBOX >>

function bool NearMoveTarget()
{
	if ( (Controller == None) || (Controller.MoveTarget == None) )
		return false;

	return ReachedDestination(Controller.MoveTarget);
}

simulated final function bool PressingFire()
{
	return ( (Controller != None) && (Controller.bFire != 0) );
}

simulated final function bool PressingAltFire()
{
	return ( (Controller != None) && (Controller.bAltFire != 0) );
}

simulated final function bool PressingMelee()
{
	return ( (Controller != None) && (Controller.bMeleeFire != 0) );
}

function ActorLite GetMoveTarget()
{
	if ( Controller == None )
		return None;

	return Controller.MoveTarget;
}

function SetMoveTarget(Actor NewTarget )
{
	if ( Controller != None )
		Controller.MoveTarget = NewTarget;
}

function bool LineOfSightTo(ActorLite Other)
{
	return ( (Controller != None) && Controller.LineOfSightTo(Other) );
}

function bool ApproveShot()
{
	// Override me.
	return true;
}

// << GEARBOX/jmw:add - FEATURE: Line-of-sight and peripheral vision checking for arbitrary point in space.
function bool CanSeeLocation(vector Loc)
{
	return ( (Controller != None) && Controller.CanSeeLocation(Loc) );
}
// GEARBOX >>

// Override me.
simulated function rotator AdjustAimNew(Ammunition FiredAmmunition, vector projStart, optional out int bSkipDoTrace )
{
		return Rotation;
}

function Actor ShootSpecial(Actor A)
{
	if ( !Controller.bCanDoSpecial || (Weapon == None) )
		return None;

	Controller.FireWeaponAt(A);
	Controller.bFire = 0;
	return A;
}

/* return a value (typically 0 to 1) adjusting Pawn's perceived strength if under some special influence (like berserk)
*/
function float AdjustedStrength()
{
	return 0;
}

function HandlePickup(Pickup pick)
{
	MakeNoise(0.2);
	if ( Controller != None )
		Controller.HandlePickup(pick);
}

function ReceiveLocalizedMessage( class<LocalMessage> Message, optional int Switch, optional PlayerReplicationInfo RelatedPRI_1, optional PlayerReplicationInfo RelatedPRI_2, optional Object OptionalObject )
{
	if ( PlayerController(Controller) != None )
		PlayerController(Controller).ReceiveLocalizedMessage( Message, Switch, RelatedPRI_1, RelatedPRI_2, OptionalObject );
}

event ClientMessage( coerce string S, optional Name Type )
{
	if ( PlayerController(Controller) != None )
		PlayerController(Controller).ClientMessage( S, Type );
}

function Trigger( actor Other, Pawn EventInstigator )
{
	if ( Controller != None )
		Controller.Trigger(Other, EventInstigator);
}

//***************************************

function bool CanTrigger(Trigger T)
{
	return true;
}

function CreateInventory(string InventoryClassName)
{
}

function Inventory CreateInventoryClass(class<Inventory> InventoryClass)
{
	return None;
}

function GiveWeapon(string aClassName )
{
	local class<Weapon> WeaponClass;
	local Weapon NewWeapon;

	WeaponClass = class<Weapon>(DynamicLoadObject(aClassName, class'Class'));

	if( FindInventoryType(WeaponClass) != None )
		return;
	newWeapon = Spawn(WeaponClass);
	if( newWeapon != None )
		newWeapon.GiveTo(self);
}

function SetDisplayProperties(ERenderStyle NewStyle, Material NewTexture, bool bLighting )
{
	Style = NewStyle;
	Texture = NewTexture;
	bUnlit = bLighting;
	if ( Weapon != None )
		Weapon.SetDisplayProperties(Style, Texture, bUnlit);

	if ( !bUpdatingDisplay && (Inventory != None) )
	{
		bUpdatingDisplay = true;
		Inventory.SetOwnerDisplay();
	}
	bUpdatingDisplay = false;
}

function SetDefaultDisplayProperties()
{
	Style = Default.Style;
	texture = Default.Texture;
	bUnlit = Default.bUnlit;
	if ( Weapon != None )
		Weapon.SetDefaultDisplayProperties();

	if ( !bUpdatingDisplay && (Inventory != None) )
	{
		bUpdatingDisplay = true;
		Inventory.SetOwnerDisplay();
	}
	bUpdatingDisplay = false;
}

function FinishedInterpolation()
{
	DropToGround();
}

function JumpOutOfWater(vector jumpDir)
{
	Falling();
	Velocity = jumpDir * WaterSpeed;
	Acceleration = jumpDir * AccelRate;
	velocity.Z = FMax(380,JumpZ); //set here so physics uses this for remainder of tick
	bUpAndOut = true;
}

/*
Modify velocity called by physics before applying new velocity
for this tick.

Velocity,Acceleration, etc. have been updated by the physics, but location hasn't
*/
simulated event ModifyVelocity(float DeltaTime, vector OldVelocity);

event FellOutOfWorld(eKillZType KillType)
{
	if ( Role < ROLE_Authority )
		return;
	if ( (Controller != None) && Controller.AvoidCertainDeath() )
		return;
	Health = -1;

	if( KillType == KILLZ_Lava)
		Died( None, class'FellLava', Location );
	else if(KillType == KILLZ_Suicide)
		Died( None, class'Fell', Location );
	else
	{
	SetPhysics(PHYS_None);
		Died( None, class'Fell', Location );
	}
}

/* ShouldCrouch()
Controller is requesting that Pawn crouch
*/
function ShouldCrouch(bool Crouch)
{
	bWantsToCrouch = Crouch;
}

function bool IsCrouching()
{
	// if not standing and not prone, then is crouching...
// GBX:PAD: Comment this out for now since we are removing prone temporarily and I just want to make absolutely
// sure it doesn't think it's in such a state
//	return ((bIsCrouched) && (nCrouchState != CrouchToProne) && (nCrouchState != StandToProne));
	return bIsCrouched;
}

function bool IsProne()
{
	// if not standing and crouch to prone or stand to prone, then prone...
// GBX:PAD: Comment this out for now since we are removing prone temporarily and I just want to make absolutely
// sure it doesn't think it's in such a state
//	return ((bIsCrouched) && ((nCrouchState == CrouchToProne) || (nCrouchState == StandToProne)));
	return false;
}

// Stub events called when physics actually allows crouch to begin or end
// use these for changing the animation (if script controlled)
event EndCrouch(float HeightAdjust)
{
	EyeHeight += HeightAdjust;
	OldZ -= HeightAdjust;
	BaseEyeHeight = Default.BaseEyeHeight;
}

event StartCrouch(float HeightAdjust)
{
	EyeHeight -= HeightAdjust;
	OldZ += HeightAdjust;
	BaseEyeHeight = FMin(0.8 * CrouchHeight, CrouchHeight - 10);
}

// GBX:PAD: Added to process ending or starting the prone state
// Stub events called when physics actually allows crouch to begin or end
// use these for changing the animation (if script controlled)
event EndProne(float HeightAdjust)
{
	EyeHeight -= HeightAdjust;
	OldZ += HeightAdjust;
	BaseEyeHeight = FMin(0.8 * CrouchHeight, CrouchHeight - 10);
}

event StartProne(float HeightAdjust)
{
	EyeHeight += HeightAdjust;
	OldZ -= HeightAdjust;
	BaseEyeHeight = FMin(0.8 * ProneHeight, ProneHeight - 10);
}

function RestartPlayer();
function AddVelocity( vector NewVelocity)
{
	if ( bIgnoreForces || (NewVelocity == vect(0,0,0)) )
		return;
	if ( (Physics == PHYS_Walking)
		|| (((Physics == PHYS_Ladder) || (Physics == PHYS_Spider)) && (NewVelocity.Z > Default.JumpZ)) )
		SetPhysics(PHYS_Falling);
	if ( (Velocity.Z > 380) && (NewVelocity.Z > 0) )
		NewVelocity.Z *= 0.5;
	Velocity += NewVelocity;
}

function KilledBy( Pawn EventInstigator )
{
	local Controller Killer;

	Health = 0;
	if ( EventInstigator != None )
		Killer = EventInstigator.Controller;
	Died( Killer, class'Suicided', Location );
}

function TakeFallingDamage()
{
	local float Shake, EffectiveSpeed;

	if (Velocity.Z < -0.5 * MaxFallSpeed)
	{
		if ( Role == ROLE_Authority )
		{
		    MakeNoise(1.0);
		    if (Velocity.Z < -1 * MaxFallSpeed)
		    {
			    EffectiveSpeed = Velocity.Z;
			    if ( TouchingWaterVolume() )
					EffectiveSpeed = FMin(0, EffectiveSpeed + 100);
			    if ( EffectiveSpeed < -1 * MaxFallSpeed )
				    TakeDamage(-100 * (EffectiveSpeed + MaxFallSpeed)/MaxFallSpeed, None, Location, vect(0,0,0), class'Fell');
		    }
		}
		if ( Controller != None )
		{
			Shake = FMin(1, -1 * Velocity.Z/MaxFallSpeed);
			Controller.ShakeView(0.175 + 0.1 * Shake, 850 * Shake, Shake * vect(0,0,1.5), 120000, vect(0,0,10), 1);
        }
	}
	else if (Velocity.Z < -1.4 * JumpZ)
		MakeNoise(0.5);
}

function ClientReStart()
{
	Velocity = vect(0,0,0);
	Acceleration = vect(0,0,0);
	BaseEyeHeight = Default.BaseEyeHeight;
	EyeHeight = BaseEyeHeight;
	PlayWaiting();
}

function ClientSetLocation( vector NewLocation, rotator NewRotation )
{
	if ( Controller != None )
		Controller.ClientSetLocation(NewLocation, NewRotation);
}

function ClientSetRotation( rotator NewRotation )
{
	if ( Controller != None )
		Controller.ClientSetRotation(NewRotation);
}

simulated function FaceRotation( rotator NewRotation, float DeltaTime )
{
	if ( Physics == PHYS_Ladder )
		SetRotation(OnLadder.Walldir);
	else
	{
		if ( (Physics == PHYS_Walking) || (Physics == PHYS_Falling) )
			NewRotation.Pitch = 0;
		SetRotation(NewRotation);
	}
}

function ClientDying(class<DamageType> DamageType, vector HitLocation)
{
	if ( Controller != None )
		Controller.ClientDying(DamageType, HitLocation);
}

function bool InCurrentCombo()
{
	return false;
}
//=============================================================================
// Inventory related functions.

// check before throwing
simulated function bool CanThrowWeapon()
{
    return (Weapon != None && Weapon.CanThrow());
}

// toss out a weapon
function TossWeapon(Vector TossVel)
{
	local Name BoneName;

	BoneName = GetWeaponBoneFor( Weapon );
	Weapon.Velocity = TossVel;
	Weapon.RotationRate.Pitch = 0;
	Weapon.RotationRate.Yaw = 16000 - Rand(32000);
	Weapon.RotationRate.Roll = 0;

	if( BoneName != '' )
	{
		Weapon.DropFrom( GetBoneCoords( BoneName ).origin );
	}
	else
	{
		Weapon.DropFrom( Location );
	}
}

// GEARBOX - toss out any item - 2004-05-10 JWS
function TossItem(Inventory inv, Vector TossVel)
{
	local Vector X,Y,Z;

	inv.Velocity = TossVel;
	GetAxes(Rotation,X,Y,Z);
//	inv.DropFrom(Location + 0.8 * CollisionRadius * X - 0.5 * CollisionRadius * Y);
	inv.DropFrom(Location);
}
// end GEARBOX - 2004-05-10 JWS

exec function SwitchToLastWeapon()
{
	if ( (Weapon != None) && (Weapon.OldWeapon != None) && Weapon.OldWeapon.HasAmmo() )
	{
		PendingWeapon = Weapon.OldWeapon;
		Weapon.PutDown();
	}
}

// The player/bot wants to select next item
exec function NextItem()
{
	if (SelectedItem==None) {
		SelectedItem = Inventory.SelectNext();
		Return;
	}
	if (SelectedItem.Inventory!=None)
		SelectedItem = SelectedItem.Inventory.SelectNext();
	else
		SelectedItem = Inventory.SelectNext();

	if ( SelectedItem == None )
		SelectedItem = Inventory.SelectNext();
}

// FindInventoryType()
// returns the inventory item of the requested class
// if it exists in this Pawn's inventory
function Inventory FindInventoryType( class DesiredClass )
{
	local Inventory Inv;
	local int Count;

	for( Inv=Inventory; Inv!=None; Inv=Inv.Inventory )
	{
		if ( Inv.class == DesiredClass )
			return Inv;
		Count++;
		if ( Count > 1000 )
			return None;
	}
	return None;
}

// Add Item to this Pawn's inventory.
// Returns true if successfully added, false if not.
function bool AddInventory( inventory NewItem )
{
	// Skip if already in the inventory.
	local inventory Inv;
	local actor Last;

	Last = self;

	// The item should not have been destroyed if we get here.
	if (NewItem ==None )
		log("tried to add none inventory to "$self);

	for( Inv=Inventory; Inv!=None; Inv=Inv.Inventory )
	{
		if( Inv == NewItem )
			return false;
		Last = Inv;
	}

	// Add to back of inventory chain (so minimizes net replication effect).
	NewItem.SetOwner(Self);
	NewItem.NetUpdateTime = Level.TimeSeconds - 1;
	NewItem.Inventory = None;
	Last.Inventory = NewItem;

	if ( Controller != None )
		Controller.NotifyAddInventory(NewItem);
	return true;
}

// Remove Item from this Pawn's inventory, if it exists.
function DeleteInventory( inventory Item )
{
	// If this item is in our inventory chain, unlink it.
	local actor Link;
	local int Count;

	if ( Item == Weapon )
	{
		Weapon.DetachFromPawn(self);
		Weapon = None;
	}
	if ( Item == SelectedItem )
		SelectedItem = None;
	for( Link = Self; Link!=None; Link=Link.Inventory )
	{
		if( Link.Inventory == Item )
		{
			Link.Inventory = Item.Inventory;
			Item.Inventory = None;
			Link.NetUpdateTime = Level.TimeSeconds - 1;
			Item.NetUpdateTime = Level.TimeSeconds - 1;
			break;
		}
		if ( Level.NetMode == NM_Client )
		{
			Count++;
			if ( Count > 1000 )
				break;
		}
	}
	Item.SetOwner(None);
}
// Just changed to pendingWeapon
function ChangedWeapon()
{
    local Weapon OldWeapon;

    ServerChangedWeapon(Weapon, PendingWeapon);

    if (Role < ROLE_Authority)
	{
        OldWeapon = Weapon;
        Weapon = PendingWeapon;
		PendingWeapon = None;

        if (Weapon != None)
        {
		    Weapon.BringUp(OldWeapon);
		}
    }

	bWeaponChange = true;
}

/*
// Just changed to pendingWeapon
function ChangedWeapon()
{
	local Weapon OldWeapon;

	OldWeapon = Weapon;

	if (Weapon == PendingWeapon)
	{
		if ( Weapon == None )
		{
			Controller.SwitchToBestWeapon();
			return;
		}
		else if ( Weapon.IsInState('DownWeapon') )
			Weapon.GotoState('Idle');
		PendingWeapon = None;
		ServerChangedWeapon(OldWeapon, Weapon);
		return;
	}
	if ( PendingWeapon == None )
		PendingWeapon = Weapon;

	Weapon = PendingWeapon;
	if ( (Weapon != None) && (Level.NetMode == NM_Client) )
	{
		Weapon.BringUp(OldWeapon);
	}
	PendingWeapon = None;
	Weapon.Instigator = self;
	ServerChangedWeapon(OldWeapon, Weapon);
	if ( Controller != None )
		Controller.ChangedWeapon();
}
*/


function name GetWeaponBoneFor(Inventory I)
{
	return 'righthand';
}

function name GetHolsterBoneFor(Inventory I)
{
	return 'righthand';
}

function ServerChangedWeapon(Weapon OldWeapon, Weapon NewWeapon)
{
    Weapon = NewWeapon;

    //if (PendingWeapon != None && Level.NetMode == NM_DedicatedServer)
    //    log("Warning: Server somehow got a pending weapon"@PendingWeapon);

    PendingWeapon = None;

	if ( OldWeapon != None )
	{
		OldWeapon.SetDefaultDisplayProperties();
		OldWeapon.DetachFromPawn(self);
        OldWeapon.GotoState('Hidden');
	}

	if ( Weapon != None )
	{
		Weapon.AttachToPawn(self);
		Weapon.BringUp(OldWeapon);
        PlayWeaponSwitch(NewWeapon);
	}
    Inventory.OwnerEvent('ChangedWeapon'); // tell inventory that weapon changed (in case any effect was being applied)
}

//==============
// Encroachment
event bool EncroachingOn( actor Other )
{
	if ( Other.bWorldGeometry )
		return true;

	if ( ((Controller == None) || !Controller.bIsPlayer || bWarping) && (Pawn(Other) != None) )
		return true;

	return false;
}

event EncroachedBy( actor Other )
{
	// Allow encroachment by Vehicles so they can push the Pawn out of the way
	if ( Pawn(Other) != None && Vehicle(Other) == None )
		gibbedBy(Other);
}

function gibbedBy(actor Other)
{
	if ( Role < ROLE_Authority )
		return;
	if ( Pawn(Other) != None )
		Died(Pawn(Other).Controller, class'DamTypeTelefragged', Location);
	else
		Died(None, class'Gibbed', Location);
}

//Base change - if new base is Pawn or decoration, damage based on relative mass and old velocity
// Also, non-players will jump off pawns immediately
function JumpOffPawn()
{
	Velocity += (100 + CollisionRadius) * VRand();
	Velocity.Z = 200 + CollisionHeight;
	SetPhysics(PHYS_Falling);
	bNoJumpAdjust = true;
	Controller.SetFall();
}

singular event BaseChange()
{
	local float decorMass;

	if ( bInterpolating )
		return;
	if ( (base == None) && (Physics == PHYS_None) )
		SetPhysics(PHYS_Falling);
	// Pawns can only set base to non-pawns, or pawns which specifically allow it.
	// Otherwise we do some damage and jump off.
	else if ( Pawn(Base) != None )
	{
		if ( !Pawn(Base).bCanBeBaseForPawns )
		{
			Base.TakeDamage( (1-Velocity.Z/400)* Mass/Base.Mass, Self,Location,0.5 * Velocity , class'Crushed');
			JumpOffPawn();
		}
	}
	else if ( (Decoration(Base) != None) && (Velocity.Z < -400) )
	{
		decorMass = FMax(Decoration(Base).Mass, 1);
		Base.TakeDamage((-2* Mass/decorMass * Velocity.Z/400), Self, Location, 0.5 * Velocity, class'Crushed');
	}
}

event UpdateEyeHeight( float DeltaTime )
{
	local float smooth, MaxEyeHeight;
	local float OldEyeHeight;
	local Actor HitActor;
	local vector HitLocation,HitNormal;

	if (Controller == None )
	{
		EyeHeight = 0;
		return;
	}
	if ( bTearOff )
	{
		EyeHeight = 0;
		bUpdateEyeHeight = false;
		return;
	}
	HitActor = trace(HitLocation,HitNormal,Location + (CollisionHeight + MAXSTEPHEIGHT + 14) * vect(0,0,1),
					Location + CollisionHeight * vect(0,0,1),true);
	if ( HitActor == None )
		MaxEyeHeight = CollisionHeight + MAXSTEPHEIGHT;
	else
		MaxEyeHeight = HitLocation.Z - Location.Z - 14;

	// smooth up/down stairs
	smooth = FMin(1.0, 10.0 * DeltaTime/Level.TimeDilation);
	If( Controller.WantsSmoothedView() )
	{
		OldEyeHeight = EyeHeight;
		EyeHeight = FClamp((EyeHeight - Location.Z + OldZ) * (1 - smooth) + BaseEyeHeight * smooth,
							-0.5 * CollisionHeight, MaxEyeheight);
	}
	else
	{
		bJustLanded = false;
		EyeHeight = FMin(EyeHeight * ( 1 - smooth) + BaseEyeHeight * smooth, MaxEyeHeight);
	}
	Controller.AdjustView(DeltaTime);
}

/* EyePosition()
Called by PlayerController to determine camera position in first person view.  Returns
the offset from the Pawn's location at which to place the camera
*/
simulated function vector EyePosition()
{
	return EyeHeight * vect(0,0,1) + WalkBob;
}

//=============================================================================

simulated event Destroyed()
{
	local Inventory Inv;
	local int i;

	if ( Controller != None )
		Controller.PawnDied(self);
	if ( Role < ROLE_Authority )
		return;

	//SDJ 2/27/2004: The client does not have the authority to destroy a player's inventory even after the player has died and had its role changed to ROLE_Authority.  Attempting to do so results in an infinite loop.
	if ( Level.NetMode != NM_Client )
	{
		while( Inventory != None )
		{
			Inv = Inventory;
			Inv.Destroy();
		}

		// see if this Pawn that we are about to destroy is in the Level.MoveTowardArray...
		for (i=Level.MoveTowardArray.Length-1; i >= 0; i--)
		{
			if (Level.MoveTowardArray[i].MyViewFocus == self)
				Level.MoveTowardArray[i].MyViewFocus = None;  // don't reference destroyed actors

			if (Level.MoveTowardArray[i].MyPawn == self)
				Level.MoveTowardArray.Remove( i, 1 );  // remove actors we are about to destroy
		}

		// see if this Pawn that we are about to destroy is in the Level.VehicleMoveTowardArray...
		for (i=Level.VehicleMoveTowardArray.Length-1; i >= 0; i--)
		{
			if (Level.VehicleMoveTowardArray[i].MyVehicle == self)
				Level.VehicleMoveTowardArray.Remove( i, 1 );  // remove actors we are about to destroy
		}
	}

	Instigator = None;  // prevent references to/in destroyed objects
	Weapon = None;
	Inventory = None;

	Super.Destroyed();
}

//=============================================================================
//
// Called immediately before gameplay begins.
//
event PreBeginPlay()
{
	Super.PreBeginPlay();
	Instigator = self;
	DesiredRotation = Rotation;
	if ( bDeleteMe )
		return;

	if ( BaseEyeHeight == 0 )
		BaseEyeHeight = 0.8 * CollisionHeight;
	EyeHeight = BaseEyeHeight;

	if ( menuname == "" )
		menuname = GetItemName(string(class));
}

event PostBeginPlay()
{
	local AIScript A;

	Super.PostBeginPlay();
	SplashTime = 0;
	SpawnTime = Level.TimeSeconds;
	EyeHeight = BaseEyeHeight;
	OldRotYaw = Rotation.Yaw;

	// automatically add controller to pawns which were placed in level
	// NOTE: pawns spawned during gameplay are not automatically possessed by a controller
	if ( Level.bStartup && (Health > 0) && !bDontPossess )
	{
		// check if I have an AI Script
		if ( AIScriptTag != '' )
		{
			ForEach AllActors(class'AIScript',A,AIScriptTag)
				break;
			// let the AIScript spawn and init my controller
			if ( A != None )
			{
				A.SpawnControllerFor(self);
				if ( Controller != None )
					return;
			}
		}
		if ( (ControllerClass != None) && (Controller == None) )
			Controller = spawn(ControllerClass);
		if ( Controller != None )
		{
			Controller.Possess(self);
			AIController(Controller).Skill += SkillModifier;
		}
	}
}

// called after PostBeginPlay on net client
simulated event PostNetBeginPlay()
{
	if ( Level.bDropDetail || (Level.DetailMode == DM_Low) )
		MaxLights = Min(4,MaxLights);
	if ( Role == ROLE_Authority )
		return;
	if ( Controller != None )
	{
		Controller.Pawn = self;
		if ( (PlayerController(Controller) != None)
			&& (PlayerController(Controller).ViewTarget == Controller) )
			PlayerController(Controller).SetViewTarget(self);
	}

	if ( Role == ROLE_AutonomousProxy )
		bUpdateEyeHeight = true;

	if ( (PlayerReplicationInfo != None)
		&& (PlayerReplicationInfo.Owner == None) )
		PlayerReplicationInfo.SetOwner(Controller);
	PlayWaiting();
}

simulated function SetMesh()
{
    if (Mesh != None)
        return;

	LinkMesh( default.mesh );
}

function SetMovementPhysics();

function TakeDamage( int Damage, Pawn instigatedBy, Vector hitlocation,
						Vector momentum, class<DamageType> damageType, optional name HitBoxName)
{
	local int actualDamage;
	local bool bAlreadyDead;
	local Controller Killer;

	if ( m_fDontTakeDamage )
	{
		return;
	}
	
	if ( damagetype == None )
	{
		if ( InstigatedBy != None )
		warn("No damagetype for damage by "$instigatedby$" with weapon "$InstigatedBy.Weapon);
		DamageType = class'DamageType';
	}

	if ( Role < ROLE_Authority )
	{
		return;
	}

	bAlreadyDead = (Health <= 0);

	if (Physics == PHYS_None)
		SetMovementPhysics();
	if (Physics == PHYS_Walking)
		momentum.Z = FMax(momentum.Z, 0.4 * VSize(momentum));
	if ( (instigatedBy == self)
		|| ((Controller != None) && (InstigatedBy != None) && (InstigatedBy.Controller != None) && InstigatedBy.Controller.SameTeamAs(Controller)) )
		momentum *= 0.6;
	momentum = momentum/Mass;

	actualDamage = Level.Game.ReduceDamage(Damage, self, instigatedBy, HitLocation, Momentum, DamageType);

	Health -= actualDamage;
	if ( HitLocation == vect(0,0,0) )
		HitLocation = Location;
	if ( bAlreadyDead )
	{
		Warn(self$" took regular damage "$damagetype$" from "$instigatedby$" while already dead at "$Level.TimeSeconds);
		ChunkUp(Rotation, DamageType);
		return;
	}

	PlayHit(actualDamage,InstigatedBy, hitLocation, damageType, Momentum);
	if ( Health <= 0 )
	{
		// Pawn died
		if ( instigatedBy != None )
			Killer = instigatedBy.GetKillerController();
		if ( bPhysicsAnimUpdate )
			TearOffMomentum = momentum;
		Died(Killer, damageType, HitLocation);
	}
	else
	{
		if ( (InstigatedBy != None) && (InstigatedBy != self) && (Controller != None)
			&& (InstigatedBy.Controller != None) && InstigatedBy.Controller.SameTeamAs(Controller) )
			Momentum *= 0.5;

		// GBX:PAD: Remove adding velocity from bullet hits for now because it doesn't look quite right
//		if (damageType.Name == 'gbxDamageExploded')
		if (damageType.Default.m_bExplosiveDamage && ( !bIsManningTurret || Health <= 0 ) )
			AddVelocity( momentum );
//		else
//		{
//			momentum.Z = 0;
//		}
		if ( Controller != None )
			Controller.NotifyTakeHit(instigatedBy, HitLocation, actualDamage, DamageType, Momentum);
	}
	MakeNoise(1.0);
}

function TeamInfo GetTeam()
{
	if ( PlayerReplicationInfo != None )
		return PlayerReplicationInfo.Team;
	return None;
}

function Controller GetKillerController()
{
	return Controller;
}

function Died(Controller Killer, class<DamageType> damageType, vector HitLocation)
{
    local Inventory Inv; // gam
	local Inventory InvNext; // GEARBOX - added so that multiplayer can drop game-important items on death 2004-05-10 JWS
    local Vector TossVel, VelVectRight, VelVectUp;

	Log(self $ " Pawn::Died() begin", 'JWS');

	if ( bDeleteMe || Level.bLevelChange )
		return; // already destroyed, or level is being cleaned up

	// mutator hook to prevent deaths
	// WARNING - don't prevent bot suicides - they suicide when really needed
	if ( Level.Game.PreventDeath(self, Killer, damageType, HitLocation) )
	{
		Health = max(Health, 1); //mutator should set this higher
		return;
	}
	Health = Min(0, Health);

    if (Weapon != None)
    {
		if ( Controller != None )
			Controller.LastPawnWeapon = Weapon.Class;
        Weapon.HolderDied();
		if (!bDontDropWeapon)
		{
			GetAxes(GetViewRotation(), TossVel, VelVectRight, VelVectUp);
//			VelVectRight = VelVectRight * (200.0 - (400.0 * FRand()));
			VelVectRight.Z = 200.0 + (100.0 * FRand());
//			TossVel = (TossVel * ((Velocity Dot TossVel) + (100 + (FRand() * 50)))) + VelVectRight;
			TossVel = TossVel * (Velocity Dot TossVel) + vect( 0, 0, 200 );
			TossWeapon(TossVel);
		}
    }

	// begin GEARBOX - added so that multiplayer can drop game-important items on death 2004-05-10 JWS
	Log(self $ " Pawn::Died() scanning Inventory", 'JWS');

	for ( Inv=Inventory; Inv!=None; Inv=InvNext )
	{
		InvNext = Inv.Inventory;

		Log(self $ " Pawn::Died() found Inv=" $ Inv $ " Inv.bDropOnPawnDeath=" $ Inv.bDropOnPawnDeath, 'JWS');

		if (Inv.bDropOnPawnDeath)
		{
			TossVel = Vect(0,0,0);
//	        TossVel = (Vector(GetViewRotation());)
//		    TossVel = TossVel * ((Velocity Dot TossVel) + 500) + Vect(0,0,200);

			Log(self $ " Pawn::Died() tossing " $ Inv $ " Inv.Inventory with TossVel= " $ TossVel, 'JWS');

			TossItem(Inv, TossVel);
		}
	}

	Inv = None;
	// end GEARBOX - 2004-05-10 JWS

	if ( Controller != None )
	{
		Controller.WasKilledBy(Killer);
		Level.Game.Killed(Killer, Controller, self, damageType);
	}
	else
		Level.Game.Killed(Killer, Controller(Owner), self, damageType);

	if ( Killer != None )
		TriggerEvent(Event, self, Killer.Pawn);
	else
		TriggerEvent(Event, self, None);

	Velocity.Z *= 1.3;
	if ( IsHumanControlled() )
		PlayerController(Controller).ForceDeathUpdate();

// never GIB!!! - jlb 3/18/2003
//    if ( (DamageType != None) && DamageType.default.bAlwaysGibs )
//		ChunkUp( Rotation, DamageType );
//	else
//	{
		PlayDying(DamageType, HitLocation);
		if ( Level.Game.bGameEnded )
			return;
		if ( !bPhysicsAnimUpdate && !IsLocallyControlled() )
			ClientDying(DamageType, HitLocation);
//	}

    // gam --- Hasten GC
	//SDJ 8/19/2004: The client does not have the authority to destroy a player's inventory even after the player has died and had its role changed to ROLE_Authority.  Attempting to do so results in an infinite loop.
	if ( Level.NetMode != NM_Client )
	{
		while( Inventory != None )
		{
			Inv = Inventory;
			Inv.Destroy();
		}
	}

    // --- gam

	Log(self $ " Pawn::Died() end", 'JWS');
}

function bool Gibbed(class<DamageType> damageType)
{
	if ( damageType.default.GibModifier == 0 )
		return false;
	if ( damageType.default.GibModifier >= 100 )
		return true;
	if ( (Health < -80) || ((Health < -40) && (FRand() < 0.6)) )
		return true;
	return false;
}

event Falling()
{
	//SetPhysics(PHYS_Falling); //Note - physics changes type to PHYS_Falling by default
	if ( Controller != None )
		Controller.SetFall();
}

event HitWall(vector HitLocation, vector HitNormal, actor Wall);

event Landed(vector HitLocation, vector HitNormal)
{
	LandBob = FMin(50, 0.055 * Velocity.Z);
	//TakeFallingDamage();  //NAC: removed these two lines to get rid of falling damage entirely.
	//if ( Health > 0 )

	PlayLanded(Velocity.Z);
	bJustLanded = true;
}

event HeadVolumeChange(PhysicsVolume newHeadVolume)
{
	if ( (Level.NetMode == NM_Client) || (Controller == None) )
		return;
	if ( HeadVolume.bWaterVolume )
	{
		if (!newHeadVolume.bWaterVolume)
		{
			BreathTime = -1.0;
		}
	}
	else if ( newHeadVolume.bWaterVolume )
		BreathTime = UnderWaterTime;
}

function bool TouchingWaterVolume()
{
	local PhysicsVolume V;

	ForEach TouchingActors(class'PhysicsVolume',V)
		if ( V.bWaterVolume )
			return true;

	return false;
}

//Pain timer just expired.
//Check what zone I'm in (and which parts are)
//based on that cause damage, and reset BreathTime

function bool IsInPain()
{
	local PhysicsVolume V;

	ForEach TouchingActors(class'PhysicsVolume',V)
		if ( V.bPainCausing && (V.DamageType != ReducedDamageType)
			&& (V.DamagePerSec > 0) )
			return true;
	return false;
}

event BreathTimer()
{
	if ( (Health < 0) || (Level.NetMode == NM_Client) )
		return;
	TakeDrowningDamage();
	if ( Health > 0 )
		BreathTime = 2.0;
}

function TakeDrowningDamage();

function bool CheckWaterJump(out vector WallNormal)
{
	local actor HitActor;
	local vector HitLocation, HitNormal, checkpoint, start, checkNorm, Extent;

	checkpoint = vector(Rotation);
	checkpoint.Z = 0.0;
	checkNorm = Normal(checkpoint);
	checkPoint = Location + CollisionRadius * checkNorm;
	Extent = CollisionRadius * vect(1,1,0);
	Extent.Z = CollisionHeight;
	HitActor = Trace(HitLocation, HitNormal, checkpoint, Location, true, Extent);
	if ( (HitActor != None) && (Pawn(HitActor) == None) )
	{
		WallNormal = -1 * HitNormal;
		start = Location;
		start.Z += 1.1 * MAXSTEPHEIGHT;
		checkPoint = start + 2 * CollisionRadius * checkNorm;
		HitActor = Trace(HitLocation, HitNormal, checkpoint, start, true);
		if (HitActor == None)
			return true;
	}

	return false;
}

function DoDoubleJump( bool bUpdating );
function bool CanDoubleJump();

function UpdateRocketAcceleration(float DeltaTime, float YawChange, float PitchChange);

function bool Dodge(eDoubleClickDir DoubleClickMove)
{
	return false;
}

//Player Jumped
function bool DoJump( bool bUpdating )
{
	if ( ((Physics == PHYS_Walking) || (Physics == PHYS_Ladder) || (Physics == PHYS_Spider)) )
	{
		if ( Role == ROLE_Authority )
		{
			if ( (Level.Game != None) && (Level.Game.GameDifficulty > 2) )
				MakeNoise(0.1 * Level.Game.GameDifficulty);
			if ( bCountJumps && (Inventory != None) )
				Inventory.OwnerEvent('Jumped');
		}

		if ( Physics == PHYS_Spider )
			Velocity = JumpZ * Floor;
		else if ( Physics == PHYS_Ladder )
			Velocity.Z = 0;
		// GBX:PAD: I've added the multiplication of m_flJumpEndurance here to limit now high one can jump if they've
		// already jumped before.
		else if ( bIsWalking )
		{
			Velocity.Z = Default.MinJumpZ + ((Default.JumpZ - Default.MinJumpZ) * m_flJumpEndurance);
			log(self$".DoJump1( "$bUpdating$" ) - "$Default.JumpZ$" - "$m_flJumpEndurance$" - "$Base.Velocity.Z);
		}
		else
		{
			Velocity.Z = MinJumpZ + ((JumpZ - MinJumpZ) * m_flJumpEndurance);
			log(self$".DoJump2( "$bUpdating$" ) - "$JumpZ$" - "$m_flJumpEndurance$" - "$Base.Velocity.Z);
		}
				
		if ( (Base != None) && !Base.bWorldGeometry )
			Velocity.Z += Base.Velocity.Z;
		SetPhysics(PHYS_Falling);

		// GEARBOX: SJP - uncrouch if crouched after a jump
		if( bIsCrouched )
			ShouldCrouch( false );

        return true;
	}
    return false;
}

/* PlayMoverHitSound()
Mover Hit me, play appropriate sound if any
*/
function PlayMoverHitSound();

function PlayDyingSound();

function bool IsHeadshot(vector HitLocation)
{
	return (HitLocation.Z > Location.Z + (0.7 * CollisionHeight));
}

simulated function vector GetLocationAsIfStanding()
{
	// Returns the location of the bottom of the pawn's feet.

	return Location - ( vect(0,0,1) * ( CollisionHeight - default.CollisionHeight ));
}

function PlayHit(float Damage, Pawn InstigatedBy, vector HitLocation, class<DamageType> damageType, vector Momentum)
{
	local vector BloodOffset, Mo, HitNormal;
	local class<Effects> DesiredEffect;
	local class<Emitter> DesiredEmitter;
	local class<Actor> BloodDecalClass;
	local vector WallHit, WallNormal;
	local Actor WallActor;
	local vector v1, v2;
	local vector bloodNormal;
	local Emitter BloodEmitter;
	local BloodEffectEmitter aBloodEffectEmitter;

	//log( self$ " Pawn::PlayHit() InstigatedBy="$InstigatedBy );

	if ( (Damage <= 0) && ((Controller == None) || !Controller.bGodMode) )
		return;

	v1 = HitLocation;
	v2 = Location;
	v2.Z = HitLocation.Z;

	HitNormal = Normal(v1 - v2);

	//DHW+ -- This calculates the vector used by the trace to see what wall the blood splatter should be on.
	//     -- Basically it is just the vector formed by the gun that fired the shot and the point where the shot hit
	bloodNormal = Normal(InstigatedBy.Weapon.GetMuzzleLocationWorld() - HitLocation);
	//DHW-

	if (Damage > DamageType.Default.DamageThreshold) //spawn some/lots of blood
	{
		// Create the server version here, the clients will create their blood decal as part of the emitter effect
		BloodDecalClass = DamageType.static.GetPawnBloodDecal(HitLocation, Damage, Momentum, self, (Level.bDropDetail || Level.DetailMode == DM_Low));

		if (BloodDecalClass != None)
		{
			//DHW+ -- changed the end point of the trace funtion so that it doesn't point straight down
			//     -- Note: the magic number 400 was changed as the distance for blood splatters just didn't feel right.
		    WallActor = Trace(WallHit, WallNormal, Location + bloodNormal*-400, Location, false);
			//DHW -
			if (WallActor != None)
			{
			    //log( self$ " Pawn::PlayHit() spawning BloodDecalClass="$BloodDecalClass$" at "$WallHit );
				spawn(BloodDecalClass,self,,WallHit + 5 * (WallNormal + VRand()), rotator(-WallNormal));
			}
		}

		// Play any set effect
		if ( EffectIsRelevant(Location,true) )
		{
			DesiredEffect = DamageType.static.GetPawnDamageEffect(HitLocation, Damage, Momentum, self, (Level.bDropDetail || Level.DetailMode == DM_Low));

			if ( DesiredEffect != None )
			{
				BloodOffset = 0.2 * CollisionRadius * HitNormal;
				BloodOffset.Z = BloodOffset.Z * 0.5;

				Mo = Momentum;
				if ( Mo.Z > 0 )
					Mo.Z *= 0.5;
				spawn(DesiredEffect,self,,HitLocation + BloodOffset, rotator(Mo));
			}

			// Spawn any preset emitter

			if (IsHeadshot(HitLocation))
			{
				DesiredEmitter = DamageType.Static.GetPawnDamageHeadshotEmitter(HitLocation, Damage, Momentum, self, (Level.bDropDetail || Level.DetailMode == DM_Low));
				if (DesiredEmitter != None)
				{
					//log( self$ " Pawn::PlayHit() spawning headshot emitter="$DesiredEmitter$" at "$HitLocation$ "HitDir="$bloodNormal );
					BloodEmitter = spawn(DesiredEmitter,,,HitLocation, Rotator(bloodNormal));
				}
			}
			else
			{
				DesiredEmitter = DamageType.Static.GetPawnDamageEmitter(HitLocation, Damage, Momentum, self, (Level.bDropDetail || Level.DetailMode == DM_Low));
				if (DesiredEmitter != None)
				{
					//log( self$ " Pawn::PlayHit() spawning non-headshot emitter="$DesiredEmitter$" at "$HitLocation$ "HitDir="$bloodNormal );
					BloodEmitter = spawn(DesiredEmitter,,,HitLocation, Rotator(bloodNormal));
				}
			}

			if ( (BloodEmitter != None) && (BloodEffectEmitter(BloodEmitter) != None) )
			{
				aBloodEffectEmitter = BloodEffectEmitter( BloodEmitter );
				
				//log( self$ " Pawn::PlayHit() setting HitDir to "$bloodNormal );
				aBloodEffectEmitter.HitX = bloodNormal.X;
				aBloodEffectEmitter.HitY = bloodNormal.Y;
				aBloodEffectEmitter.HitZ = bloodNormal.Z;
			}
		}
	}
	else
	{
		// spawn a tiny amount of blood...
		DesiredEmitter = DamageType.Static.GetPawnDamageLittleEmitter(HitLocation, Damage, Momentum, self, (Level.bDropDetail || Level.DetailMode == DM_Low));
		if (DesiredEmitter != None)
			spawn(DesiredEmitter,,,HitLocation+HitNormal, Rotator(HitNormal));
	}

	if ( Health <= 0 )
	{
		if ( PhysicsVolume.bDestructive && (PhysicsVolume.ExitActor != None) )
			Spawn(PhysicsVolume.ExitActor);
		return;
	}

	if ( Level.TimeSeconds - LastPainTime > 0.1 )
	{
		PlayTakeHit(HitLocation,Damage,damageType);
		LastPainTime = Level.TimeSeconds;
	}
}

/*
Pawn was killed - detach any controller, and die
*/

// blow up into little pieces (implemented in subclass)

simulated function ChunkUp( Rotator HitRotation, class<DamageType> D )
{
	if ( (Level.NetMode != NM_Client) && (Controller != None) )
	{
		if ( Controller.bIsPlayer )
			Controller.PawnDied(self);
		else
			Controller.Destroy();
	}
	destroy();
}

State Dying
{
ignores Trigger, Bump, HitWall, HeadVolumeChange, PhysicsVolumeChange, Falling, BreathTimer;

	event ChangeAnimation() {}
	event StopPlayFiring() {}
	function PlayFiring(float Rate, int FiringMode) {}
	function PlayWeaponSwitch(Weapon NewWeapon) {}
	function PlayTakeHit(vector HitLoc, int Damage, class<DamageType> damageType) {}
	simulated function PlayNextAnimation() {}

	function Died(Controller Killer, class<DamageType> damageType, vector HitLocation)
	{
	}

	event FellOutOfWorld(eKillZType KillType)
	{
		if(KillType == KILLZ_Lava || KillType == KILLZ_Suicide )
			return;

		Destroy();
	}

	function Timer()
	{
		if ( !PlayerCanSeeMe() || Level.Game.bDestroyVisibleDeadBodies )
			Destroy();
		else
			SetTimer(2.0, false);
	}

	function Landed(vector HitLocation, vector HitNormal)
	{
		local rotator finalRot;

		LandBob = FMin(50, 0.055 * Velocity.Z);
		if( Velocity.Z < -500 )
			TakeDamage( (1-Velocity.Z/30),Instigator,Location,vect(0,0,0) , class'Crushed');

		finalRot = Rotation;
		finalRot.Roll = 0;
		finalRot.Pitch = 0;
		setRotation(finalRot);
		SetPhysics(PHYS_None);
		SetCollision(true, false, false);

		if ( !IsAnimating(0) )
			LieStill();
	}

	/* ReduceCylinder() made obsolete by ragdoll deaths */
	function ReduceCylinder()
	{
		SetCollision(false, false, false);
	}

	function LandThump()
	{
		// animation notify - play sound if actually landed, and animation also shows it
		if ( Physics == PHYS_None)
			bThumped = true;
	}

	event AnimEnd(int Channel)
	{
		if ( Channel != 0 )
			return;
		if ( Physics == PHYS_None )
			LieStill();
		else if ( PhysicsVolume.bWaterVolume )
		{
			//-BB Fix so that characters won't fall through world while in water
			bThumped = true;
			SetCollision(true, false, false);	
			//LieStill();
		}
	}

	function LieStill()
	{
		if ( !bThumped )
			LandThump();
		SetCollision(false, false, false);
	}

	singular function BaseChange()
	{
		if( base == None )
			SetPhysics(PHYS_Falling);
		else if ( Pawn(base) != None ) // don't let corpse ride around on someone's head
        	ChunkUp( Rotation, class'Fell' );
	}

	function TakeDamage( int Damage, Pawn instigatedBy, Vector hitlocation,
							Vector momentum, class<DamageType> damageType, optional name HitBoxName)
	{
		SetPhysics(PHYS_Falling);
		if ( (Physics == PHYS_None) && (Momentum.Z < 0) )
			Momentum.Z *= -1;
		Velocity += 3 * momentum/(Mass + 200);
		if ( bInvulnerableBody )
			return;
		Damage *= DamageType.Default.GibModifier;
		Health -=Damage;
		if ( ((Damage > 30) || !IsAnimating()) && (Health < -80) )
        	ChunkUp( Rotation, DamageType );
	}

	function BeginState()
	{
		if ( (LastStartSpot != None) && (LastStartTime - Level.TimeSeconds < 6) )
			LastStartSpot.LastSpawnCampTime = Level.TimeSeconds;
		if ( bTearOff && (Level.NetMode == NM_DedicatedServer) )
			LifeSpan = 1.0;
		else
			SetTimer(Level.Game.DestroyDeadBodyTimer, false);
		SetPhysics(PHYS_Falling);
		bInvulnerableBody = true;
		if ( Controller != None )
		{
			if ( Controller.bIsPlayer )
				Controller.PawnDied(self);
			else
				Controller.Destroy();
		}
	}

Begin:
	Sleep(0.15);
	bInvulnerableBody = false;
	PlayDyingSound();
}

//=============================================================================
// Animation interface for controllers

simulated event SetAnimAction(name NewAction);

/* PlayXXX() function called by controller to play transient animation actions
*/
simulated event PlayDying(class<DamageType> DamageType, vector HitLoc)
{
	AmbientSound = None;
	GotoState('Dying');
	if ( bPhysicsAnimUpdate )
	{
		bReplicateMovement = false;
		bTearOff = true;
		Velocity += TearOffMomentum;
		SetPhysics(PHYS_Falling);
	}
	bPlayedDeath = true;
}

simulated function PlayFiring(float Rate, int FiringMode);
simulated function PlayMelee(int MeleeMode);
simulated function PlayReload(int ReloadMode);
simulated function PlayThrow(int ReloadMode);
simulated function PlayDeploy(int ReloadMode);
simulated function PlayHolster(int ReloadMode);

function PlayWeaponSwitch(Weapon NewWeapon);
simulated event StopPlayFiring()
{
	bSteadyFiring = false;
}

function PlayTakeHit(vector HitLoc, int Damage, class<DamageType> damageType)
{
	local Sound DesiredSound;

	if (Damage==0)
		return;
	//
	// Play a hit sound according to the DamageType

 	DesiredSound = DamageType.Static.GetPawnDamageSound();
	if (DesiredSound != None)
		PlayOwnedSound(DesiredSound,SLOT_Pain,0.5,false,500.0);
}

//=============================================================================
// Pawn internal animation functions

simulated event ChangeAnimation()
{
	if ( (Controller != None) && Controller.bControlAnimations )
		return;
	// player animation - set up new idle and moving animations
	PlayWaiting();
	PlayMoving();
}

simulated event AnimEnd(int Channel)
{
	if ( Channel == 0 )
		PlayWaiting();
}

// Animation group checks (usually implemented in subclass)

function bool CannotJumpNow()
{
	return false;
}

simulated event PlayJump();
simulated event PlayFalling();
simulated function PlayMoving();
simulated function PlayWaiting( optional bool bSkipTween );

function PlayLanded(float impactVel)
{
	if ( !bPhysicsAnimUpdate )
		PlayLandingAnimation(impactvel);
}

simulated event PlayLandingAnimation(float ImpactVel);

function PlayVictoryAnimation();

function Vehicle GetVehicleBase()
{
	return Vehicle(Base);
}

function HoldCarriedObject(CarriedObject O, name AttachmentBone);

// amb ---
simulated function float RateWeapon(Weapon w)
{
    if (Controller != None)
        return Controller.RateWeapon(w);
    else
        return 0.0;
}

simulated function bool IsControlled()
{
    return Controller != None;
}
// --- amb

event RotateTurret( Rotator Rot )
{
	// Engine calls this event when a turret weapon manned by this Pawn
	// needs to be rotated.
	//
	// Subclasses should override this if using turret weapons.
}

event Vector GetTurretViewOrigin()
{
	// Engine calls this event to determine a turret weapon's
	// "barrel origin" point is so that the rotator that it passes to RotateTurret()
	// will be offset from the proper spot.
	//
	// For most turrets, the Pawn's Location will suffice.
	//
	return Location;
}

// GBX:PAD: Put in here to provide a generic call to set the movement array elements.
simulated function SetMovementAnims( name nmForward, name nmBack, name nmLeft, name nmRight, name nmTurnLeft, name nmTurnRight )
{
	TurnLeftAnim = nmTurnLeft;
	TurnRightAnim = nmTurnRight;

	MovementAnims[0] = nmForward;
	MovementAnims[2] = nmLeft;
	MovementAnims[1] = nmBack;
	MovementAnims[3] = nmRight;
}

// GBX:PAD: Put this here to provide a simple test for if a character is walking or running.
simulated function bool IsMoving()
{
	return ((Acceleration.X != 0) || (Acceleration.Y != 0) || (Velocity.X != 0) || (Velocity.Y != 0) || (Velocity.Z != 0));
}
/*
simulated event VelocitySetToCreeping( float flVelocity )
{
	log(self$".VelocitySetToCreeping( "$flVelocity$" )", 'pad');
	bIsCreeping = true;
	bIsWalking = false;
}
*/
simulated event VelocitySetToWalking( float flVelocity )
{
//	if (WalkVelocityCount <= WALK_VELOCITY_COUNT_THRESHOLD)
//	{
//		WalkVelocityCount++;
//		return;
//	}

	if (WalkVelocityTime == 0.0f)
	{
		WalkVelocityTime = Level.TimeSeconds;
		return;
	}
	else if ((Level.TimeSeconds - WalkVelocityTime) < 1.0f)
	{
		return;
	}
	
//	bIsCreeping = false;
	if (!bIsWalking && (flVelocity > 0.0))
	{
		bIsWalking = true;
		// GBX:PAD: This should hopefully not cause any side effects.  Essentially what this fixes is that the changeanimation
		// event checks to see if the controller controls animations, and if so it blows off calling PlayWaiting and PlayMoving.
		// Unfortunately, this means a scripted guy will never automatically switch its movement animations.  So putting this here
		// forces the switch.
		PlayMoving();
		WalkVelocityTime = 0.0f;
	}
}

simulated event VelocitySetToRunning( float flVelocity )
{
//	bIsCreeping = false;
	if (bIsWalking)
	{
		bIsWalking = false;
		// GBX:PAD: This should hopefully not cause any side effects.  Essentially what this fixes is that the changeanimation
		// event checks to see if the controller controls animations, and if so it blows off calling PlayWaiting and PlayMoving.
		// Unfortunately, this means a scripted guy will never automatically switch its movement animations.  So putting this here
		// forces the switch.
		PlayMoving();
		WalkVelocityCount = 0;
	}
}

// SJP: Return the velocity of the Pawn as a percentage of max speed
function float GetRelativeVelocity()
{
	return VSize(Velocity) / GroundSpeed;
}

simulated function Rotator TorsoViewRotation();

simulated event bool SameTeamAs(Pawn other)
{
	if (PawnTeam == TEAM_None)
		return true;

	if (other == None)
		return true;

	if ((other.PawnTeam == TEAM_None) || (other.PawnTeam == PawnTeam))
		return true;

	return false;
}

// Returns an angle, in degress, of the current view rotation yaw to the location of a given location.  0 - 360, clockwise.
function float GetFacingAngleToLocation( Vector otherLoc )
{
	local Vector RotationVector, fVector;
	local float fAngle;

	RotationVector = Vector( GetViewRotation() );
	fVector = Normal( otherLoc - Location );

	fAngle = ACos(fVector Dot RotationVector) * 57.2957795; // 180/Pi ~= 57.2957795

	if( (RotationVector Cross fVector).Z < 0.0 )
		fAngle = 360.0 - fAngle;

	return fAngle;
}

simulated function bool DisarmWeapon( name BoneName )
{
	return false;
}

simulated function bool RearmWeapon( name BoneName )
{
	return false;
}

simulated event PostRespawnPlay()
{
	Super.PostRespawnPlay();

	bHidden = false;	
	bCanBeDamaged = true;
	bShouldBaseAtStartup = true;
	bInitializeAnimation = false;
	m_fDispositionAnimPlaying = false;
}

simulated function bool CanToggleWeapon();

simulated function Pawn GetPlayerLeader()
{
	return None;
}

simulated function int GetFireTeamType()
{
	return 3;
}

defaultproperties
{
	bCanBeDamaged=true
	 bNoRepMesh=true
	 bJumpCapable=true
 	 bCanJump=true
	 bCanWalk=true
	 bCanSwim=false
	 bCanFly=false
	 bUpdateSimulatedPosition=true
	 BaseEyeHeight=+00064.000000
     EyeHeight=+00054.000000
     CollisionRadius=+00034.000000
     CollisionHeight=+00078.000000
     GroundSpeed=+00600.000000
     AirSpeed=+00600.000000
     WaterSpeed=+00300.000000
     AccelRate=+02048.000000
	 DecelRate=+00256.000000
     JumpZ=+00420.000000
     MinJumpZ=+00200.000000
	 MaxFallSpeed=+1200.0
	 DrawType=DT_Mesh
	 bLOSHearing=true
	 HearingThreshold=+2800.0
     Health=100
     Visibility=128
	 LadderSpeed=+200.0
     noise1time=-00010.000000
     noise2time=-00010.000000
     AvgPhysicsTime=+00000.100000
     SoundDampening=+00001.000000
     DamageScaling=+00001.000000
     bDirectional=True
     bCanTeleport=True
	 bStasis=True
     SoundRadius=60
	 SoundVolume=255
     bCollideActors=True
     bCollideWorld=True
     bBlockActors=True
     bBlockPlayers=True
     bProjTarget=True
     bRotateToDesired=True
	 bCanCrouch=False
     RotationRate=(Pitch=4096,Yaw=20000,Roll=3072)
	 Texture=Texture'Engine.S_Pawn'
     RemoteRole=ROLE_SimulatedProxy
     NetPriority=+00002.000000
	 AirControl=+0.05
	 ControllerClass=class'AIController'
	 CrouchHeight=+40.0
	 CrouchRadius=+28.0
	 ProneHeight=+24.0
	 ProneRadius=+28.0
     MaxDesiredSpeed=+00001.000000
     DesiredSpeed=+00001.000000
 	 LandMovementState=PlayerWalking
	 WaterMovementState=PlayerSwimming
	 SightRadius=+05000.000000
	 bOwnerNoSee=true
	 bAcceptsProjectors=True
	 BlendChangeTime=0.25
	 WalkingPct=+0.5
	 CrouchedPct=+0.4
	 SprintPct=+2.0
	 LimpingPct=0.7
//	 CreepingThreshold=+0.25
	 WalkingThreshold=+0.5
	 CrouchedThreshold=+0.75
	 StrafeThreshold=+0.6
	 BackwardThreshold=+0.6
	 bTravel=true
	 BaseMovementRate=+525.0
	 ForwardStrafeBias=+0.0
	 BackwardStrafeBias=+0.0
	 bShouldBaseAtStartup=true
     Bob=0.0080
	ZoomBob=0.1
	 bDisturbFluidSurface=true
	 bBlockKarma=False
	 bWeaponBob=true
	 bUseCompressedPosition=true
	 HeadScale=+1.0
	kick_zoom_active=False
	kick_zooming_out=False
	 bNextCrouchState=true

	MinCrouchToggleInterval=0.0

	m_flEncumberance=1.0
	m_fCanSprint=true
	PawnTeam=TEAM_None

	m_flLegScale=1.0

	m_flJumpEndurance=1.0
	
	bOpaqueForSituationalAwarenessView=true

	bAlphaFogable=True
    bAlphaFogBlend=true
    
    bProjFlag_LevelShadow=False

	m_flMinForwardLerpPerSec=2.0
	m_flMinLeftLerpPerSec=2.0

	m_fLerpMoveAnim=False
}
//=============================================================================
// PawnAnimExtra
//
//	This is a wrapper for BeginState and EndState functionality for an animation a Pawn is running
//
//=============================================================================
class PawnAnimExtra extends Object;



static function bool BeginAnim( AnimPawn aPawn );
static function bool EndAnim( AnimPawn aPawn, bool fNoStart, bool fInterrupt );
//=============================================================================
// PawnAnimIdleListCallback
//
//	This is a wrapper for BeginState and EndState functionality for an animation a pawn is running
//	This takes care of starting another random idle at the end of one animation in the loop.  If I don't do this, they
//  loop the same anim over and over again, which looks odd.
//
//=============================================================================
class PawnAnimIdleListCallback extends PawnAnimExtra;



static function bool EndAnim( AnimPawn aPawn, bool fNoStart, bool fInterrupt )
{
	//local	int	nIdx;
	
	if (fNoStart)
		return false;

	aPawn.m_fRunNextQueueIdle = true;
	
	return true;
}
//=============================================================================
// PhysicsVolume:  a bounding volume which affects actor physics
// Each Actor is affected at any time by one PhysicsVolume
// This is a built-in Unreal class and it shouldn't be modified.
//=============================================================================
class PhysicsVolume extends Volume
	native
	nativereplication;



var()		bool		bPainCausing;	 // Zone causes pain.
var()		vector		ZoneVelocity;
var()		vector		Gravity;
var()		float		GroundFriction;
var()		float		TerminalVelocity;
var()		float		DamagePerSec;
var() class<DamageType>	DamageType;
var()		int			Priority;	// determines which PhysicsVolume takes precedence if they overlap
var() sound  EntrySound;	//only if waterzone
var() sound  ExitSound;		// only if waterzone
var() editinline I3DL2Listener VolumeEffect;
var() class<actor> EntryActor;	// e.g. a splash (only if water zone)
var() class<actor> ExitActor;	// e.g. a splash (only if water zone)
var() class<actor> PawnEntryActor; // when pawn center enters volume -BB
var() float  FluidFriction;
var() vector ViewFlash, ViewFog;

var()		bool	bDestructive; // Destroys most actors which enter it.
var()		bool	bNoInventory;
var()		bool	bMoveProjectiles;// this velocity zone should impart velocity to projectiles and effects
var()		bool	bBounceVelocity;	// this velocity zone should bounce actors that land in it
var()		bool	bNeutralZone; // Players can't take damage in this zone.
var			bool	bWaterVolume;
var	Info PainTimer;

// Distance Fog
var(VolumeFog) bool   bDistanceFog;	// There is distance fog in this physicsvolume.
var(VolumeFog) color DistanceFogColor;
var(VolumeFog) float DistanceFogStart;
var(VolumeFog) float DistanceFogEnd;

// Karma
var(Karma)	   float KExtraLinearDamping; // Extra damping applied to Karma actors in this volume.
var(Karma)	   float KExtraAngularDamping;
var(Karma)	   float KBuoyancy;			  // How buoyant Karma things are in this volume (if bWaterVolume true). Multiplied by Actors KarmaParams->KBuoyancy.

var PhysicsVolume NextPhysicsVolume;

replication
{
	// Things the server should send to the client.
	reliable if( bNetDirty && (Role==ROLE_Authority) )
		Gravity;
}

simulated function PostBeginPlay()
{
	super.PostBeginPlay();

	if( VolumeEffect == None && bWaterVolume )
		VolumeEffect = new( Level.Outer ) class'EFFECT_WaterVolume';
}

/* Called when an actor in this PhysicsVolume changes its physics mode
*/
event PhysicsChangedFor(Actor Other);

event ActorEnteredVolume(Actor Other);
event ActorLeavingVolume(Actor Other);

event PawnEnteredVolume(Pawn Other)
{
	if ( Other.IsPlayerPawn() )
		TriggerEvent(Event,self, Other);
}

event PawnLeavingVolume(Pawn Other)
{
	if ( Other.IsPlayerPawn() )
		UntriggerEvent(Event,self, Other);
}

/*
TimerPop
damage touched actors if pain causing.
since PhysicsVolume is static, this function is actually called by a volumetimer
*/
function TimerPop(VolumeTimer T)
{
	local actor A;
	local bool bFound;

	if ( T == PainTimer )
	{
		if ( !bPainCausing )
		{
			PainTimer.Destroy();
			return;
		}
		ForEach TouchingActors(class'Actor', A)
			if ( A.bCanBeDamaged && !A.bStatic )
			{
				CausePainTo(A);
				bFound = true;
			}

		if ( !bFound )
			PainTimer.Destroy();
	}
}

function Trigger( actor Other, Pawn EventInstigator )
{
	// turn zone damage on and off
	if (DamagePerSec != 0)
	{
		bPainCausing = !bPainCausing;
		if ( bPainCausing && (PainTimer == None) )
			PainTimer = spawn(class'VolumeTimer', self);
	}
}

event touch(Actor Other)
{
	local Pawn P;
	local bool bFoundPawn;

	Super.Touch(Other);
	if ( Other == None )
		return;
	if ( bNoInventory && Other.IsA('Inventory') && (Other.Owner == None) )
	{
		Other.LifeSpan = 1.5;
		return;
	}
	if ( bMoveProjectiles && (ZoneVelocity != vect(0,0,0)) )
	{
		if ( Other.Physics == PHYS_Projectile )
			Other.Velocity += ZoneVelocity;
		else if ( Other.IsA('Effects') && (Other.Physics == PHYS_None) )
		{
			Other.SetPhysics(PHYS_Projectile);
			Other.Velocity += ZoneVelocity;
		}
	}
	if ( bPainCausing )
	{
		if ( Other.bDestroyInPainVolume )
		{
			Other.Destroy();
			return;
		}
		if ( Other.bCanBeDamaged && !Other.bStatic )
		{
			CausePainTo(Other);
			if ( PainTimer == None )
				PainTimer = Spawn(class'VolumeTimer', self);
			else if ( Pawn(Other) != None )
			{
				ForEach TouchingActors(class'Pawn', P)
					if ( (P != Other) && P.bCanBeDamaged )
					{
						bFoundPawn = true;
						break;
					}
				if ( !bFoundPawn )
					PainTimer.SetTimer(1.0,true);
			}
		}
	}
	if ( bWaterVolume && Other.CanSplash() )
		PlayEntrySplash(Other);
}

function PlayEntrySplash(Actor Other)
{
	local float SplashSize;
	local actor splash;

	splashSize = FClamp(0.00003 * Other.Mass * (250 - 0.5 * FMax(-600,Other.Velocity.Z)), 0.1, 1.0 );
	if( EntrySound != None )
	{
		PlaySound(EntrySound, SLOT_Interact, splashSize);
		if ( Other.Instigator != None )
			MakeNoise(SplashSize);
	}
	if( EntryActor != None )
	{
		splash = Spawn(EntryActor);
		if ( splash != None )
			splash.SetDrawScale(splashSize);
	}
}

event untouch(Actor Other)
{
	if ( bWaterVolume && Other.CanSplash() )
		PlayExitSplash(Other);
}

function PlayExitSplash(Actor Other)
{
	local float SplashSize;
	local actor splash;
	
	splashSize = FClamp(0.003 * Other.Mass, 0.1, 1.0 );
	if( ExitSound != None )
		PlaySound(ExitSound, SLOT_Interact, splashSize);
	if( ExitActor != None )
	{
		splash = Spawn(ExitActor);
		if ( splash != None )
			splash.SetDrawScale(splashSize);
	}
}

function CausePainTo(Actor Other)
{
	local float depth;
	local Pawn P;

	// FIXMEZONE figure out depth of actor, and base pain on that!!!
	depth = 1;
	P = Pawn(Other);

	if ( DamagePerSec > 0 )
	{
		if ( Region.Zone.bSoftKillZ && (Other.Physics != PHYS_Walking) )
			return;
		Other.TakeDamage(int(DamagePerSec * depth), None, Location, vect(0,0,0), DamageType);
		if ( (P != None) && (P.Controller != None) )
			P.Controller.PawnIsInPain(self);
	}
	else
	{
		if ( (P != None) && (P.Health < P.Default.Health) )
		P.Health = Min(P.Default.Health, P.Health - depth * DamagePerSec);
	}
}

defaultproperties
{
    Gravity=(X=0.000000,Y=0.000000,Z=-1500.000000)
	FluidFriction=+0.3
//    TerminalVelocity=+02500.000000
    TerminalVelocity=+12000.000000
	bAlwaysRelevant=true
	bOnlyDirtyReplication=true
    GroundFriction=+00008.000000
	KBuoyancy=1.0
	NetUpdateFrequency=5
	bSkipActorPropertyReplication=true
}
//=============================================================================
// Pickup items.
//
// Pickup is the base class of actors that when touched by an appropriate Pawn,
// will create and place an Inventory actor in that Pawn's inventory chain.  Each
// pickup class has an associated inventory class (its InventoryType).  Pickups are
// placed by level designers.  Pickups can only interact with pawns when in their
// default Pickup state.  Pickups verify that they can give inventory to a Pawn by
// calling the GameInfo's PickupQuery() function.  After a pickup spawns an inventory
// item for a Pawn, it then queries the GameInfo by calling the GameInfo's
// ShouldRespawn() function about whether it should remain active, enter its Sleep
// state and later become active again, or destroy itself.
//
// When navigation paths are built, each pickup has an InventorySpot (a subclass
// of NavigationPoint) placed on it and associated with it
// (the Pickup's MyMarker== the InventorySpot,
// and the InventorySpot's markedItem == the pickup).
//
//=============================================================================
class Pickup extends Actor
	abstract
	placeable
	native
	nativereplication;



//-----------------------------------------------------------------------------
// AI related info.

var  float		  MaxDesireability;		// Maximum desireability this item will ever have.
var	  InventorySpot MyMarker;
var	  ActorLite PickupCache;		// used for dropped pickups
var() class<Inventory> InventoryType;
var() bool		bInstantRespawn;	  // Can be tagged so this item respawns instantly.
var	  bool		bOnlyReplicateHidden;	// only replicate changes in bHidden (optimization for level pickups)
var(Display) bool bAmbientGlow;		  // Whether to glow or not.
var		bool	bDropped;
var		bool	bPredictRespawns;	  // high skill bots may predict respawns for this item
var		bool	bDisplayPickupMessage;
var() float     RespawnTime;          // Respawn after this time, 0 for instant.
var	 float RespawnEffectTime;

var Cue	PickupAmmoCue;		// ammo pickup sound
var Cue PickupWeaponCue;	// weapon pickup sound

var() localized string PickupMessage; // Human readable description when picked up.
var() sound PickupSound;
var() string PickupForce;  // jdf
var() localized string PickupName; // Human readable description when picked up.

native final function AddToNavigation();			// cache dropped inventory in navigation network
native final function RemoveFromNavigation();

static function StaticPrecache(LevelInfo L);

function PostBeginPlay()
{
	Super.PostBeginPlay();

	if( PickupAmmoCue == None )
	{
		PickupAmmoCue = LoadSound( "GEAR.PICKUPAMMO" );
		log( "Pickup::PostBeginPlay() - PickupAmmoCue=" $ PickupAmmoCue, 'RSC' );
	}

	if( PickupWeaponCue == None )
	{
		PickupWeaponCue = LoadSound( "GEAR.ZOOMOUT" );
		log( "Pickup::PostBeginPlay() - PickupWeaponCue=" $ PickupWeaponCue, 'RSC' );
	}
}

function Destroyed()
{
	if (MyMarker != None )
		MyMarker.markedItem = None;
	if (Inventory != None )
		Inventory.Destroy();
}

/* Reset()
reset actor to initial state - used when restarting level without reloading.
*/
function Reset()
{
	if ( Inventory != None )
		destroy();
	else
	{
		GotoState('Pickup');
		Super.Reset();
	}
}

function RespawnEffect();

// Turns the pickup into a different type of pickup - specificly used by the WildcardCharger
function Pickup Transmogrify(class<Pickup> NewClass) // de
{
	local Pickup NewPickup;

	NewPickup = Spawn(NewClass);
	NewPickup.RespawnTime = RespawnTime;

	if (MyMarker != None )
	{
		MyMarker.markedItem = NewPickup;
		NewPickup.MyMarker = MyMarker;
		MyMarker = None;
	}
	Destroy();

	return NewPickup;
}

/* DetourWeight()
value of this path to take a quick detour (usually 0, used when on route to distant objective, but want to grab inventory for example)
*/
function float DetourWeight(Pawn Other,float PathWeight)
{
	return 0;
}

/* Pickups have an AI interface to allow AIControllers, such as bots, to assess the
 desireability of acquiring that pickup.  The BotDesireability() method returns a
 float typically between 0 and 1 describing how valuable the pickup is to the
 AIController.  This method is called when an AIController uses the
 FindPathToBestInventory() navigation intrinsic.
*/
function float BotDesireability( Pawn Bot )
{
	local Inventory AlreadyHas;
	local float desire;

	desire = MaxDesireability;

	if ( RespawnTime < 10 )
	{
		AlreadyHas = Bot.FindInventoryType(InventoryType);
		if ( AlreadyHas != None )
		{
			if ( Inventory != None )
			{
				if( Inventory.Charge <= AlreadyHas.Charge )
					return -1;
			}
			else if ( InventoryType.Default.Charge <= AlreadyHas.Charge )
				return -1;
		}
	}
	return desire;
}

// Either give this inventory to player Other, or spawn a copy
// and give it to the player Other, setting up original to be respawned.
//
function inventory SpawnCopy( Pawn Other )
{
	local inventory Copy;

	if ( Inventory != None )
	{
		Copy = Inventory;
		Inventory = None;
	}
	else
		Copy = spawn(InventoryType,Other,,,rot(0,0,0));

	Copy.GiveTo( Other, self );

	return Copy;
}

function StartSleeping()
{
    if (bDropped)
        Destroy();
    else
	GotoState('Sleeping');
}

function AnnouncePickup( Pawn Receiver )
{
	Receiver.HandlePickup(self);

	log( "Pickup::AnnouncePickup() - self=" $ self, 'RSC' );
	if( self.IsA( 'Ammo' ) )
	{
		if( PickupAmmoCue != None )
		{
			Receiver.PlaySoundCue( PickupAmmoCue, SLOT_Interact, 1.0 );
			log( "Pickup::AnnouncePickup() - PlaySoundCue( " $ PickupAmmoCue $ " )", 'RSC' );
		}
	}
	else
	{
		if( PickupWeaponCue != None )
		{
			Receiver.PlaySoundCue( PickupWeaponCue, SLOT_Interact, 1.0 );
			log( "Pickup::AnnouncePickup() - PlaySoundCue( " $ PickupWeaponCue $ " )", 'RSC' );
		}
	}
}

//
// Set up respawn waiting if desired.
//
function SetRespawn()
{
	if( Level.Game.ShouldRespawn(self) )
		StartSleeping();
	else
		Destroy();
}

// HUD Messages

static function string GetLocalString(
	optional int Switch,
	optional PlayerReplicationInfo RelatedPRI_1,
	optional PlayerReplicationInfo RelatedPRI_2
	)
{
	return Default.PickupMessage;
}

function InitDroppedPickupFor(Inventory Inv)
{
	SetPhysics(PHYS_Falling);
	GotoState('FallingPickup');
	Inventory = Inv;
	bAlwaysRelevant = false;
	bOnlyReplicateHidden = false;
	bUpdateSimulatedPosition = true;
    bDropped = true;
    LifeSpan = 16;
	bIgnoreEncroachers=false; // handles case of dropping stuff on lifts etc
}

function bool ReadyToPickup(float MaxWait)
{
	return false;
}

event Landed(vector HitLocation, Vector HitNormal)
{
	GotoState('Pickup');
}

//=============================================================================
// Pickup state: this inventory item is sitting on the ground.

auto state Pickup
{
	function bool ReadyToPickup(float MaxWait)
	{
		return true;
	}

	/* ValidTouch()
	 Validate touch (if valid return true to let other pick me up and trigger event).
	*/
	function bool ValidTouch( actor Other )
	{
		// make sure its a live player
		if ( (Pawn(Other) == None) || !Pawn(Other).bCanPickupInventory || (Pawn(Other).Health <= 0) )
		{
			return false;
		}

		// make sure game will let player pick me up
		if( Level.Game.PickupQuery(Pawn(Other), self) )
		{
			TriggerEvent(Event, self, Pawn(Other));
			return true;
		}
		return false;
	}

	// When touched by an actor.
	function Touch( actor Other )
	{
		local Inventory Copy;

		// If touched by a player Pawn, let him pick this up.
		if( ValidTouch(Other) )
		{
			Copy = SpawnCopy(Pawn(Other));
			AnnouncePickup(Pawn(Other));
            SetRespawn();
            if ( Copy != None )
				Copy.PickupFunction(Pawn(Other));
		}
	}

	// Make sure no Pawn already touching (while touch was disabled in sleep).
	function CheckTouching()
	{
		local Pawn P;

		ForEach TouchingActors(class'Pawn', P)
			Touch(P);
	}

	function Timer()
	{
		if ( bDropped )
			GotoState('FadeOut');
	}

	function BeginState()
		{
		if ( bDropped )
        {
			// GBX:PAD Our AI guys are not picking up weapons, so don't bother doing this junk.
//			AddToNavigation();
		    SetTimer(8, false);
		}
	}

	function EndState()
	{
		if ( bDropped )
			RemoveFromNavigation();
	}

Begin:
	CheckTouching();
}

state FallingPickup extends Pickup
{
	function CheckTouching()
{
	}

	function Timer()
	{
		GotoState('FadeOut');
	}

	function BeginState()
	{
	    SetTimer(16, false);
	}
}

State FadeOut extends Pickup
{
	function Tick(float DeltaTime)
	{
		SetDrawScale(FMax(0.01, DrawScale - Default.DrawScale * DeltaTime));
	}

	function BeginState()
	{
		RotationRate.Yaw=60000;
		SetPhysics(PHYS_Rotating);
		LifeSpan = 1.0;
	}

	function EndState()
	{
		LifeSpan = 0.0;
		SetDrawScale(Default.DrawScale);
		if ( Physics == PHYS_Rotating )
			SetPhysics(PHYS_None);
	}
}

//=============================================================================
// Sleeping state: Sitting hidden waiting to respawn.
function float GetRespawnTime()
{
	return RespawnTime;
}

// Stub for gbxWeaponPickup
function AddPhysics( Pawn LastOwner, optional vector StartingVelocity )
{
}

State Sleeping
{
	ignores Touch;

	function bool ReadyToPickup(float MaxWait)
	{
		return ( bPredictRespawns && (LatentFloat < MaxWait) );
	}

	function StartSleeping() {}

	function BeginState()
	{
		NetUpdateTime = Level.TimeSeconds - 1;
		bHidden = true;
	}
	function EndState()
	{
		NetUpdateTime = Level.TimeSeconds - 1;
		bHidden = false;
	}
Begin:
	Sleep( GetReSpawnTime() - RespawnEffectTime );
	RespawnEffect();
	Sleep(RespawnEffectTime);
    GotoState('Pickup');
}

defaultproperties
{
	RespawnEffectTime=+0.5
	bOnlyDirtyReplication=true
	NetUpdateFrequency=8
    PickupMessage="Snagged an item."
	bAlwaysRelevant=true
	RemoteRole=ROLE_DumbProxy
	bHidden=false
	NetPriority=+1.4
	bCollideActors=true
	bCollideWorld=true
     bAmbientGlow=false
//     bFixedRotationDir=True
 //    RotationRate=(Yaw=5000)
 //    DesiredRotation=(Yaw=30000)
     Texture=Texture'Engine.S_Inventory'
    MaxDesireability=0.1000
	 DrawType=DT_Mesh
	 bOnlyReplicateHidden=true
	 bOrientOnSlope=true
	 bUseCylinderCollision=true
	 bShouldBaseAtStartup=true
	bIgnoreEncroachers=true
	
	bDisplayPickupMessage=true

	bAlphaFogable=True
    bAlphaFogBlend=true

	PickupAmmoCue=None
	PickupWeaponCue=None
}
//=============================================================================
// Player: Corresponds to a real player (a local camera or remote net player).
// This is a built-in Unreal class and it shouldn't be modified.
//=============================================================================
class Player extends Object
	native
	noexport;



//-----------------------------------------------------------------------------
// Player properties.

// Internal.
var native const int vfOut;
var native const int vfExec;

// The actor this player controls.
var transient const playercontroller Actor;
var transient interaction Console;

// Window input variables
var bool bShowWindowsMouse;
var bool bSuspendPrecaching;
var transient const float WindowsMouseX;
var transient const float WindowsMouseY;
var transient const bool bWindowsMouseAvailable;
var int CurrentNetSpeed;
var globalconfig int ConfiguredInternetSpeed, ConfiguredLanSpeed;
var int GamePadIndex; // sjs
var int SplitIndex;   // sjs - splitscreen index, 0=primary player
var byte SelectedCursor;

var transient InteractionMaster InteractionMaster;	// Callback to the IM
var transient array<Interaction> LocalInteractions;	// Holds a listing of all local Interactions
var transient BaseGUIController GUIController;		// Callback to the Menu Controller


const IDC_ARROW=0;
const IDC_SIZEALL=1;
const IDC_SIZENESW=2;
const IDC_SIZENS=3;
const IDC_SIZENWSE=4;
const IDC_SIZEWE=5;
const IDC_WAIT=6;

defaultproperties
{
}
//=============================================================================
// PlayerController
//
// PlayerControllers are used by human players to control pawns.
//
// This is a built-in Unreal class and it shouldn't be modified.
// for the change in Possess().
//=============================================================================
class PlayerController extends Controller
	config(user)
	native
    nativereplication;



// Player info.
var const player Player;

// player input control
var globalconfig	bool 	bLookUpStairs;	// look up/down stairs (player)
var globalconfig	bool	bSnapToLevel;	// Snap to level eyeheight when not mouselooking
var globalconfig	bool	bAlwaysMouseLook;
var globalconfig	bool	bKeyboardLook;	// no snapping when true
var globalconfig    bool    bAutoAim;
var globalconfig	bool	bUseCrouchToggle; // Toggle crouch state, instead of holding crouch key down
var globalconfig	bool	bDontReloadAfterFire;  // Should we auto reload after firing the gun?
var globalconfig	float	CrouchHoldToStandThreshold;	//In crouch toggle, HOLDING crouch for this amount of time will cause the player to stand immediately upon crouch release
var bool					bCenterView;
//var float					CrouchHoldTime;		// Amount of time crouch key has been held down

// Player control flags
var bool		bBehindView;    // Outside-the-player view.
var bool		bFrozen;		// set when game ends or player dies to temporarily prevent player from restarting (until cleared by timer)
var bool		bInOracleCameraMP;
var bool		bPressedJump;
var	bool		bDoubleJump;
var bool		bUpdatePosition;
var bool		bIsTyping;
var bool		bFixedCamera;	// used to fix camera in position (to view animations)
var bool		bJumpStatus;	// used in net games
var	bool		bUpdating;
var globalconfig bool	bNeverSwitchOnPickup;	// if true, don't automatically switch to picked up weapon

var bool		bZooming;
var bool		bIsInLobby;
var bool		bIsInDebriefing;
var bool		bIsEndingMission;

var globalconfig bool bAlwaysLevel;
var bool		bSetTurnRot;
var bool		bCheatFlying;	// instantly stop in flying mode
var bool		bFreeCamera;	// free camera when in behindview mode (for checking out player models and animations)
var	bool		bZeroRoll;
var	bool		bCameraPositionLocked;
var	bool		bCameraRotationLocked;
var	bool		bViewBot;
var bool		UseFixedVisibility;
var bool	bBlockCloseCamera;
var bool	bValidBehindCamera;
var bool	bForcePrecache;
var bool	bClientDemo;
var const bool bAllActorsRelevant;	// used by UTTV.  DO NOT SET THIS TRUE - it has a huge impact on network performance
var bool	bShortConnectTimeOut;	// when true, reduces connect timeout to 15 seconds
var bool	bPendingDestroy;		// when true, playercontroller is being destroyed
var bool  bSkippedLastUpdate, bLastPressedJump;

var globalconfig bool bNoVoiceMessages;
var globalconfig bool bNoVoiceTaunts;
var globalconfig bool bNoAutoTaunts;
var globalconfig bool bAutoTaunt;
var globalconfig bool bNoMatureLanguage;
var globalconfig bool bDynamicNetSpeed;

var globalconfig byte AnnouncerLevel;  // 0=none, 1=no possession announcements, 2=all
var globalconfig byte AnnouncerVolume; // 1 to 4
var globalconfig float AimingHelp;
var globalconfig float MaxResponseTime;		// how long server will wait for client move update before setting position
var float WaitDelay;			// Delay time until can restart

// >>> SJP
// These guys are only set by WargamePlayerInput, and then read in WargamePlayerController. 
// I needed these values in SA view for the XBox, and the only way I could get to them was to
// expose them somewhere outside of the input class (PlayerInput), which is private.  Here they are.
var float MaxLookYawSpeed;
var float MaxLookPitchSpeed;
// <<< SJP

var input float
	aBaseX, aBaseY, aBaseZ,	aMouseX, aMouseY,
	aForward, aTurn, aStrafe, aUp, aLookUp;

// Vehicle Move Replication
var float aLastForward, aLastStrafe, aLastUp;

var input byte
	bStrafe, bSnapLevel, bLook, bFreeLook, bTurn180, bTurnToNearest, bXAxis, bYAxis;

// GBX:PAD: For other uses, trap the key buttons on an XBox control pad.
var input byte
	bAButton,
	bBButton,
	bXButton,
	bYButton,
	bRButton,
	bLButton,
	bStartButton,
	bBackButton;

struct native KeyBindingStruct  // used to store which keys are bound to which "action" commands
{
	var int		InputKey;
	var string	KeyName;
	var string	Alias;
	var string	IconText;
};

var bool bKeybindingsInitialized;
var bool bInBlockUnblockState;
var array<KeyBindingStruct> PCKeyBindings;
var array<KeyBindingStruct> XboxKeyBindings;
var array<KeyBindingStruct> XboxThumbstickBindings;

struct native ActionKeyBindStruct  // used to associate %action_ keywords with key bind "action" commands and the keyname bound to those commands
{
	var string	Keyword;
	var string	Action;
	var string	KeyName;
};

var array<ActionKeyBindStruct> ActionKeyBindings;
var array<ActionKeyBindStruct> ActionPCMoveLookBindings;
var array<ActionKeyBindStruct> ActionThumbstickBindings;

struct native ActionBindStruct
{
	var int		InputKey;
	var string	Action;
	var string	KeyName;
};

var array<ActionBindStruct> ActionBindings;  // bindings for ALL keys/buttons to Actions (multiple keys can be bound to same Action)


// actions bound to keys that you can block and/or wait for being pressed...
// NOTE: These MUST be exactly the same as in gbxScripted/Classes/TriggeredScript.uc
const KEY_ACTION_JUMP 			= 0x00000001;  // jump
const KEY_ACTION_MELEE 			= 0x00000002;  // melee attack
const KEY_ACTION_USE 			= 0x00000004;  // Use/activate
const KEY_ACTION_THROW_GRENADE	= 0x00000008;  // throw grenade
const KEY_ACTION_CYCLE_WEAPON 	= 0x00000010;  // throw grenade
const KEY_ACTION_TEAMSELECT 	= 0x00000020;  // toggle between fire and assault team
const KEY_ACTION_ORDER 			= 0x00000040;  // command mode
const KEY_ACTION_FIRE 			= 0x00000080;  // weapon fire
const KEY_ACTION_FALL_OUT 		= 0x00000100;  // issue an fall_out command
const KEY_ACTION_FALL_IN 		= 0x00000200;  // issue an fall_in command
const KEY_ACTION_FIRE_TEAM		= 0x00000400;  // select fire team
const KEY_ACTION_ASSAULT_TEAM	= 0x00000800;  // select the assault team
const KEY_ACTION_SHOW_MENU		= 0x00001000;  // show the UI menu (start button on Xbox controller)
const KEY_ACTION_SA_VIEW 		= 0x00002000;  // enter/exit situational awareness view
const KEY_ACTION_CROUCH 		= 0x00004000;  // crouch
const KEY_ACTION_ZOOM 			= 0x00008000;  // weapon zoom
const KEY_ACTION_MOVE			= 0x00010000;  // left thumbstick on Xbox, W,A,S,D keys on PC
const KEY_ACTION_LOOK			= 0x00020000;  // right thumbstick on Xbox, mouse movement on PC
const KEY_ACTION_RELOAD 		= 0x00040000;  // weapon reload
const KEY_ACTION_SA_LEFT 		= 0x00080000;  // select previous SA view item
const KEY_ACTION_SA_RIGHT 		= 0x00100000;  // select next SA view item
const KEY_ACTION_CONTINUE 		= 0x00200000;  // "continue" key (always bound to the same key/button, SPACE on PC, 'A' on Xbox)
const KEY_ACTION_CANCEL 		= 0x00400000;  // "cancel" key (always bound to the same button)
const KEY_ACTION_SA_UP			= 0x00800000;  // select SA view objective
const KEY_ACTION_SA_DOWN 		= 0x01000000;  // select SA view player

// these only apply to the Xbox controller (on the PC they do nothing)...
// NOTE: These MUST be exactly the same as in gbxScripted/Classes/TriggeredScript.uc
const KEY_BUTTON_A 						= 0x00000001;
const KEY_BUTTON_B						= 0x00000002;
const KEY_BUTTON_X						= 0x00000004;
const KEY_BUTTON_Y						= 0x00000008;
const KEY_BUTTON_BLACK					= 0x00000010;
const KEY_BUTTON_WHITE					= 0x00000020;
const KEY_BUTTON_L_TRIGGER				= 0x00000040;
const KEY_BUTTON_R_TRIGGER				= 0x00000080;
const KEY_BUTTON_DPAD_UP				= 0x00000100;
const KEY_BUTTON_DPAD_DOWN				= 0x00000200;
const KEY_BUTTON_DPAD_LEFT				= 0x00000400;
const KEY_BUTTON_DPAD_RIGHT				= 0x00000800;
const KEY_BUTTON_START					= 0x00001000;
const KEY_BUTTON_BACK					= 0x00002000;
const KEY_BUTTON_L_STICK_PRESS			= 0x00004000;
const KEY_BUTTON_R_STICK_PRESS			= 0x00008000;
const KEY_BUTTON_L_STICK_LEFT_RIGHT		= 0x00010000;
const KEY_BUTTON_L_STICK_FORWARD_BACK	= 0x00020000;
const KEY_BUTTON_R_STICK_LEFT_RIGHT		= 0x00040000;
const KEY_BUTTON_R_STICK_FORWARD_BACK	= 0x00080000;


// PC keys that can be blocked by script code (Xbox buttons are IK_Joy1 thru IK_Joy16)
var BYTE	BlockedKeys[256];
var int		PreviousBlockedActionKeyMask;
var int		PreviousBlockedButtonMask;
// key Action name that matches PlayerController ActionKeyBindings (same order as KEY_ACTION_ bitmask above)
var string	KeyActionArray[25];
// intercepts PC keys that have been pressed (sets to 'true' once the key has been pressed) (Xbox uses IK_Joy1 thru IK_Joy16)
var BYTE InterceptedKeys[256];
var float InterceptedKeyHoldTime[256];  // how long this key needs to be held down before being "intercepted"
var float InterceptedKeyHeldTime[256];  // how long this key has been held down since it was first pressed
var bool bWaitingForAnyKeyPress;
var bool bAnyKeyPressed;
	
var EDoubleClickDir DoubleClickDir;		// direction of movement key double click (for special moves)

// Camera info.
var int ShowFlags;
var int ShowFlags2;			// GBX:jlb - added for more "show" flags
var int Misc1,Misc2;
var int RendMap;
var float OrthoZoom;     // Orthogonal/map view zoom factor.
var const actor ViewTarget;
var const Controller RealViewTarget;
var PlayerController DemoViewer;
var float CameraDist;		// multiplier for behindview camera dist
var range CameraDistRange;
var vector OldCameraLoc;		// used in behindview calculations
var rotator OldCameraRot;

var float DesiredFOV;
var globalconfig float DefaultFOV;
var float		ZoomLevel;
var float		FOVRate;

// Fixed visibility.
var vector	FixedLocation;
var rotator	FixedRotation;
var matrix	RenderWorldToCamera;

// Screen flashes
var vector FlashScale, FlashFog;
var float DesiredFlashScale, ConstantGlowScale, InstantFlash;
var vector DesiredFlashFog, ConstantGlowFog, InstantFog;

// Distance fog fading.
var color	LastDistanceFogColor;
var float	LastDistanceFogStart;
var float	LastDistanceFogEnd;
var float	CurrentDistanceFogEnd;
var float	TimeSinceLastFogChange;
var int		LastZone;

// Remote Pawn ViewTargets
var rotator		TargetViewRotation;
var rotator     BlendedTargetViewRotation;
var float		TargetEyeHeight;
var vector		TargetWeaponViewOffset;

var HUD	myHUD;	// heads up display info

// HUD Effect
const MAX_HUD_EFFECTS = 3;
var HudEffect myHudEffects[ MAX_HUD_EFFECTS ];	// a stack of effects that render to the HUD: dirt, mud, etc.
var int BloodEffectIndex; // Index of the blood effect within myHudEffects
var int DirtEffectIndex; // Index of the dirt effect within myHudEffects
var int RainEffectIndex; // Index of the rain effect within myHudEffects

var float LastPlaySound;
var float LastPlaySpeech;

// Music info.
var string				Song;
var EMusicTransition	Transition;

// Move buffering for network games.  Clients save their un-acknowledged moves in order to replay them
// when they get position updates from the server.
var SavedMove SavedMoves;	// buffered moves pending position updates
var SavedMove FreeMoves;	// freed moves, available for buffering
var SavedMove PendingMove;
var float CurrentTimeStamp,LastUpdateTime,ServerTimeStamp,TimeMargin, ClientUpdateTime;
var globalconfig float MaxTimeMargin;
var Weapon OldClientWeapon;
var int WeaponUpdate;

// Progess Indicator - used by the engine to provide status messages (HUD is responsible for displaying these).
var string	ProgressMessage[4];
var color	ProgressColor[4];
var float	ProgressTimeOut;

// Localized strings
var localized string QuickSaveString;
var localized string NoPauseMessage;
var localized string ViewingFrom;
var localized string OwnCamera;

// ReplicationInfo
var GameReplicationInfo GameReplicationInfo;

// Stats Logging
var globalconfig string StatsUsername;
var globalconfig string StatsPassword;

var class<LocalMessage> LocalMessageClass;

// view shaking (affects roll, and offsets camera position)
var float	MaxShakeRoll; // max magnitude to roll camera
var vector	MaxShakeOffset; // max magnitude to offset camera position
var float	ShakeRollRate;	// rate to change roll
var vector	ShakeOffsetRate;
var vector	ShakeOffset; //current magnitude to offset camera from shake
var float	ShakeRollTime; // how long to roll.  if value is < 1.0, then MaxShakeOffset gets damped by this, else if > 1 then its the number of times to repeat undamped
var vector	ShakeOffsetTime;

var Pawn		TurnTarget;
var int			EnemyTurnSpeed;
var int			GroundPitch;
var rotator		TurnRot180;

var vector OldFloor;		// used by PlayerSpider mode - floor for which old rotation was based;

// Components ( inner classes )
var private transient CheatManager    CheatManager;   // Object within playercontroller that manages "cheat" commands
var class<CheatManager>		CheatClass;		// class of my CheatManager
var class<Actor> DebugManagerClass;
var string DebugManagerClassname;
var Actor MyDebugManager;
var private transient PlayerInput	PlayerInput;	// Object within playercontroller that manages player input.
var config class<PlayerInput>       InputClass;     // class of my PlayerInput
var const vector FailedPathStart;

// Demo recording view rotation
var int DemoViewPitch;
var int DemoViewYaw;

var Security PlayerSecurity;	// Used for Cheat Protection
var float ForcePrecacheTime;

var float LastPingUpdate;
var float ExactPing;
var float OldPing;
var float SpectateSpeed;
var globalconfig float DynamicPingThreshold;
var float NextSpeedChange;
var int ClientCap;

var float   VehicleCheckRadius;         // Radius that is checked for nearby vehicles when pressing use

// jij ---
var globalconfig int VoiceMask;
var int VoiceChannel;
var bool ListenToVoiceOnSpeaker; //SDJ 06/15/2004: Bringing voice chat in line with current TRC.
var globalconfig int OnlineStatus;
// --- jij

var globalconfig bool bEnableForceFeedback;  // turns on/off ALL forcefeedback (rumble)
var globalconfig bool bEnablePickupForceFeedback;
var globalconfig bool bEnableWeaponForceFeedback;
var globalconfig bool bEnableDamageForceFeedback;
var globalconfig bool bEnableGUIForceFeedback;
var bool bForceFeedbackSupported;  // true if a device is detected

// gam --- Xbox Live stuff
var String xuid;
var String Gamertag;
var bool bIsGuest;
var bool bHasVoice;
var globalconfig int Skill;

var bool bWasInvited; // If joined current game as a result of a game invite.
var int NetSplitID; // sjs - to map replicated playercontrollers to their correct controller ports

//SDJ 04/13/2004: From UC.
var int NumFriendRequests;
var int NumGameInvites;
// for drawing the live icons where appropriate:
var int LastNumFriendRequests;
var int LastNumGameInvites;
var float FriendRequestTimeout;
var float GameInviteTimeout;
//End SDJ------------------

// PSV: 6/2/2004 Moved here from gbxPlayerController
var bool bLockedMovement;	

var globalconfig bool			bDisableSubtitles;
var globalconfig bool			bDisableHints;
var globalconfig bool			bDisableTraining;
var globalconfig int			iAudioMode;	// PSV: 4/1/2005 Added to toggle audio setting (safe mode, 3d, eax, etc)
var globalconfig bool			bSystemDriver; // PSV: 4/4/2005 Added a couple more audio options
var globalconfig bool			bReverseStereo; // PSV: 4/4/2005 Added a couple more audio options
var globalconfig bool			bStreamingAudio; // PSV: 8/6/2005 Added option to enable/disable streaming audio
var globalconfig byte			iCrossHairIndex;
var globalconfig byte			iScreenBrightness;
var globalconfig byte			iScreenGamma;	//NAC: Added to tweak Gamma settings on PC
var globalconfig byte			iScreenContrast; //NAC: Added to tweak Contrast settings on PC
var globalconfig bool			bLowDetailTextures; //NAC: Added to toggle DetailTexture settings on PC
var globalconfig bool			bUseCube;		//NAC: Added to toggle use of cubemap render target
var globalconfig float			fGrassDetail;	//NAC: Added to tweak grass detail
var globalconfig byte			iAFiltering;	//NAC: Added to tweak Anisotropic Filtering Values
var globalconfig bool			bUseVsync;		//NAC: Added to toggle use of Vsync
var globalconfig byte			iMasterVolume;
var globalconfig byte			iMusicVolume;
var globalconfig byte			iCrossHairZoomed;
var globalconfig bool			bShowFullServers;
var globalconfig bool			bShowEmptyServers;

var transient string ProfileName;

// TODO PARIS REMOVEME
var globalconfig bool bIsDemo;

// --- gam

///// -> GEARBOX: SJP - Types used to control aim assistance
enum AimAssistStyle
{
	LeadTarget,
	StickToTarget,
	NoAssist,
};

struct native AimAssistParameters
{
	// Input variables
	var class<Pawn>		TargetBaseClass;		// Pawn class to start searching in.
	var float			SearchRadius;			// Maximum search radius for targets
	var float			AimAlignmentThreshold;	// Maximum distance from player's aim vector to Pawn considered to be a target
	var AimAssistStyle	AimStyle;				// Indicates which type of aim adjustment should be used
	var float			AimAdjustSpeed;			// A multiplier that effects the speed at which aim is adjusted based on the AimToTargetVector. Used by all AimAssistStyle's
	var float			LeadTargetRate;			// Speed at which to change view to lead target
	var float			LeadTargetRange;		// Target leading strength is attenuated over this distance
	var float			LeadTargetMaxAngle;		// Target leading strength is attenuated between your aimed angle and this angle

	// Output variables
	var Pawn			FoundTarget;			// The target, if any, that was found
	var vector			AimToTargetVector;		// A vector that represents the shortest distance from the player's aim vector to the target.  Z axis will have the actual distance.
	var float			AimToTargetAngle;		// Angle of aim relative to target
	var float			DistanceToTarget;		// Distance from player to target
	var Rotator			TargetAngularVelocity;	// Yaw & Pitch to indicate the relative angular velocity of the target, for LeadTarget style.
};

var AimAssistParameters AimAssistParams;
/////////// <- GEARBOX:SJP

var SceneManager	m_MatineeScript;

var const PlayerController	nextPlayerController; // chained Player Controller list

//DHW + --
const ZoomedShakeScalar = 0.01;
//DHW -

replication
{
	reliable if ( Role<ROLE_Authority)
		ServerThrowSwitch;


	// Things the server should send to the client.
	reliable if( bNetDirty && bNetOwner && Role==ROLE_Authority )
        GameReplicationInfo, NetSplitID;
	unreliable if ( bNetOwner && Role==ROLE_Authority && (ViewTarget != Pawn) && (Pawn(ViewTarget) != None) )
		TargetViewRotation, TargetEyeHeight, TargetWeaponViewOffset;
	reliable if( bDemoRecording && Role==ROLE_Authority )
		DemoViewPitch, DemoViewYaw;

	// Functions server can call.
	reliable if( Role==ROLE_Authority )
		ClientSetHUD,ClientReliablePlaySound, FOV, StartZoom,
		ToggleZoom, StopZoom, EndZoom, ClientSetMusic, ClientRestart,
		ClientAdjustGlow,
		ClientSetBehindView, ClientSetFixedCamera, ClearProgressMessages,
        SetProgressMessage, SetProgressTime,
		GivePawn, ClientGotoState,
		ClientChangeVoiceChatter,
		ClientLeaveVoiceChat,
        ClientChangeChannel,
		ClientValidate,
        ClientSetViewTarget, ClientCapBandwidth,
		ClientOpenMenu, ClientCloseMenu, ClientNetworkMessage, ClientTriggerEvent, ClientMatchStarting,
		ClientLateJoinToDebrefing, ClientFadePlayerScreen;

	reliable if ( (Role == ROLE_Authority) && (!bDemoRecording || (bClientDemoRecording && bClientDemoNetFunc)) )
		ClientMessage, TeamMessage, ReceiveLocalizedMessage, ReceiveObjectiveUpdate;
	unreliable if( Role==ROLE_Authority && !bDemoRecording )
        ClientPlaySound,ClientPlaySoundForPawn,PlayAnnouncement;
	reliable if( Role==ROLE_Authority && !bDemoRecording )
        ClientTravel;
	unreliable if( Role==ROLE_Authority )
        SetFOVAngle, ClientShake, ClientFlash,
		ClientAdjustPosition, ShortClientAdjustPosition, VeryShortClientAdjustPosition, LongClientAdjustPosition;
	unreliable if( (!bDemoRecording || bClientDemoRecording && bClientDemoNetFunc) && Role==ROLE_Authority )
		ClientHearSound;
    // jdf ---
    unreliable if( Role==ROLE_Authority && bForceFeedbackSupported )
        ServerPlayForceFeedback, ServerStopForceFeedback;
    // --- jdf
    reliable if( bClientDemoRecording && ROLE==ROLE_Authority )
		DemoClientSetHUD;

	// Functions client can call.
	unreliable if( Role<ROLE_Authority )
		ServerMoveFrequent, ServerMoveNoDelta,
		ServerUpdatePing, ShortServerMove, ServerMove,
		RocketServerMove, ServerSay, ServerTeamSay, ServerSetHandedness,
		ServerViewNextPlayer, ServerViewPreviousPlayer, ServerViewSelf,ServerUse, ServerDrive, ServerToggleBehindView,
		ServerServer;

	// from UT2k4 2004-10-03 JWS
	reliable if( Role<ROLE_Authority )
		ServerShortTimeout;

	reliable if( Role<ROLE_Authority )
        Speech, Pause, SetPause,Mutate,
		PrevItem, ActivateItem, ServerReStartGame, AskForPawn,
		ChangeName, ChangeTeam, Suicide,
        ServerThrowWeapon, BehindView, Typing,
		ServerChangeChannel, // jij
		ServerSetVoiceBan, ServerSetHasCommunicator,
		ServerValidationResponse, ServerVerifyViewTarget, ServerSpectateSpeed, ServerSetClientDemo;

    // jdf ---
    reliable if( Role<ROLE_Authority )
        UpdateForceFeedbackProperties, UpdateSwitchWeaponOnPickup;
    reliable if( Role==ROLE_Authority )
		RequestForceFeedbackProperties;
    reliable if( bNetDirty && bNetOwner && Role==ROLE_Authority )
        bForceFeedbackSupported, bEnableForceFeedback, bEnableWeaponForceFeedback,
        bEnablePickupForceFeedback, bEnableDamageForceFeedback,
        bEnableGUIForceFeedback;
    // --- jdf
}

native final function SetNetSpeed(int NewSpeed);
native final function string GetPlayerNetworkAddress();
native final function string GetServerNetworkAddress();
native function string ConsoleCommand( string Command );
native final function LevelInfo GetEntryLevel();
native(544) final function ResetKeyboard();
native final function SetViewTarget(Actor NewViewTarget);
native event ClientTravel( string URL, ETravelType TravelType, bool bItems );
native(546) final function UpdateURL(string NewOption, string NewValue, bool bSaveDefault);
native final function string GetDefaultURL(string Option);
// Execute a console command in the context of this player, then forward to Actor.ConsoleCommand.
native function CopyToClipboard( string Text );
native function string PasteFromClipboard();

// Validation.
private native event ClientValidate(string C);
private native event ServerValidationResponse(string R);

/* FindStairRotation()
returns an integer to use as a pitch to orient player view along current ground (flat, up, or down)
*/
native(524) final function int FindStairRotation(float DeltaTime);

native function bool IsSharingScreen(); // gam

native event ClientHearSound (
	actor Actor,
	int Id,
	sound S,
	vector SoundLocation,
	vector Parameters,
	bool Attenuate,
	bool bLipSync,
	int SoundHandle,
	name BoneForLocation
);

native simulated function AddPlayerController();
native simulated function RemovePlayerController();

native final function BlockActionKeys( int blockedkeymask );
native final function UnblockActionKeys( int blockedkeymask );
native final function BlockXboxButtons( int blockedbuttonmask );
native final function UnblockXboxButtons( int blockedbuttonmask );


simulated event PreBeginPlay()
{
	AddPlayerController();
	Super.PreBeginPlay();
}

event PostBeginPlay()
{
	local int i;

	Super.PostBeginPlay();
	SpawnDefaultHUD();
	if (Level.LevelEnterText != "" )
		ClientMessage(Level.LevelEnterText);

	DesiredFOV = DefaultFOV;
	SetViewTarget(self);  // MUST have a view target!
	if ( Level.NetMode == NM_Standalone )
		AddCheats();

    bForcePrecache = (Role < ROLE_Authority);
    ForcePrecacheTime = Level.TimeSeconds + 2;

	for (i=0; i < 256; i++)
	{
		BlockedKeys[i] = 0;
		InterceptedKeys[i] = 0;
	}
}

simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();

	// Setup HUD effects
	myHudEffects[ BloodEffectIndex ] = new( Level.Outer ) class'HudEffectBlood';

	if( myHudEffects[ BloodEffectIndex ] != None )
	{
		myHudEffects[ BloodEffectIndex ].Owner = self;
		myHudEffects[ BloodEffectIndex ].Initialize();
	}

	myHudEffects[ DirtEffectIndex ] = new( Level.Outer ) class'HudEffectDirt';

	if( myHudEffects[ DirtEffectIndex ] != None )
	{
		myHudEffects[ DirtEffectIndex ].Owner = self;
		myHudEffects[ DirtEffectIndex ].Initialize();
	}

	myHudEffects[ RainEffectIndex ] = new( Level.Outer ) class'HudEffectRain';

	if( myHudEffects[ RainEffectIndex ] != None )
	{
		myHudEffects[ RainEffectIndex ].Owner = self;
		myHudEffects[ RainEffectIndex ].Initialize();
	}
}

// from UT2k4 2004-10-03 JWS
function ServerShortTimeout()
{
	local Actor A;

	bShortConnectTimeOut = true;
    TimeMargin = -0.1;

	// quick update of pickups and gameobjectives since this player is now relevant
	if ( Level.Game.NumPlayers < 8 )
	{
		ForEach AllActors(class'Actor', A)
			if ( (A.NetUpdateFrequency < 1) && !A.bOnlyRelevantToOwner )
				A.NetUpdateTime = FMin(A.NetUpdateTime, Level.TimeSeconds + 0.2 * FRand());
	}
	else
	{
		ForEach AllActors(class'Actor', A)
			if ( (A.NetUpdateFrequency < 1) && !A.bOnlyRelevantToOwner )
				A.NetUpdateTime = FMin(A.NetUpdateTime, Level.TimeSeconds + 0.5 * FRand());
	}
}

exec function SetSpectateSpeed(Float F)
{
	SpectateSpeed = F;
	ServerSpectateSpeed(F);
}

function ServerSpectateSpeed(Float F)
{
	SpectateSpeed = F;
}

function ServerGivePawn()
{
	GivePawn(Pawn);
}

function ClientCapBandwidth(int Cap)
{
	ClientCap = Cap;
	if ( (Player != None) && (Player.CurrentNetSpeed > Cap) )
		SetNetSpeed(Cap);
}

function PendingStasis()
{
	bStasis = true;
	Pawn = None;
	GotoState('Scripting');
}

function AddCheats()
{
	// Assuming that this never gets called for NM_Client
	if (!Level.Game.bCheatsEnabled || Level.NetMode != NM_Standalone)
		return;

	if ( CheatManager == None && CheatClass != None )
		CheatManager = new( Self ) CheatClass;	// GBX:naj - modified 3/22/04 - was new(None)
    
	if ( DebugManagerClass == None && DebugManagerClassname != "" )
	{
        DebugManagerClass = class<Actor>(DynamicLoadObject(DebugManagerClassname, class'Class'));
		MyDebugManager = spawn(DebugManagerClass, self);
		MyDebugManager.Trigger(self, Pawn);  // call to initialize debug manager MyPlayerController
	}
}

function MatchStarting()
{
	AddCheats();

	ClientMatchStarting();
}

function ClientMatchStarting()
{
// stub for derived classes
}

event ClientSetViewTarget( Actor a )
{
	if ( A == None )
		ServerVerifyViewTarget();
    SetViewTarget( a );
}

function ServerVerifyViewTarget()
{
	if ( ViewTarget == self )
		return;

	ClientSetViewTarget(ViewTarget);
}

/* SpawnDefaultHUD()
Spawn a HUD (make sure that PlayerController always has valid HUD, even if \
ClientSetHUD() hasn't been called\
*/
function SpawnDefaultHUD()
{
	myHUD = spawn(class'HUD',self);
}

/* Reset()
reset actor to initial state - used when restarting level without reloading.
*/
function Reset()
{
	local vehicle DrivenVehicle;

    DrivenVehicle = Vehicle(Pawn);
	if( DrivenVehicle != None )
		DrivenVehicle.KDriverLeave(true); // Force the driver out of the car

	if (Pawn != None)
		PawnDied(Pawn);
	Super.Reset();
	SetViewTarget(self);
	bBehindView = false;
	WaitDelay = Level.TimeSeconds + 2;
    FixFOV();
    if ( !PlayerReplicationInfo.bOnlySpectator )
		GotoState('PlayerWaiting');
}

function UpdateSwitchWeaponOnPickup( bool bSwitch ) // RPC from client
{
    bNeverSwitchOnPickup = bSwitch;
}

// jdf ---
function UpdateForceFeedbackProperties( bool bSupported, bool bEnableWeapon, bool bEnablePickup, bool bEnableDamage, bool bEnableGUI )
{
    bForceFeedbackSupported = bSupported && (bEnableWeapon || bEnablePickup || bEnableDamage || bEnableGUI);
    bEnableWeaponForceFeedback = bEnableWeapon;
    bEnablePickupForceFeedback = bEnablePickup;
    bEnableDamageForceFeedback = bEnableDamage;
    bEnableGUIForceFeedback = bEnableGUI;
}
// --- jdf

// jdf ---
simulated function RequestForceFeedbackProperties()
{
	if (Level.NetMode != NM_DedicatedServer)
    {
        // sjs - here I update other prefs on the server... wah
        log("Sending Force/switch/taunt settings to server.");
	    bForceFeedbackSupported = ForceFeedbackSupported();
    }
}
// --- jdf

function CleanOutSavedMoves()
{
    local SavedMove Next;

	// clean out saved moves
	while ( SavedMoves != None )
	{
		Next = SavedMoves.NextMove;
		SavedMoves.Destroy();
		SavedMoves = Next;
	}
	if ( PendingMove != None )
	{
		PendingMove.Destroy();
		PendingMove = None;
	}
}

/* InitInputSystem()
Spawn the appropriate class of PlayerInput
Only called for playercontrollers that belong to local players
*/
event InitInputSystem()
{
	PlayerInput = new( Self ) InputClass;
}

/* ClientGotoState()
server uses this to force client into NewState
*/
function ClientGotoState(name NewState, name NewLabel)
{
	GotoState(NewState,NewLabel);
}

function AskForPawn()
{
	if ( IsInState('GameEnded') )
		ClientGotoState('GameEnded', 'Begin');
	else if ( Pawn != None )
		GivePawn(Pawn);
	else
	{
		bFrozen = false;
		ServerRestartPlayer();
	}
}

function GivePawn(Pawn NewPawn)
{
	if ( NewPawn == None )
		return;
	Pawn = NewPawn;
	NewPawn.Controller = self;
	ClientRestart(Pawn);
}

/* GetFacingDirection()
returns direction faced relative to movement dir
0 = forward
16384 = right
32768 = back
49152 = left
*/
function int GetFacingDirection()
{
	local vector X,Y,Z, Dir;

	GetAxes(Pawn.Rotation, X,Y,Z);
	Dir = Normal(Pawn.Acceleration);
	if ( Y Dot Dir > 0 )
		return ( 49152 + 16384 * (X Dot Dir) );
	else
		return ( 16384 - 16384 * (X Dot Dir) );
}

// Possess a Pawn
function Possess(Pawn aPawn)
{
    if ( PlayerReplicationInfo.bOnlySpectator )
		return;

	SetRotation(aPawn.Rotation);
	aPawn.PossessedBy(self);
	Pawn = aPawn;
	Pawn.bStasis = false;
    CleanOutSavedMoves();  // don't replay moves previous to possession
	PlayerReplicationInfo.bIsFemale = Pawn.bIsFemale;
	ServerSetHandedness(Handedness);
	Restart();
}

// unpossessed a Pawn (not because Pawn was killed)
function UnPossess()
{
	if ( Pawn != None )
	{
		SetLocation(Pawn.Location);
		Pawn.RemoteRole = ROLE_SimulatedProxy;
		Pawn.UnPossessed();
		CleanOutSavedMoves();  // don't replay moves previous to unpossession
		if ( Viewtarget == Pawn )
			SetViewTarget(self);
	}
	Pawn = None;
	if (Level.NetMode == NM_Standalone)
	{
		GotoState('');
	}
	else
	{
		GotoState('Spectating');
	}
}

function ViewNextBot()
{
	if ( CheatManager != None )
		CheatManager.ViewBot();
}

// unpossessed a Pawn (because Pawn was killed)
function PawnDied(Pawn P)
{
	if ( P != Pawn )
		return;
	EndZoom();
	if ( Pawn != None )
		Pawn.RemoteRole = ROLE_SimulatedProxy;
	if ( ViewTarget == Pawn )
		bBehindView = true;

    ServerStopForceFeedback();  // jdf

    Super.PawnDied(P);
}

function ClientSetHUD(class<HUD> newHUDType, class<Scoreboard> newScoringType)
{
	local HUD NewHUD;

	if ( (myHUD == None) || ((newHUDType != None) && (newHUDType != myHUD.Class)) )
	{
		NewHUD = spawn(newHUDType, self);
		if ( NewHUD != None )
		{
			if ( myHUD != None )
				myHUD.Destroy();
			myHUD = NewHUD;
		}
	}
	if ( (myHUD != None) && (newScoringType != None) )
		MyHUD.SpawnScoreBoard(newScoringType);
}

// jdf ---
// Server ignores this call, client plays effect
simulated function ClientPlayForceFeedback( String EffectName )
{
	if (!bEnableForceFeedback)
		return;

    if (bForceFeedbackSupported && Viewport(Player) != None)
        PlayFeedbackEffect( EffectName );
}

simulated function ClientStopForceFeedback( optional String EffectName )
{
	if (!bEnableForceFeedback)
		return;

    if (bForceFeedbackSupported && Viewport(Player) != None)
    {
		if (EffectName != "")
			StopFeedbackEffect( EffectName );
		else
			StopFeedbackEffect();
	}
}

// Server RPCs client, client plays effect
function ServerPlayForceFeedback( String EffectName )
{
	if (!bEnableForceFeedback)
		return;

    if (bForceFeedbackSupported && Viewport(Player) != None)
	    PlayFeedbackEffect( EffectName );
}

function ServerStopForceFeedback( optional String EffectName )
{
	if (!bEnableForceFeedback)
		return;

    if (bForceFeedbackSupported && Viewport(Player) != None)
    {
		if (EffectName != "")
			StopFeedbackEffect( EffectName );
		else
			StopFeedbackEffect();
	}
}
// --- jdf

function HandlePickup(Pickup pick, optional int Amount)
{
    // jdf ---
    if( bEnablePickupForceFeedback )
        ServerPlayForceFeedback( pick.PickupForce );
    // --- jdf

	if (pick.bDisplayPickupMessage)
	{
		ReceiveLocalizedMessage( pick.MessageClass, Amount, None, None, pick.Class );
	}
}

final function float UpdateFlashComponent(float current, float Step, float goal)
{
	if ( goal > current )
		return FMin(current + Step, goal);
	else
		return FMax(current - Step, goal);
}

function ViewFlash(float DeltaTime)
{
    local vector goalFog;
    local float goalscale, delta, Step;

    delta = FMin(0.1, DeltaTime);
    goalScale = 1; // + ConstantGlowScale;
    goalFog = vect(0,0,0); // ConstantGlowFog;

    if ( Pawn != None )
    {
        goalScale += Pawn.HeadVolume.ViewFlash.X;
        goalFog += Pawn.HeadVolume.ViewFog;
    }
	Step = 0.6 * delta;
	FlashScale.X = UpdateFlashComponent(FlashScale.X,step,goalScale);
    FlashScale = FlashScale.X * vect(1,1,1);

	FlashFog.X = UpdateFlashComponent(FlashFog.X,step,goalFog.X);
	FlashFog.Y = UpdateFlashComponent(FlashFog.Y,step,goalFog.Y);
	FlashFog.Z = UpdateFlashComponent(FlashFog.Z,step,goalFog.Z);
}

simulated event ReceiveLocalizedMessage( class<LocalMessage> Message, optional int Switch, optional PlayerReplicationInfo RelatedPRI_1, optional PlayerReplicationInfo RelatedPRI_2, optional Object OptionalObject )
{
	Message.Static.ClientReceive( Self, Switch, RelatedPRI_1, RelatedPRI_2, OptionalObject );
	if ( Message.default.bIsConsoleMessage && (Player != None) && (Player.Console != None) )
		Player.Console.Message(Message.Static.GetString(Switch, RelatedPRI_1, RelatedPRI_2, OptionalObject),0 );
}

simulated event ReceiveObjectiveUpdate( class<Info> Objective, Name szObjectiveTag, EObjectiveComplete nStatus, int nObjectiveIdx, bool bDisplayMessage, float flLifeTime, optional PlayerReplicationInfo RelatedPRI_1, optional PlayerReplicationInfo RelatedPRI_2 )
{
	Objective.Static.ClientReceiveObjective( self, szObjectiveTag, nStatus, nObjectiveIdx, bDisplayMessage, flLifeTime, RelatedPRI_1, RelatedPRI_2 );
}

event ClientMessage( coerce string S, optional Name Type )
{
	if (Type == '')
		Type = 'Event';

	TeamMessage(PlayerReplicationInfo, S, Type);
}

event TeamMessage( PlayerReplicationInfo PRI, coerce string S, name Type  )
{
	if ( myHUD != None )
	myHUD.Message( PRI, S, Type );

    if ( ((Type == 'Say') || (Type == 'TeamSay')) && (PRI != None) )
	{
		// Don't munge the name into the message yet, so that the GUI can do as it sees fit
		GetGUIController().ChatMessageReceived(PRI, S);

		S = PRI.PlayerName$": "$S;
	}

    Player.Console.Message( S, 6.0 );
}

simulated function PlayBeepSound();

simulated function PlayAnnouncement(sound ASound, byte AnnouncementLevel, optional bool bForce)
{
	local float Atten;

	if ( AnnouncementLevel > AnnouncerLevel )
		return;
	if ( !bForce && (Level.TimeSeconds - LastPlaySound < 1) )
		return;
	LastPlaySound = Level.TimeSeconds;	// so voice messages won't overlap
	LastPlaySpeech = Level.TimeSeconds;	// don't want chatter to overlap announcements

	Atten = FClamp(0.1 + float(AnnouncerVolume)*0.225,0.2,1.0);
	ClientPlaySound(ASound,true,Atten,SLOT_Talk);
}

function bool AllowVoiceMessage(name MessageType)
{
	if ( Level.NetMode == NM_Standalone )
		return true;

	if ( Level.TimeSeconds - OldMessageTime < 3 )
	{
		if ( (MessageType == 'TAUNT') || (MessageType == 'AUTOTAUNT') )
			return false;
		if ( Level.TimeSeconds - OldMessageTime < 1 )
			return false;
	}
	if ( Level.TimeSeconds - OldMessageTime < 6 )
		OldMessageTime = Level.TimeSeconds + 3;
	else
		OldMessageTime = Level.TimeSeconds;
	return true;
}

//Play a sound client side (so only client will hear it
simulated function ClientPlaySound(sound ASound, optional bool bVolumeControl, optional float inAtten, optional ESoundSlot slot )
{
    local float atten;

    atten = 0.9;
    if( bVolumeControl )
        atten = FClamp(inAtten,0,1);

	if ( ViewTarget != None )
		ViewTarget.PlaySound(ASound, slot, atten,,,,false);
}

simulated function ClientReliablePlaySound(sound ASound, optional bool bVolumeControl )
{
	ClientPlaySound(ASound, bVolumeControl);
}

simulated function int ClientPlaySoundForPawn(
	Pawn				Pawn,
	sound				Sound,
	optional ESoundSlot Slot,
	optional float		Volume,
	optional bool		bNoOverride,
	optional float		Radius,
	optional float		Pitch,
	optional bool		Attenuate,
	optional bool		bLipSync
)
{
	if (Pawn != None)
	{
		return Pawn.PlaySound(Sound, Slot, Volume, bNoOverride, Radius, Pitch, Attenuate, bLipSync);
	}
}

simulated event Destroyed()
{
	local SavedMove Next;
    local Vehicle DrivenVehicle;
	local Pawn Driver;

	// cheatmanager, adminmanager, and playerinput cleaned up in C++ PostScriptDestroyed()

    ClientStopForceFeedback();  // jdf

	if ( Pawn != None )
	{
		// If its a vehicle, just destroy the driver, otherwise do the normal.
        DrivenVehicle = Vehicle(Pawn);
		if( DrivenVehicle != None )
		{
			Driver = DrivenVehicle.Driver;
			DrivenVehicle.KDriverLeave(true); // Force the driver out of the car
			if ( Driver != None )
			{
				Driver.Health = 0;
				Driver.Died( self, class'Suicided', Driver.Location );
			}
		}
		else
		{
			Pawn.Health = 0;
			Pawn.Died( self, class'Suicided', Pawn.Location );
        }
	}

	myHud.Destroy();

	while ( FreeMoves != None )
	{
		Next = FreeMoves.NextMove;
		FreeMoves.Destroy();
		FreeMoves = Next;
	}
	while ( SavedMoves != None )
	{
		Next = SavedMoves.NextMove;
		SavedMoves.Destroy();
		SavedMoves = Next;
	}

    if( PlayerSecurity != None )
    {
        PlayerSecurity.Destroy();
        PlayerSecurity = None;
    }

	RemovePlayerController();
	
    Super.Destroyed();
}

function ClientSetMusic( string NewSong, EMusicTransition NewTransition )
{
    if( IsSharingScreen() || ( Player.SplitIndex != 0 ) )
        return;

	StopAllMusic( 0.0 );
	PlayMusic( NewSong, 3.0 );
	Song        = NewSong;
	Transition  = NewTransition;
}

// ------------------------------------------------------------------------
// Zooming/FOV change functions

function ToggleZoom()
{
	if ( IsZoomed() )
		EndZoom();
	else
		StartZoom();
}

function StartZoom()
{
	ZoomLevel = 0.0;
	bZooming = true;
}

function StopZoom()
{
	bZooming = false;
}

function EndZoom()
{
	bZooming = false;
	DesiredFOV = DefaultFOV;
}

event bool IsZoomed()
{
	return DesiredFOV < DefaultFOV;
}

// GBX:PAD: I'm putting this here so that some player operations (e.g. command ring mode) can disable the crosshair.
simulated function bool DisableCrosshair()
{
	return false;
}

function FixFOV()
{
	FOVAngle = Default.DefaultFOV;
	DesiredFOV = Default.DefaultFOV;
	DefaultFOV = Default.DefaultFOV;
}

function SetFOV(float NewFOV)
{
	DesiredFOV = NewFOV;
	FOVAngle = NewFOV;
}

function ResetFOV()
{
	DesiredFOV = DefaultFOV;
	FOVAngle = DefaultFOV;
}

exec function FOV(float F)
{
	if( (F >= 80.0) || (Level.Netmode==NM_Standalone) )
	{
		DefaultFOV = FClamp(F, 1, 170);
		DesiredFOV = DefaultFOV;
		SaveConfig();
	}
}

exec function Mutate(string MutateString)
{
	if( Level.NetMode == NM_Client )
		return;
	Level.Game.BaseMutator.Mutate(MutateString, Self);
}

exec function SetSensitivity(float F)
{
	PlayerInput.UpdateSensitivity(F);
}

exec function SetMouseSmoothing( int Mode )
{
    PlayerInput.UpdateSmoothing( Mode );
}

exec function SetMouseAccel(float F)
{
	PlayerInput.UpdateAccel(F);
}

exec function ForceReload()
{
	if ( (Pawn != None) && (Pawn.Weapon != None) )
	{
		Pawn.Weapon.ForceReload();
	}
}

// ------------------------------------------------------------------------
// Messaging functions

// Put all the rules for filtering out messages here (blank messages, etc...)
simulated function bool ShouldFilterOutMessage(string Msg)
{
	local bool FilterOut;

	if (Msg == "")
	{
		FilterOut = true;
	}

	return FilterOut;
}

// Send a message to all players.
function ServerSay( string Msg )
{
	if (PlayerReplicationInfo.bAdmin && left(Msg,1) == "#" )
	{
		Level.Game.AdminSay(right(Msg,len(Msg)-1));
		return;
	}
	Level.Game.Broadcast(self, Msg, 'Say');
}

exec function Say( string Msg )
{
	if (!ShouldFilterOutMessage(Msg))
	{
		ServerSay(Msg);
	}
}

function ServerTeamSay( string Msg )
{
	if( !GameReplicationInfo.bTeamGame )
	{
		ServerSay( Msg );
		return;
	}

    Level.Game.BroadcastTeam( self, Level.Game.ParseMessageString( Level.Game.BaseMutator , self, Msg ) , 'TeamSay');
}

exec function TeamSay( string Msg )
{
	if (!ShouldFilterOutMessage(Msg))
	{
		ServerTeamSay(Msg);
	}
}

// ------------------------------------------------------------------------

function ServerSetHandedness( float hand)
{
	Handedness = hand;
    if ( (Pawn != None) && (Pawn.Weapon != None) )
		Pawn.Weapon.SetHand(Handedness);
}

function SetHand(int IntValue)
{
    class'PlayerController'.default.Handedness = IntValue;
    class'PlayerController'.static.StaticSaveConfig();
    Handedness = IntValue;
    if( (Pawn != None) && (Pawn.Weapon != None) )
	Pawn.Weapon.SetHand(Handedness);

	ServerSetHandedness(Handedness);
}

exec function SetWeaponHand ( string S )
{
	if ( S ~= "Left" )
		Handedness = -1;
	else if ( S~= "Right" )
		Handedness = 1;
	else if ( S ~= "Center" )
		Handedness = 0;
	else if ( S ~= "Hidden" )
		Handedness = 2;
    SetHand(Handedness);
}

function bool IsDead()
{
	return false;
}

exec function ShowGun ()
{
    if( Handedness == 2 )
        Handedness = 1;
    else
        Handedness = 2;

    SetHand(Handedness);
}

exec function ShowPathNodes()
{
	ConsoleCommand( "SHOW PATHNODES" );
}

exec function ShowCoverLines()
{
	ConsoleCommand( "SHOW COVERLINES" );
}

function ServerServer( string Msg )
{
	local class<actor> NewClass;
	local vector SpawnLoc;
	local string ClassName;
	local name EventName;
	local Actor other, first;
	local bool bFound;
	local class<actor> aClass;

	if (Left(Msg, 11) ~= "causeevent ")
	{
		EventName = FindNameFromString(Right(Msg, Len(Msg)-11));
		TriggerEvent( EventName, Pawn, Pawn);
		return;
	}

	if (Left(Msg, 7) ~= "summon ")
	{
		ClassName = Right(Msg, Len(Msg)-7);
		NewClass = class<actor>( DynamicLoadObject( ClassName, class'Class' ) );
		if( NewClass!=None )
		{
			if ( Pawn != None )
				SpawnLoc = Pawn.Location;
			else
				SpawnLoc = Location;
			Spawn( NewClass,,,SpawnLoc + 72 * Vector(Rotation) + vect(0,0,1) * 15 );
		}
		return;
	}

	if (Msg ~= "fly")
	{
		if ( Pawn == None )
			return;
		Pawn.UnderWaterTime = Pawn.Default.UnderWaterTime;
		ClientMessage("You feel much lighter");
		Pawn.SetCollision(true, true , true);
		Pawn.bCollideWorld = true;
		bCheatFlying = true;
		GotoState('PlayerFlying');
		return;
	}

	if (Msg ~= "walk")
	{
		if ( Pawn == None )
			return;
		bCheatFlying = false;
		Pawn.UnderWaterTime = Pawn.Default.UnderWaterTime;
		Pawn.SetCollision(true, true , true);
		if (Pawn.bUseRootMotion)
			Pawn.SetPhysics(PHYS_RootMotion);
		else
			Pawn.SetPhysics(PHYS_Walking);
		Pawn.bCollideWorld = true;
		ClientReStart(Pawn);
		return;
	}

	if (Msg ~= "ghost")
	{
		if( Pawn != None && !Pawn.IsA('Vehicle') )
		{
			Pawn.UnderWaterTime = -1.0;
			ClientMessage("You feel ethereal");
			Pawn.SetCollision(false, false, false);
			Pawn.bCollideWorld = false;
			bCheatFlying = true;
			GotoState('PlayerFlying');
		}
		else
			Log("Can't Ghost In Vehicles");
		return;
	}

	if (Msg ~= "god")
	{
		if ( bGodMode )
		{
			bGodMode = false;
			ClientMessage("God mode off");
			return;
		}

		bGodMode = true;
		ClientMessage("God Mode on");
		return;
	}

	if (Msg ~= "godallies")
	{
		if ( bGodAllies )
		{
			bGodAllies = false;
			ClientMessage("God allies mode off");
			return;
		}

		bGodAllies = true;
		ClientMessage("God allies Mode on");
		return;
	}

	if (Left(Msg, 6) ~= "slomo ")
	{
		Level.Game.SetGameSpeed(float(Right(Msg, Len(Msg)-6)));
		Level.Game.SaveConfig();
		Level.Game.GameReplicationInfo.SaveConfig();
		return;
	}

	if (Msg ~= "playersonly")
	{
		Level.bPlayersOnly = !Level.bPlayersOnly;
		return;
	}

	if (Msg ~= "bfg")
	{
		Level.bWeaponsAreBFG = !Level.bWeaponsAreBFG;
		return;
	}

	if (Msg ~= "viewteam")
	{
		Msg = "ViewClass Pawn";
		// don't return here!!!
	}

	if (Left(Msg, 10) ~= "viewclass ")  // this code doesn't seem to work!  FIXME!!!
	{
		aClass = FindClassFromString(Right(Msg, Len(Msg)-10));

		if (aClass == None)
			return;

		first = None;

		ForEach AllActors( aClass, other )
		{
			if ( bFound || (first == None) )
			{
				first = other;
				if ( bFound )
					break;
			}
			if ( other == ViewTarget )
				bFound = true;
		}

		if ( first != None )
		{
			if ( Pawn(first) != None )
				ClientMessage(ViewingFrom@First.GetHumanReadableName(), 'Event');
			else
				ClientMessage(ViewingFrom@first, 'Event');

			SetViewTarget(first);
			bBehindView = ( ViewTarget != self );

			if ( bBehindView )
				ViewTarget.BecomeViewTarget();

			FixFOV();
		}
		else
		{
			if ( !Pawn.bIsManningTurret )
				bBehindView = false;

			bViewBot = false;
			if ( Pawn != None )
				SetViewTarget(Pawn);
			else
				SetViewTarget(self);

			ClientMessage(OwnCamera, 'Event');
			FixFOV();
		}
	}

	if (Msg ~= "viewself")
	{
		if ( !Pawn.bIsManningTurret )
			bBehindView = false;

		bViewBot = false;
		if ( Pawn != None )
			SetViewTarget(Pawn);
		else
			SetViewtarget(self);

		ClientMessage(OwnCamera, 'Event');
		FixFOV();
	}

	// if all else fails, issue it as a console command...
	ConsoleCommand( Msg );
}

exec function Server( string Msg )
{
	local int bIsNotShipBuild;

	bIsNotShipBuild = 0;
	IsNotShipBuild(bIsNotShipBuild);

	// if not a ship build OR (if skirmish game and bCheatsEnabled)...
	if ( (bIsNotShipBuild == 1) ||
		((GameReplicationInfo.GameType == GT_SKIRMISH) && Level.Game.bCheatsEnabled))
	{
		ServerServer(Msg);
	}
}

event PreClientTravel()
{
    log("PreClientTravel");
	ConsoleCommand( "FULLSCREENVIEWPORT 0" );
    ServerStopForceFeedback();  // jdf
}

function ClientSetFixedCamera(bool B)
{
	bFixedCamera = B;
}

function ClientSetBehindView(bool B)
{
	bBehindView = B;

    if (Vehicle(Pawn) != None)
    {
    	Vehicle(Pawn).bDesiredBehindView = B;
    	Pawn.SaveConfig();
    }
}

function ClientVoiceMessage(PlayerReplicationInfo Sender, PlayerReplicationInfo Recipient, name messagetype, byte messageID)
{
	local VoicePack V;

	if ( (Sender == None) || (Sender.VoiceType == None) || (Player.Console == None) )
		return;

	V = Spawn(Sender.VoiceType, self);
	if ( V != None )
		V.ClientInitialize(Sender, Recipient, messagetype, messageID);
}

/* ForceDeathUpdate()
Make sure ClientAdjustPosition immediately informs client of Pawn's death
*/
function ForceDeathUpdate()
{
	LastUpdateTime = Level.TimeSeconds - 10;
}

/* RocketServerMove()
compressed version of server move for PlayerRocketing state
*/
function RocketServerMove
(
	float TimeStamp,
	vector InAccel,
	vector ClientLoc,
	byte ClientRoll,
	int View
)
{
	ServerMove(TimeStamp,InAccel,ClientLoc,false,false,false,false, DCLICK_NONE,ClientRoll,View);
}

function ServerMoveFrequent // sjs
(
    float TimeStamp,
    vector InAccel,
    vector ClientLoc,
    byte ClientRoll,
    int View,
    byte OldTimeDelta,
    int OldAccel
)
{
	ServerMove(TimeStamp,InAccel,ClientLoc,false,false,false,false,DCLICK_None,ClientRoll,View,OldTimeDelta,OldAccel);
}

function ServerMoveNoDelta // sjs
(
    float TimeStamp,
    vector InAccel,
    vector ClientLoc,
    byte ClientRoll,
    int View
)
{
	ServerMove(TimeStamp,InAccel,ClientLoc,false,false,true,false,DCLICK_None,ClientRoll,View);
}

/* ShortServerMove()
compressed version of server move for bandwidth saving
*/
function ShortServerMove
(
	float TimeStamp,
	vector ClientLoc,
	bool NewbRun,
	bool NewbDuck,
	bool NewbJumpStatus,
	byte ClientRoll,
	int View
)
{
	ServerMove(TimeStamp,vect(0,0,0),ClientLoc,NewbRun,NewbDuck,NewbJumpStatus,false,DCLICK_None,ClientRoll,View);
}

/* ServerMove()
- replicated function sent by client to server - contains client movement and firing info
Passes acceleration in components so it doesn't get rounded.
*/
function ServerMove
(
	float TimeStamp,
	vector InAccel,
	vector ClientLoc,
	bool NewbRun,
	bool NewbDuck,
	bool NewbJumpStatus,
    bool NewbDoubleJump,
	eDoubleClickDir DoubleClickMove,
	byte ClientRoll,
	int View,
	optional byte OldTimeDelta,
	optional int OldAccel
)
{
	local float DeltaTime, clientErr, OldTimeStamp;
	local rotator DeltaRot, Rot, ViewRot;
	local vector Accel, LocDiff, ClientVel, ClientFloor;
	local int maxPitch, ViewPitch, ViewYaw;
    local bool NewbPressedJump, OldbRun, OldbDoubleJump;
	local eDoubleClickDir OldDoubleClickMove;
	local actor ClientBase;
	local ePhysics ClientPhysics;


	// If this move is outdated, discard it.
	if ( CurrentTimeStamp >= TimeStamp )
		return;

	// if OldTimeDelta corresponds to a lost packet, process it first
	if (  OldTimeDelta != 0 )
	{
		OldTimeStamp = TimeStamp - float(OldTimeDelta)/500 - 0.001;
		if ( CurrentTimeStamp < OldTimeStamp - 0.001 )
		{
			// split out components of lost move (approx)
			Accel.X = OldAccel >>> 23;
			if ( Accel.X > 127 )
				Accel.X = -1 * (Accel.X - 128);
			Accel.Y = (OldAccel >>> 15) & 255;
			if ( Accel.Y > 127 )
				Accel.Y = -1 * (Accel.Y - 128);
			Accel.Z = (OldAccel >>> 7) & 255;
			if ( Accel.Z > 127 )
				Accel.Z = -1 * (Accel.Z - 128);
			Accel *= 20;

			OldbRun = ( (OldAccel & 64) != 0 );
            OldbDoubleJump = ( (OldAccel & 32) != 0 );
			NewbPressedJump = ( (OldAccel & 16) != 0 );
			if ( NewbPressedJump )
				bJumpStatus = NewbJumpStatus;
			switch (OldAccel & 7)
			{
				case 0:
					OldDoubleClickMove = DCLICK_None;
					break;
				case 1:
					OldDoubleClickMove = DCLICK_Left;
					break;
				case 2:
					OldDoubleClickMove = DCLICK_Right;
					break;
				case 3:
					OldDoubleClickMove = DCLICK_Forward;
					break;
				case 4:
					OldDoubleClickMove = DCLICK_Back;
					break;
			}
			//log("Recovered move from "$OldTimeStamp$" acceleration "$Accel$" from "$OldAccel);
            OldTimeStamp = FMin(OldTimeStamp, CurrentTimeStamp + MaxResponseTime);
            MoveAutonomous(OldTimeStamp - CurrentTimeStamp, OldbRun, (bDuck == 1), NewbPressedJump, OldbDoubleJump, OldDoubleClickMove, Accel, rot(0,0,0));
			CurrentTimeStamp = OldTimeStamp;
		}
	}

	// View components
	ViewPitch = View/32768;
	ViewYaw = 2 * (View - 32768 * ViewPitch);
	ViewPitch *= 2;
	// Make acceleration.
	Accel = InAccel/10;

	NewbPressedJump = (bJumpStatus != NewbJumpStatus);
	bJumpStatus = NewbJumpStatus;

	// Save move parameters.
    DeltaTime = FMin(MaxResponseTime,TimeStamp - CurrentTimeStamp);

	if ( ServerTimeStamp > 0 )
	{
		// allow 1% error
        TimeMargin = FMax(0,TimeMargin + DeltaTime - 1.01 * (Level.TimeSeconds - ServerTimeStamp));
		if ( TimeMargin > MaxTimeMargin )
		{
			// player is too far ahead
			TimeMargin -= DeltaTime;
			if ( TimeMargin < 0.5 )
				MaxTimeMargin = Default.MaxTimeMargin;
			else
				MaxTimeMargin = 0.5;
			DeltaTime = 0;
		}
	}

	CurrentTimeStamp = TimeStamp;
	ServerTimeStamp = Level.TimeSeconds;
	ViewRot.Pitch = ViewPitch;
	ViewRot.Yaw = ViewYaw;
	ViewRot.Roll = 0;
	SetRotation(ViewRot);

	if ( Pawn != None )
	{
		Rot.Roll = 256 * ClientRoll;
		Rot.Yaw = ViewYaw;
		if ( (Pawn.Physics == PHYS_Swimming) || (Pawn.Physics == PHYS_Flying) )
			maxPitch = 2;
		else
            maxPitch = 0;
		If ( (ViewPitch > maxPitch * RotationRate.Pitch) && (ViewPitch < 65536 - maxPitch * RotationRate.Pitch) )
		{
			If (ViewPitch < 32768)
				Rot.Pitch = maxPitch * RotationRate.Pitch;
			else
				Rot.Pitch = 65536 - maxPitch * RotationRate.Pitch;
		}
		else
			Rot.Pitch = ViewPitch;
		DeltaRot = (Rotation - Rot);
		Pawn.SetRotation(Rot);
	}

    // Perform actual movement
	if ( (!Level.IsPaused() ) && (DeltaTime > 0) )
		MoveAutonomous(DeltaTime, NewbRun, NewbDuck, NewbPressedJump, NewbDoubleJump, DoubleClickMove, Accel, DeltaRot);

	// Accumulate movement error.
	if ( Level.TimeSeconds - LastUpdateTime > 0.3 )
		ClientErr = 10000;
	else if ( Level.TimeSeconds - LastUpdateTime > 180.0/Player.CurrentNetSpeed )
	{
		if ( Pawn == None )
			LocDiff = Location - ClientLoc;
		else
			LocDiff = Pawn.Location - ClientLoc;
		ClientErr = LocDiff Dot LocDiff;
	}

	// If client has accumulated a noticeable positional error, correct him.
	if ( ClientErr > 3 )
	{
		if ( Pawn == None )
		{
			ClientPhysics = Physics;
			ClientLoc = Location;
			ClientVel = Velocity;
		}
		else
		{
			ClientPhysics = Pawn.Physics;
			ClientVel = Pawn.Velocity;
			ClientBase = Pawn.Base;
            if ( (Mover(Pawn.Base) != None) || (Vehicle(Pawn.Base) != None) )
				ClientLoc = Pawn.Location - Pawn.Base.Location;
			else
				ClientLoc = Pawn.Location;
			ClientFloor = Pawn.Floor;
		}
		//	log(Level.TimeSeconds$" Client Error at "$TimeStamp$" is "$ClientErr$" with acceleration "$Accel$" LocDiff "$LocDiff$" Physics "$Pawn.Physics);
		LastUpdateTime = Level.TimeSeconds;

		if ( (Pawn == None) || (Pawn.Physics != PHYS_Spider) )
		{
			if ( ClientVel == vect(0,0,0) )
			{
					ShortClientAdjustPosition
					(
						TimeStamp,
						GetStateName(),
						ClientPhysics,
						ClientLoc.X,
						ClientLoc.Y,
						ClientLoc.Z,
						ClientBase
					);
			}
			else
				ClientAdjustPosition
				(
					TimeStamp,
					GetStateName(),
					ClientPhysics,
					ClientLoc.X,
					ClientLoc.Y,
					ClientLoc.Z,
					ClientVel.X,
					ClientVel.Y,
					ClientVel.Z,
					ClientBase
				);
		}
		else
			LongClientAdjustPosition
			(
				TimeStamp,
				GetStateName(),
				ClientPhysics,
				ClientLoc.X,
				ClientLoc.Y,
				ClientLoc.Z,
				ClientVel.X,
				ClientVel.Y,
				ClientVel.Z,
				ClientBase,
				ClientFloor.X,
				ClientFloor.Y,
				ClientFloor.Z
			);
	}
	//log("Server moved stamp "$TimeStamp$" location "$Pawn.Location$" Acceleration "$Pawn.Acceleration$" Velocity "$Pawn.Velocity);
}

// Only executed on server
function ServerDrive(float InForward, float InStrafe, float aUp, bool InJump, int View)
{
    local rotator ViewRotation;

    // Added to handle setting of the correct ViewRotation on the server in network games --Dave@Psyonix
    ViewRotation.Pitch = View/32768;
    ViewRotation.Yaw = 2 * (View - 32768 * ViewRotation.Pitch);
    ViewRotation.Pitch *= 2;
    ViewRotation.Roll = 0;
    SetRotation(ViewRotation);

    ProcessDrive(InForward, InStrafe, aUp, InJump);
}

function ProcessDrive(float InForward, float InStrafe, float InUp, bool InJump)
{
	ClientGotoState(GetStateName(), 'Begin');
}

function ProcessMove ( float DeltaTime, vector newAccel, eDoubleClickDir DoubleClickMove, rotator DeltaRot)
{
	if ( Pawn != None )
		Pawn.Acceleration = newAccel;
}

final function MoveAutonomous
(
	float DeltaTime,
	bool NewbRun,
	bool NewbDuck,
	bool NewbPressedJump,
    bool NewbDoubleJump,
	eDoubleClickDir DoubleClickMove,
	vector newAccel,
	rotator DeltaRot
)
{
	if ( NewbRun )
		bRun = 1;
	else
		bRun = 0;

	if ( NewbDuck )
		bDuck = 1;
	else
		bDuck = 0;
	bPressedJump = NewbPressedJump;
    bDoubleJump = NewbDoubleJump;
	HandleWalking();
	ProcessMove(DeltaTime, newAccel, DoubleClickMove, DeltaRot);
	if ( Pawn != None )
		Pawn.AutonomousPhysics(DeltaTime);
	else
		AutonomousPhysics(DeltaTime);
    bDoubleJump = false;
	//log("Role "$Role$" moveauto time "$100 * DeltaTime$" ("$Level.TimeDilation$")");
}

/* VeryShortClientAdjustPosition
bandwidth saving version, when velocity is zeroed, and Pawn is walking
*/
function VeryShortClientAdjustPosition
(
	float TimeStamp,
	float NewLocX,
	float NewLocY,
	float NewLocZ,
	Actor NewBase
)
{
	local vector Floor;

	if ( Pawn != None )
		Floor = Pawn.Floor;
	LongClientAdjustPosition(TimeStamp,'PlayerWalking',PHYS_Walking,NewLocX,NewLocY,NewLocZ,0,0,0,NewBase,Floor.X,Floor.Y,Floor.Z);
}

/* ShortClientAdjustPosition
bandwidth saving version, when velocity is zeroed
*/
function ShortClientAdjustPosition
(
	float TimeStamp,
	name newState,
	EPhysics newPhysics,
	float NewLocX,
	float NewLocY,
	float NewLocZ,
	Actor NewBase
)
{
	local vector Floor;

	if ( Pawn != None )
		Floor = Pawn.Floor;
	LongClientAdjustPosition(TimeStamp,newState,newPhysics,NewLocX,NewLocY,NewLocZ,0,0,0,NewBase,Floor.X,Floor.Y,Floor.Z);
}

/* ClientAdjustPosition
- pass newloc and newvel in components so they don't get rounded
*/
function ClientAdjustPosition
(
	float TimeStamp,
	name newState,
	EPhysics newPhysics,
	float NewLocX,
	float NewLocY,
	float NewLocZ,
	float NewVelX,
	float NewVelY,
	float NewVelZ,
	Actor NewBase
)
{
	local vector Floor;

	if ( Pawn != None )
		Floor = Pawn.Floor;
	LongClientAdjustPosition(TimeStamp,newState,newPhysics,NewLocX,NewLocY,NewLocZ,NewVelX,NewVelY,NewVelZ,NewBase,Floor.X,Floor.Y,Floor.Z);
}

/* LongClientAdjustPosition
long version, when care about Pawn's floor normal
*/
function LongClientAdjustPosition
(
	float TimeStamp,
	name newState,
	EPhysics newPhysics,
	float NewLocX,
	float NewLocY,
	float NewLocZ,
	float NewVelX,
	float NewVelY,
	float NewVelZ,
	Actor NewBase,
	float NewFloorX,
	float NewFloorY,
	float NewFloorZ
)
{
    local vector NewLocation, NewVelocity, NewFloor;
	local Actor MoveActor;
    local SavedMove CurrentMove;

	// update ping
	if ( (PlayerReplicationInfo != None) && !bDemoOwner )
	{
		if ( ExactPing < 0.006 )
			ExactPing = Level.TimeSeconds - TimeStamp;
		else
			ExactPing = 0.99 * ExactPing + 0.008 * (Level.TimeSeconds - TimeStamp); // placebo effect
		PlayerReplicationInfo.Ping = 1000 * ExactPing;

		if ( Level.TimeSeconds - LastPingUpdate > 4 )
		{
			if ( bDynamicNetSpeed && (OldPing > DynamicPingThreshold * 0.001) && (ExactPing > DynamicPingThreshold * 0.001) )
			{
				if ( Player.CurrentNetSpeed > 5000 )
					SetNetSpeed(5000);
				else if ( Level.MoveRepSize < 80 )
					Level.MoveRepSize += 8;
				else if ( Player.CurrentNetSpeed > 4000 )
					SetNetSpeed(4000);
				OldPing = 0;
			}
			else
				OldPing = ExactPing;
			LastPingUpdate = Level.TimeSeconds;
			ServerUpdatePing(1000 * ExactPing);
		}
	}
	if ( Pawn != None )
	{
		if ( Pawn.bTearOff )
		{
			Pawn = None;
			if ( !IsInState('GameEnded') && !IsInState('Dead') )
			{
			GotoState('Dead');
            }
			return;
		}
		MoveActor = Pawn;
        if ( (ViewTarget != Pawn)
			&& ((ViewTarget == self) || ((Pawn(ViewTarget) != None) && (Pawn(ViewTarget).Health <= 0))) )
		{
			bBehindView = false;
			SetViewTarget(Pawn);
		}
	}
	else
    {
		MoveActor = self;
 	   	if( GetStateName() != newstate )
		{
		    if ( NewState == 'GameEnded' )
			    GotoState(NewState);
			else if ( IsInState('Dead') )
			{
				if ( (NewState != 'PlayerWalking') && (NewState != 'PlayerSwimming') )
		        {
				    GotoState(NewState);
		        }
		        return;
			}
			else if ( NewState == 'Dead' )
				GotoState(NewState);
		}
	}
    if ( CurrentTimeStamp >= TimeStamp )
		return;
	CurrentTimeStamp = TimeStamp;

	NewLocation.X = NewLocX;
	NewLocation.Y = NewLocY;
	NewLocation.Z = NewLocZ;
    NewVelocity.X = NewVelX;
    NewVelocity.Y = NewVelY;
    NewVelocity.Z = NewVelZ;

	// skip update if no error
    CurrentMove = SavedMoves;
    while ( CurrentMove != None )
    {
        if ( CurrentMove.TimeStamp <= CurrentTimeStamp )
        {
            SavedMoves = CurrentMove.NextMove;
            CurrentMove.NextMove = FreeMoves;
            FreeMoves = CurrentMove;
			if ( CurrentMove.TimeStamp == CurrentTimeStamp )
			{
				FreeMoves.Clear();
				if ( (VSize(CurrentMove.SavedLocation - NewLocation) < 3)
					&& (VSize(CurrentMove.SavedVelocity - NewVelocity) < 3)
					&& (GetStateName() == NewState)
					&& ((MoveActor.Physics != PHYS_Flying) || !IsInState('PlayerWalking')) )
				{
					return;
				}
				CurrentMove = None;
			}
			else
			{
				FreeMoves.Clear();
				CurrentMove = SavedMoves;
			}
        }
        else
			CurrentMove = None;
    }

	NewFloor.X = NewFloorX;
	NewFloor.Y = NewFloorY;
	NewFloor.Z = NewFloorZ;
	MoveActor.SetBase(NewBase, NewFloor);
	if ( (Mover(NewBase) != None) || (Vehicle(NewBase) != None) )
		NewLocation += NewBase.Location;

	if ( !bDemoOwner )
	{
		//log("Client "$Role$" adjust "$self$" stamp "$TimeStamp$" location "$MoveActor.Location);
		MoveActor.bCanTeleport = false;
	    if ( !MoveActor.SetLocation(NewLocation) && (Pawn(MoveActor) != None)
			&& (MoveActor.CollisionHeight > Pawn(MoveActor).CrouchHeight)
			&& !Pawn(MoveActor).bIsCrouched
			&& (newPhysics == PHYS_Walking)
			&& (MoveActor.Physics != PHYS_Karma) && (MoveActor.Physics != PHYS_KarmaRagDoll) )
		{
			MoveActor.SetPhysics(newPhysics);
			Pawn(MoveActor).ForceCrouch();
			MoveActor.SetLocation(NewLocation);
		}
		MoveActor.bCanTeleport = true;
	}
	// Hack. Don't let network change physics mode of karma stuff on the client.
	if( MoveActor.Physics != PHYS_Karma && MoveActor.Physics != PHYS_KarmaRagDoll &&
		newPhysics != PHYS_Karma && newPhysics != PHYS_KarmaRagDoll )
	{
		MoveActor.SetPhysics(newPhysics);
	}

    MoveActor.Velocity = NewVelocity;

	if( GetStateName() != newstate )
		GotoState(newstate);

	bUpdatePosition = true;
}

function ServerUpdatePing(int NewPing)
{
	PlayerReplicationInfo.Ping = NewPing;
	PlayerReplicationInfo.bReceivedPing = true;
}

function ClientUpdatePosition()
{
	local SavedMove CurrentMove;
	local int realbRun, realbDuck;
	local bool realbWantsToCrouch, realbNextCrouchState;
	local bool bRealJump;

	// Dont do any network position updates on things running PHYS_Karma
	if( Pawn != None && (Pawn.Physics == PHYS_Karma || Pawn.Physics == PHYS_KarmaRagDoll) )
		return;

	bUpdatePosition = false;
	realbRun= bRun;
	realbDuck = bDuck;
	realbWantsToCrouch = Pawn.bWantsToCrouch;
	realbNextCrouchState = Pawn.bNextCrouchState;
	bRealJump = bPressedJump;
	CurrentMove = SavedMoves;
	bUpdating = true;
	while ( CurrentMove != None )
	{
		if ( CurrentMove.TimeStamp <= CurrentTimeStamp )
		{
			SavedMoves = CurrentMove.NextMove;
			CurrentMove.NextMove = FreeMoves;
			FreeMoves = CurrentMove;
			FreeMoves.Clear();
			CurrentMove = SavedMoves;
		}
		else
		{
			Pawn.bWantsToCrouch = CurrentMove.bWantsToCrouch;
			Pawn.bNextCrouchState = CurrentMove.bNextCrouchState;
            MoveAutonomous(CurrentMove.Delta, CurrentMove.bRun, CurrentMove.bDuck, CurrentMove.bPressedJump, CurrentMove.bDoubleJump, CurrentMove.DoubleClickMove, CurrentMove.Acceleration, rot(0,0,0));
			CurrentMove = CurrentMove.NextMove;
		}
	}
    if ( PendingMove != None )
    {
		Pawn.bWantsToCrouch = PendingMove.bWantsToCrouch;
		Pawn.bNextCrouchState = PendingMove.bNextCrouchState;
        MoveAutonomous(PendingMove.Delta, PendingMove.bRun, PendingMove.bDuck, PendingMove.bPressedJump, PendingMove.bDoubleJump, PendingMove.DoubleClickMove, PendingMove.Acceleration, rot(0,0,0));
	}

	//log("Client updated position to "$Pawn.Location);
	bUpdating = false;
	bDuck = realbDuck;
	Pawn.bWantsToCrouch = realbWantsToCrouch;
	Pawn.bNextCrouchState = realbNextCrouchState;
	bRun = realbRun;
	bPressedJump = bRealJump;
}

final function SavedMove GetFreeMove()
{
	local SavedMove s, first;
	local int i;

	if ( FreeMoves == None )
	{
        // don't allow more than 100 saved moves
		For ( s=SavedMoves; s!=None; s=s.NextMove )
		{
			i++;
            if ( i > 100 )
			{
				first = SavedMoves;
				SavedMoves = SavedMoves.NextMove;
				first.Clear();
				first.NextMove = None;
				// clear out all the moves
				While ( SavedMoves != None )
				{
					s = SavedMoves;
					SavedMoves = SavedMoves.NextMove;
					s.Clear();
					s.NextMove = FreeMoves;
					FreeMoves = s;
				}
				return first;
			}
		}
		return Spawn(class'SavedMove');
	}
	else
	{
		s = FreeMoves;
		FreeMoves = FreeMoves.NextMove;
		s.NextMove = None;
		return s;
	}
}

function int CompressAccel(int C)
{
	if ( C >= 0 )
		C = Min(C, 127);
	else
		C = Min(abs(C), 127) + 128;
	return C;
}

/*
========================================================================
Here's how player movement prediction, replication and correction works in network games:

Every tick, the PlayerTick() function is called.  It calls the PlayerMove() function (which is implemented
in various states).  PlayerMove() figures out the acceleration and rotation, and then calls ProcessMove()
(for single player or listen servers), or ReplicateMove() (if its a network client).

ReplicateMove() saves the move (in the PendingMove list), calls ProcessMove(), and then replicates the move
to the server by calling the replicated function ServerMove() - passing the movement parameters, the client's
resultant position, and a timestamp.

ServerMove() is executed on the server.  It decodes the movement parameters and causes the appropriate movement
to occur.  It then looks at the resulting position and if enough time has passed since the last response, or the
position error is significant enough, the server calls ClientAdjustPosition(), a replicated function.

ClientAdjustPosition() is executed on the client.  The client sets its position to the servers version of position,
and sets the bUpdatePosition flag to true.

When PlayerTick() is called on the client again, if bUpdatePosition is true, the client will call
ClientUpdatePosition() before calling PlayerMove().  ClientUpdatePosition() replays all the moves in the pending
move list which occured after the timestamp of the move the server was adjusting.
*/

//
// Replicate this client's desired movement to the server.
//
function ReplicateMove
(
	float DeltaTime,
	vector NewAccel,
	eDoubleClickDir DoubleClickMove,
	rotator DeltaRot
)
{
	local SavedMove NewMove, OldMove, LastMove;
	local byte ClientRoll;
	local float OldTimeDelta, NetMoveDelta;
	local int OldAccel;
	local vector BuildAccel, AccelNorm, MoveLoc;

	// find the most recent move, and the most recent interesting move
	if ( SavedMoves != None )
	{
        LastMove = SavedMoves;
		AccelNorm = Normal(NewAccel);
        while ( LastMove.NextMove != None )
		{
			// find most recent interesting move to send redundantly
            if ( LastMove.bPressedJump || LastMove.bDoubleJump || ((LastMove.DoubleClickMove != DCLICK_NONE) && (LastMove.DoubleClickMove < 5))
                || ((LastMove.Acceleration != NewAccel) && ((normal(LastMove.Acceleration) Dot AccelNorm) < 0.95)) )
                OldMove = LastMove;
            LastMove = LastMove.NextMove;
		}
        if ( LastMove.bPressedJump || LastMove.bDoubleJump || ((LastMove.DoubleClickMove != DCLICK_NONE) && (LastMove.DoubleClickMove < 5))
            || ((LastMove.Acceleration != NewAccel) && ((normal(LastMove.Acceleration) Dot AccelNorm) < 0.95)) )
            OldMove = LastMove;
	}
    // Get a SavedMove actor to store the movement in.
    if ( PendingMove != None )
        PendingMove.SetMoveFor(self, DeltaTime, NewAccel, DoubleClickMove);

	NewMove = GetFreeMove();
	if ( NewMove == None )
		return;
	NewMove.SetMoveFor(self, DeltaTime, NewAccel, DoubleClickMove);

	// Simulate the movement locally.
    bDoubleJump = false;
	ProcessMove(NewMove.Delta, NewMove.Acceleration, NewMove.DoubleClickMove, DeltaRot);

	if ( Pawn != None )
		Pawn.AutonomousPhysics(NewMove.Delta);
	else
		AutonomousPhysics(DeltaTime);

	if ( PendingMove == None )
		PendingMove = NewMove;
	else
	{
		NewMove.NextMove = FreeMoves;
		FreeMoves = NewMove;
		FreeMoves.Clear();
		NewMove = PendingMove;
	}
    NewMove.PostUpdate(self);
    NetMoveDelta = FMax(80.0/Player.CurrentNetSpeed, 0.015);

    // Decide whether to hold off on move
    // send if double click move, jump, or fire unless really too soon, or if newmove.delta big enough
    if ( !Level.bCapFramerate && !PendingMove.bPressedJump && !PendingMove.bDoubleJump
		&& ((PendingMove.DoubleClickMove == DCLICK_None) || (PendingMove.DoubleClickMove == DCLICK_Active))
		&& ((PendingMove.Acceleration == NewAccel) || ((Normal(NewAccel) Dot Normal(PendingMove.Acceleration)) > 0.95))
		&& (PendingMove.Delta < NetMoveDelta - ClientUpdateTime) )
	{
		return;
	}
	else
	{
		ClientUpdateTime = PendingMove.Delta - NetMoveDelta;
		if ( SavedMoves == None )
			SavedMoves = PendingMove;
		else
			LastMove.NextMove = PendingMove;
		PendingMove = None;
	}

	// check if need to redundantly send previous move
	if ( OldMove != None )
	{
		// old move important to replicate redundantly
		OldTimeDelta = FMin(255, (Level.TimeSeconds - OldMove.TimeStamp) * 500);
		BuildAccel = 0.05 * OldMove.Acceleration + vect(0.5, 0.5, 0.5);
		OldAccel = (CompressAccel(BuildAccel.X) << 23)
					+ (CompressAccel(BuildAccel.Y) << 15)
					+ (CompressAccel(BuildAccel.Z) << 7);
		if ( OldMove.bRun )
			OldAccel += 64;
        if ( OldMove.bDoubleJump )
			OldAccel += 32;
		if ( OldMove.bPressedJump )
			OldAccel += 16;
		OldAccel += OldMove.DoubleClickMove;
	}

	// Send to the server
	ClientRoll = (Rotation.Roll >> 8) & 255;
	if ( NewMove.bPressedJump )
		bJumpStatus = !bJumpStatus;

	if ( Pawn == None )
		MoveLoc = Location;
	else
		MoveLoc = Pawn.Location;

	if ( IsInState('PlayerRocketing') )
		RocketServerMove
		(
			NewMove.TimeStamp,
			NewMove.Acceleration * 10,
			MoveLoc,
			ClientRoll,
			(32767 & (Rotation.Pitch/2)) * 32768 + (32767 & (Rotation.Yaw/2))
		);
    else if ( (NewMove.Acceleration == vect(0,0,0)) && (NewMove.DoubleClickMove == DCLICK_None) && !NewMove.bDoubleJump )
		ShortServerMove
		(
			NewMove.TimeStamp,
			MoveLoc,
			NewMove.bRun,
			NewMove.bDuck,
			bJumpStatus,
			ClientRoll,
			(32767 & (Rotation.Pitch/2)) * 32768 + (32767 & (Rotation.Yaw/2))
		);
	else
		ServerMove
		(
			NewMove.TimeStamp,
			NewMove.Acceleration * 10,
			MoveLoc,
			NewMove.bRun,
			NewMove.bDuck,
			bJumpStatus,
            NewMove.bDoubleJump,
			NewMove.DoubleClickMove,
			ClientRoll,
			(32767 & (Rotation.Pitch/2)) * 32768 + (32767 & (Rotation.Yaw/2)),
			OldTimeDelta,
			OldAccel
		);
	}

function HandleWalking()
{
	// GBX:PAD: I commented this out for now to accomodate analog movement on the XBox.  On the PC it breaks the use
	// of the walk key.
//	if ( Pawn != None )
//		Pawn.SetWalking( (bRun != 0) && !Region.Zone.IsA('WarpZoneInfo') );
}

function ServerRestartGame()
{
}

function SetFOVAngle(float newFOV)
{
	FOVAngle = newFOV;
}

function ClientFlash( float scale, vector fog )
{
    FlashScale = scale * vect(1,1,1);
    flashfog = 0.001 * fog;
}

function ClientAdjustGlow( float scale, vector fog )
{
	ConstantGlowScale += scale;
	ConstantGlowFog += 0.001 * fog;
}

function ResetShakeView()
{
	MaxShakeRoll = 0.0f;
	ShakeRollTime = 0.0f;
	ShakeRollRate = 0.0f;
	ShakeOffsetTime = vect(0.0f, 0.0f, 0.0f);
	MaxShakeOffset = vect(0.0f, 0.0f, 0.0f);
	ShakeOffsetRate = vect(0.0f, 0.0f, 0.0f);
	
	ShakeOffset = vect(0.0f, 0.0f, 0.0f);

	if (Pawn != None)
	{
		Pawn.bobtime = 0.0f;
		Pawn.WalkBob = vect( 0.0f, 0.0f, 0.0f );
		Pawn.AppliedBob = 0.0f;
		Pawn.LandBob = 0.0f;
	}
}

/* ClientShake()
Function called on client to shake view.
Only ShakeView() should call ClientShake()
*/
private function ClientShake(vector ShakeRoll, vector OffsetMag, vector ShakeRate, float OffsetTime)
{
	if ( (MaxShakeRoll < ShakeRoll.X) || (ShakeRollTime < 0.01 * ShakeRoll.Y) )
{
		MaxShakeRoll = ShakeRoll.X;
		ShakeRollTime = 0.01 * ShakeRoll.Y;
		ShakeRollRate = 0.01 * ShakeRoll.Z;
}
	if ( VSize(OffsetMag) > VSize(MaxShakeOffset) )
	{
		ShakeOffsetTime = OffsetTime * vect(1,1,1);
		MaxShakeOffset = OffsetMag;
		ShakeOffsetRate = ShakeRate;
	}
	}

/* ShakeView()
Call this function to shake the player's view
shaketime = how long to roll view
RollMag = how far to roll view as it shakes
OffsetMag = max view offset
RollRate = how fast to roll view
OffsetRate = how fast to offset view
OffsetTime = how long to offset view (number of shakes)
*/
function ShakeView( float shaketime, float RollMag, vector OffsetMag, float RollRate, vector OffsetRate, float OffsetTime)
{
	local vector ShakeRoll;

	ShakeRoll.X = RollMag;
	ShakeRoll.Y = 100 * shaketime;
	ShakeRoll.Z = 100 * rollrate;
	ClientShake(ShakeRoll, OffsetMag, OffsetRate, OffsetTime);
}

function damageAttitudeTo(Pawn Other, float Damage)
{
	if ( (Other != None) && (Other != Pawn) && (Damage > 0) )
		Enemy = Other;
}

function Typing( bool bTyping )
{
	bIsTyping = bTyping;
 	Pawn.bIsTyping = bIsTyping;
	if ( bTyping && (Pawn != None) && !Pawn.bTearOff )
		Pawn.ChangeAnimation();

}

//*************************************************************************************
// Normal gameplay execs
// Type the name of the exec function at the console to execute it

exec function Jump( optional float F )
{
	if ( Level.Pauser == PlayerReplicationInfo )
	{
		SetPause(False);
	}
	else
	{
		bPressedJump = true;
	}
}

// Send a voice message of a certain type to a certain player.
exec function Speech( name Type, int Index, string Callsign )
{
	if(PlayerReplicationInfo.VoiceType != None)
		PlayerReplicationInfo.VoiceType.static.PlayerSpeech( Type, Index, Callsign, Self );
}

exec function RestartLevel()
{
	if( Level.Netmode==NM_Standalone )
		ClientTravel( "?restart", TRAVEL_Relative, false );
}

exec function LocalTravel( string URL )
{
	if( Level.Netmode==NM_Standalone )
		ClientTravel( URL, TRAVEL_Relative, true );
}

// ------------------------------------------------------------------------
// Loading and saving

/* QuickSave()
Save game to slot 9
*/
exec NotInShip function QuickSave()
{
	if ( (Pawn.Health > 0)
		&& (Level.NetMode == NM_Standalone) )
	{
		ClientMessage(QuickSaveString);
		ConsoleCommand("SaveGame 9");
	}
}

/* QuickLoad()
Load game from slot 9
*/
exec NotInShip function QuickLoad()
{
	if ( Level.NetMode == NM_Standalone )
		ClientTravel( "?load=9", TRAVEL_Absolute, false);
}

/* SetPause()
 Try to pause game; returns success indicator.
 Replicated to server in network games.
 */
function bool SetPause( BOOL bPause )
{
	DebounceFireKeys();
	return Level.Game.SetPause(bPause, self);
}

function DebounceFireKeys()
{
    bFire = 0;
    bAltFire = 0;
    bMeleeFire = 0;
}

// << GEARBOX/jmw:add - Oracle cam special semi-pause mode.
simulated function bool SetOraclePause( BOOL bPause )
{
    local bool ret;
	
	ret = false;
	
	// We don't want the Oracle camera to pause multiplayer
	if( Level.NetMode != NM_ListenServer && Level.NetMode != NM_Client )
	{
		bFire = 0;
		bAltFire = 0;
		bMeleeFire = 0;
		ret = Level.Game.SetOraclePause(bPause, self);
	}
	else
	{
		if ( bPause )
		{
			bInOracleCameraMP = true;
			bFire = 0;
			bAltFire = 0;
			bMeleeFire = 0;
			bLockedMovement = true;
		}
		else
		{
			bInOracleCameraMP = false;
			bLockedMovement = false;
		}

		ret = false;
	}

	return ret;
}
// GEARBOX >>

/* Pause()
Command to try to pause the game.
*/
exec function Pause()
{
	if (Level.Game.bOracleCamActive || Level.TimeSeconds < 1.0f)
	{
		return;
	}
	// Pause if not already
	if(Level.Pauser == None)
		SetPause(true);
	else
		SetPause(false);
}

exec function AbsPause( bool bPause )
{
	// Pause if not already
	SetPause(bPause);
}

exec function ShowMenu()
{
	// Pause if not already
/* GBX:CEK: 6/11/2004 - moved to individual screens
	if(Level.Pauser == None)
		SetPause(true);
*/
	if( Level.Game.bOracleCamActive )
		return;

	if ((Level.GetLevelFileName() ~= "startup") || (Level.GetLevelFileName() ~= "legal"))
		return;

    ClientStopForceFeedback();  // jdf - no way to pause feedback

	// Open menu
	ClientOpenMenu(GetCurrentStartMenu());
}

exec function PreloadGUI()
{
	ConsoleCommand("OBJ MARK");

	PreloadMenu(GetCurrentStartMenu());
	PreloadMenu("");

	if ((Level.NetMode == NM_Standalone) && !Level.IsMenuMap())
	{
		PreloadMenu(class'GameEngine'.default.SuccessMenuClass);
		PreloadMenu(class'GameEngine'.default.FailedMenuClass);
	}

	ConsoleCommand("OBJ LIST MARKCHECK");
}

function string GetCurrentStartMenu()
{
	switch (Level.NetMode)
	{
	case NM_ListenServer:
	case NM_DedicatedServer:
		return class'GameEngine'.default.PopupMPServerMenuClass;
		break;

	case NM_Client:
		return class'GameEngine'.default.PopupMPMenuClass;
		break;

	case NM_Standalone:
		if (Level.IsMenuMap())
		{
			return class'GameEngine'.default.MainMenuClass;
		}
		else
		{
			return class'GameEngine'.default.PopupSPMenuClass;
		}
		break;
	}

	return "";
}

// Activate specific inventory item
exec function ActivateInventoryItem( class InvItem )
{
	local Powerups Inv;

	Inv = Powerups(Pawn.FindInventoryType(InvItem));
	if ( Inv != None )
		Inv.Activate();
}

// ------------------------------------------------------------------------
// Weapon changing functions

//DHW + -- Sets a countdown flag that will signal the touch function in gbxWeaponPickup to 
//      -- throw the pawn's weapon before picking up the new one.  This was added to make the 
//      -- weapon swapping code more atomic to prevent race conditions with other pawns 
//      -- throwing weapons at the same time.
function ServerThrowSwitch( )
{
	//Set the counter flag to a reasonable number
	//Note a bool could be used but this is a back-up to make sure old throw commands don't linger
	AnimPawn(Pawn).bthrowWeapon = 4.0f;
}
//DHW -

/* ThrowWeapon()
Throw out current weapon, and switch to a new weapon
*/

function ThrowWeapon()
{
    if ( (Pawn == None) || (Pawn.Weapon == None) )
		return;

	//DHW +  -- We no longer throw right away but instead wait to throw until the touch and instead set a flag
	ServerThrowSwitch();
    //ServerThrowWeapon();
	//DHW -
}

function ServerThrowWeapon()
{
    local Vector TossVel;

    if (Pawn.CanThrowWeapon())
    {
        TossVel = Vector(GetViewRotation());
        TossVel = TossVel * ((Pawn.Velocity Dot TossVel) + 500) + Vect(0,0,200);
        Pawn.TossWeapon(TossVel);
        ClientSwitchToBestWeapon();
    }
}

/* PrevWeapon()
- switch to previous inventory group weapon
*/
exec function PrevWeapon()
{
	if( Level.IsPaused() || Pawn.bIsManningTurret )
		return;
	if ( Pawn.Weapon == None )
	{
		SwitchToBestWeapon();
		return;
	}
	if ( Pawn.PendingWeapon != None )
		Pawn.PendingWeapon = Pawn.Inventory.PrevWeapon(None, Pawn.PendingWeapon);
	else
		Pawn.PendingWeapon = Pawn.Inventory.PrevWeapon(None, Pawn.Weapon);

	if ( Pawn.PendingWeapon != None )
		Pawn.Weapon.PutDown();
}

/* NextWeapon()
- switch to next inventory group weapon
*/
exec function NextWeapon()
{
	if( Level.IsPaused() || Pawn.bIsManningTurret )
		return;

	if ( Pawn.Weapon == None )
	{
		SwitchToBestWeapon();
		return;
	}
	if ( Pawn.PendingWeapon != None )
		Pawn.PendingWeapon = Pawn.Inventory.NextWeapon(None, Pawn.PendingWeapon);
	else
		Pawn.PendingWeapon = Pawn.Inventory.NextWeapon(None, Pawn.Weapon);

	if ( Pawn.PendingWeapon != None )
		Pawn.Weapon.PutDown();
}

exec function PipedSwitchWeapon(byte F)
{
	if ( (Pawn == None) || (Pawn.PendingWeapon != None) )
		return;

	SwitchWeapon(F);
}

// The player wants to switch to weapon group number F.
exec function SwitchWeapon (byte F )
{
    local weapon newWeapon;

    if ( Level.IsPaused() || Pawn == None || Pawn.Inventory == None || IsZoomed() || Pawn.bIsManningTurret )
        return;

//    if (MyHud != None)
//        MyHud.NotifyWeaponBar(true);

    if ( (Pawn.Weapon != None) && (Pawn.Weapon.Inventory != None) )
        newWeapon = Pawn.Weapon.Inventory.WeaponChange(F, false);
    else
        newWeapon = None;
    if ( newWeapon == None )
        newWeapon = Pawn.Inventory.WeaponChange(F, false, Pawn.Weapon.Inventory);

    if ( newWeapon == None )
        return;

    if ( Pawn.PendingWeapon != None && Pawn.PendingWeapon.bForceSwitch )
        return;

    if ( Pawn.Weapon == None )
    {
        Pawn.PendingWeapon = newWeapon;
        Pawn.ChangedWeapon();
    }
    else if ( Pawn.Weapon != newWeapon || Pawn.PendingWeapon != None )
    {
        Pawn.PendingWeapon = newWeapon;
        Pawn.Weapon.PutDown();
    }
    else if ( Pawn.Weapon == newWeapon )
    {
        Pawn.Weapon.Reselect(); // sjs
    }
}

exec function GetWeapon(class<Weapon> NewWeaponClass )
{
    local Inventory Inv;

    if ( (Pawn.Inventory == None) || (NewWeaponClass == None) )
        return;

//    if (MyHud != None)
//        MyHud.NotifyWeaponBar(true);

    if ( (Pawn.Weapon != None) && (Pawn.Weapon.Class == NewWeaponClass) && (Pawn.PendingWeapon == None) )
    {
        Pawn.Weapon.Reselect();
        return;
    }

    if ( Pawn.PendingWeapon != None && Pawn.PendingWeapon.bForceSwitch )
        return;

    for ( Inv=Pawn.Inventory; Inv!=None; Inv=Inv.Inventory )
    {
        if ( Inv.Class == NewWeaponClass )
        {
            Pawn.PendingWeapon = Weapon(Inv);
            if ( !Pawn.PendingWeapon.HasAmmo() )
            {
                ClientMessage( Pawn.PendingWeapon.ItemName$Pawn.PendingWeapon.MessageNoAmmo );
                Pawn.PendingWeapon = None;
                return;
            }
            Pawn.Weapon.PutDown();
            return;
        }
    }
}

// The player wants to select previous item
exec function PrevItem()
{
	local Inventory Inv;
	local Powerups LastItem;

    if ( (Level.IsPaused() ) || (Pawn == None) )
		return;
	if (Pawn.SelectedItem==None)
	{
		Pawn.SelectedItem = Pawn.Inventory.SelectNext();
		Return;
	}
	if (Pawn.SelectedItem.Inventory!=None)
		for( Inv=Pawn.SelectedItem.Inventory; Inv!=None; Inv=Inv.Inventory )
		{
			if (Inv==None) Break;
			if ( Inv.IsA('Powerups') && Powerups(Inv).bActivatable) LastItem=Powerups(Inv);
		}
	for( Inv=Pawn.Inventory; Inv!=Pawn.SelectedItem; Inv=Inv.Inventory )
	{
		if (Inv==None) Break;
		if ( Inv.IsA('Powerups') && Powerups(Inv).bActivatable) LastItem=Powerups(Inv);
	}
	if (LastItem!=None)
		Pawn.SelectedItem = LastItem;
}

// The player wants to active selected item
exec function ActivateItem()
{
	if( Level.IsPaused() )
		return;
	if ( (Pawn != None) && (Pawn.SelectedItem!=None) )
		Pawn.SelectedItem.Activate();
}

// The player wants to fire.
exec function Fire( optional float F )
{
	local bool bMultiplayer;

	if ( Level.NetMode == NM_LISTENSERVER || Level.NetMode == NM_CLIENT )
		bMultiplayer = true;
	else
		bMultiplayer = false;
	
	if ( bMultiplayer )
	{
		if ( bLockedMovement )
		{
			SetPause(false);
			return;
		}
	}
	
	if ( Level.Pauser == PlayerReplicationInfo )
	{
		SetPause(false);
		return;
	}

	if( Pawn != None && Pawn.Weapon != None )
	{
		if ( bMultiplayer )
		{
			// Check for multiplayer health bonus which is awardwd when a player has reinforced
			if ( Pawn.Health > 100 )
			{
				// Remove health bonus since the player is firing
				Pawn.Health = 100;
				Log( self$ " PlayerController::Fire() Removing health bonus since player is firing!", 'PSV' );
			}
		}

		Pawn.Weapon.Fire(F);

		if (Level.Game.bHoldFire)  // is this game configured to hold fire?
			Level.Game.fHoldFireTime = Level.TimeSeconds;  // set the time the player fired his weapon
	}
}

// The player wants to alternate-fire.
exec function AltFire( optional float F )
{
	local bool bMultiplayer;

	if ( Level.NetMode == NM_LISTENSERVER || Level.NetMode == NM_CLIENT )
		bMultiplayer = true;
	else
		bMultiplayer = false;
	
	if ( bMultiplayer )
	{
		if ( bLockedMovement )
		{
			SetPause(false);
			return;
		}
	}
	
	if ( Level.Pauser == PlayerReplicationInfo )
	{
		SetPause(false);
		return;
	}
    if( Pawn != None && Pawn.Weapon != None )
	{
		if ( bMultiplayer )
		{
			// Check for multiplayer health bonus which is awardwd when a player has reinforced
			if ( Pawn.Health > 100 )
			{
				// Remove health bonus since the player is firing
				Pawn.Health = 100;
				Log( self$ " PlayerController::Fire() Removing health bonus since player is alt-firing!", 'PSV' );
			}
		}
		
		Pawn.Weapon.AltFire(F);
	}
}

// The player wants to alternate-fire.
exec function MeleeFire( optional float F )
{
	if ( Level.NetMode == NM_LISTENSERVER || Level.NetMode == NM_CLIENT )
	{
		if ( bLockedMovement )
		{
			SetPause(false);
			return;
		}
	}
	
	if ( Level.Pauser == PlayerReplicationInfo )
	{
		SetPause(false);
		return;
	}
	
	//if( Pawn != None && Pawn.Weapon != None )
		//Pawn.Weapon.MeleeFire(F);		// GBX:naj - Damage is handled later by a anim notify.
}

// The player wants to use something in the level.
exec function Use()
{
	ServerUse();
}

function ServerUse()
{
	local Actor A;
	local Vehicle DrivenVehicle, EntryVehicle, V;

	if ( Role < ROLE_Authority )
		return;

	if ( Level.Pauser == PlayerReplicationInfo )
	{
		SetPause(false);
		return;
	}

	if (Pawn==None)
		return;

	DrivenVehicle = Vehicle(Pawn);
	if( DrivenVehicle != None )
	{
		DrivenVehicle.KDriverLeave(false);
		return;
	}

    // Check for nearby vehicles
    ForEach Pawn.VisibleCollidingActors(class'Vehicle', V, VehicleCheckRadius)
    {
        // Found a vehicle within radius
        EntryVehicle = V.FindEntryVehicle(Pawn);
        if (EntryVehicle != None && EntryVehicle.TryToDrive(Pawn))
            return;
    }

	// Send the 'DoUse' event to each actor player is touching.
	ForEach Pawn.TouchingActors(class'Actor', A)
	{
		A.UsedBy(Pawn);
	}
}

exec function Suicide()
{
	if ( (Pawn != None) && (Level.TimeSeconds - Pawn.LastStartTime > 1) )
    Pawn.KilledBy( Pawn );
}

function Name( coerce string S )
{
	SetName(S);
}

function SetName( coerce string S)
{
	ChangeName(S);
	UpdateURL("Name", S, true);
	SaveConfig();
}

function ChangeName( coerce string S )
{
    if ( Len(S) > 20 )
        S = left(S,20);
	ReplaceText(S, " ", "_");
    Level.Game.ChangeName( self, S, true );
}

exec function ChangeTeam( int N )
{
	local TeamInfo OldTeam;
    local XBoxAddr EmptyAddr;

	OldTeam = PlayerReplicationInfo.Team;
    Level.Game.ChangeTeam(self, N, true);
	if ( Level.Game.bTeamGame && (PlayerReplicationInfo.Team != OldTeam) )
    {
		if ( Pawn != None )
			Pawn.Died( None, class'DamageType', Pawn.Location );

        // jij ---
        // also, force the client to cycle to the next available voice channel
        ServerChangeChannel(Self, EmptyAddr, 0, -3 );
        // --- jij
	}
}


exec function SwitchLevel( string URL )
{
	if( Level.NetMode==NM_Standalone || Level.netMode==NM_ListenServer )
		Level.ServerTravel( URL, false );
}

exec function ClearProgressMessages()
{
	local int i;

	for (i=0; i<ArrayCount(ProgressMessage); i++)
	{
		ProgressMessage[i] = "";
		ProgressColor[i] = class'Canvas'.Static.MakeColor(255,255,255);
	}
}

exec event SetProgressMessage( int Index, string S, color C )
{
	if ( Index < ArrayCount(ProgressMessage) )
	{
		ProgressMessage[Index] = S;
		ProgressColor[Index] = C;
	}
}

exec event SetProgressTime( float T )
{
	ProgressTimeOut = T + Level.TimeSeconds;
}

function Restart()
{
	Super.Restart();
	ServerTimeStamp = 0;
	TimeMargin = 0;
	EnterStartState();
	bBehindView = Pawn.PointOfView();
	ClientRestart(Pawn);
	SetViewTarget(Pawn);
}

function EnterStartState()
{
	local name NewState;

	if ( Pawn.PhysicsVolume.bWaterVolume )
	{
		if ( Pawn.HeadVolume.bWaterVolume )
			Pawn.BreathTime = Pawn.UnderWaterTime;
		NewState = Pawn.WaterMovementState;
	}
	else
		NewState = Pawn.LandMovementState;

	if ( IsInState(NewState) )
		BeginState();
	else
		GotoState(NewState);
}

function ClientRestart(Pawn NewPawn)
{
	Pawn = NewPawn;
	if ( (Pawn != None) && Pawn.bTearOff )
	{
		Pawn.Controller = None;
		Pawn = None;
	}
	if ( Pawn == None )
	{
		GotoState('WaitingForPawn');
		return;
	}
	Pawn.ClientRestart();
	SetViewTarget(Pawn);
	bBehindView = Pawn.PointOfView();
    BehindView(bBehindView);
    CleanOutSavedMoves();
	EnterStartState();
}

exec function BehindView( Bool B )
{
	if ( (Level.NetMode == NM_Standalone) || Level.Game.bAllowBehindView || Vehicle(Pawn) != None || PlayerReplicationInfo.bOnlySpectator || PlayerReplicationInfo.bAdmin || IsA('Admin') )
	{
		if ( (Vehicle(Pawn)==None) || (Vehicle(Pawn).bAllowViewChange) )	// Allow vehicles to limit view changes
		{
		    bBehindView = B;
		    ClientSetBehindView(bBehindView);
		}
    }
}

exec function ToggleBehindView()
{
	ServerToggleBehindview();
}

function ServerToggleBehindView()
{
	local bool B;

	if ( Level.NetMode == NM_Standalone || Level.Game.bAllowBehindView || Vehicle(Pawn) != None || PlayerReplicationInfo.bOnlySpectator || PlayerReplicationInfo.bAdmin || IsA('Admin') )
	{
		if ( (Vehicle(Pawn)==None) || (Vehicle(Pawn).bAllowViewChange) )	// Allow vehicles to limit view changes
		{
			B = !bBehindView;
			ClientSetBehindView(B);
			bBehindView = B;
		}
	}
}

//=============================================================================
// functions.

// Just changed to pendingWeapon
function ChangedWeapon()
{
    if ( Pawn.PendingWeapon != None )
        Pawn.PendingWeapon.SetHand(Handedness);
}

event TravelPostAccept()
{
	if ( Pawn.Health <= 0 )
		Pawn.Health = Pawn.Default.Health;
}

event ServerPlayerTick( float DeltaTime )
{
}

event PlayerTick( float DeltaTime )
{
	if ( bForcePrecache && (Level.TimeSeconds > ForcePrecacheTime) )
	{
		bForcePrecache = false;
		Level.FillPrecacheMaterialsArray();
		Level.FillPrecacheStaticMeshesArray();
		Level.FillPrecacheMeshesArray();
	}
	else if ( !bShortConnectTimeOut ) // from UT2k4 2004-10-03 JWS
	{
		bShortConnectTimeOut = true;
		ServerShortTimeout();
	}

	PlayerInput.PlayerInput(DeltaTime);
	if ( bUpdatePosition )
		ClientUpdatePosition();
	PlayerMove(DeltaTime);
}

function PlayerMove(float DeltaTime);

function bool NotifyLanded(vector HitNormal)
{
	return bUpdating;
}

//=============================================================================
// Player Control

// Player view.
// Compute the rendering viewpoint for the player.
//

function AdjustView(float DeltaTime )
{
	// teleporters affect your FOV, so adjust it back down
	if ( Pawn.kick_zoom_active )
	{
		if (Pawn.kick_zooming_out == True)
		{
			if (FOVAngle <= Pawn.DesiredZoomFOV)
			{
				FOVAngle = FOVAngle - FMin(-5, 0.2 * DeltaTime * (FOVAngle - Pawn.DesiredZoomFOV));

				if ( FOVAngle > Pawn.DesiredZoomFOV )
				{
					FOVAngle = Pawn.DesiredZoomFOV;
					Pawn.kick_zooming_out = false;
					Pawn.DesiredZoomFOV = Pawn.PreZoomFOV;
				}
			}
		}

		if (Pawn.kick_zooming_out == False)  // zooming back in...
		{
			if (FOVAngle >= Pawn.DesiredZoomFOV)
			{
				FOVAngle = FOVAngle - FMax(2, 0.2 * DeltaTime * (FOVAngle - Pawn.DesiredZoomFOV));

				if ( FOVAngle < Pawn.DesiredZoomFOV )
				{
					FOVAngle = Pawn.DesiredZoomFOV;
					Pawn.kick_zoom_active = false;
				}
			}
		}
	}
	else if ( FOVAngle != DesiredFOV )
	{
		if (FOVRate == 0.0f)
		{
			FOVAngle = DesiredFOV;
		}
		else if ( FOVAngle > DesiredFOV )
		{
			FOVAngle = FOVAngle - FMax(FOVRate, 0.2 * DeltaTime * (FOVAngle - DesiredFOV));
			if ( FOVAngle < DesiredFOV )
				FOVAngle = DesiredFOV;
		}
		else
		{
			FOVAngle = FOVAngle - FMin(-FOVRate, 0.2 * DeltaTime * (FOVAngle - DesiredFOV));
			if ( FOVAngle > DesiredFOV)
				FOVAngle = DesiredFOV;
		}
	}

	// adjust FOV for weapon zooming
	if ( bZooming )
	{
		ZoomLevel += DeltaTime * 1.0;
		if (ZoomLevel > 0.9)
			ZoomLevel = 0.9;
		DesiredFOV = FClamp(90.0 - (ZoomLevel * 88.0), 1, 170);
	}
}

function CalcBehindView(out vector CameraLocation, out rotator CameraRotation, float Dist)
{
	local vector View,HitLocation,HitNormal;
    local float ViewDist,RealDist;

	if ( bCameraRotationLocked )
	{
		CameraRotation = ViewTarget.Rotation;
		CameraRotation.Pitch = Rotation.Pitch;
	}
	else
		CameraRotation = Rotation;

	if ( bBlockCloseCamera )
		CameraLocation.Z += 12;

	View = vect(1,0,0) >> CameraRotation;

    // add view radius offset to camera location and move viewpoint up from origin (amb)
    RealDist = Dist;

    if( Trace( HitLocation, HitNormal, CameraLocation - Dist * vector(CameraRotation), CameraLocation,false,vect(10,10,10) ) != None )
		ViewDist = FMin( (CameraLocation - HitLocation) Dot View, Dist );
	else
		ViewDist = Dist;

    if ( !bBlockCloseCamera || !bValidBehindCamera || (ViewDist > 10 + FMax(ViewTarget.CollisionRadius, ViewTarget.CollisionHeight)) )
	{
		//Log("Update Cam ");
		bValidBehindCamera = true;
		OldCameraLoc = CameraLocation - ViewDist * View;
		OldCameraRot = CameraRotation;
	}
	else
	{
		//Log("Dont Update Cam "$bBlockCloseCamera@bValidBehindCamera@ViewDist);
		SetRotation(OldCameraRot);
	}

    CameraLocation = OldCameraLoc;
    CameraRotation = OldCameraRot;
}

function CalcFirstPersonView( out vector CameraLocation, out rotator CameraRotation )
{
	// First-person view.
	CameraRotation = Rotation;
	CameraLocation = CameraLocation + Pawn.EyePosition() + ShakeOffset;
}

event rotator GetViewRotation()
{
//	if ( bBehindView && (Pawn != None) )
//		return Pawn.Rotation;
	return Rotation;
}

event PlayerCalcView(out actor ViewActor, out vector CameraLocation, out rotator CameraRotation )
{
	local Pawn PTarget;

	if (m_MatineeScript != None)
	{
		m_MatineeScript.MatineeCalcView( ViewActor, CameraLocation, CameraRotation );
		return;
	}
	// If desired, call the Pawn's own special callview
	if( Pawn != None && Pawn.bSpecialCalcView )
	{
		// try the 'special' calcview. This may return false if its not applicable, and we do the usual.
		if( Pawn.SpecialCalcView(ViewActor, CameraLocation, CameraRotation) )
		{
			return;
		}
	}

	if ( (ViewTarget == None) || ViewTarget.bDeleteMe )
	{
		if ( bViewBot && (CheatManager != None) )
			CheatManager.ViewBot();
        else if ( (Pawn != None) && !Pawn.bDeleteMe )
			SetViewTarget(Pawn);
        else if ( RealViewTarget != None )
			SetViewTarget(RealViewTarget);
		else
			SetViewTarget(self);
	}

	ViewActor = ViewTarget;
	CameraLocation = ViewTarget.Location;

	if ( ViewTarget == Pawn )
	{
		if( bBehindView ) //up and behind
			CalcBehindView(CameraLocation, CameraRotation, CameraDist * Pawn.Default.CollisionRadius);
		else
			CalcFirstPersonView( CameraLocation, CameraRotation );

		return;
	}
	if ( ViewTarget == self )
	{
		if ( bCameraPositionLocked )
			CameraRotation = CheatManager.LockedRotation;
		else
			CameraRotation = Rotation;

		return;
	}

    if ( ViewTarget.IsA('Projectile') && !bBehindView )
    {
        CameraLocation += (ViewTarget.CollisionHeight) * vect(0,0,1);
        CameraRotation = Rotation;

        return;
    }

	CameraRotation = ViewTarget.Rotation;
	PTarget = Pawn(ViewTarget);
	if ( PTarget != None )
	{
		if ( Level.NetMode == NM_Client )
		{
			PTarget.SetViewRotation(TargetViewRotation);
            CameraRotation = BlendedTargetViewRotation;

			PTarget.EyeHeight = TargetEyeHeight;
			if ( PTarget.Weapon != None )
				PTarget.Weapon.PlayerViewOffset = TargetWeaponViewOffset;
		}
		else if ( PTarget.IsPlayerPawn() )
			CameraRotation = PTarget.GetViewRotation();
		if ( !bBehindView )
			CameraLocation += PTarget.EyePosition();
	}
	if ( bBehindView )
	{
		CameraLocation = CameraLocation + (ViewTarget.Default.CollisionHeight - ViewTarget.CollisionHeight) * vect(0,0,1);
		CalcBehindView(CameraLocation, CameraRotation, CameraDist * ViewTarget.Default.CollisionRadius);
	}
}

function int BlendRot(float DeltaTime, int BlendC, int NewC)
{
	if ( Abs(BlendC - NewC) > 32767 )
	{
		if ( BlendC > NewC )
			NewC += 65536;
		else
			BlendC += 65536;
	}
	if ( Abs(BlendC - NewC) > 4096 )
		BlendC = NewC;
	else
		BlendC = BlendC + (NewC - BlendC) * FMin(1,24 * DeltaTime);

	return (BlendC & 65535);
}

function CheckShake(out float MaxOffset, out float Offset, out float Rate, out float Time)
{
	if ( abs(Offset) < abs(MaxOffset) )
		return;

	Offset = MaxOffset;

	//DHW + -- Comment
	if (IsZoomed())
		Offset *= ZoomedShakeScalar;
	//DHW -

	if ( Time > 1 )
	{
		if ( Time * abs(MaxOffset/Rate) <= 1 )
			MaxOffset = MaxOffset * (1/Time - 1);
		else
			MaxOffset *= -1;
		Time -= 1;
		Rate *= -1;
	}
	else
	{
		MaxOffset = 0;
		Offset = 0;
		Rate = 0;
	}
}

function ViewShake(float DeltaTime)
{
	local Rotator ViewRotation;
	local float FRoll;

	if ( ShakeOffsetRate != vect(0,0,0) )
	{
		// modify shake offset
		ShakeOffset.X += DeltaTime * ShakeOffsetRate.X;
		CheckShake(MaxShakeOffset.X, ShakeOffset.X, ShakeOffsetRate.X, ShakeOffsetTime.X);

		ShakeOffset.Y += DeltaTime * ShakeOffsetRate.Y;
		CheckShake(MaxShakeOffset.Y, ShakeOffset.Y, ShakeOffsetRate.Y, ShakeOffsetTime.Y);

		ShakeOffset.Z += DeltaTime * ShakeOffsetRate.Z;
		CheckShake(MaxShakeOffset.Z, ShakeOffset.Z, ShakeOffsetRate.Z, ShakeOffsetTime.Z);
	}

	ViewRotation = Rotation;

	if ( ShakeRollRate != 0 )
	{
		ViewRotation.Roll = ((ViewRotation.Roll & 65535) + ShakeRollRate * DeltaTime) & 65535;
		if ( ViewRotation.Roll > 32768 )
			ViewRotation.Roll -= 65536;
		FRoll = ViewRotation.Roll;
		CheckShake(MaxShakeRoll, FRoll, ShakeRollRate, ShakeRollTime);
		ViewRotation.Roll = FRoll;
	}
	else if ( bZeroRoll )
		ViewRotation.Roll = 0;
	SetRotation(ViewRotation);
}

function bool TurnTowardNearestEnemy();

function TurnAround()
{
	if ( !bSetTurnRot )
	{
		TurnRot180 = Rotation;
		TurnRot180.Yaw += 32768;
		bSetTurnRot = true;
	}

	DesiredRotation = TurnRot180;
	bRotateToDesired = ( DesiredRotation.Yaw != Rotation.Yaw );
}

function UpdateRotation(float DeltaTime, float maxPitch)
{
	local rotator newRotation, ViewRotation;

	if ( bInterpolating || ((Pawn != None) && Pawn.bInterpolating) )
	{
		ViewShake(deltaTime);
		return;
	}
	ViewRotation = Rotation;
	DesiredRotation = ViewRotation; //save old rotation
	if ( bTurnToNearest != 0 )
		TurnTowardNearestEnemy();
	else if ( bTurn180 != 0 )
		TurnAround();
	else
	{
		TurnTarget = None;
		bRotateToDesired = false;
		bSetTurnRot = false;
		ViewRotation.Yaw += 32.0 * DeltaTime * aTurn;
		ViewRotation.Pitch += 32.0 * DeltaTime * aLookUp;
	}
	ViewRotation.Pitch = ViewRotation.Pitch & 65535;
	If ((ViewRotation.Pitch > 18000) && (ViewRotation.Pitch < 49152))
	{
		If (aLookUp > 0)
			ViewRotation.Pitch = 18000;
		else
			ViewRotation.Pitch = 49152;
	}

	SetRotation(ViewRotation);

	ViewShake(deltaTime);
	ViewFlash(deltaTime);

	NewRotation = ViewRotation;
	NewRotation.Roll = Rotation.Roll;

	if ( !bRotateToDesired && (Pawn != None) && (!bFreeCamera || !bBehindView) )
		Pawn.FaceRotation(NewRotation, deltatime);
}

function ClearDoubleClick()
{
	if (PlayerInput != None)
		PlayerInput.DoubleClickTimer = 0.0;
}

// Player movement.
// Player Standing, walking, running, falling.
state PlayerWalking
{
ignores SeePlayer, HearNoise, Bump;

	function bool NotifyPhysicsVolumeChange( PhysicsVolume NewVolume )
	{
		if ( NewVolume.bWaterVolume )
			GotoState(Pawn.WaterMovementState);
		return false;
	}

	function ProcessMove(float DeltaTime, vector NewAccel, eDoubleClickDir DoubleClickMove, rotator DeltaRot)
	{
		local vector OldAccel;

		if ( Pawn == None )
			return;
		OldAccel = Pawn.Acceleration;
		Pawn.Acceleration = NewAccel;

//		if (bInOracleCameraMP)
//			return;

		if ( bDoubleJump && (bUpdating || Pawn.CanDoubleJump()) )
			Pawn.DoDoubleJump(bUpdating);
        else if ( bPressedJump )
			Pawn.DoJump(bUpdating);

		if ( Pawn.Physics != PHYS_Falling )
		{
			if (bDuck == 1)
			{
				if( bUseCrouchToggle )
				{
					if( !Pawn.bWantsToCrouch && Pawn.bNextCrouchState )
						Pawn.ShouldCrouch(true);
					else if( Pawn.bWantsToCrouch && !Pawn.bNextCrouchState )
						Pawn.ShouldCrouch(false);

//					CrouchHoldTime = FMin(CrouchHoldToStandThreshold, CrouchHoldTime + DeltaTime);
				}
				else
				{
					if( !Pawn.bIsCrouched && Pawn.bCanCrouch )
						Pawn.ShouldCrouch(true);
				}
			}
			else
			{
				if( bUseCrouchToggle )
				{
//					if( CrouchHoldTime >= CrouchHoldToStandThreshold )
//						Pawn.ShouldCrouch(!Pawn.bWantsToCrouch);
//					else
						Pawn.bNextCrouchState = !Pawn.bWantsToCrouch;

//					CrouchHoldTime = 0.0;
				}
				else
				{
					if( Pawn.bIsCrouched )
						Pawn.ShouldCrouch(false);
				}
			}

//			Pawn.CrouchToggleIntervalCounter = FMin( Pawn.MinCrouchToggleInterval, Pawn.CrouchToggleIntervalCounter + DeltaTime );
		}
	}

	function PlayerMove( float DeltaTime )
	{
		local vector X,Y,Z, NewAccel;
		local eDoubleClickDir DoubleClickMove;
		local rotator OldRotation, ViewRotation;
		local bool	bSaveJump;

		GetAxes(Pawn.Rotation,X,Y,Z);

		// Update acceleration.
		NewAccel = aForward*X + aStrafe*Y;
		NewAccel.Z = 0;
		if ( VSize(NewAccel) < 1.0 )
			NewAccel = vect(0,0,0);
		DoubleClickMove = PlayerInput.CheckForDoubleClickMove(DeltaTime);

		GroundPitch = 0;
		ViewRotation = Rotation;
		if ( Pawn.Physics == PHYS_Walking )
		{
			// tell Pawn about any direction changes to give it a chance to play appropriate animation
			//if walking, look up/down stairs - unless player is rotating view
			if ( (bLook == 0)
                && (((Pawn.Acceleration != Vect(0,0,0)) && bSnapToLevel) || !bKeyboardLook) )
			{
				if ( bLookUpStairs || bSnapToLevel )
				{
					GroundPitch = FindStairRotation(deltaTime);
					ViewRotation.Pitch = GroundPitch;
				}
				else if ( bCenterView )
				{
					ViewRotation.Pitch = ViewRotation.Pitch & 65535;
					if (ViewRotation.Pitch > 32768)
						ViewRotation.Pitch -= 65536;
					ViewRotation.Pitch = ViewRotation.Pitch * (1 - 12 * FMin(0.0833, deltaTime));
                    if ( Abs(ViewRotation.Pitch) < 200 )
						ViewRotation.Pitch = 0;
				}
			}
		}
		else
		{
			if ( !bKeyboardLook && (bLook == 0) && bCenterView )
			{
				ViewRotation.Pitch = ViewRotation.Pitch & 65535;
				if (ViewRotation.Pitch > 32768)
					ViewRotation.Pitch -= 65536;
				ViewRotation.Pitch = ViewRotation.Pitch * (1 - 12 * FMin(0.0833, deltaTime));
                if ( Abs(ViewRotation.Pitch) < 200 )
					ViewRotation.Pitch = 0;
			}
		}
		Pawn.CheckBob(DeltaTime, Y);

		if ( !bLockedMovement && !bInOracleCameraMP )
		{
			// Update rotation.
			SetRotation(ViewRotation);
			OldRotation = Rotation;
			UpdateRotation(DeltaTime, 1);
		}
		bDoubleJump = false;

		if ( bPressedJump && Pawn.CannotJumpNow() )
		{
//			bSaveJump = true;
			bPressedJump = false;
		}
		else
			bSaveJump = false;

		if ( Role < ROLE_Authority ) // then save this move and replicate it
		{
			if ( bLockedMovement )
				ReplicateMove(DeltaTime, vect(0,0,0), DoubleClickMove, OldRotation - Rotation);
			else
				ReplicateMove(DeltaTime, NewAccel, DoubleClickMove, OldRotation - Rotation);
		}
		else
			ProcessMove(DeltaTime, NewAccel, DoubleClickMove, OldRotation - Rotation);
//		bPressedJump = bSaveJump;
		bPressedJump = false;
	}

	function BeginState()
	{
       	DoubleClickDir = DCLICK_None;
       	bPressedJump = false;
       	GroundPitch = 0;
		if ( Pawn != None )
		{
		if ( Pawn.Mesh == None )
			Pawn.SetMesh();
		Pawn.ShouldCrouch(false);
		if (Pawn.Physics != PHYS_Falling && Pawn.Physics != PHYS_Karma) // FIXME HACK!!!
			Pawn.SetPhysics(PHYS_Walking);
		}
	}

	function EndState()
	{

		GroundPitch = 0;
		if ( Pawn != None && bDuck==0 )
		{
			Pawn.ShouldCrouch(false);
		}
	}
}

// player is climbing ladder
state PlayerClimbing
{
ignores SeePlayer, HearNoise, Bump;

	function bool NotifyPhysicsVolumeChange( PhysicsVolume NewVolume )
	{
		if ( NewVolume.bWaterVolume )
			GotoState(Pawn.WaterMovementState);
		else
			GotoState(Pawn.LandMovementState);
		return false;
	}

	function ProcessMove(float DeltaTime, vector NewAccel, eDoubleClickDir DoubleClickMove, rotator DeltaRot)
	{
		local vector OldAccel;

		OldAccel = Pawn.Acceleration;
		Pawn.Acceleration = NewAccel;

		if ( bPressedJump )
		{
			Pawn.DoJump(bUpdating);
			if ( Pawn.Physics == PHYS_Falling )
				GotoState('PlayerWalking');
		}
	}

	function PlayerMove( float DeltaTime )
	{
		local vector X,Y,Z, NewAccel;
		local eDoubleClickDir DoubleClickMove;
		local rotator OldRotation, ViewRotation;
		local bool	bSaveJump;

		GetAxes(Rotation,X,Y,Z);

		// Update acceleration.
		if ( Pawn.OnLadder != None )
			NewAccel = aForward*Pawn.OnLadder.ClimbDir;
		else
			NewAccel = aForward*X + aStrafe*Y;
		if ( VSize(NewAccel) < 1.0 )
			NewAccel = vect(0,0,0);

		ViewRotation = Rotation;

		// Update rotation.
		SetRotation(ViewRotation);
		OldRotation = Rotation;
		UpdateRotation(DeltaTime, 1);

		if ( Role < ROLE_Authority ) // then save this move and replicate it
			ReplicateMove(DeltaTime, NewAccel, DoubleClickMove, OldRotation - Rotation);
		else
			ProcessMove(DeltaTime, NewAccel, DoubleClickMove, OldRotation - Rotation);
		bPressedJump = bSaveJump;
	}

	function BeginState()
	{
		Pawn.ShouldCrouch(false);
		bPressedJump = false;
	}

	function EndState()
	{
		if ( Pawn != None )
			Pawn.ShouldCrouch(false);
	}
}

// Player movement.
// Player Driving a Karma vehicle.
state PlayerDriving
{
ignores SeePlayer, HearNoise, Bump;

    function ProcessMove(float DeltaTime, vector NewAccel, eDoubleClickDir DoubleClickMove, rotator DeltaRot)
    {

    }

	// Set the throttle, steering etc. for the vehicle based on the input provided
	function ProcessDrive(float InForward, float InStrafe, float InUp, bool InJump)
	{
		local Vehicle CurrentVehicle;

	    CurrentVehicle = Vehicle(Pawn);

        if(CurrentVehicle == None)
            return;

		//log("Forward:"@InForward@" Strafe:"@InStrafe@" Up:"@InUp);

		CurrentVehicle.Throttle = FClamp( InForward/5000.0, -1.0, 1.0 );
		CurrentVehicle.Steering = FClamp( -InStrafe/5000.0, -1.0, 1.0 );
		CurrentVehicle.Rise = FClamp( InUp/5000.0, -1.0, 1.0 );
	}

    function PlayerMove( float DeltaTime )
    {
		local Vehicle CurrentVehicle;
		local float NewPing;

		CurrentVehicle = Vehicle(Pawn);

		// update 'looking' rotation
        UpdateRotation(DeltaTime, 2);

        // TODO: Don't send things like aForward and aStrafe for gunners who don't need it
		// Only servers can actually do the driving logic.
        if (Role < ROLE_Authority )
        {
			if ( (Level.TimeSeconds - LastPingUpdate > 4) && (PlayerReplicationInfo != None) && !bDemoOwner )
			{
				LastPingUpdate = Level.TimeSeconds;
				NewPing = float(ConsoleCommand("GETPING"));
				if ( ExactPing < 0.006 )
					ExactPing = FMin(0.1,0.001 * NewPing);
				else
					ExactPing = 0.99 * ExactPing + 0.0001 * NewPing;
				PlayerReplicationInfo.Ping = Min(250.0 * ExactPing, 255);
				PlayerReplicationInfo.bReceivedPing = true;
				OldPing = ExactPing;
				ServerUpdatePing(1000 * ExactPing);
			}
            if (!bSkippedLastUpdate &&                              // in order to skip this update we must not have skipped the last one
                (Player.CurrentNetSpeed < 10000) &&                 // and netspeed must be low
                (Level.TimeSeconds - ClientUpdateTime < 0.0222) &&  // and time since last update must be short
                bPressedJump == bLastPressedJump &&                 // and update must not contain major changes
                aUp - aLastUp < 0.01 &&                             // "
                aForward - aLastForward < 0.01 &&                   // "
                aStrafe - aLastStrafe < 0.01                        // "
               )
            {
//                log("!bSkippedLastUpdate: "$!bSkippedLastUpdate);
//                log("(Player.CurrentNetSpeed < 10000): "$(Player.CurrentNetSpeed < 10000));
//                log("(Level.TimeSeconds - ClientUpdateTime < 0.0222): "$(Level.TimeSeconds - ClientUpdateTime < 0.0222)$"  - "$Level.TimeSeconds - ClientUpdateTime);
//                log("bPressedJump == bLastPressedJump: "$bPressedJump == bLastPressedJump);
//                log("aUp - aLastUp < 0.01: "$aUp - aLastUp < 0.01);
//                log("aForward - aLastForward < 0.01: "$aForward - aLastForward < 0.01);
//                log("aStrafe - aLastStrafe < 0.01: "$aStrafe - aLastStrafe < 0.01);

                bSkippedLastUpdate = True;
                return;
            }
            else
            {
                bSkippedLastUpdate = False;
                ClientUpdateTime = Level.TimeSeconds;

                // Save Move
                bLastPressedJump = bPressedJump;
                aLastUp = aUp;
                aLastForward = aForward;
                aLastStrafe = aStrafe;

                if (CurrentVehicle != None)
                {
                    CurrentVehicle.Throttle = FClamp( aForward/5000.0, -1.0, 1.0 );
                    CurrentVehicle.Steering = FClamp( -aStrafe/5000.0, -1.0, 1.0 );
                    CurrentVehicle.Rise = FClamp( aUp/5000.0, -1.0, 1.0 );
                }

                ServerDrive(aForward, aStrafe, aUp, bPressedJump, (32767 & (Rotation.Pitch/2)) * 32768 + (32767 & (Rotation.Yaw/2)));
            }
        }
		else
			ProcessDrive(aForward, aStrafe, aUp, bPressedJump);

		// If the vehicle is being controlled here - set replicated variables.
		if (CurrentVehicle != None)
		{
			if(bFire == 0 && CurrentVehicle.bWeaponIsFiring)
				CurrentVehicle.ClientVehicleCeaseFire(False);

			if(bAltFire == 0 && CurrentVehicle.bWeaponIsAltFiring)
				CurrentVehicle.ClientVehicleCeaseFire(True);
		}
    }

	function BeginState()
	{
		PlayerReplicationInfo.bReceivedPing = false;
		CleanOutSavedMoves();
	}

	function EndState()
	{
		CleanOutSavedMoves();
	}
}

// Player movement.
// Player walking on walls
state PlayerSpidering
{
ignores SeePlayer, HearNoise, Bump;

	event bool NotifyHitWall(vector HitNormal, actor HitActor)
	{
		Pawn.SetPhysics(PHYS_Spider);
		Pawn.SetBase(HitActor, HitNormal);
		return true;
	}

	// if spider mode, update rotation based on floor
	function UpdateRotation(float DeltaTime, float maxPitch)
	{
        local rotator ViewRotation;
		local vector MyFloor, CrossDir, FwdDir, OldFwdDir, OldX, RealFloor;

		if ( bInterpolating || Pawn.bInterpolating )
		{
			ViewShake(deltaTime);
			return;
		}

		TurnTarget = None;
		bRotateToDesired = false;
		bSetTurnRot = false;

		if ( (Pawn.Base == None) || (Pawn.Floor == vect(0,0,0)) )
			MyFloor = vect(0,0,1);
		else
			MyFloor = Pawn.Floor;

		if ( MyFloor != OldFloor )
		{
			// smoothly change floor
			RealFloor = MyFloor;
			MyFloor = Normal(6*DeltaTime * MyFloor + (1 - 6*DeltaTime) * OldFloor);
			if ( (RealFloor Dot MyFloor) > 0.999 )
				MyFloor = RealFloor;

			// translate view direction
			CrossDir = Normal(RealFloor Cross OldFloor);
			FwdDir = CrossDir Cross MyFloor;
			OldFwdDir = CrossDir Cross OldFloor;
			ViewX = MyFloor * (OldFloor Dot ViewX)
						+ CrossDir * (CrossDir Dot ViewX)
						+ FwdDir * (OldFwdDir Dot ViewX);
			ViewX = Normal(ViewX);

			ViewZ = MyFloor * (OldFloor Dot ViewZ)
						+ CrossDir * (CrossDir Dot ViewZ)
						+ FwdDir * (OldFwdDir Dot ViewZ);
			ViewZ = Normal(ViewZ);
			OldFloor = MyFloor;
			ViewY = Normal(MyFloor Cross ViewX);
		}

		if ( (aTurn != 0) || (aLookUp != 0) )
		{
			// adjust Yaw based on aTurn
			if ( aTurn != 0 )
				ViewX = Normal(ViewX + 2 * ViewY * Sin(0.0005*DeltaTime*aTurn));

			// adjust Pitch based on aLookUp
			if ( aLookUp != 0 )
			{
				OldX = ViewX;
				ViewX = Normal(ViewX + 2 * ViewZ * Sin(0.0005*DeltaTime*aLookUp));
				ViewZ = Normal(ViewX Cross ViewY);

				// bound max pitch
				if ( (ViewZ Dot MyFloor) < 0.707   )
				{
					OldX = Normal(OldX - MyFloor * (MyFloor Dot OldX));
					if ( (ViewX Dot MyFloor) > 0)
						ViewX = Normal(OldX + MyFloor);
					else
						ViewX = Normal(OldX - MyFloor);

					ViewZ = Normal(ViewX Cross ViewY);
				}
			}

			// calculate new Y axis
			ViewY = Normal(MyFloor Cross ViewX);
		}
		ViewRotation =  OrthoRotation(ViewX,ViewY,ViewZ);
		SetRotation(ViewRotation);
		ViewShake(deltaTime);
		ViewFlash(deltaTime);
		Pawn.FaceRotation(ViewRotation, deltaTime );
	}

	function bool NotifyLanded(vector HitNormal)
	{
		Pawn.SetPhysics(PHYS_Spider);
		return bUpdating;
	}

	function bool NotifyPhysicsVolumeChange( PhysicsVolume NewVolume )
	{
		if ( NewVolume.bWaterVolume )
			GotoState(Pawn.WaterMovementState);
		return false;
	}

	function ProcessMove(float DeltaTime, vector NewAccel, eDoubleClickDir DoubleClickMove, rotator DeltaRot)
	{
		local vector OldAccel;

		OldAccel = Pawn.Acceleration;
		Pawn.Acceleration = NewAccel;

		if ( bPressedJump )
			Pawn.DoJump(bUpdating);
	}

	function PlayerMove( float DeltaTime )
	{
		local vector NewAccel;
		local eDoubleClickDir DoubleClickMove;
		local rotator OldRotation, ViewRotation;
		local bool	bSaveJump;

		GroundPitch = 0;
		ViewRotation = Rotation;

		if ( !bKeyboardLook && (bLook == 0) && bCenterView )
		{
			// FIXME - center view rotation based on current floor
		}
		Pawn.CheckBob(DeltaTime,vect(0,0,0));

		// Update rotation.
		SetRotation(ViewRotation);
		OldRotation = Rotation;
		UpdateRotation(DeltaTime, 1);

		// Update acceleration.
		NewAccel = aForward*Normal(ViewX - OldFloor * (OldFloor Dot ViewX)) + aStrafe*ViewY;
		if ( VSize(NewAccel) < 1.0 )
			NewAccel = vect(0,0,0);

		if ( bPressedJump && Pawn.CannotJumpNow() )
		{
			bSaveJump = true;
			bPressedJump = false;
		}
		else
			bSaveJump = false;

		if ( Role < ROLE_Authority ) // then save this move and replicate it
			ReplicateMove(DeltaTime, NewAccel, DoubleClickMove, OldRotation - Rotation);
		else
			ProcessMove(DeltaTime, NewAccel, DoubleClickMove, OldRotation - Rotation);
		bPressedJump = bSaveJump;
	}

	function BeginState()
	{
		if ( Pawn.Mesh == None )
			Pawn.SetMesh();
		OldFloor = vect(0,0,1);
		GetAxes(Rotation,ViewX,ViewY,ViewZ);
		DoubleClickDir = DCLICK_None;
		Pawn.ShouldCrouch(false);
		bPressedJump = false;
		if (Pawn.Physics != PHYS_Falling)
			Pawn.SetPhysics(PHYS_Spider);
		GroundPitch = 0;
		Pawn.bCrawler = true;
		Pawn.SetCollisionSize(Pawn.Default.CollisionHeight,Pawn.Default.CollisionHeight);
	}

	function EndState()
	{
		GroundPitch = 0;
		if ( Pawn != None )
		{
			Pawn.SetCollisionSize(Pawn.Default.CollisionRadius,Pawn.Default.CollisionHeight);
			Pawn.ShouldCrouch(false);
			Pawn.bCrawler = Pawn.Default.bCrawler;
		}
	}
}

// Player movement.
// Player Swimming
state PlayerSwimming
{
ignores SeePlayer, HearNoise, Bump;

	function bool WantsSmoothedView()
	{
		return ( !Pawn.bJustLanded );
	}

	function bool NotifyLanded(vector HitNormal)
	{
		if ( Pawn.PhysicsVolume.bWaterVolume )
			Pawn.SetPhysics(PHYS_Swimming);
		else
			GotoState(Pawn.LandMovementState);
		return bUpdating;
	}

	function bool NotifyPhysicsVolumeChange( PhysicsVolume NewVolume )
	{
		local actor HitActor;
		local vector HitLocation, HitNormal, checkpoint;

		if ( !NewVolume.bWaterVolume )
		{
			Pawn.SetPhysics(PHYS_Falling);
            if ( Pawn.Velocity.Z > 0 )
            {
			    if (Pawn.bUpAndOut && Pawn.CheckWaterJump(HitNormal)) //check for waterjump
			    {
				    Pawn.velocity.Z = FMax(Pawn.JumpZ,420) + 2 * Pawn.CollisionRadius; //set here so physics uses this for remainder of tick
				    GotoState(Pawn.LandMovementState);
			    }
			    else if ( (Pawn.Velocity.Z > 160) || !Pawn.TouchingWaterVolume() )
				    GotoState(Pawn.LandMovementState);
			    else //check if in deep water
			    {
				    checkpoint = Pawn.Location;
				    checkpoint.Z -= (Pawn.CollisionHeight + 6.0);
				    HitActor = Trace(HitLocation, HitNormal, checkpoint, Pawn.Location, false);
				    if (HitActor != None)
					    GotoState(Pawn.LandMovementState);
				    else
				    {
					    Enable('Timer');
					    SetTimer(0.7,false);
				    }
			    }
		    }
        }
		else
		{
			Disable('Timer');
			Pawn.SetPhysics(PHYS_Swimming);
		}
		return false;
	}

	function ProcessMove(float DeltaTime, vector NewAccel, eDoubleClickDir DoubleClickMove, rotator DeltaRot)
	{
		local vector X,Y,Z, OldAccel;

		GetAxes(Rotation,X,Y,Z);
		OldAccel = Pawn.Acceleration;
		Pawn.Acceleration = NewAccel;
		Pawn.bUpAndOut = ((X Dot Pawn.Acceleration) > 0) && ((Pawn.Acceleration.Z > 0) || (Rotation.Pitch > 2048));
		if ( !Pawn.PhysicsVolume.bWaterVolume ) //check for waterjump
			NotifyPhysicsVolumeChange(Pawn.PhysicsVolume);
	}

	function PlayerMove(float DeltaTime)
	{
		local rotator oldRotation;
		local vector X,Y,Z, NewAccel;

		GetAxes(Rotation,X,Y,Z);

		NewAccel = aForward*X + aStrafe*Y + aUp*vect(0,0,1);
		if ( VSize(NewAccel) < 1.0 )
			NewAccel = vect(0,0,0);

		//add bobbing when swimming
		Pawn.CheckBob(DeltaTime, Y);

		// Update rotation.
		oldRotation = Rotation;
		UpdateRotation(DeltaTime, 2);

		if ( Role < ROLE_Authority ) // then save this move and replicate it
			ReplicateMove(DeltaTime, NewAccel, DCLICK_None, OldRotation - Rotation);
		else
			ProcessMove(DeltaTime, NewAccel, DCLICK_None, OldRotation - Rotation);
		bPressedJump = false;
	}

	function Timer()
	{
		if ( !Pawn.PhysicsVolume.bWaterVolume && (Role == ROLE_Authority) )
			GotoState(Pawn.LandMovementState);

		Disable('Timer');
	}

	function BeginState()
	{
		Disable('Timer');
		Pawn.SetPhysics(PHYS_Swimming);
	}
}

state PlayerFlying
{
ignores SeePlayer, HearNoise, Bump;

	function PlayerMove(float DeltaTime)
	{
		local vector X,Y,Z;

		GetAxes(Rotation,X,Y,Z);

		Pawn.Acceleration = aForward*X + aStrafe*Y;
		if ( VSize(Pawn.Acceleration) < 1.0 )
			Pawn.Acceleration = vect(0,0,0);
		if ( bCheatFlying && (Pawn.Acceleration == vect(0,0,0)) )
			Pawn.Velocity = vect(0,0,0);
		// Update rotation.
		UpdateRotation(DeltaTime, 2);

		if ( Role < ROLE_Authority ) // then save this move and replicate it
			ReplicateMove(DeltaTime, Pawn.Acceleration, DCLICK_None, rot(0,0,0));
		else
			ProcessMove(DeltaTime, Pawn.Acceleration, DCLICK_None, rot(0,0,0));
	}

	function BeginState()
	{
		Pawn.SetPhysics(PHYS_Flying);
	}
}

state PlayerRocketing
{
ignores SeePlayer, HearNoise, Bump;

	/* ServerMove()
	- replicated function sent by client to server - contains client movement and firing info
	Passes acceleration in components so it doesn't get rounded.
	IGNORE VANILLA SERVER MOVES
	*/
	function ServerMove
	(
		float TimeStamp,
		vector InAccel,
		vector ClientLoc,
		bool NewbRun,
		bool NewbDuck,
		bool NewbJumpStatus,
		bool NewbDoubleJump,
		eDoubleClickDir DoubleClickMove,
		byte ClientRoll,
		int View,
		optional byte OldTimeDelta,
		optional int OldAccel
	)
	{
		if ( CurrentTimeStamp < TimeStamp )
	       Pawn.AutonomousPhysics(TimeStamp - CurrentTimeStamp);
		CurrentTimeStamp = TimeStamp;
		ServerTimeStamp = Level.TimeSeconds;
	}

	function RocketServerMove
	(
		float TimeStamp,
		vector InAccel,
		vector ClientLoc,
		byte ClientRoll,
		int View
	)
	{
		//if ( InAccel Dot Pawn.Velocity < 0 )
		//	InAccel = 0.1 * Pawn.AccelRate * Normal(Pawn.Velocity);
		Global.ServerMove(TimeStamp,InAccel,ClientLoc,false,false,false,false, DCLICK_NONE,ClientRoll,View);
	}

    function PlayerMove(float DeltaTime)
    {
		Pawn.UpdateRocketAcceleration(DeltaTime,aTurn,aLookUp);
		SetRotation(Pawn.Rotation);
		if ( Role < ROLE_Authority ) // then save this move and replicate it
			ReplicateMove(DeltaTime, Pawn.Acceleration, DCLICK_None, rot(0,0,0));
		else
			ProcessMove(DeltaTime, Pawn.Acceleration, DCLICK_None, rot(0,0,0));
	}

    function BeginState()
    {
        Pawn.SetPhysics(PHYS_Flying);
    }
}

function bool IsSpectating()
{
	return false;
}

function bool IsFieldPromoting()
{
	return false;
}

function bool IsViewingDeadBody()
{
	return false;
}

state BaseSpectating
{
	function bool IsSpectating()
	{
		return false;
	}

	function ProcessMove(float DeltaTime, vector NewAccel, eDoubleClickDir DoubleClickMove, rotator DeltaRot)
	{
		Acceleration = NewAccel;
        MoveSmooth(SpectateSpeed * Normal(Acceleration) * DeltaTime);
	}

	function PlayerMove(float DeltaTime)
	{
		local vector X,Y,Z;

		if ( (Pawn(ViewTarget) != None) && (Level.NetMode == NM_Client) )
		{
			if ( Pawn(ViewTarget).bSimulateGravity )
				TargetViewRotation.Roll = 0;
			BlendedTargetViewRotation.Pitch = BlendRot(DeltaTime, BlendedTargetViewRotation.Pitch, TargetViewRotation.Pitch & 65535);
			BlendedTargetViewRotation.Yaw = BlendRot(DeltaTime, BlendedTargetViewRotation.Yaw, TargetViewRotation.Yaw & 65535);
			BlendedTargetViewRotation.Roll = BlendRot(DeltaTime, BlendedTargetViewRotation.Roll, TargetViewRotation.Roll & 65535);
		}
		GetAxes(Rotation,X,Y,Z);

		Acceleration = 0.02 * (aForward*X + aStrafe*Y + aUp*vect(0,0,1));

		UpdateRotation(DeltaTime, 1);

		if ( Role < ROLE_Authority ) // then save this move and replicate it
			ReplicateMove(DeltaTime, Acceleration, DCLICK_None, rot(0,0,0));
		else
			ProcessMove(DeltaTime, Acceleration, DCLICK_None, rot(0,0,0));
	}
}

state Scripting
{
	// FIXME - IF HIT FIRE, AND NOT bInterpolating, Leave script
	exec function Fire( optional float F )
	{
	}

	exec function AltFire( optional float F )
	{
		Fire(F);
	}
}

function ServerViewNextPlayer()
{
    local Controller C, Pick;
    local bool bFound, bRealSpec, bWasSpec;
	local TeamInfo RealTeam;

    bRealSpec = PlayerReplicationInfo.bOnlySpectator;
    bWasSpec = !bBehindView && (ViewTarget != Pawn) && (ViewTarget != self);
    PlayerReplicationInfo.bOnlySpectator = true;
    RealTeam = PlayerReplicationInfo.Team;

	Log( self$ " PlayerController:Spectating::ServerViewNextPlayer()", 'PSV');

	// view next player
	for ( C=Level.ControllerList; C!=None; C=C.NextController )
	{
        if ( Level.Game.CanSpectate(self,true,C) )
		{
			if ( Pick == None )
                Pick = C;
			if ( bFound )
			{
                Pick = C;
				break;
			}
			else
                bFound = ( (RealViewTarget == C) || (ViewTarget == C) );
		}
	}
	
    PlayerReplicationInfo.Team = RealTeam;
	SetViewTarget(Pick);
    //ClientSetViewTarget(Pick); //SDJ 10/17/2004: SetViewTarget() already does this.
    if ( (ViewTarget == self) || bWasSpec )
		bBehindView = false;
	else
		bBehindView = true; //bChaseCam;
    ClientSetBehindView(bBehindView);
    PlayerReplicationInfo.bOnlySpectator = bRealSpec;
}

function ServerViewPreviousPlayer()
{
    local Controller C, Pick, Previous;
    local bool bFound, bRealSpec, bWasSpec;
	local TeamInfo RealTeam;

    bRealSpec = PlayerReplicationInfo.bOnlySpectator;
    bWasSpec = !bBehindView && (ViewTarget != Pawn) && (ViewTarget != self);
    PlayerReplicationInfo.bOnlySpectator = true;
    RealTeam = PlayerReplicationInfo.Team;

	Log( self$ " PlayerController:Spectating::ServerViewNextPlayer()", 'PSV');

	// view previous player
	Previous = None;
	for ( C=Level.ControllerList; C!=None; C=C.NextController )
	{
        if ( Level.Game.CanSpectate(self,true,C) )
		{
			bFound = ( (RealViewTarget == C) || (ViewTarget == C) );
			if (bFound == true)
			{
				if (Previous == None)
				{
					//We need to wrap around and get the last one in the list.
					for ( C=C; C!=None; C=C.NextController )
					{
						if ( Level.Game.CanSpectate(self,true,C) )
						{
							Previous = C;
						}
					}
				}
				
				Pick = Previous;
				break;
			}
			
			Previous = C;
		}
	}
	
    PlayerReplicationInfo.Team = RealTeam;
	SetViewTarget(Pick);
    if ( (ViewTarget == self) || bWasSpec )
		bBehindView = false;
	else
		bBehindView = true; //bChaseCam;
    ClientSetBehindView(bBehindView);
    PlayerReplicationInfo.bOnlySpectator = bRealSpec;
}

function ServerViewSelf()
{
	bBehindView = false;
    SetViewTarget(self);
    ClientSetViewTarget(self);
	ClientMessage(OwnCamera, 'Event');
}

function LoadPlayers()
{
	local int i;

	if ( GameReplicationInfo == None )
		return;

	for ( i=0; i<GameReplicationInfo.PRIArray.Length; i++ )
		GameReplicationInfo.PRIArray[i].UpdatePrecacheMaterials();
}

simulated function OnSpectatingBegin();

state Spectating extends BaseSpectating
{
	ignores SwitchWeapon, RestartLevel, ClientRestart, Suicide,
	 ThrowWeapon, NotifyPhysicsVolumeChange, NotifyHeadVolumeChange;

	function bool IsSpectating()
	{
		return true;
	}

	exec function Fire( optional float F )
	{
		bCameraRotationLocked = !bCameraRotationLocked;
	}

	function PlayerTick( float DeltaTime )
	{
		Global.PlayerTick( DeltaTime );
		
        // Make sure our view target isn't dead
		if ( (ViewTarget == None) || (!ViewTarget.IsA('Pawn')) || (Pawn(ViewTarget).IsDead()) )
		{
			//Log( self$ " PlayerController:state Spectating::PlayerTick() View target is dead, switching to next player", 'MP');
			SpectateNextSoldier( 0.0 );
		}
	}

	event PlayerCalcView(out actor ViewActor, out vector CameraLocation, out rotator CameraRotation )
	{
		if (ViewTarget != None)
		{
			ViewActor = ViewTarget;
			CameraLocation = ViewTarget.Location;

			CalcBehindView(CameraLocation, CameraRotation, CameraDist * ViewTarget.Default.CollisionRadius);
		}
	}

	exec function SpectateNextSoldier( optional float F )
	{
		//Log( self$ " PlayerController:state Spectating::PlayerTick() Moving to next player", 'MP');
		ServerViewNextPlayer();
	}

	function ProcessMove(float DeltaTime, vector NewAccel, eDoubleClickDir DoubleClickMove, rotator DeltaRot)
	{
	}

	function PlayerMove(float DeltaTime)
	{
		UpdateRotation(DeltaTime, 1);
	}

	function BeginState()
	{
		OnSpectatingBegin();

		//log( self$" PlayerController::Spectating::BeginState()", 'MP' );

		if ( Pawn != None )
		{
			SetLocation(Pawn.Location);
			UnPossess();
		}
		bCollideWorld = true;
		bCameraRotationLocked = false;
		ServerViewNextPlayer();
	}

	function EndState()
	{
		PlayerReplicationInfo.bIsSpectator = false;
		bCollideWorld = false;
		bCameraRotationLocked = false;
	}
}

state Lobby
{
	function BeginState()
	{
		//log("PlayerController" @self @"entering Lobby state (MP)", 'MP');

		if ((Viewport(Player) != None) && (Player.SplitIndex == 0))
		{
			if (Role < ROLE_Authority)
			{
				ClientOpenMenu("GUI.gbx_MPLobbyClient");
			}
			else
			{
				ClientOpenMenu("GUI.gbx_MPLobbyServer");
			}
		}

		bIsInLobby = true;
	}

	function EndState()
	{
		bIsInLobby = false;
	}

Begin:
	// if the Pawn has a weapon (possile after reconnecting from a previous map), remove it (otherwise the breathing profile causes the view to sway)
	if (Pawn.Weapon != None)
	{
		Pawn.Weapon.Destroy();
		Pawn.Weapon = None;
	}
}

function bool IsOnline()
{
	return (Level.NetMode != NM_Standalone);
}

state Lobby_Skirmish_Base
{
	function BeginState()
	{
		if ((Viewport(Player) != None) && (Player.SplitIndex == 0))
		{
			// pc version is a bit different since we don't have splitscreen
			if (!CheckOnline())
			{
				log("Unknown client/server state.  Retrying lobby...", 'guilog');
				SetTimer(0.2, true);
			}
		}

		bIsInLobby = true;
	}

	function EndState()
	{
		bIsInLobby = false;
	}

	function OpenLobbyMenu(string lobbyMenu)
	{
		ClientOpenMenu(lobbyMenu,,"WAIT");
	}

	function bool CheckOnline()
	{
		local bool result;

		if ((Level.Game != None) && (Level.Game.MaxPlayers == 1))
		{
			OpenLobbyMenu("GUI.gbx_SkirmishLobbyServerOffline");
			result = true;
		}
		else if (IsOnline())
		{
			if (Role < ROLE_Authority)
			{
				OpenLobbyMenu("GUI.gbx_SkirmishLobbyClientOnline");
			}
			else
			{
				OpenLobbyMenu("GUI.gbx_SkirmishLobbyServerOnline");
			}

			result = true;
		}

		return result;
	}

	function Timer()
	{
		if (CheckOnline())
		{
			SetTimer(0.0, false);
		}
	}

Begin:
	// if the Pawn has a weapon (possile after reconnecting from a previous map), remove it (otherwise the breathing profile causes the view to sway)
	if (Pawn.Weapon != None)
	{
		Pawn.Weapon.Destroy();
		Pawn.Weapon = None;
	}
}

state Lobby_Skirmish extends Lobby_Skirmish_Base
{
	function BeginState()
	{
		log("PlayerController" @self @"entering Lobby state (SKIRMISH)", 'guilog');

		Super.BeginState();

		bIsInLobby = true;
	}

	function EndState()
	{
		bIsInLobby = false;
	}

	function OpenLobbyMenu(string lobbyMenu)
	{
		ClientOpenMenu(lobbyMenu);
	}

Begin:
	// if the Pawn has a weapon (possile after reconnecting from a previous map), remove it (otherwise the breathing profile causes the view to sway)
	if (Pawn.Weapon != None)
	{
		Pawn.Weapon.Destroy();
		Pawn.Weapon = None;
	}
}

state Lobby_Skirmish_Wait extends Lobby_Skirmish_Base
{
	function BeginState()
	{
		log("PlayerController" @self @"entering Lobby state (SKIRMISH WAIT)", 'guilog');

		Super.BeginState();

		bIsInLobby = true;
	}

	function EndState()
	{
		bIsInLobby = false;
	}

	function OpenLobbyMenu(string lobbyMenu)
	{
		ClientOpenMenu(lobbyMenu,,"WAIT");
	}
}

state LateJoinBase
{
	function BeginState()
	{
		log("PlayerController" @self @"entering LateJoinBase state", 'guilog');

		if (Viewport(Player) != None) 
		{
			ViewportReady();
		}
		else
		{
			SetTimer(0.2, true);
		}
	}

	function Timer()
	{
		if (Viewport(Player) != None)
		{
			SetTimer(0.0, false);
			ViewportReady();
		}
	}

	function ViewportReady();
}

state LateJoinToDebrefing extends LateJoinBase
{
	function ViewportReady()
	{
		GotoState('Debriefing');
	}
}

state LateJoinToDebrefing_Skirmish extends LateJoinBase
{
	function ViewportReady()
	{
		GotoState('Debriefing_Skirmish');
	}
}

state LateJoinToDebrefing_SkirmishLobby extends LateJoinBase
{
	function ViewportReady()
	{
		GotoState('Debriefing_SkirmishLobby');
	}
}

state Debriefing
{
	function BeginState()
	{
		//log("PlayerController" @self @"entering Debriefing state", 'MP');

		if ((Viewport(Player) != None) && (Player.SplitIndex == 0))
		{
			if (Role < ROLE_Authority)
			{
				ClientOpenMenu("GUI.gbx_MPDebriefingClient");
			}
			else
			{
				ClientOpenMenu("GUI.gbx_MPDebriefingServer");
			}
		}

		bIsInDebriefing = true;
	}

	function EndState()
	{
		bIsInDebriefing = false;
	}

	function KillAIControllers()
	{
		local Controller C, C_Next;

		for ( C=Level.ControllerList; C!=None; C = C_Next)
		{
			C_Next = C.NextController;

			if (PlayerController(C) == None)  // is this NOT a PlayerController?
			{
				if (C.Pawn != None)
				{
					C.Pawn.UnPossessed();
					C.Pawn = None;
				}

				C.Destroy();
			}
		}
	}

Begin:
	// if the Pawn has a weapon (possile after reconnecting from a previous map), remove it (otherwise the breathing profile causes the view to sway)
	if (Pawn.Weapon != None)
	{
		Pawn.Weapon.Destroy();
		Pawn.Weapon = None;
	}

	// kill off any Controllers that aren't PlayerControllers (we don't want AI doing stuff during the Debriefing screen)...
	KillAIControllers();
}

state Debriefing_Skirmish
{
	function BeginState()
	{
		local BaseGUIController GUIController;
		log("PlayerController" @self @"entering Lobby state (Debriefing_Skirmish)", 'guilog');

		PlayerReplicationInfo.SetLobbyAttached(false);
	
		GUIController = GetGUIController();


		if (GUIController.bIsDemoVersion)// && Level.GetLevelFileName() == "SKR_US_RAILYARD")
		{
			if (GUIController.ViewportOwner.Actor.GameReplicationInfo.WinningTeam == 1)
			{
				ConsoleCommand("DEMO_LEVEL_END_SKR");
			}
		}

		if ((Viewport(Player) != None) && (Player.SplitIndex == 0))
		{
			if ((Level.AuthMode == AM_SystemLink) || (Level.AuthMode == AM_Live))
			{
				if (Role < ROLE_Authority)
				{
					ClientOpenMenu("GUI.gbx_SkirmishGameOverClient");
				}
				else
				{
					ClientOpenMenu("GUI.gbx_SkirmishGameOverServer");
				}
			}
			else if (Player.SplitIndex == 0) // handles (Level.AuthMode == AM_SplitScreen) also
			{
				ClientOpenMenu("GUI.gbx_SkirmishGameOverServer");
			}
		}

		bIsInDebriefing = true;
	}

	function EndState()
	{
		bIsInDebriefing = false;
	}

	function KillAIControllers()
	{
		local Controller C, C_Next;

		for ( C=Level.ControllerList; C!=None; C = C_Next)
		{
			C_Next = C.NextController;

			if (PlayerController(C) == None)  // is this NOT a PlayerController?
			{
				if (C.Pawn != None)
				{
					C.Pawn.UnPossessed();
					C.Pawn = None;
				}

				C.Destroy();
			}
		}
	}

Begin:
	// if the Pawn has a weapon (possile after reconnecting from a previous map), remove it (otherwise the breathing profile causes the view to sway)
	if (Pawn.Weapon != None)
	{
		Pawn.Weapon.Destroy();
		Pawn.Weapon = None;
	}

	// kill off any Controllers that aren't PlayerControllers (we don't want AI doing stuff during the Debriefing screen)...
	KillAIControllers();
}

state Debriefing_SkirmishLobby
{
	function BeginState()
	{
		log("PlayerController" @self @"entering Lobby state (Debriefing_SkirmishLobby)", 'guilog');

		if ((Viewport(Player) != None) && (Player.SplitIndex == 0))
		{
			ClientCloseMenu(true,,true);

			if ((Level.Game != None) && (Level.Game.MaxPlayers == 1))
			{
				ClientOpenMenu("GUI.gbx_SkirmishLobbyServerOffline");
			}
			else if (IsOnline())
			{
				if (Role < ROLE_Authority)
				{
					ClientOpenMenu("GUI.gbx_SkirmishLobbyClientOnline");
				}
				else
				{
					ClientOpenMenu("GUI.gbx_SkirmishLobbyServerOnline");
				}
			}
			else
			{
				ClientOpenMenu("GUI.gbx_SkirmishLobbyServerOffline");
			}
		}

		bIsInDebriefing = true;
	}

	function EndState()
	{
		bIsInDebriefing = false;
	}

	function KillAIControllers()
	{
		local Controller C, C_Next;

		for ( C=Level.ControllerList; C!=None; C = C_Next)
		{
			C_Next = C.NextController;

			if (PlayerController(C) == None)  // is this NOT a PlayerController?
			{
				if (C.Pawn != None)
				{
					C.Pawn.UnPossessed();
					C.Pawn = None;
				}

				C.Destroy();
			}
		}
	}

Begin:
	// if the Pawn has a weapon (possile after reconnecting from a previous map), remove it (otherwise the breathing profile causes the view to sway)
	if (Pawn.Weapon != None)
	{
		Pawn.Weapon.Destroy();
		Pawn.Weapon = None;
	}

	// kill off any Controllers that aren't PlayerControllers (we don't want AI doing stuff during the Debriefing screen)...
	KillAIControllers();
}

auto state PlayerWaiting extends BaseSpectating
{
ignores SeePlayer, HearNoise, NotifyBump, TakeDamage, PhysicsVolumeChange, NextWeapon, PrevWeapon, SwitchToBestWeapon;

	exec function Jump( optional float F )
	{
	}

	exec function Suicide()
	{
	}

	function ChangeTeam( int N )
	{
        Level.Game.ChangeTeam(self, N, true);
	}

    function ServerRestartPlayer()
	{
		if ( Level.TimeSeconds < WaitDelay )
			return;
		if ( Level.NetMode == NM_Client )
			return;
		if ( Level.Game.bWaitingToStartMatch )
			PlayerReplicationInfo.bReadyToPlay = true;
		else
			Level.Game.RestartPlayer(self);
	}

	exec function Fire(optional float F)
	{
	}

	exec function AltFire(optional float F)
	{
	}

	function ProcessMove(float DeltaTime, vector NewAccel, eDoubleClickDir DoubleClickMove, rotator DeltaRot)
	{
	}

	
	function PlayerMove(float DeltaTime)
	{
		UpdateRotation(DeltaTime, 1);

		if ( Role < ROLE_Authority ) // then save this move and replicate it
			ReplicateMove(DeltaTime, Acceleration, DCLICK_None, rot(0,0,0));
		else
			ProcessMove(DeltaTime, Acceleration, DCLICK_None, rot(0,0,0));
	}
	

	function EndState()
	{
		if ( Pawn != None )
			Pawn.SetMesh();
        if ( PlayerReplicationInfo != None )
			PlayerReplicationInfo.SetWaitingPlayer(false);
		bCollideWorld = false;
	}

	function BeginState()
	{
		if ( PlayerReplicationInfo != None )
			PlayerReplicationInfo.SetWaitingPlayer(true);
		bCollideWorld = true;
	}
}

state WaitingForPawn extends BaseSpectating
{
ignores SeePlayer, HearNoise, KilledBy, SwitchWeapon;

	exec function Fire( optional float F )
	{
		AskForPawn();
	}

	exec function AltFire( optional float F )
	{
	}

	function LongClientAdjustPosition
	(
		float TimeStamp,
		name newState,
		EPhysics newPhysics,
		float NewLocX,
		float NewLocY,
		float NewLocZ,
		float NewVelX,
		float NewVelY,
		float NewVelZ,
		Actor NewBase,
		float NewFloorX,
		float NewFloorY,
		float NewFloorZ
	)
	{
		if ( newState == 'GameEnded' )
			GotoState(newState);
	}

	function PlayerTick(float DeltaTime)
	{
		Global.PlayerTick(DeltaTime);

		if ( Pawn != None )
		{
			Pawn.Controller = self;
            Pawn.bUpdateEyeHeight = true;
			ClientRestart(Pawn);
		}
        else if ( (TimerRate <= 0.0) || (TimerRate > 1.0) )
		{
			SetTimer(0.2,true);
			AskForPawn();
		}
	}

	function Timer()
	{
		AskForPawn();
	}

	function BeginState()
	{
		SetTimer(0.2, true);
        AskForPawn();
	}

	function EndState()
	{
		bBehindView = false;
		SetTimer(0.0, false);
	}
}

function ClientGameEnded()
{
	Super.ClientGameEnded();

	Log(self $ " PlayerController::ClientGameEnded() called", 'JWS');
}

function ClientLateJoinToDebrefing(name debriefingState)
{
	GotoState(debriefingState);
}

state GameEnded
{
ignores SeePlayer, HearNoise, KilledBy, NotifyBump, HitWall, NotifyHeadVolumeChange, NotifyPhysicsVolumeChange, Falling, TakeDamage, Suicide;

	function ServerReStartPlayer()
	{
	}

	function bool IsSpectating()
	{
		return false;
	}

	function ThrowWeapon()
	{
	}

	function PlayerMove(float DeltaTime)
	{
		local vector X,Y,Z;
		local Rotator ViewRotation;

		GetAxes(Rotation,X,Y,Z);
		// Update view rotation.

		if ( !bFixedCamera )
		{
			ViewRotation = Rotation;
			ViewRotation.Yaw += 32.0 * DeltaTime * aTurn;
			ViewRotation.Pitch += 32.0 * DeltaTime * aLookUp;
			ViewRotation.Pitch = ViewRotation.Pitch & 65535;
			If ((ViewRotation.Pitch > 18000) && (ViewRotation.Pitch < 49152))
			{
				If (aLookUp > 0)
					ViewRotation.Pitch = 18000;
				else
					ViewRotation.Pitch = 49152;
			}
			SetRotation(ViewRotation);
		}
		else if ( ViewTarget != None )
			SetRotation(ViewTarget.Rotation);

		ViewShake(DeltaTime);
		ViewFlash(DeltaTime);

		if ( Role < ROLE_Authority ) // then save this move and replicate it
			ReplicateMove(DeltaTime, vect(0,0,0), DCLICK_None, rot(0,0,0));
		else
			ProcessMove(DeltaTime, vect(0,0,0), DCLICK_None, rot(0,0,0));
		bPressedJump = false;
	}

	function ServerMove
	(
		float TimeStamp,
		vector InAccel,
		vector ClientLoc,
		bool NewbRun,
		bool NewbDuck,
		bool NewbJumpStatus,
        bool NewbDoubleJump,
		eDoubleClickDir DoubleClickMove,
		byte ClientRoll,
		int View,
		optional byte OldTimeDelta,
		optional int OldAccel
	)
	{
        Global.ServerMove(TimeStamp, InAccel, ClientLoc, NewbRun, NewbDuck, NewbJumpStatus,NewbDoubleJump,
							DoubleClickMove, ClientRoll, (32767 & (Rotation.Pitch/2)) * 32768 + (32767 & (Rotation.Yaw/2)) );

	}

	function FindGoodView()
	{
		local vector cameraLoc;
		local rotator cameraRot, ViewRotation;
		local int tries, besttry;
		local float bestdist, newdist;
		local int startYaw;
		local actor ViewActor;

		ViewRotation = Rotation;
		ViewRotation.Pitch = 56000;
		tries = 0;
		besttry = 0;
		bestdist = 0.0;
		startYaw = ViewRotation.Yaw;

		for (tries=0; tries<16; tries++)
		{
			cameraLoc = ViewTarget.Location;
			SetRotation(ViewRotation);
			PlayerCalcView(ViewActor, cameraLoc, cameraRot);
			newdist = VSize(cameraLoc - ViewTarget.Location);
			if (newdist > bestdist)
			{
				bestdist = newdist;
				besttry = tries;
			}
			ViewRotation.Yaw += 4096;
		}

		ViewRotation.Yaw = startYaw + besttry * 4096;
		SetRotation(ViewRotation);
	}

	function Timer()
	{
		if (!bIsEndingMission)
		{
			if (Level.NetMode == NM_Client || Level.NetMode == NM_ListenServer)
			{
				if ( GameReplicationInfo.GameType == GT_SKIRMISH )
					GotoState('Debriefing_Skirmish');
				else
					GotoState('Debriefing');
			}
		}
	}

	function LongClientAdjustPosition
	(
		float TimeStamp,
		name newState,
		EPhysics newPhysics,
		float NewLocX,
		float NewLocY,
		float NewLocZ,
		float NewVelX,
		float NewVelY,
		float NewVelZ,
		Actor NewBase,
		float NewFloorX,
		float NewFloorY,
		float NewFloorZ
	)
	{
	}

	function BeginState()
	{
		local Pawn P;

		EndZoom();
		if (Level.NetMode != NM_Standalone)
		{
			bFixedCamera = true;
		}

        FOVAngle = DesiredFOV;
		bFire = 0;
		bAltFire = 0;
		bMeleeFire = 0;
		if ( Pawn != None )
		{
			Pawn.Velocity = vect(0,0,0);
			Pawn.SetPhysics(PHYS_None);
			Pawn.AmbientSound = None;
			Pawn.bSpecialHUD = false;
 			Pawn.bNoWeaponFiring = true;
			Pawn.SimAnim.AnimRate = 0;
			Pawn.bPhysicsAnimUpdate = false;
			Pawn.StopAnimating();
            Pawn.SetCollision(true,false,false);
            StopFiring();
 			Pawn.bIgnoreForces = true;
		}
		
		bFrozen = true;
		if ( !bFixedCamera )
		{
			FindGoodView();
			bBehindView = true;
		}
		if (!bIsEndingMission)
		{
			SetTimer(5, false);
		}
		ForEach DynamicActors(class'Pawn', P)
		{
			if ( P.Role == ROLE_Authority )
				P.RemoteRole = ROLE_DumbProxy;
			P.SetCollision(true,false,false);
			P.AmbientSound = None;
 			P.bNoWeaponFiring = true;
			P.Velocity = vect(0,0,0);
			P.SetPhysics(PHYS_None);
            P.bPhysicsAnimUpdate = false;
            P.StopAnimating();
            P.bIgnoreForces = true;
		}
	}

Begin:
}

state Dead
{
ignores SeePlayer, HearNoise, KilledBy, SwitchWeapon, NextWeapon, PrevWeapon;

	function bool IsDead()
	{
		return true;
	}

	function ServerReStartPlayer()
	{
		Super.ServerRestartPlayer();
	}

	exec function Fire( optional float F )
	{
		if ( bFrozen )
		{
			if ( (TimerRate <= 0.0) || (TimerRate > 1.0) )
				bFrozen = false;
			return;
		}
        LoadPlayers();
		ServerReStartPlayer();
	}

	exec function AltFire( optional float F )
	{
		Fire(F);
	}

	function ServerMove
	(
		float TimeStamp,
		vector Accel,
		vector ClientLoc,
		bool NewbRun,
		bool NewbDuck,
		bool NewbJumpStatus,
        bool NewbDoubleJump,
		eDoubleClickDir DoubleClickMove,
		byte ClientRoll,
		int View,
		optional byte OldTimeDelta,
		optional int OldAccel
	)
	{
		Global.ServerMove(
					TimeStamp,
					Accel,
					ClientLoc,
					false,
					false,
					false,
                    false,
					DoubleClickMove,
					ClientRoll,
					View);
	}

	function PlayerMove(float DeltaTime)
	{
		local vector X,Y,Z;
		local rotator ViewRotation;

		if ( !bFrozen )
		{
			if ( bPressedJump )
			{
				Fire(0);
				bPressedJump = false;
			}
			GetAxes(Rotation,X,Y,Z);
			// Update view rotation.
			ViewRotation = Rotation;
			ViewRotation.Yaw += 32.0 * DeltaTime * aTurn;
			ViewRotation.Pitch += 32.0 * DeltaTime * aLookUp;
			ViewRotation.Pitch = ViewRotation.Pitch & 65535;
			If ((ViewRotation.Pitch > 18000) && (ViewRotation.Pitch < 49152))
			{
				If (aLookUp > 0)
					ViewRotation.Pitch = 18000;
				else
					ViewRotation.Pitch = 49152;
			}
			SetRotation(ViewRotation);
			if ( Role < ROLE_Authority ) // then save this move and replicate it
				ReplicateMove(DeltaTime, vect(0,0,0), DCLICK_None, rot(0,0,0));
		}
        else if ( (TimerRate <= 0.0) || (TimerRate > 1.0) )
			bFrozen = false;

		ViewShake(DeltaTime);
		ViewFlash(DeltaTime);
	}

	function FindGoodView()
	{
		local vector cameraLoc;
		local rotator cameraRot, ViewRotation;
		local int tries, besttry;
		local float bestdist, newdist;
		local int startYaw;
		local actor ViewActor;

		////log("Find good death scene view");
		ViewRotation = Rotation;
		ViewRotation.Pitch = 56000;
		tries = 0;
		besttry = 0;
		bestdist = 0.0;
		startYaw = ViewRotation.Yaw;

		for (tries=0; tries<16; tries++)
		{
			cameraLoc = ViewTarget.Location;
			SetRotation(ViewRotation);
			PlayerCalcView(ViewActor, cameraLoc, cameraRot);
			newdist = VSize(cameraLoc - ViewTarget.Location);
			if (newdist > bestdist)
			{
				bestdist = newdist;
				besttry = tries;
			}
			ViewRotation.Yaw += 4096;
		}

		ViewRotation.Yaw = startYaw + besttry * 4096;
		SetRotation(ViewRotation);
	}

	function Timer()
	{
		if (!bFrozen)
			return;

		bFrozen = false;
		bPressedJump = false;
	}

	function BeginState()
	{
		if ( (Pawn != None) && (Pawn.Controller == self) )
			Pawn.Controller = None;
		EndZoom();
		FOVAngle = DesiredFOV;
		Pawn = None;
		Enemy = None;
		bBehindView = true;
		bFrozen = true;
		bJumpStatus = false;
		bPressedJump = false;
        bBlockCloseCamera = true;
		bValidBehindCamera = false;
		FindGoodView();
        SetTimer(1.0, false);
		CleanOutSavedMoves();
	}

	function EndState()
	{
		bBlockCloseCamera = false;
		CleanOutSavedMoves();
		Velocity = vect(0,0,0);
		Acceleration = vect(0,0,0);
        if ( !PlayerReplicationInfo.bOutOfLives )
			bBehindView = false;
		bPressedJump = false;
}
Begin:
    Sleep(3.0);
}

//------------------------------------------------------------------------------
// Control options
function ChangeStairLook( bool B )
{
	bLookUpStairs = B;
	if ( bLookUpStairs )
		bAlwaysMouseLook = false;
}

function ChangeAlwaysMouseLook(Bool B)
{
	bAlwaysMouseLook = B;
	if ( bAlwaysMouseLook )
		bLookUpStairs = false;
}

// Replace with good code

function BaseGUIController GetGUIController()
{
	local PlayerController PC;

	for( PC = Level.PlayerControllerList; PC != None; PC = PC.nextPlayerController )
	{
		if (( Viewport(PC.Player) != None ) && (PC.Player.GUIController != None))
		{
			return PC.Player.GUIController;
		}
	}

	log("Warning: Could not find GUIController.", 'guilog');
	return None;
}

simulated function PreloadMenu(string Menu)
{
	local BaseGUIController GUIController;
	GUIController = GetGUIController();
	if (GUIController == None) return;

	GUIController.PreloadMenu(Menu);
}

event ClientOpenMenu (string Menu, optional bool bDisconnect, optional string Msg1, optional string Msg2, optional bool bAvoidDuplicates)
{
	OpenMenu(Menu, bDisconnect, Msg1, Msg2, bAvoidDuplicates);
}

event ClientCloseMenu(optional bool bCloseAll, optional bool bCancel, optional bool bLeaveTopMost)
{
	CloseMenu(bCloseAll, bCancel, bLeaveTopMost);
}

// From UT2k4 2005-03-23 JWS
function ClientNetworkMessage(string ParamA, string ParamB)
{
	ClientOpenMenu(class'GameEngine'.default.ConnectErrorMenuClass, true, ParamA, ParamB);
}

simulated function ClientTriggerEvent(Name EventName, Actor Other, Pawn EventInstigator)
{
	TriggerEvent(EventName, Other, EventInstigator);
}

// non-replicated versions of the menu open/close functions
event OpenMenu (string Menu, optional bool bDisconnect, optional string Msg1, optional string Msg2, optional bool bAvoidDuplicates)
{
	local BaseGUIController GUIController;
	GUIController = GetGUIController();

	log("PlayerController(" $self $") OpenMenu" @menu @"using GUIController" @GUIController, 'guilog');
	if (GUIController == None) return;

	GUIController.OpenMenu(Menu, Msg1, Msg2, bAvoidDuplicates);

	if (bDisconnect)
		ConsoleCommand("Disconnect");
}

event CloseMenu(optional bool bCloseAll, optional bool bCancel, optional bool bLeaveTopMost)
{
	local BaseGUIController GUIController;
	GUIController = GetGUIController();

	log("PlayerController(" $self $") ClientCloseMenu using GUIController" @GUIController, 'guilog');
	if (GUIController == None) return;

	if (bCloseAll)
		GUIController.CloseAll(bCancel, bLeaveTopMost);
	else
		GUIController.CloseMenu(bCancel);
}

event bool MenuIsOpen(string MenuClassName)
{
	local bool result;
	local BaseGUIController GUIController;
	GUIController = GetGUIController();

	if (GUIController != None)
	{
		result = GUIController.MenuIsOpen(MenuClassName);
	}
	
	return result;
}

event bool MenuIsActive()
{
	local BaseGUIController GUIController;

	GUIController = GetGUIController();
	if (GUIController != None)
		return GUIController.bActive;
	
	return false;
}

function DisplayMissionFinished(bool bSuccess, optional string params)
{
	local BaseGUIController GUIController;
	GUIController = GetGUIController();
	
	if ((Level.NetMode != NM_Standalone) || Level.IsMenuMap())
		return;

	if (bSuccess)
	{
		// DEMO UBI STATS UPDATE
		if (GUIController.bIsDemoVersion && Level.GetLevelFileName() == "D08_1030_CLOSEQUARTERS")
		{
			log("CLOSE QUARTERS IS WON!",'CRG');
			ConsoleCommand("DEMO_LEVEL_END_CQ");
			ConsoleCommand("DEMO_COMPLETED");
		}
	
		ClientOpenMenu(class'GameEngine'.default.SuccessMenuClass,, params);
	}
	else
		ClientOpenMenu(class'GameEngine'.default.FailedMenuClass,, params);
}

function bool CanRestartPlayer()
{
    return !PlayerReplicationInfo.bOnlySpectator;
}

event ServerSetVoiceBan( bool voiceBanned )
{
	PlayerReplicationInfo.bVoiceBanned = voiceBanned;
}

event ServerSetHasCommunicator( bool hasCommunicator )
{
	PlayerReplicationInfo.bHasCommunicator = hasCommunicator;
}

// jij ---
event ServerChangeChannel( PlayerController Player, XboxAddr XbAddr, int PortNo, int Channel )
{
	if ( (Player.PlayerReplicationInfo != None) && (Player.PlayerReplicationInfo.VoiceChatterHandle == 0) )
	{
		Player.PlayerReplicationInfo.VoiceChatterHandle = GetNextVoiceChatterHandle();
		log("Assigned voice chatter handle " $ Player.PlayerReplicationInfo.VoiceChatterHandle, 'MP');
	}

	XbAddr.GamerTag = Player.GamerTag;
	XbAddr.VoiceChatterHandle = Player.PlayerReplicationInfo.VoiceChatterHandle;

    if( (Level.NetMode == NM_DedicatedServer) || (Level.NetMode == NM_ListenServer) )
    {
        if (Channel == -1)
        {
            // select the best channel for this client to be in
            Level.Game.JoinBestVoiceChannel(Player, xbAddr, PortNo, true);
        }
        else if (Channel == -2)
        {
            // client wants to leave the channel, notify everyone
            Level.Game.LeaveVoiceChannel(Player, xbAddr, PortNo, Channel, true);
        }
        else if (Channel == -3)
        {
            // client wants to join best channel, but from script (so no XboxAddr/PortNo)
            Level.Game.JoinBestVoiceChannel(Player, xbAddr, PortNo, false);
        }
        else if (Channel <= -4)
        {
            // client wants to join a specific channel, but from script (so no XboxAddr/PortNo)
            Channel = -Channel;
            Channel -= 4;
            Level.Game.JoinVoiceChannel(Player, xbAddr, PortNo, Channel, false);
        }
        else
        {
            // try to join the specified channel, if it is not already full
            Level.Game.JoinVoiceChannel(Player, xbAddr, PortNo, Channel, true);
        }
    }
}

simulated function ClientChangeVoiceChatter( XboxAddr xbAddr, int PortNo, bool Add, optional bool isLocalChatter )
{
	ChangeVoiceChatter( xbAddr, PortNo, Add, isLocalChatter );
}

simulated function ClientLeaveVoiceChat()
{
	LeaveVoiceChat();
}

simulated function ClientChangeChannel(int Channel)
{
    VoiceChannel = Channel;
    if (PlayerReplicationInfo != None)
        PlayerReplicationInfo.VoiceChannel = Channel;
}

native final function LeaveVoiceChat();
native final function ChangeVoiceChatter( XboxAddr xbAddr, int PortNo, bool Add, bool isLocalChatter );
native final function int GetNextVoiceChatterHandle();
// --- jij

//--------------------- Demo recording stuff

// Called on the client during client-side demo recording
simulated event StartClientDemoRec()
{
	// Here we replicate functions which the demo never saw.
	DemoClientSetHUD( MyHud.Class, MyHud.ScoreBoard.Class );

	// tell server to replicate more stuff to me
	bClientDemo = true;
	ServerSetClientDemo();
}

function ServerSetClientDemo()
{
	bClientDemo = true;
}

// Called on the playback client during client-side demo playback
simulated function DemoClientSetHUD(class<HUD> newHUDClass, class<Scoreboard> newScoringClass )
{
	if( MyHUD == None )
	{
		ClientSetHUD( newHUDClass, newScoringClass );
	}
}

function CalculateTargetAngularVelocity( out AimAssistParameters Params )
{
	local vector p, v;
	local float r, rr;

	// Calculate target lead direction/rate
	p = Pawn.Location - Params.FoundTarget.Location;	// vector from target to player
	v = Pawn.Velocity - Params.FoundTarget.Velocity;  // relative velocity of target to player
	rr = p.X*p.X + p.Y*p.Y;
	r  = sqrt(rr);

	// Returns radians, convert to rotational units
	Params.TargetAngularVelocity.yaw = FClamp( (((p.X*v.Y - p.Y*v.X)/rr) * 32768)/Pi, -32768, 32768 );  // Max yaw adjustment is +/- 180 deg.
	Params.TargetAngularVelocity.pitch = FClamp( ((r*v.Z - p.Z/r*(p.X*v.X + p.Y*v.Y))/(rr + p.Z*p.Z) * 32768)/Pi, -16384, 16384 ); // Max pitch adjustment is +/- 90 deg.
}

function bool GetAutoAimTarget( out AimAssistParameters Params )
{
	local Actor A, HitActor;
	local Pawn TestPawn;
	local vector RotationVector, TargetVector, AimToTarget, StartTrace, EndTrace, HitNormal, HitLocation;
	local float AimAngle;

	if( Pawn == None )
	{
		return false;
	}

	//Perf_Begin("SJP+++ GetAutoAimTarget");

	// Clear the output variables in case they were already set
	Params.FoundTarget = None;
	Params.AimToTargetVector = vect(0,0,0);

	if( Params.TargetBaseClass == None )
		return false;

	// My view rotation vector
	RotationVector = Vector( Pawn.GetViewRotation() );

	foreach DynamicActors( Params.TargetBaseClass, A )
	{
		TestPawn = Pawn(A);

		// Don't worry about myself or dead things or friends
		if( TestPawn == None || TestPawn == Pawn || TestPawn.IsDead() || TestPawn.Controller == None || TestPawn.Controller.SameTeamAs( Self ))
			continue;

		// Vector from player to target
		TargetVector = TestPawn.Location - Pawn.Location;

		// Skip pawns that are out of range, if specified
		if( Params.SearchRadius != 0.0 && VSizeSquared(TargetVector) > Params.SearchRadius * Params.SearchRadius )
			continue;

		AimAngle = ACos(Normal(TargetVector) Dot RotationVector) * 57.2957795; // 180/Pi ~= 57.2957795

		// Only worry about pawns in our view
		if( AimAngle < DesiredFOV / 2 )
		{
			// Shortest distance perpendicular from player's aim vector to target Pawn
			AimToTarget = RotationVector Cross TargetVector;

			if( (Params.AimStyle == AimAssistStyle.LeadTarget && AimAngle <= Params.LeadTargetMaxAngle) ||
				(Params.AimStyle == AimAssistStyle.StickToTarget && VSize(AimToTarget) <= Params.AimAlignmentThreshold) )
			{
				// Finally, make sure the selected target is visible

				StartTrace = Pawn.Location + Pawn.EyePosition();
				EndTrace = TestPawn.Location + TestPawn.EyePosition();

				HitActor = Trace( HitLocation, HitNormal, EndTrace, StartTrace, true );

				// The best target will be the closest target to the player
				if( HitActor == TestPawn && (Params.FoundTarget == None || VSize(TargetVector) < Params.DistanceToTarget) )
				{
					Params.FoundTarget = TestPawn;
					Params.AimToTargetVector = AimToTarget;
					Params.DistanceToTarget = VSize(TargetVector);
					Params.AimToTargetAngle = AimAngle;
				}
			}
		}
	}

	//Perf_End();

	return Params.FoundTarget != None;
}

function float ComputeCompositeAttenuation( float angle, float maxAngle, float distance, float maxDistance )
{
	return ComputeAttenuation(0.5, angle, maxAngle) * ComputeAttenuation(0.5, distance, maxDistance);
}

simulated event UpdatePlayer(string newName)
{
    ProfileName = newName;

    if (GetCurrentGameProfile() != None)
    {
        return;
    }
    ChangeName(newName);
	if (Level.NetMode != NM_DedicatedServer)
    {
        log("Sending Force/switch/taunt settings to server.");
        UpdateForceFeedbackProperties( ForceFeedbackSupported(), bEnableWeaponForceFeedback, bEnablePickupForceFeedback, bEnableDamageForceFeedback, bEnableGUIForceFeedback );  // jdf
//        UpdateSwitchWeaponOnPickup(bNeverSwitchOnPickup);
//        ServerSetAutotaunt(bAutoTaunt);
    }
}

// Need a stub for this in gbxEffects
function CreateHudDirtEffect( int numParticles );
function CreateHudRainEffect( int numParticles );

exec function Unlock(optional string mode)
{
	if (mode ~= "RANDOM")
	{
		class'Engine.GameProfile'.Static.UnlockProfile(Level, ProfileName, true);
	}
	else
	{
		class'Engine.GameProfile'.Static.UnlockProfile(Level, ProfileName, false);
	}
}

simulated function bool ReloadAfterWeaponFire()
{
	return (bDontReloadAfterFire == false);
}

simulated function PlayerInput GetPlayerInput()
{
	return PlayerInput;
}

static function string ParseTokenDelimited(out string str, optional string delimiter)
{
	local string result;
	local int index;

	result = "";
	if (delimiter == "")
		delimiter = ",";

    index = InStr(str, delimiter);
    if (index < 0)
    {
        result = str;
		str = "";
    }
	else
	{
		result = Left(str, index);
		str = Right(str, Len(str) - index - 1);
	}

	return result;
}

function TrimSpaces(out string s)
{
	while( Left(s,1)==" " || Asc(Left(s,1))==9 )
		s = Mid(s, 1);

	while( Right(s,1)==" " || Asc(Left(s,1))==9 )
		s = Left(s, Len(s)-1);
}

function bool KeyBindingMatchesToken(string KeyBinding, string Token)
{
	local string s, InStr;

	InStr = KeyBinding;
	TrimSpaces(InStr);

	while (true)
	{
		s = ParseTokenDelimited(InStr, "|");
		TrimSpaces(s);

		if (s == "")
		{
			break;  // done, no match
		}

		if ((Len(Token) == Len(s)) && (Token ~= s))
		{
			return true;
		}

		if ((Token ~= Left(s, Len(Token))) && (Mid(s, Len(Token), 1) == " "))
		{
			return true;
		}
	}

	return false;
}

event InitKeyBindings()
{
	local int i, j;
	local bool found;
	local string KeyName, Alias;
	local int blockedkeymask, blockedbuttonmask;  //save the current blocked key/button state

	if (bKeybindingsInitialized)
		return;

	bKeybindingsInitialized = true;

	if (!bInBlockUnblockState)  // did we call this function from within Block/UnBlock native code, if so, don't cause infinite recursion
	{
		// if keyboard/controller bindings have changed, we need to unblock keys/buttons, load the new aliases,
		// then block the keys/buttons again...

		// save any previously blocked keys/buttons so that we can unblock them, then block them again below
		blockedkeymask = PreviousBlockedActionKeyMask;
		blockedbuttonmask = PreviousBlockedButtonMask;

		if (blockedkeymask != 0)
			UnblockActionKeys( blockedkeymask );
		if (blockedbuttonmask != 0)
			UnblockXboxButtons( blockedbuttonmask );
	}

	if (Level.IsXbox())
	{
		for (i=0; i < XboxKeyBindings.Length; i++)
		{
			XboxKeyBindings[i].Alias = ConsoleCommand("KEYBINDING"@XboxKeyBindings[i].KeyName);
		}

		for (i=0; i < XboxThumbstickBindings.Length; i++)
		{
			XboxThumbstickBindings[i].Alias = ConsoleCommand("KEYBINDING"@XboxThumbstickBindings[i].KeyName);
		}

		// find the Alias that matches each Action Key Binding...
		for (j=0; j < ActionKeyBindings.Length; j++)
		{
			found = false;

			for (i=0; i < XboxKeyBindings.Length; i++)
			{
				if (KeyBindingMatchesToken(XboxKeyBindings[i].Alias, ActionKeyBindings[j].Action))
				{
					ActionKeyBindings[j].KeyName = XboxKeyBindings[i].KeyName;
					found = true;
					break;
				}
			}

			if (!found)
				Log("ActionKeyBindings["$j$"].Action="$ActionKeyBindings[j].Action$" not found in any Alias!!!");
		}

		// find the Alias that matches each Action Thumbstick Binding...
		for (j=0; j < ActionThumbstickBindings.Length; j++)
		{
			found = false;

			for (i=0; i < XboxThumbstickBindings.Length; i++)
			{
				if (InStr(XboxThumbstickBindings[i].Alias, ActionThumbstickBindings[j].Action) >= 0)
				{
					ActionThumbstickBindings[j].KeyName = XboxThumbstickBindings[i].KeyName;
					found = true;
					break;
				}
			}

			if (!found)
				Log("ActionThumbstickBindings["$j$"].Action="$ActionThumbstickBindings[j].Action$" not found in any Alias!!!");
		}
	}
	else
	{
		// remove all existing PCKeyBindings first (in case we've changed some keybindings and running this multiple times...
		if (PCKeyBindings.Length > 0)
			PCKeyBindings.Remove(0, PCKeyBindings.Length);

		for (i=0; i < 255; i++)
		{
			KeyName = ConsoleCommand("KEYNAME"@i);
//			LocalizedKeyName = ConsoleCommand("LOCALIZEDKEYNAME"@i);
			if (KeyName != "")
			{
				Alias = ConsoleCommand("KEYBINDING"@KeyName);
				if (Alias != "")
				{
					PCKeyBindings.Length = PCKeyBindings.Length + 1;
					PCKeyBindings[PCKeyBindings.Length-1].InputKey = i;
					PCKeyBindings[PCKeyBindings.Length-1].KeyName = KeyName;
					PCKeyBindings[PCKeyBindings.Length-1].Alias = Alias;
				}
			}
		}

		// find the Alias that matches each Action Key Binding...
		for (j=0; j < ActionKeyBindings.Length; j++)
		{
			found = false;

			for (i=0; i < PCKeyBindings.Length; i++)
			{
				if (KeyBindingMatchesToken(PCKeyBindings[i].Alias, ActionKeyBindings[j].Action))
				{
					ActionKeyBindings[j].KeyName = PCKeyBindings[i].KeyName;
					found = true;
					break;
				}
			}

			if (!found)
				Log("ActionKeyBindings["$j$"].Action="$ActionKeyBindings[j].Action$" not found in any Alias!!!");
		}

		// find the Alias that matches each Action Movement/Look Binding...
		for (j=0; j < ActionPCMoveLookBindings.Length; j++)
		{
			found = false;

			for (i=0; i < PCKeyBindings.Length; i++)
			{
				if (InStr(PCKeyBindings[i].Alias, ActionPCMoveLookBindings[j].Action) >= 0)
				{
					ActionPCMoveLookBindings[j].KeyName = PCKeyBindings[i].KeyName;
					found = true;
					break;
				}
			}

			if (!found)
				Log("ActionPCMoveLookBindings["$j$"].Action="$ActionPCMoveLookBindings[j].Action$" not found in any Alias!!!");
		}

	}

	if (ActionBindings.Length > 0)
		ActionBindings.Remove(0, ActionBindings.Length);

	if (Level.IsXbox())
	{
		// for each Action, add ActionKeyBindings and ActionThumbstickBindings to the ActionBindings array
		for (i=0; i < ActionKeyBindings.Length; i++)
		{
			for (j=0; j < XboxKeyBindings.Length; j++)
			{
				if (KeyBindingMatchesToken(XboxKeyBindings[j].Alias, ActionKeyBindings[i].Action))
				{
					ActionBindings.Length = ActionBindings.Length + 1;
					ActionBindings[ActionBindings.Length - 1].InputKey = XboxKeyBindings[j].InputKey;
					ActionBindings[ActionBindings.Length - 1].Action = ActionKeyBindings[i].Action;
					ActionBindings[ActionBindings.Length - 1].KeyName = XboxKeyBindings[j].KeyName;
				}
			}
			for (j=0; j < XboxThumbstickBindings.Length; j++)
			{
				if (KeyBindingMatchesToken(XboxThumbstickBindings[j].Alias, ActionKeyBindings[i].Action))
				{
					ActionBindings.Length = ActionBindings.Length + 1;
					ActionBindings[ActionBindings.Length - 1].InputKey = XboxThumbstickBindings[j].InputKey;
					ActionBindings[ActionBindings.Length - 1].Action = ActionKeyBindings[i].Action;
					ActionBindings[ActionBindings.Length - 1].KeyName = XboxThumbstickBindings[j].KeyName;
				}
			}
		}

		for (i=0; i < ActionThumbstickBindings.Length; i++)
		{
			for (j=0; j < XboxKeyBindings.Length; j++)
			{
				if (KeyBindingMatchesToken(XboxKeyBindings[j].Alias, ActionThumbstickBindings[i].Action))
				{
					ActionBindings.Length = ActionBindings.Length + 1;
					ActionBindings[ActionBindings.Length - 1].InputKey = XboxKeyBindings[j].InputKey;
					ActionBindings[ActionBindings.Length - 1].Action = ActionThumbstickBindings[i].Action;
					ActionBindings[ActionBindings.Length - 1].KeyName = XboxKeyBindings[j].KeyName;
				}
			}
			for (j=0; j < XboxThumbstickBindings.Length; j++)
			{
				if (KeyBindingMatchesToken(XboxThumbstickBindings[j].Alias, ActionThumbstickBindings[i].Action))
				{
					ActionBindings.Length = ActionBindings.Length + 1;
					ActionBindings[ActionBindings.Length - 1].InputKey = XboxThumbstickBindings[j].InputKey;
					ActionBindings[ActionBindings.Length - 1].Action = ActionThumbstickBindings[i].Action;
					ActionBindings[ActionBindings.Length - 1].KeyName = XboxThumbstickBindings[j].KeyName;
				}
			}
		}
	}
	else
	{
		// for each Action, check KeyBindingMatchesToken for all PCKeyBindings and add to ActionBindings array
		for (i=0; i < ActionKeyBindings.Length; i++)
		{
			for (j=0; j < PCKeyBindings.Length; j++)
			{
				if (KeyBindingMatchesToken(PCKeyBindings[j].Alias, ActionKeyBindings[i].Action))
				{
					ActionBindings.Length = ActionBindings.Length + 1;
					ActionBindings[ActionBindings.Length - 1].InputKey = PCKeyBindings[j].InputKey;
					ActionBindings[ActionBindings.Length - 1].Action = ActionKeyBindings[i].Action;
					ActionBindings[ActionBindings.Length - 1].KeyName = PCKeyBindings[j].KeyName;
				}
			}
		}

		for (i=0; i < ActionPCMoveLookBindings.Length; i++)
		{
			for (j=0; j < PCKeyBindings.Length; j++)
			{
				if (KeyBindingMatchesToken(PCKeyBindings[j].Alias, ActionPCMoveLookBindings[i].Action))
				{
					ActionBindings.Length = ActionBindings.Length + 1;
					ActionBindings[ActionBindings.Length - 1].InputKey = PCKeyBindings[j].InputKey;
					ActionBindings[ActionBindings.Length - 1].Action = ActionPCMoveLookBindings[i].Action;
					ActionBindings[ActionBindings.Length - 1].KeyName = PCKeyBindings[j].KeyName;
				}
			}
		}
	}

	if (!bInBlockUnblockState)  // did we call this function from within Block/UnBlock native code, if so, don't cause infinite recursion
	{
		// now block any keys/buttons that were previously blocked...
		if (blockedkeymask != 0)
			BlockActionKeys( blockedkeymask );
		if (blockedbuttonmask != 0)
			BlockXboxButtons( blockedbuttonmask );
	}
}

function DeactivateOracleImmediately();

function FadePlayerScreen( byte bFadeType, float flFadeTime, bool bFadePersistant )
{
	if (Viewport(Player) != None)
	{
		Level.m_bFadeScreen = bFadeType;
		Level.m_flStartFadeTime = Level.TimeSeconds;
		Level.m_flFadeTime = flFadeTime;
		if (bFadePersistant)
		{
			MyHUD.SetPersistantFadeOverride( true );
		}
		else
		{
			MyHUD.SetPersistantFadeOverride( false );
			MyHUD.SetFadeOverride( true );
		}
	}
	else
	{
		ClientFadePlayerScreen( bFadeType, flFadeTime, bFadePersistant );
	}
}

function ClientFadePlayerScreen( byte bFadeType, float flFadeTime, bool bFadePersistant )
{
	Level.m_bFadeScreen = bFadeType;
	Level.m_flStartFadeTime = Level.TimeSeconds;
	Level.m_flFadeTime = flFadeTime;
	if (bFadePersistant)
	{
		MyHUD.SetPersistantFadeOverride( true );
	}
	else
	{
		MyHUD.SetPersistantFadeOverride( false );
		MyHUD.SetFadeOverride( true );
	}
}

defaultproperties
{
	bHidden=true
	 AimingHelp=0.0
     OrthoZoom=+40000.000000
     FlashScale=(X=1.000000,Y=1.000000,Z=1.000000)
	 AnnouncerVolume=4
	 FOVAngle=85.000
     DesiredFOV=70.000000
	 DefaultFOV=70.000000
	 FOVRate=20.000000
     Handedness=1.000000
     bAlwaysMouseLook=True
	 ViewingFrom="Now viewing from"
	 OwnCamera="Now viewing from own camera"
     QuickSaveString="Quick Saving"
     NoPauseMessage="Game is not pauseable"
     bTravel=True
     bStasis=False
	 NetPriority=3
    MaxTimeMargin=+0.35
	 LocalMessageClass=class'LocalMessage'
	 bIsPlayer=true
	 bCanOpenDoors=true
	 bCanDoSpecial=true
	 Physics=PHYS_None
	 EnemyTurnSpeed=45000
	 CheatClass=class'Engine.CheatManager'
	 InputClass=class'Engine.PlayerInput'
	 CameraDist=+9.0	// PSV: 6/16/2004 Changed from 9 units for MP field promotion...doesn't seem to affect anything in SP
	CameraDistRange=(Min=3.0,Max=40.0)
	 bZeroRoll=true
    bDynamicNetSpeed=true
    // jdf ---
	bEnableForceFeedback=True
    bEnableWeaponForceFeedback=True
    bEnablePickupForceFeedback=True
    bEnableDamageForceFeedback=True
    bEnableGUIForceFeedback=False
    bForceFeedbackSupported=False
    // --- jdf
    ProgressTimeOut=0.0

    // jij ---
	ListenToVoiceOnSpeaker=True
    VoiceMask=0
    OnlineStatus=1
    // --- jij

    bIsGuest=true

    MaxResponseTime=0.7
    SpectateSpeed=+600.0
    DynamicPingThreshold=+400.0
    ClientCap=0

    NetSplitID=-1
    Skill=0

	bUseCrouchToggle = true
	CrouchHoldToStandThreshold = 0.5

	// By default, aim assist will do nothing
	AimAssistParams=(TargetBaseClass=None);

	bInOracleCameraMP = false
	bCameraRotationLocked = false

	BloodEffectIndex = 0
	DirtEffectIndex = 1
	RainEffectIndex = 2

	bIsHumanPlayer=true
	bKeybindingsInitialized=false

	bDisableSubtitles=true
	bDisableHints=false
	bDisableTraining=false
	iAudioMode=2			// PSV: 4/1/2005 add audio option (defaults to software 3D)
	bSystemDriver=true// PSV: 4/4/2005 added more audio options
	bReverseStereo = false	// PSV: 4/4/2005 added more audio options
	bStreamingAudio = true	// PSV: 8/6/2005 added option to enable/disable streaming audio
	bLowDetailTextures = false //NAC: Added to toggle DetailTexture settings on PC
	bUseCube = true;		//NAC: Added to toggle use of cubemap render target
	fGrassDetail = 1.0;	//NAC: Added to tweak grass detail
	iCrossHairIndex=0
	iScreenBrightness=5
	iScreenGamma=5;		//NAC: added to tweak gamma settings on PC
	iScreenContrast=5;	//NAC: added to tweak contrast settings on PC
	iAFiltering=1;	//NAC: Added to tweak Anisotropic Filtering Values
	bUseVsync=false;		//NAC: Added to toggle use of Vsync
	iMasterVolume=10
	iMusicVolume=10
	bShowFullServers=false
	bShowEmptyServers=false

	XboxKeyBindings(0)=(InputKey=200,KeyName="Joy1",Alias="",IconText="%button_a%")
	XboxKeyBindings(1)=(InputKey=201,KeyName="Joy2",Alias="",IconText="%button_b%")
	XboxKeyBindings(2)=(InputKey=202,KeyName="Joy3",Alias="",IconText="%button_x%")
	XboxKeyBindings(3)=(InputKey=203,KeyName="Joy4",Alias="",IconText="%button_y%")
	XboxKeyBindings(4)=(InputKey=204,KeyName="Joy5",Alias="",IconText="%button_black%")
	XboxKeyBindings(5)=(InputKey=205,KeyName="Joy6",Alias="",IconText="%button_white%")
	XboxKeyBindings(6)=(InputKey=206,KeyName="Joy7",Alias="",IconText="%button_L_trigger%")
	XboxKeyBindings(7)=(InputKey=207,KeyName="Joy8",Alias="",IconText="%button_R_trigger%")
	XboxKeyBindings(8)=(InputKey=208,KeyName="Joy9",Alias="",IconText="%button_dpad%%button_U_arrow%")
	XboxKeyBindings(9)=(InputKey=209,KeyName="Joy10",Alias="",IconText="%button_dpad%%button_D_arrow%")
	XboxKeyBindings(10)=(InputKey=210,KeyName="Joy11",Alias="",IconText="%button_dpad%%button_L_arrow%")
	XboxKeyBindings(11)=(InputKey=211,KeyName="Joy12",Alias="",IconText="%button_dpad%%button_R_arrow%")
	XboxKeyBindings(12)=(InputKey=212,KeyName="Joy13",Alias="",IconText="%button_START%")
	XboxKeyBindings(13)=(InputKey=213,KeyName="Joy14",Alias="",IconText="%button_BACK%")
	XboxKeyBindings(14)=(InputKey=214,KeyName="Joy15",Alias="",IconText="%button_L_thumbstick%")
	XboxKeyBindings(15)=(InputKey=215,KeyName="Joy16",Alias="",IconText="%button_R_thumbstick%")

	XboxThumbstickBindings(0)=(InputKey=224,KeyName="JoyX",Alias="",IconText="%button_L_thumbstick%")
	XboxThumbstickBindings(1)=(InputKey=225,KeyName="JoyY",Alias="",IconText="%button_L_thumbstick%")
	XboxThumbstickBindings(2)=(InputKey=232,KeyName="JoyU",Alias="",IconText="%button_R_thumbstick%")
	XboxThumbstickBindings(3)=(InputKey=233,KeyName="JoyV",Alias="",IconText="%button_R_thumbstick%")

	// these will have "%action" or "%icon" added in front of the Keyword...
	ActionKeyBindings(0)=(Keyword="_jump%",Action="Jump",KeyName="")
	ActionKeyBindings(1)=(Keyword="_melee%",Action="MeleeAttack",KeyName="")
	ActionKeyBindings(2)=(Keyword="_use%",Action="AUse",KeyName="")
	ActionKeyBindings(3)=(Keyword="_throw_grenade%",Action="AltFire",KeyName="")
	ActionKeyBindings(4)=(Keyword="_cycle_weapon%",Action="ASelectWeapon",KeyName="")
	ActionKeyBindings(5)=(Keyword="_team_select%",Action="UnitSelect",KeyName="")
	ActionKeyBindings(6)=(Keyword="_order%",Action="ACommand",KeyName="")
	ActionKeyBindings(7)=(Keyword="_fire%",Action="Fire",KeyName="")
	ActionKeyBindings(8)=(Keyword="_fall_out",Action="FallOutInput",KeyName="")
	ActionKeyBindings(9)=(Keyword="_fall_in%",Action="FallInInput",KeyName="")
	ActionKeyBindings(10)=(Keyword="_sa_left%",Action="PrevOracleCamTarget",KeyName="")
	ActionKeyBindings(11)=(Keyword="_sa_right%",Action="NextOracleCamTarget",KeyName="")
	ActionKeyBindings(12)=(Keyword="",Action="ShowMenu",KeyName="")
	ActionKeyBindings(13)=(Keyword="_sa_view%",Action="ActivateOracleKey",KeyName="")
	ActionKeyBindings(14)=(Keyword="_crouch%",Action="Duck",KeyName="")
	ActionKeyBindings(15)=(Keyword="_zoom%",Action="AZoom",KeyName="")
	ActionKeyBindings(16)=(Keyword="_continue%",Action="Continue",KeyName="")
	ActionKeyBindings(17)=(Keyword="_cancel%",Action="Cancel",KeyName="")
	ActionKeyBindings(18)=(Keyword="_sa_up%",Action="OracleCamTargetObjective",KeyName="")
	ActionKeyBindings(19)=(Keyword="_sa_down%",Action="OracleCamTargetSelf",KeyName="")
	ActionKeyBindings(20)=(Keyword="_reload%",Action="ReloadKey",KeyName="")

	ActionPCMoveLookBindings(0)=(Keyword="_move%",Action="StrafeLeft",KeyName="")
	ActionPCMoveLookBindings(1)=(Keyword="_move%",Action="StrafeRight",KeyName="")
	ActionPCMoveLookBindings(2)=(Keyword="_move%",Action="MoveForward",KeyName="")
	ActionPCMoveLookBindings(3)=(Keyword="_move%",Action="MoveBackward",KeyName="")
	ActionPCMoveLookBindings(4)=(Keyword="",Action="Axis aMouseX",KeyName="")
	ActionPCMoveLookBindings(5)=(Keyword="_look%",Action="Axis aMouseY",KeyName="")

	ActionThumbstickBindings(0)=(Keyword="_move%",Action="Axis aStrafe",KeyName="")
	ActionThumbstickBindings(1)=(Keyword="",Action="Axis aBaseY",KeyName="")
	ActionThumbstickBindings(2)=(Keyword="",Action="Axis aBaseX",KeyName="")
	ActionThumbstickBindings(3)=(Keyword="_look%",Action="Axis aLookup",KeyName="")

	KeyActionArray(0)="Jump"
	KeyActionArray(1)="MeleeAttack"
	KeyActionArray(2)="AUse"
	KeyActionArray(3)="AltFire"
	KeyActionArray(4)="ASelectWeapon"
	KeyActionArray(5)="UnitSelect"
	KeyActionArray(6)="ACommand"
	KeyActionArray(7)="Fire"
	KeyActionArray(8)="FallOutInput"
	KeyActionArray(9)="FallInInput"
	KeyActionArray(10)="ASelectUnitFire"
	KeyActionArray(11)="ASelectUnitAssault"
	KeyActionArray(12)="ShowMenu"
	KeyActionArray(13)="ActivateOracleKey"
	KeyActionArray(14)="Duck"
	KeyActionArray(15)="AZoom"
	KeyActionArray(16)="Axis aStrafe"
	KeyActionArray(17)="Axis aLookup"
	KeyActionArray(18)="ReloadKey"
	KeyActionArray(19)="PrevOracleCamTarget"
	KeyActionArray(20)="NextOracleCamTarget"
	KeyActionArray(21)="Continue"
	KeyActionArray(22)="Cancel"
	KeyActionArray(23)="OracleCamTargetObjective"
	KeyActionArray(24)="OracleCamTargetSelf"

    VehicleCheckRadius=700.0
}
//=============================================================================
// PlayerInput
// Object within playercontroller that manages player input.
// only spawned on client
//=============================================================================

class PlayerInput extends Object within PlayerController
	config(User)
	native
	transient;



var globalconfig	bool	bInvertMouse;

var bool		bWasForward;	// used for doubleclick move
var bool		bWasBack;
var bool		bWasLeft;
var bool		bWasRight;
var bool		bEdgeForward;
var bool		bEdgeBack;
var bool		bEdgeLeft;
var bool 		bEdgeRight;
var	bool		bAdjustSampling;

// Mouse smoothing
var globalconfig byte   MouseSmoothingMode;
var globalconfig float  MouseSmoothingStrength;
var globalconfig float	MouseSensitivity;
var globalconfig float  MouseSamplingTime;
var globalconfig float  MouseAccelThreshold;

var globalconfig bool  bUseAimAssist;

var float SmoothedMouse[2], ZeroTime[2], SamplingTime[2], MaybeTime[2], OldSamples[4];
var int MouseSamples[2];

var	float DoubleClickTimer; // max double click interval for double click move
var globalconfig float	DoubleClickTime;


//=============================================================================
// Input related functions.

function bool InvertLook();

// Postprocess the player's input.
event PlayerInput( float DeltaTime )
{
	local float FOVScale, MouseScale, flGroundSpeed;

	// Ignore input if we're playing back a client-side demo.
	if( Outer.bDemoOwner && !Outer.default.bDemoOwner )
		return;

	// GBX:naj - added 11/21/03 - to avoid Accessed None msgs.
	if ( Pawn == None )
		flGroundSpeed = class'Pawn'.Default.GroundSpeed;
	else
		flGroundSpeed = Pawn.GroundSpeed;

	// Check for Double click move
	// flag transitions
	bEdgeForward = (bWasForward ^^ (aBaseY > (flGroundSpeed * 0.95) ));
	bEdgeBack = (bWasBack ^^ (aBaseY < 0));
	bEdgeLeft = (bWasLeft ^^ (aStrafe < 0));
	bEdgeRight = (bWasRight ^^ (aStrafe > 0));
	bWasForward = (aBaseY > (flGroundSpeed * 0.95) );
	bWasBack = (aBaseY < 0);
	bWasLeft = (aStrafe < 0);
	bWasRight = (aStrafe > 0);

	// Smooth and amplify mouse movement
	FOVScale = DesiredFOV * 0.0142857; // 1/70
	MouseScale = MouseSensitivity * FOVScale;
	aMouseX = SmoothMouse(aMouseX*MouseScale, DeltaTime,bXAxis,0);
	aMouseY = SmoothMouse(aMouseY*MouseScale, DeltaTime,bYAxis,1);

	aMouseX = AccelerateMouse(aMouseX);
	aMouseY = AccelerateMouse(aMouseY);

	// adjust keyboard and joystick movements
	aLookUp *= FOVScale;
	aTurn   *= FOVScale;

	// Remap raw x-axis movement.
	if( bStrafe!=0 ) // strafe
		aStrafe += aBaseX * 7.5 + aMouseX;
	else // forward
		aTurn  += aBaseX * FOVScale + aMouseX;
	aBaseX = 0;

	// Remap mouse y-axis movement.
	if( (bStrafe == 0) && (bAlwaysMouseLook || (bLook!=0)) )
	{
		// Look up/down.
		if ( bInvertMouse )
			aLookUp -= aMouseY;
		else
			aLookUp += aMouseY;
	}
	else // Move forward/backward.
		aForward += aMouseY;

	if ( bSnapLevel != 0 )
	{
		bCenterView = true;
		bKeyboardLook = false;
	}
	else if (aLookUp != 0)
	{
		bCenterView = false;
		bKeyboardLook = true;
	}
	else if ( bSnapToLevel && !bAlwaysMouseLook )
	{
		bCenterView = true;
		bKeyboardLook = false;
	}

	// Remap other y-axis movement.
	if ( bFreeLook != 0 )
	{
		bKeyboardLook = true;
		aLookUp += 0.5 * aBaseY * FOVScale;
	}
	else
		aForward += aBaseY;

	aBaseY = 0;

	// Handle walking.
	HandleWalking();
}

exec function SetSmoothingMode(byte B)
{
	MouseSmoothingMode = B;
	log("Smoothing mode "$MouseSmoothingMode);
}

exec function SetSmoothingStrength(float F)
{
	MouseSmoothingStrength = FClamp(F,0,1);
}

exec function InvertMouse()
{
	bInvertMouse = !bInvertMouse;
}

//NAC: added function to set the mouse sensitvity via console
exec function SetMouseSensitivity(float x){
	UpdateSensitivity(x);
}
function float AccelerateMouse(float aMouse)
{
	local float Accel;

	if ( abs(aMouse) == 0 )
		return 0;

	Accel = MouseAccelThreshold * MouseSensitivity;
	if ( abs(aMouse) < Accel )
	{
		if ( abs(aMouse) < 0.1 * Accel )
			aMouse *= 0.1;
		else
			aMouse = aMouse * abs(aMouse)/Accel;
	}
	return aMouse;
}

function float SmoothMouse(float aMouse, float DeltaTime, out byte SampleCount, int Index)
{
	local int i, sum;
	local float delta;

	if ( MouseSmoothingMode == 0 )
		return aMouse;

	if ( aMouse == 0 )
	{
		ZeroTime[Index] += DeltaTime;
		if ( ZeroTime[Index] < MouseSamplingTime )
		{
			SamplingTime[Index] += DeltaTime;
			MaybeTime[Index] += DeltaTime;
			aMouse = SmoothedMouse[Index];
		}
		else
		{
			if ( bAdjustSampling && (MouseSamples[Index] > 9) )
			{
				SamplingTime[Index] -= MaybeTime[Index];
				if (MouseSamples[Index] != 0.0f)  // don't divide by zero!!!
					MouseSamplingTime = 0.9 * MouseSamplingTime + 0.1 * SamplingTime[Index]/MouseSamples[Index];
			}
			SamplingTime[Index] = 0;
			SmoothedMouse[Index] = 0;
			MouseSamples[Index] = 0;
		}
	}
	else
	{
		MaybeTime[Index] = 0;

		if ( SmoothedMouse[Index] != 0 )
		{
			MouseSamples[Index] += SampleCount;
			if ( DeltaTime > MouseSamplingTime * (SampleCount + 1) )
				SamplingTime[Index] += MouseSamplingTime * SampleCount;
			else
			{
				SamplingTime[Index] += DeltaTime;
				delta = MouseSamplingTime * SampleCount;
				if (delta != 0.0f)  // don't divide by zero!!!
					aMouse = aMouse * DeltaTime/delta;
			}
		}
		else
			SamplingTime[Index] = 0.5 * MouseSamplingTime;

		if (SampleCount != 0)  // don't divide by zero!!!
			SmoothedMouse[Index] = aMouse/SampleCount;

		ZeroTime[Index] = 0;
	}
	SampleCount = 0;

	if ( MouseSmoothingMode > 1 )
	{
		if ( aMouse == 0 )
		{
			// stop in next tick
			for ( i=0; i<3; i++ )
			{
				sum += (i+1) * 0.1;
				aMouse += sum * OldSamples[i];
				OldSamples[i] = 0;
			}
			OldSamples[3] = 0;
		}
		else
		{
			aMouse = 0.4 * aMouse;
			OldSamples[3] = aMouse;
			for ( i=0; i<3; i++ )
			{
				aMouse += (i+1) * 0.1 * OldSamples[i];
				OldSamples[i] = OldSamples[i+1];
			}

		}
	}
	return aMouse;
}

function UpdateSensitivity(float F)
{
	MouseSensitivity = FMax(0,F);
    default.MouseSensitivity = MouseSensitivity;
	class'PlayerInput'.static.StaticSaveConfig();
}

function UpdateAccel(float F)
{
	MouseAccelThreshold = FMax(0,f);
	default.MouseAccelThreshold = MouseAccelThreshold;
	class'PlayerInput'.static.StaticSaveConfig();
}

function UpdateSmoothing( int Mode )
{
    MouseSmoothingMode = Mode;
    default.MouseSmoothingMode = MouseSmoothingMode;
	class'PlayerInput'.static.StaticSaveConfig();
}

function ChangeSnapView( bool B )
{
	bSnapToLevel = B;
}

// check for double click move
function Actor.eDoubleClickDir CheckForDoubleClickMove(float DeltaTime)
{
	local Actor.eDoubleClickDir DoubleClickMove, OldDoubleClick;

	if ( DoubleClickDir == DCLICK_Active )
		DoubleClickMove = DCLICK_Active;
	else
		DoubleClickMove = DCLICK_None;
	if (DoubleClickTime > 0.0)
	{
		if ( DoubleClickDir == DCLICK_Active )
		{
			if ( (Pawn != None) && (Pawn.Physics == PHYS_Walking) )
			{
				DoubleClickTimer = 0;
				DoubleClickDir = DCLICK_Done;
			}
		}
		else if ( DoubleClickDir != DCLICK_Done )
		{
			OldDoubleClick = DoubleClickDir;
			DoubleClickDir = DCLICK_None;

			if (bEdgeForward && bWasForward)
				DoubleClickDir = DCLICK_Forward;
			else if (bEdgeBack && bWasBack)
				DoubleClickDir = DCLICK_Back;
			else if (bEdgeLeft && bWasLeft)
				DoubleClickDir = DCLICK_Left;
			else if (bEdgeRight && bWasRight)
				DoubleClickDir = DCLICK_Right;

			if ( DoubleClickDir == DCLICK_None)
				DoubleClickDir = OldDoubleClick;
			else if ( DoubleClickDir != OldDoubleClick )
				DoubleClickTimer = DoubleClickTime + 0.5 * DeltaTime;
			else
				DoubleClickMove = DoubleClickDir;
		}

		if (DoubleClickDir == DCLICK_Done)
		{
			DoubleClickTimer = FMin(DoubleClickTimer-DeltaTime,0);
			if (DoubleClickTimer < -0.35)
			{
				DoubleClickDir = DCLICK_None;
				DoubleClickTimer = DoubleClickTime;
			}
		}
		else if ((DoubleClickDir != DCLICK_None) && (DoubleClickDir != DCLICK_Active))
		{
			DoubleClickTimer -= DeltaTime;
			if (DoubleClickTimer < 0)
			{
				DoubleClickDir = DCLICK_None;
				DoubleClickTimer = DoubleClickTime;
			}
		}
	}
	return DoubleClickMove;
}

defaultproperties
{
	 bAdjustSampling=true
	 MouseSamplingTime=+0.008333
	 MouseSmoothingStrength=+0.3
	 MouseSmoothingMode=1
     MouseSensitivity=3.000000
    MouseAccelThreshold=100.0
     DoubleClickTime=0.280000

	 bUseAimAssist = false;
}
//=============================================================================
// PlayerReplicationInfo.
//=============================================================================
class PlayerReplicationInfo extends ReplicationInfo
	native nativereplication;



var float				Score;			// Player's current score.
var float				Deaths;			// Number of player's deaths.
var CarriedObject		HasFlag;
var int					Ping;				// packet loss packed into this property as well
var Volume				PlayerVolume;
var ZoneInfo            PlayerZone;
var int					NumLives;

var string				PlayerName;		// Player name, or blank if none.
var string				OldName, PreviousName;		// Temporary value.
var int					PlayerID;		// Unique id number.
var TeamInfo			Team;			// Player Team
var int					TeamID;			// Player position in team.
var class<VoicePack>	VoiceType;
var bool				bAdmin;				// Player logged in as Administrator
var bool				bIsFemale;
var bool				bIsSpectator;
var bool				bOnlySpectator;
var bool				bWaitingPlayer;
var bool				bReadyToPlay;
var bool				bOutOfLives;
var bool				bBot;
var bool				bWelcomed;			// set after welcome message broadcast (not replicated)
var bool				bReceivedPing;
var bool				bHasFlag;

// GBX:CEK: 5/17/2004 - Lobby functionality
var bool				bLobbyAttached;		// handles ready in skirmish
var int					LobbyPlayerSlot;	// also handles role choice in skirmish
var int					LobbyClientNum;
var int					SkirmishToDLevel[2];// continue level for Skirmish:tour of duty mode. (US/DE)

var int WavesScore;							// Holds the number of defense waves someone has cleared.

// Time elapsed.
var int					StartTime;

var localized String	StringDead;
var localized String    StringSpectating;
var localized String	StringUnknown;
var localized String	StringGuest;

var String              UbicomName;

// gam --- needed for XLive players list
var String xuid;
var String Gamertag;
var bool bIsGuest;
var bool bHasVoice;
var bool bVoiceBanned;
var bool bHasCommunicator;
var int VoiceChatterHandle;
var int Skill;
// --- gam

// jij ---
var int VoiceChannel;
// --- jij

// added 2004-10-13 JWS
var UnitReplicationInfo	Unit;

var int					GoalsScored;		// not replicated - used on server side only
var int					Kills;				// not replicated

replication
{
	// Things the server should send to the client.
	reliable if ( bNetDirty && (Role == Role_Authority) )
		Score, Deaths, bHasFlag, PlayerVolume, PlayerZone,
		PlayerName, Team, TeamID, VoiceType, bIsFemale, bAdmin,
		bIsSpectator, bOnlySpectator, bWaitingPlayer, bReadyToPlay,
		bOutOfLives, 
		xuid, Gamertag, bIsGuest, bHasVoice, bVoiceBanned, bHasCommunicator, Skill, VoiceChannel, VoiceChatterHandle, // gam, jij
		bLobbyAttached, LobbyPlayerSlot, LobbyClientNum, NumLives, Unit, SkirmishToDLevel, WavesScore;

	reliable if ( bNetDirty && (!bNetOwner || bDemoRecording) && (Role == Role_Authority) )
		Ping;
	reliable if ( bNetInitial && (Role == Role_Authority) )
		StartTime, bBot;
        
    reliable if ( Role == Role_Authority )
        UbicomName;

	// GBX:CEK: 5/17/2004 - Lobby functionality
	reliable if (Role < Role_Authority)
		SetLobbyPlayerSlot, SetLobbyAttached, SetSkirmishToDLevel;
}

function PostBeginPlay()
{
	if ( Role < ROLE_Authority )
		return;
    if (AIController(Owner) != None)
        bBot = true;
	StartTime = Level.Game.GameReplicationInfo.ElapsedTime;
	Timer();
	SetTimer(1.5 + FRand(), true);
}

simulated function PostNetBeginPlay()
{
	local GameReplicationInfo GRI;

	ForEach DynamicActors(class'GameReplicationInfo',GRI)
	{
		GRI.AddPRI(self);
		break;
	}
}

simulated function Destroyed()
{
	local GameReplicationInfo GRI;

	ForEach DynamicActors(class'GameReplicationInfo',GRI)
        GRI.RemovePRI(self);

	SetOwner(None);  // prevent references to/in destroyed objects

    super.Destroyed();
}

/* Reset()
reset actor to initial state - used when restarting level without reloading.
*/
function Reset()
{
	Super.Reset();
	Score = 0;
	Deaths = 0;
	SetFlag(None);
	bReadyToPlay = false;
	NumLives = 0;
	bOutOfLives = false;
}

function SetFlag(CarriedObject NewFlag)
{
	HasFlag = NewFlag;
	bHasFlag = (HasFlag != None);
}

simulated function string GetHumanReadableName()
{
	if (!bBot && (Level.AuthMode == AM_Live))
	{
		if (bIsGuest)
			return StringGuest @ Gamertag;
		else
			return Gamertag;
	}

	return PlayerName;
}

simulated function string GetLocationName()
{
    if( ( PlayerVolume == None ) && ( PlayerZone == None ) )
    {
    	if ( (Owner != None) && Controller(Owner).IsInState('Dead') )
        	return StringDead;
        else
        	return StringSpectating;
    }

	if( ( PlayerVolume != None ) && ( PlayerVolume.LocationName != class'Volume'.Default.LocationName ) )
		return PlayerVolume.LocationName;
	else if( PlayerZone != None && ( PlayerZone.LocationName != "" )  )
		return PlayerZone.LocationName;
    else if ( Level.Title != Level.Default.Title )
		return Level.Title;
	else
        return StringUnknown;
}

simulated function material GetPortrait();
event UpdateCharacter();

function UpdatePlayerLocation()
{
    local Volume V, Best;
    local Pawn P;
    local Controller C;

    C = Controller(Owner);

    if( C != None )
        P = C.Pawn;

    if( P == None )
		{
        PlayerVolume = None;
        PlayerZone = None;
        return;
    }

    if ( PlayerZone != P.Region.Zone )
		PlayerZone = P.Region.Zone;

    foreach P.TouchingActors( class'Volume', V )
    {
        if( V.LocationName == "")
            continue;

        if( (Best != None) && (V.LocationPriority <= Best.LocationPriority) )
            continue;

        if( V.Encompasses(P) )
            Best = V;
		}
    if ( PlayerVolume != Best )
		PlayerVolume = Best;
}

/* DisplayDebug()
list important controller attributes on canvas
*/
simulated function DisplayDebug(Canvas Canvas, out float YL, out float YPos)
{
	if ( Team != None )
		Canvas.DrawText("     PlayerName "$PlayerName$" Team "$Team.GetHumanReadableName()$" has flag "$HasFlag);
	else
		Canvas.DrawText("     PlayerName "$PlayerName$" NO Team");
}

event ClientNameChange()
{
    local PlayerController PC;

	ForEach DynamicActors(class'PlayerController', PC)
		PC.ReceiveLocalizedMessage( class'GameMessage', 2, self );
}

function Timer()
{
    local Controller C;

	UpdatePlayerLocation();
	SetTimer(1.5 + FRand(), true);
	if( FRand() < 0.65 )
		return;

	if( !bBot )
	{
	    C = Controller(Owner);
		if ( !bReceivedPing )
			Ping = int(C.ConsoleCommand("GETPING"));
	}
}

function SetPlayerName(string S)
{
	OldName = PlayerName;
	PlayerName = S;
}

function SetWaitingPlayer(bool B)
{
	bIsSpectator = B;
	bWaitingPlayer = B;
}

// amb ---
function int GetPlayerRecordIndex();
// --- amb

// =======================================================================================================================================================
// Lobby functionality
// =======================================================================================================================================================
function int GetLobbyTeamCount(int team)
{
	local PlayerReplicationInfo pri;
	local int result;

	result = 0;
	ForEach DynamicActors(class'PlayerReplicationInfo', pri)
	{
		switch(team)
		{
		case ETeamIdentifier.TEAM_None:	// "any team"
			if (pri.bLobbyAttached)
				result++;
			break;

		case ETeamIdentifier.TEAM_US:
			if (pri.IsTeamGerman())
				result++;
			break;

		case ETeamIdentifier.TEAM_German:
			if (pri.IsTeamGerman())
				result++;
			break;
		}
	}

	return result;
}

function bool IsSlotOccupied(int slot)
{
	local PlayerReplicationInfo pri;
	ForEach DynamicActors(class'PlayerReplicationInfo', pri)
	{
		if (pri.bLobbyAttached && (pri.LobbyPlayerSlot == slot))
			return true;
	}

	return false;
}

function SetLobbyPlayerSlot(int newSlot)
{
	if (!bLobbyAttached)
	{
		LobbyPlayerSlot = newSlot;
	}
}

function InitializeTeam(ETeamIdentifier team)
{
	local int count;

	if (team == ETeamIdentifier.TEAM_None)
		team = ETeamIdentifier.TEAM_US;

	// each team has 2 "slots"
	// us = 0,1 german = 2,3
	count = GetLobbyTeamCount(team);

	// determine the slot to use
	if (Level.Game.MaxPlayers > 2)
	{
		// in 2v2, each team has 2 slots
		count = count % 2;
	}
	else
	{
		// in 1v1, each only has a single slot
		count = 0;
	}

	if (team == ETeamIdentifier.TEAM_US)
	{
		SetLobbyPlayerSlot(count);
	}
	else
	{
		SetLobbyPlayerSlot(2 + count);
	}
}

function SetLobbyAttached(bool bAttach)
{
	// see if the slot is open first if we're attaching
	// always allow in skirmish
	if (!bAttach || Level.Game.IsA('WargameSkirmish') || !IsSlotOccupied(LobbyPlayerSlot))
		bLobbyAttached = bAttach;
}

function SetSkirmishToDLevel(int newLevelUS, int newLevelDE)
{
	SkirmishToDLevel[0] = newLevelUS;
	SkirmishToDLevel[1] = newLevelDE;
}

static function ETeamIdentifier GetLobbyTeamChoice(int lobbySlot)
{
	switch(lobbySlot)
	{
	case 0:
	case 1:
		return ETeamIdentifier.TEAM_US;

	case 2:
	case 3:
		return ETeamIdentifier.TEAM_German;
	}

	return ETeamIdentifier.TEAM_None;
}

simulated function bool IsTeamGerman()
{
	return bLobbyAttached && ( GetLobbyTeamChoice(LobbyPlayerSlot) == ETeamIdentifier.TEAM_German );
}

simulated function bool IsTeamUSA()
{
	return bLobbyAttached && ( GetLobbyTeamChoice(LobbyPlayerSlot) == ETeamIdentifier.TEAM_US );
}

simulated function int LobbyGetPlayerTeamRole()
{
	local int teamRole;
	
	teamRole = LobbyPlayerSlot % 2;
	return teamRole;
}

defaultproperties
{
	RemoteRole=ROLE_SimulatedProxy
	bAlwaysRelevant=True
    StringSpectating="Spectating"
    StringUnknown="Unknown"
    StringDead="Dead"
	StringGuest="Guest:"
    NetUpdateFrequency=5
    bIsGuest=true
    Skill=50

	VoiceChatterHandle=0
	UbicomName="???"
}
//=============================================================================
// Player start location.
//=============================================================================
class PlayerStart extends SmallNavigationPoint
	placeable
	native;



// Players on different teams are not spawned in areas with the
// same TeamNumber unless there are more teams in the level than
// team numbers.
var() byte TeamNumber;			// what team can spawn at this start
var() bool bSinglePlayerStart;	// use first start encountered with this true for single player
var() bool bCoopStart;			// start can be used in coop games
var() bool bEnabled;
var() bool bPrimaryStart;		// None primary starts used only if no primary start available
var() float LastSpawnCampTime;	// last time a Pawn starting from this spot died within 5 seconds
var() int	m_nCheckpointID;

defaultproperties
{
	 bPrimaryStart=true
 	 bEnabled=true
     bSinglePlayerStart=True
     bCoopStart=True
     bDirectional=True
     Texture=Texture'Engine.S_Player'
     m_nCheckpointID=0
}
//=============================================================================
// PolyMarker.
//
// These are markers for the polygon drawing mode.
//
// These should NOT be manually added to the level.  The editor adds and
// deletes them on it's own.
//
//=============================================================================
class PolyMarker extends Keypoint
	placeable
	native;



defaultproperties
{
     bEdShouldSnap=True
     Texture=Texture'Engine.S_PolyMarker'
	 bStatic=True
}
class PotentialClimbWatcher extends Info
	native;



simulated function Tick(float DeltaTime)
{
	local rotator PawnRot;
	local LadderVolume L;
	local bool bFound;

	if ( (Owner == None) || Owner.bDeleteMe || !Pawn(Owner).CanGrabLadder() )
	{
		destroy();
		return;
	}

	PawnRot = Owner.Rotation;
	PawnRot.Pitch = 0;
	ForEach Owner.TouchingActors(class'LadderVolume', L)
		if ( L.Encompasses(Owner) )
		{
			if ( (vector(PawnRot) Dot L.LookDir) > 0.9 )
			{
				Pawn(Owner).ClimbLadder(L);
				destroy();
				return;
			}
			else
				bFound = true;
		}

	if ( !bFound )
		destroy();
}
//=============================================================================
// Powerup items - activatable inventory.
//=============================================================================
class Powerups extends Inventory
	abstract
	native
	nativereplication;



var travel int NumCopies;
var() bool bAutoActivate;			   // automatically activated when picked up
var() bool        bActivatable;       // Whether item can be activated/deactivated (if true, must auto activate)
var	travel bool   bActive;			  // Whether item is currently activated.
var() localized String ExpireMessage; // Messages shown when powerup charge runs out

var() sound ActivateSound, DeActivateSound;

replication
{
	// Things the server should send to the client.
	reliable if( bNetOwner && bNetDirty && (Role==ROLE_Authority) )
		NumCopies, bActivatable, bActive;
}

event TravelPreAccept()
{
	Super.TravelPreAccept();
	if( bActive )
		Activate();
}

function PickupFunction(Pawn Other)
{
	Super.PickupFunction(Other);

	if (bActivatable && Other.SelectedItem==None)
		Other.SelectedItem=self;
	if (bActivatable && bAutoActivate && Other.bAutoActivate)
		Activate();
}

//
// Select first activatable item.
//
function Powerups SelectNext()
{
	if ( bActivatable )
		return self;

	if ( Inventory != None )
		return Inventory.SelectNext();
	else
		return None;
}

//
// Toggle Activation of selected Item.
//
function Activate()
{
	if( bActivatable )
	{
		GoToState('Activated');
	}
}

//
// Advanced function which lets existing items in a Pawn's inventory
// prevent the Pawn from picking something up. Return true to abort pickup
// or if item handles the pickup
function bool HandlePickupQuery( Pickup Item )
{
	if (item.InventoryType == class)
	{
		if (bCanHaveMultipleCopies)
		{
			NumCopies++;
			Item.SetRespawn();
		}
		else if ( bDisplayableInv )
		{
			if ( Item.Inventory != None )
				Charge = Max(Charge, Item.Inventory.Charge);
			else
				Charge = Max(Charge, Item.InventoryType.Default.Charge);
		}
		else
			return false;

		Item.AnnouncePickup(Pawn(Owner));
		return true;
	}
	if ( Inventory == None )
		return false;

	return Inventory.HandlePickupQuery(Item);
}

function float UseCharge(float Amount);
function FireEffect();

//
// This is called when a usable inventory item has used up it's charge.
//
function UsedUp()
{
	if ( Pawn(Owner) != None )
	{
		bActivatable = false;
		Pawn(Owner).NextItem();
		if (Pawn(Owner).SelectedItem == Self)
		{
			Pawn(Owner).NextItem();
			if (Pawn(Owner).SelectedItem == Self)
				Pawn(Owner).SelectedItem=None;
		}

		Instigator.ReceiveLocalizedMessage( MessageClass, 0, None, None, Self.Class );
	}
	Owner.PlaySound(DeactivateSound,SLOT_Interface);
	Destroy();
}

static function string GetLocalString(
	optional int Switch,
	optional PlayerReplicationInfo RelatedPRI_1,
	optional PlayerReplicationInfo RelatedPRI_2
	)
{
	return Default.ExpireMessage;
}


//=============================================================================
// Active state: this inventory item is armed and ready to rock!

state Activated
{
	function BeginState()
	{
		bActive = true;
	}

	function EndState()
	{
		bActive = false;
	}

	function Activate()
	{
		if ( (Pawn(Owner) != None) && Pawn(Owner).bAutoActivate
			&& bAutoActivate && (Charge>0) )
				return;

		Global.Activate();
	}
}

defaultproperties
{
}
//=============================================================================
// ProfileBase.
// Copyright 2001 Digital Extremes - All Rights Reserved.
// Confidential.
//=============================================================================
class ProfileBase extends Object;


// --- WARNING --------------------------------------------------------------------------------------------------------
const AccuracyMin           = 0.5;
const TacticsMin            = 0.5;
const AgilityMin            = 0.5;

const AccuracyMax           = 1.0;
const TacticsMax            = 1.0;
const AgilityMax            = 1.0;

const MaxStrLen             = 15;

const cNumTeams             = 20;
const cNumPlayersPerTeam    = 6;
const cNumLadders           = 4;
const cNumLadderRungs       = 7;
const cNumDifficultyLevels  = 4;
const cNumMaps              = 15;

const cNumPos               = 3;
enum EPlayerPos
{
    POS_Defense,
    POS_Offense,
    POS_Freelance,
    POS_None,
};
var localized string PositionText[cNumPos];
// --- WARNING --------------------------------------------------------------------------------------------------------
// -Update ULoadSaveManager::MaxSaveGameFileSize if the maximum save game size changes
// -Update ULoadSaveManager::SaveGameFileVersion if the data layout changes
// --- WARNING --------------------------------------------------------------------------------------------------------


static simulated function string StaticGetPositionString(EPlayerPos pos)
{
    return default.PositionText[int(pos)];
}

static simulated function string CapStringLen(string s, optional string version)
{
    s = s $ version;
    if (Len(s) <= MaxStrLen)
        return s;
    return Left(s, MaxStrLen - Len(version)) $ version;
}


defaultproperties
{
    PositionText(0)="DEFENSE"
    PositionText(1)="OFFENSE"
    PositionText(2)="FREELANCE"
}
//=============================================================================
// Projectile.
//
// A delayed-hit projectile that moves around for some time after it is created.
//=============================================================================
class Projectile extends Actor
	abstract
	native;



//-----------------------------------------------------------------------------
// Projectile variables.

// Motion information.
var		float   Speed;               // Initial speed of projectile.
var		float   MaxSpeed;            // Limit on speed of projectile (0 means no limit)
var		float	TossZ;
var		Actor	ZeroCollider;
var		bool	bSwitchToZeroCollision; // if collisionextent nonzero, and hit actor with bBlockNonZeroExtents=0, switch to zero extent collision

// Damage attributes.
var   float    Damage;
var	  float	   DamageRadius;
var   float	   MomentumTransfer; // Momentum magnitude imparted by impacting projectile.
var   class<DamageType>	   MyDamageType;

// Projectile sound effects
var   sound    SpawnSound;		// Sound made when projectile is spawned.
var   sound	   ImpactSound;		// Sound made when projectile hits something.

// explosion effects
var   class<Projector> ExplosionDecal;
var   float		ExploWallOut;	// distance to move explosions out from wall

var Controller ProjOwner;

//==============
// Encroachment
function bool EncroachingOn( actor Other )
{
	if ( (Other.Brush != None) || (Brush(Other) != None) )
		return true;

	return false;
}

//==============
// Touching
simulated singular function Touch(Actor Other)
{
	local actor HitActor;
	local vector HitLocation, HitNormal, VelDir, AdjustedLocation;
	local bool bBeyondOther;
	local float BackDist, DirZ;

	if ( Other == None ) // Other just got destroyed in its touch?
		return;
	if ( Other.bProjTarget || (Other.bBlockActors && Other.bBlockPlayers) )
	{
		if ( Velocity == vect(0,0,0) || Other.IsA('Mover') )
		{
			ProcessTouch(Other,Location);
			return;
		}

		//get exact hitlocation - trace back along velocity vector
		bBeyondOther = ( (Velocity Dot (Location - Other.Location)) > 0 );
		VelDir = Normal(Velocity);
		DirZ = sqrt(abs(VelDir.Z));
		BackDist = Other.CollisionRadius * (1 - DirZ) + Other.CollisionHeight * DirZ;
		if ( bBeyondOther )
			BackDist += VSize(Location - Other.Location);
		else
			BackDist -= VSize(Location - Other.Location);

	 	HitActor = Trace(HitLocation, HitNormal, Location, Location - 1.1 * BackDist * VelDir, true);
		if (HitActor == Other)
			AdjustedLocation = HitLocation;
		else if ( bBeyondOther )
			AdjustedLocation = Other.Location - Other.CollisionRadius * VelDir;
		else
			AdjustedLocation = Location;
		ProcessTouch(Other, AdjustedLocation);
		if ( (Role < ROLE_Authority) && (Other.Role == ROLE_Authority) )
			ClientSideTouch(Other, AdjustedLocation);
	}
	}

/* ClientSideTouch()
Allows client side actors (with Role==ROLE_Authority on the client, like ragdolls)
to be affected by projectiles
*/
simulated function ClientSideTouch(Actor Other, Vector HitLocation)
{
	Other.TakeDamage(Damage, instigator, Location, MomentumTransfer * Normal(Velocity), MyDamageType);
}

simulated function ProcessTouch(Actor Other, Vector HitLocation)
{
	if ( Other != Instigator )
		Explode(HitLocation,Normal(HitLocation-Other.Location));
}

simulated function HitWall (vector HitLocation, vector HitNormal, actor Wall)
{
	if ( Role == ROLE_Authority )
	{
		if ( Mover(Wall) != None )
			Wall.TakeDamage( Damage, instigator, Location, MomentumTransfer * Normal(Velocity), MyDamageType);

		MakeNoise(1.0);
	}
	Explode(Location + ExploWallOut * HitNormal, HitNormal);
	if ( (ExplosionDecal != None) && (Level.NetMode != NM_DedicatedServer) )
		Spawn(ExplosionDecal,self,,Location, rotator(-HitNormal));
}

simulated function BlowUp(vector HitLocation)
{
	HurtRadius(Damage,DamageRadius, MyDamageType, MomentumTransfer, HitLocation );
	if ( Role == ROLE_Authority )
		MakeNoise(1.0);
}

simulated function Explode(vector HitLocation, vector HitNormal)
{
	Destroy();
}

simulated final function RandSpin(float spinRate)
{
	DesiredRotation = RotRand();
	RotationRate.Yaw = spinRate * 2 *FRand() - spinRate;
	RotationRate.Pitch = spinRate * 2 *FRand() - spinRate;
	RotationRate.Roll = spinRate * 2 *FRand() - spinRate;
}

static function vector GetTossVelocity(Pawn P, Rotator R)
{
	local vector V;

	V = Vector(R);
	V *= ((P.Velocity Dot V)*0.4 + Default.Speed);
	V.Z += Default.TossZ;
	return V;
}

defaultproperties
{
	bCanBeDamaged=true
	 bAcceptsProjectors=false
	 bUseCylinderCollision=true
	 DamageRadius=+220.0
     MaxSpeed=+02000.000000
     DrawType=DT_Mesh
     Texture=Texture'Engine.S_Camera'
     SoundVolume=0
     CollisionRadius=+00000.000000
     CollisionHeight=+00000.000000
     bCollideActors=True
     bCollideWorld=True
	 bNetTemporary=true
	 bGameRelevant=true
	 bReplicateInstigator=true
     Physics=PHYS_Projectile
     LifeSpan=+0014.000000
     NetPriority=+00002.500000
	 MyDamageType=class'DamageType'
	 RemoteRole=ROLE_SimulatedProxy
	 bUnlit=true
	 TossZ=+100.0
     bNetInitialRotation=true
	 bDisturbFluidSurface=true
}
class Projector extends Actor
	placeable
	native
	dependson(GbxShader);

enum EProjectorArchetype
{
    PRJA_Undefined,
    PRJA_Basic,                 // Simple projected texture (fullbright)
    PRJA_Shadow,                // Blurred multitextured object
    PRJA_Lit,                   // Simple projected texture (may be lit with point lights and will be lit with modulate2x math)
    PRJA_BasicRefPose,          // Same as simple but projects against RefPose for Skeletal Meshes
};

enum EProjectorClass
{
    PRJC_Undefined,
    PRJC_BSP,
    PRJC_Terrain,
    PRJC_StaticMesh,
    PRJC_SkeletalMesh,
    PRJC_Particle,
    PRJC_BatchedGeometry,
};

#exec Texture Import file=Textures\GRADIENT_Fade.tga Name=GRADIENT_Fade Mips=Off UCLAMPMODE=CLAMP VCLAMPMODE=CLAMP DXT=3
#exec Texture Import file=Textures\GRADIENT_Clip.tga Name=GRADIENT_Clip Mips=Off UCLAMPMODE=CLAMP VCLAMPMODE=CLAMP DXT=3

// Projector properties.

var() EProjectorArchetype           ProjectorArchetype;
var() GbxShader.EGbxBlendEquation   BlendEquation;
var() GbxShader.EGbxBlendFunction   BlendSrcFunction;
var() GbxShader.EGbxBlendFunction   BlendDstFunction;
var() Material	ProjTexture;
var() int		FOV;
var() int		MaxTraceDistance;
var() color     TransparentFactor;      // If a=1 lerp to TransparentColor.rgb to go transparent.  if b=1 lerp to TransparentColor.a to go transparent
var() color     TransparentColor;       // Color to lerp the projector to get it to be transparent (either via alphafog or angle dot product)
var() color     OverriddenFogColor;     // custom rgb fog color (alpha unused)
var() bool		bGradient;
var() bool		bLevelStatic;
var() bool		bDynamicAttach;
var() bool		bProjectBSP;
var() bool		bProjectTerrain;
var() bool		bProjectStaticMesh;
var() bool		bProjectParticles;
var() bool		bProjectActor;
var() bool		bClipBSP;
var() bool		bClipStaticMesh;     // render the entire model with the projector or a subset of the model
var() bool      bClipStaticMeshTris; // Clip static mesh triangles into smaller traingles
var() bool		bProjectOnUnlit;
var() bool		bProjectOnBackfaces;
var() bool		bProjectOnAlpha;
var() bool      bDoNotColorFog;     // projector ignores color fog
var() bool      bDoNotAlphaFog;     // projector ignores alpha fog
var() bool      bOverrideFogColor;  // projector uses a custom fog color
var() name		ProjectTag;


// Internal state.

var const transient plane FrustumPlanes[6];
var const transient vector FrustumVertices[8];
var const transient Box Box;
var const transient ProjectorRenderInfoPtr RenderInfo;
var transient Matrix Matrix;

// Native interface.

native function AttachProjector(optional Actor AttachActor);
native function DetachProjector(optional bool Force);
native function AbandonProjector(optional float Lifetime);

native function AttachActor( Actor A );
native function DetachActor( Actor A );

simulated event PostBeginPlay()
{
	AttachProjector();
	if( bLevelStatic )
	{
		AbandonProjector();
		Destroy();
	}
	if( bProjectActor )
		SetCollision(True, False, False);
}

simulated event Touch( Actor Other )
{
	if(Other==None)
		return;
	// Changed by Demiurge (ProjectorOptimize)
	// Changed so that we don't AttachActor() for static projector/static object combinations
	if( Other.bAcceptsProjectors && (ProjectTag=='' || Other.Tag==ProjectTag) && (bProjectStaticMesh || Other.StaticMesh == None) && !(Other.bStatic && bStatic))
		AttachActor(Other);
}

simulated event Untouch( Actor Other )
{
	DetachActor(Other);
}

simulated function SetProjectorArchetypeBasic()
{
	ProjectorArchetype = PRJA_Basic;
}

simulated function SetProjectorArchetypeShadow()
{
	ProjectorArchetype = PRJA_Shadow;
}

defaultproperties
{
    ProjectorArchetype=PRJA_Basic
	BlendEquation=blendequation_Add
	BlendSrcFunction=blend_SrcAlpha
	BlendDstFunction=blend_OneMinusSrcAlpha
	bDoNotColorFog=false
	bDoNotAlphaFog=false
	bOverrideFogColor=false
	TransparentFactor=(R=0,G=0,B=255,A=0)
	TransparentColor=(R=0,G=0,B=0,A=0)
	OverriddenFogColor=(R=0,G=0,B=0,A=0)
	
	FOV=0
	bDirectional=True
	Texture=Texture'Engine.S_Projector'
	MaxTraceDistance=1000
	bProjectBSP=True
	bProjectTerrain=True
	bProjectStaticMesh=True
	bProjectParticles=False
	bProjectActor=True
	bClipBSP=False
	bClipStaticMesh=False
	bLevelStatic=False
	bProjectOnUnlit=False
	bHidden=True
	bStatic=True
	bProjectOnBackfaces=False
	bDynamicAttach=False
	RemoteRole=ROLE_None

	bProjFlag_Shadow=False
	bProjFlag_VehicleShadow=False
	bProjFlag_LevelShadow=False
	bProjFlag_Blood=False
	bProjFlag_Bullet=False
	bProjFlag_Blast=False
	bProjFlag_SAVIcon=False
	bProjFlag_ObjectiveIcon=False
	bProjFlag_CommandRing=False
}
//=============================================================================
// ReachSpec.
//
// A Reachspec describes the reachability requirements between two NavigationPoints
//
//=============================================================================
class ReachSpec extends Object
	native;

var	int		Distance;
var	const ActorLite Start;		// navigationpoint at start of this path
var	const ActorLite End;		// navigationpoint at endpoint of this path (next waypoint or goal)
var	int		CollisionRadius;
var	int		CollisionHeight;
var	int		reachFlags;			// see EReachSpecFlags definition in UnPath.h
var	int		MaxLandingVelocity;
var	byte	bPruned;
var	const bool	bForced;

var const byte CoverBits[3];  // 'byte' allows for 8 cover directions, index 0=low, index 1=crouched, index 2=standing
class RenderedMaterial extends Material
	native
	noexport;


//=============================================================================
// ReplicationInfo.
//=============================================================================
class ReplicationInfo extends Info
	abstract
	native;



cpptext
{
	INT* GetOptimizedRepList( BYTE* Recent, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel );
}

defaultproperties
{
	RemoteRole=ROLE_SimulatedProxy
	 bAlwaysRelevant=True
     bStatic=False
     bNoDelete=False
}
//=============================================================================
// SavedMove is used during network play to buffer recent client moves,
// for use when the server modifies the clients actual position, etc.
// This is a built-in Unreal class and it shouldn't be modified.
//=============================================================================
class SavedMove extends Info;



// also stores info in Acceleration attribute
var SavedMove NextMove;		// Next move in linked list.
var float TimeStamp;		// Time of this move.
var float Delta;			// Distance moved.
var bool	bRun;
var bool	bDuck;
var bool	bWantsToCrouch;
var bool	bNextCrouchState;
var bool	bPressedJump;
var bool	bDoubleJump;
var EDoubleClickDir DoubleClickMove;	// Double click info.
var EPhysics SavedPhysics;
var vector SavedLocation, SavedVelocity;

final function Clear()
{
	TimeStamp = 0;
	Delta = 0;
	DoubleClickMove = DCLICK_None;
	Acceleration = vect(0,0,0);
	bRun = false;
	bDuck = false;
	bWantsToCrouch = false;
	bNextCrouchState = false;
	bPressedJump = false;
	bDoubleJump = false;
}

final function PostUpdate(PlayerController P)
{
	bDoubleJump = P.bDoubleJump || bDoubleJump;
	if ( P.Pawn != None )
	{
		SavedLocation = P.Pawn.Location;
		SavedVelocity = P.Pawn.Velocity;
	}
}

final function SetMoveFor(PlayerController P, float DeltaTime, vector NewAccel, EDoubleClickDir InDoubleClick)
{
	if ( VSize(NewAccel) > 3072 )
		NewAccel = 3072 * Normal(NewAccel);
	if ( Delta > 0 )
		Acceleration = (DeltaTime * NewAccel + Delta * Acceleration)/(Delta + DeltaTime);
	else
	{
		if ( P.Pawn != None )
			SavedPhysics = P.Pawn.Physics;
		Acceleration = NewAccel;
	}
	Delta += DeltaTime;

	if ( DoubleClickMove == eDoubleClickDir.DCLICK_None )
		DoubleClickMove = InDoubleClick;
	bRun = (P.bRun > 0);
	bDuck = (P.bDuck > 0);
	bWantsToCrouch = P.Pawn.bWantsToCrouch;
	bNextCrouchState = P.Pawn.bNextCrouchState;
	bPressedJump = P.bPressedJump || bPressedJump;
	bDoubleJump = P.bDoubleJump || bDoubleJump;
	TimeStamp = Level.TimeSeconds;
}

defaultproperties
{
     bHidden=True
}
//=============================================================================
// SceneManager
//
// Manages a matinee scene.  Contains a list of action items that will
// be played out in order.
//=============================================================================
class SceneManager extends Info
	placeable
	native;



// Graphics for UI
struct Orientation
{
	var() ECamOrientation	CamOrientation;
	var() actor LookAt;
	var() float EaseIntime;
	var() int bReversePitch;
	var() int bReverseYaw;
	var() int bReverseRoll;

	var int MA;
	var float PctInStart, PctInEnd, PctInDuration;
	var rotator StartingRotation;
};

struct Interpolator
{
	var() int bDone;
	var() float _value;
	var() float _remainingTime;
	var() float _totalTime;
	var() float _speed;
	var() float _acceleration;
};

// Exposed vars
var()	export	editinline	array<MatAction>	Actions;
var()	config	enum EAffect
{
	AFFECT_ViewportCamera,
	AFFECT_Actor,
} Affect;
var()	Actor	AffectedActor;			// The name of the actor which will follow the matinee path (if Affect==AFFECT_Actor)
var()	bool	bLooping;				// If this is TRUE, the path will looping endlessly
var()	bool	bCinematicView;			// Should the screen go into letterbox mode when playing this scene?
var()	bool	bDisable;				// Disable this after it's triggered
var()	bool	bExclusive;				// This should be the only matinee scene running while active
var()   name	PlayerScriptTag;		// Tag of sequence that player's Pawn should use during sequence
var()	name	NextSceneTag;			// The tag of the next scenemanager to execute when this one finishes

// These vars are set by the SceneManager in it's Tick function.  Don't mess with them directly.
var		transient float PctSceneComplete;			// How much of the scene has finished running
var		transient mataction	CurrentAction;			// The currently executing action
var		transient float SceneSpeed;
var		transient float	TotalSceneTime;				// The total time the scene will take to run (in seconds)
var		transient Actor	Viewer;						// The actor viewing this scene (the one being affected by the actions)
var		transient Pawn OldPawn;						// The Pawn we need to repossess when scene is over
var		transient bool bIsRunning;					// If TRUE, this scene is executing.
var		transient bool bIsSceneStarted;				// If TRUE, the scene has been initialized and is running
var		transient bool bCameraInPlayerHead;			// The camera is currently locked in the head of the player pawn
var		transient bool bNewShake;					// GBX:PAD: We're using the new camera shake logic
var		transient float CurrentTime;				// Keeps track of the current time using the DeltaTime passed to Tick
var		transient float TickDeltaTime;				// Stash off the delta time from the tick for use in other functions
var		transient array<vector> SampleLocations;	// Sampled locations for camera movement
var		transient array<MatSubAction> SubActions;	// The list of sub actions which will execute during this scene
var		transient Orientation CamOrientation;		// The current camera orientation
var		transient Orientation PrevOrientation;		// The previous orientation that was set
var		transient Interpolator RotInterpolator;		// Interpolation helper for rotations
var		transient Rotator CameraRotate;				// The SubActionCameraShake effect fills this var in each frame
var		transient vector CameraShake;				// The SubActionCameraShake effect fills this var in each frame
var		transient vector DollyOffset;				// How far away we are from the actor we are locked to
var		transient Pawn   PlayerBody;				// Body of the player the camera should occupy
var		transient name	PlayerAttachBone;			// Bone on the player "body" to which to attach the camera.
var		transient PlayerController	PlayerInput;	// Controller for this view pawn.
var		transient Rotator ScriptViewOffset;			// An offset from the bone position of the pawn at which to orient the camera

// Native functions
native function float GetTotalSceneTime();
native function MatineeCalcView(out actor ViewActor, out vector CameraLocation, out rotator CameraRotation );

simulated function BeginPlay()
{
	Super.BeginPlay();

	if( Affect == AFFECT_Actor && AffectedActor == None )
		log( "SceneManager : Affected actor is NULL!" );

	//
	// Misc set up
	//

	TotalSceneTime = GetTotalSceneTime();
	bIsRunning = false;
	bIsSceneStarted = false;
}

function Trigger( actor Other, Pawn EventInstigator )
{
	local SceneManager	aScene;

	if (bExclusive)
	{
		ForEach AllActors(class'SceneManager', aScene)
		{
			if (aScene == self)
			{
				continue;
			}
			if (aScene.bIsRunning)
			{
//				aScene.CurrentTime = aScene.TotalSceneTime;
//				aScene.bLooping = false;
				aScene.bIsRunning = false;
//				aScene.SceneEnded();
			}
		}
	}
		
	if (bIsRunning || bIsSceneStarted)
	{
		PctSceneComplete = 0.0;
		if (CurrentAction != None)
		{
			CurrentAction.SampleLocations.Remove( 0, CurrentAction.SampleLocations.Length );
		}
		CurrentAction = None;
		SceneSpeed = 1;
		SampleLocations.Remove( 0, SampleLocations.Length );
		SubActions.Remove( 0, SubActions.Length );
		log(self$".Trigger( "$Other$", "$EventInstigator$" ) - "$Tag$" - "$SampleLocations.Length);
	}
	bIsRunning = true;
	bIsSceneStarted = false;
	// GBX:PAD: Make this something the mapper can turn off for complex camera shots that might retrigger the same
	// camera more than once.
	if (bDisable)
	{
		Disable( 'Trigger' );
	}
}

// Events
event SceneStarted()	// Called from C++ when the scene starts.
{
	local PlayerController P;
	local AIScript S;

	// Figure out who our viewer is.
	Viewer = None;
	if( Affect==AFFECT_Actor )
		Viewer = AffectedActor;
	else
	{
		for( P = Level.PlayerControllerList ; P != None ; P = P.nextPlayerController )
			if( P.IsA('PlayerController') ) // && (P.Pawn != None) )
			{
				Viewer = P;
				if (PlayerController(Viewer).Pawn != None)
				{
					OldPawn = PlayerController(Viewer).Pawn;
					if ( OldPawn != None )
					{
						OldPawn.Velocity = vect(0,0,0);
						OldPawn.Acceleration = vect(0,0,0);
						PlayerController(Viewer).UnPossess();
						if ( PlayerScriptTag != 'None' )
						{
							ForEach DynamicActors( class'AIScript', S, PlayerScriptTag )
								break;
							if ( S != None )
								S.TakeOver(OldPawn);
						}
					}
				}
				PlayerController(Viewer).StartInterpolation();
				PlayerController(Viewer).MyHud.bHideHUD = true;
				break;
			}
	}
	Viewer.StartInterpolation();
}

event SceneEnded()		// Called from C++ when the scene ends.
{
	bIsSceneStarted = false;

	if( Affect==AFFECT_ViewportCamera )
	{
		if ( PlayerController(Viewer) != None )
		{
			if ( OldPawn != None )
			{
				PlayerController(Viewer).Possess( OldPawn );
			}
			else	// GBX:PAD: This is a bit dumb, but if one matinee scene interrupts another, the pawn wasn't
					// reset before the new script started, so the new script will have no player pawn.
			{
				ForEach DynamicActors( class'Pawn', OldPawn )
				{
					if (OldPawn.IsA('gbxPlayerPawn'))
					{
						break;
					}
				}
				if ( OldPawn != None )
				{
					PlayerController(Viewer).Possess( OldPawn );
				}
			}
			PlayerController(Viewer).MyHud.bHideHUD = false;
		}
	}
	Viewer.FinishedInterpolation();
	Enable( 'Trigger' );
}

defaultproperties
{
	Style=STY_Sprite
	Texture=Texture'Engine.S_SceneManager'
	Affect=AFFECT_ViewportCamera
	SceneSpeed=1
	bLooping=False
	bDisable=True
}
//=============================================================================
// ScoreBoard
//=============================================================================
class ScoreBoard extends Info;



var() GameReplicationInfo           GRI;
var() class<HUD> HUDClass;
var bool bDisplayMessages;

simulated function PostBeginPlay()
{
    Super.PostBeginPlay();

    InitGRI();
    Init();
}

function Font GetSmallerFontFor(Canvas Canvas, int offset)
{
	local int i;

	for ( i=0; i<8-offset; i++ )
	{
		if ( HUDClass.default.FontScreenWidthMedium[i] <= Canvas.ClipX )
			return HUDClass.static.LoadFontStatic(i+offset);
	}
	return HUDClass.static.LoadFontStatic(8);
}

function bool HaveHalfFont(Canvas Canvas, int Offset)
{
	local int i;

	for ( i=0; i<9-offset; i++ )
		if ( HUDClass.default.FontScreenWidthSmall[i] <= Canvas.ClipX )
			return true;
	return false;
}

simulated function InitGRI()
{
    GRI = PlayerController(Owner).GameReplicationInfo;
}

simulated function string InitTitle()
{
    return Caps(GRI.GameName);
}

simulated function Init();

simulated event DrawScoreboard( Canvas C, float ScaleX, float ScaleY, optional bool bSimplified )
{
	UpdateGRI();
    UpdateScoreBoard(C, ScaleX, ScaleY, bSimplified);
}

simulated function DrawMPTeam(Canvas Canvas, float ScaleX, float ScaleY, ETeamIdentifier team, optional int bDisplayType)
{
}
 
function bool UpdateGRI()
{
    if (GRI == None)
    {
        InitGRI();
		if ( GRI == None )
			return false;
	}
    SortPRIArray();
    return true;
}

static simulated function String FormatTime( int Seconds )
{
    local int Minutes, Hours;
    local String Time;

    if( Seconds > 3600 )
    {
        Hours = Seconds / 3600;
        Seconds -= Hours * 3600;

        Time = Hours$":";
	}
	Minutes = Seconds / 60;
    Seconds -= Minutes * 60;

    if( Minutes >= 10 )
        Time = Time $ Minutes $ ":";
    else
        Time = Time $ "0" $ Minutes $ ":";

    if( Seconds >= 10 )
        Time = Time $ Seconds;
    else
        Time = Time $ "0" $ Seconds;

    return Time;
}

simulated function UpdateScoreBoard(Canvas Canvas, float ScaleX, float ScaleY, optional bool bSimplified);

simulated function bool InOrder( PlayerReplicationInfo P1, PlayerReplicationInfo P2 )
{
    if( P1.bOnlySpectator )
    {
        if( P2.bOnlySpectator )
            return true;
        else
            return false;
    }
    else if ( P2.bOnlySpectator )
        return true;

    if( P1.Score < P2.Score )
        return false;
    if( P1.Score == P2.Score )
    {
		if ( P1.Deaths > P2.Deaths )
			return false;
		if ( (P1.Deaths == P2.Deaths) && (PlayerController(P2.Owner) != None) && (Viewport(PlayerController(P2.Owner).Player) != None) )
			return false;
	}
    return true;
}

simulated function SortPRIArray()
{
    local int i,j;
    local PlayerReplicationInfo tmp;

    for (i=0; i<GRI.PRIArray.Length-1; i++)
    {
        for (j=i+1; j<GRI.PRIArray.Length; j++)
        {
            if( !InOrder( GRI.PRIArray[i], GRI.PRIArray[j] ) )
            {
                tmp = GRI.PRIArray[i];
                GRI.PRIArray[i] = GRI.PRIArray[j];
                GRI.PRIArray[j] = tmp;
            }
        }
    }
}

function NextStats();

defaultproperties
{
	HUDClass=class'HUD'
}
//=============================================================================
// Scout used for path generation.
//=============================================================================
class Scout extends Pawn
	native
	notplaceable;



var const float MaxLandingVelocity;

function PreBeginPlay()
{
	Destroy(); //scouts shouldn't exist during play
}

defaultproperties
{
     AccelRate=+00001.000000
     CollisionRadius=+00028.000000
     CollisionHeight=+00090.000000
     bCollideActors=False
     bCollideWorld=False
     bBlockActors=False
     bBlockPlayers=False
     bProjTarget=False
	 bPathColliding=True
}
//=============================================================================
// Object to facilitate storing information about a scripted attachment on a model
//
// << GBX/PAD:created -- entire file
//
//=============================================================================

class ScriptedAttachmentInfo extends Object
	editinlinenew;



var		ScriptedInventoryAttachment	m_Attachment;
var		name						m_nmAttachBone;

defaultproperties
{
}
class ScriptedInventoryAttachment extends InventoryAttachment;

function InitDroppedItem()
{
	SetPhysics(PHYS_Falling);
	bAlwaysRelevant = false;
	bUpdateSimulatedPosition = true;
    LifeSpan = 16;
	bIgnoreEncroachers=false; // handles case of dropping stuff on lifts etc
	SetCollision( true, false, false );
	bCollideWorld=true;
    bFixedRotationDir=True;
    RotationRate.Yaw=5000;
    DesiredRotation.Yaw=30000;
	bOrientOnSlope=true;
	bUseCylinderCollision=true;
	bShouldBaseAtStartup=true;
}

//
// Toss this item out.
//
function DropFrom(vector StartLocation)
{
	SetDefaultDisplayProperties();
	StopAnimating();
	GotoState('');

	bOnlyDrawIfAttached = false;
	SetOwner(None);
	
	InitDroppedItem();
}

defaultproperties
{
	bOnlyDrawIfAttached=true
	NetUpdateFrequency=10
	DrawType=DT_StaticMesh
	RemoteRole=ROLE_SimulatedProxy
	bAcceptsProjectors=True
	bUseLightingFromBase=True
    bOnlyDirtyReplication=true
	bCollideWorld=true

	CollisionRadius=+00016.000000
	CollisionHeight=+0003.000000
}
// ====================================================================
//  Class:  Engine.Security
//  Parent: Engine.Info
//
//  The security package is spawned and owned by each PlayerController as they
//  enter the game.  It allows for the server to check various aspects
//  of the client.
// ====================================================================

class Security extends Info
		Native;



// When a command is executed, it's stored here in so we always know what the
// last command was.

var int LastType;
var string LastParams[2];

replication
{
	reliable if (Role==ROLE_Authority)
		ClientPerform, ClientMessage;

	reliable if (ROLE<ROLE_Authority)
		ServerCallBack;
}

// ====================================================================
// The security system works as follows.  The Server performs a security command
// by executing a ClientPerform call.  This will replicate to the client which then passes it
// nativly using NativePerform.  Native perform nativally replicates the response back to the
// response handler (ServerCallBack) for this client.
// ====================================================================

native function NativePerform(int SecType, string Param1, string Param2);

simulated function ClientPerform(int SecType, string Param1, string Param2)
{
	NativePerform(SecType, Param1, Param2);
}

event ServerCallback(int SecType, string Data)	// Should be Subclassed
{
	SetTimer(0,false);
	GotoState('');
}

// ====================================================================
// Perform causes the security system to perform a command, and then
// wait for a response.

function Perform(int SecType, string Param1, string Param2, float TimeOut)
{
	// Store the command

	LastType = SecType;
	LastParams[0] = Param1;
	LastParams[1] = Param2;

	ClientPerform(SecType, Param1, Param2);	// Tell the client to perform the command
	SetTimer(TimeOut,false);				// Setup a timeout for the command
	GotoState('Probation');					// Client is now on probation while we await the response
}

// ====================================================================
// When the Security actor performs a security command, it enters the probationary state while
// it awaits a response.  If the TimeOut value is exceeded, the client is removed from the server.

state Probation
{
	function Timer()			// Should be SubClassed
	{
		BadClient(LastType,LastParams[0]$","$LastParams[1]);
	}
}



// ====================================================================
// The Final portion of the security is the communitcation system between
// the server and the client when something goes wrong.

function BadClient(int Code, string data)	// Should be subclassed
{
	ClientMessage("The Server has determined that your client is illegal and you have been removed! Code: "$Code$" ["$Data$"]");
	Owner.Destroy();
	Destroy();
}

simulated function ClientMessage(string s)	// Should be subclassed
{
	log(S,'Security');
}

defaultproperties
{

}
class ShadowBitmapMaterial extends BitmapMaterial
	native;


#exec Texture Import file=Textures\BlobTexture.pcx MIPS=OFF UCLAMPMODE=CLAMP VCLAMPMODE=CLAMP PRECACHE

var const transient int	TextureInterfaces[2];

var Actor	ShadowActor;
var vector	LightDirection;
var float	LightDistance,
			LightFOV;
var bool	Dirty,
			Invalid,
			bBlobShadow;
var float   CullDistance;
var byte	ShadowDarkness;

var BitmapMaterial	BlobShadow;

cpptext
{
	virtual void Destroy();

	virtual FBaseTexture* GetRenderInterface();
	virtual UBitmapMaterial* Get(FTime Time,UViewport* Viewport);
	virtual void PrepareForProjectorUse(UViewport* Viewport);
}

//
//	Default properties
//

defaultproperties
{
	Format=TEXF_RGBA8
	UClampMode=TC_Clamp
	VClampMode=TC_Clamp
	USize=128
	VSize=128
	UClamp=128
	VClamp=128
	UBits=7
	VBits=7
	Dirty=True
	Invalid=False
	BlobShadow=BlobTexture
	ShadowDarkness=255
	
	bAlphaKill=true
}
//
//	ShadowProjector
//

class ShadowProjector extends Projector;



var() Actor					ShadowActor;
var() vector				LightDirection;
var() float					LightDistance;
var() bool					RootMotion;
var() bool					bBlobShadow;
var() bool                  bOrientedShadow;
var() bool					bShadowActive;
var ShadowBitmapMaterial	ShadowTexture;
var   float					m_flNextShadowCheck;
var   int                   OrientationOffset;

const SHADOW_CHECK_INTERVAL = 0.1;
const SHADOW_BLOB_DISTANCE = 1000;
const SHADOW_HIDDEN_DISTANCE = 2000;

//
//	PostBeginPlay
//

event PostBeginPlay()
{
	Super(Actor).PostBeginPlay();
}

//
//	Destroyed
//

event Destroyed()
{
	if(ShadowTexture != None)
	{
		DetachProjector( true );
		ShadowTexture.ShadowActor = None;

//		if(!ShadowTexture.Invalid)
//			Level.ObjectPool.FreeObject(ShadowTexture);
		delete( ShadowTexture );

		ShadowTexture = None;
		ProjTexture = None;
	}

	Super.Destroyed();
}

//
//	InitShadow
//

function InitShadow(BitmapMaterial UserBlobShadow, bool bActive)
{
	local Plane		BoundingSphere;

	if(ShadowActor != None)
	{
		BoundingSphere = ShadowActor.GetRenderBoundingSphere();
		FOV = Atan(BoundingSphere.W * 2 + 160, LightDistance) * 180 / PI;

//		ShadowTexture = ShadowBitmapMaterial(Level.ObjectPool.AllocateObject(class'ShadowBitmapMaterial', Level.Outer )); // GBX:naj - modified 3/11/04
		ShadowTexture = new( Level.Outer ) class'ShadowBitmapMaterial';
		ProjTexture = ShadowTexture;

		if(ShadowTexture != None)
		{
			SetDrawScale(LightDistance * tan(0.5 * FOV * PI / 180) / (0.5 * ShadowTexture.USize));

			ShadowTexture.Invalid = False;
			ShadowTexture.bBlobShadow = bBlobShadow;
			ShadowTexture.ShadowActor = ShadowActor;
			ShadowTexture.LightDirection = Normal(LightDirection);
			ShadowTexture.LightDistance = LightDistance;
			ShadowTexture.LightFOV = FOV;
            ShadowTexture.CullDistance = CullDistance;
            if (UserBlobShadow != None)
            {
                ShadowTexture.BlobShadow = UserBlobShadow;
            }

			Enable('Tick');
			UpdateShadow();
		}
		else
			Log(Name$".InitShadow: Failed to allocate texture");
	}
	else
		Log(Name$".InitShadow: No actor");
}

//
//	UpdateShadow
//

function UpdateShadow()
{
	local coords	C;
//	local float		flDist;
    local rotator   ShadowRotation;

	if (Level.bNoAppFocus)
	{
		return;
	}
	
	DetachProjector(true);

	if(ShadowActor != None && !ShadowActor.bHidden && ShadowTexture != None && bShadowActive)
	{
/*
		if (!Level.Game.IsA('WargameMultiplayer'))
		{
			if (Level.TimeSeconds > m_flNextShadowCheck)
			{
				flDist = VSize(ShadowActor.Location - Level.GetLocalPlayerController().Pawn.Location);
				if (flDist > SHADOW_HIDDEN_DISTANCE)
				{
					ShadowTexture.bBlobShadow=true;
				}
				else
				{
					if (Level.Game.bBlobShadowsOnly || (flDist > SHADOW_BLOB_DISTANCE))
					{
						ShadowTexture.bBlobShadow=true;
					}
					else
					{
						ShadowTexture.bBlobShadow=false;
					}
				}
				m_flNextShadowCheck = Level.TimeSeconds + SHADOW_CHECK_INTERVAL;
			}
		}
*/
		if(ShadowTexture.Invalid)
		{
			Destroy();
		}
		else
		{
			if(!bBlobShadow && RootMotion && ShadowActor.DrawType == DT_Mesh && ShadowActor.Mesh != None)
			{
				C = ShadowActor.GetBoneCoords('');
				SetLocation(C.Origin);
			}
			else
			{
				SetLocation(ShadowActor.Location + vect(0,0,5));
			}
			
			if (bOrientedShadow)
			{
    			ShadowRotation = Rotator(Normal(-LightDirection));
    			ShadowRotation.Roll = ShadowActor.Rotation.Yaw + OrientationOffset;
    			SetRotation(ShadowRotation);
			}
			else
			{
			    SetRotation(Rotator(Normal(-LightDirection)));
			}

			ShadowTexture.Dirty = true;
            ShadowTexture.CullDistance = CullDistance;

            AttachProjector();
		}
	}
}

//
//	Tick
//

function Tick(float DeltaTime)
{
	super.Tick(DeltaTime);
	UpdateShadow();
}

function SetProjectorActor( Actor ProjectorActor )
{
	if (ProjectorActor == None)
		DetachProjector( true );
	else
		AttachProjector();
	ShadowActor = ProjectorActor;
	if (ShadowTexture != None)
	{
		ShadowTexture.ShadowActor = ProjectorActor;
	}
	// Force an update since, when going into SA view, we pause the game which prevents update from repositioning these
	// previous sleeping projectors to the location of their owner.
	UpdateShadow();
}

defaultproperties
{
    ProjectorArchetype=PRJA_Shadow
	BlendEquation=blendequation_Add
	BlendSrcFunction=blend_DstColor
	BlendDstFunction=blend_SrcColor
	bDoNotColorFog=false
	bDoNotAlphaFog=false
	bOverrideFogColor=true
	TransparentFactor=(R=0,G=0,B=0,A=255)
	TransparentColor=(R=128,G=128,B=128,A=255)
	OverriddenFogColor=(R=128,G=128,B=128,A=255)
    
    bProjectOnBackfaces=True
	bShadowActive=True
	bProjectActor=False
	bProjectOnAlpha=False
	bClipBSP=True
	bClipStaticMesh=True
	bClipStaticMeshTris=True
	bGradient=True
	bStatic=False
	bOwnerNoSee=True
	bBlobShadow=False
	bOrientedShadow=False
	RemoteRole=ROLE_None
    CullDistance=1200.0
    bDynamicAttach=True
    OrientationOffset=24576
    
	bProjFlag_Shadow=True
	bProjFlag_VehicleShadow=False
	bProjFlag_LevelShadow=False
	bProjFlag_Blood=False
	bProjFlag_Bullet=False
	bProjFlag_Blast=False
	bProjFlag_SAVIcon=False
	bProjFlag_ObjectiveIcon=False
	bProjFlag_CommandRing=False
}
//=============================================================================
// SkyZoneInfo.
//=============================================================================
class SkyZoneInfo extends ZoneInfo
	native;



defaultproperties
{
	RemoteRole=ROLE_SimulatedProxy
}
// SmallNavigationPoint
// Convenience class, to allow single point to specify small navigation point sizes

class SmallNavigationPoint extends NavigationPoint
	native
	abstract;



defaultproperties
{
     CollisionRadius=+00028.000000
     CollisionHeight=+00090.000000
}
//=============================================================================
// Emitter: An Unreal Spark Particle Emitter.
//=============================================================================
class SparkEmitter extends ParticleEmitter
	native;



struct ParticleSparkData
{
	var	float	TimeBeforeVisible;
	var float	TimeBetweenSegments;
	var vector	StartLocation;
	var vector	StartVelocity;
};

var (Spark)			range						LineSegmentsRange;
var (Spark)			range						TimeBeforeVisibleRange;
var (Spark)			range						TimeBetweenSegmentsRange;

var transient		array<ParticleSparkData>	SparkData;
var transient		vertexbuffer				VertexBuffer;
var transient		indexbuffer					IndexBuffer;
var transient		int							NumSegments;
var transient		int							VerticesPerParticle;
var transient		int							IndicesPerParticle;
var transient		int							PrimitivesPerParticle;


defaultproperties
{
	LineSegmentsRange=(Min=5,Max=5)
}
//=============================================================================
// Emitter: An Unreal Sprite Particle Emitter.
//=============================================================================
class SpriteEmitter extends ParticleEmitter
	native;




enum EParticleDirectionUsage
{
	PTDU_None,
	PTDU_Up,
	PTDU_Right,
	PTDU_Forward,
	PTDU_Normal,
	PTDU_UpAndNormal,
	PTDU_RightAndNormal,
	PTDU_Scale
};


var (Sprite)		EParticleDirectionUsage		UseDirectionAs;
var (Sprite)		vector						ProjectionNormal;

var transient		vector						RealProjectionNormal;

defaultproperties
{
	UseDirectionAs=PTDU_None
	ProjectionNormal=(X=0,Y=0,Z=1)
}
//=============================================================================
// StaticMeshActor.
// An actor that is drawn using a static mesh(a mesh that never changes, and
// can be cached in video memory, resulting in a speed boost).
//=============================================================================

class StaticMeshActor extends Actor
	native
	placeable;



var(Collision) bool bExactProjectileCollision;		// nonzero extent projectiles should shrink to zero when hitting this actor

defaultproperties
{
	DrawType=DT_StaticMesh
	bEdShouldSnap=True
	bStatic=True
	bStaticLighting=True
	bShadowCast=True
	bCollideActors=True
	bBlockActors=True
	bBlockPlayers=True
	bBlockKarma=True
	bWorldGeometry=True
    CollisionHeight=+000001.000000
	CollisionRadius=+000001.000000
	bExactProjectileCollision=true
	bAlphaFogable=True
    bAlphaFogBlend=true
    
	bAcceptsProjectors=True		//DHW+ We want static models to accept blood and bullet decals no
	
	bProjFlag_Shadow=False
	bProjFlag_SAVIcon=False
	bProjFlag_Blood=True
	bProjFlag_Bullet=True
	bProjFlag_Blast=False
	bProjFlag_ObjectiveIcon=False
}
// Polgyon back-to-front sorted for alphablending at runtime

class StaticMeshActorSorted extends StaticMeshActor
	native
	placeable;
	
var float RecalcDistance;   // How far the POV needs to move before the polygons are re-sorted

var transient   int             IndexBufferPtr[2]; // FRawIndexBuffer*
var transient   StaticMesh      IndicesFromMesh[2];// Sanity check to make sure the 'StaticMesh' field hasnt changed on us
var transient   vector          SortedPOV[2];      // Point-of-view of the last sorted position

defaultproperties
{
	DrawType=DT_StaticMeshSorted
	
	RecalcDistance=512.0
}
// ====================================================================
//  Class:  WarfareGame.StationaryWeapons
//  Parent: Engine.Actor
//

// ====================================================================

class StationaryWeapons extends Pickup
		Abstract
		Native
		NativeReplication;



var()	int  TeamIndex;			// The team that owns this weapon
var()   bool bIgnoreTeammates;	// This weapon will ignore teammates
var()	StaticMesh Meshes[2];	// What meshes to use

var 	byte bActive;			// Is this weapon active
var	byte bLastActive;		// What was the last bActive

replication
{
	reliable if (ROLE==ROLE_Authority)
		bActive, TeamIndex;
}

event PostBeginPlay()
{
	SetTeam(TeamIndex);
	Super.PostBeginPlay();
}

function SetTeam(int NewTeamIndex)
{
	SetStaticMesh(Meshes[NewTeamIndex]);
	TeamIndex = NewTeamIndex;
}

// Activated and Deactivated are called when bActive changes state on replication

simulated event Activated();
simulated event Deactivated();

auto state fucked
{
}

function Activate()			// Should be subclassed
{
	bActive = 1;
	if ( (Level.NetMode==NM_ListenServer) || (Level.NetMode==NM_Standalone) )
		Activated();

}

function DeActivate()		// Should be subclassed
{
	bActive = 0;
	if ( (Level.NetMode==NM_ListenServer) || (LEvel.NetMode==NM_Standalone) )
		Deactivated();
}

function Explode(vector HitLocation, vector HitNormal)
{
	Destroy();
}

function float ReduceDamage(int Damage, class <DamageType> DamageType)
{
	return Damage;
}

function TakeDamage(int Damage, Pawn EventInstigator, vector HitLocation, vector Momentum, class <DamageType> DamageType, optional name HitBoxName)
{
	Explode(HitLocation, vect(0,0,0));
}


defaultproperties
{
	DrawType=DT_StaticMesh
	Physics=PHYS_None
	bNoDelete=false
	bIgnoreTeammates=true
	RemoteRole=ROLE_SimulatedProxy
    bCollideActors=True
	bCollideWorld=true
    bProjTarget=True
    bFixedRotationDir=false
    RotationRate=(Yaw=0)
    DesiredRotation=(Yaw=0)
	bOnlyReplicateHidden=false
}
class SubActionCameraEffect extends MatSubAction
	native
	noexport
	collapsecategories;



var() editinline CameraEffect	CameraEffect;
var() float						StartAlpha,
								EndAlpha;
var() bool						DisableAfterDuration;

defaultproperties
{
	Icon=SubActionFade
	Desc="Camera effect"
	StartAlpha=0.0
	EndAlpha=1.0
	DisableAfterDuration=False
}
//=============================================================================
// SubActionCameraShake:
//
// Shakes the camera randomly.
//=============================================================================
class SubActionCameraShake extends MatSubAction
	native;

var(Shake)	rangevector		Shake;
var(Shake)	float			RollMag;
var(Shake)	float			RollRate;
var(Shake)	float			RollTime;
var(Shake)	Vector			OffsetMag;
var(Shake)	Vector			OffsetRate;
var(Shake)	float			OffsetTime;

defaultproperties
{
	Icon=SubActionCameraShake
	Desc="Shake"
}
//=============================================================================
// SubActionFade:
//
// Fades to/from a color
//=============================================================================
class SubActionFade extends MatSubAction
	native;



var(Fade)	color	FadeColor;		// The color to use for the fade
var(Fade)	bool	bFadeOut;		// If TRUE, the screen is fading out (towards the color)

defaultproperties
{
	Icon=SubActionFade
	Desc="Fade"
	bFadeOut=true
}
//=============================================================================
// SubActionFOV:
//
// Changes the viewers FOV
//=============================================================================
class SubActionFOV extends MatSubAction
	native;



var(FOV)	range		FOV;

defaultproperties
{
	Icon=SubActionFOV
	Desc="FOV"
}
//=============================================================================
// SubActionGameSpeed:
//
// Changes the game speed.
//=============================================================================
class SubActionGameSpeed extends MatSubAction
	native;



var(GameSpeed)	range	GameSpeed;

defaultproperties
{
	Icon=SubActionGameSpeed
	Desc="Game Speed"
}
//=============================================================================
// SubActionOrientation:
//
// Changes the camera orientation.
//=============================================================================
class SubActionOrientation extends MatSubAction
	native;



var(Orientation)	Orientation		CamOrientation;

defaultproperties
{
	Icon=SubActionOrientation
	Desc="Orientation"
}
//=============================================================================
// SubActionSceneSpeed:
//
// Alters the speed of the scene without affecting the engine speed.
//=============================================================================
class SubActionSceneSpeed extends MatSubAction
	native;



var(SceneSpeed)	range	SceneSpeed;

defaultproperties
{
	Icon=SubActionSceneSpeed
	Desc="Scene Speed"
}
//=============================================================================
// SubActionTrigger:
//
// Fires off a trigger.
//=============================================================================
class SubActionTrigger extends MatSubAction
	native;



var(Trigger)	name	EventName;		// The event to trigger

defaultproperties
{
	Icon=SubActionTrigger
	Desc="Trigger"
}
class Suicided extends DamageType
	abstract;



defaultproperties
{
    DeathString="%o had an aneurysm."
	MaleSuicide="%o had an aneurysm."
	FemaleSuicide="%o had an aneurysm."
    bNoSpecificLocation=true
    bArmorStops=false
}
//=============================================================================
// SVehicle
// karma physics subclass of vehicle, including networking support
//=============================================================================

class SVehicle extends Vehicle
	native
	abstract;

cpptext
{
#ifdef WITH_KARMA
	// Actor interface.
	virtual void PostBeginPlay();
	virtual void Destroy();
	virtual void PostNetReceive();
	virtual void PostNetReceiveLocation();
    virtual void PostEditChange();
	virtual void setPhysics(BYTE NewPhysics, AActor *NewFloor, FVector NewFloorV);
	virtual void TickSimulated( FLOAT DeltaSeconds );
	virtual void TickAuthoritative( FLOAT DeltaSeconds );
	virtual void physKarma(FLOAT DeltaTime);
	virtual void preContactUpdate();
	virtual void preKarmaStep(FLOAT DeltaTime);

	// SVehicle interface.
	virtual void UpdateVehicle(FLOAT DeltaTime);
	virtual void KTermSVehicleDynamics();
#endif

}

var (SVehicle) editinline export	array<SVehicleWheel>		Wheels; // Wheel data

var	const bool			bVehicleOnGround; // OUTPUT: True if _any_ SVehicleWheel is currently touching the ground (ignores contacts with chassis etc)

//// PHYSICS ////
var (SVehicle) float	VehicleMass;
var (SVehicle) float	FlipTorque, FlipTime;
var float FlipScale, FlipTimeLeft;
var vector FlipAxis;

//// EFFECTS ////
var (SVehicle) class<Actor>	DestroyEffectClass;		// Effect spawned when vehicle is destroyed

// Useful function for plotting data to real-time graph on screen.
native final function GraphData(string DataName, float DataValue);

// You got some new info from the server (ie. VehicleState has some new info).
event VehicleStateReceived();

// Do script car model stuff here - but DONT create/destroy anything.
native event UpdateVehicle( float DeltaTime );

// Do any general vehicle set-up when it gets spawned.
simulated function PostNetBeginPlay()
{
    Super.PostNetBeginPlay();

	// Make sure params are up to date.
	SVehicleUpdateParams();
}

function JumpOffPawn() {}

// Called when a parameter of the overall articulated actor has changed (like PostEditChange)
// The script must then call KUpdateConstraintParams or Actor Karma mutators as appropriate.
simulated event SVehicleUpdateParams()
{
	KSetMass(VehicleMass);
}

// The pawn Driver has tried to take control of this vehicle
function bool TryToDrive(Pawn P)
{
	if (FlipTimeLeft > 0)
		return false;

	if (NeedsFlip())
	{
		Flip(vector(P.Rotation), 1);
		return false;
	}

	return super.TryToDrive(P);
}

function Flip(vector HitNormal, float ForceScale)
{
	if (!bCanFlip)
		return;

	FlipTimeLeft = FlipTime;
	FlipScale = ForceScale;
	FlipAxis = HitNormal;
	FlipAxis.Z = 0;
	enable('Tick');
}

simulated function KApplyForce(out vector Force, out vector Torque)
{
	local float torqueScale;
	local vector worldUp, torqueAxis;

	Super.KApplyForce(Force, Torque);

	if (FlipTimeLeft <= 0)
		return;

	worldUp = vect(0, 0, 1) >> Rotation;

	torqueAxis = Normal(FlipAxis Cross worldUp);

	// Torque scaled by how far over we are.
	// This will be between 0 and PI - so convert to between 0 and 1.
	torqueScale = Acos(worldUp Dot vect(0, 0, 1))/3.1416;

	Torque = FlipScale * FlipTorque * torqueScale * torqueAxis;
}

simulated function Tick(float deltaTime)
{
	Super.Tick(deltaTime);

	if (FlipTimeLeft > 0)
	{
		KWake();
		FlipTimeLeft -= deltaTime;
		if (FlipTimeLeft <= 0 && !bDriving)
			disable('Tick');
	}
}

simulated function Destroyed()
{
	// Trigger any effects for destruction
	if ( DestroyEffectClass != None )
		Spawn(DestroyEffectClass, , , Location, Rotation);

	super.Destroyed();
}

// Includes properties from KActor
defaultproperties
{
	VehicleMass=1.0
    Physics=PHYS_Karma
	bEdShouldSnap=True
	bStatic=False
	bShadowCast=False
	bCollideActors=True
	bCollideWorld=False
    bProjTarget=True
	bBlockActors=True
	bBlockNonZeroExtentTraces=True
	bBlockZeroExtentTraces=True
	bWorldGeometry=False
	bBlockKarma=True
	bAcceptsProjectors=True
	bCanBeBaseForPawns=True
	bAlwaysRelevant=false
	RemoteRole=ROLE_SimulatedProxy
	bNetInitialRotation=True
	bSpecialCalcView=True
//jlb	bDramaticLighting=True
	FlipTorque=300
	FlipTime=2

	// this needs to be true to collide with AI Pawns
	bCollideSkeletalMesh=true
}
//=============================================================================
// SVehicle spawner location.
//=============================================================================

class SVehicleFactory extends Actor
	native
	placeable;

#exec TEXTURE IMPORT NAME=S_KVehFact	FILE=Textures\S_KVehFact.tga    MIPS=OFF COMPRESS=DXT1

var()	class<Vehicle>		VehicleClass;

var()	bool	bDontWaitForTrigger;
var()	int					MaxVehicleCount;
var		int					VehicleCount;

cpptext
{
	INT AddMyMarker(AActor *S);
}

function PreBeginPlay()
{
	local Vehicle CreatedVehicle;

/*jlb
	if (!Level.Game.bAllowVehicles && !bNoDelete)
	{
		Destroy();
		return;
	}
jlb*/

	Super.PreBeginPlay();

	if (bDontWaitForTrigger)
	{
		if ( VehicleClass != None )
		{
			CreatedVehicle = spawn(VehicleClass, , , Location, Rotation);
			if ( CreatedVehicle != None )
			{
				VehicleCount++;
				CreatedVehicle.ParentFactory = self;
			}
		}
	}
}

event VehicleDestroyed( Vehicle V )
{
	VehicleCount--;
}

event VehiclePossessed( Vehicle V );
event VehicleUnPossessed( Vehicle V );


event Trigger( Actor Other, Pawn EventInstigator )
{
	local Vehicle CreatedVehicle;

//jlb	if (!Level.Game.bAllowVehicles)
//jlb		return;

	if ( VehicleClass == None )
	{
		Log("SVehicleFactory:"@self@"has no VehicleClass");
		return;
	}

	if ( !EventInstigator.IsA('Pawn') )
		return;

	if ( VehicleCount >= MaxVehicleCount )
	{
		// Send a message saying 'too many vehicles already'
		return;
	}

	if ( VehicleClass != None )
	{
		CreatedVehicle = spawn(VehicleClass, , , Location, Rotation);
		if ( CreatedVehicle != None )
		{
			VehicleCount++;
			CreatedVehicle.ParentFactory = self;
		}
	}
}


defaultproperties
{
	MaxVehicleCount=1
	bHidden=true
	Texture=S_KVehFact
	RemoteRole=ROLE_None
	bNoDelete=True
	bDirectional=true
}
class SVehicleWheel extends Object
	native;


cpptext
{
#ifdef WITH_KARMA
	// Actor interface.
	virtual bool preContactUpdate(AActor *MyOwner);
	virtual void KTermSVehicleDynamics();
#endif
}

// INPUT
var()					float	Steer; // degrees

var()					float	DriveForce; // resultant linear driving force at wheel center
var()					float	LongFriction; // maximum linear longitudinal (roll) friction force
var()					float	LatFriction; // maximum linear longitudinal (roll) friction force
var()					float	LongSlip;
var()					float	LatSlip;
var()					float	ChassisTorque; // Torque applied back to the chassis (equal-and-opposite) from this wheel.

// PARAMS
var()					bool	bPoweredWheel;
var()					bool	bHandbrakeWheel;
var()                   bool    bTrackWheel;
var()                   bool    bLeftTrack;
var()					enum	EVehicleSteerType
{
	VST_Fixed,
	VST_Steered,
	VST_Inverted
} SteerType; // How steering affects this wheel.

var()					name	BoneName;
var()					EAxis	BoneRollAxis; // Local axis to rotate the wheel around for normal rolling movement.
var()					EAxis	BoneSteerAxis; // Local axis to rotate the wheel around for steering.
var()					vector	BoneOffset; // Offset from wheel bone to line check point (middle of tyre). NB: Not affected by scale.
var()					float	WheelRadius; // Length of line check. Usually 2x wheel radius.
var()					bool	bInvertRollDirection;

var()					float	Softness;
var()					float	PenScale;
var()					float	PenOffset;
var()					float	Restitution;
var()					float	Adhesion;
var()					float	WheelInertia;
var()					float	SuspensionTravel;
var()					float   SuspensionOffset;
var()					float	HandbrakeSlipFactor;
var()					float	HandbrakeFrictionFactor;
var()					float	SuspensionMaxRenderTravel;

var()					name	SupportBoneName; // Name of strut etc. that will be rotated around local X as wheel goes up and down.
var()					EAxis	SupportBoneAxis; // Local axis to rotate support bone around.

// Approximations to Pacejka's Magic Formula
var()					InterpCurve		LongFrictionFunc; // Function of SlipVel
var()					InterpCurve		LatSlipFunc; // Function of SpinVel

// OUTPUT

// Calculated on startup
var						vector	WheelPosition; // Wheel center in actor ref frame. Calculated using BoneOffset above.
var						float	SupportPivotDistance; // If a SupportBoneName is specified, this is the distance used to calculate the anglular displacement.

// Calculated each frame
var						bool	bWheelOnGround;
var						float	TireLoad; // Load on tire
var						vector	WheelDir; // Wheel 'forward' in world ref frame. Unit length.
var						vector	WheelAxle; // Wheel axle in world ref frame. Unit length.

var						float	SpinVel; // Radians per sec
var						float	TrackVel; // Radians per sec

var						float   SlipAngle; // Angle between wheel facing direction and wheel travelling direction. In degrees.

var						float	SlipVel;   // Difference in linear velocity between ground and wheel at contact.

var						float	SuspensionPosition; // Output position of
var						float	CurrentRotation;


// Used internally for Karma stuff - DO NOT CHANGE!
var		transient const int		KContact;

defaultproperties
{
	HandbrakeSlipFactor=1.0
	HandbrakeFrictionFactor=1.0
	Softness=0.05
	PenScale=1.0
	WheelInertia=1.0
	SteerType=VST_Fixed
	SuspensionTravel=50.0
	SuspensionMaxRenderTravel=50.0
	WheelRadius=35
	BoneRollAxis=AXIS_X
	BoneSteerAxis=AXIS_Z
	SupportBoneAxis=AXIS_Y
}
//=============================================================================
// TeamInfo.
//=============================================================================
class TeamInfo extends ReplicationInfo
	native
	nativereplication;



var localized string TeamName;
var int Size; //number of players on this team in the level
var float Score;
var int TeamIndex;
var color TeamColor, AltTeamColor;
var Actor HomeBase;			// key objective associated with this team
var() class<Pawn> DefaultPlayerClass;
var localized string ColorNames[4];
var Material TeamIcon;

replication
{
	// Variables the server should send to the client.
	reliable if( bNetDirty && (Role==ROLE_Authority) )
		Score, HomeBase;
	reliable if ( bNetInitial && (Role==ROLE_Authority) )
		TeamName, TeamColor, AltTeamColor, TeamIndex, TeamIcon;
}

function bool BelongsOnTeam(class<Pawn> PawnClass)
{
	return true;
}

simulated function UpdatePrecacheMaterials()
{
	Level.AddPrecacheMaterial(TeamIcon);
}

simulated function string GetHumanReadableName()
{
	if ( TeamName == Default.TeamName )
	{
		if ( TeamIndex < 4 )
			return ColorNames[TeamIndex];
		return TeamName@TeamIndex;
	}
	return TeamName;
}

function bool AddToTeam( Controller Other, optional int desiredTeamId )
{
	local Controller P;
	local bool bSuccess;

	// make sure loadout works for this team
	if ( Other == None )
	{
		log("Added none to team!!!");
		return false;
	}

	if (MessagingSpectator(Other) != None)
		return false;

	Size++;
	Other.PlayerReplicationInfo.Team = self;
	Other.PlayerReplicationInfo.NetUpdateTime = Level.TimeSeconds - 1;

	bSuccess = false;
	if ( Other.IsA('PlayerController') )
	{
		desiredTeamId = Max(desiredTeamId, 0);		
		Other.PlayerReplicationInfo.TeamID = desiredTeamId;
	}
	else
		Other.PlayerReplicationInfo.TeamID = 1;

	while ( !bSuccess )
	{
		bSuccess = true;
		for ( P=Level.ControllerList; P!=None; P=P.nextController )
            if ( P.bIsPlayer && (P != Other)
				&& (P.PlayerReplicationInfo.Team == Other.PlayerReplicationInfo.Team)
				&& (P.PlayerReplicationInfo.TeamId == Other.PlayerReplicationInfo.TeamId) )
				bSuccess = false;
		if ( !bSuccess )
		{
			log(self $ " TeamInfo::AddToTeam(): TeamId collision between P = " $ P $ ", and Other = " $ Other, 'MP');
			Other.PlayerReplicationInfo.TeamID = Other.PlayerReplicationInfo.TeamID + 1;
		}
	}
	return true;
}

function RemoveFromTeam(Controller Other)
{
	Size--;
	Other.PlayerReplicationInfo.Team = None; //SDJ 06/04/2004: Clearing PlayerReplicationInfo.Team seems like an obvious part of removing a player from a team as addToTeam() is responsible for setting it.
}

defaultproperties
{
	TeamName="Team"
	TeamColor=(R=255,G=0,B=0,A=255)
	AltTeamColor=(R=200,G=0,B=0,A=255)
	ColorNames(0)="Red"
	ColorNames(1)="Blue"
	ColorNames(2)="Green"
	ColorNames(3)="Gold"
}
//
//	ShadowProjector
//

class TeamLogoProjector extends ShadowProjector;

function Destroyed()
{
	Instigator = None;  // prevent references to/in destroyed objects

    super.Destroyed();
}


defaultproperties
{
    ProjectorArchetype=PRJA_Basic
	BlendEquation=blendequation_Add
    BlendSrcFunction=blend_SrcAlpha
    BlendDstFunction=blend_OneMinusSrcAlpha
	bDoNotColorFog=true
	bDoNotAlphaFog=true
	bOverrideFogColor=true
	TransparentFactor=(R=0,G=0,B=255,A=0)
	TransparentColor=(R=0,G=0,B=0,A=0)
	OverriddenFogColor=(R=0,G=0,B=0,A=0)

    bGradient=False
    bBlobShadow=True
    bOrientedShadow=False

	bProjFlag_Shadow=False
	bProjFlag_VehicleShadow=False
	bProjFlag_LevelShadow=False
	bProjFlag_Blood=False
	bProjFlag_Bullet=False
	bProjFlag_Blast=False
	bProjFlag_SAVIcon=True
	bProjFlag_ObjectiveIcon=False
	bProjFlag_CommandRing=False
}
///=============================================================================
// Teleports actors either between different teleporters within a level
// or to matching teleporters on other levels, or to general Internet URLs.
//=============================================================================
class Teleporter extends SmallNavigationPoint
	placeable
	native;



//-----------------------------------------------------------------------------
// Teleporter URL can be one of the following forms:
//
// TeleporterName
//		Teleports to a named teleporter in this level.
//		if none, acts only as a teleporter destination
//
// LevelName/TeleporterName
//     Teleports to a different level on this server.
//
// Unreal://Server.domain.com/LevelName/TeleporterName
//     Teleports to a different server on the net.
//
var() string URL;

//-----------------------------------------------------------------------------
// Product the user must have installed in order to enter the teleporter.
var() name ProductRequired;

//-----------------------------------------------------------------------------
// Teleporter destination flags.
var() bool    bChangesVelocity; // Set velocity to TargetVelocity.
var() bool    bChangesYaw;      // Sets yaw to teleporter's Rotation.Yaw
var() bool    bReversesX;       // Reverses X-component of velocity.
var() bool    bReversesY;       // Reverses Y-component of velocity.
var() bool    bReversesZ;       // Reverses Z-component of velocity.

// Teleporter flags
var() bool	  bEnabled;			// Teleporter is turned on;

//-----------------------------------------------------------------------------
// Teleporter destination directions.
var() vector  TargetVelocity;   // If bChangesVelocity, set target's velocity to this.

// AI related
var Actor TriggerActor;		//used to tell AI how to trigger me
var Actor TriggerActor2;

var float LastFired;

//-----------------------------------------------------------------------------
// Teleporter destination functions.

replication
{
	reliable if( Role==ROLE_Authority )
		bEnabled, URL;
	reliable if ( bNetInitial && (Role == ROLE_Authority) )
		bChangesVelocity, bChangesYaw, bReversesX, bReversesY, bReversesZ, TargetVelocity;
}

function PostBeginPlay()
{
	if (URL ~= "")
		SetCollision(false, false, false); //destination only

	if ( !bEnabled )
		FindTriggerActor();
	Super.PostBeginPlay();
}

function FindTriggerActor()
{
	local Actor A;

	TriggerActor = None;
	TriggerActor2 = None;
	ForEach DynamicActors(class 'Actor', A)
		if ( A.Event == Tag)
		{
			if (TriggerActor == None)
				TriggerActor = A;
			else
			{
				TriggerActor2 = A;
				return;
			}
		}
}

// Accept an actor that has teleported in.
simulated function bool Accept( actor Incoming, Actor Source )
{
	local rotator NewRot, OldRot;
	local float mag;
	local vector oldDir;
	local Controller P;

	if ( Incoming == None )
		return false;

	// Move the actor here.
	Disable('Touch');
	NewRot = Incoming.Rotation;
	if (bChangesYaw)
	{
		OldRot = Incoming.Rotation;
		NewRot.Yaw = Rotation.Yaw;
		if ( Source != None )
			NewRot.Yaw += (32768 + Incoming.Rotation.Yaw - Source.Rotation.Yaw);
	}

	if ( Pawn(Incoming) != None )
	{
		//tell enemies about teleport
		if ( Role == ROLE_Authority )
			For ( P=Level.ControllerList; P!=None; P=P.NextController )
				if ( P.Enemy == Incoming )
					P.LineOfSightTo(Incoming);

		if ( !Pawn(Incoming).SetLocation(Location) )
		{
			log(self$" Teleport failed for "$Incoming);
			return false;
		}
		if ( (Role == ROLE_Authority)
			|| (Level.TimeSeconds - LastFired > 0.5) )
		{
			NewRot.Roll = 0;
			Pawn(Incoming).SetRotation(NewRot);
			Pawn(Incoming).SetViewRotation(NewRot);
			Pawn(Incoming).ClientSetRotation(NewRot);
			LastFired = Level.TimeSeconds;
		}
		if ( Pawn(Incoming).Controller != None )
		{
			Pawn(Incoming).Controller.MoveTimer = -1.0;
			Pawn(Incoming).Anchor = self;
			Pawn(Incoming).SetMoveTarget(self);
		}
		Incoming.PlayTeleportEffect(false, true);
	}
	else
	{
		if ( !Incoming.SetLocation(Location) )
		{
			Enable('Touch');
			return false;
		}
		if ( bChangesYaw )
			Incoming.SetRotation(NewRot);
	}
	Enable('Touch');

	if (bChangesVelocity)
		Incoming.Velocity = TargetVelocity;
	else
	{
		if ( bChangesYaw )
		{
			if ( Incoming.Physics == PHYS_Walking )
				OldRot.Pitch = 0;
			oldDir = vector(OldRot);
			mag = Incoming.Velocity Dot oldDir;
			Incoming.Velocity = Incoming.Velocity - mag * oldDir + mag * vector(Incoming.Rotation);
		}
		if ( bReversesX )
			Incoming.Velocity.X *= -1.0;
		if ( bReversesY )
			Incoming.Velocity.Y *= -1.0;
		if ( bReversesZ )
			Incoming.Velocity.Z *= -1.0;
	}
	return true;
}

//-----------------------------------------------------------------------------
// Teleporter functions.

function Trigger( actor Other, Pawn EventInstigator )
{
	local Actor A;

	bEnabled = !bEnabled;
	if ( bEnabled ) //teleport any pawns already in my radius
		ForEach TouchingActors(class'Actor', A)
			PostTouch(A);
}

event Touch(Actor Other)
{
	if ( !bEnabled || (Other == None) )
		return;

	if( Other.bCanTeleport && Other.PreTeleport(Self)==false )
	{
		PendingTouch = Other.PendingTouch;
		Other.PendingTouch = self;
	}
}

// Teleporter was touched by an actor.
simulated function PostTouch( actor Other )
{
	local Teleporter D,Dest[16];
	local int i;

		if( (InStr( URL, "/" ) >= 0) || (InStr( URL, "#" ) >= 0) )
		{
			// Teleport to a level on the net.
			if( (Role == ROLE_Authority) && (Pawn(Other) != None)
				&& Pawn(Other).IsHumanControlled() )
				Level.Game.SendPlayer(PlayerController(Pawn(Other).Controller), URL);
		}
		else
		{
			// Teleport to a random teleporter in this local level, if more than one pick random.

			foreach AllActors( class 'Teleporter', D )
				if( string(D.tag)~=URL && D!=Self )
				{
					Dest[i] = D;
					i++;
					if ( i > arraycount(Dest) )
						break;
				}

			i = rand(i);
			if( Dest[i] != None )
			{
				// Teleport the actor into the other teleporter.
				if ( Other.IsA('Pawn') )
					Other.PlayTeleportEffect(false, true);
				Dest[i].Accept( Other, self );
				if ( Pawn(Other) != None )
					TriggerEvent(Event, self, Pawn(Other));
			}
		}
	}

/* SpecialHandling is called by the navigation code when the next path has been found.
It gives that path an opportunity to modify the result based on any special considerations
*/

function Actor SpecialHandling(Pawn Other)
{
	local vector Dist2D;
	local name RouteTag;

	if (!Other.Controller.RouteCache[1].bIsNavigationPointLite)
		RouteTag = Actor(Other.Controller.RouteCache[1]).tag;
	else
		RouteTag = NavigationPointLite(Other.Controller.RouteCache[1]).tag;

	if ( bEnabled && (Teleporter(Other.Controller.RouteCache[1]) != None)
		&& (string(RouteTag)~=URL) )
	{
		if ( Abs(Location.Z - Other.Location.Z) < CollisionHeight + Other.CollisionHeight )
		{
			Dist2D = Location - Other.Location;
			Dist2D.Z = 0;
			if ( VSize(Dist2D) < CollisionRadius + Other.CollisionRadius )
				PostTouch(Other);
		}
		return self;
	}

	if (TriggerActor == None)
	{
		FindTriggerActor();
		if (TriggerActor == None)
			return None;
	}

	if ( (TriggerActor2 != None)
		&& (VSize(TriggerActor2.Location - Other.Location) < VSize(TriggerActor.Location - Other.Location)) )
		return TriggerActor2;

	return TriggerActor;
}


defaultproperties
{
	 RemoteRole=ROLE_SimulatedProxy
	 bChangesYaw=true
     bEnabled=True
     bDirectional=True
     SoundVolume=128
     bCollideActors=True
	 Texture=Texture'Engine.S_Teleport'
}
class TerrainInfo extends Info
	noexport
	showcategories(Movement,Collision,Lighting,LightColor,Karma,Force)
	native
	placeable;

#exec Texture Import File=Textures\TerrainBad.tga MIPS=OFF COMPRESS=DXT1

struct NormalPair
{
	var vector Normal1;
	var vector Normal2;
};

enum ETexMapAxis
{
	TEXMAPAXIS_XY,
	TEXMAPAXIS_XZ,
	TEXMAPAXIS_YZ,
};

enum ESortOrder
{
	SORT_NoSort,
	SORT_BackToFront,
	SORT_FrontToBack
};

enum EDecoShader
{
    DECO_Basic,
    DECO_Grass,
    DECO_TallGrass,
};

struct TerrainLayer
{
	var() Material	Texture;
	var() Texture	AlphaMap;
	var() int		AlphaStreamIndex;
	var() float		UScale;
	var() float		VScale;
	var() float		UPan;
	var() float		VPan;
	var() ETexMapAxis TextureMapAxis;
	var() float		TextureRotation;
	var() Rotator	LayerRotation;
	var   Matrix	TerrainMatrix;
	var() float		KFriction;
	var() float		KRestitution;
};

struct DecorationLayer
{
	var() int			ShowOnTerrain;
	var() Texture		ScaleMap;
	var() Texture		DensityMap;
	var() Texture		ColorMap;
	var() StaticMesh	StaticMesh;
	var() rangevector	ScaleMultiplier;
	var() range			FadeoutRadius;
	var() range			DensityMultiplier;
	var() int			MaxPerQuad;
	var() int			Seed;
	var() int			AlignToTerrain;
	var() ESortOrder	DrawOrder;
	var() int			ShowOnInvisibleTerrain;
	var() int			LitDirectional;
	var() int			DisregardTerrainLighting;
	var() int			RandomYaw;
	var() Texture		SkewMap;				// << GEARBOX/jmw:add - FEATURE: Texture-skewed decorations >>
	var() range			FadeinRadius;			// << GEARBOX/ZONER:add - FEATURE: Minimum draw distance for decolayer >>
	var() EDecoShader   DecoShader;             // << GEARBOX/ZONER:add - FEATURE: deco shader selection >>
	var() range         ScaleRange;             // << GEARBOX/ZONER:add - FEATURE: vary scale of decos (uniform or shader dependant non-uniform scalar NOT VECTOR) >>
};


struct DecoInfo
{
	var vector	Location;
	var plane   NewRotation;    // really a quaternion
	var color   Color;          //
	var float   Scale;
};

struct DecoSectorInfo
{
	var array<DecoInfo>	DecoInfo;
	var vector			Location;
	var float			Radius;
};

struct DecorationLayerData
{
	var array<DecoSectorInfo> Sectors;
};

var() int						TerrainSectorSize;
var() Texture					TerrainMap;
var() vector					TerrainScale;
var() TerrainLayer				Layers[32];
var() array<DecorationLayer>	DecoLayers;
var() float						DecoLayerOffset;
var config float				DecoDrawDistanceScale;
var() plane                     SunlightColor;
var() plane                     ShadeColor;
var() bool						Inverted;

// This option means use half the graphics res for Karma collision.
// Note - Karma ignores per-quad info (eg. 'invisible' and 'edge-turned') with this set to true.
var() bool						bKCollisionHalfRes;

var() bool						m_fTerrainDisabled;

//
// Internal data
//
var transient int							RuntimeFlags;
var	native const array<DecorationLayerData> DecoLayerData;
var native const array<TerrainSector>		Sectors;
var native const int						HeightmapX;
var native const int 						HeightmapY;
var native const int 						SectorsX;
var native const int 						SectorsY;
var native const TerrainPrimitive 			Primitive;
var native const vector						ToWorld[4];
var native const vector						ToHeightmap[4];
var native const array<int>					SelectedVertices;
var native const int						ShowGrid;
var const array<int>						QuadVisibilityBitmap;
var const array<int>						EdgeTurnBitmap;
var const array<material> QuadDomMaterialBitmap;
var native const array<int>					RenderCombinations;
var native const array<int>					VertexStreams;
var native const array<int>					WeightStreams;
var native const array<color>				VertexColors;
var native const array<color>				PaintedColor;		// editor only
var native const Texture CollapsedLayers;

defaultproperties
{
	Texture=Texture'Engine.S_TerrainInfo'
	TerrainScale=(X=64,Y=64,Z=64)
	bStatic=True	// GBX:PAD - Changed this back since it wrecks terrain in multiplayer, plus there is a different, more stable way now to destroy terrain
//	bStatic=False  // GBX:jlb - changed to allow destroyable terrain
	bStaticLighting=True
	bWorldGeometry=true
    bHidden=true
	TerrainSectorSize=16
	bKCollisionHalfRes=False
	m_fTerrainDisabled=False

	bAcceptsProjectors=True
	bProjFlag_Shadow=True
	bProjFlag_VehicleShadow=True
	bProjFlag_LevelShadow=True
	bProjFlag_Blood=True
	bProjFlag_Bullet=True
	bProjFlag_Blast=True
	bProjFlag_SAVIcon=True
	bProjFlag_ObjectiveIcon=True
	bProjFlag_CommandRing=True

	DecoDrawDistanceScale=1.0f
}
//=============================================================================
// For internal testing.
//=============================================================================
class TestInfo extends Info;



var() bool bTrue1;
var() bool bFalse1;
var() bool bTrue2;
var() bool bFalse2;
var bool bBool1;
var bool bBool2;
var() int xnum;
var float ppp;
var string sxx;
var int MyArray[2];
var vector v1,v2;
var string TestRepStr;
//var string[32] teststring;

const Pie=3.14;
const Str="Tim";
const Lotus=vect(1,2,3);

var struct STest
{
	var bool b1;
	var int i;
	var bool b2;
	var bool b3;
} ST;

function TestQ()
{
	local vector v;
	v.x = 2;
	v.y = 3;
	v.z = 4;
	assert(v==vect(2,3,4));
	assert(v.z==4);
	assert(v.y==3);
	assert(v.x==2);
}

static function test()
{
	class'testinfo'.default.v1 = vect(1,2,3);
}

function PostBeginPlay()
{
	log("!!BEGIN");

	default.v1=vect(5,4,3);
	assert(default.v1==vect(5,4,3));
	test();
	assert(default.v1==vect(1,2,3));

	assert(IsA('Actor'));
	assert(IsA('TestInfo'));
	assert(IsA('Info'));
	assert(!IsA('LevelInfo'));
	assert(!IsA('Texture'));
	//o=dynamicloadobject( "UnrealShare.AutoMag.Reload", class'object' );
	//assert(o!=None);
	//assert(o==None);
	log("!!END");
}

function TestStructBools()
{
	assert(ST.b1==false);
	assert(ST.b2==false);
	assert(ST.b3==false);

	ST.b1=true;
	assert(ST.b1==true);
	assert(ST.b2==false);
	assert(ST.b3==false);

	ST.b2=true;
	assert(ST.b1==true);
	assert(ST.b2==true);
	assert(ST.b3==false);

	ST.b3=true;
	assert(ST.b1==true);
	assert(ST.b2==true);
	assert(ST.b3==true);

	ST.b1=false;
	ST.b2=false;
	ST.b3=false;
}

function BeginPlay()
{
	local testobj to;

	to = new(None) class'TestObj';
	to = new(None)class'TestObj';
	to = new(self)class'TestObj';
	to = new(self,"")class'TestObj';
	to = new(self,"",0)class'TestObj';
	to.Test();
	TestStructBools();
}

function TestX( bool bResource )
{
	local int n;
	n = int(bResource);
	MyArray[ int(bResource) ] = 0;
	MyArray[ int(bResource) ]++;
}

function bool RecurseTest()
{
	bBool1=true;
	return false;
}

function TestLimitor( class c )
{
	local class<actor> NewClass;
	NewClass = class<actor>( c );
}

static function int OtherStatic( int i )
{
	assert(i==246);
	assert(default.xnum==777);
	return 555;
}

static function int TestStatic( int i )
{
	assert(i==123);
	assert(default.xnum==777);
	assert(OtherStatic(i*2)==555);
	return i;
}

function TestContinueFor()
{
	local int i;
	log("TestContinue");
	for( i=0; i<20; i++ )
	{
		log("iteration "$i);
		if(i==7||i==9||i==19)
			continue;
		log("...");
	}
	log("DoneContinue");
}

function TestContinueWhile()
{
	local int i;
	log("TestContinue");
	while( ++i <= 20 )
	{
		log("iteration "$i);
		if(i==7||i==9)
			continue;
		log("...");
	}
	log("DoneContinue");
}

function TestContinueDoUntil()
{
	local int i;
	log("TestContinue");
	do
	{
		i++;
		log("iteration "$i);
		if(i==7||i==9||i>18)
			continue;
		log("...");
	} until( i>20 );
	log("DoneContinue");
}

function TestContinueForEach()
{
	local actor a;
	log("TestContinue");
	foreach AllActors( class'Actor', a )
	{
		log("actor "$a);
		if(light(a)==none)
			continue;
		log("...");
	}
	log("DoneContinue");
}


function SubTestOptionalOut( optional out int a, optional out int b, optional out int c )
{
	a *= 2;
	b = b*2;
	c += c;
}
function TestOptionalOut()
{
	local int a,b,c;
	a=1; b=2; c=3;

	SubTestOptionalOut(a,b,c);
	assert(a==2); assert(b==4); assert(c==6);

	SubTestOptionalOut(a,b);
	assert(a==4); assert(b==8); assert(c==6);

	SubTestOptionalOut(,b,c);
	assert(a==4); assert(b==16); assert(c==12);

	SubTestOptionalOut();
	assert(a==4); assert(b==16); assert(c==12);

	SubTestOptionalOut(a,b,c);
	assert(a==8); assert(b==32); assert(c==24);

	log("TestOptionalOut ok!");
}

function TestNullContext( actor a )
{
	bHidden = a.bHidden;
	a.bHidden = bHidden;
}

function TestSwitch()
{
	local string s;
	local int i;
	local bool b;
	s="Tim";
	i=2;
	switch( i )
	{
		case 0:
			assert(false);
			break;
		case 2:
			b=true;
			break;
		default:
			assert(false);
			break;
	}
	assert(b);
	switch( s )
	{
		case "":
			assert(false);
			break;
		case "xyzzy":
			assert(false);
			break;
		default:
			b=false;
			break;
	}
	assert(!b);
	log("testswitch succeeded");
}

function Tick( float DeltaTime )
{
	local class C;
	local class<testinfo> TC;

	log("time="$Level.TimeSeconds);

	TestOptionalOut();
	TestNullContext( self );
	TestNullContext( None );
	TestSwitch();

	v1=vect(1,2,3);
	v2=vect(2,4,6);
	assert(v1!=v2);
	assert(!(v1==v2));
	assert(v1==vect(1,2,3));
	assert(v2==vect(2,4,6));
	assert(vect(1,2,5)!=v1);
	assert(v1*2==v2);
	assert(v1==v2/2);

	assert(Pie==3.14);
	assert(Pie!=2);
	assert(Str=="Tim");
	assert(Str!="Bob");
	assert(Lotus==vect(1,2,3));

	assert(GetPropertyText("sxx")=="Tim");
	assert(GetPropertyText("ppp")!="123");
	assert(GetPropertyText("bogus")=="");
	xnum=345;
	assert(GetPropertyText("xnum")=="345");
	SetPropertyText("xnum","999");
	assert(xnum==999);
	assert(xnum!=666);

	assert(bTrue1==true);
	assert(bFalse1==false);
	assert(bTrue2==true);
	assert(bFalse2==false);

	assert(default.bTrue1==true);
	assert(default.bFalse1==false);
	assert(default.bTrue2==true);
	assert(default.bFalse2==false);

	assert(class'TestInfo'.default.bTrue1==true);
	assert(class'TestInfo'.default.bFalse1==false);
	assert(class'TestInfo'.default.bTrue2==true);
	assert(class'TestInfo'.default.bFalse2==false);

	TC=Class;
	assert(TC.default.bTrue1==true);
	assert(TC.default.bFalse1==false);
	assert(TC.default.bTrue2==true);
	assert(TC.default.bFalse2==false);

	C=Class;
	assert(class<testinfo>(C).default.bTrue1==true);
	assert(class<testinfo>(C).default.bFalse1==false);
	assert(class<testinfo>(C).default.bTrue2==true);
	assert(class<testinfo>(C).default.bFalse2==false);

	assert(default.xnum==777);
	TestStatic(123);
	TC.static.TestStatic(123);
	class<testinfo>(C).static.TestStatic(123);

	bBool2=RecurseTest();
	assert(bBool2==false);

	TestStructBools();
	TestQ();

	log( "All tests passed" );
}

function f();

function temp()
{
	temp();
}

state AA
{
	function f();
}
state BB
{
	function f();
}
state CCAA extends AA
{
	function f();
}
state DDAA extends AA
{
	function f();
}
state EEDDAA extends DDAA
{
	function f();
}

defaultproperties
{
	bTrue1=true
	bTrue2=true
	bHidden=false
	sxx="Tim"
	ppp=3.14
	xnum=777
	bAlwaysRelevant=True
	RemoteRole=ROLE_SimulatedProxy
}
//=============================================================================
// TestObj: A purely scripted object for internal testing.
//=============================================================================
class TestObj extends Object;



function Test()
{
	log( "TestObj.Test" );
}
class TexCoordSource extends TexModifier
	native
	editinlinenew
	collapsecategories;



var() int	SourceChannel;

cpptext
{
	void PostEditChange();
}

defaultproperties
{
	SourceChannel=0
	TexCoordSource=TCS_Stream0
}
class TexEnvMap extends TexModifier
	editinlinenew
	native;



cpptext
{
	// UTexModifier interface
	virtual FMatrix* GetMatrix(FLOAT TimeSeconds);
}

var() enum ETexEnvMapType
{
	EM_WorldSpace,
	EM_CameraSpace,
} EnvMapType;

defaultproperties
{
	EnvMapType=EM_CameraSpace
	TexCoordCount=TCN_3DCoords
}
class TexMatrix extends TexModifier
	native;



cpptext
{
	// UTexModifier interface
	virtual FMatrix* GetMatrix(FLOAT TimeSeconds) { return &Matrix; }
}

var Matrix Matrix;
class TexModifier extends Modifier
	noteditinlinenew
	native;



cpptext
{
	// UTexModifier interface
	virtual FMatrix* GetMatrix(FLOAT TimeSeconds) { return NULL; }

	// Material interface.
	virtual INT MaterialUSize();
	virtual INT MaterialVSize();
	virtual BYTE RequiredUVStreams();
}

var enum ETexCoordSrc
{
	TCS_Stream0,
	TCS_Stream1,
	TCS_Stream2,
	TCS_Stream3,
	TCS_Stream4,
	TCS_Stream5,
	TCS_Stream6,
	TCS_Stream7,
	TCS_WorldCoords,
	TCS_CameraCoords,
	TCS_WorldEnvMapCoords,
	TCS_CameraEnvMapCoords,
	TCS_ProjectorCoords,
	TCS_NoChange,				// don't specify a source, just modify it
	TCS_VertexShader_ModelCoords,
	TCS_VertexShader_WorldCoords,
} TexCoordSource;

var enum ETexCoordCount
{
	TCN_2DCoords,
	TCN_3DCoords,
	TCN_4DCoords
} TexCoordCount;

var bool TexCoordProjected;

defaultproperties
{
	TexCoordSource=TCS_NoChange
	TexCoordCount=TCN_2DCoords
	TexCoordProjected=False
}
class TexOscillator extends TexModifier
	editinlinenew
	native;



cpptext
{
	// UTexModifier interface
	virtual FMatrix* GetMatrix(FLOAT TimeSeconds);
	// UObject interface
	virtual void PostEditChange();
}

enum ETexOscillationType
{
	OT_Pan,
	OT_Stretch,
	OT_StretchRepeat,
	OT_Jitter
};

var() Float UOscillationRate;
var() Float VOscillationRate;
var() Float UOscillationPhase;
var() Float VOscillationPhase;
var() Float UOscillationAmplitude;
var() Float VOscillationAmplitude;
var() ETexOscillationType UOscillationType;
var() ETexOscillationType VOscillationType;
var() float UOffset;
var() float VOffset;

var Matrix M;

// current state for OT_Jitter.
var float LastSu;
var float LastSv;
var float CurrentUJitter;
var float CurrentVJitter;

defaultproperties
{
	UOscillationRate=1
	VOscillationRate=1
	UOscillationAmplitude=0.1
	VOscillationAmplitude=0.1
	UOscillationType=OT_Pan
	VOscillationType=OT_Pan
}
class TexOscillatorTriggered extends TexOscillator
	native;



cpptext
{
	// UTexModifier interface
	virtual FMatrix* GetMatrix(FLOAT TimeSeconds);
}

enum ERetriggerAction
{
	RTA_Reverse,
	RTA_Reset,
	RTA_Ignore,
	RTA_Retrigger,
};

var() ERetriggerAction RetriggerAction;
var() float StopAfterPeriod;
var transient float TriggeredTime;
var transient bool Reverse;
var transient bool Triggered;

function Trigger( Actor Other, Actor EventInstigator )
{
	if( Triggered )
	{
		switch( RetriggerAction )
		{
		case RTA_Reverse:
			Triggered = False;
			TriggeredTime = Other.Level.TimeSeconds;
			Reverse = True;
			break;
		case RTA_Reset:
			Triggered = False;
			TriggeredTime = -1.0;
			Reverse = True;
			break;
		}
	}
	else
	{
		if( RetriggerAction != RTA_Retrigger )
			Triggered = True;
		TriggeredTime = Other.Level.TimeSeconds;
		Reverse = False;
	}
}

function Reset()
{
	Triggered = False;
	TriggeredTime = -1.0;
	Reverse = False;
}

defaultproperties
{
	RetriggerAction=RTA_Retrigger
	StopAfterPeriod=0.5
	TriggeredTime=-1.0
	Reverse=False
	Triggered=False
	UOscillationPhase=0
	VOscillationPhase=0.25
	UOscillationRate=0
	VOscillationRate=0.5
	UOscillationAmplitude=0
	VOscillationAmplitude=0.5
}
class TexPanner extends TexModifier
	editinlinenew
	native;



cpptext
{
	// UTexModifier interface
	virtual FMatrix* GetMatrix(FLOAT TimeSeconds);
}

var() rotator PanDirection;
var() float PanRate;
var Matrix M;

defaultproperties
{
	PanRate=0.1
	PanDirection=(Yaw=0)
}
class TexPannerTriggered extends TexPanner
	native;



cpptext
{
	// UTexModifier interface
	virtual FMatrix* GetMatrix(FLOAT TimeSeconds);
}
var() TexOscillatorTriggered.ERetriggerAction RetriggerAction;
var() float StopAfterPeriod;
var transient float TriggeredTime;
var transient bool Reverse;
var transient bool Triggered;

function Trigger( Actor Other, Actor EventInstigator )
{
	if( Triggered )
	{
		switch( RetriggerAction )
		{
		case RTA_Reverse:
			Triggered = False;
			TriggeredTime = Other.Level.TimeSeconds;
			Reverse = True;
			break;
		case RTA_Reset:
			Triggered = False;
			TriggeredTime = -1.0;
			Reverse = True;
			break;
		}
	}
	else
	{
		if( RetriggerAction != RTA_Retrigger )
			Triggered = True;
		TriggeredTime = Other.Level.TimeSeconds;
		Reverse = False;
	}
}

function Reset()
{
	Triggered = False;
	TriggeredTime = -1.0;
	Reverse = False;
}

defaultproperties
{
	RetriggerAction=RTA_Retrigger
	StopAfterPeriod=0.5
	TriggeredTime=-1.0
	Reverse=False
	Triggered=False
}
class TexRotator extends TexModifier
	editinlinenew
	native;



cpptext
{
	// UTexModifier interface
	virtual FMatrix* GetMatrix(FLOAT TimeSeconds);
}

enum ETexRotationType
{
	TR_FixedRotation,
	TR_ConstantlyRotating,
	TR_OscillatingRotation,
};

var Matrix M;
var() ETexRotationType TexRotationType;
var() rotator Rotation;
var() float UOffset;
var() float VOffset;
var() rotator OscillationRate;
var() rotator OscillationAmplitude;
var() rotator OscillationPhase;

defaultproperties
{
	TexRotationType=TR_FixedRotation
}
class TexScaler extends TexModifier
	editinlinenew
	native;



cpptext
{
	// UTexModifier interface
	virtual FMatrix* GetMatrix(FLOAT TimeSeconds);
}

var Matrix M;
var() float UScale;
var() float VScale;
var() float UOffset;
var() float VOffset;

defaultproperties
{
	UScale=1.0
	VScale=1.0
}
//=============================================================================
// Texture: An Unreal texture map.
// This is a built-in Unreal class and it shouldn't be modified.
//=============================================================================
class Texture extends BitmapMaterial
	safereplace
	native
	noteditinlinenew
	dontcollapsecategories
	noexport;



// Palette.
var(Texture) palette Palette;

// Detail texture.
var(Texture) Material Detail;

// Texture flags.
var(Surface)			bool bMasked;
var(Surface)			bool bAlphaTexture;
var(Surface)			bool bTwoSided;
var private             bool bRealtimeChanged;    // Changed since last render.
var(Texture)            bool bDoNotPrecache;

// Mipmaps.
var private native const array<int> Mips;

var const transient int	RenderInterface;

defaultproperties
{
}
//=============================================================================
// TexturePool
// maintains a pool of in-use textures, freeing textures as needed to load new ones
//=============================================================================
class TexturePool extends object
	native;

cpptext
{
	void UnloadTexture(int index);
	INT FindOldestTexture();
	UBOOL CanLoadTexture(UTexture *tex);
	void PurgeTextures(UTexture *newTexture=NULL);
}

struct native TexturePoolItem_s
{
	var() Texture						MyTexture;
	var() bool							bLoaded;
	var() bool							bNeeded;
	var() int							UseCount;
};


var ObjectPool							RenderTextures;		// freelist of textures that are proxy textures for the pool

var private array<TexturePoolItem_s>	Textures;			// source data to be displayed through RenderTextures

var private int							MaxTextureCount;
var private int							MaxTextureSize;
var private int							CurrentTextureSize;		// size of textures currently loaded
var private int							PeakTextureSize;
var private int							CurrentTextureCount;	// number of textures currently loaded
var private int							PeakTextureCount;
var private int							CurrentUseCount;		// used to track textures that haven't been used in a while
var bool								bStrictTextureLimit;	// if set, will not load a texture that's too large even transiently

// =======================================================================================================================================================
// Initialization
// =======================================================================================================================================================
function Init(Object Outer, optional int maxSize, optional int maxCount)
{
	RenderTextures = new( Outer )class'ObjectPool';
	CurrentUseCount = 1;
	MaxTextureCount = maxCount;
	MaxTextureSize = maxSize;
}

function Flush()
{
	local int i;

	log("--------------------------------------------------------",'guilog');
	log("TexturePool::Flush",'guilog');
	log("Loaded Count : (cur=" $CurrentTextureCount $", peak=" $PeakTextureCount $") / max=" $MaxTextureCount, 'guilog');
	log("Loaded Size  : (cur=" $CurrentTextureSize $", peak=" $PeakTextureSize $") / max=" $MaxTextureSize, 'guilog');
	log("RenderTextureCount=" $RenderTextures.Objects.Length, 'guilog');
	log("Textures: Count=" $Textures.Length, 'guilog');

	for (i=0; i<Textures.Length; i++)
	{
		log(String(Textures[i].MyTexture), 'guilog');
		UnloadTexture(i);
	}

	log("--------------------------------------------------------",'guilog');

	Textures.Length = 0;
}

function Material AllocRenderMaterial()
{
	local Texture result;

	result = Texture( RenderTextures.AllocateObject(class'Texture', Outer) );
	result.bNoFlushMipMaps = true;

	return result;
}

function FreeRenderMaterial(out Material tex)
{
	SetCurrentTexture(Texture(tex), -1);
	RenderTextures.FreeObject(tex);
	tex = None;
}

// =======================================================================================================================================================
// The good stuff
// =======================================================================================================================================================
// while any texture will do
function bool GetTexture(Material dst, optional string texName)
{
	local Texture src;
	local int i;

	if (Texture(dst) == None)
	{
		log("WARNING: TexturePool::GetTexture - dst must be a texture object.");
		return false;
	}

	if (texName == "")
	{
		SetCurrentTexture(Texture(dst), -1);
		return true;
	}

	src = Texture(DynamicLoadObject(texName, class'Texture'));

	if (src == None)
		return false;

	i = FindTexture(src);
	if (i == -1)
		i = AddTexture(src);

	if (i == -1)
		return false;

	SetCurrentTexture(Texture(dst), i);

	return true;
}

function MarkAsUnneeded(string texName)
{
	local Texture tex;
	local int i;

	tex = Texture(FindObject(texName, class'Texture'));
	log("Marking texture " $texName $" (" $tex $") as unneeded.", 'guilog');
	if (tex == None)
		return;

	i = FindTexture(tex);
	if (i != -1)
		Textures[i].bNeeded = false;
}

private function SetCurrentTexture(Texture dst, int index)
{
	local bool bMustUnload;

	if (index != -1)
	{
		// load the texture.  If it fails but the texture was loaded, it must be unloaded
		bMustUnload = !LoadTexture(index);
		if (Textures[index].bLoaded)
		{
			MirrorTexture(dst, Textures[index].MyTexture);

			Textures[index].bNeeded = true;
			Textures[index].UseCount = CurrentUseCount;
			CurrentUseCount++;

			if (bMustUnload)
			{
				UnloadTexture(index);		
			}
		}
	}
	else
	{
		MirrorTexture(dst, None);
	}
}

// MirrorTexture
// Copies important parts of the texture and its data from src to dst
private native function MirrorTexture(Texture dst, Texture src);

// LoadTexture
// Loads the texture data for the given index
// Will attempt to free the oldest of current in-use textures if this is a limited size pool
// If the texture is greater than the size of the whole pool, result will be false
// Texture will still load if bStrictTextureLimit is false but it should be unloaded immediately
// Result will also be false if  the load failed.
private native function bool LoadTexture(int index);

// UnloadTexture
// Unloads the texture data for the given index
private native function UnloadTexture(int index);

// =======================================================================================================================================================
// list management
// =======================================================================================================================================================
private function int AddTexture(Texture tex)
{
	local int i;

	i = Textures.Length;
	Textures.Length = i+1;
	Textures[i].MyTexture = tex;
	Textures[i].bLoaded = false;
	Textures[i].bNeeded = true;
	Textures[i].UseCount = 0;

	return i;
}

private function int FindTexture(Texture tex)
{
	local int i;

	if (tex == None)
		return -1;

	for (i=0; i<Textures.Length; i++)
	{
		if (Textures[i].MyTexture == tex)
			return i;
	}

	return -1;
}

defaultproperties
{
	MaxTextureCount=0
	MaxTextureSize=0

}
//=============================================================================
// Emitter: An Unreal Trail Particle Emitter.
//=============================================================================
class TrailEmitter extends ParticleEmitter
	abstract
	native;



struct ParticleTrailData
{
	var vector	Location;
	var color	Color;
	var float	Size;
	var int		DoubleDummy1;
	var int		DoubleDummy2;
};

struct ParticleTrailInfo
{
	var int		TrailIndex;
	var int		NumPoints;
	var vector	LastLocation;
};

var (Trail)			int							MaxPointsPerTrail;
var (Trail)			float						DistanceThreshold;
var (Trail)			bool						UseCrossedSheets;
var (Trail)			int							MaxTrailTwistAngle;

var transient		array<ParticleTrailData>	TrailData;
var transient		array<ParticleTrailInfo>	TrailInfo;
var transient		vertexbuffer				VertexBuffer;
var transient		indexbuffer					IndexBuffer;
var transient		int							VerticesPerParticle;
var transient		int							IndicesPerParticle;
var transient		int							PrimitivesPerParticle;


defaultproperties
{
	MaxPointsPerTrail=50
	DistanceThreshold=1
	MaxTrailTwistAngle=16384
}
//=============================================================================
// Trigger: senses things happening in its proximity and generates
// sends Trigger/UnTrigger to actors whose names match 'EventName'.
//=============================================================================
class Trigger extends Triggers
	native;



//-----------------------------------------------------------------------------
// Trigger variables.

// Trigger type.
var() enum ETriggerType
{
	TT_PlayerProximity,	// Trigger is activated by player proximity.
	TT_PawnProximity,	// Trigger is activated by any Pawn's proximity
	TT_ClassProximity,	// Trigger is activated by actor of ClassProximityType only
	TT_AnyProximity,    // Trigger is activated by any actor in proximity.
	TT_Shoot,		    // Trigger is activated by player shooting it.
	TT_HumanPlayerProximity,	// Trigger activated by human player (not bot)
} TriggerType;

// Human readable triggering message.
var() localized string Message;

// Only trigger once and then go dormant.
var() bool bTriggerOnceOnly;

// For triggers that are activated/deactivated by other triggers.
var() bool bInitiallyActive;

var() class<actor> ClassProximityType;

var() float	RepeatTriggerTime; //if > 0, repeat trigger message at this interval is still touching other
var() float ReTriggerDelay; //minimum time before trigger can be triggered again
var	  float TriggerTime;
var() float DamageThreshold; //minimum damage to trigger if TT_Shoot

var() name MatchTag;			// Triggerable only by actors whose tag matches this.

// AI vars
var	actor TriggerActor;	// actor that triggers this trigger
var actor TriggerActor2;

// store for reset

var bool bSavedInitialCollision;
var bool bSavedInitialActive;

//=============================================================================
// AI related functions

function PreBeginPlay()
{
	Super.PreBeginPlay();

	if ( (TriggerType == TT_PlayerProximity)
		|| (TriggerType == TT_PawnProximity)
		|| (TriggerType == TT_HumanPlayerProximity)
		|| ((TriggerType == TT_ClassProximity) && ClassIsChildOf(ClassProximityType,class'Pawn')) )
		OnlyAffectPawns(true);
}

function PostBeginPlay()
{
	if ( !bInitiallyActive )
		FindTriggerActor();
	if ( TriggerType == TT_Shoot )
	{
		bHidden = false;
		bProjTarget = true;
		SetDrawType(DT_None);
	}
	bSavedInitialActive = bInitiallyActive;
	bSavedInitialCollision = bCollideActors;
	Super.PostBeginPlay();
}

/* Reset()
reset actor to initial state - used when restarting level without reloading.
*/
function Reset()
{
	Super.Reset();

	// collision, bInitiallyactive
	bInitiallyActive = bSavedInitialActive;
	SetCollision(bSavedInitialCollision, bBlockActors, bBlockPlayers );
}


function FindTriggerActor()
{
	local Actor A;

	TriggerActor = None;
	TriggerActor2 = None;
	ForEach AllActors(class 'Actor', A)
		if ( A.Event == Tag)
		{
			if (TriggerActor == None)
				TriggerActor = A;
			else
			{
				TriggerActor2 = A;
				return;
			}
		}
}

function Actor SpecialHandling(Pawn Other)
{
	local Actor A;

	if ( bTriggerOnceOnly && !bCollideActors )
		return None;

	if ( (TriggerType == TT_HumanPlayerProximity) && !Other.IsHumanControlled() )
		return None;

	if ( (TriggerType == TT_PlayerProximity) && !Other.IsPlayerPawn() )
		return None;

	if ( !bInitiallyActive )
	{
		if ( TriggerActor == None )
			FindTriggerActor();
		if ( TriggerActor == None )
			return None;
		if ( (TriggerActor2 != None)
			&& (VSize(TriggerActor2.Location - Other.Location) < VSize(TriggerActor.Location - Other.Location)) )
			return TriggerActor2;
		else
			return TriggerActor;
	}

	// is this a shootable trigger?
	if ( TriggerType == TT_Shoot )
		return Other.ShootSpecial(self);

	// can other trigger it right away?
	if ( IsRelevant(Other) )
	{
		ForEach TouchingActors(class'Actor', A)
			if ( A == Other )
				Touch(Other);
		return self;
	}

	return self;
}

// when trigger gets turned on, check its touch list

function CheckTouchList()
{
	local Actor A;

	ForEach TouchingActors(class'Actor', A)
		Touch(A);
}

//=============================================================================
// Trigger states.

// Trigger is always active.
state() NormalTrigger
{
}

// Other trigger toggles this trigger's activity.
state() OtherTriggerToggles
{
	function Trigger( actor Other, Pawn EventInstigator )
	{
		bInitiallyActive = !bInitiallyActive;
		if ( bInitiallyActive )
			CheckTouchList();
	}
}

// Other trigger turns this on.
state() OtherTriggerTurnsOn
{
	function Trigger( actor Other, Pawn EventInstigator )
	{
		local bool bWasActive;

		bWasActive = bInitiallyActive;
		bInitiallyActive = true;
		if ( !bWasActive )
			CheckTouchList();
	}
}

// Other trigger turns this off.
state() OtherTriggerTurnsOff
{
	function Trigger( actor Other, Pawn EventInstigator )
	{
		bInitiallyActive = false;
	}
}

//=============================================================================
// Trigger logic.

//
// See whether the other actor is relevant to this trigger.
//
function bool IsRelevant( actor Other )
{
	if( !bInitiallyActive )
		return false;

	if( MatchTag != '' && Other.Tag != MatchTag )
	{
		return false;
	}

	switch( TriggerType )
	{
		case TT_HumanPlayerProximity:
			return (Pawn(Other) != None) && Pawn(Other).IsHumanControlled();
		case TT_PlayerProximity:
			return (Pawn(Other) != None) && (Pawn(Other).IsPlayerPawn() || Pawn(Other).WasPlayerPawn());
		case TT_PawnProximity:
			return (Pawn(Other) != None) && Pawn(Other).CanTrigger(self);
		case TT_ClassProximity:
			return ClassIsChildOf(Other.Class, ClassProximityType);
		case TT_AnyProximity:
			return true;
		case TT_Shoot:
			return ( (Projectile(Other) != None) && (Projectile(Other).Damage >= DamageThreshold) );
		default:
			return false;
	}
}
//
// Called when something touches the trigger.
//
function Touch( actor Other )
{
	local int i;

	log(self$".Touch( "$Other$" ) - "$Tag);
	if( IsRelevant( Other ) )
	{
		if ( ReTriggerDelay > 0 )
		{
			if ( Level.TimeSeconds - TriggerTime < ReTriggerDelay )
				return;
			TriggerTime = Level.TimeSeconds;
		}
		// Broadcast the Trigger message to all matching actors.
		TriggerEvent(Event, self, Other.Instigator);

		if ( (Pawn(Other) != None) && (Pawn(Other).Controller != None) )
		{
			for ( i=0;i<4;i++ )
				if ( Pawn(Other).Controller.GoalList[i] == self )
				{
					Pawn(Other).Controller.GoalList[i] = None;
					break;
				}
		}

		if( (Message != "") && (Other.Instigator != None) )
			// Send a string message to the toucher.
			Other.Instigator.ClientMessage( Message );

		if( bTriggerOnceOnly )
			// Ignore future touches.
			SetCollision(False);
		else if ( RepeatTriggerTime > 0 )
			SetTimer(RepeatTriggerTime, false);
	}
}

function Timer()
{
	local bool bKeepTiming;
	local Actor A;

	bKeepTiming = false;

	ForEach TouchingActors(class'Actor', A)
		if ( IsRelevant(A) )
		{
			bKeepTiming = true;
			Touch(A);
		}

	if ( bKeepTiming )
		SetTimer(RepeatTriggerTime, false);
}

function TakeDamage( int Damage, Pawn instigatedBy, Vector hitlocation,
						Vector momentum, class<DamageType> damageType, optional name HitBoxName)
{
	if ( bInitiallyActive && (TriggerType == TT_Shoot) && (Damage >= DamageThreshold) && (instigatedBy != None) )
	{
		if ( ReTriggerDelay > 0 )
		{
			if ( Level.TimeSeconds - TriggerTime < ReTriggerDelay )
				return;
			TriggerTime = Level.TimeSeconds;
		}
		// Broadcast the Trigger message to all matching actors.
		TriggerEvent(Event, self, instigatedBy);

		if( Message != "" )
			// Send a string message to the toucher.
			instigatedBy.Instigator.ClientMessage( Message );

		if( bTriggerOnceOnly )
			// Ignore future touches.
			SetCollision(False);
	}
}

//
// When something untouches the trigger.
//
function UnTouch( actor Other )
{
	if( IsRelevant( Other ) )
		UntriggerEvent(event, self, Other.Instigator);
}

defaultproperties
{
	 Texture=Texture'Engine.S_Trigger'
     bInitiallyActive=True
     InitialState=NormalTrigger
	 bBlockZeroExtentTraces=false
}
//=============================================================================
// TriggeredVolume:  a bounding volume
// touch() and untouch() notifications to the volume as actors enter or leave it
// enteredvolume() and leftvolume() notifications when center of actor enters the volume
// pawns with bIsPlayer==true  cause playerenteredvolume notifications instead of actorenteredvolume()
// This is a built-in Unreal class and it shouldn't be modified.
//=============================================================================
class TriggeredVolume extends Volume;

defaultproperties
{
	bStatic=False
}
//=============================================================================
// TriggeredVolumeToggle.
//=============================================================================
class TriggeredVolumeToggle extends TriggeredVolume
    placeable;

event Trigger( Actor Other, Pawn EventInstigator )
{
    Super.Trigger( Other, EventInstigator );

    // Log( "*** Toggle ***", 'TriggeredScript' );

    // Toggle between blocking and not blocking.
    SetCollision( !bCollideActors, bBlockActors, bBlockPlayers );
}

//=============================================================================
// Event.
//=============================================================================
class Triggers extends Actor
	abstract
	placeable
	native;

// If set, then this will search all actors for a match, not just dynamic actors
var() bool bSearchAllActors;

event Destroyed()
{
	local	Volume	aVolume;
	
	Super.Destroyed();
	ForEach AllActors(class'Volume', aVolume)
	{
		if (aVolume.AssociatedActor == self)
		{
			aVolume.AssociatedActor = None;
		}
	}
//	SetCollision( false, false, false );
}

/*
Trigger an event
*/
event TriggerEvent( Name EventName, Actor Other, Pawn EventInstigator )
{
	local Actor A;

	if ( EventName == '' )
		return;

	if (bSearchAllActors)
	{
		ForEach AllActors( class 'Actor', A, EventName )
		{
			A.Trigger(Other, EventInstigator);
		}
	}
	else
	{
		ForEach DynamicActors( class 'Actor', A, EventName )
		{
			A.Trigger(Other, EventInstigator);
		}
	}
}


defaultproperties
{
     bHidden=True
     CollisionRadius=+00040.000000
     CollisionHeight=+00040.000000
     bCollideActors=True
     bSearchAllActors=False
}
// GEARBOX 2004-10-13 JWS created
class UnitReplicationInfo extends ReplicationInfo
	native;

var TeamInfo	Team;
var EUnitType	Type;
var int			TeamID;
var float		Score;

replication
{
	// Things the server should send to the client.
	reliable if ( bNetDirty && (Role == Role_Authority) )
		Team, Type, TeamID, Score;
}

simulated function bool BelongsToPlayer(PlayerReplicationInfo PRI)
{
	local bool result;
	local TeamInfo TI;

	result = false;

	TI = PRI.Team;
	if (TI != None)
	{
		if (TI.TeamIndex == Team.TeamIndex &&
			PRI.TeamID   == TeamID)
		{
			result = true;
		}
	}

	return result;
}

simulated function PostNetBeginPlay()
{
	local GameReplicationInfo GRI;

	ForEach DynamicActors(class'GameReplicationInfo',GRI)
	{
		GRI.AddURI(self);
		break;
	}

	Super.PostNetBeginPlay();
}

simulated function Destroyed()
{
	local GameReplicationInfo GRI;

	ForEach DynamicActors(class'GameReplicationInfo',GRI)
	{
		GRI.RemoveURI(self);
	}

    Super.Destroyed();
}


defaultproperties
{
	Score = 0.0f

	RemoteRole=ROLE_SimulatedProxy
	bAlwaysRelevant=True
}
//=============================================================================
// UseTrigger: if a player stands within proximity of this trigger, and hits Use,
// it will send Trigger/UnTrigger to actors whose names match 'EventName'.
//=============================================================================
class UseTrigger extends Triggers;



var() localized string Message;

event bool UsedBy( Pawn user )
{
	TriggerEvent(Event, self, user);
	return true;
}

function Touch( Actor Other )
{
	if( (Message != "") && (Other.Instigator != None) )
		// Send a string message to the toucher.
		Other.Instigator.ClientMessage( Message );
}

defaultproperties
{
	Texture=Texture'Engine.S_TriggerUse'
}
class UtilityPole extends StaticMeshActor
	native
	placeable;

enum WireLinkup
{
    WL_Undefined,
    WL_Wire1,
    WL_Wire2,
    WL_Wire3,
    WL_Wire4,
};

var(Wire) edfindable UtilityPole NextPole;             // Next pole in the list
var(Wire) vector      WireOffset[4];        // Location relative to self->Location for wire attachment
var(Wire) byte        NumSegments[4];
var(Wire) float       Slack[4];
var(Wire) float       Width[4];
var(Wire) WireLinkup  Linkup[4];            // what index it connects to on NextPole (if its active)
var(Wire) byte        Active[4];            // should be bool but complicates c++ code badly

defaultproperties
{
    Linkup[0]=WL_Wire1
    Linkup[1]=WL_Wire2
    Linkup[2]=WL_Wire3
    Linkup[3]=WL_Wire4
    
    Width[0]=4.0
    Width[1]=4.0
    Width[2]=4.0
    Width[3]=4.0
}
class VariableTexPanner extends TexModifier
	editinlinenew
	native;

cpptext
{
	// UTexModifier interface
	virtual FMatrix* GetMatrix(FLOAT TimeSeconds);
}

var() rotator PanDirection;
var() float PanRate;
var Matrix M;

var float LastTime;
var float PanOffset;

defaultproperties
{
	PanRate=0.1
	PanDirection=(Yaw=0)
}
//=============================================================================
// Vehicle
// this abstract base class contains gameplay and AI code for vehicles
//=============================================================================

class Vehicle extends Pawn
    native
    nativereplication
    abstract;

var globalconfig bool bVehicleShadows;	// Global config option for vehicle shadows

var             bool    bDriving;               // Vehicle is being driven
var             bool    bOldDriving;
var				bool	bDrawVehicleShadow;		// Vehicle Shadow
var (Vehicle)	bool	bDrawDriverInTP;		// Whether to draw the driver when in 3rd person mode.
var (Vehicle)	bool	bDriverCollideActors;	// if driver is drawn in vehicle, is Driver.bCollideActors true ?
var (Vehicle)	bool	bRelativeExitPos;		// relative vector to vehicle?

var		bool	bDefensive;				// should be used by defenders
var		bool	bAutoTurret;			// controlled by AI if no player controlling (FIXME Move to subclass)
var		bool	bRemoteControlled;		// destroying vehicle won't kill player
var		bool	bEjectDriver;			// If vehicle is destroyed, don't kill and eject driver(s)
var		bool	bTurnInPlace;			// whether vehicle can turn in place
var		bool	bFollowLookDir;			// used by AI to know that controller's rotation determines vehicle rotation
var		bool	bNonHumanControl;		// Cannot be controlled by humans
var		bool	bStalled;				// Vehicle is stalled (can't apply acceleration)
var     bool    bVehicleDestroyed;      // Vehicle has been destroyed (no more need to simulate special vehicle physics)
var     bool    bShowDamageOverlay;     // Vehicle should display the normal pawn damage overlay when hit by a weapon
var     bool    bDropDetail;            // Vehicle should reduce its detail level
var		bool	bNoFriendlyFire;		// FriendlyFire disabled for this vehicle

// Cameras
var (Vehicle) bool	bDrawMeshInFP;		// Whether to draw the vehicle mesh when in 1st person mode.
var (Vehicle) bool	bZeroPCRotOnEntry;	// If true, set camera rotation to zero on entering vehicle. If false, set it to the vehicle rotation.
var	bool	bPCRelativeFPRotation;		// In 1st person, PlayerController rotation is relative to vehicle rotation

var     bool    bWeaponisFiring;
var     bool    bWeaponisAltFiring;

var		bool	bTeamLocked;		// Team defines which players are allowed to enter the vehicle
var		bool	bEnterringUnlocks;	// Vehicle is unlocked when a player enterred it..
var	bool bCanFlip;
var	bool bAllowViewChange;
var	bool bAllowWeaponToss; //if the driver dies, will he toss his weapon?

var(Vehicle) bool	bHUDTrackVehicle;	// If true, Vehicle will tracked on HUD. (For Objectives in Assault)
var	bool bHasRadar;
var bool bHasHandbrake;					// hint for AI
var bool bScriptedRise;					// hint for AI
var bool bKeyVehicle;					// hint for AI
var bool bSeparateTurretFocus;			// hint for AI (for tank type turreted vehicles)

var() bool	bHighScoreKill;	// vehicle is considered important, and awards 5 points upon destruction.

var	bool	bAdjustDriversHead;	// rotate driver's head depending on view rotation
var bool	bEnemyLockedOn;
var config bool bDesiredBehindView;

var	bool bHideRemoteDriver; // If Set to true, the remote controlling driver will be hidden
var bool bShowChargingBar;
var bool bDriverHoldsFlag;
var bool bCanCarryFlag;

var bool bSpawnProtected;	// Cannot be destroyed by a player before its been possessed.

var() bool bFPNoZFromCameraPitch; // Ignore any vehicle-space Z due to FPCamViewOffset (so looking up and down doesn't change camera Z rel to vehicle)

var		byte	StuckCount;				// used by AI
var()	byte	Team;
var     byte    OldTeam, PrevTeam;  // OldTeam is used for replication purposes, PrevTeam is the team of the previous driver.

var				Rotator	PlayerEnterredRotation;	// Original rotation when player enterred vehicle
var		float	EjectMomentum;

var class<Controller> AutoTurretControllerClass;

// generic controls (set by controller, used by concrete derived classes)
var (Vehicle) float		Steering;		// between -1 and 1
var (Vehicle) float		Throttle;		// between -1 and 1
var (Vehicle) float		Rise;			// between -1 and 1
var           int       DriverViewPitch;      // The driver's view pitch
var           int       DriverViewYaw;        // The driver's view yaw

var float		ThrottleTime;	// last time at which throttle was 0 (used by AI)
var float		StuckTime;
var float		VehicleMovingTime; // used by AI C++

var (Vehicle) vector	DrivePos;		// Position (rel to vehicle) to put player while driving.
var (Vehicle) rotator	DriveRot;		// Rotation (rel to vehicle) to put driver while driving.
var (Vehicle) name		DriveAnim;		// Animation to play while driving.

//Info for EntryPositions
var (Vehicle) array<vector>	ExitPositions;		// Positions (rel to vehicle) to try putting the player when exiting.
var (Vehicle) vector	                EntryPosition;		// Offset for the entry trigger
var (Vehicle) float                     EntryRadius;        // Radius for the entry trigger

var (Vehicle) vector   FPCamPos;		// Position of camera when driving first person.
var (Vehicle) vector   FPCamViewOffset; // Offset in reference frame of camera.

//clientside settings
var config float TPCamDistance;
// force feedback
var string CenterSpringForce;
var int CenterSpringRangePitch;
var int CenterSpringRangeRoll;

var (Vehicle) vector   TPCamLookat; // Look at location in vehicle space
var (Vehicle) vector   TPCamWorldOffset; // Applied in world space after vehicle transform.
var float DesiredTPCamDistance, LastCameraCalcTime, CameraSpeed; //for smoothly interpolating TPCamDistance to new value
var (Vehicle) Range    TPCamDistRange;

var (Vehicle) int	MaxViewYaw;			// Maximum amount you can look left and right
var (Vehicle) int	MaxViewPitch;		// Maximum amount you can look up and down

var		Pawn			Driver;		// Can be None if Controller spawns right away with vehicle
var		SVehicleFactory	ParentFactory;

// FX
var String			TransEffects[2];		// Spawning effects
var	ShadowProjector	VehicleShadow;			// Shadow projector
var	float			ShadowMaxTraceDist;
var float			ShadowCullDistance;

var float MomentumMult;	//damage momentum multiplied by this value before being applied to vehicle
var float DriverDamageMult; //damage to the driver is multiplied by this value

// Missle warning
var String	LockOnClassString;
var float	LastLockWarningTime;

var Vehicle NextVehicle;
var localized string VehiclePositionString;
var localized string VehicleNameString;
var localized string VehicleDescription;

var Texture TeamBeaconTexture, NoEntryTexture;
var Material TeamBeaconBorderMaterial;

var AIMarker MyMarker;  // used for stationary turrets

//VEHICULAR MANSLAUGHTER
var float MinRunOverSpeed; //speed must be greater than this for running into someone to do damage
var class<DamageType> RanOverDamageType, CrushedDamageType;
var sound RanOverSound;
var name StolenAnnouncement;
var sound StolenSound;

var	float LinkHealMult;	// If > 0, Link Gun secondary heals an amount equal to its damage times this

var float OldSteering;
var float VehicleLostTime, TeamUseTime, PlayerStartTime;
var float MaxDesireability;
var const float AIMoveCheckTime;
var float ObjectiveGetOutDist; //if AI controlled and bot needs to trigger an objective not triggerable by vehicles, it will try to get out this far away

var name FlagBone;
var vector FlagOffset;
var rotator FlagRotation;

var	float	WheelsScale;

// HORN
var array<sound>	HornSounds;
var float			LastHornTime;

// BULLET HITS
var() array<sound>    BulletSounds;

// HUD OVERLAY
var class<Actor>            HUDOverlayClass;
var Actor                   HUDOverlay;
var() vector                HUDOverlayOffset;
var() float                 HUDOverlayFOV;

// SPAWN OVERLAY MATERIAL
var()   Material            SpawnOverlay[2];


struct native SVehicleIcon
{
	var Material	Material;
	var float		X, Y, SizeX, SizeY;
	var bool		bIsGreyScale;
};

var SVehicleIcon VehicleIcon;

cpptext
{
	virtual void PreNetReceive();
	virtual void PostNetReceive();
	void performPhysics(FLOAT DeltaSeconds);
	virtual UBOOL moveToward(const FVector &Dest, UActorLite *GoalActor);
	virtual void rotateToward(AActor *Focus, FVector FocalPoint);
	virtual UBOOL IsStuck();
	INT* GetOptimizedRepList(BYTE* Recent, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel);
	INT AddMyMarker(AActor *S);
	void SteerVehicle(FVector Direction);
	UBOOL IsNetRelevantFor( APlayerController* RealViewer, AActor* Viewer, FVector SrcLocation );
	virtual FVector GetDestination(AController *C);
	virtual void setMoveTimer(FVector MoveDir);
	virtual int calcMoveFlags();
}

replication
{
	reliable if ( Role==ROLE_Authority )
		ClientKDriverEnter, ClientKDriverLeave, FixPCRotation, ClientClearController;

	unreliable if( bNetDirty && Role==ROLE_Authority )
        bDriving, bTeamLocked, Driver, Team, bVehicleDestroyed, WheelsScale;

	unreliable if( bNetInitial && Role==ROLE_Authority )
		bHUDTrackVehicle;

	reliable if ( Role < ROLE_Authority )
		VehicleFire, VehicleCeaseFire;
}

function PreBeginPlay()
{
/*jlb
	if ( !Level.Game.bAllowVehicles && !bDeleteMe )
	{
		Destroy();
		return;
	}
jlb*/

	Super.PreBeginPlay();
}

/*jlb
function PlayerChangedTeam()
{
	if ( Driver != None )
		Driver.KilledBy(Driver);
	else
		Super.PlayerChangedTeam();
}
jlb*/

simulated function SetBaseEyeheight()
{
	BaseEyeheight = Default.BaseEyeheight;
	Eyeheight = BaseEyeheight;
}

simulated function string GetVehiclePositionString()
{
	return VehiclePositionString;
}

function Suicide()
{
	if ( Driver != None )
		Driver.KilledBy(Driver);
	else
		KilledBy(self);
}

function bool CheatWalk()
{
	return false;
}

function bool CheatGhost()
{
	return false;
}

function bool CheatFly()
{
	return false;
}

simulated function PostBeginPlay()
{
	local controller NewController;

	super.PostBeginPlay();

	if ( bDeleteMe )
		return;

	// Glue a shadow projector on
	if ( bVehicleShadows && bDrawVehicleShadow && (Level.NetMode != NM_DedicatedServer) )
    {
        VehicleShadow = Spawn(class'ShadowProjector', self, '', Location);
        VehicleShadow.ShadowActor		= Self;
        VehicleShadow.bBlobShadow		= false;
        VehicleShadow.LightDirection	= Normal(vect(1,1,6));
        VehicleShadow.LightDistance		= 1200;
        VehicleShadow.MaxTraceDistance	= ShadowMaxTraceDist;
		VehicleShadow.CullDistance		= ShadowCullDistance;
//jlb        VehicleShadow.InitShadow();
    }

	if ( Role == Role_Authority )
	{
		if ( bAutoTurret && (Controller == None) && (AutoTurretControllerClass != None) )
		{
			NewController = spawn(AutoTurretControllerClass);
			if ( NewController != None )
				NewController.Possess(self);
		}
		if ( !bAutoTurret && !bNonHumanControl && IndependentVehicle() )
			Level.Game.RegisterVehicle(self);
	}

    OldTeam = Team;
    PrevTeam = Team;
}

simulated event SetInitialState()
{
    Super.SetInitialState();

    Disable('Tick');
}

function bool StronglyRecommended(Actor S, int TeamIndex, Actor Objective)
{
	return bKeyVehicle;
}

/*jlb
//return a value indicating how useful this vehicle is to bots
function float BotDesireability(Actor S, int TeamIndex, Actor Objective)
{
	local bool bSameTeam;
	local PlayerController P;

	bSameTeam = ( GetTeamNum() == TeamIndex );
	if ( bSameTeam )
	{
		if ( Level.TimeSeconds < TeamUseTime )
			return 0;
		if ( !bKeyVehicle && (Level.TimeSeconds < PlayerStartTime) )
		{
			P = Level.GetLocalPlayerController();
			if ( (P == None) || ((P.Pawn != None) && (Vehicle(P.Pawn) == None)) )
				return 0;
		}
	}
	if ( !bKeyVehicle && !bStationary && (Level.TimeSeconds < VehicleLostTime) )
		return 0;
	else if (Health <= 0 || Occupied() || (bTeamLocked && !bSameTeam))
		return 0;

	if (bKeyVehicle)
		return 100;

	return ((MaxDesireability * 0.5) + (MaxDesireability * 0.5 * (float(Health) / HealthMax)));
}
jlb*/

simulated function Destroyed()
{
//jlb	local Vehicle	V, Prev;

	if ( ParentFactory != None )
		ParentFactory.VehicleDestroyed( Self );		// Notify parent factory of death

    if ( VehicleShadow != None )
		VehicleShadow.Destroy();					// Destroy shadow projector

	if ( bAutoTurret && (Controller != None) && ClassIsChildOf(Controller.Class, AutoTurretControllerClass) && !Controller.bDeleteMe )
	{
		Controller.Destroy();
		Controller = None;
	}

	if ( Driver != None )
		Destroyed_HandleDriver();

/*jlb
	if ( Level.Game != None )
	{
		if ( Level.Game.VehicleList == Self )
			Level.Game.VehicleList = NextVehicle;
		else
		{
			Prev = Level.Game.VehicleList;
			if ( Prev != None )
				for ( V=Level.Game.VehicleList.NextVehicle; V!=None; V=V.NextVehicle )
				{
					if ( V == self )
					{
						Prev.NextVehicle = NextVehicle;
						break;
					}
					else
						Prev = V;
				}
		}
	}
jlb*/

	super.Destroyed();
}

simulated function Destroyed_HandleDriver()
{
	local Pawn		OldDriver;

	Driver.LastRenderTime = LastRenderTime;
	if ( Role == ROLE_Authority )
	{
		// if Driver wasn't visible in vehicle, destroy it
		if ( Driver != None && !bRemoteControlled && !bEjectDriver && !bDrawDriverInTP && Driver.Health > 0 )
		{
			OldDriver = Driver;
			Driver = None;
			OldDriver.DrivenVehicle = None;
			if ( !OldDriver.bDeleteMe )
				OldDriver.Destroy();
		}
		else if ( !bRemoteControlled && !bEjectDriver )
        {
			// otherwise spawn dead karma body
	        if (!bDrawDriverInTP && PlaceExitingDriver())
	        {
	            Driver.StopDriving(self);
	            Driver.DrivenVehicle = self;
	        }
			Driver.TearOffMomentum = Velocity * 0.25;
//			Driver.Died(Controller, class'DamRanOver', Driver.Location);
			Driver.Died(Controller, class'Crushed', Driver.Location);
        }
	}
	else if ( Driver.DrivenVehicle == self )
		Driver.StopDriving(self);
}

simulated function vector GetCameraLocationStart()
{
	return Location;
}

simulated function SpecialCalcBehindView(PlayerController PC, out actor ViewActor, out vector CameraLocation, out rotator CameraRotation )
{
	local vector CamLookAt, HitLocation, HitNormal, OffsetVector;
	local Actor HitActor;
    local vector x, y, z;

	if (DesiredTPCamDistance < TPCamDistance)
		TPCamDistance = FMax(DesiredTPCamDistance, TPCamDistance - CameraSpeed * (Level.TimeSeconds - LastCameraCalcTime));
	else if (DesiredTPCamDistance > TPCamDistance)
		TPCamDistance = FMin(DesiredTPCamDistance, TPCamDistance + CameraSpeed * (Level.TimeSeconds - LastCameraCalcTime));

    GetAxes(PC.Rotation, x, y, z);
	ViewActor = self;
	CamLookAt = GetCameraLocationStart() + (TPCamLookat >> Rotation) + TPCamWorldOffset;

	OffsetVector = vect(0, 0, 0);
	OffsetVector.X = -1.0 * TPCamDistance;

	CameraLocation = CamLookAt + (OffsetVector >> PC.Rotation);

	HitActor = Trace(HitLocation, HitNormal, CameraLocation, CamLookAt, true, vect(40, 40, 40));
	if ( HitActor != None
	     && (HitActor.bWorldGeometry || HitActor == GetVehicleBase() || Trace(HitLocation, HitNormal, CameraLocation, CamLookAt, false, vect(40, 40, 40)) != None) )
			CameraLocation = HitLocation;

//jlb    CameraRotation = Normalize(PC.Rotation + PC.ShakeRot);
    CameraRotation = Normalize(PC.Rotation);
//jlb    CameraLocation = CameraLocation + PC.ShakeOffset.X * x + PC.ShakeOffset.Y * y + PC.ShakeOffset.Z * z;
    CameraLocation = CameraLocation;
}

simulated function SpecialCalcFirstPersonView(PlayerController PC, out actor ViewActor, out vector CameraLocation, out rotator CameraRotation )
{
	local quat CarQuat, LookQuat, ResultQuat;
	local vector VehicleZ, CamViewOffsetWorld, x, y, z;
	local float CamViewOffsetZAmount;

	GetAxes(PC.Rotation, x, y, z);
	ViewActor = self;

	if (bPCRelativeFPRotation)
	{
		CarQuat = QuatFromRotator(Rotation);
		CameraRotation = Normalize(PC.Rotation);
		LookQuat = QuatFromRotator(CameraRotation);
		ResultQuat = QuatProduct(LookQuat, CarQuat);
		CameraRotation = QuatToRotator(ResultQuat);
	}
	else
		CameraRotation = PC.Rotation;

	// Camera position is locked to car
	CamViewOffsetWorld = FPCamViewOffset >> CameraRotation;
	CameraLocation = GetCameraLocationStart() + (FPCamPos >> Rotation) + CamViewOffsetWorld;

	if(bFPNoZFromCameraPitch)
	{
		VehicleZ = vect(0,0,1) >> Rotation;
		CamViewOffsetZAmount = CamViewOffsetWorld Dot VehicleZ;
		CameraLocation -= CamViewOffsetZAmount * VehicleZ;
	}

//jlb	CameraRotation = Normalize(CameraRotation + PC.ShakeRot);
	CameraRotation = Normalize(CameraRotation);
//jlb	CameraLocation = CameraLocation + PC.ShakeOffset.X * x + PC.ShakeOffset.Y * y + PC.ShakeOffset.Z * z;
	CameraLocation = CameraLocation;
}

// Special calc-view for vehicles
simulated function bool SpecialCalcView(out actor ViewActor, out vector CameraLocation, out rotator CameraRotation )
{
	local PlayerController pc;

	pc = PlayerController(Controller);

	// Only do this mode we have a playercontroller
	if( (pc == None) || (pc.Viewtarget != self) )
		return false;

	if( pc.bBehindView )
		SpecialCalcBehindView(PC,ViewActor,CameraLocation,CameraRotation);
	else
		SpecialCalcFirstPersonView(PC,ViewActor,CameraLocation,CameraRotation);

	LastCameraCalcTime = Level.TimeSeconds;

	return true;
}

simulated function bool SpectatorSpecialCalcView(PlayerController Viewer, out Actor ViewActor, out vector CameraLocation, out rotator CameraRotation)
{
	local rotator DummyRotation;

	if (Viewer.ViewTarget != self)
		return false;

	if (Viewer.bBehindView)
	{
		DesiredTPCamDistance = (TPCamDistRange.Max - TPCamDistRange.Min) * (Viewer.CameraDist / Viewer.CameraDistRange.Max) + TPCamDistRange.Min;
		SpecialCalcBehindView(Viewer, ViewActor, CameraLocation, CameraRotation);
	}
	else
		SpecialCalcFirstPersonView(Viewer, ViewActor, CameraLocation, DummyRotation); //use rotation set by playercontroller

	LastCameraCalcTime = Level.TimeSeconds;

	Viewer.SetLocation(CameraLocation);

	return true;
}

// Events called on driver entering/leaving vehicle

function Vehicle FindEntryVehicle(Pawn P)
{
	if ( AIController(P.Controller) != None )
		return self;
	if (VSize(P.Location - (Location + (EntryPosition >> Rotation))) < EntryRadius)
        return self;
    return None;
}

// The pawn Driver has tried to take control of this vehicle
function bool TryToDrive(Pawn P)
{
	if ( P.bIsCrouched ||  bNonHumanControl || (P.Controller == None) || (Driver != None) || (P.DrivenVehicle != None) || !P.Controller.bIsPlayer
	     || P.IsA('Vehicle') || Health <= 0 )
		return false;

//jlb	if( !Level.Game.CanEnterVehicle(self, P) )
//jlb		return false;

/*jlb
	// Check vehicle Locking....
	if ( !bTeamLocked || P.GetTeamNum() == Team )
	{
		if ( bEnterringUnlocks && bTeamLocked )
			bTeamLocked = false;

		KDriverEnter( P );
		return true;
	}
	else
	{
		VehicleLocked( P );
		return false;
	}
jlb*/

	KDriverEnter( P );
	return true;
}

event VehicleLocked( Pawn P );	// Pawn tried to enter vehicle, but it's locked!!

function PossessedBy(Controller C)
{
	local PlayerController PC;
	local AIController AIC;

	if ( bAutoTurret && (Controller != None) && ClassIsChildOf(Controller.Class, AutoTurretControllerClass) && !Controller.bDeleteMe )
	{
		Controller.Destroy();
		Controller = None;
	}

	super.PossessedBy( C );

/*jlb
	// Stole another team's vehicle, so set Team to new owner's team
	if ( C.GetTeamNum() != Team )
	{
		//add stat tracking event/variable here?
		if ( Team != 255 && PlayerController(C) != None )
		{
			if( StolenAnnouncement != '' )
				PlayerController(C).PlayRewardAnnouncement(StolenAnnouncement, 1);

			if( StolenSound != None )
				PlaySound( StolenSound,, 2.5*TransientSoundVolume,, 400);
		}

		if ( C.GetTeamNum() != 255 )
			SetTeamNum( C.GetTeamNum() );
	}
jlb*/

	NetPriority = 3;
	NetUpdateFrequency = 100;
	ThrottleTime = Level.TimeSeconds;
	bSpawnProtected = false;

	PC = PlayerController(C);
	if ( PC != None )
	{
		ClientKDriverEnter( PC );
	}
	else
	{
		AIC = AIController(C);
		if ( AIC != None )
		{
			bDriving = True;
			StuckCount = 0;

			Driver = self;  // AI controlled vehicles drive themselves

			DrivingStatusChanged();

//jlb			AttachFlag(PlayerReplicationInfo.HasFlag);

//jlb			Level.Game.DriverEnteredVehicle(self, P);
		}
	}

//jlb	if ( ParentFactory != None && ( !bAutoTurret || !ClassIsChildOf(C.Class, AutoTurretControllerClass) ) )
//jlb		ParentFactory.VehiclePossessed( Self );		// Notify parent factory
	if ( ParentFactory != None )
		ParentFactory.VehiclePossessed( Self );		// Notify parent factory
}

function UnPossessed()
{
	local PlayerController	PC;
	local Controller		NewController;
	local bool				bWasPlayer;

	StopWeaponFiring();
	PC = PlayerController(Controller);



    if ( PC != None )
	{
		bWasPlayer = true;
        ClientKDriverLeave(PC);
		if (bPCRelativeFPRotation && !PC.bBehindView)
			FixPCRotation(PC);
	}
	else
        ClientClearController();

	NetPriority = Default.NetPriority;			// restore original netpriority changed when possessing
	NetUpdateTime = Level.TimeSeconds - 1;
	NetUpdateFrequency = 8;

	super.UnPossessed();

//jlb	if ( ParentFactory != None && ( !bAutoTurret || (Controller == None) || !ClassIsChildOf(Controller.Class, AutoTurretControllerClass) ) )
//jlb		ParentFactory.VehicleUnPossessed( Self );		// Notify parent of UnPossessed()
	if ( ParentFactory != None )
		ParentFactory.VehicleUnPossessed( Self );		// Notify parent of UnPossessed()

	if ( Health > 0 && !bDeleteMe )
	{
		if ( bWasPlayer && bAutoTurret && (AutoTurretControllerClass != None) )
		{
			Controller		= None;
			NewController	= spawn(AutoTurretControllerClass);
			if ( NewController != None )
				NewController.Possess( Self );
		}
	}
}

function KDriverEnter(Pawn P)
{
	local Controller C;

	bDriving = True;
	StuckCount = 0;

	// We don't have pre-defined exit positions here, so we use the original player location as an exit point
	if ( !bRelativeExitPos )
	{
		PlayerEnterredRotation = P.Rotation;
		ExitPositions[0] =  P.Location + Vect(0,0,16);
	}

	// Set pawns current controller to control the vehicle pawn instead
	C = P.Controller;
//jlb	if ( !bCanCarryFlag && (C.PlayerReplicationInfo.HasFlag != None)  )
//jlb		P.DropFlag();

	Driver = P;
	Driver.StartDriving( Self );

	// Disconnect PlayerController from Driver and connect to SVehicle.
//jlb	C.bVehicleTransition = true; // to keep Bots from doing Restart()
	C.Unpossess();
	Driver.SetOwner( Self ); // This keeps the driver relevant.
	C.Possess( Self );
//jlb	C.bVehicleTransition = false;

	DrivingStatusChanged();

	if ( PlayerController(C) != None )
		VehicleLostTime = 0;

//jlb	AttachFlag(PlayerReplicationInfo.HasFlag);

//jlb	Level.Game.DriverEnteredVehicle(self, P);
}

function AttachFlag(Actor FlagActor)
{
	if ( !bDriverHoldsFlag && (FlagActor != None) )
	{
		AttachToBone(FlagActor,FlagBone);
		FlagActor.SetRelativeRotation(FlagRotation);
		FlagActor.SetRelativeLocation(FlagOffset);
	}
}

simulated event SetWheelsScale(float NewScale)
{
	WheelsScale = NewScale;
}

// Called from the PlayerController when player wants to get out.
event bool KDriverLeave( bool bForceLeave )
{
	local Controller C;
	local PlayerController	PC;
	local bool havePlaced;

//jlb	if( !bForceLeave && !Level.Game.CanLeaveVehicle(self, Driver) )
//jlb		return false;

//jlb	if ( (PlayerReplicationInfo != None) && (PlayerReplicationInfo.HasFlag != None) )
//jlb		Driver.HoldFlag(PlayerReplicationInfo.HasFlag);

	// Do nothing if we're not being driven
	if (Controller == None )
		return false;

	// Before we can exit, we need to find a place to put the driver.
	// Iterate over array of possible exit locations.

	if ( (Driver != None) && (!bRemoteControlled || bHideRemoteDriver) )
    {
	    Driver.bHardAttach = false;
	    Driver.bCollideWorld = true;
	    Driver.SetCollision(true, true);
	    havePlaced = PlaceExitingDriver();

	    // If we could not find a place to put the driver, leave driver inside as before.
	    if (!havePlaced && !bForceLeave )
	    {
	        Driver.bHardAttach = true;
	        Driver.bCollideWorld = false;
	        Driver.SetCollision(false, false);
	        return false;
	    }
	}

	bDriving = False;

	// Reconnect Controller to Driver.
	C = Controller;
	if (C.RouteGoal == self)
		C.RouteGoal = None;
	if (C.MoveTarget == self)
		C.MoveTarget = None;
//jlb	C.bVehicleTransition = true;
	Controller.UnPossess();

	if ( (Driver != None) && (Driver.Health > 0) )
	{
		Driver.SetOwner( C );
		C.Possess( Driver );

		PC = PlayerController(C);
		if ( PC != None )
			PC.ClientSetViewTarget( Driver ); // Set playercontroller to view the person that got out

		Driver.StopDriving( Self );
	}
//jlb	C.bVehicleTransition = false;

	if ( C == Controller )	// If controller didn't change, clear it...
		Controller = None;

//jlb	Level.Game.DriverLeftVehicle(self, Driver);

	// Car now has no driver
	Driver = None;

	DriverLeft();

	// Put brakes on before you get out :)
    Throttle	= 0;
    Steering	= 0;
	Rise		= 0;

    return true;
}

// DriverLeft() called by KDriverLeave()
function DriverLeft()
{
    DrivingStatusChanged();
}

simulated function UpdateTiltForceFeedback()
{
/*jlb
	local rotator SpringCenter;
	local PlayerController PC;
	local float pitch, roll;

	PC = PlayerController(Controller);
	if(	PC != None
	&&	PC.bEnableGUIForceFeedback
	&&	PC.bForceFeedbackSupported
	&&	Viewport(PC.Player) != None
	&&	CenterSpringRangePitch > 0
	&&	CenterSpringRangeRoll > 0
	){
		SpringCenter = rotation;
		pitch = Clamp(SpringCenter.Pitch, -CenterSpringRangePitch, CenterSpringRangePitch);
		roll = Clamp(SpringCenter.Roll, -CenterSpringRangeRoll, CenterSpringRangeRoll);
		pitch /= CenterSpringRangePitch;
		roll /= CenterSpringRangeRoll;
		PC.ChangeSpringFeedbackEffect(CenterSpringForce, roll, pitch);
	}
jlb*/
}

simulated function ClientKDriverEnter(PlayerController PC)
{
//	PC.bFreeCamera = true;

	// Set rotation of camera when getting into vehicle based on bZeroPCRotOnEntry
	if ( bZeroPCRotOnEntry )
		PC.SetRotation( rot(0, 0, 0) );

	//set starting camera distance to local player's preferences
	TPCamDistance = default.TPCamDistance;
	DesiredTPCamDistance = TPCamDistance;

    if (!PC.bBehindView)
	   ActivateOverlay(True);

	if (PC.bEnableGUIForceFeedback)
	{
		UpdateTiltForceFeedback();
		PC.ClientPlayForceFeedback(CenterSpringForce);
	}
}

simulated function ClientClearController()
{
    ActivateOverlay(False);
}

simulated function ClientKDriverLeave(PlayerController PC)
{
//	PC.bFreeCamera = false;

	// Stop messing with bOwnerNoSee
	if ( Driver != None )
		Driver.bOwnerNoSee = Driver.default.bOwnerNoSee;

	if (PC.bEnableGUIForceFeedback)
		PC.ClientStopForceFeedback(CenterSpringForce);

	bWeaponisFiring = False;
	bWeaponisAltFiring = False;

	ActivateOverlay(False);
}

simulated function ActivateOverlay(bool bActive)
{
    if (bActive)
    {
        if (HUDOverlayClass != None && HUDOverlay == None)
            HUDOverlay = spawn(HUDOverlayClass);
    }
    else if (HUDOverlay != None)
        HUDOverlay.Destroy();
}

//seperate replicated function called from UnPossessed() to make PC rotation no longer relative to vehicle
//needed because PC.bBehindView will get screwed around with as a result of unpossessing vehicle and repossessing Driver
simulated function FixPCRotation(PlayerController PC)
{
	PC.SetRotation(rotator(vector(PC.Rotation) >> Rotation));
}

simulated function AttachDriver(Pawn P)
{
	local vector AttachPos;

	P.bHardAttach = true;
	AttachPos = Location + (DrivePos >> Rotation);
	P.SetLocation( AttachPos );
	P.SetPhysics( PHYS_None );
	P.SetBase( Self );
	P.SetRelativeRotation( DriveRot );
}

simulated function DetachDriver(Pawn P) {}

function bool PlaceExitingDriver()
{
	local int		i, j;
	local vector	tryPlace, Extent, HitLocation, HitNormal, ZOffset, RandomSphereLoc;

	Extent = Driver.default.CollisionRadius * vect(1,1,0);
	Extent.Z = Driver.default.CollisionHeight;
	ZOffset = Driver.default.CollisionHeight * vect(0,0,1);

	//avoid running driver over by placing in direction perpendicular to velocity
	if ( VSize(Velocity) > 100 )
	{
		tryPlace = Normal(Velocity cross vect(0,0,1)) * (CollisionRadius + Driver.default.CollisionRadius ) * 1.25 ;
		if ( FRand() < 0.5 )
			tryPlace *= -1; //randomly prefer other side
		if ( (Trace(HitLocation, HitNormal, Location + tryPlace + ZOffset, Location + ZOffset, false, Extent) == None && Driver.SetLocation(Location + tryPlace + ZOffset))
		     || (Trace(HitLocation, HitNormal, Location - tryPlace + ZOffset, Location + ZOffset, false, Extent) == None && Driver.SetLocation(Location - tryPlace + ZOffset)) )
			return true;
	}


	if ( !bRelativeExitPos )
	{
		for( i=0; i<ExitPositions.Length; i++)
		{
			tryPlace = ExitPositions[i];

			if ( Driver.SetLocation(tryPlace) )
				return true;
			else
			{
				for (j=0; j<10; j++) // try random positions in a sphere...
				{
					RandomSphereLoc = VRand()*200* FMax(FRand(),0.5);
					RandomSphereLoc.Z = Extent.Z * FRand();

					// First, do a line check (stops us passing through things on exit).
					if ( Trace(HitLocation, HitNormal, tryPlace+RandomSphereLoc, tryPlace, false, Extent) == None )
					{
						if ( Driver.SetLocation(tryPlace+RandomSphereLoc) )
							return true;
					}
					else if ( Driver.SetLocation(HitLocation) )
						return true;
				}
			}
		}
		return false;
	}

	for( i=0; i<ExitPositions.Length; i++)
	{
		if ( ExitPositions[0].Z != 0 )
			ZOffset = Vect(0,0,1) * ExitPositions[0].Z;
		else
			ZOffset = Driver.default.CollisionHeight * vect(0,0,2);

		tryPlace = Location + ( (ExitPositions[i]-ZOffset) >> Rotation) + ZOffset;

		// First, do a line check (stops us passing through things on exit).
		if ( Trace(HitLocation, HitNormal, tryPlace, Location + ZOffset, false, Extent) != None )
			continue;

		// Then see if we can place the player there.
		if ( !Driver.SetLocation(tryPlace) )
			continue;

		return true;
	}
	return false;
}

function Pawn CheckForHeadShot(Vector loc, Vector ray, float AdditionalScale)
{
    return None;
}

function TakeDamage( int Damage, Pawn instigatedBy, Vector hitlocation,
						Vector momentum, class<DamageType> damageType, optional	name HitBoxName)
{
	local int ActualDamage;
	local Controller Killer;

	// Spawn Protection: Cannot be destroyed by a player until possessed
	if ( bSpawnProtected && instigatedBy != None && instigatedBy != Self )
		return;

	NetUpdateTime = Level.TimeSeconds - 1; // force quick net update

/*jlb
	if (DamageType != None)
	{
		if ((instigatedBy == None || instigatedBy.Controller == None) && DamageType.default.bDelayedDamage && DelayedDamageInstigatorController != None)
			instigatedBy = DelayedDamageInstigatorController.Pawn;

		Damage *= DamageType.default.VehicleDamageScaling;
		momentum *= DamageType.default.VehicleMomentumScaling * MomentumMult;

	        if (bShowDamageOverlay && DamageType.default.DamageOverlayMaterial != None && Damage > 0 )
        	    SetOverlayMaterial( DamageType.default.DamageOverlayMaterial, DamageType.default.DamageOverlayTime, false );
	}
jlb*/

	if (bRemoteControlled && Driver!=None)
	{
	    ActualDamage = Damage;
	    if (Weapon != None)
	        Weapon.AdjustPlayerDamage(ActualDamage, InstigatedBy, HitLocation, Momentum, DamageType );
//jlb	    if (InstigatedBy != None && InstigatedBy.HasUDamage())
//jlb	        ActualDamage *= 2;

	    ActualDamage = Level.Game.ReduceDamage(ActualDamage, self, instigatedBy, HitLocation, Momentum, DamageType);

	    if (Health - ActualDamage <= 0)
	       	KDriverLeave(false);
	}

    if ( Physics != PHYS_Karma )
	{
		super.TakeDamage(Damage,InstigatedBy,HitLocation,Momentum,DamageType);
		return;
	}

	if (Weapon != None)
	        Weapon.AdjustPlayerDamage(Damage, InstigatedBy, HitLocation, Momentum, DamageType );
//jlb	if (InstigatedBy != None && InstigatedBy.HasUDamage())
//jlb		Damage *= 2;
	ActualDamage = Level.Game.ReduceDamage(Damage, self, instigatedBy, HitLocation, Momentum, DamageType);
	Health -= ActualDamage;

	PlayHit(actualDamage, InstigatedBy, hitLocation, damageType, Momentum);
	// The vehicle is dead!
	if ( Health <= 0 )
	{

		if ( Driver!=None && (bEjectDriver || bRemoteControlled) )
		{
			if ( bEjectDriver )
				EjectDriver();
			else
        		KDriverLeave( false );
		}

		// pawn died
		if ( instigatedBy != None )
			Killer = instigatedBy.GetKillerController();
//jlb		if ( Killer == None && (DamageType != None) && DamageType.Default.bDelayedDamage )
//jlb			Killer = DelayedDamageInstigatorController;
		Died(Killer, damageType, HitLocation);
	}
	else if ( Controller != None )
		Controller.NotifyTakeHit(instigatedBy, HitLocation, actualDamage, DamageType, Momentum);

	MakeNoise(1.0);

	if ( !bDeleteMe )
	{
//jlb		if ( Location.Z > Level.StallZ )
//jlb			Momentum.Z = FMin(Momentum.Z, 0);
		KAddImpulse(Momentum, hitlocation);
	}
}

function bool HealDamage(int Amount, Controller Healer, class<DamageType> DamageType)
{
	if ( PlayerController(Healer) != None )
		PlayerStartTime = Level.TimeSeconds + 3;
//jlb	if (Health <= 0 || Health >= HealthMax || Amount <= 0 || Healer == None || !TeamLink(Healer.GetTeamNum()))
	if (Health <= 0 || Amount <= 0 || Healer == None)
		return false;

//jlb	Health = Min(Health + (Amount * LinkHealMult), HealthMax);
	Health = Health + (Amount * LinkHealMult);
	NetUpdateTime = Level.TimeSeconds - 1;
	return true;
}

//determine if radius damage that hit the vehicle should damage the driver
function DriverRadiusDamage(float DamageAmount, float DamageRadius, Controller EventInstigator, class<DamageType> DamageType, float Momentum, vector HitLocation)
{
	local float damageScale, dist;
	local vector dir;

	//if driver has collision, whatever is causing the radius damage will hit the driver by itself
	if (EventInstigator == None || Driver == None || Driver.bCollideActors || bRemoteControlled)
		return;

	dir = Driver.Location - HitLocation;
	dist = FMax(1, VSize(dir));
	dir = dir/dist;
	damageScale = 1 - FMax(0,(dist - Driver.CollisionRadius)/DamageRadius);
	if (damageScale <= 0)
		return;

//jlb	Driver.SetDelayedDamageInstigatorController(EventInstigator);
	Driver.TakeDamage( damageScale * DamageAmount, EventInstigator.Pawn, Driver.Location - 0.5 * (Driver.CollisionHeight + Driver.CollisionRadius) * dir,
			   damageScale * Momentum * dir, DamageType );
}


function DriverDied()
{
	local Controller C;

	Level.Game.DiscardInventory( Driver );
//jlb	if (PlayerReplicationInfo != None && PlayerReplicationInfo.HasFlag != None)
//jlb		PlayerReplicationInfo.HasFlag.Drop(0.5 * Velocity);

	C = Controller;
	Driver.StopDriving( Self );
	Driver.Controller = C;
	Driver.DrivenVehicle = self; //for in game stats, so it knows pawn was killed inside a vehicle

	if ( Controller == None )
		return;

	if ( PlayerController(Controller) != None )
	{
		Controller.SetLocation(Location);
		PlayerController(Controller).SetViewTarget( Driver );
		PlayerController(Controller).ClientSetViewTarget( Driver );
	}

	Controller.Unpossess();
	if ( Controller == C )
		Controller = None;
	C.Pawn = Driver;

//jlb	Level.Game.DriverLeftVehicle(self, Driver);

	// Car now has no driver
	Driver = None;
	bDriving = false;

	// Put brakes on before you get out :)
    Throttle	= 0;
    Steering	= 0;
	Rise		= 0;
}

function Died(Controller Killer, class<DamageType> damageType, vector HitLocation)
{
	local PlayerController PC;
	local Controller C;

	if ( bDeleteMe || Level.bLevelChange )
		return; // already destroyed, or level is being cleaned up

	if ( Physics != PHYS_Karma )
	{
		super.Died(Killer, damageType, HitLocation);
		return;
	}

	if ( Level.Game.PreventDeath(self, Killer, damageType, HitLocation) )
	{
		Health = max(Health, 1); //mutator should set this higher
		return;
	}
	Health = Min(0, Health);

	if ( Controller != None )
	{
		C = Controller;
		C.WasKilledBy(Killer);
		Level.Game.Killed(Killer, C, self, damageType);
		if( C.bIsPlayer )
		{
			PC = PlayerController(C);
			if ( PC != None )
				ClientKDriverLeave(PC); // Just to reset HUD etc.
			else
                ClientClearController();
			if ( (bRemoteControlled || bEjectDriver) && (Driver != None) && (Driver.Health > 0) )
			{
				C.Unpossess();
				C.Possess(Driver);

				if ( bEjectDriver )
					EjectDriver();

				Driver = None;
			}
			else
				C.PawnDied(self);
		}

		if ( !C.bIsPlayer && !C.bDeleteMe )
			C.Destroy();
	}
	else
		Level.Game.Killed(Killer, Controller(Owner), self, damageType);

	if ( Killer != None )
		TriggerEvent(Event, self, Killer.Pawn);
	else
		TriggerEvent(Event, self, None);

	if ( IsHumanControlled() )
		PlayerController(Controller).ForceDeathUpdate();

	if ( !bDeleteMe )
		Destroy(); // Destroy the vehicle itself (see Destroyed)
}

function AdjustDriverDamage(out int Damage, Pawn InstigatedBy, Vector HitLocation, out Vector Momentum, class<DamageType> DamageType)
{
	if ( InGodMode() )
 		Damage = 0;
	else
 		Damage *= DriverDamageMult;
}

function EjectDriver()
{
	local Pawn		OldPawn;
	local vector	EjectVel;

	OldPawn = Driver;

	KDriverLeave( true );

	if ( OldPawn == None )
		return;

	EjectVel	= VRand();
	EjectVel.Z	= 0;
	EjectVel	= (Normal(EjectVel)*0.2 + Vect(0,0,1)) * EjectMomentum;

	OldPawn.Velocity = EjectVel;

	// Spawn Protection
	OldPawn.SpawnTime = Level.TimeSeconds;
	OldPawn.PlayTeleportEffect( false, false);
}

// Input
event bool UsedBy( Pawn user )
{
	if ( Driver != None )
			return false;

	// Enter vehicle code
	TryToDrive( User );
	return true;
}

function Fire( optional float F )
{
	VehicleFire( false );
	bWeaponIsFiring = true;
}

function AltFire( optional float F )
{
	VehicleFire( true );
	bWeaponIsAltFiring = true;
}

function ClientVehicleCeaseFire(bool bWasAltFire)
{
	if (bWasAltFire)
		bWeaponIsAltFiring = false;
	else
		bWeaponIsFiring = false;

	VehicleCeaseFire(bWasAltFire);
}

// Do some server-side vehicle firing stuff
function VehicleFire(bool bWasAltFire)
{
	if ( bWasAltFire )
		bWeaponIsAltFiring = true;
	else
		bWeaponIsFiring = true;
}

function VehicleCeaseFire(bool bWasAltFire)
{
	if ( bWasAltFire )
		bWeaponIsAltFiring = false;
	else
		bWeaponIsFiring = false;
}

state UnDeployed
{
    function VehicleFire(bool bWasAltFire)
    {
        Global.VehicleFire(bWasAltFire);
    }

    function VehicleCeaseFire(bool bWasAltFire)
    {
        Global.VehicleCeaseFire(bWasAltFire);
    }
}

state Deployed
{
    function VehicleFire(bool bWasAltFire)
    {
        Global.VehicleFire(bWasAltFire);
    }

    function VehicleCeaseFire(bool bWasAltFire)
    {
        Global.VehicleCeaseFire(bWasAltFire);
    }
}

function bool StopWeaponFiring()
{
	local bool bResult;

	if ( bWeaponIsFiring )
	{
		ClientVehicleCeaseFire( false );
		bWeaponIsFiring = false;
		bResult = true;
	}
	if ( bWeaponIsAltFiring )
	{
		ClientVehicleCeaseFire( true );
		bWeaponIsAltFiring = false;
		bResult = true;
	}
	return bResult;
}


event UpdateEyeHeight( float DeltaTime )
{
	local Controller C;

	if ( Controller != None && Controller.IsA('PlayerController') )
		Controller.AdjustView( DeltaTime );

	for ( C=Level.ControllerList; C!=None; C=C.NextController )
		if ( C.IsA('PlayerController') && (PlayerController(C).ViewTarget == self) )
			return;

	bUpdateEyeHeight =false;
	Eyeheight = BaseEyeheight;
}

// Vehicles ignore 'face rotation'.
simulated function FaceRotation( rotator NewRotation, float DeltaTime ) {}

simulated event SetAnimAction(name NewAction)
{
	if ( bDrawDriverInTP && (Driver != None) )
		Driver.SetAnimAction(NewAction);
}

// Vehicles dont get telefragged.
event EncroachedBy(Actor Other) {}

// RanInto() called for encroaching actors which successfully moved the other actor out of the way
event RanInto(Actor Other)
{
	local vector Momentum;
	local float Speed;

	if (Pawn(Other) == None || Vehicle(Other) != None || Other == Instigator || Other.Role != ROLE_Authority)
		return;

	Speed = VSize(Velocity);
	if (Speed > MinRunOverSpeed)
	{
		Momentum = Velocity * 0.25 * Other.Mass;

		if (Controller != None && Controller.SameTeamAs(Pawn(Other).Controller))
			Momentum += Speed * 0.25 * Other.Mass * Normal(Velocity cross vect(0,0,1));
		if (RanOverSound != None)
			PlaySound(RanOverSound,,TransientSoundVolume*2.5);

       		Other.TakeDamage(int(Speed * 0.075), Instigator, Other.Location, Momentum, RanOverDamageType);
	}
}

// This will get called if we couldn't move a pawn out of the way.
function bool EncroachingOn(Actor Other)
{
	if ( Other == None || Other == Instigator || Other.Role != ROLE_Authority || (!Other.bCollideActors && !Other.bBlockActors)
	     || VSize(Velocity) < 10 )
		return false;

	// If its a non-vehicle pawn, do lots of damage.
	if( (Pawn(Other) != None) && (Vehicle(Other) == None) )
	{
		Other.TakeDamage(10000, Instigator, Other.Location, Velocity * Other.Mass, CrushedDamageType);
		return false;
	}
}

/*jlb
simulated function bool CheckTauntValid( name Sequence )
{
	if ( !bDrawDriverInTP || (Driver == None) )
		return false;
	return Driver.CheckTauntValid(Sequence);
}
jlb*/


// AI code
function bool Occupied()
{
	return ( Controller != None );
}

function float ReservationCostMultiplier()
{
	return 1.0;
}

function bool SpokenFor(Controller C)
{
	return false;
}

function SetReservation(controller C);

function Vehicle OpenPositionFor(Pawn P)
{
	if ( Controller == None )
		return self;
	return None;
}

simulated function bool IndependentVehicle()
{
	return true;
}

function Actor GetBestEntry(Pawn P)
{
	return self;
}

function Vehicle GetMoveTargetFor(Pawn P)
{
	return self;
}

simulated event DrivingStatusChanged()
{
    local PlayerController PC;

	PC = Level.GetLocalPlayerController();

//jlb	if (bDriving && PC != None && (PC.ViewTarget == None || !(PC.ViewTarget.IsJoinedTo(self))))
	if (bDriving && PC != None && (PC.ViewTarget == None))
        bDropDetail = (Level.bDropDetail || (Level.DetailMode == DM_Low));
    else
        bDropDetail = False;

    if (bDriving)
        Enable('Tick');
    else
        Disable('Tick');
}

simulated function Tick(float DeltaTime)
{
//jlb    local	rotator				Look;
	local	class<LocalMessage>	LockOnClass;

//	DrawDebugSphere(Location + (EntryPosition >> Rotation), EntryRadius, 20, 255, 0, 0);

    if ( Role == ROLE_Authority )
    {
    	if ( Driver != None && Controller != None )
		{
			if ( bEnemyLockedOn && PlayerController(Controller) != None && Level.TimeSeconds > LastLockWarningTime + 1.5)
        	{
				LockOnClass = class<LocalMessage>(DynamicLoadObject(LockOnClassString, class'class'));
				PlayerController(Controller).ReceiveLocalizedMessage(LockOnClass, 12);
        		LastLockWarningTime = Level.TimeSeconds;
			}
		}
	}

/*jlb
	if ( Level.NetMode != NM_DedicatedServer && !bDropDetail && bAdjustDriversHead && bDrawDriverinTP && (Driver != None) && (Driver.HeadBone != '') )
	{
		Look.Yaw = (DriverViewYaw - Driver.Rotation.Yaw) & 65535;
		if ( Look.Yaw > 12000 )
		{
			if ( Look.Yaw < 32768 )
			{
				if ( Look.Yaw > 20768 )
					Look.Yaw = Look.Yaw - 32768;
				else if ( Look.Yaw > 16768 )
					Look.Yaw = -12000 + 6 * (20768 - Look.Yaw);
				else
					Look.Yaw = 12000;
			}
			else if ( Look.Yaw < 53535 )
			{
				if ( Look.Yaw < 44768 )
					Look.Yaw = Look.Yaw + 32768;
				else if ( Look.Yaw < 48768 )
					Look.Yaw = 12000 + 6 * (44768 - Look.Yaw);
				else
					Look.Yaw = 53535;
			}
		}
		Look.Yaw *= -1;
		Driver.SetBoneDirection(Driver.HeadBone, Look, vect(0,0,0), 1.0f, 0);
	}
jlb*/

	UpdateTiltForceFeedback();
}

/* PointOfView()
called by controller when possessing this pawn
false = 1st person, true = 3rd person
*/
simulated function bool PointOfView()
{
	if (!bAllowViewChange)
		return true;

	return default.bDesiredBehindView;
}

// Spawn FX
function PlayTeleportEffect( bool bOut, bool bSound)
{
	local Actor			A;
	local class<Actor>	TransEffect;

	if ( (GetTeam() == None) || (GetTeam().TeamIndex == 0) )
		TransEffect = class<Actor>(DynamicLoadObject(TransEffects[0], class'Class'));
	else
		TransEffect = class<Actor>(DynamicLoadObject(TransEffects[1], class'Class'));

	if ( TransEffect != None )
		A = Spawn(TransEffect,,,Location + CollisionHeight * vect(0,0,0.75));

	// for fast moving vehicles, make the effect sticky
	if ( A != None )
		A.SetBase( Self );

    super.PlayTeleportEffect( bOut, bSound );
}

simulated event PlayDying(class<DamageType> DamageType, vector HitLoc) {}

/*jlb
simulated function int GetTeamNum()
{
	if ( Role == Role_Authority && Team == 255 && (Controller != None) )
	   SetTeamNum( Controller.GetTeamNum() );

    return Team;
}
jlb*/

//Notify vehicle that an enemy has locked on to it
event NotifyEnemyLockedOn()
{
	bEnemyLockedOn = true;
}

//Notify vehicle that an enemy has lost the lock
event NotifyEnemyLostLock()
{
	bEnemyLockedOn = false;
}

/*
Team is changed when vehicle is possessed
and PrevTeam is restored when vehicle is unpossessed
*/
function SetTeamNum(byte T)
{
	PrevTeam	= Team;
    Team		= T;

	if ( PrevTeam != Team )
		TeamChanged();
}

simulated event TeamChanged() {}

simulated function DisplayDebug(Canvas Canvas, out float YL, out float YPos)
{
	super.DisplayDebug(Canvas, YL, YPos);

	Canvas.SetDrawColor(255,255,255);
	Canvas.DrawText("Steering "$Steering$" throttle "$Throttle$" rise "$Rise);

	if ( Driver != None )
	{
        YPos += YL;
    	YPos += YL;
		Canvas.SetPos(0, YPos);
		Canvas.SetDrawColor(0,0,255);
		Canvas.DrawText("--- DRIVER");
		Canvas.SetPos(4, YPos);
		Driver.DisplayDebug( Canvas, YL, YPos );
	}
}

function Actor ShootSpecial(Actor A)
{
	local Controller OldController;

	if ( !Controller.bCanDoSpecial || (Weapon == None) )
		return None;

	Controller = OldController;
	if ( KDriverLeave(false) && (OldController.Pawn != None) )
	{
		OldController.Pawn.SetRotation(rotator(A.Location - OldController.Pawn.Location));
		OldController.Focus = A;
		OldController.FireWeaponAt(A);
	}
	return A;
}

//Vehicles stall when they go above the level's StallZ
simulated event Stalled();
simulated event UnStalled();

simulated function NextWeapon()
{
    local PlayerController PC;

    if ( Level.Pauser != None )
        return;

    PC = PlayerController(Controller);
    if (PC == None)
    	return;

    if (!PC.bBehindView)
    {
    	PC.BehindView(true);
	DesiredTPCamDistance = TPCamDistRange.Min;
	TPCamDistance = DesiredTPCamDistance;
    }
    else
	DesiredTPCamDistance = Min(DesiredTPCamDistance + 100, TPCamDistRange.Max);

    default.TPCamDistance = DesiredTPCamDistance;
    StaticSaveConfig();
}

simulated function PrevWeapon()
{
    local PlayerController PC;

    if ( Level.Pauser != None )
        return;

    PC = PlayerController(Controller);
    if (PC == None || !PC.bBehindView)
    	return;

    if (DesiredTPCamDistance ~= TPCamDistRange.Min)
    	PC.BehindView(false);
    else
    {
	DesiredTPCamDistance = Max(DesiredTPCamDistance - 100, TPCamDistRange.Min);
	default.TPCamDistance = DesiredTPCamDistance;
	StaticSaveConfig();
    }
}

function bool TeamLink(int TeamNum)
{
	return (LinkHealMult > 0 && Team == TeamNum && Health > 0);
}

event bool NeedsFlip()
{
	local vector worldUp, gravUp;
	local float GravMag;

	GravMag = VSize(PhysicsVolume.Gravity);
	if( GravMag < 0.1 )
		gravUp = vect(0,0,1);
	else
		gravUp = -1.0 * (PhysicsVolume.Gravity/GravMag);

	worldUp = vect(0,0,1) >> Rotation;
	if (worldUp Dot gravUp < 0.7071)
		return true;

	return false;
}

function Flip(vector HitNormal, float ForceScale);

simulated function float ChargeBar();

simulated function ClientPlayForceFeedback( String EffectName )
{
    local PlayerController PC;

    PC = PlayerController(Controller);
    //if ( PC != None && PC.bEnableVehicleForceFeedback )
    if ( PC != None && PC.bEnableGUIForceFeedback )
    {
        PC.ClientPlayForceFeedback( EffectName );
    }
}

simulated function StopForceFeedback( String EffectName )
{
    local PlayerController PC;

    PC = PlayerController(Controller);
    //if ( PC != None && PC.bEnableVehicleForceFeedback )
    if ( PC != None && PC.bEnableGUIForceFeedback )
    {
        PC.ClientStopForceFeedback( EffectName );
    }
}

function ServerPlayHorn(int HornIndex)
{
	if( (Level.TimeSeconds - LastHornTime > 3.0) && (HornIndex >= 0) && (HornIndex < HornSounds.Length) )
	{
		PlaySound( HornSounds[HornIndex],, 3.5*TransientSoundVolume,, 800);
		LastHornTime = Level.TimeSeconds;
	}
}

function int NumPassengers()
{
	if ( Driver != None )
		return 1;
	return 0;
}

function Pawn GetInstigator()
{
	return Self;
}

function AIController GetBotPassenger()
{
	return AIController(Controller);
}

function bool IsVehicleEmpty()
{
	return (Driver == None);
}

function bool HasOccupiedTurret()
{
	return false;
}

/*jlb
function float AdjustedStrength()
{
	if (bStationary && bDefensive)
		return 1.0;

	return 0;
}
jlb*/

static function StaticPrecache(LevelInfo L);

/*jlb
function int GetSpree()
{
	if (Driver != None)
		return Driver.GetSpree();

	return 0;
}

function IncrementSpree()
{
	if (Driver != None)
		Driver.IncrementSpree();
}
jlb*/

simulated function POVChanged(PlayerController PC, bool bBehindViewChanged)
{
	if (PC.bBehindView)
	{
		if (bBehindViewChanged && bPCRelativeFPRotation)
			PC.SetRotation(rotator(vector(PC.Rotation) >> Rotation));

		bOwnerNoSee = false;

		if (Driver != None)
		{
			if (bDrawDriverInTP)
				Driver.bOwnerNoSee = false;
			else
				Driver.bOwnerNoSee = true;
		}

        if (PC == Controller)   // No overlays for spectators
            ActivateOverlay(False);
	}
	else
	{
		if (bPCRelativeFPRotation)
			PC.SetRotation(rotator(vector(PC.Rotation) << Rotation));

		if (bDrawMeshInFP)
			bOwnerNoSee = false;
		else
			bOwnerNoSee = true;

		if (Driver != None)
		{
			Driver.bOwnerNoSee = true;
		}

        if (bDriving && PC == Controller)   // No overlays for spectators
            ActivateOverlay(True);
	}
}

function PlayTakeHit(vector HitLocation, int Damage, class<DamageType> DamageType)
{
/*jlb
    local int SoundNum;

    if (IndependentVehicle() && DamageType.Default.bBulletHit && BulletSounds.Length > 0)
    {
		SoundNum = Rand(BulletSounds.Length);

		if (Controller != None && Controller == Level.GetLocalPlayerController())
            PlayOwnedSound(BulletSounds[SoundNum], SLOT_None, 2.0, False, 400);
        else
            PlayOwnedSound(BulletSounds[SoundNum], SLOT_None, 2.0, False, 100);
	}
jlb*/
}

function array<Vehicle> GetTurrets();

function CheckSuperBerserk();

//=============================================================================
// defaultproperties
//=============================================================================

defaultproperties
{
	bAdjustDriversHead=true
	LandMovementState=PlayerDriving
	bVehicleShadows=true
	bDrawVehicleShadow=true
	bDontPossess=false
	bUseCompressedPosition=false
	bCanPickupInventory=false
	Team=255
	OldTeam=255
	PrevTeam=255

	Steering=0
    Throttle=0

	EjectMomentum=1000
	ExitPositions(0)=(X=0,Y=0,Z=0)

	EntryPosition=(X=0,Y=0,Z=0)
	EntryRadius=100.0

	DrivePos=(X=0,Y=0,Z=0)
	bZeroPCRotOnEntry=true
	bRelativeExitPos=true
	bPCRelativeFPRotation=true

	TPCamLookat=(X=-100,Y=0,Z=100)
	TPCamWorldOffset=(X=0,Y=0,Z=0)
	TPCamDistance=600
	TPCamDistRange=(Min=50,Max=1500)
	CameraSpeed=500
	bDesiredBehindView=true

	MaxViewYaw=16000
	MaxViewPitch=16000

//jlb	TransEffects(0)="XEffects.TransEffectRed"
//jlb	TransEffects(1)="XEffects.TransEffectBlue"

	DriveAnim=Vehicle_Driving
	CollisionRadius=+120.0
	CollisionHeight=+50.0
	SightRadius=+15000.0
	ShadowMaxTraceDist=+350
	ShadowCullDistance=1500.0
//jlb	bForceSkelUpdate=true
	bCanBeBaseForPawns=True

	MomentumMult=4.0
	DriverDamageMult=1.0
	VehiclePositionString="in a vehicle"
	VehicleNameString="Vehicle"

//jlb	LockOnClassString="Onslaught.ONSOnslaughtMessage"

//jlb	RanOverDamageType=class'DamRanOver'
	CrushedDamageType=class'Crushed'
    bAllowViewChange=true
	LinkHealMult=0.35
	VehicleLostTime=0.0
	NetUpdateFrequency=4
	NetPriority=1

//jlb	CenterSpringForce="SpringONSHoverBike"
	CenterSpringRangePitch=2000
	CenterSpringRangeRoll=2000

	bDriverHoldsFlag=true
	bCanCarryFlag=true

	WalkingPct=+1.0
	CrouchedPct=+1.0

	MaxDesireability=0.5

	ObjectiveGetOutDist=1000.0
}
//
//	ShadowProjector
//

class VehicleShadowProjector extends ShadowProjector;

defaultproperties
{
    bBlobShadow=True
    bOrientedShadow=True

	bProjFlag_Shadow=False
	bProjFlag_VehicleShadow=True
	bProjFlag_LevelShadow=False
	bProjFlag_Blood=False
	bProjFlag_Bullet=False
	bProjFlag_Blast=False
	bProjFlag_SAVIcon=False
	bProjFlag_ObjectiveIcon=False
	bProjFlag_CommandRing=False
}
//=============================================================================
// VisBlockingVolume:  a bounding volume
// used to block visibility for AI Pawns
//=============================================================================

class VisBlockingVolume extends Volume
	native;

var() float NoVisBlockDistance;  // don't block visibility if start of trace is less than this distance away

defaultproperties
{
	bVisBlockingVolume=true
	bCollideActors=true
	bBlockZeroExtentTraces=false
	bBlockNonZeroExtentTraces=false
	NoVisBlockDistance=2000.0
}
//=============================================================================
// VoicePack.
//=============================================================================
class VoicePack extends Info
	abstract;



/*
ClientInitialize() sets up playing the appropriate voice segment, and returns a string
 representation of the message
*/
function ClientInitialize(PlayerReplicationInfo Sender, PlayerReplicationInfo Recipient, name messagetype, byte messageIndex);
static function PlayerSpeech(name Type, int Index, string Callsign, Actor PackOwner);

static function byte GetMessageIndex(name PhraseName)
{
	return 0;
}

static function int PickRandomTauntFor(controller C, bool bNoMature, bool bNoHumanOnly)
{
	return 0;
}

defaultproperties
{
	bStatic=false
	LifeSpan=+10.0
    RemoteRole=ROLE_None
}
//=============================================================================
// Volume:  a bounding volume
// touch() and untouch() notifications to the volume as actors enter or leave it
// enteredvolume() and leftvolume() notifications when center of actor enters the volume
// pawns with bIsPlayer==true  cause playerenteredvolume notifications instead of actorenteredvolume()
// This is a built-in Unreal class and it shouldn't be modified.
//=============================================================================
class Volume extends Brush
	native;



var Actor AssociatedActor;			// this actor gets touch() and untouch notifications as the volume is entered or left
var() name AssociatedActorTag;		// Used by L.D. to specify tag of associated actor
var() int LocationPriority;
var() localized string LocationName;
var() edfindable decorationlist DecoList;		// A list of decorations to be spawned inside the volume when the level starts
var() bool bInitiallyActive;
var   bool bInitialized;


native function bool Encompasses(Actor Other); // returns true if center of actor is within volume

function PostBeginPlay()
{
	Super.PostBeginPlay();
}

function PostLoadGame()
{
	Super.PostLoadGame();
	
	if (bInitiallyActive)
	{
		if ( AssociatedActorTag != '' )
		{
			ForEach AllActors(class'Actor',AssociatedActor, AssociatedActorTag)
			{
				break;
			}
		}
		if ( AssociatedActor != None )
		{
			GotoState('AssociatedTouch');
			InitialState = GetStateName();
		}
		bInitialized=true;
	}
}

function DisplayDebug(Canvas Canvas, out float YL, out float YPos)
{
	Super.DisplayDebug(Canvas,YL,YPos);
	Canvas.DrawText("AssociatedActor "$AssociatedActor, false);
	YPos += YL;
	Canvas.SetPos(4,YPos);
}

State AssociatedTouch
{
	event touch( Actor Other )
	{
		if ( AssociatedActor == None )	// GBX:naj - this test is to get rid of 'Accessed None's.
			GotoState( '' );
		else
		if( AssociatedActor.bCollideActors )
		{
			// Don't touch the associated actor unless it is colliding.
			// This specifically fixes the problem with associated Triggers being retriggered despite bTriggerOnceOnly.
			AssociatedActor.touch(Other);
		}
	}

	event untouch( Actor Other )
	{
		if ( AssociatedActor == None )	// GBX:naj - this test is to get rid of 'Accessed None's.
			GotoState( '' );
		else
		if( AssociatedActor.bCollideActors )
		{
			// Don't untouch the associated actor unless it is colliding.
			AssociatedActor.untouch(Other);
		}
	}

	function BeginState()
	{
		local Actor A;

		ForEach TouchingActors(class'Actor', A)
		{
			if( A.bCollideActors )
			{
				Touch(A);
			}
		}
		
		SetTimer( 0.1f, true );
	}
}

event Trigger( Actor Other, Pawn EventInstigator )
{
	if (!bInitialized)
	{
		if ( AssociatedActorTag != '' )
		{
			ForEach AllActors(class'Actor',AssociatedActor, AssociatedActorTag)
			{
				break;
			}
		}
		if ( AssociatedActor != None )
		{
			GotoState('AssociatedTouch');
			InitialState = GetStateName();
			bInitialized=true;
		}
	}
}

defaultproperties
{
	bCollideActors=True
	LocationName="unspecified"
	bSkipActorPropertyReplication=true

	bInitiallyActive=true
	bInitialized=false

	bBlockZeroExtentTraces=false
}
class VolumeTimer extends info;



var PhysicsVolume V;

function PostBeginPlay()
{
	Super.PostBeginPlay();
	SetTimer(1.0, true);
	V = PhysicsVolume(Owner);
}

function Timer()
{
	V.TimerPop(self);
}

defaultproperties
{
	bStatic=false
	RemoteRole=ROLE_None
}
//=============================================================================
// WarpZoneInfo. For making disjoint spaces appear as if they were connected;
// supports both in-level warp zones and cross-level warp zones.
//=============================================================================
class WarpZoneInfo extends ZoneInfo
	native;



//-----------------------------------------------------------------------------
// Information set by the level designer.

var() string     OtherSideURL;
var() name       ThisTag;
var() bool		 bNoTeleFrag;

//-----------------------------------------------------------------------------
// Internal.

var const int              iWarpZone;
var const coords           WarpCoords;
var transient WarpZoneInfo OtherSideActor;
var transient object       OtherSideLevel;
var() string		       Destinations[8];
var int					   numDestinations;

//-----------------------------------------------------------------------------
// Network replication.

replication
{
	reliable if( Role==ROLE_Authority )
		OtherSideURL, ThisTag, OtherSideActor;
}

//-----------------------------------------------------------------------------
// Functions.

// Warp coordinate system transformations.
native(314) final function Warp  ( out vector Loc, out vector Vel, out rotator R );
native(315) final function UnWarp( out vector Loc, out vector Vel, out rotator R );

function PreBeginPlay()
{
	Super.PreBeginPlay();

	// Generate the local connection.
	Generate();

	// Setup destination list.
	numDestinations = 0;
	While( numDestinations < 8 )
		if (Destinations[numDestinations] != "")
			numDestinations++;
		else
			numDestinations = 8;

	// Generate URL if necessary.
	if( numDestinations>0 && (OtherSideURL == "") )
		OtherSideURL = Destinations[0];
}

function Trigger( actor Other, Pawn EventInstigator )
{
	local int nextPick;
	if (numDestinations == 0)
		return;

	nextPick = 0;
	While( (nextPick < 8) && (Destinations[nextPick] != OtherSideURL )  )
		nextPick++;

	nextPick++;
	if ( (nextPick > 7) || (Destinations[nextPick] == "") )
		nextPick = 0;

	OtherSideURL = Destinations[nextPick];
	ForceGenerate();
}

// Set up this warp zone's destination.
simulated event Generate()
{
	if( OtherSideLevel != None )
		return;
	ForceGenerate();
}

// Set up this warp zone's destination.
simulated event ForceGenerate()
{
	if( InStr(OtherSideURL,"/") >= 0 )
	{
		// Remote level.
		//log( "Warpzone " $ Self $ " remote" );
		OtherSideLevel = None;
		OtherSideActor = None;
	}
	else
	{
		// Local level.
		OtherSideLevel = XLevel;
		foreach AllActors( class 'WarpZoneInfo', OtherSideActor )
			if( string(OtherSideActor.ThisTag)~=OtherSideURL && OtherSideActor!=Self )
				break;
		//log( "Warpzone " $ Self $ " local, connected to " $ OtherSideActor );
	}
}

// When an actor enters this warp zone.
simulated function ActorEntered( actor Other )
{
	local vector L;
	local rotator R;
	local Controller P;

	//if ( Other.Role == ROLE_AutonomousProxy )
	//	return; // don't simulate for client players
	if( !Other.bJustTeleported )
	{
		Generate();
		if( OtherSideActor != None )
		{
			// This needs to also perform a coordinate system transformation,
			// in case the portals aren't directionally aligned. This is easy to
			// do but UnrealScript doesn't provide coordinate system operators yet.
			Other.Disable('Touch');
			Other.Disable('UnTouch');

			L = Other.Location;
			if( Pawn(Other) != None )
				R = Pawn(Other).GetViewRotation();

			UnWarp( L, Other.Velocity, R );
			OtherSideActor.Warp( L, Other.Velocity, R );

			if( Other.IsA('Pawn') )
			{
				Pawn(Other).bWarping = bNoTelefrag;
				if ( Other.SetLocation(L) )
				{
					//tell enemies about teleport
					if ( Role == ROLE_Authority )
						For ( P=Level.ControllerList; P!=None; P=P.NextController )
							if (P.Enemy == Other)
								P.LineOfSightTo(Other);
					R.Roll = 0;
					Pawn(Other).SetViewRotation(R);
					Pawn(Other).ClientSetLocation(L, R );
					if ( Pawn(Other).Controller != None )
						Pawn(Other).Controller.MoveTimer = -1.0;
				}
				else
				{
					// set up to keep trying to teleport
					GotoState('DelayedWarp');
				}
			}
			else
			{
				Other.SetLocation(L);
				Other.SetRotation( R );
			}
			Other.Enable('Touch');
			Other.Enable('UnTouch');
			// Change rotation according to portal's rotational change.
		}
	}
}

event ActorLeaving( actor Other )
{
	If ( Other.IsA('Pawn') )
		Pawn(Other).bWarping = false;
}

State DelayedWarp
{
	function Tick(float DeltaTime)
	{
		local Controller P;
		local bool bFound;

		For ( P=Level.ControllerList; P!=None; P=P.NextController )
			if ( P.Pawn.bWarping && (P.Pawn.Region.Zone == Self) )
			{
				bFound = true;
				ActorEntered(P);
			}

		If ( !bFound )
			GotoState('');
	}
}

defaultproperties
{
	Texture=Texture'Engine.S_ZoneWarp'
}
//=============================================================================
// WarpZoneMarker.
//=============================================================================
class WarpZoneMarker extends SmallNavigationPoint
	native;



var WarpZoneInfo markedWarpZone;

// AI related
var Actor TriggerActor;		//used to tell AI how to trigger me
var Actor TriggerActor2;

function PostBeginPlay()
{
	if ( markedWarpZone.numDestinations > 1 )
		FindTriggerActor();
	Super.PostBeginPlay();
}

function FindTriggerActor()
{
	local ZoneTrigger Z;
	ForEach AllActors(class 'ZoneTrigger', Z)
		if ( Z.Event == markedWarpZone.ZoneTag)
		{
			TriggerActor = Z;
			return;
		}
}

/* SpecialHandling is called by the navigation code when the next path has been found.
It gives that path an opportunity to modify the result based on any special considerations
*/

/* FIXME - how to figure out if other side actor is OK and use intelligently for all dests?
*/
function Actor SpecialHandling(Pawn Other)
{
	if (Other.Region.Zone == markedWarpZone)
		markedWarpZone.ActorEntered(Other);
	return self;
}
/*	if ( markedWarpZone.numDestinations <= 1 )
		return self;

	if ( markedWarpZone.OtherSideActor is OK )
		return self;

	if (TriggerActor == None)
	{
		FindTriggerActor();
		if (TriggerActor == None)
			return None;
	}

	return TriggerActor;
}
*/

defaultproperties
{
     bCollideWhenPlacing=False
	 bHiddenEd=true
}
//=============================================================================
// WayBeacon.
//=============================================================================
class WayBeacon extends Keypoint
	notplaceable;



defaultproperties
{
	bObsolete=true
}
class Weapon extends Inventory
    abstract
    native
    nativereplication;



const NUM_FIRE_MODES = 3;

var() class<WeaponFire> FireModeClass[NUM_FIRE_MODES];
var() editinline WeaponFire FireMode[NUM_FIRE_MODES];
var() Ammunition Ammo[NUM_FIRE_MODES];

// animation //
var() Name IdleAnim[3];
var() Name RestAnim;
var() Name AimAnim;
var() Name RunAnim;
var() Name SelectAnim;
var() Name PutDownAnim;
var() Name PutDownAnimQuick;
var() Name ZoomInAnim;
var() Name ZoomOutAnim;

var() float IdleAnimRate;
var() float RestAnimRate;
var() float AimAnimRate;
var() float RunAnimRate;
var() float SelectAnimRate;
var() float	SelectAnimReadyDelay;
var() float PutDownAnimRate;
var() float	PutDownAnimReadyDelay;
var() float PutDownAnimQuickRate;
var() float	PutDownAnimQuickReadyDelay;

// sounds //
var() Sound SelectSound;

// AI //
var()	int		BotMode; // the fire Mode currently being used for bots
var()	float	AIRating;
var		bool	bStationary;	// GBX:naj - added 7/30/03 - for turret weapons.
var()	bool	bMeleeWeapon;
var()	bool	bSniping;
var()	bool	bCanThrow;
var()	bool	bForceSwitch; // if true, this weapon will prevent any other weapon from delaying the switch to it (bomb launcher)
var		bool	bForceReload;
var		bool	m_fCanSprint; // GBX:PAD: Can the pawn sprint while carrying this weapon?
var		bool	m_fZoomed;		// GBX:PAD: Player is in zoomed in mode on this weapon.
var		bool	bMpKarmaWeaponDrops; // Use karma for weapon drops in multiplayer
var		bool	bAimingAtFriendly;	// The weapon is currently aiming at a friendly soldier, so don't allow the trigger to be pulled.
var		float	CurrentRating;	// rating result from most recent RateSelf()

// other useful stuff //
var() vector EffectOffset; // where muzzle flashes and smoke appear. replace by bone reference eventually
var() Localized string MessageNoAmmo;
var() float DisplayFOV;
var() enum EWeaponClientState
{
    WS_None,
    WS_Hidden,
    WS_BringUp,
    WS_PutDown,
    WS_ReadyToFire,
	WS_Reloading,
	WS_ZoomIn,
	WS_ZoomOut,
	WS_Disarmed,
	WS_ThrowGrenade,
	WS_Melee
} ClientState; // this will always be None on the server

var() config byte ExchangeFireModes;

var float hand;

// amb ---
var() config byte Priority;
// --- amb

// gam ---
var() int IconGroup; // 0 => Ungrouped. Allows for
// --- gam

var transient bool bPendingSwitch;
var() float   FireRateAtten;	// sjs

var	Weapon	OldWeapon;
var string	LeftHandedMesh;		// string of name of left-handed view mesh (if different)
var	texture	CrossHair;
var float	TraceDist;
var	int     DefaultAmmoCount[NUM_FIRE_MODES];		// Amount of ammo initially in pick-up item.

// messages
var   Localized string WeaponDescription;
var   Color NameColor;	// used when drawing name on HUD

// GBX:naj - added 10/15/03 - To prevent pawns from reloading until they're ready to.
var bool	bDelayReloading;

// ammo //
// GBX:PAD: I'm moving this stuff over from WeaponFire to Weapon because it's easier to maintain it here.
var() int AmmoClipSize;
var() int ClipAmt;
var() int DroppedAmmoCount[NUM_FIRE_MODES];

// GBX:PAD: Percent by which this weapon reduces the maximum speed of the character actively using it.
var float				m_flEncumberance;
// GBX:PAD: Percent by which this weapon reduces the maximum speed of the character when the weapon is sited.
var float				m_flSiteEncumberance;

var float				m_flDrawOffset;		// Used to offset the view model a certain amount if "bumping" against things
var float				m_flPctOffset;		// What percent of this offset should we apply?
var float				m_flMinOffset;		// Minimum offset by which to retract gun.

// GEARBOX: PSV 5/3/2004 Automatic weapons can fire on different slots
var ESoundSlot			m_eNextWeaponSoundSlot;
var bool				m_bIsAutomatic;

var bool				m_fDestroyWhenEmpty;	// When there are no more shots for this weapon, go ahead and remove it from inventory
var bool				m_fDestroyAfterSwitch;	// Destroy this weapon after it is switched out.

var int					m_nLastPitch;
var int					m_nDesiredPitch;		// Used for dropping the pitch of the weapon when looking at a friendly soldier

var AttachedPart		m_anExtendedActor;		// Used to store the model for the extended attachment of this view model

var int					localClipAmt; // used to fix a problem where lag can cause the client to think they are out of ammo to early.
native simulated event RenderOverlays( Canvas Canvas );


// Network replication
//
replication
{
    // Things the server should send to the client.
    reliable if(  bNetDirty && ( Role==ROLE_Authority ) )
        Ammo, FireRateAtten, ClientState, ClipAmt;

    // Functions called by server on client
    reliable if( Role==ROLE_Authority )
        ClientWeaponSet, ClientWeaponThrown, ClientForceReload;

    // functions called by client on server
    reliable if( Role<ROLE_Authority )
        ServerStartFire, ServerStopFire, ServerForceReload;
}

function PostBeginPlay()
{
	ClipAmt = AmmoClipSize;
	Super.PostBeginPlay();
	
	//SDJ 03/03/2004: With the below change it is to possible to create a ThirdPersonActor when the corresponding 
	//                Weapon does not have a valid Instigator.  This breaks impact and muzzle effects until the
	//                ThirdPersonActor is recreated after switching away and then back to this Weapon. If we enounter
	//                and verify what this change was supposed to fix then we can reconsider what the real problem is.
/*
	// GBX:PAD: I added this in since, previously, this was being spawned as part of the AttachToPawn function.
	// The problem there was that code that needs to be called on the client was immediatly being called after,
	// so it would fail since the attachment wasn't "spawned" yet.	
	if (Level.NetMode != NM_Client)
	{
		ThirdPersonActor = Spawn(AttachmentClass,Owner);
		
		InventoryAttachment(ThirdPersonActor).InitFor(self);
	}
*/
}

//=================================================================
// AI functions

function float RangedAttackTime()
{
	return 0;
}

function bool RecommendRangedAttack()
{
	return false;
}

function bool FocusOnLeader()
{
	return false;
}

function bool OKToFire()  //NAC: implement in subclasses
{
	return true;
}

function FireHack(byte Mode);

// return true if weapon effect has splash damage (if significant)
// use by bot to avoid hurting self
// should be based on current firing Mode if active
function bool SplashDamage()
{
    return FireMode[Max(0,BotMode)].bSplashDamage;
}

// return true if weapon should be fired to take advantage of splash damage
// For example, rockets should be fired at enemy feet
function bool RecommendSplashDamage()
{
    return FireMode[Max(0,BotMode)].bRecommendSplashDamage;
}

function float GetDamageRadius()
{
    if (FireMode[Max(0,BotMode)].ProjectileClass == None)
        return 0;
    else
        return FireMode[Max(0,BotMode)].ProjectileClass.default.DamageRadius;
}

// Repeater weapons like minigun should be 0.99, other weapons based on likelihood
// of firing again right away
function float RefireRate()
{
    return FireMode[Max(0,BotMode)].BotRefireRate * FireRateAtten;
}

simulated function bool IsAutomatic()
{
	return m_bIsAutomatic;
}

simulated function DisplayDebug(Canvas Canvas, out float YL, out float YPos)
{
    local int i;
    local string T;
    local name Anim;
    local float frame,rate;

    Canvas.SetDrawColor(0,255,0);
    Canvas.DrawText("WEAPON "$GetItemName(string(self)), false, 0.9, 0.9);
    YPos += YL;
    Canvas.SetPos(4,YPos);

    T = "     STATE: "$GetStateName()$" Timer: "$TimerCounter;

    Canvas.DrawText(T, false, 0.9, 0.9);
    YPos += YL;
    Canvas.SetPos(4,YPos);

    if ( DrawType == DT_StaticMesh )
        Canvas.DrawText("     StaticMesh "$GetItemName(string(StaticMesh))$" AmbientSound "$AmbientSound, false, 0.9, 0.9);
    else
        Canvas.DrawText("     Mesh "$GetItemName(string(Mesh))$" AmbientSound "$AmbientSound, false, 0.9, 0.9);
    YPos += YL;
    Canvas.SetPos(4,YPos);
    if ( Mesh != None )
    {
        // mesh animation
        GetAnimParams(0,Anim,frame,rate);
        T = "     AnimSequence "$Anim$" Frame "$frame$" Rate "$rate;
        if ( bAnimByOwner )
            T= T$" Anim by Owner";

        Canvas.DrawText(T, false, 0.9, 0.9);
        YPos += YL;
        Canvas.SetPos(4,YPos);
    }

    for ( i=0; i<NUM_FIRE_MODES; i++ )
    {
        if ( FireMode[i] == None )
        {
            Canvas.DrawText("NO FIREMODE "$i, false, 0.9, 0.9);
            YPos += YL;
            Canvas.SetPos(4,YPos);
        }
        else
            FireMode[i].DisplayDebug(Canvas,YL,YPos);

        if ( Ammo[i] == None )
        {
            Canvas.DrawText("NO AMMO "$i, false, 0.9, 0.9);
            YPos += YL;
            Canvas.SetPos(4,YPos);
        }
        else
            Ammo[i].DisplayDebug(Canvas,YL,YPos);
    }
}

simulated function Weapon RecommendWeapon( out float rating, optional bool bForceIfLast )
{
    local Weapon Recommended;
    local float oldRating;

    if( (Instigator == None) || (Instigator.Controller == None) )
        rating = -2;
    else
        rating = RateSelf() + Instigator.Controller.WeaponPreference(self);

    if ( inventory != None )
    {
        Recommended = inventory.RecommendWeapon(oldRating);
        if ( (Recommended != None) && (oldRating > rating) )
        {
            rating = oldRating;
            return Recommended;
        }
    }
    return self;
}

function SetAITarget(Actor T);

/* BestMode()
choose between regular or alt-fire
*/
function byte BestMode()
{
	if ( Instigator.Controller.bFire != 0 )
		return 0;
	else if ( Instigator.Controller.bAltFire != 0 )
		return 1;
	if ( FRand() < 0.5 )
		return 1;
	return 0;
}

/* BotFire()
called by NPC firing weapon. Weapon chooses appropriate firing Mode to use (typically no change)
bFinished should only be true if called from the Finished() function
FiringMode can be passed in to specify a firing Mode (used by scripted sequences)
*/
/*function bool BotFire(bool bFinished, optional name FiringMode)
{
    local int newmode;
    local Controller C;

    C = Instigator.Controller;
	newMode = BestMode();

    if ( newMode == BotMode && FireMode[newMode].bIsFiring )
        return true;

    if ( !ReadyToFire(newMode) || ClientState != WS_ReadyToFire )
		return false;

    if ( newMode == 0 )
    {
        C.bFire = 1;
        C.bAltFire = 0;
    }
    else
    {
        C.bFire = 0;
        C.bAltFire = 1;
    }

    if ( BotMode != -1 )
            StopFire(BotMode);

    StartFire(NewMode);

    BotMode = NewMode;

    return true;
}*/
function bool BotFire(bool bFinished, optional name FiringMode)
{
    local int newmode;
    local Controller C;

    C = Instigator.Controller;
	newMode = BestMode();

	if ( newMode == 0 )
	{
		C.bFire = 1;
		C.bAltFire = 0;
	}
	else
	{
		C.bFire = 0;
		C.bAltFire = 1;
	}

	if ( bFinished )
		return true;

    if ( FireMode[BotMode].bIsFiring )
		StopFire(BotMode);

    if ( !ReadyToFire(newMode) || ClientState != WS_ReadyToFire || ClientState == WS_Reloading )
		return false;

    StartFire(NewMode);
    BotMode = NewMode;
    return true;
}


// this returns the actual projectile spawn location or trace start
simulated function vector GetFireStart(vector X, vector Y, vector Z)
{
    return FireMode[Max(0,BotMode)].GetFireStart(X,Y,Z);
}

simulated function float AmmoStatus() // returns float value for ammo amount
{
    if (Ammo[0] == None)
        return 0.0;
    else
	    return float(Ammo[0].AmmoAmount) / float(Ammo[0].MaxAmmo);
}

// need to figure out modified rating based on enemy/tactical situation
simulated function float RateSelf()
{
    if ( !HasAmmo() )
        CurrentRating = -2;
	else
		CurrentRating = Instigator.RateWeapon(self);
	return CurrentRating;
}

function float GetAIRating()
{
	return AIRating;
}

// tells bot whether to charge or back off while using this weapon
function float SuggestAttackStyle()
{
    return 0.0;
}

// tells bot whether to charge or back off while defending against this weapon
function float SuggestDefenseStyle()
{
    return 0.0;
}

// return true if recommend jumping while firing to improve splash damage (by shooting at feet)
// true for R.L., for example
function bool SplashJump()
{
    return FireMode[Max(0,BotMode)].bSplashJump;
}

simulated function DrawCrossHair( canvas Canvas)
{
	local float XLength;

	if ( CrossHair == None )
		return;
	XLength = 32.0;
	Canvas.bNoSmooth = False;
	Canvas.SetPos(0.503 * (Canvas.ClipX - XLength), 0.504 * (Canvas.ClipY - XLength));
	Canvas.Style = ERenderStyle.STY_Translucent;
	Canvas.SetDrawColor(255,255,255);
	Canvas.DrawTile(CrossHair, XLength, XLength, 0, 0, 32, 32);
	Canvas.bNoSmooth = True;
	Canvas.Style = Style;
}

// return false if out of range, can't see target, etc.
function bool CanAttack(Actor Other)
{
    local float Dist, CheckDist;
    local vector HitLocation, HitNormal,X,Y,Z, projStart;
    local actor HitActor;
    local int m;
	local bool bInstantHit;

    if ( (Instigator == None) || (Instigator.Controller == None) )
        return false;

    // check that target is within range
    Dist = VSize(Instigator.Location - Other.Location);
    if ( (Dist > FireMode[0].MaxRange()) && (Dist > FireMode[1].MaxRange()) )
        return false;

    // check that can see target
    if ( !Instigator.Controller.LineOfSightTo(Other) )
        return false;

    for (m = 0; m < NUM_FIRE_MODES; m++)
    {
		if ( FireMode[m].bInstantHit )
			bInstantHit = true;
		else
		{
			CheckDist = FMax(CheckDist, 0.5 * FireMode[m].ProjectileClass.Default.Speed);
	        CheckDist = FMax(CheckDist, 300);
	        CheckDist = FMin(CheckDist, VSize(Other.Location - Location));
		}
	}
    // check that would hit target, and not a friendly
    GetAxes(Instigator.Controller.Rotation, X,Y,Z);
    projStart = GetFireStart(X,Y,Z);
    if ( bInstantHit )
        HitActor = Trace(HitLocation, HitNormal, Other.Location + Other.CollisionHeight * vect(0,0,0.8), projStart, true);
    else
    {
        // for non-instant hit, only check partial path (since others may move out of the way)
        HitActor = Trace(HitLocation, HitNormal,
                projStart + CheckDist * Normal(Other.Location + Other.CollisionHeight * vect(0,0,0.8) - Location),
                projStart, true);
    }

    if ( (HitActor == None) || (HitActor == Other) || (Pawn(HitActor) == None)
		|| (Pawn(HitActor).Controller == None) || !Instigator.Controller.SameTeamAs(Pawn(HitActor).Controller) )
        return true;

    return false;
}


//=================================================================

simulated function PostNetBeginPlay()
{
    local int m;

    Super.PostNetBeginPlay();

    for (m = 0; m < NUM_FIRE_MODES; m++)
    {
        if (FireModeClass[m] != None)
        {
            FireMode[m] = Spawn(FireModeClass[m], self);
            FireMode[m].ThisModeNum = m;
            FireMode[m].Weapon = self;
            FireMode[m].Instigator = Instigator;
        }
    }

	m_anExtendedActor = Spawn( class'AttachedPart', self );
	if (Level.NetMode == NM_StandAlone)
	{
		if (((Instigator != None) && (Instigator.m_fFingerMissing)) || Level.bHartsockWounded)
		{
			ExtendedAttachment( m_anExtendedActor, 'hands', 'hands_bandage' );
		}
		else
		{
			ExtendedAttachment( m_anExtendedActor, 'hands', 'hands' );
		}
	}
	else
	{
		ExtendedAttachment( m_anExtendedActor, 'hands', 'hands_MP' );
	}
}

simulated event Destroyed()
{
    local int m;

    AmbientSound = None;

    for (m = 0; m < NUM_FIRE_MODES; m++)
    {
        if (FireMode[m] != None)
        {
            FireMode[m].Weapon = None;
            FireMode[m].Destroy();
            FireMode[m] = None;
        }
        if (Ammo[m] != None)
        {
            Ammo[m].Destroy();
            Ammo[m] = None;
        }
    }

	Instigator = None;  // prevent references to/in destroyed objects

    super.Destroyed();
}

simulated function Reselect()
{
}

simulated function SetHand(float InHand)
{
    Hand = InHand;
}

// GBX:naj - removed 8/6/03 - useless function.
simulated function GetViewAxes( out vector xaxis, out vector yaxis, out vector zaxis )
{
    if ( Instigator.Controller == None )
        GetAxes( Instigator.Rotation, xaxis, yaxis, zaxis );
    else
        GetAxes( Instigator.Controller.Rotation, xaxis, yaxis, zaxis );
}

simulated function vector GetEffectStart()
{
    local Vector X,Y,Z;

    // jjs - this function should actually never be called in third person views
    // any effect that needs a 3rdp weapon offset should figure it out itself

    // 1st person
    if (Instigator.IsFirstPerson())
    {
        //GetViewAxes(X, Y, Z);
		GetAxes( Instigator.GetViewRotation(), X, Y, Z );
        return (Instigator.Location +
            Instigator.CalcDrawOffset(self) +
            EffectOffset.X * X +
            EffectOffset.Y * Y +
            EffectOffset.Z * Z);
    }
    // 3rd person
    else
    {
		log("Attempt to call GetEffectStart() with a 3rd person Pawn.", 'ScriptWarning');
        /*
		GetViewAxes(X, Y, Z);
        return (Instigator.Location +
            Instigator.EyeHeight*Vect(0,0,0.5) +
            Vector(Instigator.Rotation) * 40.0);
		*/
    }
}

simulated function IncrementFlashCount(int Mode)
{
	local WeaponAttachment WA;
    if ( ThirdPersonActor.IsA('WeaponAttachment') )
    {
		WA = WeaponAttachment(ThirdPersonActor);
        WA.FiringMode = Mode;
        ThirdPersonActor.NetUpdateTime = Level.TimeSeconds - 1;
        WA.FlashCount++;
        WA.ThirdPersonEffects();
    }
}

simulated function ZeroFlashCount(int Mode)
{
	local WeaponAttachment WA;
    if ( ThirdPersonActor != None && ThirdPersonActor.IsA('WeaponAttachment') )
    {
		WA = WeaponAttachment(ThirdPersonActor);
        WA.FiringMode = Mode;
        ThirdPersonActor.NetUpdateTime = Level.TimeSeconds - 1;
        WA.FlashCount = 0;
        WA.ThirdPersonEffects();
    }
}

simulated function Weapon WeaponChange( byte F, bool bSilent, optional Inventory LastCheck )
{
    local Weapon newWeapon;

    if ( InventoryGroup == F )
    {
        if ( !HasAmmo() )
        {
            if ( Inventory == None )
                newWeapon = None;
            else
                newWeapon = Inventory.WeaponChange(F, bSilent, LastCheck);

            if ( !bSilent && (newWeapon == None) && Instigator.IsHumanControlled() )
            {
                Instigator.ClientMessage( ItemName$MessageNoAmmo );
            }

            return newWeapon;
        }
        else
            return self;
    }
    else if ( Inventory == None )
        return None;
    else
        return Inventory.WeaponChange(F, bSilent, LastCheck);
}

simulated function Weapon PrevWeapon(Weapon CurrentChoice, Weapon CurrentWeapon)
{
    if ( HasAmmo() )
    {
        if ( (CurrentChoice == None) )
        {
            if ( CurrentWeapon != self )
                CurrentChoice = self;
        }
        else if ( InventoryGroup == CurrentChoice.InventoryGroup )
        {
            if ( InventoryGroup == CurrentWeapon.InventoryGroup )
            {
                if ( (GroupOffset < CurrentWeapon.GroupOffset)
                    && (GroupOffset > CurrentChoice.GroupOffset) )
                    CurrentChoice = self;
            }
            else if ( GroupOffset > CurrentChoice.GroupOffset )
                CurrentChoice = self;
        }
        else if ( InventoryGroup > CurrentChoice.InventoryGroup )
        {
            if ( (InventoryGroup < CurrentWeapon.InventoryGroup)
                || (CurrentChoice.InventoryGroup > CurrentWeapon.InventoryGroup) )
                CurrentChoice = self;
        }
        else if ( (CurrentChoice.InventoryGroup > CurrentWeapon.InventoryGroup)
                && (InventoryGroup < CurrentWeapon.InventoryGroup) )
            CurrentChoice = self;
    }
    if ( Inventory == None )
        return CurrentChoice;
    else
        return Inventory.PrevWeapon(CurrentChoice,CurrentWeapon);
}

simulated function Weapon NextWeapon(Weapon CurrentChoice, Weapon CurrentWeapon)
{
    if ( HasAmmo() )
    {
        if ( (CurrentChoice == None) )
        {
            if ( CurrentWeapon != self )
                CurrentChoice = self;
        }
        else if ( InventoryGroup == CurrentChoice.InventoryGroup )
        {
            if ( InventoryGroup == CurrentWeapon.InventoryGroup )
            {
                if ( (GroupOffset > CurrentWeapon.GroupOffset)
                    && (GroupOffset < CurrentChoice.GroupOffset) )
                    CurrentChoice = self;
            }
            else if ( GroupOffset < CurrentChoice.GroupOffset )
                CurrentChoice = self;
        }

        else if ( InventoryGroup < CurrentChoice.InventoryGroup )
        {
            if ( (InventoryGroup > CurrentWeapon.InventoryGroup)
                || (CurrentChoice.InventoryGroup < CurrentWeapon.InventoryGroup) )
                CurrentChoice = self;
        }
        else if ( (CurrentChoice.InventoryGroup < CurrentWeapon.InventoryGroup)
                && (InventoryGroup > CurrentWeapon.InventoryGroup) )
            CurrentChoice = self;
    }
    if ( Inventory == None )
        return CurrentChoice;
    else
        return Inventory.NextWeapon(CurrentChoice,CurrentWeapon);
}


function HolderDied()
{
    local int m;

    for (m = 0; m < NUM_FIRE_MODES; m++)
    {
        if (FireMode[m].bIsFiring)
        {
            StopFire(m);
            if (FireMode[m].bFireOnRelease)
                FireMode[m].ModeDoFire();
        }
    }
}

simulated function bool CanThrow()
{
    return (bCanThrow && (ClientState == WS_ReadyToFire || Level.NetMode == NM_DedicatedServer) && (ClientState != WS_Reloading));
}

function DropFrom( vector StartLocation )
{
    local int m;
	local Pickup Pickup;
	local vector impulseVector;

// GBX:PAD: Removing the HasAmmo check because, if there is no ammo in this weapon, we should be able to throw it down
// Since we probably don't want it.
//    if (!bCanThrow || !HasAmmo())
    if (!bCanThrow)
        return;

    ClientWeaponThrown();

    for (m = 0; m < NUM_FIRE_MODES; m++)
    {
        if (FireMode[m].bIsFiring)
            StopFire(m);
    }

	if ( Instigator != None )
	{
		DetachFromPawn(Instigator);
	}

	Log( "****SJP: Dropped weapon: Spawning pickup class "$PickupClass, 'SJP' );

	Pickup = Spawn(PickupClass,,,StartLocation, Pawn(Owner).Rotation );

	// If this did not spawn, then lets try again, but we will move it up some.
	if (Pickup == None)
	{
		log ("Dropped weapon: Failed to spawn pickup class " $PickupClass$ ".  Respawning", 'CRG');
		Pickup = Spawn(PickupClass,,,StartLocation + vect(0,0,200), Pawn(Owner).Rotation );
		if (Pickup == None)
			log("Dropped weapon: 2nd attempt to spawn " $PickupClass$ " failed.  Not Spawing",'CRG');
	}

	if ( Pickup != None )
	{
    	Pickup.InitDroppedPickupFor(self);

		// Turn on physics in single player
		if ( Level.NetMode == NM_StandAlone || bMpKarmaWeaponDrops )
		{
			if( Pawn(Owner).IsFirstPerson() )
			{
				impulseVector = Velocity;
			}
			else
			{
				impulseVector = vect(0,0,0);
			}

			Pickup.AddPhysics( Pawn(Owner), impulseVector );
		}

        if (WeaponPickup(Pickup) != None)
        {
			if (Instigator.Health > 0)
				WeaponPickup(Pickup).bThrown = true;

			WeaponPickup(Pickup).AmmoAmount[0] = Ammo[0].AmmoAmount;
			WeaponPickup(Pickup).ClipAmount[0] = ClipAmt;
        }
    }

    Destroy();
}

simulated function ClientWeaponThrown()
{
    local int m;

    AmbientSound = None;

    if( Level.NetMode != NM_Client )
        return;

    Instigator.DeleteInventory(self);
    for (m = 0; m < NUM_FIRE_MODES; m++)
    {
        if (Ammo[m] != None)
        {
            Instigator.DeleteInventory(Ammo[m]);
        }
    }
}

function bool GiveTo(Pawn Other, optional Pickup Pickup)
{
    local int m;
    local weapon w;
    local bool bPossiblySwitch, bGiveDefaultAmmo;
	local int nGive;
	local bool bLoaded;

    Instigator = Other;

    w = Weapon(Instigator.FindInventoryType(class));
    if (w == None)
    {
        Super.GiveTo(Other);
        bPossiblySwitch = true;
    }
    else
    {
        if (!W.HasAmmo())
            bPossiblySwitch = true;
    }

    if ( PlayerController(Instigator.Controller) != None && PlayerController(Instigator.Controller).bNeverSwitchOnPickup )
        bPossiblySwitch = false;

    if ( Pickup == None )
        bPossiblySwitch = true;

    for (m = 0; m < NUM_FIRE_MODES; m++)
    {
		bGiveDefaultAmmo = false;
		bLoaded = true;
        if (FireMode[m] != None)
        {
            FireMode[m].Instigator = Instigator;

            if (Pickup != None)
            {
                DroppedAmmoCount[m] = WeaponPickup(Pickup).AmmoAmount[m];
                if ((m == 0) && (WeaponPickup(Pickup).ClipAmount[m] > 0))
					ClipAmt = WeaponPickup(Pickup).ClipAmount[m];
				if ((m == 0) && (DroppedAmmoCount[m] == 0) && (WeaponPickup(Pickup).ClipAmount[m] == 0))
					bLoaded = false;
            }

			if (DroppedAmmoCount[m] == 0)
				bGiveDefaultAmmo = true;
			GiveAmmo(m);
			if (bGiveDefaultAmmo)
			{
				if (DefaultAmmoCount[m] > 0)
				{
					nGive = min( Ammo[m].MaxAmmo - Ammo[m].AmmoAmount, DefaultAmmoCount[m] );
					Ammo[m].AmmoAmount = Ammo[m].AmmoAmount + nGive;
					DefaultAmmoCount[m] = DefaultAmmoCount[m] - nGive;
				}
			}
			if (!bLoaded)
			{
				Ammo[m].AmmoAmount = 0;
				ClipAmt = 0;
			}
        }
    }
/*
	for (m = 0; m < NUM_FIRE_MODES; m++)
	{
		if ((DefaultAmmoCount[m] > 0) && (DroppedAmmoCount[m] == 0))
		{
			nGive = min( Ammo[m].MaxAmmo - Ammo[m].AmmoAmount, DefaultAmmoCount[m] );
			Ammo[m].AmmoAmount = Ammo[m].AmmoAmount + nGive;
			DefaultAmmoCount[m] = DefaultAmmoCount[m] - nGive;
		}
	}
*/
    ClientWeaponSet(bPossiblySwitch);
    
    //SDJ 06/08/2004: The server needs to a bit more management of this state for a client's weapons.
    if ((Role == ROLE_Authority) && (ClientState == WS_None) && (Instigator != None))
	{
		if (Instigator.IsLocallyControlled() == false)
		{
			ClientState = WS_Hidden;
		}
	}
	
	return true;
}

function GiveAmmo(int m)
{
    local bool bJustSpawnedAmmo;
    local int addAmount;

    if ( FireMode[m] != None && FireMode[m].AmmoClass != None )
    {
		if ( Instigator != None )
			Ammo[m] = Ammunition(Instigator.FindInventoryType(FireMode[m].AmmoClass));

        if ( Ammo[m] == None )
        {
            Ammo[m] = Spawn(FireMode[m].AmmoClass, FireMode[m]);
			if ( Instigator != None )
				Instigator.AddInventory(Ammo[m]);
            bJustSpawnedAmmo = true;
        }

        if (bJustSpawnedAmmo || m == 0)
        {
            if (DroppedAmmoCount[m] > 0)
            {
                addAmount = DroppedAmmoCount[m];
                DroppedAmmoCount[m] = 0;
            }
            else
            {
                addAmount = Ammo[m].InitialAmount;
            }

            Ammo[m].AddAmmo(addAmount);
            Ammo[m].GotoState('');
        }
    }
}

simulated function ClientWeaponSet(bool bPossiblySwitch)
{
    local int Mode;

    Instigator = Pawn(Owner);

    bPendingSwitch = bPossiblySwitch;

    if( Instigator == None )
    {
        GotoState('PendingClientWeaponSet');
        return;
    }

    for( Mode = 0; Mode < NUM_FIRE_MODES; Mode++ )
    {
        if( FireModeClass[Mode] != None )
        {
            if( ( FireMode[Mode] == None ) || ( FireMode[Mode].AmmoClass != None ) && ( Ammo[Mode] == None ) )
            {
                GotoState('PendingClientWeaponSet');
                return;
            }
        }

		if (FireMode[Mode] != None)
			FireMode[Mode].Instigator = Instigator;
    }

    ClientState = WS_Hidden;
    GotoState('Hidden');

    if( Level.NetMode == NM_DedicatedServer || !Instigator.IsHumanControlled() )
        return;

    if( Instigator.Weapon == self || Instigator.PendingWeapon == self ) // this weapon was switched to while waiting for replication, switch to it now
    {
        if (Instigator.PendingWeapon != None)
		{
            Instigator.ChangedWeapon();
		}
        else
        {
            BringUp();
        }
        return;
    }

	if( Instigator.PendingWeapon != None && Instigator.PendingWeapon.bForceSwitch ){    
		return;
	}

    if( Instigator.Weapon == None )
    {
        Instigator.PendingWeapon = self;
        Instigator.ChangedWeapon();
    }
    else if ( bPossiblySwitch )
    {
        if ( Instigator.PendingWeapon != None )
        {
            if ( RateSelf() > Instigator.PendingWeapon.RateSelf() )
            {
                Instigator.PendingWeapon = self;
                Instigator.Weapon.PutDown();
            }
        }
        else if ( RateSelf() > Instigator.Weapon.RateSelf() )
        {
            Instigator.PendingWeapon = self;
            Instigator.Weapon.PutDown();
        }
    }
}

simulated function BringUp(optional Weapon PrevWeapon)
{
    if (ClientState == WS_Hidden)
    {
        PlayOwnedSound(SelectSound, SLOT_Interact, 0.5,,,, false);

        if (Instigator.IsLocallyControlled())
        {
            if (HasAnim(SelectAnim))
			{
                PlayAnim(SelectAnim, SelectAnimRate, 0.0);
			}
        }
        if (Level.NetMode == NM_StandAlone)
        {
			if (((Instigator != None) && (Instigator.m_fFingerMissing)) || Level.bHartsockWounded)
			{
				ExtendedAttachment( m_anExtendedActor, 'hands', 'hands_bandage' );
			}
			else
			{
				ExtendedAttachment( m_anExtendedActor, 'hands', 'hands' );
			}
		}
		else
		{
			ExtendedAttachment( m_anExtendedActor, 'hands', 'hands_MP' );
		}
        
//        if (WeaponAttachment(ThirdPersonActor) != None)
//			IncrementFlashCount(WeaponAttachment(ThirdPersonActor).WEAP_StateDeploy);
        ClientState = WS_BringUp;
        
        SetTimer(SelectAnimReadyDelay, false);
    }
    if (WeaponAttachment(ThirdPersonActor) != None)
		WeaponAttachment( ThirdPersonActor ).SetupInstigatorProperties();
}

simulated function bool PutDown()
{
    local int Mode;

    if (ClientState == WS_BringUp || ClientState == WS_ReadyToFire)
    {
        if (Instigator.PendingWeapon == None || !Instigator.PendingWeapon.bForceSwitch)
        {
            for (Mode = 0; Mode < NUM_FIRE_MODES; Mode++)
            {
                if (FireMode[Mode].bFireOnRelease && FireMode[Mode].bIsFiring)
                    return false;
            }
        }

        if (Instigator.IsLocallyControlled())
        {
            for (Mode = 0; Mode < NUM_FIRE_MODES; Mode++)
            {
                if (FireMode[Mode].bIsFiring)
                    ClientStopFire(Mode);
            }

			if (Instigator.Controller.IsA('PlayerController') && (PlayerController(Instigator.Controller).GameReplicationInfo.GameType == GT_Multiplayer))
			{
				if (ClientState != WS_BringUp && HasAnim(PutDownAnimQuick))
				{
					PlayAnim(PutDownAnimQuick, PutDownAnimQuickRate, 0.0);
				}
				else
				{
					if (ClientState != WS_BringUp && HasAnim(PutDownAnim))
					{
						PlayAnim(PutDownAnim, PutDownAnimRate, 0.0);
					}
				}
			}
			else
			{
				if (ClientState != WS_BringUp && HasAnim(PutDownAnim))
				{
					PlayAnim(PutDownAnim, PutDownAnimRate, 0.0);
				}
			}
        }

//        if (WeaponAttachment(ThirdPersonActor) != None)
//			IncrementFlashCount(WeaponAttachment(ThirdPersonActor).WEAP_StateHolster);
			
        ClientState = WS_PutDown;

		if (Instigator.Controller.IsA('PlayerController') && (PlayerController(Instigator.Controller).GameReplicationInfo.GameType == GT_Multiplayer))
		{
			if (HasAnim(PutDownAnimQuick))
			{
				SetTimer(PutDownAnimQuickReadyDelay, false);
			}
			else
			{
				SetTimer(PutDownAnimReadyDelay, false);
			}
		}
		else
		{
			SetTimer(PutDownAnimReadyDelay, false);
		}
    }
    return true; // return false if preventing weapon switch
}

simulated function bool DisarmWeapon( name BoneName )
{
    return false; // return false if preventing weapon switch
}

simulated function bool RearmWeapon( name BoneName )
{
	return false;
}

/*
simulated function Tick(float dt)
{
    if ((FireMode[0].bIsFiring || FireMode[1].bIsFiring) && Instigator.Weapon != self)
    {
        log(self@"firing while not active");
    }
}*/

simulated function Fire(float F)
{
}

simulated function AltFire(float F)
{
}

simulated function MeleeFire(float F)
{
}

simulated function PlayMeleeStrikeSound( Pawn Attacker );
simulated function PlayMeleeSwooshSound( Pawn Attacker );

simulated event WeaponTick(float dt); // only called on currently held weapon

// amb ---
simulated function OutOfAmmo()
{
	// GBX:PAD: I've moved this up since the server needs to worry about this also, so this weapon isn't locally
	// controlled for them.
	if (m_fDestroyWhenEmpty)
	{
		m_fDestroyAfterSwitch = true;
	}
	
    if (!Instigator.IsLocallyControlled())
        return;

    if (HasAmmo())
        return;

	DoAutoSwitch();
}

simulated function DoAutoSwitch()
{
    Instigator.Controller.SwitchToBestWeapon();
}
// --- amb

//// client only ////
simulated event ClientStartFire(int Mode)
{
    if (!Pawn(Owner).Controller.CanFire())
        return;

    if (Role < ROLE_Authority)
    {
        if (StartFire(Mode))
        {
            //Log("ClientStartFire"@Level.TimeSeconds);
            ServerStartFire(Mode);
        }
    }
    else
    {
        StartFire(Mode);
    }
}

simulated event ClientStopFire(int Mode)
{
    if (Role < ROLE_Authority)
    {
        //Log("ClientStopFire"@Level.TimeSeconds);
        StopFire(Mode);
    }
    ServerStopFire(Mode);
}

//// server only ////
event ServerStartFire(byte Mode)
{
    if (FireMode[Mode].NextFireTime > Level.TimeSeconds + FireMode[Mode].PreFireTime)
    {
        if (!FireMode[Mode].bIsFiring)
        {
            //log("Start Delayed");
            FireMode[Mode].bServerDelayStartFire = true;
        }
    }
    else if (StartFire(Mode))
    {
        //Log("ServerStartFire"@Level.TimeSeconds);
        FireMode[Mode].ServerStartFireTime = Level.TimeSeconds;
    }
}

function ServerStopFire(byte Mode)
{
    // if a stop was received on the same frame as a start then we need to delay the stop for one frame
    if (FireMode[Mode].bServerDelayStartFire || FireMode[Mode].ServerStartFireTime == Level.TimeSeconds)
    {
        //log("Stop Delayed");
        FireMode[Mode].bServerDelayStopFire = true;
    }
    else
    {
        //Log("ServerStopFire"@Level.TimeSeconds);
        StopFire(Mode);
    }
}

simulated function bool ReadyToFire(int Mode)
{
    local int alt;

    if (Mode == 0)
        alt = 1;
    else
        alt = 0;


       	if ( Level.bUseLegacyReadyToFire )
		{
		// GBX:naj - original code path
		if ( (FireMode[alt].bModeExclusive && FireMode[alt].bIsFiring)		
			|| (FireMode[Mode].NextFireTime > Level.TimeSeconds + FireMode[Mode].PreFireTime) 
			|| !FireMode[Mode].AllowFire() )
		{
			return false;
		}
		}
		else
		{
		// GBX:naj - new code path
		if ( (FireMode[alt].bModeExclusive && FireMode[alt].bIsFiring)		
			|| (FireMode[Mode].NextFireTime > Level.TimeSeconds + FireMode[Mode].PreFireTime) 
			|| !FireMode[Mode].ReadyToFire() )
		{
			return false;
		}
    }

	return true;
}

simulated function bool CanPlaySignalAnim()
{
    if ( ( (FireMode[1].bModeExclusive && FireMode[1].bIsFiring) ||
		   (FireMode[2].bModeExclusive && FireMode[2].bIsFiring) ||
		   (FireMode[0].NextFireTime < Level.TimeSeconds + FireMode[0].PreFireTime) ) &&
		   (m_flDrawOffset < 70)		// -BB If we are to close to a wall we don't play hand signals
       )
	{
		if (ClientState == WS_ReadyToFire)
		{
			return true;
		}
	}
	
	return false;
}

//// client & server ////
simulated function bool StartFire(int Mode)
{
    local int alt;

    //if (FireMode[Mode].bIsFiring)
    //    return true;

    if (!ReadyToFire(Mode))
        return false;

    if (Mode == 0)
        alt = 1;
    else
        alt = 0;

	if ((Mode == 0) && !AlwaysAutoReload())
	{
		if (NeedsToReload() && !bDelayReloading)
		{
			if ( !AlwaysAutoReload() && !(Instigator.Controller.ReloadAfterWeaponFire()))
			{
				FireMode[Mode].PlayDryFire();
			}
			else if (ClientState != WS_Reloading)
			{
				ClientForceReload();
//				FireMode[Mode].PlayReloading();
			}
			return false;
		}
	}
	
    FireMode[Mode].bIsFiring = true;
    FireMode[Mode].NextFireTime = Level.TimeSeconds + FireMode[Mode].PreFireTime;

    if (FireMode[alt].bModeExclusive)
    {
        // prevents rapidly alternating fire modes
        FireMode[Mode].NextFireTime = FMax(FireMode[Mode].NextFireTime, FireMode[alt].NextFireTime);
    }

    if (Instigator.IsLocallyControlled())
    {
        if (FireMode[Mode].PreFireTime > 0.0 || FireMode[Mode].bFireOnRelease)
        {
            FireMode[Mode].PlayPreFire();
        }
        FireMode[Mode].FireCount = 0;
    }

    return true;
}

simulated event StopFire(int Mode)
{

    //if (!FireMode[Mode].bIsFiring)
    //    return;

    if (Instigator.IsLocallyControlled() && !FireMode[Mode].bFireOnRelease)
    {
        FireMode[Mode].PlayFireEnd();
    }
    FireMode[Mode].bIsFiring = false;
    FireMode[Mode].StopFiring();
	if (!FireMode[Mode].bFireOnRelease && ClientState == WS_ReadyToFire){  //NAC: added check of clientstate to make sure we are ready to fire before we go off and zero out everything!

			ZeroFlashCount(Mode);
	}
}



simulated function Timer()
{
	local int Mode;

    if (ClientState == WS_BringUp)
    {
		for( Mode = 0; Mode < NUM_FIRE_MODES; Mode++ )
	       FireMode[Mode].InitEffects();

		WeaponAttachment( ThirdPersonActor ).SetupInstigatorProperties();
        ClientState = WS_ReadyToFire;
		PlayIdle(); // This must be after setting the client state!
	}
    else if (ClientState == WS_PutDown)
    {
		/*	GBX:naj - removed 10/30/03 - This code was preventing pawns from
		// putting down their weapons unless they had another weapon waiting.
		// MG42 assistants need to put down their weapons with no pending weapon.
		//
		if ( Instigator.PendingWeapon == None )
		{
			PlayIdle();
			ClientState = WS_ReadyToFire;
			PlayIdle(); // This must be after setting the client state!
		}
		else
		{
		*/
			ClientState = WS_Hidden;
			Instigator.ChangedWeapon();
			for( Mode = 0; Mode < NUM_FIRE_MODES; Mode++ )
				FireMode[Mode].DestroyEffects();
		//}
    }
}


simulated function bool IsFiring() // called by Pawn animation, mostly
{
    return  ( ClientState == WS_ReadyToFire && (FireMode[0].IsFiring() || FireMode[1].IsFiring() || FireMode[2].IsFiring()) );
}

simulated function bool IsReloading() // called by Pawn animation, mostly
{
    return  ( ClientState == WS_Reloading );
}

//NAC: added accessor function
function bool IsThrowingGrenade()
{
	return (ClientState == WS_ThrowGrenade );
}
  	 
function bool IsRapidFire() // called by Pawn animation
{
    if (FireMode[1] != None && FireMode[1].bIsFiring)
        return FireMode[1].bPawnRapidFireAnim;
    else if (FireMode[0] != None)
        return FireMode[0].bPawnRapidFireAnim;
    else
        return false;
}

function bool IsAimed() // called by Pawn animation
{
    return true;
}

function ConsumeAmmo(int Mode, float load)
{
	if (Ammo[Mode] != None)
        Ammo[Mode].UseAmmo(int(load));
	ClipAmt -= min(ClipAmt, load);
}

function ReloadClip()
{
	if ((Ammo[0] != None) && (FireMode[0] != None))
	{
		if( Instigator.bUnloaded )	// RSC: if unlimited ammo cheat enabled, add back the used clip amount
			Ammo[0].AmmoAmount = Ammo[0].MaxAmmo;

		ClipAmt = min(AmmoClipSize, Ammo[0].AmmoAmount);
	}

	FireMode[0].bIsReloading = false;
}

simulated function bool NeedsToReload()
{
//	log(self$".NeedsToReload() - "$Ammo[0]$" - "$FireMode[0]$" - "$Ammo[0].AmmoAmount$" - "$FireMode[0].AmmoPerFire$" - "$bForceReload$" - "$AmmoClipSize$" - "$ClipAmt, 'pad');
	return ( ((Ammo[0] != None) && (FireMode[0] != None) && (Ammo[0].AmmoAmount >= FireMode[0].AmmoPerFire)) && (bForceReload || ((AmmoClipSize > 0) && (ClipAmt == 0))) );
}

// amb ---
simulated function bool HasAmmo()
{
    return ( (Ammo[0] != None && FireMode[0] != None && Ammo[0].AmmoAmount >= FireMode[0].AmmoPerFire)
          || (Ammo[1] != None && FireMode[0] != None && Ammo[1].AmmoAmount >= FireMode[0].AmmoPerFire) );

    /*return (FireMode[Mode] != None &&
            Ammo[Mode] != None &&
            Ammo[Mode].AmmoAmount >= FireMode[Mode].AmmoPerFire);*/
}
// --- amb


// called every time owner takes damage while holding this weapon - used by link gun and shield gun
function AdjustPlayerDamage( out int Damage, Pawn InstigatedBy, Vector HitLocation,
                             out Vector Momentum, class<DamageType> DamageType)
{
}

// Implemented in gbxWeapon.
simulated function NotifyThirdPersonReloadFinished() {}	

simulated function AnimEnd(int channel)
{
    local name anim;
    local float frame, rate;

    GetAnimParams(0, anim, frame, rate);

	if (ClientState == WS_ReadyToFire)
	{
		if ((FireMode[0] != None) && (anim == FireMode[0].FireAnim) && HasAnim(FireMode[0].FireEndAnim)) // rocket hack
		{
			PlayAnim(FireMode[0].FireEndAnim, FireMode[0].FireEndAnimRate, 0.0);
		}
		else if ((FireMode[1] != None) && (anim==FireMode[1].FireAnim) && HasAnim(FireMode[1].FireEndAnim))
		{
			PlayAnim(FireMode[1].FireEndAnim, FireMode[1].FireEndAnimRate, 0.0);
		}
		else if ((FireMode[0] == None || !FireMode[0].bIsFiring) && (FireMode[1] == None || !FireMode[1].bIsFiring))
		{
//			if (Instigator.Controller.ReloadAfterWeaponFire() && NeedsToReload() && !bDelayReloading)
//			{
//				FireMode[0].PlayReloading();
//			}
//			else
//			{
				PlayIdle();
//			}
		}
	}
	else if (ClientState == WS_Reloading)
	{
		ClientState = WS_ReadyToFire;
		PlayIdle();
		ReloadClip();
	}
	else
	{
		PlayIdle();
	}
	FireMode[0].bWaitForAnim = false;
	FireMode[1].bWaitForAnim = false;
	FireMode[2].bWaitForAnim = false;
}

simulated function PlayIdle()
{
    PlayAnim(IdleAnim[Rand(9)%3], IdleAnimRate, 0.2);
}

// GBX:naj - added 11/20/03.  Override me.
function InvalidateBurst() {}

state PendingClientWeaponSet
{
    simulated function Timer()
    {
        if ( Pawn(Owner) != None )
            ClientWeaponSet(bPendingSwitch);
    }

    simulated function BeginState()
    {
        SetTimer(0.05, true);
    }

    simulated function EndState()
    {
        SetTimer(0.0, false);
    }
}

state Hidden
{
}

function Actor GetHitEffectOwner()
{
    return None;
}

function bool CheckReflect( Vector HitLocation, out Vector RefNormal, int AmmoDrain )
{
    return false;
}

function DoReflectEffect(int Drain)
{

}

static function bool CollectStats()
{
    return true;
}

// amb ---
function bool HandlePickupQuery( pickup Item )
{
    local WeaponPickup wpu;

	if (class == Item.InventoryType)
    {
        wpu = WeaponPickup(Item);
        if (wpu != None)
            return !wpu.AllowRepeatPickup();
        else
            return false;
    }

    if ( Inventory == None )
		return false;

	return Inventory.HandlePickupQuery(Item);
}
/*
static simulated function StaticPreLoadData()
{
	Super.StaticPreLoadData();
    PreLoad(default.IconMaterial);
}
*/
// --- amb

/* Force reloading even though clip isn't empty.  Called by player controller exec function,
and implemented in idle state */
simulated function ForceReload()
{
	FireMode[0].PlayReloading();
}

function ServerForceReload()
{
	FireMode[0].PlayReloading();
}

simulated function ClientForceReload()
{
	if ((ClientState == WS_ReadyToFire) && (Ammo[0].AmmoAmount > 0))
	{
		if (Level.NetMode == NM_Client)
		{
			ServerForceReload();
		}
		FireMode[0].PlayReloading();
	}
}

simulated function PlayZoomIn()
{
	PlayAnim(ZoomInAnim, 1.0, 0.0);
	ClientState = WS_ZoomIn;
}

simulated function PlayZoomOut()
{
	PlayAnim(ZoomOutAnim, 1.0, 0.0);
	ClientState = WS_ZoomOut;
}

// GBX:naj - added 8/12/03
simulated function Vector GetMuzzleLocationWorld()
{
	if ( ThirdPersonActor.IsA('WeaponAttachment') )
	{
		return WeaponAttachment( ThirdPersonActor ).GetMuzzleLocationWorld();
	}
	else if ( Instigator != None )
	{
		return Instigator.Location + Instigator.EyePosition();
	}
	else
	{
		return Vect(0,0,0);
	}
}

// GBX:sjp - added 12/7/04
simulated function Vector GetChamberLocationWorld()
{
	if ( ThirdPersonActor.IsA('WeaponAttachment') )
	{
		return WeaponAttachment( ThirdPersonActor ).GetChamberLocationWorld();
	}
	else if ( Instigator != None )
	{
		return Instigator.Location + Instigator.EyePosition();
	}
	else
	{
		return Vect(0,0,0);
	}
}


// GBX:sjp - added 10/23/03
// Overrides Actor implementation
simulated function Coords GetAttachmentTagWorldCoords( Name TagName )
{
	local Coords TagCoords;

	if ( BoneTagExists( TagName ) )
	{
 		TagCoords = GetTagCoords( TagName );
 	}
 	else if ((m_anExtendedActor != None) && m_anExtendedActor.BoneTagExists( TagName ))
 	{
 		TagCoords = m_anExtendedActor.GetTagCoords( TagName );
 	}

	// Sine the weapon is rendered in an overlay at a different FOV than the world, we have to project the coordinates
	// to the DisplayFOV and back again to the 3d world FOV of the player
	if( Instigator.IsFirstPerson() && PlayerController(Instigator.Controller) != None )
	{
		TagCoords.Origin = InventoryAttachment(ThirdPersonActor).GetFOVLocation( TagCoords.Origin, DisplayFOV );
		//ScreenLoc = WorldToScreen( TagCoords.Origin, PlayerController(Instigator.Controller).Player, DisplayFOV );
		//TagCoords.Origin = InventoryAttachment(ThirdPersonActor).ScreenToWorld( ScreenLoc, PlayerController(Instigator.Controller).Player );
	}

	return TagCoords;
}


// GBX:naj - added 10/15/03
function DisableReload()
{
	bDelayReloading = true;
}

function EnableReload()
{
	bDelayReloading = false;
	if ( NeedsToReload() && !FireMode[0].bIsReloading )
	{
		FireMode[0].PlayReloading();
	}
}

// GBX:naj - added 1/13/04
simulated function DoMeleeAttack() {}

// GBX:PAD - This is a hook for the controller to use when setting fatigue on the weapon itself.
simulated native function SetFatigue( float flFatigue );

function StartOpBurst()
{
	if ( FireMode[0] != None )
		FireMode[0].StartOpBurst();
}

function StartBerserk()
{
	if ( FireMode[0] != None )
		FireMode[0].StartBerserk();
}

function StopBerserk()
{
	if ( FireMode[0] != None )
		FireMode[0].StopBerserk();
}

// This function should return true for weapons that auto-reload even if the players' preferences normally dictate otherwise.
function bool AlwaysAutoReload()
{
	return false;
}

function ActivateOracle()
{
}

function bool IsAmmoFull()
{
    if (Ammo[0].AmmoAmount < Ammo[0].MaxAmmo)
		return false;
	else
		return true;
}

function TopOffAmmo()
{
	GiveAmmo(Ammo[0].MaxAmmo - Ammo[0].AmmoAmount);
}

function bool AmmoMatches( Weapon aWeapon )
{
	return true;
}

defaultproperties
{
    DrawType=DT_Mesh
    Style=STY_Normal
    PlayerViewOffset=(X=0,Y=0,Z=0)
    InventoryGroup=1

    FireModeClass(0)=None
    FireModeClass(1)=None

    // animation //
    IdleAnim=Idle
    RestAnim=Rest
    AimAnim=Aim
    RunAnim=Run
    SelectAnim=Select
    PutDownAnim=Down

    IdleAnimRate=1.0
    RestAnimRate=1.0
    AimAnimRate=1.0
    RunAnimRate=1.0
    SelectAnimRate=1.0
    PutDownAnimRate=1.0
    PutDownAnimQuickRate=1.0

    // other useful stuff //
    MessageNoAmmo=" has no ammo"
    DisplayFOV=90.0
    bCanThrow=true

    AIRating=0.5
    CurrentRating=0.5

    AttachmentClass=class'WeaponAttachment';

    NetPriority=3.0
    ScaleGlow=1.5
    AmbientGlow=20
    MaxLights=6
    FireRateAtten=1.0

	bStationary=false
	m_eNextWeaponSoundSlot=SLOT_WeaponFire1
	m_bIsAutomatic=false

	m_flEncumberance=1.0
	m_flSiteEncumberance=0.4
	SelectAnimReadyDelay=0.5
	PutDownAnimReadyDelay=0.5
	PutDownAnimQuickReadyDelay=0.5

	bMpKarmaWeaponDrops=false
}
class WeaponAttachment extends InventoryAttachment
	native
	nativereplication;



const WEAP_StateFiring = 1;
const WEAP_StateMelee = 2;
const WEAP_StateReload = 3;
const WEAP_StateThrow = 4;
const WEAP_StateDeploy = 5;
const WEAP_StateHolster = 6;

var		byte	FlashCount;			// when incremented, draw muzzle flash for current frame
var		byte	SpawnHitCount;		// when incremented, spawn hit effect at mHitLocation
var		bool	bAutoFire;			// When set to true.. begin auto fire sequence (used to play looping anims)
var		int		FiringMode;			// replicated to identify what type of firing/reload animations to play
var		float	FiringSpeed;		// used by human animations to determine the appropriate speed to play firing animations
var		vector  mHitLocation;		// used for spawning hit effects client side


// GBX:naj - added 8/12/03
// GBX:sjp - update 10/18/03
var	Name	MuzzleTagName;			// Name of attachment tag that defines the muzzle location in 3rd person
var Name	ViewMuzzleTagName;		// Name of attachment tag that defines the muzzle location in 1st person

var	Name	ChamberTagName;			// Name of attachment tag that defines the chamber location in 3rd person
var Name	ViewChamberTagName;		// Name of attachment tag that defiens the chamber location in 1st person

var Vector	StaticMuzzleOffset;
var float	StaticMuzzleCrouchHeightAdjust;

// PSV: 7/7/2005 Moved here from AttachmentDEMG42_
var Vector MuzzleOffset;

replication
{
	// Things the server should send to the client.
	reliable if( bNetDirty && !bNetOwner && (Role==ROLE_Authority) )
		FlashCount, FiringMode, bAutoFire;

	reliable if ( bNetDirty && (Role==ROLE_Authority) )
		mHitLocation, SpawnHitCount;
}

simulated function Destroyed()
{
	Instigator = None;  // prevent references to/in destroyed objects
	SetOwner(None);

    Super.Destroyed();
}

simulated function HitEffectNotify(Effects e);

/*
ThirdPersonEffects called by Pawn's C++ tick if FlashCount incremented
becomes true
OR called locally for local player
*/
simulated event ThirdPersonEffects()
{
	// spawn 3rd person effects

	// have Pawn play firing anim
	if ( Instigator != None )
		Instigator.PlayFiring(1.0,FiringMode);
}

// GBX:naj - added 8/12/03
simulated function Vector GetMuzzleLocationWorld()
{
	local Coords C;
	local Vector vecLoc;

	if ( Instigator.IsFirstPerson() )
	{
		C = Instigator.Weapon.GetAttachmentTagWorldCoords( ViewMuzzleTagName );
		return C.Origin;
	}
	else
	{
		if (Instigator.DrawType == DT_StaticMesh)
		{
			vecLoc = Instigator.Location + (Vector(Instigator.Rotation) * StaticMuzzleOffset.X);
			vecLoc.Z = vecLoc.Z + StaticMuzzleOffset.Z;
			if (Instigator.bIsCrouched)
				vecLoc.Z = vecLoc.Z + StaticMuzzleCrouchHeightAdjust;
			return vecLoc;
		}
		else
		{
			C = Instigator.GetAttachmentTagWorldCoords( MuzzleTagName );
			return C.Origin;
		}
	}
}

// GBX:SJP - use this for things like ejected shells
simulated function Vector GetChamberLocationWorld()
{
	local Coords C;
	local Vector vecLoc;

	if ( Instigator.IsFirstPerson() )
	{
		C = Instigator.Weapon.GetAttachmentTagWorldCoords( ViewChamberTagName );
		return C.Origin;
	}
	else
	{
		if (Instigator.DrawType == DT_StaticMesh)
		{
			vecLoc = Instigator.Location + (Vector(Instigator.Rotation) * StaticMuzzleOffset.X);
			vecLoc.Z = vecLoc.Z + StaticMuzzleOffset.Z;
			if (Instigator.bIsCrouched)
				vecLoc.Z = vecLoc.Z + StaticMuzzleCrouchHeightAdjust;
			return vecLoc;
		}
		else
		{
			C = Instigator.GetAttachmentTagWorldCoords( ChamberTagName );
			return C.Origin;
		}
	}
}

// GBX:PAD: a hook for letting the attachment set up properties for the Pawn it's attached to.
simulated function SetupInstigatorProperties()
{
}

// From UT2k3 2004-08-16 JWS
/* UpdateHit
- used to update properties so hit effect can be spawn client side
*/
event UpdateHit(Actor HitActor, vector HitLocation, vector HitNormal, material HitMaterial, bool HitWater);

simulated function DoImpactEffects();

defaultproperties
{
	bReplicateInstigator=true
	FiringSpeed=+1.0
    bActorShadows=true

	MuzzleTagName=rifle_muzzle
	ChamberTagName=rifle_chamber
	ViewMuzzleTagName=view_muzzle
	ViewChamberTagName=view_chamber

	StaticMuzzleOffset=(X=150.000000,Y=0.0000,Z=55.0000)
	StaticMuzzleCrouchHeightAdjust=-30.0f

	bAlphaFogable=True
    bAlphaFogBlend=true
}
class WeaponFire extends Actor
    native;

//const WEAP_StateFiring = 1;
//const WEAP_StateMelee = 2;
//const WEAP_StateReload = 3;
//const WEAP_StateThrow = 4;
//const WEAP_StateDeploy = 5;
//const WEAP_StateHolster = 6;

var() Weapon Weapon;
var() int ThisModeNum;
var() int FireType;
var() int ShotCount, ShotCountMod;

// animation //
var() Name DryFireAnim;
var() Name PreFireAnim;
var() Name FireAnim;
var() Name FireLoopAnim;
var() Name FireEndAnim;
var() Name ReloadAnim;

var() float PreFireAnimRate;
var() float FireAnimRate;
var() float FireLoopAnimRate;
var() float FireEndAnimRate;
var() float ReloadAnimRate;
var() float TweenTime;

// sound //
var() String StereoFireSoundName;
var() String FireSoundName;
var() String NoAmmoSoundName;

var() Cue FireSoundCue;			// Mono cue should be played when originating from non-local player
var() Cue StereoFireSoundCue;	// Stereo cue should be played when local player is firing

var() Sound NoAmmoSound;
var() int FireSoundHandle;

var globalconfig bool bPlayStereoWeapons;

var bool	bIgnoreDamageThisBullet;
var bool	bSoundsLoaded;

// jdf ---
// Force Feedback //
var() String FireForce;
var() String PreFireForce;
// --- jdf

// timing //
var() float PreFireTime;       // seconds before first shot
var() float FireRateSP;          // Singleplayer: seconds between shots
var() float FireRateMP;          // Multiplayer: seconds between shots
var() float AIFireRateSP;		// Singleplayer: seconds between shots for AI controlled weapons
var() float AIFireRateMP;		// Multiplayer: seconds between shots for AI controlled weapons
var() float AIFireRateVarianceSP;	// Singleplayer: Possible variation (lower or higher) in fire rate.
var() float AIFireRateVarianceMP;	// Multiplayer: Possible variation (lower or higher) in fire rate.
var() float	AIOpBurstMultiplierSP;
var() float	AIOpBurstMultiplierMP;

var() bool  bFireOnRelease;    // if true, shot will be fired when button is released, HoldTime will be the time the button was held for
var() bool  bWaitForRelease;   // if true, fire button must be released between each shot
var() bool  bModeExclusive;    // if true, no other fire modes can be active at the same time as this one
var   bool  bIsFiring;
var   bool  bNowWaiting;
var   bool  bServerDelayStopFire;
var   bool  bServerDelayStartFire;
var   bool  bIsReloading;
var   bool  bAccurateFirstShot;	// Machine guns with this flag set will always have an accurate first shot, at a minimum interval of Controller.ACCURATE_FIRST_SHOT_INTERVAL

var() float MaxHoldTime;
var() float HoldTime;
var   float NextFireTime;
var   float ServerStartFireTime;

// camera shakes //
var() vector ShakeRotMag;           // how far to rot view
var() vector ShakeRotRate;          // how fast to rot view
var() float  ShakeRotTime;          // how much time to rot the instigator's view
var() vector ShakeOffsetMag;        // max view offset vertically
var() vector ShakeOffsetRate;       // how fast to offset view vertically
var() float  ShakeOffsetTime;       // how much time to offset view

var   bool bWaitForAnim;			// Wait for the animation to finish before firing the next shot
// AI //
var() bool bSplashDamage;
var() bool bSplashJump;
var() bool bRecommendSplashDamage;
var() bool bTossed;
var() bool bLeadTarget;
var() bool bInstantHit;

var() class<Projectile> ProjectileClass;
var() float BotRefireRate;
var() float WarnTargetPct;

// muzzle flash & smoke //
var() class<Emitter> FlashEmitterClass;
var() transient Emitter FlashEmitter;
var() bool bAttachFlashEmitter;
//var() class<Emitter> SmokeEmitterClass;
//var() Emitter SmokeEmitter;
//var() bool bAttachSmokeEmitter;

// GEARBOX: AI and Human aim error values for weapons
// "Minimum" Error variables
var	int	AimErrorMin_AI_SP;
var	int	AimErrorMin_AI_MP;
var	int	AimErrorMin_Human;

// "Maximum" Error variables
var	int	AimErrorMax_AI_SP_Crouched;
var	int	AimErrorMax_AI_SP_Standing;
var	int	AimErrorMax_AI_SP_Moving;

var	int	AimErrorMax_AI_MP_Crouched;
var	int	AimErrorMax_AI_MP_Standing;
var	int	AimErrorMax_AI_MP_Moving;

var	int	AimErrorMax_Human_Crouched;
var	int	AimErrorMax_Human_Standing;
var	int	AimErrorMax_Human_MovingSlow;
var	int	AimErrorMax_Human_MovingFast;

// Machine guns have an accurate first shot
var int AimErrorMin_Human_FirstShot;
var int AimErrorMax_Human_FirstShot;


// "Maximum" error multipliers
var	float AimMultiplier_AI_SP_Sighted;
var float	AimMultiplier_AI_MP_Sighted;

// Human Zoomed-View Error variables
var int AimErrorMin_Human_Zoomed;
var int AimErrorMax_Human_Zoomed;

// Suppression Multiplier - Augments or reduces suppression done by this weapon.
var float	SuppressionMultiplierSP;
var float	SuppressionMultiplierMP;

// other useful stuff //
var() bool  bPawnRapidFireAnim; // for determining what anim the firer should play
var() bool  bReflective;
var() int ProjPerFire;

var int FireCount;
var() float DamageAtten; // attenuate instant-hit/projectile damage by this multiplier
var() float AutoAim; // cos of the max angle

var() class<Ammunition> AmmoClass;
var() int AmmoPerFire;
var() int Load;

simulated function PostBeginPlay()
{
    Load = AmmoPerFire;
    
    if (bFireOnRelease)
        bWaitForRelease = true;

    if (bWaitForRelease)
        bNowWaiting = true;

	// preload sounds
	if ( FireSoundName != "" )
		FireSoundCue = LoadSound( FireSoundName );

	if ( StereoFireSoundName != "" )
		StereoFireSoundCue = LoadSound( StereoFireSoundName );

    Weapon = Weapon(Owner);
}

simulated function Destroyed()
{
    DestroyEffects();

	Instigator = None;  // prevent references to/in destroyed objects
	SetOwner(None);
	Weapon = None;

    Super.Destroyed();
}

simulated function DestroyEffects()
{
    if (FlashEmitter != None)
    {
        //log("Destroyed "$FlashEmitter);
        FlashEmitter.Destroy();
    }
}

simulated function InitEffects()
{
    // don't even spawn on server
    if ( Level.NetMode == NM_DedicatedServer )
		return;

	/*
	if ( FlashEmitterClass != None && FlashEmitter == None )
    {
        FlashEmitter = Spawn(FlashEmitterClass);
        log("Spawned "$FlashEmitter);
    }
	*/
}

function DoFireEffect()
{
}

simulated function ClientDoFireEffect()
{
}

simulated function Emitter GetMuzzleFlash()
{
	if ( ( FlashEmitter == None || FlashEmitter.bDeleteMe ) && FlashEmitterClass != None )
    {
		FlashEmitter = Spawn(FlashEmitterClass);
        log("Spawned "$FlashEmitter, 'weapon');
    }

	return FlashEmitter;
}

// For first-person muzzle flashes only
event DrawMuzzleFlash(Canvas Canvas)
{
	if (FlashEmitter != None && FlashEmitter.Base != Weapon)
    {
        FlashEmitter.SetLocation( Weapon.GetEffectStart() );
        Canvas.DrawActor( FlashEmitter, Weapon.DisplayFOV );
    }
}

function FlashMuzzleFlash()
{
}


function ShakeView()
{
    local PlayerController P;

    P = PlayerController(Instigator.Controller);
    if (P != None)
    {
        P.ShakeView(ShakeRotTime, ShakeRotMag.Z, ShakeOffsetMag, ShakeRotRate.Z, ShakeOffsetRate, ShakeOffsetTime);
    }
}

// jdf ---
function ClientPlayForceFeedback( String EffectName )
{
    local PlayerController PC;

    PC = PlayerController(Instigator.Controller);
    if (PC != None && PC.bEnableWeaponForceFeedback )
    {
        PC.ClientPlayForceFeedback(EffectName);
    }
}

function ClientStopForceFeedback( String EffectName )
{
    local PlayerController PC;

    PC = PlayerController(Instigator.Controller);
    if (PC != None && PC.bEnableWeaponForceFeedback )
        {
        PC.ClientStopForceFeedback(EffectName);
    }
}
// --- jdf

function Update(float dt)
{
}

function StartFiring()
{
	
}

// Called locally to stop first person fire loop and play one off shot
function StopFiring();

function StartOpBurst() 
{
	AIFireRateSP = default.AIFireRateSP * AIOpBurstMultiplierSP;
	AIFireRateMP = default.AIFireRateMP * AIOpBurstMultiplierMP;

	if ( !Level.UseMPStyleFatigue() )
		FireAnimRate = default.FireAnimRate * AIOpBurstMultiplierSP;
	else
		FireAnimRate = default.FireAnimRate * AIOpBurstMultiplierMP;
}

function StartBerserk()
{
	StartOpBurst();
}

function StopBerserk() 
{
	AIFireRateSP = default.AIFireRateSP;
	AIFireRateMP = default.AIFireRateMP;
    FireAnimRate = default.FireAnimRate;
}

function bool IsFiring()
{
	return bIsFiring;
}

event ModeTick(float dt);

event ModeDoFire()
{
	local float AppliedFireRate;
	local PlayerController PC;
	local bool bLocalPlayerFiring;
	local bool ammoOveride;

	bLocalPlayerFiring = false;
	
	if( !Instigator.Controller.AllowFire() || !AllowFire())
	{
		Weapon.InvalidateBurst();
		return;
	}


	// If client, check to see if are clip amount is correct.
	// Lag can cause this to be incorrectly set to low, and we think
	// we are out of ammo. Bit of a hack fix.
	ammoOveride = false;
	if (Weapon.Role < ROLE_Authority)
	{
		if (Weapon.ClipAmt < Weapon.localClipAmt - 1)
		{
			ammoOveride = true;
			Weapon.localClipAmt = Weapon.ClipAmt+1;
		}
		else
			Weapon.localClipAmt = Weapon.ClipAmt;
	}

	if ( !Weapon.HasAmmo() && !ammoOveride)
	{
		return;
	}
	else if (Weapon.NeedsToReload() && !Weapon.bDelayReloading && !ammoOveride)
	{
		if ( !Weapon.AlwaysAutoReload() && !(Instigator.Controller.ReloadAfterWeaponFire()))
		{
			PlayDryFire();
		}
		else if ((Weapon.ClientState != WS_Reloading) && (Instigator.Controller.IsA('gbxAIController') || Weapon.AlwaysAutoReload()))
		{		
			PlayReloading();
		}
		else
		{
			if ( Weapon.IsAutomatic() && FireSoundHandle != 0 )
			{
				Weapon.ClientStopFire(0);
			}
		}	
		return; 
	}

	else if (Weapon.IsA('WeapDEPAK88_'))
	{
		if (!Weapon.OKToFire())
		{
			return;
		}
		Weapon.StopFire(0);  //NAC this thing only gets to fire when its firingcontroller says so!
	}

    if (MaxHoldTime > 0.0)
        HoldTime = FMin(HoldTime, MaxHoldTime);

    // server
    if (Weapon.Role == ROLE_Authority)
    {
		Load = AmmoPerFire;

	    DoFireEffect();

        Weapon.ConsumeAmmo(ThisModeNum, Load);

        if (Weapon == None || Instigator == None)
		{
			return;
		}
    }
	else
	{
		ClientDoFireEffect();
	}

	// client
    if (Instigator.IsLocallyControlled())
    {
		PlayFiring();

		for( PC = Level.PlayerControllerList; PC != None; PC = PC.nextPlayerController )
		{
			if ( Instigator.Controller == PC )
			{
				bLocalPlayerFiring = true;
				break;
			}
		}

		if ( StereoFireSoundCue != None && bLocalPlayerFiring && (Instigator.Controller == Level.GetLocalPlayerController()) )
		{
            //log( self$ " ModeDoFire() Instigator.Controller == Level.GetLocalPlayerController()!  About to play sound locally!", 'MP' );
			
            FireSoundHandle = Weapon.PlayLocalSoundCue(StereoFireSoundCue, SLOT_None, false);	

			if( Level.NetMode != NM_Standalone )
			{
				//log( self$ " ModeDoFire() Instigator.Controller == Level.GetLocalPlayerController()!  About to remote mono sound!", 'MP' );
				Weapon.PlayRemoteSoundCue(FireSoundCue, SLOT_None, true, false);
			}
		}
		else
		{
			//log( self$ " ModeDoFire() StereoFireSoundCue: "$StereoFireSoundCue$" bLocalPlayerFiring: "$bLocalPlayerFiring$ " Firing coming from somebody who is not local player controller!  Only playing mono sound!", 'MP' );

				FireSoundHandle = Weapon.PlayOwnedSoundCue(FireSoundCue, SLOT_None, TransientSoundVolume,,,,true);	
        }
    }
	else
	{
		FireSoundHandle = Weapon.PlayOwnedSoundCue(FireSoundCue, SLOT_None, TransientSoundVolume,,,,true);
	}

	if ( Weapon.IsAutomatic() )
	{
		if ( Weapon.m_eNextWeaponSoundSlot == SLOT_WeaponFire1 )
			Weapon.m_eNextWeaponSoundSlot = SLOT_WeaponFire2;
		else
			Weapon.m_eNextWeaponSoundSlot = SLOT_WeaponFire1;
	}

	Weapon.IncrementFlashCount(FireType);

	if (Instigator.Controller.IsA('AIController'))
	{
		if ( !Level.UseMPStyleFatigue() )
			AppliedFireRate = AIFireRateSP;
		else
			AppliedFireRate = AIFireRateMP;

		// set the next firing time. must be careful here so client and server do not get out of sync
		if (bFireOnRelease)
		{
			if (bIsFiring)
			{				
				NextFireTime += ( MaxHoldTime + AppliedFireRate*Weapon.FireRateAtten + GetRandomFireRateChange() );
			}
			else
			{
				NextFireTime = Level.TimeSeconds + AppliedFireRate*Weapon.FireRateAtten + GetRandomFireRateChange();
			}
		}
		else
		{
			NextFireTime += ( AppliedFireRate*Weapon.FireRateAtten + GetRandomFireRateChange() );
			NextFireTime = FMax(NextFireTime, Level.TimeSeconds);			
		}
	}
	else
	{
		if ( !Level.UseMPStyleFatigue() )
			AppliedFireRate = FireRateSP;
		else
			AppliedFireRate = FireRateMP;

		// set the next firing time. must be careful here so client and server do not get out of sync
		if (bFireOnRelease)
		{
			if (bIsFiring)
				NextFireTime += MaxHoldTime + AppliedFireRate*Weapon.FireRateAtten;
			else
				NextFireTime = Level.TimeSeconds + AppliedFireRate*Weapon.FireRateAtten;
		}
		else
		{
			NextFireTime += AppliedFireRate*Weapon.FireRateAtten;
			NextFireTime = FMax(NextFireTime, Level.TimeSeconds);
		}
	}

    HoldTime = 0;

    if (Instigator.PendingWeapon != Weapon && Instigator.PendingWeapon != None)
    {
        if (Weapon.PutDown())
            bIsFiring = false;
    }

	bWaitForAnim = true;
}

event ModeHoldFire()
{
    if (Instigator.IsLocallyControlled())
        PlayStartHold();
}

// GBX:naj - Allow for a small variation in the rate of fire to seem more human.
function float GetRandomFireRateChange()
{
	local float AppliedVariance;

	if ( !Level.UseMPStyleFatigue() )
		AppliedVariance = AIFireRateVarianceSP;
	else
		AppliedVariance = AIFireRateVarianceMP;

	if ( AppliedVariance > 0.0 )
	{
		if ( Rand( 2 ) == 0 )
			return FRand() * AppliedVariance;
		else
			return -FRand() * AppliedVariance;
	}
	else
	{
		// Save a little on a Rand() and an FRand().  :)
		return 0.0;
	}
}

// GBX:naj - Avoid call to expensive InstantFire function AllowFire by using only the WeaponFire logic from AllowFire().
simulated function bool ReadyToFire()
{
	return ( (Weapon.Ammo[ThisModeNum] != None) && (Weapon.Ammo[ThisModeNum].AmmoAmount >= AmmoPerFire) );
}

simulated function bool AllowFire()
{
	local bool bReadyToFire;

	// if this is a multiplayer game and the weapon is not ready to fire (i.e. zooming, reloading, etc), return false
	if( Level.NetMode != NM_Standalone && Weapon.ClientState != WS_ReadyToFire )
		bReadyToFire = false;
	else
		bReadyToFire = true;

    return ( Weapon.Ammo[ThisModeNum] != None && Weapon.Ammo[ThisModeNum].AmmoAmount >= AmmoPerFire && bReadyToFire );
}


//// client animation ////

function PlayPreFire()
{
    if ((Weapon.Mesh != None) && Weapon.HasAnim(PreFireAnim))
    {
	    Weapon.PlayAnim(PreFireAnim, PreFireAnimRate, TweenTime);
    }

    ClientPlayForceFeedback(PreFireForce);  // jdf
}

function PlayStartHold()
{
}

function PlayFiring()
{
	if ( Instigator.IsFirstPerson() )
	{
		//DHW + -- Removed outdated weapon kick code
		//ShakeView();
		//DHW -

		if (Weapon.Mesh != None)
		{
			if (FireCount > 0)
			{
				if (Weapon.HasAnim(FireLoopAnim))
				{
					Weapon.PlayAnim(FireLoopAnim, FireLoopAnimRate, 0.0);
				}
				else
				{
					Weapon.PlayAnim(FireAnim, FireAnimRate, TweenTime);
				}
			}
			else
			{
				Weapon.PlayAnim(FireAnim, FireAnimRate, TweenTime);
			}
		}

		if( FireForce != "" )
		{
			ClientPlayForceFeedback(FireForce);  // jdf
		}
	}

    FireCount++;
}

function PlayFireEnd()
{
	if ((Weapon.Mesh != None) && Weapon.HasAnim(FireEndAnim))
    {
        Weapon.PlayAnim(FireEndAnim, FireEndAnimRate, TweenTime);
    }
}

simulated function PlayReloading()
{
	if (Weapon.HasAnim(ReloadAnim) && !Weapon.bDelayReloading)
	{
		Weapon.ClientStopFire(0);

		if (Weapon.Mesh != None)
		{
			Weapon.PlayAnim(ReloadAnim, ReloadAnimRate, TweenTime);
		}

	    Weapon.ClientState = WS_Reloading;
		bIsReloading = true;
	}

	if (WeaponAttachment(Weapon.ThirdPersonActor) != None)
		Weapon.IncrementFlashCount(WeaponAttachment(Weapon.ThirdPersonActor).WEAP_StateReload);
}

simulated function PlayDryFire()
{
	if ( (Weapon.Mesh != None) && Instigator.IsFirstPerson() )
	{
		Weapon.PlayAnim(DryFireAnim, FireAnimRate, TweenTime);
	}
}

function Rotator AdjustAimNew(Vector Start, optional out int bSkipDoTrace)
{
    local Ammunition Ammo;

    // stuff Ammo with AI info
    Ammo = Weapon.Ammo[ThisModeNum];
    if (Ammo == None)
    {
        Log("warning:"@Weapon@self@"needs an ammo class for nefarious AI purposes");
        return Instigator.Rotation;
    }
    else
    {
        Ammo.bTossed = bTossed;
        Ammo.bTrySplash = bRecommendSplashDamage;
        Ammo.bLeadTarget = bLeadTarget;
        Ammo.bInstantHit = bInstantHit;
        Ammo.ProjectileClass = ProjectileClass;
		Ammo.WarnTargetPct = WarnTargetPct;
        Ammo.MaxRange = MaxRange(); //amb: for autoaim
        Ammo.AutoAim = AutoAim;
		return Instigator.AdjustAimNew(Ammo, Start, bSkipDoTrace);
    }
}

simulated function vector GetFireStart(vector X, vector Y, vector Z)
{
    return Instigator.Location + Instigator.EyePosition();
}

simulated function DisplayDebug(Canvas Canvas, out float YL, out float YPos)
{
    Canvas.SetDrawColor(0,255,0);
    Canvas.DrawText("  FIREMODE "$GetItemName(string(self))$" IsFiring "$bIsFiring);
    YPos += YL;
    Canvas.SetPos(4,YPos);
/*
    Canvas.DrawText("  FireOnRelease "$bFireOnRelease$" HoldTime "$HoldTime$" MaxHoldTime "$MaxHoldTime);
    YPos += YL;
    Canvas.SetPos(4,YPos);

    Canvas.DrawText("  NextFireTime "$NextFireTime$" NowWaiting "$bNowWaiting);
    YPos += YL;
    Canvas.SetPos(4,YPos);
*/
}

function float MaxRange()
{
	return 5000;
}

// If this is a projectile weapon, then fire that projectile now.  This is separate from regular firing since, with
// things such as grenade throws, the projectile does not actually fly until far into the animation.
simulated function FireProjectile()
{
}

// GBX:naj - added 9/4/03 - implement in subclasses.
function Rotator GetLastAimRotator()
{
	return Rot(0,0,0);
}

function GetBestBurstCount( ESuppressionLevel SuppressionLevel, out int MinShots, out int MaxShots )
{
	// Override me.
	MinShots = 0;
	MaxShots = 0;
	log("GetBestBurstCount() not overridden for WeaponFire subclass "$Self.name, 'ScriptWarning' );
}

function GetOpBurstCount( out int MinShots, out int MaxShots )
{
	// Override me.
	MinShots = 0;
	MaxShots = 0;
	log("GetOpBurstCount() not overridden for WeaponFire subclass "$Self.name, 'ScriptWarning' );
}

function GetBestBurstLength( ESuppressionLevel SuppressionLevel, out float MinLen, out float MaxLen )
{
	// Override me.
	MinLen = 0.0;
	MaxLen = 0.0;
	log("GetBestBurstLength() not overridden for WeaponFire subclass "$Self.name, 'ScriptWarning' );
}

// GBX:naj - added 2/5/04
function SetNoDamageThisBullet()
{
	bIgnoreDamageThisBullet = true;
}

function SetInstaKill( bool bInstaKill );	// Implement me.

defaultproperties
{
    bHidden=true
    RemoteRole=ROLE_None

	DryFireAnim=fire_empty
    PreFireAnim=PreFire
    FireAnim=Fire
    FireLoopAnim=FireLoop
    FireEndAnim=FireEnd
    ReloadAnim=Reload

    PreFireAnimRate=1.0
    FireAnimRate=1.0
    FireLoopAnimRate=1.0
    FireEndAnimRate=1.0
    ReloadAnimRate=1.0
    TweenTime=0.1

    PreFireTime=0.0
    FireRateSP=0.5
	FireRateMP=0.5
	AIOpBurstMultiplierSP=1.0
	AIOpBurstMultiplierMP=1.0

    bModeExclusive=true

    // AI //
    bSplashDamage=false
    bRecommendSplashDamage=false
    BotRefireRate=0.95
    bTossed=false
    bLeadTarget=false
    bInstantHit=true
    ProjectileClass=None
    ProjPerFire=1
    DamageAtten=1.0
    AutoAim=0.92

	SuppressionMultiplierSP=1.0			// 1.0 has no effect.
	SuppressionMultiplierMP=1.0			// 1.0 has no effect.
	AimMultiplier_AI_MP_Sighted=1.0		// 1.0 has no effect.
	AimMultiplier_AI_SP_Sighted=1.0		// 1.0 has no effect.

    TransientSoundVolume=0.6
	MaxHoldTime=0.0

	bIsFiring=false
	bFireOnRelease=false
	bSoundsLoaded=false
	bPlayStereoWeapons=true
}
class WeaponPickup extends Pickup
	notplaceable
	abstract;



var() bool	  bWeaponStay;
var() bool	  bThrown; // true if deliberatly thrown, not dropped from kill
var() int     AmmoAmount[3];
var() int     ClipAmount[3];

function PostBeginPlay()
{
	Super.PostBeginPlay();
	SetWeaponStay();
	MaxDesireability = 1.2 * class<Weapon>(InventoryType).Default.AIRating;
}

function SetWeaponStay()
{
	bWeaponStay = bWeaponStay || Level.Game.bWeaponStay;
}

// amb ---
function StartSleeping()
{
    if (bDropped)
        Destroy();
    else if (!bWeaponStay)
	    GotoState('Sleeping');
}

function bool AllowRepeatPickup()
{
    return (!bWeaponStay || (bDropped && !bThrown));
}
// --- amb

/* DetourWeight()
value of this path to take a quick detour (usually 0, used when on route to distant objective, but want to grab inventory for example)
*/
function float DetourWeight(Pawn Other,float PathWeight)
{
	local Weapon AlreadyHas;

	AlreadyHas = Weapon(Other.FindInventoryType(InventoryType));
	if ( (AlreadyHas != None)
		&& (bWeaponStay || (AlreadyHas.Ammo[0].AmmoAmount > 0)) )
		return 0;
	if ( AIController(Other.Controller).PriorityObjective()
		&& ((Other.Weapon.AIRating > 0.5) || (PathWeight > 400)) )
		return 0;
	if ( class<Weapon>(InventoryType).Default.AIRating > Other.Weapon.AIRating )
		return class<Weapon>(InventoryType).Default.AIRating/PathWeight;
	return class<Weapon>(InventoryType).Default.AIRating/PathWeight;
}

// tell the bot how much it wants this weapon pickup
// called when the bot is trying to decide which inventory pickup to go after next
function float BotDesireability(Pawn Bot)
{
	local Weapon AlreadyHas;
	local float desire;

	// bots adjust their desire for their favorite weapons
	desire = MaxDesireability + Bot.Controller.AdjustDesireFor(self);

	// see if bot already has a weapon of this type
	AlreadyHas = Weapon(Bot.FindInventoryType(InventoryType));
	if ( AlreadyHas != None )
	{
		if ( Bot.Controller.bHuntPlayer )
			return 0;

		// can't pick it up if weapon stay is on
		if ( !AllowRepeatPickup() )
			return 0;
		if ( (RespawnTime < 10)
			&& ( bHidden || (AlreadyHas.Ammo[0] == None)
				|| (AlreadyHas.Ammo[0].AmmoAmount >= AlreadyHas.Ammo[0].MaxAmmo)) )
			return 0;

		if ( AlreadyHas.Ammo[0] == None )
			return 0.25 * desire;

		// bot wants this weapon for the ammo it holds
		if( ( AlreadyHas.Ammo[0].AmmoAmount > 0 ) && ( AlreadyHas.Ammo[0].PickupClass != None ) ) // gam
			return FMax( 0.25 * desire,
					AlreadyHas.Ammo[0].PickupClass.Default.MaxDesireability
					 * FMin(1, 0.15 * AlreadyHas.Ammo[0].MaxAmmo/AlreadyHas.Ammo[0].AmmoAmount) );
		else
			return 0.05;
	}
	if ( Bot.Controller.bHuntPlayer && (MaxDesireability * 0.833 < Bot.Weapon.AIRating - 0.1) )
		return 0;

	// incentivize bot to get this weapon if it doesn't have a good weapon already
	if ( (Bot.Weapon == None) || (Bot.Weapon.AIRating < 0.5) )
		return 2*desire;

	return desire;
}

function float GetRespawnTime()
{
	if ( (Level.NetMode != NM_Standalone) || (Level.Game.GameDifficulty > 3.f) )
		return ReSpawnTime;
	return RespawnTime * (0.33 + 0.22 * Level.Game.GameDifficulty);
}

function InitDroppedPickupFor(Inventory Inv)
{
    local Weapon W;
    W = Weapon(Inv);
    if (W != None)
    {
        if (W.Ammo[0] != None)
            AmmoAmount[0] = W.Ammo[0].AmmoAmount;
        if (W.Ammo[1] != None && W.Ammo[1] != W.Ammo[0])
            AmmoAmount[1] = W.Ammo[1].AmmoAmount;
    }
    Super.InitDroppedPickupFor(None);
}

function Reset()
{
    AmmoAmount[0] = 0;
    AmmoAmount[1] = 0;
    Super.Reset();
}

function inventory SpawnCopy( Pawn Other )
{
    local inventory inv;
    local weapon w;

    inv = Other.FindInventoryType(InventoryType);
    if (inv != None)
    {
        w = weapon(inv);

        if (w.Ammo[0] != None)
        {
            w.Ammo[0].AddAmmo(w.Ammo[0].default.InitialAmount);
        }

        return inv;
    }
    else
    {
        return Super.SpawnCopy(Other);
    }
}

defaultproperties
{
    PickupMessage="You got a weapon"
    RespawnTime=30.000000
    Texture=Texture'Engine.S_Weapon'
    MaxDesireability=0.5000
    AmbientGlow=64 // jjs
    bPredictRespawns=true
}
class WireManager extends Actor
	native
	abstract
	notplaceable
	dependson(UtilityPole);
	
#exec TEXTURE IMPORT NAME=WireNormals FILE=Textures\WireNormals.dds UCLAMPMODE=CLAMP VCLAMPMODE=CLAMP

var() Material WireMaterial;
var transient array<UtilityPole> UtilityPoles;
var transient int NumCachedVertices;
var transient box WireBoundingBox;
var transient const WirePrimitive WirePrimitive;
var transient bool WireBoundsValid;

defaultproperties
{
	bStatic=True
	bAlphaFogable=True
	DrawType=DT_GbxWires
	SpecialSort=SS_Wires
}
class xNameList extends Object
    abstract;


var() localized array<string>   maNames;
var() localized string          mDefaultName;
var() transient array<int>      maUsed;
var() bool                      mbUniqueOnly;
var() bool                      mbAllUsed;
var() int                       mNumUsed;


function Init(int options);

function Created()
{
    local int i;
    for (i=0; i<maNames.Length; i++)
        maUsed[i] = 0;
}

function int GetRandomName(out string s, bool useit) //always use!
{
    local int rnd;

    if (mbAllUsed || maNames.Length==0)
    {
        s = mDefaultName;
        return -1;
    }

    rnd = Rand(maNames.Length);

    if (mbUniqueOnly)
    {
        CheckUnique(rnd);
        
        if (useit)
            UseName(rnd);
    }

    s = GetName(rnd);

    return rnd;
}

function string GetName(int index)
{
    return maNames[index];
}

function CheckUnique(out int rnd)
{
    for (rnd=rnd; rnd<maNames.Length; rnd++)
    {
        if (!IsUsed(rnd))
            return;
    }

    rnd = 0;
    CheckUnique(rnd);
}

function bool IsUsed(int i)
{
    return (maUsed[i] == 1);
}

function RemoveName(int index)
{
    maNames.Remove(index, 1);
    maUsed.Remove(index, 1);
}

function UseName(int i)
{
    assert(ValidName(i));
    assert(!mbAllUsed);

    if (mbUniqueOnly)
        assert(!IsUsed(i));

    mNumUsed++;
    maUsed[i] = 1;

    mbAllUsed = true;
    for (i=0; i<maNames.Length; i++)
    {
        if (maUsed[i] == 0)
        {
            mbAllUsed = false;
            break;
        }
    }
}

function bool ValidName(int i)
{
    return (i >= 0 && i < maNames.Length);
}

function int FindName(string s)
{
    local int i;

    for (i=0; i<maNames.Length; i++)
        if (s ~= maNames[i])
            return i;

    return -1;
}

function int UseNextName()
{
    local int i;

    assert(!mbAllUsed);

    for (i=0; i<maNames.Length; i++)
    {
        if (!IsUsed(i))
        {
            UseName(i);
            return i;
        }
    }

    assert(false);
}


defaultproperties
{
    mbUniqueOnly=true
    mDefaultName="NoName"
}//=============================================================================
// ZoneInfo, the built-in Unreal class for defining properties
// of zones.  If you place one ZoneInfo actor in a
// zone you have partioned, the ZoneInfo defines the
// properties of the zone.
// This is a built-in Unreal class and it shouldn't be modified.
//=============================================================================
class ZoneInfo extends Info
	native
	placeable;



//-----------------------------------------------------------------------------
// Zone properties.

var skyzoneinfo SkyZone; // Optional sky zone containing this zone's sky.
var() name ZoneTag;
var() localized String LocationName;

var() float KillZ;		// any actor falling below this level gets destroyed
var() eKillZType KillZType;	// passed by FellOutOfWorldEvent(), to allow different KillZ effects
var() bool bSoftKillZ;	// 2000 units of grace unless land

//-----------------------------------------------------------------------------
// Zone flags.

var() const bool   bFogZone;			// Zone is fog-filled.
var()		bool   bTerrainZone;		// There is terrain in this zone.
var()		bool   bDistanceFog;		// There is distance fog in this zone.
var()		bool   bClearToFogColor;	// Clear to fog color if distance fog is enabled.

var const array<TerrainInfo> Terrains;

var() color DistanceFogColor;
var() float DistanceFogStart;
var() float DistanceFogEnd;
var() float DistanceFogBlendTime;
var() range DistanceFade;              // GEARBOX:ZONER:add - alpha fog start/end range
var() range DistanceFadeInverse;       // GEARBOX:ZONER:add - inverse alpha fog start/end range for skybox to fade out when close
var() range DistanceClipHardware;      // GEARBOX:ZONER: changed DistanceNearClipHardware/DistanceFarClipHardware to a new variable range so all existing maps would get reset
var() range DistanceClipSpecial;       // GEARBOX:ZONER: special hardware depth clip planes for skybox models
var() float SplitScreenDistanceFadeScale;      // GEARBOX:ZONER: distance fade scale for split screen mode
var   float DistanceFadeScale;
var() color ParticleAmbientColor;       // ZONER: Added to modulate certains particles by this color to darken them in darker maps

var(ZoneSound) editinline I3DL2Listener ZoneEffect;

var(ZoneWind) float		WindDirection;			// 0-360 degrees
var(ZoneWind) float		WindIntensity;			// strength (roughly diameter of sway for grass in unreal units)
var(ZoneWind) float     WindFlutterIntensity;   // strength of tree/hedgerow high frequency flutter
var(ZoneWind) float		WindSwaySpeed;			// speed of grass waves in seconds (low frequency oscillation)
var(ZoneWind) float		WindFlutterSpeed;		// speed of grass waves in seconds (high frequency oscillation)
var(ZoneWind) vector	BlastLocationA;			// location of a blast epicenter A
var(ZoneWind) vector	BlastLocationB; 		// location of a blast epicenter B
var(ZoneWind) float		BlastRadiusA;			// radius of blast epicenter A
var(ZoneWind) float		BlastRadiusB;			// radius of blast epicenter B
var(ZoneWind) float		BlastFlutterFactorA;	// speed off blast A grass waves (high frequency flutter)
var(ZoneWind) float		BlastFlutterFactorB;	// speed off blast B grass waves (high frequency flutter)
var(ZoneWind) float		BlastKnockdownFactorA;	// strength of 'knockdown' at edge of blast radius
var(ZoneWind) float		BlastKnockdownFactorB;	// strength of 'knockdown' at edge of blast radius
var			  bool		bUseBlastB;				// For toggling between A and B. If true, use blast B parameters; otherwise, use blast A.

//------------------------------------------------------------------------------

var(ZoneVisibility) bool bLonelyZone;								// This zone is the only one to see or never seen
var(ZoneVisibility) editinline array<ZoneInfo> ManualExcludes;		// No Idea.. just sounded cool

//=============================================================================
// Iterator functions.

// Iterate through all actors in this zone.
native(308) final iterator function ZoneActors( class<actor> BaseClass, out actor Actor );

simulated function LinkToSkybox()
{
	local skyzoneinfo TempSkyZone;

	// SkyZone.
	foreach AllActors( class 'SkyZoneInfo', TempSkyZone, '' )
		SkyZone = TempSkyZone;
	if(Level.DetailMode == DM_Low)
	{
		foreach AllActors( class 'SkyZoneInfo', TempSkyZone, '' )
			if( !TempSkyZone.bHighDetail && !TempSkyZone.bSuperHighDetail )
				SkyZone = TempSkyZone;
	}
	else if(Level.DetailMode == DM_High)
	{
	foreach AllActors( class 'SkyZoneInfo', TempSkyZone, '' )
			if( !TempSkyZone.bSuperHighDetail )
				SkyZone = TempSkyZone;
	}
	else if(Level.DetailMode == DM_SuperHigh)
	{
		foreach AllActors( class 'SkyZoneInfo', TempSkyZone, '' )
			SkyZone = TempSkyZone;
	}
}

//=============================================================================
// Engine notification functions.

simulated function PreBeginPlay()
{
	Super.PreBeginPlay();

	// call overridable function to link this ZoneInfo actor to a skybox
	LinkToSkybox();
}

// When an actor enters this zone.
event ActorEntered( actor Other );

// When an actor leaves this zone.
event ActorLeaving( actor Other );

defaultproperties
{
     KillZ=-1000000.0
     bStatic=True
     bNoDelete=True
     Texture=Texture'Engine.S_ZoneInfo'
     AmbientSaturation=0
	 DistanceFogColor=(R=128,G=128,B=128,A=0)
	 DistanceFogStart=3000
	 DistanceFogEnd=8000
	 DistanceFogBlendTime=1.0

	 WindDirection=15
	 WindIntensity=5
	 WindSwaySpeed=1.5
	 WindFlutterSpeed=0.5
	 SplitScreenDistanceFadeScale=1.0
	 DistanceFadeScale=1.0
	 
	 ParticleAmbientColor=(R=255,G=255,B=255,A=255)
}
//=============================================================================
// ZoneTrigger.
//=============================================================================
class ZoneTrigger extends Trigger;



//
// Called when something touches the trigger.
//
function Touch( actor Other )
{
	local ZoneInfo Z;
	if( IsRelevant( Other ) )
	{
		// Broadcast the Trigger message to all matching actors.
		if( Event != '' )
			foreach AllActors( class 'ZoneInfo', Z )
				if ( Z.ZoneTag == Event )
					Z.Trigger( Other, Other.Instigator );

		if( Message != "" )
			// Send a string message to the toucher.
			Other.Instigator.ClientMessage( Message );

		if( bTriggerOnceOnly )
			// Ignore future touches.
			SetCollision(False);
	}
}

//
// When something untouches the trigger.
//
function UnTouch( actor Other )
{
	local ZoneInfo Z;
	if( IsRelevant( Other ) )
	{
		// Untrigger all matching actors.
		if( Event != '' )
			foreach AllActors( class 'ZoneInfo', Z )
				if ( Z.ZoneTag == Event )
					Z.UnTrigger( Other, Other.Instigator );
	}
}

defaultproperties
{
	Texture=Texture'Engine.S_TriggerZone'
}
