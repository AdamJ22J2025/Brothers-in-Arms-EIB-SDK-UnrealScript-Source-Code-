class AmmoDEFG42Sniper extends gbxAmmo;


defaultproperties
{
    ItemName="US BAR Bullets"

	WeaponKick=(x=125,y=0,z=500)
	WeaponKickZoomed=(x=100,y=0,z=500)

	KickRecoverRate = 6;

    PickupClass=class'PickupAmmoDEFG42_'
    MaxAmmo=210
    InitialAmount=120

	AmmoShellClass=class'ShellDEFG42_'
	BulletTracerClass=class'EmitterBulletTracerUS'
}
class AmmoDEFG42_ extends gbxAmmo;


defaultproperties
{
    ItemName="US BAR Bullets"

	WeaponKick=(x=125,y=0,z=500)
	WeaponKickZoomed=(x=100,y=0,z=400)

	KickRecoverRate = 6;

    PickupClass=class'PickupAmmoDEFG42_'
    MaxAmmo=200
    InitialAmount=120

	AmmoShellClass=class'ShellDEFG42_'
	BulletTracerClass=class'EmitterBulletTracerUS'
}
class AmmoDEFlakvierling extends gbxAmmo;

//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
    ItemName="German Flakvierling ammunition"
	BulletTracerClass=class'EmitterFlakTracer'
    PickupClass=None
    MaxAmmo=400
    InitialAmount=20
}class AmmoDEK98_ extends gbxAmmo;


defaultproperties
{
    ItemName="German K98 Bullets"

    PickupClass=class'PickupAmmoDEK98_'
    MaxAmmo=65
    InitialAmount=35

	WeaponKick=(x=125,y=0,z=400)
	WeaponKickZoomed=(x=150,y=10,z=1200)

	KickRecoverRate = 1.4;

	AmmoShellClass=class'ShellDEK98_'
	BulletTracerClass=class'EmitterBulletTracerGeneric'
}
//=============================================================================
// German MG42 ammunition class.
//
// Author: Neil Johnson, Gearbox Software.
//=============================================================================
class AmmoDEMG42_ extends gbxAmmo;


//---------------------------------------------------------
//	ApplyKick
//---------------------------------------------------------
function ApplyKick()
{
	local float diff_x, diff_y, diff_z;
	local vector v_kick;

	if ( Instigator != None && Instigator.Controller != None && Instigator.Controller.bIsHumanPlayer )
	{
		if (WeapDEMG42_( Instigator.Weapon ).IsZoomed() )
		{
			if (bRandomizeWeaponKick)
			{
				diff_x = WeaponKickZoomedMax.x - WeaponKickZoomedMin.x;
				diff_y = WeaponKickZoomedMax.y - WeaponKickZoomedMin.y;
				diff_z = WeaponKickZoomedMax.z - WeaponKickZoomedMin.z;

				v_kick.x = WeaponKickZoomedMin.x + FRand() * diff_x;
				v_kick.y = WeaponKickZoomedMin.y + FRand() * diff_y;
				v_kick.z = WeaponKickZoomedMin.z + FRand() * diff_z;
			}
			else
			{
				v_kick = WeaponKickZoomed;
			}

			gbxPawn(Instigator).ClientKickView( v_kick, KickRecoverRate, WeaponFovKick );
		}
		else
		{
			if (bRandomizeWeaponKick)
			{
				diff_x = WeaponKickMax.x - WeaponKickMin.x;
				diff_y = WeaponKickMax.y - WeaponKickMin.y;
				diff_z = WeaponKickMax.z - WeaponKickMin.z;

				v_kick.x = WeaponKickMin.x + FRand() * diff_x;
				v_kick.y = WeaponKickMin.y + FRand() * diff_y;
				v_kick.z = WeaponKickMin.z + FRand() * diff_z;
			}
			else
			{
				v_kick = WeaponKick;
			}

			gbxPawn(Instigator).ClientKickView( v_kick, KickRecoverRate, WeaponFovKick );
		}
	}
}

//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
    ItemName="German MG42 ammunition"

    PickupClass=None
    MaxAmmo=400
    InitialAmount=400

	bUnlimited=true
	BulletTracerClass=class'EmitterBulletTracerGerman'
	AmmoShellClass=class'ShellDEMG42_'

	WeaponKick=(x=0,y=0,z=0)
	WeaponKickMin=(x=-50,y=0,z=-30)
	WeaponKickMax=(x=50,y=0,z=250)
	WeaponKickZoomed=(x=0,y=0,z=0)
	WeaponKickZoomedMin=(x=-50,y=0,z=-30)
	WeaponKickZoomedMax=(x=50,y=0,z=250)
	KickRecoverRate=10.0;
	KickRecoverRateZoomed=10.0;
	bRandomizeWeaponKick=true
}
class AmmoDEMortar extends gbxAmmo;

//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
    ItemName="German Mortar rounds"

    PickupClass=None
    MaxAmmo=400
    InitialAmount=1
}class AmmoDEMP40_ extends gbxAmmo;


defaultproperties
{
    ItemName="German MP40 Bullets"

	WeaponKick=(x=125,y=0,z=350)
	WeaponKickZoomed=(x=75,y=0,z=200)

	KickRecoverRate = 6.0;

    PickupClass=class'PickupAmmoDEMP40_'

   MaxAmmo=224
   InitialAmount=128

   AmmoShellClass=class'ShellUSThompson'
   BulletTracerClass=class'EmitterBulletTracerGeneric'
}
class AmmoDEP38_ extends gbxAmmo;


defaultproperties
{
    ItemName="German P38 Bullets"

	WeaponKick=(x=50,y=0,z=100)
	WeaponKickZoomed=(x=100,y=0,z=400)

	KickRecoverRate = 6.0;

    PickupClass=class'PickupAmmoDEP38_'
    MaxAmmo=96
    InitialAmount=24

	AmmoShellClass=class'ShellDEP38_'
}
class AmmoDEPanzerfaust extends gbxAmmo;


defaultproperties
{
    ItemName="German Panzerfaust Ammo"

	//WeaponKick=(x=200,y=25,z=800)
	WeaponKick=(x=125,y=0,z=350)
	WeaponKickZoomed=(x=150,y=10,z=600)

	KickRecoverRate = 5.0;

    PickupClass=class'PickupAmmoDEPanzerfaust'
    MaxAmmo=1
    InitialAmount=1

	AmmoShellClass=None
	BulletTracerClass=None
}
class AmmoDEPanzerMain extends gbxAmmo;


defaultproperties
{
    ItemName="US Stuart Main"

	//WeaponKick=(x=200,y=25,z=800)
	WeaponKick=(x=125,y=0,z=350)
	WeaponKickZoomed=(x=150,y=10,z=600)

	KickRecoverRate = 5.0;

    PickupClass=None
    MaxAmmo=200
    InitialAmount=200

	AmmoShellClass=None
	BulletTracerClass=None
}
class AmmoDESTG44_ extends gbxAmmo;


defaultproperties
{
    ItemName="US BAR Bullets"

	WeaponKick=(x=125,y=0,z=400)
	WeaponKickZoomed=(x=100,y=0,z=300)

	KickRecoverRate = 6;

    PickupClass=class'PickupAmmoDESTG44_'
    MaxAmmo=210
    InitialAmount=120

	AmmoShellClass=class'ShellDESTG44_'
	BulletTracerClass=class'EmitterBulletTracerUS'
}
class AmmoDEStugMain extends gbxAmmo;


defaultproperties
{
    ItemName="DE Stug Main"

	//WeaponKick=(x=200,y=25,z=800)
	WeaponKick=(x=125,y=0,z=350)
	WeaponKickZoomed=(x=150,y=10,z=600)

	KickRecoverRate = 5.0;

    PickupClass=None
    MaxAmmo=200
    InitialAmount=200

	AmmoShellClass=None
	BulletTracerClass=None
}
class AmmoUSBar extends gbxAmmo;


defaultproperties
{
    ItemName="US BAR Bullets"

	WeaponKick=(x=125,y=0,z=400)
	WeaponKickZoomed=(x=100,y=0,z=300)

	KickRecoverRate = 4;

    PickupClass=class'PickupAmmoUSBar'
    MaxAmmo=240
    InitialAmount=120

	AmmoShellClass=class'ShellUSBar'
	BulletTracerClass=class'EmitterBulletTracerUS'
}
class AmmoUSBazooka extends gbxAmmo;


defaultproperties
{
    ItemName="US Bazooka Ammo"

	//WeaponKick=(x=200,y=25,z=800)
	WeaponKick=(x=125,y=0,z=350)
	WeaponKickZoomed=(x=150,y=10,z=600)

	KickRecoverRate = 5.0;

    PickupClass=class'PickupAmmoUSBazooka'
    MaxAmmo=10
    InitialAmount=5

	AmmoShellClass=None
	BulletTracerClass=class'EmitterBulletTracerGeneric'
}
class AmmoUSColt1911_ extends gbxAmmo;


defaultproperties
{
    ItemName="US .45 Bullets"

	WeaponKick=(x=100,y=0,z=200)
	WeaponKickZoomed=(x=150,y=0,z=600)

	KickRecoverRate = 6.0;

    PickupClass=class'PickupAmmoUSColt1911_'
    MaxAmmo=84
    InitialAmount=21

	AmmoShellClass=class'ShellUSColt1911_'
}
//=============================================================================
// US M10 tank 50 cal. machine gun ammunition class.
//=============================================================================
class AmmoUSM10_50cal extends gbxAmmo;


//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
    ItemName="US M10 tank 50 cal ammunition"

    PickupClass=None
    MaxAmmo=400
    InitialAmount=400

	bUnlimited=true
	BulletTracerClass=class'EmitterBulletTracerUS'
	AmmoShellClass=class'ShellUSM1_'

	WeaponKick=(x=0,y=0,z=0)
	WeaponKickMin=(x=-100,y=0,z=-50)
	WeaponKickMax=(x=100,y=0,z=400)
	WeaponKickZoomed=(x=0,y=0,z=0)
	WeaponKickZoomedMin=(x=-100,y=0,z=-50)
	WeaponKickZoomedMax=(x=100,y=0,z=400)
	KickRecoverRate=3.0;
	KickRecoverRateZoomed=3.0;
	bRandomizeWeaponKick=true
}
class AmmoUSM10_Main extends gbxAmmo;


defaultproperties
{
    ItemName="US M10 Main"

	//WeaponKick=(x=200,y=25,z=800)
	WeaponKick=(x=125,y=0,z=350)
	WeaponKickZoomed=(x=150,y=10,z=600)

	KickRecoverRate = 5.0;

    PickupClass=None
    MaxAmmo=200
    InitialAmount=200

	AmmoShellClass=None
	BulletTracerClass=None
}
class AmmoUSM1Carbine extends gbxAmmo;


defaultproperties
{
    ItemName="US Carbine Bullets"

	//WeaponKick=(x=200,y=25,z=800)
	WeaponKick=(x=125,y=0,z=250)
	WeaponKickZoomed=(x=150,y=10,z=600)

	KickRecoverRate = 2.5

    PickupClass=class'PickupAmmoUSM1Carbine'
    MaxAmmo=75
    InitialAmount=45

	AmmoShellClass=class'ShellUSM1_'
	BulletTracerClass=class'EmitterBulletTracerGeneric'
}
class AmmoUSM1_ extends gbxAmmo;


defaultproperties
{
    ItemName="US M1 Bullets"

	//WeaponKick=(x=200,y=25,z=800)
	WeaponKick=(x=125,y=0,z=300)
	WeaponKickZoomed=(x=150,y=10,z=1000)

	KickRecoverRate = 1.6;

    PickupClass=class'PickupAmmoUSM1_'
    MaxAmmo=88
    InitialAmount=48

	AmmoShellClass=class'ShellUSM1_'
	BulletTracerClass=class'EmitterBulletTracerGeneric'
}
class AmmoUSM3A1_ extends gbxAmmo;


defaultproperties
{
    ItemName="US M3A1 Sub-Machine Gun Bullets"

	WeaponKick=(x=125,y=0,z=350)
	WeaponKickZoomed=(x=75,y=0,z=200)

	KickRecoverRate = 6.0;

	PickupClass=class'PickupAmmoUSM3A1_'

	MaxAmmo=210
	InitialAmount=120

	AmmoShellClass=class'ShellUSM3A1_'
	BulletTracerClass=class'EmitterBulletTracerGeneric'
}
//=============================================================================
// US Sherman tank 50 cal. machine gun ammunition class.
//=============================================================================
class AmmoUSSherman50cal extends gbxAmmo;


//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
    ItemName="US Sherman tank 50 cal ammunition"

    PickupClass=None
    MaxAmmo=400
    InitialAmount=400

	bUnlimited=true
	BulletTracerClass=class'EmitterBulletTracerUS'
	AmmoShellClass=class'ShellUSM1_'

	WeaponKick=(x=0,y=0,z=0)
	WeaponKickMin=(x=-100,y=0,z=-50)
	WeaponKickMax=(x=100,y=0,z=400)
	WeaponKickZoomed=(x=0,y=0,z=0)
	WeaponKickZoomedMin=(x=-100,y=0,z=-50)
	WeaponKickZoomedMax=(x=100,y=0,z=400)
	KickRecoverRate=3.0;
	KickRecoverRateZoomed=3.0;
	bRandomizeWeaponKick=true
}
class AmmoUSShermanMain extends gbxAmmo;


defaultproperties
{
    ItemName="US Sherman Main"

	//WeaponKick=(x=200,y=25,z=800)
	WeaponKick=(x=125,y=0,z=350)
	WeaponKickZoomed=(x=150,y=10,z=600)

	KickRecoverRate = 5.0;

    PickupClass=None
    MaxAmmo=200
    InitialAmount=200

	AmmoShellClass=None
	BulletTracerClass=None
}
class AmmoUSSpringfield extends gbxAmmo;


defaultproperties
{
    ItemName="US Carbine Bullets"

	//WeaponKick=(x=200,y=25,z=800)
	WeaponKick=(x=125,y=0,z=350)
	WeaponKickZoomed=(x=150,y=10,z=600)

	KickRecoverRate = 1.8;

    PickupClass=class'PickupAmmoUSSpringfield'
    MaxAmmo=55
    InitialAmount=30

	AmmoShellClass=class'ShellUSM1_'
	BulletTracerClass=class'EmitterBulletTracerGeneric'
}
//=============================================================================
// US Stuart tank 30 cal. machine gun ammunition class.
//=============================================================================
class AmmoUSStuart30cal extends gbxAmmo;


//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
    ItemName="US Stuart tank 30 cal ammunition"

    PickupClass=None
    MaxAmmo=400
    InitialAmount=400

	bUnlimited=true
	BulletTracerClass=class'EmitterBulletTracerUS'
	AmmoShellClass=class'ShellUSM1_'

	WeaponKick=(x=0,y=0,z=0)
	WeaponKickMin=(x=-100,y=0,z=-50)
	WeaponKickMax=(x=100,y=0,z=400)
	WeaponKickZoomed=(x=0,y=0,z=0)
	WeaponKickZoomedMin=(x=-100,y=0,z=-50)
	WeaponKickZoomedMax=(x=100,y=0,z=400)
	KickRecoverRate=3.0;
	KickRecoverRateZoomed=3.0;
	bRandomizeWeaponKick=true
}
class AmmoUSStuartMain extends gbxAmmo;


defaultproperties
{
    ItemName="US Stuart Main"

	//WeaponKick=(x=200,y=25,z=800)
	WeaponKick=(x=125,y=0,z=350)
	WeaponKickZoomed=(x=150,y=10,z=600)

	KickRecoverRate = 5.0;

    PickupClass=None
    MaxAmmo=200
    InitialAmount=200

	AmmoShellClass=None
	BulletTracerClass=None
}
class AmmoUSThompson extends gbxAmmo;


defaultproperties
{
    ItemName="US M1A1 Sub-Machine Gun Bullets"

	WeaponKick=(x=125,y=0,z=350)
	WeaponKickZoomed=(x=75,y=0,z=200)

	KickRecoverRate = 6.0;

	PickupClass=class'PickupAmmoUSThompson'

	MaxAmmo=140
	InitialAmount=80

	AmmoShellClass=class'ShellUSThompson'
	BulletTracerClass=class'EmitterBulletTracerGeneric'
}
class AnimNotify_FiregbxWeapon extends AnimNotify_Scripted;



event Notify( Actor Owner )
{
	if (Owner.IsA('gbxWeapon'))
	{

	}
}
class AttachmentDEFG42Sniper extends InstantFireWeaponAttachment;


simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();
	
	SetStaticMesh(StaticMesh(DynamicLoadObject("s_npc_weapon_de.de_fg42_sniper", class'StaticMesh')));
}

defaultproperties
{
	DrawScale=1.0
//    StaticMesh=StaticMesh's_npc_weapon_de.de_fg42_sniper'
	DrawType=DT_StaticMesh

    //MuzFlashClass=class'gbxEffects.MuzzleFlashBar'
    //bFlashForPrimary=true
    //bFlashLight=true

    LightType=LT_Pulse
    LightEffect=LE_NonIncidence
    LightPeriod=3
    LightBrightness=50
    LightHue=30
    LightSaturation=150
    LightRadius=4.0

	RelativeLocation=(X=0.000000,Y=1.0000,Z=-0.3000)

	MuzzleTagName=rifle_muzzle
	ChamberTagName=rifle_chamber

	PawnAnimInfoClass=class'PawnAnimInfoFinalMachineGun'

	bUseTracers=true
	bFirstPersonTracers=false
	TracerFrequency=3
}
class AttachmentDEFG42_ extends InstantFireWeaponAttachment;


simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();
	
	SetStaticMesh(StaticMesh(DynamicLoadObject("s_npc_weapon_de.de_fg42", class'StaticMesh')));
}

defaultproperties
{
	DrawScale=1.0
//    StaticMesh=StaticMesh's_npc_weapon_de.de_fg42'
	DrawType=DT_StaticMesh

    //MuzFlashClass=class'gbxEffects.MuzzleFlashBar'
    //bFlashForPrimary=true
    //bFlashLight=true

    LightType=LT_Pulse
    LightEffect=LE_NonIncidence
    LightPeriod=3
    LightBrightness=50
    LightHue=30
    LightSaturation=150
    LightRadius=4.0

	RelativeLocation=(X=0.000000,Y=1.0000,Z=-0.3000)

	MuzzleTagName=rifle_muzzle
	ChamberTagName=rifle_chamber

	PawnAnimInfoClass=class'PawnAnimInfoFinalMachineGun'

	bUseTracers=true
	bFirstPersonTracers=false
	TracerFrequency=3
}
class AttachmentDEFlakvierling extends InstantFireWeaponAttachment;

simulated event ThirdPersonEffects()
{
}

//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
	PawnAnimInfoClass=class'PawnAnimInfoFinalFlakvierling'
}
//=============================================================================
// German MG42 3rd person attachment class.
//
// Author: Neil Johnson, Gearbox Software.
//=============================================================================
class AttachmentDEHalftrackMG42_ extends InstantFireWeaponAttachment;



var int Flash;
var String	FirstPersonShellSoundName;
var Cue	FirstPersonShellSound;

//---------------------------------------------------------
//	ThirdPersonEffects
//---------------------------------------------------------
simulated event ThirdPersonEffects()
{
	local Vector MuzzleVec;

	if (FlashCount==0)
		return;

	// GBX:naj - MG42's have neither firing nor reload animations.  
	// Thus there are no calls here to Instigator.PlayFiring() or PlayReload()
	// as you might see with normal weapons.

	if ((MyAmmoTypeClass != None) && (FiringMode == WEAP_StateFiring))
	{
		MuzzleVec = GetMuzzleLocationWorld();

		if ( FiringMode == WEAP_StateFiring )
		{
			FlashMuzzleFlash( MuzzleVec );
			
			DoImpactEffects();

			if ((Instigator != None) && (Instigator.DrawType != DT_StaticMesh))
				EjectShell( GetChamberLocationWorld(), MyAmmoTypeClass.Default.AmmoShellClass );

			if( bUseTracers )
			{
				SendTracer( MuzzleVec, MyAmmoTypeClass.Default.BulletTracerClass );
			}
			if (gbxAmmo(Instigator.Weapon.Ammo[0]) != None)
				gbxAmmo(Instigator.Weapon.Ammo[0]).ApplyKick();
		}
	}
}

//---------------------------------------------------------
//	GetMuzzleLocationWorld
//---------------------------------------------------------
simulated function Vector GetMuzzleLocationWorld()
{
	local Vector X,Y,Z;
	GetAxes(Instigator.Weapon.Rotation, X,Y,Z);
	return Instigator.Weapon.Location + (MuzzleOffset.X*X) + (MuzzleOffset.Y*Y) + (MuzzleOffset.Z*Z);
}

//---------------------------------------------------------
//	InitFor
//---------------------------------------------------------
function InitFor(Inventory I)
{
	Instigator = I.Instigator;
}

//---------------------------------------------------------
//	FlashMuzzleFlash
//---------------------------------------------------------
simulated function FlashMuzzleFlash( Vector Location )
{
	if ( Instigator != None && Instigator.Weapon != None &&
		Instigator.Weapon.IsA( 'WeapDEHalftrackMG42_' ) && Level.TimeSeconds - LastFlashTime > MinFlashInterval )
	{
		WeapDEHalftrackMG42_( Instigator.Weapon ).FlashMuzzleFlash();
		LastFlashTime = Level.TimeSeconds;
	}
}

//---------------------------------------------------------
//	EjectShell
//---------------------------------------------------------
simulated function bool EjectShell( Vector Location, class<gbxWeaponShells> ShellClass )
{
	local bool	bEjected;
	
	if (	( Flash % 2 ) == 0 &&
			Instigator != None && Instigator.Weapon != None &&
			Instigator.Weapon.IsA( 'WeapDEHalftrackMG42_' ) )
	{
		if ( WeapDEHalftrackMG42_( Instigator.Weapon ).CanSpawnShellCasing() )
			bEjected = super.EjectShell( Location, ShellClass );
		
		if ( WeapDEHalftrackMG42_( Instigator.Weapon ).ShouldPlayFirstPersonShellSound() )
		{
			if( FirstPersonShellSound == None && FirstPersonShellSoundName != "" )
			{
				FirstPersonShellSound = LoadSound( FirstPersonShellSoundName );
			}

			Instigator.PlayOwnedSoundCue( FirstPersonShellSound, SLOT_None,,,,, );
		}
	}

	Flash++;
	
	return bEjected;
}

//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
    LightType=LT_Pulse
    LightEffect=LE_NonIncidence
    LightPeriod=3
    LightBrightness=50
    LightHue=30
    LightSaturation=150
    LightRadius=4.0

	bUseTracers=true;
	TracerFrequency=3;

	RelativeLocation=(X=0.000000,Y=1.0000,Z=-0.3000)

	MuzzleOffset=(X=110,Y=0,Z=0)

	FirstPersonShellSoundName="GEAR.SHELL"
	PawnAnimInfoClass=class'PawnAnimInfoFinalHalftrackMG42_'

	MinFlashInterval=0.1
}
class AttachmentDEK98Sniper extends InstantFireWeaponAttachment;


simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();
	
	SetStaticMesh(StaticMesh(DynamicLoadObject("s_npc_weapon_de.de_k98_sniper", class'StaticMesh')));
}

defaultproperties
{
	DrawScale=1.0
//    StaticMesh=StaticMesh's_npc_weapon_de.de_k98_sniper'
	DrawType=DT_StaticMesh

    LightType=LT_Pulse
    LightEffect=LE_NonIncidence
    LightPeriod=3
    LightBrightness=50
    LightHue=30
    LightSaturation=150
    LightRadius=4.0

	RelativeLocation=(X=0.000000,Y=1.0000,Z=-0.3000)

	MuzzleTagName=rifle_muzzle
	ChamberTagName=rifle_chamber

	bUseTracers=true
	TracerFrequency=1

	PawnAnimInfoClass=class'PawnAnimInfoFinalK98_'
}
class AttachmentDEK98_ extends InstantFireWeaponAttachment;


simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();
	
	SetStaticMesh(StaticMesh(DynamicLoadObject("s_npc_weapon_de.de_k98", class'StaticMesh')));
}

defaultproperties
{
	DrawScale=1.0
//    StaticMesh=StaticMesh's_npc_weapon_de.de_k98'
	DrawType=DT_StaticMesh

    LightType=LT_Pulse
    LightEffect=LE_NonIncidence
    LightPeriod=3
    LightBrightness=50
    LightHue=30
    LightSaturation=150
    LightRadius=4.0

	RelativeLocation=(X=0.000000,Y=1.0000,Z=-0.3000)

	MuzzleTagName=rifle_muzzle
	ChamberTagName=rifle_chamber

	bUseTracers=true
	TracerFrequency=1

	PawnAnimInfoClass=class'PawnAnimInfoFinalK98_'
}
//=============================================================================
// German MG42 3rd person attachment class.
//
// Author: Neil Johnson, Gearbox Software.
//=============================================================================
class AttachmentDEMG42_ extends InstantFireWeaponAttachment;



var int Flash;
var String	FirstPersonShellSoundName;
var Cue	FirstPersonShellSound;

var Rotator		WeaponRotation;
var Vector	WeaponLocation;

replication 
{
	unreliable if ( Role==ROLE_Authority && bNetDirty )
		WeaponRotation, WeaponLocation;
}

//---------------------------------------------------------
//	ThirdPersonEffects
//---------------------------------------------------------
simulated event ThirdPersonEffects()
{
	local Vector MuzzleVec;
	//Log( " AttachmentDEMG42_::ThirdPersonEffects() FlashCount="$FlashCount$" FiringMode="$FiringMode$" MyAmmoTypeClass="$MyAmmoTypeClass, 'MP' );

	if (FlashCount==0)
		return;

	// GBX:naj - MG42's have neither firing nor reload animations.  
	// Thus there are no calls here to Instigator.PlayFiring() or PlayReload()
	// as you might see with normal weapons.

	if ((MyAmmoTypeClass != None) && (FiringMode == WEAP_StateFiring))
	{
		MuzzleVec = GetMuzzleLocationWorld();

		if ( FiringMode == WEAP_StateFiring )
		{
			FlashMuzzleFlash( MuzzleVec );
			
			DoImpactEffects();

			if ((Instigator != None) && (Instigator.DrawType != DT_StaticMesh))
				EjectShell( GetChamberLocationWorld(), MyAmmoTypeClass.Default.AmmoShellClass );

			if( bUseTracers )
			{
				//Log( " AttachmentDEMG42_::ThirdPersonEffects() Calling SendTracer() MyAmmoTypeClass.Default.BulletTracerClass="$MyAmmoTypeClass.Default.BulletTracerClass, 'MP' );
				SendTracer( MuzzleVec, MyAmmoTypeClass.Default.BulletTracerClass );
			}
			if (gbxAmmo(Instigator.Weapon.Ammo[0]) != None)
				gbxAmmo(Instigator.Weapon.Ammo[0]).ApplyKick();
		}
	}
}

simulated function Tick( float delta )
{
	if ( Instigator != None && Instigator.Weapon != None )
	{
		//Log( " AttachmentDEMG42_::Tick() Updating weapon rotation and location vars for client. WeaponRotation="$WeaponRotation$" WeaponLocation="$WeaponLocation, 'MP' );
		WeaponRotation = Instigator.Weapon.Rotation;
		WeaponLocation = Instigator.Weapon.Location;
	}
}

//---------------------------------------------------------
//	GetMuzzleLocationWorld
//---------------------------------------------------------
simulated function Vector GetMuzzleLocationWorld()
{
	local Vector X,Y,Z;
	local Vector result;

	//Log( " AttachmentDEMG42_::GetMuzzleLocationWorld() Owner="$Owner$" WeaponRotation="$WeaponRotation$" Instigator="$Instigator$" WeaponLocation="$WeaponLocation$" Instigator.Weapon="$Instigator.Weapon$" Instigator.Rotation="$Instigator.Rotation$" Instigator.Weapon.Rotation="$Instigator.Weapon.Rotation$" Instigator.Weapon.Location="$Instigator.Weapon.Location$" Location="$Location, 'MP' );

	if ( Role < ROLE_Authority )
	{
		//GetAxes(Instigator.Rotation, X,Y,Z);
		GetAxes(WeaponRotation, X, Y, Z);
		result = WeaponLocation + (MuzzleOffset.X*X) + (MuzzleOffset.Y*Y) + (MuzzleOffset.Z*Z);
		//Log( " AttachmentDEMG42_::GetMuzzleLocationWorld() returning result="$result, 'MP' );
	}
	else
	{
	GetAxes(Instigator.Weapon.Rotation, X,Y,Z);
		result= Instigator.Weapon.Location + (MuzzleOffset.X*X) + (MuzzleOffset.Y*Y) + (MuzzleOffset.Z*Z);
		//Log( " AttachmentDEMG42_::GetMuzzleLocationWorld() returning temp="$temp, 'MP' );
	}

     return result;
}

//---------------------------------------------------------
//	InitFor
//---------------------------------------------------------
function InitFor(Inventory I)
{
	Instigator = I.Instigator;
}

//---------------------------------------------------------
//	FlashMuzzleFlash
//---------------------------------------------------------
simulated function FlashMuzzleFlash( Vector Location )
{
	//Log( " AttachmentDEMG42_::FlashMuzzleFlash() Instigator="$Instigator$" Instigator.Weapon="$Instigator.Weapon$" Level.TimeSeconds="$Level.TimeSeconds$" LastFlashTime="$LastFlashTime$" MinFlashInterval="$MinFlashInterval, 'MP' );

	if ( Role < ROLE_Authority )
	{
		Super.FlashMuzzleFlash( Location );		
	}
	else
	{
	if ( Instigator != None && Instigator.Weapon != None &&
		Instigator.Weapon.IsA( 'WeapDEMG42_' ) && Level.TimeSeconds - LastFlashTime > MinFlashInterval )
	{
		WeapDEMG42_( Instigator.Weapon ).FlashMuzzleFlash();
		LastFlashTime = Level.TimeSeconds;
	}
}
}

//---------------------------------------------------------
//	EjectShell
//---------------------------------------------------------
simulated function bool EjectShell( Vector Location, class<gbxWeaponShells> ShellClass )
{
	local bool	bEjected;
	
	if (	( Flash % 2 ) == 0 &&
			Instigator != None && Instigator.Weapon != None &&
			Instigator.Weapon.IsA( 'WeapDEMG42_' ) )
	{
		if ( WeapDEMG42_( Instigator.Weapon ).CanSpawnShellCasing() )
			bEjected = super.EjectShell( Location, ShellClass );
		
		if ( WeapDEMG42_( Instigator.Weapon ).ShouldPlayFirstPersonShellSound() )
		{
			if( FirstPersonShellSound == None && FirstPersonShellSoundName != "" )
			{
				FirstPersonShellSound = LoadSound( FirstPersonShellSoundName );
			}

			Instigator.PlayOwnedSoundCue( FirstPersonShellSound, SLOT_None,,,,, );
		}
	}

	Flash++;
	
	return bEjected;
}

//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
    LightType=LT_Pulse
    LightEffect=LE_NonIncidence
    LightPeriod=3
    LightBrightness=50
    LightHue=30
    LightSaturation=150
    LightRadius=4.0

	bUseTracers=true;
	TracerFrequency=3;

	RelativeLocation=(X=0.000000,Y=1.0000,Z=-0.3000)

	//MuzzleOffset=(X=63,Y=0,Z=15)
	MuzzleOffset=(X=55,Y=0,Z=0)

	FirstPersonShellSoundName="GEAR.SHELL"
	PawnAnimInfoClass=class'PawnAnimInfoFinalMG42_'

	MinFlashInterval=0.1

	bAlwaysRelevant=true
	bSkipActorPropertyReplication=false
}
class AttachmentDEMP40_ extends InstantFireWeaponAttachment;


simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();
	
	SetStaticMesh(StaticMesh(DynamicLoadObject("s_npc_weapon_de.de_mp40", class'StaticMesh')));
}

defaultproperties
{
	DrawScale=1.0
//    StaticMesh=StaticMesh's_npc_weapon_de.de_mp40'
	DrawType=DT_StaticMesh

    //MuzFlashClass=class'gbxEffects.MuzzleFlashThompson'
    //bFlashForPrimary=true
    //bFlashLight=true

    LightType=LT_Pulse
    LightEffect=LE_NonIncidence
    LightPeriod=3
    LightBrightness=50
    LightHue=30
    LightSaturation=150
    LightRadius=4.0

	RelativeLocation=(X=0.000000,Y=1.0000,Z=-0.3000)

	MuzzleTagName=rifle_muzzle_mp40
	ChamberTagName=rifle_chamber

	bUseTracers=true
	bFirstPersonTracers=false
	TracerFrequency=1

	PawnAnimInfoClass=class'PawnAnimInfoFinalSubMachineGun'
}
class AttachmentDEP38_ extends InstantFireWeaponAttachment;


simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();
	
	SetStaticMesh(StaticMesh(DynamicLoadObject("s_npc_weapon_de.de_p38", class'StaticMesh')));
}

defaultproperties
{
	DrawScale=1.0
//    StaticMesh=StaticMesh's_npc_weapon_de.de_p38'
	DrawType=DT_StaticMesh

    //MuzFlashClass=class'gbxEffects.MuzzleFlashColt1911_'
    //bFlashForPrimary=true
    //bFlashLight=true

    LightType=LT_Pulse
    LightEffect=LE_NonIncidence
    LightPeriod=3
    LightBrightness=50
    LightHue=30
    LightSaturation=150
    LightRadius=4.0

	RelativeLocation=(X=0.000000,Y=1.0000,Z=-0.3000)

	MuzzleTagName=pistol_muzzle
	ChamberTagName=pistol_chamber

	PawnAnimInfoClass=class'PawnAnimInfoFinalOneHand'

	bUseTracers=false
	bFirstPersonTracers=false
}
class AttachmentDEPak36_ extends InstantFireWeaponAttachment;

simulated function Vector GetMuzzleLocationWorld()
{
	local Coords C;

	C = Instigator.Weapon.GetTagCoords( MuzzleTagName );
	return C.Origin;
}

//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
	PawnAnimInfoClass=class'PawnAnimInfoFinalPak36_'
	MuzzleTagName=muzzle
}
class AttachmentDEPak88_ extends InstantFireWeaponAttachment;

simulated function Vector GetMuzzleLocationWorld()
{
	local Coords C;

	C = Instigator.Weapon.GetTagCoords( MuzzleTagName );
	return C.Origin;
}

//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
	PawnAnimInfoClass=class'PawnAnimInfoFinalPak88_'
	MuzzleTagName=barrel
}
class AttachmentDEPanzerfaust extends gbxWeaponAttachment;

simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();
	
	SetStaticMesh(StaticMesh(DynamicLoadObject("s_npc_weapon_de.de_panzerfaust", class'StaticMesh')));
}

simulated function FlashMuzzleFlash( Vector MuzzleLocation )
{
	if (MuzFlash == None)
	{
		if (Instigator.IsFirstPerson())
		{
			if (gbxWeapon(Instigator.Weapon) != None)
				MuzFlash = gbxWeapon(Instigator.Weapon).GetMuzzleFlash();
		}
		else
		{
			MuzFlash = Spawn( MuzFlashClass, None );
		}
	}

	if (MuzFlash != None)
	{
		if( Level.TimeSeconds - LastFlashTime > MinFlashInterval )
		{
			MuzFlash.SetLocation( MuzzleLocation );

			if( Instigator.IsFirstPerson() )
			{
				MuzFlash.SetRotation( Instigator.GetViewRotation() );
			}
			else
			{
				MuzFlash.SetRotation( Rotation );
			}

			MuzFlash.Flash();
			LastFlashTime = Level.TimeSeconds;
		}
	}
}

simulated function DrawMuzzleFlash( Canvas canvas )
{
}

defaultproperties
{
	DrawScale=1.0
//    StaticMesh=StaticMesh's_npc_weapon_de.de_panzerfaust'
	DrawType=DT_StaticMesh

    LightType=LT_Pulse
    LightEffect=LE_NonIncidence
    LightPeriod=3
    LightBrightness=50
    LightHue=30
    LightSaturation=150
    LightRadius=4.0

	RelativeLocation=(X=0.000000,Y=1.0000,Z=-0.3000)

	MuzzleTagName=rifle_muzzle
	ChamberTagName=rifle_chamber

	bUseTracers=true
	TracerFrequency=1

	PawnAnimInfoClass=class'PawnAnimInfoFinalTwoHand'
	MuzFlashClass=class'gbxEffects.MuzzleFlashPanzerfaust'
}
class AttachmentDESTG44_ extends InstantFireWeaponAttachment;


simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();
	
	SetStaticMesh(StaticMesh(DynamicLoadObject("s_npc_weapon_de.de_stg44", class'StaticMesh')));
}

defaultproperties
{
	DrawScale=1.0
//    StaticMesh=StaticMesh's_npc_weapon_de.de_stg44'
	DrawType=DT_StaticMesh

    //MuzFlashClass=class'gbxEffects.MuzzleFlashBar'
    //bFlashForPrimary=true
    //bFlashLight=true

    LightType=LT_Pulse
    LightEffect=LE_NonIncidence
    LightPeriod=3
    LightBrightness=50
    LightHue=30
    LightSaturation=150
    LightRadius=4.0

	RelativeLocation=(X=0.000000,Y=1.0000,Z=-0.3000)

	MuzzleTagName=rifle_muzzle_stg44
	ChamberTagName=rifle_chamber

	PawnAnimInfoClass=class'PawnAnimInfoFinalMachineGun'

	bUseTracers=true
	bFirstPersonTracers=false
	TracerFrequency=3
}
class AttachmentUSBar extends InstantFireWeaponAttachment;


simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();
	
	SetStaticMesh(StaticMesh(DynamicLoadObject("s_npc_weapon_us.us_bar", class'StaticMesh')));
}

defaultproperties
{
	DrawScale=1.0
//    StaticMesh=StaticMesh's_npc_weapon_us.us_bar'
	DrawType=DT_StaticMesh

    //MuzFlashClass=class'gbxEffects.MuzzleFlashBar'
    //bFlashForPrimary=true
    //bFlashLight=true

    LightType=LT_Pulse
    LightEffect=LE_NonIncidence
    LightPeriod=3
    LightBrightness=50
    LightHue=30
    LightSaturation=150
    LightRadius=4.0

	RelativeLocation=(X=0.000000,Y=1.0000,Z=-0.3000)

	MuzzleTagName=rifle_muzzle_bar
	ChamberTagName=rifle_chamber

	PawnAnimInfoClass=class'PawnAnimInfoFinalMachineGun'

	bUseTracers=true
	bFirstPersonTracers=false
	TracerFrequency=3
}
class AttachmentUSBazooka extends gbxWeaponAttachment;


simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();
	
	SetStaticMesh(StaticMesh(DynamicLoadObject("s_npc_weapon_us.us_bazooka", class'StaticMesh')));
}

defaultproperties
{
	DrawScale=1.0
//    StaticMesh=StaticMesh's_npc_weapon_us.us_bazooka'
	DrawType=DT_StaticMesh

    //MuzFlashClass=class'gbxEffects.MuzzleFlashM1_'
    //bFlashForPrimary=true
    //bFlashLight=true

    LightType=LT_Pulse
    LightEffect=LE_NonIncidence
    LightPeriod=3
    LightBrightness=50
    LightHue=30
    LightSaturation=150
    LightRadius=4.0

	RelativeLocation=(X=0.000000,Y=1.0000,Z=-0.3000)

	MuzzleTagName=rifle_muzzle
	ChamberTagName=rifle_chamber

	bUseTracers=true
	TracerFrequency=1

	PawnAnimInfoClass=class'PawnAnimInfoFinalTwoHand'
	MuzFlashClass=class'gbxEffects.MuzzleFlashBazooka'
}
class AttachmentUSColt1911Baker extends AttachmentUSColt1911_;

defaultproperties
{
	Skins(0)=Texture't_npc_weapon_us.us_colt_father'
}
class AttachmentUSColt1911_ extends InstantFireWeaponAttachment;


simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();
	
	SetStaticMesh(StaticMesh(DynamicLoadObject("s_npc_weapon_us.us_colt", class'StaticMesh')));
}

defaultproperties
{
	DrawScale=1.0
//    StaticMesh=StaticMesh's_npc_weapon_us.us_colt'
	DrawType=DT_StaticMesh

    //MuzFlashClass=class'gbxEffects.MuzzleFlashColt1911_'
    //bFlashForPrimary=true
    //bFlashLight=true

    LightType=LT_Pulse
    LightEffect=LE_NonIncidence
    LightPeriod=3
    LightBrightness=50
    LightHue=30
    LightSaturation=150
    LightRadius=4.0

	RelativeLocation=(X=0.000000,Y=1.0000,Z=-0.3000)

	MuzzleTagName=pistol_muzzle
	ChamberTagName=pistol_chamber

	PawnAnimInfoClass=class'PawnAnimInfoFinalOneHand'

	bUseTracers=false
	bFirstPersonTracers=false
}
//=============================================================================
// US M10 tank 50 cal. machine gun 3rd person attachment class.
//=============================================================================
class AttachmentUSM10_50cal extends InstantFireWeaponAttachment;



var int Flash;
//---------------------------------------------------------
//	ThirdPersonEffects
//---------------------------------------------------------
simulated event ThirdPersonEffects()
{
	local Vector MuzzleVec;

	if (FlashCount==0)
		return;

	if ((MyAmmoTypeClass != None) && (FiringMode == WEAP_StateFiring))
	{
		MuzzleVec = GetMuzzleLocationWorld();

		if ( FiringMode == WEAP_StateFiring )
		{
			FlashMuzzleFlash( MuzzleVec );

			DoImpactEffects();
			
			if ((Instigator != None) && (Instigator.DrawType != DT_StaticMesh))
				EjectShell( GetChamberLocationWorld(), MyAmmoTypeClass.Default.AmmoShellClass );

			if( bUseTracers )
			{
				SendTracer( MuzzleVec, MyAmmoTypeClass.Default.BulletTracerClass );
			}
			if (gbxAmmo(Instigator.Weapon.Ammo[0]) != None)
				gbxAmmo(Instigator.Weapon.Ammo[0]).ApplyKick();
		}
	}
}

//---------------------------------------------------------
//	GetMuzzleLocationWorld
//---------------------------------------------------------
simulated function Vector GetMuzzleLocationWorld()
{
	local Vector X,Y,Z;
	GetAxes(Instigator.Weapon.Rotation, X,Y,Z);
	return Instigator.Weapon.Location + (MuzzleOffset.X*X) + (MuzzleOffset.Y*Y) + (MuzzleOffset.Z*Z);
}

//---------------------------------------------------------
//	InitFor
//---------------------------------------------------------
function InitFor(Inventory I)
{
	Instigator = I.Instigator;
}

//---------------------------------------------------------
//	FlashMuzzleFlash
//---------------------------------------------------------
simulated function FlashMuzzleFlash( Vector Location )
{
	if ( Instigator != None && Instigator.Weapon != None &&
		Instigator.Weapon.IsA( 'WeapUSM10_50cal' ) && Level.TimeSeconds - LastFlashTime > MinFlashInterval )
	{
		WeapUSM10_50cal( Instigator.Weapon ).FlashMuzzleFlash();
		LastFlashTime = Level.TimeSeconds;
	}
}

//---------------------------------------------------------
//	EjectShell
//---------------------------------------------------------
simulated function bool EjectShell( Vector Location, class<gbxWeaponShells> ShellClass )
{
	local bool	bEjected;
	
	if (	( Flash % 2 ) == 0 &&
			Instigator != None && Instigator.Weapon != None &&
			Instigator.Weapon.IsA( 'WeapUSM10_50cal' ) )
	{
		if ( WeapUSM10_50cal( Instigator.Weapon ).CanSpawnShellCasing() )
			bEjected = super.EjectShell( Location, ShellClass );	
	}

	Flash++;
	
	return bEjected;
}

//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
    LightType=LT_Pulse
    LightEffect=LE_NonIncidence
    LightPeriod=3
    LightBrightness=50
    LightHue=30
    LightSaturation=150
    LightRadius=4.0

	bUseTracers=true;
	TracerFrequency=3;

	RelativeLocation=(X=0.000000,Y=1.0000,Z=-0.3000)

	MuzzleOffset=(X=45,Y=0,Z=0)

	PawnAnimInfoClass=class'PawnAnimInfoFinalM10_50cal'
}
//=============================================================================
// US M1919 3rd person attachment class.
//
// Author: Neil Johnson, Gearbox Software.
//=============================================================================
class AttachmentUSM1919_ extends InstantFireWeaponAttachment;



var int Flash;
//---------------------------------------------------------
//	ThirdPersonEffects
//---------------------------------------------------------
simulated event ThirdPersonEffects()
{
	local Vector MuzzleVec;

	if (FlashCount==0)
		return;

	// GBX:naj - MG42's have neither firing nor reload animations.  
	// Thus there are no calls here to Instigator.PlayFiring() or PlayReload()
	// as you might see with normal weapons.

	if ((MyAmmoTypeClass != None) && (FiringMode == WEAP_StateFiring))
	{
		MuzzleVec = GetMuzzleLocationWorld();

		if ( FiringMode == WEAP_StateFiring )
		{
			FlashMuzzleFlash( MuzzleVec );

			DoImpactEffects();
			
			if ((Instigator != None) && (Instigator.DrawType != DT_StaticMesh))
				EjectShell( GetChamberLocationWorld(), MyAmmoTypeClass.Default.AmmoShellClass );

			if( bUseTracers )
			{
				SendTracer( MuzzleVec, MyAmmoTypeClass.Default.BulletTracerClass );
			}
			if (gbxAmmo(Instigator.Weapon.Ammo[0]) != None)
				gbxAmmo(Instigator.Weapon.Ammo[0]).ApplyKick();
		}
	}
}

//---------------------------------------------------------
//	GetMuzzleLocationWorld
//---------------------------------------------------------
simulated function Vector GetMuzzleLocationWorld()
{
	local Vector X,Y,Z;
	GetAxes(Instigator.Weapon.Rotation, X,Y,Z);
	return Instigator.Weapon.Location + (MuzzleOffset.X*X) + (MuzzleOffset.Y*Y) + (MuzzleOffset.Z*Z);
}

//---------------------------------------------------------
//	InitFor
//---------------------------------------------------------
function InitFor(Inventory I)
{
	Instigator = I.Instigator;
}

//---------------------------------------------------------
//	FlashMuzzleFlash
//---------------------------------------------------------
simulated function FlashMuzzleFlash( Vector Location )
{
	if ( Instigator != None && Instigator.Weapon != None &&
		Instigator.Weapon.IsA( 'WeapUSM1919_' ) )
	{
		WeapUSM1919_( Instigator.Weapon ).FlashMuzzleFlash();
	}
}

//---------------------------------------------------------
//	EjectShell
//---------------------------------------------------------
simulated function bool EjectShell( Vector Location, class<gbxWeaponShells> ShellClass )
{
	local bool	bEjected;
	
	if (	( Flash % 2 ) == 0 &&
			Instigator != None && Instigator.Weapon != None &&
			Instigator.Weapon.IsA( 'WeapUSM1919_' ) )
	{
		if ( WeapUSM1919_( Instigator.Weapon ).CanSpawnShellCasing() )
			bEjected = super.EjectShell( Location, ShellClass );	
	}

	Flash++;
	
	return bEjected;
}

//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
    LightType=LT_Pulse
    LightEffect=LE_NonIncidence
    LightPeriod=3
    LightBrightness=50
    LightHue=30
    LightSaturation=150
    LightRadius=4.0

	bUseTracers=true;
	TracerFrequency=3;

	RelativeLocation=(X=0.000000,Y=1.0000,Z=-0.3000)

	//MuzzleOffset=(X=63,Y=0,Z=15)
	MuzzleOffset=(X=45,Y=0,Z=0)

	PawnAnimInfoClass=class'PawnAnimInfoFinalM1919_'
}
class AttachmentUSM1Carbine extends InstantFireWeaponAttachment;

simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();
	
	SetStaticMesh(StaticMesh(DynamicLoadObject("s_npc_weapon_us.us_m1_carbine", class'StaticMesh')));
}

defaultproperties
{
	DrawScale=1.0
//    StaticMesh=StaticMesh's_npc_weapon_us.us_m1_carbine'
	DrawType=DT_StaticMesh

    //MuzFlashClass=class'gbxEffects.MuzzleFlashM1_'
    //bFlashForPrimary=true
    //bFlashLight=true

    LightType=LT_Pulse
    LightEffect=LE_NonIncidence
    LightPeriod=3
    LightBrightness=50
    LightHue=30
    LightSaturation=150
    LightRadius=4.0

	RelativeLocation=(X=0.000000,Y=1.0000,Z=-0.3000)

	MuzzleTagName=rifle_muzzle_m1carbine
	ChamberTagName=rifle_chamber

	bUseTracers=true
	TracerFrequency=1

	PawnAnimInfoClass=class'PawnAnimInfoFinalTwoHand'
}
class AttachmentUSM1_ extends InstantFireWeaponAttachment;


var String EjectedClipCueName;
var Cue EjectedClipCue;

var M1EjectedClip	EjectedClip;

simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();
	
	SetStaticMesh(StaticMesh(DynamicLoadObject("s_npc_weapon_us.us_m1", class'StaticMesh')));
}

simulated function Destroyed()
{
	if (EjectedClip != None)
		EjectedClip.Destroy();

	Super.Destroyed();
}

simulated function ClipDestroyed()
{
	EjectedClip = None;
}

simulated function bool EjectShell( Vector Location, class<gbxWeaponShells> ShellClass )
{
	local bool	bEjected;
	
	// Eject a normal shell casing
	if( Instigator.IsFirstPerson() && !PlayerController(Instigator.Controller).IsZoomed() )
	{
		bEjected = super.EjectShell( Location, ShellClass );
	}
    else if( Instigator != None && Instigator.PlayerCanSeeMe() )
	{
		bEjected = super.EjectShell( Location, ShellClass );
	}
	
	// Eject an empty ammo clip along with the last shell
	if ((Instigator.Weapon != None) && (Instigator.Weapon.ClipAmt <= 0))
	{
		// Spawn the clip emitter if it hasn't been created yet
		if( (EjectedClip == None) && bEjected )
			EjectedClip = Spawn(class'M1EjectedClip', Instigator.Weapon);

		if( EjectedClip != None )
		{
			EjectedClip.TriggerEmitters( Location, Instigator.Rotation );

			if( EjectedClipCueName != "" )
			{
				if( EjectedClipCue == None )
				{
					EjectedClipCue = LoadSound( EjectedClipCueName );
				}
				
				if( EjectedClipCue != None )
				{
					EjectedClip.PlayOwnedSoundCue(EjectedClipCue, SLOT_None,,,,,true );
				}
			}
		}
	}
	
	return bEjected;
}

defaultproperties
{
	DrawScale=1.0
//    StaticMesh=StaticMesh's_npc_weapon_us.us_m1'
	DrawType=DT_StaticMesh

    //MuzFlashClass=class'gbxEffects.MuzzleFlashM1_'
    //bFlashForPrimary=true
    //bFlashLight=true

    LightType=LT_Pulse
    LightEffect=LE_NonIncidence
    LightPeriod=3
    LightBrightness=50
    LightHue=30
    LightSaturation=150
    LightRadius=4.0

	RelativeLocation=(X=0.000000,Y=1.0000,Z=-0.3000)

	MuzzleTagName=rifle_muzzle
	ChamberTagName=rifle_chamber

	bUseTracers=true
	TracerFrequency=1

	PawnAnimInfoClass=class'PawnAnimInfoFinalTwoHand'
	EjectedClipCueName="W_M1GARAND.CLIP_EJECT"
}
class AttachmentUSM3A1_ extends InstantFireWeaponAttachment;


simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();
	
	SetStaticMesh(StaticMesh(DynamicLoadObject("s_npc_weapon_us.us_m3a1", class'StaticMesh')));
}

defaultproperties
{
	DrawScale=1.0
//    StaticMesh=StaticMesh's_npc_weapon_us.us_m3a1'
	DrawType=DT_StaticMesh

    //MuzFlashClass=class'gbxEffects.MuzzleFlashM3A1_'
    //bFlashForPrimary=true
    //bFlashLight=true

    LightType=LT_Pulse
    LightEffect=LE_NonIncidence
    LightPeriod=3
    LightBrightness=50
    LightHue=30
    LightSaturation=150
    LightRadius=4.0

	RelativeLocation=(X=0.000000,Y=1.0000,Z=-0.3000)

	MuzzleTagName=rifle_muzzle_thompson
	ChamberTagName=rifle_chamber

	PawnAnimInfoClass=class'PawnAnimInfoFinalSubMachineGun'

	bUseTracers=true
	bFirstPersonTracers=false
	TracerFrequency=3
}
//=============================================================================
// US Sherman tank 50 cal. machine gun 3rd person attachment class.
//=============================================================================
class AttachmentUSSherman50cal extends InstantFireWeaponAttachment;



var int Flash;
//---------------------------------------------------------
//	ThirdPersonEffects
//---------------------------------------------------------
simulated event ThirdPersonEffects()
{
	local Vector MuzzleVec;

	if (FlashCount==0)
		return;

	if ((MyAmmoTypeClass != None) && (FiringMode == WEAP_StateFiring))
	{
		MuzzleVec = GetMuzzleLocationWorld();

		if ( FiringMode == WEAP_StateFiring )
		{
			FlashMuzzleFlash( MuzzleVec );

			DoImpactEffects();
			
			if ((Instigator != None) && (Instigator.DrawType != DT_StaticMesh))
				EjectShell( GetChamberLocationWorld(), MyAmmoTypeClass.Default.AmmoShellClass );

			if( bUseTracers )
			{
				SendTracer( MuzzleVec, MyAmmoTypeClass.Default.BulletTracerClass );
			}
			if (gbxAmmo(Instigator.Weapon.Ammo[0]) != None)
				gbxAmmo(Instigator.Weapon.Ammo[0]).ApplyKick();
		}
	}
}

//---------------------------------------------------------
//	GetMuzzleLocationWorld
//---------------------------------------------------------
simulated function Vector GetMuzzleLocationWorld()
{
	local Vector X,Y,Z;
	GetAxes(Instigator.Weapon.Rotation, X,Y,Z);
	return Instigator.Weapon.Location + (MuzzleOffset.X*X) + (MuzzleOffset.Y*Y) + (MuzzleOffset.Z*Z);
}

//---------------------------------------------------------
//	InitFor
//---------------------------------------------------------
function InitFor(Inventory I)
{
	Instigator = I.Instigator;
}

//---------------------------------------------------------
//	FlashMuzzleFlash
//---------------------------------------------------------
simulated function FlashMuzzleFlash( Vector Location )
{
	if ( Instigator != None && Instigator.Weapon != None &&
		Instigator.Weapon.IsA( 'WeapUSSherman50cal' ) && Level.TimeSeconds - LastFlashTime > MinFlashInterval )
	{
		WeapUSSherman50cal( Instigator.Weapon ).FlashMuzzleFlash();
		LastFlashTime = Level.TimeSeconds;
	}
}

//---------------------------------------------------------
//	EjectShell
//---------------------------------------------------------
simulated function bool EjectShell( Vector Location, class<gbxWeaponShells> ShellClass )
{
	local bool	bEjected;
	
	if (	( Flash % 2 ) == 0 &&
			Instigator != None && Instigator.Weapon != None &&
			Instigator.Weapon.IsA( 'WeapUSSherman50cal' ) )
	{
		if ( WeapUSSherman50cal( Instigator.Weapon ).CanSpawnShellCasing() )
			bEjected = super.EjectShell( Location, ShellClass );	
	}

	Flash++;
	
	return bEjected;
}

//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
    LightType=LT_Pulse
    LightEffect=LE_NonIncidence
    LightPeriod=3
    LightBrightness=50
    LightHue=30
    LightSaturation=150
    LightRadius=4.0

	bUseTracers=true;
	TracerFrequency=3;

	RelativeLocation=(X=0.000000,Y=1.0000,Z=-0.3000)

	MuzzleOffset=(X=45,Y=0,Z=0)

	PawnAnimInfoClass=class'PawnAnimInfoFinalSherman50cal'
}
class AttachmentUSSpringfield extends InstantFireWeaponAttachment;

simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();
	
	SetStaticMesh(StaticMesh(DynamicLoadObject("s_npc_weapon_us.us_springfield", class'StaticMesh')));
}

defaultproperties
{
	DrawScale=1.0
//    StaticMesh=StaticMesh's_npc_weapon_us.us_springfield'
	DrawType=DT_StaticMesh

    //MuzFlashClass=class'gbxEffects.MuzzleFlashM1_'
    //bFlashForPrimary=true
    //bFlashLight=true

    LightType=LT_Pulse
    LightEffect=LE_NonIncidence
    LightPeriod=3
    LightBrightness=50
    LightHue=30
    LightSaturation=150
    LightRadius=4.0

	RelativeLocation=(X=0.000000,Y=1.0000,Z=-0.3000)

	MuzzleTagName=rifle_muzzle
	ChamberTagName=rifle_chamber

	bUseTracers=true
	TracerFrequency=1

	PawnAnimInfoClass=class'PawnAnimInfoFinalTwoHand'
}
//=============================================================================
// US Stuart tank 30 cal. machine gun 3rd person attachment class.
//=============================================================================
class AttachmentUSStuart30cal extends InstantFireWeaponAttachment;



var int Flash;
//---------------------------------------------------------
//	ThirdPersonEffects
//---------------------------------------------------------
simulated event ThirdPersonEffects()
{
	local Vector MuzzleVec;

	if (FlashCount==0)
		return;

	if ((MyAmmoTypeClass != None) && (FiringMode == WEAP_StateFiring))
	{
		MuzzleVec = GetMuzzleLocationWorld();

		if ( FiringMode == WEAP_StateFiring )
		{
			FlashMuzzleFlash( MuzzleVec );

			DoImpactEffects();
			
			if ((Instigator != None) && (Instigator.DrawType != DT_StaticMesh))
				EjectShell( GetChamberLocationWorld(), MyAmmoTypeClass.Default.AmmoShellClass );

			if( bUseTracers )
			{
				SendTracer( MuzzleVec, MyAmmoTypeClass.Default.BulletTracerClass );
			}
			if (gbxAmmo(Instigator.Weapon.Ammo[0]) != None)
				gbxAmmo(Instigator.Weapon.Ammo[0]).ApplyKick();
		}
	}
}

//---------------------------------------------------------
//	GetMuzzleLocationWorld
//---------------------------------------------------------
simulated function Vector GetMuzzleLocationWorld()
{
	
	local Vector X,Y,Z;
	local vector BoneLoc;

	GetAxes(Instigator.Weapon.Rotation, X,Y,Z);
	BoneLoc = WeapUSStuart30cal( Instigator.Weapon ).MyTankPawn.GetBoneCoords(WeapUSStuart30cal( Instigator.Weapon ).GunBoneName).origin;
	return BoneLoc + (MuzzleOffset.X*X) + (MuzzleOffset.Y*Y) + (MuzzleOffset.Z*Z);

}

//---------------------------------------------------------
//	InitFor
//---------------------------------------------------------
function InitFor(Inventory I)
{
	Instigator = I.Instigator;
}

//---------------------------------------------------------
//	FlashMuzzleFlash
//---------------------------------------------------------
simulated function FlashMuzzleFlash( Vector Location )
{
	if ( Instigator != None && Instigator.Weapon != None &&
		Instigator.Weapon.IsA( 'WeapUSStuart30cal' ) && Level.TimeSeconds - LastFlashTime > MinFlashInterval )
	{
		WeapUSStuart30cal( Instigator.Weapon ).FlashMuzzleFlash();
		LastFlashTime = Level.TimeSeconds;
	}
}

//---------------------------------------------------------
//	EjectShell
//---------------------------------------------------------
simulated function bool EjectShell( Vector Location, class<gbxWeaponShells> ShellClass )
{
	local	bool	bEjected;
	
	if (	( Flash % 2 ) == 0 &&
			Instigator != None && Instigator.Weapon != None &&
			Instigator.Weapon.IsA( 'WeapUSStuart30cal' ) )
	{
		if ( WeapUSStuart30cal( Instigator.Weapon ).CanSpawnShellCasing() )
			bEjected = super.EjectShell( Location, ShellClass );	
	}

	Flash++;
	
	return bEjected;
}

//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
    LightType=LT_Pulse
    LightEffect=LE_NonIncidence
    LightPeriod=3
    LightBrightness=50
    LightHue=30
    LightSaturation=150
    LightRadius=4.0

	bUseTracers=true;
	TracerFrequency=3;

	RelativeLocation=(X=0.000000,Y=1.0000,Z=-0.3000)

	MuzzleOffset=(X=100,Y=0,Z=0)

	PawnAnimInfoClass=class'PawnAnimInfoFinalStuart30cal'
}
class AttachmentUSThompson extends InstantFireWeaponAttachment;


simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();
	
	SetStaticMesh(StaticMesh(DynamicLoadObject("s_npc_weapon_us.us_thompson", class'StaticMesh')));
}

defaultproperties
{
	DrawScale=1.0
//    StaticMesh=StaticMesh's_npc_weapon_us.us_thompson'
	DrawType=DT_StaticMesh

    //MuzFlashClass=class'gbxEffects.MuzzleFlashThompson'
    //bFlashForPrimary=true
    //bFlashLight=true

    LightType=LT_Pulse
    LightEffect=LE_NonIncidence
    LightPeriod=3
    LightBrightness=50
    LightHue=30
    LightSaturation=150
    LightRadius=4.0

	RelativeLocation=(X=0.000000,Y=1.0000,Z=-0.3000)

	MuzzleTagName=rifle_muzzle_thompson
	ChamberTagName=rifle_chamber

	PawnAnimInfoClass=class'PawnAnimInfoFinalSubMachineGun'

	bUseTracers=true
	bFirstPersonTracers=false
	TracerFrequency=3
}
class AttachmentUSThompsonMud extends AttachmentUSThompson;


simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();
	
	Skins[0] = Texture( DynamicLoadObject( "t_npc_weapon_us.us_thompson_muddy", class'Texture' ) );
}
class ConscriptK98GoreSetup extends GorePackSetup;

defaultproperties
{
	PackGoreTextureNames(0)="t_character_de.grids.conscript_k98"
	PackGoreTextureNames(1)="t_character_de.grids.conscript_k98_leftside"
	PackGoreTextureNames(2)="t_character_de.grids.conscript_k98_leftsidemass"
	PackGoreTextureNames(3)="t_character_de.grids.conscript_k98_rightside"
	PackGoreTextureNames(4)="t_character_de.grids.conscript_k98_rightsidemass"
	PackGoreTextureNames(5)="t_character_de.grids.conscript_k98_legs"
}
class ConscriptMP40GoreSetup extends GorePackSetup;

defaultproperties
{
	PackGoreTextureNames(0)="t_character_de.grids.conscript_mp40"
	PackGoreTextureNames(1)="t_character_de.grids.conscript_mp40_leftside"
	PackGoreTextureNames(2)="t_character_de.grids.conscript_mp40_leftsidemass"
	PackGoreTextureNames(3)="t_character_de.grids.conscript_mp40_rightside"
	PackGoreTextureNames(4)="t_character_de.grids.conscript_mp40_rightsidemass"
	PackGoreTextureNames(5)="t_character_de.grids.conscript_mp40_legs"

	PackGoreHandState(1)=(R=1,G=1,B=1)
	PackGoreHandState(3)=(R=1,G=0,B=1)
}
// ====================================================================
//  Class:  DamageDEFG42Sniper
//
// (c) 2001, Epic Games, Inc - All Rights Reserved
// ====================================================================

class DamageDEFG42Sniper extends gbxDamageBullet;


defaultproperties
{
    DeathString="%k ripped %o full of holes with the %w."
	bArmorStops=true
	GibModifier=+0.4
	LowDetailEffect=None
	LowDetailEmitter=class'gbxBloodEffect'
	LowDetailHeadshotEmitter=class'gbxBloodEffectHeadshot'
	LowDetailLittleEmitter=class'gbxBloodEffectLittle'
	bInstantHit=true
	bFastInstantHit=true
	DamageWeaponName="German FG42"
	PawnDamageEffect=None
	PawnDamageEmitter=class'gbxBloodEffect'
	PawnDamageHeadshotEmitter=class'gbxBloodEffectHeadshot'
	PawnDamageLittleEmitter=class'gbxBloodEffectLittle'
	DamageDesc=2
	DamageThreshold=15
	DamageKick=(x=512,y=0,z=512)
	BloodDecal=class'BloodScorch'
	m_bBulletDamage=true
}
// ====================================================================
//  Class:  DamageDEFG42_
//
// (c) 2001, Epic Games, Inc - All Rights Reserved
// ====================================================================

class DamageDEFG42_ extends gbxDamageBullet;


defaultproperties
{
    DeathString="%k ripped %o full of holes with the %w."
	bArmorStops=true
	GibModifier=+0.4
	LowDetailEffect=None
	LowDetailEmitter=class'gbxBloodEffect'
	LowDetailHeadshotEmitter=class'gbxBloodEffectHeadshot'
	LowDetailLittleEmitter=class'gbxBloodEffectLittle'
	bInstantHit=true
	bFastInstantHit=true
	DamageWeaponName="German FG42"
	PawnDamageEffect=None
	PawnDamageEmitter=class'gbxBloodEffect'
	PawnDamageHeadshotEmitter=class'gbxBloodEffectHeadshot'
	PawnDamageLittleEmitter=class'gbxBloodEffectLittle'
	DamageDesc=2
	DamageThreshold=15
	DamageKick=(x=512,y=0,z=512)
	BloodDecal=class'BloodScorch'
	m_bBulletDamage=true
}
// ====================================================================
//  Class:  DamageDEK98_
//
// (c) 2001, Epic Games, Inc - All Rights Reserved
// ====================================================================

class DamageDEK98_ extends gbxDamageBullet;


defaultproperties
{
    DeathString="%k ripped %o full of holes with the %w."
	bArmorStops=true
	GibModifier=+0.4
	LowDetailEffect=None
	LowDetailEmitter=class'gbxBloodEffect'
	LowDetailHeadshotEmitter=class'gbxBloodEffectHeadshot'
	LowDetailLittleEmitter=class'gbxBloodEffectLittle'
	bInstantHit=true
	bFastInstantHit=true
	DamageWeaponName="German K98"
	PawnDamageEffect=None
	PawnDamageEmitter=class'gbxBloodEffect'
	PawnDamageHeadshotEmitter=class'gbxBloodEffectHeadshot'
	PawnDamageLittleEmitter=class'gbxBloodEffectLittle'
	DamageDesc=2
	DamageThreshold=15
	DamageKick=(x=512,y=0,z=512)
	BloodDecal=class'BloodScorch'
	m_bBulletDamage=true
}
//=============================================================================
// German MG42 damage class.
//
// Author: Neil Johnson, Gearbox Software.
//=============================================================================

class DamageDEMG42_ extends gbxDamageBullet;


defaultproperties
{
    DeathString="%k ripped %o full of holes with the %w."
	bArmorStops=true
	GibModifier=+0.4
	LowDetailEffect=None
	LowDetailEmitter=class'gbxBloodEffect'
	LowDetailHeadshotEmitter=class'gbxBloodEffectHeadshot'
	LowDetailLittleEmitter=class'gbxBloodEffectLittle'
	bInstantHit=true
	bFastInstantHit=true
	DamageWeaponName="German MG42"
	PawnDamageEffect=None
	PawnDamageEmitter=class'gbxBloodEffect'
	PawnDamageHeadshotEmitter=class'gbxBloodEffectHeadshot'
	PawnDamageLittleEmitter=class'gbxBloodEffectLittle'
	DamageDesc=2
	DamageThreshold=15
	DamageKick=(x=512,y=0,z=512)
	BloodDecal=class'BloodScorch'
	m_bBulletDamage=true
}
// ====================================================================
//  Class:  DamageDEMP40_
//
// (c) 2001, Epic Games, Inc - All Rights Reserved
// ====================================================================

class DamageDEMP40_ extends gbxDamageBullet;


defaultproperties
{
    DeathString="%k ripped %o full of holes with the %w."
	bArmorStops=true
	GibModifier=+0.4
	LowDetailEffect=None
	LowDetailEmitter=class'gbxBloodEffect'
	LowDetailHeadshotEmitter=class'gbxBloodEffectHeadshot'
	LowDetailLittleEmitter=class'gbxBloodEffectLittle'
	bInstantHit=true
	bFastInstantHit=true
	DamageWeaponName="German MP40"
	PawnDamageEffect=None
	PawnDamageEmitter=class'gbxBloodEffect'
	PawnDamageHeadshotEmitter=class'gbxBloodEffectHeadshot'
	PawnDamageLittleEmitter=class'gbxBloodEffectLittle'
	DamageDesc=2
	DamageThreshold=15
	DamageKick=(x=512,y=0,z=512)
	BloodDecal=class'BloodScorch'
	m_bBulletDamage=true
}
// ====================================================================
//  Class:  DamageDEP38_
//
// (c) 2001, Epic Games, Inc - All Rights Reserved
// ====================================================================

class DamageDEP38_ extends gbxDamageBullet;


defaultproperties
{
    DeathString="%k ripped %o full of holes with the %w."
	bArmorStops=true
	GibModifier=+0.4
	LowDetailEffect=None
	LowDetailEmitter=class'gbxBloodEffect'
	LowDetailHeadshotEmitter=class'gbxBloodEffectHeadshot'
	LowDetailLittleEmitter=class'gbxBloodEffectLittle'
	bInstantHit=true
	bFastInstantHit=true
	DamageWeaponName="German P38"
	PawnDamageEffect=None
	PawnDamageEmitter=class'gbxBloodEffect'
	PawnDamageHeadshotEmitter=class'gbxBloodEffectHeadshot'
	PawnDamageLittleEmitter=class'gbxBloodEffectLittle'
	DamageDesc=2
	DamageThreshold=15
	DamageKick=(x=512,y=0,z=512)
	BloodDecal=class'BloodScorch'
	m_bBulletDamage=true
}
// ====================================================================
//  Class:  DamageDEPanzerfaust
//
// (c) 2001, Epic Games, Inc - All Rights Reserved
// ====================================================================

class DamageDEPanzerfaust extends gbxDamageExploded;


defaultproperties
{
    DeathString="%k ripped %o full of holes with the %w."
	bArmorStops=false
	GibModifier=+0.4
	LowDetailEffect=None
	LowDetailEmitter=class'gbxBloodEffect'
	LowDetailHeadshotEmitter=class'gbxBloodEffectHeadshot'
	LowDetailLittleEmitter=class'gbxBloodEffectLittle'
	bInstantHit=true
	bFastInstantHit=true
	DamageWeaponName="German Panzerfaust"
	PawnDamageEffect=None
	PawnDamageEmitter=class'gbxBloodEffect'
	PawnDamageHeadshotEmitter=class'gbxBloodEffectHeadshot'
	PawnDamageLittleEmitter=class'gbxBloodEffectLittle'
	DamageDesc=2
	DamageThreshold=15
	DamageKick=(x=512,y=0,z=512)
	BloodDecal=class'BloodScorch'
	
	m_bDamagesArmor=true
	m_bExplosiveDamage=true
}
// ====================================================================
//  Class:  DamageDESTG44_
//
// (c) 2001, Epic Games, Inc - All Rights Reserved
// ====================================================================

class DamageDESTG44_ extends gbxDamageBullet;


defaultproperties
{
    DeathString="%k ripped %o full of holes with the %w."
	bArmorStops=true
	GibModifier=+0.4
	LowDetailEffect=None
	LowDetailEmitter=class'gbxBloodEffect'
	LowDetailHeadshotEmitter=class'gbxBloodEffectHeadshot'
	LowDetailLittleEmitter=class'gbxBloodEffectLittle'
	bInstantHit=true
	bFastInstantHit=true
	DamageWeaponName="German STG44"
	PawnDamageEffect=None
	PawnDamageEmitter=class'gbxBloodEffect'
	PawnDamageHeadshotEmitter=class'gbxBloodEffectHeadshot'
	PawnDamageLittleEmitter=class'gbxBloodEffectLittle'
	DamageDesc=2
	DamageThreshold=15
	DamageKick=(x=512,y=0,z=512)
	BloodDecal=class'BloodScorch'
	m_bBulletDamage=true
}
// ====================================================================
//  Class:  DamageUSBazooka
//
// (c) 2001, Epic Games, Inc - All Rights Reserved
// ====================================================================

class DamageGammonBomb extends gbxDamageExploded;


defaultproperties
{
    DeathString="%k ripped %o full of holes with the %w."
	bArmorStops=false
	GibModifier=+0.4
	LowDetailEffect=None
	LowDetailEmitter=class'gbxBloodEffect'
	LowDetailHeadshotEmitter=class'gbxBloodEffectHeadshot'
	LowDetailLittleEmitter=class'gbxBloodEffectLittle'
	bInstantHit=true
	bFastInstantHit=true
	DamageWeaponName="US Bazooka"
	PawnDamageEffect=None
	PawnDamageEmitter=class'gbxBloodEffect'
	PawnDamageHeadshotEmitter=class'gbxBloodEffectHeadshot'
	PawnDamageLittleEmitter=class'gbxBloodEffectLittle'
	DamageDesc=2
	DamageThreshold=15
	DamageKick=(x=512,y=0,z=512)
	BloodDecal=class'BloodScorch'

	m_bDamagesArmor=true
	m_bExplosiveDamage=true
}
// ====================================================================
//  Class:  DamageTankCannon
// ====================================================================

class DamageTankCannon extends gbxDamageExploded;


defaultproperties
{
    DeathString="%k ripped %o full of holes with the %w."
	bArmorStops=false
	GibModifier=+0.4
	LowDetailEffect=None
	LowDetailEmitter=class'gbxBloodEffect'
	LowDetailHeadshotEmitter=class'gbxBloodEffectHeadshot'
	LowDetailLittleEmitter=class'gbxBloodEffectLittle'
	bInstantHit=true
	bFastInstantHit=true
	DamageWeaponName="Tank Cannon"
	PawnDamageEffect=None
	PawnDamageEmitter=class'gbxBloodEffect'
	PawnDamageHeadshotEmitter=class'gbxBloodEffectHeadshot'
	PawnDamageLittleEmitter=class'gbxBloodEffectLittle'
	DamageDesc=2
	DamageThreshold=15
	DamageKick=(x=512,y=0,z=512)
	BloodDecal=class'BloodScorch'

	m_bDamagesArmor=true
	m_bExplosiveDamage=true
}
// ====================================================================
//  Class:  DamageUSBar
//
// (c) 2001, Epic Games, Inc - All Rights Reserved
// ====================================================================

class DamageUSBar extends gbxDamageBullet;


defaultproperties
{
    DeathString="%k ripped %o full of holes with the %w."
	bArmorStops=true
	GibModifier=+0.4
	LowDetailEffect=None
	LowDetailEmitter=class'gbxBloodEffect'
	LowDetailHeadshotEmitter=class'gbxBloodEffectHeadshot'
	LowDetailLittleEmitter=class'gbxBloodEffectLittle'
	bInstantHit=true
	bFastInstantHit=true
	DamageWeaponName="US BAR"
	PawnDamageEffect=None
	PawnDamageEmitter=class'gbxBloodEffect'
	PawnDamageHeadshotEmitter=class'gbxBloodEffectHeadshot'
	PawnDamageLittleEmitter=class'gbxBloodEffectLittle'
	DamageDesc=2
	DamageThreshold=15
	DamageKick=(x=512,y=0,z=512)
	BloodDecal=class'BloodScorch'
	m_bBulletDamage=true
}
// ====================================================================
//  Class:  DamageUSBazooka
//
// (c) 2001, Epic Games, Inc - All Rights Reserved
// ====================================================================

class DamageUSBazooka extends gbxDamageExploded;


defaultproperties
{
    DeathString="%k ripped %o full of holes with the %w."
	bArmorStops=false
	GibModifier=+0.4
	LowDetailEffect=None
	LowDetailEmitter=class'gbxBloodEffect'
	LowDetailHeadshotEmitter=class'gbxBloodEffectHeadshot'
	LowDetailLittleEmitter=class'gbxBloodEffectLittle'
	bInstantHit=true
	bFastInstantHit=true
	DamageWeaponName="US Bazooka"
	PawnDamageEffect=None
	PawnDamageEmitter=class'gbxBloodEffect'
	PawnDamageHeadshotEmitter=class'gbxBloodEffectHeadshot'
	PawnDamageLittleEmitter=class'gbxBloodEffectLittle'
	DamageDesc=2
	DamageThreshold=15
	DamageKick=(x=512,y=0,z=512)
	BloodDecal=class'BloodScorch'
	
	m_bDamagesArmor=true
	m_bExplosiveDamage=true
}
// ====================================================================
//  Class:  DamageUSColt1911_
//
// (c) 2001, Epic Games, Inc - All Rights Reserved
// ====================================================================

class DamageUSColt1911_ extends gbxDamageBullet;


defaultproperties
{
    DeathString="%k ripped %o full of holes with the %w."
	bArmorStops=true
	GibModifier=+0.4
	LowDetailEffect=None
	LowDetailEmitter=class'gbxBloodEffect'
	LowDetailHeadshotEmitter=class'gbxBloodEffectHeadshot'
	LowDetailLittleEmitter=class'gbxBloodEffectLittle'
	bInstantHit=true
	bFastInstantHit=true
	DamageWeaponName="US .45"
	PawnDamageEffect=None
	PawnDamageEmitter=class'gbxBloodEffect'
	PawnDamageHeadshotEmitter=class'gbxBloodEffectHeadshot'
	PawnDamageLittleEmitter=class'gbxBloodEffectLittle'
	DamageDesc=2
	DamageThreshold=15
	DamageKick=(x=512,y=0,z=512)
	BloodDecal=class'BloodScorch'
	m_bBulletDamage=true
}
// ====================================================================
//  Class:  DamageUSBarMelee
//
// (c) 2001, Epic Games, Inc - All Rights Reserved
// ====================================================================

class DamageUSGunButtMelee extends gbxDamageType;


defaultproperties
{
    DeathString="%k ripped %o full of holes with the %w."
	bArmorStops=true
	GibModifier=+0.4
	LowDetailEffect=None
	LowDetailEmitter=None
	LowDetailHeadshotEmitter=None
	LowDetailLittleEmitter=None
	bInstantHit=true
	bFastInstantHit=true
	DamageWeaponName="US BAR"
	PawnDamageEffect=None
	PawnDamageEmitter=None
	PawnDamageHeadshotEmitter=None
	PawnDamageLittleEmitter=None
	DamageDesc=2
	DamageThreshold=15
	DamageKick=(x=512,y=0,z=512)
	BloodDecal=None
	bKUseOwnDeathVel=true
	KDeathVel=50
}
// ====================================================================
//  Class:  DamageUSM1Carbine
//
// (c) 2001, Epic Games, Inc - All Rights Reserved
// ====================================================================

class DamageUSM1Carbine extends gbxDamageBullet;


defaultproperties
{
    DeathString="%k ripped %o full of holes with the %w."
	bArmorStops=true
	GibModifier=+0.4
	LowDetailEffect=None
	LowDetailEmitter=class'gbxBloodEffect'
	LowDetailHeadshotEmitter=class'gbxBloodEffectHeadshot'
	LowDetailLittleEmitter=class'gbxBloodEffectLittle'
	bInstantHit=true
	bFastInstantHit=true
	DamageWeaponName="US M1 Carbine"
	PawnDamageEffect=None
	PawnDamageEmitter=class'gbxBloodEffect'
	PawnDamageHeadshotEmitter=class'gbxBloodEffectHeadshot'
	PawnDamageLittleEmitter=class'gbxBloodEffectLittle'
	DamageDesc=2
	DamageThreshold=15
	DamageKick=(x=512,y=0,z=512)
	BloodDecal=class'BloodScorch'
	m_bBulletDamage=true
}
// ====================================================================
//  Class:  DamageUSM1_
//
// (c) 2001, Epic Games, Inc - All Rights Reserved
// ====================================================================

class DamageUSM1_ extends gbxDamageBullet;


defaultproperties
{
    DeathString="%k ripped %o full of holes with the %w."
	bArmorStops=true
	GibModifier=+0.4
	LowDetailEffect=None
	LowDetailEmitter=class'gbxBloodEffect'
	LowDetailHeadshotEmitter=class'gbxBloodEffectHeadshot'
	LowDetailLittleEmitter=class'gbxBloodEffectLittle'
	bInstantHit=true
	bFastInstantHit=true
	DamageWeaponName="US M1"
	PawnDamageEffect=None
	PawnDamageEmitter=class'gbxBloodEffect'
	PawnDamageHeadshotEmitter=class'gbxBloodEffectHeadshot'
	PawnDamageLittleEmitter=class'gbxBloodEffectLittle'
	DamageDesc=2
	DamageThreshold=15
	DamageKick=(x=512,y=0,z=512)
	BloodDecal=class'BloodScorch'
	m_bBulletDamage=true
}
// ====================================================================
//  Class:  DamageUSM3A1
//
// (c) 2001, Epic Games, Inc - All Rights Reserved
// ====================================================================

class DamageUSM3A1_ extends gbxDamageBullet;


defaultproperties
{
    DeathString="%k ripped %o full of holes with the %w."
	bArmorStops=true
	GibModifier=+0.4
	LowDetailEffect=None
	LowDetailEmitter=class'gbxBloodEffect'
	LowDetailHeadshotEmitter=class'gbxBloodEffectHeadshot'
	LowDetailLittleEmitter=class'gbxBloodEffectLittle'
	bInstantHit=true
	bFastInstantHit=true
	DamageWeaponName="US M3A1 Sub-Machine Gun"
	PawnDamageEffect=None
	PawnDamageEmitter=class'gbxBloodEffect'
	PawnDamageHeadshotEmitter=class'gbxBloodEffectHeadshot'
	PawnDamageLittleEmitter=class'gbxBloodEffectLittle'
	DamageDesc=2
	DamageThreshold=15
	DamageKick=(x=512,y=0,z=512)
	BloodDecal=class'BloodScorch'
	m_bBulletDamage=true
}
// ====================================================================
//  Class:  DamageUSSpringfield
//
// (c) 2001, Epic Games, Inc - All Rights Reserved
// ====================================================================

class DamageUSSpringfield extends gbxDamageBullet;


defaultproperties
{
    DeathString="%k ripped %o full of holes with the %w."
	bArmorStops=true
	GibModifier=+0.4
	LowDetailEffect=None
	LowDetailEmitter=class'gbxBloodEffect'
	LowDetailHeadshotEmitter=class'gbxBloodEffectHeadshot'
	LowDetailLittleEmitter=class'gbxBloodEffectLittle'
	bInstantHit=true
	bFastInstantHit=true
	DamageWeaponName="US M1903 Bolt-Action Rifle"
	PawnDamageEffect=None
	PawnDamageEmitter=class'gbxBloodEffect'
	PawnDamageHeadshotEmitter=class'gbxBloodEffectHeadshot'
	PawnDamageLittleEmitter=class'gbxBloodEffectLittle'
	DamageDesc=2
	DamageThreshold=15
	DamageKick=(x=512,y=0,z=512)
	BloodDecal=class'BloodScorch'
	m_bBulletDamage=true
}
// ====================================================================
//  Class:  DamageUSThompson
//
// (c) 2001, Epic Games, Inc - All Rights Reserved
// ====================================================================

class DamageUSThompson extends gbxDamageBullet;


defaultproperties
{
    DeathString="%k ripped %o full of holes with the %w."
	bArmorStops=true
	GibModifier=+0.4
	LowDetailEffect=None
	LowDetailEmitter=class'gbxBloodEffect'
	LowDetailHeadshotEmitter=class'gbxBloodEffectHeadshot'
	LowDetailLittleEmitter=class'gbxBloodEffectLittle'
	bInstantHit=true
	bFastInstantHit=true
	DamageWeaponName="US M1A1 Sub-Machine Gun"
	PawnDamageEffect=None
	PawnDamageEmitter=class'gbxBloodEffect'
	PawnDamageHeadshotEmitter=class'gbxBloodEffectHeadshot'
	PawnDamageLittleEmitter=class'gbxBloodEffectLittle'
	DamageDesc=2
	DamageThreshold=15
	DamageKick=(x=512,y=0,z=512)
	BloodDecal=class'BloodScorch'
	m_bBulletDamage=true
}
class FireDEFG42Sniper extends FireSubMachineGun
	config(User);

defaultproperties
{
    AmmoClass=class'AmmoDEFG42_'
    AmmoPerFire=1
    DamageType=class'DamageDEFG42_'
    //DamageMin=50
    //DamageMax=60
	Damage_Human_SP=(min=45,max=60)
	Damage_Human_MP=(min=35,max=35)
	Damage_AI_SP=(min=30,max=45)
	Damage_AI_MP=(min=35,max=35)
    bPawnRapidFireAnim=true
	Load=1

    FireAnim=fire
    FireEndAnim=None
    FireLoopAnim=None
    FireAnimRate=1.0
	ReloadAnim=reload
	ReloadAnimRate=1.0

    FlashEmitterClass=class'gbxEffects.MuzzleFlashFG42_'

	FireSoundName="W_FG42.FIRE"

	// Loops
	FireLoopSoundName="W_FG42.FIRELOOP"
	StereoFireLoopSoundName="W_FG42.FIRELOOP_ST"
	FireEndLoopSoundName="W_FG42.FIRELOOPEND"
	StereoFireEndLoopSoundName="W_FG42.FIRELOOPEND_ST"

    //FireSound=Sound'WeaponSounds.AssaultRifle.AssaultRifleFire'
    FireForce="AssaultRifleFire"   // jdf

	PreFireTime=0.0
    FireRateSP=0.1 // SJP: 0.1 = 600 Rnds/min (accurate)
	FireRateMP=0.1 // SJP: 0.1 = 600 Rnds/min (accurate)
    AIFireRateSP=0.1
	AIFireRateMP=0.1
    bModeExclusive=true

	SuppressionMultiplierSP=0.8
	SuppressionMultiplierMP=1.2

    AimErrorMin_Human=450
	AimErrorMax_Human_Crouched=500	
	AimErrorMax_Human_Standing=900
	AimErrorMax_Human_MovingSlow=1200
	AimErrorMax_Human_MovingFast=1300
	AimErrorMin_Human_Zoomed=200
	AimErrorMax_Human_Zoomed=1700
	AimErrorMin_Human_FirstShot=50
	AimErrorMax_Human_FirstShot=150

	AimErrorMin_AI_MP=450
	AimErrorMax_AI_MP_Crouched=500
	AimErrorMax_AI_MP_Standing=900
	AimErrorMax_AI_MP_Moving=1200
	AimMultiplier_AI_MP_Sighted=1.0

	AimErrorMin_AI_SP=450
	AimErrorMax_AI_SP_Crouched=500
	AimErrorMax_AI_SP_Standing=900
	AimErrorMax_AI_SP_Moving=1200
	AimMultiplier_AI_SP_Sighted=1.0

    ShakeOffsetMag=(X=0.0,Y=0.0,Z=0.0)
    ShakeOffsetRate=(X=1000.0,Y=1000.0,Z=1000.0)
    ShakeOffsetTime=2
    ShakeRotMag=(X=50.0,Y=50.0,Z=50.0)
    ShakeRotRate=(X=10000.0,Y=10000.0,Z=10000.0)
    ShakeRotTime=2

    TweenTime = 0.01

	bWaitForRelease=false

	// Burst count levels.
	Burst_High_SP=(Min=2,Max=3)
	Burst_High_MP=(Min=10,Max=20)
	Burst_Low_SP=(Min=4,Max=6)
	Burst_Low_MP=(Min=10,Max=20)
	Burst_Op_SP=(Min=4,Max=6)
	Burst_Op_MP=(Min=10,Max=30)

	ShotCountMod=3

	m_flRandomBurstRange=0.0

	// This really sucks, but constants are supported here, so I'm just setting this to the value of the constant.
	FireType=1
	bAccurateFirstShot=true
	
	MinFireLoopSustainTime = 0.06
}
class FireDEFG42_ extends FireSubMachineGun
	config(User);

defaultproperties
{
    AmmoClass=class'AmmoDEFG42_'
    AmmoPerFire=1
    DamageType=class'DamageDEFG42_'
    //DamageMin=50
    //DamageMax=60
	Damage_Human_SP=(min=45,max=60)
	Damage_Human_MP=(min=35,max=35)
	Damage_AI_SP=(min=30,max=45)
	Damage_AI_MP=(min=35,max=35)
    bPawnRapidFireAnim=true
	Load=1

    FireAnim=fire
    FireEndAnim=None
    FireLoopAnim=None
    FireAnimRate=1.0
	ReloadAnim=reload
	ReloadAnimRate=1.0

    FlashEmitterClass=class'gbxEffects.MuzzleFlashFG42_'

	FireSoundName="W_FG42.FIRE"

	// Loops
	FireLoopSoundName="W_FG42.FIRELOOP"
	StereoFireLoopSoundName="W_FG42.FIRELOOP_ST"
	FireEndLoopSoundName="W_FG42.FIRELOOPEND"
	StereoFireEndLoopSoundName="W_FG42.FIRELOOPEND_ST"

    //FireSound=Sound'WeaponSounds.AssaultRifle.AssaultRifleFire'
    FireForce="AssaultRifleFire"   // jdf

	PreFireTime=0.0
    FireRateSP=0.1 // SJP: 0.1 = 600 Rnds/min (accurate)
	FireRateMP=0.1 // SJP: 0.1 = 600 Rnds/min (accurate)
    AIFireRateSP=0.1
	AIFireRateMP=0.1
    bModeExclusive=true

	SuppressionMultiplierSP=0.8
	SuppressionMultiplierMP=1.2

    AimErrorMin_Human=650
	AimErrorMax_Human_Crouched=800	
	AimErrorMax_Human_Standing=1000
	AimErrorMax_Human_MovingSlow=1300
	AimErrorMax_Human_MovingFast=1400
	AimErrorMin_Human_Zoomed=250
	AimErrorMax_Human_Zoomed=1700
	AimErrorMin_Human_FirstShot=50
	AimErrorMax_Human_FirstShot=150

	AimErrorMin_AI_MP=650
	AimErrorMax_AI_MP_Crouched=800
	AimErrorMax_AI_MP_Standing=1000
	AimErrorMax_AI_MP_Moving=1400
	AimMultiplier_AI_MP_Sighted=1.0

	AimErrorMin_AI_SP=650
	AimErrorMax_AI_SP_Crouched=800
	AimErrorMax_AI_SP_Standing=1000
	AimErrorMax_AI_SP_Moving=1400
	AimMultiplier_AI_SP_Sighted=1.0

    ShakeOffsetMag=(X=0.0,Y=0.0,Z=0.0)
    ShakeOffsetRate=(X=1000.0,Y=1000.0,Z=1000.0)
    ShakeOffsetTime=2
    ShakeRotMag=(X=50.0,Y=50.0,Z=50.0)
    ShakeRotRate=(X=10000.0,Y=10000.0,Z=10000.0)
    ShakeRotTime=2

    TweenTime = 0.01

	bWaitForRelease=false

	// Burst count levels.
	Burst_High_SP=(Min=2,Max=3)
	Burst_High_MP=(Min=10,Max=20)
	Burst_Low_SP=(Min=4,Max=6)
	Burst_Low_MP=(Min=10,Max=20)
	Burst_Op_SP=(Min=4,Max=6)
	Burst_Op_MP=(Min=10,Max=30)

	ShotCountMod=3

	m_flRandomBurstRange=0.0

	// This really sucks, but constants are supported here, so I'm just setting this to the value of the constant.
	FireType=1
	bAccurateFirstShot=true
	
	MinFireLoopSustainTime = 0.06
}
class FireDEFlakvierling extends InstantFire;

var transient gbxMuzzleFlash FlashEmitters[4];
var class<gbxMuzzleFlash> MuzzleFlashClass;

var class<emitter> TracerClass;

var Name	MuzzleFlashBones[4];
var int		TracerCount;

//---------------------------------------------------------
//	PostNetBeginPlay
//---------------------------------------------------------
function PostNetBeginPlay()
{
	local int x;

	Super.PostNetBeginPlay();
	
	if ( FlashEmitters[0] == None && MuzzleFlashClass != None )
    {
		for( x=0; x<4; x++)
		{
			FlashEmitters[x] = Spawn(MuzzleFlashClass);
			FlashEmitters[x].InitializeMuzzleFlash();
			FlashEmitters[x].Emitters[0].SuspendSpawning();
		}
    }

}

function PlayFiring()
{
	Super.PlayFiring();

	// DANGER: Super's version of this function MIGHT play the animation if you're in first-person mode.
	Weapon.PlayAnim(FireAnim, FireAnimRate, TweenTime);

	WeapDEFlakvierling( Weapon ).PlayFiring();
}

function StopFiring()
{	
	local int		x;
	Super.StopFiring();

	for( x=0; x<4; x++)
	{
		FlashEmitters[x].Emitters[0].SuspendSpawning();
	}
}

function SendTracer(int Muzzle)
{
	local Rotator	AimRot;
	local Emitter	Tracer;
	AimRot = TurretWeapon( Weapon ).GetFireRotation();	

	if(TracerCount==4)		//Every forth barrel we fire a tracer
	{	
		Tracer=Spawn(TracerClass,,,Weapon.GetBoneCoords( MuzzleFlashBones[Muzzle] ).Origin,AimRot);
		Tracer.Emitters[0].Trigger();
		TracerCount=0;
	}
	else
		TracerCount++;
}

simulated function FlashMuzzleFlashes( bool bFirstPass )
{
	local Rotator	AimRot;
	local int		x;	
	AimRot = TurretWeapon( Weapon ).GetFireRotation();	

	// GBX:PAD: Added this because it is now transient, so it won't be recreated in PostNetBeginPlay, so doing
	// this guarantees it will be created if not there.
	if ( FlashEmitters[0] == None && MuzzleFlashClass != None )
    {
		for( x=0; x<4; x++)
		{
			FlashEmitters[x] = Spawn(MuzzleFlashClass);
			FlashEmitters[x].InitializeMuzzleFlash();
			FlashEmitters[x].Emitters[0].SuspendSpawning();
		}
    }

	if ( bFirstPass )
	{
		FlashEmitters[0].SetLocation( Weapon.GetBoneCoords( MuzzleFlashBones[0] ).Origin );
		FlashEmitters[0].SetRotation( AimRot );
		FlashEmitters[0].Flash();		
		SendTracer(0);

		FlashEmitters[2].SetLocation( Weapon.GetBoneCoords( MuzzleFlashBones[2] ).Origin );
		FlashEmitters[2].SetRotation( AimRot );
		FlashEmitters[2].Flash();		
		SendTracer(2);
	}
	else
	{
		FlashEmitters[1].SetLocation( Weapon.GetBoneCoords( MuzzleFlashBones[1] ).Origin );
		FlashEmitters[1].SetRotation( AimRot );
		FlashEmitters[1].Flash();	
		SendTracer(1);

		FlashEmitters[3].SetLocation( Weapon.GetBoneCoords( MuzzleFlashBones[3] ).Origin );
		FlashEmitters[3].SetRotation( AimRot );
		FlashEmitters[3].Flash();
		SendTracer(3);
		
		Weapon.PlayOwnedSoundCue(FireSoundCue, Weapon.m_eNextWeaponSoundSlot, TransientSoundVolume,,,,true);	
	}	
}

simulated function PlayReloading()
{
	if ( Weapon.IsReloading() )
		return;
	
	//Weapon.ClientStopFire(0);

	WeapDEFlakvierling( Weapon ).PlayReloading();

    // TBD: reloading sound here

	Weapon.ClientState = WS_Reloading;
	bIsReloading = true;

	if (WeaponAttachment(Weapon.ThirdPersonActor) != None)
		Weapon.IncrementFlashCount(WeaponAttachment(Weapon.ThirdPersonActor).WEAP_StateReload);	
}

function DoTrace(Vector Start, Rotator Dir, optional out Vector End, optional out Vector EndDir)
{
}

defaultproperties
{
	AmmoClass=class'AmmoDEFlakvierling'
	MuzzleFlashClass=class'MuzzleFlashFlakvierling'
	TracerClass=class'EmitterFlakTracer'

	MuzzleFlashBones(0)=Dummy10
	MuzzleFlashBones(1)=Dummy11
	MuzzleFlashBones(2)=Dummy16
	MuzzleFlashBones(3)=Dummy17
	
	FireAnim=Fire
	FireAnimRate=1.0
	AmmoPerFire=1

	AIFireRateSP=0.4
	AIFireRateMP=0.4

	FireSoundName="W_ANTIAIR.Fire"

	TracerCount=0

}
//=============================================================================
// German MG42 fire mode class.
//
// Author: Neil Johnson, Gearbox Software.
//=============================================================================
class FireDEHalftrackMG42_ extends InstantFire
	config(User);



//---------------------------------------------------------
//	Variables
//---------------------------------------------------------
var Rotator		AimRot;		// Direction the weapon was aimed at.

//---------------------------------------------------------
//	PostNetBeginPlay
//---------------------------------------------------------
function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();

	// GBX:naj - spawning the muzzle flash is required here to avoid it flashing the first time you mount the weapon.
	if ( ((FlashEmitter == None) || FlashEmitter.bDeleteMe) && FlashEmitterClass != None )
    {
		FlashEmitter = Spawn(FlashEmitterClass);
		gbxMuzzleFlash( FlashEmitter ).InitializeMuzzleFlash();
    }
}

//---------------------------------------------------------
//	PlayFiring
//---------------------------------------------------------
function PlayFiring()
{
	if ( Instigator.Weapon.IsA( 'WeapDEMG42_' ) )
	{
		WeapDEMG42_( Instigator.Weapon ).PlayFiringAnim();
	}

	ClientPlayForceFeedback(FireForce);
}

//---------------------------------------------------------
//	PlayReloading
//---------------------------------------------------------
simulated function PlayReloading()
{
	local bool bKeepFiring;

	bKeepFiring = bIsFiring;

	Weapon.ClientStopFire(0);
	Weapon.ReloadClip();

	if ( bKeepFiring )
		gbxWeapon( Weapon ).StartFiringWeapon();
}

simulated function bool ReadyToFire()
{
	return AllowFire();
}

//---------------------------------------------------------
//	AllowFire
//---------------------------------------------------------
simulated function bool AllowFire()
{
	if (Weapon.IsA('gbxWeapon') && Instigator.Controller.bIsHumanPlayer)
	{
		if (gbxWeapon(Weapon).bAimingAtFriendly)
			return false;
	}
	return Super.AllowFire();
	/*
	// Do the relatively-expensive muzzle check only on every third bullet.
	// (Handled in parent.)
	if ( ShotCount % 3 != 0 )
	{
		return true;
	}
    else if (Super.AllowFire() && Instigator.ApproveShot() )
	{
        return true;
	}
    else
    {
        //ClickTime = Level.TimeSeconds + 0.25;
        return false;
    }
	*/
}

//---------------------------------------------------------
//	GetMuzzleFlash
//---------------------------------------------------------
simulated function Emitter GetMuzzleFlash()
{
	local Vector X,Y,Z;
	local AttachmentDEHalftrackMG42_ Attachment;

	GetAxes( Weapon.Rotation, X,Y,Z);

	if ( ((FlashEmitter == None) || FlashEmitter.bDeleteMe) && FlashEmitterClass != None )
    {
		Attachment = WeapDEHalftrackMG42_( Weapon ).GetAttachment();
		if ( Attachment == None )
			return None;

        FlashEmitter = Spawn(FlashEmitterClass);
		FlashEmitter.SetLocation( Weapon.Location + Attachment.MuzzleOffset.X*X + Attachment.MuzzleOffset.Y*Y + Attachment.MuzzleOffset.Z*Z );
		FlashEmitter.SetRotation( Weapon.Rotation );
		FlashEmitter.SetBase( Weapon );		

		gbxMuzzleFlash( FlashEmitter ).InitializeMuzzleFlash();
    }

	FlashEmitter.Instigator = Self.Instigator;
	return FlashEmitter;
}

//---------------------------------------------------------
//	StartFiringWeapon
//---------------------------------------------------------
function StartFiringWeapon()
{
	if ( FlashEmitter != None && FlashEmitter.IsA( 'gbxMuzzleFlash' ) )
		gbxMuzzleFlash( FlashEmitter ).FireButtonPressed();
}

//---------------------------------------------------------
//	StopFiringWeapon
//---------------------------------------------------------
function StopFiringWeapon()
{
	if ( FlashEmitter != None && FlashEmitter.IsA( 'gbxMuzzleFlash' ) )
		gbxMuzzleFlash( FlashEmitter ).FireButtonReleased();
}

//---------------------------------------------------------
//	GetBestBurstLength
//---------------------------------------------------------
function GetBestBurstLength( ESuppressionLevel SuppressionLevel, out float MinLen, out float MaxLen )
{
	switch ( SuppressionLevel )
	{
	case SL_UNSUPPRESSED:
		MinLen = BurstLength_Low.Min;
		MaxLen = BurstLength_Low.Max;
		break;
	case SL_SUPPRESSED:
		MinLen = BurstLength_High.Min;
		MaxLen = BurstLength_High.Max;
		break;
	}
}

//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
    AmmoClass=class'AmmoDEMG42_'
    AmmoPerFire=1
    DamageType=class'DamageDEMG42_'
	Damage_Human_SP=(min=90,max=120)
	Damage_Human_MP=(min=90,max=120)
	Damage_AI_SP=(min=90,max=120)
	Damage_AI_MP=(min=90,max=120)
    bPawnRapidFireAnim=true
	Load=1

	FireAnim=Fire
    FireEndAnim=None
    FireLoopAnim=None
	ReloadAnim=None

	FlashEmitterClass=class'gbxEffects.MuzzleFlashMG42_'

    FireForce="MachineGunFire"   // jdf

	PreFireTime=0.0
	FireRateSP=0.06
	FireRateMP=0.06
    AIFireRateSP=0.06
	AIFireRateMP=0.06
    bModeExclusive=true

	SuppressionMultiplierSP=1.5

	TraceRange=15000

	bWaitForRelease=false

	ShakeOffsetMag=(X=1.0,Y=1.0,Z=1.0)
    ShakeOffsetRate=(X=1000.0,Y=1000.0,Z=1000.0)
    ShakeOffsetTime=2
    ShakeRotMag=(X=50.0,Y=50.0,Z=50.0)
    ShakeRotRate=(X=10000.0,Y=10000.0,Z=10000.0)
    ShakeRotTime=2

	BurstLength_Low=(Min=0.05,Max=1.5)
	BurstLength_High=(Min=0.2,Max=0.5)

	// This really sucks, but constants are supported here, so I'm just setting this to the value of the constant.
	FireType=1

	AimErrorMin_Human=450
	AimErrorMax_Human_Crouched=500	
	AimErrorMax_Human_Standing=900
	AimErrorMin_Human_Zoomed=150
	AimErrorMax_Human_Zoomed=450

	AimErrorMin_AI_SP=250
	AimErrorMax_AI_SP_Crouched=250
	AimMultiplier_AI_SP_Sighted=1.0

	ShotCountMod=3
}
class FireDEK98Sniper extends SingleBulletReloadFire;

var float LastFireTime;
var float ClickTime;

event ModeDoFire()
{
	LastFireTime = Level.TimeSeconds;
	Super.ModeDoFire();
}

event ModeHoldFire()
{
}

defaultproperties
{
    AmmoClass=class'AmmoDEK98_'
    AmmoPerFire=1
    DamageType=class'DamageDEK98_'
    //DamageMin=45
    //DamageMax=100
	Damage_Human_SP=(min=100,max=100)
	Damage_Human_MP=(min=100,max=100)
	Damage_AI_SP=(min=40,max=45)
	Damage_AI_MP=(min=100,max=100)
    bPawnRapidFireAnim=true
	Load=1

    FireAnim=fire
    FireEndAnim=None
    FireLoopAnim=None
    FireAnimRate=1.0
	ReloadAnim=reload
	ReloadAnimRate=1.0

    FlashEmitterClass=class'gbxEffects.MuzzleFlashK98_'
	
	// PSV: 3/22/2004 Using cues now...
	FireSoundName="W_K98MAUSER.FIRE"
	StereoFireSoundName="W_K98MAUSER.FIRE_ST"

    FireForce="RifleFire"   // jdf

	PreFireTime=0.0
    //FireRate=1.2
	FireRateSP=1.2
	FireRateMP=1.2
    AIFireRateSP=1.2
	AIFireRateMP=1.2
	AIOpBurstMultiplierSP=0.7
	AIOpBurstMultiplierMP=0.7
    bModeExclusive=true

//	SuppressionMultiplierSP=1.25
	SuppressionMultiplierSP=10
	SuppressionMultiplierMP=10

    AimErrorMin_Human=100
	AimErrorMax_Human_Crouched=200	
	AimErrorMax_Human_Standing=350
	AimErrorMax_Human_MovingSlow=1100
	AimErrorMax_Human_MovingFast=1300
	AimErrorMin_Human_Zoomed=0
	AimErrorMax_Human_Zoomed=30

	AimErrorMin_AI_MP=100
	AimErrorMax_AI_MP_Crouched=200
	AimErrorMax_AI_MP_Standing=350
	AimErrorMax_AI_MP_Moving=1200
	AimMultiplier_AI_MP_Sighted=0.2

	AimErrorMin_AI_SP=800
	AimErrorMax_AI_SP_Crouched=1500
	AimErrorMax_AI_SP_Standing=2800
	AimErrorMax_AI_SP_Moving=5400
	AimMultiplier_AI_SP_Sighted=0.3

    ShakeOffsetMag=(X=0.0,Y=0.0,Z=0.0)
    ShakeOffsetRate=(X=1000.0,Y=1000.0,Z=1000.0)
    ShakeOffsetTime=2
    ShakeRotMag=(X=50.0,Y=50.0,Z=50.0)
    ShakeRotRate=(X=10000.0,Y=10000.0,Z=10000.0)
    ShakeRotTime=2

	bWaitForRelease=false

	// Burst count levels.
	Burst_High_SP=(Min=1,Max=1)
	Burst_High_MP=(Min=1,Max=1)
	Burst_Low_SP=(Min=2,Max=3)
	Burst_Low_MP=(Min=2,Max=3)
	Burst_Op_SP=(Min=4,Max=6)
	Burst_Op_MP=(Min=4,Max=6)

	// This really sucks, but constants are supported here, so I'm just setting this to the value of the constant.
	FireType=1

    TraceRange=30000

	ShotCountMod=0

	ReloadAnimList[0]=reload_05
	ReloadAnimList[1]=reload_01
	ReloadAnimList[2]=reload_02
	ReloadAnimList[3]=reload_03
	ReloadAnimList[4]=reload_04

	LastShotFireAnim=fire_last
	LastShotFireRate=0.36
}
class FireDEK98_ extends SingleBulletReloadFire;

var float LastFireTime;
var float ClickTime;

event ModeDoFire()
{
	LastFireTime = Level.TimeSeconds;
	Super.ModeDoFire();
}

event ModeHoldFire()
{
}

defaultproperties
{
    AmmoClass=class'AmmoDEK98_'
    AmmoPerFire=1
    DamageType=class'DamageDEK98_'
    //DamageMin=45
    //DamageMax=100
	Damage_Human_SP=(min=90,max=105)
	Damage_Human_MP=(min=60,max=60)
	Damage_AI_SP=(min=40,max=45)
	Damage_AI_MP=(min=60,max=60)
    bPawnRapidFireAnim=true
	Load=1

    FireAnim=fire
    FireEndAnim=None
    FireLoopAnim=None
    //FireAnimRate=1.0
	FireAnimRate=1.3
	ReloadAnim=reload
	ReloadAnimRate=1.0

    FlashEmitterClass=class'gbxEffects.MuzzleFlashK98_'

	// PSV: 3/22/2004 Using cues now...
	FireSoundName="W_K98MAUSER.FIRE"
	StereoFireSoundName="W_K98MAUSER.FIRE_ST"

    FireForce="RifleFire"   // jdf

	PreFireTime=0.0
    //FireRate=1.2
	//FireRate=1.0
	FireRateSP=1.5
	FireRateMP=1.5
    AIFireRateSP=1.5	// was 0.9
	AIFireRateMP=1.5
	AIFireRateVarianceMP=0.2

	AIOpBurstMultiplierSP=0.7
	AIOpBurstMultiplierMP=0.6
    bModeExclusive=true

    AimErrorMin_Human=200
	AimErrorMax_Human_Crouched=300	
	AimErrorMax_Human_Standing=350
	AimErrorMax_Human_MovingSlow=1100
	AimErrorMax_Human_MovingFast=1300
	//AimErrorMin_Human_Zoomed=30
	AimErrorMin_Human_Zoomed=75
	AimErrorMax_Human_Zoomed=200

	AimErrorMin_AI_MP=200
	AimErrorMax_AI_MP_Crouched=300
	AimErrorMax_AI_MP_Standing=350
	AimErrorMax_AI_MP_Moving=1300
	AimMultiplier_AI_MP_Sighted=1.0

	AimErrorMin_AI_SP=200
	AimErrorMax_AI_SP_Crouched=300
	AimErrorMax_AI_SP_Standing=350
	AimErrorMax_AI_SP_Moving=1300
	AimMultiplier_AI_SP_Sighted=0.5

	// GBX:naj - these settings are similar to MP and make the K98 very accurate.
	//AimErrorMin_AI_SP=400
	//AimErrorMax_AI_SP_Crouched=500
	//AimErrorMax_AI_SP_Standing=800
	//AimErrorMax_AI_SP_Moving=2400
	//AimMultiplier_AI_SP_Sighted=0.5

    ShakeOffsetMag=(X=0.0,Y=0.0,Z=0.0)
    ShakeOffsetRate=(X=1000.0,Y=1000.0,Z=1000.0)
    ShakeOffsetTime=2
    ShakeRotMag=(X=50.0,Y=50.0,Z=50.0)
    ShakeRotRate=(X=10000.0,Y=10000.0,Z=10000.0)
    ShakeRotTime=2

	bWaitForRelease=false

	// Suppression Multiplier
	SuppressionMultiplierSP=3.0
	SuppressionMultiplierMP=3.0

	// Burst count levels.
	Burst_High_SP=(Min=1,Max=1)
	Burst_High_MP=(Min=1,Max=4)
	Burst_Low_SP=(Min=2,Max=3)
	Burst_Low_MP=(Min=1,Max=4)
	Burst_Op_SP=(Min=4,Max=6)
	Burst_Op_MP=(Min=3,Max=5)

	// This really sucks, but constants are supported here, so I'm just setting this to the value of the constant.
	FireType=1

	ShotCountMod=0

	ReloadAnimList[0]=reload
	ReloadAnimList[1]=reload_01
	ReloadAnimList[2]=reload_02
	ReloadAnimList[3]=reload_03
	ReloadAnimList[4]=reload_04

	LastShotFireAnim=fire_last
	LastShotFireRate=0.36
}
class FireDEMG42Static extends InstantFire;



var float	LastFireTime;
var float	ClickTime;

event ModeDoFire()
{
	LastFireTime = Level.TimeSeconds;
	Super.ModeDoFire();
}

event ModeHoldFire()
{
}

//---------------------------------------------------------
//	StartFiringWeapon
//---------------------------------------------------------
function StartFiringWeapon()
{
	if ( FlashEmitter != None && FlashEmitter.IsA( 'gbxMuzzleFlash' ) )
		gbxMuzzleFlash( FlashEmitter ).FireButtonPressed();
}

//---------------------------------------------------------
//	StopFiringWeapon
//---------------------------------------------------------
function StopFiringWeapon()
{
	if ( FlashEmitter != None && FlashEmitter.IsA( 'gbxMuzzleFlash' ) )
		gbxMuzzleFlash( FlashEmitter ).FireButtonReleased();
}

defaultproperties
{
    AmmoClass=class'AmmoDEMG42_'
    AmmoPerFire=1
    DamageType=class'DamageDEMG42_'
    //DamageMin=90
    //DamageMax=120
	Damage_Human_SP=(min=90,max=120)
	Damage_Human_MP=(min=90,max=120)
	Damage_AI_SP=(min=90,max=120)
	Damage_AI_MP=(min=90,max=120)
    bPawnRapidFireAnim=true
	Load=1

    FireAnim=fire
    FireEndAnim=None
    FireLoopAnim=None
    FireAnimRate=1.0
	ReloadAnim=reload
	ReloadAnimRate=1.0

    FlashEmitterClass=class'gbxEffects.MuzzleFlashMG42_'

    FireForce="MachineGunFire"   // jdf

	PreFireTime=0.0
	FireRateSP=0.07
	FireRateMP=0.07
    AIFireRateSP=0.07
	AIFireRateMP=0.07
    bModeExclusive=true

	SuppressionMultiplierSP=0.5
    //AimErrorAI_SP=(Min=50,Max=500)
	//AimErrorAI_MP=(Min=50,Max=500)
    //AimErrorHuman_SP=50
	//AimErrorHuman_MP=50

    ShakeOffsetMag=(X=0.0,Y=0.0,Z=0.0)
    ShakeOffsetRate=(X=1000.0,Y=1000.0,Z=1000.0)
    ShakeOffsetTime=2
    ShakeRotMag=(X=50.0,Y=50.0,Z=50.0)
    ShakeRotRate=(X=10000.0,Y=10000.0,Z=10000.0)
    ShakeRotTime=2

    TweenTime = 0.01

	TraceRange=15000
	
	bWaitForRelease=false

	// Burst count levels.
	Burst_High_SP=(Min=10,Max=20)
	Burst_High_MP=(Min=10,Max=20)
	Burst_Low_SP=(Min=10,Max=20)
	Burst_Low_MP=(Min=10,Max=20)
	Burst_Op_SP=(Min=10,Max=20)
	Burst_Op_MP=(Min=10,Max=20)

	ShotCountMod=3

	// This really sucks, but constants are supported here, so I'm just setting this to the value of the constant.
	FireType=1
}
//=============================================================================
// German MG42 fire mode class.
//
// Author: Neil Johnson, Gearbox Software.
//=============================================================================
class FireDEMG42_ extends InstantFire;

// loops for things like machine guns
var String FireLoopSoundName;
var String StereoFireLoopSoundName;
var String FireEndLoopSoundName;
var String StereoFireEndLoopSoundName;

// sounds
var() Sound FireLoopSound;

// cues for the loops
var Cue FireLoopSoundCue;
var Cue StereoFireLoopSoundCue;
var Cue FireEndLoopSoundCue;
var Cue StereoFireEndLoopSoundCue;

var float FireLoopSustainEndTime;
var float fAmbientSoundFadeOutTime;

//---------------------------------------------------------
//	Variables
//---------------------------------------------------------
var Rotator		AimRot;		// Direction the weapon was aimed at.

// If the fire mode is being destroyed, stop any and all sounds immediatley
simulated function Destroyed()
{
	//log( self$" FireDEMG42_::Destroyed()", 'MP' );
    
    Super.Destroyed();
        
    // Make sure any looping sounds stop
	//log( self$ " FireDEMG42_::Destroyed() Weapon: "$Weapon, 'MP');
	
	if ( FireSoundHandle != 0 )
	{
		//log(self$ " FireDEMG42_::Destroyed() calling StopSound()!", 'MP');   
		StopSound( FireSoundHandle );
	}

	//log(self$ " FireDEMG42_::Destroyed() setting AmbientSound to None!", 'MP');   
	PlayAmbientSound(None);

    Super.Destroyed();
}

//---------------------------------------------------------
//	PostNetBeginPlay
//---------------------------------------------------------
function PostNetBeginPlay()
{
	//log( " FireDEMG42_::PostNetBeginPlay()", 'MP' );

	Super.PostNetBeginPlay();

	// GBX:naj - spawning the muzzle flash is required here to avoid it flashing the first time you mount the weapon.
	if ( ((FlashEmitter == None) || FlashEmitter.bDeleteMe) && FlashEmitterClass != None )
    {
		FlashEmitter = Spawn(FlashEmitterClass);
		gbxMuzzleFlash( FlashEmitter ).InitializeMuzzleFlash();
    }

	// Loops
	if ( FireLoopSoundName != "" )
	{
		FireLoopSoundCue = LoadSound( FireLoopSoundName );
		FireLoopSound = Sound( DynamicLoadObject( FireLoopSoundName, class'Sound' ) );
	}

	if ( StereoFireLoopSoundName != "" )
	{
		StereoFireLoopSoundCue = LoadSound( StereoFireLoopSoundName );
	}
		

	if ( FireEndLoopSoundName != "" )
		FireEndLoopSoundCue = LoadSound( FireEndLoopSoundName );
    
	if ( StereoFireEndLoopSoundName != "" )
		StereoFireEndLoopSoundCue = LoadSound( StereoFireEndLoopSoundName );

	if ( FireLoopSoundCue != None )
	{
		if ( Weapon.ThirdPersonActor != None )
		{
			Weapon.ThirdPersonActor.SoundRadius = FireLoopSoundCue.MaximumDistance;
		}
	}
	
	//log(self$ " FireDEMG42_::PostNetBeginPlay() FireLoopSoundCue: "$FireLoopSoundCue$" FireLoopSound: " $FireLoopSound$ " Weapon: " $Weapon$ " Weapon.ThirdPersonActor: " $Weapon.ThirdPersonActor, 'MP');
}

//---------------------------------------------------------
//	PlayFiring
//---------------------------------------------------------
function PlayFiring()
{
	if ( Instigator.Weapon.IsA( 'WeapDEMG42_' ) )
	{
		WeapDEMG42_( Instigator.Weapon ).PlayFiringAnim();
	}

	ClientPlayForceFeedback(FireForce);
}

//---------------------------------------------------------
//	PlayReloading
//---------------------------------------------------------
simulated function PlayReloading()
{
	local bool bKeepFiring;

	//log( self$ " FireDEMG42::PlayReloading()", 'MP' );

	bKeepFiring = bIsFiring;

	Weapon.ClientStopFire(0);
	Weapon.ReloadClip();

	if ( bKeepFiring )
		gbxWeapon( Weapon ).StartFiringWeapon();
}

simulated function bool ReadyToFire()
{
	return AllowFire();
}

//---------------------------------------------------------
//	AllowFire
//---------------------------------------------------------
simulated function bool AllowFire()
{
	if (Weapon.IsA('gbxWeapon') && Instigator.Controller.bIsHumanPlayer)
	{
		if (gbxWeapon(Weapon).bAimingAtFriendly)
			return false;
	}
	return Super.AllowFire();
	/*
	// Do the relatively-expensive muzzle check only on every third bullet.
	// (Handled in parent.)
	if ( ShotCount % 3 != 0 )
	{
		return true;
	}
    else if (Super.AllowFire() && Instigator.ApproveShot() )
	{
        return true;
	}
    else
    {
        //ClickTime = Level.TimeSeconds + 0.25;
        return false;
    }
	*/
}

//---------------------------------------------------------
//	GetMuzzleFlash
//---------------------------------------------------------
simulated function Emitter GetMuzzleFlash()
{
	local Vector X,Y,Z;
	local AttachmentDEMG42_ Attachment;

	GetAxes( Weapon.Rotation, X,Y,Z);

	if ( ((FlashEmitter == None) || FlashEmitter.bDeleteMe) && FlashEmitterClass != None )
    {
		Attachment = WeapDEMG42_( Weapon ).GetAttachment();
		if ( Attachment == None )
			return None;

        FlashEmitter = Spawn(FlashEmitterClass);
		FlashEmitter.SetLocation( Weapon.Location + Attachment.MuzzleOffset.X*X + Attachment.MuzzleOffset.Y*Y + Attachment.MuzzleOffset.Z*Z );
		FlashEmitter.SetRotation( Weapon.Rotation );
		FlashEmitter.SetBase( Weapon );		

		gbxMuzzleFlash( FlashEmitter ).InitializeMuzzleFlash();
    }

	FlashEmitter.Instigator = Self.Instigator;
	return FlashEmitter;
}

//---------------------------------------------------------
//	StartFiringWeapon
//---------------------------------------------------------
function StartFiringWeapon()
{
	//log(self$ " Time:"$Level.TimeSeconds$" FireDEMG42_::StartFiringWeapon() Weapon.ThirdPersonActor.Instigator="$Weapon.ThirdPersonActor.Instigator$" Instigator="$Instigator$" Local="$Instigator.IsLocallyControlled()$"Level.GetLocalPlayerController()="$Level.GetLocalPlayerController(), 'MP' );

	if ( FlashEmitter != None && FlashEmitter.IsA( 'gbxMuzzleFlash' ) )
		gbxMuzzleFlash( FlashEmitter ).FireButtonPressed();

    // client
    if (Instigator.IsLocallyControlled())
    {
		if ( Instigator.Controller == Level.GetLocalPlayerController() )
		{
			//log(self$ " Time:"$Level.TimeSeconds$" FireDEMG42_::StartFiringWeapon() Instigator.Controller == Level.GetLocalPlayerController()!  About to play sound locally!", 'MP' );

			if ( FireSoundHandle == 0 )  
			{
				if ( StereoFireLoopSoundCue != None /*&& (Instigator.Controller == Level.GetLocalPlayerController())*/ )
				{
					FireSoundHandle = Weapon.PlayLocalSoundCue(StereoFireLoopSoundCue, SLOT_None, false);	
					//log(self$ " FireDEMG42_::StartFiringWeapon() Setting SustainEndTime: " $FireLoopSustainEndTime, 'MP');  
				}
				else
				{
					//log( self$ " FireDEMG42_::StartFiringWeapon() StereoFireLoopSoundCue is NULL so MONO first person firing sound will play!  Baaaad!", 'MP' );				
					FireSoundHandle = Weapon.PlayOwnedSoundCue(FireLoopSoundCue, SLOT_None, TransientSoundVolume,,,,true);	
				}
			}
		}
    }

	// Change fire states
	if ( !WeapDEMG42_(Weapon).bWeaponFiring )
	{
		StartFiring();
	}
}

//---------------------------------------------------------
//	StopFiringWeapon
//---------------------------------------------------------
function StopFiringWeapon()
{
	//log( " FireDEMG42_::StopFiringWeapon()", 'MP' );

	if ( FlashEmitter != None && FlashEmitter.IsA( 'gbxMuzzleFlash' ) )
		gbxMuzzleFlash( FlashEmitter ).FireButtonReleased();

	StopFiring();
}

//---------------------------------------------------------
//	GetBestBurstLength
//---------------------------------------------------------
function GetBestBurstLength( ESuppressionLevel SuppressionLevel, out float MinLen, out float MaxLen )
{
	switch ( SuppressionLevel )
	{
	case SL_UNSUPPRESSED:
		MinLen = BurstLength_Low.Min;
		MaxLen = BurstLength_Low.Max;
		break;
	case SL_SUPPRESSED:
		MinLen = BurstLength_High.Min;
		MaxLen = BurstLength_High.Max;
		break;
	}
}

// PSV: 11/29/2004 Added fire loop support for machine guns
simulated function PlayAmbientSound(Sound aSound)
{
	if (Weapon.ThirdPersonActor == None) 
	{
        //log(self$ " FireDEMG42::PlayAmbientSound() Weapon: " $Weapon$ " Weapon.ThirdPersonActor == NULL!!!  BAD!!", 'MP');
		return;		
	}

	//log(self$ "FireDEMG42::PlayAmbientSound() aSound: "$aSound, 'MP');

	// Because users can fire and release super fast, we need to sustain the fireloop long enough 
	// so that at least one fire "bang" sound is played
    if ( aSound == None )
	{		
		if  ( Weapon.ThirdPersonActor.AmbientSound != None )
		{
			//log(self$ "FireDEMG42::PlayAmbientSound() Setting Weapon.ThirdPersonActor.AmbientSound:"$Weapon.ThirdPersonActor.AmbientSound$" to "$aSound, 'MP');
			// Set a fade-out time for the fire looping sound
			Weapon.ThirdPersonActor.m_fAmbientSoundFadeOutTime = fAmbientSoundFadeOutTime;
			Weapon.ThirdPersonActor.AmbientSound = aSound;
		}
		else
		{
			//log(self$ "FireDEMG42::PlayAmbientSound() Weapon.ThirdPersonActor.AmbientSound is already set to None.", 'MP');
		}
    }
	else
	{
		//log(self$ "PlayAmbientSound() Weapon.ThirdPersonActor="$Weapon.ThirdPersonActor$" AmbientSound set to "$aSound, 'MP');   
		Weapon.ThirdPersonActor.AmbientSound = aSound;
	}
}

// Called locally to stop first person fire loop and play one off shot
function StopFiring()
{
	//log( " FireDEMG42_::StopFiring() bIsFiring="$bIsFiring$" WeapDEMG42_(Weapon).bWeaponFiring="$WeapDEMG42_(Weapon).bWeaponFiring$" FireSoundHandle="$FireSoundHandle, 'MP' );

	if ( !WeapDEMG42_(Weapon).bWeaponFiring && FireSoundHandle == 0 )
	{
		//log(self$ " Time:"$Level.TimeSeconds$" FireDEMG42::StopFiring() Returning because Weapon.bWeaponFiring == FALSE!", 'MP' );
		return;
	}
	
	Super.StopFiring();

	//log(self$ " Time:"$Level.TimeSeconds$" FireDEMG42::StopFiring() Weapon.bWeaponFiring="$WeapDEMG42_(Weapon).bWeaponFiring$" FireSoundHandle=" $FireSoundHandle, 'MP' );

	if (Instigator.IsLocallyControlled())
	{
		//log(self$ " Time:"$Level.TimeSeconds$" FireDEMG42::StopFiring() LOCALLY CONTROLLED!", 'MP');

		if ( StereoFireEndLoopSoundCue != None && (Instigator.Controller == Level.GetLocalPlayerController()) )
		{
			if ( FireSoundHandle != 0 )
			{
				//log( self$ " FireDEMG42::StopFiring() Playing stereo one off shot", 'MP');	
				Weapon.PlayLocalSoundCue(StereoFireEndLoopSoundCue, SLOT_None, false);	
			}
			else
			{
				//log( self$ " Time:"$Level.TimeSeconds$" FireDEMG42::StopFiring() FireSoundHandle is NULL so we didnt play stereofireendloopsoundcue!", 'MP' );
			}
		}
		else
		{
			//log(self$ " Time:"$Level.TimeSeconds$" FireDEMG42::StopFiring() Weapon.ThirdPersonActor.AmbientSound="$Weapon.ThirdPersonActor.AmbientSound, 'MP' );
			//log(self$ " Time:"$Level.TimeSeconds$" FireDEMG42::StopFiring() Missing stereo cue or AI guy stopped firing on server.  Playing mono one off shot", 'MP');	
			Weapon.PlayLocalSoundCue(FireEndLoopSoundCue, SLOT_None, false);	
		}
	}

	if ( Weapon.ThirdPersonActor.AmbientSound != None )
	{
		// This shouldn't be the case for the local guy!!!!!!!! BAD!!!!
		//log(self$ " Time:"$Level.TimeSeconds$" FireDEMG42::StopFiring() Playing mono one off shot", 'MP');
		Weapon.PlayRemoteSoundCue(FireEndLoopSoundCue, SLOT_None, true, false);
	}
	else
	{
		//log(self$ " Time:"$Level.TimeSeconds$" FireDEMG42::StopFiring() Not playing one off end shot because Weapon.ThirdPersonActor.AmbientSound is NULL!");
	}
	
	// Was the stereo loop playing?
	if ( FireSoundHandle != 0 )					
		StopSound( FireSoundHandle );

	// Stop the mono loop
	PlayAmbientSound(None);

	FireSoundHandle = 0;
}

auto state Idle
{
    function BeginState()
    {
	//log(" Time:"$Level.TimeSeconds$" FireDEMG42_::Idle::BeginState()", 'MP' );
        PlayAmbientSound(None);
    }

    function EndState()
    {
    }

    function StartFiring()
    {
	//log( " Time:"$Level.TimeSeconds$" FireDEMG42_::Idle::StartFiring()", 'MP' );
	//bWeaponFiring = true;
        GotoState('FireLoop');
    }
}

state FireLoop
{
    function BeginState()
    {
	//log( " Time:"$Level.TimeSeconds$" FireDEMG42_::FireLoop::StartFiring() Calling PlayAmbientSound("$FireLoopSound$")", 'MP');
	PlayAmbientSound(FireLoopSound);
    }

    function StopFiring()
    {
	//log( " Time:"$Level.TimeSeconds$" FireDEMG42_::FireLoop::StopFiring()", 'MP' );
	Global.StopFiring();
	GotoState('Idle');
    }

    function EndState()
    {
    }
}

//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
    AmmoClass=class'AmmoDEMG42_'
    AmmoPerFire=1
    DamageType=class'DamageDEMG42_'
	Damage_Human_SP=(min=90,max=120)
	Damage_Human_MP=(min=90,max=120)
	Damage_AI_SP=(min=90,max=120)
	Damage_AI_MP=(min=90,max=120)
    bPawnRapidFireAnim=true
	Load=1

	FireAnim=Fire
    FireEndAnim=None
    FireLoopAnim=None
	ReloadAnim=None

	FlashEmitterClass=class'gbxEffects.MuzzleFlashMG42_'

    FireForce="MachineGunFire"   // jdf

	PreFireTime=0.0
	FireRateSP=0.06
	FireRateMP=0.06
    AIFireRateSP=0.06
	AIFireRateMP=0.06
    bModeExclusive=true

	SuppressionMultiplierSP=1.5

	TraceRange=15000

	bWaitForRelease=false

	ShakeOffsetMag=(X=1.0,Y=1.0,Z=1.0)
    ShakeOffsetRate=(X=1000.0,Y=1000.0,Z=1000.0)
    ShakeOffsetTime=2
    ShakeRotMag=(X=50.0,Y=50.0,Z=50.0)
    ShakeRotRate=(X=10000.0,Y=10000.0,Z=10000.0)
    ShakeRotTime=2

	BurstLength_Low=(Min=0.05,Max=1.5)
	BurstLength_High=(Min=0.2,Max=0.5)

	// This really sucks, but constants are supported here, so I'm just setting this to the value of the constant.
	FireType=1

	AimErrorMin_Human=450
	AimErrorMax_Human_Crouched=500	
	AimErrorMax_Human_Standing=900
	AimErrorMin_Human_Zoomed=150
	AimErrorMax_Human_Zoomed=450

	AimErrorMin_AI_SP=250
	AimErrorMax_AI_SP_Crouched=250
	AimMultiplier_AI_SP_Sighted=1.0

	ShotCountMod=3

	// One off sounds
	//FireSoundName="W_MG42A.FIRELOOPEND"
	
	// Loops
	FireLoopSoundName="W_MG42A.FIRELOOP"
	StereoFireLoopSoundName="W_MG42A.FIRELOOP_ST"
	FireEndLoopSoundName="W_MG42A.FIRELOOPEND"
	StereoFireEndLoopSoundName="W_MG42A.FIRELOOPEND_ST"

	//MinFireLoopSustainTime = 0.0
	//bCheckForEndSustainLoop = false
	FireLoopSustainEndTime = 0.0
	fAmbientSoundFadeOutTime = 0.1
}
class FireDEMortar extends WeaponFire;

//---------------------------------------------------------
//	Variables
//---------------------------------------------------------
var gbxMortarShell			Shell;
var float					ShellDelay;
var Cue		MortarLaunchSound;
var Cue		MortarFlightSound;
var String	MortarLaunchSoundName;
var String	MortarFlightSoundName;

function PostBeginPlay() 
{
	Super.PostBeginPlay();

	if ( MortarFlightSoundName != "" )
	{
		MortarFlightSound = LoadSound(MortarFlightSoundName);
	}

	if ( MortarLaunchSoundName != "" )
	{
		MortarLaunchSound = LoadSound(MortarLaunchSoundName);
	}
}

//---------------------------------------------------------
//	PlayFiring
//---------------------------------------------------------
simulated function PlayFiring()
{
	Super.PlayFiring();

	WeapDEMortar( Weapon ).PlayFiring();
}

//---------------------------------------------------------
//	DoFireEffect
//---------------------------------------------------------
event DoFireEffect() {}

//---------------------------------------------------------
//	GetTargetLocMarching
//---------------------------------------------------------
function Vector GetTargetLocMarching( int TotalShots, int NumShotsAlreadyFired, float StartingOffset )
{
	local Vector OffsetDir;
	local float SingleShotOffset;

	OffsetDir = Normal( Weapon.Location - WeapDEMortar( Weapon ).TargetLocation );
	SingleShotOffset = StartingOffset / TotalShots;

	return WeapDEMortar( Weapon ).TargetLocation + SingleShotOffset * ( TotalShots - NumShotsAlreadyFired ) * OffsetDir;
}

//---------------------------------------------------------
//	GetTargetLocEffect
//---------------------------------------------------------
function Vector GetTargetLocEffect( float Offset )
{
	local Rotator OffsetRot;

	OffsetRot.Yaw = FRand() * 65535;

	return WeapDEMortar( Weapon ).TargetLocation + Offset * Vector( OffsetRot );
}

//---------------------------------------------------------
//	GetTargetLocBracketing
//---------------------------------------------------------
function Vector GetTargetLocBracketing( int TotalShots, int NumShotsAlreadyFired, float StartingOffset )
{
	local bool bRightSide;
	local Vector OffsetDir;
	local float SingleShotOffset;
	
	if ( NumShotsAlreadyFired % 2 == 0 )
		bRightSide = true;

	OffsetDir = Normal( WeapDEMortar( Weapon ).TargetLocation - Weapon.Location ) cross Vect(0,0,1);
	if ( bRightSide )
		OffsetDir *= -1;

	SingleShotOffset = StartingOffset / TotalShots;
	return WeapDEMortar( Weapon ).TargetLocation + SingleShotOffset * ( TotalShots - NumShotsAlreadyFired ) * OffsetDir;
}

//---------------------------------------------------------
//	GetTargetLocBounded
//---------------------------------------------------------
function Vector GetTargetLocBounded( float Offset )
{
	local Vector NewLoc;
	local Rotator OffsetDir;
	
	NewLoc = WeapDEMortar( Weapon ).TargetLocation;
	OffsetDir.Yaw = FRand() * 65535;
	NewLoc += ( Offset * FRand() * Vector( OffsetDir ) );

	return NewLoc;
}

//---------------------------------------------------------
//	LaunchMortar
//---------------------------------------------------------
function LaunchMortar( EMortarFire FireType, int TotalShots, int NumShotsAlreadyFired, float StartingOffset )
{
	local Vector X,Y,Z, OffsetLoc;
	local Vector TargetLocation;
	local Rotator ShellRot, TempRot;

	if ( WeapDEMortar( Weapon ).Target == None )
		return;

	GetAxes( Weapon.Rotation, X,Y,Z );

	switch ( FireType )
	{
		case MortarFire_Marching_Random:
		case MortarFire_Marching:
			TargetLocation = GetTargetLocMarching( TotalShots, NumShotsAlreadyFired, StartingOffset );
			break;
		case MortarFire_Effect:
			TargetLocation = GetTargetLocEffect( StartingOffset );
			break;
		case MortarFire_Bracketing:
			TargetLocation = GetTargetLocBracketing( TotalShots, NumShotsAlreadyFired, StartingOffset );
			break;
		case MortarFire_Bounded:
			TargetLocation = GetTargetLocBounded( StartingOffset );
			break;
		default:
			return;
	}

	ShellRot = WeapDEMortar( Weapon ).MuzzleRotation;
	TempRot = Rotator( TargetLocation - Weapon.Location );
	ShellRot.Yaw = TempRot.Yaw;

	PlayOwnedSoundCue( MortarLaunchSound, SLOT_None );
	Shell = Spawn(class'gbxMortarShell',self,, WeapDEMortar( Weapon ).MuzzleLocation, ShellRot );

	// To make the Marching less linear, we randomize the target location a bit,.
	if ( FireType == MortarFire_Marching_Random )
	{	
		OffsetLoc.x = Rand(800);
		OffsetLoc.y = Rand(500);
		Shell.Launch( TargetLocation+OffsetLoc, ShellDelay );
	}
	else
		Shell.Launch( TargetLocation, ShellDelay );

	Shell.MortarFlightSound = MortarFlightSound;
}

//---------------------------------------------------------
//	PlayReloading
//---------------------------------------------------------
simulated function PlayReloading()
{
}

//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
	AmmoClass=class'AmmoDEMortar'
	AIFireRateSP=0.1
	AIFireRateMP=0.1
	ShellDelay=3.5
	AmmoPerFire=1
	MortarLaunchSoundName="W_MORTAR.Fire"
	MortarFlightSoundName="W_MORTAR.INCOMING"	
}class FireDEMP40_ extends FireSubMachineGun;

var Emitter	ViewFlashEmitter;
var class<Emitter> ViewFlashEmitterClass;

/// SJP: The thompson muzzle flash doesn't work very well in first person, so provide an alternative here
simulated function Emitter GetMuzzleFlash()
{
	if ( Instigator.IsFirstPerson() )
    {
		if( ((ViewFlashEmitter == None) || ViewFlashEmitter.bDeleteMe) && ViewFlashEmitterClass != None )
		{
			ViewFlashEmitter = Spawn(ViewFlashEmitterClass);
			log("Spawned "$ViewFlashEmitter, 'weapon');
		}

		return ViewFlashEmitter;
    }
	else
	{
		return Super.GetMuzzleFlash();
	}
}

defaultproperties
{
    AmmoClass=class'AmmoDEMP40_'
    AmmoPerFire=1
    DamageType=class'DamageDEMP40_'
    //DamageMin=35
    //DamageMax=40
	Damage_Human_SP=(min=30,max=40)
	Damage_Human_MP=(min=30,max=30)
	Damage_AI_SP=(min=25,max=30)
	Damage_AI_MP=(min=30,max=30)
    bPawnRapidFireAnim=true
	Load=1

    FireAnim=fire
    FireEndAnim=None
    FireLoopAnim=None
    FireAnimRate=1.0
	ReloadAnim=reload
	ReloadAnimRate=1.0
    FlashEmitterClass=class'gbxEffects.MuzzleFlashThompson'
	ViewFlashEmitterClass=class'gbxEffects.MuzzleFlashColt1911_'

	// One off sounds
	FireSoundName="W_MP40D.FIRE"
	
	// Loops
	FireLoopSoundName="W_MP40D.FIRELOOP"
	StereoFireLoopSoundName="W_MP40D.FIRELOOP_ST"
	FireEndLoopSoundName="W_MP40D.FIRELOOPEND"
	StereoFireEndLoopSoundName="W_MP40D.FIRELOOPEND_ST"

    FireForce="SubMachineGunFire"   // jdf

	PreFireTime=0.0
    FireRateSP=0.12	// 500 rpm
	FireRateMP=0.12	// 500 rpm
    AIFireRateSP=0.12
	AIFireRateMP=0.12
    bModeExclusive=true

	SuppressionMultiplierSP=0.5
	SuppressionMultiplierMP=0.4

    AimErrorMin_Human=800
	AimErrorMax_Human_Crouched=900
	AimErrorMax_Human_Standing=1000
	AimErrorMax_Human_MovingSlow=1300
	AimErrorMax_Human_MovingFast=1500
	AimErrorMin_Human_Zoomed=450
	AimErrorMax_Human_Zoomed=1600
	AimErrorMin_Human_FirstShot=100
	AimErrorMax_Human_FirstShot=300

	AimErrorMin_AI_MP=800
	AimErrorMax_AI_MP_Crouched=900
	AimErrorMax_AI_MP_Standing=1000
	AimErrorMax_AI_MP_Moving=1500
	AimMultiplier_AI_MP_Sighted=1.0

	AimErrorMin_AI_SP=800
	AimErrorMax_AI_SP_Crouched=900
	AimErrorMax_AI_SP_Standing=1000
	AimErrorMax_AI_SP_Moving=1500
	AimMultiplier_AI_SP_Sighted=0.6

    ShakeOffsetMag=(X=0.0,Y=0.0,Z=0.0)
    ShakeOffsetRate=(X=1000.0,Y=1000.0,Z=1000.0)
    ShakeOffsetTime=2
    ShakeRotMag=(X=50.0,Y=50.0,Z=50.0)
    ShakeRotRate=(X=10000.0,Y=10000.0,Z=10000.0)
    ShakeRotTime=2

    TweenTime = 0.01

	bWaitForRelease=false
	bAccurateFirstShot=true

	// Burst count levels.
	Burst_High_SP=(Min=2,Max=5)
	Burst_High_MP=(Min=10,Max=20)
	Burst_Low_SP=(Min=5,Max=10)
	Burst_Low_MP=(Min=10,Max=20)
	Burst_Op_SP=(Min=5,Max=10)
	Burst_Op_MP=(Min=10,Max=32)

	ShotCountMod=3

	m_flRandomBurstRange=0.0

	// This really sucks, but constants are supported here, so I'm just setting this to the value of the constant.
	FireType=1
	
	MinFireLoopSustainTime = 0.11
}
class FireDEP38_ extends InstantFire;



var float LastFireTime;
var float ClickTime;

var Name EmptyReload;

event ModeDoFire()
{
	LastFireTime = Level.TimeSeconds;
	Super.ModeDoFire();
}

event ModeHoldFire()
{
}

defaultproperties
{
    AmmoClass=class'AmmoDEP38_'
    AmmoPerFire=1
    DamageType=class'DamageDEP38_'
    //DamageMin=35
    //DamageMax=40
	Damage_Human_SP=(min=30,max=40)
	Damage_Human_MP=(min=35,max=35)
	Damage_AI_SP=(min=30,max=40)
	Damage_AI_MP=(min=35,max=35)
    bPawnRapidFireAnim=true
	Load=1

    FireAnim=fire
    FireEndAnim=None
    FireLoopAnim=None
    FireAnimRate=1.0
	ReloadAnim=reload
	ReloadAnimRate=1.0

    FlashEmitterClass=class'gbxEffects.MuzzleFlashColt1911_'

	// PSV: 3/22/2004 Using cues now...
	FireSoundName="W_P38D.FIRE"
	StereoFireSoundName="W_P38D.FIRE_ST"

    FireForce="PistolFire"   // jdf

	PreFireTime=0.0
    //FireRate=0.35
    FireRateSP=0.3
	FireRateMP=0.3
    AIFireRateSP=0.3
	AIFireRateMP=0.3
    bModeExclusive=true

	SuppressionMultiplierSP=0.5
	SuppressionMultiplierMP=2.0

    AimErrorMin_Human=900
	AimErrorMax_Human_Crouched=1000
	AimErrorMax_Human_Standing=1200
	AimErrorMax_Human_MovingSlow=1300
	AimErrorMax_Human_MovingFast=1600
	AimErrorMin_Human_Zoomed=350
	AimErrorMax_Human_Zoomed=800

	AimErrorMin_AI_MP=900
	AimErrorMax_AI_MP_Crouched=1000
	AimErrorMax_AI_MP_Standing=1200
	AimErrorMax_AI_MP_Moving=1600
	AimMultiplier_AI_MP_Sighted=0.8

	AimErrorMin_AI_SP=900
	AimErrorMax_AI_SP_Crouched=1000
	AimErrorMax_AI_SP_Standing=1200
	AimErrorMax_AI_SP_Moving=1600
	AimMultiplier_AI_SP_Sighted=0.8

    ShakeOffsetMag=(X=0.0,Y=0.0,Z=0.0)
    ShakeOffsetRate=(X=1000.0,Y=1000.0,Z=1000.0)
    ShakeOffsetTime=2
    ShakeRotMag=(X=50.0,Y=50.0,Z=50.0)
    ShakeRotRate=(X=10000.0,Y=10000.0,Z=10000.0)
    ShakeRotTime=2

	TweenTime = 0.01

	bWaitForRelease=true
	EmptyReload = Reload_Empty

	// This really sucks, but constants are supported here, so I'm just setting this to the value of the constant.
	FireType=1

	ShotCountMod=0
}
class FireDEPak36_ extends InstantFire;

var float ShellVelocity;

simulated function PlayFiring()
{
	Super.PlayFiring();

	// DANGER: Super's version of this function MIGHT play the animation if you're in first-person mode.
	Weapon.PlayAnim(FireAnim, FireAnimRate, TweenTime);

	WeapDEPak36_( Weapon ).PlayFiring();

	Spawn( FlashEmitterClass,,, Weapon.GetMuzzleLocationWorld(), TurretWeapon( Weapon ).GetFireRotation() );
}

function DoFireEffect()
{
	local ProjectileDEPak36_ aShell;
	local Rotator Aim;
	local Vector StartTrace;
	local int bSkipDoTrace;

	StartTrace = Weapon.GetMuzzleLocationWorld();

	if (gbxPawn(Instigator) != None)
		gbxPawn(Instigator).LastAimRotator = Aim;
		
	Aim = AdjustAimNew( StartTrace, bSkipDoTrace );

	aShell = Spawn( class'ProjectileDEPak36_',,, StartTrace, Aim );
	aShell.LaunchingWeapon = Weapon;
}

simulated function PlayReloading()
{
	/*
	if ( Weapon.IsReloading() )
		return;

	WeapDEPak36_( Weapon ).PlayReloading();

    // TBD: reloading sound here

	Weapon.ClientState = WS_Reloading;
	bIsReloading = true;

	Weapon.IncrementFlashCount(WEAP_StateReload);	
	*/
}

defaultproperties
{
	AmmoClass=class'AmmoDEFlakvierling'
	FlashEmitterClass=class'MuzzleFlashPak36_'

	FireAnim=Fire
	FireAnimRate=1.0
	AmmoPerFire=1

	AIFireRateSP=0.4
	AIFireRateMP=0.4

	ShellVelocity=1000.0

	FireSoundName="W_ANTITANKGUN.Fire"
	StereoFireSoundName="W_ANTITANKGUN.Fire_ST"
}
//=============================================================================
// Main AI controller for the Pak 88 Loader.
//
// Author: Nick Chinnici 
// Gearbox Software.
//=============================================================================

class FireDEPAK88_ extends InstantFire;

var class<gbxMuzzleFlash> MuzzleFlashClass;

var float	ShellVelocity;

//---------------------------------------------------------
//	PostNetBeginPlay
//---------------------------------------------------------
function PostNetBeginPlay()
{

	Super.PostNetBeginPlay();
}

function PlayFiring()
{
	if (!WeapDEPAK88_(Weapon).OKToFire())
		return;  //NAC: it is not ok to fire, we have not given the player time to get back on his feet
	Super.PlayFiring();

	// DANGER: Super's version of this function MIGHT play the animation if you're in first-person mode.
	Weapon.PlayAnim(FireAnim, FireAnimRate, TweenTime);

	WeapDEPAK88_( Weapon ).PlayFiring();
	Spawn( MuzzleFlashClass,,, Weapon.GetBoneCoords('Barrel_01').origin, TurretWeapon( Weapon ).GetFireRotation() );
	WeapDEPAK88_( Weapon ).PlayReloading();
}

function StopFiring()
{	
	Super.StopFiring();
}


function DoFireEffect()
{
	local ProjectileDEPAK88_ aShell;
	local Rotator Aim;
	local Vector StartTrace;
	local int bSkipDoTrace;

	if (!WeapDEPAK88_(Weapon).OKToFire())
		return;  //NAC: it is not ok to fire, we have not given the player time to get back on his feet

	StartTrace = Weapon.GetBoneCoords('Barrel_01').origin;

	if (gbxPawn(Instigator) != None)
		gbxPawn(Instigator).LastAimRotator = Aim;
		
	Aim = AdjustAimNew( StartTrace, bSkipDoTrace );
	spawn(class'Pak88SmokeAndDust', None,, StartTrace, TurretWeapon( Weapon ).GetFireRotation());
	aShell = Spawn( class'ProjectileDEPAK88_',,, StartTrace, Aim );
	aShell.LaunchingWeapon = Weapon;
}


simulated function PlayReloading()
{
	if ( Weapon.IsReloading() )
		return;
	

	WeapDEPAK88_( Weapon ).PlayReloading();

    // TBD: reloading sound here

	Weapon.ClientState = WS_Reloading;
	bIsReloading = true;

	if (WeaponAttachment(Weapon.ThirdPersonActor) != None)
		Weapon.IncrementFlashCount(WeaponAttachment(Weapon.ThirdPersonActor).WEAP_StateReload);	
}


function float MaxRange()
{
	return 18000;
}

function DoTrace(Vector Start, Rotator Dir, optional out Vector End, optional out Vector EndDir)
{
}

defaultproperties
{
	AmmoClass=class'AmmoDEFlakvierling'
	MuzzleFlashClass=class'MuzzleFlashPak88_'
	
	FireAnim=Fire
	FireAnimRate=1.0
	AmmoPerFire=1

	AIFireRateSP=9.0
	AIFireRateMP=9.0

	TraceRange=18000

	FireSoundName="W_88GUN.FIRE"

	ShellVelocity = 2000;

}
class FireDEPanzerfaust extends WeaponFire;

var class<DamageType>	DamageType;
var float				TraceRange;
var float				Momentum;
var float				HitEffectProb;
var float				FireTraceBackStep; // Distance to subtract from the start location of a fire trace

// Burst-count min/max values to use when firing; categorized by suppression level (low, med., high).
var Range Burst_High;
//var Range Burst_Med;
var Range Burst_Low;
var Range Burst_Op;

var Range BurstLength_High;
//var Range BurstLength_Med;
var Range BurstLength_Low;

var float					m_flRandomBurstRange;
var ProjectileDEPanzerfaust	FiredRocket;

const AMMO_INVENTORY_SHOW_TIME = 3.0;

simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();
}

event ModeDoFire()
{
	Super.ModeDoFire();

	if ( Weapon.IsA('gbxWeapon') && gbxWeapon(Weapon).m_fZoomed)
	{
		bWaitForAnim = false;
	}
}

function PlayFiring()
{
	Super.PlayFiring();

	//SJP: Kick the view
	if ( Instigator.Weapon.Ammo[0] != None )
	{
		if( gbxAmmo(Instigator.Weapon.Ammo[0]) != None )
		{
			//gbxAmmo(Instigator.Weapon.Ammo[0]).ApplyKick();
			//gbxWeaponAttachment(gbxWeapon(Instigator.Weapon).ThirdPersonActor).EjectShell( gbxAmmo(Instigator.Weapon.Ammo[0]).AmmoShellClass );
		}

		if (Weapon.ClipAmt <= 0)
		{
			if (gbxWeapon(Weapon) != None)
			{
				gbxWeapon(Weapon).flAmmoFadeTime = AMMO_INVENTORY_SHOW_TIME;
				gbxWeapon(Weapon).flLastAmmoFadeTime = Level.TimeSeconds;
			}
		}

		gbxWeapon(Weapon).flLastFireTime = Level.TimeSeconds;
	}
	Weapon.AnimBlendToAlpha( 1, 0.0, 0.0 );	// Reset the breathing animation so it doesn't override the fire animation
	if (gbxWeapon(Weapon) != None)
	{
		gbxWeapon(Weapon).m_fResetBreathe = true;
	}
	
	gbxWeapon(Weapon).m_fPlayingFire = true;
}

function DoFireEffect()
{
    local Vector StartRocket;
    local Rotator Aim;
	local Vector HitLocation, HitNormal;
	local Actor HitActor;
	local float lookdist;

    Instigator.MakeNoise(1.0);

	if (!Level.Game.IsA('WargameMultiplayer'))
	{
		StartRocket = Weapon.GetMuzzleLocationWorld();				
	}
	else
	{
		if (Instigator.IsHumanControlled())
		{
			StartRocket = Instigator.Location + Instigator.EyePosition();
			
		}
		else
		{
			StartRocket = Weapon.GetMuzzleLocationWorld();
		}
	}	

	// Get the modified aim rotator based on the weapon aim error (as well as any other error values along the way).
	Aim = AdjustAimNew(StartRocket);

	if (gbxPawn(Instigator) != None)
		gbxPawn(Instigator).LastAimRotator = Aim;

	if (FiredRocket != None)
	{
		FiredRocket.Destroy();
	}
	
	FiredRocket = Spawn( class'ProjectileDEPanzerfaust', Instigator,, StartRocket, Aim );
	
	if ( FiredRocket != None && Instigator != None )
	{
		if(Instigator.IsHumanControlled() )
		{
			// Hack for bug 17784.  If you shoot the panzerfaust straight down into ground
			// it goes through it because of the safe launch dist.
			if (Vector(Aim).Z < -0.6)
				FiredRocket.SafeLaunchDist = 10.0;		
		
			// Use safety launch to make sure the rocket spawns and travels effectively.  However, if the player is actually aiming at a point
			// Closer than the safety launch distance, bring that distance down so the rocket will blow up in his face.
			HitActor = Trace( HitLocation, HitNormal, StartRocket + ( Vector( Aim ) * ( FiredRocket.SafeLaunchDist + 26.0 ) ), StartRocket - ( Vector( Aim ) * 26.0 ), true );

			lookdist = VSize( StartRocket - HitLocation ) - 26.0;

			if( HitLocation == vect(0,0,0) || lookdist > FiredRocket.SafeLaunchDist )
			{
				FiredRocket.UseSafetyLaunch();
			}
			else
			{
				FiredRocket.SetCollision( true, false, false );
				FiredRocket.bCollideWorld = true;
				FiredRocket.HitWall( HitLocation, HitNormal, HitActor );
			}
		}
		else
		{
			FiredRocket.UseSafetyLaunch();		// Ensures the NPC will not shoot a shell into the wall in front of him.
		}
	}

	if ((FiredRocket != None) && Weapon.IsA('gbxWeapon'))
	{
		FiredRocket.m_aGuideTarget = gbxWeapon(Weapon).m_aGuideTarget;
	}

	ClientDoFireEffect();
}

simulated function ClientDoFireEffect()
{
	if ( Instigator.IsHumanControlled() && Instigator.IsA( 'gbxPawn' ) )
		Instigator.Controller.JogFatigue( gbxPawn( Instigator ).FatigueJog_PlayerFiredShot );	
}

simulated function PlayReloading()
{	
	return;
	// -BB From what I can tell, the panzerfaust never really reloads because you can only have one at a time.  
	//  So when the system calls the below code it would make the weapon reload/shell toss behave erradically.
	/*
	local gbxPlayerController gbxPC;

	if ( Weapon.ClipAmt >= Weapon.AmmoClipSize )
	{
		gbxWeapon(Weapon).flAmmoFadeTime = AMMO_INVENTORY_SHOW_TIME;  //NAC: added this so that anytime the player presses the reload key, it shows the number of clips available.
		return;
	}

	// SJP - Throw down shell casing if it exists
	if( WeapDEPanzerfaust(Weapon) != None )
	{
		WeapDEPanzerfaust(Weapon).ThrowCasing();
	}

	if (Weapon.ClipAmt >= Weapon.AmmoClipSize)
		return;

	if (Instigator.IsA('Mind') && Instigator.IsMoving() && Instigator.bIsCrouched)
		return;
		
	gbxWeapon(Weapon).m_fAIWeaponWaitingToFire = false;
	gbxWeapon(Weapon).flAmmoFadeTime = AMMO_INVENTORY_SHOW_TIME;
	gbxWeapon(Weapon).flLastAmmoFadeTime = Level.TimeSeconds;

	gbxPC = gbxPlayerController(Instigator.Controller);

	if( gbxWeapon(Weapon).m_fZoomed && gbxPC != None )
	{
		gbxPC.PendingDelayedAction = ReloadAfterZoomOut;
		gbxWeapon(Weapon).ForceUnzoom();
		//gbxPC.ChangeView(0);
	}
	else
	{
		Super.PlayReloading();
	}
	*/
}

function FlashMuzzleFlash()
{
	local gbxMuzzleFlash MuzFlash;

	MuzFlash = gbxMuzzleFlash(GetMuzzleFlash());
	MuzFlash.SetLocation(Weapon.Location);
	MuzFlash.Flash();
}

// GEARBOX: SJP - Look at RenderOverlays in gbxWeapon
// For first-person muzzle flashes only
function DrawMuzzleFlash(Canvas Canvas)
{
}

simulated function bool ReadyToFire()
{
	return AllowFire();
}

simulated function bool AllowFire()
{
	if( Super.AllowFire() )
	{
		if (Pawn(Weapon.Owner) != None)
		{
			if (Pawn(Weapon.Owner).bIsSprinting)
			{
				Pawn(Weapon.Owner).SetSprinting( false );
			}

			if (Weapon.IsA('gbxWeapon') && Pawn(Weapon.Owner).Controller.bIsHumanPlayer)
			{
				if (gbxWeapon(Weapon).bAimingAtFriendly)
				{
					PlayDryFire();
				}
				return !(gbxWeapon(Weapon).bAimingAtFriendly);
			}
		}
		
		return true;
	}

	return false;
}


function Rotator GetLastAimRotator()
{
	if (gbxPawn(Instigator) != None)
		return gbxPawn(Instigator).LastAimRotator;
	return Rot(0,0,0);
}

function GetBestBurstCount( ESuppressionLevel SuppressionLevel, out int MinShots, out int MaxShots )
{
	MinShots = 1;
	MaxShots = 1;
}

function GetOpBurstCount( out int MinShots, out int MaxShots )
{
	MinShots = 1;
	MaxShots = 1;
}

simulated function Tick(float DeltaTime)
{
	Super.Tick(DeltaTime);

	if (Weapon == None)
		return;

//	if (!Weapon.bDelayReloading && (Weapon.Ammo[0].AmmoAmount > 0) && (Weapon.ClipAmt <= 0) && (Weapon.ClientState != WS_Reloading) && !gbxWeapon(Weapon).m_fPlayingFire)
//	{
//		PlayReloading();
//	}
}

defaultproperties
{
    AmmoClass=class'AmmoDEPanzerfaust'
    AmmoPerFire=1
    DamageType=class'DamageDEPanzerfaust'
    bPawnRapidFireAnim=true
	Load=1

    FireAnim=fire
    FireEndAnim=None
    FireLoopAnim=None
    FireAnimRate=1.0
	ReloadAnim=Deploy
	ReloadAnimRate=1.0

    FlashEmitterClass=class'gbxEffects.MuzzleFlashPanzerfaustView'
	//FlashEmitterClass=class'gbxEffects.MuzzleFlashBazookaView'

	FireSoundName="W_PANZERFAUST.FIRE"
	StereoFireSoundName="W_PANZERFAUST.FIRE_ST"
    FireForce="AssaultRifleFire"   // jdf

	PreFireTime=0.0
	FireRateSP=3.0
	FireRateMP=3.0
	AIFireRateSP=3.0
	AIFireRateMP=3.0
    bModeExclusive=true

    ShakeOffsetMag=(X=0.0,Y=0.0,Z=0.0)
    ShakeOffsetRate=(X=1000.0,Y=1000.0,Z=1000.0)
    ShakeOffsetTime=2
    ShakeRotMag=(X=10.0,Y=10.0,Z=10.0)
    ShakeRotRate=(X=10000.0,Y=10000.0,Z=10000.0)
    ShakeRotTime=2

    TweenTime = 0.0

	bWaitForRelease=true

	// This really sucks, but constants are supported here, so I'm just setting this to the value of the constant.
	FireType=1
}
class FireDESTG44_ extends FireSubMachineGun;

defaultproperties
{
    AmmoClass=class'AmmoDESTG44_'
    AmmoPerFire=1
    DamageType=class'DamageDESTG44_'
    //DamageMin=50
    //DamageMax=60
	Damage_Human_SP=(min=40,max=50)
	Damage_Human_MP=(min=35,max=35)
	Damage_AI_SP=(min=30,max=40)
	Damage_AI_MP=(min=35,max=35)
    bPawnRapidFireAnim=true
	Load=1

    FireAnim=fire
    FireEndAnim=None
    FireLoopAnim=None
    FireAnimRate=1.0
	ReloadAnim=reload
	ReloadAnimRate=1.0

    FlashEmitterClass=class'gbxEffects.MuzzleFlashBar'

	FireSoundName="W_STG44D.FIRE"

	// Loops
	FireLoopSoundName="W_STG44D.FIRELOOP"
	StereoFireLoopSoundName="W_STG44D.FIRELOOP_ST"
	FireEndLoopSoundName="W_STG44D.FIRELOOPEND"
	StereoFireEndLoopSoundName="W_STG44D.FIRELOOPEND_ST"

    //FireSound=Sound'WeaponSounds.AssaultRifle.AssaultRifleFire'
    FireForce="AssaultRifleFire"   // jdf

	PreFireTime=0.0
    FireRateSP=0.12 // SJP: 0.12 = 500 Rnds/min (accurate)
	FireRateMP=0.12 // SJP: 0.12 = 500 Rnds/min (accurate)
    AIFireRateSP=0.12
	AIFireRateMP=0.12
    bModeExclusive=true

	SuppressionMultiplierSP=0.8
	SuppressionMultiplierMP=1.2

    AimErrorMin_Human=550
	AimErrorMax_Human_Crouched=700	
	AimErrorMax_Human_Standing=900
	AimErrorMax_Human_MovingSlow=1500
	AimErrorMax_Human_MovingFast=1800
	AimErrorMin_Human_Zoomed=250
	AimErrorMax_Human_Zoomed=1700
	AimErrorMin_Human_FirstShot=50
	AimErrorMax_Human_FirstShot=150

	AimErrorMin_AI_MP=550
	AimErrorMax_AI_MP_Crouched=700
	AimErrorMax_AI_MP_Standing=900
	AimErrorMax_AI_MP_Moving=1800
	AimMultiplier_AI_MP_Sighted=1.0

	AimErrorMin_AI_SP=550
	AimErrorMax_AI_SP_Crouched=700
	AimErrorMax_AI_SP_Standing=900
	AimErrorMax_AI_SP_Moving=1800
	AimMultiplier_AI_SP_Sighted=1.0

    ShakeOffsetMag=(X=0.0,Y=0.0,Z=0.0)
    ShakeOffsetRate=(X=1000.0,Y=1000.0,Z=1000.0)
    ShakeOffsetTime=2
    ShakeRotMag=(X=50.0,Y=50.0,Z=50.0)
    ShakeRotRate=(X=10000.0,Y=10000.0,Z=10000.0)
    ShakeRotTime=2

    TweenTime = 0.01

	bWaitForRelease=false

	// Burst count levels.
	Burst_High_SP=(Min=2,Max=3)
	Burst_High_MP=(Min=10,Max=20)
	Burst_Low_SP=(Min=4,Max=6)
	Burst_Low_MP=(Min=10,Max=20)
	Burst_Op_SP=(Min=4,Max=6)
	Burst_Op_MP=(Min=10,Max=30)

	ShotCountMod=3

	m_flRandomBurstRange=0.0

	// This really sucks, but constants are supported here, so I'm just setting this to the value of the constant.
	FireType=1
	bAccurateFirstShot=true
	
	MinFireLoopSustainTime = 0.09
}
//=============================================================================
// M10 Tank main gun fire mode class.
//=============================================================================
class FireM10_MainGun extends InstantFire
	config(User);


//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
    AmmoClass=class'AmmoUSM10_Main'
    AmmoPerFire=1
//    DamageType=class'DamageUSM10_Main'
//	DamageMin=90
//	DamageMax=120
//    bPawnRapidFireAnim=true
//	Load=1

    //FireAnim=fire
	FireAnim=None
    FireEndAnim=None
    FireLoopAnim=None
	ReloadAnim=None

	FlashEmitterClass=None

    FireForce="AssaultRifleFire"   // jdf

	PreFireTime=0.0
	FireRateSP=0.07
	FireRateMP=0.07
    bModeExclusive=true

    //AimErrorAI_SP=(Min=50,Max=50)
	//AimErrorAI_MP=(Min=50,Max=50)
    //AimErrorHuman_SP=50
	//AimErrorHuman_MP=50

	TraceRange=15000

	bWaitForRelease=false

	ShakeOffsetMag=(X=1.0,Y=1.0,Z=1.0)
    ShakeOffsetRate=(X=1000.0,Y=1000.0,Z=1000.0)
    ShakeOffsetTime=2
    ShakeRotMag=(X=50.0,Y=50.0,Z=50.0)
    ShakeRotRate=(X=10000.0,Y=10000.0,Z=10000.0)
    ShakeRotTime=2

	// This really sucks, but constants are supported here, so I'm just setting this to the value of the constant.
	FireType=1
}
class FireMelee extends WeaponFire;



var float LastFireTime;
var float MeleeRange;

event ModeDoFire()
{
	local float AppliedFireRate;

	if (!AllowFire())
		return;

	if( Instigator.IsFirstPerson() )
	{
		if( PlayerController(Instigator.Controller).IsZoomed() )
		{
			gbxPlayerController( Instigator.Controller ).ChangeView(0);
			if (gbxPlayerController( Instigator.Controller ).PendingDelayedAction == MeleeAfterZoomOut)
			{
				gbxPlayerController( Instigator.Controller ).PendingDelayedAction = NoAction;
				gbxPlayerController( Instigator.Controller ).bMeleeFire = 0;
			}
			else
			{
				return;
			}
		}

		PlayFiring();
	}

	if ( Level.NetMode == NM_Standalone )
		AppliedFireRate = FireRateSP;
	else
		AppliedFireRate = FireRateMP;

	if (WeaponAttachment(Weapon.ThirdPersonActor) != None)
		Weapon.IncrementFlashCount(WeaponAttachment(Weapon.ThirdPersonActor).WEAP_StateMelee);
	gbxWeapon(Weapon).m_fCanZoom = false;
	gbxWeapon(Weapon).m_fPlayingMelee = true;
	LastFireTime = Level.TimeSeconds;
	NextFireTime = Level.TimeSeconds + AppliedFireRate*Weapon.FireRateAtten;

    if (Weapon.Role == ROLE_Authority)
    {
        DoFireEffect();

        if (Weapon == None || Instigator == None)
		{
            return;
		}
    }

	// This is a bit of a hack, but we need to make sure that the player doesn't try to fire their weapon while this
	// grenade throw is going on.
	if (Weapon.FireMode[0] != None)
		Weapon.FireMode[0].NextFireTime = Level.TimeSeconds + AppliedFireRate*Weapon.FireRateAtten;
	if (Weapon.FireMode[1] != None)
		Weapon.FireMode[1].NextFireTime = Level.TimeSeconds + AppliedFireRate*Weapon.FireRateAtten;
}

simulated function PlayFiring()
{
	Weapon.m_flDrawOffset=0.0f; //-BB
	Super.PlayFiring();
	Weapon.ClientState = WS_Melee;
	Weapon.PlayMeleeSwooshSound( Instigator );
}

function DoFireEffect()
{
	/*	This code is not needed.  Damage from melee is done in gbxWeapon.MeleeFire() for players and in WargamePawn.CheckMeleeSuccess() for AI pawns.
	//local Actor	anObject;
	local gbxPawn aPawn;
	local vector HitLocation, HitNormal, StartTrace, SmackVelocity, X,Y,Z;

	Instigator.GetAxes(Instigator.GetViewRotation(), X, Y, Z);
	StartTrace = Instigator.Location - (Instigator.EyeHeight * vect(0,0,1));

	foreach VisibleCollidingActors(class'gbxPawn', aPawn, MeleeRange )
	{
		if ( aPawn == Instigator || aPawn.SameTeamAs( Instigator ) )
			continue;
		
		SmackVelocity = aPawn.Location - Instigator.Location;
		SmackVelocity.Z += 25.0;
		if ( !aPawn.bIsManningTurret )
		{
			aPawn.AddVelocity( 300.0 * Normal( SmackVelocity ) );
		}
		aPawn.ClientKickView( Vect(4000.0, 0, -1000.0 ), 1.0, 0.0 );
		aPawn.TakeDamage(80, Instigator, HitLocation, 30000.000000*HitNormal, gbxWeapon(Weapon).MyMeleeDamageType);
		break;
	}
	*/

}

event ModeHoldFire()
{
}

simulated function bool ReadyToFire()
{
	return AllowFire();
}

simulated function bool AllowFire()
{
	if ( Weapon.ClientState != WS_ReadyToFire )
		return false;
		
	if (Weapon.IsA('gbxWeapon') && (Pawn(Weapon.Owner) != None) && Pawn(Weapon.Owner).Controller.bIsHumanPlayer)
	{
		return !(gbxWeapon(Weapon).bAimingAtFriendly);
	}
	
	return true;
}

defaultproperties
{
    ProjPerFire=0
	Load=0

    FireAnim=Melee
    FireEndAnim=None
    FireLoopAnim=None
    FireAnimRate=1.0
	ReloadAnim=None
	ReloadAnimRate=1.0

	PreFireTime=0.0
    FireRateSP=0.75
	FireRateMP=0.75
    AIFireRateSP=2.2
	AIFireRateMP=2.2
    bModeExclusive=true

    BotRefireRate=3.82
    //AimError=400

    ShakeOffsetMag=(X=1.0,Y=1.0,Z=1.0)
    ShakeOffsetRate=(X=1000.0,Y=1000.0,Z=1000.0)
    ShakeOffsetTime=2
    ShakeRotMag=(X=50.0,Y=50.0,Z=50.0)
    ShakeRotRate=(X=10000.0,Y=10000.0,Z=10000.0)
    ShakeRotTime=2

	bWaitForRelease=false

//	FireSoundName="W_Grenade.Sounds.Use"

	// This really sucks, but constants are supported here, so I'm just setting this to the value of the constant.
	FireType=2

	MeleeRange=200.0
}
//=============================================================================
// Stuart Tank bow machine gun fire mode class.
//=============================================================================
class FirePanzerBowGun extends InstantFire
	config(User);


//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
    AmmoClass=class'AmmoDEMG42_'
    AmmoPerFire=1
    DamageType=class'DamageDEMG42_'
	//DamageMin=90
	//DamageMax=120
	Damage_Human_SP=(min=90,max=120)
	Damage_Human_MP=(min=90,max=120)
	Damage_AI_SP=(min=90,max=120)
	Damage_AI_MP=(min=90,max=120)
    bPawnRapidFireAnim=true
	Load=1

    //FireAnim=fire
	FireAnim=None
    FireEndAnim=None
    FireLoopAnim=None
	ReloadAnim=None

	FlashEmitterClass=class'gbxEffects.MuzzleFlashStuartTankBowGun'

    FireForce="AssaultRifleFire"   // jdf

	PreFireTime=0.0
	FireRateSP=0.07
	FireRateMP=0.07
    bModeExclusive=true

	//AimErrorAI_SP=(Min=50,Max=50) // Singleplayer: US weapons do not change with difficulty settings.
	//AimErrorAI_MP=(Min=50,Max=50)
    //AimErrorHuman_SP=50
	//AimErrorHuman_MP=50

	TraceRange=15000

	bWaitForRelease=false

	ShakeOffsetMag=(X=1.0,Y=1.0,Z=1.0)
    ShakeOffsetRate=(X=1000.0,Y=1000.0,Z=1000.0)
    ShakeOffsetTime=2
    ShakeRotMag=(X=50.0,Y=50.0,Z=50.0)
    ShakeRotRate=(X=10000.0,Y=10000.0,Z=10000.0)
    ShakeRotTime=2

	// This really sucks, but constants are supported here, so I'm just setting this to the value of the constant.
	FireType=1
}
//=============================================================================
// Stuart Tank coax machine gun fire mode class.
//=============================================================================
class FirePanzerMainGun extends InstantFire
	config(User);


//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
    AmmoClass=class'AmmoDEPanzerMain'
    AmmoPerFire=1
//    DamageType=class'DamageUSStuartMain'
//	DamageMin=90
//	DamageMax=120
//    bPawnRapidFireAnim=true
//	Load=1

    //FireAnim=fire
	FireAnim=None
    FireEndAnim=None
    FireLoopAnim=None
	ReloadAnim=None

	FlashEmitterClass=None

    FireForce="AssaultRifleFire"   // jdf

	PreFireTime=0.0
	FireRateSP=0.07
	FireRateMP=0.07
    bModeExclusive=true

    //AimErrorAI_SP=(Min=50,Max=50)
	//AimErrorAI_MP=(Min=50,Max=50)
    //AimErrorHuman_SP=50
	//AimErrorHuman_MP=50

	TraceRange=15000

	bWaitForRelease=false

	ShakeOffsetMag=(X=1.0,Y=1.0,Z=1.0)
    ShakeOffsetRate=(X=1000.0,Y=1000.0,Z=1000.0)
    ShakeOffsetTime=2
    ShakeRotMag=(X=50.0,Y=50.0,Z=50.0)
    ShakeRotRate=(X=10000.0,Y=10000.0,Z=10000.0)
    ShakeRotTime=2

	// This really sucks, but constants are supported here, so I'm just setting this to the value of the constant.
	FireType=1
}
class FireSecondaryItem extends ProjectileFire;



var float LastFireTime;
var float ClickTime;

const SECONDARY_INVENTORY_SHOW_TIME = 6.0;


event ModeDoFire()
{
	local float AppliedFireRate;

	if (!AllowFire())
		return;

	if (Level.NetMode != NM_Client)
	{
		gbxUsableItem( gbxPawn(Instigator).SecondaryWeapon ).Prepare();
	}

	if( Instigator.IsFirstPerson() )
	{
		if( PlayerController(Instigator.Controller).IsZoomed() )
		{		
			gbxPlayerController( Instigator.Controller ).ChangeView(0);
			// GBX:PAD: I'm throwing this in here because the animation of throwing the grenade will interrupt the
			// zoom out animation, ths preventing the animend from resetting this value.
			Weapon.m_fZoomed = false;
		}

		FireAnim = gbxUsableItem( gbxPawn(Instigator).SecondaryWeapon ).GetUseAnimation();
		PlayFiring();
	}

	if ( Level.NetMode == NM_Standalone )
		AppliedFireRate = FireRateSP;
	else
		AppliedFireRate = FireRateMP;

	if (WeaponAttachment(Weapon.ThirdPersonActor) != None)
		Weapon.IncrementFlashCount(WeaponAttachment(Weapon.ThirdPersonActor).WEAP_StateThrow);
	gbxWeapon(Weapon).m_fCanZoom = false;
	LastFireTime = Level.TimeSeconds;
	NextFireTime = Level.TimeSeconds + AppliedFireRate*Weapon.FireRateAtten;

	// Set Hud fade variables for the grenades
	gbxPawn(Instigator).flSecondaryUIFadeTime = SECONDARY_INVENTORY_SHOW_TIME;	
	gbxPawn(Instigator).flSecondaryUILastFadeTime = Level.TimeSeconds;

	// This is a bit of a hack, but we need to make sure that the player doesn't try to fire their weapon while this
	// grenade throw is going on.
	if (Weapon.FireMode[0] != None)
		Weapon.FireMode[0].NextFireTime = Level.TimeSeconds + AppliedFireRate*Weapon.FireRateAtten;
	if (Weapon.FireMode[2] != None)
		Weapon.FireMode[2].NextFireTime = Level.TimeSeconds + AppliedFireRate*Weapon.FireRateAtten;

	if (Level.NetMode != NM_Client)
	{
		if( gbxPawn(Instigator).bUnloaded )	// RSC: added for infinite ammo cheat
			return; 

		if (gbxUsableItem(gbxPawn(Instigator).SecondaryWeapon).bCanHaveMultipleCopies) {
			gbxUsableItem(gbxPawn(Instigator).SecondaryWeapon).NumCopies -= 1;
		}
	}
}

simulated function PlayFiring()
{
	Super.PlayFiring();

//    if( gbxUsableItem(gbxPawn(Instigator).SecondaryWeapon).DummyGrenade == None )
//        gbxUsableItem(gbxPawn(Instigator).SecondaryWeapon).DummyGrenade = Spawn(gbxUsableItem(gbxPawn(Instigator).SecondaryWeapon).DummyGrenadeType);
    Weapon.AttachToBone(gbxUsableItem(gbxPawn(Instigator).SecondaryWeapon).DummyGrenade, Instigator.Controller.Pawn.GetWeaponBoneFor( gbxPawn(Instigator).SecondaryWeapon ));
	
	Weapon.ClientState = WS_ThrowGrenade;
}

event ModeHoldFire()
{
}

simulated function bool ReadyToFire()
{
	return AllowFire();
}

simulated function bool AllowFire()
{
	if ( gbxPawn(Instigator).SecondaryWeapon == None )
		return false;
	if ( Weapon.ClientState != WS_ReadyToFire )
		return false;
	if (gbxWeapon(gbxPawn(Instigator).Weapon).m_fPlayingFire )
		return false;	
	if (gbxUsableItem(gbxPawn(Instigator).SecondaryWeapon).bCanHaveMultipleCopies)
		if (gbxUsableItem(gbxPawn(Instigator).SecondaryWeapon).NumCopies <= 0)
			return false;	
	return true;
}

simulated function FireProjectile()
{
	if ((gbxPawn(Instigator) != None) && (gbxPawn(Instigator).SecondaryWeapon != None))
	{
		gbxUsableItem( gbxPawn(Instigator).SecondaryWeapon ).Use(1.0);
	}
	gbxWeapon(Weapon).m_fCanZoom = true;
}

defaultproperties
{
    ProjPerFire=1
	Load=1

    FireAnim=None
    FireEndAnim=None
    FireLoopAnim=None
    FireAnimRate=1.0
	ReloadAnim=reload
	ReloadAnimRate=1.0

	Spread=0.020
    SpreadStyle=SS_Random
    PreFireTime=0.0
    FireRateSP=2.2
	FireRateMP=2.2
    AIFireRateSP=2.2
	AIFireRateMP=2.2
    bModeExclusive=true

    BotRefireRate=3.82
    //AimError=400

    ShakeOffsetMag=(X=1.0,Y=1.0,Z=1.0)
    ShakeOffsetRate=(X=1000.0,Y=1000.0,Z=1000.0)
    ShakeOffsetTime=2
    ShakeRotMag=(X=50.0,Y=50.0,Z=50.0)
    ShakeRotRate=(X=10000.0,Y=10000.0,Z=10000.0)
    ShakeRotTime=2

	bWaitForRelease=true

//	FireSoundName="W_Grenade.Sounds.Use"

	// This really sucks, but constants are supported here, so I'm just setting this to the value of the constant.
	FireType=4
}
//=============================================================================
// Sherman Tank bow machine gun fire mode class.
//=============================================================================
class FireShermanBowGun extends InstantFire
	config(User);


//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
    AmmoClass=class'AmmoDEMG42_'
    AmmoPerFire=1
    DamageType=class'DamageDEMG42_'
	//DamageMin=90
	//DamageMax=120
	Damage_Human_SP=(min=90,max=120)
	Damage_Human_MP=(min=90,max=120)
	Damage_AI_SP=(min=90,max=120)
	Damage_AI_MP=(min=90,max=120)
    bPawnRapidFireAnim=true
	Load=1

    //FireAnim=fire
	FireAnim=None
    FireEndAnim=None
    FireLoopAnim=None
	ReloadAnim=None

	FlashEmitterClass=class'gbxEffects.MuzzleFlashShermanTankBowGun'

    FireForce="AssaultRifleFire"   // jdf

	PreFireTime=0.0
	FireRateSP=0.07
	FireRateMP=0.07
    AIFireRateSP=0.07
	AIFireRateMP=0.07
    bModeExclusive=true

    //AimErrorMax=200
	//AimErrorAI_SP=(Min=50,Max=50) // Singleplayer: US weapons do not change with difficulty settings.
	//AimErrorAI_MP=(Min=50,Max=50)
    //AimErrorHuman_SP=50
	//AimErrorHuman_MP=50

	TraceRange=15000

	bWaitForRelease=false

	ShakeOffsetMag=(X=1.0,Y=1.0,Z=1.0)
    ShakeOffsetRate=(X=1000.0,Y=1000.0,Z=1000.0)
    ShakeOffsetTime=2
    ShakeRotMag=(X=50.0,Y=50.0,Z=50.0)
    ShakeRotRate=(X=10000.0,Y=10000.0,Z=10000.0)
    ShakeRotTime=2

	// This really sucks, but constants are supported here, so I'm just setting this to the value of the constant.
	FireType=1
}
//=============================================================================
// Sherman Tank coax machine gun fire mode class.
//=============================================================================
class FireShermanCoaxGun extends InstantFire
	config(User);


//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
    AmmoClass=class'AmmoDEMG42_'
    AmmoPerFire=1
    DamageType=class'DamageDEMG42_'
	//DamageMin=90
	//DamageMax=120
	Damage_Human_SP=(min=90,max=120)
	Damage_Human_MP=(min=90,max=120)
	Damage_AI_SP=(min=90,max=120)
	Damage_AI_MP=(min=90,max=120)
    bPawnRapidFireAnim=true
	Load=1

    //FireAnim=fire
	FireAnim=None
    FireEndAnim=None
    FireLoopAnim=None
	ReloadAnim=None

	FlashEmitterClass=class'gbxEffects.MuzzleFlashShermanTankCoaxGun'

    FireForce="AssaultRifleFire"   // jdf

	PreFireTime=0.0
	FireRateSP=0.07
	FireRateMP=0.07
    AIFireRateSP=0.07
	AIFireRateMP=0.07
    bModeExclusive=true

    //AimErrorAI_SP=(Min=50,Max=50)
	//AimErrorAI_MP=(Min=50,Max=50)
    //AimErrorHuman_SP=50
	//AimErrorHuman_MP=50

	TraceRange=15000

	bWaitForRelease=false

	ShakeOffsetMag=(X=1.0,Y=1.0,Z=1.0)
    ShakeOffsetRate=(X=1000.0,Y=1000.0,Z=1000.0)
    ShakeOffsetTime=2
    ShakeRotMag=(X=50.0,Y=50.0,Z=50.0)
    ShakeRotRate=(X=10000.0,Y=10000.0,Z=10000.0)
    ShakeRotTime=2

	// This really sucks, but constants are supported here, so I'm just setting this to the value of the constant.
	FireType=1
}
//=============================================================================
// Sherman Tank main gun fire mode class.
//=============================================================================
class FireShermanMainGun extends InstantFire
	config(User);


//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
    AmmoClass=class'AmmoUSShermanMain'
    AmmoPerFire=1
//    DamageType=class'DamageUSShermanMain'
//	DamageMin=90
//	DamageMax=120
//    bPawnRapidFireAnim=true
//	Load=1

    //FireAnim=fire
	FireAnim=None
    FireEndAnim=None
    FireLoopAnim=None
	ReloadAnim=None

	FlashEmitterClass=None

    FireForce="AssaultRifleFire"   // jdf

	PreFireTime=0.0
	FireRateSP=0.07
	FireRateMP=0.07
    bModeExclusive=true

    //AimErrorAI_SP=(Min=50,Max=50)
	//AimErrorAI_MP=(Min=50,Max=50)
    //AimErrorHuman_SP=50
	//AimErrorHuman_MP=50

	TraceRange=15000

	bWaitForRelease=false

	ShakeOffsetMag=(X=1.0,Y=1.0,Z=1.0)
    ShakeOffsetRate=(X=1000.0,Y=1000.0,Z=1000.0)
    ShakeOffsetTime=2
    ShakeRotMag=(X=50.0,Y=50.0,Z=50.0)
    ShakeRotRate=(X=10000.0,Y=10000.0,Z=10000.0)
    ShakeRotTime=2

	// This really sucks, but constants are supported here, so I'm just setting this to the value of the constant.
	FireType=1
}
//=============================================================================
// Stuart Tank bow machine gun fire mode class.
//=============================================================================
class FireStuartBowGun extends InstantFire
	config(User);


//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
    AmmoClass=class'AmmoDEMG42_'
    AmmoPerFire=1
    DamageType=class'DamageDEMG42_'
	//DamageMin=90
	//DamageMax=120
	Damage_Human_SP=(min=90,max=120)
	Damage_Human_MP=(min=90,max=120)
	Damage_AI_SP=(min=90,max=120)
	Damage_AI_MP=(min=90,max=120)
    bPawnRapidFireAnim=true
	Load=1

    //FireAnim=fire
	FireAnim=None
    FireEndAnim=None
    FireLoopAnim=None
	ReloadAnim=None

	FlashEmitterClass=class'gbxEffects.MuzzleFlashStuartTankBowGun'

    FireForce="AssaultRifleFire"   // jdf

	PreFireTime=0.0
	FireRateSP=0.07
	FireRateMP=0.07
    AIFireRateSP=0.07
	AIFireRateMP=0.07
    bModeExclusive=true

	//AimErrorAI_SP=(Min=50,Max=50) // Singleplayer: US weapons do not change with difficulty settings.
	//AimErrorAI_MP=(Min=50,Max=50)
    //AimErrorHuman_SP=50
	//AimErrorHuman_MP=50

	TraceRange=15000

	bWaitForRelease=false

	ShakeOffsetMag=(X=1.0,Y=1.0,Z=1.0)
    ShakeOffsetRate=(X=1000.0,Y=1000.0,Z=1000.0)
    ShakeOffsetTime=2
    ShakeRotMag=(X=50.0,Y=50.0,Z=50.0)
    ShakeRotRate=(X=10000.0,Y=10000.0,Z=10000.0)
    ShakeRotTime=2

	// This really sucks, but constants are supported here, so I'm just setting this to the value of the constant.
	FireType=1
}
//=============================================================================
// Stuart Tank coax machine gun fire mode class.
//=============================================================================
class FireStuartCoaxGun extends InstantFire
	config(User);


//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
    AmmoClass=class'AmmoDEMG42_'
    AmmoPerFire=1
    DamageType=class'DamageDEMG42_'
	//DamageMin=90
	//DamageMax=120
	Damage_Human_SP=(min=90,max=120)
	Damage_Human_MP=(min=90,max=120)
	Damage_AI_SP=(min=90,max=120)
	Damage_AI_MP=(min=90,max=120)
    bPawnRapidFireAnim=true
	Load=1

    //FireAnim=fire
	FireAnim=None
    FireEndAnim=None
    FireLoopAnim=None
	ReloadAnim=None

	FlashEmitterClass=class'gbxEffects.MuzzleFlashStuartTankCoaxGun'

    FireForce="AssaultRifleFire"   // jdf

	PreFireTime=0.0
	FireRateSP=0.07
	FireRateMP=0.07
    AIFireRateSP=0.07
	AIFireRateMP=0.07
    bModeExclusive=true

    //AimErrorAI_SP=(Min=50,Max=50)
	//AimErrorAI_MP=(Min=50,Max=50)
    //AimErrorHuman_SP=50
	//AimErrorHuman_MP=50

	TraceRange=15000

	bWaitForRelease=false

	ShakeOffsetMag=(X=1.0,Y=1.0,Z=1.0)
    ShakeOffsetRate=(X=1000.0,Y=1000.0,Z=1000.0)
    ShakeOffsetTime=2
    ShakeRotMag=(X=50.0,Y=50.0,Z=50.0)
    ShakeRotRate=(X=10000.0,Y=10000.0,Z=10000.0)
    ShakeRotTime=2

	// This really sucks, but constants are supported here, so I'm just setting this to the value of the constant.
	FireType=1
}
//=============================================================================
// Stuart Tank main gun fire mode class.
//=============================================================================
class FireStuartMainGun extends InstantFire
	config(User);


//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
    AmmoClass=class'AmmoUSStuartMain'
    AmmoPerFire=1
//    DamageType=class'DamageUSStuartMain'
//	DamageMin=90
//	DamageMax=120
//    bPawnRapidFireAnim=true
//	Load=1

    //FireAnim=fire
	FireAnim=None
    FireEndAnim=None
    FireLoopAnim=None
	ReloadAnim=None

	FlashEmitterClass=None

    FireForce="AssaultRifleFire"   // jdf

	PreFireTime=0.0
	FireRateSP=0.07
	FireRateMP=0.07
    bModeExclusive=true

    TraceRange=15000

	bWaitForRelease=false

	ShakeOffsetMag=(X=1.0,Y=1.0,Z=1.0)
    ShakeOffsetRate=(X=1000.0,Y=1000.0,Z=1000.0)
    ShakeOffsetTime=2
    ShakeRotMag=(X=50.0,Y=50.0,Z=50.0)
    ShakeRotRate=(X=10000.0,Y=10000.0,Z=10000.0)
    ShakeRotTime=2

	// This really sucks, but constants are supported here, so I'm just setting this to the value of the constant.
	FireType=1
}
//=============================================================================
// Stuart Tank coax machine gun fire mode class.
//=============================================================================
class FireStugMainGun extends InstantFire
	config(User);


//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
    AmmoClass=class'AmmoDEStugMain'
    AmmoPerFire=1
//    DamageType=class'DamageUSStuartMain'
//	DamageMin=90
//	DamageMax=120
//    bPawnRapidFireAnim=true
//	Load=1

    //FireAnim=fire
	FireAnim=None
    FireEndAnim=None
    FireLoopAnim=None
	ReloadAnim=None

	FlashEmitterClass=None

    FireForce="AssaultRifleFire"   // jdf

	PreFireTime=0.0
	FireRateSP=0.07
	FireRateMP=0.07
    bModeExclusive=true

    //AimErrorAI_SP=(Min=50,Max=50)
	//AimErrorAI_MP=(Min=50,Max=50)
    //AimErrorHuman_SP=50
	//AimErrorHuman_MP=50

	TraceRange=15000

	bWaitForRelease=false

	ShakeOffsetMag=(X=1.0,Y=1.0,Z=1.0)
    ShakeOffsetRate=(X=1000.0,Y=1000.0,Z=1000.0)
    ShakeOffsetTime=2
    ShakeRotMag=(X=50.0,Y=50.0,Z=50.0)
    ShakeRotRate=(X=10000.0,Y=10000.0,Z=10000.0)
    ShakeRotTime=2

	// This really sucks, but constants are supported here, so I'm just setting this to the value of the constant.
	FireType=1
}
class FireSubMachineGun extends InstantFire;


// loops for things like machine guns
var String FireLoopSoundName;
var String StereoFireLoopSoundName;
var String FireEndLoopSoundName;
var String StereoFireEndLoopSoundName;

// sounds
var() Sound FireLoopSound;

// cues for the loops
var Cue FireLoopSoundCue;
var Cue StereoFireLoopSoundCue;
var Cue FireEndLoopSoundCue;
var Cue StereoFireEndLoopSoundCue;

var float MinFireLoopSustainTime;
var float FireLoopSustainEndTime;
var bool  bCheckForEndSustainLoop;
var float fAmbientSoundFadeOutTime;

// From FireUSThompson.uc
var bool	bWeaponFiring;
var float	LastFireTime;
var float	ClickTime;

simulated function PostBeginPlay()
{
	// Set the sound radius for the ThirdPersonActor based on cue max distance

	Super.PostBeginPlay();

	// Loops
	if ( FireLoopSoundName != "" )
	{
		FireLoopSoundCue = LoadSound( FireLoopSoundName );
		FireLoopSound = Sound( DynamicLoadObject( FireLoopSoundName, class'Sound' ) );
	}

	if ( StereoFireLoopSoundName != "" )
	{
		StereoFireLoopSoundCue = LoadSound( StereoFireLoopSoundName );
	}
		

	if ( FireEndLoopSoundName != "" )
		FireEndLoopSoundCue = LoadSound( FireEndLoopSoundName );
    
	if ( StereoFireEndLoopSoundName != "" )
		StereoFireEndLoopSoundCue = LoadSound( StereoFireEndLoopSoundName );

	if ( FireLoopSoundCue != None )
	{
		if ( Weapon.ThirdPersonActor != None )
		{
			Weapon.ThirdPersonActor.SoundRadius = FireLoopSoundCue.MaximumDistance;
		}
	}
	
	//log(self$ " FireSubMachineGun::PostBeginPlay() FireLoopSoundCue: "$FireLoopSoundCue$" FireLoopSound: " $FireLoopSound$ " Weapon: " $Weapon$ " Weapon.ThirdPersonActor: " $Weapon.ThirdPersonActor, 'DevSound');
}

// If the fire mode is being destroyed, stop any and all sounds immediatley
simulated function Destroyed()
{
    //log(self$ " FireSubMachineGun::Destroyed()", 'DevSound');
    
    Super.Destroyed();
        
    // Make sure any looping sounds stop
	FireLoopSustainEndTime = 0.0;
	bCheckForEndSustainLoop = false;

	//log( self$ " FireSubMachineGun::Destroyed() Weapon: "$Weapon, 'DevSound');
	
	if ( FireSoundHandle != 0 )
	{
		//log(self$ " FireSubMachineGun::Destroyed() calling StopSound()!", 'DevSound');   
		StopSound( FireSoundHandle );
	}

	//log(self$ " FireSubMachineGun::Destroyed() setting AmbientSound to None!", 'DevSound');   
	PlayAmbientSound(None);

    Super.Destroyed();
}

// Machine gun weapons define all their ModeDoFire() code in their class.
// This is why you won't see any calls to Super.ModeDoFire().
event ModeDoFire()
{
	local float AppliedFireRate;	
	local bool isAutomatic;
	local bool ammoOveride;
		
	LastFireTime = Level.TimeSeconds;

	if( !Instigator.Controller.AllowFire() || !AllowFire())
	{
		Weapon.InvalidateBurst();
		Weapon.StopFire(0);
		return;
	}

	// If client, check to see if are clip amount is correct.
	// Lag can cause this to be incorrectly set to low, and we think
	// we are out of ammo. Bit of a hack fix.
	ammoOveride = false;
	if (Weapon.Role < ROLE_Authority)
	{
		if (Weapon.ClipAmt < Weapon.localClipAmt - 1)
		{
			ammoOveride = true;
			Weapon.localClipAmt = Weapon.ClipAmt+1;
		}
		else
			Weapon.localClipAmt = Weapon.ClipAmt;
	}
	
	if ( !Weapon.HasAmmo() && !ammoOveride)
	{
		return;
	}
	else if (Weapon.NeedsToReload() && !Weapon.bDelayReloading && !ammoOveride)
	{
		if ( !Weapon.AlwaysAutoReload() && !(Instigator.Controller.ReloadAfterWeaponFire()))
		{
			PlayDryFire();
            return;
		}
		else if ((Weapon.ClientState != WS_Reloading) && (Instigator.Controller.IsA('gbxAIController') || Weapon.AlwaysAutoReload()))
		{
			PlayReloading();
		}
		else
		{
			if ( Weapon.IsAutomatic() && FireSoundHandle != 0 )
			{
				Weapon.ClientStopFire(0);
			}
		}
		return;
	}

    if (MaxHoldTime > 0.0)
        HoldTime = FMin(HoldTime, MaxHoldTime);

    // server
    if (Weapon.Role == ROLE_Authority)
    {
		Load = AmmoPerFire;

        Weapon.ConsumeAmmo(ThisModeNum, Load);

        DoFireEffect();

        if (Weapon == None || Instigator == None)
		{
            return;
		}
    }
	else
	{
		ClientDoFireEffect();
	}

	isAutomatic = Weapon.IsAutomatic();
	//IFiring = IsFiring();
	
    // Reset sustain flag	
    bCheckForEndSustainLoop = false;

    // client
    if (Instigator.IsLocallyControlled())
    {
		//log( self$":ModeDoFire() Instigator.IsLocallyControlled() == TRUE!", 'MP' );
		
		PlayFiring();
        
		if ( Instigator.Controller == Level.GetLocalPlayerController() )
		{
			//log( self$ " ModeDoFire() Instigator.Controller == Level.GetLocalPlayerController()!  About to play sound locally!", 'MP' );

			if ( FireSoundHandle == 0 )  
			{
				if ( StereoFireLoopSoundCue != None /*&& (Instigator.Controller == Level.GetLocalPlayerController())*/ )
				{
					FireSoundHandle = Weapon.PlayLocalSoundCue(StereoFireLoopSoundCue, SLOT_None, false);	
					FireLoopSustainEndTime = Level.TimeSeconds + MinFireLoopSustainTime;
					//log(self$ "ModeDoFire() Setting SustainEndTime: " $FireLoopSustainEndTime, 'DevSound');  
				}
				else
				{
					//log( self$ " StereoFireLoopSoundCue is NULL so MONO first person firing sound will play!  Baaaad!", 'DevSound' );				
					FireSoundHandle = Weapon.ThirdPersonActor.PlayOwnedSoundCue(FireLoopSoundCue, SLOT_None, TransientSoundVolume,,,,true);	
				}
			}
		}
    }

	Weapon.IncrementFlashCount(FireType);

	if (Instigator.Controller.IsA('AIController'))
	{
		if ( !Level.m_bMPStyleFatigue && Level.NetMode == NM_Standalone )
			AppliedFireRate = AIFireRateSP;
		else
			AppliedFireRate = AIFireRateMP;

		// set the next firing time. must be careful here so client and server do not get out of sync
		if (bFireOnRelease)
		{
			if (bIsFiring)
			{				
				NextFireTime += ( MaxHoldTime + AppliedFireRate*Weapon.FireRateAtten + GetRandomFireRateChange() );
			}
			else
			{
				NextFireTime = Level.TimeSeconds + AppliedFireRate*Weapon.FireRateAtten + GetRandomFireRateChange();
			}
		}
		else
		{
			NextFireTime += ( AppliedFireRate*Weapon.FireRateAtten + GetRandomFireRateChange() );
			NextFireTime = FMax(NextFireTime, Level.TimeSeconds);			
		}
	}
	else
	{
		if ( !Level.m_bMPStyleFatigue && Level.NetMode == NM_Standalone )
			AppliedFireRate = FireRateSP;
		else
			AppliedFireRate = FireRateMP;

		// set the next firing time. must be careful here so client and server do not get out of sync
		if (bFireOnRelease)
		{
			if (bIsFiring)
				NextFireTime += MaxHoldTime + AppliedFireRate*Weapon.FireRateAtten;
			else
				NextFireTime = Level.TimeSeconds + AppliedFireRate*Weapon.FireRateAtten;
		}
		else
		{
			NextFireTime += AppliedFireRate*Weapon.FireRateAtten;
			NextFireTime = FMax(NextFireTime, Level.TimeSeconds);
		}
	}

    HoldTime = 0;

    if (Instigator.PendingWeapon != Weapon && Instigator.PendingWeapon != None)
    {
        if (Weapon.PutDown())
            bIsFiring = false;

        //log( self$ " ModeDoFire() setting bCheckForEndSustainLoop to true!", 'DevSound' );
        bCheckForEndSustainLoop = true;
    }

	bWaitForAnim = true;

    // Change fire states
	if ( !bWeaponFiring )
	{
		StartFiring();
	}
}

event ModeTick(float dt)
{
	local bool bNeedsToReload;
	Super.ModeTick(dt);

	bNeedsToReload = Weapon.NeedsToReload();
	
	//log( self$ " ModeTick() bNeedsToReload: " $bNeedsToReload$ " bIsFiring: " $bIsFiring$ " bWeaponFiring: " $bWeaponFiring$ " Level.TimeSeconds: " $Level.TimeSeconds$ " FireLoopSustainEndTime: " $FireLoopSustainEndTime$ " FireSoundHandle: " $FireSoundHandle, 'DevSound' );

	if ( !bIsFiring && bWeaponFiring ||
		Weapon.NeedsToReload() && bIsFiring ||
		bCheckForEndSustainLoop )
	{
		bNeedsToReload = Weapon.NeedsToReload();
		//log(self$ " ModeTick() bIsFiring: "$bIsFiring$" bWeaponFiring: " $bWeaponFiring$" bNeedsToReload: " $bNeedsToReload$ " bCheckForEndSustainLoop = true", 'DevSound');
		
		if ( Level.TimeSeconds > FireLoopSustainEndTime )
		{
			//log(self$ " ModeTick() Level.TimeSeconds IS greater then FireLoopSustainEndTime, stopping fireloop!", 'DevSound');

			StopFiring();		// will handle calling stop on sound handle and removing ambient sound
		}
		else
		{
			//log(self$ " ModeTick() Level.TimeSeconds is NOT greater then FireLoopSustainEndTime", 'DevSound');
		}
		
	}
}

// PSV: 11/29/2004 Added fire loop support for machine guns
simulated function PlayAmbientSound(Sound aSound)
{
	if (Weapon.ThirdPersonActor == None) 
	{
        //log(self$ " FireSubMachineGun::PlayAmbientSound() Weapon: " $Weapon$ " Weapon.ThirdPersonActor == NULL!!!  BAD!!", 'DevSound');
		return;		
	}

	// Because users can fire and release super fast, we need to sustain the fireloop long enough 
	// so that at least one fire "bang" sound is played
    if ( aSound == None )
	{		
		//log(self$ "PlayAmbientSound() aSound: "$aSound$ " Level.TimeSeconds: "$Level.TimeSeconds$ " IS greater then SustainEndTime: "$FireLoopSustainEndTime$ " , setting AmbientSound to "$aSound, 'DevSound');
		
        if ( Level.TimeSeconds > FireLoopSustainEndTime )
		{
			if  ( Weapon.ThirdPersonActor.AmbientSound != None )
			{
				// Set a fade-out time for the fire looping sound
				Weapon.ThirdPersonActor.m_fAmbientSoundFadeOutTime = fAmbientSoundFadeOutTime;
				Weapon.ThirdPersonActor.AmbientSound = aSound;
			}

			FireLoopSustainEndTime = 0.0;
			bCheckForEndSustainLoop = false;
		}
        else
	    {
			//log(self$ "PlayAmbientSound() Level.TimeSeconds: " $Level.TimeSeconds$ " is NOT greater then SustainEndTime: " $FireLoopSustainEndTime, 'DevSound');

			// Set flag so we can check for end in Tick()
			bCheckForEndSustainLoop = true;
	    }
    }
	else
	{
		FireLoopSustainEndTime = Level.TimeSeconds + MinFireLoopSustainTime;
		//log(self$ "PlayAmbientSound() Setting SustainEndTime: " $FireLoopSustainEndTime, 'DevSound');   

		Weapon.ThirdPersonActor.AmbientSound = aSound;
		bCheckForEndSustainLoop = false;
	}
}

event ModeHoldFire()
{
	Super.ModeHoldFire();
}

// Called locally to stop first person fire loop and play one off shot
function StopFiring()
{
	Super.StopFiring();

	//log(self$ " FireSubMachineGun::StopFiring() FireSoundHandle: " $FireSoundHandle, 'DevSound' );

	if ( Weapon.IsAutomatic() )
	{
		// Because users can fire and release super fast, we need to sustain the fireloop long enough 
		// so that at least one fire "bang" sound is played
		if ( Level.TimeSeconds > FireLoopSustainEndTime )
		{		
			//log(self$ " FireSubMachineGun::StopFiring() Level.TimeSeconds: "$Level.TimeSeconds$ " IS greater then SustainEndTime: "$FireLoopSustainEndTime$ " , setting AmbientSound to None!", 'DevSound');
		
			FireLoopSustainEndTime = 0.0;
			bCheckForEndSustainLoop = false;

			if (Instigator.IsLocallyControlled())
			{
				//log( self$ " FireSubMachineGun::StopFiring() LOCALLY CONTROLLED!");
				// PSV: 7/26/2005 Not splitscreen friendly 
				// Should use IsALocalPlayerController()
				//if ( StereoFireEndLoopSoundCue != None && (Instigator.Controller == Level.GetLocalPlayerController()) )
				if ( (Instigator.Controller == Level.GetLocalPlayerController()) && FireSoundHandle != 0  )
				{
					if ( StereoFireEndLoopSoundCue != None )
					{
						//log( self$ " FireSubMachineGun::StopFiring() Playing stereo one off shot");	
						Weapon.PlayLocalSoundCue(StereoFireEndLoopSoundCue, SLOT_None, false);	
					}
					else
					{
						//log( self$ " FireSubMachineGun::StopFiring() Missing stereo cue?!  Playing mono one off shot");	
						Weapon.PlayLocalSoundCue(FireEndLoopSoundCue, SLOT_None, false);	
					}
				}
				else
				{
					//log( self$ " FireSubMachineGun::StopFiring() Missing stereo cue?!  Playing mono one off shot");	
					if ( Weapon.ThirdPersonActor.AmbientSound != None )
						Weapon.PlayLocalSoundCue(FireEndLoopSoundCue, SLOT_None, false);	
				}
			}

			if ( Weapon.ThirdPersonActor.AmbientSound != None )
			{
				// This shouldn't be the case for the local guy!!!!!!!! BAD!!!!
				//log( self$ " FireSubMachineGun::StopFiring() Playing mono one off shot");
				Weapon.ThirdPersonActor.PlayRemoteSoundCue(FireEndLoopSoundCue, SLOT_None, true, false);
			}
			else
			{
				//log(self$ " FireSubMachineGun::StopFiring() Not playing one off end shot because Weapon.ThirdPersonActor.AmbientSound is NULL!");
			}
			
			// Was the stereo loop playing?
			if ( FireSoundHandle != 0 )					
				StopSound( FireSoundHandle );

			// Stop the mono loop
			PlayAmbientSound(None);

			FireSoundHandle = 0;
		}
		else
		{
			//log(self$ " FireSubMachineGun::StopFiring() Level.TimeSeconds: " $Level.TimeSeconds$ " is NOT greater then SustainEndTime: " $FireLoopSustainEndTime, 'DevSound');
		
			// Set flag so we can check for end in Tick()
			bCheckForEndSustainLoop = true;
		}
	}
}

auto state Idle
{
    function BeginState()
    {
        PlayAmbientSound(None);
    }

    function EndState()
    {
    }

    function StartFiring()
    {
		bWeaponFiring = true;
        GotoState('FireLoop');
    }
}

state FireLoop
{
    function BeginState()
    {
		//log(self$ " FireSubMachineGun::FireLoop::BeginState() Calling PlayAmbientSound("$FireLoopSound$")", 'DevSound');
		PlayAmbientSound(FireLoopSound);
    }

    function StopFiring()
    {
		Global.StopFiring();
	
		bWeaponFiring = false;
		GotoState('Idle');
    }

    function EndState()
    {
    }
}

defaultproperties
{
	MinFireLoopSustainTime = 0.0
	bCheckForEndSustainLoop = false
	FireLoopSustainEndTime = 0.0
	fAmbientSoundFadeOutTime = 0.1
}class FireUSBar extends InstantFire;



var float	LastFireTime;
var float	ClickTime;

event ModeDoFire()
{
	LastFireTime = Level.TimeSeconds;
	Super.ModeDoFire();
}

event ModeHoldFire()
{
}

defaultproperties
{
    AmmoClass=class'AmmoUSBar'
    AmmoPerFire=1
    DamageType=class'DamageUSBar'
    //DamageMin=50
    //DamageMax=60
	Damage_Human_SP=(min=60,max=70)
	Damage_Human_MP=(min=45,max=45)
	Damage_AI_SP=(min=35,max=40)
	Damage_AI_MP=(min=45,max=45)
    bPawnRapidFireAnim=true
	Load=1

    FireAnim=fire
    FireEndAnim=None
    FireLoopAnim=None
    FireAnimRate=1.0
	ReloadAnim=reload
	ReloadAnimRate=1.0

    FlashEmitterClass=class'gbxEffects.MuzzleFlashBar'

	FireSoundName="W_BAR.FIRE"
	StereoFireSoundName="W_BAR.FIRE_ST"
	
    //FireSound=Sound'WeaponSounds.AssaultRifle.AssaultRifleFire'
    FireForce="AssaultRifleFire"   // jdf

	PreFireTime=0.0
    FireRateSP=0.15 // SJP: 0.12 = 500 Rnds/min (accurate)
	FireRateMP=0.15 // SJP: 0.12 = 500 Rnds/min (accurate)
    AIFireRateSP=0.15
	AIFireRateMP=0.15
	AIFireRateVarianceSP=0.0
	AIFireRateVarianceMP=0.0
    bModeExclusive=true

	SuppressionMultiplierSP=1.0
	SuppressionMultiplierMP=1.5

	AimErrorMin_Human=500
	AimErrorMax_Human_Crouched=500	
	AimErrorMax_Human_Standing=900
	AimErrorMax_Human_MovingSlow=1500
	AimErrorMax_Human_MovingFast=2200
	AimErrorMin_Human_Zoomed=250
	AimErrorMax_Human_Zoomed=1500
	AimErrorMin_Human_FirstShot=50
	AimErrorMax_Human_FirstShot=150

	AimErrorMin_AI_MP=500
	AimErrorMax_AI_MP_Crouched=500
	AimErrorMax_AI_MP_Standing=900
	AimErrorMax_AI_MP_Moving=2200
	AimMultiplier_AI_MP_Sighted=1.0

	AimErrorMin_AI_SP=500
	AimErrorMax_AI_SP_Crouched=500
	AimErrorMax_AI_SP_Standing=900
	AimErrorMax_AI_SP_Moving=2200
	AimMultiplier_AI_SP_Sighted=0.8

    ShakeOffsetMag=(X=0.0,Y=0.0,Z=0.0)
    ShakeOffsetRate=(X=1000.0,Y=1000.0,Z=1000.0)
    ShakeOffsetTime=2
    ShakeRotMag=(X=50.0,Y=50.0,Z=50.0)
    ShakeRotRate=(X=10000.0,Y=10000.0,Z=10000.0)
    ShakeRotTime=2

    TweenTime = 0.01

	bWaitForRelease=false

	// Burst count levels.
	Burst_High_SP=(Min=6,Max=10)
	Burst_High_MP=(Min=5,Max=15)
	Burst_Low_SP=(Min=5,Max=10)
	Burst_Low_MP=(Min=5,Max=15)
	Burst_Op_SP=(Min=5,Max=10)
	Burst_Op_MP=(Min=7,Max=20)

	ShotCountMod=3

	m_flRandomBurstRange=0.0

	// This really sucks, but constants are supported here, so I'm just setting this to the value of the constant.
	FireType=1
	bAccurateFirstShot=true
}
class FireUSBazooka extends WeaponFire;

var class<DamageType>	DamageType;
var float				TraceRange;
var float				Momentum;
var float				HitEffectProb;
var float				FireTraceBackStep; // Distance to subtract from the start location of a fire trace

// Burst-count min/max values to use when firing; categorized by suppression level (low, med., high).
var Range Burst_High_SP;
var Range Burst_High_MP;
var Range Burst_Low_SP;
var Range Burst_Low_MP;
var Range Burst_Op_SP;
var Range Burst_Op_MP;

var Range BurstLength_High;
//var Range BurstLength_Med;
var Range BurstLength_Low;

var float				m_flRandomBurstRange;
var ProjectileUSBazooka	FiredRocket;

const AMMO_INVENTORY_SHOW_TIME = 3.0;

simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();
}

event ModeDoFire()
{
	Super.ModeDoFire();

	if ( Weapon.IsA('gbxWeapon') && gbxWeapon(Weapon).m_fZoomed)
	{
		bWaitForAnim = false;
	}
}

function PlayFiring()
{
	Super.PlayFiring();

	//SJP: Kick the view
	if ( Instigator.Weapon.Ammo[0] != None )
	{
		if( gbxAmmo(Instigator.Weapon.Ammo[0]) != None )
		{
			//gbxAmmo(Instigator.Weapon.Ammo[0]).ApplyKick();
			//gbxWeaponAttachment(gbxWeapon(Instigator.Weapon).ThirdPersonActor).EjectShell( gbxAmmo(Instigator.Weapon.Ammo[0]).AmmoShellClass );
		}

		if (Weapon.ClipAmt <= 0)
		{
			if (gbxWeapon(Weapon) != None)
			{
				gbxWeapon(Weapon).flAmmoFadeTime = AMMO_INVENTORY_SHOW_TIME;
				gbxWeapon(Weapon).flLastAmmoFadeTime = Level.TimeSeconds;
			}
		}

		gbxWeapon(Weapon).flLastFireTime = Level.TimeSeconds;
	}
	Weapon.AnimBlendToAlpha( 1, 0.0, 0.0 );	// Reset the breathing animation so it doesn't override the fire animation
	if (gbxWeapon(Weapon) != None)
	{
		gbxWeapon(Weapon).m_fResetBreathe = true;
	}
	
	gbxWeapon(Weapon).m_fPlayingFire = true;
}

function DoFireEffect()
{
    local Vector StartRocket;
    local Rotator Aim;
	local Vector HitLocation, HitNormal;
	local Actor HitActor;
	local float lookdist;

    Instigator.MakeNoise(1.0);

	if (!Level.Game.IsA('WargameMultiplayer'))
	{
		StartRocket = Weapon.GetMuzzleLocationWorld();				
	}
	else
	{
		if (Instigator.IsHumanControlled())
		{
			StartRocket = Instigator.Location + Instigator.EyePosition();
			
		}
		else
		{
			StartRocket = Weapon.GetMuzzleLocationWorld();
		}
	}	

	// Get the modified aim rotator based on the weapon aim error (as well as any other error values along the way).
	Aim = AdjustAimNew(StartRocket);

	if (gbxPawn(Instigator) != None)
		gbxPawn(Instigator).LastAimRotator = Aim;

	if (FiredRocket != None)
	{
		FiredRocket.Destroy();
	}
	
	FiredRocket = Spawn( class'ProjectileUSBazooka', Instigator,, StartRocket, Aim );
	
	if ((FiredRocket != None) && Weapon.IsA('gbxWeapon'))
	{
		// Use safety launch to make sure the rocket spawns and travels effectively.  However, if the player is actually aiming at a point
		// Closer than the safety launch distance, bring that distance down so the rocket will blow up in his face.
		HitActor = Trace( HitLocation, HitNormal, StartRocket + ( Vector( Aim ) * ( FiredRocket.SafeLaunchDist + 26.0 ) ), StartRocket - ( Vector( Aim ) * 26.0 ), true );

		lookdist = VSize( StartRocket - HitLocation ) - 26.0;

		if( HitLocation == vect(0,0,0) || lookdist > FiredRocket.SafeLaunchDist )
		{
			FiredRocket.UseSafetyLaunch();
		}
		else
		{
			FiredRocket.SetCollision( true, false, false );
			FiredRocket.bCollideWorld = true;
			FiredRocket.HitWall( HitLocation, HitNormal, HitActor );
		}

		FiredRocket.m_aGuideTarget = gbxWeapon(Weapon).m_aGuideTarget;
	}

	ClientDoFireEffect();
}

simulated function ClientDoFireEffect()
{
	if ( Instigator.IsHumanControlled() && Instigator.IsA( 'gbxPawn' ) )
		Instigator.Controller.JogFatigue( gbxPawn( Instigator ).FatigueJog_PlayerFiredShot );	
}

simulated function PlayReloading()
{
	local gbxPlayerController gbxPC;

	if (Weapon.ClipAmt >= Weapon.AmmoClipSize)
		return;

	if (Instigator.IsA('Mind') && Instigator.IsMoving() && Instigator.bIsCrouched)
		return;
		
	gbxWeapon(Weapon).m_fAIWeaponWaitingToFire = false;
	gbxWeapon(Weapon).flAmmoFadeTime = AMMO_INVENTORY_SHOW_TIME;
	gbxWeapon(Weapon).flLastAmmoFadeTime = Level.TimeSeconds;

	gbxPC = gbxPlayerController(Instigator.Controller);

	if( gbxWeapon(Weapon).m_fZoomed && gbxPC != None )
	{
		gbxPC.PendingDelayedAction = ReloadAfterZoomOut;
		gbxWeapon(Weapon).ForceUnzoom();
		//gbxPC.ChangeView(0);
	}
	else
	{
		Super.PlayReloading();
	}
}

function FlashMuzzleFlash()
{
	local gbxMuzzleFlash MuzFlash;

	MuzFlash = gbxMuzzleFlash(GetMuzzleFlash());
	MuzFlash.SetLocation(Weapon.Location);
	MuzFlash.Flash();
}

// GEARBOX: SJP - Look at RenderOverlays in gbxWeapon
// For first-person muzzle flashes only
function DrawMuzzleFlash(Canvas Canvas)
{
}

simulated function bool ReadyToFire()
{
	return AllowFire();
}

simulated function bool AllowFire()
{
	if( Super.AllowFire() )
	{
		if (Pawn(Weapon.Owner) != None)
		{
			if (Pawn(Weapon.Owner).bIsSprinting)
			{
				Pawn(Weapon.Owner).SetSprinting( false );
			}

			if (Weapon.IsA('gbxWeapon') && Pawn(Weapon.Owner).Controller.bIsHumanPlayer)
			{
				if (gbxWeapon(Weapon).bAimingAtFriendly)
				{
					PlayDryFire();
				}
				return !(gbxWeapon(Weapon).bAimingAtFriendly);
			}
		}
		
		return true;
	}

	return false;
}


function Rotator GetLastAimRotator()
{
	if (gbxPawn(Instigator) != None)
		return gbxPawn(Instigator).LastAimRotator;
	return Rot(0,0,0);
}

function GetBestBurstCount( ESuppressionLevel SuppressionLevel, out int MinShots, out int MaxShots )
{
	MinShots = 1;
	MaxShots = 1;
}

function GetOpBurstCount( out int MinShots, out int MaxShots )
{
	MinShots = 1;
	MaxShots = 1;
}

simulated function Tick(float DeltaTime)
{
	Super.Tick(DeltaTime);

	if (Weapon == None)
		return;
	
//	if (!Weapon.bDelayReloading && (Weapon.Ammo[0].AmmoAmount > 0) && (Weapon.ClipAmt <= 0) && (Weapon.ClientState != WS_Reloading) && !gbxWeapon(Weapon).m_fPlayingFire)
//	{
//		PlayReloading();
//	}
}

defaultproperties
{
    AmmoClass=class'AmmoUSBazooka'
    AmmoPerFire=1
    DamageType=class'DamageUSBazooka'
    bPawnRapidFireAnim=true
	Load=1

    FireAnim=fire
    FireEndAnim=None
    FireLoopAnim=None
    FireAnimRate=1.0
	ReloadAnim=reload
	ReloadAnimRate=1.0

    FlashEmitterClass=class'gbxEffects.MuzzleFlashBazookaView'

	//FireSound=Sound'WeaponSounds.AssaultRifle.AssaultRifleFire'
    FireForce="AssaultRifleFire"   // jdf

	PreFireTime=0.0
	FireRateSP=0.01
	FireRateMP=0.01
	AIFireRateSP=0.5
	AIFireRateMP=0.5
	AIFireRateVarianceSP=0.25		// Up to a 1/4 second difference in either direction.
	AIFireRateVarianceMP=0.25		// Up to a 1/4 second difference in either direction.
//    FireRate=0.5
    //FireRate = 0.25
    bModeExclusive=true

    BotRefireRate=0.5
    //AimErrorAI_SP=(Min=300,Max=300)	// Singleplayer: US weapons do not change with difficulty settings.
	//AimErrorAI_MP=(Min=300,Max=300)
    //AimErrorHuman_SP=300
	//AimErrorHuman_MP=300

    ShakeOffsetMag=(X=0.0,Y=0.0,Z=0.0)
    ShakeOffsetRate=(X=1000.0,Y=1000.0,Z=1000.0)
    ShakeOffsetTime=2
    ShakeRotMag=(X=10.0,Y=10.0,Z=10.0)
    ShakeRotRate=(X=10000.0,Y=10000.0,Z=10000.0)
    ShakeRotTime=2

    TweenTime = 0.0

	bWaitForRelease=true

	// Burst count levels.
	Burst_High_SP=(Min=1,Max=3)
	Burst_High_MP=(Min=1,Max=3)
	Burst_Low_SP=(Min=3,Max=5)
	Burst_Low_MP=(Min=3,Max=5)
	Burst_Op_SP=(Min=8,Max=8)
	Burst_Op_MP=(Min=8,Max=8)

	// This really sucks, but constants are supported here, so I'm just setting this to the value of the constant.
	FireType=1

	FireSoundName="W_USBAZOOKA.FIRE"
	StereoFireSoundName="W_USBAZOOKA.FIRE_ST"
}

class FireUSColt1911_ extends InstantFire;



var float LastFireTime;
var float ClickTime;

var Name EmptyReload;

event ModeDoFire()
{
	LastFireTime = Level.TimeSeconds;
	Super.ModeDoFire();
}

event ModeHoldFire()
{
}

defaultproperties
{
    AmmoClass=class'AmmoUSColt1911_'
    AmmoPerFire=1
    DamageType=class'DamageUSColt1911_'
    //DamageMin=35
    //DamageMax=40
	Damage_Human_SP=(min=35,max=45)
	Damage_Human_MP=(min=35,max=35)
	Damage_AI_SP=(min=35,max=45)
	Damage_AI_MP=(min=35,max=35)
    bPawnRapidFireAnim=true
	Load=1

    FireAnim=fire
    FireEndAnim=None
    FireLoopAnim=None
    FireAnimRate=1.0
	ReloadAnim=reload
	ReloadAnimRate=1.0

    FlashEmitterClass=class'gbxEffects.MuzzleFlashColt1911_'

	FireSoundName = "W_COLT.FIRE"
	StereoFireSoundName = "W_COLT.FIRE_ST"

    FireForce="PistolFire"   // jdf

	PreFireTime=0.0
    //FireRate=0.35
    FireRateSP=0.35
	FireRateMP=0.35
    AIFireRateSP=0.35
	AIFireRateMP=0.35
    bModeExclusive=true

	SuppressionMultiplierSP=0.5
	SuppressionMultiplierMP=2.0

    AimErrorMin_Human=1000
	AimErrorMax_Human_Crouched=1100
	AimErrorMax_Human_Standing=1300
	AimErrorMax_Human_MovingSlow=1400
	AimErrorMax_Human_MovingFast=1800
	AimErrorMin_Human_Zoomed=350
	AimErrorMax_Human_Zoomed=1000

	AimErrorMin_AI_MP=1000
	AimErrorMax_AI_MP_Crouched=1100
	AimErrorMax_AI_MP_Standing=1300
	AimErrorMax_AI_MP_Moving=1800
	AimMultiplier_AI_MP_Sighted=0.6

	AimErrorMin_AI_SP=1000
	AimErrorMax_AI_SP_Crouched=1100
	AimErrorMax_AI_SP_Standing=1300
	AimErrorMax_AI_SP_Moving=1800
	AimMultiplier_AI_SP_Sighted=0.6

    ShakeOffsetMag=(X=0.0,Y=0.0,Z=0.0)
    ShakeOffsetRate=(X=1000.0,Y=1000.0,Z=1000.0)
    ShakeOffsetTime=2
    ShakeRotMag=(X=50.0,Y=50.0,Z=50.0)
    ShakeRotRate=(X=10000.0,Y=10000.0,Z=10000.0)
    ShakeRotTime=2

	TweenTime = 0.01

	bWaitForRelease=true
	EmptyReload = Reload_Empty

	// This really sucks, but constants are supported here, so I'm just setting this to the value of the constant.
	FireType=1

	ShotCountMod=0
}
//=============================================================================
// US M10 tank 50 cal. machine gun fire mode class.
//=============================================================================
class FireUSM10_50cal extends InstantFire
	config(User);



//---------------------------------------------------------
//	Variables
//---------------------------------------------------------
var Rotator		AimRot;		// Direction the weapon was aimed at.

//---------------------------------------------------------
//	PostNetBeginPlay
//---------------------------------------------------------
function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();

	// GBX:naj - spawning the muzzle flash is required here to avoid it flashing the first time you mount the weapon.
	if ( FlashEmitter == None && FlashEmitterClass != None )
    {
		FlashEmitter = Spawn(FlashEmitterClass);
		gbxMuzzleFlash( FlashEmitter ).InitializeMuzzleFlash();
    }
}

//---------------------------------------------------------
//	PlayFiring
//---------------------------------------------------------
function PlayFiring()
{
	if ( Instigator.Weapon.IsA( 'WeapUSM10_50cal' ) )
	{
		WeapUSM10_50cal( Instigator.Weapon ).PlayFiringAnim();
	}

	ClientPlayForceFeedback(FireForce);
}

//---------------------------------------------------------
//	PlayReloading
//---------------------------------------------------------
simulated function PlayReloading()
{
	local bool bKeepFiring;

	bKeepFiring = bIsFiring;

	Weapon.ClientStopFire(0);
	Weapon.ReloadClip();

	if ( bKeepFiring )
		gbxWeapon( Weapon ).StartFiringWeapon();
}

simulated function bool ReadyToFire()
{
	return AllowFire();
}

//---------------------------------------------------------
//	AllowFire
//---------------------------------------------------------
simulated function bool AllowFire()
{
	if (Weapon.IsA('gbxWeapon') && Instigator.Controller.bIsHumanPlayer)
	{
		if (gbxWeapon(Weapon).bAimingAtFriendly)
		{
			return false;
		}
	}

	return Super.AllowFire();
}

//---------------------------------------------------------
//	GetMuzzleFlash
//---------------------------------------------------------
simulated function Emitter GetMuzzleFlash()
{
	local Vector X,Y,Z;
	local AttachmentUSM10_50cal Attachment;

	GetAxes( Weapon.Rotation, X,Y,Z);

	if ( ((FlashEmitter == None) || FlashEmitter.bDeleteMe) && FlashEmitterClass != None )
    {
		Attachment = WeapUSM10_50cal( Weapon ).GetAttachment();
		if ( Attachment == None )
			return None;

        FlashEmitter = Spawn(FlashEmitterClass);
		FlashEmitter.SetLocation( Weapon.Location + Attachment.MuzzleOffset.X*X + Attachment.MuzzleOffset.Y*Y + Attachment.MuzzleOffset.Z*Z );
		FlashEmitter.SetRotation( Weapon.Rotation );
		FlashEmitter.SetBase( Weapon );		

		gbxMuzzleFlash( FlashEmitter ).InitializeMuzzleFlash();
    }

	FlashEmitter.Instigator = Self.Instigator;
	return FlashEmitter;
}

//---------------------------------------------------------
//	StartFiringWeapon
//---------------------------------------------------------
function StartFiringWeapon()
{
	if ( FlashEmitter != None && FlashEmitter.IsA( 'gbxMuzzleFlash' ) )
		gbxMuzzleFlash( FlashEmitter ).FireButtonPressed();
}

//---------------------------------------------------------
//	StopFiringWeapon
//---------------------------------------------------------
function StopFiringWeapon()
{
	if ( FlashEmitter != None && FlashEmitter.IsA( 'gbxMuzzleFlash' ) )
		gbxMuzzleFlash( FlashEmitter ).FireButtonReleased();
}

//---------------------------------------------------------
//	GetBestBurstLength
//---------------------------------------------------------
function GetBestBurstLength( ESuppressionLevel SuppressionLevel, out float MinLen, out float MaxLen )
{
	switch ( SuppressionLevel )
	{
	case SL_UNSUPPRESSED:
		MinLen = BurstLength_Low.Min;
		MaxLen = BurstLength_Low.Max;
		break;
	case SL_SUPPRESSED:
		MinLen = BurstLength_High.Min;
		MaxLen = BurstLength_High.Max;
		break;
	}
}

//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
    AmmoClass=class'AmmoUSM10_50cal'
    AmmoPerFire=1
    DamageType=class'DamageUSM1_'
	Damage_Human_SP=(min=90,max=120)
	Damage_Human_MP=(min=90,max=120)
	Damage_AI_SP=(min=90,max=120)
	Damage_AI_MP=(min=90,max=120)
    bPawnRapidFireAnim=true
	Load=1

	FireAnim=Fire
    FireEndAnim=None
    FireLoopAnim=None
	ReloadAnim=None

	FlashEmitterClass=class'gbxEffects.MuzzleFlash50cal'

    FireForce="MachineGunFire"   // jdf

	PreFireTime=0.0
	FireRateSP=0.109 // 550 rounds per minute
	FireRateMP=0.109 // 550 rounds per minute
    AIFireRateSP=0.07
	AIFireRateMP=0.07
    bModeExclusive=true

	SuppressionMultiplierSP=1.5

	TraceRange=15000

	bWaitForRelease=false

	ShakeOffsetMag=(X=1.0,Y=1.0,Z=1.0)
    ShakeOffsetRate=(X=1000.0,Y=1000.0,Z=1000.0)
    ShakeOffsetTime=2
    ShakeRotMag=(X=50.0,Y=50.0,Z=50.0)
    ShakeRotRate=(X=10000.0,Y=10000.0,Z=10000.0)
    ShakeRotTime=2

	// This really sucks, but constants are supported here, so I'm just setting this to the value of the constant.
	FireType=1

	ShotCountMod=3
}
class FireUSM1919_ extends FireDEMG42_;

defaultproperties
{
	FireRateSP=0.09
	FireRateMP=0.09
    AIFireRateSP=0.09
	AIFireRateMP=0.09
}class FireUSM1Carbine extends InstantFire;



var float LastFireTime;
var float ClickTime;
var transient gbxWeaponShells EjectedShell;

event ModeDoFire()
{
	LastFireTime = Level.TimeSeconds;
	Super.ModeDoFire();
}

event ModeHoldFire()
{
}

defaultproperties
{
    AmmoClass=class'AmmoUSM1Carbine'
    AmmoPerFire=1
    DamageType=class'DamageUSM1Carbine'
    //DamageMin=50
    //DamageMax=60
	Damage_Human_SP=(min=40,max=50)
	Damage_Human_MP=(min=35,max=35)
	Damage_AI_SP=(min=30,max=35)
	Damage_AI_MP=(min=35,max=35)
    bPawnRapidFireAnim=true
	Load=1

    FireAnim=fire
    FireEndAnim=None
    FireLoopAnim=None
    FireAnimRate=1.0
	ReloadAnim=reload
	ReloadAnimRate=1.0

    FlashEmitterClass=class'gbxEffects.MuzzleFlashM1_'

	FireSoundName="W_M1CARBINE.FIRE"
	StereoFireSoundName="W_M1CARBINE.FIRE_ST"
    //FireSound=Sound'WeaponSounds.AssaultRifle.AssaultRifleFire'
    FireForce="AssaultRifleFire"   // jdf

	PreFireTime=0.0
    FireRateSP=0.12
	FireRateMP=0.21// PSV 6/16/2005 Changed per request of Patrick Blank 0.3
    AIFireRateSP=0.3
	AIFireRateMP=0.3
	AIOpBurstMultiplierSP=0.4
	AIOpBurstMultiplierMP=0.6
	AIFireRateVarianceSP=0.15		// Up to a 1/4 second difference in either direction.
	AIFireRateVarianceMP=0.05
    bModeExclusive=true

    AimErrorMin_Human=250
	AimErrorMax_Human_Crouched=300	
	AimErrorMax_Human_Standing=500
	AimErrorMax_Human_MovingSlow=1200
	AimErrorMax_Human_MovingFast=1700
	//AimErrorMin_Human_Zoomed=50
	AimErrorMin_Human_Zoomed=75
	AimErrorMax_Human_Zoomed=200

	AimErrorMin_AI_MP=250
	AimErrorMax_AI_MP_Crouched=300
	AimErrorMax_AI_MP_Standing=500
	AimErrorMax_AI_MP_Moving=1700
	AimMultiplier_AI_MP_Sighted=1.0

	AimErrorMin_AI_SP=250
	AimErrorMax_AI_SP_Crouched=300
	AimErrorMax_AI_SP_Standing=500
	AimErrorMax_AI_SP_Moving=1700
	AimMultiplier_AI_SP_Sighted=0.25

    ShakeOffsetMag=(X=0.0,Y=0.0,Z=0.0)
    ShakeOffsetRate=(X=1000.0,Y=1000.0,Z=1000.0)
    ShakeOffsetTime=2
    ShakeRotMag=(X=10.0,Y=10.0,Z=10.0)
    ShakeRotRate=(X=10000.0,Y=10000.0,Z=10000.0)
    ShakeRotTime=2

    TweenTime = 0.0

	bWaitForRelease=true

	// Suppression Multiplier
	SuppressionMultiplierMP=0.4

	// Burst count levels.
	Burst_High_SP=(Min=1,Max=3)
	Burst_High_MP=(Min=3,Max=10)
	Burst_Low_SP=(Min=3,Max=5)
	Burst_Low_MP=(Min=3,Max=10)
	Burst_Op_SP=(Min=8,Max=8)
	Burst_Op_MP=(Min=5,Max=15)

	// This really sucks, but constants are supported here, so I'm just setting this to the value of the constant.
	FireType=1

	ShotCountMod=2
}
class FireUSM1_ extends SingleBulletReloadFire;



var float LastFireTime;
var float ClickTime;
var transient gbxWeaponShells EjectedShell;

event ModeDoFire()
{
	LastFireTime = Level.TimeSeconds;
	Super.ModeDoFire();
}

event ModeHoldFire()
{
}

function StartOpBurst()
{
	Super.StartOpBurst();
	AIFireRateVarianceSP = 0.0;		// Really no need for rate-of-fire variation when firing this fast.
	AIFireRateVarianceMP = 0.0;		// Really no need for rate-of-fire variation when firing this fast.
	NextFireTime = Level.TimeSeconds;	// Move up the next bullet time.
}

function StartBerserk()
{
	Super.StartBerserk();
	AIFireRateVarianceSP = 0.0;		// Really no need for rate-of-fire variation when firing this fast.
	AIFireRateVarianceMP = 0.0;		// Really no need for rate-of-fire variation when firing this fast.
	NextFireTime = Level.TimeSeconds;	// Move up the next bullet time.
}

function StopBerserk()
{
	Super.StopBerserk();
	AIFireRateVarianceSP = default.AIFireRateVarianceSP;
	AIFireRateVarianceSP = default.AIFireRateVarianceMP;
}

defaultproperties
{
    AmmoClass=class'AmmoUSM1_'
    AmmoPerFire=1
    DamageType=class'DamageUSM1_'
    //DamageMin=50
    //DamageMax=60
	Damage_Human_SP=(min=80,max=105)
	Damage_Human_MP=(min=50,max=50)
	Damage_AI_SP=(min=40,max=45)
	Damage_AI_MP=(min=50,max=50)
    bPawnRapidFireAnim=true
	Load=1

    FireAnim=fire
    FireEndAnim=None
    FireLoopAnim=None
    FireAnimRate=1.0
	ReloadAnim=reload
	ReloadAnimRate=1.0

    FlashEmitterClass=class'gbxEffects.MuzzleFlashM1_'

	FireSoundName="W_M1GARAND.FIRE"
	StereoFireSoundName="W_M1GARAND.FIRE_ST"
	//FireSound=Sound'WeaponSounds.AssaultRifle.AssaultRifleFire'
    FireForce="RifleFire"   // jdf

	PreFireTime=0.0
	FireRateSP=0.25
	FireRateMP=0.425// PSV 6/16/2005 Changed per request of Patrick Blank 0.6
	AIFireRateSP=0.5
	AIFireRateMP=0.65
	AIFireRateVarianceSP=0.25		// Up to a 1/4 second difference in either direction.
	AIFireRateVarianceMP=0.1
	AIOpBurstMultiplierSP=0.4
	AIOpBurstMultiplierMP=0.6
//    FireRate=0.5
    //FireRate = 0.25
    bModeExclusive=true

    BotRefireRate=0.5
    //AimErrorAI_SP=(Min=300,Max=300)	// Singleplayer: US weapons do not change with difficulty settings.
	//AimErrorAI_MP=(Min=300,Max=300)
    //AimErrorHuman_SP=300
	//AimErrorHuman_MP=300

    ShakeOffsetMag=(X=0.0,Y=0.0,Z=0.0)
    ShakeOffsetRate=(X=1000.0,Y=1000.0,Z=1000.0)
    ShakeOffsetTime=2
    ShakeRotMag=(X=10.0,Y=10.0,Z=10.0)
    ShakeRotRate=(X=10000.0,Y=10000.0,Z=10000.0)
    ShakeRotTime=2

    TweenTime = 0.0

	AimErrorMin_Human=200
	AimErrorMax_Human_Crouched=250	
	AimErrorMax_Human_Standing=450
	AimErrorMax_Human_MovingSlow=900
	AimErrorMax_Human_MovingFast=1100
	//AimErrorMin_Human_Zoomed=30
	AimErrorMin_Human_Zoomed=75
	AimErrorMax_Human_Zoomed=200

	AimErrorMin_AI_MP=200
	AimErrorMax_AI_MP_Crouched=250
	AimErrorMax_AI_MP_Standing=450
	AimErrorMax_AI_MP_Moving=1100
	AimMultiplier_AI_MP_Sighted=1.0

	AimErrorMin_AI_SP=200
	AimErrorMax_AI_SP_Crouched=250
	AimErrorMax_AI_SP_Standing=450
	AimErrorMax_AI_SP_Moving=1100
	AimMultiplier_AI_SP_Sighted=0.3

	bWaitForRelease=true

	// Suppression Multiplier
	SuppressionMultiplierMP=1.2

	// Burst count levels.
	Burst_High_SP=(Min=1,Max=3)
	Burst_High_MP=(Min=2,Max=5)
	Burst_Low_SP=(Min=3,Max=5)
	Burst_Low_MP=(Min=2,Max=5)
	Burst_Op_SP=(Min=8,Max=8)
	Burst_Op_MP=(Min=4,Max=8)

	// This really sucks, but constants are supported here, so I'm just setting this to the value of the constant.
	FireType=1

	ShotCountMod=2

	ReloadAnimList[0]=reload
	ReloadAnimList[1]=reload_full
}
class FireUSM3A1_ extends FireSubMachineGun
	config(User);

var Emitter	ViewFlashEmitter;
var class<Emitter> ViewFlashEmitterClass;

/// SJP: The m3a1 muzzle flash doesn't work very well in first person, so provide an alternative here
simulated function Emitter GetMuzzleFlash()
{
	if ( Instigator.IsFirstPerson() )
    {
		if ( ( ViewFlashEmitter == None || ViewFlashEmitter.bDeleteMe ) && ViewFlashEmitterClass != None )
		{
			ViewFlashEmitter = Spawn(ViewFlashEmitterClass);
			log("Spawned "$ViewFlashEmitter, 'weapon');
		}

		return ViewFlashEmitter;
    }
	else
	{
		return Super.GetMuzzleFlash();
	}
}

defaultproperties
{
    AmmoClass=class'AmmoUSM3A1_'
    AmmoPerFire=1
    DamageType=class'DamageUSM3A1_'
    //DamageMin=35
    //DamageMax=40
	Damage_Human_SP=(min=35,max=45)
	Damage_Human_MP=(min=30,max=30)
	Damage_AI_SP=(min=25,max=30)
	Damage_AI_MP=(min=30,max=30)
    bPawnRapidFireAnim=true
	Load=1

    FireAnim=fire
    FireEndAnim=None
    FireLoopAnim=None
    FireAnimRate=1.0
	ReloadAnim=reload
	ReloadAnimRate=1.0
    FlashEmitterClass=class'gbxEffects.MuzzleFlashThompson'
	ViewFlashEmitterClass=class'gbxEffects.MuzzleFlashThompsonView'

	// One off sounds
	FireSoundName="W_M3A1.FIRE"
	
	// Loops
	FireLoopSoundName="W_M3A1.FIRELOOP"
	StereoFireLoopSoundName="W_M3A1.FIRELOOP_ST"
	FireEndLoopSoundName="W_M3A1.FIRELOOP_END"
	StereoFireEndLoopSoundName="W_M3A1.FIRELOOPEND_ST"
	

    FireForce="SubMachineGunFire"   // jdf

	PreFireTime=0.0
    FireRateSP=0.133 // PAD: 0.133 = 450 Rnds/min (accurate)
	FireRateMP=0.133 // PAD: 0.133 = 450 Rnds/min (accurate)
    AIFireRateSP=0.133
	AIFireRateMP=0.133
    bModeExclusive=true

    SuppressionMultiplierSP=0.5
	SuppressionMultiplierMP=0.5

	AimErrorMin_Human=750
	AimErrorMax_Human_Crouched=800
	AimErrorMax_Human_Standing=1000
	AimErrorMax_Human_MovingSlow=1000
	AimErrorMax_Human_MovingFast=1400
	AimErrorMin_Human_Zoomed=400
	AimErrorMax_Human_Zoomed=1300
	AimErrorMin_Human_FirstShot=100
	AimErrorMax_Human_FirstShot=300

	AimErrorMin_AI_MP=750
	AimErrorMax_AI_MP_Crouched=800
	AimErrorMax_AI_MP_Standing=1000
	AimErrorMax_AI_MP_Moving=1400
	AimMultiplier_AI_MP_Sighted=1.0

	AimErrorMin_AI_SP=750
	AimErrorMax_AI_SP_Crouched=800
	AimErrorMax_AI_SP_Standing=1000
	AimErrorMax_AI_SP_Moving=1400
	AimMultiplier_AI_SP_Sighted=0.8

    ShakeOffsetMag=(X=0.0,Y=0.0,Z=0.0)
    ShakeOffsetRate=(X=1000.0,Y=1000.0,Z=1000.0)
    ShakeOffsetTime=2
    ShakeRotMag=(X=50.0,Y=50.0,Z=50.0)
    ShakeRotRate=(X=10000.0,Y=10000.0,Z=10000.0)
    ShakeRotTime=2

    TweenTime = 0.01

	bWaitForRelease=false

	// Burst count levels.
	Burst_High_SP=(Min=2,Max=5)
	Burst_High_MP=(Min=5,Max=15)
	Burst_Low_SP=(Min=5,Max=10)
	Burst_Low_MP=(Min=5,Max=15)
	Burst_Op_SP=(Min=5,Max=10)
	Burst_Op_MP=(Min=7,Max=20)

	ShotCountMod=3

	m_flRandomBurstRange=0.0

	// This really sucks, but constants are supported here, so I'm just setting this to the value of the constant.
	FireType=1
	
	bAccurateFirstShot=true
	
	MinFireLoopSustainTime = 0.06
}
//=============================================================================
// US Sherman tank 50 cal. machine gun fire mode class.
//=============================================================================
class FireUSSherman50cal extends InstantFire;



//---------------------------------------------------------
//	Variables
//---------------------------------------------------------
var Rotator		AimRot;		// Direction the weapon was aimed at.

//---------------------------------------------------------
//	PostNetBeginPlay
//---------------------------------------------------------
function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();

	// GBX:naj - spawning the muzzle flash is required here to avoid it flashing the first time you mount the weapon.
	if ( FlashEmitter == None && FlashEmitterClass != None )
    {
		FlashEmitter = Spawn(FlashEmitterClass);
		gbxMuzzleFlash( FlashEmitter ).InitializeMuzzleFlash();
    }
}

//---------------------------------------------------------
//	PlayFiring
//---------------------------------------------------------
function PlayFiring()
{
	if ( Instigator.Weapon.IsA( 'WeapUSSherman50cal' ) )
	{
		WeapUSSherman50cal( Instigator.Weapon ).PlayFiringAnim();
	}

	ClientPlayForceFeedback(FireForce);
}

//---------------------------------------------------------
//	PlayReloading
//---------------------------------------------------------
simulated function PlayReloading()
{
	local bool bKeepFiring;

	bKeepFiring = bIsFiring;

	Weapon.ClientStopFire(0);
	Weapon.ReloadClip();

	if ( bKeepFiring )
		gbxWeapon( Weapon ).StartFiringWeapon();
}

simulated function bool ReadyToFire()
{
	return AllowFire();
}

//---------------------------------------------------------
//	AllowFire
//---------------------------------------------------------
simulated function bool AllowFire()
{
	if (Weapon.IsA('gbxWeapon') && Instigator.Controller.bIsHumanPlayer)
	{
		if (gbxWeapon(Weapon).bAimingAtFriendly)
		{
			return false;
		}
	}

	return Super.AllowFire();
}

//---------------------------------------------------------
//	GetMuzzleFlash
//---------------------------------------------------------
simulated function Emitter GetMuzzleFlash()
{
	local Vector X,Y,Z;
	local AttachmentUSSherman50cal Attachment;

	GetAxes( Weapon.Rotation, X,Y,Z);

	if ( ((FlashEmitter == None) || FlashEmitter.bDeleteMe) && FlashEmitterClass != None )
    {
		Attachment = WeapUSSherman50cal( Weapon ).GetAttachment();
		if ( Attachment == None )
			return None;

        FlashEmitter = Spawn(FlashEmitterClass);
		FlashEmitter.SetLocation( Weapon.Location + Attachment.MuzzleOffset.X*X + Attachment.MuzzleOffset.Y*Y + Attachment.MuzzleOffset.Z*Z );
		FlashEmitter.SetRotation( Weapon.Rotation );
		FlashEmitter.SetBase( Weapon );		

		gbxMuzzleFlash( FlashEmitter ).InitializeMuzzleFlash();
    }

	FlashEmitter.Instigator = Self.Instigator;
	return FlashEmitter;
}

//---------------------------------------------------------
//	StartFiringWeapon
//---------------------------------------------------------
function StartFiringWeapon()
{
	if ( FlashEmitter != None && FlashEmitter.IsA( 'gbxMuzzleFlash' ) )
		gbxMuzzleFlash( FlashEmitter ).FireButtonPressed();
}

//---------------------------------------------------------
//	StopFiringWeapon
//---------------------------------------------------------
function StopFiringWeapon()
{
	if ( FlashEmitter != None && FlashEmitter.IsA( 'gbxMuzzleFlash' ) )
		gbxMuzzleFlash( FlashEmitter ).FireButtonReleased();
}

//---------------------------------------------------------
//	GetBestBurstLength
//---------------------------------------------------------
function GetBestBurstLength( ESuppressionLevel SuppressionLevel, out float MinLen, out float MaxLen )
{
	switch ( SuppressionLevel )
	{
	case SL_UNSUPPRESSED:
		MinLen = BurstLength_Low.Min;
		MaxLen = BurstLength_Low.Max;
		break;
	case SL_SUPPRESSED:
		MinLen = BurstLength_High.Min;
		MaxLen = BurstLength_High.Max;
		break;
	}
}

//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
    AmmoClass=class'AmmoUSSherman50cal'
    AmmoPerFire=1
    DamageType=class'DamageUSM1_'
	Damage_Human_SP=(min=90,max=120)
	Damage_Human_MP=(min=90,max=120)
	Damage_AI_SP=(min=90,max=120)
	Damage_AI_MP=(min=90,max=120)
    bPawnRapidFireAnim=true
	Load=1

	FireAnim=Fire
    FireEndAnim=None
    FireLoopAnim=None
	ReloadAnim=None

	FlashEmitterClass=class'gbxEffects.MuzzleFlash50cal'

    FireForce="MachineGunFire"   // jdf

	PreFireTime=0.0
	FireRateSP=0.109 // 550 rounds per minute
	FireRateMP=0.109 // 550 rounds per minute
    AIFireRateSP=0.07
	AIFireRateMP=0.07
    bModeExclusive=true

	SuppressionMultiplierSP=1.5

	TraceRange=15000

	bWaitForRelease=false

	ShakeOffsetMag=(X=1.0,Y=1.0,Z=1.0)
    ShakeOffsetRate=(X=1000.0,Y=1000.0,Z=1000.0)
    ShakeOffsetTime=2
    ShakeRotMag=(X=50.0,Y=50.0,Z=50.0)
    ShakeRotRate=(X=10000.0,Y=10000.0,Z=10000.0)
    ShakeRotTime=2

	// This really sucks, but constants are supported here, so I'm just setting this to the value of the constant.
	FireType=1

	ShotCountMod=3
}
class FireUSSpringfield extends SingleBulletReloadFire;

var float LastFireTime;
var float ClickTime;
var transient gbxWeaponShells EjectedShell;

event ModeDoFire()
{
	LastFireTime = Level.TimeSeconds;
	Super.ModeDoFire();
}

event ModeHoldFire()
{
}

defaultproperties
{
    AmmoClass=class'AmmoUSSpringfield'
    AmmoPerFire=1
    DamageType=class'DamageUSSpringfield'
    //DamageMin=50
    //DamageMax=60
	Damage_Human_SP=(min=100,max=100)
	Damage_Human_MP=(min=100,max=100)
	Damage_AI_SP=(min=40,max=45)
	Damage_AI_MP=(min=100,max=100)
    bPawnRapidFireAnim=true
	Load=1

    FireAnim=fire
    FireEndAnim=None
    FireLoopAnim=None
    FireAnimRate=1.0
	ReloadAnim=reload
	ReloadAnimRate=1.0

    FlashEmitterClass=class'gbxEffects.MuzzleFlashM1_'

	FireSoundName="W_SPRINGFIELD.FIRE"
	StereoFireSoundName="W_SPRINGFIELD.FIRE_ST"
    //FireSound=Sound'WeaponSounds.AssaultRifle.AssaultRifleFire'
    FireForce="AssaultRifleFire"   // jdf

	PreFireTime=0.0
	FireRateSP=1.3125
	FireRateMP=1.3125
    AIFireRateSP=1.0
	AIFireRateMP=1.0
	
    bModeExclusive=true

	SuppressionMultiplierSP=1.25
	SuppressionMultiplierMP=10

    AimErrorMin_Human=200
	AimErrorMax_Human_Crouched=250	
	AimErrorMax_Human_Standing=450
	AimErrorMax_Human_MovingSlow=1100
	AimErrorMax_Human_MovingFast=1300
	AimErrorMin_Human_Zoomed=0
	AimErrorMax_Human_Zoomed=30

	AimErrorMin_AI_MP=200
	AimErrorMax_AI_MP_Crouched=250
	AimErrorMax_AI_MP_Standing=450
	AimErrorMax_AI_MP_Moving=1200
	AimMultiplier_AI_MP_Sighted=0.0

	AimErrorMin_AI_SP=200
	AimErrorMax_AI_SP_Crouched=250
	AimErrorMax_AI_SP_Standing=450
	AimErrorMax_AI_SP_Moving=1200
	AimMultiplier_AI_SP_Sighted=0.0

    ShakeOffsetMag=(X=0.0,Y=0.0,Z=0.0)
    ShakeOffsetRate=(X=1000.0,Y=1000.0,Z=1000.0)
    ShakeOffsetTime=2
    ShakeRotMag=(X=10.0,Y=10.0,Z=10.0)
    ShakeRotRate=(X=10000.0,Y=10000.0,Z=10000.0)
    ShakeRotTime=2

    TweenTime = 0.0

	bWaitForRelease=true

	// Burst count levels.
	Burst_High_SP=(Min=1,Max=3)
	Burst_High_MP=(Min=1,Max=3)
	Burst_Low_SP=(Min=4,Max=8)
	Burst_Low_MP=(Min=4,Max=8)

	// This really sucks, but constants are supported here, so I'm just setting this to the value of the constant.
	FireType=1

    TraceRange=30000
	ShotCountMod=0

	ReloadAnimList[0]=reload
	ReloadAnimList[1]=reload_01
	ReloadAnimList[2]=reload_02
	ReloadAnimList[3]=reload_03
	ReloadAnimList[4]=reload_04

	LastShotFireAnim=fire_last
	LastShotFireRate=0.3
}
//=============================================================================
// US Stuart tank 30 cal. machine gun fire mode class.
//=============================================================================
class FireUSStuart30cal extends InstantFire;



//---------------------------------------------------------
//	Variables
//---------------------------------------------------------
var Rotator		AimRot;		// Direction the weapon was aimed at.

//---------------------------------------------------------
//	PostNetBeginPlay
//---------------------------------------------------------
function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();

	// GBX:naj - spawning the muzzle flash is required here to avoid it flashing the first time you mount the weapon.
	if ( FlashEmitter == None && FlashEmitterClass != None )
    {
		FlashEmitter = Spawn(FlashEmitterClass);
		gbxMuzzleFlash( FlashEmitter ).InitializeMuzzleFlash();
    }
}

//---------------------------------------------------------
//	PlayFiring
//---------------------------------------------------------
function PlayFiring()
{
	if ( Instigator.Weapon.IsA( 'WeapUSStuart30cal' ) )
	{
		WeapUSStuart30cal( Instigator.Weapon ).PlayFiringAnim();
	}

	ClientPlayForceFeedback(FireForce);
}

//---------------------------------------------------------
//	PlayReloading
//---------------------------------------------------------
simulated function PlayReloading()
{
	local bool bKeepFiring;

	bKeepFiring = bIsFiring;

	Weapon.ClientStopFire(0);
	Weapon.ReloadClip();

	if ( bKeepFiring )
		gbxWeapon( Weapon ).StartFiringWeapon();
}

simulated function bool ReadyToFire()
{
	return AllowFire();
}

//---------------------------------------------------------
//	AllowFire
//---------------------------------------------------------
simulated function bool AllowFire()
{
	if (Weapon.IsA('gbxWeapon') && Instigator.Controller.bIsHumanPlayer)
	{
		if (gbxWeapon(Weapon).bAimingAtFriendly)
		{
			return false;
		}
	}

	return Super.AllowFire();
}

//---------------------------------------------------------
//	GetMuzzleFlash
//---------------------------------------------------------
simulated function Emitter GetMuzzleFlash()
{
	local Vector X,Y,Z;
	local AttachmentUSStuart30cal Attachment;

	GetAxes( Weapon.Rotation, X,Y,Z);

	if ( ((FlashEmitter == None) || FlashEmitter.bDeleteMe) && FlashEmitterClass != None )
    {
		Attachment = WeapUSStuart30cal( Weapon ).GetAttachment();
		if ( Attachment == None )
			return None;

        FlashEmitter = Spawn(FlashEmitterClass);
		FlashEmitter.SetLocation( Weapon.Location + Attachment.MuzzleOffset.X*X + Attachment.MuzzleOffset.Y*Y + Attachment.MuzzleOffset.Z*Z );
		FlashEmitter.SetRotation( Weapon.Rotation );
		FlashEmitter.SetBase( Weapon );		

		gbxMuzzleFlash( FlashEmitter ).InitializeMuzzleFlash();
    }

	FlashEmitter.Instigator = Self.Instigator;
	return FlashEmitter;
}

//---------------------------------------------------------
//	StartFiringWeapon
//---------------------------------------------------------
function StartFiringWeapon()
{
	if ( FlashEmitter != None && FlashEmitter.IsA( 'gbxMuzzleFlash' ) )
		gbxMuzzleFlash( FlashEmitter ).FireButtonPressed();
}

//---------------------------------------------------------
//	StopFiringWeapon
//---------------------------------------------------------
function StopFiringWeapon()
{
	if ( FlashEmitter != None && FlashEmitter.IsA( 'gbxMuzzleFlash' ) )
		gbxMuzzleFlash( FlashEmitter ).FireButtonReleased();
}

//---------------------------------------------------------
//	GetBestBurstLength
//---------------------------------------------------------
function GetBestBurstLength( ESuppressionLevel SuppressionLevel, out float MinLen, out float MaxLen )
{
	switch ( SuppressionLevel )
	{
	case SL_UNSUPPRESSED:
		MinLen = BurstLength_Low.Min;
		MaxLen = BurstLength_Low.Max;
		break;
	case SL_SUPPRESSED:
		MinLen = BurstLength_High.Min;
		MaxLen = BurstLength_High.Max;
		break;
	}
}

//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
    AmmoClass=class'AmmoUSStuart30cal'
    AmmoPerFire=1
    DamageType=class'DamageUSM1_'
	Damage_Human_SP=(min=90,max=120)
	Damage_Human_MP=(min=90,max=120)
	Damage_AI_SP=(min=90,max=120)
	Damage_AI_MP=(min=90,max=120)
    bPawnRapidFireAnim=true
	Load=1

	FireAnim=Fire
    FireEndAnim=None
    FireLoopAnim=None
	ReloadAnim=None

	FlashEmitterClass=class'gbxEffects.MuzzleFlash30cal'

    FireForce="MachineGunFire"   // jdf

	PreFireTime=0.0
	FireRateSP=0.12  // 500 rounds per minute
	FireRateMP=0.12  // 500 rounds per minute
    AIFireRateSP=0.07
	AIFireRateMP=0.07
    bModeExclusive=true

	SuppressionMultiplierSP=1.5

	TraceRange=15000

	bWaitForRelease=false

	ShakeOffsetMag=(X=1.0,Y=1.0,Z=1.0)
    ShakeOffsetRate=(X=1000.0,Y=1000.0,Z=1000.0)
    ShakeOffsetTime=2
    ShakeRotMag=(X=50.0,Y=50.0,Z=50.0)
    ShakeRotRate=(X=10000.0,Y=10000.0,Z=10000.0)
    ShakeRotTime=2

	// This really sucks, but constants are supported here, so I'm just setting this to the value of the constant.
	FireType=1

	ShotCountMod=3
}
class FireUSThompson extends FireSubMachineGun;

var Emitter	ViewFlashEmitter;
var class<Emitter> ViewFlashEmitterClass;

/// SJP: The thompson muzzle flash doesn't work very well in first person, so provide an alternative here
simulated function Emitter GetMuzzleFlash()
{
	if ( Instigator.IsFirstPerson() )
    {
		if ( ( ViewFlashEmitter == None || ViewFlashEmitter.bDeleteMe ) && ViewFlashEmitterClass != None )
		{
			ViewFlashEmitter = Spawn(ViewFlashEmitterClass);
			log("Spawned "$ViewFlashEmitter, 'weapon');
		}

		return ViewFlashEmitter;
    }
	else
	{
		return Super.GetMuzzleFlash();
	}
}

defaultproperties
{
    AmmoClass=class'AmmoUSThompson'
    AmmoPerFire=1
    DamageType=class'DamageUSThompson'
    //DamageMin=35
    //DamageMax=40
	Damage_Human_SP=(min=35,max=45)
	Damage_Human_MP=(min=30,max=30)
	Damage_AI_SP=(min=25,max=30)
	Damage_AI_MP=(min=30,max=30)
    bPawnRapidFireAnim=true
	Load=1

    FireAnim=fire
    FireEndAnim=None
    FireLoopAnim=None
    FireAnimRate=1.0
	ReloadAnim=reload
	ReloadAnimRate=1.0
    FlashEmitterClass=class'gbxEffects.MuzzleFlashThompson'
	ViewFlashEmitterClass=class'gbxEffects.MuzzleFlashThompsonView'

	// One off sounds
	FireSoundName="W_THOMPSON.FIRE"
	
	// Loops
	FireLoopSoundName="W_THOMPSON.FIRELOOP"
	StereoFireLoopSoundName="W_THOMPSON.FIRELOOPA_ST"
	FireEndLoopSoundName="W_THOMPSON.FIRELOOPEND"
	StereoFireEndLoopSoundName="W_THOMPSON.FIRELOOPAEND_ST"
	

    FireForce="SubMachineGunFire"   // jdf

	PreFireTime=0.0
    FireRateSP=0.091	// 660 rpm (Thompson was rated at 600-725 rpm)
	FireRateMP=0.091	// 660 rpm (Thompson was rated at 600-725 rpm)
    AIFireRateSP=0.091
	AIFireRateMP=0.091
    bModeExclusive=true

    SuppressionMultiplierSP=0.5
	SuppressionMultiplierMP=0.5

	AimErrorMin_Human=750
	AimErrorMax_Human_Crouched=1000
	AimErrorMax_Human_Standing=1000
	AimErrorMax_Human_MovingSlow=1300
	AimErrorMax_Human_MovingFast=1400
	AimErrorMin_Human_Zoomed=350
	AimErrorMax_Human_Zoomed=1300
	AimErrorMin_Human_FirstShot=100
	AimErrorMax_Human_FirstShot=300

	AimErrorMin_AI_MP=750
	AimErrorMax_AI_MP_Crouched=1000
	AimErrorMax_AI_MP_Standing=1000
	AimErrorMax_AI_MP_Moving=1400
	AimMultiplier_AI_MP_Sighted=1.0

	AimErrorMin_AI_SP=750
	AimErrorMax_AI_SP_Crouched=1000
	AimErrorMax_AI_SP_Standing=1000
	AimErrorMax_AI_SP_Moving=1400
	AimMultiplier_AI_SP_Sighted=0.8

    ShakeOffsetMag=(X=0.0,Y=0.0,Z=0.0)
    ShakeOffsetRate=(X=1000.0,Y=1000.0,Z=1000.0)
    ShakeOffsetTime=2
    ShakeRotMag=(X=50.0,Y=50.0,Z=50.0)
    ShakeRotRate=(X=10000.0,Y=10000.0,Z=10000.0)
    ShakeRotTime=2

    TweenTime = 0.01

	bWaitForRelease=false

	// Burst count levels.
	Burst_High_SP=(Min=2,Max=5)
	Burst_High_MP=(Min=5,Max=15)
	Burst_Low_SP=(Min=5,Max=10)
	Burst_Low_MP=(Min=5,Max=15)
	Burst_Op_SP=(Min=5,Max=10)
	Burst_Op_MP=(Min=7,Max=20)

	ShotCountMod=3

	m_flRandomBurstRange=0.0

	// This really sucks, but constants are supported here, so I'm just setting this to the value of the constant.
	FireType=1
	
	bAccurateFirstShot=true
	
	MinFireLoopSustainTime = 0.08
}
class FlakvierlingBrokenTurret extends Actor;

var Actor  MyBase;  

simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();
	
	SetStaticMesh(StaticMesh(DynamicLoadObject("s_military_de.Weapon.flakvierling_dmg_gun", class'StaticMesh')));
}

function Tick(float	DeltaTime)
{
	local float dist;

	Super.Tick(DeltaTime);

	if (MyBase != None)
	{
		//NAC: We need to make sure that top half isn't separated from the bottom half of this broken gun.  If they are too far separated, set to PHYS_Falling
		dist = VSizeSquared(MyBase.Location - Self.Location);
		if (dist > 1.0) 
		{
			SetBase(MyBase);
			SetPhysics(PHYS_Falling);
		}
	}
}

function SetFlakBase(Actor NewBase)
{
	//we get signal
	MyBase = NewBase;  //all NewBase are belong to us!
}

defaultproperties
{
	Physics=PHYS_Falling
	bCollideActors=true
	bCollideWorld=true
	bBlockActors=true
	bBlockPlayers=true
	CollisionRadius=1
	CollisionHeight=1
	DrawType=DT_StaticMesh
//	StaticMesh=StaticMesh's_military_de.Weapon.flakvierling_dmg_gun'
	bHidden=false
}class FlakvierlingFactory extends Actor
	placeable;


//---------------------------------------------------------
// Variables
//---------------------------------------------------------
var		WeapDEFlakvierling		Gun;
var()	Name					GunnerToDraft, LeftLoaderToDraft, RightLoaderToDraft;
var()	Name					DeathEvent;
var()	float					EnemyTooCloseDist;
var()	bool					bAllowTNT;
var()	bool					RecruitImmediately;

//---------------------------------------------------------
//	SpawnGun
//---------------------------------------------------------
function SpawnGun()
{
	Gun = Spawn( class'WeapDEFlakvierling', Self );
}

//---------------------------------------------------------
//	PostNetBeginPlay
//---------------------------------------------------------
function PostBeginPlay()
{
	local TNTTrigger aTNTTrigger;

	SpawnGun();

	Gun.GunnerToDraft = GunnerToDraft;
	Gun.LeftLoaderToDraft = LeftLoaderToDraft;
	Gun.RightLoaderToDraft = RightLoaderToDraft;
	Gun.EnemyTooCloseDist = EnemyTooCloseDist;
	Gun.bDontRecruit = !RecruitImmediately;
	Gun.Tag = Self.Tag;
	Gun.DeathEvent = DeathEvent;

	if ( bAllowTNT )
	{
		aTNTTrigger = Spawn( class'TNTTrigger', Gun );
		aTNTTrigger.SetCollisionSize( Self.CollisionRadius, aTNTTrigger.CollisionHeight );
		aTNTTrigger.m_aUseTarget = Gun;
		aTNTTrigger.SetBase(Self);
		aTNTTrigger.SetCollision(true, false, false);
		aTNTTrigger.SetAttachedTurret( Gun );

		Gun.MyTNTTrigger = aTNTTrigger;
	}
}

//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
	DrawType=DT_Mesh
//	Mesh=k_prop.de_flakv
	EditorMeshName="k_prop.de_flakv"
	bHidden=true
	EnemyTooCloseDist=1000.0
	CollisionRadius=300.0
	bAllowTNT=true
	RecruitImmediately=true

	bOpaqueForSituationalAwarenessView=true

	bAlphaFogable=True
    bAlphaFogBlend=true
}
class FlakVReloadCallback extends PawnAnimExtra;

static function bool EndAnim( AnimPawn aPawn, bool fNoStart, bool fInterrupt )
{
	if ( gbxPawn( aPawn ).Turret != None )
	{
		gbxPawn( aPawn ).Turret.ReloadFinished();
		return true;
	}

	return false;
}class gbxDummyObject extends Actor;


simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();
	
	//SetStaticMesh(StaticMesh(DynamicLoadObject("s_military_de.Weapon.mortar_round", class'StaticMesh')));
}



simulated function Tick(float DeltaTime)
{
	Super.Tick( DeltaTime );

}

simulated function Timer()
{
	Super.Timer();
	SetPhysics( PHYS_None );
}


defaultproperties
{

	Physics=PHYS_None
	DrawScale=1.00000
    bCollideWorld=true
	bFixedRotationDir=True
	DrawType=DT_STATICMESH
}//=============================================================================
// Base class for all grenades
//=============================================================================
class gbxGammonBomb extends gbxExplosive
	placeable;

simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();
	
	SetStaticMesh(StaticMesh(DynamicLoadObject("s_npc_item_us.equipment.radio", class'StaticMesh')));
}

function bool DisplayContextMessage(gbxPlayerController PlayerController); // stubs for MP
function ClearContextMessage(gbxPlayerController PlayerController);

simulated function ProcessTouch(Actor Other, Vector HitLocation)
{
}

simulated function HitWall (vector HitLocation, vector HitNormal, actor Wall)
{
}

function bool ActivateBomb( Pawn User )
{
	StartExplosionTimer();
	return true;
}

function Trigger(actor Other, pawn EventInstigator)
{
	local gbxPlayerController	aController;
	
	//Log( self$ " gbxGammonBomb::Trigger() Other: " $Other, 'PSV');

	aController = gbxPlayerController(EventInstigator.Controller);
	if (aController != None)
	{
		//Log( self$ " gbxGammonBomb::Trigger() EventInstigator.Weapon" $EventInstigator.Weapon, 'PSV');
		if (gbxWeapon(EventInstigator.Weapon) != None)
		{
			//Log( self$ " gbxGammonBomb::Trigger() Calling PlantBombOnTarget()!", 'PSV');
			aController.PlantBombOnTarget( self );
		}
	}
	else
	{
		super.Trigger(Other,EventInstigator);

		//Log( self$ " gbxGammonBomb::Trigger() Calling StartExplosionTimer()!", 'PSV');

		StartExplosionTimer();
	}
}

defaultproperties
{
	ExplosionDecal=class'BlastMark'
	MyDamageType=class'DamageGammonBomb'
	speed=1000.000000
	MaxSpeed=1500.000000
	Damage=500.000000
	//DamageRadius=768.000000
	DamageRadius=375.000000	// GBX:naj - modified 4/5/04
	MomentumTransfer=50000
	//Mass=050.000
	Physics=PHYS_None
//	StaticMesh=StaticMesh's_npc_item_us.equipment.radio'
	DrawScale=1.00000
	AmbientGlow=64
	bBounce=True
	bFixedRotationDir=True
	DesiredRotation=(Pitch=12000,Yaw=5666,Roll=2334)
	DrawType=DT_STATICMESH
	Style=STY_Modulated

    ShakeRadius=2000.000000
	ViewRollTime=0.200000
	RollMag=20.000000
	RollRate=100.000000
	OffsetMagVertical=20.000000
	OffsetRateVertical=800.000000
	OffsetMagHorizontal=20.000000
	OffsetRateHorizontal=800.000000
	OffsetIterations=10.000000

	bBlowingUp=false

	FuseTimeMin=5.0
	FuseTimeMax=5.0

	HeavyTraumaRadius=384.0

    CollisionRadius=+005.000000
	CollisionHeight=+020.000000
	bCollideWhenPlacing=false

	LifeSpan=+0.000000

	bUnlit=false
	LightType=LT_None
}
class gbxHeavyBreatheProfile extends gbxBreatheProfile;

defaultproperties
{
	// Xbox settings
	//BreathePitchAdjustRate=(Min=125.0,Max=425.0)
	//BreatheYawAdjustRate=(Min=100.0,Max=250.0)
	//BreatheYawLimit=(Min=75.0,Max=150.0)
	//BreatheAttenAccel=(Min=0.2,Max=0.3)
	//BreatheAttenDecel=(Min=0.8,Max=0.6)

	// PC settings
	BreathePitchAdjustRate=(Min=200.0,Max=475.0)
	BreatheYawAdjustRate=(Min=100.00,Max=300.0)
	BreatheYawLimit=(Min=75.0,Max=150.0)
	BreatheAttenAccel=(Min=0.2,Max=0.3)
	BreatheAttenDecel=(Min=0.8,Max=0.6)
}class gbxLightBreatheProfile extends gbxBreatheProfile;

defaultproperties
{
	// Xbox settings
	//BreathePitchAdjustRate=(Min=75.00,Max=375.0)
	//BreatheYawAdjustRate=(Min=50.00,Max=150.0)
	//BreatheYawLimit=(Min=50.0,Max=100.0)
	//BreatheAttenAccel=(Min=0.1,Max=0.2)
	//BreatheAttenDecel=(Min=0.9,Max=0.7)

	// PC settings
	BreathePitchAdjustRate=(Min=150.00,Max=450.0)
	BreatheYawAdjustRate=(Min=100.00,Max=250.0)
	BreatheYawLimit=(Min=75.0,Max=150.0)
	BreatheAttenAccel=(Min=0.2,Max=0.3)
	BreatheAttenDecel=(Min=0.8,Max=0.6)
}class gbxMachineGunShells extends gbxWeaponShells;


defaultproperties
{
    Begin Object Class=MeshEmitter Name=MeshEmitter3
		SecondsBeforeInactive=0
        // GBX:najnaj
		// StaticMesh=StaticMesh's_military_us.Weapon.m1_shell'
        Acceleration=(Z=-900.000000)
        UseCollision=True
        //DampingFactorRange=(X=(Min=0.700000,Max=0.700000),Y=(Min=0.700000,Max=0.700000),Z=(Min=0.700000,Max=0.700000))
		DampingFactorRange=(X=(Min=0.200000,Max=0.200000),Y=(Min=0.200000,Max=0.200000),Z=(Min=0.200000,Max=0.200000))
        MaxParticles=40
        UseRotationFrom=PTRS_Offset
		SpinParticles=True
        SpinsPerSecondRange=(X=(Min=-1.000000,Max=4.000000),Y=(Min=-2.000000,Max=2.000000),Z=(Min=-1.000000,Max=2.000000))
        DampRotation=True
        //RotationDampingFactorRange=(X=(Min=0.700000,Max=0.700000),Y=(Min=0.700000,Max=0.700000),Z=(Min=0.700000,Max=0.700000))
		RotationDampingFactorRange=(X=(Min=0.200000,Max=0.200000),Y=(Min=0.200000,Max=0.200000),Z=(Min=0.200000,Max=0.200000))
		StartSizeRange=(X=(Min=0.200000,Max=0.200000),Y=(Min=0.200000,Max=0.200000),Z=(Min=0.200000,Max=0.200000))
		AutomaticInitialSpawning=False
        ParticlesPerSecond=0.000000
        InitialParticlesPerSecond=0.000000
        //LifetimeRange=(Min=2.000000,Max=2.000000)
		LifetimeRange=(Min=1.000000,Max=1.000000)
		RespawnDeadParticles=False
        StartVelocityRange=(X=(Min=-100.000000,Max=100.000000),Y=(Min=20.000000,Max=100.000000),Z=(Min=100.000000,Max=200.000000))
		StartLocationOffset=(X=20,Y=20,Z=10)
    End Object

    Emitters(0)=MeshEmitter'MeshEmitter3'
}
class gbxMediumBreatheProfile extends gbxBreatheProfile;

defaultproperties
{
	// Xbox settings
	//BreathePitchAdjustRate=(Min=100.0,Max=400.0)
	//BreatheYawAdjustRate=(Min=75.00,Max=200.0)
	//BreatheYawLimit=(Min=65.0,Max=125.0)
	//BreatheAttenAccel=(Min=0.1,Max=0.2)
	//BreatheAttenDecel=(Min=0.8,Max=0.7)

	// PC settings
	BreathePitchAdjustRate=(Min=200.0,Max=450.0)
	BreatheYawAdjustRate=(Min=100.00,Max=275.0)
	BreatheYawLimit=(Min=75.0,Max=150.0)
	BreatheAttenAccel=(Min=0.2,Max=0.3)
	BreatheAttenDecel=(Min=0.8,Max=0.6)
}class gbxMortarShell extends gbxExplosive;


const BAZOOKA_ROCKET_BURN_DIST=11520;

var Vector	FireVector;
var bool	bHitWater;
var bool	bActive;
var bool	bSoundStarted;
var vector	Dir, TargetLoc;
var float	m_flLaunchTime;
var float	m_flTravelDist;
var float	TimeBeforeDropToPlaySound;
var Cue		MortarFlightSound;

var float	ShellDelay;

simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();
	
	SetStaticMesh(StaticMesh(DynamicLoadObject("s_military_de.Weapon.mortar_round", class'StaticMesh')));
}

simulated function BeginPlay()
{
	if ( (Level.DetailMode != DM_Low) && !Level.bDropDetail )
		SmokeRate = 0.03;
	else
		SmokeRate = 0.15;
}

simulated function PhysicsVolumeChange( PhysicsVolume NewVolume )
{
	if ( !NewVolume.bWaterVolume || bHitWater )
		return;

	bHitWater = True;
	Spawn(class'WaterSplashLarge',,,,rot(16384,0,0));			//-BB
	Velocity=0.6*Velocity;
}

simulated function ProcessTouch( actor Other, vector HitLocation )
{
	if (!bActive)
		return;

	if ( Other!=instigator )
	{
		Explosion(HitLocation);
		bActive = false;
	}
}

simulated function HitWall( vector HitLocation, vector HitNormal, actor Wall )
{
	local Projector Decal;

	if (!bActive)
		return;

	Velocity = Vect( 0, 0, 0 );
	
	if ( Role == ROLE_Authority )
	{
		if ( Mover(Wall) != None )
			Wall.TakeDamage( Damage, instigator, Location, MomentumTransfer * Normal(Velocity), MyDamageType);

		MakeNoise(1.0);
	}

	Explosion(Location + ExploWallOut * HitNormal);

	if ( (ExplosionDecal != None) && (Level.NetMode != NM_DedicatedServer) )
	{
		Decal = Spawn(ExplosionDecal,self,,Location, rotator(-HitNormal));
	}
}

function ServerExplosion(vector HitLocation)
{
	Explosion( HitLocation );
}

simulated function Destroyed()
{
	Super.Destroyed();
}

simulated function Tick(float DeltaTime)
{
	Super.Tick( DeltaTime );
	
	m_flTravelDist = m_flTravelDist + VSize( Velocity * DeltaTime );
	if (m_flTravelDist > BAZOOKA_ROCKET_BURN_DIST)
	{
		Velocity.X = Velocity.X * (1.0f - (0.1 * DeltaTime));
		Velocity.Y = Velocity.Y * (1.0f - (0.1 * DeltaTime));
	}
	Velocity.Z = Velocity.Z - (150 * DeltaTime);
}

simulated function Timer()
{
	Super.Timer();
	// Make the shell disappear and go dormant until notified to teleport.
	Velocity = Vect(0,0,0);
	SetPhysics( PHYS_None );
	//bHidden = true;
}

function Launch( Vector NewTargetLoc, float NewShellDelay )
{
	Dir = vector(Rotation);
	Velocity = speed * Dir;
	if (PhysicsVolume.bWaterVolume)
	{
		bHitWater = True;
		Velocity=0.6*Velocity;
	}
	bActive = true;

	m_flLaunchTime = Level.TimeSeconds;

	TargetLoc = NewTargetLoc;
	ShellDelay = NewShellDelay;
	GotoState( 'Ascending' );
}

//=========================================================
//	State Ascending
//=========================================================
state Ascending 
{
	function BeginState()
	{
		SetTimer( 0.25, false );
	}

	function Timer()
	{
		Super.Timer();
		GotoState( 'WaitingForDrop' );
	}
}

//=========================================================
//	State Waiting
//=========================================================
state WaitingForDrop
{
	function BeginState()
	{
		bHidden = true;
		SetPhysics( PHYS_None );
		Velocity = Vect(0,0,0);
		
		if ( TimeBeforeDropToPlaySound < ShellDelay )
		{
			SetTimer( ShellDelay - TimeBeforeDropToPlaySound, false );			
		}
		else
		{
			bSoundStarted = true;
			PlayOwnedSoundCue( MortarFlightSound, SLOT_None );
			SetTimer( ShellDelay, false );			
		}
	}

	function Timer()
	{
		local Rotator NewRot;
		Super.Timer();
		//DHW+ -- Removed line as it was causing mortar shells to re-appear mid-air.
		//bHidden = false;
		//DHW-

		if ( bSoundStarted )
		{
			NewRot = Rotation;
			NewRot.Pitch = ( NewRot.Pitch - 2*NewRot.Pitch ) & 65535;
			SetRotation( NewRot );
			SetLocation( TargetLoc - 2000*Vector( NewRot ) );		
			SetPhysics( PHYS_Projectile );
			Velocity = speed * Vector( NewRot );
			bHidden = false;					
			GotoState( '' );
		}
		else
		{
			bSoundStarted = true;
			PlaySoundCue( MortarFlightSound, SLOT_None );
			SetTimer( TimeBeforeDropToPlaySound, false );
		}
	}
}

defaultproperties
{
	ExplosionDecal=class'BlastMark'
	MyDamageType=class'DamageUSBazooka'
    speed=6000.0
	MaxSpeed=6000.000000
	Damage=500.000000
    RemoteRole=ROLE_SimulatedProxy
    LifeSpan=30.0
	DamageRadius=375.000000	// GBX:naj - modified 4/5/04
	MomentumTransfer=50000
	Physics=PHYS_Projectile
//	StaticMesh=StaticMesh's_military_de.Weapon.mortar_round'
	DrawScale=1.00000
	AmbientGlow=64
	bBounce=false
    bCollideWorld=true
	bFixedRotationDir=True
	DrawType=DT_STATICMESH

    ShakeRadius=2000.000000
	ViewRollTime=0.200000
	RollMag=20.000000
	RollRate=100.000000
	OffsetMagVertical=20.000000
	OffsetRateVertical=800.000000
	OffsetMagHorizontal=20.000000
	OffsetRateHorizontal=800.000000
	OffsetIterations=10.000000

	bBlowingUp=false

	FuseTimeMin=5.0
	FuseTimeMax=6.0

	HeavyTraumaRadius=384.0
	TimeBeforeDropToPlaySound=2.75
	WeaponCategory=WC_Mortar

	bActive=false
	bDestroyWhenDone=true
}class gbxPistolBreatheProfile extends gbxBreatheProfile;

defaultproperties
{
	BreathePitchAdjustRate=(Min=50.00,Max=325.0)
	BreatheYawAdjustRate=(Min=25.00,Max=100.0)
	BreatheYawLimit=(Min=35.0,Max=75.00)
	BreatheAttenAccel=(Min=0.1,Max=0.1)
	BreatheAttenDecel=(Min=0.9,Max=0.8)
}//=============================================================================
// Base class for all grenades
//=============================================================================
class gbxProjectile extends gbxExplosive;

const GUIDE_DELAY_TIME = 0.1f;
var Actor	m_aGuideTarget;
var float	m_flNextGuideTime;
class gbxSniperBreatheProfile extends gbxBreatheProfile;

defaultproperties
{
	BreathePitchAdjustRate=(Min=0.0,Max=75.0)
	BreatheYawAdjustRate=(Min=0.00,Max=0.0)
	BreatheYawLimit=(Min=0.0,Max=0.0)
	BreatheAttenAccel=(Min=0.1,Max=0.2)
	BreatheAttenDecel=(Min=0.8,Max=0.7)
}class gbxSupportedBreatheProfile extends gbxBreatheProfile;

defaultproperties
{
	BreathePitchAdjustRate=(Min=25.0,Max=50.0)
	BreatheYawAdjustRate=(Min=25.0,Max=50.0)
	BreatheYawLimit=(Min=25.0,Max=50.0)
	BreatheAttenAccel=(Min=0.2,Max=0.6)
	BreatheAttenDecel=(Min=0.6,Max=0.6)
}//=============================================================================
// Base class for all grenades
//=============================================================================
class gbxTankShell extends gbxExplosive;


var Vector	FireVector;
var bool	bHitWater;
var bool	bActive;
var vector Dir;

//var	TankShellTrail trail;

var class<Projector> ExplosionDecalVehicle;


simulated function PostNetBeginPlay()
{
	Dir = vector(Rotation);
	Velocity = speed * Dir;
	if (PhysicsVolume.bWaterVolume)
	{
		bHitWater = True;
		Velocity=0.6*Velocity;
	}
	bActive = true;

//	if (ROLE != ROLE_Authority)
//	{
//		Trail = Spawn(class'TankShellTrail ',self);
//		Trail.SetBase(Self);
//	}
	
	Super.PostNetBeginPlay();

	SetStaticMesh(StaticMesh(DynamicLoadObject("s_military_us.tank_round_stuart", class'StaticMesh')));
}

simulated function BeginPlay()
{
	if ( (Level.DetailMode != DM_Low) && !Level.bDropDetail )
		SmokeRate = 0.03;
	else
		SmokeRate = 0.15;
}

simulated function PhysicsVolumeChange( PhysicsVolume NewVolume )
{
	if ( !NewVolume.bWaterVolume || bHitWater )
		return;

	bHitWater = True;
	Spawn(class'WaterSplashLarge',,,,rot(16384,0,0));			//-BB
	Velocity=0.6*Velocity;
}

simulated function ProcessTouch( actor Other, vector HitLocation )
{
	if (!bActive)
		return;

	if (Other != instigator)
	{
		Explosion(HitLocation);

		bActive = false;
	}
}

simulated function HitWall( vector HitLocation, vector HitNormal, actor Wall )
{
	local Projector Decal;
	local ProjectorRelative DecalRelative;
	local vector vHit, TraceEnd;
	local float Length;

	if (!bActive)
		return;

	Velocity = Vect( 0, 0, 0 );

	vHit = HitLocation - Location;
	Length = VSize(vHit);
	vHit = Normal(vHit);

	TraceEnd = Location + (vHit * (Length + 1.0f));

	if (TraceHitBackDrop(TraceEnd, Location))
	{
		Destroy();
		return;
	}

	if ( Role == ROLE_Authority )
	{
		if ( Mover(Wall) != None )
			Wall.TakeDamage( Damage, instigator, Location, MomentumTransfer * Normal(Velocity), MyDamageType);

		MakeNoise(1.0);
	}

	Explosion(Location + ExploWallOut * HitNormal);

	if (Wall.IsA('gbxSVehicle'))
	{
		if ( (ExplosionDecalVehicle != None) && (Level.NetMode != NM_DedicatedServer) )
		{
			Decal = Spawn(ExplosionDecalVehicle,self,,Location + HitNormal, rotator(-HitNormal));
			DecalRelative = ProjectorRelative(Decal);
			if (DecalRelative != None)
			{
			    DecalRelative.SetRelativeProjector(Wall, Location + HitNormal, rotator(-HitNormal));
			}
		}
	}
	else
	{
		if ( (ExplosionDecal != None) && (Level.NetMode != NM_DedicatedServer) )
		{
			Decal = Spawn(ExplosionDecal,self,,Location + ExploWallOut * HitNormal, rotator(-HitNormal));
		}
	}
}

function ServerExplosion(vector HitLocation)
{
	Explosion( HitLocation );
}

simulated function Explosion(vector HitLocation)
{
	local Controller C;
	local vector OffsetMag, OffsetRate;
	local IImpactManager ImpactMgr;
	local Material FloorMat;
	local Vector HitLoc, HitNormal;
	local ExplosionPhysical MyExplosionPhysical;
	local gbxMessage ExplosionMsg;

	local float AirBurstDistance, BurstDist;

	if ( Level.NetMode != NM_DedicatedServer )
	{
		Trace( HitLoc, HitNormal, HitLocation - Vect(0, 0, 4096), HitLocation, false,, FloorMat );

		AirBurstDistance = VSize(HitLocation - HitLoc);

		// Clear the floor material so the impact manager will understand the explosion as an air burst
		if( AirBurstDistance > AirBurstThreshold )
			FloorMat = None;

		ImpactMgr = class'ImpactManager'.static.GetInstance( Level.Outer, self );
		if (ImpactMgr != None)
			ImpactMgr.HandleExplosionImpact(self, FloorMat,	WeaponCategory, HitLocation, rotator( HitNormal ));

		// shake the players a bit...
		OffsetMag = OffsetMagHorizontal * vect(1,1,0) + OffsetMagVertical * vect(0,0,1);
		OffsetRate = OffsetRateHorizontal * vect(1,1,0) + OffsetRateVertical * vect(0,0,1);
		for ( C=Level.ControllerList; C!=None; C=C.NextController )
		{
			if ( PlayerController(C) != None )
			{
				BurstDist = VSize(Location - PlayerController(C).ViewTarget.Location);

				if( BurstDist < ShakeRadius && BurstDist > HeavyTraumaRadius )
					C.ShakeView(ViewRollTime,RollMag,OffsetMag,RollRate,OffsetRate,OffsetIterations);
			}
		}

		// Create the physical effect. 
		// TODO The physical effect should do most of the above: shake the player, send a message, etc. 
		// All the non-visual, non-unique-to-this-class stuff.
		MyExplosionPhysical = Spawn( class'ExplosionPhysicalGrenade' );

		// Suppress any units in the vicinity.
		ExplosionMsg = new( Level.Outer ) class<gbxMessage>( DynamicLoadObject( ExplosionMessageName, class'Class' ));
		ExplosionMsg.Sender = None; // the shell will already be destroyed by the time this message is processed
		ExplosionMsg.bUseSenderLocation = false;
		ExplosionMsg.bHasLocation = true;
		ExplosionMsg.vLocation = self.Location;
		ExplosionMsg.BroadcastRadius = FMax(1800.0f, DamageRadius * 2.0f);
		ExplosionMsg.Instigator = Instigator;  // store the Pawn that instigated this explosion as the instigator of the gbxMessage

		PostGBXMessage( ExplosionMsg );
	}
	
	if( FloorMat != None )
	{
		DoDamage( HitLocation );
	}
	else
	{
		DoDamage( HitLocation, AirBurstDistance );
	}

	bBlowingUp = true;
	TriggerEvent(Event, self, None);
	if (bDestroyWhenDone)
	{
		Destroy();
	}
}

simulated function Destroyed()
{
//	if ( Trail != None )
//	{
//		Trail.Emitters[0].AutomaticInitialSpawning=False;
//		Trail.Emitters[0].RespawnDeadParticles=false;
//		Trail.Emitters[1].AutomaticInitialSpawning=False;
//		Trail.Emitters[1].RespawnDeadParticles=false;
//		Trail.Emitters[1].ParticlesPerSecond=0;
//		Trail.AutoReset=False;
//		Trail.AutoDestroy=True;
//	}
	
	Super.Destroyed();
}

simulated function HurtRadius( float DamageAmount, float DamageRadius, class<DamageType> DamageType, float Momentum, vector HitLocation )
{
	local actor Victim;
	local float damageScale, victim_dist, dist;
	local vector dir;
	local Pawn SomePawn;

	if( bHurtEntry )
		return;

	bHurtEntry = true;  // prevent recursive HurtRadius loop

	// For tank shells use 'RadiusActors()' instead of 'VisibleCollidingActors()' to slightly damage
	// Pawns that are behind nearby cover...
	foreach RadiusActors( class 'Actor', Victim, DamageRadius, HitLocation )
	{
		// don't let blast damage affect fluid - CollisingActors doesn't really work for them - jag
		if( (Victim != self) && (Victim.Role == ROLE_Authority) )
		{
			SomePawn = Pawn(Victim);

			victim_dist = VSize(Victim.Location - Owner.Location);

			// if Victim is an Infantry Pawn (i.e. not a vehicle)
			if (SomePawn != None)
			{
				// is the victim outside the fade distance of the zone the owner is in?  If so, victim isn't rendered, so don't damage them...
				if (Owner.Region.Zone != None)
				{
					if ((Owner.Region.Zone.DistanceFade.Min > 1.0) && (victim_dist > Owner.Region.Zone.DistanceFade.Min))
					{
						// don't do any damage to this victim...
						continue;
					}
				}
			}

			dir = Victim.Location - HitLocation;
			dist = FMax(1,VSize(dir));
			dir = dir/dist;
			damageScale = 1 - FMax(0,(dist - Victim.CollisionRadius)/DamageRadius);

			if (gbxSVehicle(Victim) == None)  // not a vehicle?
			{
				if (victim_dist > 3500.0)  // special rules if victim is > 3500 units from tank shell owner...
				{
					// only pawns fully exposed beyond 3500 units take any damage...
					if (FastTrace( Victim.Location, HitLocation ))
					{
						damageScale = damageScale * 0.2f;  // pawns beyond 3500 units and fully exposed get 20% damage

						Victim.TakeDamage
						(
							damageScale * DamageAmount,
							Instigator,
							Victim.Location - 0.5 * (Victim.CollisionHeight + Victim.CollisionRadius) * dir,
							(damageScale * Momentum * dir),
							DamageType
						);
					}
				}
				else
				{
					if (FastTrace( Victim.Location, HitLocation ))  // is victim fully exposed to tank shell explosion?
					{
						Victim.TakeDamage
						(
							damageScale * DamageAmount,
							Instigator,
							Victim.Location - 0.5 * (Victim.CollisionHeight + Victim.CollisionRadius) * dir,
							(damageScale * Momentum * dir),
							DamageType
						);
					}
					else  // victim was only partially exposed (or completely hidden), gets 1/2 of blast...
					{
						if (SomePawn != None)
						{
							if (SomePawn.PawnTeam == Team_US)
								damageScale = damageScale * 0.2f;  // US only gets damaged 20% of full amount
							else
								damageScale = damageScale * 0.5f;  // Germans (and TEAM_None) get damaged 50% of full amount
						}
						else
						{
							damageScale = damageScale * 0.5f;  // damage to something other than a Pawn
						}

						Victim.TakeDamage
						(
							damageScale * DamageAmount,
							Instigator,
							Victim.Location - 0.5 * (Victim.CollisionHeight + Victim.CollisionRadius) * dir,
							(damageScale * Momentum * dir),
							DamageType
						);
					}
				}
			}
			else
			{
				Victim.TakeDamage
				(
					damageScale * DamageAmount,
					Instigator,
					Victim.Location - 0.5 * (Victim.CollisionHeight + Victim.CollisionRadius) * dir,
					(damageScale * Momentum * dir),
					DamageType
				);
			}
		}
	}

	bHurtEntry = false;
}


defaultproperties
{
	ExplosionDecal=class'TankProjectileScorch'
	ExplosionDecalVehicle=class'TankProjectileScorchSmall'
	MyDamageType=class'DamageTankCannon'
    Speed=10000.0
	MaxSpeed=15000.000000
	Damage=500.000000
    RemoteRole=ROLE_SimulatedProxy
    LifeSpan=8.0
	DamageRadius=500.000000
	MomentumTransfer=50000
	Physics=PHYS_Projectile
	StaticMesh=StaticMesh's_military_us.tank_round_stuart'
	DrawScale=1.00000
	AmbientGlow=64
	bBounce=false
    bCollideWorld=true
	bFixedRotationDir=True
	DrawType=DT_STATICMESH

	ExplosionMessageName="gbxAI.PerceptionTankShellExplosion"

    ShakeRadius=2000.000000
	ViewRollTime=0.200000
	RollMag=20.000000
	RollRate=100.000000
	OffsetMagVertical=20.000000
	OffsetRateVertical=800.000000
	OffsetMagHorizontal=20.000000
	OffsetRateHorizontal=800.000000
	OffsetIterations=10.000000

	bBlowingUp=false

	FuseTimeMin=5.0
	FuseTimeMax=6.0

	HeavyTraumaRadius=384.0
	
	bActive=false
	bDestroyWhenDone=true

	WeaponCategory=WC_TankShell

	ExploWallOut=2.0
}
class InfantryK98GoreSetup extends GorePackSetup;

defaultproperties
{
	PackGoreTextureNames(0)="t_character_de.grids.infantry_k98"
	PackGoreTextureNames(1)="t_character_de.grids.infantry_k98_leftside"
	PackGoreTextureNames(2)="t_character_de.grids.infantry_k98_leftsidemass"
	PackGoreTextureNames(3)="t_character_de.grids.infantry_k98_rightside"
	PackGoreTextureNames(4)="t_character_de.grids.infantry_k98_rightsidemass"
	PackGoreTextureNames(5)="t_character_de.grids.infantry_k98_legs"
}
class InfantryMP40GoreSetup extends GorePackSetup;

defaultproperties
{
	PackGoreTextureNames(0)="t_character_de.grids.infantry_mp40"
	PackGoreTextureNames(1)="t_character_de.grids.infantry_mp40_leftside"
	PackGoreTextureNames(2)="t_character_de.grids.infantry_mp40_leftsidemass"
	PackGoreTextureNames(3)="t_character_de.grids.infantry_mp40_rightside"
	PackGoreTextureNames(4)="t_character_de.grids.infantry_mp40_rightsidemass"
	PackGoreTextureNames(5)="t_character_de.grids.infantry_mp40_legs"

	PackGoreHandState(1)=(R=1,G=1,B=1)
	PackGoreHandState(3)=(R=1,G=0,B=1)
}
class InstantFire extends WeaponFire
	native;

cpptext
{
	virtual FLOAT MaxRange();
}

var class<DamageType>	DamageType;
var int					TracesPerFire;
var Range				Damage_Human_SP;
var Range				Damage_Human_MP;
var Range				Damage_AI_SP;
var Range				Damage_AI_MP;
var float				TraceRange;
var float				Momentum;
var float				HitEffectProb;
var float				FireTraceBackStep; // Distance to subtract from the start location of a fire trace

// Burst-count min/max values to use when firing; categorized by suppression level (low, med., high).
var Range Burst_High_SP;
var Range Burst_High_MP;
var Range Burst_Low_SP;
var Range Burst_Low_MP;
var Range Burst_Op_SP;
var Range Burst_Op_MP;

var Range BurstLength_High;		// GBX:naj - Deprecate this?
var Range BurstLength_Low;		// GBX:naj - Deprecate this?

var float				m_flRandomBurstRange;

const AMMO_INVENTORY_SHOW_TIME = 3.0;


function float MaxRange()
{
	return TraceRange;
}

event ModeDoFire()
{
	Super.ModeDoFire();

	if (Weapon.ClipAmt <= 0 && !(Instigator.Controller.ReloadAfterWeaponFire()))
	{
		Instigator.ReceiveLocalizedMessage(class'gbxUseKeyHUDMessage', EContextUseType.ReloadWeaponButton);  // display the USE message
	}
	
	if ( Weapon.IsA('gbxWeapon') && gbxWeapon(Weapon).m_fZoomed)
	{
		bWaitForAnim = false;
	}
}

function PlayFiring()
{
	Super.PlayFiring();

	//SJP: Kick the view
	if ( Instigator.Weapon.Ammo[0] != None )
	{
		if( gbxAmmo(Instigator.Weapon.Ammo[0]) != None )
		{
			//gbxAmmo(Instigator.Weapon.Ammo[0]).ApplyKick();
			//gbxWeaponAttachment(gbxWeapon(Instigator.Weapon).ThirdPersonActor).EjectShell( gbxAmmo(Instigator.Weapon.Ammo[0]).AmmoShellClass );
		}

		if (Weapon.ClipAmt <= 0)
		{
			if (gbxWeapon(Weapon) != None)
			{
				gbxWeapon(Weapon).flAmmoFadeTime = AMMO_INVENTORY_SHOW_TIME;
				gbxWeapon(Weapon).flLastAmmoFadeTime = Level.TimeSeconds;
			}
		}

		gbxWeapon(Weapon).flLastFireTime = Level.TimeSeconds;

		if (gbxWeapon(Weapon).m_nAIWeaponBurstCount > 0)
		{
			NextFireTime += (FRand() * m_flRandomBurstRange);
		}
	}
	Weapon.AnimBlendToAlpha( 1, 0.0, 0.0 );	// Reset the breathing animation so it doesn't override the fire animation
	if (gbxWeapon(Weapon) != None)
	{
		gbxWeapon(Weapon).m_fResetBreathe = true;
	}
	
	gbxWeapon(Weapon).m_fPlayingFire = true;
}

function DoFireEffect()
{
	Instigator.MakeNoise(1.0);

	ClientDoFireEffect();
}

function DoBFG()
{
	local gbxPawn aGbxP;
	local Vector Momentum;

	if ( Instigator == None || Instigator.Controller == None )
		return;

	foreach dynamicactors( class'gbxPawn', aGbxP )
	{
		if ( aGbxP.PawnTeam == Instigator.PawnTeam )
			continue;

		if ( Normal( aGbxP.Location - Instigator.Location ) dot Vector( Instigator.Controller.Rotation ) > 0.7071 &&
			VSize( aGbxP.Location - Instigator.Location ) <= 20000.0 )
		{
			Momentum = 5000.0 * Normal( aGbxP.Location - Instigator.Location );
			Momentum.Z += 2000.0;
			aGbxP.Velocity = Momentum;
			aGbxP.TakeDamage( 200, Instigator, aGbxP.Location, Momentum, DamageType );			
		}
	}	
}

simulated function ClientDoFireEffect()
{
    local Vector StartTrace;
    local Rotator Aim;
	local int bSkipDoTrace;
	local bool bIsHumanControlled;

	if ( Level.bWeaponsAreBFG && Instigator.IsHumanControlled() )
	{
		DoBFG();
	}

    // the to-hit trace always starts right in front of the eye
    //StartTrace = Instigator.Location + Instigator.EyePosition();

	// GBX:naj - no it doesn't; it starts from the muzzle
	// unless the pawn is the player.

	// GBX:sjp - well, now the GetMuzzleLocationWorld() handles
	// first person view as well.

	// SDJ 04/30/2004: Part 3 of the "Where the hell does the bullet come from saga".  In multiplayer having the bullet
	//                 originate at the muzzle location is a bad idea since the muzzle location is first/third person view
	//                 dependent.  This was causing clients to be horribly inaccurate since on the server they are technically
	//                 in third person.  So in multiplayer we'll use the old unreal logic for the bullet origin for players.

	// GBX:sjp 12/20/2004 - Screw it; use the eyeposition in first person for both SP and MP.  This fixes several SP bugs.

	// GBX:naj - 5/18/04 - Separated AI and human weapon aim error into different values.
	// GBX:naj - 1/06/05 - Substituted IsHumanControlled() for IsPlayerPawn().  IsPlayerPawn() returns true for all pawns, human- and AI-controlled.


	bIsHumanControlled = Instigator.IsHumanControlled();
	if ( bIsHumanControlled && !Instigator.bIsManningTurret )
	{
		StartTrace = Instigator.Location + Instigator.EyePosition();
	}
	else
	{
		StartTrace = Weapon.GetMuzzleLocationWorld();
	}

	// Get the modified aim rotator based on the weapon aim error (as well as any other error values along the way).
	Aim = AdjustAimNew(StartTrace, bSkipDoTrace);

	if (gbxPawn(Instigator) != None)
		gbxPawn(Instigator).LastAimRotator = Aim;

	if ( bSkipDoTrace != 1 )
	{
		bTraceWater = true;	//-BB
		DoTrace(StartTrace, Aim);
		bTraceWater = false;
	}

	if ( bIsHumanControlled && Instigator.IsA( 'gbxPawn' ) )
	{
		Instigator.Controller.JogFatigue( gbxPawn( Instigator ).FatigueJog_PlayerFiredShot );	
	}
}

native function DoTrace(Vector Start, Rotator Dir, optional out Vector End, optional out Vector EndDir);

function SpawnBeamEffect(Vector Start, Rotator Dir, Vector HitLocation, Vector HitNormal, int ReflectNum)
{
}

simulated function PlayReloading()
{
	local gbxPlayerController gbxPC;

	if (Weapon.ClipAmt >= Weapon.AmmoClipSize){
		gbxWeapon(Weapon).flAmmoFadeTime = AMMO_INVENTORY_SHOW_TIME;  //NAC: added this so that anytime the player presses the reload key, it shows the number of clips available.
		gbxWeapon(Weapon).flLastAmmoFadeTime = Level.TimeSeconds;
		return;
	}

	if (Instigator.IsA('Mind') && Instigator.IsMoving() && Instigator.bIsCrouched)
		return;
		
//	if (gbxWeapon(Weapon).m_fZoomed)
//		gbxWeapon(Weapon).ForceUnzoom();

	gbxWeapon(Weapon).m_fAIWeaponWaitingToFire = false;
	gbxWeapon(Weapon).flAmmoFadeTime = AMMO_INVENTORY_SHOW_TIME;
	gbxWeapon(Weapon).flLastAmmoFadeTime = Level.TimeSeconds;

	gbxPC = gbxPlayerController(Instigator.Controller);

	//DHW + -- Added to prevent player from entering reload anim if he's out of ammo
	if (Weapon.Ammo[0].AmmoAmount <= Weapon.ClipAmt)
	// GBX:PAD: The previous check was preventing partial clips from loading if the gun only had 1 partial clip
	// left.
//	if (Weapon.Ammo[0].AmmoAmount <= 0)
		return;
	//DHW -

	if( gbxWeapon(Weapon).m_fZoomed && gbxPC != None )
	{
		gbxPC.PendingDelayedAction = ReloadAfterZoomOut;
		gbxWeapon(Weapon).ForceUnzoom();
		//gbxPC.ChangeView(0);
	}
	else
	{
		Super.PlayReloading();
	}
}

simulated function FlashMuzzleFlash()
{
	local gbxMuzzleFlash MuzFlash;

	MuzFlash = gbxMuzzleFlash(GetMuzzleFlash());
	MuzFlash.SetLocation(Weapon.Location);
	MuzFlash.Flash();
}

function DrawMuzzleFlash(Canvas Canvas)
{
}

simulated function bool AllowFire()
{
	if( Super.AllowFire() )
	{
		if (Pawn(Weapon.Owner) != None)
		{
			if (Pawn(Weapon.Owner).bIsSprinting)
			{
				Pawn(Weapon.Owner).SetSprinting( false );
			}

			if (Weapon.IsA('gbxWeapon') && Instigator.Controller.bIsHumanPlayer )
			{
				if (gbxWeapon(Weapon).bAimingAtFriendly)
				{
					PlayDryFire();
				}
				return !(gbxWeapon(Weapon).bAimingAtFriendly);
			}
		}

		if ( ShotCountMod > 0 && ShotCount > 0 )
		{
			ShotCount = ( ShotCount + 1 ) % ShotCountMod;
			return true;
		}
		else
		{
			ShotCount = ( ShotCount + 1 ) % ShotCountMod;
			return Instigator.ApproveShot();
		}
	}

	return false;
}


function Rotator GetLastAimRotator()
{
	if (gbxPawn(Instigator) != None)
		return gbxPawn(Instigator).LastAimRotator;
	return Rot(0,0,0);
}

function GetBestBurstCount( ESuppressionLevel SuppressionLevel, out int MinShots, out int MaxShots )
{
	switch ( SuppressionLevel )
	{
	case SL_UNSUPPRESSED:
		if ( !Level.UseMPStyleFatigue() )
		{
			MinShots = Burst_Low_SP.Min;
			MaxShots = Burst_Low_SP.Max;
		}
		else
		{
			MinShots = Burst_Low_MP.Min;
			MaxShots = Burst_Low_MP.Max;
		}
		break;
	case SL_SUPPRESSED:
		if ( !Level.UseMPStyleFatigue() )
		{
			MinShots = Burst_High_SP.Min;
			MaxShots = Burst_High_SP.Max;
		}
		else
		{
			MinShots = Burst_High_MP.Min;
			MaxShots = Burst_High_MP.Max;
		}
		break;
	}
}

function GetOpBurstCount( out int MinShots, out int MaxShots )
{
	if ( !Level.UseMPStyleFatigue() )
	{
		MinShots = Burst_Op_SP.Min;
		MaxShots = Burst_Op_SP.Max;
	}
	else
	{
		MinShots = Burst_Op_MP.Min;
		MaxShots = Burst_Op_MP.Max;
	}
}

function SetInstaKill( bool bInstaKill )
{
	if ( bInstaKill )
	{
		Damage_Human_SP.min=1000;
		Damage_Human_SP.max=1000;
		Damage_Human_MP.min=1000;
		Damage_Human_MP.max=1000;
		Damage_AI_SP.min=1000;
		Damage_AI_SP.max=1000;
		Damage_AI_MP.min=1000;
		Damage_AI_MP.max=1000;
	}
	else
	{
		Damage_Human_SP=Default.Damage_Human_SP;
		Damage_Human_MP=Default.Damage_Human_MP;
		Damage_AI_SP=Default.Damage_AI_SP;
		Damage_AI_MP=Default.Damage_AI_MP;
	}
}

simulated function Tick(float DeltaTime)
{
	local bool bReloadAfterFireAllowed;

	Super.Tick(DeltaTime);

	if (Weapon == None || Instigator == None || Instigator.Controller == None)
		return;
	
	if ( Instigator != None && Instigator.Controller != None )
		bReloadAfterFireAllowed = Instigator.Controller.ReloadAfterWeaponFire();
	else
		bReloadAfterFireAllowed = true;

//	if ( Weapon.Ammo[0] != None && Weapon.IsA( 'gbxWeapon' ) )
//	{
//		if ( bReloadAfterFireAllowed && !Weapon.bDelayReloading && (Weapon.Ammo[0].AmmoAmount > 0) && (Weapon.ClipAmt <= 0) && (Weapon.ClientState != WS_Reloading) && !gbxWeapon(Weapon).m_fPlayingFire)
//		{
//			PlayReloading();
//		}
//	}
}

defaultproperties
{
	Momentum=25000
    TracesPerFire=1	
    TraceRange=10000
//    NoAmmoSound=Sound'WeaponSounds.P1Reload5'
	bInstantHit=true
    AutoAim=0.95
    HitEffectProb=0.75
	FireTraceBackStep=125
	
	m_flRandomBurstRange=0.1
	ShotCountMod=0
}
// This class bridges the gap between gbxBase and gbxInventory packages
// so that clients can get correct 3rd person weapon effects 2004-08-16 JWS
class InstantFireWeaponAttachment extends gbxWeaponAttachment;

var byte OldSpawnHitCount;
var byte LocalSpawnHitCount;

// From UT2k3 2004-08-16 JWS
var vector					mHitNormal;
var material				mHitMaterial;
var bool					mHitWater;
var Actor                   mHitActor;
/* UpdateHit
- used to update properties so hit effect can be spawn client side
*/
simulated event UpdateHit(Actor HitActor, vector HitLocation, vector HitNormal, material HitMaterial, bool HitWater)
{
	LocalSpawnHitCount = SpawnHitCount;
	SpawnHitCount++;
	mHitActor = HitActor;
	mHitLocation = HitLocation;
	mHitNormal = HitNormal;
	mHitMaterial = HitMaterial;
	mHitWater = HitWater;
}

simulated function GetHitInfo()
{
	local vector HitLocation, start;
	start = Instigator.Location + Instigator.EyePosition(); // from InstantFire::ClientDoFireEffect() 2004-08-17 JWS
	
	// have to overshoot the traceend a bit because otherwise the trace doesn't work...
	bTraceWater=true;
	mHitActor=Trace(HitLocation,	// HitLocation
		  mHitNormal,	// HitNormal
		  mHitLocation+(0.1*(mHitLocation-start)),	// TraceEnd
		  start,		// TraceStart
		  true,			// bTraceActors
		  ,				// Extent
		  mHitMaterial, // Material
		  true,			// bTraceCollisionBoxes
		  false);		// bNotifyListeners // client no longer generates his own bullet whiz events 2004-08-21 JWS
	bTraceWater=false;

	if(mHitActor.IsA('WaterVolume'))
		mHitWater=true;
	else
		mHitWater=false;

}

// something very much like this code used to be in InstantFire::DoTrace()
simulated function DoImpactEffects()
{

	local IImpactManager ImpactMgr;
	local vector ImpactLoc;

	ImpactMgr = Level.ImpactMgr;

	if ( ImpactMgr != None && Level.NetMode != NM_DedicatedServer )
	{
		if ( OldSpawnHitCount != SpawnHitCount || LocalSpawnHitCount != SpawnHitCount)
		{
			OldSpawnHitCount = SpawnHitCount;

			// Only the client needs to get hit info and generate bullet whiz sounds here.
			// The server already did this in InstantFire::DoTrace() 2004-08-16 JWS
			if ( Level.NetMode == NM_Client )
			{
				GetHitInfo();
			}

			// offset the impact location slightly to prevent spawning stuff inside walls...
			ImpactLoc = mHitLocation + (mHitNormal * 2.0f);
			
			//NAC:If there is a HitActor, then go ahead and do the bullet impact effects.
			if(mHitActor != None)
			ImpactMgr.HandleBulletImpact(mHitActor, Instigator, mHitMaterial, mHitWater, WC_Rifle, ImpactLoc, rotator(mHitNormal) );
		}
	}
}
class M1919Factory extends MG42Factory;


//---------------------------------------------------------
//	SpawnGun
//---------------------------------------------------------
function SpawnGun()
{
	local vector X, Y, Z;

	GetAxes(Rotation,X,Y,Z);
	Gun = Spawn(class'WeapUSM1919_', Self,, Location, Rotation);
	PivotOrigin = Location + PivotOffset.X*X + PivotOffset.Y*Y + PivotOffset.Z*Z;
	Gun.SetLocation( PivotOrigin + GunOffset.X*X + GunOffset.Y*Y + GunOffset.Z*Z );
	WeapUSM1919_( Gun ).SetFactory( Self );
}

//---------------------------------------------------------
//	PostNetBeginPlay
//---------------------------------------------------------
function PostBeginPlay()
{
	Super.PostBeginPlay();
	TurretTrigger.m_eUseType=UseBrowning;
}

simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();
	
	Mesh = Mesh( DynamicLoadObject( "k_prop.us_30cal", class'Mesh' ) );
}

defaultproperties
{
	DrawType=DT_MESH
//	Mesh=k_prop.us_30cal
	EditorMeshName="k_prop.us_30cal"
	bHidden=false	

	CollisionHeight=240.000000

	PivotOffset=(X=83,Y=3,Z=70)
	GunOffset=(X=50,Y=0,Z=7)

	// Nine-point blending animations.
	ForwardDownAnim=forward_down
	ForwardLevelAnim=forward_level
	ForwardUpAnim=forward_up
	LeftDownAnim=left_down
	LeftLevelAnim=left_level
	LeftUpAnim=left_up
	RightDownAnim=right_down
	RightLevelAnim=right_level
	RightUpAnim=right_up

	DontRecruit=true	// M1919s don't need to recruit NPCs.

	bOpaqueForSituationalAwarenessView=true

	bAlphaFogable=True
    bAlphaFogBlend=true
}class M1EjectedClip extends gbxWeaponShells;


simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();
	
	SetStaticMesh(StaticMesh(DynamicLoadObject("s_military_us.Weapon.m1_clip", class'StaticMesh')));
}

function Destroyed()
{

	if (Owner.IsA('gbxWeapon'))
		gbxWeapon(Owner).ClipDestroyed();
	else
	if (Owner.IsA('gbxWeaponAttachment'))
		gbxWeaponAttachment(Owner).ClipDestroyed();

	Super.Destroyed();
}

defaultproperties
{
    Begin Object Class=MeshEmitter Name=M1EjectedClip_ME10
		SecondsBeforeInactive=0
        StaticMesh=StaticMesh's_military_us.Weapon.m1_clip'
        Acceleration=(Z=-900.000000)
        UseCollision=True
		DampingFactorRange=(X=(Min=0.200000,Max=0.200000),Y=(Min=0.200000,Max=0.200000),Z=(Min=0.200000,Max=0.200000))
        MaxParticles=40
        UseRotationFrom=PTRS_Offset
		SpinParticles=True
        SpinsPerSecondRange=(X=(Min=-1.000000,Max=4.000000),Y=(Min=-2.000000,Max=2.000000),Z=(Min=-1.000000,Max=2.000000))
        DampRotation=True
        RotationDampingFactorRange=(X=(Min=0.700000,Max=0.700000),Y=(Min=0.700000,Max=0.700000),Z=(Min=0.700000,Max=0.700000))
		StartSizeRange=(X=(Min=0.12000,Max=0.12000),Y=(Min=0.12000,Max=0.12000),Z=(Min=0.12000,Max=0.12000))
		AutomaticInitialSpawning=False
        ParticlesPerSecond=0.000000
        InitialParticlesPerSecond=0.000000
        LifetimeRange=(Min=2.000000,Max=2.000000)
		RespawnDeadParticles=False
        StartVelocityRange=(X=(Min=75.000000,Max=100.000000),Y=(Min=75.000000,Max=125.000000),Z=(Min=150.000000,Max=175.000000))
    End Object

    Emitters(0)=MeshEmitter'M1EjectedClip_ME10'
}
//=============================================================================
// Factory class for spawning an MG42 machine gun.  Doubles as the weapon's skeletal
// mesh when viewed in third-person mode.
//
// Author: Neil Johnson, Gearbox Software.
//=============================================================================
class MG42Factory extends IMG42Factory
	placeable;


//---------------------------------------------------------
// Properties
//---------------------------------------------------------
var (MG42Factory)	Name	GunnerMountTag,
							FeederMountTag,
							SpotterMountTag;
var (MG42Factory)	Name	MountEvent,
							DismountEvent;
var (MG42Factory)	Name	GunnerToDraft;
var (MG42Factory)	bool	IgnoreSuppression;			// Gunner's behavior doesn't change with suppression.
var (MG42Factory)	bool	DontRecruit;
var (MG42Factory)	Range	PauseTime_Low;
var (MG42Factory)	Range	PauseTime_High;
var	(MG42Factory)	Range	BurstLength_Low;
var	(MG42Factory)	Range	BurstLength_High;
var (MG42Factory)	float	EnemyTooCloseDist;
var ()				bool	bDontDismountUnlessFlanked;
var (MG42Factory)	bool	bAllowPlayerMount;
var ()				bool	bDontFleeFromGrenades;

//---------------------------------------------------------
// Variables
//---------------------------------------------------------
var TurretWeapon			Gun;			// The weapon itself;
var MG42Trigger	TurretTrigger;	// Trigger to allow the player to mount the gun.

var Name	CurNinePointAnim1, CurNinePointAnim2;
var Name	ForwardDownAnim, ForwardLevelAnim, ForwardUpAnim,
			LeftDownAnim, LeftLevelAnim, LeftUpAnim,
			RightDownAnim, RightLevelAnim, RightUpAnim;

const NINEPOINT_CHANNEL0 = 0;
const NINEPOINT_CHANNEL1 = 1;
const NINEPOINT_CHANNEL2 = 2;

var const Vector	GunOffset;		// Offset at which the gun is positioned
var Vector PivotOrigin, PivotOffset;

var NinePointDir Dir1;
var float BlendAlpha1;
var NinePointDir Dir2;
var float BlendAlpha2;
var bool bDoBlending;

var float PrevAlpha1, PrevAlpha2;
var NinePointDir PrevDirDiag, PrevDirEdge;

replication 
{
	reliable if ( Role==ROLE_Authority && bNetDirty )
		Gun, Dir1, BlendAlpha1, Dir2, BlendAlpha2, bDoBlending;
}

//---------------------------------------------------------
//	SpawnGun
//---------------------------------------------------------
function SpawnGun()
{
	local vector X, Y, Z;

	log( self$ " MG42Factory::SpawnGun()", 'MP');

	GetAxes(Rotation,X,Y,Z);
	Gun = Spawn(class'WeapDEMG42_', Self,, Location, Rotation);
	PivotOrigin = Location + PivotOffset.X*X + PivotOffset.Y*Y + PivotOffset.Z*Z;
	Gun.SetLocation( PivotOrigin + GunOffset.X*X + GunOffset.Y*Y + GunOffset.Z*Z );
	WeapDEMG42_( Gun ).SetFactory( Self );
}

//---------------------------------------------------------
//	Rebalance
//---------------------------------------------------------
function Vector Rebalance( optional Rotator Rot)
{
	local vector X, Y, Z;

	//log( self$ " MG42Factory::Rebalance()", 'MP');

	if ( Rot == Rot(0,0,0) )
		Rot = Rotation;

	GetAxes(Rot,X,Y,Z);

	return PivotOrigin + GunOffset.X*X + GunOffset.Y*Y + GunOffset.Z*Z;
}

//---------------------------------------------------------
//	PostNetBeginPlay
//---------------------------------------------------------
function PostBeginPlay()
{	
	local WeapDEMG42_ TheMG;

	Super.PostBeginPlay();

	log( self$ " MG42Factory::PostBeginPlay()", 'MP');

	if ( Role == ROLE_Authority )
	{
	SpawnGun();

		TheMG = WeapDEMG42_( Gun );

		// Impart properties to the MG42.
		TheMG.Zone1OuterRadius = Zone1OuterRadius;
		TheMG.Zone2OuterRadius = Zone2OuterRadius;
		TheMG.Zone3OuterRadius = Zone3OuterRadius;

		TheMG.GunnerToDraft = GunnerToDraft;
		TheMG.GunnerMountTag = GunnerMountTag;
		TheMG.MountEvent = MountEvent;
		TheMG.DismountEvent = DismountEvent;

		TheMG.bIgnoreSuppression = IgnoreSuppression;
		TheMG.NoShotProtectionDist = NoShotProtectionDist;

		TheMG.bDontRecruit = DontRecruit;
		TheMG.bDontDismountUnlessFlanked = bDontDismountUnlessFlanked;
		TheMG.bDontFleeFromGrenades = bDontFleeFromGrenades;

		TheMG.AttachPathNodes();

		if ( Self.Tag != '' && Self.Tag != 'MG42Factory' )
		{
			Gun.Tag = Self.Tag;
		}
		else
		{
			Gun.Tag = Gun.Name;		// At the least, give the weapon a unique tag name.
		}

		TheMG.PauseTime_Low = PauseTime_Low;
		TheMG.PauseTime_High = PauseTime_High;

		// Try setting up owner for the weapon attachemnt
		TheMG.ThirdPersonActor.SetOwner( self );

		InstantFire( TheMG.FireMode[0] ).BurstLength_Low = BurstLength_Low;
		InstantFire( TheMG.FireMode[0] ).BurstLength_High = BurstLength_High;

		TurretTrigger = spawn(class'MG42Trigger', Gun);
		TurretTrigger.SetCollisionSize( Self.CollisionRadius, Self.CollisionHeight );
		TurretTrigger.m_eUseType=UseMG42;
		TurretTrigger.Event = Gun.Tag;
		TurretTrigger.SetBase(Self);
		TurretTrigger.m_aAngleTarget = Gun;
		TurretTrigger.SetCollision(true, false, false);
		if( !bAllowPlayerMount )
			TurretTrigger.bDisabled=true;

		TheMG.MyTrigger = TurretTrigger;
		TheMG.EnemyTooCloseDist = EnemyTooCloseDist;

		SetCollisionSize( 5.0, Self.CollisionHeight );
	}
}

simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();
	
	//log( self$ " MG42Factory::PostNetBeginPlay() 1 mesh="$Mesh$" bHidden="$bHidden, 'MP');

	Mesh = Mesh( DynamicLoadObject( "k_prop.de_mg42_emplaced", class'Mesh' ) );

	//log( self$ " MG42Factory::PostNetBeginPlay() 2 mesh="$Mesh$" bHidden="$bHidden, 'MP');
}

//---------------------------------------------------------
//	ShowFactory
//---------------------------------------------------------
function ShowFactory()
{
	log( self$ " MG42Factory::ShowFactory() Owner: " $Owner, 'MP' );
	
	bHidden = false;
	bOwnerNoSee = false;
	PlayAnim( ForwardLevelAnim,,, NINEPOINT_CHANNEL0);
}

//---------------------------------------------------------
//	HideFactory
//---------------------------------------------------------
function HideFactory()
{
	log( self$ " MG42Factory::HideFactory() Owner: " $Owner, 'MP' );
	
	bHidden = true;
	bOwnerNoSee = true;
}

simulated event	Tick( float DeltaTime )
{
	// client side nine point blending	
	if ( Role < ROLE_Authority )
	{
		if ( bDoBlending )
		{
			//Log( self$" MG42Factory::event	Tick() Rotation"$Rotation$" NewFaceRot="$NewFaceRot, 'MP' );
			DoNinePointBlending( Dir1, BlendAlpha1, Dir2, BlendAlpha2 );
		}
	}
}

//---------------------------------------------------------
//	DoNinePointBlending
//---------------------------------------------------------
simulated function DoNinePointBlending( NinePointDir Dir1, float BlendAlpha1, NinePointDir Dir2, float BlendAlpha2 )
{
	local Name Dir1Anim, Dir2Anim;

	//log( self$ " MG42Factory::DoNinePointBlending() Mesh="$Mesh$" Dir1="$Dir1$" BlendAlpha1="$BlendAlpha1$" Dir2="$Dir2$" BlendAlpha2="$BlendAlpha2, 'MP' );

	// Can we early out of here?
	if ( (PrevAlpha1==BlendAlpha1) && (PrevAlpha2==BlendAlpha2) && (PrevDirDiag==Dir1) && (PrevDirEdge==Dir2) )
	{
		//Log( " MG42Factory::DoNinePointBlending() bailing since nothing has changed!", 'MP' );
		return;
	}

	if ( Mesh == None )
	{
		Mesh = Mesh( DynamicLoadObject( "k_prop.de_mg42_emplaced", class'Mesh' ) );
		//log( self$ " MG42Factory::DoNinePointBlending() Mesh="$Mesh, 'MP' );
	}

	if (BlendAlpha2 > 0.01) {
		AnimBlendParams(NINEPOINT_CHANNEL2, BlendAlpha2, 0.0f, 0);
	}
	if (BlendAlpha1 > 0.01) {
		AnimBlendParams(NINEPOINT_CHANNEL1, BlendAlpha1, 0.0f, 0);
	}
	
	// Dir1 denotes the first animation to blend.  The first animation
	// should be an "edge animation" (aligned with one of the cardinal
	// directions of up, down, left, or right).
	//
	// Dir2 denotes the second animation to blend.
	// It represents a "diagonal animation" (aligned with one
	// of the diagonal directions: e.g. up-left, down-right, etc.
	//
	switch(Dir1) {
		case NPD_UpLeft:
			Dir1Anim = LeftUpAnim;
			break;
		case NPD_UpCenter:
			Dir1Anim = ForwardUpAnim;
			break;
		case NPD_UpRight:
			Dir1Anim = RightUpAnim;
			break;
		//--------------
		case NPD_MidLeft:
			Dir1Anim = LeftLevelAnim;
			break;
		case NPD_MidCenter:
			Dir1Anim = ForwardLevelAnim;
			break;
		case NPD_MidRight:
			Dir1Anim = RightLevelAnim;
			break;
		//--------------
		case NPD_LowLeft:
			Dir1Anim = LeftDownAnim;
			break;
		case NPD_LowCenter:
			Dir1Anim = ForwardDownAnim;
			break;
		case NPD_LowRight:
			Dir1Anim = RightDownAnim;
			break;
	}

	switch(Dir2) {
		case NPD_UpLeft:
			Dir2Anim = LeftUpAnim;
			break;
		case NPD_UpCenter:
			Dir2Anim = ForwardUpAnim;
			break;
		case NPD_UpRight:
			Dir2Anim = RightUpAnim;
			break;
		//--------------
		case NPD_MidLeft:
			Dir2Anim = LeftLevelAnim;
			break;
		case NPD_MidCenter:
			Dir2Anim = ForwardLevelAnim;
			break;
		case NPD_MidRight:
			Dir2Anim = RightLevelAnim;
			break;
		//--------------
		case NPD_LowLeft:
			Dir2Anim = LeftDownAnim;
			break;
		case NPD_LowCenter:
			Dir2Anim = ForwardDownAnim;
			break;
		case NPD_LowRight:
			Dir2Anim = RightDownAnim;
			break;
	}

	// Play the new Dir1 animation if it has changed.
	if (Dir1Anim != CurNinePointAnim1) {
		CurNinePointAnim1 = Dir1Anim;
		LoopAnim(CurNinePointAnim1, 1.0, 0.1, NINEPOINT_CHANNEL1);
	}

	// Play the new Dir2 animation if it has changed.
	if (Dir2Anim != CurNinePointAnim2) {
		CurNinePointAnim2 = Dir2Anim;
		LoopAnim(CurNinePointAnim2, 1.0, 0.1, NINEPOINT_CHANNEL2);
	}

	PrevAlpha1 = BlendAlpha1;
	PrevAlpha2 = BlendAlpha2;
	PrevDirDiag = Dir1;
	PrevDirEdge = Dir2;
}

function StopBlending()
{
	//Log( " MG42Factory::StopBlending() bDoBlending="$bDoBlending$" setting it to false!", 'MP' );

	bDoBlending = false;
		
	AnimBlendParams(NINEPOINT_CHANNEL2, 0.0f, 0.0f, 0);
	AnimBlendParams(NINEPOINT_CHANNEL1, 0.0f, 0.0f, 0);
}

//---------------------------------------------------------
//	Landed
//---------------------------------------------------------
event Landed( vector HitLocation, vector HitNormal )
{
	local vector X, Y, Z;

	log( self$ " MG42Factory::Landed()", 'MP');

	GetAxes(Rotation,X,Y,Z);
	PivotOrigin = Location + PivotOffset.X*X + PivotOffset.Y*Y + PivotOffset.Z*Z;
	Gun.SetLocation( PivotOrigin + GunOffset.X*X + GunOffset.Y*Y + GunOffset.Z*Z );
	Gun.Landed( HitLocation, HitNormal );
}

//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
	RemoteRole=ROLE_AutonomousProxy
	
	DrawType=DT_MESH
//	Mesh=k_prop.de_mg42_emplaced
	EditorMeshName="k_prop.de_mg42_emplaced"

	bHidden=false
	bAlwaysRelevant=true
	bNoDelete=true

	bOwnerNoSee=true
	bOnlyOwnerSee = false;

	CollisionRadius=140.0
	CollisionHeight=40

	Zone1OuterRadius=2000.0
	Zone2OuterRadius=2500.0
	Zone3OuterRadius=3000.0
	NoShotProtectionDist=1000.0

	PivotOffset=(X=77,Y=0,Z=30)
	GunOffset=(X=28,Y=0,Z=17)

	PauseTime_Low=(Min=0.5,Max=0.8)
	PauseTime_High=(Min=3.0,Max=5.0)

	BurstLength_Low=(Min=0.5,Max=1.0)
//	BurstLength_Med=(Min=0.5,Max=1.0)
	BurstLength_High=(Min=0.0,Max=0.3)

	IgnoreSuppression=false

	MountEvent=MG42_mount
	DismountEvent=MG42_dismount

	// Nine-point blending animations.
	ForwardDownAnim=f_down
	ForwardLevelAnim=f_level
	ForwardUpAnim=f_up
	LeftDownAnim=l_down
	LeftLevelAnim=l_level
	LeftUpAnim=l_up
	RightDownAnim=r_down
	RightLevelAnim=r_level
	RightUpAnim=r_up

	EnemyTooCloseDist=1000.0

	//Physics=PHYS_Falling
	Physics=PHYS_None
	bStatic=false
	bCollideActors=false
	bBlockActors=false
	bBlockPlayers=false
	bCollideWorld=true
	bCollideSkeletalMesh=true
	bBlockZeroExtentTraces=true
	bBlockNonZeroExtentTraces=true

	bOpaqueForSituationalAwarenessView=true

	bAlphaFogable=True
    bAlphaFogBlend=true

	bDontDismountUnlessFlanked=false
	bAllowPlayerMount=true;
	bDontFleeFromGrenades=false
}
class MortarCallback extends PawnAnimExtra;

static function bool EndAnim( AnimPawn aPawn, bool fNoStart, bool fInterrupt )
{
	local gbxPawn gbxP;

	gbxP = gbxPawn( aPawn );
	if ( gbxP.Turret != None && gbxP.Turret.IsA( 'WeapDEMortar' ) )
	{
		WeapDEMortar( gbxP.Turret ).NotifyLoadShellAnimEnd();
	}

	return true;
}class MortarFactory extends Actor
	placeable;


//---------------------------------------------------------
// Properties
//---------------------------------------------------------

//---------------------------------------------------------
// Variables
//---------------------------------------------------------
var		WeapDEMortar		Gun;
var()	Name				GunnerToDraft, LeftLoaderToDraft, RightLoaderToDraft;
var()	float				EnemyTooCloseDist;
var()	float				NoticeBulletImpactsDist;	// GBX:naj - fixes bug 3876
var()	Name				MortarName, MountEvent, DismountEvent, StopFiringEvent;
var()	bool				RecruitImmediately;
var()	bool				DismountWhenNearbyImpacts;
var()	bool				DismountWhenNearbyWhizzes;
var()	bool				FireRateIndependent;
var()	int					MaximumCrewSize;

//---------------------------------------------------------
//	SpawnGun
//---------------------------------------------------------
function SpawnGun()
{
	Gun = Spawn( class'WeapDEMortar', Self );
}

//---------------------------------------------------------
//	PostNetBeginPlay
//---------------------------------------------------------
function PostBeginPlay()
{
	SpawnGun();	

	Gun.Tag = MortarName;
	Gun.GunnerToDraft = GunnerToDraft;
	Gun.LeftLoaderToDraft = LeftLoaderToDraft;
	Gun.RightLoaderToDraft = RightLoaderToDraft;
	Gun.MountEvent = MountEvent;
	Gun.DismountEvent = DismountEvent;
	Gun.StopFiringEvent = StopFiringEvent;
	Gun.EnemyTooCloseDist = EnemyTooCloseDist;
	Gun.bDontRecruit = !RecruitImmediately;
	Gun.MaxCrewSize = Clamp( MaximumCrewSize, 1, 3 );
	Gun.bDismountWhenNearbyImpacts = DismountWhenNearbyImpacts;
	Gun.bDismountWhenNearbyWhizzes = DismountWhenNearbyWhizzes;
	Gun.bFireRateIndependent = FireRateIndependent;
	Gun.NoticeBulletImpactsDist = NoticeBulletImpactsDist;
}

//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
	DrawType=DT_StaticMesh
//	StaticMesh=StaticMesh's_military_de.Weapon.mortar'
	EditorStaticMeshName="s_military_de.Weapon.mortar"

	bHidden=true
	EnemyTooCloseDist=1500.0
	MaximumCrewSize=3
	RecruitImmediately=true
	FireRateIndependent=false

	bOpaqueForSituationalAwarenessView=true

	bAlphaFogable=True
    bAlphaFogBlend=true

	NoticeBulletImpactsDist=1000.0f
}
class Pak36Factory extends Actor
	placeable;

//---------------------------------------------------------
// Properties
//---------------------------------------------------------
var(Pak36Factory)	Name	GunnerToDraft, LoaderToDraft;
var(Pak36Factory)	Name	MountEvent, DismountEvent;
var(Pak36Factory)	Name	DeathEvent;
var(Pak36Factory)	float	NoShotProtectionDist;
var(Pak36Factory)	float	EnemyTooCloseDist;
var(Pak36Factory)	float	MaxFiringDist;
var(Pak36Factory)	float	KillZoneDist;
var()				bool	bAllowTNT;
var()				bool	RecruitImmediately;

var bool bPlayerUseable;

//---------------------------------------------------------
// Variables
//---------------------------------------------------------
var		WeapDEPak36_		Gun;
var gbxContextUseTrigger	TurretTrigger;	// Trigger to allow the player to mount the gun.

//---------------------------------------------------------
//	SpawnGun
//---------------------------------------------------------
function SpawnGun()
{
	Gun = Spawn( class'WeapDEPak36_', Self );
}

//---------------------------------------------------------
//	PostNetBeginPlay
//---------------------------------------------------------
function PostBeginPlay()
{
	local TNTTrigger aTNTTrigger;

	SpawnGun();

	Gun.GunnerToDraft = GunnerToDraft;
	Gun.LoaderToDraft = LoaderToDraft;
	Gun.MountEvent = MountEvent;
	Gun.DismountEvent = DismountEvent;
	Gun.NoShotProtectionDist = NoShotProtectionDist;
	Gun.EnemyTooCloseDist = EnemyTooCloseDist;
	Gun.MaxFiringDist = MaxFiringDist;
	Gun.KillZoneDist = KillZoneDist;
	Gun.bDontRecruit = !RecruitImmediately;
	Gun.Tag = Self.Tag;
	Gun.DeathEvent = DeathEvent;

	if ( bPlayerUseable )
	{
		TurretTrigger = spawn(class'gbxContextUseTrigger', Gun);
		TurretTrigger.SetCollisionSize( Self.CollisionRadius, TurretTrigger.CollisionHeight );
		TurretTrigger.m_eUseType=UsePak36;
		TurretTrigger.Event = Gun.Tag;
		TurretTrigger.SetBase(Self);
		TurretTrigger.SetCollision(true, false, false);
		Gun.MyTrigger = TurretTrigger;
	}
	else if ( bAllowTNT )
	{
		aTNTTrigger = Spawn( class'TNTTrigger', Gun );
		aTNTTrigger.SetCollisionSize( Self.CollisionRadius, aTNTTrigger.CollisionHeight );
		aTNTTrigger.m_aUseTarget = Gun;
		aTNTTrigger.SetBase(Self);
		aTNTTrigger.SetCollision(true, false, false);
		aTNTTrigger.SetAttachedTurret( Gun );

		Gun.MyTNTTrigger = aTNTTrigger;
	}
}

//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
	DrawType=DT_Mesh
//	Mesh=Mesh'k_prop.de_pak36'
	EditorMeshName="k_prop.de_pak36"
	bHidden=true

	CollisionRadius=280.0

	MountEvent=Pak36_mount
	DismountEvent=Pak36_dismount

	NoShotProtectionDist=1000.0
	EnemyTooCloseDist=1500.0
	MaxFiringDist=10000

	KillZoneDist=5500.0

	bPlayerUseable=false
	bAllowTNT=true
	RecruitImmediately=true

	bOpaqueForSituationalAwarenessView=true

	bAlphaFogable=True
    bAlphaFogBlend=true
}
class PAK88BrokenTurret extends Actor;

simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();
	
	SetStaticMesh(StaticMesh(DynamicLoadObject("s_military_de.Weapon.88mm_dmg_top", class'StaticMesh')));
}

defaultproperties
{
	Physics=PHYS_None
	DrawType=DT_StaticMesh
//	StaticMesh=StaticMesh's_military_de.Weapon.flakvierling_dmg_gun'
	bHidden=false
}class PAK88Factory extends Actor
	placeable;


//---------------------------------------------------------
// Variables
//---------------------------------------------------------
var		WeapDEPAK88_			Gun;
var()	Name					GunnerToDraft, FuseSetterToDraft, Pak88Name, LoaderToDraft, SpotterToDraft;
var(Pak88Factory)	Name		DismountEvent;
var()	Name					DeathEvent;
var()	float					EnemyTooCloseDist;
var()	bool					bAllowTNT;
var()	bool					RecruitImmediately;
var()	bool					bFuseSetterInCrew;
var()	float					LoaderNoShotProtectionDist;

//---------------------------------------------------------
//	SpawnGun
//---------------------------------------------------------
function SpawnGun()
{
	Gun = Spawn( class'WeapDEPAK88_', Self );
}

//---------------------------------------------------------
//	PostNetBeginPlay
//---------------------------------------------------------
function PostBeginPlay()
{
	local TNTTrigger aTNTTrigger;

	SpawnGun();

	Gun.GunnerToDraft = GunnerToDraft;
	if (bFuseSetterInCrew)
	{
	Gun.FuseSetterToDraft = FuseSetterToDraft;
		Gun.bNoFuseSetter = false;
	}
	else 
	{
		Gun.bNoFuseSetter = true;

	}
	Gun.LoaderToDraft = LoaderToDraft;
	Gun.SpotterToDraft = SpotterToDraft;
	Gun.DismountEvent = DismountEvent;
	Gun.EnemyTooCloseDist = EnemyTooCloseDist;
	Gun.bDontRecruit = !RecruitImmediately;
	Gun.Tag = Self.Tag;
	Gun.DeathEvent = DeathEvent;
	Gun.LoaderNoShotProtectionDist = LoaderNoShotProtectionDist;

	if ( bAllowTNT )
	{
		aTNTTrigger = Spawn( class'TNTTrigger', Gun );
		aTNTTrigger.SetCollisionSize( Self.CollisionRadius, aTNTTrigger.CollisionHeight );
		aTNTTrigger.m_aUseTarget = Gun;
		aTNTTrigger.SetBase(Self);
		aTNTTrigger.SetCollision(true, false, false);
		aTNTTrigger.SetAttachedTurret( Gun );

		Gun.MyTNTTrigger = aTNTTrigger;
	}
}

//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
	DrawType=DT_Mesh
//	Mesh=k_prop.de_flakv
	EditorMeshName="k_prop.de_88flak";

	//DrawType=DT_Sprite
	Texture=Texture'Engine.S_Weapon'
	bHidden=true
	EnemyTooCloseDist=1000.0
	CollisionRadius=300.0
	bAllowTNT=true
	RecruitImmediately=true

	bOpaqueForSituationalAwarenessView=true

	bAlphaFogable=True
    bAlphaFogBlend=true
	bFuseSetterInCrew = false;
}
class Pak88ReloadCallback extends PawnAnimExtra;

static function bool EndAnim( AnimPawn aPawn, bool fNoStart, bool fInterrupt )
{
	if ( gbxPawn( aPawn ).Turret != None )
	{
		gbxPawn( aPawn ).Turret.ReloadFinished();
		return true;
	}

	return false;
}class PanzerK98GoreSetup extends GorePackSetup;

defaultproperties
{
	PackGoreTextureNames(0)="t_character_de.grids.panzer_k98"
	PackGoreTextureNames(1)="t_character_de.grids.panzer_k98_leftside"
	PackGoreTextureNames(2)="t_character_de.grids.panzer_k98_leftsidemass"
	PackGoreTextureNames(3)="t_character_de.grids.panzer_k98_rightside"
	PackGoreTextureNames(4)="t_character_de.grids.panzer_k98_rightsidemass"
	PackGoreTextureNames(5)="t_character_de.grids.panzer_k98_legs"

	PackGoreHandState(1)=(R=1,G=1,B=1)
	PackGoreHandState(3)=(R=1,G=0,B=1)
}
class PanzerMP40GoreSetup extends GorePackSetup;

defaultproperties
{
	PackGoreTextureNames(0)="t_character_de.grids.panzer_mp40"
	PackGoreTextureNames(1)="t_character_de.grids.panzer_mp40_leftside"
	PackGoreTextureNames(2)="t_character_de.grids.panzer_mp40_leftsidemass"
	PackGoreTextureNames(3)="t_character_de.grids.panzer_mp40_rightside"
	PackGoreTextureNames(4)="t_character_de.grids.panzer_mp40_rightsidemass"
	PackGoreTextureNames(5)="t_character_de.grids.panzer_mp40_legs"

	PackGoreHandState(1)=(R=1,G=1,B=1)
	PackGoreHandState(3)=(R=1,G=0,B=1)
}
class PanzerSturmGoreSetup extends GorePackSetup;

defaultproperties
{
	PackGoreTextureNames(0)="t_character_de.grids.panzer_sturm"
	PackGoreTextureNames(1)="t_character_de.grids.panzer_sturm_leftside"
	PackGoreTextureNames(2)="t_character_de.grids.panzer_sturm_leftsidemass"
	PackGoreTextureNames(3)="t_character_de.grids.panzer_sturm_rightside"
	PackGoreTextureNames(4)="t_character_de.grids.panzer_sturm_rightsidemass"
	PackGoreTextureNames(5)="t_character_de.grids.panzer_sturm_legs"
}
class ParaMP40GoreSetup extends GorePackSetup;

defaultproperties
{
	PackGoreTextureNames(0)="t_character_de.grids.para_mp40"
	PackGoreTextureNames(1)="t_character_de.grids.para_mp40_leftside"
	PackGoreTextureNames(2)="t_character_de.grids.para_mp40_leftsidemass"
	PackGoreTextureNames(3)="t_character_de.grids.para_mp40_rightside"
	PackGoreTextureNames(4)="t_character_de.grids.para_mp40_rightsidemass"
	PackGoreTextureNames(5)="t_character_de.grids.para_mp40_legs"
}
class ParaSturmGoreSetup extends GorePackSetup;

defaultproperties
{
	PackGoreTextureNames(0)="t_character_de.grids.para_sturm"
	PackGoreTextureNames(1)="t_character_de.grids.para_sturm_leftside"
	PackGoreTextureNames(2)="t_character_de.grids.para_sturm_leftsidemass"
	PackGoreTextureNames(3)="t_character_de.grids.para_sturm_rightside"
	PackGoreTextureNames(4)="t_character_de.grids.para_sturm_rightsidemass"
	PackGoreTextureNames(5)="t_character_de.grids.para_sturm_legs"
}
//=============================================================================
// PawnAnimInfoFinal88Loader - This has animations for the 88 Loader pawn.
//
//=============================================================================
class PawnAnimInfoFinal88Loader extends ItemPawnAnimInfo;




defaultproperties
{
	TurnLeftRelaxed=standing_turn_left_relaxed
	TurnRightRelaxed=standing_turn_right_relaxed
	TurnLeftCombatRelaxed=standing_turn_left_combat
	TurnRightCombatRelaxed=standing_turn_right_combat
	TurnLeftSighted=standing_turn_left
	TurnRightSighted=standing_turn_right

	WalkingForwardRelaxed=standing_walk
	WalkingForwardSighted=standing_walk_aimed_sighted
	WalkingForwardLimpLeft=standing_walk_limp_left_leg
	WalkingForwardLimpRight=standing_walk_limp_left_leg
	WalkingLeftRelaxed=standing_strafe_left_walk_relaxed
	WalkingLeftSighted=standing_strafe_left_walk_sighted
	WalkingRightRelaxed=standing_strafe_right_walk_relaxed
	WalkingRightSighted=standing_strafe_right_walk_sighted
	WalkingBackRelaxed=standing_walk_back
	WalkingBackSighted=standing_walk_back_aimed_sighted

	RunningForwardRelaxed=standing_run
	RunningForwardSighted=standing_run_aimed
	RunningForwardLimpLeft=standing_run_limp_left_leg
	RunningForwardLimpRight=standing_run_limp_left_leg
	RunningLeftRelaxed=standing_strafe_left_fast
	RunningLeftSighted=standing_strafe_left_fast
	RunningRightRelaxed=standing_strafe_right_fast
	RunningRightSighted=standing_strafe_right_fast
	RunningBackRelaxed=standing_run_back
	RunningBackSighted=standing_run_back_aimed
	//
	//StandingSprint=de_88_spotter_standing_idle
	//
	//IdleStandingNoCombat(0)=crouched_idle_relaxed_1
	//IdleStandingNoCombat(1)=crouched_idle_relaxed_2
	//IdleStandingNoCombat(2)=crouched_idle_relaxed_3
	//IdleStandingNoCombat(3)=crouched_idle_relaxed_4
	//IdleStandingNoCombat(4)=crouched_idle_relaxed_5
	//IdleStandingNoCombat(5)=crouched_idle_relaxed_1
	//IdleStandingNoCombat(6)=crouched_idle_relaxed_2

	//IdleStandingAlert(0)=crouched_idle_relaxed_1
	//IdleStandingAlert(1)=crouched_idle_relaxed_2
	//IdleStandingAlert(2)=crouched_idle_relaxed_3
	//IdleStandingAlert(3)=crouched_idle_relaxed_4
	//IdleStandingAlert(4)=crouched_idle_relaxed_5
	//IdleStandingAlert(5)=crouched_idle_relaxed_1
	//IdleStandingAlert(6)=crouched_idle_relaxed_2
	//
	//IdleStandingSighted(0)=crouched_idle_relaxed_1
	//IdleStandingSighted(1)=crouched_idle_relaxed_2
	//IdleStandingSighted(2)=crouched_idle_relaxed_3
	//IdleStandingSighted(3)=crouched_idle_relaxed_4
	//IdleStandingSighted(4)=crouched_idle_relaxed_5
	//IdleStandingSighted(5)=crouched_idle_relaxed_1
	//IdleStandingSighted(6)=crouched_idle_relaxed_2

	IdleStandingNoCombat(0)=standing_idle_relaxed_1
	IdleStandingNoCombat(1)=standing_idle_relaxed_2
	IdleStandingNoCombat(2)=standing_idle_relaxed_3
	IdleStandingNoCombat(3)=standing_idle_relaxed_4
	IdleStandingNoCombat(4)=standing_idle_relaxed_5
	IdleStandingNoCombat(5)=standing_idle_relaxed_6
	IdleStandingNoCombat(6)=standing_idle_relaxed_7

	IdleStandingAlert(0)=standing_idle_combat_1
	IdleStandingAlert(1)=standing_idle_combat_2
	IdleStandingAlert(2)=standing_idle_combat_3
	IdleStandingAlert(3)=standing_idle_combat_4
	IdleStandingAlert(4)=standing_idle_combat_1//standing_idle_combat_5
	IdleStandingAlert(5)=standing_idle_combat_2//standing_idle_combat_6
	IdleStandingAlert(6)=standing_idle_combat_3//standing_idle_combat_7
	
	IdleStandingSighted(0)=standing_idle_combat_1
	IdleStandingSighted(1)=standing_idle_combat_2
	IdleStandingSighted(2)=standing_idle_combat_3
	IdleStandingSighted(3)=standing_idle_combat_4
	IdleStandingSighted(4)=standing_idle_combat_1
	IdleStandingSighted(5)=standing_idle_combat_2
	IdleStandingSighted(6)=standing_idle_combat_3
	
	IdleCrouchedNoCombat(0)=crouched_idle_relaxed_1
	IdleCrouchedNoCombat(1)=crouched_idle_relaxed_2
	IdleCrouchedNoCombat(2)=crouched_idle_relaxed_3
	IdleCrouchedNoCombat(3)=crouched_idle_relaxed_4
	IdleCrouchedNoCombat(4)=crouched_idle_relaxed_5
	IdleCrouchedNoCombat(5)=crouched_idle_relaxed_5
	IdleCrouchedNoCombat(6)=crouched_idle_relaxed_5
	IdleCrouchedRelaxed(0)=crouched_idle_relaxed_1
	IdleCrouchedRelaxed(1)=crouched_idle_relaxed_2
	IdleCrouchedRelaxed(2)=crouched_idle_relaxed_3
	IdleCrouchedRelaxed(3)=crouched_idle_relaxed_4
	IdleCrouchedRelaxed(4)=crouched_idle_relaxed_5
	IdleCrouchedRelaxed(5)=crouched_idle_relaxed_5
	IdleCrouchedRelaxed(6)=crouched_idle_relaxed_5
	IdleCrouchedSighted(0)=crouched_idle_relaxed_1
	IdleCrouchedSighted(1)=crouched_idle_relaxed_2
	IdleCrouchedSighted(2)=crouched_idle_relaxed_3
	IdleCrouchedSighted(3)=crouched_idle_relaxed_4
	IdleCrouchedSighted(4)=crouched_idle_relaxed_5
	IdleCrouchedSighted(5)=crouched_idle_relaxed_5
	IdleCrouchedSighted(6)=crouched_idle_relaxed_5
	//WeaponAnimSet="a_hold_misc.88"
}
//=============================================================================
// PawnAnimInfoFinal88Spotter - This has animations for the 88 spotter pawn.
//
//=============================================================================
class PawnAnimInfoFinal88Spotter extends ItemPawnAnimInfo;




defaultproperties
{
	TurnLeftRelaxed=de_88_spotter_standing_turn_left
	TurnRightRelaxed=de_88_spotter_standing_turn_right
	TurnLeftSighted=de_88_spotter_standing_turn_left
	TurnRightSighted=de_88_spotter_standing_turn_right
	TurnLeftCombatRelaxed=de_88_spotter_standing_turn_left
	TurnRightCombatRelaxed=de_88_spotter_standing_turn_right

	//WalkingForwardRelaxed=de_88_spotter_standing_idle
	//WalkingForwardSighted=de_88_spotter_standing_idle
	//WalkingForwardLimpLeft=de_88_spotter_standing_idle
	//WalkingForwardLimpRight=de_88_spotter_standing_idle
	//WalkingLeftRelaxed=de_88_spotter_standing_idle
	//WalkingLeftSighted=de_88_spotter_standing_idle
	//WalkingRightRelaxed=de_88_spotter_standing_idle
	//WalkingRightSighted=de_88_spotter_standing_idle
	//WalkingBackRelaxed=de_88_spotter_standing_idle
	//WalkingBackSighted=de_88_spotter_standing_idle

	//RunningForwardRelaxed=de_88_spotter_standing_idle
	//RunningForwardSighted=de_88_spotter_standing_idle
	//RunningForwardLimpLeft=de_88_spotter_standing_idle
	//RunningForwardLimpRight=de_88_spotter_standing_idle
	//RunningLeftRelaxed=de_88_spotter_standing_idle
	//RunningLeftSighted=de_88_spotter_standing_idle
	//RunningRightRelaxed=de_88_spotter_standing_idle
	//RunningRightSighted=de_88_spotter_standing_idle
	//RunningBackRelaxed=de_88_spotter_standing_idle
	//RunningBackSighted=de_88_spotter_standing_idle
	//
	//StandingSprint=de_88_spotter_standing_idle
	//

	FlinchStanding(0)=de_88_spotter_standing_flinch_small
	FlinchStanding(1)=de_88_spotter_standing_flinch_small
	FlinchStanding(2)=de_88_spotter_standing_flinch_small
	FlinchStanding(3)=de_88_spotter_standing_flinch_small

	IdleStandingNoCombat(0)=de_88_spotter_standing_idle
	IdleStandingNoCombat(1)=de_88_spotter_standing_idle
	IdleStandingNoCombat(2)=de_88_spotter_standing_idle
	IdleStandingNoCombat(3)=de_88_spotter_standing_idle
	IdleStandingNoCombat(4)=de_88_spotter_standing_idle
	IdleStandingNoCombat(5)=de_88_spotter_standing_idle
	IdleStandingNoCombat(6)=de_88_spotter_standing_idle

	IdleStandingAlert(0)=de_88_spotter_standing_idle
	IdleStandingAlert(1)=de_88_spotter_standing_idle
	IdleStandingAlert(2)=de_88_spotter_standing_idle
	IdleStandingAlert(3)=de_88_spotter_standing_idle
	IdleStandingAlert(4)=de_88_spotter_standing_idle
	IdleStandingAlert(5)=de_88_spotter_standing_idle
	IdleStandingAlert(6)=de_88_spotter_standing_idle
	
	IdleStandingSighted(0)=de_88_spotter_standing_idle
	IdleStandingSighted(1)=de_88_spotter_standing_idle
	IdleStandingSighted(2)=de_88_spotter_standing_idle
	IdleStandingSighted(3)=de_88_spotter_standing_idle
	IdleStandingSighted(4)=de_88_spotter_standing_idle
	IdleStandingSighted(5)=de_88_spotter_standing_idle
	IdleStandingSighted(6)=de_88_spotter_standing_idle
	
	StandingToCrouch=de_88_spotter_standing_to_crouched
	CrouchToStanding=de_88_spotter_crouched_to_standing

	IdleCrouchedNoCombat(0)=de_88_spotter_crouched_idle
	IdleCrouchedNoCombat(1)=de_88_spotter_crouched_idle
	IdleCrouchedNoCombat(2)=de_88_spotter_crouched_idle
	IdleCrouchedNoCombat(3)=de_88_spotter_crouched_idle
	IdleCrouchedNoCombat(4)=de_88_spotter_crouched_idle
	IdleCrouchedNoCombat(5)=de_88_spotter_crouched_idle
	IdleCrouchedNoCombat(6)=de_88_spotter_crouched_idle
	IdleCrouchedRelaxed(0)=de_88_spotter_crouched_idle
	IdleCrouchedRelaxed(1)=de_88_spotter_crouched_idle
	IdleCrouchedRelaxed(2)=de_88_spotter_crouched_idle
	IdleCrouchedRelaxed(3)=de_88_spotter_crouched_idle
	IdleCrouchedRelaxed(4)=de_88_spotter_crouched_idle
	IdleCrouchedRelaxed(5)=de_88_spotter_crouched_idle
	IdleCrouchedRelaxed(6)=de_88_spotter_crouched_idle
	IdleCrouchedSighted(0)=de_88_spotter_crouched_idle
	IdleCrouchedSighted(1)=de_88_spotter_crouched_idle
	IdleCrouchedSighted(2)=de_88_spotter_crouched_idle
	IdleCrouchedSighted(3)=de_88_spotter_crouched_idle
	IdleCrouchedSighted(4)=de_88_spotter_crouched_idle
	IdleCrouchedSighted(5)=de_88_spotter_crouched_idle
	IdleCrouchedSighted(6)=de_88_spotter_crouched_idle


	CrouchedTurnLeftSighted=de_88_spotter_crouched_turn_left
	CrouchedTurnRightSighted=de_88_spotter_crouched_turn_right

	FlinchCrouched(0)=de_88_spotter_crouched_flinch_small
	FlinchCrouched(1)=de_88_spotter_crouched_flinch_small
	FlinchCrouched(2)=de_88_spotter_crouched_flinch_small
	FlinchCrouched(3)=de_88_spotter_crouched_flinch_small//crouched_flinch_4
	
	//WeaponAnimSet="a_hold_misc.88"
}
//=============================================================================
// PawnAnimInfoFinalFlakvierling - This has animations for the non-Simple Simon pawn.
//
//=============================================================================
class PawnAnimInfoFinalFlakvierling extends PawnAnimInfoFinalTwoHand;



defaultproperties
{
	WeaponAnimSet="a_hold_misc.flakv"
}
//=============================================================================
// PawnAnimInfoFinalMG42_ - This has animations for the non-Simple Simon pawn.
//
//=============================================================================
class PawnAnimInfoFinalHalftrackMG42_ extends PawnAnimInfoFinalTwoHand;


defaultproperties
{
	WeaponAnimSet="a_hold_misc.Halftrack"
}
//=============================================================================
// PawnAnimInfoFinalK98_ - This has animations for the non-Simple Simon pawn.
//
//=============================================================================
class PawnAnimInfoFinalK98_ extends PawnAnimInfoFinalTwoHand;



defaultproperties
{
	m_fPlayCycleAnim=true
}
//=============================================================================
// PawnAnimInfoFinalSherman50cal - This has animations for the non-Simple Simon pawn.
//
//=============================================================================
class PawnAnimInfoFinalM10_50cal extends PawnAnimInfoFinalTwoHand;


defaultproperties
{
	WeaponAnimSet="a_hold_misc.m10"
}
//=============================================================================
// PawnAnimInfoFinalM1919_ - This has animations for the non-Simple Simon pawn.
//
//=============================================================================
class PawnAnimInfoFinalM1919_ extends PawnAnimInfoFinalTwoHand;



defaultproperties
{
	WeaponAnimSet="a_hold_misc.30cal"
}
//=============================================================================
// PawnAnimInfoFinalTwoHand - This has animations for the non-Simple Simon pawn.
//
//=============================================================================
class PawnAnimInfoFinalMachineGun extends PawnAnimInfoFinalTwoHand;



defaultproperties
{
	ReloadStanding=standing_reload
	ReloadCrouched=crouched_reload
}
//=============================================================================
// PawnAnimInfoFinalMG42_ - This has animations for the non-Simple Simon pawn.
//
//=============================================================================
class PawnAnimInfoFinalMG42_ extends PawnAnimInfoFinalTwoHand;



defaultproperties
{
	WeaponAnimSet="a_hold_misc.mg42"
}
//=============================================================================
// PawnAnimInfoFinalOneHand - This has animations for the non-Simple Simon pawn.
//
//=============================================================================
class PawnAnimInfoFinalOneHand extends PawnAnimInfoFinalTwoHand;


defaultproperties
{
//	FireStandingSighted=standing_firing_sighted_P
	
//	FireCrouchedSighted=crouched_firing_sighted_P
//	FireCornerStandingLeft=standing_firing_sighted_P
//	FireCornerStandingRight=standing_firing_sighted_P

//	TurnLeftSighted=standing_turn_left_P
//	TurnRightSighted=standing_turn_right_P

//	WalkingForwardSighted=standing_walk_aimed_sighted_P
//	WalkingLeftSighted=standing_strafe_left_walk_sighted_P
//	WalkingRightSighted=standing_strafe_right_walk_sighted_P
//	WalkingBackSighted=standing_walk_back_aimed_sighted_P

//	RunningForwardSighted=standing_run_aimed_P
//	RunningLeftSighted=standing_strafe_left_fast_P
//	RunningRightSighted=standing_strafe_right_fast_P
//	RunningBackSighted=standing_run_back_aimed_P

//	StandingSprint=standing_sprint_P
	
//	CrouchedTurnLeftSighted=crouched_turn_left_P
//	CrouchedTurnRightSighted=crouched_turn_right_P

//	CrouchedCreepForwardSighted=crouched_creeping_aimed_sighted_P
//	CrouchedCreepLeftSighted=crouched_strafe_left_aimed_sighted_P
//	CrouchedCreepBackSighted=crouched_creeping_back_aimed_sighted_P
//	CrouchedCreepRightSighted=crouched_strafe_right_aimed_sighted_P
	
//	MeleeAttack(0)=standing_melee_attack_1_P
//	MeleeAttack(1)=standing_melee_attack_2_P
//	MeleeAttack(2)=standing_melee_attack_1_P
	
//	ReloadStanding=standing_reload_P
//	ReloadCrouched=crouched_reload_P
	
//	IdleStandingSighted(0)=standing_idle_aimed_sighted_1_P
//	IdleStandingSighted(1)=standing_idle_aimed_sighted_2_P
//	IdleStandingSighted(2)=standing_idle_aimed_sighted_3_P
//	IdleStandingSighted(3)=standing_idle_aimed_sighted_3_P
//	IdleStandingSighted(4)=standing_idle_aimed_sighted_3_P
//	IdleStandingSighted(5)=standing_idle_aimed_sighted_3_P
//	IdleStandingSighted(6)=standing_idle_aimed_sighted_3_P

//	IdleCrouchedSighted(0)=crouched_idle_aimed_sighted_1_P
//	IdleCrouchedSighted(1)=crouched_idle_aimed_sighted_1_P
//	IdleCrouchedSighted(2)=crouched_idle_aimed_sighted_1_P
//	IdleCrouchedSighted(3)=crouched_idle_aimed_sighted_2_P
//	IdleCrouchedSighted(4)=crouched_idle_aimed_sighted_3_P
//	IdleCrouchedSighted(5)=crouched_idle_aimed_sighted_3_P
//	IdleCrouchedSighted(6)=crouched_idle_aimed_sighted_3_P
	
//	StandingToCrouch=standing_to_crouched_P
//	CrouchToStanding=crouched_to_standing_P

//	ThrowGrenadeStanding=standing_throw_grenade_P
//	ThrowGrenadeCrouched=crouched_throw_grenade_P

//	JumpInPlace=standing_jump_in_place_P
//	RunningJump=standing_running_jump_P
	
	WeaponAnimSet="a_hold_pistol.a_hold_pistol"
	m_fReloadHandSwitch=false
}
//=============================================================================
// PawnAnimInfoFinalPak36_ - This has animations for the non-Simple Simon pawn.
//
//=============================================================================
class PawnAnimInfoFinalPak36_ extends PawnAnimInfoFinalTwoHand;



defaultproperties
{
	WeaponAnimSet="a_hold_misc.pak"
}
//=============================================================================
// PawnAnimInfoFinalPak88_ - This has animations for the non-Simple Simon pawn.
//
//=============================================================================
class PawnAnimInfoFinalPak88_ extends PawnAnimInfoFinalTwoHand;



defaultproperties
{
	WeaponAnimSet="a_hold_misc.88"
}
//=============================================================================
// PawnAnimInfoFinalSherman50cal - This has animations for the non-Simple Simon pawn.
//
//=============================================================================
class PawnAnimInfoFinalSherman50cal extends PawnAnimInfoFinalTwoHand;


defaultproperties
{
	WeaponAnimSet="a_hold_misc.sherman"
}
//=============================================================================
// PawnAnimInfoFinalSherman50cal - This has animations for the non-Simple Simon pawn.
//
//=============================================================================
class PawnAnimInfoFinalStuart30cal extends PawnAnimInfoFinalTwoHand;


defaultproperties
{
	WeaponAnimSet="a_hold_misc.stuart"
}
//=============================================================================
// PawnAnimInfoFinalTwoHand - This has animations for the non-Simple Simon pawn.
//
//=============================================================================
class PawnAnimInfoFinalSubMachineGun extends PawnAnimInfoFinalTwoHand;



defaultproperties
{
	ReloadStanding=standing_reload
	ReloadCrouched=crouched_reload
}
//=============================================================================
// PawnAnimInfoFinalTwoHand - This has animations for the non-Simple Simon pawn.
//
//=============================================================================
class PawnAnimInfoFinalTwoHand extends ItemPawnAnimInfo;



defaultproperties
{
	FireStandingSighted=standing_firing_sighted
	FireStandingWallFacing=crouched_wall_facing_fire_firing
	FireStandingWallFacingUrban=crouched_wall_facing_peekfire_firing

	FireCrouchedSighted=crouched_firing_sighted
	FireCornerStandingLeft=standing_firing_sighted
	FireCornerStandingRight=standing_firing_sighted
	FireCornerCrouchedLeft=crouched_wall_lean_left_fire_firing
	FireCornerCrouchedRight=crouched_wall_lean_right_fire_firing

	FireCornerStandingLeftUrban=standing_wall_lean_left_fire_fire;
	FireCornerStandingRightUrban=standing_wall_lean_right_fire_fire;

	CycleStanding=standing_cycle_bolt

	CycleCrouched=crouched_cycle_bolt
	CycleCrouchedCornerFiringLeft=crouched_wall_lean_left_fire_cycle_bolt
	CycleCrouchedCornerFiringRight=crouched_wall_lean_right_fire_cycle_bolt

	TurnLeftRelaxed=standing_turn_left_relaxed
	TurnRightRelaxed=standing_turn_right_relaxed
	TurnLeftCombatRelaxed=standing_turn_left_combat
	TurnRightCombatRelaxed=standing_turn_right_combat
	TurnLeftSighted=standing_turn_left
	TurnRightSighted=standing_turn_right

	WalkingForwardRelaxed=standing_walk
	WalkingForwardSighted=standing_walk_aimed_sighted
	WalkingForwardLimpLeft=standing_walk_limp_left_leg
	WalkingForwardLimpRight=standing_walk_limp_left_leg
	WalkingLeftRelaxed=standing_strafe_left_walk_relaxed
	WalkingLeftSighted=standing_strafe_left_walk_sighted
	WalkingRightRelaxed=standing_strafe_right_walk_relaxed
	WalkingRightSighted=standing_strafe_right_walk_sighted
	WalkingBackRelaxed=standing_walk_back
	WalkingBackSighted=standing_walk_back_aimed_sighted

	RunningForwardRelaxed=standing_run
	RunningForwardSighted=standing_run_aimed
	RunningForwardLimpLeft=standing_run_limp_left_leg
	RunningForwardLimpRight=standing_run_limp_left_leg
	RunningLeftRelaxed=standing_strafe_left_fast
	RunningLeftSighted=standing_strafe_left_fast
	RunningRightRelaxed=standing_strafe_right_fast
	RunningRightSighted=standing_strafe_right_fast
	RunningBackRelaxed=standing_run_back
	RunningBackSighted=standing_run_back_aimed

	StandingSprint=standing_sprint

	CrouchedTurnLeftSighted=crouched_turn_left
	CrouchedTurnRightSighted=crouched_turn_right

	CrouchedCreepForwardRelaxed=crouched_creeping
	CrouchedCreepForwardSighted=crouched_creeping_aimed_sighted
	CrouchedCreepLeftRelaxed=crouched_strafe_left
	CrouchedCreepLeftSighted=crouched_strafe_left_aimed_sighted
	CrouchedCreepRightRelaxed=crouched_strafe_right
	CrouchedCreepRightSighted=crouched_strafe_right_aimed_sighted
	CrouchedCreepBackRelaxed=crouched_creeping_back
	CrouchedCreepBackSighted=crouched_creeping_back_aimed_sighted

	CrouchedSprint=crouched_sprint

	MeleeAttack(0)=standing_melee_attack_1
	MeleeAttack(1)=standing_melee_attack_2
	//MeleeAttack(2)=standing_melee_attack_3 // Bayonet charge
	MeleeAttack(2)=standing_melee_attack_1

	ReloadStanding=standing_reload
	ReloadCrouched=crouched_reload
	ReloadWallFacingCrouched=crouched_wall_lean_reload
	ReloadWallFacingCrouchedLeft=crouched_wall_lean_left_reload
	ReloadWallFacingCrouchedRight=crouched_wall_lean_right_reload
	ReloadWallFacingStandingLeft=standing_wall_lean_left_reload
	ReloadWallFacingStandingRight=standing_wall_lean_right_reload
	ReloadCoverUrban=crouched_wall_facing_peekfire_reload

	DeployStanding=standing_draw
	DeployCrouched=crouched_draw

	HolsterStanding=standing_holster
	HolsterCrouched=crouched_holster

	FlinchStanding(0)=standing_flinch_1
	FlinchStanding(1)=standing_flinch_2
	FlinchStanding(2)=standing_flinch_3
	FlinchStanding(3)=standing_flinch_3//standing_flinch_4
	FlinchCrouched(0)=crouched_flinch_1
	FlinchCrouched(1)=crouched_flinch_2
	FlinchCrouched(2)=crouched_flinch_3
	FlinchCrouched(3)=standing_flinch_3//crouched_flinch_4

	IdleStandingNoCombat(0)=standing_idle_relaxed_1
	IdleStandingNoCombat(1)=standing_idle_relaxed_2
	IdleStandingNoCombat(2)=standing_idle_relaxed_3
	IdleStandingNoCombat(3)=standing_idle_relaxed_4
	IdleStandingNoCombat(4)=standing_idle_relaxed_5
	IdleStandingNoCombat(5)=standing_idle_relaxed_6
	IdleStandingNoCombat(6)=standing_idle_relaxed_7

	IdleStandingAlert(0)=standing_idle_combat_1
	IdleStandingAlert(1)=standing_idle_combat_2
	IdleStandingAlert(2)=standing_idle_combat_3
	IdleStandingAlert(3)=standing_idle_combat_4
	IdleStandingAlert(4)=standing_idle_combat_1//standing_idle_combat_5
	IdleStandingAlert(5)=standing_idle_combat_2//standing_idle_combat_6
	IdleStandingAlert(6)=standing_idle_combat_3//standing_idle_combat_7
	
	IdleStandingSighted(0)=standing_idle_aimed_sighted_1
	IdleStandingSighted(1)=standing_idle_aimed_sighted_2
	IdleStandingSighted(2)=standing_idle_aimed_sighted_3
	IdleStandingSighted(3)=standing_idle_aimed_sighted_3
	IdleStandingSighted(4)=standing_idle_aimed_sighted_3
	IdleStandingSighted(5)=standing_idle_aimed_sighted_3
	IdleStandingSighted(6)=standing_idle_aimed_sighted_3
	IdleStandingWallLeanPeekLeft=standing_wall_lean_left_peek_peeking
	IdleStandingWallLeanPeekRight=standing_wall_lean_right_peek_peeking
	IdleStandingWallLeanFireLeft=standing_idle_aimed_sighted_1
	IdleStandingWallLeanFireRight=standing_idle_aimed_sighted_1
	IdleStandingWallLeanFireLeftUrban=standing_wall_lean_left_fire_frame
	IdleStandingWallLeanFireRightUrban=standing_wall_lean_right_fire_frame
	IdleStandingWallLeanLeft(0)=standing_wall_lean_left_idle
	IdleStandingWallLeanLeft(1)=standing_wall_lean_left_idle_2
	IdleStandingWallLeanLeft(2)=standing_wall_lean_left_idle_3
	IdleStandingWallLeanLeft(3)=standing_wall_lean_left_idle_4
	IdleStandingWallLeanRight(0)=standing_wall_lean_right_idle
	IdleStandingWallLeanRight(1)=standing_wall_lean_right_idle_2
	IdleStandingWallLeanRight(2)=standing_wall_lean_right_idle_3
	IdleStandingWallLeanRight(3)=standing_wall_lean_right_idle_4
	IdleStandingWallFacing=crouched_wall_facing_fire_idle
	IdleStandingWallFacingUrban=crouched_wall_facing_peekfire_firing_frame
	IdleStandingBackToWall=standing_wall_lean_idle

	IdleCrouchedNoCombat(0)=crouched_idle_relaxed_1
	IdleCrouchedNoCombat(1)=crouched_idle_relaxed_2
	IdleCrouchedNoCombat(2)=crouched_idle_relaxed_3
	IdleCrouchedNoCombat(3)=crouched_idle_relaxed_4
	IdleCrouchedNoCombat(4)=crouched_idle_relaxed_5
	IdleCrouchedNoCombat(5)=crouched_idle_relaxed_5
	IdleCrouchedNoCombat(6)=crouched_idle_relaxed_5
	IdleCrouchedRelaxed(0)=crouched_idle_relaxed_1
	IdleCrouchedRelaxed(1)=crouched_idle_relaxed_2
	IdleCrouchedRelaxed(2)=crouched_idle_relaxed_3
	IdleCrouchedRelaxed(3)=crouched_idle_relaxed_4
	IdleCrouchedRelaxed(4)=crouched_idle_relaxed_5
	IdleCrouchedRelaxed(5)=crouched_idle_relaxed_5
	IdleCrouchedRelaxed(6)=crouched_idle_relaxed_5
	IdleCrouchedSighted(0)=crouched_idle_aimed_sighted_1
	IdleCrouchedSighted(1)=crouched_idle_aimed_sighted_1
	IdleCrouchedSighted(2)=crouched_idle_aimed_sighted_1
	IdleCrouchedSighted(3)=crouched_idle_aimed_sighted_2
	IdleCrouchedSighted(4)=crouched_idle_aimed_sighted_3
	IdleCrouchedSighted(5)=crouched_idle_aimed_sighted_3
	IdleCrouchedSighted(6)=crouched_idle_aimed_sighted_3
	IdleCrouchedWallLeanPeekLeft=crouched_wall_lean_left_peek_peeking
	IdleCrouchedWallLeanPeekRight=crouched_wall_lean_right_peek_peeking
	IdleCrouchedWallLeanFireLeft=crouched_wall_lean_left_fire_idle
	IdleCrouchedWallLeanFireRight=crouched_wall_lean_right_fire_idle
	IdleCrouchedWallLeanLeft(0)=crouched_wall_lean_left_idle
	IdleCrouchedWallLeanLeft(1)=crouched_wall_lean_left_idle_2
	IdleCrouchedWallLeanLeft(2)=crouched_wall_lean_left_idle_3
	IdleCrouchedWallLeanLeft(3)=crouched_wall_lean_left_idle_4
	IdleCrouchedWallLeanRight(0)=crouched_wall_lean_right_idle
	IdleCrouchedWallLeanRight(1)=crouched_wall_lean_right_idle_2
	IdleCrouchedWallLeanRight(2)=crouched_wall_lean_right_idle_3
	IdleCrouchedWallLeanRight(3)=crouched_wall_lean_right_idle_4
	//IdleCrouchedWallFacing=crouched_idle_relaxed_wall
	//IdleCrouchedWallFacing(0)=crouched_idle_relaxed_wall
	//IdleCrouchedWallFacing(1)=crouched_idle_relaxed_wall
	//IdleCrouchedWallFacing(2)=crouched_idle_relaxed_wall	
	IdleCrouchedWallFacing(0)=crouched_wall_lean_idle_1
	IdleCrouchedWallFacing(1)=crouched_wall_lean_idle_2
	IdleCrouchedWallFacing(2)=crouched_wall_lean_idle_3
	IdleCrouchedWallFacing(3)=crouched_wall_lean_idle_4
	IdleCrouchedWallFacing(4)=crouched_wall_lean_idle_5
	IdleCrouchedWallFacing(5)=crouched_wall_lean_idle_5
	IdleCrouchedWallFacing(6)=crouched_wall_lean_idle_5

	IdleWallFacingPeek=crouched_wall_facing_peek_idle

	StandingToCrouch=standing_to_crouched
	StandingCoverFireToCrouchLeft=crouched_wall_lean_left_mount_from_standing
	StandingCoverFireToCrouchRight=crouched_wall_lean_right_mount_from_standing
	StandingPeekToCrouch=crouched_wall_facing_peek_dismount
	StandingToCrouchFacingWall=crouched_wall_facing_fire_dismount
	StandingToCrouchFacingWallUrban=crouched_wall_facing_peekfire_dismount

	CrouchToStanding=crouched_to_standing
	CrouchToStandingCoverFireLeft=crouched_to_standing_fire_left
	CrouchToStandingCoverFireRight=crouched_to_standing_fire_right
	CrouchToStandingPeek=crouched_wall_facing_peek_mount
	CrouchToStandingFacingWall=crouched_wall_facing_fire_mount
	CrouchToStandingFacingWallUrban=crouched_wall_facing_peekfire_mount

	MountPeekLeftStanding=standing_wall_lean_left_peek_mount
	MountPeekLeftCrouched=crouched_wall_lean_left_peek_mount
	MountPeekRightStanding=standing_wall_lean_right_peek_mount
	MountPeekRightCrouched=crouched_wall_lean_right_peek_mount
	MountFireLeftCrouched=crouched_wall_lean_left_fire_mount
	MountFireRightCrouched=crouched_wall_lean_right_fire_mount
	MountFireLeftStanding=standing_wall_lean_left_fire_mount
	MountFireRightStanding=standing_wall_lean_right_fire_mount

	MountMG42Gunner=UNARMED_mg42_mount

	DismountPeekLeftCrouched=crouched_wall_lean_left_peek_dismount
	DismountPeekRightCrouched=crouched_wall_lean_right_peek_dismount
	DismountPeekLeftStanding=standing_wall_lean_left_peek_dismount
	DismountPeekRightStanding=standing_wall_lean_right_peek_dismount
	DismountFireLeftCrouched=crouched_wall_lean_left_fire_dismount
	DismountFireLeftStanding=standing_wall_lean_left_fire_dismount
	DismountFireRightCrouched=crouched_wall_lean_right_fire_dismount
	DismountFireRightStanding=standing_wall_lean_right_fire_dismount

	DismountMG42Gunner=UNARMED_mg42_dismount
	DismountMG42GunnerTurn=UNARMED_mg42_dismount_turn

	MountTankStuart30cal=stuart_player_mount_gun
	DismountTankStuart30cal=stuart_player_dismount_gun
	MountTankSherman50cal=sherman_player_mount_gun
	DismountTankSherman50cal=sherman_player_dismount_gun

	ReactToBulletsStanding(0)=standing_react_to_bullets_1
	ReactToBulletsStanding(1)=standing_react_to_bullets_2
	ReactToBulletsStanding(2)=standing_react_to_bullets_3
	ReactToBulletsStanding(3)=standing_react_to_bullets_4
	ReactToBulletsStanding(4)=standing_react_to_bullets_5
	ReactToBulletsCrouched(0)=crouched_react_to_bullets_1
	ReactToBulletsCrouched(1)=crouched_react_to_bullets_2
	ReactToBulletsCrouched(2)=crouched_react_to_bullets_3
	ReactToBulletsCrouched(3)=crouched_react_to_bullets_4
	ReactToBulletsLeftCornerCrouched(0)=crouched_wall_lean_left_react_to_bullets_1
	ReactToBulletsLeftCornerCrouched(1)=crouched_wall_lean_left_react_to_bullets_2
	ReactToBulletsLeftCornerCrouched(2)=crouched_wall_lean_left_react_to_bullets_3
	ReactToBulletsRightCornerCrouched(0)=crouched_wall_lean_right_react_to_bullets_1
	ReactToBulletsRightCornerCrouched(1)=crouched_wall_lean_right_react_to_bullets_2
	ReactToBulletsRightCornerCrouched(2)=crouched_wall_lean_right_react_to_bullets_3
	ReactToBulletsLeftCornerStanding(0)=standing_wall_lean_left_react_to_bullets_1
	ReactToBulletsLeftCornerStanding(1)=standing_wall_lean_left_react_to_bullets_2
	ReactToBulletsLeftCornerStanding(2)=standing_wall_lean_left_react_to_bullets_3
	ReactToBulletsRightCornerStanding(0)=standing_wall_lean_right_react_to_bullets_1
	ReactToBulletsRightCornerStanding(1)=standing_wall_lean_right_react_to_bullets_2
	ReactToBulletsRightCornerStanding(2)=standing_wall_lean_right_react_to_bullets_3

	CombatReadyTransitions(0)=standing_idle_to_combat_1
	CombatReadyTransitions(1)=standing_idle_to_combat_2
	CombatReadyTransitions(2)=standing_idle_to_combat_3
	CombatReadyTransitions(3)=standing_idle_to_combat_4

	WallLeanCrouchedToStandingLeft=standing_wall_lean_left_mount_from_crouched
	WallLeanCrouchedToStandingRight=standing_wall_lean_right_mount_from_crouched
	WallLeanStandingToCrouchedLeft=crouched_wall_lean_left_mount_from_standing
	WallLeanStandingToCrouchedRight=crouched_wall_lean_right_mount_from_standing
	WallLeanStandingToStandingLeft=standing_wall_lean_left_mount_from_standing
	WallLeanStandingToStandingRight=standing_wall_lean_right_mount_from_standing
	WallLeanCrouchedToCrouchedLeft=crouched_wall_lean_left_mount_from_crouched
	WallLeanCrouchedToCrouchedRight=crouched_wall_lean_right_mount_from_crouched
	WallLeanCrouchedToStandingBack=standing_wall_lean_mount_from_crouched
	WallLeanStandingToStandingBack=standing_wall_lean_mount_from_standing

	DismountWallLeanCrouchedToCrouchedLeft=crouched_wall_lean_left_dismount_to_crouched
	DismountWallLeanCrouchedToCrouchedRight=crouched_wall_lean_right_dismount_to_crouched
	DismountWallLeanCrouchedToStandingLeft=crouched_wall_lean_left_dismount_to_standing	
	DismountWallLeanCrouchedToStandingRight=crouched_wall_lean_right_dismount_to_standing	
	DismountWallLeanStandingToCrouchedLeft=standing_wall_lean_left_dismount_to_crouched
	DismountWallLeanStandingToCrouchedRight=standing_wall_lean_right_dismount_to_crouched
	DismountWallLeanStandingToStandingLeft=standing_wall_lean_left_dismount_to_standing
	DismountWallLeanStandingToStandingRight=standing_wall_lean_right_dismount_to_standing

	/// These are deprecated
	ThrowGrenadeStanding=standing_throw_grenade
	ThrowGrenadeCrouched=crouched_throw_grenade

	GrenadeStandingToCower=standing_down_to_cower
	GrenadeCrouchedToCower=crouched_down_to_cower
	GrenadeStandingFromCower=standing_up_from_cower
	GrenadeCrouchedFromCower=crouched_up_from_cower
	GrenadeCowering=crouched_cower

	GrenadeReturnCrouched=crouched_grenade_return
	GrenadeReturnStanding=standing_grenade_return

	IdleFeedingMG42Idle=UNARMED_mg42_assistant_idle
	IdleFeedingMG42Firing=UNARMED_mg42_assistant_feeding
	IdleSpottingMG42=UNARMED_spotter_search

	IdleFlakVGunner(0)=Flakv_gunner_idle_1
	IdleFlakVGunner(1)=Flakv_gunner_idle_2
	IdleFlakVGunner(2)=Flakv_gunner_idle_3

	IdleFlakvLoaderLeft(0)=Flakv_L_loader_idle_1
	IdleFlakvLoaderLeft(1)=Flakv_L_loader_idle_2
	IdleFlakvLoaderLeft(2)=Flakv_L_loader_idle_3

	IdleFlakvLoaderRight(0)=Flakv_R_loader_idle_1
	IdleFlakvLoaderRight(1)=Flakv_R_loader_idle_2
	IdleFlakvLoaderRight(2)=Flakv_R_loader_idle_3

	IdlePak88Gunner = de_88_gunner_idle
	IdlePak88FuseSetter = de_88_fuse_setter_idle
	IdlePak88Spotter = de_88_spotter_standing_idle

	ReloadFlakvLeft=Flakv_L_loader_reload
	ReloadFlakvRight=Flakv_R_loader_reload

	ReloadPak88FuseSetter = de_88_fuse_setter_sets_fuse

	DismountFlakVGunner=FlakV_gunner_dismount
	DismountFlakVLeftLoader=FlakV_L_loader_dismount
	DismountFlakVRightLoader=FlakV_R_loader_dismount

	DismountPak36Gunner=pak_gunner_dismount
	DismountPak36Loader=pak_loader_dismount

	DismountPak88Gunner = de_88_gunner_dismount
	DismountPak88FuseSetter = de_88_fuse_setter_dismount

	DismountMortarGunner=de_mortar_gunner_dismount
	DismountMortarLeftLoader=de_mortar_loader_1_dismount
	DismountMortarRightLoader=de_mortar_loader_2_dismount

	OffsetXFlakVGunnerDismount=20.948
	OffsetYFlakVGunnerDismount=100.374
	OffsetXFlakVLeftLoaderDismount=-80.42
	OffsetYFlakVLeftLoaderDismount=42.474	
	OffsetXFlakVRightLoaderDismount=-195.878
	OffsetYFlakVRightLoaderDismount=65.276

	OffsetXPak36GunnerDismount=-98.017
	OffsetYPak36GunnerDismount=1.525
	OffsetXPak36LoaderDismount=-57.851
	OffsetYPak36LoaderDismount=-6.758

	OffsetXMortarGunnerDismount;
	OffsetYMortarGunnerDismount;
	OffsetXMortarLeftLoaderDismount;
	OffsetYMortarLeftLoaderDismount;
	OffsetXMortarRightLoaderDismount;
	OffsetYMortarRightLoaderDismount;

	ReloadPak36_=pak_loader_idle_2  //NAC: set to idle to save memory 

	IdlePak36Gunner(0)=pak_gunner_idle_1

	IdlePak36Loader(0)=pak_loader_idle_2
	IdlePak36Loader(1)=pak_loader_idle_2

	IdleMortarGunner(0)=de_mortar_gunner_idle_3
	IdleMortarGunner(1)=de_mortar_gunner_idle_3
	IdleMortarGunner(2)=de_mortar_gunner_idle_3
	
	IdleMortarLoaderLeft(0)=de_mortar_loader_1_idle_2
	IdleMortarLoaderLeft(1)=de_mortar_loader_1_idle_2
	IdleMortarLoaderLeft(2)=de_mortar_loader_1_idle_2

	IdleMortarLoaderRight(0)=de_mortar_loader_2_idle_2
	IdleMortarLoaderRight(1)=de_mortar_loader_2_idle_2
	IdleMortarLoaderRight(2)=de_mortar_loader_2_idle_2

	TNTMountAnim=standing_explosives_down
	TNTPlantingAnim=standing_explosives_planting
	TNTDismountAnim=standing_explosives_up

	SpottingMG42Point=UNARMED_spotter_point

	ThrowGermanGrenadeStanding=
	ThrowGermanGrenadeCrouched=

	JumpInPlace=standing_jump_in_place
	RunningJump=standing_running_jump

	PlayerBlownDown(0)=PLAYER_blown_down_2
	PlayerBlownDown(1)=PLAYER_blown_down_3

	WeaponAnimSet="a_hold_rifle.a_hold_rifle"
	m_fReloadHandSwitch=true
}
//=============================================================================
// PawnAnimInfoFinalUnarmed - This has animations for the non-Simple Simon pawn.
//
//=============================================================================
class PawnAnimInfoFinalUnarmed extends PawnAnimInfoFinalTwoHand;



defaultproperties
{
	TurnLeftRelaxed=standing_turn_left_relaxed
	TurnRightRelaxed=standing_turn_right_relaxed
	TurnLeftSighted=standing_turn_left
	TurnRightSighted=standing_turn_right

	WalkingForwardRelaxed=UNARMED_walk
	WalkingForwardSighted=UNARMED_walk
	WalkingForwardLimpLeft=UNARMED_walk
	WalkingForwardLimpRight=UNARMED_walk
	WalkingLeftRelaxed=UNARMED_strafe_left
	WalkingLeftSighted=UNARMED_strafe_left
	WalkingRightRelaxed=UNARMED_strafe_right
	WalkingRightSighted=UNARMED_strafe_right
	WalkingBackRelaxed=UNARMED_walk_back
	WalkingBackSighted=UNARMED_walk_back

	RunningForwardRelaxed=UNARMED_run
	RunningForwardSighted=UNARMED_run
	RunningForwardLimpLeft=UNARMED_run
	RunningForwardLimpRight=UNARMED_run
	RunningLeftRelaxed=UNARMED_strafe_left
	RunningLeftSighted=UNARMED_strafe_left
	RunningRightRelaxed=UNARMED_strafe_right
	RunningRightSighted=UNARMED_strafe_right
	RunningBackRelaxed=UNARMED_run_back
	RunningBackSighted=UNARMED_run_back
	
	StandingSprint=UNARMED_sprint
	
	IdleStandingNoCombat(0)=UNARMED_idle_1
	IdleStandingNoCombat(1)=UNARMED_idle_2
	IdleStandingNoCombat(2)=UNARMED_idle_3
	IdleStandingNoCombat(3)=UNARMED_idle_4
	IdleStandingNoCombat(4)=UNARMED_idle_5
	IdleStandingNoCombat(5)=UNARMED_idle_6
	IdleStandingNoCombat(6)=UNARMED_idle_6

	IdleStandingAlert(0)=UNARMED_idle_1
	IdleStandingAlert(1)=UNARMED_idle_2
	IdleStandingAlert(2)=UNARMED_idle_3
	IdleStandingAlert(3)=UNARMED_idle_4
	IdleStandingAlert(4)=UNARMED_idle_5
	IdleStandingAlert(5)=UNARMED_idle_6
	IdleStandingAlert(6)=UNARMED_idle_6
	
	IdleStandingSighted(0)=UNARMED_idle_1
	IdleStandingSighted(1)=UNARMED_idle_2
	IdleStandingSighted(2)=UNARMED_idle_3
	IdleStandingSighted(3)=UNARMED_idle_4
	IdleStandingSighted(4)=UNARMED_idle_5
	IdleStandingSighted(5)=UNARMED_idle_6
	IdleStandingSighted(6)=UNARMED_idle_6
	
	WeaponAnimSet="a_hold_misc.unarmed"
}
//=============================================================================
// PawnAnimInfoPak88_ - This has animations for the non-Simple Simon pawn.
//
//=============================================================================
class PawnAnimInfoPak88_ extends PawnAnimInfoFinalTwoHand;



defaultproperties
{
	WeaponAnimSet="a_hold_misc.88"
}
class PickupAmmoDEFG42_ extends Ammo;


simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();
	
	SetStaticMesh(StaticMesh(DynamicLoadObject("s_military_us.Equipment.us_para_ammobag", class'StaticMesh')));
}

defaultproperties
{
    InventoryType=class'AmmoDEFG42_'

    MessageClass=class'PickupMessagePlus'
    PickupMessage="US BAR Ammo"
//    PickupSound=Sound'PickupSounds.AssaultAmmoPickup'
    PickupForce="PickupAmmoDEFG42_"  // jdf

    AmmoAmount=100
    MaxDesireability=0.240000

	// GBX:najnaj
//	StaticMesh=StaticMesh's_military_us.equipment.us_para_ammobag'
    DrawType=DT_STATICMESH
    bAcceptsProjectors=false
}
class PickupAmmoDEK98_ extends Ammo;


simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();
	
	SetStaticMesh(StaticMesh(DynamicLoadObject("s_military_us.Equipment.us_para_ammobag", class'StaticMesh')));
}

defaultproperties
{
    InventoryType=class'AmmoDEK98_'

    MessageClass=class'PickupMessagePlus'
    PickupMessage="German K98 Ammo"
//    PickupSound=Sound'PickupSounds.AssaultAmmoPickup'
    PickupForce="PickupAmmoDEK98_"  // jdf

    AmmoAmount=100
    MaxDesireability=0.240000

	// GBX:najnaj
//	StaticMesh=StaticMesh's_military_us.Equipment.us_para_ammobag'
    DrawType=DT_STATICMESH
    bAcceptsProjectors=false
}
class PickupAmmoDEMP40_ extends Ammo;


simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();
	
	SetStaticMesh(StaticMesh(DynamicLoadObject("s_military_us.Equipment.us_para_ammobag", class'StaticMesh')));
}

defaultproperties
{
    InventoryType=class'AmmoDEMP40_'

    MessageClass=class'PickupMessagePlus'
    PickupMessage="German MP40 Ammo"
//    PickupSound=Sound'PickupSounds.AssaultAmmoPickup'
    PickupForce="PickupAmmoDEMP40_"  // jdf

    AmmoAmount=100
    MaxDesireability=0.240000

	// GBX:najnaj
//	StaticMesh=StaticMesh's_military_us.equipment.us_para_ammobag'
    DrawType=DT_STATICMESH
    bAcceptsProjectors=false
}
class PickupAmmoDEP38_ extends Ammo;


simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();
	
	SetStaticMesh(StaticMesh(DynamicLoadObject("s_military_us.Equipment.us_para_ammobag", class'StaticMesh')));
}

defaultproperties
{
    InventoryType=class'AmmoDEP38_'

    MessageClass=class'PickupMessagePlus'
    PickupMessage="US .45 Ammo"
//    PickupSound=Sound'PickupSounds.AssaultAmmoPickup'
    PickupForce="PickupAmmoDEP38_"  // jdf

    AmmoAmount=96
    MaxDesireability=0.240000

	// GBX:najnaj
//	StaticMesh=StaticMesh's_military_us.equipment.us_para_ammobag'
    DrawType=DT_STATICMESH
    bAcceptsProjectors=false
}
class PickupAmmoDEPanzerfaust extends Ammo;


simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();
	
	SetStaticMesh(StaticMesh(DynamicLoadObject("s_military_us.Equipment.us_para_ammobag", class'StaticMesh')));
}

defaultproperties
{
    InventoryType=class'AmmoDEPanzerfaust'

    MessageClass=class'PickupMessagePlus'
    PickupMessage="German Panzerfaust Ammo"
//    PickupSound=Sound'PickupSounds.AssaultAmmoPickup'
    PickupForce="PickupAmmoDEPanzerfaust"  // jdf

    AmmoAmount=2
    MaxDesireability=0.240000

	// GBX:najnaj
//	StaticMesh=StaticMesh's_military_us.equipment.us_para_ammobag'
    DrawType=DT_STATICMESH
    bAcceptsProjectors=false
}
class PickupAmmoDESTG44_ extends Ammo;


simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();
	
	SetStaticMesh(StaticMesh(DynamicLoadObject("s_military_us.Equipment.us_para_ammobag", class'StaticMesh')));
}

defaultproperties
{
    InventoryType=class'AmmoDESTG44_'

    MessageClass=class'PickupMessagePlus'
    PickupMessage="US BAR Ammo"
//    PickupSound=Sound'PickupSounds.AssaultAmmoPickup'
    PickupForce="PickupAmmoDESTG44_"  // jdf

    AmmoAmount=100
    MaxDesireability=0.240000

	// GBX:najnaj
//	StaticMesh=StaticMesh's_military_us.equipment.us_para_ammobag'
    DrawType=DT_STATICMESH
    bAcceptsProjectors=false
}
class PickupAmmoUSBar extends Ammo;


simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();
	
	SetStaticMesh(StaticMesh(DynamicLoadObject("s_military_us.Equipment.us_para_ammobag", class'StaticMesh')));
}

defaultproperties
{
    InventoryType=class'AmmoUSBar'

    MessageClass=class'PickupMessagePlus'
    PickupMessage="US BAR Ammo"
//    PickupSound=Sound'PickupSounds.AssaultAmmoPickup'
    PickupForce="PickupAmmoUSBar"  // jdf

    AmmoAmount=100
    MaxDesireability=0.240000

	// GBX:najnaj
//	StaticMesh=StaticMesh's_military_us.equipment.us_para_ammobag'
    DrawType=DT_STATICMESH
    bAcceptsProjectors=false
}
class PickupAmmoUSBazooka extends Ammo;


simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();
	
	SetStaticMesh(StaticMesh(DynamicLoadObject("s_military_us.Equipment.us_para_ammobag", class'StaticMesh')));
}

defaultproperties
{
    InventoryType=class'AmmoUSBazooka'

    MessageClass=class'PickupMessagePlus'
    PickupMessage="US Bazooka Ammo"
//    PickupSound=Sound'PickupSounds.AssaultAmmoPickup'
    PickupForce="PickupAmmoUSBazooka"  // jdf

    AmmoAmount=100
    MaxDesireability=0.240000

	// GBX:najnaj
//	StaticMesh=StaticMesh's_military_us.equipment.us_para_ammobag'
    DrawType=DT_STATICMESH
    bAcceptsProjectors=false
}
class PickupAmmoUSColt1911_ extends Ammo;


simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();
	
	SetStaticMesh(StaticMesh(DynamicLoadObject("s_military_us.Equipment.us_para_ammobag", class'StaticMesh')));
}

defaultproperties
{
    InventoryType=class'AmmoUSColt1911_'

    MessageClass=class'PickupMessagePlus'
    PickupMessage="US .45 Ammo"
//    PickupSound=Sound'PickupSounds.AssaultAmmoPickup'
    PickupForce="PickupAmmoUSColt1911_"  // jdf

    AmmoAmount=84
    MaxDesireability=0.240000

	// GBX:najnaj
//	StaticMesh=StaticMesh's_military_us.equipment.us_para_ammobag'
    DrawType=DT_STATICMESH
    bAcceptsProjectors=false
}
class PickupAmmoUSM1Carbine extends Ammo;


simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();
	
	SetStaticMesh(StaticMesh(DynamicLoadObject("s_military_us.Equipment.us_para_ammobag", class'StaticMesh')));
}

defaultproperties
{
    InventoryType=class'AmmoUSM1Carbine'

    MessageClass=class'PickupMessagePlus'
    PickupMessage="US M1 Carbine Ammo"
//    PickupSound=Sound'PickupSounds.AssaultAmmoPickup'
    PickupForce="PickupAmmoUSM1Carbine"  // jdf

    AmmoAmount=100
    MaxDesireability=0.240000

	// GBX:najnaj
//	StaticMesh=StaticMesh's_military_us.equipment.us_para_ammobag'
    DrawType=DT_STATICMESH
    bAcceptsProjectors=false
}
class PickupAmmoUSM1_ extends Ammo;


simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();
	
	SetStaticMesh(StaticMesh(DynamicLoadObject("s_military_us.Equipment.us_para_ammobag", class'StaticMesh')));
}

defaultproperties
{
    InventoryType=class'AmmoUSM1_'

    MessageClass=class'PickupMessagePlus'
    PickupMessage="US M1 Ammo"
//    PickupSound=Sound'PickupSounds.AssaultAmmoPickup'
    PickupForce="PickupAmmoUSM1_"  // jdf

    AmmoAmount=100
    MaxDesireability=0.240000

	// GBX:najnaj
//	StaticMesh=StaticMesh's_military_us.equipment.us_para_ammobag'
    DrawType=DT_STATICMESH
    bAcceptsProjectors=false
}
class PickupAmmoUSM3A1_ extends Ammo;


simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();
	
	SetStaticMesh(StaticMesh(DynamicLoadObject("s_military_us.Equipment.us_para_ammobag", class'StaticMesh')));
}

defaultproperties
{
    InventoryType=class'AmmoUSM3A1_'

    MessageClass=class'PickupMessagePlus'
    PickupMessage="US M3A1 Sub-Machine Gun Ammo"
//    PickupSound=Sound'PickupSounds.AssaultAmmoPickup'
    PickupForce="PickupAmmoUSM3A1_"  // jdf

    AmmoAmount=100
    MaxDesireability=0.240000

	// GBX:najnaj
//	StaticMesh=StaticMesh's_military_us.equipment.us_para_ammobag'
    DrawType=DT_STATICMESH
    bAcceptsProjectors=false
}
class PickupAmmoUSSpringfield extends Ammo;


simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();
	
	SetStaticMesh(StaticMesh(DynamicLoadObject("s_military_us.Equipment.us_para_ammobag", class'StaticMesh')));
}

defaultproperties
{
    InventoryType=class'AmmoUSSpringfield'

    MessageClass=class'PickupMessagePlus'
    PickupMessage="US M1 Carbine Ammo"
//    PickupSound=Sound'PickupSounds.AssaultAmmoPickup'
    PickupForce="PickupAmmoUSSpringfield"  // jdf

    AmmoAmount=100
    MaxDesireability=0.240000

	// GBX:najnaj
//	StaticMesh=StaticMesh's_military_us.equipment.us_para_ammobag'
    DrawType=DT_STATICMESH
    bAcceptsProjectors=false
}
class PickupAmmoUSThompson extends Ammo;


simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();
	
	SetStaticMesh(StaticMesh(DynamicLoadObject("s_military_us.Equipment.us_para_ammobag", class'StaticMesh')));
}

defaultproperties
{
    InventoryType=class'AmmoUSThompson'

    MessageClass=class'PickupMessagePlus'
    PickupMessage="US M1A1 Sub-Machine Gun Ammo"
//    PickupSound=Sound'PickupSounds.AssaultAmmoPickup'
    PickupForce="PickupAmmoUSThompson"  // jdf

    AmmoAmount=100
    MaxDesireability=0.240000

	// GBX:najnaj
//	StaticMesh=StaticMesh's_military_us.equipment.us_para_ammobag'
    DrawType=DT_STATICMESH
    bAcceptsProjectors=false
}
class PickupUsableBandage extends gbxWeaponPickup
	placeable;


defaultproperties
{
	InventoryType=class'UsableBandage'
	PickupMessage="You picked up a Bandage."
//	PickupSound=Sound'WeaponPickup'
//	StaticMesh=StaticMesh's_temp_us_weapons.Equipment.Firstaid'
//	Mesh=Mesh'GeistGL3'
	CollisionRadius=34.000000
	CollisionHeight=8.000000

	m_eWeaponType=WeaponSecondary
    bAcceptsProjectors=false
}
class PickupUsableTrophy extends gbxWeaponPickup
	placeable;


var travel bool	m_fCollected;
var() localized string	m_szTrophyName;
var() localized string	m_szTrophyDesc;
var() Material m_aTrophyIcon;

function PickupItem( Pawn aPawn )
{
	local Inventory Copy;

	if (bDisabled)
		return;

	Copy = SpawnCopy(aPawn);
	Copy.ItemName = m_szTrophyName;
	Copy.ItemDesc = m_szTrophyDesc;
	Copy.Icon = m_aTrophyIcon;
	AnnouncePickup(aPawn);
    SetRespawn();
	Copy.PickupFunction(aPawn);
	gbxPawn(aPawn).m_fTrophySelect = false;
	TriggerEvent(Event, aPawn.Controller, aPawn);
}

defaultproperties
{
	// This icon no longer exists.
	//m_aTrophyIcon=material'WG_HUD.HUD.wpn_bandage'

	InventoryType=class'UsableTrophies'
	PickupMessage="You picked up a Trophy."
//	PickupSound=Sound'WeaponPickup'
//	StaticMesh=StaticMesh's_temp_us_weapons.Equipment.Firstaid'
//	Mesh=Mesh'GeistGL3'
	CollisionRadius=34.000000
	CollisionHeight=8.000000

//    RotationRate=(Yaw=0)
//    DesiredRotation=(Yaw=0)

	m_eWeaponType=WeaponTrophy
    bAcceptsProjectors=false
}
class PickupUsableUSHandGrenade extends gbxWeaponPickup
	placeable;


simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();
	
	SetStaticMesh(StaticMesh(DynamicLoadObject("s_military_us.Equipment.us_para_ammobag", class'StaticMesh')));
}

defaultproperties
{
	InventoryType=class'UsableUSHandGrenade'
	PickupMessage="You picked up a Hand Grenade."
//	PickupSound=Sound'WeaponPickup'
	// GBX:najnaj
//	StaticMesh=StaticMesh's_military_us.equipment.us_para_ammobag'
    DrawType=DT_STATICMESH
	CollisionRadius=34.000000
	CollisionHeight=8.000000

	m_eWeaponType=WeaponSecondary
    bAcceptsProjectors=false
}
//=============================================================================
// PickupWeapDEFG42Sniper
//=============================================================================
class PickupWeapDEFG42Sniper extends gbxWeaponPickup
	placeable;


simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();
	
	SetStaticMesh(StaticMesh(DynamicLoadObject("s_npc_weapon_de.de_fg42_sniper", class'StaticMesh')));
	SetDrawType( DT_StaticMesh );
}

defaultproperties
{
    InventoryType=class'WeapDEFG42Sniper'

	DrawType=DT_Sprite
	Texture=Texture'Engine.S_Weapon'
    MessageClass=class'PickupMessagePlus'
    PickupMessage="You got the German FG42 automatic rifle with scope."
//    PickupSound=Sound'PickupSounds.AssaultRiflePickup'
    PickupForce="PickupDEFG42_"  // jdf
    PickupName="German FG42 automatic rifle with scope"

	MaxDesireability=+0.4

//    StaticMesh=StaticMesh's_npc_weapon_de.de_fg42_sniper'
//    DrawType=DT_StaticMesh
    DrawScale=1.0
    bAcceptsProjectors=false

	DropCueName="GEAR.DROPMACHINEGUN"

	AmmoAmount(0)=200
	ClipAmount(0)=20
}
//=============================================================================
// PickupWeapDEFG42_
//=============================================================================
class PickupWeapDEFG42_ extends gbxWeaponPickup
	placeable;


simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();
	
	SetStaticMesh(StaticMesh(DynamicLoadObject("s_npc_weapon_de.de_fg42", class'StaticMesh')));
	SetDrawType( DT_StaticMesh );
}

defaultproperties
{
    InventoryType=class'WeapDEFG42_'

	DrawType=DT_Sprite
	Texture=Texture'Engine.S_Weapon'
    MessageClass=class'PickupMessagePlus'
    PickupMessage="You got the German FG42 Machine Gun."
//    PickupSound=Sound'PickupSounds.AssaultRiflePickup'
    PickupForce="PickupDEFG42_"  // jdf
    PickupName="FG42"

	MaxDesireability=+0.4

//    StaticMesh=StaticMesh's_npc_weapon_de.de_fg42'
//    DrawType=DT_StaticMesh
    DrawScale=1.0
    bAcceptsProjectors=false

	DropCueName="GEAR.DROPMACHINEGUN"

	AmmoAmount(0)=200
	ClipAmount(0)=20
}
//=============================================================================
// PickupWeapDEK98Sniper
//=============================================================================
class PickupWeapDEK98Sniper extends gbxWeaponPickup
	placeable;


simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();
	
	SetStaticMesh(StaticMesh(DynamicLoadObject("s_npc_weapon_de.de_k98_sniper", class'StaticMesh')));
	SetDrawType( DT_StaticMesh );
}

defaultproperties
{
    InventoryType=class'WeapDEK98Sniper'

	DrawType=DT_Sprite
	Texture=Texture'Engine.S_Weapon'
    MessageClass=class'PickupMessagePlus'
    PickupMessage="You got the German K98 Sniper Rifle."
//    PickupSound=Sound'PickupSounds.AssaultRiflePickup'
    PickupForce="PickupDEK98Sniper"  // jdf
    PickupName="German K98 Sniper Rifle"

	MaxDesireability=+0.4

//    StaticMesh=StaticMesh's_npc_weapon_de.de_k98_sniper'
//    DrawType=DT_StaticMesh
    DrawScale=1.0
    bAcceptsProjectors=false

	AmmoAmount(0)=65
	ClipAmount(0)=5
}
//=============================================================================
// PickupWeapDEK98_
//=============================================================================
class PickupWeapDEK98_ extends gbxWeaponPickup
	placeable;


simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();
	
	SetStaticMesh(StaticMesh(DynamicLoadObject("s_npc_weapon_de.de_k98", class'StaticMesh')));
	SetDrawType( DT_StaticMesh );
}

defaultproperties
{
    InventoryType=class'WeapDEK98_'

	DrawType=DT_Sprite
	Texture=Texture'Engine.S_Weapon'
    MessageClass=class'PickupMessagePlus'
    PickupMessage="You got the German K98 Rifle."
//    PickupSound=Sound'PickupSounds.AssaultRiflePickup'
    PickupForce="PickupDEK98_"  // jdf
    PickupName="German K98 Rifle"

	MaxDesireability=+0.4

//    StaticMesh=StaticMesh's_npc_weapon_de.de_k98'
//    DrawType=DT_StaticMesh
    DrawScale=1.0
    bAcceptsProjectors=false

	AmmoAmount(0)=65
	ClipAmount(0)=5
}
//=============================================================================
// PickupWeapDEMP40_
//=============================================================================
class PickupWeapDEMP40_ extends gbxWeaponPickup
	placeable;


simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();
	
	SetStaticMesh(StaticMesh(DynamicLoadObject("s_npc_weapon_de.de_mp40", class'StaticMesh')));
	SetDrawType( DT_StaticMesh );
}

defaultproperties
{
    InventoryType=class'WeapDEMP40_'

	DrawType=DT_Sprite
	Texture=Texture'Engine.S_Weapon'
    MessageClass=class'PickupMessagePlus'
    PickupMessage="You got the German MP40."
//    PickupSound=Sound'PickupSounds.AssaultRiflePickup'
    PickupForce="PickupDEMP40_"  // jdf
    PickupName="German MP 40"

	MaxDesireability=+0.4

//    StaticMesh=StaticMesh's_npc_weapon_de.de_mp40'
//    DrawType=DT_StaticMesh
    DrawScale=1.0
    bAcceptsProjectors=false

	AmmoAmount(0)=224
	ClipAmount(0)=32

	DropCueName="GEAR.DROPMACHINEGUN"
}
//=============================================================================
// PickupWeapDEP38_
//=============================================================================
class PickupWeapDEP38_ extends gbxWeaponPickup
	placeable;


simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();
	
	SetStaticMesh(StaticMesh(DynamicLoadObject("s_npc_weapon_de.de_p38", class'StaticMesh')));
	SetDrawType( DT_StaticMesh );
}

defaultproperties
{
    InventoryType=class'WeapDEP38_'

	DrawType=DT_Sprite
	Texture=Texture'Engine.S_Weapon'
    MessageClass=class'PickupMessagePlus'
    PickupMessage="You got the German P38 Pistol."
//    PickupSound=Sound'PickupSounds.AssaultRiflePickup'
    PickupForce="PickupDEP38_"  // jdf
    PickupName="German P38 Pistol"

	MaxDesireability=+0.4

//    StaticMesh=StaticMesh's_npc_weapon_de.de_p38'
//    DrawType=DT_StaticMesh
    DrawScale=1.0
    bAcceptsProjectors=false

	DropCueName="GEAR.DROPPISTOL"

	AmmoAmount(0)=96
	ClipAmount(0)=8
}
//=============================================================================
// PickupWeapDEPanzerfaust
//=============================================================================
class PickupWeapDEPanzerfaust extends gbxWeaponPickup
	placeable;


simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();
	
	SetStaticMesh(StaticMesh(DynamicLoadObject("s_npc_weapon_de.de_panzerfaust", class'StaticMesh')));
	SetDrawType( DT_StaticMesh );
}

defaultproperties
{
    InventoryType=class'WeapDEPanzerfaust'

	DrawType=DT_Sprite
	Texture=Texture'Engine.S_Weapon'
    MessageClass=class'PickupMessagePlus'
    PickupMessage="You got the German Panzerfaust."
//    PickupSound=Sound'PickupSounds.AssaultRiflePickup'
    PickupForce="PickupDEPanzerfaust"  // jdf
    PickupName="German Panzerfaust"

	MaxDesireability=+0.4

//    StaticMesh=StaticMesh's_npc_weapon_de.de_panzerfaust'
//    DrawType=DT_StaticMesh
    DrawScale=1.0
    bAcceptsProjectors=false

	AmmoAmount(0)=1
	ClipAmount(0)=1

	GetSurfTypeFromTexture=false // This fixes bug 6046.
}
//=============================================================================
// PickupWeapDESTG44_
//=============================================================================
class PickupWeapDESTG44_ extends gbxWeaponPickup
	placeable;


simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();
	
	SetStaticMesh(StaticMesh(DynamicLoadObject("s_npc_weapon_de.de_stg44", class'StaticMesh')));
	SetDrawType( DT_StaticMesh );
}

defaultproperties
{
    InventoryType=class'WeapDESTG44_'

	DrawType=DT_Sprite
	Texture=Texture'Engine.S_Weapon'
    MessageClass=class'PickupMessagePlus'
    PickupMessage="You got the German STG44 Machine Gun."
//    PickupSound=Sound'PickupSounds.AssaultRiflePickup'
    PickupForce="PickupDESTG44_"  // jdf
    PickupName="STG 44"

	MaxDesireability=+0.4

//    StaticMesh=StaticMesh's_npc_weapon_de.de_stg44'
//    DrawType=DT_StaticMesh
    DrawScale=1.0
    bAcceptsProjectors=false

	DropCueName="GEAR.DROPMACHINEGUN"

	AmmoAmount(0)=210
	ClipAmount(0)=30
}
//=============================================================================
// PickupWeapUSBar
//=============================================================================
class PickupWeapUSBar extends gbxWeaponPickup
	placeable;


simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();
	
	SetStaticMesh(StaticMesh(DynamicLoadObject("s_npc_weapon_us.us_bar", class'StaticMesh')));
	SetDrawType( DT_StaticMesh );
}

defaultproperties
{
    InventoryType=class'WeapUSBar'

	DrawType=DT_Sprite
	Texture=Texture'Engine.S_Weapon'
    MessageClass=class'PickupMessagePlus'
    PickupMessage="You got the US BAR Machine Gun."
//    PickupSound=Sound'PickupSounds.AssaultRiflePickup'
    PickupForce="PickupUSBar"  // jdf
    PickupName="US BAR"

	MaxDesireability=+0.4

//    StaticMesh=StaticMesh's_npc_weapon_us.us_bar'
//    DrawType=DT_StaticMesh
    DrawScale=1.0
    bAcceptsProjectors=false

	DropCueName="GEAR.DROPMACHINEGUN"

	AmmoAmount(0)=240
	ClipAmount(0)=20
}
//=============================================================================
// PickupWeapUSBazooka
//=============================================================================
class PickupWeapUSBazooka extends gbxWeaponPickup
	placeable;


simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();
	
	SetStaticMesh(StaticMesh(DynamicLoadObject("s_npc_weapon_us.us_bazooka", class'StaticMesh')));
	SetDrawType( DT_StaticMesh );
}

defaultproperties
{
    InventoryType=class'WeapUSBazooka'

	DrawType=DT_Sprite
	Texture=Texture'Engine.S_Weapon'
    MessageClass=class'PickupMessagePlus'
    PickupMessage="You got the US Bazooka."
//    PickupSound=Sound'PickupSounds.AssaultRiflePickup'
    PickupForce="PickupUSBazooka"  // jdf
    PickupName="US Bazooka"

	MaxDesireability=+0.4

//    StaticMesh=StaticMesh's_npc_weapon_us.us_bazooka'
//    DrawType=DT_StaticMesh
    DrawScale=1.0
    bAcceptsProjectors=false

	AmmoAmount(0)=5
	ClipAmount(0)=1
}
//=============================================================================
// PickupWeapUSColt1911Baker
//=============================================================================
class PickupWeapUSColt1911Baker extends PickupWeapUSColt1911_
	placeable;

defaultproperties
{
    InventoryType=class'WeapUSColt1911Baker'
	Skins(0)=Texture't_npc_weapon_us.us_colt_father'
}
//=============================================================================
// PickupWeapUSColt1911_
//=============================================================================
class PickupWeapUSColt1911_ extends gbxWeaponPickup
	placeable;


simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();
	
	SetStaticMesh(StaticMesh(DynamicLoadObject("s_npc_weapon_us.us_colt", class'StaticMesh')));
	SetDrawType( DT_StaticMesh );
}

defaultproperties
{
    InventoryType=class'WeapUSColt1911_'

	DrawType=DT_Sprite
	Texture=Texture'Engine.S_Weapon'
    MessageClass=class'PickupMessagePlus'
    PickupMessage="You got the US .45 Pistol."
//    PickupSound=Sound'PickupSounds.AssaultRiflePickup'
    PickupForce="PickupUSColt1911_"  // jdf
    PickupName="US .45 Pistol"

	MaxDesireability=+0.4

//    StaticMesh=StaticMesh's_npc_weapon_us.us_colt'
//    DrawType=DT_StaticMesh
    DrawScale=1.0
    bAcceptsProjectors=false

	DropCueName="GEAR.DROPPISTOL"

	AmmoAmount(0)=84
	ClipAmount(0)=7
}
//=============================================================================
// PickupWeapUSM1Carbine
//=============================================================================
class PickupWeapUSM1Carbine extends gbxWeaponPickup
	placeable;


simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();
	
	SetStaticMesh(StaticMesh(DynamicLoadObject("s_npc_weapon_us.us_m1_carbine", class'StaticMesh')));
	SetDrawType( DT_StaticMesh );
}

defaultproperties
{
    InventoryType=class'WeapUSM1Carbine'

	DrawType=DT_Sprite
	Texture=Texture'Engine.S_Weapon'
    MessageClass=class'PickupMessagePlus'
    PickupMessage="You got the US M1 Carbine Rifle."
//    PickupSound=Sound'PickupSounds.AssaultRiflePickup'
    PickupForce="PickupUSM1Carbine"  // jdf
    PickupName="US M1 Carbine Rifle"

	MaxDesireability=+0.4

//    StaticMesh=StaticMesh's_npc_weapon_us.us_m1_carbine'
//    DrawType=DT_StaticMesh
    DrawScale=1.0
    bAcceptsProjectors=false

	AmmoAmount(0)=75
	ClipAmount(0)=15
}
//=============================================================================
// PickupWeapUSM1_
//=============================================================================
class PickupWeapUSM1_ extends gbxWeaponPickup
	placeable;


simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();
	
	SetStaticMesh(StaticMesh(DynamicLoadObject("s_npc_weapon_us.us_m1", class'StaticMesh')));
	SetDrawType( DT_StaticMesh );
}

defaultproperties
{
    InventoryType=class'WeapUSM1_'

	DrawType=DT_Sprite
	Texture=Texture'Engine.S_Weapon'
    MessageClass=class'PickupMessagePlus'
    PickupMessage="You got the US M1 Rifle."
//    PickupSound=Sound'PickupSounds.AssaultRiflePickup'
    PickupForce="PickupUSM1_"  // jdf
    PickupName="US M1 Rifle"

	MaxDesireability=+0.4

//    StaticMesh=StaticMesh's_npc_weapon_us.us_m1'
//    DrawType=DT_StaticMesh
    DrawScale=1.0
    bAcceptsProjectors=false

	AmmoAmount(0)=88
	ClipAmount(0)=8
}
//=============================================================================
// PickupWeapUSM3A1_
//=============================================================================
class PickupWeapUSM3A1_ extends gbxWeaponPickup
	placeable;


simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();
	
	SetStaticMesh(StaticMesh(DynamicLoadObject("s_npc_weapon_us.us_m3a1", class'StaticMesh')));
	SetDrawType( DT_StaticMesh );
}

defaultproperties
{
    InventoryType=class'WeapUSM3A1_'

	DrawType=DT_Sprite
	Texture=Texture'Engine.S_Weapon'
    MessageClass=class'PickupMessagePlus'
    PickupMessage="You got the US M3A1 Sub-Machine Gun."
//    PickupSound=Sound'PickupSounds.AssaultRiflePickup'
    PickupForce="PickupUSM3A1_"  // jdf
    PickupName="US M3A1 Sub-Machine Gun"

	MaxDesireability=+0.4

//    StaticMesh=StaticMesh's_npc_weapon_us.us_m3a1'
//    DrawType=DT_StaticMesh
    DrawScale=1.0
    bAcceptsProjectors=false

	DropCueName="GEAR.DROPMACHINEGUN"

	AmmoAmount(0)=140
	ClipAmount(0)=20
}
//=============================================================================
// PickupWeapUSSpringfield
//=============================================================================
class PickupWeapUSSpringfield extends gbxWeaponPickup
	placeable;


simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();
	
	SetStaticMesh(StaticMesh(DynamicLoadObject("s_npc_weapon_us.us_springfield", class'StaticMesh')));
	SetDrawType( DT_StaticMesh );
}

defaultproperties
{
    InventoryType=class'WeapUSSpringfield'

	DrawType=DT_Sprite
	Texture=Texture'Engine.S_Weapon'
    MessageClass=class'PickupMessagePlus'
    PickupMessage="You got the US M1903 Bolt-Action Rifle."
//    PickupSound=Sound'PickupSounds.AssaultRiflePickup'
    PickupForce="PickupUSSpringfield"  // jdf
    PickupName="US M1903 Bolt-Action Rifle"

	MaxDesireability=+0.4

//    StaticMesh=StaticMesh's_npc_weapon_us.us_springfield'
//    DrawType=DT_StaticMesh
    DrawScale=1.0
    bAcceptsProjectors=false

	AmmoAmount(0)=55
	ClipAmount(0)=5
}
//=============================================================================
// PickupWeapUSThompson
//=============================================================================
class PickupWeapUSThompson extends gbxWeaponPickup
	placeable;


simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();
	
	SetStaticMesh(StaticMesh(DynamicLoadObject("s_npc_weapon_us.us_thompson", class'StaticMesh')));
	SetDrawType( DT_StaticMesh );
}

defaultproperties
{
    InventoryType=class'WeapUSThompson'

	DrawType=DT_Sprite
	Texture=Texture'Engine.S_Weapon'
    MessageClass=class'PickupMessagePlus'
    PickupMessage="You got the US M1A1 Sub-Machine Gun."
//    PickupSound=Sound'PickupSounds.AssaultRiflePickup'
    PickupForce="PickupUSThompson"  // jdf
    PickupName="US M1A1 Sub-Machine Gun"

	MaxDesireability=+0.4

//    StaticMesh=StaticMesh's_npc_weapon_us.us_thompson'
//    DrawType=DT_StaticMesh
    DrawScale=1.0
    bAcceptsProjectors=false

	DropCueName="GEAR.DROPMACHINEGUN"

	AmmoAmount(0)=140
	ClipAmount(0)=20
}
//=============================================================================
// PickupWeapUSThompson
//=============================================================================
class PickupWeapUSThompsonMud extends PickupWeapUSThompson
	placeable;


simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();
	
	Skins[0] = Texture( DynamicLoadObject( "t_npc_weapon_us.us_thompson_muddy", class'Texture' ) );
}

defaultproperties
{
    InventoryType=class'WeapUSThompsonMud'
}//=============================================================================
// Base class for all grenades
//=============================================================================
class ProjectileDEPak36_ extends ProjectileRocket;

var Weapon	LaunchingWeapon;

simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();
	
	SetStaticMesh(StaticMesh(DynamicLoadObject("s_military_de.Weapon.tank_round", class'StaticMesh')));
}

simulated function ProcessTouch( actor Other, vector HitLocation )
{
	if (!bActive)
		return;

	if ( Other!=instigator && Other != LaunchingWeapon )
	{
		Explosion(HitLocation);
		bActive = false;
	}
}

defaultproperties
{
	ExplosionDecal=class'BlastMark'
	ExplosionDecalVehicle=class'BlastMarkSmallVehicle'
	MyDamageType=class'DamageUSBazooka'
    DamageRadius=375.000000
//	StaticMesh=StaticMesh's_military_de.Weapon.tank_round'
	DrawScale=2.00000
	DrawType=DT_STATICMESH
	bUseTrail=false

	speed=20000.0
}
//=============================================================================
// Base class for all grenades
//=============================================================================
class ProjectileDEPAK88_ extends ProjectileRocket;

var Weapon	LaunchingWeapon;

const HEAVY_TRAUMA_SOUND_DELAY=0.5f;

simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();
	
	SetStaticMesh(StaticMesh(DynamicLoadObject("s_military_de.Weapon.tank_round", class'StaticMesh')));  
}

simulated function ProcessTouch( actor Other, vector HitLocation )
{
	if (!bActive)
		return;

	if ( Other!=instigator && Other != LaunchingWeapon )
	{
		Explosion(HitLocation);
		bActive = false;
	}
}


simulated function HurtRadius( float DamageAmount, float DamageRadius, class<DamageType> DamageType, float Momentum, vector HitLocation )
{
	local actor Victims;
	local float damageScale, dist;
	local vector dir;
	local Vector HitLoc, HitNormal;
	local name HitBoxName;
	local Actor HitActor;
	local float Coll_Height, Coll_Radius;

	if( bHurtEntry )
		return;

	bHurtEntry = true;

	// For Bazookas use 'RadiusActors()' instead of 'VisibleCollidingActors()' to slightly damage
	// Pawns that are behind nearby cover...
	foreach RadiusActors( class 'Actor', Victims, DamageRadius, HitLocation )
	{
		// don't let blast damage affect fluid - CollisingActors doesn't really work for them - jag
		if( (Victims != self) && (Victims.Role == ROLE_Authority) )
		{
			if (gbxVehicle(Victims) != None)
			{
				Coll_Height = gbxVehicle(Victims).VehicleCollisionHeight;
				Coll_Radius = gbxVehicle(Victims).VehicleCollisionRadius;
			}
			else
			{
				Coll_Height = Victims.CollisionHeight;
				Coll_Radius = Victims.CollisionRadius;
			}

			dir = Victims.Location - HitLocation;
			dist = FMax(1,VSize(dir));
			dir = dir/dist;
			damageScale = 1 - FMax(0,(dist - Coll_Radius)/DamageRadius);

			HitActor = Trace( HitLoc, HitNormal, Victims.Location, HitLocation, true,,,true,, HitBoxName );

			if (HitActor == Victims)  // victim was exposed, gets full brunt of blast...
			{
				Victims.TakeDamage
				(
					damageScale * DamageAmount,
					Instigator,
					Victims.Location - 0.5 * (Coll_Height + Coll_Radius) * dir,
					(damageScale * Momentum * dir),
					DamageType,
					HitBoxName
				);
			}
			else  // victim was only partially exposed (or completely hidden), gets 1/2 of blast...
			{
				damageScale = damageScale * 0.5f;
				Victims.TakeDamage
				(
					damageScale * DamageAmount,
					Instigator,
					Victims.Location - 0.5 * (Coll_Height + Coll_Radius) * dir,
					(damageScale * Momentum * dir),
					DamageType,
					HitBoxName
				);
			}

			if( dist < HeavyTraumaRadius && Level.Game.IsA('WargameSinglePlayer') && Victims.IsA('gbxPlayerPawn') && gbxPlayerController(Pawn(Victims).Controller) != None )
			{
					if (damageScale < 0.5)
					{
						gbxPawn(Victims).DoMeleeTrauma();
						gbxPawn(Victims).bPlayHeavyTraumaSound = true;
						gbxPawn(Victims).flHeavyTraumaSoundTime = Level.TimeSeconds + HEAVY_TRAUMA_SOUND_DELAY;
					}
					else 
					{
						WeapDEPAK88_(self.LaunchingWeapon).SetPlayerHitTimer(Level.TimeSeconds);  //NAC set a delay on the next time the 88 can fire when it hits the player to allow him to get back on his feet!
						gbxPlayerController(Pawn(Victims).Controller).DoHeavyTrauma();
					}
			}
		}
	}
	bHurtEntry = false;
}


defaultproperties
{
	ExplosionDecal=class'BlastMark'
	ExplosionDecalVehicle=class'BlastMarkSmallVehicle'
	MyDamageType=class'DamageUSBazooka'
    DamageRadius=750.000000
	Damage=500.000000
//	StaticMesh=StaticMesh's_military_de.Weapon.tank_round'
	DrawScale=2.00000
	DrawType=DT_STATICMESH
	bUseTrail=false

	speed=20000.0
}
//=============================================================================
// Base class for all grenades
//=============================================================================
class ProjectileDEPanzerfaust extends ProjectileRocket;

simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();
	
	SetStaticMesh(StaticMesh(DynamicLoadObject("s_npc_weapon_de.de_panzerfaust_projectile", class'StaticMesh')));
}

defaultproperties
{
	ExplosionDecal=class'BlastMark'
	ExplosionDecalVehicle=class'BlastMarkSmallVehicle'
	MyDamageType=class'DamageUSBazooka'    
	DamageRadius=375.000000
//	StaticMesh=StaticMesh's_npc_weapon_de.de_panzerfaust_projectile'
	DrawType=DT_STATICMESH
	bUseTrail=false

	RocketDrag = 750.0
	speed = 4500.0

	WeaponCategory=WC_Bazooka

	bCollideWorld=false
	bCollideActors=false
}

class ProjectileFire extends WeaponFire;


var() float Spread; // rotator units. no relation to AimError
var() enum ESpreadStyle
{
    SS_None,
    SS_Random, // spread is max random angle deviation
    SS_Line   // spread is angle between each projectile
} SpreadStyle;

var() Vector ProjSpawnOffset; // +x forward, +y right, +z up

function DoFireEffect()
{
    local Vector StartProj, StartTrace, X,Y,Z;
    local Rotator R, Aim;
    local Vector HitLocation, HitNormal;
    local Actor Other;
    local int p;
    local int SpawnCount;
    local float theta;

    Instigator.MakeNoise(1.0);
    Weapon.GetViewAxes(X,Y,Z);

    StartTrace = Instigator.Location + Instigator.EyePosition();// + X*Instigator.CollisionRadius;
    StartProj = StartTrace + X*ProjSpawnOffset.X + Y*ProjSpawnOffset.Y + Z*ProjSpawnOffset.Z;

    // check if projectile would spawn through a wall and adjust start location accordingly
    Other = Trace(HitLocation, HitNormal, StartProj, StartTrace, false);
    if (Other != None)
    {
        StartProj = HitLocation;
    }

	Aim = AdjustAimNew(StartProj);

    SpawnCount = Max(1, ProjPerFire * Load);

    switch (SpreadStyle)
    {
    case SS_Random:
        X = Vector(Aim);
        for (p = 0; p < SpawnCount; p++)
        {
            R.Yaw = Spread * (FRand()-0.5);
            R.Pitch = Spread * (FRand()-0.5);
            R.Roll = Spread * (FRand()-0.5);
            SpawnProjectile(StartProj, Rotator(X >> R));
        }
        break;
    case SS_Line:
        for (p = 0; p < SpawnCount; p++)
        {
            theta = Spread*PI/32768*(p - float(SpawnCount-1)/2.0);
            X.X = Cos(theta);
            X.Y = Sin(theta);
            X.Z = 0.0;
            SpawnProjectile(StartProj, Rotator(X >> Aim));
        }
        break;
    default:
        SpawnProjectile(StartProj, Aim);
    }
}

function projectile SpawnProjectile(Vector Start, Rotator Dir)
{
    local Projectile p;

    if( ProjectileClass != None )
        p = Spawn(ProjectileClass, self,, Start, Dir);

    if( p == None )
        return None;

    p.ProjOwner = Weapon.Instigator.Controller;
    p.Damage = Ceil(p.Damage * DamageAtten);
    return p;
}

simulated function vector GetFireStart(vector X, vector Y, vector Z)
{
    return Instigator.Location + Instigator.EyePosition() + X*ProjSpawnOffset.X + Y*ProjSpawnOffset.Y + Z*ProjSpawnOffset.Z;
}

defaultproperties
{
    ProjPerFire=1
	SpreadStyle=SS_None
    ProjSpawnOffset=(X=0,Y=0,Z=-10)

    bLeadTarget=true
    bInstantHit=false
	WarnTargetPct=+0.5
}
//=============================================================================
// German Hand Grenade
//=============================================================================
class ProjectileGermanHandGrenade extends gbxGrenade;


simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();
	
	SetStaticMesh(StaticMesh(DynamicLoadObject("s_military_de.Weapon.stick_grenade", class'StaticMesh')));
}

defaultproperties
{
	Damage=300.000000

	ImpactSoundCueName="IMPACTS.STICKGRENADE_GROUND"

//	StaticMesh=StaticMesh's_military_de.Weapon.stick_grenade'
	AttachTagName=righthand_grenade_us

	HeavyTraumaRadius=384.0

	bBlowingUp=false
}
//=============================================================================
// Multiplayer German Hand Grenade
//=============================================================================
class ProjectileGermanHandGrenadeMP extends gbxGrenade;


simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();
	
	SetStaticMesh(StaticMesh(DynamicLoadObject("s_military_de.Weapon.stick_grenade", class'StaticMesh')));
}

defaultproperties
{
	Damage=200.0f
	DamageRadius=800.0f


	ImpactSoundCueName="IMPACTS.STICKGRENADE_GROUND"

//	StaticMesh=StaticMesh's_military_de.Weapon.stick_grenade'
	AttachTagName=righthand_grenade_us

	HeavyTraumaRadius=384.0

	bBlowingUp=false
}
class ProjectileRocket extends gbxProjectile;

var Vector	FireVector;
var bool	bHitWater;
var bool	bActive;
var bool	bUseTrail;
var bool	bUsingSafeLaunches;
var vector  Direction;
var float	m_flTravelTime;
var float	RocketDrag;
var float	SafeLaunchDist, PlayerSafeLaunchDist;

var	BazookaRocketTrail trail;

var   class<Projector> ExplosionDecalVehicle;

simulated function PostNetBeginPlay()
{
	Direction = vector(Rotation);
	Velocity = speed * Direction;
	if (PhysicsVolume.bWaterVolume)
	{
		bHitWater = True;
		Velocity=0.6*Velocity;
	}
	bActive = true;

	if ( (Pawn(Owner).IsLocallyControlled() ) || (ROLE!=ROLE_Authority) )
	{
		if ( bUseTrail )
		{
			Trail = Spawn(class'BazookaRocketTrail',self);
			log(self$".PostNetBeginPlay() - "$Trail);
			Trail.SetBase(Self);
		}
	}
	
	// GBX:naj - fix bug 9223: Humans and NPCs should use different safe-launch distances (50 for player; 520 for NPCs).
	if ( Pawn(Owner).IsHumanControlled() )
	{
		SafeLaunchDist = Default.PlayerSafeLaunchDist;
	}

	Super.PostNetBeginPlay();

	SetStaticMesh(StaticMesh(DynamicLoadObject("s_npc_weapon_us.us_rocket_projectile", class'StaticMesh')));	
}

simulated function BeginPlay()
{
	if ( (Level.DetailMode != DM_Low) && !Level.bDropDetail )
		SmokeRate = 0.03;
	else
		SmokeRate = 0.15;
}

// Ensures that the shell will not explode close to the shooter.
simulated function UseSafetyLaunch()
{
	bUsingSafeLaunches = true;
	bCollideWorld = false;
	SetCollision( false, false, false );
	bActive = false;
}

simulated function PhysicsVolumeChange( PhysicsVolume NewVolume )
{
	if ( !NewVolume.bWaterVolume || bHitWater )
		return;

	bHitWater = True;
	Spawn(class'WaterSplashLarge',,,,rot(16384,0,0));			//-BB
	Velocity=0.6*Velocity;
}

simulated function ProcessTouch( actor Other, vector HitLocation )
{
	if (!bActive)
		return;

	if ( Other!=instigator )
	{
		Explosion(HitLocation);
		bActive = false;
	}
}

simulated function HitWall( vector HitLocation, vector HitNormal, actor Wall )
{
	local Projector Decal;
	local ProjectorRelative DecalRelative;
	local vector vHit, TraceEnd;
	local float Length;

	if (!bActive)
		return;

	Velocity = Vect( 0, 0, 0 );

	vHit = HitLocation - Location;
	Length = VSize(vHit);
	vHit = Normal(vHit);

	TraceEnd = Location + (vHit * (Length + 1.0f));

	if (TraceHitBackDrop(TraceEnd, Location))
	{
		Destroy();
		return;
	}

	if ( Role == ROLE_Authority )
	{
		if ( Mover(Wall) != None )
			Wall.TakeDamage( Damage, instigator, Location, MomentumTransfer * Normal(Velocity), MyDamageType);

		MakeNoise(1.0);
	}

	Explosion(Location + ExploWallOut * HitNormal);

	if (Wall.IsA('gbxSVehicle'))
	{
		if ( (ExplosionDecalVehicle != None) && (Level.NetMode != NM_DedicatedServer) )
		{
			Decal = Spawn(ExplosionDecalVehicle,self,,Location, rotator(-HitNormal));
			DecalRelative = ProjectorRelative(Decal);
			if (DecalRelative != None)
			{
			    DecalRelative.SetRelativeProjector(Wall, Location, rotator(-HitNormal));
			}
		}
	}
	else
	{
		if ( (ExplosionDecal != None) && (Level.NetMode != NM_DedicatedServer) )
		{
			Decal = Spawn(ExplosionDecal,self,,Location, rotator(-HitNormal));
		}
	}
}

function ServerExplosion(vector HitLocation)
{
	Explosion( HitLocation );
}

simulated function Destroyed()
{
	if ( Trail != None )
	{
		Trail.ShutdownTrail();
	}
	
	Super.Destroyed();
}

simulated function HurtRadius( float DamageAmount, float DamageRadius, class<DamageType> DamageType, float Momentum, vector HitLocation )
{
	local actor Victims;
	local float damageScale, dist;
	local vector dir;
	local Vector HitLoc, HitNormal;
	local name HitBoxName;
	local Actor HitActor;
	local float Coll_Height, Coll_Radius;

	if( bHurtEntry )
		return;

	bHurtEntry = true;

	// For Bazookas use 'RadiusActors()' instead of 'VisibleCollidingActors()' to slightly damage
	// Pawns that are behind nearby cover...
	foreach RadiusActors( class 'Actor', Victims, DamageRadius, HitLocation )
	{
		// don't let blast damage affect fluid - CollisingActors doesn't really work for them - jag
		if( (Victims != self) && (Victims.Role == ROLE_Authority) )
		{
			if (gbxVehicle(Victims) != None)
			{
				Coll_Height = gbxVehicle(Victims).VehicleCollisionHeight;
				Coll_Radius = gbxVehicle(Victims).VehicleCollisionRadius;
			}
			else
			{
				Coll_Height = Victims.CollisionHeight;
				Coll_Radius = Victims.CollisionRadius;
			}

			dir = Victims.Location - HitLocation;
			dist = FMax(1,VSize(dir));
			dir = dir/dist;
			damageScale = 1 - FMax(0,(dist - Coll_Radius)/DamageRadius);

			HitActor = Trace( HitLoc, HitNormal, Victims.Location, HitLocation, true,,,true,, HitBoxName );

			if (HitActor == Victims)  // victim was exposed, gets full brunt of blast...
			{
				Victims.TakeDamage
				(
					damageScale * DamageAmount,
					Instigator,
					Victims.Location - 0.5 * (Coll_Height + Coll_Radius) * dir,
					(damageScale * Momentum * dir),
					DamageType,
					HitBoxName
				);
			}
			else  // victim was only partially exposed (or completely hidden), gets 1/2 of blast...
			{
				damageScale = damageScale * 0.5f;

				Victims.TakeDamage
				(
					damageScale * DamageAmount,
					Instigator,
					Victims.Location - 0.5 * (Coll_Height + Coll_Radius) * dir,
					(damageScale * Momentum * dir),
					DamageType,
					HitBoxName
				);
			}

			if( dist < HeavyTraumaRadius && Level.Game.IsA('WargameSinglePlayer') && Victims.IsA('gbxPlayerPawn') && gbxPlayerController(Pawn(Victims).Controller) != None )
			{
				gbxPlayerController(Pawn(Victims).Controller).DoHeavyTrauma();
			}
		}
	}
	bHurtEntry = false;
}

simulated function Tick(float DeltaTime)
{
	Super.Tick( DeltaTime );
	
	if ( bUsingSafeLaunches && Instigator != None )
	{
		if ( VSize( Location - Instigator.Location ) > SafeLaunchDist )
		{
			bCollideWorld = true;
			SetCollision( true, true, true );
			bUsingSafeLaunches = false;
			bActive = true;
		}
	}

	if ((m_aGuideTarget != None) && (m_flNextGuideTime < Level.TimeSeconds))
	{
		Velocity = VSize( Velocity ) * Normal( m_aGuideTarget.Location - Location );
		m_flNextGuideTime = Level.TimeSeconds + GUIDE_DELAY_TIME;
	}

	m_flTravelTime += DeltaTime;

	// Add drag
	Velocity -= Direction * RocketDrag * DeltaTime;

	// Add gravity over time
	Velocity.Z += PhysicsVolume.Gravity.Z * 0.5 * m_flTravelTime * DeltaTime;

	// Rotation changes
	SetRotation( Rotator( Velocity ) );
}

defaultproperties
{
	ExplosionDecal=class'BlastMark'
	ExplosionDecalVehicle=class'BlastMarkSmallVehicle'
	MyDamageType=class'DamageUSBazooka'
    speed=6000.0
	MaxSpeed=6000.000000
	Damage=500.000000
    RemoteRole=ROLE_SimulatedProxy
    LifeSpan=8.0
	DamageRadius=375.000000
	MomentumTransfer=50000
	Physics=PHYS_Projectile
//	StaticMesh=StaticMesh's_npc_weapon_us.us_rocket_projectile'
	DrawScale=1.00000
	AmbientGlow=64
	bBounce=false
    bCollideWorld=true
	bFixedRotationDir=True
	DrawType=DT_STATICMESH

    ShakeRadius=2000.000000
	ViewRollTime=0.200000
	RollMag=20.000000
	RollRate=100.000000
	OffsetMagVertical=20.000000
	OffsetRateVertical=800.000000
	OffsetMagHorizontal=20.000000
	OffsetRateHorizontal=800.000000
	OffsetIterations=10.000000

	bBlowingUp=false

	FuseTimeMin=5.0
	FuseTimeMax=6.0

	HeavyTraumaRadius=768.0
	
	bUseTrail=false
	bActive=false
	bDestroyWhenDone=true

	SafeLaunchDist=520.0f	// Damage radius plus a safety threshold
	PlayerSafeLaunchDist=35.0f
}//=============================================================================
// Base class for all grenades
//=============================================================================
class ProjectileUSBazooka extends ProjectileRocket;

simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();
	
	SetStaticMesh(StaticMesh(DynamicLoadObject("s_npc_weapon_us.us_rocket_projectile", class'StaticMesh')));
}

defaultproperties
{
	ExplosionDecal=class'BlastMark'
	ExplosionDecalVehicle=class'BlastMarkSmallVehicle'
	MyDamageType=class'DamageUSBazooka'
    DrawType=DT_STATICMESH
//	StaticMesh=StaticMesh's_npc_weapon_us.us_rocket_projectile'
	DamageRadius=375.000000
	bUseTrail=false

	RocketDrag=1500.0

	speed=8000.0

	DrawScale=2.0

	WeaponCategory=WC_Bazooka

	bCollideWorld=false
	bCollideActors=false
}

//=============================================================================
// US Hand Grenade
//=============================================================================
class ProjectileUSHandGrenade extends gbxGrenade;


simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();
	
	SetStaticMesh(StaticMesh(DynamicLoadObject("s_npc_weapon_us.us_grenade", class'StaticMesh')));
}

defaultproperties
{
	Damage=400.000000

//	StaticMesh=StaticMesh's_npc_weapon_us.us_grenade'
	AttachTagName=righthand_grenade_us

	bBlowingUp=false
}
//=============================================================================
// Multiplayer US Hand Grenade
//=============================================================================
class ProjectileUSHandGrenadeMP extends gbxGrenade;


simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();
	
	SetStaticMesh(StaticMesh(DynamicLoadObject("s_npc_weapon_us.us_grenade", class'StaticMesh')));
}

defaultproperties
{
	Damage=200.0f
	DamageRadius=800.0f

//	StaticMesh=StaticMesh's_npc_weapon_us.us_grenade'
	AttachTagName=righthand_grenade_us

	bBlowingUp=false
}
class RemoveableInventory extends KActor;



var name AttachBoneName;

event AttachRemoveable( Actor A )
{
	SetOwner( A );
	Owner.AttachToBone( Self, AttachBoneName );
	SetPhysics( PHYS_None );
	SetCollision( False );
	bCollideWorld=False;
	bBlockNonZeroExtentTraces=False;
	bBlockZeroExtentTraces=False;
	KSetBlockKarma( False );
}

event bool DetachRemoveable( Vector momentum )
{
	if( KarmaParams( KParams ) != None )
	{
		Owner.DetachFromBone( Self );
		Velocity = momentum;
		SetOwner( None );
		SetCollision( Default.bCollideActors );
		bCollideWorld=Default.bCollideWorld;
		bBlockNonZeroExtentTraces=Default.bBlockNonZeroExtentTraces;
		bBlockZeroExtentTraces=Default.bBlockZeroExtentTraces;
		KSetBlockKarma( Default.bBlockKarma );
		SetPhysics( PHYS_Karma );
		KWake();
		return true;
	}
	return false;
}

defaultproperties
{
	bStatic=false
	bNoDelete=false
	Physics=PHYS_None
	DrawType=DT_StaticMesh
	bBlockActors=False
	bBlockPlayers=False
	KParams=None
}
class ShellDEFG42_ extends gbxWeaponShells;


defaultproperties
{
   Begin Object Class=SpriteEmitter Name=SpriteEmitter2
	   SecondsBeforeInactive=0
       Acceleration=(Z=-900.000000)
       UseCollision=True
       DampingFactorRange=(X=(Min=0.500000,Max=0.500000),Y=(Min=0.500000,Max=0.500000),Z=(Min=0.500000,Max=0.500000))
       UseMaxCollisions=True
       MaxCollisions=(Min=3.000000,Max=5.000000)
       ColorScale(0)=(Color=(B=255,G=255,R=255,A=255))
       ColorScale(1)=(RelativeTime=1.000000,Color=(B=255,G=255,R=255,A=255))
       FadeOutStartTime=3.200000
       FadeOut=True
       MaxParticles=30
       RespawnDeadParticles=False
       UseRotationFrom=PTRS_Offset
       SpinParticles=True
       StartSpinRange=(X=(Max=1.000000))
       StartSizeRange=(X=(Min=5.000000,Max=5.000000),Y=(Min=5.000000,Max=5.000000),Z=(Min=5.000000,Max=5.000000))
       UniformSize=True
       InitialParticlesPerSecond=0.000000
       AutomaticInitialSpawning=False
       DrawStyle=PTDS_AlphaBlend
       Texture=Texture't_effect.particle.casing_m1'
       TextureUSubdivisions=4
       TextureVSubdivisions=8
       BlendBetweenSubdivisions=True
       SubdivisionEnd=31
       LifetimeRange=(Min=2.000000)
       StartVelocityRange=(X=(Min=-20.000000,Max=20.000000),Y=(Min=100.000000,Max=150.000000),Z=(Min=150.000000,Max=250.000000))
   End Object
   Emitters(0)=SpriteEmitter'SpriteEmitter2'

	EmitterSoundName="GEAR.SHELL"
	PlaySoundPct = 0.8
}
class ShellDEK98_ extends gbxWeaponShells;


defaultproperties
{
   Begin Object Class=SpriteEmitter Name=SpriteEmitter1
       SecondsBeforeInactive=0
       Acceleration=(Z=-900.000000)
       UseCollision=True
       DampingFactorRange=(X=(Min=0.500000,Max=0.500000),Y=(Min=0.500000,Max=0.500000),Z=(Min=0.500000,Max=0.500000))
       UseMaxCollisions=True
       MaxCollisions=(Min=3.000000,Max=5.000000)
       ColorScale(0)=(Color=(B=255,G=255,R=255,A=255))
       ColorScale(1)=(RelativeTime=1.000000,Color=(B=255,G=255,R=255,A=255))
       FadeOutStartTime=3.200000
       FadeOut=True
       MaxParticles=10
       RespawnDeadParticles=False
       UseRotationFrom=PTRS_Offset
       SpinParticles=True
       StartSpinRange=(X=(Max=1.000000))
       StartSizeRange=(X=(Min=5.000000,Max=5.000000),Y=(Min=5.000000,Max=5.000000),Z=(Min=5.000000,Max=5.000000))
       UniformSize=True
       InitialParticlesPerSecond=0.000000
       AutomaticInitialSpawning=False
       DrawStyle=PTDS_AlphaBlend
       Texture=Texture't_effect.particle.casing_m1'
       TextureUSubdivisions=4
       TextureVSubdivisions=8
       BlendBetweenSubdivisions=True
       SubdivisionEnd=31
       LifetimeRange=(Min=2.000000)
       StartVelocityRange=(X=(Min=75.000000,Max=100.000000),Y=(Min=75.000000,Max=125.000000),Z=(Min=250.000000,Max=275.000000))
   End Object
   Emitters(0)=SpriteEmitter'SpriteEmitter1'

	EmitterSoundName="GEAR.SHELL"
	PlaySoundPct = 1.0

}
class ShellDEMG42_ extends gbxWeaponShells;


defaultproperties
{
   Begin Object Class=SpriteEmitter Name=SpriteEmitter63
	   SecondsBeforeInactive=0
       Acceleration=(Z=-900.000000)
       UseCollision=True
       DampingFactorRange=(X=(Min=0.500000,Max=0.500000),Y=(Min=0.500000,Max=0.500000),Z=(Min=0.500000,Max=0.500000))
       UseMaxCollisions=True
       MaxCollisions=(Min=3.000000,Max=5.000000)
       ColorScale(0)=(Color=(B=255,G=255,R=255,A=255))
       ColorScale(1)=(RelativeTime=1.000000,Color=(B=255,G=255,R=255,A=255))
       FadeOutStartTime=3.200000
       FadeOut=True
       MaxParticles=30
       RespawnDeadParticles=False
       UseRotationFrom=PTRS_Offset
       SpinParticles=True
       StartSpinRange=(X=(Max=1.000000))
       StartSizeRange=(X=(Min=5.000000,Max=5.000000),Y=(Min=5.000000,Max=5.000000),Z=(Min=5.000000,Max=5.000000))
       UniformSize=True
       InitialParticlesPerSecond=0.000000
       AutomaticInitialSpawning=False
       DrawStyle=PTDS_AlphaBlend
       Texture=Texture't_effect.particle.casing_m1'
       TextureUSubdivisions=4
       TextureVSubdivisions=8
       BlendBetweenSubdivisions=True
       SubdivisionEnd=31
       LifetimeRange=(Min=2.000000)
       StartVelocityRange=(X=(Min=-20.000000,Max=20.000000),Y=(Min=100.000000,Max=150.000000),Z=(Min=150.000000,Max=250.000000))
   End Object
   Emitters(0)=SpriteEmitter'SpriteEmitter63'

	EmitterSoundName="GEAR.SHELL"
	PlaySoundPct = 0.8
}
class ShellDEP38_ extends gbxWeaponShells;


defaultproperties
{
    Begin Object Class=MeshEmitter Name=MeshEmitter4
		SecondsBeforeInactive=0
		// GBX:najnaj
        //StaticMesh=StaticMesh's_military_us.Weapon.m1_shell'
        Acceleration=(Z=-900.000000)
        UseCollision=True
		DampingFactorRange=(X=(Min=0.200000,Max=0.200000),Y=(Min=0.200000,Max=0.200000),Z=(Min=0.200000,Max=0.200000))
        MaxParticles=40
        UseRotationFrom=PTRS_Offset
		SpinParticles=True
        SpinsPerSecondRange=(X=(Min=-1.000000,Max=4.000000),Y=(Min=-2.000000,Max=2.000000),Z=(Min=-1.000000,Max=2.000000))
        DampRotation=True
		RotationDampingFactorRange=(X=(Min=0.200000,Max=0.200000),Y=(Min=0.200000,Max=0.200000),Z=(Min=0.200000,Max=0.200000))
		StartSizeRange=(X=(Min=0.1,Max=0.1),Y=(Min=0.05,Max=0.03),Z=(Min=0.1,Max=0.1))
		AutomaticInitialSpawning=False
        ParticlesPerSecond=0.000000
        InitialParticlesPerSecond=0.000000
		LifetimeRange=(Min=2.000000,Max=2.000000)
		RespawnDeadParticles=False
        StartVelocityRange=(X=(Min=-100.000000,Max=100.000000),Y=(Min=200.000000,Max=250.000000),Z=(Min=100.000000,Max=125.000000))
    End Object

	EmitterSoundName="GEAR.SHELL"
	PlaySoundPct = 1.0

    Emitters(0)=MeshEmitter'MeshEmitter4'
}
class ShellDEPanzerfaustCasing extends KActor;

var Range SpinRange;

const CASING_LIFETIME=10.0;

simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();
	
	SetStaticMesh(StaticMesh(DynamicLoadObject("s_npc_weapon_de.de_npc_weapons_temp.de_panzerfaust_spent", class'StaticMesh')));
}

simulated function ThrowCasing( Pawn WeapOwner )
{
	if( Level.NetMode == NM_Standalone )
	{
		KParams = new(Self,"PanzerCasingKarmaParams")class'KarmaParams';

		if( KParams != None && KarmaParams(KParams) != None )
		{
			KarmaParams(KParams).KMass=1.0;
			KarmaParams(KParams).KStartEnabled=false;
			KarmaParams(KParams).bHighDetailOnly=false;
			KarmaParams(KParams).KFriction=0.75000;
			KarmaParams(KParams).KRestitution=0.020000;
			KarmaParams(KParams).bKStayUpright=false;
			KarmaParams(KParams).KLinearDamping=0.2;
			KarmaParams(KParams).KAngularDamping=0.25;
			KarmaParams(KParams).KVelDropBelowThreshold=5.0;
			KarmaParams(KParams).KImpactThreshold=100.0;
			KarmaParams(KParams).KBuoyancy=0.2;
			KarmaParams(KParams).bDoSafeTime=true;
			KarmaParams(KParams).KStartLinVel = Vector( WeapOwner.GetViewRotation() ) * 512.0 >> Rot(0,16384,0);
			KarmaParams(KParams).KStartAngVel = Normal( Location - (WeapOwner.Location + WeapOwner.EyePosition()) ) * RandRange( SpinRange.Min, SpinRange.Max );

			SetPhysics( PHYS_Karma );

			KWake();
		}
	}
	else
	{
		SetPhysics( PHYS_Falling );
	}

	SetTimer( CASING_LIFETIME, false );
}

function Timer()
{
	SetPhysics( PHYS_None );
	Destroy();
}

defaultproperties
{
	CollisionRadius=+0015.000000
	CollisionHeight=+008.000000
	Physics=PHYS_None;
	bNoDelete=false
//	StaticMesh=StaticMesh's_npc_weapon_de.de_npc_weapons_temp.de_panzerfaust_spent'
	bBlockPlayers=False
	bBlockActors=False
	SpinRange=(Min=-256.0,Max=256.0);
	ImpactCueName="GEAR.DROPRIFLE"
}class ShellDESTG44_ extends gbxWeaponShells;


defaultproperties
{
   Begin Object Class=SpriteEmitter Name=SpriteEmitter2
	   SecondsBeforeInactive=0
       Acceleration=(Z=-900.000000)
       UseCollision=True
       DampingFactorRange=(X=(Min=0.500000,Max=0.500000),Y=(Min=0.500000,Max=0.500000),Z=(Min=0.500000,Max=0.500000))
       UseMaxCollisions=True
       MaxCollisions=(Min=3.000000,Max=5.000000)
       ColorScale(0)=(Color=(B=255,G=255,R=255,A=255))
       ColorScale(1)=(RelativeTime=1.000000,Color=(B=255,G=255,R=255,A=255))
       FadeOutStartTime=3.200000
       FadeOut=True
       MaxParticles=30
       RespawnDeadParticles=False
       UseRotationFrom=PTRS_Offset
       SpinParticles=True
       StartSpinRange=(X=(Max=1.000000))
       StartSizeRange=(X=(Min=5.000000,Max=5.000000),Y=(Min=5.000000,Max=5.000000),Z=(Min=5.000000,Max=5.000000))
       UniformSize=True
       InitialParticlesPerSecond=0.000000
       AutomaticInitialSpawning=False
       DrawStyle=PTDS_AlphaBlend
       Texture=Texture't_effect.particle.casing_m1'
       TextureUSubdivisions=4
       TextureVSubdivisions=8
       BlendBetweenSubdivisions=True
       SubdivisionEnd=31
       LifetimeRange=(Min=2.000000)
       StartVelocityRange=(X=(Min=-20.000000,Max=20.000000),Y=(Min=100.000000,Max=150.000000),Z=(Min=150.000000,Max=250.000000))
   End Object
   Emitters(0)=SpriteEmitter'SpriteEmitter2'

	EmitterSoundName="GEAR.SHELL"
	PlaySoundPct = 0.8
}
class ShellUS45Cal extends gbxWeaponShells;


defaultproperties
{
    Begin Object Class=MeshEmitter Name=MeshEmitter2
		SecondsBeforeInactive=0
		// GBX:najnaj
        //StaticMesh=StaticMesh's_military_us.Weapon.m1_shell'
        Acceleration=(Z=-900.000000)
        UseCollision=True
		DampingFactorRange=(X=(Min=0.200000,Max=0.200000),Y=(Min=0.200000,Max=0.200000),Z=(Min=0.200000,Max=0.200000))
        MaxParticles=40
        UseRotationFrom=PTRS_Offset
		SpinParticles=True
        SpinsPerSecondRange=(X=(Min=-1.000000,Max=4.000000),Y=(Min=-2.000000,Max=2.000000),Z=(Min=-1.000000,Max=2.000000))
        DampRotation=True
		RotationDampingFactorRange=(X=(Min=0.200000,Max=0.200000),Y=(Min=0.200000,Max=0.200000),Z=(Min=0.200000,Max=0.200000))
		StartSizeRange=(X=(Min=0.1,Max=0.1),Y=(Min=0.05,Max=0.03),Z=(Min=0.1,Max=0.1))
		AutomaticInitialSpawning=False
        ParticlesPerSecond=0.000000
        InitialParticlesPerSecond=0.000000
		LifetimeRange=(Min=2.000000,Max=2.000000)
		RespawnDeadParticles=False
        StartVelocityRange=(X=(Min=-100.000000,Max=100.000000),Y=(Min=200.000000,Max=250.000000),Z=(Min=100.000000,Max=125.000000))
    End Object

    DrawScale=3.0
	EmitterSoundName="GEAR.SHELL"
	PlaySoundPct = 1.0

    Emitters(0)=MeshEmitter'MeshEmitter2'
}
class ShellUSBar extends gbxWeaponShells;


defaultproperties
{
   Begin Object Class=SpriteEmitter Name=SpriteEmitter3
	   SecondsBeforeInactive=0
       Acceleration=(Z=-900.000000)
       UseCollision=True
       DampingFactorRange=(X=(Min=0.500000,Max=0.500000),Y=(Min=0.500000,Max=0.500000),Z=(Min=0.500000,Max=0.500000))
       UseMaxCollisions=True
       MaxCollisions=(Min=3.000000,Max=5.000000)
       ColorScale(0)=(Color=(B=255,G=255,R=255,A=255))
       ColorScale(1)=(RelativeTime=1.000000,Color=(B=255,G=255,R=255,A=255))
       FadeOutStartTime=3.200000
       FadeOut=True
       MaxParticles=30
       RespawnDeadParticles=False
       UseRotationFrom=PTRS_Offset
       SpinParticles=True
       StartSpinRange=(X=(Max=1.000000))
       StartSizeRange=(X=(Min=5.000000,Max=5.000000),Y=(Min=5.000000,Max=5.000000),Z=(Min=5.000000,Max=5.000000))
       UniformSize=True
       InitialParticlesPerSecond=0.000000
       AutomaticInitialSpawning=False
       DrawStyle=PTDS_AlphaBlend
       Texture=Texture't_effect.particle.casing_m1'
       TextureUSubdivisions=4
       TextureVSubdivisions=8
       BlendBetweenSubdivisions=True
       SubdivisionEnd=31
       LifetimeRange=(Min=2.000000)
       StartVelocityRange=(X=(Min=-20.000000,Max=20.000000),Y=(Min=100.000000,Max=150.000000),Z=(Min=150.000000,Max=250.000000))
   End Object
   Emitters(0)=SpriteEmitter'SpriteEmitter3'

	EmitterSoundName="GEAR.SHELL"
	PlaySoundPct = 0.8
}class ShellUSColt1911_ extends gbxWeaponShells;


defaultproperties
{
   Begin Object Class=SpriteEmitter Name=SpriteEmitter4
	   SecondsBeforeInactive=0
       Acceleration=(Z=-900.000000)
       UseCollision=True
       DampingFactorRange=(X=(Min=0.500000,Max=0.500000),Y=(Min=0.500000,Max=0.500000),Z=(Min=0.500000,Max=0.500000))
       UseMaxCollisions=True
       MaxCollisions=(Min=3.000000,Max=5.000000)
       ColorScale(0)=(Color=(B=255,G=255,R=255,A=255))
       ColorScale(1)=(RelativeTime=1.000000,Color=(B=255,G=255,R=255,A=255))
       FadeOutStartTime=3.200000
       FadeOut=True
       MaxParticles=30
       RespawnDeadParticles=False
       UseRotationFrom=PTRS_Offset
       SpinParticles=True
       StartSpinRange=(X=(Max=1.000000))
       StartSizeRange=(X=(Min=5.000000,Max=5.000000),Y=(Min=5.000000,Max=5.000000),Z=(Min=5.000000,Max=5.000000))
       UniformSize=True
       InitialParticlesPerSecond=0.000000
       AutomaticInitialSpawning=False
       DrawStyle=PTDS_AlphaBlend
       Texture=Texture't_effect.particle.casing_m1'
       TextureUSubdivisions=4
       TextureVSubdivisions=8
       BlendBetweenSubdivisions=True
       SubdivisionEnd=31
       LifetimeRange=(Min=2.000000)
       StartVelocityRange=(X=(Min=-20.000000,Max=20.000000),Y=(Min=100.000000,Max=150.000000),Z=(Min=150.000000,Max=250.000000))
   End Object
   Emitters(0)=SpriteEmitter'SpriteEmitter4'

    DrawScale=3.0
	EmitterSoundName="GEAR.SHELL"
	PlaySoundPct = 1.0
}
class ShellUSM1_ extends gbxWeaponShells;


defaultproperties
{
   Begin Object Class=SpriteEmitter Name=SpriteEmitter5
	   SecondsBeforeInactive=0
       Acceleration=(Z=-900.000000)
       UseCollision=True
       DampingFactorRange=(X=(Min=0.500000,Max=0.500000),Y=(Min=0.500000,Max=0.500000),Z=(Min=0.500000,Max=0.500000))
       UseMaxCollisions=True
       MaxCollisions=(Min=3.000000,Max=5.000000)
       ColorScale(0)=(Color=(B=255,G=255,R=255,A=255))
       ColorScale(1)=(RelativeTime=1.000000,Color=(B=255,G=255,R=255,A=255))
       FadeOutStartTime=3.200000
       FadeOut=True
       MaxParticles=10
       RespawnDeadParticles=False
       UseRotationFrom=PTRS_Offset
       SpinParticles=True
       StartSpinRange=(X=(Max=1.000000))
       StartSizeRange=(X=(Min=5.000000,Max=5.000000),Y=(Min=5.000000,Max=5.000000),Z=(Min=5.000000,Max=5.000000))
       UniformSize=True
       InitialParticlesPerSecond=0.000000
       AutomaticInitialSpawning=False
       DrawStyle=PTDS_AlphaBlend
       Texture=Texture't_effect.particle.casing_m1'
       TextureUSubdivisions=4
       TextureVSubdivisions=8
       BlendBetweenSubdivisions=True
       SubdivisionEnd=31
       LifetimeRange=(Min=2.000000)
       StartVelocityRange=(X=(Min=75.000000,Max=100.000000),Y=(Min=75.000000,Max=125.000000),Z=(Min=250.000000,Max=275.000000))
   End Object
   Emitters(0)=SpriteEmitter'SpriteEmitter5'

	EmitterSoundName="GEAR.SHELL"
	PlaySoundPct = 1.0

}class ShellUSM3A1_ extends gbxWeaponShells;


defaultproperties
{
   Begin Object Class=SpriteEmitter Name=SpriteEmitter6
	   SecondsBeforeInactive=0
       Acceleration=(Z=-900.000000)
       UseCollision=True
       DampingFactorRange=(X=(Min=0.500000,Max=0.500000),Y=(Min=0.500000,Max=0.500000),Z=(Min=0.500000,Max=0.500000))
       UseMaxCollisions=True
       MaxCollisions=(Min=3.000000,Max=5.000000)
       ColorScale(0)=(Color=(B=255,G=255,R=255,A=255))
       ColorScale(1)=(RelativeTime=1.000000,Color=(B=255,G=255,R=255,A=255))
       FadeOutStartTime=3.200000
       FadeOut=True
       MaxParticles=30
       RespawnDeadParticles=False
       UseRotationFrom=PTRS_Offset
       SpinParticles=True
       StartSpinRange=(X=(Max=1.000000))
       StartSizeRange=(X=(Min=5.000000,Max=5.000000),Y=(Min=5.000000,Max=5.000000),Z=(Min=5.000000,Max=5.000000))
       UniformSize=True
       InitialParticlesPerSecond=0.000000
       AutomaticInitialSpawning=False
       DrawStyle=PTDS_AlphaBlend
       Texture=Texture't_effect.particle.casing_m1'
       TextureUSubdivisions=4
       TextureVSubdivisions=8
       BlendBetweenSubdivisions=True
       SubdivisionEnd=31
       LifetimeRange=(Min=2.000000)
       StartVelocityRange=(X=(Min=-20.000000,Max=20.000000),Y=(Min=100.000000,Max=150.000000),Z=(Min=150.000000,Max=250.000000))
   End Object
   Emitters(0)=SpriteEmitter'SpriteEmitter6'

	DrawScale=3.0
	EmitterSoundName="GEAR.SHELL"
}
class ShellUSThompson extends gbxWeaponShells;


defaultproperties
{
   Begin Object Class=SpriteEmitter Name=SpriteEmitter6
	   SecondsBeforeInactive=0
       Acceleration=(Z=-900.000000)
       UseCollision=True
       DampingFactorRange=(X=(Min=0.500000,Max=0.500000),Y=(Min=0.500000,Max=0.500000),Z=(Min=0.500000,Max=0.500000))
       UseMaxCollisions=True
       MaxCollisions=(Min=3.000000,Max=5.000000)
       ColorScale(0)=(Color=(B=255,G=255,R=255,A=255))
       ColorScale(1)=(RelativeTime=1.000000,Color=(B=255,G=255,R=255,A=255))
       FadeOutStartTime=3.200000
       FadeOut=True
       MaxParticles=30
       RespawnDeadParticles=False
       UseRotationFrom=PTRS_Offset
       SpinParticles=True
       StartSpinRange=(X=(Max=1.000000))
       StartSizeRange=(X=(Min=5.000000,Max=5.000000),Y=(Min=5.000000,Max=5.000000),Z=(Min=5.000000,Max=5.000000))
       UniformSize=True
       InitialParticlesPerSecond=0.000000
       AutomaticInitialSpawning=False
       DrawStyle=PTDS_AlphaBlend
       Texture=Texture't_effect.particle.casing_m1'
       TextureUSubdivisions=4
       TextureVSubdivisions=8
       BlendBetweenSubdivisions=True
       SubdivisionEnd=31
       LifetimeRange=(Min=2.000000)
       StartVelocityRange=(X=(Min=-20.000000,Max=20.000000),Y=(Min=100.000000,Max=150.000000),Z=(Min=150.000000,Max=250.000000))
   End Object
   Emitters(0)=SpriteEmitter'SpriteEmitter6'

	DrawScale=3.0
	EmitterSoundName="GEAR.SHELL"
}
class SingleBulletReloadFire extends InstantFire;

var array<Name>		ReloadAnimList;
var Name			LastShotFireAnim;
var float			LastShotFireRate;

function PlayFiring()
{
	if( Weapon.ClipAmt == 0 && Weapon.HasAnim(default.LastShotFireAnim) )
	{
		FireAnim = default.LastShotFireAnim;
		FireRateSP = default.LastShotFireRate;
		FireRateMP = default.LastShotFireRate;
	}
	else
	{
		FireAnim = default.FireAnim;
		FireRateSP = default.FireRateSP;
		FireRateMP = default.FireRateMP;
	}

	Super.PlayFiring();
}

simulated function PlayReloading()
{
	local gbxPlayerController gbxPC;
	local int AnimIndex;

	if (Weapon.ClipAmt >= Weapon.AmmoClipSize){
		gbxWeapon(Weapon).flAmmoFadeTime = AMMO_INVENTORY_SHOW_TIME;  //NAC: added this so that anytime the player presses the reload key, it shows the number of clips available.
		gbxWeapon(Weapon).flLastAmmoFadeTime = Level.TimeSeconds;
		return;
	}

	if (Instigator.IsA('Mind') && Instigator.IsMoving() && Instigator.bIsCrouched)
		return;

	gbxWeapon(Weapon).m_fAIWeaponWaitingToFire = false;
	gbxWeapon(Weapon).flAmmoFadeTime = AMMO_INVENTORY_SHOW_TIME;
	gbxWeapon(Weapon).flLastAmmoFadeTime = Level.TimeSeconds;

	gbxPC = gbxPlayerController(Instigator.Controller);

	//DHW + -- Added to prevent player from entering reload anim if he's out of ammo
	log(self$".PlayReloading() - "$Weapon.Ammo[0].AmmoAmount$" - "$Weapon.ClipAmt);
	if (Weapon.Ammo[0].AmmoAmount <= Weapon.ClipAmt)
	// GBX:PAD: The previous check was preventing partial clips from loading if the gun only had 1 partial clip
	// left.
//	if (Weapon.Ammo[0].AmmoAmount <= 0)
		return;
	//DHW -

	if( gbxWeapon(Weapon).m_fZoomed && gbxPC != None )
	{
		gbxPC.PendingDelayedAction = ReloadAfterZoomOut;
		gbxWeapon(Weapon).ForceUnzoom();
	}
	else
	{
		if( Weapon.ClipAmt == 0 )
		{
			DoPlayAnim(0);
		}
		else
		{
			AnimIndex = Min( Weapon.AmmoClipSize - Weapon.ClipAmt, default.ReloadAnimList.Length - 1 );
			DoPlayAnim( AnimIndex );
		}
	}
}

simulated function DoPlayAnim( int AnimIndex )
{
	if(Weapon.HasAnim( default.ReloadAnimList[AnimIndex] ) && !Weapon.bDelayReloading )
	{
		Weapon.ClientStopFire(0);

		Weapon.PlayAnim(default.ReloadAnimList[AnimIndex], ReloadAnimRate, TweenTime);

		Weapon.ClientState = WS_Reloading;
		bIsReloading = true;
	}

	if( WeaponAttachment( Weapon.ThirdPersonActor ) != None )
		Weapon.IncrementFlashCount( WeaponAttachment(Weapon.ThirdPersonActor).WEAP_StateReload );
}

defaultproperties
{
	ReloadAnimList[0]=reload
}class TankGrenade extends gbxExplosive;


defaultproperties
{
	bCollideActors=false
	bCollideWorld=false
	bCollideWhenPlacing=false

	Physics=PHYS_None

	DrawType=None

	bHidden=false
	
	MyDamageType=class'DamageGammonBomb'	

	ExplosionDecal=None
	Damage=500.000000
	DamageRadius=375.000000
	HeavyTraumaRadius=500.0
	MomentumTransfer=50000

	flFuseTime=10.0

	ShakeRadius=2000.000000
	ViewRollTime=0.200000
	RollMag=20.000000
	RollRate=100.000000
	OffsetMagVertical=20.000000
	OffsetRateVertical=800.000000
	OffsetMagHorizontal=20.000000
	OffsetRateHorizontal=800.000000
	OffsetIterations=10.000000	
}class TNT extends gbxExplosive;

#exec OBJ LOAD FILE=..\staticmesh\s_military_us.usx

var float MessageInterval;
var float CheckZInterval, NextCheckZTime;
var bool  bShowClockTimer;

function StartExplosionTimer()
{
	Super.StartExplosionTimer();
	SetTimer(MessageInterval, true);
	bShowClockTimer = true;
}

simulated function Timer()
{
	local gbxMessage GrenadeMessage;

	GrenadeMessage = new( None ) class<gbxMessage>( DynamicLoadObject( "gbxAI.PerceptionGrenade", class'Class' ));
	GrenadeMessage.Sender = self;
	GrenadeMessage.bUseSenderLocation = true;
	GrenadeMessage.bHasLocation = true;
	GrenadeMessage.BroadcastRadius = DamageRadius;		
	GrenadeMessage.bBroadcastLOSBlocked = true;
	PostGBXMessage( GrenadeMessage );
}

// Don't do anything if this thing hit a wall or the floor.
simulated function HitWall (vector HitLocation, vector HitNormal, actor Wall) {}

event Landed( vector HitLocation, vector HitNormal )
{
	//bHidden = false;	// Now keeping satchel invisible until the player dismounts.
}

// Make sure to handle rare cases where the TNT falls through the world.
function Tick( float DeltaTime )
{
	local	PlayerController	aPlayer;
	
	//DHW + Moved code out of the Parent Tick to prevent the fusetimer being updated

	//removed to prevent TNT ticking fusetime
	//Super.Tick( DeltaTime );

	//Moved up and modified from gbxExplosive to explode TNT when fusetime is up
	if ( !bHidden ) 
	{
		if ( bActivated )
		{
			if (Role == ROLE_Authority)
			{
				if ( flFuseTime <= 0.0 )
				{
					flFuseTime = 0.0;
					iReplicatedFuseTime = 0;
					bShouldExplode = true;
					Explosion( Location );
				}
			}
		}

		if( bBlowingUp )
		{
			if ( bHideAfterExplosion )	{	bHidden = true;	}
			else						{	Destroy();		}
		}
	}
	//DHW -

	if ( NextCheckZTime < 0.00001f || Level.TimeSeconds > NextCheckZTime )
	{
		if ( ( Instigator.Location.Z - Self.Location.Z > 1000.0f ) )
		{
			TNTTrigger( TheTrigger ).NotifyFellThroughWorld();
			Self.Destroy();
		}

		NextCheckZTime = Level.TimeSeconds + CheckZInterval;
	}
	
	if (!bHidden && bShowClockTimer)
	{
		if (Level.NetMode == NM_StandAlone)
		{
			aPlayer = Level.GetLocalPlayerController();
			if ((aPlayer != None) && (gbxHUD(aPlayer.MyHUD) != None))
			{
				gbxHUD(aPlayer.MyHUD).SetHUDClock( flFuseTime );
			}
		}
		bShowClockTimer = false;
	}
}

simulated function Explode(vector HitLocation, vector HitNormal) {}

function Explosion(vector HitLocation)
{
	//DHW + -- Alert the LDs that the explosion is going off soon
	TNTTrigger( TheTrigger ).NotifyPreExplosion();
	//DHW -
	Super.Explosion( HitLocation );
	TNTTrigger( TheTrigger ).NotifyExploded();
}

defaultproperties
{
	DrawType=DT_StaticMesh
	//StaticMesh=s_military_us.weapon.satchel_charge
	StaticMesh=s_military_us.weapon.explosive_charge
	bHidden=true
	
	DrawScale=1.5
	MyDamageType=class'DamageGammonBomb'	

	FuseTimeMin=10.0
	FuseTimeMax=10.0
	MessageInterval=0.5
	
	CollisionRadius=2.0

	Physics=PHYS_Falling

	ExplosionDecal=class'BlastMark'
	Damage=500.000000
	DamageRadius=750.000000
	HeavyTraumaRadius=400.0
	MomentumTransfer=50000

	ShakeRadius=2000.000000
	ViewRollTime=0.200000
	RollMag=20.000000
	RollRate=100.000000
	OffsetMagVertical=20.000000
	OffsetRateVertical=800.000000
	OffsetMagHorizontal=20.000000
	OffsetRateHorizontal=800.000000
	OffsetIterations=10.000000	

	CheckZInterval=1.0
}class TNTAsparagus extends TNT;class UsableBandage extends gbxUsableItem;



var() int		m_nHealAmount;

//=============================================================================
// Using.

simulated function Use( float Value )
{
	if (Pawn( Owner ) != None)
	{
		Pawn( Owner ).Health += min( m_nHealAmount, 100 - Pawn( Owner ).Health );
	}
}

defaultproperties
{
//	Icon=material'WG_HUD.HUD.wpn_bandage'
	m_nHealAmount = 20
	m_bItemBucket = 2
	ItemName="Bandage"
	ItemDesc="Bandage. Heals 20 points of damage."
}
class UsableGermanHandGrenade extends UsableHandGrenade;



defaultproperties
{
	nIconX=175
	nIconY=219
	nIconW=24
	nIconH=32
	m_bItemBucket = 1
	ItemName="German HandGrenade"
	ItemDesc="German HandGrenade.  Blows up real good."
	bCanHaveMultipleCopies=true
	NumCopies=5

	GrenadeClass=class'ProjectileGermanHandGrenade'
}
class UsableGermanHandGrenadeMP extends UsableHandGrenade;



defaultproperties
{
	nIconX=175
	nIconY=219
	nIconW=24
	nIconH=32
	m_bItemBucket = 1
	ItemName="German HandGrenade"
	ItemDesc="German HandGrenade.  Blows up real good."
	bCanHaveMultipleCopies=true
	NumCopies=1

	GrenadeClass=class'ProjectileGermanHandGrenadeMP'
}
class UsableHandGrenade extends gbxUsableItem;



var class<gbxGrenade>	GrenadeClass;
var	Vector				ThrowVector;	// Velocity vector to launch the grenade
var gbxGrenade			Grenade;		// Grenade object
var float				FuseStartDelay;
const GRENADE_THROW_DELAY = 1.56f;
var bool				fWaitForThrow;
var float				GrenadeThrowTime;

function Prepare()
{
	if (ROLE==ROLE_Authority)
	{
		// Spawn the grenade
		Grenade = Spawn(GrenadeClass, self,,Instigator.Location + Instigator.EyePosition());
		Grenade.RemoteRole = ROLE_None;

		// Log(name$".Prepare() - "$Grenade.Owner);
		// Attach it to my instigator
		Grenade.AttachToPawn( Instigator );

		// Making noise when the pin is pulled ensures the grenade will almost never work.
		// Instead, make noise when it is actually thrown

		// Start the fuse after a little delay
		SetTimer( FuseStartDelay, false );
		
		GrenadeThrowTime = Level.TimeSeconds + GRENADE_THROW_DELAY;
		fWaitForThrow = true;
	}
}

simulated function Use( float Value )
{
	// Log(name$".Use( "$Value$" ) - "$Grenade);
	if (Pawn( Owner ) != None)
	{
		ProjectileFire();
	}
}

simulated function name GetUseAnimation()
{
	return 'grenade_throw';
}

function ServerProjectileFire()
{
	if (Role < ROLE_Authority)
		return;

	Owner.MakeNoise(1.0);

	// speak throwgrenade dialogue
	log( "GrenadeFiringController::CookingGrenade() - " $ Level.TheAISpeechManager $ ".PlaySpeech( " $ Pawn( Owner ) $ ", 'ThrowingGrenade' )", 'RSC' );
	Level.TheAISpeechManager.PlaySpeech( 
		Pawn( Owner ),
		None,
		'ThrowingGrenade',
		,
		,
		0.0,
		,
		2.0,
		2.0
	);

	if( Grenade != None )
	{
		if( Instigator != None ) // None == dead - don't launch the grenade.
		{
			if( ThrowVector != Vect(0,0,0) )
				Grenade.ThrowGrenade( ThrowVector );
			else
				Grenade.ThrowGrenade();
		}
		else
		{
			Grenade.ThrowGrenade( vect(0,0,1.0) );
		}
	}
}

simulated function ProjectileFire()
{
	ServerProjectileFire();
//	Log(name$".ProjectileFire() - "$Grenade);
//	if( Grenade != None )
//	{
//		if( ThrowVector != Vect(0,0,0) )
//			Grenade.ThrowGrenade( ThrowVector );
//		else
//			Grenade.ThrowGrenade();
//	}
}

function Timer()
{
	// Light it up!
	Grenade.StartFuse();
}

function Tick(float Delta)
{
	Super.Tick( Delta );
	
	if ( fWaitForThrow && (GrenadeThrowTime < Level.TimeSeconds))
	{
		ProjectileFire();
		if ((gbxPawn(Instigator) != None) && (gbxWeapon(gbxPawn(Instigator).Weapon) != None))
			gbxWeapon(gbxPawn(Instigator).Weapon).m_fCanZoom = true;
		fWaitForThrow = false;
	}
}

defaultproperties
{
	FuseStartDelay = 1.10;
}
//=============================================================================
// Trophy items - Mostly just for appearance.  No particular usable ability.
//=============================================================================
class UsableTrophies extends gbxUsableItem;



defaultproperties
{
	m_bItemBucket = 3
}
class UsableUSHandGrenade extends UsableHandGrenade;



defaultproperties
{
	nIconX=1
	nIconY=187
	nIconW=32
	nIconH=32
	m_bItemBucket = 1
	ItemName="US HandGrenade"
	ItemDesc="US HandGrenade.  Blows up real good."
	bCanHaveMultipleCopies=true
	NumCopies=1

	GrenadeClass=class'ProjectileUSHandGrenade'
}
class UsableUSHandGrenadeMP extends UsableHandGrenade;



defaultproperties
{
	nIconX=1
	nIconY=187
	nIconW=32
	nIconH=32
	m_bItemBucket = 1
	ItemName="US HandGrenade"
	ItemDesc="US HandGrenade.  Blows up real good."
	bCanHaveMultipleCopies=true
	NumCopies=1

	GrenadeClass=class'ProjectileUSHandGrenadeMP'
}
class WargameWeapon extends gbxWeapon
	abstract
	native;

replication
{
	reliable if ( Role == ROLE_Authority )
		ClientPlantGammonBombOnTarget, ClientDenyPlantGammonBombOnTarget;

	reliable if ( Role < ROLE_Authority )
		ServerPlantGammonBombOnTarget;
}

var bool bDisableCrosshair;
var Rotator m_rotDesiredWeaponDir;
var Rotator m_rotLastWeaponDir;
var Rotator	m_rotWeaponDir;
var Rotator m_rotBreathDir;
var Rotator m_rotLastBaseAngle;
var Vector	m_vecDesiredDirRate;
var Vector	m_vecFatigueDirRate;
var Vector	m_vecChangeDirRate;
var float	m_flLastAccelTime;
var float	m_flDirStartTime;
var float	m_flDecelStartTime;
var float	m_flWeaponDirRate;

var name	m_szFromHipAngleBone;
var name	m_szZoomedAngleBone;

const ROT_MOMENTUM_RATE = 15;
const ROT_CHARACTER_DIR_RATE = 1.0f;
const MAX_ROT_ACCEL_RATE = 300;

var float	m_flMaxRotAccelRate;
var float	m_flRotFatigueTime;
var float	m_flErrorScale;

var bool	m_fDisableFatigue;


simulated native function AdjustWeaponAngle( int nError );

simulated function DrawCrossHair( canvas Canvas )
{
	local float XLength, YLength;
	local  PlayerController PlayerOwner;
	local HUD	Hud;

	
	if( bDisableCrosshair )
		return;

	if (( Level.NetMode == NM_StandAlone ) && (Level.DifficultyLevel == DIFF_Authentic))
	{
		return;
	}
	if ( Instigator != None && Instigator.IsHumanControlled() )
	{
		PlayerOwner = PlayerController(Instigator.Controller);

		if ( PlayerOwner.IsZoomed() && (PlayerOwner.iCrossHairZoomed == 0))
			return;
			
		if ( PlayerOwner.DisableCrosshair() )
			return;
	
		if ( PlayerOwner.iCrossHairIndex == 0 )
			return;

		//if ( Level.NetMode != NM_StandAlone )
		//	return;

                if ( PlayerOwner.GameReplicationInfo.GameType == GT_MULTIPLAYER )
                        return;

		Hud = PlayerOwner.MyHud;

		if (Hud == None)
		{
			XLength = 32;
			YLength = 32;
		}
		else
		{
			XLength = 32 * Hud.flMinScaleX;
			YLength = 32 * Hud.flMinScaleY;
		}
		Canvas.bNoSmooth = False;
		//Canvas.SetPos(0.503 * (Canvas.ClipX - XLength), 0.504 * (Canvas.ClipY - XLength));

		Canvas.SetPos(0.5 * (Canvas.ClipX - XLength), 0.5 * (Canvas.ClipY - YLength));

		// GBX:PAD: I'm not sure why this adjustment is here, but it throws off the crosshair position so that it's
		// not actually where you intend to fire.
//		Canvas.CurY -= (YLength *0.3 );   //NAC: Why the magic number?  Since all other icons in the game use the "Rotator" it causes them to be displaced a little...instead of changing all of them, this was MUCH easier!

	//	Canvas.Style = ERenderStyle.STY_Translucent;
		Canvas.Style = ERenderStyle.STY_Additive;
		Canvas.SetDrawColor(255,255,255,96);

		Canvas.DrawTile(m_TestCrosshairs[PlayerOwner.iCrossHairIndex - 1], XLength, YLength, 0, 0, m_TestCrosshairs[PlayerOwner.iCrossHairIndex - 1].USize, m_TestCrosshairs[PlayerOwner.iCrossHairIndex - 1].VSize);

		Canvas.bNoSmooth = True;
		Canvas.Style = Style;
	}		
}

exec function ToggleCrosshair()
{
	bDisableCrosshair = !bDisableCrosshair;
}

// Compare self to current weapon.  If better than current weapon, then switch
simulated function ClientWeaponSet(bool bOptionalSet)
{
	local gbxPawn	aPlayer;

	Instigator = Pawn(Owner); //weapon's instigator isn't replicated to client

	if ( m_eWeaponType == WeaponPrimary )
	{
		aPlayer = gbxPawn( Instigator );
		Super.ClientWeaponSet( bOptionalSet );
		return;
	}

	if (gbxPawn( Instigator ) != None)
	{
		aPlayer = gbxPawn( Instigator );

		if ( aPlayer.SecondaryWeapon == None )
		{
			aPlayer.PendingSecondaryWeapon = self;
			aPlayer.ChangedSecondaryWeapon();
		}
	}

	GotoState('');
}

simulated function ForceUnzoom()
{
	local PlayerController	aPlayer;

	if (PlayerController(Instigator.Controller) != None)
	{
		aPlayer = PlayerController(Instigator.Controller);

		aPlayer.DesiredFOV = aPlayer.DefaultFOV;

		if (gbxPawn(aPlayer.Pawn) != None)
		{
			aPlayer.Pawn.eWeaponAimedState = WAS_Sighted; // GBX:naj - 3/24/04
			aPlayer.Pawn.flLastAimedStateChange = Level.TimeSeconds;
			SwitchZoomView( false );
		}
	}
}

function PlantGammonBombOnTarget()
{
	ServerPlantGammonBombOnTarget();
}

// This is called by the server when a client use's an explosive trigger and is allowed to begin planting bomb
simulated function ClientPlantGammonBombOnTarget()
{
	ServerPlantGammonBombOnTarget();		
}

simulated function ClientDenyPlantGammonBombOnTarget()
{
}

// This is called by the client to tell the server we're done animating
function ServerPlantGammonBombOnTarget()
{
	local gbxPlayerController aController;
	
	aController = gbxPlayerController(Instigator.Controller);
	if (aController != None)
	{
		if ( !aController.AttachBombToTarget( Instigator ))
		{
			// The server decided that you cannot plant teh bomb
			ClientDenyPlantGammonBombOnTarget();
		}
	}
	else
	{
		// The server decided that you cannot plant teh bomb
		ClientDenyPlantGammonBombOnTarget();
	}
}

exec notinship function DisableWeaponFatigue( bool fDisable )
{
	m_fDisableFatigue = fDisable;
	m_rotWeaponDir = rot( 0, 0, 0 );
	SetBoneRotation( m_szZoomedAngleBone, m_rotWeaponDir, 0, 1.0f );
}

exec function SetFatigueAccelRate( float flMaxRotAccelRate )
{
	m_flMaxRotAccelRate = flMaxRotAccelRate;
}
exec function SetFatigueFatigueTime( float flRotFatigueTime )
{
	m_flRotFatigueTime = flRotFatigueTime;
}
exec function SetFatigueErrorScale( float flErrorScale )
{
	m_flErrorScale = flErrorScale;
}

defaultproperties
{
	bDisableCrosshair = false
	m_flWeaponDirRate = 0.0f

	m_szFromHipAngleBone = ""
	m_szZoomedAngleBone = "Gun"

	m_flMaxRotAccelRate = 300
	m_flRotFatigueTime = 1.0f
	m_flErrorScale = 1.0f

	Icon=Texture't_interface_mb.hud.interface_comp'
}
//=============================================================================
// WeapDEFG42Sniper
//=============================================================================
class WeapDEFG42Sniper extends WargameWeapon
    config(user);

simulated function LoadWeaponMesh()
{
	Mesh = Mesh( DynamicLoadObject( "k_view_weapons.view_fg42_sniper", class'Mesh' ) );
	m_NormalViewMesh = Mesh( DynamicLoadObject( "k_view_weapons.view_fg42_sniper", class'Mesh' ) );
	m_ZoomViewMesh = Mesh( DynamicLoadObject( "k_view_weapons.view_fg42_sniper_crosshair", class'Mesh' ) );
	LinkMesh( Mesh );
	Super.LoadWeaponMesh();
}

function byte BestMode()
{
	return 0;
}

defaultproperties
{
    ItemName="German FG42 automatic rifle with scope"

    FireModeClass(0)=FireDEFG42Sniper
    FireModeClass(1)=FireSecondaryItem
    FireModeClass(2)=FireMelee
    InventoryGroup=2
//	Mesh=Mesh'k_view_weapons.view_fg42_sniper'
//	m_NormalViewMesh=Mesh'k_view_weapons.view_fg42_sniper'
//	m_ZoomViewMesh=Mesh'k_view_weapons.view_fg42_sniper_crosshair'
	m_nCharacterBodyIdx=5
    BobDamping=0.5
    PickupClass=class'PickupWeapDEFG42Sniper'
    EffectOffset=(X=150.0,Y=10.0,Z=-10.0)
	DisplayFOV=+50.0
    AttachmentClass=class'AttachmentDEFG42Sniper'

    DrawScale=1.0
	PlayerViewOffset=(X=20.000,Y=0.000000,Z=-0.50000)
    SelectSound=None

	AIRating=+0.4
    CurrentRating=0.4

	// This icon no longer exists.
	//Icon=material'WG_HUD.HUD.wpn_garand'

//	m_aClipIcon=material'WG_HUD.HUD.clip_garand'
//	m_flBulletHeight=18
//	m_flClipHeight=128
//	m_flClipWidth=128
//	m_fClipFront=true
//	m_aFrontBulletIcon=material't_interface_mb.HUD.ammo_30cal'
//	m_aBackBulletIcon=material'WG_HUD.HUD.ammo_bullet_bck'
	m_nBulletIconTextureX=232
	m_nBulletIconTextureY=229
	m_nClipIconTextureX=232
	m_nClipIconTextureY=203

	m_eWeaponType=WeaponPrimary
	MyMeleeDamageType=class'DamageUSGunButtMelee'

	DefaultAmmoCount(0)=200

	ZoomInAnim=aim_up
	ZoomOutAnim=aim_down
	SelectAnim=deploy
	PutDownAnim=holster
	PutDownAnimQuick=holster_short
	IdleAnim(0)=idle_01
	IdleAnim(1)=idle_02
	IdleAnim(2)=idle_03

	WeaponBoneName=rifle_hold

	ZoomFovMod=45.0000

	AmmoClipSize=20

	m_flEncumberance=1.0
	m_fCanSprint=true
        m_bIsAutomatic=true

	Desirability=2.0

	BreatheProfileClass=class'gbxMediumBreatheProfile'

	DEPawnPackGoreClass(0)=class'gbxInventory.ConscriptMP40GoreSetup'
	DEPawnPackGoreClass(1)=class'gbxInventory.InfantryMP40GoreSetup'
	DEPawnPackGoreClass(2)=class'gbxInventory.ParaSturmGoreSetup'
	DEPawnPackGoreClass(3)=class'gbxInventory.PanzerSturmGoreSetup'

	Icon=material't_interface_mb.HUD.training_art'
	nIconX=0
	nIconY=0
	nIconW=29
	nIconH=107

	WeaponName = WN_DEFG42SNIPER
	AmmoName = AM_Nothing

	SelectAnimReadyDelay = 0.5
	PutDownAnimReadyDelay = 1.25
}
//=============================================================================
// WeapDEFG42_
//=============================================================================
class WeapDEFG42_ extends WargameWeapon
    config(user);

simulated function LoadWeaponMesh()
{
	Mesh = Mesh( DynamicLoadObject( "k_view_weapons.view_fg42", class'Mesh' ) );
	m_NormalViewMesh = Mesh( DynamicLoadObject( "k_view_weapons.view_fg42", class'Mesh' ) );
	m_ZoomViewMesh = Mesh( DynamicLoadObject( "k_view_weapons.view_fg42_crosshair", class'Mesh' ) );
	LinkMesh( Mesh );
	Super.LoadWeaponMesh();
}

function byte BestMode()
{
	return 0;
}

defaultproperties
{
    ItemName="German FG42 Machine Gun"

    FireModeClass(0)=FireDEFG42_
    FireModeClass(1)=FireSecondaryItem
    FireModeClass(2)=FireMelee
    InventoryGroup=2
//	Mesh=Mesh'k_view_weapons.view_fg42'
//	m_NormalViewMesh=Mesh'k_view_weapons.view_fg42'
//	m_ZoomViewMesh=Mesh'k_view_weapons.view_fg42_crosshair'
	m_nCharacterBodyIdx=5
    BobDamping=0.5
    PickupClass=class'PickupWeapDEFG42_'
    EffectOffset=(X=150.0,Y=10.0,Z=-10.0)
	DisplayFOV=+50.0
    AttachmentClass=class'AttachmentDEFG42_'

    DrawScale=1.0
	PlayerViewOffset=(X=20.000,Y=0.000000,Z=-0.50000)
    SelectSound=None

	AIRating=+0.4
    CurrentRating=0.4

	// This icon no longer exists.
	//Icon=material'WG_HUD.HUD.wpn_garand'

//	m_aClipIcon=material'WG_HUD.HUD.clip_garand'
//	m_flBulletHeight=18
//	m_flClipHeight=128
//	m_flClipWidth=128
//	m_fClipFront=true
//	m_aFrontBulletIcon=material't_interface_mb.HUD.ammo_30cal'
//	m_aBackBulletIcon=material'WG_HUD.HUD.ammo_bullet_bck'
	m_nBulletIconTextureX=232
	m_nBulletIconTextureY=229
	m_nClipIconTextureX=232
	m_nClipIconTextureY=203

	m_eWeaponType=WeaponPrimary
	MyMeleeDamageType=class'DamageUSGunButtMelee'

	DefaultAmmoCount(0)=200

	ZoomInAnim=aim_up
	ZoomOutAnim=aim_down
	SelectAnim=deploy
	PutDownAnim=holster
	PutDownAnimQuick=holster_short
	IdleAnim(0)=idle_01
	IdleAnim(1)=idle_02
	IdleAnim(2)=idle_03

	WeaponBoneName=rifle_hold

	ZoomFovMod=17.0000

	AmmoClipSize=20

	m_flEncumberance=1.0
	m_fCanSprint=true
        m_bIsAutomatic=true

	Desirability=2.0

	BreatheProfileClass=class'gbxMediumBreatheProfile'

	DEPawnPackGoreClass(0)=class'gbxInventory.ConscriptMP40GoreSetup'
	DEPawnPackGoreClass(1)=class'gbxInventory.InfantryMP40GoreSetup'
	DEPawnPackGoreClass(2)=class'gbxInventory.ParaSturmGoreSetup'
	DEPawnPackGoreClass(3)=class'gbxInventory.PanzerSturmGoreSetup'

	Icon=material't_interface_mb.HUD.training_art'
	nIconX=8
	nIconY=0
	nIconW=21
	nIconH=107

	WeaponName = WN_DEFG42
	AmmoName = AM_Nothing

	SelectAnimReadyDelay = 0.5
	PutDownAnimReadyDelay = 1.25
}
class WeapDEFlakvierling extends TurretWeapon;

//---------------------------------------------------------
//	Variables
//---------------------------------------------------------
var Actor	TargetActor;		// If this is None, the controller will assign random targets.
var	Name	BaseBone, GunBone, CoGunBone, HorizCrankBone, VertCrankBone;
var Name	GunnerAttach, LeftLoaderAttach, RightLoaderAttach;
var Name	GunnerToDraft, LeftLoaderToDraft, RightLoaderToDraft;
var Name	DeathEvent;
var float	YawRotSpeed, PitchRotSpeed;
var float	NextCrewCheckTime;
var float	CrewCheckInterval;
var int		CurBaseYaw, CurGunPitch, PitchOffset;
var int		MaxPitch,MinPitch;
var bool	bDontRecruit;
var bool	bCrewHasBeenDrafted;
var bool	bTurningLeft, bTurningRight, bTurningUp, bTurningDown, bWasFiring;
var Rotator	DesiredRot, LastRequestedRot;
var gbxPawn	Gunner, LeftLoader, RightLoader;
var Vector	GunnerOffset, LeftLoaderOffset, RightLoaderOffset;
var FlakvierlingBrokenTurret BrokenTurret;

var const int		HorizRotChannel, VertRotChannel;

var enum ELoaderSide
{
	Loader_Left,
	Loader_Right

} LastSideToReload;

//---------------------------------------------------------
//	PostNetBeginPlay
//---------------------------------------------------------
function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();
	GiveAmmo(0);

	Mesh = Mesh(DynamicLoadObject("k_prop.de_flakv", class'Mesh'));
	LinkMesh( Mesh );
	
	PlayAnim( 'Idle' );	
}

//---------------------------------------------------------
//	IsAntiAir
//---------------------------------------------------------
function bool IsAntiAir() 
{ 
	return true; 
}

//---------------------------------------------------------
//	GetBracingAnim
//---------------------------------------------------------
// TBD: Get rid of this ugly function - move animation names into ItemPawnAnimInfo.
function Name GetBracingAnim( gbxPawn Loader )
{
	if ( Loader == LeftLoader )
		return 'Flakv_L_loader_fire';
	else if ( Loader == RightLoader )
		return 'Flakv_R_loader_fire';
	else
		return '';
}

//---------------------------------------------------------
//	SetTargetActor
//---------------------------------------------------------
function SetTargetActor( Actor NewTargetActor )
{
	TargetActor = NewTargetActor;
}

//---------------------------------------------------------
//	GetTargetActor
//---------------------------------------------------------
function Actor GetTargetActor()
{
	return TargetActor;	// May be None.
}

//---------------------------------------------------------
//	FaceRotation
//---------------------------------------------------------
function FaceRotation( Rotator Rot )
{
	Rot.Pitch = Rot.Pitch & 65535;

	if ( bHasBlownUp )
		return;

	// Hacky damper code: Throw out the request if it's only a little bit different from the current one.
	if ( abs( Rot.Pitch - LastRequestedRot.Pitch ) <= 5 && abs( Rot.Yaw - LastRequestedRot.Yaw ) <= 5 )
		return;

	LastRequestedRot = Rot;

	// Make sure the requested pitch does not go outside the bounds of the weapon.
	if ( Rot.Pitch > MaxPitch ) 
	{
		if ( Rot.Pitch > 32768 )
		{
			Rot.Pitch = 0;
		}
		else
		{
			Rot.Pitch = MaxPitch;
		}
	}

	// Make sure the requested pitch isn't to low
	if(Rot.Pitch < MinPitch)
	{
		Rot.Pitch = MinPitch;
	}
	
	DesiredRot = Rot;	
	DesiredRot.Pitch -= PitchOffset;		// Because at pitch=0, the gun may not actually be pointing horizontally	

	DesiredRot.Pitch = DesiredRot.Pitch & 65535;
	DesiredRot.Yaw = DesiredRot.Yaw & 65535;
}

//---------------------------------------------------------
//	GetAdjustedRotation
//---------------------------------------------------------
function int GetAdjustedRotation( int CurPosition, int DesiredPosition, float Speed, float DeltaTime, out int bRotatingLeft )
{
	local int Diff, NewPos, Offset;
	local bool bIsNegative, bDidSubtract, bSnap;
	local float AdjustedSpeed;

	Diff = DesiredPosition - CurPosition;
	bIsNegative = ( Diff < 0 );

	Diff = abs( Diff );

	if ( Diff > 32767)
	{
		Diff = 65536 - Diff;
		bDidSubtract = true;
	}

	AdjustedSpeed = Speed;
	Offset = AdjustedSpeed*DeltaTime;
	if ( Offset >= Diff )
	{
		do
		{
			AdjustedSpeed *= 0.75;
			Offset = AdjustedSpeed*DeltaTime;
		}
		until( AdjustedSpeed < 0.25*Speed || Offset <= Diff );
		
		if ( Offset >= Diff )
		{
			bSnap = true;
		}
	}
	
	if ( ( bDidSubtract && bIsNegative ) || ( !bDidSubtract && !bIsNegative ) )
	{
		if ( bSnap )
			NewPos = DesiredPosition;
		else
			NewPos = (CurPosition + Offset ) & 65535;
		
		bRotatingLeft = 0;
	}
	else
	{
		if ( bSnap )
			NewPos = DesiredPosition;
		else
			NewPos = (CurPosition - Offset ) & 65535;

		bRotatingLeft = 1;
	}

	return NewPos;	
}

//---------------------------------------------------------
//	PawnIsInCrew
//---------------------------------------------------------
function bool PawnIsInCrew( Pawn P ) 
{ 
	return P == Gunner || P == LeftLoader || P == RightLoader;
}

//---------------------------------------------------------
//	DraftCrew
//---------------------------------------------------------
function DraftCrew()
{
	local gbxPawn aDraftee;
	local class<gbxAIController> MindClass;
	
	ForEach DynamicActors(class'gbxPawn', aDraftee )
	{
		if ( aDraftee.Tag == GunnerToDraft && Gunner == None )
		{
			Gunner = aDraftee;
			MindClass = class<gbxAIController>( DynamicLoadObject( "gbxAI.MindFlakvierlingGunner", class'Class' ) );
			Gunner.CrewTurret( Self, MindClass, Job_Flakv_Gunner );
		}
		else if ( aDraftee.Tag == LeftLoaderToDraft && LeftLoader == None  )
		{
			LeftLoader = aDraftee;
			MindClass = class<gbxAIController>( DynamicLoadObject( "gbxAI.MindFlakvierlingLoader", class'Class' ) );
			LeftLoader.CrewTurret( Self, MindClass, Job_Flakv_LeftLoader );
		}
		else if ( aDraftee.Tag == RightLoaderToDraft && RightLoader == None  )
		{
			RightLoader = aDraftee;
			MindClass = class<gbxAIController>( DynamicLoadObject( "gbxAI.MindFlakvierlingLoader", class'Class' ) );
			RightLoader.CrewTurret( Self, MindClass, Job_Flakv_RightLoader );
		}
	}

	if ( Gunner != None )
		bCrewHasBeenDrafted = true;
}

//---------------------------------------------------------
//	GetFireRotation
//---------------------------------------------------------
function Rotator GetFireRotation()
{
	local Rotator Temp;
	Temp.Pitch = CurGunPitch;
	Temp.Pitch = ( Temp.Pitch + 5385 ) & 65535;
	Temp.Yaw = CurBaseYaw;
	return Temp;
}

//---------------------------------------------------------
//	GetViewOrigin
//---------------------------------------------------------
function Vector GetViewOrigin()
{
	if ( Gunner != None )
		return Gunner.Location;
}

//---------------------------------------------------------
//	Tick
//---------------------------------------------------------
function Tick( float DeltaTime )
{
	local name AnimName;
	local float AnimFrame, AnimRate;
	local Rotator BaseRot, GunRot, CrankRot;;
	local int RotatingLeft, RotatingUp;

	Super.Tick( DeltaTime );

	if ( bHasBlownUp )
		return;

	// Make sure that this weapon is manned.
	//if ( !bCrewHasBeenDrafted )
	//{
	if ( !bDontRecruit && !bCrewHasBeenDrafted && Level.TimeSeconds > NextCrewCheckTime )
	{
		NextCrewCheckTime = Level.TimeSeconds + CrewCheckInterval;
		DraftCrew();		
	}

	if ( Gunner == None )
		return;

	bTurningLeft = false;
	bTurningRight = false;
	bTurningUp = false;
	bTurningDown = false;
	
	// Determine which direction (if any) the weapon is turning.
	if ( abs( DesiredRot.Yaw - CurBaseYaw ) > 0 )
	{		
		CurBaseYaw = GetAdjustedRotation( CurBaseYaw, DesiredRot.Yaw, YawRotSpeed, DeltaTime, RotatingLeft );
		BaseRot.Pitch = Rotation.Yaw-CurBaseYaw;	// Yes, I must use the pitch component to yaw the base.  Confusing, isn't it?
		SetBoneRotation( BaseBone, BaseRot, 1.0 );
		
		if ( RotatingLeft == 1 )
		{
			bTurningLeft = true;
		}
		else
		{
			bTurningRight = true;
		}
	}
	else
	if ( abs( DesiredRot.Pitch - CurGunPitch ) > 0 )
	{
		CurGunPitch = GetAdjustedRotation( CurGunPitch, DesiredRot.Pitch, PitchRotSpeed, DeltaTime, RotatingUp );
		GunRot.Yaw = ( (65536-CurGunPitch) ) & 65535;
		SetBoneRotation( GunBone, GunRot, 1.0 );
		SetBoneRotation( CoGunBone, GunRot, 1.0 );
		
		if ( RotatingUp == 1 )
			bTurningUp = true;
		else
			bTurningDown = true;
	}	
	
	// Play the appropriate hand-cranking animation if the weapon is turning.
	if ( bTurningLeft )
	{		
		PlayCrankAnimations( 'Flakv_gunner_crank_left' );
	}
	else if ( bTurningRight )
	{		
		PlayCrankAnimations( 'Flakv_gunner_crank_right' );
	}
	else if ( bTurningUp )
	{
		PlayCrankAnimations( 'Flakv_gunner_crank_up' );
	}
	else if ( bTurningDown )
	{
		PlayCrankAnimations( 'Flakv_gunner_crank_down' );
	}
	
	// Synchronize the crank bones with the gunner's cranking animation, if any.
	Gunner.GetAnimParams( 0, AnimName, AnimFrame, AnimRate );
	if ( AnimName == 'Flakv_gunner_crank_left' )
	{
		CrankRot.Pitch = AnimFrame * 65535;
		SetBoneRotation( HorizCrankBone, CrankRot, 1.0 );
		SetBoneRotation( VertCrankBone, Rot(0,0,0), 1.0 );
	}
	else if ( AnimName == 'Flakv_gunner_crank_right' )
	{
		CrankRot.Pitch = 65536 - AnimFrame * 65535;
		SetBoneRotation( HorizCrankBone, CrankRot, 1.0 );
		SetBoneRotation( VertCrankBone, Rot(0,0,0), 1.0 );
	}
	else if ( AnimName == 'Flakv_gunner_crank_up' )
	{
		CrankRot.Yaw = AnimFrame * 65535;
		SetBoneRotation( HorizCrankBone, Rot(0,0,0), 1.0 );
		SetBoneRotation( VertCrankBone, CrankRot, 1.0 );
	}
	else if ( AnimName == 'Flakv_gunner_crank_down' )
	{
		CrankRot.Yaw = 65536 - AnimFrame * 65535;
		SetBoneRotation( HorizCrankBone, Rot(0,0,0), 1.0 );
		SetBoneRotation( VertCrankBone, CrankRot, 1.0 );
	}		
	else
	{
		SetBoneRotation( HorizCrankBone, Rot(0,0,0), 1.0 );
		SetBoneRotation( VertCrankBone, Rot(0,0,0), 1.0 );
	}

	if ( !FireMode[0].bIsFiring && bWasFiring )
	{
		Self.LoopAnim( 'Idle', 1.0, 0.25 );
		gbxAIController( Gunner.Controller ).NotifyStopFiring();
		gbxAIController( LeftLoader.Controller ).NotifyStopFiring();
		gbxAIController( RightLoader.Controller ).NotifyStopFiring();
		bWasFiring = false;
	}
}

//---------------------------------------------------------
//	PlayCrankAnimations
//---------------------------------------------------------
simulated function PlayCrankAnimations( Name GunnerAnim )
{
	local name AnimName;
	local float AnimFrame, AnimRate;

	Gunner.GetAnimParams( 0, AnimName, AnimFrame, AnimRate );
	if ( AnimName != GunnerAnim )
	{
		Gunner.AddAnimToQueue( GunnerAnim, 96.0, true, false,, 2.0, 0.15 );
	}	
}

//---------------------------------------------------------
//	PlayFiring
//---------------------------------------------------------
simulated function PlayFiring()
{
	local name AnimName;
	local float AnimFrame, AnimRate;	

	Gunner.GetAnimParams( 0, AnimName, AnimFrame, AnimRate );

	gbxAIController( Gunner.Controller ).NotifyBeginFiring();
	gbxAIController( LeftLoader.Controller ).NotifyBeginFiring();
	gbxAIController( RightLoader.Controller ).NotifyBeginFiring();

	FireDEFlakvierling( FireMode[0] ).FlashMuzzleFlashes( true );
	
	SetTimer( 0.2, false );
	bWasFiring = true;
}

//---------------------------------------------------------
//	Timer
//---------------------------------------------------------
function Timer()
{
	if ( bHasBlownUp )		//If the timer was set before a dismount it will fire again.  
	{
		SetTimer( 0.0, false );
		return;
	}

	Super.Timer();
	FireDEFlakvierling( FireMode[0] ).FlashMuzzleFlashes( false );
}

//---------------------------------------------------------
//	CompleteMount
//---------------------------------------------------------
function CompleteMount( gbxPawn gbxP )
{
	if ( gbxP == Gunner )
	{
		Gunner.SetBase( None );
		Gunner.SetPhysics( PHYS_None );
		AttachToBone( Gunner, GunnerAttach );		
		Gunner.SetRelativeRotation( Rot( 0,32768,16384 ) );
		Gunner.SetRelativeLocation( GunnerOffset );
		Gunner.FlushAnimQueueChannel( 0,, true );
		Gunner.StopAnimating();
		Gunner.LoadMountAnimations( Mount_MountFlakVGunner );
		Gunner.bDoTorsoTwist = false;
		Gunner.SetWeapon( Self );

		Instigator = Gunner;
		if ( Ammo[0] != None )
			Ammo[0].Instigator = Instigator;
		if ( FireMode[0] != None )
			FireMode[0].Instigator = Instigator;
		if ( ThirdPersonActor != None )
			ThirdPersonActor.Instigator = Instigator;

	}
	else if ( gbxP == LeftLoader )
	{
		LeftLoader.SetBase( None );
		LeftLoader.SetPhysics( PHYS_None );
		AttachToBone( LeftLoader, LeftLoaderAttach );
		LeftLoader.SetRelativeRotation( Rot( 0,32768,16384 ) );
		LeftLoader.SetRelativeLocation( LeftLoaderOffset );
		LeftLoader.FlushAnimQueueChannel( 0,, true );
		LeftLoader.StopAnimating();
		LeftLoader.LoadMountAnimations( Mount_MountFlakVLoader );
		LeftLoader.bDoTorsoTwist = false;
		LeftLoader.SetWeapon( None );
	}
	else if ( gbxP == RightLoader )
	{
		RightLoader.SetBase( None );
		RightLoader.SetPhysics( PHYS_None );
		AttachToBone( RightLoader, RightLoaderAttach );
		RightLoader.SetRelativeRotation( Rot( 0,32768,16384 ) );
		RightLoader.SetRelativeLocation( RightLoaderOffset );
		RightLoader.FlushAnimQueueChannel( 0,, true );
		RightLoader.StopAnimating();
		RightLoader.LoadMountAnimations( Mount_MountFlakVLoader );
		RightLoader.bDoTorsoTwist = false;
		RightLoader.SetWeapon( None );
	}	

	gbxP.PlayWaiting();
}

//---------------------------------------------------------
//	PreparePawnToDismount
//---------------------------------------------------------
function PreparePawnToDismount( gbxPawn gbxP )
{
	gbxP.SetPhysics( PHYS_Falling );

	//make sure we suspend spawning of smoke when they exit
	FireDEFlakvierling( FireMode[0] ).StopFiring();
	FireDEFlakvierling( FireMode[1] ).StopFiring();
}

//---------------------------------------------------------
//	CompleteDismount
//---------------------------------------------------------
function CompleteDismount( gbxPawn gbxP )
{
	//make sure we suspend spawning of smoke when they exit
	FireDEFlakvierling( FireMode[0] ).StopFiring();
	//gbxP.Weapon = None;  // hack so SetWeapon() will call ChangedWeapon() - jlb
	//gbxP.SetWeapon( gbxP.LastWeapon );
}

//---------------------------------------------------------
//	ForceCrewDismount
//---------------------------------------------------------
function ForceCrewDismount( optional Pawn InstigatedBy )
{
	bDontRecruit = true;

	bTurningLeft = false;
	bTurningRight = false;
	bTurningUp = false;
	bTurningDown = false;

	if ( Gunner != None )
	{
		StopFiringWeapon();
		gbxAIController( Gunner.Controller ).BreakOutJustMe( InstigatedBy );
	}

	if ( LeftLoader != None )
	{
		gbxAIController( LeftLoader.Controller ).BreakOutJustMe( InstigatedBy );
	}

	if ( RightLoader != None )
	{
		gbxAIController( RightLoader.Controller ).BreakOutJustMe( InstigatedBy );
	}

	Gunner = None;
	LeftLoader = None;
	RightLoader = None;
}

// Special override fixes a rare bug where the FiringController tells the weapon to stop firing right after it has consumed its last
// bullet.  This had prevented the weapon from ever firing again.
function StopFiringWeapon()
{
	Super.StopFiringWeapon();
	if ( NeedsToReload() )
	{
		PlayReloading();
	}
}

//---------------------------------------------------------
//	PlayReloading
//---------------------------------------------------------
simulated function PlayReloading() 
{
	gbxAIController( LeftLoader.Controller ).ReloadTurret();
	gbxAIController( RightLoader.Controller ).ReloadTurret();	
}

//---------------------------------------------------------
//	ReloadFinished
//---------------------------------------------------------
function ReloadFinished()
{
	ReloadClip();
	gbxAIController( LeftLoader.Controller ).NotifyReloadFinished();
	gbxAIController( RightLoader.Controller ).NotifyReloadFinished();
}

//---------------------------------------------------------
//	NotifyForceDismount
//---------------------------------------------------------
function NotifyForceDismount( optional bool bDoNothingIfHumanControlled )
{
	ForceCrewDismount();
}

//---------------------------------------------------------
//	SetBlownUp
//---------------------------------------------------------
function SetBlownUp()
{
	local Rotator NewTurretRot;

	Super.SetBlownUp();

	StopFiringWeapon();

	bTurningLeft = false;
	bTurningRight = false;
	bTurningUp = false;
	bTurningDown = false;

	if ( Gunner != None )
	{
		Gunner.Destroy();
	}
		
	if ( LeftLoader != None )
	{
		LeftLoader.Destroy();
	}
	
	if ( RightLoader != None )
	{
		RightLoader.Destroy();
	}

	SetDrawType( DT_StaticMesh );
	SetStaticMesh( StaticMesh(DynamicLoadObject("s_military_de.Weapon.flakvierling_dmg_base", class'StaticMesh')) );
	
	BrokenTurret = Spawn( class'FlakvierlingBrokenTurret' );
	
	NewTurretRot.Yaw = CurBaseYaw;
	//NewTurretRot.Pitch = CurGunPitch;
	BrokenTurret.SetLocation( Self.Location );
	BrokenTurret.SetRotation( NewTurretRot );
	BrokenTurret.SetFlakBase(self);
}

//---------------------------------------------------------
//	BlowUp
//---------------------------------------------------------
function BlowUp( Pawn EventInstigator )
{
	local Rotator NewTurretRot, HurtOffsetRot;

	Super.BlowUp( EventInstigator );

	bTurningLeft = false;
	bTurningRight = false;
	bTurningUp = false;
	bTurningDown = false;

	SetDrawType( DT_StaticMesh );
	SetStaticMesh( StaticMesh(DynamicLoadObject("s_military_de.Weapon.flakvierling_dmg_base", class'StaticMesh')) );
	
	BrokenTurret = Spawn( class'FlakvierlingBrokenTurret' );
	
	NewTurretRot.Yaw = CurBaseYaw;
	NewTurretRot.Pitch = CurGunPitch;
	BrokenTurret.SetLocation( Self.Location );
	BrokenTurret.SetRotation( NewTurretRot );

	HurtOffsetRot = NewTurretRot;
	HurtOffsetRot.Pitch = 0;
	
	HurtRadius( 500.0,500.0, class'DamageTankCannon', 50000, Location - 100.0*Vector( HurtOffsetRot ) );

	if ( DeathEvent != '' )
	{
		TriggerEvent( DeathEvent, Self, EventInstigator );
	}
}

//---------------------------------------------------------
//	CanBeDestroyedBy
//---------------------------------------------------------
function bool CanBeDestroyedBy( class<DamageType> DamageType ) 
{ 
	return (
		DamageType == class'DamageGammonBomb' || 
		DamageType == class'DamageTankCannon' ||
		DamageType == class'DamageDEPanzerfaust' ||
		DamageType == class'DamageUSBazooka' 
		);
}

//---------------------------------------------------------
//	AlwaysAutoReload
//---------------------------------------------------------
function bool AlwaysAutoReload()
{
	return true;
}

simulated event RenderOverlays( Canvas Canvas ) {}

//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
	DrawType=DT_Mesh
//	Mesh=Mesh'k_prop.de_flakv'
//	StaticMesh=StaticMesh's_military_de.Weapon.flakvierling_dmg_base'
	Mesh=None
	StaticMesh=None
	Texture=Texture'Engine.S_Weapon'

	FireModeClass(0)=FireDEFlakvierling
	FireModeClass(1)=FireDEFlakvierling
	AttachmentClass=class'AttachmentDEFlakvierling'

	BaseBone=Dummy01
	GunBone=Dummy04
	CoGunBone=Dummy03
	HorizCrankBone=Dummy14
	VertCrankBone=Dummy12

	GunnerAttach=Gunner
	LeftLoaderAttach=Left
	RightLoaderAttach=Right

	YawRotSpeed=5000.0
	PitchRotSpeed=5000.0
	PitchOffset=5385
	MaxPitch=16384
	MinPitch=8192

	GunnerOffset=(x=0,y=7.0,z=0)
	LeftLoaderOffset=(x=0,y=0,z=0)
	RightLoaderOffset=(x=0,y=0,z=0)
	
	HorizRotChannel=1
	VertRotChannel=2

	ClientState=WS_Hidden
	AmmoClipSize=20

	Physics=PHYS_Falling
	bStatic=false
	bCollideActors=true
	bBlockActors=true
	bBlockPlayers=true
	bCollideWorld=true
	bCollideSkeletalMesh=true
	bBlockZeroExtentTraces=true
	bBlockNonZeroExtentTraces=true
	CollisionHeight=0.0

	CrewCheckInterval=3.0

	BreatheProfileClass=class'gbxSupportedBreatheProfile'

	bOpaqueForSituationalAwarenessView=true
}//=============================================================================
// German MG42 machine gun mounted on the Halftrack vehicle
//=============================================================================

class WeapDEHalftrackMG42_ extends TurretWeapon;

//---------------------------------------------------------
//	Configurable Properties
//---------------------------------------------------------
var ()	Name	MountEvent;
var ()	Name	DismountEvent;

//---------------------------------------------------------
//	Variables / Constants
//---------------------------------------------------------
var Vector			GunnerOffset;				// Used to position the gunner mesh.
var bool			bIsMounting;
var bool			bIsDismounting;
var bool			bWeaponFiring;
var float			MountStartStamp;
var float			MaxRotSpeed;
var float			LastTimeSecs;
var float			HorizCosTheta, VertCosTheta;
var gbxPawn			Gunner;						// The pawns manning this weapon.

var Range	PauseTime_Low;
var Range	PauseTime_High;

var Rotator	MyLastRot;

var const int HorizFieldUU;
var const int VertFieldUU;

// The names of the animations to use nine-point blending with
// when using this weapon.
var Name	PawnForwardDownAnim, PawnForwardLevelAnim, PawnForwardUpAnim,
			PawnLeftDownAnim, PawnLeftLevelAnim, PawnLeftUpAnim,
			PawnRightDownAnim, PawnRightLevelAnim, PawnRightUpAnim;

enum VerticalFacing		{VF_Up, VF_Center, VF_Down};
enum HorizontalFacing	{HF_Left, HF_Center, HF_Right};


simulated function LoadWeaponMesh()
{
	Mesh = Mesh( DynamicLoadObject( "k_view_weapons.mg42_crosshair", class'Mesh' ) );
	LinkMesh( Mesh );
	log(self$".LoadWeaponMesh() - "$Mesh);
	Super.LoadWeaponMesh();
}

//---------------------------------------------------------
//	PostNetBeginPlay
//---------------------------------------------------------
simulated function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();

	GiveAmmo(0);

	if ( ThirdPersonActor == None )
	{
		ThirdPersonActor = Spawn(AttachmentClass,Owner);
		InventoryAttachment(ThirdPersonActor).InitFor(self);
	}

	if ( FireLoopSoundName != "" )
		FireLoopSound = Sound( DynamicLoadObject( FireLoopSoundName, class'Sound' ) );
	if ( FireOneBulletSoundName != "" )
		FireOneBulletSound = Sound( DynamicLoadObject( FireOneBulletSoundName, class'Sound' ) );
	if ( StereoFireLoopSoundName != "" )
		StereoFireLoopSound = Sound( DynamicLoadObject( StereoFireLoopSoundName, class'Sound' ) );
	if ( StereoFireOneBulletSoundName != "" )
		StereoFireOneBulletSound = Sound( DynamicLoadObject( StereoFireOneBulletSoundName, class'Sound' ) );

	PlayAnim( 'Idle', 1.0 );
}

//---------------------------------------------------------
//	IsMachineGun
//---------------------------------------------------------
function bool IsMachineGun()
{
	return true;
}

//---------------------------------------------------------
//	GetBestBurstLength
//---------------------------------------------------------
function GetBestBurstLength( ESuppressionLevel SuppressionLevel, out float MinLen, out float MaxLen )
{
	FireMode[0].GetBestBurstLength( SuppressionLevel, MinLen, MaxLen );
}

//---------------------------------------------------------
//	GetBestPauseTime
//---------------------------------------------------------
function GetBestPauseTime( ESuppressionLevel SuppressionLevel, out float MinLen, out float MaxLen )
{
	if ( SuppressionLevel == SL_UNSUPPRESSED )
	{
		MinLen = PauseTime_Low.Min;
		MaxLen = PauseTime_Low.Max;
	}
	else
	{
		MinLen = PauseTime_High.Min;
		MaxLen = PauseTime_High.Max;
	}
}

//---------------------------------------------------------
//	Tick
//---------------------------------------------------------
function Tick( float DeltaTime )
{
	//log( self$ " WeapDEMG42_::Tick()", 'MP' );

	if ( FireMode[0] != None )
	{
		// Ensure that a gunner-less MG is not firing ad infinitum.
		if ( bWeaponFiring && ( Gunner == None || Gunner.IsDead() ) )
		{
			StopFiringWeapon();
		}
		else if ( FireMode[0].bIsFiring && !bWeaponFiring && !bIsDismounting )
		{
			StartFiringWeapon();
		}
		else if ( !FireMode[0].bIsFiring && bWeaponFiring )
		{
			StopFiringWeapon();
		}
	}

	Super.Tick( DeltaTime );
}

//---------------------------------------------------------
//	CalculateLerpedRotator
//---------------------------------------------------------
function Rotator CalculateLerpedRotator( Rotator Rot1, Rotator Rot2, float LerpSpeed, out int YawDiff )
{
	local bool bDidSubtract;
	local bool bIsNegative;
	local Rotator TempRot;

	YawDiff = Rot1.Yaw - Rot2.Yaw;
	bIsNegative = (YawDiff < 0);

	YawDiff = abs(YawDiff);

	if ( YawDiff > 32768)
	{
		YawDiff = 65536 - YawDiff;
		bDidSubtract = true;
	}

	if ( LastTimeSecs == 0 )
		LastTimeSecs = Level.TimeSeconds;

	if ( ( bDidSubtract && bIsNegative ) || ( !bDidSubtract && !bIsNegative ) )
	{
		// Rot1 is to the RIGHT of Rot2; YawDiff is the angle (in Unreal Units).
		TempRot.Yaw = (Rot1.Yaw - LerpSpeed*(Level.TimeSeconds - LastTimeSecs )*YawDiff) & 65535;
	}
	else
	{
		// Rot1 is to the LEFT of Rot2; YawDiff is the angle (in Unreal Units).
		TempRot.Yaw = (Rot1.Yaw + LerpSpeed*(Level.TimeSeconds - LastTimeSecs )*YawDiff) & 65535;
	}

	TempRot.Pitch = Rot2.Pitch;
	TempRot.Roll = Rot2.Roll;

	LastTimeSecs = Level.TimeSeconds;
	return TempRot;
}

//---------------------------------------------------------
//	FaceRotation
//---------------------------------------------------------
// Make the turret weapon rotate to face a particular direction.
function FaceRotation( Rotator Rot ) {

	// OK, now the aim is to end up with two alpha values for
	// animation channels 1 and 2.  These channels, along with
	// base channel 0, will be blended to produce a smooth transitioning
	// of the gunner's pose as the user moves the mouse.
	//
	// Channel 0 plays the 'level-forward' gunning animation at all times.
	// Channel 1 plays an 'edge animation' (i.e. 'level-left', 'level-right',
	// 'up-forward', or 'down-forward').  Channel 2 plays a 'diagonal animation'
	// (i.e. 'up-left', 'up-right', 'down-left', or 'down-right').
	//
	// The blending occurs progressively; that is, the edge animation is
	// blended over the base animation first, and then the diagonal animation
	// is blended over that result in turn.
	//
	local Vector Aim, AimXY, AimXZ, D, V;
	local Float DotH, DotV, DotCamera, Alpha1, Alpha2, m;
	local HorizontalFacing HorizFace;
	local VerticalFacing VertFace;
	local NinePointDir DirDiag, DirEdge;
	local Rotator LerpedRot;
	local int YawDiff;
	local vector LocalX, LocalY, LocalZ;		// The local axes of the mount.

	// Sanity check.
	if (Gunner == None)
	{
		log("Error: MG42 Gunner is null!");
		return;
	}

	if ( bIsDismounting )
	{
		return;
	}

	Gunner.SetRotation( Owner.Rotation );

	GetAxes(Owner.Rotation, LocalX, LocalY, LocalZ);

	// Smoothly interpolate the rotation.
	//
	// If the camera is facing to the rear of the weapon, interpolate nice and slowly when the camera crosses the Prime Meridian.
	//
	// Lerp iff: the gunner is AI-controlled, the difference in movement since the last tick is large, or the camera is facing to the rear.
	if ( !Gunner.IsHumanControlled() )
	{
		DotCamera = Vector(Rot) dot Vector(Owner.Rotation);
		if ( DotCamera < 0 )
			MaxRotSpeed = 1;
		else
			MaxRotSpeed = Default.MaxRotSpeed;

		LerpedRot = CalculateLerpedRotator( MyLastRot, Rot, MaxRotSpeed, YawDiff );
		Rot = LerpedRot;
	}

	RestrictYawAndPitch( Rot );

	// Adjust the gun's actual rotation.
	SetRotation(Rot);
	MyLastRot = Rot;

	// Next, we'll calculate DotH and DotV again, only using the gun's actual
	// current orientation (due to the motion-delay placed on the gun, the
	// actual orientation may differ from the requested orientation.
	Aim = Vector(Rotation);
	AimXZ = Aim - ((Aim dot LocalY) * LocalY);
	AimXY = Aim - ((Aim dot LocalZ) * LocalZ);
	AimXZ = Normal(AimXZ);
	AimXY = Normal(AimXY);

	DotH = AimXY dot LocalY;
	DotV = AimXZ dot LocalZ;

	// The extants of movement are -45deg to 45deg in the horizontal direction,
	// and -15deg to 15deg in the vertical direction,
	// so the min/max dot products will be +/-0.7071 and +/-0.2588.
	// Remap the dot-prods into the space -1.0 to 1.0.
	DotH /= HorizCosTheta;
	DotV /= VertCosTheta;

	DotH = FClamp( DotH, -1.0, 1.0 );
	DotV = FClamp( DotV, -1.0, 1.0 );

	// Determine what quadrant the aim vector is in.
	if (DotV < 0)
		VertFace = VF_Down;
	else
		VertFace = VF_Up;

	//if (DotH < 0)
	if (DotH > 0)
		HorizFace = HF_Right;
	 else
		HorizFace = HF_Left;


	// Absolute-value the dot prods so that we can simplify calculations below.
	DotH = abs(DotH);
	DotV = abs(DotV);

	//_DotH = DotH;
	//_DotV = DotV;

	// From the quadrant information, determine which two
	// diagonal and edge animations to use.
	if (VertFace == VF_Down) {
		if (HorizFace == HF_Left) {
			DirDiag = NPD_LowLeft;
			if (DotH >= DotV)
				DirEdge = NPD_MidLeft;
			else
				DirEdge = NPD_LowCenter;
		} else {
			DirDiag = NPD_LowRight;
			if (DotH >= DotV)
				DirEdge = NPD_MidRight;
			else
				DirEdge = NPD_LowCenter;
		}
	} else {	// VF_Up
		if (HorizFace == HF_Left) {
			DirDiag = NPD_UpLeft;
			if (DotH >= DotV)
				DirEdge = NPD_MidLeft;
			else
				DirEdge = NPD_UpCenter;
		} else {
			DirDiag = NPD_UpRight;
			if (DotH >= DotV)
				DirEdge = NPD_MidRight;
			else
				DirEdge = NPD_UpCenter;
		}
	}

	// Step 4: Figure the alpha blending values to use for the
	// two channels.  Point D is the point in 2D space that we found
	// above.  Point V is a point of intersection between the line thru
	// D and the nearest corner with the x- or the y-axis.
	//
	// Alpha1 is found by finding the distance from the origin to V.
	// Alpha2 is the distance between V and D.
	//
	// By absolute-valuing the dot prods above, we reduce the problem
	// to quadrant 1 (at this point, we have the two animations we need.
	// Except for knowing whether our edge-animation is horizontal or vertical,
	// quadrant information is no longer relevant.
	//
	D.X = DotH;	// 0.0 to 1.0, no negative values.
	D.Y = DotV;	// 0.0 to 1.0, no negative values.
	D.Z = 0;

	if (D.X == 1.0)	{	// Avoid divide-by-zero errors in the slope formula.
		Alpha1 = 1.0;
		Alpha2 = D.Y;
	} else {
		// m is the slope of the line through D and the corner (1,1).
		m = (1.0 - D.Y) / (1.0 - D.X);

		if (DirEdge == NPD_MidRight || DirEdge == NPD_MidLeft) {

			// The edge-animation is horizontal, so find x when
			// the line intercepts the x-axis (when y=0).
			Alpha1 = D.X - (D.Y / m);	// -b/m in intercept-slope formula.
			V.x = Alpha1;
			V.y = 0;
			V.z = 0;

		} else {	// Vertical edge (NPD_UpCenter or NPD_LowCenter).
			// The edge-animation is vertical, so find y when
			// the line intercepts the y-axis (when x=0).
			Alpha1 = D.Y - (m * D.X);	// 'b' in intercept-slope formula.
			V.x = 0;
			V.y = Alpha1;
			V.z = 0;
		}

		// Alpha2 is the proportion of the length of vector D - V
		// to that of vector (1,1) - V.  The equation used below
		// is the optimized form of the one in comments.
		Alpha2 = VSize(D - V) / (1.41421 - 0.41421 * Alpha1);	// 0.41421 == sqrt(2)
		//Alpha2 = VSize(D - V) / VSize(Vect(1,1,0) - V);		// Keep this for reference.
	}

	// Play the gunning animations, supplying the edge-animation,
	// the diagonal-animation, and their blending factors.
	Gunner.DoNinePointBlending( DirEdge, Alpha1, DirDiag, Alpha2 );
	if (gbxPawn(Owner) != None)
		gbxPawn(Owner).DoNinePointBlending( DirEdge, Alpha1, DirDiag, Alpha2 );
}

//---------------------------------------------------------
//	CompleteMount
//---------------------------------------------------------
function CompleteMount( gbxPawn gbxP )
{
	local int Mode;
	local vector X, Y, Z;
	local vector PawnLoc;
	local int index;

	// Do some initial cleanup.
	CleanUpProperties();

	SetInstaKill( false );	// Just in case it was left with insta-kill on.

	Gunner = gbxP;

	Instigator = Gunner;
	if ( Ammo[0] != None )
		Ammo[0].Instigator = Gunner;
	if ( FireMode[0] != None )
		FireMode[0].Instigator = Instigator;
	if ( ThirdPersonActor != None )
		ThirdPersonActor.Instigator = Instigator;

	Gunner.SetNinePointAnimations(
		PawnForwardDownAnim, PawnForwardLevelAnim, PawnForwardUpAnim,
		PawnLeftDownAnim, PawnLeftLevelAnim, PawnLeftUpAnim,
		PawnRightDownAnim, PawnRightLevelAnim, PawnRightUpAnim);

	Gunner.Velocity = vect(0,0,0);
	Gunner.bRotateToDesired = false;
	Gunner.DesiredRotation = Owner.Rotation;

	GetAxes(Rotation, X, Y, Z);

	PawnLoc = Location + GunnerOffset.X*X + GunnerOffset.Y*Y + GunnerOffset.Z*Z;

	Gunner.SetLocation( PawnLoc );
	Gunner.SetRotation( Owner.Rotation );

	Gunner.bHardAttach = true;
	Gunner.SetBase(Owner);

	//Gunner.ResetLookAtImmediate(true, true, true);
	//Gunner.StopLookAt( true, true, true );

	SetRotation( Owner.Rotation );
	MyLastRot = Owner.Rotation;

	bIsMounting = false;

	for( Mode = 0; Mode < NUM_FIRE_MODES; Mode++ )
	{
		if (FireMode[Mode] != None)
//			FireMode[Mode].InitEffects();
			FireMode[Mode].GetMuzzleFlash();
	}

	if (Gunner.Weapon != None)  // hide the current weapon (if there is one)...
	{
		Gunner.Weapon.ClientState = WS_Hidden;
		if (Gunner.Weapon.ThirdPersonActor != None)
			Gunner.Weapon.ThirdPersonActor.bHidden = true;  // hide the weapon quickly
	}

	Gunner.PendingWeapon = None;
	Gunner.Weapon = None;  // hack so SetWeapon() will call ChangedWeapon() - jlb

	Gunner.SetWeapon( self );

	// gbxWeapon AnimEnd transitions ClientState from WS_BringUp to WS_ReadyToFire, since this weapon has no deploy animation, we set WS_ReadyToFire ourselves.
	ClientState = WS_ReadyToFire;

	if ( Gunner.MyUnit != None )
	{
		Gunner.MyUnit.MemberGainedMachineGun( Gunner );
	}

	// Send out a mount event to anyone who may be interested.
	TriggerEvent( MountEvent, self, Gunner );

	Gunner.FlushAnimQueueChannel( 0,, true );

	for (index=1; index <= 16; index++)
		Gunner.FlushAnimQueueChannel( index, false, true );

	Gunner.StopAnimating(true);

	Gunner.PlayWaiting();
}

//---------------------------------------------------------
//	CenterWeapon
//---------------------------------------------------------
function MountFailed( gbxPawn gbxP )
{
	Super.MountFailed( gbxP );
}

//---------------------------------------------------------
//	CenterWeapon
//---------------------------------------------------------
function CenterWeapon()
{
	SetRotation( Owner.Rotation );
}

//---------------------------------------------------------
//	PreparePawnToDismount
//---------------------------------------------------------
function PreparePawnToDismount( gbxPawn gbxP )
{
	// Check that the pawn passed in is the gunner.
	if (gbxP != Gunner)
		return;

	StopFiringWeapon();

	gbxP.StopNinePointBlending();
	gbxP.SetRotation( Owner.Rotation );
	gbxP.Controller.SetRotation( Owner.Rotation );

	if (gbxP.bUseRootMotion)
		gbxP.SetPhysics(PHYS_RootMotion);
	else
		gbxP.SetPhysics(PHYS_Walking);

	bIsDismounting = true;
}

//---------------------------------------------------------
//	CompleteDismount
//---------------------------------------------------------
function CompleteDismount( gbxPawn gbxP )
{
	if ( gbxP == Gunner )
	{
		Instigator = None;
		Ammo[0].Instigator = None;
		FireMode[0].Instigator = None;

		if ( Gunner.MyUnit != None )
		{
			Gunner.MyUnit.MemberLostMachineGun( Gunner );
		}

		SetInstaKill( false );	// Just in case it was left with insta-kill on.
		CleanUpProperties();

		// Send out a dismount event to anyone who may be interested.
		TriggerEvent( DismountEvent, self, gbxP );
	}

	gbxP.Weapon = None;  // hack so SetWeapon() will call ChangedWeapon() - jlb

	if ( gbxP.LastWeapon != None )
		gbxP.SetWeapon( gbxP.LastWeapon );
	else
		gbxP.Controller.SwitchToBestWeapon();

	CenterWeapon();
}

//---------------------------------------------------------
//	CleanUpProperties
//---------------------------------------------------------
function CleanUpProperties()
{
	Gunner = None;
	bIsMounting = false;
	bIsDismounting = false;
}

//---------------------------------------------------------
//	InformCrewToGetUp
//---------------------------------------------------------
function InformCrewToGetUp( gbxPawn Caller)
{
	if ( Gunner != None && Gunner != Caller )
		Gunner.BreakOutOfJob();
}

//---------------------------------------------------------
//	GunnerDied
//---------------------------------------------------------
function GunnerDied( gbxPawn gbxP )
{
	if ( gbxP == Gunner )
	{
		bIsMounting = false;
		bIsDismounting = false;

		SetRelativeRotation(Rot(0,0,0));

		Gunner.bCollideWorld = true;

		if ( Gunner.MyUnit != None )
		{
			Gunner.MyUnit.MemberLostMachineGun( Gunner );
		}

		SetInstaKill( false );	// Just in case it was left with insta-kill on.

		Gunner.bIsManningTurret = false;

		Gunner = None;
	}
}

//---------------------------------------------------------
//	StartFiringWeapon
//---------------------------------------------------------
function StartFiringWeapon()
{
	if (bAimingAtFriendly && Instigator.IsA('gbxPawn'))
	{
		bFiringAtFriendly = true;
	}

	if ( bWeaponFiring || bIsDismounting )
		return;

	// RSC: Don't fire if we are issuing a command
	if( !Instigator.Controller.AllowFire() )
		return;

	if( !BAimingAtFriendly ) { // RSC: dont play a sound if aiming at a friendly
		if( Instigator.IsLocallyControlled() )
		{
			if ( StereoFireLoopSound != None && (Instigator.Controller == Level.GetLocalPlayerController()) )
			{
				FireLoopSoundHandle = PlaySound( StereoFireLoopSound, SLOT_None, TransientSoundVolume,,,,false);
			}
			else
			{
				FireLoopSoundHandle = PlaySound( FireLoopSound, SLOT_WeaponFire1, TransientSoundVolume,,,,true);
			}
		}
		else
		{
			FireLoopSoundHandle = PlaySound( FireLoopSound, SLOT_WeaponFire1, TransientSoundVolume,,,,true);
		}
	}

	if ( FireMode[0].IsA( 'FireDEHalftrackMG42_' ) )
		FireDEHalftrackMG42_( FireMode[0] ).StartFiringWeapon();

	Super.StartFiringWeapon();

	bWeaponFiring = true;
}

//---------------------------------------------------------
//	StopFiringWeapon
//---------------------------------------------------------
function StopFiringWeapon()
{
	if ( FireMode[0].IsA( 'FireDEHalftrackMG42_' ) )
		FireDEHalftrackMG42_( FireMode[0] ).StopFiringWeapon();

	if ( !bWeaponFiring )
		return;

	if (FireLoopSoundHandle != 0)
	{
		//StopSound( FireLoopSoundHandle );
		//FireLoopSoundHandle = 0;

		if (Instigator.IsLocallyControlled())
		{
			if ( StereoFireOneBulletSound != None && (Instigator.Controller == Level.GetLocalPlayerController()) )
			{
				PlaySound( StereoFireOneBulletSound, SLOT_NONE, TransientSoundVolume,,,,false);
			}
			else
			{
				PlaySound( FireOneBulletSound, SLOT_NONE, TransientSoundVolume,,,,true);
			}
		}
		else
		{
			PlaySound( FireOneBulletSound, SLOT_NONE, TransientSoundVolume,,,,true);
		}

		//PlaySound( FireOneBulletSound, SLOT_NONE, TransientSoundVolume,,,,false);

		StopSound( FireLoopSoundHandle );
		FireLoopSoundHandle = 0;
	}

	Super.StopFiringWeapon();

	bWeaponFiring = false;
}

function ConsumeAmmo(int Mode, float load) {}

//---------------------------------------------------------
//	FlashMuzzleFlash
//---------------------------------------------------------
// For 3rd person only.  See PostRender() in this class for 1st person muzzle flashes.
simulated function FlashMuzzleFlash()
{
	local gbxMuzzleFlash MuzFlash;

	if ( Gunner == None || bIsDismounting )
		return;

	if ( FireMode[0].IsA( 'FireDEHalftrackMG42_' ) )
	{
		MuzFlash = gbxMuzzleFlash( FireDEHalftrackMG42_( FireMode[0] ).GetMuzzleFlash() );

		MuzFlash.SetLocation( GetMuzzleLocationWorld() );
		MuzFlash.SetRotation( Rotation );
		MuzFlash.Flash();
	}
}

//---------------------------------------------------------
//	Fire
//---------------------------------------------------------
simulated function Fire(float F)
{
	// RSC: Don't fire if we are issuing a command. BB: Or if it is being dismounted
	if( !Instigator.Controller.AllowFire() || bIsDismounting )
		return;

	StartFiringWeapon();
	Super.Fire(F);
}

//---------------------------------------------------------
//	PlayFiringAnim
//---------------------------------------------------------
simulated function PlayFiringAnim()
{
	// Deprecate.
}

//---------------------------------------------------------
//	StopFire
//---------------------------------------------------------
simulated event StopFire(int Mode)
{
	if (FireLoopSoundHandle != 0)
	{
		//StopSound( FireLoopSoundHandle );
		//FireLoopSoundHandle = 0;

		if (Instigator.IsLocallyControlled())
		{
			if ( StereoFireOneBulletSound != None && (Instigator.Controller == Level.GetLocalPlayerController()) )
			{
				PlaySound( StereoFireOneBulletSound, SLOT_NONE, TransientSoundVolume,,,,false);
			}
			else
			{
				PlaySound( FireOneBulletSound, SLOT_NONE, TransientSoundVolume,,,,true);
			}
		}
		else
		{
			PlaySound( FireOneBulletSound, SLOT_NONE, TransientSoundVolume,,,,true);
		}

		//PlaySound( FireOneBulletSound, SLOT_NONE, TransientSoundVolume,,,,false);
		StopSound( FireLoopSoundHandle );
		FireLoopSoundHandle = 0;
	}

	bWeaponFiring = false;
	StopFiringWeapon();
	Super.StopFire( Mode );
}

//---------------------------------------------------------
//	RestrictYawAndPitch
//---------------------------------------------------------
function RestrictYawAndPitch( out Rotator ControllerRot )
{
	local int Diff;
	local bool bIsNegative, bDidSubtract;
	local int OwnerYaw, OwnerPitch;

	ControllerRot.Yaw = ControllerRot.Yaw & 65535;
	ControllerRot.Pitch = ControllerRot.Pitch & 65535;
	OwnerYaw = Owner.Rotation.Yaw & 65535;
	OwnerPitch = Owner.Rotation.Pitch & 65535;

	Diff = ControllerRot.Yaw - OwnerYaw;

	bIsNegative = (Diff < 0);

	Diff = abs(Diff);

	if ( Diff > 32768)
	{
		Diff = 65536 - Diff;
		bDidSubtract = true;
	}
	else
	{
		bDidSubtract = false;
	}

	if ( Diff > HorizFieldUU )
	{
		if ( ( bDidSubtract && bIsNegative ) || ( !bDidSubtract && !bIsNegative ) )
		{
			// ControllerRot is to the RIGHT of Owner.
			ControllerRot.Yaw = (OwnerYaw + HorizFieldUU) & 65535;
		}
		else
		{
			// ControllerRot is to the LEFT of Owner.
			ControllerRot.Yaw = (OwnerYaw - HorizFieldUU) & 65535;
		}
	}

	// Pitch.
	Diff = ControllerRot.Pitch - OwnerPitch;
	bIsNegative = ( Diff < 0 );
	Diff = abs( Diff );

	if ( Diff > 32768 )
	{
		Diff = 65536 - Diff;
		bDidSubtract = true;
	}
	else
	{
		bDidSubtract = false;
	}

	if ( Diff > VertFieldUU )
	{
		if ( ( bDidSubtract && bIsNegative ) || ( !bDidSubtract && !bIsNegative ) )
			ControllerRot.Pitch = OwnerPitch + VertFieldUU;
		else
			ControllerRot.Pitch = OwnerPitch - VertFieldUU;
	}
}

//---------------------------------------------------------
//	RestrictPitchOnly
//---------------------------------------------------------
function RestrictPitchOnly( out Rotator ControllerRot )
{
	local int Diff;
	local bool bIsNegative, bDidSubtract;
	local int OwnerYaw, OwnerPitch;

	ControllerRot.Yaw = ControllerRot.Yaw & 65535;
	ControllerRot.Pitch = ControllerRot.Pitch & 65535;
	OwnerYaw = Owner.Rotation.Yaw & 65535;
	OwnerPitch = Owner.Rotation.Pitch & 65535;

	// Pitch.
	Diff = ControllerRot.Pitch - OwnerPitch;
	bIsNegative = ( Diff < 0 );
	Diff = abs( Diff );

	if ( Diff > 32768 )
	{
		Diff = 65536 - Diff;
		bDidSubtract = true;
	}

	if ( Diff > VertFieldUU )
	{
		if ( ( bDidSubtract && bIsNegative ) || ( !bDidSubtract && !bIsNegative ) )
			ControllerRot.Pitch = OwnerPitch + VertFieldUU;
		else
			ControllerRot.Pitch = OwnerPitch - VertFieldUU;
	}
}

//---------------------------------------------------------
//	ClientStartFire
//---------------------------------------------------------
// Needed to override this because Owner is different for this weapon than most other weapons.
simulated event ClientStartFire(int Mode)
{
	if (!Gunner.Controller.CanFire() || bIsDismounting )
        return;

    if (Role < ROLE_Authority)
    {
        if (StartFire(Mode))
        {
            ServerStartFire(Mode);
        }
    }
    else
    {
        StartFire(Mode);
    }
}

//---------------------------------------------------------
//	GetFireRotation
//---------------------------------------------------------
function Rotator GetFireRotation()
{
	return Rotation;
}

//---------------------------------------------------------
//	GetViewOrigin
//---------------------------------------------------------
function Vector GetViewOrigin()
{
	if ( Gunner != None )
		return Gunner.Location;
}

//---------------------------------------------------------
//	AdjustAimNew
//---------------------------------------------------------
// Used only with player pawns; AI pawns use the AdjustAimNew() in FiringController.
function Rotator AdjustAimSpecial( Ammunition Ammo, Vector ProjStart, Rotator AimRotator, int WeaponAimError )
{
	local float FinalErrorMax;

	FinalErrorMax = WeaponAimError;

	// Yaw.
	if ( Rand(2) == 0 )
		AimRotator.Yaw += FRand() * FinalErrorMax;
	else
		AimRotator.Yaw -= FRand() * FinalErrorMax;

	// Pitch
	if ( Rand(2) == 0 )
		AimRotator.Pitch += FRand() * FinalErrorMax;
	else
		AimRotator.Pitch -= FRand() * FinalErrorMax;

	return AimRotator;
}

//---------------------------------------------------------
//	NeverAllowShotProtectionFor
//---------------------------------------------------------
function bool NeverAllowShotProtectionFor( class<DamageType> DamageType )
{
	return (
		DamageType == class'DamageGammonBomb' ||
		DamageType == class'DamageTankCannon' ||
		DamageType == class'DamageDEPanzerfaust' ||
		DamageType == class'DamageUSBazooka' ||
		DamageType == class'DamageGrenade'
		);
}

//---------------------------------------------------------
//	RejectDamageRequest
//---------------------------------------------------------
function bool RejectDamageRequest( Pawn Shooter, Pawn Victim, class<DamageType> DamageType )
{
	local Vector MyFacingVect, ToShooterVect;
	local float DistToShooter;

	if ( !bUseShotProtection || Level.bWeaponsAreBFG )
		return false;

	// No rejection for heavy explosives.
	if ( NeverAllowShotProtectionFor( DamageType ) )
		return false;

	MyFacingVect = Vector( Owner.Rotation );
	ToShooterVect = Shooter.Location - Location;

	MyFacingVect.Z = 0;
	ToShooterVect.Z = 0;

	DistToShooter = VSizeIgnoreZ( ToShooterVect );

	MyFacingVect = Normal( MyFacingVect );
	ToShooterVect = Normal( ToShooterVect );

	if ( MyFacingVect dot ToShooterVect < ShotProtectionCosTheta )	// 45 degrees
		return false;

	if ( DistToShooter  > NoShotProtectionDist )
		return true;
	else
		return false;
}

//---------------------------------------------------------
//	CanSpawnShellCasing
//---------------------------------------------------------
function bool CanSpawnShellCasing()
{
	return false;
}

//---------------------------------------------------------
//	ShouldPlayShellSound
//---------------------------------------------------------
function bool ShouldPlayFirstPersonShellSound()
{
	return false;
}

//---------------------------------------------------------
//	IsOnCrew
//---------------------------------------------------------
function bool IsOnCrew( gbxPawn gbxP )
{
	if ( Gunner == gbxP )
		return true;

	return false;
}

//---------------------------------------------------------
//	GetAttachment
//---------------------------------------------------------
function AttachmentDEHalftrackMG42_ GetAttachment()
{
	return AttachmentDEHalftrackMG42_( ThirdPersonActor );
}

//---------------------------------------------------------
//	GetBaseVector
//---------------------------------------------------------
function Vector GetBaseVector()
{
	return Vector( Owner.Rotation );
}

//---------------------------------------------------------
//	NotifyCrewMemberDied
//---------------------------------------------------------
function NotifyCrewMemberDied( gbxPawn gbxP )
{
	if ( gbxP == Gunner )
	{
		StopFiringWeapon();
		GunnerDied( gbxP );
	}
}

//---------------------------------------------------------
//	NotifyForceDismount
//---------------------------------------------------------
function NotifyForceDismount( optional bool bDoNothingIfHumanControlled )
{
	if ( Gunner != None )
	{
		if ( Gunner.Controller.IsA( 'gbxAIController' ) )
		{
			gbxAIController( Gunner.Controller ).BreakOutJustMe();
		}
	}
}

function bool AlwaysAutoReload()
{
	return true;
}

event bool TargetIsInMyConeOfFire( gbxPawn aTarget, optional bool bUseNarrowHysteresis )
{
	return PointIsInMyConeOfFire( aTarget.Location, bUseNarrowHysteresis );
}

function bool PointIsInMyConeOfFire( Vector TargetLoc, optional bool bUseNarrowHysteresis )
{
	local Vector ToTarget, BaseVectorAdjusted;

	// Quick dot-product check first to see if the enemy is behind this weapon.
	ToTarget = TargetLoc - self.Location;
	ToTarget.Z = 0;
	ToTarget = Normal( ToTarget );
	BaseVectorAdjusted = GetBaseVector();
	BaseVectorAdjusted.Z = 0;
	BaseVectorAdjusted = Normal( BaseVectorAdjusted );

	if ( bUseNarrowHysteresis )
		return ( BaseVectorAdjusted dot ToTarget >= ( HorizCosTheta + 0.03f ) );
	else
		return ( BaseVectorAdjusted dot ToTarget >= ( HorizCosTheta - 0.1f ) );
}

//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
	DrawType=DT_None
	bHidden=true
	DisplayFOV=+35.0
	bAcceptsProjectors=false
	DrawScale=1.0
	ItemName="German MG42 Machinegun"
	bHardAttach=false

	MyMountAction=Mount_MountMG42HalftrackGunner
	MyDismountAction=Mount_DismountMG42HafltrackGunner
	PlayersJob=Job_MG42_Gunner

	FireModeClass(0)=FireDEHalftrackMG42_
	FireModeClass(1)=FireDEHalftrackMG42_
	AttachmentClass=class'AttachmentDEHalftrackMG42_'

	DefaultAmmoCount(0)=400

	// Nine-point blending animations.
	PawnForwardDownAnim=de_halftrack_mg42_forward_down
	PawnForwardLevelAnim=de_halftrack_mg42_forward_level
	PawnForwardUpAnim=de_halftrack_mg42_forward_up
	PawnLeftDownAnim=de_halftrack_mg42_left_down
	PawnLeftLevelAnim=de_halftrack_mg42_left_level
	PawnLeftUpAnim=de_halftrack_mg42_left_up
	PawnRightDownAnim=de_halftrack_mg42_right_down
	PawnRightLevelAnim=de_halftrack_mg42_right_level
	PawnRightUpAnim=de_halftrack_mg42_right_up

	HorizCosTheta=0.7071
	VertCosTheta=0.2588

	FireLoopSoundName="W_MG42A.FIRELOOP"
	FireOneBulletSoundName="W_MG42A.FIRELOOPEND"

	StereoFireLoopSoundName="W_MG42A.FIRELOOP_ST"
	StereoFireOneBulletSoundName="W_MG42A.FIRELOOPEND_ST"

	MaxRotSpeed=11.0

	GunnerOffset=(X=-60,Y=0,Z=-50)

	bUseShotProtection=true
	NoShotProtectionDist=1000.0

	PauseTime_Low=(Min=0.15,Max=1.0)
	PauseTime_High=(Min=3.0,Max=5.0)

	HorizFieldUU=8192
	VertFieldUU=2731

	ClientState=WS_Hidden

	AmmoClipSize=400

	BreatheProfileClass=class'gbxSupportedBreatheProfile'

	WeaponName = WN_DEMG42
	AmmoName = AM_Nothing

	bOpaqueForSituationalAwarenessView=true
}
//=============================================================================
// WeapDEK98Sniper
//=============================================================================
class WeapDEK98Sniper extends WargameWeapon
    config(user);

simulated function LoadWeaponMesh()
{
	Mesh = Mesh( DynamicLoadObject( "k_view_weapons.view_k98_sniper", class'Mesh' ) );
	m_NormalViewMesh = Mesh( DynamicLoadObject( "k_view_weapons.view_k98_sniper", class'Mesh' ) );
	m_ZoomViewMesh = Mesh( DynamicLoadObject( "k_view_weapons.view_k98_sniper_crosshair", class'Mesh' ) );
	LinkMesh( Mesh );
	Super.LoadWeaponMesh();
}

function byte BestMode()
{
	return 0;
}

defaultproperties
{
    ItemName="German K98 Sniper Rifle"

    FireModeClass(0)=FireDEK98Sniper
    FireModeClass(1)=FireSecondaryItem
    FireModeClass(2)=FireMelee
    InventoryGroup=2
//	Mesh=Mesh'k_view_weapons.view_k98_sniper'
//	m_NormalViewMesh=Mesh'k_view_weapons.view_k98_sniper'
//	m_ZoomViewMesh=Mesh'k_view_weapons.view_k98_sniper_crosshair'
	m_nCharacterBodyIdx=3
    BobDamping=0.5
    PickupClass=class'PickupWeapDEK98Sniper'
    EffectOffset=(X=100.0,Y=25.0,Z=-10.0)
	DisplayFOV=+50.0
    AttachmentClass=class'AttachmentDEK98Sniper'

    DrawScale=1.0
	PlayerViewOffset=(X=20.000,Y=0.000000,Z=-0.50000)
    SelectSound=None

	AIRating=+0.4
    CurrentRating=0.4

	// This icon no longer exists.
	//Icon=material'WG_HUD.HUD.wpn_garand'

//	m_aClipIcon=material'WG_HUD.HUD.clip_garand'
//	m_flBulletHeight=18
//	m_flClipHeight=128
//	m_flClipWidth=128
//	m_fClipFront=true
//	m_aFrontBulletIcon=material'WG_HUD.HUD.ammo_bullet_frt'
//	m_aFrontBulletIcon=material't_interface_mb.HUD.ammo_30cal'
//	m_aBackBulletIcon=material'WG_HUD.HUD.ammo_bullet_bck'
	m_nBulletIconTextureX=258
	m_nBulletIconTextureY=177
	m_nClipIconTextureX=206
	m_nClipIconTextureY=177

	m_eWeaponType=WeaponPrimary
	MyMeleeDamageType=class'DamageUSGunButtMelee'

	DefaultAmmoCount(0)=65

	ZoomFovMod=55.0000
	
	ZoomInAnim=aim_up
	ZoomOutAnim=aim_down
	SelectAnim=deploy
	PutDownAnim=holster
	PutDownAnimQuick=holster_short
	IdleAnim(0)=idle_01
	IdleAnim(1)=idle_02
	IdleAnim(2)=idle_03

	AmmoClipSize=5

	m_flEncumberance=1.0
	m_fCanSprint=true

	WeaponBoneName=rifle_hold

	BreatheProfileClass=class'gbxSniperBreatheProfile'
	
	nIconX=458
	nIconY=0
	nIconW=26
	nIconH=137

	DEPawnPackGoreClass(0)=class'gbxInventory.ConscriptK98GoreSetup'
	DEPawnPackGoreClass(1)=class'gbxInventory.InfantryK98GoreSetup'
	DEPawnPackGoreClass(2)=class'gbxInventory.ParaSturmGoreSetup'
	DEPawnPackGoreClass(3)=class'gbxInventory.PanzerK98GoreSetup'

	WeaponName = WN_K98Sniper
	AmmoName = AM_Nothing

	SelectAnimReadyDelay = 0.5
	PutDownAnimReadyDelay = 1.25
}
//=============================================================================
// WeapDEK98_
//=============================================================================
class WeapDEK98_ extends WargameWeapon
    config(user);

simulated function LoadWeaponMesh()
{
	Mesh = Mesh( DynamicLoadObject( "k_view_weapons.view_k98", class'Mesh' ) );
	m_NormalViewMesh = Mesh( DynamicLoadObject( "k_view_weapons.view_k98", class'Mesh' ) );
	m_ZoomViewMesh = Mesh( DynamicLoadObject( "k_view_weapons.view_k98_crosshair", class'Mesh' ) );
	LinkMesh( Mesh );
	Super.LoadWeaponMesh();
}

function byte BestMode()
{
	return 0;
}

function bool CanShootDuringMelee() 
{ 
	return false; 
}

defaultproperties
{
    ItemName="German K98 Rifle"

    FireModeClass(0)=FireDEK98_
    FireModeClass(1)=FireSecondaryItem
    FireModeClass(2)=FireMelee
    InventoryGroup=2
//	Mesh=Mesh'k_view_weapons.view_k98'
//	m_NormalViewMesh=Mesh'k_view_weapons.view_k98'
//	m_ZoomViewMesh=Mesh'k_view_weapons.view_k98_crosshair'
	m_nCharacterBodyIdx=3
    BobDamping=0.5
    PickupClass=class'PickupWeapDEK98_'
    EffectOffset=(X=100.0,Y=25.0,Z=-10.0)
	DisplayFOV=+50.0
    AttachmentClass=class'AttachmentDEK98_'

    DrawScale=1.0
	PlayerViewOffset=(X=20.000,Y=0.000000,Z=-0.50000)
    SelectSound=None

	AIRating=+0.4
    CurrentRating=0.4

	// This icon no longer exists.
	//Icon=material'WG_HUD.HUD.wpn_garand'

//	m_aClipIcon=material'WG_HUD.HUD.clip_garand'
//	m_flBulletHeight=18
//	m_flClipHeight=128
//	m_flClipWidth=128
//	m_fClipFront=true
//	m_aFrontBulletIcon=material'WG_HUD.HUD.ammo_bullet_frt'
//	m_aFrontBulletIcon=material't_interface_mb.HUD.ammo_30cal'
//	m_aBackBulletIcon=material'WG_HUD.HUD.ammo_bullet_bck'
	m_nBulletIconTextureX=258
	m_nBulletIconTextureY=177
	m_nClipIconTextureX=206
	m_nClipIconTextureY=177

	m_eWeaponType=WeaponPrimary
	MyMeleeDamageType=class'DamageUSGunButtMelee'

	DefaultAmmoCount(0)=65

	ZoomInAnim=aim_up
	ZoomOutAnim=aim_down
	SelectAnim=deploy
	PutDownAnim=holster
	PutDownAnimQuick=holster_short
	IdleAnim(0)=idle_01
	IdleAnim(1)=idle_02
	IdleAnim(2)=idle_03

	AmmoClipSize=5

	m_flEncumberance=1.0
	m_fCanSprint=true

	WeaponBoneName=rifle_hold

	BreatheProfileClass=class'gbxMediumBreatheProfile'

	nIconX=465
	nIconY=0
	nIconW=19
	nIconH=137

	DEPawnPackGoreClass(0)=class'gbxInventory.ConscriptK98GoreSetup'
	DEPawnPackGoreClass(1)=class'gbxInventory.InfantryK98GoreSetup'
	DEPawnPackGoreClass(2)=class'gbxInventory.ParaSturmGoreSetup'
	DEPawnPackGoreClass(3)=class'gbxInventory.PanzerK98GoreSetup'

	WeaponName = WN_DEK98
	AmmoName = AM_Nothing

	SelectAnimReadyDelay = 0.5
	PutDownAnimReadyDelay = 1.25
}
//=============================================================================
// WeapDEMG42Static
//=============================================================================
class WeapDEMG42Static extends WargameWeapon
    config(user);


var Cue				FireLoopSound;
var String			FireLoopSoundName;
var	int				FireLoopSoundHandle;
var Cue				FireOneBulletSound;
var String			FireOneBulletSoundName;

var bool			bWeaponFiring;

simulated function PostBeginPlay()
{
	if ( FireLoopSoundName != "" )
		FireLoopSound = LoadSound(FireLoopSoundName);
	if ( FireOneBulletSoundName != "" )
		FireOneBulletSound = LoadSound(FireOneBulletSoundName);
		
	Super.PostBeginPlay();
}

simulated function LoadWeaponMesh()
{
	Mesh = Mesh( DynamicLoadObject( "k_view_model_us.view_thompson", class'Mesh' ) );
	m_NormalViewMesh = Mesh( DynamicLoadObject( "k_view_model_us.view_thompson", class'Mesh' ) );
	m_ZoomViewMesh = Mesh( DynamicLoadObject( "k_view_model_us.view_thompson_crosshair", class'Mesh' ) );
	LinkMesh( Mesh );
	Super.LoadWeaponMesh();
}

function byte BestMode()
{
	return 0;
}

//---------------------------------------------------------
//	StartFiringWeapon
//---------------------------------------------------------
function StartFiringWeapon()
{
	if ( bWeaponFiring )
		return;

	// RSC: dont fire if we are issuing a command
	if( !Instigator.Controller.AllowFire() )
		return;

	FireLoopSoundHandle = PlaySoundCue( FireLoopSound, SLOT_NONE, TransientSoundVolume,,,,false);

	if ( FireMode[0].IsA( 'FireDEMG42_' ) )
		FireDEMG42_( FireMode[0] ).StartFiringWeapon();

	Super.StartFiringWeapon();

	bWeaponFiring = true;
}

//---------------------------------------------------------
//	StopFiringWeapon
//---------------------------------------------------------
function StopFiringWeapon()
{
	if ( FireMode[0].IsA( 'FireDEMG42_' ) )
		FireDEMG42_( FireMode[0] ).StopFiringWeapon();

	if ( !bWeaponFiring )
		return;

	if (FireLoopSoundHandle != 0)
	{
		StopSound( FireLoopSoundHandle );
		FireLoopSoundHandle = 0;

		PlaySoundCue( FireOneBulletSound, SLOT_NONE, TransientSoundVolume,,,,false);
	}

	Super.StopFiringWeapon();

	bWeaponFiring = false;
}

//---------------------------------------------------------
//	Tick
//---------------------------------------------------------
function Tick( float DeltaTime )
{
	local gbxMuzzleFlash MuzFlash;

	// Hide the muzzle flash if in first-person mode because we only want 
	// to render it during PostRender().
	MuzFlash = gbxMuzzleFlash( FireDEMG42Static( FireMode[0] ).GetMuzzleFlash() );
	if (MuzFlash != None)
	{
		if ( m_fZoomed )
			MuzFlash.bHidden = true;
		else
			MuzFlash.bHidden = false;
	}

	if ( FireMode[0] != None )
	{
		if ( FireMode[0].bIsFiring && !bWeaponFiring )
		{
			StartFiringWeapon();
		}
		else if ( !FireMode[0].bIsFiring && bWeaponFiring )
		{
			StopFiringWeapon();
		}
	}

	Super.Tick( DeltaTime );
}

//---------------------------------------------------------
//	StopFire
//---------------------------------------------------------
simulated event StopFire(int Mode)
{
	if (FireLoopSoundHandle != 0)
	{
		StopSound( FireLoopSoundHandle );
		FireLoopSoundHandle = 0;

		PlaySoundCue( FireOneBulletSound, SLOT_NONE, TransientSoundVolume,,,,false);
	}

	bWeaponFiring = false;
	StopFiringWeapon();
	Super.StopFire( Mode );
}

defaultproperties
{
    ItemName="German MG42 Machinegun"

    FireModeClass(0)=FireDEMG42Static
    FireModeClass(1)=FireDEMG42Static
    FireModeClass(2)=FireMelee
    InventoryGroup=2
//	Mesh=Mesh'K_view_model_us.view_thompson'
//	m_NormalViewMesh=Mesh'K_view_model_us.view_thompson'
//	m_ZoomViewMesh=Mesh'K_view_model_us.view_thompson_crosshair'
	m_nCharacterBodyIdx=4
    BobDamping=0.5
    PickupClass=class'PickupWeapDEMP40_'
    EffectOffset=(X=100.0,Y=25.0,Z=-10.0)
	DisplayFOV=+50.0
    AttachmentClass=class'AttachmentDEMP40_'

    DrawScale=1.0
	PlayerViewOffset=(X=20.000,Y=0.000000,Z=-0.50000)
    SelectSound=None

	AIRating=+0.4
    CurrentRating=0.4

	FireLoopSoundName="W_MG42A.LOOP"
	FireOneBulletSoundName="W_MG42A.SINGLE"
	
	m_eWeaponType=WeaponPrimary
	MyMeleeDamageType=class'DamageUSGunButtMelee'

	DefaultAmmoCount(0)=400

	ZoomInAnim=aim_up
	ZoomOutAnim=aim_down
	SelectAnim=deploy
	PutDownAnim=holster
	IdleAnim(0)=idle_01
	IdleAnim(1)=idle_02
	IdleAnim(2)=idle_03

	WeaponBoneName=rifle_hold

	m_flPauseTimeExposed=0.7

	AmmoClipSize=400

	m_flEncumberance=1.0
	m_fCanSprint=true
	m_bIsAutomatic=true

	nIconX=334
	nIconY=0
	nIconW=24
	nIconH=99
}
//=============================================================================
// German MG42 turret-mounted machine gun.
//
// Author: Neil Johnson, Gearbox Software.
//=============================================================================

class WeapDEMG42_ extends TurretWeapon;

//---------------------------------------------------------
//	Configurable Properties
//---------------------------------------------------------
var ()	Name	GunnerMountTag;				// Tag of the PathNode where the gunner should mount.
var ()	Name	MountEvent;
var ()	Name	DismountEvent;

//---------------------------------------------------------
//	Variables / Constants
//---------------------------------------------------------
var MG42Trigger	MyTrigger;			// The context-use trigger used to get on/off this weapon.
var Name			GunnerToDraft;
var Vector			BaseVector;
var Vector			LocalX, LocalY, LocalZ;		// The local axes of the mount.
var Vector			GunnerOffset;				// Used to position the gunner mesh.
var Vector			FeederOffset;				// Used to position the ammo feeder.
var Vector			SpotterOffset;				// Used to position the spotter.
var Vector			CameraStartOffset;
var Vector			CameraMountedOffset;
var Vector			CameraDismountedOffset;
var Vector			CameraOffset;
var Vector			CameraOffsetZoomed;
var bool			bIsMounting;
var bool			bIsDismounting;
var bool			bWeaponFiring;
var bool			bFirstPersonZoom;
var bool			bFreeCamera;
var bool			bDontRecruit;
var bool			bDontDismountUnlessFlanked;
var bool			bDontFleeFromGrenades;
var bool			bZoomAfterSA;
var float			MountStartStamp;
var float			NextCrewCheckTime;			// The next timestamp at which to check for crew candidates.
var float			MaxRotSpeed;
var float			LastTimeSecs;
var float			CameraMountSpeed, CameraDismountSpeed;
var float			HorizCosTheta, VertCosTheta;
var float			CrossHairNextDrawTime, CrosshairDrawFreq;
var float			CompleteMountTime;
var float			DismountTime;
var gbxPawn			Crew[3];					// The pawns manning this weapon.
var gbxPawn			Claimants[3];				// The pawns claiming this weapon for gunning, feeding, and spotting.
var Array<gbxPawn>	CandidateList;				// List of candidates for this weapon's crew.
var ActorLite	GunnerMountPoint;
var ActorLite	FeederMountPoint;
var ActorLite	SpotterMountPoint;
var MG42Factory	MyFactory;

var Range	PauseTime_Low;
var Range	PauseTime_High;

var Rotator	MyLastRot;

var const int HorizFieldUU;
var const int VertFieldUU;
var const int CameraPitchUU;

// The names of the animations to use nine-point blending with
// when using this weapon.
var Name	PlayerMountAnim, PlayerDismountAnim;
var Name	PawnForwardDownAnim, PawnForwardLevelAnim, PawnForwardUpAnim,
			PawnLeftDownAnim, PawnLeftLevelAnim, PawnLeftUpAnim,
			PawnRightDownAnim, PawnRightLevelAnim, PawnRightUpAnim;

enum VerticalFacing		{VF_Up, VF_Center, VF_Down};
enum HorizontalFacing	{HF_Left, HF_Center, HF_Right};

var const int	GUNNER;

var float PrevAlpha1, PrevAlpha2;
var NinePointDir PrevDirDiag, PrevDirEdge;

simulated function LoadWeaponMesh()
{
	Mesh = Mesh( DynamicLoadObject( "k_view_weapons.mg42_crosshair", class'Mesh' ) );
	LinkMesh( Mesh );
	//log(self$".LoadWeaponMesh() - "$Mesh);
	Super.LoadWeaponMesh();
}

//---------------------------------------------------------
//	PostNetBeginPlay
//---------------------------------------------------------
simulated function PostNetBeginPlay()
{
	//Log( " WeapDEMG42_::PostNetBeginPlay()", 'MP' );

	if ( ThirdPersonActor == None )
	{
		ThirdPersonActor = Spawn(AttachmentClass,Owner);		
		InventoryAttachment(ThirdPersonActor).InitFor(self);
	}

	Super.PostNetBeginPlay();
		
	GiveAmmo(0);

	//Log( " WeapDEMG42_::PostNetBeginPlay() ThirdPersonActor="$ThirdPersonActor, 'MP' );

	PlayAnim( 'Idle', 1.0 );
}

//---------------------------------------------------------
//	IsMachineGun
//---------------------------------------------------------
function bool IsMachineGun() 
{ 
	return true; 
}

//---------------------------------------------------------
//	SetFactory
//---------------------------------------------------------
function SetFactory( MG42Factory NewFactory )
{
	MyFactory = NewFactory;
	SetBase(None);

	BaseVector = Vector( MyFactory.Rotation );
}

//---------------------------------------------------------
//	AttachPathNodes
//---------------------------------------------------------
function AttachPathNodes()
{
	local ActorLite NavPoint;
	local name NavPointTag;

	if (GunnerMountTag == '')  // this MG42 not used by AI (no mount PathNode specified)?
		return;

	// Locate the mount nodes.
	for (NavPoint=Level.NavigationPointList; NavPoint!=None; NavPoint=NavPoint.nextNavigationPoint)
	{
		if (NavPoint.bIsNavigationPoint)
			NavPointTag = NavigationPoint(NavPoint).Tag;
		else if (NavPoint.bIsNavigationPointLite)
			NavPointTag = NavigationPointLite(NavPoint).Tag;

		if ( NavPointTag == GunnerMountTag )
		{
			GunnerMountPoint = NavPoint;
			break;
		}
	}	

	if ( GunnerMountPoint != None )
	{
		if (GunnerMountPoint.bIsNavigationPoint)
			NavigationPoint(GunnerMountPoint).SetLocation( GetMyMountPoint() );
		else if (GunnerMountPoint.bIsNavigationPointLite)
			NavigationPointLite(GunnerMountPoint).SetLocation( GetMyMountPoint() );
	}
}

//---------------------------------------------------------
//	Landed
//---------------------------------------------------------
event Landed( vector HitLocation, vector HitNormal )
{
	// Adjust the location of the gunner mount to be _precisely_ where we want them to be.
	if ( GunnerMountPoint != None )
	{
		if (GunnerMountPoint.bIsNavigationPoint)
			NavigationPoint(GunnerMountPoint).SetLocation( GetMyMountPoint() );
		else if (GunnerMountPoint.bIsNavigationPointLite)
			NavigationPointLite(GunnerMountPoint).SetLocation( GetMyMountPoint() );
	}
}

//---------------------------------------------------------
//	HasPendingGunner
//---------------------------------------------------------
function bool HasPendingGunner()
{
	return (Claimants[GUNNER] != None);
}

//---------------------------------------------------------
//	PawnIsInCrew
//---------------------------------------------------------
function bool PawnIsInCrew( Pawn P ) 
{ 
	return P == Crew[GUNNER];
}

//---------------------------------------------------------
//	GetBestBurstLength
//---------------------------------------------------------
function GetBestBurstLength( ESuppressionLevel SuppressionLevel, out float MinLen, out float MaxLen )
{
	FireMode[0].GetBestBurstLength( SuppressionLevel, MinLen, MaxLen );
}

//---------------------------------------------------------
//	GetBestPauseTime
//---------------------------------------------------------
function GetBestPauseTime( ESuppressionLevel SuppressionLevel, out float MinLen, out float MaxLen )
{
	if ( SuppressionLevel == SL_UNSUPPRESSED )
	{
		MinLen = PauseTime_Low.Min;
		MaxLen = PauseTime_Low.Max;
	}
	else
	{
		MinLen = PauseTime_High.Min;
		MaxLen = PauseTime_High.Max;
	}
}

//---------------------------------------------------------
//	Tick
//---------------------------------------------------------
function Tick( float DeltaTime )
{
	local int x;
	local class<gbxAIController> MindClass;
	local gbxPawn ClosestPawn;
	local gbxMuzzleFlash MuzFlash;

	//log( self$ " WeapDEMG42_::Tick()", 'MP' );

	// Hide the muzzle flash if a players is in first-person mode because we only want 
	// to render it during PostRender(). 
	MuzFlash = gbxMuzzleFlash( FireDEMG42_( FireMode[0] ).GetMuzzleFlash() );
	if ( bFirstPersonZoom && Crew[GUNNER].IsA( 'gbxPlayerPawn' ) )
	{
		MuzFlash.bHidden = true;		
	}
	else
	{
		MuzFlash.bHidden = false;		
	}

	if ( FireMode[0] != None )
	{		
		// Ensure that a gunner-less MG is not firing ad infinitum.
		if ( bWeaponFiring && ( Crew[GUNNER] == None || Crew[GUNNER].IsDead() ) )
		{
			StopFiringWeapon();
		}
		else if ( FireMode[0].bIsFiring && !bWeaponFiring && !bIsDismounting )
		{			
			StartFiringWeapon();
		}
		else if ( !FireMode[0].bIsFiring && bWeaponFiring )
		{
			StopFiringWeapon();
		}
	}

	if ( Level.TimeSeconds > NextCrewCheckTime )
	{
		NextCrewCheckTime = Level.TimeSeconds + 5.0;

		// Check if the claimants/crew are still alive.
		for(x=0; x < 3; ++x)
		{
			if ( !bIsMounting && ( bDontRecruit || ( Claimants[x] != None && Claimants[x].IsDead() ) ) )
			{
				Claimants[x] = None;
			}
		}
		for(x=0; x < 3; ++x)
		{
			if ( Crew[x] == None || Crew[x].IsDead() )
			{
				if ( x == GUNNER && Crew[GUNNER] != None )
				{
					StopFiringWeapon();
					Instigator = None;
					Ammo[0].Instigator = None;
					FireMode[0].Instigator = None;
				}

				Crew[x] = None;
			}
		}

		// Fill vacant crew positions.
		if ( Crew[GUNNER] == None && CheckOKToRecruit() )		
		{
			ClosestPawn = GetClosestCandidate();
			//log( self$ " WeapDEMG42_::Tick() Passed recruit test!  ", 'MP' );
			if ( ClosestPawn != None && ( Claimants[GUNNER] == None || ClosestPawn == Claimants[GUNNER] ) && ClosestPawn.CanCrewTurret( Self ) )
			{				
				MindClass = class<gbxAIController>( DynamicLoadObject( "gbxAI.MindMG42Gunner", class'Class' ) );
				Claimants[GUNNER] = ClosestPawn;
				ClosestPawn.CrewTurret( Self, MindClass, Job_MG42_Gunner );
			}
			/*else
			{
				log( self$ " WeapDEMG42_::Tick() Failed to added to turret crew!", 'MP' );
			}*/
		}

	}

	Super.Tick( DeltaTime );
}

function ActivateOracle()
{
	if (bFirstPersonZoom)
	{
		bZoomAfterSA = true;	
		bFirstPersonZoom = false;
		MyFactory.ShowFactory();
	}
	else if (bZoomAfterSA)
	{
		bFirstPersonZoom = true;
		MyFactory.HideFactory();
		bZoomAfterSA = false;
	}

}

//---------------------------------------------------------
//	CheckOKToRecruit
//---------------------------------------------------------
function bool CheckOKToRecruit()
{
	return ( !bDontRecruit && ( CandidateList.Length > 0 || GunnerToDraft != '' ) );
}

//---------------------------------------------------------
//	GetDraftedGunner
//---------------------------------------------------------
function gbxPawn GetDraftedGunner()
{
	local gbxPawn DraftedGunner;

	//log( self$ " WeapDEMG42_::GetDraftedGunner() GunnerToDraft: " $GunnerToDraft, 'MP' );

	if ( GunnerToDraft != '' )
	{
		foreach DynamicActors( class 'gbxPawn', DraftedGunner, GunnerToDraft )
		{
			if ( DraftedGunner.IsDead() )
			{
				//log( self$ " WeapDEMG42_::GetDraftedGunner() DraftedGunner is DEAD!", 'MP' );
				
				GunnerToDraft = '';
				return None;
			}
			else
			{
				//log( self$ " WeapDEMG42_::GetDraftedGunner() DraftedGunner: " $DraftedGunner, 'MP' );

				return DraftedGunner;
			}
		}
	}

	return None;
}

//---------------------------------------------------------
//	GetClosestCandidate
//---------------------------------------------------------
function gbxPawn GetClosestCandidate()
{
	local Pawn MountPointClaimant;
	local gbxPawn ClosestPawn;
	local float OneDist, ClosestDist;
	local int x;
	local bool bClosestPawnIsDraftee;

	if (GunnerMountPoint == None)  // no Gunner mount point specified (and thus no AI can use it)?
		return None;

	ClosestPawn = None;
	ClosestDist = 99999;	

	//log( self$ " WeapDEMG42_::GetClosestCandidate()", 'MP' );

	// Get the draftee, if he exists.
	ClosestPawn = GetDraftedGunner();

	if ( ClosestPawn != None )
	{
		bClosestPawnIsDraftee = true;
	}
	else
	{
		bClosestPawnIsDraftee = false;

		for(x = 0; x < CandidateList.Length; ++x)
		{
			if ( CandidateList[x].IsDead() )
			{
				CandidateList.Remove( x, 1 );
				continue;
			}

			if ( /*CandidateList[x] == Claimants[GUNNER] ||*/
				CandidateList[x] == Crew[GUNNER] ||
				!CandidateList[x].CanCrewTurret( Self ) )
			{
				continue;
			}

			OneDist = VSizeIgnoreZ( CandidateList[x].Location - Self.Location );
			if ( OneDist < ClosestDist )
			{
				ClosestDist = OneDist;
				ClosestPawn = CandidateList[x];
			}
		}
	}

	//log( self$ " WeapDEMG42_::GetClosestCandidate() bClosestPawnIsDraftee: "$bClosestPawnIsDraftee$ " CandidateList.Length: "$CandidateList.Length$ " ClosestPawn: " $ClosestPawn, 'MP' );

	// Check if anyone has claimed the mount point.
	if ( GunnerMountPoint.bIsNavigationPointLite )
		MountPointClaimant = NavigationPointLite( GunnerMountPoint ).Claimant;
	else
		MountPointClaimant = NavigationPoint( GunnerMountPoint ).Claimant;

	//log( self$ " WeapDEMG42_::GetClosestCandidate() MountPointClaimant: "$MountPointClaimant, 'MP' );

	// If the mount point's claimant is the guy we picked, groovy, go ahead and recruit him.
	// If the mount point's claimant is NOT the guy we picked, skip recruiting altogether if we have a
	// handpicked draftee in mind.  If we don't have a draftee, hell, just try to recruit the claimant.
	if ( MountPointClaimant == None || MountPointClaimant == ClosestPawn )
	{
		//log( self$ " WeapDEMG42_::GetClosestCandidate() returning ClosestPawn!!", 'MP' );
		return ClosestPawn;
	}
	else if ( !bClosestPawnIsDraftee && MountPointClaimant.IsA( 'gbxPawn' ) && gbxPawn( MountPointClaimant ).CanCrewTurret( Self ) )
	{
		//log( self$ " WeapDEMG42_::GetClosestCandidate() returning MountPointClaimant!!", 'MP' );
		return gbxPawn( MountPointClaimant );
	}
	else
	{
		//log( self$ " WeapDEMG42_::GetClosestCandidate() returning NONE!!", 'MP' );
		return None;
	}
}

//---------------------------------------------------------
//	CalculateLerpedRotator
//---------------------------------------------------------
function Rotator CalculateLerpedRotator( Rotator Rot1, Rotator Rot2, float LerpSpeed, out int YawDiff )
{
	local bool bDidSubtract;
	local bool bIsNegative;
	local Rotator TempRot;
	
	YawDiff = Rot1.Yaw - Rot2.Yaw;
	bIsNegative = (YawDiff < 0);

	YawDiff = abs(YawDiff);

	if ( YawDiff > 32768)
	{
		YawDiff = 65536 - YawDiff;
		bDidSubtract = true;
	}

	if ( LastTimeSecs == 0 )
		LastTimeSecs = Level.TimeSeconds;

	if ( ( bDidSubtract && bIsNegative ) || ( !bDidSubtract && !bIsNegative ) )
	{
		// Rot1 is to the RIGHT of Rot2; YawDiff is the angle (in Unreal Units).
		TempRot.Yaw = (Rot1.Yaw - LerpSpeed*(Level.TimeSeconds - LastTimeSecs )*YawDiff) & 65535;
	}
	else
	{
		// Rot1 is to the LEFT of Rot2; YawDiff is the angle (in Unreal Units).
		TempRot.Yaw = (Rot1.Yaw + LerpSpeed*(Level.TimeSeconds - LastTimeSecs )*YawDiff) & 65535;
	}

	TempRot.Pitch = Rot2.Pitch;
	TempRot.Roll = Rot2.Roll;

	LastTimeSecs = Level.TimeSeconds;
	return TempRot;
}

//---------------------------------------------------------
//	FaceRotation
//---------------------------------------------------------
// Make the turret weapon rotate to face a particular direction.
function FaceRotation( Rotator Rot ) {

	// OK, now the aim is to end up with two alpha values for
	// animation channels 1 and 2.  These channels, along with
	// base channel 0, will be blended to produce a smooth transitioning
	// of the gunner's pose as the user moves the mouse.
	//
	// Channel 0 plays the 'level-forward' gunning animation at all times.
	// Channel 1 plays an 'edge animation' (i.e. 'level-left', 'level-right',
	// 'up-forward', or 'down-forward').  Channel 2 plays a 'diagonal animation'
	// (i.e. 'up-left', 'up-right', 'down-left', or 'down-right').
	//
	// The blending occurs progressively; that is, the edge animation is
	// blended over the base animation first, and then the diagonal animation
	// is blended over that result in turn.
	//
	local Vector Aim, AimXY, AimXZ, D, V;
	local Float DotH, DotV, DotCamera, Alpha1, Alpha2, m;
	local HorizontalFacing HorizFace;
	local VerticalFacing VertFace;
	local NinePointDir DirDiag, DirEdge;
	local Rotator LerpedRot;
	local int YawDiff;
	local bool bUpdateClient;

	//Log( self$" WeapDEMG42_::FaceRotation() Rot="$Rot, 'MP' );

	// TODO:  PERF!  Why don't we keep a copy of the last rotation so we can avoid all of this work if the rotation is the same?

	// Sanity check.
	if (Crew[GUNNER] == None)
	{
		log("Error: MG42 Gunner is null!", 'MP');
		return;
	}
	if ( bIsDismounting )
	{
		return;
	}

	GetAxes(MyFactory.Rotation, LocalX, LocalY, LocalZ);

	// Smoothly interpolate the rotation.
	//
	// If the camera is facing to the rear of the weapon, interpolate nice and slowly when the camera crosses the Prime Meridian.
	//	
	// Lerp iff: the gunner is AI-controlled, the difference in movement since the last tick is large, or the camera is facing to the rear.
	if ( !Crew[GUNNER].IsHumanControlled() || ( !bFirstPersonZoom && (YawDiff > 2000 || DotCamera < 0) ) )
	{
		DotCamera = Vector(Rot) dot Vector(MyFactory.Rotation);
		if ( DotCamera < 0 )
			MaxRotSpeed = 1;	
		else
			MaxRotSpeed = Default.MaxRotSpeed;	
		
		LerpedRot = CalculateLerpedRotator( MyLastRot, Rot, MaxRotSpeed, YawDiff );
		Rot = LerpedRot;		
	}
	
	RestrictYawAndPitch( Rot );	
	
	// Adjust the gun's actual rotation.
	SetRotation(Rot);
	SetLocation( MyFactory.Rebalance( Rot ) );
	
	MyLastRot = Rot;

	// Next, we'll calculate DotH and DotV again, only using the gun's actual
	// current orientation (due to the motion-delay placed on the gun, the
	// actual orientation may differ from the requested orientation.
	Aim = Vector(Rotation);
	AimXZ = Aim - ((Aim dot LocalY) * LocalY);
	AimXY = Aim - ((Aim dot LocalZ) * LocalZ);
	AimXZ = Normal(AimXZ);
	AimXY = Normal(AimXY);

	DotH = AimXY dot LocalY;
	DotV = AimXZ dot LocalZ;

	// The extants of movement are -45deg to 45deg in the horizontal direction,
	// and -15deg to 15deg in the vertical direction,
	// so the min/max dot products will be +/-0.7071 and +/-0.2588.
	// Remap the dot-prods into the space -1.0 to 1.0.
	DotH /= HorizCosTheta;
	DotV /= VertCosTheta;

	DotH = FClamp( DotH, -1.0, 1.0 );
	DotV = FClamp( DotV, -1.0, 1.0 );

	// Determine what quadrant the aim vector is in.
	if (DotV < 0)
		VertFace = VF_Down;
	else
		VertFace = VF_Up;

	//if (DotH < 0)
	if (DotH > 0)
		HorizFace = HF_Right;
	 else
		HorizFace = HF_Left;


	// Absolute-value the dot prods so that we can simplify calculations below.
	DotH = abs(DotH);
	DotV = abs(DotV);

	//_DotH = DotH;
	//_DotV = DotV;

	// From the quadrant information, determine which two
	// diagonal and edge animations to use.
	if (VertFace == VF_Down) {
		if (HorizFace == HF_Left) {
			DirDiag = NPD_LowLeft;
			if (DotH >= DotV)
				DirEdge = NPD_MidLeft;
			else
				DirEdge = NPD_LowCenter;
		} else {
			DirDiag = NPD_LowRight;
			if (DotH >= DotV)
				DirEdge = NPD_MidRight;
			else
				DirEdge = NPD_LowCenter;
		}
	} else {	// VF_Up
		if (HorizFace == HF_Left) {
			DirDiag = NPD_UpLeft;
			if (DotH >= DotV)
				DirEdge = NPD_MidLeft;
			else
				DirEdge = NPD_UpCenter;
		} else {
			DirDiag = NPD_UpRight;
			if (DotH >= DotV)
				DirEdge = NPD_MidRight;
			else
				DirEdge = NPD_UpCenter;
		}
	}

	// Step 4: Figure the alpha blending values to use for the
	// two channels.  Point D is the point in 2D space that we found
	// above.  Point V is a point of intersection between the line thru
	// D and the nearest corner with the x- or the y-axis.
	//
	// Alpha1 is found by finding the distance from the origin to V.
	// Alpha2 is the distance between V and D.
	//
	// By absolute-valuing the dot prods above, we reduce the problem
	// to quadrant 1 (at this point, we have the two animations we need.
	// Except for knowing whether our edge-animation is horizontal or vertical,
	// quadrant information is no longer relevant.
	//
	D.X = DotH;	// 0.0 to 1.0, no negative values.
	D.Y = DotV;	// 0.0 to 1.0, no negative values.
	D.Z = 0;

	if (D.X == 1.0)	{	// Avoid divide-by-zero errors in the slope formula.
		Alpha1 = 1.0;
		Alpha2 = D.Y;
	} else {
		// m is the slope of the line through D and the corner (1,1).
		m = (1.0 - D.Y) / (1.0 - D.X);

		if (DirEdge == NPD_MidRight || DirEdge == NPD_MidLeft) {

			// The edge-animation is horizontal, so find x when
			// the line intercepts the x-axis (when y=0).
			Alpha1 = D.X - (D.Y / m);	// -b/m in intercept-slope formula.
			V.x = Alpha1;
			V.y = 0;
			V.z = 0;

		} else {	// Vertical edge (NPD_UpCenter or NPD_LowCenter).
			// The edge-animation is vertical, so find y when
			// the line intercepts the y-axis (when x=0).
			Alpha1 = D.Y - (m * D.X);	// 'b' in intercept-slope formula.
			V.x = 0;
			V.y = Alpha1;
			V.z = 0;
		}

		// Alpha2 is the proportion of the length of vector D - V
		// to that of vector (1,1) - V.  The equation used below
		// is the optimized form of the one in comments.
		Alpha2 = VSize(D - V) / (1.41421 - 0.41421 * Alpha1);	// 0.41421 == sqrt(2)
		//Alpha2 = VSize(D - V) / VSize(Vect(1,1,0) - V);		// Keep this for reference.
	}

	// Play the gunning animations, supplying the edge-animation,
	// the diagonal-animation, and their blending factors.

	if ( Level.Game.GameReplicationInfo.GameType == GT_SINGLEPLAYER )
	{
		Crew[GUNNER].DoNinePointBlending( DirEdge, Alpha1, DirDiag, Alpha2 );
		MyFactory.DoNinePointBlending( DirEdge, Alpha1, DirDiag, Alpha2 );
	}
	else
	{
		// TODO: Make guy nine point blend too on the client
		//Crew[GUNNER].ClientDoNinePointBlending( DirEdge, Alpha1, DirDiag, Alpha2 );
                Crew[GUNNER].DoNinePointBlending( DirEdge, Alpha1, DirDiag, Alpha2 );
		
		// Server runs the function like normal
		MyFactory.DoNinePointBlending( DirEdge, Alpha1, DirDiag, Alpha2 );

		// Now do some work for the client

		// This would be more effecient if these were variables being passed over since its possible that only one of them is changing at a time!
		// Keep this function though to turn on the bDoBlending flag for the factory.
		if ( DirDiag != PrevDirDiag )
		{
			//Log( self$" WeapDEMG42_::FaceRotation() DirDiag != PrevDirDiag", 'MP' );
			bUpdateClient = true;
		}
		else if ( DirEdge != PrevDirEdge ) 
		{
			//Log( self$" WeapDEMG42_::FaceRotation() DirEdge != PrevDirEdge", 'MP' );
			bUpdateClient = true;
		}
		else if ( (!FloatsTheSame(Alpha1, PrevAlpha1, 0.1)) )
		{
			//Log( self$" WeapDEMG42_::FaceRotation() Alpha1 != PrevAlpha1", 'MP' );
			bUpdateClient = true;
		}
		else if ( (!FloatsTheSame(Alpha2, PrevAlpha2, 0.1)) )
		{
			//Log( self$" WeapDEMG42_::FaceRotation() Alpha2 != PrevAlpha2", 'MP' );
			bUpdateClient = true;
		}
		
		MyFactory.bDoBlending = true;

		if ( bUpdateClient )
		{
			//Log( self$" WeapDEMG42_::FaceRotation() Updating vars to replicate to client.", 'MP' );
			// Save for next time
			MyFactory.BlendAlpha1 = Alpha1;
			MyFactory.BlendAlpha2 = Alpha2;
			MyFactory.Dir1 = DirDiag;
			MyFactory.Dir2 = DirEdge;
		}
	}
}

function bool FloatsTheSame( float f1, float f2, float minDiff )
{
	local float diff;
	//Log( " WeapDEMG42_::CompareFloats() f1="$f1$" f2="$f2, 'MP' );
	
	diff = abs(f1 - f2);
	
	if ( diff >= minDiff )
		return true;
	else
		return false;
}

//---------------------------------------------------------
//	PreparePawnToMount
//---------------------------------------------------------
function PreparePawnToMount(gbxPawn gbxP)
{
	//log( self$ " WeapDEMG42_::PreparePawnToMount() gbxP: " $gbxP, 'MP' );
	
	if ( gbxP != Claimants[GUNNER] )
	{
		log("Error! Pawn "$gbxP$" attempting to call WeapDEMG42_::PreparePawnToMount() without claiming first.", 'MP');
		return;
	}

	// Do some initial cleanup.
	CleanUpProperties();

	if ( gbxP.IsHumanControlled() )
	{
		if (gbxPlayerController(gbxP.Controller) != None)
			gbxPlayerController(gbxP.Controller).bDisableCrosshair = true;  // temporarily turn crosshair off

		gbxP.SetTurretAnims( PlayerMountAnim, PlayerDismountAnim );
	}

	//log( self$ " WeapDEMG42_::PreparePawnToMount() About to call gbxP.PrepareToMount()!", 'MP' );

	gbxP.PrepareToMount();

	bIsMounting = true;

	SetOwner( Instigator );
}

//---------------------------------------------------------
//	CompleteMount
//---------------------------------------------------------
function CompleteMount( gbxPawn gbxP )
{
	local int Mode;

	//log( self$ " WeapDEMG42_::CompleteMount()", 'MP' );

	if ( gbxP == Claimants[GUNNER] )
	{
		if ( gbxP != Claimants[GUNNER] )
		{
			log("Pawn "$gbxP$" attempting to call WeapDEMG42_::CompleteMount() without claiming first.", 'MP');
			return;
		}

		SetInstaKill( false );	// Just in case it was left with insta-kill on.

		Crew[GUNNER] = gbxP;
		Claimants[GUNNER] = None;

		Instigator = Crew[GUNNER];
		if ( Ammo[0] != None )
			Ammo[0].Instigator = Crew[GUNNER];
		if ( FireMode[0] != None )
			FireMode[0].Instigator = Instigator;
		if ( ThirdPersonActor != None )
			ThirdPersonActor.Instigator = Instigator;
		
		Crew[GUNNER].SetNinePointAnimations(
			PawnForwardDownAnim, PawnForwardLevelAnim, PawnForwardUpAnim,
			PawnLeftDownAnim, PawnLeftLevelAnim, PawnLeftUpAnim,
			PawnRightDownAnim, PawnRightLevelAnim, PawnRightUpAnim);

		Crew[GUNNER].Velocity = vect(0,0,0);
		Crew[GUNNER].bRotateToDesired = false;
		Crew[GUNNER].DesiredRotation = MyFactory.Rotation;		

		GetAxes(MyFactory.Rotation, LocalX, LocalY, LocalZ);
		Crew[GUNNER].SetLocation( GetMyMountPoint() );
		Crew[GUNNER].SetRotation( MyFactory.Rotation );

		//Crew[GUNNER].ResetLookAtImmediate(true, true, true);
		//Crew[GUNNER].StopLookAt( true, true, true );

		Self.SetRotation( MyFactory.Rotation );
		MyLastRot = MyFactory.Rotation;

		bIsMounting = false;

		for( Mode = 0; Mode < NUM_FIRE_MODES; Mode++ )
			if (FireMode[Mode] != None)
//				FireMode[Mode].InitEffects();
				FireMode[Mode].GetMuzzleFlash();

		Crew[GUNNER].SetWeapon( Self );

		if ( Crew[GUNNER].MyUnit != None )
		{
			Crew[GUNNER].MyUnit.MemberGainedMachineGun( Crew[GUNNER] );
		}

		// Send out a mount event to anyone who may be interested.
		TriggerEvent( MountEvent, Self, Crew[GUNNER] );	

		Crew[GUNNER].PlayWaiting();

		// Force player to be zoomed in after mount.
		SetFirstPersonZoom( true );

		CompleteMountTime=Level.TimeSeconds;
		MyTrigger.bDontDisplayMessage = true;

		if (gbxPlayerController(gbxP.Controller) != None)
		{
			gbxPlayerController(gbxP.Controller).bDisableCrosshair = false;

			//NAC:  This call to Timer 2x in a row is an ugly hack, but it forces the user's current weapon and the newly mounted MG to do some necessary clean up/set up code quickly to avoid delays while mounting the MG
			gbxP.Weapon.Timer();
			gbxP.Weapon.Timer();
		}


	}
}

//---------------------------------------------------------
//	CenterWeapon
//---------------------------------------------------------
function MountFailed( gbxPawn gbxP )
{
	Super.MountFailed( gbxP );

	if (gbxPlayerController(gbxP.Controller) != None)
		gbxPlayerController(gbxP.Controller).bDisableCrosshair = false;

	// Reactivate the trigger.
	MyTrigger.bDontDisplayMessage = false;
}

//---------------------------------------------------------
//	CenterWeapon
//---------------------------------------------------------
function CenterWeapon()
{
	SetRotation( MyFactory.Rotation );
	SetLocation( MyFactory.Rebalance( MyFactory.Rotation ) );
	MyFactory.StopBlending();	
}

//---------------------------------------------------------
//	PreparePawnToDismount
//---------------------------------------------------------
function PreparePawnToDismount( gbxPawn gbxP )
{
	// Check that the pawn passed in is the gunner.
	if (gbxP != Crew[GUNNER])
		return;	

	StopFiringWeapon();

	if (gbxPlayerController(gbxP.Controller) != None)
		gbxPlayerController(gbxP.Controller).bDisableCrosshair = true;  // temporarily turn crosshair off

	gbxP.StopNinePointBlending();
	gbxP.SetRotation( MyFactory.Rotation );
	gbxP.Controller.SetRotation( MyFactory.Rotation );

	if (gbxP.bUseRootMotion)
		gbxP.SetPhysics(PHYS_RootMotion);
	else
		gbxP.SetPhysics(PHYS_Walking);

	SetFirstPersonZoom( false );

	bIsDismounting = true;
}

//---------------------------------------------------------
//	CompleteDismount
//---------------------------------------------------------
function CompleteDismount( gbxPawn gbxP )
{
	if ( gbxP == Crew[GUNNER] )
	{
		Instigator = None;
		Ammo[0].Instigator = None;
		FireMode[0].Instigator = None;

		if ( Crew[GUNNER].MyUnit != None )
		{
			Crew[GUNNER].MyUnit.MemberLostMachineGun( Crew[GUNNER] );
		}

		SetInstaKill( false );	// Just in case it was left with insta-kill on.		
		CleanUpProperties();
		CameraOffset.X = 0.0;
		CameraOffset.Z = 0.0;

		// Send out a dismount event to anyone who may be interested.
		TriggerEvent( DismountEvent, Self, gbxP );

		// Reactivate my trigger, which was made inactive when used.
		MyTrigger.bDontDisplayMessage = false;
		MyTrigger.Touch(gbxP); // Retouch the trigger. Brings context message back up

		if (gbxPlayerController(gbxP.Controller) != None)
			gbxPlayerController(gbxP.Controller).bDisableCrosshair = false;
	}

	gbxP.Weapon = None;  // hack so SetWeapon() will call ChangedWeapon() - jlb

	DismountTime = Level.TimeSeconds;
	if ( gbxP.LastWeapon != None )
		gbxP.SetWeapon( gbxP.LastWeapon );
	else
		gbxP.Controller.SwitchToBestWeapon();
	
	CenterWeapon();
}

//---------------------------------------------------------
//	CleanUpProperties
//---------------------------------------------------------
function CleanUpProperties()
{
	Crew[GUNNER] = None;
	bFirstPersonZoom = false;
	bIsMounting = false;
	bIsDismounting = false;
	CameraOffset.X = 0.0;
	CameraOffset.Z = 0.0;
}

//---------------------------------------------------------
//	InformCrewToGetUp
//---------------------------------------------------------
function InformCrewToGetUp( gbxPawn Caller)
{
	local int x;

	//for ( x = 0; x < Crew.Length; ++x )
	for ( x = 0; x < 3; ++x )
	{
		if ( Crew[x] != None && Crew[x] != Caller )
			Crew[x].BreakOutOfJob();
	}
}

//---------------------------------------------------------
//	GunnerDied
//---------------------------------------------------------
function GunnerDied( gbxPawn gbxP )
{
	if ( gbxP == Crew[GUNNER] )
	{
		bFirstPersonZoom = false;
		bIsMounting = false;
		bIsDismounting = false;

		SetRelativeRotation(Rot(0,0,0));

		Crew[GUNNER].bCollideWorld = true;
		Crew[GUNNER].SetLocation( GetMyMountPoint() );

		if ( Crew[GUNNER].MyUnit != None )
		{
			Crew[GUNNER].MyUnit.MemberLostMachineGun( Crew[GUNNER] );
		}

		SetInstaKill( false );	// Just in case it was left with insta-kill on.

		Crew[GUNNER] = None;
		Claimants[GUNNER] = None;

		// Reactivate my trigger, which was made inactive when used.
		MyTrigger.bDontDisplayMessage = false;
	}
}

//---------------------------------------------------------
//	GetMyMountPoint
//---------------------------------------------------------
function Vector GetMyMountPoint()
{
	local Vector X,Y,Z;
	GetAxes( MyFactory.Rotation, X,Y,Z );
	
	return MyFactory.Location + GunnerOffset.X*X + GunnerOffset.Y*Y + GunnerOffset.Z*Z;
}

//---------------------------------------------------------
//	GetMountPoint
//---------------------------------------------------------
function ActorLite GetMountPoint()
{
	return GunnerMountPoint;
}

//---------------------------------------------------------
//	Trigger
//---------------------------------------------------------
event Trigger(Actor Other, Pawn EventInstigator)
{
	local gbxPawn gbxP;
	local Actor EncroachedActor;
	local bool bEncroached;

	gbxP = gbxPawn( EventInstigator );

	// Skip the action instigator is in the middle of a reload.
	if ( gbxP.IsTransitioning() || (gbxP.Weapon != Self &&( gbxP.Weapon.IsReloading() || gbxP.Weapon.IsThrowingGrenade())))  //NAC:  3/10/05 added additional check to see if we are throwing a grenade
		return;

	if ( Crew[GUNNER] == gbxP )	// Gunner wishes to dismount.
	{
		//NAC:if the player hasn't been on the gun long enough to allow the entire mounting proceedure to occur, don't let him dismount
		if (Level.TimeSeconds - CompleteMountTime < 1.0)
			return;
		Crew[GUNNER].DismountTurretPlayer(true);
		MountStartStamp=Level.TimeSeconds;

		MyFactory.SetOwner( None );
	}
	else						// Gunner wishes to mount.
	if ( Crew[GUNNER] == None )
	{
		Claimants[GUNNER] = gbxP;

		if ( Claimants[GUNNER].IsHumanControlled() )
		{
			//NAC:if the player hasn't been off the gun long enough to return him to a normal state don't let him mount again right away
			if (Level.TimeSeconds - DismountTime < 1.0)
				return;
			bEncroached = Claimants[GUNNER].CheckEncroachment( GetMyMountPoint(), MyFactory.Rotation, EncroachedActor );

			if ( bEncroached && EncroachedActor.IsA( 'Pawn' ) && Pawn( EncroachedActor ).IsDead() )
			{
				// TBD: Move dead pawn out of the way somehow
			}
			else
			if ( bEncroached && !EncroachedActor.IsA( 'Pawn' ) )
			{
				bEncroached = false;
			}

			if ( !bEncroached && TryToPlaceGunner( Claimants[GUNNER] ) )
			{
				PreparePawnToMount( Claimants[GUNNER] );
				Claimants[GUNNER].MountTurretPlayer( Self, true );
				if ( Claimants[GUNNER].bHasStartedMountAnim )
				{
					Claimants[GUNNER].SetRotation( MyFactory.Rotation );
					Claimants[GUNNER].Controller.SetRotation( MyFactory.Rotation );
				}
				MountStartStamp=Level.TimeSeconds;

				//log( self$ " WeapDEMG42_::Trigger("$Other$", "$EventInstigator$") Owner: " $Owner, 'MP');

				MyFactory.SetOwner( EventInstigator );
			}
			else
			{
				MyTrigger.bDontDisplayMessage = false;	// We have to do this because gbxContextUseTriggers disable themselves when UsedBy.
				log("WARNING: MG42 encroachment check failed.  EncroachingActor=="$EncroachedActor, 'MP' );
			}
		}		
	}
}

function bool TryToPlaceGunner( gbxPawn TheGunner )
{
	local int i;
	local Vector TrialMountLocation;

	TrialMountLocation = GetMyMountPoint();

	for ( i = 0; i < 10; ++i )
	{
		if ( TheGunner.SetLocation( TrialMountLocation ) )
		{
			return true;
		}
		else
		{		
			log("NAJ**** "$Self.Name$" Failed to mount location; adding 5 units to Z-height.", 'naj' );
			TrialMountLocation.Z += 5;
		}
	}

	return false;
}

//---------------------------------------------------------
//	StartFiringWeapon
//---------------------------------------------------------
function StartFiringWeapon()
{
	//log( " WeapDEMG42_::StartFiringWeapon()", 'MP' );
	if (bAimingAtFriendly && Instigator.IsA('gbxPawn'))
	{
		bFiringAtFriendly = true;
	}

	if ( bWeaponFiring || bIsDismounting )
		return;

	// RSC: Don't fire if we are issuing a command
	if( !Instigator.Controller.AllowFire() )
		return;

	if ( FireMode[0].IsA( 'FireDEMG42_' ) )
		FireDEMG42_( FireMode[0] ).StartFiringWeapon();

	if ( bFirstPersonZoom )
		LoopAnim( 'Fire', 1.0, 0.0 );

	Super.StartFiringWeapon();

	//log( " WeapDEMG42_::StartFiringWeapon() Setting bWeaponFiring to true!", 'MP' );
	bWeaponFiring = true;
}

//---------------------------------------------------------
//	StopFiringWeapon
//---------------------------------------------------------
function StopFiringWeapon()
{
	if ( FireMode[0].IsA( 'FireDEMG42_' ) )
		FireDEMG42_( FireMode[0] ).StopFiringWeapon();

	if ( !bWeaponFiring )
		return;

	if ( bFirstPersonZoom )
		PlayAnim( 'Idle', 1.0 );

	Super.StopFiringWeapon();

	//Log( " WeapDEMG42_::StopFiringWeapon() Setting bWeaponFiring to false!", 'MP' );
	bWeaponFiring = false;
}

function ConsumeAmmo(int Mode, float load) {}

simulated event RenderOverlays( Canvas Canvas ) {}

simulated function DrawHud(canvas Canvas, gbxHud Hud, FontInfo Fonts, int nPass) {}

simulated function DrawCrossHair( canvas Canvas )
{
	local float XLength, YLength;
	local  PlayerController PlayerOwner;
	local Vector HitLoc, HitNorm;
	local Actor HitActor;
	local HUD	Hud;

	if ( bFirstPersonZoom )
		return;

	if (( Level.NetMode == NM_StandAlone ) && (Level.DifficultyLevel == DIFF_Authentic))
	{
		return;
	}
	
	if ( Instigator != None && Instigator.IsHumanControlled() )
	{
		PlayerOwner = PlayerController(Instigator.Controller);
			
		if ( PlayerOwner.DisableCrosshair() )
			return;	

		if ( PlayerOwner.iCrossHairIndex == 0)
			return;

		Hud = PlayerOwner.MyHud;

		if (Hud == None)
		{
			XLength = 32;
			YLength = 32;
		}
		else
		{
			XLength = 32 * Hud.flMinScaleX;
			YLength = 32 * Hud.flMinScaleY;
		}

		if ( Level.TimeSeconds >= CrosshairNextDrawTime )
		{
			HitActor = Trace( HitLoc, HitNorm, Location + 15000 * Vector( Rotation ), Location, false );
			
			if ( HitActor != None )
			{
				Canvas.Style = ERenderStyle.STY_Additive;
				Canvas.SetDrawColor(255,255,255,96);
				Canvas.DrawTile3D( m_TestCrosshairs[PlayerOwner.iCrossHairIndex - 1], HitLoc, XLength, YLength, 0, 0, m_TestCrosshairs[PlayerOwner.iCrossHairIndex - 1].USize, m_TestCrosshairs[PlayerOwner.iCrossHairIndex - 1].VSize);
			}

			CrossHairNextDrawTime = Level.TimeSeconds + CrosshairDrawFreq;
		}
	}		
}

//---------------------------------------------------------
//	FlashMuzzleFlash
//---------------------------------------------------------
// For 3rd person only.  See PostRender() in this class for 1st person muzzle flashes.
simulated function FlashMuzzleFlash()
{
	local gbxMuzzleFlash MuzFlash;
	//Log( " WeapDEMG42_::FlashMuzzleFlash()", 'MP' );

	if ( Crew[GUNNER] == None || bIsDismounting )
		return;

	if ( FireMode[0].IsA( 'FireDEMG42_' ) )
	{
		MuzFlash = gbxMuzzleFlash( FireDEMG42_( FireMode[0] ).GetMuzzleFlash() );

		// We only want to hide the flash if a players is firing it
		if( bFirstPersonZoom && Crew[GUNNER].IsA( 'gbxPlayerPawn' ))	
		{
			MuzFlash.bHidden = true;		// PostRender() will unhide it and render it.
			MuzFlash.Flash();
		}
		else
		{
			MuzFlash.SetLocation( GetMuzzleLocationWorld() );
			MuzFlash.SetRotation( Rotation );
			MuzFlash.Flash();
		}
	}
}

//---------------------------------------------------------
//	AnimEnd
//---------------------------------------------------------
simulated function AnimEnd(int channel)
{
	if ( bFirstPersonZoom )
	{
		if ( bWeaponFiring )
		{
			//PlayAnim( 'Fire', 1.0 );
		}			
		else
		{
			PlayAnim( 'Idle', 1.0 );
		}
	}
	else
		Super.AnimEnd( channel );
}

//---------------------------------------------------------
//	Fire
//---------------------------------------------------------
simulated function Fire(float F)
{	
	// RSC: Don't fire if we are issuing a command. BB: Or if it is being dismounted
	if( !Instigator.Controller.AllowFire() || bIsDismounting )
		return;

	StartFiringWeapon();
	Super.Fire(F);	
}

//---------------------------------------------------------
//	PlayFiringAnim
//---------------------------------------------------------
simulated function PlayFiringAnim()
{
	// Deprecate. 
}

//---------------------------------------------------------
//	StopFire
//---------------------------------------------------------
simulated event StopFire(int Mode)
{
	bWeaponFiring = false;
	StopFiringWeapon();
	Super.StopFire( Mode );
}

//---------------------------------------------------------
//	SetFirstPersonZoom
//---------------------------------------------------------
function SetFirstPersonZoom( bool bZoomed )
{
	local PlayerController PC;

	// don't change zoom settings if currently in OracleCam (SA View) mode...
	if( Level.Game.bOracleCamActive )
		return;

	bFirstPersonZoom = bZoomed;

	if ( Crew[GUNNER] == None || !Crew[GUNNER].IsA( 'gbxPlayerPawn' ) )
		return;

	if ( bZoomed )
	{
		MyFactory.HideFactory();
		//Crew[GUNNER].bHidden = true;

		PC = PlayerController( Crew[GUNNER].Controller );
		PC.DesiredFOV = DisplayFOV;

		PC.bBehindView = false;
	}
	else
	{
		MyFactory.ShowFactory();		
		//Crew[GUNNER].bHidden = false;

		PC = PlayerController( Crew[GUNNER].Controller );
		PC.DesiredFOV = PC.DefaultFOV;

		PC.bBehindView = true;
	}
}

//---------------------------------------------------------
//	RestrictYawAndPitch
//---------------------------------------------------------
function RestrictYawAndPitch( out Rotator ControllerRot )
{
	local int Diff;
	local bool bIsNegative, bDidSubtract;
	local int FactoryYaw, FactoryPitch;

	ControllerRot.Yaw = ControllerRot.Yaw & 65535;
	ControllerRot.Pitch = ControllerRot.Pitch & 65535;
	FactoryYaw = MyFactory.Rotation.Yaw & 65535;
	FactoryPitch = MyFactory.Rotation.Pitch & 65535;

	Diff = ControllerRot.Yaw - FactoryYaw;

	bIsNegative = (Diff < 0);

	Diff = abs(Diff);

	if ( Diff > 32768)
	{
		Diff = 65536 - Diff;
		bDidSubtract = true;
	}
	else
	{
		bDidSubtract = false;
	}

	if ( Diff > HorizFieldUU )
	{
		if ( ( bDidSubtract && bIsNegative ) || ( !bDidSubtract && !bIsNegative ) )
		{
			// ControllerRot is to the RIGHT of MyFactory.
			ControllerRot.Yaw = (FactoryYaw + HorizFieldUU) & 65535;
		}
		else
		{
			// ControllerRot is to the LEFT of MyFactory.
			ControllerRot.Yaw = (FactoryYaw - HorizFieldUU) & 65535;
		}
	}

	// Pitch.
	Diff = ControllerRot.Pitch - FactoryPitch;
	bIsNegative = ( Diff < 0 );
	Diff = abs( Diff );

	if ( Diff > 32768 )
	{
		Diff = 65536 - Diff;
		bDidSubtract = true;
	}
	else
	{
		bDidSubtract = false;
	}

	if ( Diff > VertFieldUU )
	{
		if ( ( bDidSubtract && bIsNegative ) || ( !bDidSubtract && !bIsNegative ) )
			ControllerRot.Pitch = FactoryPitch + VertFieldUU;
		else
			ControllerRot.Pitch = FactoryPitch - VertFieldUU;
	}
}

//---------------------------------------------------------
//	RestrictPitchOnly
//---------------------------------------------------------
function RestrictPitchOnly( out Rotator ControllerRot )
{
	local int Diff;
	local bool bIsNegative, bDidSubtract;
	local int FactoryYaw, FactoryPitch;

	ControllerRot.Yaw = ControllerRot.Yaw & 65535;
	ControllerRot.Pitch = ControllerRot.Pitch & 65535;
	FactoryYaw = MyFactory.Rotation.Yaw & 65535;
	FactoryPitch = MyFactory.Rotation.Pitch & 65535;

	// Pitch.
	Diff = ControllerRot.Pitch - FactoryPitch;
	bIsNegative = ( Diff < 0 );
	Diff = abs( Diff );

	if ( Diff > 32768 )
	{
		Diff = 65536 - Diff;
		bDidSubtract = true;
	}

	if ( Diff > VertFieldUU )
	{
		if ( ( bDidSubtract && bIsNegative ) || ( !bDidSubtract && !bIsNegative ) )
			ControllerRot.Pitch = FactoryPitch + VertFieldUU;
		else
			ControllerRot.Pitch = FactoryPitch - VertFieldUU;
	}
}

//---------------------------------------------------------
//	CalcThirdPersonView
//---------------------------------------------------------
function CalcThirdPersonView( gbxPawn thePawn, out actor ViewActor, out vector CameraLocation, out rotator CameraRotation )
{
	local Vector X,Y,Z;
	local Rotator ControllerRot;
	local float T;

	ViewActor = thePawn;

	CameraLocation = thePawn.Location;

	if ( bFirstPersonZoom )
	{
		CameraOffset = CameraOffsetZoomed;
	}
	else
	if ( bIsMounting )
	{
		// Player is mounting turret.  Zoom out.
		T = FClamp( ( Level.TimeSeconds - MountStartStamp ) * CameraMountSpeed, 0, 1 );
		CameraOffset = CameraStartOffset + T*( CameraMountedOffset - CameraStartOffset );
	}
	else
	if ( bIsDismounting )
	{
		// Player is dismounting turret.  Zoom in.
		T = FClamp( ( Level.TimeSeconds - MountStartStamp ) * CameraDismountSpeed, 0, 1 );
		CameraOffset = CameraMountedOffset + T*( CameraDismountedOffset - CameraMountedOffset );
	}
	else		
	{
		CameraOffset = CameraMountedOffset;
	}

	// Restrict the yaw and pitch to the cone of fire.
	if ( Crew[GUNNER] != None )
	{
		ControllerRot = Crew[GUNNER].Controller.Rotation;

		// Yaw.
		if ( !bFreeCamera )
		{
			RestrictYawAndPitch( ControllerRot );
		}
		else
		{
			//ControllerRot.Yaw = ControllerRot.Yaw & 65535;
			RestrictPitchOnly( ControllerRot );
		}

		Crew[GUNNER].Controller.SetRotation( ControllerRot );
	}

	if ( !bIsMounting && !bIsDismounting )
	{
		CameraRotation = ControllerRot;
	}

	GetAxes( CameraRotation, X,Y,Z );
	CameraLocation = CameraLocation - CameraOffset.X*X + CameraOffset.Y*Y + CameraOffset.Z*Z;

	CameraRotation.Pitch -= CameraPitchUU;
}

//---------------------------------------------------------
//	CalcFirstPersonView
//---------------------------------------------------------
function CalcFirstPersonView( gbxPawn thePawn, out actor ViewActor, out vector CameraLocation, out rotator CameraRotation )
{
	local Vector X,Y,Z;
	local Rotator ControllerRot;

	ViewActor = Self;

	CameraOffset.X = CameraOffsetZoomed.X;
	CameraOffset.Y = CameraOffsetZoomed.Y;
	CameraOffset.Z = CameraOffsetZoomed.Z;

	GetAxes( Self.Rotation, X,Y,Z );
	CameraLocation = Self.Location + CameraOffset.X*X + CameraOffset.Y*Y + CameraOffset.Z*Z;

	// Restrict the yaw to the cone of fire.
	if ( Crew[GUNNER] != None )
	{
		ControllerRot = Crew[GUNNER].Controller.Rotation;

		RestrictYawAndPitch( ControllerRot );

		CameraRotation = ControllerRot;

		Crew[GUNNER].Controller.SetRotation( ControllerRot );
	}
}

//---------------------------------------------------------
//	SpecialCalcView
//---------------------------------------------------------
simulated function SpecialCalcView( gbxPawn thePawn, out actor ViewActor, out vector CameraLocation, out rotator CameraRotation )
{
	if ( bFirstPersonZoom )
		CalcFirstPersonView( thePawn, ViewActor, CameraLocation, CameraRotation );
	else
		CalcThirdPersonView( thePawn, ViewActor, CameraLocation, CameraRotation );
}

//---------------------------------------------------------
//	ClientStartFire
//---------------------------------------------------------
// Needed to override this because Owner is different for this weapon than most other weapons.
simulated event ClientStartFire(int Mode)
{
	if (!Crew[GUNNER].Controller.CanFire() || bIsDismounting )
        return;

    if (Role < ROLE_Authority)
    {
        if (StartFire(Mode))
        {
            ServerStartFire(Mode);
        }
    }
    else
    {
        StartFire(Mode);
    }
}

//---------------------------------------------------------
//	GetFireRotation
//---------------------------------------------------------
function Rotator GetFireRotation()
{
	return Rotation;
}

//---------------------------------------------------------
//	GetViewOrigin
//---------------------------------------------------------
function Vector GetViewOrigin()
{
	if ( Crew[GUNNER] != None )
		return Crew[GUNNER].Location;
}

//---------------------------------------------------------
//	AdjustAimNew
//---------------------------------------------------------
// Used only with player pawns; AI pawns use the AdjustAimNew() in FiringController.
function Rotator AdjustAimSpecial( Ammunition Ammo, Vector ProjStart, Rotator AimRotator, int WeaponAimError )
{
	local float FinalErrorMax;

	FinalErrorMax = WeaponAimError;

	// Yaw.
	if ( Rand(2) == 0 )
		AimRotator.Yaw += FRand() * FinalErrorMax;
	else
		AimRotator.Yaw -= FRand() * FinalErrorMax;

	// Pitch
	if ( Rand(2) == 0 )
		AimRotator.Pitch += FRand() * FinalErrorMax;
	else
		AimRotator.Pitch -= FRand() * FinalErrorMax;

	return AimRotator;
}

//---------------------------------------------------------
//	CandidateAcquired
//---------------------------------------------------------
function CandidateAcquired( gbxPawn Candidate )
{
	local int x;

	// Here's how it works: add this candidate only if:
	//	1) The pawn is an AI-controlled pawn.
	//	2) The list is currently empty;
	//  3) The first candidate in the list is on this candidate's team.

	if ( Candidate.IsA( 'gbxPlayerPawn' ) )
		return;

	if ( CandidateList.Length == 0 || CandidateList[0].SameTeamAs( Candidate ) )
	{
		for( x = 0; x < CandidateList.Length; ++x )
		{
			if ( CandidateList[x] == Candidate )
				return;
		}

		// Add.
		CandidateList[CandidateList.Length] = Candidate;
	}
}

//---------------------------------------------------------
//	CandidateLost
//---------------------------------------------------------
function CandidateLost( gbxPawn Candidate )
{
	local int x;

	for( x = 0; x < CandidateList.Length; ++x )
	{
		if ( CandidateList[x] == Candidate )
		{
			CandidateList.Remove( x, 1 );
			return;
		}
	}
}

//---------------------------------------------------------
//	NeverAllowShotProtectionFor
//---------------------------------------------------------
function bool NeverAllowShotProtectionFor( class<DamageType> DamageType )
{
	return (
		DamageType == class'DamageGammonBomb' || 
		DamageType == class'DamageTankCannon' ||
		DamageType == class'DamageDEPanzerfaust' ||
		DamageType == class'DamageUSBazooka' ||
		DamageType == class'DamageGrenade' 
		);
}

//---------------------------------------------------------
//	RejectDamageRequest
//---------------------------------------------------------
function bool RejectDamageRequest( Pawn Shooter, Pawn Victim, class<DamageType> DamageType )
{
	local Vector MyFacingVect, ToShooterVect;
	local float DistToShooter;

	if ( !bUseShotProtection || Level.bWeaponsAreBFG )
		return false;

	// No rejection for heavy explosives.
	if ( NeverAllowShotProtectionFor( DamageType ) )
		return false;

	if ( !PawnIsInCrew( Victim ) || Victim.IsHumanControlled() )
		return false;

	MyFacingVect = Vector( MyFactory.Rotation );
	ToShooterVect = Shooter.Location - Location;

	MyFacingVect.Z = 0;
	ToShooterVect.Z = 0;

	DistToShooter = VSizeIgnoreZ( ToShooterVect );

	MyFacingVect = Normal( MyFacingVect );
	ToShooterVect = Normal( ToShooterVect );

	if ( MyFacingVect dot ToShooterVect < ShotProtectionCosTheta )	// 45 degrees
		return false;

	if ( DistToShooter  > NoShotProtectionDist )
		return true;
	else
		return false;
}

//---------------------------------------------------------
//	CanSpawnShellCasing
//---------------------------------------------------------
function bool CanSpawnShellCasing()
{
	return ( Crew[GUNNER].IsHumanControlled() && !bFirstPersonZoom );
}

//---------------------------------------------------------
//	ShouldPlayShellSound
//---------------------------------------------------------
function bool ShouldPlayFirstPersonShellSound()
{
	return ( Crew[GUNNER].IsHumanControlled() && bFirstPersonZoom );
}

//---------------------------------------------------------
//	IsOnCrew
//---------------------------------------------------------
function bool IsOnCrew( gbxPawn gbxP )
{
	local int x;

	for( x = 0; x < 3; ++x )
		if ( Crew[x] == gbxP )
			return true;
	return false;
}

//---------------------------------------------------------
//	GetAttachment
//---------------------------------------------------------
function AttachmentDEMG42_ GetAttachment()
{
	return AttachmentDEMG42_( ThirdPersonActor );
}

//---------------------------------------------------------
//	PlayZoomIn
//---------------------------------------------------------
simulated function PlayZoomIn()
{
	if ( !bIsMounting && !bIsDismounting )
		SetFirstPersonZoom( true );
}

//---------------------------------------------------------
//	PlayZoomOut
//---------------------------------------------------------
simulated function PlayZoomOut()
{
	if ( !bIsMounting && !bIsDismounting )
		SetFirstPersonZoom( false );
}

//---------------------------------------------------------
//	IsZoomed
//---------------------------------------------------------
event bool IsZoomed()
{
	return bFirstPersonZoom;
}

//---------------------------------------------------------
//	CanZoom
//---------------------------------------------------------
simulated function bool CanZoom()
{
	return true;
}

//---------------------------------------------------------
//	GetBaseVector
//---------------------------------------------------------
function Vector GetBaseVector()
{
	return BaseVector;
}

//---------------------------------------------------------
//	NotifyCrewMemberDied
//---------------------------------------------------------
function NotifyCrewMemberDied( gbxPawn gbxP )
{
	CandidateLost( gbxP );

	if ( gbxP == Crew[GUNNER] )
	{
		StopFiringWeapon();
		GunnerDied( gbxP );
		
		NextCrewCheckTime = 0.0;	// Force the weapon to look for a new gunner during the next tick.		
	}
}

//---------------------------------------------------------
//	NotifyForceDismount
//---------------------------------------------------------
function NotifyForceDismount( optional bool bDoNothingIfHumanControlled )
{
	local int x;
	for (x=0; x<3; ++x)
		if ( Crew[x] != None )
		{
			if ( Crew[x].Controller.IsA( 'gbxAIController' ) )
			{
				gbxAIController( Crew[x].Controller ).BreakOutJustMe();
			}
			else
			if ( Crew[x].Controller.bIsHumanPlayer && !bDoNothingIfHumanControlled )
			{
				Crew[GUNNER].DismountTurretPlayer(true);
			}
		}
}

//---------------------------------------------------------
//	PostRender
//---------------------------------------------------------
function PostRender( Canvas TheCanvas )
{
	local gbxMuzzleFlash MuzFlash;

	if ( bFirstPersonZoom )
	{		
		MuzFlash = gbxMuzzleFlash( FireDEMG42_( FireMode[0] ).GetMuzzleFlash() );
		if ( MuzFlash != None )
		{
			MuzFlash.bHidden = false;
			MuzFlash.SetLocation( GetMuzzleLocationWorld() );
			MuzFlash.SetRotation( Rotation );
			TheCanvas.DrawActor( MuzFlash, 50 );
		}
		TheCanvas.DrawActor(self, DisplayFOV);
	}	

	CalcOffsetWeaponCollision();
}

function bool AlwaysAutoReload()
{
	return true;
}

event bool TargetIsInMyConeOfFire( gbxPawn aTarget, optional bool bUseNarrowHysteresis )
{
	return PointIsInMyConeOfFire( aTarget.Location, bUseNarrowHysteresis );
}

function bool PointIsInMyConeOfFire( Vector TargetLoc, optional bool bUseNarrowHysteresis ) 
{ 
	local Vector ToTarget, BaseVectorAdjusted;

	// Quick dot-product check first to see if the enemy is behind this weapon.
	ToTarget = TargetLoc - Self.Location;
	ToTarget.Z = 0;
	ToTarget = Normal( ToTarget );
	BaseVectorAdjusted = BaseVector;
	BaseVectorAdjusted.Z = 0;
	BaseVectorAdjusted = Normal( BaseVectorAdjusted );

	if ( bUseNarrowHysteresis )
		return ( BaseVectorAdjusted dot ToTarget >= ( HorizCosTheta + 0.03f ) );
	else
		return ( BaseVectorAdjusted dot ToTarget >= ( HorizCosTheta - 0.1f ) );
}

//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
	DrawType=DT_Mesh
	bHidden=true
	DisplayFOV=+35.0
	bAcceptsProjectors=false
	DrawScale=1.0
	ItemName="German MG42 Machinegun"
	Physics=PHYS_None

	MyMountAction=Mount_MountMG42Gunner
	MyDismountAction=Mount_DismountMG42Gunner
	PlayersJob=Job_MG42_Gunner

	FireModeClass(0)=FireDEMG42_
	FireModeClass(1)=FireDEMG42_
	AttachmentClass=class'AttachmentDEMG42_'

	DefaultAmmoCount(0)=400	

	// Nine-point blending animations.
	PlayerMountAnim=PLAYER_mg42_mount
	PlayerDismountAnim=PLAYER_mg42_dismount

	PawnForwardDownAnim=mg42_forward_down
	PawnForwardLevelAnim=mg42_forward_level
	PawnForwardUpAnim=mg42_forward_up
	PawnLeftDownAnim=mg42_left_down
	PawnLeftLevelAnim=mg42_left_level
	PawnLeftUpAnim=mg42_left_up
	PawnRightDownAnim=mg42_right_down
	PawnRightLevelAnim=mg42_right_level
	PawnRightUpAnim=mg42_right_up

	HorizCosTheta=0.7071
	VertCosTheta=0.2588

	MaxRotSpeed=11.0

	GunnerOffset=(X=0,Y=0,Z=0)

	GUNNER=0

	Crew(0)=None
	Crew(1)=None
	Crew(2)=None
	Claimants(0)=None
	Claimants(1)=None
	Claimants(2)=None

	CameraMountSpeed=2.0
	CameraDismountSpeed=1.3
	CameraStartOffset=(X=30.0,Y=0.0,Z=150.0)
	//CameraMountedOffset=(X=90,Y=0.1,Z=100.0)
	CameraMountedOffset=(X=175,Y=0.1,Z=100.0)
	CameraDismountedOffset=(X=25.0,Y=0.0,Z=85.0)

	CameraOffsetZoomed=(X=-35.8,Y=0.05,Z=0.86)

	bUseShotProtection=true
	NoShotProtectionDist=1000.0

	PauseTime_Low=(Min=0.15,Max=1.0)
	PauseTime_High=(Min=3.0,Max=5.0)

	HorizFieldUU=8192
	VertFieldUU=2731
	CameraPitchUU=2000

	ClientState=WS_Hidden

	AmmoClipSize=400	

	bFreeCamera=true

	BreatheProfileClass=class'gbxSupportedBreatheProfile'

	WeaponName = WN_DEMG42
	AmmoName = AM_Nothing

	CrosshairDrawFreq=0.01

	bOpaqueForSituationalAwarenessView=true
	bDontDismountUnlessFlanked=false
	bDontFleeFromGrenades=false

	bAlwaysRelevant=true
}
class WeapDEMortar extends TurretWeapon;

//---------------------------------------------------------
//	Variables
//---------------------------------------------------------
var bool					bCrewHasBeenDrafted, bReadyToShoot;
var bool					bDontRecruit;
var bool					bWaitingOnShell, bWaitingOnAnim;
var bool					bDismountWhenNearbyImpacts;
var bool					bDismountWhenNearbyWhizzes;
var bool					bFireRateIndependent;
var Name					GunnerToDraft, LeftLoaderToDraft, RightLoaderToDraft;
var Name					MountEvent, DismountEvent, StopFiringEvent;
var gbxPawn					Gunner, LeftLoader, RightLoader;
var Vector					GunnerOffset, LeftLoaderOffset, RightLoaderOffset;
var Vector					MuzzleLocation, MuzzleOffset;
var Vector					TargetLocation;
var Rotator					MuzzleRotation;
var Actor					Target;
var EMortarFire				FireType;
var int						TotalShots, NumShotsSoFar;
var int						MaxCrewSize, CurCrewSize;
var float					TimeBetweenShots;
var float					OffsetFromTarget;
var float					LastCheckedProximityTime, CheckProximityInterval;
var float					NextCrewCheckTime;
var float					CrewCheckInterval;
var float					NoticeBulletImpactsDist;		// GBX:naj - Fixes bug 3876
const QUEUE_FIRE_PRIORITY	= 96;

//---------------------------------------------------------
//	PostBeginPlay
//---------------------------------------------------------
function PostNetBeginPlay()
{
	local Vector X,Y,Z;

	Super.PostNetBeginPlay();
	
	SetStaticMesh(StaticMesh(DynamicLoadObject("s_military_de.Weapon.mortar", class'StaticMesh')));
	
	GetAxes( Rotation, X,Y,Z );
	MuzzleLocation = Self.Location + MuzzleOffset.X*X + MuzzleOffset.Y*Y + MuzzleOffset.Z*Z;
	MuzzleRotation.Yaw = Rotation.Yaw;
	MuzzleRotation.Pitch = 13000;

	GiveAmmo(0);
}

//---------------------------------------------------------
//	IsMortar
//---------------------------------------------------------
function bool IsMortar() 
{ 
	return true; 
}

//---------------------------------------------------------
//	FaceRotation
//---------------------------------------------------------
function FaceRotation( Rotator Rot ) {}

//---------------------------------------------------------
//	PawnIsInCrew
//---------------------------------------------------------
function bool PawnIsInCrew( Pawn P ) 
{ 
	return P == Gunner || P == LeftLoader || P == RightLoader;
}

//---------------------------------------------------------
//	DraftCrew
//---------------------------------------------------------
function DraftCrew()
{
	local gbxPawn aDraftee;
	local class<gbxAIController> MindClass;

	// Ensure that no more than the maximum number of crew members is drafted.
	if ( MaxCrewSize < 3 )
		RightLoaderToDraft = '';
	if ( MaxCrewSize < 2 )
		LeftLoaderToDraft = '';

	ForEach DynamicActors(class'gbxPawn', aDraftee )
	{		
		if ( Gunner == None && aDraftee.Tag == GunnerToDraft )
		{
			Gunner = aDraftee;
			MindClass = class<gbxAIController>( DynamicLoadObject( "gbxAI.MindMortarGunner", class'Class' ) );
			Gunner.CrewTurret( Self, MindClass, Job_Mortar_Gunner );			
			CurCrewSize++;
		}
		else if ( LeftLoader == None && aDraftee.Tag == LeftLoaderToDraft )
		{
			LeftLoader = aDraftee;
			MindClass = class<gbxAIController>( DynamicLoadObject( "gbxAI.MindMortarLoader", class'Class' ) );
			LeftLoader.CrewTurret( Self, MindClass, Job_Mortar_LeftLoader );
			CurCrewSize++;
		}
		else if ( RightLoader == None && aDraftee.Tag == RightLoaderToDraft )
		{
			RightLoader = aDraftee;
			MindClass = class<gbxAIController>( DynamicLoadObject( "gbxAI.MindMortarLoader", class'Class' ) );
			RightLoader.CrewTurret( Self, MindClass, Job_Mortar_RightLoader );
			CurCrewSize++;
		}
	}

	if ( CurCrewSize >= MaxCrewSize )
	{
		bCrewHasBeenDrafted = true;
		return;
	}
}

// Keep spawning the crew member upwards until you find a clear spot; then use gravity to drop him down in place.
function SetPawnOnMountLocation( gbxPawn CrewMember, Vector IdealOffset )
{
	local Vector LocalX, LocalY, LocalZ;
	GetAxes( Rotation, LocalX, LocalY, LocalZ );

	if ( CrewMember.SetLocation( Self.Location + IdealOffset.X*LocalX + IdealOffset.Y*LocalY + IdealOffset.Z*LocalZ ) )
		return;
	
	IdealOffset.Z += 10.0;

	if ( CrewMember.SetLocation( Self.Location + IdealOffset.X*LocalX + IdealOffset.Y*LocalY + IdealOffset.Z*LocalZ ) )
		return;

	IdealOffset.Z += 10.0;

	if ( CrewMember.SetLocation( Self.Location + IdealOffset.X*LocalX + IdealOffset.Y*LocalY + IdealOffset.Z*LocalZ ) )
		return;

	IdealOffset.Z += 10.0;

	if ( CrewMember.SetLocation( Self.Location + IdealOffset.X*LocalX + IdealOffset.Y*LocalY + IdealOffset.Z*LocalZ ) )
		return;

	IdealOffset.Z += 20.0;

	if ( CrewMember.SetLocation( Self.Location + IdealOffset.X*LocalX + IdealOffset.Y*LocalY + IdealOffset.Z*LocalZ ) )
		return;

	IdealOffset.Z += 50.0;

	if ( CrewMember.SetLocation( Self.Location + IdealOffset.X*LocalX + IdealOffset.Y*LocalY + IdealOffset.Z*LocalZ ) )
		return;

	IdealOffset.Z += 100.0;

	CrewMember.SetLocation( Self.Location + IdealOffset.X*LocalX + IdealOffset.Y*LocalY + IdealOffset.Z*LocalZ );
}

//---------------------------------------------------------
//	CompleteMount
//---------------------------------------------------------
function CompleteMount( gbxPawn gbxP )
{	
	if ( gbxP == Gunner )
	{
		SetPawnOnMountLocation( Gunner, GunnerOffset );
		Gunner.SetRotation( Self.Rotation );
		LeftLoader.SetPhysics( PHYS_Falling );
		Gunner.StartGoingToCrouch( true );
		Gunner.FlushAnimQueueChannel( 0,, true );
		Gunner.LoadMountAnimations( Mount_MountMortarGunner );
		Gunner.bDoTorsoTwist = false;
		Gunner.bNoTurnBody = true;
		Gunner.SetWeapon( Self );

		Instigator = Gunner;
		if ( Ammo[0] != None )
			Ammo[0].Instigator = Instigator;
		if ( FireMode[0] != None )
			FireMode[0].Instigator = Instigator;
		if ( ThirdPersonActor != None )
			ThirdPersonActor.Instigator = Instigator;

		// Send out a mount event to anyone who may be interested.
		TriggerEvent( MountEvent, Self, Gunner );

	}
	else if ( gbxP == LeftLoader )
	{
		SetPawnOnMountLocation( LeftLoader, LeftLoaderOffset );
		LeftLoader.SetRotation( Self.Rotation );
		LeftLoader.SetPhysics( PHYS_Falling );
		LeftLoader.StartGoingToCrouch( true );
		LeftLoader.FlushAnimQueueChannel( 0,, true );
		LeftLoader.LoadMountAnimations( Mount_MountMortarLoader );
		LeftLoader.bDoTorsoTwist = false;
		LeftLoader.bNoTurnBody = true;
		LeftLoader.SetWeapon( None );
	}
	else if ( gbxP == RightLoader )
	{	
		SetPawnOnMountLocation( RightLoader, RightLoaderOffset );
		RightLoader.SetRotation( Self.Rotation );
		LeftLoader.SetPhysics( PHYS_Falling );
		RightLoader.StartGoingToCrouch( true );
		RightLoader.FlushAnimQueueChannel( 0,, true );
		RightLoader.LoadMountAnimations( Mount_MountMortarLoader );
		RightLoader.bDoTorsoTwist = false;
		RightLoader.bNoTurnBody = true;
		RightLoader.SetWeapon( None );
	}	
	
	gbxP.PlayWaiting();
}

//---------------------------------------------------------
//	Tick
//---------------------------------------------------------
function Tick( float DeltaTime )
{	
	Super.Tick( DeltaTime );

	// Make sure that this weapon is manned.
	if ( !bDontRecruit && !bCrewHasBeenDrafted && Level.TimeSeconds > NextCrewCheckTime )
	{
		NextCrewCheckTime = Level.TimeSeconds + CrewCheckInterval;
		DraftCrew();		
	}	

	if ( Gunner == None )
		return;
}

//---------------------------------------------------------
//	ForceCrewDismount
//---------------------------------------------------------
function ForceCrewDismount( optional Pawn InstigatedBy )
{
	bDontRecruit = true;

	if ( Gunner != None )
	{
		StopFiringWeapon();
		gbxAIController( Gunner.Controller ).BreakOutJustMe( InstigatedBy );
	}

	if ( LeftLoader != None )
	{
		gbxAIController( LeftLoader.Controller ).BreakOutJustMe( InstigatedBy );
	}	

	if ( RightLoader != None )
	{
		gbxAIController( RightLoader.Controller ).BreakOutJustMe( InstigatedBy );
	}
}


//---------------------------------------------------------
//	SetFireParameters
//---------------------------------------------------------
function SetFireParameters( Actor NewTarget, EMortarFire NewFireType, int NewNumShots, float NewTimeBetweenShots, float NewOffsetFromTarget )
{
	Target = NewTarget;
	FireType = NewFireType;
	TotalShots = NewNumShots;
	ClipAmt = NewNumShots;	
	TimeBetweenShots = NewTimeBetweenShots;
	OffsetFromTarget = NewOffsetFromTarget;	
	NumShotsSoFar = 0;
}

//---------------------------------------------------------
//	ClientStartFire
//---------------------------------------------------------
// Needed to override this because Owner is different for this weapon than most other weapons.
simulated event ClientStartFire(int Mode)
{
    if (!Gunner.Controller.CanFire())
        return;

    if (Role < ROLE_Authority)
    {
        if (StartFire(Mode))
        {
            ServerStartFire(Mode);
        }
    }
    else
    {
        StartFire(Mode);
    }
}

//---------------------------------------------------------
//	DoFireEffect
//---------------------------------------------------------
function DoFireEffect() {}

//---------------------------------------------------------
//	PlayFiring
//---------------------------------------------------------
simulated function PlayFiring()
{	
	if ( bWaitingOnShell || bWaitingOnAnim )
	{
		return;
	}
	
	if ( !bFireRateIndependent )
	{
		bWaitingOnShell = true;
	}

	if ( Gunner != None )
	{
		Gunner.AddAnimToQueue( 'de_mortar_gunner_fire', QUEUE_FIRE_PRIORITY, true, false,,, 0.15 );
	}

	if ( LeftLoader != None && !bFireRateIndependent )
	{
		LeftLoader.AddAnimToQueue( 'de_mortar_loader_1_fire', QUEUE_FIRE_PRIORITY, true, false,,, 0.15, class'MortarCallback' );
		bWaitingOnAnim = true;
	}
	else
	{
		// No left loader, so we can't rely on an animation notify to launch the shell.
		NotifyReadyToLaunch();
	}

	if ( RightLoader != None && !bFireRateIndependent )
	{
		RightLoader.AddAnimToQueue( 'de_mortar_loader_2_fire', QUEUE_FIRE_PRIORITY, true, false,,, 0.15 );
	}
}

//---------------------------------------------------------
//	NotifyForceDismount
//---------------------------------------------------------
function NotifyForceDismount( optional bool bDoNothingIfHumanControlled )
{
	ForceCrewDismount();
}

//---------------------------------------------------------
//	NotifyReadyToLaunch
//---------------------------------------------------------
function NotifyReadyToLaunch()
{
	log("NAJ**** NotifyReadyToLaunch; setting bWaitingOnShell to false.", 'naj' );
	bWaitingOnShell = false;

	if ( NumShotsSoFar == 0 )
	{
		TargetLocation = Target.Location;
	}
	if (Gunner.Controller.GetStateName() == 'Dismounting' )
	{
		StopFiringWeapon();
		return;
	}
	Spawn( class'MuzzleFlashMortar', Self,, MuzzleLocation, MuzzleRotation );
	NumShotsSoFar++;	
	FireDEMortar( FireMode[0] ).LaunchMortar( FireType, TotalShots, NumShotsSoFar, OffsetFromTarget );	
	StopFiringWeapon();	

	if ( NumShotsSoFar == TotalShots )
	{
		TriggerEvent( StopFiringEvent, Self, Gunner );
	}	
}

//---------------------------------------------------------
//	NotifyLoadShellAnimEnd
//---------------------------------------------------------
// Safeguard in case the anim notify didn't fire.
function NotifyLoadShellAnimEnd()
{
	log("NAJ**** NotifyLoadShellAnimEnd; bWaitingOnShell=="$bWaitingOnShell$" ; setting bWaitingOnAnim to false.", 'naj' );

	if ( bWaitingOnShell )
		NotifyReadyToLaunch();

	bWaitingOnAnim = false;
}

//---------------------------------------------------------
//	ReadyToShoot
//---------------------------------------------------------
function bool ReadyToShoot()
{
	log("NAJ**** ReadyToShoot: bWaitingOnShell="$bWaitingOnShell$" ; bWaitingOnAnim="$bWaitingOnAnim, 'naj' );
	return !bWaitingOnShell && !bWaitingOnAnim && ( ClipAmt > 0 );
}

//---------------------------------------------------------
//	IndependentFireMode
//---------------------------------------------------------
function bool IndependentFireMode()
{
	return bFireRateIndependent;
}

//---------------------------------------------------------
//	CompleteDismount
//---------------------------------------------------------
function CompleteDismount( gbxPawn gbxP )
{
	if ( gbxP == Gunner )
	{
		Instigator = None;
		Ammo[0].Instigator = None;
		FireMode[0].Instigator = None;

		Gunner = None;

		// Send out a dismount event to anyone who may be interested.
		TriggerEvent( DismountEvent, Self, gbxP );		
	}	
	else if ( gbxP == LeftLoader )
	{
		LeftLoader = None;
	}
	else if ( gbxP == RightLoader )
	{
		RightLoader = None;
	}

	//gbxP.Weapon = None;  // hack so SetWeapon() will call ChangedWeapon() - jlb
	//gbxP.SetWeapon( gbxP.LastWeapon );
}

//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
	DrawType=DT_StaticMesh
//	StaticMesh=StaticMesh's_military_de.Weapon.mortar'
	StaticMesh=None
	Texture=Texture'Engine.S_Weapon'

	FireModeClass(0)=FireDEMortar
	FireModeClass(1)=FireDEMortar

	Physics=PHYS_None
	bStatic=false
	bCollideActors=true
	bBlockKarma=true
	bBlockActors=true
	bBlockPlayers=true
	bCollideWorld=false
	bBlockZeroExtentTraces=true
	bBlockNonZeroExtentTraces=true	

	GunnerOffset=(x=-92.0,y=-0.787,z=0)
	LeftLoaderOffset=(x=-12.625,y=82.999,z=0)
	RightLoaderOffset=(x=-13.032,y=-77.398,z=0)
	MuzzleOffset=(x=25,y=0,z=100)

	ClientState=WS_Hidden

	AmmoClipSize=1

	EnemyTooCloseDist=1500.0
	CrewCheckInterval=3.0
	bReadyToShoot=true

	BreatheProfileClass=class'gbxSupportedBreatheProfile'

	bDamagesVehicles=true

	bOpaqueForSituationalAwarenessView=true
}//=============================================================================
// WeapDEMP40_
//=============================================================================
class WeapDEMP40_ extends WargameWeapon
    config(user);

simulated function LoadWeaponMesh()
{
	Mesh = Mesh( DynamicLoadObject( "k_view_weapons.view_mp40", class'Mesh' ) );
	m_NormalViewMesh = Mesh( DynamicLoadObject( "k_view_weapons.view_mp40", class'Mesh' ) );
	m_ZoomViewMesh = Mesh( DynamicLoadObject( "k_view_weapons.view_mp40_crosshair", class'Mesh' ) );
	LinkMesh( Mesh );
	Super.LoadWeaponMesh();
}

function byte BestMode()
{
	return 0;
}

defaultproperties
{
    ItemName="German Machine Pistol 40"

    FireModeClass(0)=FireDEMP40_
    FireModeClass(1)=FireSecondaryItem
    FireModeClass(2)=FireMelee
    InventoryGroup=2
//	Mesh=Mesh'k_view_weapons.view_mp40'
//	m_NormalViewMesh=Mesh'k_view_weapons.view_mp40'
//	m_ZoomViewMesh=Mesh'k_view_weapons.view_mp40_crosshair'
	m_nCharacterBodyIdx=4
    BobDamping=0.5
    PickupClass=class'PickupWeapDEMP40_'
    EffectOffset=(X=100.0,Y=25.0,Z=-10.0)
	DisplayFOV=+50.0
    AttachmentClass=class'AttachmentDEMP40_'

    DrawScale=1.0
	PlayerViewOffset=(X=20.000,Y=0.000000,Z=-0.50000)
    SelectSound=None

	AIRating=+0.4
    CurrentRating=0.4

	// This icon no longer exists.
	//Icon=material'WG_HUD.HUD.wpn_garand'

//	m_aClipIcon=material'WG_HUD.HUD.clip_garand'
//	m_flBulletHeight=18
//	m_flClipHeight=128
//	m_flClipWidth=128
//	m_fClipFront=true
//	m_aFrontBulletIcon=material't_interface_mb.HUD.ammo_45cal'
//	m_aBackBulletIcon=material'WG_HUD.HUD.ammo_bullet_bck'
	m_nBulletIconTextureX=232
	m_nBulletIconTextureY=229
	m_nClipIconTextureX=206
	m_nClipIconTextureY=229

	m_eWeaponType=WeaponPrimary
	MyMeleeDamageType=class'DamageUSGunButtMelee'

	DefaultAmmoCount(0)=224

	ZoomInAnim=aim_up
	ZoomOutAnim=aim_down
	SelectAnim=deploy
	PutDownAnim=holster
	IdleAnim(0)=idle_01
	IdleAnim(1)=idle_02
	IdleAnim(2)=idle_03

	WeaponBoneName=rifle_hold

	ZoomFovMod=17.0000

	m_flPauseTimeExposed=0.7

	AmmoClipSize=32

	m_flEncumberance=1.0
	m_fCanSprint=true
	m_bIsAutomatic=true

	Desirability=1.5

	BreatheProfileClass=class'gbxMediumBreatheProfile'
	
	nIconX=281
	nIconY=0
	nIconW=31
	nIconH=92

	DEPawnPackGoreClass(0)=class'gbxInventory.ConscriptMP40GoreSetup'
	DEPawnPackGoreClass(1)=class'gbxInventory.InfantryMP40GoreSetup'
	DEPawnPackGoreClass(2)=class'gbxInventory.ParaMP40GoreSetup'
	DEPawnPackGoreClass(3)=class'gbxInventory.PanzerMP40GoreSetup'

	WeaponName = WN_DEMP40
	AmmoName = AM_Nothing
}
//=============================================================================
// WeapDEP38_
//=============================================================================
class WeapDEP38_ extends WargameWeapon
    config(user);

simulated function LoadWeaponMesh()
{
	Mesh = Mesh( DynamicLoadObject( "k_view_weapons.view_p38", class'Mesh' ) );
	m_NormalViewMesh = Mesh( DynamicLoadObject( "k_view_weapons.view_p38", class'Mesh' ) );
	m_ZoomViewMesh = Mesh( DynamicLoadObject( "k_view_weapons.view_p38_crosshair", class'Mesh' ) );
	WeaponSkinOverride=Texture( DynamicLoadObject( "T_View_model_de.View_weapons.view_p38", class'Texture' ) );
	LinkMesh( Mesh );
	Super.LoadWeaponMesh();
}

function byte BestMode()
{
	return 0;
}

defaultproperties
{
    ItemName="German P38 Pistol"

    FireModeClass(0)=FireDEP38_
    FireModeClass(1)=FireSecondaryItem
    FireModeClass(2)=FireMelee
    InventoryGroup=2
//	Mesh=Mesh'k_view_weapons.view_p38'
//	m_NormalViewMesh=Mesh'k_view_weapons.view_p38'
//	m_ZoomViewMesh=Mesh'k_view_weapons.view_p38_crosshair'
	m_nCharacterBodyIdx=2
    BobDamping=0.5
    PickupClass=class'PickupWeapDEP38_'
    EffectOffset=(X=100.0,Y=25.0,Z=-10.0)
	DisplayFOV=+50.0
    AttachmentClass=class'AttachmentDEP38_'

    DrawScale=1.0
	PlayerViewOffset=(X=20.000,Y=0.000000,Z=-0.50000)
    SelectSound=None

	AIRating=+0.4
    CurrentRating=0.4

	// This icon no longer exists.
	//Icon=material'WG_HUD.HUD.wpn_garand'

//	m_aClipIcon=material'WG_HUD.HUD.clip_garand'
//	m_flBulletHeight=18
//	m_flClipHeight=128
//	m_flClipWidth=128
//	m_fClipFront=true
//	m_aFrontBulletIcon=material't_interface_mb.HUD.ammo_45cal'
//	m_aBackBulletIcon=material'WG_HUD.HUD.ammo_bullet_bck'
	m_nBulletIconTextureX=232
	m_nBulletIconTextureY=229
	m_nClipIconTextureX=232
	m_nClipIconTextureY=177

	m_eWeaponType=WeaponPrimary
	MyMeleeDamageType=class'DamageUSGunButtMelee'

	DefaultAmmoCount(0)=96

	ZoomInAnim=aim_up
	ZoomOutAnim=aim_down
	SelectAnim=deploy
	PutDownAnim=holster
	IdleAnim(0)=idle_01
	IdleAnim(1)=idle_02
	IdleAnim(2)=idle_03

	ZoomFovMod = 10.0000

	AmmoClipSize=8

	m_flEncumberance=1.0
	m_fCanSprint=true

	WeaponBoneName=pistol_hold

	BreatheProfileClass=class'gbxPistolBreatheProfile'
	
	nIconX=217
	nIconY=0
	nIconW=33
	nIconH=51

	DEPawnPackGoreClass(0)=class'gbxInventory.ConscriptK98GoreSetup'
	DEPawnPackGoreClass(1)=class'gbxInventory.InfantryK98GoreSetup'
	DEPawnPackGoreClass(2)=class'gbxInventory.ParaSturmGoreSetup'
	DEPawnPackGoreClass(3)=class'gbxInventory.PanzerK98GoreSetup'
	
	WeaponName = WN_DEP38
	AmmoName = AM_Nothing

	m_fZoomHasHands=true
}
class WeapDEPak36_ extends TurretWeapon;

//---------------------------------------------------------
//	Variables
//---------------------------------------------------------
var bool					bDontRecruit;
var bool					bCrewHasBeenDrafted, bReloadingShell;
var bool					bTurningLeft, bTurningRight, bTurningUp, bTurningDown;
var	bool					bIsMounting, bIsDismounting;
var int						CurBaseYaw, CurGunPitch, PitchOffset;
var int						MaxYawDelta, MaxPitchDeltaDown, MaxPitchDeltaUp;
var int						MaxYawModelDelta;
var int						CameraPitchUU;
var	Name					GunBone;
var Name					GunnerToDraft, LoaderToDraft;
var Name					MountEvent;
var Name					DismountEvent;
var Name					DeathEvent;
var float					YawRotSpeed, PitchRotSpeed;
var float					MountStartStamp;
var float					CameraZoomSpeed, CameraZoomOutSpeed;
var	float					MaxFiringDist;
var float					KillZoneDist;
var float					NextCrewCheckTime;
var float					CrewCheckInterval;
var gbxPawn					Gunner, Loader;
var Vector					GunnerOffset, LoaderOffset;
var Vector					CameraStartOffset;
var Vector					CameraEndOffset;
var Vector					CameraOffset;
var Rotator					DesiredRot;
var gbxContextUseTrigger	MyTrigger;

//---------------------------------------------------------
//	PostBeginPlay
//---------------------------------------------------------
function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();

	GiveAmmo(0);

	Mesh = Mesh(DynamicLoadObject("k_prop.de_pak36", class'Mesh'));
	LinkMesh( Mesh );
	
	PlayAnim( 'Idle' );	

	CurBaseYaw = Rotation.Yaw;
	CurGunPitch = Rotation.Pitch;
}

//---------------------------------------------------------
//	IsAntiTank
//---------------------------------------------------------
function bool IsAntiTank() 
{ 
	return true; 
}

//---------------------------------------------------------
//	Landed
//---------------------------------------------------------
event Landed( vector HitLocation, vector HitNormal )
{
	local Vector LocalX, LocalY, LocalZ;
	
	// The weapon was set up above the ground and has fallen to the floor.
	// Make sure the crew is line up properly, otherwise they'll be left floating in the air.
	//
	GetAxes( Rotation, LocalX, LocalY, LocalZ );

	if ( Gunner != None )
	{
		Gunner.SetLocation( Self.Location + GunnerOffset.X*LocalX + GunnerOffset.Y*LocalY + GunnerOffset.Z*LocalZ );
	}

	if ( Loader != None )
	{
		Loader.SetLocation( Self.Location + LoaderOffset.X*LocalX + LoaderOffset.Y*LocalY + LoaderOffset.Z*LocalZ );
	}
}

//---------------------------------------------------------
//	PawnIsInCrew
//---------------------------------------------------------
function bool PawnIsInCrew( Pawn P ) 
{ 
	return P == Gunner || P == Loader;
}

//---------------------------------------------------------
//	DraftCrew
//---------------------------------------------------------
function DraftCrew()
{
	local gbxPawn aDraftee;
	local class<gbxAIController> MindClass;

	ForEach DynamicActors(class'gbxPawn', aDraftee )
	{
		if ( aDraftee.Tag == GunnerToDraft )
		{
			Gunner = aDraftee;
			MindClass = class<gbxAIController>( DynamicLoadObject( "gbxAI.MindPak36Gunner", class'Class' ) );
			Gunner.CrewTurret( Self, MindClass, Job_Pak36_Gunner );
		}
		else if ( aDraftee.Tag == LoaderToDraft )
		{
			Loader = aDraftee;
			MindClass = class<gbxAIController>( DynamicLoadObject( "gbxAI.MindPak36Loader", class'Class' ) );
			Loader.CrewTurret( Self, MindClass, Job_Pak36_Loader );
		}
	}

	if ( Gunner != None )
	{
		Gunner.MyUnit.MemberGainedMachineGun(Gunner);  //NAC:OK, he doesn't have an MG, but he's got a Frickin 36....we want suppression to behave the same way if there is no spotter.
		bCrewHasBeenDrafted = true;
        }
}

//---------------------------------------------------------
//	GetRotDelta
//---------------------------------------------------------
function GetRotDelta( int Requested, int Center, out int Diff, out int RightOfCenter )
{
	local bool bIsNegative, bDidSubtract;

	Requested = Requested & 65535;
	Center = Center & 65535;

	Diff = Requested - Center;
	bIsNegative = ( Diff < 0 );
	Diff = abs( Diff );

	if ( Diff > 32767 )
	{
		Diff = 65535 - Diff;
		bDidSubtract = true;
	}
	if ( ( bDidSubtract && !bIsNegative ) || ( !bDidSubtract && bIsNegative ) )
	{
		RightOfCenter = 0;
	}
	else if ( ( !bDidSubtract && !bIsNegative ) || ( bDidSubtract && bIsNegative ) )
	{
		RightOfCenter = 1;
	}
}

//---------------------------------------------------------
//	FaceRotation
//---------------------------------------------------------
function FaceRotation( Rotator Rot )
{
	local int Diff, RightOfCenter;

	if ( bHasBlownUp )
		return;

	Rot.Pitch = Rot.Pitch & 65535;
	Rot.Yaw = Rot.Yaw & 65535;

	// Make sure the requested pitch and yaw do not go outside the bounds of the weapon.
	GetRotDelta( Rot.Pitch, Rotation.Pitch, Diff, RightOfCenter );
	if ( RightOfCenter == 1 && Diff > MaxPitchDeltaUp )
	{
		Rot.Pitch = ( Rotation.Pitch + MaxPitchDeltaUp ) & 65535;
	}
	else if ( RightOfCenter == 0 && Diff > MaxPitchDeltaDown )
	{
		Rot.Pitch = ( Rotation.Pitch - MaxPitchDeltaDown ) & 65535;
	}	
	
	GetRotDelta( Rot.Yaw, Rotation.Yaw, Diff, RightOfCenter );
	if ( RightOfCenter == 1 && Diff > MaxYawDelta )
	{
		Rot.Yaw = ( Rotation.Yaw + MaxYawDelta ) & 65535;
	}
	else if ( RightOfCenter == 0 && Diff > MaxYawDelta )
	{
		Rot.Yaw = ( Rotation.Yaw - MaxYawDelta ) & 65535;
	}

	DesiredRot = Rot;	
	DesiredRot.Pitch -= PitchOffset;		// Because at pitch=0, the gun may not actually be pointing horizontally	

	DesiredRot.Pitch = DesiredRot.Pitch & 65535;
	DesiredRot.Yaw = DesiredRot.Yaw & 65535;
}

//---------------------------------------------------------
//	GetAdjustedRotation
//---------------------------------------------------------
function int GetAdjustedRotation( int CurPosition, int DesiredPosition, float Speed, float DeltaTime, out int bRotatingLeft )
{
	local int Diff, NewPos, Offset;
	local bool bIsNegative, bDidSubtract, bSnap;
	local float AdjustedSpeed;

	Diff = DesiredPosition - CurPosition;
	bIsNegative = ( Diff < 0 );

	Diff = abs( Diff );

	if ( Diff > 32767)
	{
		Diff = 65536 - Diff;
		bDidSubtract = true;
	}

	AdjustedSpeed = Speed;
	Offset = AdjustedSpeed*DeltaTime;
	if ( Offset >= Diff )
	{
		do
		{
			AdjustedSpeed *= 0.75;
			Offset = AdjustedSpeed*DeltaTime;
		}
		until( AdjustedSpeed < 0.25*Speed || Offset <= Diff );
		
		if ( Offset >= Diff )
		{
			bSnap = true;
		}
	}
	
	if ( ( bDidSubtract && bIsNegative ) || ( !bDidSubtract && !bIsNegative ) )
	{
		if ( bSnap )
			NewPos = DesiredPosition;
		else
			NewPos = (CurPosition + Offset ) & 65535;
		
		bRotatingLeft = 0;
	}
	else
	{
		if ( bSnap )
			NewPos = DesiredPosition;
		else
			NewPos = (CurPosition - Offset ) & 65535;

		bRotatingLeft = 1;
	}

	return NewPos;	
}

//---------------------------------------------------------
//	Tick
//---------------------------------------------------------
function Tick( float DeltaTime )
{	
	local Rotator GunRot;
	local int RotatingLeft, RotatingDown;

	Super.Tick( DeltaTime );

	if ( bHasBlownUp )
		return;

	// Make sure that this weapon is manned.
	//if ( !bCrewHasBeenDrafted )
	//{
	if ( !bDontRecruit && !bCrewHasBeenDrafted && Level.TimeSeconds > NextCrewCheckTime )
	{
		NextCrewCheckTime = Level.TimeSeconds + CrewCheckInterval;
		DraftCrew();		
	}	

	if ( Gunner == None ) 
	{
		return;
	}

	bTurningLeft = false;
	bTurningRight = false;
	bTurningUp = false;
	bTurningDown = false;

	if ( !bReloadingShell )
	{
		// Determine which direction (if any) the weapon is turning.
		if ( abs( DesiredRot.Yaw - CurBaseYaw ) > 0 )
		{		
			CurBaseYaw = GetAdjustedRotation( CurBaseYaw, DesiredRot.Yaw, YawRotSpeed, DeltaTime, RotatingLeft );		
			
			if ( RotatingLeft == 1 )
				bTurningLeft = true;
			else
				bTurningRight = true;
		}
		else
		if ( abs( DesiredRot.Pitch - CurGunPitch ) > 0 )
		{
			CurGunPitch = GetAdjustedRotation( CurGunPitch, DesiredRot.Pitch, PitchRotSpeed, DeltaTime, RotatingDown );		
			
			if ( RotatingDown == 1 )
				bTurningDown = true;
			else
				bTurningUp = true;
		}	

		if ( bTurningLeft || bTurningRight || bTurningUp || bTurningDown )
		{
			// -BB Restrict the barrel movement a bit
			if(CurBaseYaw > (Rotation.Yaw & 65535) + MaxYawModelDelta)
				GunRot.Yaw = -((Rotation.Yaw & 65535) + MaxYawModelDelta);
			else if(CurBaseYaw < (Rotation.Yaw & 65535) - MaxYawModelDelta)
				GunRot.Yaw = -((Rotation.Yaw & 65535) - MaxYawModelDelta);
			else
				GunRot.Yaw = -CurBaseYaw;

			GunRot.Roll = CurGunPitch;
			SetBoneRotation( GunBone, GunRot + Rotation, 1.0 );
		}
		
		//NAC: Removed crank animations to save memory
		// Play the appropriate hand-cranking animation if the weapon is turning.
/*		if ( bTurningLeft )
		{		
			PlayCrankAnimations( 'pak_gunner_adjust_left', 0 );
		}
		else if ( bTurningRight )
		{		
			PlayCrankAnimations( 'pak_gunner_adjust_right', 0 );
		}
		else if ( bTurningUp )
		{
			PlayCrankAnimations( 'pak_gunner_adjust_up', 0 );
		}
		else if ( bTurningDown )
		{
			PlayCrankAnimations( 'pak_gunner_adjust_down', 0 );
		}
		else
		{	*/	
			Gunner.PlayWaiting();	
		//}

		if ( !FireMode[0].bIsFiring )
		{
			Self.LoopAnim( 'Idle', 1.0, 0.25 );
		}
	}
}

//---------------------------------------------------------
//	PlayCrankAnimations
//---------------------------------------------------------
simulated function PlayCrankAnimations( Name GunnerAnim, int Channel )
{
	local name AnimName;
	local float AnimFrame, AnimRate;

	Gunner.GetAnimParams( 0, AnimName, AnimFrame, AnimRate );
	if ( AnimName != GunnerAnim )
	{
		Gunner.AddAnimToQueue( GunnerAnim, 95.0, true, false,, 2.0, 0.05,, Channel );
	}
}

//---------------------------------------------------------
//	ClientStartFire
//---------------------------------------------------------
// Needed to override this because Owner is different for this weapon than most other weapons.
simulated event ClientStartFire(int Mode)
{
    if (!Gunner.Controller.CanFire() || bHasBlownUp )
        return;

    if (Role < ROLE_Authority)
    {
        if (StartFire(Mode))
        {
            ServerStartFire(Mode);
        }
    }
    else
    {
        StartFire(Mode);
    }
}

//---------------------------------------------------------
//	PlayFiring
//---------------------------------------------------------
simulated function PlayFiring()
{	
	//Gunner.PlayAnim( 'pak_gunner_fire' );
	//Gunner.AddAnimToQueue( 'pak_gunner_fire', 96.0, true, false );	//NAC: Removed fire animation to save memory
	
	if ( Loader != None )
	{
		bReloadingShell = true;
		gbxAIController( Loader.Controller ).ReloadTurret();
	}
	else
	{
		// TBD: Play player reload anim.
		ReloadFinished();
	}
}

//---------------------------------------------------------
//	AdjustAimNew
//---------------------------------------------------------
// Used only with player pawns; AI pawns use the AdjustAimNew() in FiringController.
function Rotator AdjustAimSpecial( Ammunition Ammo, Vector ProjStart, Rotator AimRotator, int WeaponAimError )
{
	// The Pak is hard enough to aim as it is--don't add any inaccuracy to the thing!!
	return AimRotator;
}

//---------------------------------------------------------
//	GetViewOrigin
//---------------------------------------------------------
function Vector GetViewOrigin()
{
	return Self.Location;
}

//---------------------------------------------------------
//	GetFireRotation
//---------------------------------------------------------
function Rotator GetFireRotation()
{
	local Rotator Temp;
	Temp.Pitch = CurGunPitch;
	Temp.Yaw = CurBaseYaw;
	return Temp;
}

//---------------------------------------------------------
//	CompleteMount
//---------------------------------------------------------
function CompleteMount( gbxPawn gbxP )
{	
	local Vector LocalX, LocalY, LocalZ;

	GetAxes( Rotation, LocalX, LocalY, LocalZ );

	if ( gbxP == Gunner )
	{
		Gunner.StartGoingToCrouch( true );
		Gunner.bNoTurnBody = true;
		Gunner.SetLocation( Self.Location + GunnerOffset.X*LocalX + GunnerOffset.Y*LocalY + GunnerOffset.Z*LocalZ );
		Gunner.SetRotation( Self.Rotation );
		Gunner.bHardAttach = true;
		Gunner.SetBase( self );	// new
		Gunner.FlushAnimQueueChannel( 0,, true );
		Gunner.LoadMountAnimations( Mount_MountPak36Gunner );
		Gunner.bDoTorsoTwist = false;
		Gunner.SetWeapon( Self );

		Instigator = Gunner;
		if ( Ammo[0] != None )
			Ammo[0].Instigator = Instigator;
		if ( FireMode[0] != None )
			FireMode[0].Instigator = Instigator;
		if ( ThirdPersonActor != None )
			ThirdPersonActor.Instigator = Instigator;

		bIsMounting = false;				

		// Send out a mount event to anyone who may be interested.
		TriggerEvent( MountEvent, Self, Gunner );
	}
	else if ( gbxP == Loader )
	{
		Loader.StartGoingToCrouch( true );
		Loader.bNoTurnBody = true;
		Loader.SetLocation( Self.Location + LoaderOffset.X*LocalX + LoaderOffset.Y*LocalY + LoaderOffset.Z*LocalZ );
		Loader.SetRotation( Self.Rotation );
		Loader.SetBase( self );	// new
		Loader.FlushAnimQueueChannel( 0,, true );
		Loader.LoadMountAnimations( Mount_MountPak36Loader );
		Loader.bDoTorsoTwist = false;
		Loader.SetWeapon( None );
	}	

	gbxP.PlayWaiting();
}

//---------------------------------------------------------
//	ReloadFinished
//---------------------------------------------------------
function ReloadFinished()
{
	ReloadClip();
	if ( Loader != None )
	{
		gbxAIController( Loader.Controller ).NotifyReloadFinished();
	}
	bReloadingShell = false;
}

//---------------------------------------------------------
//	NotifyForceDismount
//---------------------------------------------------------
function NotifyForceDismount( optional bool bDoNothingIfHumanControlled )
{
	ForceCrewDismount();
}

//---------------------------------------------------------
//	ForceCrewDismount
//---------------------------------------------------------
function ForceCrewDismount( optional Pawn InstigatedBy )
{
	bDontRecruit = true;

	if ( Gunner != None )
	{
		StopFiringWeapon();
		Gunner.MyUnit.MemberLostMachineGun(Gunner); 
		gbxAIController( Gunner.Controller ).BreakOutJustMe( InstigatedBy );
	}

	if ( Loader != None )
	{
		gbxAIController( Loader.Controller ).BreakOutJustMe( InstigatedBy );
	}	
}

//---------------------------------------------------------
//	GetMyMountPoint
//---------------------------------------------------------
function Vector GetMyMountPoint()
{
	local Vector X,Y,Z;
	GetAxes( Rotation, X,Y,Z );
	return Location + MountOffset.X*X + MountOffset.Y*Y + MountOffset.Z*Z;
}

//---------------------------------------------------------
//	PreparePlayerToMount
//---------------------------------------------------------
function PreparePlayerToMount()
{
	Gunner.SetTurretAnims( 'pak_gunner_idle_1', 'pak_gunner_dismount' );  //NAC: this will rarely, if ever get called.  I changed the first arguement from 'pak_gunner_mount' to save memory
	Gunner.SetLocation( GetMyMountPoint() );
	Gunner.SetRotation( Rotation );
	Gunner.Controller.SetRotation( Rotation );
	Gunner.PrepareToMount();
	Gunner.Job = Job_Pak36_Gunner;

	bIsMounting = true;
}

//---------------------------------------------------------
//	PreparePawnToDismount
//---------------------------------------------------------
function PreparePawnToDismount( gbxPawn gbxP )
{
	// Check that the pawn passed in is the gunner.
	if (gbxP != Gunner )
		return;

	StopFiringWeapon();
	//TBD: try this: SetBoneRotation( GunBone,,, 0 );

	bIsDismounting = true;
}

//---------------------------------------------------------
//	CompleteDismount
//---------------------------------------------------------
function CompleteDismount( gbxPawn gbxP )
{
	if ( gbxP == Gunner )
	{
		Instigator = None;
		Ammo[0].Instigator = None;
		FireMode[0].Instigator = None;

		Gunner = None;
		bIsDismounting = false;
		CameraOffset.X = 0.0;
		CameraOffset.Z = 0.0;

		// Send out a dismount event to anyone who may be interested.
		TriggerEvent( DismountEvent, Self, gbxP );

		// Reactivate my trigger, which was made inactive when used.
		MyTrigger.bDontDisplayMessage = false;
	}	
	else if ( gbxP == Loader )
	{
		Loader = None;
	}

	//gbxP.Weapon = None;  // hack so SetWeapon() will call ChangedWeapon() - jlb
	//gbxP.SetWeapon( gbxP.LastWeapon );
}

//---------------------------------------------------------
//	Trigger
//---------------------------------------------------------
event Trigger(Actor Other, Pawn EventInstigator)
{
	local gbxPawn gbxP;

	if ( !EventInstigator.IsA( 'gbxPlayerPawn' ) || bHasBlownUp )
		return;
	
	gbxP = gbxPawn( EventInstigator );

	// Don't allow the player to mount if an enemy is still using it!
	if ( ( Gunner != None && Gunner != gbxP ) || Loader != None )
		return;

	// Skip the action instigator is in the middle of a reload.
	if ( gbxP.IsTransitioning() || (gbxP.Weapon != Self && gbxP.Weapon.IsReloading() ) )
		return;

	if ( Gunner == gbxP )	// Gunner wishes to dismount.
	{
		Gunner.DismountTurretPlayer(true);
		MountStartStamp=Level.TimeSeconds;
	}
	else						// Gunner wishes to mount.
	if ( Gunner == None )
	{
		if ( Gunner != None )
		{
			// TBD: najnaj: Tell the current claimant that he's been booted!
		}
		Gunner = gbxP;
		PreparePlayerToMount();
		Gunner.MountTurretPlayer( Self, true );
		MountStartStamp=Level.TimeSeconds;
	}
}

//---------------------------------------------------------
//	SpecialCalcView
//---------------------------------------------------------
simulated function SpecialCalcView( gbxPawn thePawn, out actor ViewActor, out vector CameraLocation, out rotator CameraRotation )
{
	CalcThirdPersonView( thePawn, ViewActor, CameraLocation, CameraRotation );
}

//---------------------------------------------------------
//	CalcThirdPersonView
//---------------------------------------------------------
function CalcThirdPersonView( gbxPawn thePawn, out actor ViewActor, out vector CameraLocation, out rotator CameraRotation )
{
	local Vector X,Y,Z;
	local Rotator ControllerRot;
	local int Diff, RightOfCenter;
	local float T;
	ViewActor = thePawn;

	CameraLocation = thePawn.Location;

	if ( true )
	{
		if ( bIsMounting )
		{
			// Player is mounting turret.  Zoom out.
			T = FClamp( ( Level.TimeSeconds - MountStartStamp ) * CameraZoomSpeed, 0, 1 );
			CameraOffset = CameraStartOffset + T*( CameraEndOffset - CameraStartOffset );
		}
		else if ( bIsDismounting )
		{
			// Player is dismounting turret.  Zoom in.
			T = FClamp( ( Level.TimeSeconds - MountStartStamp ) * CameraZoomOutSpeed, 0, 1 );
			CameraOffset = CameraEndOffset + T*( CameraStartOffset - CameraEndOffset );
		}
		else
		{
			CameraOffset = CameraEndOffset;
		}
	}

	// Restrict the yaw and pitch to the cone of fire.
	if ( Gunner != None )
	{
		ControllerRot = Gunner.Controller.Rotation;

		// Yaw.
		GetRotDelta( ControllerRot.Yaw, Rotation.Yaw, Diff, RightOfCenter );
		if ( Diff > MaxYawDelta )
		{
			if ( RightOfCenter == 1 )
				ControllerRot.Yaw = (Rotation.Yaw + MaxYawDelta) & 65535;
			else
				ControllerRot.Yaw = (Rotation.Yaw - MaxYawDelta) & 65535;
		}

		// Pitch.
		GetRotDelta( ControllerRot.Pitch, Rotation.Pitch, Diff, RightOfCenter );
		if ( RightOfCenter == 1 && Diff > MaxPitchDeltaUp )
		{
			ControllerRot.Pitch = ( Rotation.Pitch + MaxPitchDeltaUp ) & 65535;
		}
		else if ( RightOfCenter == 0 && Diff > MaxPitchDeltaDown )
		{
			ControllerRot.Pitch = ( Rotation.Pitch - MaxPitchDeltaDown ) & 65535;
		}		

		Gunner.Controller.SetRotation( ControllerRot );
	}
	GetAxes( CameraRotation, X,Y,Z );
	CameraLocation = CameraLocation - CameraOffset.X*X + CameraOffset.Y*Y + CameraOffset.Z*Z;

	CameraRotation.Pitch -= CameraPitchUU;
}

//---------------------------------------------------------
//	SetBlownUp
//---------------------------------------------------------
function SetBlownUp()
{
	Super.SetBlownUp();

	SetDrawType( DT_StaticMesh );
	SetStaticMesh( StaticMesh(DynamicLoadObject("s_military_de.Weapon.pak36_dmg", class'StaticMesh')) );

	if ( Gunner != None )
	{
		Gunner.Destroy();
	}

	if ( Loader != None )
	{
		Loader.Destroy();
	}
}

//---------------------------------------------------------
//	BlowUp
//---------------------------------------------------------
function BlowUp( Pawn EventInstigator )
{
	Super.BlowUp( EventInstigator );

	SetDrawType( DT_StaticMesh );
	SetStaticMesh( StaticMesh(DynamicLoadObject("s_military_de.Weapon.pak36_dmg", class'StaticMesh')) );

	HurtRadius( 500.0,500.0, class'DamageTankCannon', 50000, Location - 100.0*Vector( Rotation ) );

	if ( DeathEvent != '' )
	{
		TriggerEvent( DeathEvent, Self, EventInstigator );
	}

	// If the crew is still alive, get them off this thing.
	if ( Gunner != None && !Gunner.IsDead() )
	{
		ForceCrewDismount( EventInstigator );
	}
}

//---------------------------------------------------------
//	CanBeDestroyedBy
//---------------------------------------------------------
function bool CanBeDestroyedBy( class<DamageType> DamageType ) 
{ 
	return (
		DamageType == class'DamageGammonBomb' || 
		DamageType == class'DamageTankCannon' ||
		DamageType == class'DamageDEPanzerfaust' ||
		DamageType == class'DamageUSBazooka' 
		);
}

//---------------------------------------------------------
//	NeverAllowShotProtectionFor
//---------------------------------------------------------
function bool NeverAllowShotProtectionFor( class<DamageType> DamageType )
{
	return (
		CanBeDestroyedBy( DamageType ) ||
		DamageType == class'DamageGrenade' 
		);
}

function bool TargetIsInKillZone( Pawn Target )
{
	return VSize( Target.Location - Self.Location ) <= KillZoneDist;
}

simulated event RenderOverlays( Canvas Canvas ) {}

//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
	DrawType=DT_Mesh
//	Mesh=Mesh'k_prop.de_pak36'
//	StaticMesh=StaticMesh's_military_de.Weapon.pak36_dmg'
	Mesh=None
	StaticMesh=None
	Texture=Texture'Engine.S_Weapon'

	GunnerOffset=(x=-104.022,y=-44.898,z=38.447)	// Landon's original
	LoaderOffset=(x=-102.999,y=55.599,z=42.412)
	YawRotSpeed=1800.0
	PitchRotSpeed=1800.0
	PitchOffset=0
	MaxPitchDeltaDown=1000
	MaxPitchDeltaUp=2000
	//MaxYawDelta=4096
	MaxYawDelta=1820
	MaxYawModelDelta=900
	GunBone=gun_base

	FireModeClass(0)=FireDEPak36_
	FireModeClass(1)=FireDEPak36_
	AttachmentClass=class'AttachmentDEPak36_'

	ClientState=WS_Hidden
	AmmoClipSize=1

	EnemyTooCloseDist=1500.0
	MountOffset=(X=-104.022,Y=-44.898,Z=0)
	CameraStartOffset=(X=100,Y=0,Z=100)
	CameraEndOffset=(X=150,Y=40,Z=80)

	MyMountAction=Mount_MountPak36Gunner
	CameraPitchUU=1000
	CameraZoomSpeed=2.0
	CameraZoomOutSpeed=0.8

	Physics=PHYS_Falling
	bStatic=false
	bBlockKarma=true
	bCollideActors=true
	bBlockActors=true
	bBlockPlayers=true
	bCollideWorld=true
	bCollideSkeletalMesh=true
	bBlockZeroExtentTraces=true
	bBlockNonZeroExtentTraces=true
	CollisionHeight=0.0

	bUseShotProtection=true
	NoShotProtectionDist=1000.0
	MaxFiringDist=10000

	BreatheProfileClass=class'gbxSupportedBreatheProfile'

	CrewCheckInterval=3.0
	bDamagesVehicles=true
	
	bOpaqueForSituationalAwarenessView=true
}class WeapDEPAK88_ extends TurretWeapon;

//---------------------------------------------------------
//	Variables
//---------------------------------------------------------
var Actor	TargetActor;		// If this is None, the controller will assign random targets.
var	Name	GunBone, CoGunBone, HorizCrankBone, VertCrankBone;
var Name	GunnerAttach, FuseSetterAttach;
var Name	GunnerToDraft, FuseSetterToDraft, LoaderToDraft, SpotterToDraft;
var Name	DeathEvent;
var float	YawRotSpeed, PitchRotSpeed;
var float	NextCrewCheckTime;
var float	CrewCheckInterval;
var int		TotalShots;
var int		NumShotsSoFar;
var int		PlayerDownTime;	//NAC: this is used to give the player a little bit more time to move after he has been knocked on his ass.
var float	TimeBetweenShots;
var float	OffsetFromTarget;
var float	PlayerHitTimer;
var float	LoaderNoShotProtectionDist;

//sounds
var Sound	GunFireSound;
var string	GunFireSoundName;
var Sound	TurretRotatingSound;  // turret rotating sound is looped
var string	TurretRotatingSoundName;
var int		TurretRotatingSoundHandle;
var Sound	TurretStopSound;
var string	TurretStopSoundName;
var Sound	SteamSound;
var string	SteamSoundName;


var int		GunnerAimOffset;
var int		CurBaseYaw, CurGunPitch, PitchOffset;
var int		MaxPitch,MinPitch;
var int		MaxYawDelta, MaxPitchDeltaDown, MaxPitchDeltaUp;
var bool	bDontRecruit;
var bool	bCrewHasBeenDrafted;
var bool	bGunIsLoaded;
var bool	bNoFuseSetter;
var bool	bTurningLeft, bTurningRight, bTurningUp, bTurningDown, bIsTurning, bWasFiring;
var Rotator	DesiredRot, LastRequestedRot;
var gbxPawn	Gunner, FuseSetter, Loader, Spotter;
var Vector	GunnerOffset, FuseSetterOffset;
//var PAK88BrokenTurret BrokenTurret;

var Name					DismountEvent;
var Actor	LoaderRef;  //A reference point for the loader to move to 
var Actor	BarrelCollision1,BarrelCollision2,BarrelCollision3;  //HACK for collision on the Barrel of this gun

var const int		HorizRotChannel, VertRotChannel;

var enum ELoaderSide
{
	Loader_Left,
	Loader_Right

} LastSideToReload;

//---------------------------------------------------------
//	PostNetBeginPlay
//---------------------------------------------------------
function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();
	GiveAmmo(0);

	Mesh = Mesh(DynamicLoadObject("k_prop.de_88flak", class'Mesh'));
	LinkMesh( Mesh );
	CreateSounds();
	SetUpLoaderReference();
	SetUpBarrelCollision();
	DesiredRot = Rotation;
	PlayAnim( 'Idle' );	
}


simulated function CreateSounds()
{
	if ( GunFireSoundName != "" )
		GunFireSound = Sound( DynamicLoadObject( GunFireSoundName, class'Sound' ) );
	if ( TurretRotatingSoundName != "" )
		TurretRotatingSound = Sound( DynamicLoadObject( TurretRotatingSoundName, class'Sound' ) );
	if ( TurretStopSoundName != "" )
		TurretStopSound = Sound( DynamicLoadObject( TurretStopSoundName, class'Sound' ) );
	if ( SteamSoundName != "" )
		SteamSound = Sound( DynamicLoadObject( SteamSoundName, class'Sound' ) );
}


function SetUpLoaderReference()
{
	local vector LoaderRefOffset;

	LoaderRefOffset.X = 700.0; //700
	LoaderRefOffset.Y = 0.0;
	LoaderRefOffset.Z = 60.0;
	LoaderRef = spawn(class'gbxDummyObject');
	LoaderRef.bHidden=false;
	LoaderRef.SetBase( None );
	LoaderRef.SetPhysics( PHYS_None );
	AttachToBone( LoaderRef, 'Barrel_01' );		
	LoaderRef.SetRelativeRotation( Rot( 0,32768,16384 ) );
	LoaderRef.SetRelativeLocation( LoaderRefOffset );
}


function SetUpBarrelCollision()
{
	local vector BarrelOffset;

	BarrelOffset.X = 50.0; 
	BarrelOffset.Y = 0.0;
	BarrelOffset.Z = 0.0;
	BarrelCollision1 = spawn(class'gbxDummyObject');
	BarrelCollision1.bHidden=false;
	BarrelCollision1.SetBase( None );
	BarrelCollision1.SetPhysics( PHYS_None );
	AttachToBone( BarrelCollision1, 'Barrel_01' );		
	BarrelCollision1.SetRelativeRotation( Rot( 0,32768,16384 ) );
	BarrelCollision1.SetCollision(true,true,true);
	BarrelCollision1.SetCollisionSize(50.0,10.0);
	BarrelCollision1.SetRelativeLocation( BarrelOffset );


	BarrelOffset.X = 150.0; 
	BarrelCollision2 = spawn(class'gbxDummyObject');
	BarrelCollision2.bHidden=false;
	BarrelCollision2.SetBase( None );
	BarrelCollision2.SetPhysics( PHYS_None );
	AttachToBone( BarrelCollision2, 'Barrel_01' );		
	BarrelCollision2.SetRelativeRotation( Rot( 0,32768,16384 ) );
	BarrelCollision2.SetCollision(true,true,true);
	BarrelCollision2.SetCollisionSize(50.0,10.0);
	BarrelCollision2.SetRelativeLocation( BarrelOffset );


	BarrelOffset.X = 250.0; 
	BarrelCollision3 = spawn(class'gbxDummyObject');
	BarrelCollision3.bHidden=false;
	BarrelCollision3.SetBase( None );
	BarrelCollision3.SetPhysics( PHYS_None );
	AttachToBone( BarrelCollision3, 'Barrel_01' );		
	BarrelCollision3.SetRelativeRotation( Rot( 0,32768,16384 ) );
	BarrelCollision3.SetCollision(true,true,true);
	BarrelCollision3.SetCollisionSize(50.0,10.0);
	BarrelCollision3.SetRelativeLocation( BarrelOffset );
}
//---------------------------------------------------------
//	IsAntiAir
//---------------------------------------------------------
function bool IsPak88() 
{ 
	return true; 
}

//---------------------------------------------------------
//	GetBracingAnim
//---------------------------------------------------------
// TBD: Get rid of this ugly function - move animation names into ItemPawnAnimInfo.
function Name GetBracingAnim( gbxPawn Loader )
{
	if ( Loader == FuseSetter )
		return 'de_88_fuse_setter_idle';
	else if (Loader == Spotter)
		return 'de_88_spotter_standing_idle';
	else
		return '';
}

//---------------------------------------------------------
//	SetTargetActor
//---------------------------------------------------------
function SetTargetActor( Actor NewTargetActor )
{
	TargetActor = NewTargetActor;
}

//---------------------------------------------------------
//	GetTargetActor
//---------------------------------------------------------
function Actor GetTargetActor()
{

	return TargetActor;	// May be None.
}

//---------------------------------------------------------
//	GetRotDelta
//---------------------------------------------------------
function GetRotDelta( int Requested, int Center, out int Diff, out int RightOfCenter )
{
	local bool bIsNegative, bDidSubtract;

	Requested = Requested & 65535;
	Center = Center & 65535;

	Diff = Requested - Center;
	bIsNegative = ( Diff < 0 );
	Diff = abs( Diff );

	if ( Diff > 32767 )
	{
		Diff = 65535 - Diff;
		bDidSubtract = true;
	}
	if ( ( bDidSubtract && !bIsNegative ) || ( !bDidSubtract && bIsNegative ) )
	{
		RightOfCenter = 0;
	}
	else if ( ( !bDidSubtract && !bIsNegative ) || ( bDidSubtract && bIsNegative ) )
	{
		RightOfCenter = 1;
	}
}

//---------------------------------------------------------
//	FaceRotation
//---------------------------------------------------------
function FaceRotation( Rotator Rot )
{
		local int Diff, RightOfCenter;

	if ( bHasBlownUp )
		return;

	if (TargetActor == None)  //if there is no target to rotate to, don't rotate!
		return;

	Rot.Pitch = Rot.Pitch & 65535;
	Rot.Yaw = Rot.Yaw & 65535;

	// Make sure the requested pitch and yaw do not go outside the bounds of the weapon.
	GetRotDelta( Rot.Pitch, Rotation.Pitch, Diff, RightOfCenter );
	if ( RightOfCenter == 1 && Diff > MaxPitchDeltaUp )
	{
		Rot.Pitch = ( Rotation.Pitch + MaxPitchDeltaUp ) & 65535;
	}
	else if ( RightOfCenter == 0 && Diff > MaxPitchDeltaDown )
	{
		Rot.Pitch = ( Rotation.Pitch - MaxPitchDeltaDown ) & 65535;
	}	


	DesiredRot = Rot;	
	DesiredRot.Pitch *= -1;		// Because at pitch=0, the gun may not actually be pointing horizontally	

	DesiredRot.Pitch = DesiredRot.Pitch & 65535;
	DesiredRot.Yaw = DesiredRot.Yaw & 65535;
}

//---------------------------------------------------------
//	GetAdjustedRotation
//---------------------------------------------------------
function int GetAdjustedRotation( int CurPosition, int DesiredPosition, float Speed, float DeltaTime, out int bRotatingLeft )
{
	local int Diff, NewPos, Offset;
	local bool bIsNegative, bDidSubtract, bSnap;
	local float AdjustedSpeed;

	Diff = DesiredPosition - CurPosition;
	bIsNegative = ( Diff < 0 );

	Diff = abs( Diff );

	if ( Diff > 32767)
	{
		Diff = 65536 - Diff;
		bDidSubtract = true;
	}

	AdjustedSpeed = Speed;
	Offset = AdjustedSpeed*DeltaTime;
	if ( Offset >= Diff )
	{
		do
		{
			AdjustedSpeed *= 0.75;
			Offset = AdjustedSpeed*DeltaTime;
		}
		until( AdjustedSpeed < 0.25*Speed || Offset <= Diff );
		
		if ( Offset >= Diff )
		{
			bSnap = true;
		}
	}
	
	if ( ( bDidSubtract && bIsNegative ) || ( !bDidSubtract && !bIsNegative ) )
	{
		if ( bSnap )
			NewPos = DesiredPosition;
		else
			NewPos = (CurPosition + Offset ) & 65535;
		
		bRotatingLeft = 0;
	}
	else
	{
		if ( bSnap )
			NewPos = DesiredPosition;
		else
			NewPos = (CurPosition - Offset ) & 65535;

		bRotatingLeft = 1;
	}

	return NewPos;	
}

//---------------------------------------------------------
//	PawnIsInCrew
//---------------------------------------------------------
function bool PawnIsInCrew( Pawn P ) 
{ 
	return P == Gunner || P == FuseSetter || P == Spotter || P == Loader;
}

//---------------------------------------------------------
//	DraftCrew
//---------------------------------------------------------
function DraftCrew()
{
	local gbxPawn aDraftee;
	local class<gbxAIController> MindClass;
	local int index;
	local MeshAnimation	aMeshAnim;
	local gbxAIController NewMind;
	
	ForEach DynamicActors(class'gbxPawn', aDraftee )
	{
		if ( aDraftee.Tag == GunnerToDraft && Gunner == None )
		{
			Gunner = aDraftee;

			//clear out all of the animation queues
			Gunner.FlushAnimQueueChannel( 0 );
			for (index=1; index <= 16; index++)
				Gunner.FlushAnimQueueChannel( index, false, true );

			MindClass = class<gbxAIController>( DynamicLoadObject( "gbxAI.MindPAK88Gunner", class'Class' ) );
			Gunner.CrewTurret( Self, MindClass, Job_PAK88_Gunner );
		}
		else if ( aDraftee.Tag == FuseSetterToDraft && FuseSetter == None && !bNoFuseSetter )
		{
			FuseSetter = aDraftee;
			MindClass = class<gbxAIController>( DynamicLoadObject( "gbxAI.MindPAK88FuseSetter", class'Class' ) );
			//clear out all of the animation queues
			FuseSetter.FlushAnimQueueChannel( 0 );
			for (index=1; index <= 16; index++)
				FuseSetter.FlushAnimQueueChannel( index, false, true );
	                FuseSetter.CrewTurret( Self, MindClass, Job_PAK88_FuseSetter );
		}
		else if ( aDraftee.Tag == LoaderToDraft && Loader == None  )
		{

			Loader = aDraftee;

			Loader.SetBase(None);
			Loader.bHardAttach = true;
			Loader.SetBase(self);

			MindClass = class<gbxAIController>( DynamicLoadObject( "gbxAI.MindPAK88Loader", class'Class' ) );

			if( Loader != None && !Loader.IsDead() )
			{
				aMeshAnim = MeshAnimation(DynamicLoadObject("a_hold_misc.88",class'MeshAnimation'));
				if (aMeshAnim != None)
				{
					if(Loader.LinkSkelAnim(aMeshAnim))
					{
						Loader.MeshAnim = aMeshAnim;
						Loader.CurMeshAnimName = "a_hold_misc.88";
					}
					Loader.bInitializeAnimation = false;
				}
			}

			Loader.SetWeapon(None);

			Loader.CrewTurret( Self, MindClass, Job_PAK88_Loader );

			Loader.SetPhysics(PHYS_FALLING);

		}
		else if ( aDraftee.Tag == SpotterToDraft && Spotter == None  )
		{
			Spotter = aDraftee;

			Spotter.SetBase(None);
			Spotter.bHardAttach = true;
			Spotter.SetBase(self);

			MindClass = class<gbxAIController>( DynamicLoadObject( "gbxAI.MindPAK88Spotter", class'Class' ) );

			NewMind = gbxAIController( Spotter.Controller ).ChangeMind( MindClass );

			if( Spotter != None && !Spotter.IsDead() )
			{
				aMeshAnim = MeshAnimation(DynamicLoadObject("a_hold_misc.88",class'MeshAnimation'));
				if (aMeshAnim != None)
				{
					if(Spotter.LinkSkelAnim(aMeshAnim))
					{
						Spotter.MeshAnim = aMeshAnim;
						Spotter.CurMeshAnimName = "a_hold_misc.88";
					}
					Spotter.bInitializeAnimation = false;
				}
			}

			Spotter.SetWeapon(None);

			Spotter.SetPhysics(PHYS_FALLING);
			gbxAIController( Spotter.Controller ).StartJob();
		}
	}


	if ( Gunner != None )
	{
		if (Spotter==None)
			Gunner.MyUnit.MemberGainedMachineGun(Gunner);  //OK, he doesn't have an MG, but he's got a Frickin 88....we want suppression to behave the same way if there is no spotter.
		bCrewHasBeenDrafted = true;
	}


}

//---------------------------------------------------------
//	GetFireRotation
//---------------------------------------------------------
function Rotator GetFireRotation()
{
	local Rotator Temp;
	Temp.Pitch = CurGunPitch;
	Temp.Pitch = (Temp.Pitch *-1 ) & 65535;
	Temp.Yaw = CurBaseYaw + GunnerAimOffset;
	return Temp;
}

//---------------------------------------------------------
//	SetPlayerHitTimer
//---------------------------------------------------------
function SetPlayerHitTimer(float time)
{
	PlayerHitTimer = time;

}

//---------------------------------------------------------
//	OKToFire
//---------------------------------------------------------
simulated function bool OKToFire()
{

	if(TargetActor == Level.GetLocalPlayerController().Pawn )  //if we are shooting at the player, he is close enough to fire at, and we've given him time to get up if shot at before, ok the shot
	{
		//log("**************PLAYER SHOT AT TIME DIFF:"$(Level.TimeSeconds - PlayerHitTimer),'NAC');
		if( (Level.TimeSeconds - PlayerHitTimer) < PlayerDownTime)
		{
			// since we haven't given the player time to get up, do nothing.
			return false;
		}
		return true;
	}
	return true;
}



//---------------------------------------------------------
//	GetViewOrigin
//---------------------------------------------------------
function Vector GetViewOrigin()
{
	if ( Gunner != None )
		return Gunner.Location;
}

//---------------------------------------------------------
//	Tick
//---------------------------------------------------------
function Tick( float DeltaTime )
{
	local Rotator BaseRot, GunRot;
	local int RotatingLeft, RotatingUp;

	Super.Tick( DeltaTime );

	if ( bHasBlownUp )
	{
		//overwrite the idle animation with the broken one
		PlayAnim( 'Idle_broken', 1.0, 0.0 );

		//NAC:if the crew has been drafted and the gun has blown up, make sure the crew members abandon ship!
		if (bCrewHasBeenDrafted)
		{
			if (Gunner !=None)
				ForceCrewDismount();
			if (Loader != None)
				ForceCrewDismount();
			if (Spotter != None)
				ForceCrewDismount();
			if (FuseSetter != None)
				ForceCrewDismount();
		}
		return;
	}

	// Make sure that this weapon is manned.
	//if ( !bCrewHasBeenDrafted )
	//{
	if ( !bDontRecruit && !bCrewHasBeenDrafted && Level.TimeSeconds > NextCrewCheckTime )
	{
		NextCrewCheckTime = Level.TimeSeconds + CrewCheckInterval;
		DraftCrew();		
	}

	if ( Gunner == None )
	{
		//NAC:if the crew has been drafted and there is no Gunner, make sure the other crew members abandon ship!
		if (bCrewHasBeenDrafted)
	{
		if (Loader != None)
				ForceCrewDismount();
		if (Spotter != None)
				ForceCrewDismount();
		if (FuseSetter != None)
				ForceCrewDismount();
		}
		return;
	}

	bTurningLeft = false;
	bTurningRight = false;
	bTurningUp = false;
	bTurningDown = false;
	
	// Determine which direction (if any) the weapon is turning.
	if ( abs( DesiredRot.Yaw - CurBaseYaw ) > 0 )
	{		
		CurBaseYaw = GetAdjustedRotation( CurBaseYaw, DesiredRot.Yaw, YawRotSpeed, DeltaTime, RotatingLeft );
		BaseRot.Pitch = Rotation.Yaw-CurBaseYaw - GunnerAimOffset;	// Yes, I must use the pitch component to yaw the base.  Confusing, isn't it?
		SetBoneRotation( GunBone, BaseRot, 1.0 );
		
		if ( RotatingLeft == 1 )
		{
			bTurningLeft = true;
		}
		else
		{
			bTurningRight = true;
		}
	}
	if ( abs( DesiredRot.Pitch - CurGunPitch ) > 0 )
	{
		CurGunPitch = GetAdjustedRotation( CurGunPitch, DesiredRot.Pitch, PitchRotSpeed, DeltaTime, RotatingUp );
		GunRot.Yaw = CurGunPitch & 65535;
		SetBoneRotation( CoGunBone, GunRot, 1.0 );
		
		if ( RotatingUp == 1 )
			bTurningUp = true;
		else
			bTurningDown = true;
	}	
	
	// Play the appropriate hand-cranking animation if the weapon is turning.
	if ( bTurningLeft )
	{		
		PlayCrankAnimations( 'de_88_gunner_cranking' );
	}
	else if ( bTurningRight )
	{		
		PlayCrankAnimations( 'de_88_gunner_cranking' );
	}
	else if ( bTurningUp )
	{
		PlayCrankAnimations( 'de_88_gunner_cranking' );
	}
	else if ( bTurningDown )
	{
		PlayCrankAnimations( 'de_88_gunner_cranking' );
	}
	else
		StopRotatingAction('de_88_gunner_idle');

	if ( !FireMode[0].bIsFiring && bWasFiring )
	{
		//Self.LoopAnim( 'Idle', 1.0, 0.25 );
		gbxAIController( Gunner.Controller ).NotifyStopFiring();
		if (!bNoFuseSetter)
		gbxAIController( FuseSetter.Controller ).NotifyStopFiring();
		bWasFiring = false;
	}
}

//---------------------------------------------------------
//	PlayCrankAnimations
//---------------------------------------------------------
simulated function PlayCrankAnimations( Name GunnerAnim )
{

		Gunner.AddAnimToQueue( GunnerAnim, 96.0, true, false,, 2.0, 0.30 );
		if (TurretRotatingSoundHandle < 0 )
		{
			TurretRotatingSoundHandle = PlaySound( TurretRotatingSound, SLOT_NONE, TransientSoundVolume,,,,false);
		}
		bIsTurning = true;
}

//---------------------------------------------------------
//	StopRotatingAction
//---------------------------------------------------------
simulated function StopRotatingAction( Name GunnerAnim )
{

		Gunner.AnimEnd(0);
		Gunner.AddAnimToQueue( 'de_88_gunner_idle', 96.0, true, false,, 2.0, 0.15 );
		if (TurretRotatingSoundHandle >= 0)
		{
			StopSound( TurretRotatingSoundHandle );
			TurretRotatingSoundHandle = -1;
			PlaySound( TurretStopSound, SLOT_NONE, TransientSoundVolume,,,,false);

		}
		bIsTurning = false;	
}



//---------------------------------------------------------
//	PlayFiring
//---------------------------------------------------------
simulated function PlayFiring()
{
	local name AnimName;
	local float AnimFrame, AnimRate;	

	Gunner.GetAnimParams( 0, AnimName, AnimFrame, AnimRate );

	gbxAIController( Gunner.Controller ).NotifyBeginFiring();
	if (!bNoFuseSetter)
	gbxAIController( FuseSetter.Controller ).NotifyBeginFiring();
	Loader.Controller.GotoState('Reloading');

	PlaySound( GunFireSound, SLOT_NONE, TransientSoundVolume,,,,false);
	SetTimer( 0.2, false );
	bWasFiring = true;

}

//---------------------------------------------------------
//	Timer
//---------------------------------------------------------
function Timer()
{
	if ( bHasBlownUp )		//If the timer was set before a dismount it will fire again.  
	{
		SetTimer( 0.0, false );
		return;
	}

	Super.Timer();
}

//---------------------------------------------------------
//	CompleteMount
//---------------------------------------------------------
function CompleteMount( gbxPawn gbxP )
{
	if ( gbxP == Gunner )
	{
		Gunner.SetBase( None );
		Gunner.SetPhysics( PHYS_None );
		AttachToBone( Gunner, GunnerAttach );		
		Gunner.SetRelativeRotation( Rot( 0,32768,16384 ) );
		Gunner.SetRelativeLocation( GunnerOffset );
		Gunner.FlushAnimQueueChannel( 0,, true );
		Gunner.StopAnimating();
		Gunner.LoadMountAnimations( Mount_MountPak88Gunner );
		Gunner.bDoTorsoTwist = false;
		Gunner.SetWeapon( Self );

		Instigator = Gunner;
		if ( Ammo[0] != None )
			Ammo[0].Instigator = Instigator;
		if ( FireMode[0] != None )
			FireMode[0].Instigator = Instigator;
		if ( ThirdPersonActor != None )
			ThirdPersonActor.Instigator = Instigator;

	}
	else if ( gbxP == FuseSetter )
	{
		FuseSetter.SetBase( None );
		FuseSetter.SetPhysics( PHYS_None );
		AttachToBone( FuseSetter, FuseSetterAttach );
		FuseSetter.SetRelativeRotation( Rot( 28900,32768,16384 ) );
		FuseSetter.SetRelativeLocation( FuseSetterOffset );
		FuseSetter.FlushAnimQueueChannel( 0,, true );
		FuseSetter.StopAnimating();
		FuseSetter.LoadMountAnimations( Mount_MountPak88FuseSetter );
		FuseSetter.bDoTorsoTwist = false;
		FuseSetter.SetWeapon( None );
	}


	else if ( gbxP == Loader )
	{
		Loader.SetBase( None );
		Loader.SetPhysics( PHYS_FALLING );
		Loader.FlushAnimQueueChannel( 0,, true );
		Loader.LoadMountAnimations( Mount_MountPak88Loader );
		Loader.SetWeapon( None );
	}

	else if ( gbxP == Spotter )
	{
		Spotter.SetBase( None );
		Spotter.SetPhysics( PHYS_FALLING );
		Spotter.FlushAnimQueueChannel( 0,, true );
		Spotter.SetWeapon( None );
	}

	gbxP.PlayWaiting();
}

//---------------------------------------------------------
//	PreparePawnToDismount
//---------------------------------------------------------
function PreparePawnToDismount( gbxPawn gbxP )
{
	
	gbxP.SetPhysics( PHYS_Falling );
	//make sure we suspend spawning of smoke when they exit
	FireDEPAK88_( FireMode[0] ).StopFiring();
	FireDEPAK88_( FireMode[1] ).StopFiring();

	if (TurretRotatingSoundHandle >= 0)
	{
		StopSound( TurretRotatingSoundHandle );
		TurretRotatingSoundHandle = -1;
		PlaySound( TurretStopSound, SLOT_NONE, TransientSoundVolume,,,,false);

	}
}

//---------------------------------------------------------
//	CompleteDismount
//---------------------------------------------------------
function CompleteDismount( gbxPawn gbxP )
{
	//make sure we suspend spawning of smoke when they exit
	FireDEPAK88_( FireMode[0] ).StopFiring();
}

//---------------------------------------------------------
//	ForceCrewDismount
//---------------------------------------------------------
function ForceCrewDismount( optional Pawn InstigatedBy )
{
	bDontRecruit = true;

	bTurningLeft = false;
	bTurningRight = false;
	bTurningUp = false;
	bTurningDown = false;

	if ( Gunner != None )
	{
		StopFiringWeapon();
		gbxAIController( Gunner.Controller ).BreakOutJustMe( InstigatedBy );
		// Send out a dismount event to anyone who may be interested.
		TriggerEvent( DismountEvent, Self, Gunner );
		Gunner.MyUnit.MemberLostMachineGun(Gunner); 
	}

	if ( FuseSetter != None )
	{
		gbxAIController( FuseSetter.Controller ).BreakOutJustMe( InstigatedBy );
		// Send out a dismount event to anyone who may be interested.
		TriggerEvent( DismountEvent, Self, FuseSetter );
	}

	if (Spotter != None)
	{
		gbxAIController( Spotter.Controller ).BreakOutJustMe( InstigatedBy );
		// Send out a dismount event to anyone who may be interested.
		TriggerEvent( DismountEvent, Self, Spotter );
	}

	if (Loader != None)
	{
		gbxAIController( Loader.Controller ).BreakOutJustMe( InstigatedBy );
		// Send out a dismount event to anyone who may be interested.
		TriggerEvent( DismountEvent, Self, Loader );
	}

	Gunner = None;
	FuseSetter = None;
	Loader = None;
	Spotter = None;

}

// Special override fixes a rare bug where the FiringController tells the weapon to stop firing right after it has consumed its last
// bullet.  This had prevented the weapon from ever firing again.
function StopFiringWeapon()
{
	Super.StopFiringWeapon();
	if ( NeedsToReload() )
	{
		PlayReloading();
	}
}

//---------------------------------------------------------
//	PlayReloading
//---------------------------------------------------------
simulated function PlayReloading() 
{
	if (!bNoFuseSetter)
	gbxAIController( FuseSetter.Controller ).ReloadTurret();
}

//---------------------------------------------------------
//	ReloadFinished
//---------------------------------------------------------
function ReloadFinished()
{
	ReloadClip();
	if (!bNoFuseSetter)
	gbxAIController( FuseSetter.Controller ).NotifyReloadFinished();
}

//---------------------------------------------------------
//	NotifyForceDismount
//---------------------------------------------------------
function NotifyForceDismount( optional bool bDoNothingIfHumanControlled )
{
	ForceCrewDismount();
}

//---------------------------------------------------------
//	SetBlownUp
//---------------------------------------------------------
function SetBlownUp()
{
	Super.SetBlownUp();

	StopFiringWeapon();

	bTurningLeft = false;
	bTurningRight = false;
	bTurningUp = false;
	bTurningDown = false;

	if ( Gunner != None )
	{
		Gunner.Destroy();
	}
		
	if ( FuseSetter != None )
	{
		FuseSetter.Destroy();
	}
	
	if ( Spotter != None )
	{
		Spotter.Destroy();
	}

	//set the animation to be the broken one
	PlayAnim( 'Idle_broken', 1.0, 0.0 );
	//set the texture on the gun to be damaged
	Skins[0] = GbxShaderMaterial( DynamicLoadObject( "t_military_de.de_88mm_deployed_dmg_gbx", class'GbxShaderMaterial' ) );

	PlaySound( SteamSound, SLOT_NONE, TransientSoundVolume,,,,false);

}




//---------------------------------------------------------
//	BlowUp
//---------------------------------------------------------
function BlowUp( Pawn EventInstigator )
{
	local Rotator NewTurretRot, HurtOffsetRot;

	Super.BlowUp( EventInstigator );

	bTurningLeft = false;
	bTurningRight = false;
	bTurningUp = false;
	bTurningDown = false;

	//set the animation to be the broken one
	PlayAnim( 'Idle_broken', 1.0, 0.0 );
	//set the texture on the gun to be damaged
	Skins[0] = GbxShaderMaterial( DynamicLoadObject( "t_military_de.de_88mm_deployed_dmg_gbx", class'GbxShaderMaterial' ) );

	PlaySound( SteamSound, SLOT_NONE, TransientSoundVolume,,,,false);

	HurtOffsetRot = NewTurretRot;
	HurtOffsetRot.Pitch = 0;
	
	HurtRadius( 500.0,500.0, class'DamageTankCannon', 50000, Location - 100.0*Vector( HurtOffsetRot ) );

	if ( DeathEvent != '' )
	{
		TriggerEvent( DeathEvent, Self, EventInstigator );
	}
}

//---------------------------------------------------------
//	CanBeDestroyedBy
//---------------------------------------------------------
function bool CanBeDestroyedBy( class<DamageType> DamageType ) 
{ 
	return (
		DamageType == class'DamageGammonBomb' || 
		DamageType == class'DamageTankCannon' ||
		DamageType == class'DamageDEPanzerfaust' ||
		DamageType == class'DamageUSBazooka' 
		);
}

//---------------------------------------------------------
//	AlwaysAutoReload
//---------------------------------------------------------
function bool AlwaysAutoReload()
{
	return true;
}

simulated event RenderOverlays( Canvas Canvas ) {}

//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
	DrawType=DT_Mesh

	Mesh=None
	StaticMesh=None
	Texture=Texture'Engine.S_Weapon'

	FireModeClass(0)=FireDEPAK88_
	FireModeClass(1)=FireDEPAK88_
	AttachmentClass=class'AttachmentDEPak88_'

	GunBone=Horizontal
	CoGunBone=Elevation

	GunnerAttach= Right
	FuseSetterAttach=Left

	YawRotSpeed=1000.0
	PitchRotSpeed=1000.0
	PitchOffset=5385
	MaxPitch=16384
	MinPitch=8192
	MaxPitchDeltaDown=2000
	MaxPitchDeltaUp=5000

	GunnerOffset=(x=0.0,y=17.0,z=0.0)
	FuseSetterOffset=(x=1.0,y=0.0,z=2.0)
	GunnerAimOffset = 200
	
	HorizRotChannel=1
	VertRotChannel=2

	ClientState=WS_Hidden
	AmmoClipSize=20

	//Sounds
	GunFireSoundName = "W_88GUN.FIRE"
	TurretRotatingSoundName = "W_88GUN.ROTATE_LOOP"
	TurretStopSoundName = "W_88GUN.ROTATE_STOP"
	SteamSoundName = "W_88GUN.STEAM"
	TurretRotatingSoundHandle = -1


	Physics=PHYS_Falling
	bStatic=false
	bCollideActors=true
	bBlockActors=true
	bBlockPlayers=true
	bCollideWorld=true
	bCollideSkeletalMesh=true
	bBlockZeroExtentTraces=true
	bBlockNonZeroExtentTraces=true
	bNoFuseSetter = true 
	CollisionHeight=0.0

	CrewCheckInterval=3.0

	BreatheProfileClass=class'gbxSupportedBreatheProfile'

	bGunIsLoaded = true;
	bOpaqueForSituationalAwarenessView=true
	
	NumShotsSoFar = -1

	PlayerDownTime = 13  // 13 is not a lucky number!

	Zone1OuterRadius = 2500.0
	Zone2OuterRadius = 5000.0 
	Zone3OuterRadius = 25000.0
}//=============================================================================
// WeapDEPanzerfaust
//=============================================================================
class WeapDEPanzerfaust extends WargameWeapon
    config(user);


var Cue				FireSoundCue;
var bool			bDropCasingOnSwitch;

var ShellDEPanzerfaustCasing casing;

simulated function PostBeginPlay()
{
	FireSoundCue = LoadSound( "W_PANZERFAUST.FIRE" );

	Super.PostBeginPlay();
}

simulated function LoadWeaponMesh()
{
	Mesh = Mesh( DynamicLoadObject( "k_view_weapons.view_panzerfaust", class'Mesh' ) );
	m_NormalViewMesh = Mesh( DynamicLoadObject( "k_view_weapons.view_panzerfaust", class'Mesh' ) );
	m_ZoomViewMesh = Mesh( DynamicLoadObject( "k_view_weapons.view_panzerfaust_crosshair", class'Mesh' ) );
	LinkMesh( Mesh );
	Super.LoadWeaponMesh();
}

function ConsumeAmmo(int Mode, float load)
{
	Super.ConsumeAmmo(Mode, load);
	
	if( !HasAmmo() )
	{
		bDropCasingOnSwitch = true;
	}
}

simulated function AnimEnd(int channel)
{
	Super.AnimEnd(channel);

	if(ClientState == WS_ReadyToFire && Instigator.IsHumanControlled() && Level.NetMode == NM_Standalone )
    {
		SpawnCasing();
	}
}

simulated function SpawnCasing()
{
	if( casing == None && Instigator.IsHumanControlled() )
	{
		casing = Spawn( class'ShellDePanzerfaustCasing', None,,,Rotation + rot(0,0,49152) );
		casing.bHidden = true;
	}

	casing.SetLocation( GetBoneCoords( 'bolt' ).Origin + ( Vector(Instigator.GetViewRotation()) * 32.0 >> Rot(0,16384,0) ) );
	casing.SetBase( self );
}

simulated function ThrowCasing()
{
	if( casing != None )
	{
		casing.bHidden = false;
		casing.ThrowCasing( Instigator );
		casing = None;
	}
}

simulated function Timer()
{
	Super.Timer();

	if ( Level.NetMode == NM_Standalone )
	{
		if( bDropCasingOnSwitch && ClientState == WS_Hidden  )
		{
			ThrowCasing();
			bDropCasingOnSwitch = false;
		}
		else if( ClientState == WS_ReadyToFire )
		{
			SpawnCasing();
		}
	}
}

function byte BestMode()
{
	return 0;
}

function bool IsRocketLauncher()
{
	return true;
}

function bool RequiresSpecialMind( out class<gbxAIController> RequiredFC )
{
	RequiredFC = class<gbxAIController>( DynamicLoadObject( "gbxAI.MindPanzerfaust", class'Class' ) );
	return true;
}

defaultproperties
{
    ItemName="German Panzerfaust"

    FireModeClass(0)=FireDEPanzerfaust
    FireModeClass(1)=FireSecondaryItem
    FireModeClass(2)=FireMelee
    InventoryGroup=2
//	Mesh=Mesh'k_view_weapons.view_panzerfaust'
//	m_NormalViewMesh=Mesh'k_view_weapons.view_panzerfaust'
//	m_ZoomViewMesh=Mesh'k_view_weapons.view_panzerfaust_crosshair'
	m_nCharacterBodyIdx=3
    BobDamping=0.5
    PickupClass=class'PickupWeapDEPanzerfaust'
    EffectOffset=(X=130.0,Y=23.0,Z=-20.0)
	DisplayFOV=+50.0
    AttachmentClass=class'AttachmentDEPanzerfaust'

    DrawScale=1.0
	PlayerViewOffset=(X=20.000,Y=0.000000,Z=-0.50000)
    SelectSound=None

	AIRating=+0.4
    CurrentRating=0.4

	m_nBulletIconTextureX=258
	m_nBulletIconTextureY=203
	m_nClipIconTextureX=258
	m_nClipIconTextureY=203

	m_eWeaponType=WeaponPrimary
	MyMeleeDamageType=class'DamageUSGunButtMelee'

	DefaultAmmoCount(0)=1

	ZoomInAnim=aim_up
	ZoomOutAnim=aim_down
	SelectAnim=deploy
	PutDownAnim=holster
	IdleAnim(0)=idle_01
	IdleAnim(1)=idle_02
	IdleAnim(2)=idle_03
	BreathingAnim=breathe

	AmmoClipSize=1

	m_flEncumberance=1.0
	m_fCanSprint=true

	BreatheProfileClass=class'gbxHeavyBreatheProfile'

	bDamagesVehicles=true
	m_fDestroyWhenEmpty=true

	nIconX=358
	nIconY=0
	nIconW=27
	nIconH=108

	SelectAnimReadyDelay = 2.3
	PutDownAnimReadyDelay = 1.5

	DEPawnPackGoreClass(0)=class'gbxInventory.ConscriptK98GoreSetup'
	DEPawnPackGoreClass(1)=class'gbxInventory.InfantryK98GoreSetup'
	DEPawnPackGoreClass(2)=class'gbxInventory.ParaSturmGoreSetup'
	DEPawnPackGoreClass(3)=class'gbxInventory.PanzerK98GoreSetup'

	bThrowGrenadeLeftHanded=true

	WeaponName = WN_DEPanzerfaust
	AmmoName = AM_Nothing
	bMustSwitchWhenEmpty = true
}
//=============================================================================
// WeapDESTG44_
//=============================================================================
class WeapDESTG44_ extends WargameWeapon
    config(user);

simulated function LoadWeaponMesh()
{
	Mesh = Mesh( DynamicLoadObject( "k_view_weapons.view_stg44", class'Mesh' ) );
	m_NormalViewMesh = Mesh( DynamicLoadObject( "k_view_weapons.view_stg44", class'Mesh' ) );
	m_ZoomViewMesh = Mesh( DynamicLoadObject( "k_view_weapons.view_stg44_crosshair", class'Mesh' ) );
	LinkMesh( Mesh );
	Super.LoadWeaponMesh();
}

function byte BestMode()
{
	return 0;
}

defaultproperties
{
    ItemName="German STG44 Machine Gun"

    FireModeClass(0)=FireDESTG44_
    FireModeClass(1)=FireSecondaryItem
    FireModeClass(2)=FireMelee
    InventoryGroup=2
//	Mesh=Mesh'k_view_weapons.view_stg44'
//	m_NormalViewMesh=Mesh'k_view_weapons.view_stg44'
//	m_ZoomViewMesh=Mesh'k_view_weapons.view_stg44_crosshair'
	m_nCharacterBodyIdx=5
    BobDamping=0.5
    PickupClass=class'PickupWeapDESTG44_'
    EffectOffset=(X=150.0,Y=10.0,Z=-10.0)
	DisplayFOV=+50.0
    AttachmentClass=class'AttachmentDESTG44_'

    DrawScale=1.0
	PlayerViewOffset=(X=20.000,Y=0.000000,Z=-0.50000)
    SelectSound=None

	AIRating=+0.4
    CurrentRating=0.4

	// This icon no longer exists.
	//Icon=material'WG_HUD.HUD.wpn_garand'

//	m_aClipIcon=material'WG_HUD.HUD.clip_garand'
//	m_flBulletHeight=18
//	m_flClipHeight=128
//	m_flClipWidth=128
//	m_fClipFront=true
//	m_aFrontBulletIcon=material't_interface_mb.HUD.ammo_30cal'
//	m_aBackBulletIcon=material'WG_HUD.HUD.ammo_bullet_bck'
	m_nBulletIconTextureX=232
	m_nBulletIconTextureY=229
	m_nClipIconTextureX=232
	m_nClipIconTextureY=203

	m_eWeaponType=WeaponPrimary
	MyMeleeDamageType=class'DamageUSGunButtMelee'

	DefaultAmmoCount(0)=210

	ZoomInAnim=aim_up
	ZoomOutAnim=aim_down
	SelectAnim=deploy
	PutDownAnim=holster
	PutDownAnimQuick=holster_short
	IdleAnim(0)=idle_01
	IdleAnim(1)=idle_02
	IdleAnim(2)=idle_03

	WeaponBoneName=rifle_hold

	ZoomFovMod=17.0000

	AmmoClipSize=30

	m_flEncumberance=1.0
	m_fCanSprint=true
        m_bIsAutomatic=true

	Desirability=2.0

	BreatheProfileClass=class'gbxMediumBreatheProfile'

	DEPawnPackGoreClass(0)=class'gbxInventory.ConscriptMP40GoreSetup'
	DEPawnPackGoreClass(1)=class'gbxInventory.InfantryMP40GoreSetup'
	DEPawnPackGoreClass(2)=class'gbxInventory.ParaSturmGoreSetup'
	DEPawnPackGoreClass(3)=class'gbxInventory.PanzerSturmGoreSetup'

	nIconX=334
	nIconY=0
	nIconW=24
	nIconH=99

	WeaponName = WN_DESTG44
	AmmoName = AM_Nothing

	SelectAnimReadyDelay = 0.5
	PutDownAnimReadyDelay = 1.25
}
//=============================================================================
// WeapUSBar
//=============================================================================
class WeapUSBar extends WargameWeapon
    config(user);

simulated function LoadWeaponMesh()
{
	Mesh = Mesh( DynamicLoadObject( "k_view_weapons.view_bar", class'Mesh' ) );
	m_NormalViewMesh = Mesh( DynamicLoadObject( "k_view_weapons.view_bar", class'Mesh' ) );
	m_ZoomViewMesh = Mesh( DynamicLoadObject( "k_view_weapons.view_bar_crosshair", class'Mesh' ) );
	LinkMesh( Mesh );
	Super.LoadWeaponMesh();
}

function byte BestMode()
{
	return 0;
}

defaultproperties
{
    ItemName="US BAR Machine Gun"

    FireModeClass(0)=FireUSBar
    FireModeClass(1)=FireSecondaryItem
    FireModeClass(2)=FireMelee
    InventoryGroup=2
//	Mesh=Mesh'k_view_weapons.view_bar'
//	m_NormalViewMesh=Mesh'k_view_weapons.view_bar'
//	m_ZoomViewMesh=Mesh'k_view_weapons.view_bar_crosshair'
	m_nCharacterBodyIdx=5
    BobDamping=0.5
    PickupClass=class'PickupWeapUSBar'
    EffectOffset=(X=150.0,Y=10.0,Z=-10.0)
	DisplayFOV=+50.0
    AttachmentClass=class'AttachmentUSBar'

    DrawScale=1.0
	PlayerViewOffset=(X=20.000,Y=0.000000,Z=-0.50000)
    SelectSound=None

	AIRating=+0.4
    CurrentRating=0.4

	// This icon no longer exists.
	//Icon=material'WG_HUD.HUD.wpn_garand'

//	m_aClipIcon=material'WG_HUD.HUD.clip_garand'
//	m_flBulletHeight=18
//	m_flClipHeight=128
//	m_flClipWidth=128
//	m_fClipFront=true
//	m_aFrontBulletIcon=material't_interface_mb.HUD.ammo_30cal'
//	m_aBackBulletIcon=material'WG_HUD.HUD.ammo_bullet_bck'
	m_nBulletIconTextureX=232
	m_nBulletIconTextureY=229
	m_nClipIconTextureX=232
	m_nClipIconTextureY=203

	m_eWeaponType=WeaponPrimary
	MyMeleeDamageType=class'DamageUSGunButtMelee'

	DefaultAmmoCount(0)=240

	ZoomInAnim=aim_up
	ZoomOutAnim=aim_down
	SelectAnim=deploy
	PutDownAnim=holster
	PutDownAnimQuick=holster_short
	IdleAnim(0)=idle_01
	IdleAnim(1)=idle_02
	IdleAnim(2)=idle_03

	WeaponBoneName=rifle_hold

	ZoomFovMod=17.0000
	
	AmmoClipSize=20

	m_flPauseTimeExposed=0.6

	m_flEncumberance=1.0
	m_fCanSprint=true

	Desirability=2.0
	
	BreatheProfileClass=class'gbxHeavyBreatheProfile'

	nIconX=435
	nIconY=0
	nIconW=23
	nIconH=133

	WeaponName = WN_USBAR
	AmmoName = AM_US306Cal

	SelectAnimReadyDelay = 0.5
	PutDownAnimReadyDelay = 1.65
}
//=============================================================================
// WeapUSBazooka
//=============================================================================
class WeapUSBazooka extends WargameWeapon
    config(user);

simulated function LoadWeaponMesh()
{
	Mesh = Mesh( DynamicLoadObject( "k_view_weapons.view_bazooka", class'Mesh' ) );
	m_NormalViewMesh = Mesh( DynamicLoadObject( "k_view_weapons.view_bazooka", class'Mesh' ) );
	m_ZoomViewMesh = Mesh( DynamicLoadObject( "k_view_weapons.view_bazooka_crosshair", class'Mesh' ) );
	LinkMesh( Mesh );
	Super.LoadWeaponMesh();
}

function byte BestMode()
{
	return 0;
}

function bool IsRocketLauncher()
{
	return true;
}

defaultproperties
{
    ItemName="US Bazooka"

    FireModeClass(0)=FireUSBazooka
    FireModeClass(1)=FireSecondaryItem
    FireModeClass(2)=FireMelee
    InventoryGroup=2
//	Mesh=Mesh'k_view_weapons.view_bazooka'
//	m_NormalViewMesh=Mesh'k_view_weapons.view_bazooka'
//	m_ZoomViewMesh=Mesh'k_view_weapons.view_bazooka_crosshair'
	m_nCharacterBodyIdx=3
    BobDamping=0.5
    PickupClass=class'PickupWeapUSBazooka'
    EffectOffset=(X=130.0,Y=23.0,Z=-20.0)
	DisplayFOV=+50.0
    AttachmentClass=class'AttachmentUSBazooka'

    DrawScale=1.0
	PlayerViewOffset=(X=20.000,Y=0.000000,Z=-0.50000)
    SelectSound=None

	AIRating=+0.4
    CurrentRating=0.4

	// This icon no longer exists.
	//Icon=material'WG_HUD.HUD.wpn_garand'

//	m_aClipIcon=material'WG_HUD.HUD.clip_garand'
//	m_flBulletHeight=18
//	m_flClipHeight=128
//	m_flClipWidth=128
//	m_fClipFront=true
//	m_aFrontBulletIcon=material't_interface_mb.HUD.ammo_30cal'
//	m_aBackBulletIcon=material'WG_HUD.HUD.ammo_bullet_bck'
	m_nBulletIconTextureX=258
	m_nBulletIconTextureY=229
	m_nClipIconTextureX=258
	m_nClipIconTextureY=229

	m_eWeaponType=WeaponPrimary
	MyMeleeDamageType=class'DamageUSGunButtMelee'

	DefaultAmmoCount(0)=5

	ZoomInAnim=aim_up
	ZoomOutAnim=aim_down
	SelectAnim=deploy
	PutDownAnim=holster
	IdleAnim(0)=idle_01
	IdleAnim(1)=idle_02
	IdleAnim(2)=idle_03
	BreathingAnim=breathe

	AmmoClipSize=1

	m_flEncumberance=1.0
	m_fCanSprint=true

	BreatheProfileClass=class'gbxHeavyBreatheProfile'

	bDamagesVehicles=true
	
	nIconX=484
	nIconY=0
	nIconW=28
	nIconH=152
	
	bThrowGrenadeLeftHanded=true

	WeaponName = WN_USBazooka
	AmmoName = AM_Nothing
}
//=============================================================================
// WeapUSColt1911_
//=============================================================================
class WeapUSColt1911Baker extends WeapUSColt1911_;

defaultproperties
{
	Skins(0)=Texture'T_View_model_us.View_weapons.hand'
	Skins(1)=Texture'T_View_model_us.View_weapons.view_colt1911_father'
	Skins(2)=Texture'T_View_model_us.View_weapons.view_colt1911_father'

    PickupClass=class'PickupWeapUSColt1911Baker'
    AttachmentClass=class'AttachmentUSColt1911Baker'
}
//=============================================================================
// WeapUSColt1911_
//=============================================================================
class WeapUSColt1911_ extends WargameWeapon
    config(user);

simulated function LoadWeaponMesh()
{
	Mesh = Mesh( DynamicLoadObject( "k_view_weapons.view_colt1911", class'Mesh' ) );
	m_NormalViewMesh = Mesh( DynamicLoadObject( "k_view_weapons.view_colt1911", class'Mesh' ) );
	m_ZoomViewMesh = Mesh( DynamicLoadObject( "k_view_weapons.view_colt1911_crosshair", class'Mesh' ) );
	WeaponSkinOverride=Texture( DynamicLoadObject( "T_View_model_us.View_weapons.view_colt1911", class'Texture' ) );
	LinkMesh( Mesh );
	Super.LoadWeaponMesh();
}

function byte BestMode()
{
	return 0;
}

defaultproperties
{
    ItemName="US .45 Pistol"

    FireModeClass(0)=FireUSColt1911_
    FireModeClass(1)=FireSecondaryItem
    FireModeClass(2)=FireMelee
    InventoryGroup=2
//	Mesh=Mesh'k_view_weapons.view_colt1911'
//	m_NormalViewMesh=Mesh'k_view_weapons.view_colt1911'
//	m_ZoomViewMesh=Mesh'k_view_weapons.view_colt1911_crosshair'
	m_nCharacterBodyIdx=2
    BobDamping=0.5
    PickupClass=class'PickupWeapUSColt1911_'
    EffectOffset=(X=100.0,Y=25.0,Z=-10.0)
	DisplayFOV=+50.0
    AttachmentClass=class'AttachmentUSColt1911_'

    DrawScale=1.0
	PlayerViewOffset=(X=20.000,Y=0.000000,Z=-0.50000)
    SelectSound=None

	AIRating=+0.4
    CurrentRating=0.4

	// This icon no longer exists.
	//Icon=material'WG_HUD.HUD.wpn_garand'

//	m_aClipIcon=material'WG_HUD.HUD.clip_garand'
//	m_flBulletHeight=18
//	m_flClipHeight=128
//	m_flClipWidth=128
//	m_fClipFront=true
//	m_aFrontBulletIcon=material't_interface_mb.HUD.ammo_45cal'
//	m_aBackBulletIcon=material'WG_HUD.HUD.ammo_bullet_bck'
	m_nBulletIconTextureX=232
	m_nBulletIconTextureY=229
	m_nClipIconTextureX=232
	m_nClipIconTextureY=177

	m_eWeaponType=WeaponPrimary
	MyMeleeDamageType=class'DamageUSGunButtMelee'

	DefaultAmmoCount(0)=84

	ZoomInAnim=aim_up
	ZoomOutAnim=aim_down
	SelectAnim=deploy
	PutDownAnim=holster
	IdleAnim(0)=idle_01
	IdleAnim(1)=idle_02
	IdleAnim(2)=idle_03

	ZoomFovMod = 10.0000

	AmmoClipSize=7

	m_flEncumberance=1.0
	m_fCanSprint=true

	WeaponBoneName=pistol_hold

	BreatheProfileClass=class'gbxPistolBreatheProfile'
	
	nIconX=217
	nIconY=52
	nIconW=33
	nIconH=49

	m_fZoomHasHands=true
}
//=============================================================================
// US M10 Tank turret-mounted machine gun.
//=============================================================================
class WeapUSM10_50cal extends WeapUSUsableMachineGun
	config(User);


simulated function LoadWeaponMesh()
{
	Mesh = Mesh( DynamicLoadObject( "k_view_weapons.view_50cal_crosshair", class'Mesh' ) );
	LinkMesh( Mesh );
	Super.LoadWeaponMesh();
}

//---------------------------------------------------------
//	Tick
//---------------------------------------------------------
function Tick( float DeltaTime )
{
	local gbxMuzzleFlash MuzFlash;

	Super.Tick( DeltaTime );

	if (MyGunner == None)
	{
		if ((FireMode[0] != None) && FireMode[0].bIsFiring)
			StopFiringWeapon();

		return;
	}

	// Hide the muzzle flash if in first-person mode because we only want 
	// to render it during PostRender().
	MuzFlash = gbxMuzzleFlash( FireUSM10_50cal( FireMode[0] ).GetMuzzleFlash() );

	if ( m_fZoomed )
		MuzFlash.bHidden = true;
	else
		MuzFlash.bHidden = false;

	if ( FireMode[0] != None )
	{
		if ( FireMode[0].bIsFiring && !bWeaponFiring )
		{
			StartFiringWeapon();
		}
		else if ( !FireMode[0].bIsFiring && bWeaponFiring )
		{
			StopFiringWeapon();
		}
	}
}

function vector GetPlayerMountPoint(gbxPawn gbxP)
{
	local vector MountPoint;
	local vector RotX, RotY, RotZ;

	GetAxes(MyTankPawn.Rotation, RotX, RotY, RotZ);

	if (bIsRearTrigger)
	{
		gbxP.SetTurretAnims( 'M10_player_mount_gun', 'M10_player_dismount_gun' );
		MountPoint = MyTankPawn.Location + (MountAnimStartOffset.X * RotX + MountAnimStartOffset.Y * RotY + MountAnimStartOffset.Z * RotZ);
	}
	else
	{
		gbxP.SetTurretAnims( 'M10_player_remount_gun', 'M10_player_dismount_gun' );
		MountPoint = MyTankPawn.Location + (GunnerOffsetStanding.X * RotX + GunnerOffsetStanding.Y * RotY + GunnerOffsetStanding.Z * RotZ);
	}

	return MountPoint;
}

//---------------------------------------------------------
//	GetAimRot
//---------------------------------------------------------
function Rotator GetAimRot()
{
	return FireUSM10_50cal(FireMode[0]).AimRot;
}

//---------------------------------------------------------
//	StartFiringWeapon
//---------------------------------------------------------
function StartFiringWeapon()
{
	if (bAimingAtFriendly && Instigator.IsA('gbxPawn'))
	{
		bFiringAtFriendly = true;
	}
	
	if ( bWeaponFiring )
		return;

	if (bIsMounting || bIsDismounting)
		return;

	// RSC: dont fire if we are issuing a command
	if( !Instigator.Controller.AllowFire() )
		return;

	if ( m_fZoomed )
	{
		FireLoopSoundHandle = PlaySound( StereoFireLoopSound, SLOT_None, TransientSoundVolume,,,,false);
	}
	else
	{
		FireLoopSoundHandle = PlaySound( FireLoopSound, SLOT_WeaponFire1, TransientSoundVolume,,,,true);
	}

	if ( FireMode[0].IsA( 'FireUSM10_50cal' ) )
		FireUSM10_50cal( FireMode[0] ).StartFiringWeapon();

	if ( m_fZoomed )
		LoopAnim( 'Fire', 1.0, 0.0 );

	Super.StartFiringWeapon();

	bWeaponFiring = true;
}

//---------------------------------------------------------
//	StopFiringWeapon
//---------------------------------------------------------
function StopFiringWeapon()
{
	if ( FireMode[0].IsA( 'FireUSM10_50cal' ) )
		FireUSM10_50cal( FireMode[0] ).StopFiringWeapon();

	if ( !bWeaponFiring )
		return;

	if (FireLoopSoundHandle != 0)
	{
		StopSound( FireLoopSoundHandle );
		FireLoopSoundHandle = 0;
	}

	if ( m_fZoomed )
	{
		PlaySound( StereoFireOneBulletSound, SLOT_NONE, TransientSoundVolume,,,,false);
	}
	else
	{
		PlaySound( FireOneBulletSound, SLOT_WeaponFire1, TransientSoundVolume,,,,true);
	}

	if ( m_fZoomed )
		PlayAnim( 'Idle', 1.0 );

	Super.StopFiringWeapon();

	bWeaponFiring = false;
}

//---------------------------------------------------------
//	FlashMuzzleFlash
//---------------------------------------------------------
// For 3rd person only.  See PostRender() in this class for 1st person muzzle flashes.
simulated function FlashMuzzleFlash()
{
	local gbxMuzzleFlash MuzFlash;

	if ( MyGunner == None )
		return;

	if (bIsMounting || bIsDismounting)
		return;

	if ( FireMode[0].IsA( 'FireUSM10_50cal' ) )
	{
		MuzFlash = gbxMuzzleFlash( FireUSM10_50cal( FireMode[0] ).GetMuzzleFlash() );

		if ( m_fZoomed )
		{
			MuzFlash.bHidden = true;		// PostRender() will unhide it and render it.
			MuzFlash.Flash();
		}
		else
		{
			MuzFlash.SetLocation( GetMuzzleLocationWorld() );
			MuzFlash.SetRotation( Rotation );
			MuzFlash.Flash();
		}
	}
}

//---------------------------------------------------------
//	GetAttachment
//---------------------------------------------------------
function AttachmentUSM10_50cal GetAttachment()
{
	return AttachmentUSM10_50cal( ThirdPersonActor );
}

//---------------------------------------------------------
//	PostRender
//---------------------------------------------------------
function PostRender( Canvas TheCanvas )
{
	local gbxMuzzleFlash MuzFlash;

	if ( m_fZoomed )
	{		
		MuzFlash = gbxMuzzleFlash( FireUSM10_50cal( FireMode[0] ).GetMuzzleFlash() );
		if ( MuzFlash != None )
		{
			MuzFlash.bHidden = false;
			MuzFlash.SetLocation( GetMuzzleLocationWorld() );			
			MuzFlash.SetRotation( Rotation );			
			TheCanvas.DrawActor( MuzFlash, 50 );			
		}
		TheCanvas.DrawActor(self, DisplayFOV);		

		CalcOffsetWeaponCollision();
	}	
}

function bool AlwaysAutoReload()
{
	return true;
}

//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
	DrawType=DT_Mesh
	ItemName="US M10 50cal"

	GunBoneName="50cal_muzzle"

	MyMountAction=Mount_MountTankM10_50cal
	MyDismountAction=Mount_DismountTankM10_50cal

	FireModeClass(0)=FireUSM10_50cal
	FireModeClass(1)=FireUSM10_50cal
	AttachmentClass=class'AttachmentUSM10_50cal'

	DefaultAmmoCount(0)=400

	// Nine-point blending animations.
	PawnForwardDownAnim="M10_player_forward_down"
	PawnForwardLevelAnim="M10_player_forward_level"
	PawnForwardUpAnim="M10_player_forward_up"
	PawnLeftDownAnim="M10_player_left_down"
	PawnLeftLevelAnim="M10_player_left_level"
	PawnLeftUpAnim="M10_player_left_up"
	PawnRightDownAnim="M10_player_right_down"
	PawnRightLevelAnim="M10_player_right_level"
	PawnRightUpAnim="M10_player_right_up"

	FireLoopSoundName="W_30CAL.Loop"
	FireOneBulletSoundName="W_30CAL.End"
	StereoFireLoopSoundName="W_30CAL.LOOP_ST"
	StereoFireOneBulletSoundName="W_30CAL.END_ST"

	MaxRotSpeed=600.0

	GunnerOffset=(X=-210,Y=0,Z=92)
	GunnerOffsetStanding=(X=-225,Y=0,Z=150)

	MountAnimStartOffset=(X=-335.0,Y=130,Z=-38.0)

	CameraRearZoomTime=3.0
	CameraTurretZoomTime=1.0
	CameraTurretZoomHeadTime=1.1
	CameraRearStartOffset=(X=-300.0,Y=0.0,Z=300.0)
	CameraTurretStartOffset=(X=-60.0,Y=0.0,Z=0.0)
	CameraEndOffset=(X=-500,Y=0.0,Z=200.0)

	CameraOffsetZoomed=(X=-38.5,Y=0.1,Z=0.92)

	HorizCosTheta=0.7547096  // 41 degrees (instead of 40 degrees)
	VertCosTheta=0.1305262  // 7.5 degrees (instead of 8.0 degrees)

	HorizFieldUU=7281
	VertFieldUU=1457
	ThirdPersonHorizFieldUU=12000
	ThirdPersonVertFieldUpUU=3000
	ThirdPersonVertFieldDownUU=5461
	CameraPitchUU=2000

	ClientState=WS_Hidden

	AmmoClipSize=400

	MuzzleOffset=(X=50,Y=0,Z=0)
	MuzzleOffset3rdPerson=(X=10,Y=5,Z=0)
}
class WeapUSM1919_ extends WeapDEMG42_;

simulated function LoadWeaponMesh()
{
	Mesh = Mesh( DynamicLoadObject( "k_view_weapons.view_30cal_crosshair", class'Mesh' ) );
	LinkMesh( Mesh );
	Super.LoadWeaponMesh();
}

defaultproperties
{
	ItemName="U.S. M1919 30 Caliber Machinegun"

	FireModeClass(0)=FireUSM1919_
	FireModeClass(1)=FireUSM1919_
	AttachmentClass=class'AttachmentUSM1919_'

	FireLoopSoundName="W_30CAL.Loop"
	FireOneBulletSoundName="W_30CAL.End"

	StereoFireLoopSoundName="W_30CAL.LOOP_ST"
	StereoFireOneBulletSoundName="W_30CAL.END_ST"

	// Nine-point blending animations.
	//PawnMountAnim=30cal_mount
	//PawnDismountAnim=30cal_dismount	

	PlayerMountAnim=30cal_player_mount
	PlayerDismountAnim=30cal_player_dismount

	PawnForwardDownAnim=30cal_forward_down
	PawnForwardLevelAnim=30cal_forward_level
	PawnForwardUpAnim=30cal_forward_up
	PawnLeftDownAnim=30cal_left_down
	PawnLeftLevelAnim=30cal_left_level
	PawnLeftUpAnim=30cal_left_up
	PawnRightDownAnim=30cal_right_down
	PawnRightLevelAnim=30cal_right_level
	PawnRightUpAnim=30cal_right_up	
	
	CameraDismountedOffset=(X=25.0,Y=0.0,Z=85.0)
	CameraOffsetZoomed=(X=-38.5,Y=0,Z=0.92)

	HorizCosTheta=1.075
	VertCosTheta=0.525

	GunnerOffset=(X=-10,Y=0,Z=30)

	//HorizFieldUU=12470
	//VertFieldUU=3640

	MyMountAction=Mount_Mount30CalGunner
	MyDismountAction=Mount_Dismount30CalGunner

	WeaponName = WN_USColt1911
	AmmoName = AM_US45Cal

	bOpaqueForSituationalAwarenessView=true
}//=============================================================================
// WeapUSM1Carbine
//=============================================================================
class WeapUSM1Carbine extends WargameWeapon
    config(user);

simulated function LoadWeaponMesh()
{
	Mesh = Mesh( DynamicLoadObject( "k_view_weapons.view_m1_carbine", class'Mesh' ) );
	m_NormalViewMesh = Mesh( DynamicLoadObject( "k_view_weapons.view_m1_carbine", class'Mesh' ) );
	m_ZoomViewMesh = Mesh( DynamicLoadObject( "k_view_weapons.view_m1_carbine_crosshair", class'Mesh' ) );
	LinkMesh( Mesh );
	Super.LoadWeaponMesh();
}

function byte BestMode()
{
	return 0;
}

defaultproperties
{
    ItemName="US M1 Carbine Rifle"

    FireModeClass(0)=FireUSM1Carbine
    FireModeClass(1)=FireSecondaryItem
    FireModeClass(2)=FireMelee
    InventoryGroup=2
//	Mesh=Mesh'k_view_weapons.view_m1_carbine'
//	m_NormalViewMesh=Mesh'k_view_weapons.view_m1_carbine'
//	m_ZoomViewMesh=Mesh'k_view_weapons.view_m1_carbine_crosshair'
	m_nCharacterBodyIdx=3
    BobDamping=0.5
    PickupClass=class'PickupWeapUSM1Carbine'
    EffectOffset=(X=130.0,Y=23.0,Z=-20.0)
	DisplayFOV=+50.0
    AttachmentClass=class'AttachmentUSM1Carbine'

    DrawScale=1.0
	PlayerViewOffset=(X=20.000,Y=0.000000,Z=-0.50000)
    SelectSound=None

	AIRating=+0.4
    CurrentRating=0.4

	// This icon no longer exists.
	//Icon=material'WG_HUD.HUD.wpn_garand'

//	m_aClipIcon=material'WG_HUD.HUD.clip_garand'
//	m_flBulletHeight=18
//	m_flClipHeight=128
//	m_flClipWidth=128
//	m_fClipFront=true
//	m_aFrontBulletIcon=material't_interface_mb.HUD.ammo_30cal'
//	m_aBackBulletIcon=material'WG_HUD.HUD.ammo_bullet_bck'
	m_nBulletIconTextureX=258
	m_nBulletIconTextureY=177
	m_nClipIconTextureX=486
	m_nClipIconTextureY=160

	m_eWeaponType=WeaponPrimary
	MyMeleeDamageType=class'DamageUSGunButtMelee'

	DefaultAmmoCount(0)=75

	ZoomInAnim=aim_up
	ZoomOutAnim=aim_down
	SelectAnim=deploy
	PutDownAnim=holster
	PutDownAnimQuick=holster_short
	IdleAnim(0)=idle_01
	IdleAnim(1)=idle_02
	IdleAnim(2)=idle_03
	BreathingAnim=breathe

	AmmoClipSize=15

	m_flEncumberance=1.0
	m_fCanSprint=true

	BreatheProfileClass=class'gbxLightBreatheProfile'
	
	nIconX=312
	nIconY=0
	nIconW=22
	nIconH=99
	
	WeaponName = WN_USM1Carbine
	AmmoName = AM_US30Cal

	SelectAnimReadyDelay = 0.5
	PutDownAnimReadyDelay = 1.25
}
//=============================================================================
// WeapUSM1_
//=============================================================================
class WeapUSM1_ extends WargameWeapon
    config(user);

simulated function LoadWeaponMesh()
{
	Mesh = Mesh( DynamicLoadObject( "k_view_weapons.view_m1", class'Mesh' ) );
	m_NormalViewMesh = Mesh( DynamicLoadObject( "k_view_weapons.view_m1", class'Mesh' ) );
	m_ZoomViewMesh = Mesh( DynamicLoadObject( "k_view_weapons.view_m1_crosshair", class'Mesh' ) );
	LinkMesh( Mesh );
	Super.LoadWeaponMesh();
}

function byte BestMode()
{
	return 0;
}

defaultproperties
{
    ItemName="US M1 Rifle"

    FireModeClass(0)=FireUSM1_
    FireModeClass(1)=FireSecondaryItem
    FireModeClass(2)=FireMelee
    InventoryGroup=2
//	Mesh=Mesh'k_view_weapons.view_m1'
//	m_NormalViewMesh=Mesh'k_view_weapons.view_m1'
//	m_ZoomViewMesh=Mesh'k_view_weapons.view_m1_crosshair'
	m_nCharacterBodyIdx=3
    BobDamping=0.5
    PickupClass=class'PickupWeapUSM1_'
    EffectOffset=(X=130.0,Y=23.0,Z=-20.0)
	DisplayFOV=+50.0
    AttachmentClass=class'AttachmentUSM1_'

    DrawScale=1.0
	PlayerViewOffset=(X=20.000,Y=0.000000,Z=-0.50000)
    SelectSound=None

	AIRating=+0.4
    CurrentRating=0.4

	// This icon no longer exists.
	//Icon=material'WG_HUD.HUD.wpn_garand'

//	m_aClipIcon=material'WG_HUD.HUD.clip_garand'
//	m_flBulletHeight=18
//	m_flClipHeight=128
//	m_flClipWidth=128
//	m_fClipFront=true
//	m_aFrontBulletIcon=material't_interface_mb.HUD.ammo_30cal'
//	m_aBackBulletIcon=material'WG_HUD.HUD.ammo_bullet_bck'
	m_nBulletIconTextureX=258
	m_nBulletIconTextureY=177
	m_nClipIconTextureX=206
	m_nClipIconTextureY=177

	m_eWeaponType=WeaponPrimary
	MyMeleeDamageType=class'DamageUSGunButtMelee'

	DefaultAmmoCount(0)=88

	ZoomInAnim=aim_up
	ZoomOutAnim=aim_down
	SelectAnim=deploy
	PutDownAnim=holster
	PutDownAnimQuick=holster_short
	IdleAnim(0)=idle_01
	IdleAnim(1)=idle_02
	IdleAnim(2)=idle_03
	BreathingAnim=breathe

	AmmoClipSize=8

	m_flEncumberance=1.0
	m_fCanSprint=true

	BreatheProfileClass=class'gbxMediumBreatheProfile'
	
	nIconX=385
	nIconY=0
	nIconW=24
	nIconH=122

	WeaponName = WN_USM1
	AmmoName = AM_US306Cal

	SelectAnimReadyDelay = 0.5
	PutDownAnimReadyDelay = 1.25
}//=============================================================================
// WeapUSM1_
//=============================================================================
class WeapUSM3A1_ extends WargameWeapon
    config(user);

simulated function LoadWeaponMesh()
{
	Mesh = Mesh( DynamicLoadObject( "k_view_weapons.view_m3a1", class'Mesh' ) );
	m_NormalViewMesh = Mesh( DynamicLoadObject( "k_view_weapons.view_m3a1", class'Mesh' ) );
	m_ZoomViewMesh = Mesh( DynamicLoadObject( "k_view_weapons.view_m3a1_crosshair", class'Mesh' ) );
	LinkMesh( Mesh );
	Super.LoadWeaponMesh();
}

function byte BestMode()
{
	return 0;
}

defaultproperties
{
    ItemName="US M3A1 Sub-Machine Gun"

    FireModeClass(0)=FireUSM3A1_
    FireModeClass(1)=FireSecondaryItem
    FireModeClass(2)=FireMelee
    InventoryGroup=2
//	Mesh=Mesh'k_view_weapons.view_m3a1'
//	m_NormalViewMesh=Mesh'k_view_weapons.view_m3a1'
//	m_ZoomViewMesh=Mesh'k_view_weapons.view_m3a1_crosshair'
	m_nCharacterBodyIdx=4
    BobDamping=0.5
    PickupClass=class'PickupWeapUSM3A1_'
    EffectOffset=(X=120.0,Y=20.0,Z=-18.0)
	DisplayFOV=+50.0
    AttachmentClass=class'AttachmentUSM3A1_'

    DrawScale=1.0
	PlayerViewOffset=(X=20.000,Y=0.000000,Z=-0.50000)
    SelectSound=None

	AIRating=+0.4
    CurrentRating=0.4

	// This icon no longer exists.
	//Icon=material'WG_HUD.HUD.wpn_garand'

//	m_aClipIcon=material'WG_HUD.HUD.clip_garand'
//	m_flBulletHeight=18
//	m_flClipHeight=128
//	m_flClipWidth=128
//	m_fClipFront=true
//	m_aFrontBulletIcon=material't_interface_mb.HUD.ammo_45cal'
//	m_aBackBulletIcon=material'WG_HUD.HUD.ammo_bullet_bck'
	m_nBulletIconTextureX=232
	m_nBulletIconTextureY=229
	m_nClipIconTextureX=206
	m_nClipIconTextureY=229

	m_eWeaponType=WeaponPrimary
	MyMeleeDamageType=class'DamageUSGunButtMelee'

	DefaultAmmoCount(0)=210

	ZoomInAnim=aim_up
	ZoomOutAnim=aim_down
	SelectAnim=deploy
	PutDownAnim=holster
	PutDownAnimQuick=holster_short
	IdleAnim(0)=idle_01
	IdleAnim(1)=idle_02
	IdleAnim(2)=idle_03

	WeaponBoneName=rifle_hold

	ZoomFovMod=17.0000

	m_flPauseTimeExposed=0.7

	AmmoClipSize=30

	m_flEncumberance=1.0
	m_fCanSprint=true
	m_bIsAutomatic=true

	Desirability=1.5

	BreatheProfileClass=class'gbxMediumBreatheProfile'
	
	Icon=material't_interface_mb.HUD.training_art'
	nIconX=29
	nIconY=47
	nIconW=36
	nIconH=81

	WeaponName = WN_USM3A1
	AmmoName = AM_US45Cal

	SelectAnimReadyDelay = 0.5
	PutDownAnimReadyDelay = 1.25
	PutDownAnimQuickReadyDelay = 1.20
}
//=============================================================================
// US Sherman Tank turret-mounted machine gun.
//=============================================================================
class WeapUSSherman50cal extends WeapUSUsableMachineGun
	config(User);


simulated function LoadWeaponMesh()
{
	Mesh = Mesh( DynamicLoadObject( "k_view_weapons.view_50cal_crosshair", class'Mesh' ) );
	LinkMesh( Mesh );
	Super.LoadWeaponMesh();
}

//---------------------------------------------------------
//	Tick
//---------------------------------------------------------
function Tick( float DeltaTime )
{
	local gbxMuzzleFlash MuzFlash;

	Super.Tick( DeltaTime );

	if (MyGunner == None)
	{
		if ((FireMode[0] != None) && FireMode[0].bIsFiring)
			StopFiringWeapon();

		return;
	}

	// Hide the muzzle flash if in first-person mode because we only want 
	// to render it during PostRender().
	MuzFlash = gbxMuzzleFlash( FireUSSherman50cal( FireMode[0] ).GetMuzzleFlash() );

	if ( m_fZoomed )
		MuzFlash.bHidden = true;
	else
		MuzFlash.bHidden = false;

	if ( FireMode[0] != None )
	{
		if ( FireMode[0].bIsFiring && !bWeaponFiring )
		{
			StartFiringWeapon();
		}
		else if ( !FireMode[0].bIsFiring && bWeaponFiring )
		{
			StopFiringWeapon();
		}
	}
}

function vector GetPlayerMountPoint(gbxPawn gbxP)
{
	local vector MountPoint;
	local vector RotX, RotY, RotZ;

	GetAxes(MyTankPawn.Rotation, RotX, RotY, RotZ);

	if (bIsRearTrigger)
	{
		gbxP.SetTurretAnims( 'Sherman_player_mount_gun', 'Sherman_player_dismount_gun' );
		MountPoint = MyTankPawn.Location + (MountAnimStartOffset.X * RotX + MountAnimStartOffset.Y * RotY + MountAnimStartOffset.Z * RotZ);
	}
	else
	{
		gbxP.SetTurretAnims( 'Sherman_player_remount_gun', 'Sherman_player_dismount_gun' );
		MountPoint = MyTankPawn.Location + (GunnerOffsetStanding.X * RotX + GunnerOffsetStanding.Y * RotY + GunnerOffsetStanding.Z * RotZ);
	}

	return MountPoint;
}

//---------------------------------------------------------
//	GetAimRot
//---------------------------------------------------------
function Rotator GetAimRot()
{
	return FireUSSherman50cal(FireMode[0]).AimRot;
}

//---------------------------------------------------------
//	StartFiringWeapon
//---------------------------------------------------------
function StartFiringWeapon()
{
	if (bAimingAtFriendly && Instigator.IsA('gbxPawn'))
	{
		bFiringAtFriendly = true;
	}
	
	if ( bWeaponFiring )
		return;

	if (bIsMounting || bIsDismounting)
		return;

	// RSC: dont fire if we are issuing a command
	if( !Instigator.Controller.AllowFire() )
		return;

	if ( m_fZoomed )
	{
		FireLoopSoundHandle = PlaySound( StereoFireLoopSound, SLOT_None, TransientSoundVolume,,,,false);
	}
	else
	{
		FireLoopSoundHandle = PlaySound( FireLoopSound, SLOT_WeaponFire1, TransientSoundVolume,,,,true);
	}

	if ( FireMode[0].IsA( 'FireUSSherman50cal' ) )
		FireUSSherman50cal( FireMode[0] ).StartFiringWeapon();

	if ( m_fZoomed )
		LoopAnim( 'Fire', 1.0, 0.0 );

	Super.StartFiringWeapon();

	bWeaponFiring = true;
}

//---------------------------------------------------------
//	StopFiringWeapon
//---------------------------------------------------------
function StopFiringWeapon()
{
	if ( FireMode[0].IsA( 'FireUSSherman50cal' ) )
		FireUSSherman50cal( FireMode[0] ).StopFiringWeapon();

	if ( !bWeaponFiring )
		return;

	if (FireLoopSoundHandle != 0)
	{
		StopSound( FireLoopSoundHandle );
		FireLoopSoundHandle = 0;
	}

	if ( m_fZoomed )
	{
		PlaySound( StereoFireOneBulletSound, SLOT_NONE, TransientSoundVolume,,,,false);
	}
	else
	{
		PlaySound( FireOneBulletSound, SLOT_WeaponFire1, TransientSoundVolume,,,,true);
	}

	if ( m_fZoomed )
		PlayAnim( 'Idle', 1.0 );

	Super.StopFiringWeapon();

	bWeaponFiring = false;
}

//---------------------------------------------------------
//	FlashMuzzleFlash
//---------------------------------------------------------
// For 3rd person only.  See PostRender() in this class for 1st person muzzle flashes.
simulated function FlashMuzzleFlash()
{
	local gbxMuzzleFlash MuzFlash;

	if ( MyGunner == None )
		return;

	if (bIsMounting || bIsDismounting)
		return;

	if ( FireMode[0].IsA( 'FireUSSherman50cal' ) )
	{
		MuzFlash = gbxMuzzleFlash( FireUSSherman50cal( FireMode[0] ).GetMuzzleFlash() );

		if ( m_fZoomed )
		{
			MuzFlash.bHidden = true;		// PostRender() will unhide it and render it.
			MuzFlash.Flash();
		}
		else
		{
			MuzFlash.SetLocation( GetMuzzleLocationWorld() );
			MuzFlash.SetRotation( Rotation );
			MuzFlash.Flash();
		}
	}
}

//---------------------------------------------------------
//	GetAttachment
//---------------------------------------------------------
function AttachmentUSSherman50cal GetAttachment()
{
	return AttachmentUSSherman50cal( ThirdPersonActor );
}

//---------------------------------------------------------
//	PostRender
//---------------------------------------------------------
function PostRender( Canvas TheCanvas )
{
	local gbxMuzzleFlash MuzFlash;

	if ( m_fZoomed )
	{		
		MuzFlash = gbxMuzzleFlash( FireUSSherman50cal( FireMode[0] ).GetMuzzleFlash() );
		if ( MuzFlash != None )
		{
			MuzFlash.bHidden = false;
			MuzFlash.SetLocation( GetMuzzleLocationWorld() );			
			MuzFlash.SetRotation( Rotation );			
			TheCanvas.DrawActor( MuzFlash, 50 );			
		}
		TheCanvas.DrawActor(self, DisplayFOV);		

		CalcOffsetWeaponCollision();
	}	
}

function bool AlwaysAutoReload()
{
	return true;
}

//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
	DrawType=DT_Mesh
	ItemName="US Sherman 50cal"

	GunBoneName="50cal"

	MyMountAction=Mount_MountTankSherman50cal
	MyDismountAction=Mount_DismountTankSherman50cal

	FireModeClass(0)=FireUSSherman50cal
	FireModeClass(1)=FireUSSherman50cal
	AttachmentClass=class'AttachmentUSSherman50cal'

	DefaultAmmoCount(0)=400

	// Nine-point blending animations.
	PawnForwardDownAnim="Sherman_forward_down"
	PawnForwardLevelAnim="Sherman_forward_level"
	PawnForwardUpAnim="Sherman_forward_up"
	PawnLeftDownAnim="Sherman_left_down"
	PawnLeftLevelAnim="Sherman_left_level"
	PawnLeftUpAnim="Sherman_left_up"
	PawnRightDownAnim="Sherman_right_down"
	PawnRightLevelAnim="Sherman_right_level"
	PawnRightUpAnim="Sherman_right_up"

	FireLoopSoundName="W_30CAL.Loop"
	FireOneBulletSoundName="W_30CAL.End"
	StereoFireLoopSoundName="W_30CAL.LOOP_ST"
	StereoFireOneBulletSoundName="W_30CAL.END_ST"

	MaxRotSpeed=600.0

	GunnerOffset=(X=-190,Y=33,Z=94)
	GunnerOffsetStanding=(X=-187,Y=34,Z=140)

	MountAnimStartOffset=(X=-277.0,Y=162.0,Z=-40.0)

	CameraRearZoomTime=3.0
	CameraTurretZoomTime=1.0
	CameraTurretZoomHeadTime=1.1
	CameraRearStartOffset=(X=-200.0,Y=0.0,Z=300.0)
	CameraTurretStartOffset=(X=-40.0,Y=0.0,Z=0.0)
	CameraEndOffset=(X=-500,Y=0.0,Z=200.0)

	CameraOffsetZoomed=(X=-38.5,Y=0.1,Z=0.92)

	HorizCosTheta=0.7547096  // 41 degrees (instead of 40 degrees)
	VertCosTheta=0.1305262  // 7.5 degrees (instead of 8.0 degrees)

	HorizFieldUU=7281
	VertFieldUU=1457
	ThirdPersonHorizFieldUU=12000
	ThirdPersonVertFieldUpUU=3000
	ThirdPersonVertFieldDownUU=5461
	CameraPitchUU=2000

	ClientState=WS_Hidden

	AmmoClipSize=400

	MuzzleOffset=(X=50,Y=0,Z=3)
	MuzzleOffset3rdPerson=(X=15,Y=5,Z=0)
}
//=============================================================================
// WeapUSSpringfield
//=============================================================================
class WeapUSSpringfield extends WargameWeapon
    config(user);

simulated function LoadWeaponMesh()
{
	Mesh = Mesh( DynamicLoadObject( "k_view_weapons.view_springfield", class'Mesh' ) );
	m_NormalViewMesh = Mesh( DynamicLoadObject( "k_view_weapons.view_springfield", class'Mesh' ) );
	m_ZoomViewMesh = Mesh( DynamicLoadObject( "k_view_weapons.view_springfield_crosshair", class'Mesh' ) );
	LinkMesh( Mesh );
	Super.LoadWeaponMesh();
}

function byte BestMode()
{
	return 0;
}

defaultproperties
{
    ItemName="US M1903 Bolt-Action Rifle"

    FireModeClass(0)=FireUSSpringfield
    FireModeClass(1)=FireSecondaryItem
    FireModeClass(2)=FireMelee
    InventoryGroup=2
//	Mesh=Mesh'k_view_weapons.view_springfield'
//	m_NormalViewMesh=Mesh'k_view_weapons.view_springfield'
//	m_ZoomViewMesh=Mesh'k_view_weapons.view_springfield_crosshair'
	m_nCharacterBodyIdx=3
    BobDamping=0.5
    PickupClass=class'PickupWeapUSSpringfield'
    EffectOffset=(X=130.0,Y=23.0,Z=-20.0)
	DisplayFOV=+50.0
    AttachmentClass=class'AttachmentUSSpringfield'

    DrawScale=1.0
	PlayerViewOffset=(X=20.000,Y=0.000000,Z=-0.50000)
    SelectSound=None

	AIRating=+0.4
    CurrentRating=0.4

	// This icon no longer exists.
	//Icon=material'WG_HUD.HUD.wpn_garand'

//	m_aClipIcon=material'WG_HUD.HUD.clip_garand'
//	m_flBulletHeight=18
//	m_flClipHeight=128
//	m_flClipWidth=128
//	m_fClipFront=true
//	m_aFrontBulletIcon=material't_interface_mb.HUD.ammo_30cal'
//	m_aBackBulletIcon=material'WG_HUD.HUD.ammo_bullet_bck'
	m_nBulletIconTextureX=258
	m_nBulletIconTextureY=177
	m_nClipIconTextureX=206
	m_nClipIconTextureY=203

	m_eWeaponType=WeaponPrimary
	MyMeleeDamageType=class'DamageUSGunButtMelee'

	DefaultAmmoCount(0)=55

	ZoomFovMod=55.0000

	ZoomInAnim=aim_up
	ZoomOutAnim=aim_down
	SelectAnim=deploy
	PutDownAnim=holster
	PutDownAnimQuick=holster_short
	IdleAnim(0)=idle_01
	IdleAnim(1)=idle_02
	IdleAnim(2)=idle_03
	BreathingAnim=breathe

	AmmoClipSize=5

	m_flEncumberance=1.0
	m_fCanSprint=true

	BreatheProfileClass=class'gbxSniperBreatheProfile'
	
	nIconX=409
	nIconY=0
	nIconW=26
	nIconH=122

	WeaponName = WN_USSpringfield
	AmmoName = AM_US306Cal

	SelectAnimReadyDelay = 0.5
	PutDownAnimReadyDelay = 1.25
}
//=============================================================================
// US Stuart Tank turret-mounted machine gun.
//=============================================================================
class WeapUSStuart30cal extends WeapUSUsableMachineGun
	config(User);


simulated function LoadWeaponMesh()
{
	Mesh = Mesh( DynamicLoadObject( "k_view_weapons.view_30cal_crosshair", class'Mesh' ) );
	LinkMesh( Mesh );
	Super.LoadWeaponMesh();
}

//---------------------------------------------------------
//	Tick
//---------------------------------------------------------
function Tick( float DeltaTime )
{
	local gbxMuzzleFlash MuzFlash;

	Super.Tick( DeltaTime );

	if (MyGunner == None || bIsDismounting)
	{
		if ((FireMode[0] != None) && FireMode[0].bIsFiring)
			StopFiringWeapon();

		return;
	}

	// Hide the muzzle flash if in first-person mode because we only want 
	// to render it during PostRender().
	MuzFlash = gbxMuzzleFlash( FireUSStuart30cal( FireMode[0] ).GetMuzzleFlash() );

	if ( m_fZoomed )
		MuzFlash.bHidden = true;
	else
		MuzFlash.bHidden = false;

	if ( FireMode[0] != None )
	{
		if ( FireMode[0].bIsFiring && !bWeaponFiring && !bIsDismounting )
		{
			StartFiringWeapon();
		}
		else if ( !FireMode[0].bIsFiring && bWeaponFiring )
		{
			StopFiringWeapon();
		}
	}
}

function vector GetPlayerMountPoint(gbxPawn gbxP)
{
	local vector MountPoint;
	local vector RotX, RotY, RotZ;

	GetAxes(MyTankPawn.Rotation, RotX, RotY, RotZ);

	if (bIsRearTrigger)
	{
		gbxP.SetTurretAnims( 'Stuart_player_mount_gun', 'Stuart_player_dismount_gun' );
		MountPoint = MyTankPawn.Location + (MountAnimStartOffset.X * RotX + MountAnimStartOffset.Y * RotY + MountAnimStartOffset.Z * RotZ);
	}
	else
	{
		gbxP.SetTurretAnims( 'Stuart_player_remount_gun', 'Stuart_player_dismount_gun' );
		MountPoint = MyTankPawn.Location + (GunnerOffsetStanding.X * RotX + GunnerOffsetStanding.Y * RotY + GunnerOffsetStanding.Z * RotZ);
	}

	return MountPoint;
}

//---------------------------------------------------------
//	GetAimRot
//---------------------------------------------------------
function Rotator GetAimRot()
{
	return FireUSStuart30cal(FireMode[0]).AimRot;
}

//---------------------------------------------------------
//	StartFiringWeapon
//---------------------------------------------------------
function StartFiringWeapon()
{
	if (bAimingAtFriendly && Instigator.IsA('gbxPawn'))
	{
		bFiringAtFriendly = true;
	}
	
	if ( bWeaponFiring || bIsDismounting )
		return;

	if (bIsMounting || bIsDismounting)
		return;

	// RSC: dont fire if we are issuing a command
	if( !Instigator.Controller.AllowFire() )
		return;

	if ( m_fZoomed )
	{
		FireLoopSoundHandle = PlaySound( StereoFireLoopSound, SLOT_None, TransientSoundVolume,,,,false);
	}
	else
	{
		FireLoopSoundHandle = PlaySound( FireLoopSound, SLOT_WeaponFire1, TransientSoundVolume,,,,true);
	}

	if ( FireMode[0].IsA( 'FireUSStuart30cal' ) )
		FireUSStuart30cal( FireMode[0] ).StartFiringWeapon();

	if ( m_fZoomed )
		LoopAnim( 'Fire', 1.0, 0.0 );

	Super.StartFiringWeapon();

	bWeaponFiring = true;
}

//---------------------------------------------------------
//	StopFiringWeapon
//---------------------------------------------------------
function StopFiringWeapon()
{
	if ( FireMode[0].IsA( 'FireUSStuart30cal' ) )
		FireUSStuart30cal( FireMode[0] ).StopFiringWeapon();

	if ( !bWeaponFiring )
		return;

	if (FireLoopSoundHandle != 0)
	{
		StopSound( FireLoopSoundHandle );
		FireLoopSoundHandle = 0;
	}

	if ( m_fZoomed )
	{
		PlaySound( StereoFireOneBulletSound, SLOT_NONE, TransientSoundVolume,,,,false);
	}
	else
	{
		PlaySound( FireOneBulletSound, SLOT_WeaponFire1, TransientSoundVolume,,,,true);
	}

	if ( m_fZoomed )
		PlayAnim( 'Idle', 1.0 );

	Super.StopFiringWeapon();

	bWeaponFiring = false;
}

//---------------------------------------------------------
//	FlashMuzzleFlash
//---------------------------------------------------------
// For 3rd person only.  See PostRender() in this class for 1st person muzzle flashes.
simulated function FlashMuzzleFlash()
{
	local gbxMuzzleFlash MuzFlash;

	if ( MyGunner == None )
		return;

	if (bIsMounting || bIsDismounting)
		return;

	if ( FireMode[0].IsA( 'FireUSStuart30cal' ) )
	{
		MuzFlash = gbxMuzzleFlash( FireUSStuart30cal( FireMode[0] ).GetMuzzleFlash() );

		if ( m_fZoomed )
		{
			MuzFlash.bHidden = true;		// PostRender() will unhide it and render it.
			MuzFlash.Flash();
		}
		else
		{
			MuzFlash.SetLocation( GetMuzzleLocationWorld() );
			MuzFlash.SetRotation( Rotation );
			MuzFlash.Flash();
		}
	}
}

//---------------------------------------------------------
//	GetAttachment
//---------------------------------------------------------
function AttachmentUSStuart30cal GetAttachment()
{
	return AttachmentUSStuart30cal( ThirdPersonActor );
}

//---------------------------------------------------------
//	PostRender
//---------------------------------------------------------
function PostRender( Canvas TheCanvas )
{
	local gbxMuzzleFlash MuzFlash;

	if ( m_fZoomed )
	{		
		MuzFlash = gbxMuzzleFlash( FireUSStuart30cal( FireMode[0] ).GetMuzzleFlash() );
		if ( MuzFlash != None )
		{
			MuzFlash.bHidden = false;
			MuzFlash.SetLocation( GetMuzzleLocationWorld() );			
			MuzFlash.SetRotation( Rotation );			
			TheCanvas.DrawActor( MuzFlash, 50 );			
		}
		TheCanvas.DrawActor(self, DisplayFOV);		
		
		CalcOffsetWeaponCollision();
	}	
}

function bool AlwaysAutoReload()
{
	return true;
}

//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
	DrawType=DT_Mesh
	ItemName="US Stuart 30cal"

	GunBoneName="30cal"

	MyMountAction=Mount_MountTankStuart30cal
	MyDismountAction=Mount_DismountTankStuart30cal

	FireModeClass(0)=FireUSStuart30cal
	FireModeClass(1)=FireUSStuart30cal
	AttachmentClass=class'AttachmentUSStuart30cal'

	DefaultAmmoCount(0)=400

	// Nine-point blending animations.
	PawnForwardDownAnim="stuart_forward_down"
	PawnForwardLevelAnim="stuart_forward_level"
	PawnForwardUpAnim="stuart_forward_up"
	PawnLeftDownAnim="stuart_left_down"
	PawnLeftLevelAnim="stuart_left_level"
	PawnLeftUpAnim="stuart_left_up"
	PawnRightDownAnim="stuart_right_down"
	PawnRightLevelAnim="stuart_right_level"
	PawnRightUpAnim="stuart_right_up"

	FireLoopSoundName="W_30CAL.Loop"
	FireOneBulletSoundName="W_30CAL.End"
	StereoFireLoopSoundName="W_30CAL.LOOP_ST"
	StereoFireOneBulletSoundName="W_30CAL.END_ST"

	MaxRotSpeed=800.0

	GunnerOffset=(X=-92,Y=68,Z=80)
	GunnerOffsetStanding=(X=-88,Y=68,Z=120)

	MountAnimStartOffset=(X=-220.0,Y=142.0,Z=-40.0)

	CameraRearZoomTime=3.0
	CameraTurretZoomTime=1.0
	CameraTurretZoomHeadTime=1.4
	CameraRearStartOffset=(X=-200.0,Y=0.0,Z=300.0)
	CameraTurretStartOffset=(X=-40.0,Y=0.0,Z=0.0)
	CameraEndOffset=(X=-400,Y=0.0,Z=200.0)

	CameraOffsetZoomed=(X=-38.5,Y=0.1,Z=0.92)

	HorizCosTheta=0.5  // 40 degrees  //Bueno
	VertCosTheta=0.4067  // 66 degrees

	HorizFieldUU=7281
	VertFieldUU=4369
	ThirdPersonHorizFieldUU=12000
	ThirdPersonVertFieldUpUU=5461
	ThirdPersonVertFieldDownUU=5461
	CameraPitchUU=2000

	ClientState=WS_Hidden

	AmmoClipSize=400

	MuzzleOffset=(X=50,Y=0,Z=-10)
	MuzzleOffset3rdPerson=(X=110,Y=0,Z=0)
}
//=============================================================================
// WeapUSM1_
//=============================================================================
class WeapUSThompson extends WargameWeapon
    config(user);

simulated function LoadWeaponMesh()
{
	Mesh = Mesh( DynamicLoadObject( "k_view_weapons.view_thompson", class'Mesh' ) );
	m_NormalViewMesh = Mesh( DynamicLoadObject( "k_view_weapons.view_thompson", class'Mesh' ) );
	m_ZoomViewMesh = Mesh( DynamicLoadObject( "k_view_weapons.view_thompson_crosshair", class'Mesh' ) );
	LinkMesh( Mesh );
	Super.LoadWeaponMesh();
}

function byte BestMode()
{
	return 0;
}

defaultproperties
{
    ItemName="US M1A1 Sub-Machine Gun"

    FireModeClass(0)=FireUSThompson
    FireModeClass(1)=FireSecondaryItem
    FireModeClass(2)=FireMelee
    InventoryGroup=2
//	Mesh=Mesh'k_view_weapons.view_thompson'
//	m_NormalViewMesh=Mesh'k_view_weapons.view_thompson'
//	m_ZoomViewMesh=Mesh'k_view_weapons.view_thompson_crosshair'
	m_nCharacterBodyIdx=4
    BobDamping=0.5
    PickupClass=class'PickupWeapUSThompson'
    EffectOffset=(X=120.0,Y=20.0,Z=-18.0)
	DisplayFOV=+50.0
    AttachmentClass=class'AttachmentUSThompson'

    DrawScale=1.0
	PlayerViewOffset=(X=20.000,Y=0.000000,Z=-0.50000)
    SelectSound=None

	AIRating=+0.4
    CurrentRating=0.4

	// This icon no longer exists.
	//Icon=material'WG_HUD.HUD.wpn_garand'

//	m_aClipIcon=material'WG_HUD.HUD.clip_garand'
//	m_flBulletHeight=18
//	m_flClipHeight=128
//	m_flClipWidth=128
//	m_fClipFront=true
//	m_aFrontBulletIcon=material't_interface_mb.HUD.ammo_45cal'
//	m_aBackBulletIcon=material'WG_HUD.HUD.ammo_bullet_bck'
	m_nBulletIconTextureX=232
	m_nBulletIconTextureY=229
	m_nClipIconTextureX=206
	m_nClipIconTextureY=229

	m_eWeaponType=WeaponPrimary
	MyMeleeDamageType=class'DamageUSGunButtMelee'

	DefaultAmmoCount(0)=140

	ZoomInAnim=aim_up
	ZoomOutAnim=aim_down
	SelectAnim=deploy
	PutDownAnim=holster
	PutDownAnimQuick=holster_short
	IdleAnim(0)=idle_01
	IdleAnim(1)=idle_02
	IdleAnim(2)=idle_03

	WeaponBoneName=rifle_hold

	ZoomFovMod=17.0000

	m_flPauseTimeExposed=0.7

	AmmoClipSize=20

	m_flEncumberance=1.0
	m_fCanSprint=true
	m_bIsAutomatic=true

	Desirability=1.5

	BreatheProfileClass=class'gbxMediumBreatheProfile'
	
	nIconX=250
	nIconY=0
	nIconW=31
	nIconH=90

	WeaponName = WN_USThompson
	AmmoName = AM_US45Cal

	SelectAnimReadyDelay = 0.5
	PutDownAnimReadyDelay = 1.25
}
//=============================================================================
// WeapUSThompsonMud
//=============================================================================
class WeapUSThompsonMud extends WeapUSThompson
    config(user);

defaultproperties
{
    PickupClass=class'PickupWeapUSThompsonMud'
    AttachmentClass=class'AttachmentUSThompsonMud'
}
//=============================================================================
// US turret-mounted machine gun usable by players
//=============================================================================
class WeapUSUsableMachineGun extends TurretWeapon;

//---------------------------------------------------------
//	Variables / Constants
//---------------------------------------------------------
var gbxContextUseTrigger	MyRearTrigger;		// The context-use trigger used to get on/off this weapon.
var gbxContextUseTrigger	MyTurretTrigger;	// The context-use trigger used to get on/off this weapon.
var bool		bIsRearTrigger;				// keep track of which trigger was used (rear or turret)
var vector		BaseVector;
var vector		GunnerOffset;				// Used to position the gunner mesh.
var vector		GunnerOffsetStanding;

var vector		CameraRearStartOffset;		// relative to the mount point location
var vector		CameraTurretStartOffset;	// relative to the mount point location
var	vector		CameraSweepStartOffset;		// relative to the tank's Location
var float		CameraStartPitch;

var vector		CameraEndOffset;			// relative to the gunner's Location
var vector		CameraSweepEndOffset;		// relative to the tank's Location
var float		CameraEndPitch;

var float		CameraZoomTime;				// how long the camera takes to move from CameraSweepStartOffset to CameraSweepEndOffset
var float		CameraRearZoomTime;
var float		CameraTurretZoomTime;
var float		CameraTurretZoomHeadTime;
var bool		bCameraNeedsToPause;
var bool		bCameraIsPaused;
var float		CameraPausedTime;

var vector		CameraOffset;
var vector		CameraOffsetZoomed;
var bool		bIsMounting;
var bool		bIsDismounting;
var bool		bWeaponFiring;
var float		MountStartStamp;
var float		MaxRotSpeed;
var float		LastTimeSecs;
var gbxPawn		MyGunner;
var gbxPawn		MyTankPawn;

var vector	MountAnimStartOffset;
var vector	MuzzleOffset;
var vector	MuzzleOffset3rdPerson;

var float	CrossHairNextDrawTime, CrosshairDrawFreq;

var rotator	MyPreviousFacingRot;
var float	HorizCosTheta, VertCosTheta;
var rotator PreviousTankRotation;
var float	RotRate;
var float	LastDeltaTime;

var const int HorizFieldUU;
var const int VertFieldUU;
var const int ThirdPersonHorizFieldUU;
var const int ThirdPersonVertFieldUpUU;
var const int ThirdPersonVertFieldDownUU;
var const int CameraPitchUU;


// The names of the animations to use nine-point blending with
// when using this weapon.
var Name	PawnForwardDownAnim, PawnForwardLevelAnim, PawnForwardUpAnim,
			PawnLeftDownAnim, PawnLeftLevelAnim, PawnLeftUpAnim,
			PawnRightDownAnim, PawnRightLevelAnim, PawnRightUpAnim;

var name	TankForwardLevelAnim;
var name	TankIdleClosedAnim;

var name	GunBoneName;

enum VerticalFacing		{VF_Up, VF_Center, VF_Down};
enum HorizontalFacing	{HF_Left, HF_Center, HF_Right};

var AttachedPart ExtendedAttachment;  // attached skeletalmesh for the machine gun (so we can hide it in "iron sights" view)
var mesh ExtendedAttachmentMesh;

var bool	PreviousGodMode;
var bool	bMatchStarted;

const NINEPOINT_CHANNEL0 = 0;
const NINEPOINT_CHANNEL1 = 17;
const NINEPOINT_CHANNEL2 = 18;


//---------------------------------------------------------
//	PostNetBeginPlay
//---------------------------------------------------------
function PostNetBeginPlay()
{
	Super.PostNetBeginPlay();

	GiveAmmo(0);

	if ( ThirdPersonActor == None )
	{
		ThirdPersonActor = Spawn(AttachmentClass,Owner);		
		InventoryAttachment(ThirdPersonActor).InitFor(self);
	}

	if ( FireLoopSoundName != "" )
		FireLoopSound = Sound( DynamicLoadObject( FireLoopSoundName, class'Sound' ) );
	if ( FireOneBulletSoundName != "" )
		FireOneBulletSound = Sound( DynamicLoadObject( FireOneBulletSoundName, class'Sound' ) );
	if ( StereoFireLoopSoundName != "" )
		StereoFireLoopSound = Sound( DynamicLoadObject( StereoFireLoopSoundName, class'Sound' ) );
	if ( StereoFireOneBulletSoundName != "" )
		StereoFireOneBulletSound = Sound( DynamicLoadObject( StereoFireOneBulletSoundName, class'Sound' ) );
}

//---------------------------------------------------------
//	SetMount - used to hard attach this weapon to some other actor
//---------------------------------------------------------
function SetMount(gbxPawn NewMount)
{
	MyTankPawn = NewMount;
	SetBase(MyTankPawn);

	BaseVector = Vector( MyTankPawn.Rotation );
}

function SetExtendedAttachment(AttachedPart ExtAttach)
{
	ExtendedAttachment = ExtAttach;
	ExtendedAttachmentMesh = ExtAttach.Mesh;
}

function SetTriggers(gbxContextUseTrigger CtxRearUseTrigger, gbxContextUseTrigger CtxTurretUseTrigger)
{
	MyRearTrigger = CtxRearUseTrigger;
	MyTurretTrigger = CtxTurretUseTrigger;
}

function SetAnims(name ForwardLevelAnim, name IdleClosedAnim)
{
	TankForwardLevelAnim = ForwardLevelAnim;
	TankIdleClosedAnim = IdleClosedAnim;
}

function MatchStarting()
{
	bMatchStarted = true;
}

//---------------------------------------------------------
//	IsInUse
//---------------------------------------------------------
function bool IsInUse()
{
	// The gun is in use if it has a gunner.
	return (MyGunner != None);
}

//---------------------------------------------------------
//	GetBestBurstLength
//---------------------------------------------------------
function GetBestBurstLength( ESuppressionLevel SuppressionLevel, out float MinLen, out float MaxLen )
{
	FireMode[0].GetBestBurstLength( SuppressionLevel, MinLen, MaxLen );
}

//---------------------------------------------------------
//	Tick
//---------------------------------------------------------
function Tick( float DeltaTime )
{
	if (bIsDismounting && (FireMode[0] != None) && FireMode[0].bIsFiring)
		StopFiringWeapon();

	Super.Tick( DeltaTime );

	LastDeltaTime = DeltaTime;
}

function ActivateOracle()
{
	if ( ExtendedAttachment.Mesh == None )  // is the 3rd person weapon currently hidden?
	{
		m_fZoomed = false;
		ExtendedAttachment.Mesh = ExtendedAttachmentMesh;  // un-hide the weapon
	}
}

function int GetRotDiff(int A, int B)
{
	local int comp;

	comp = (A - B) & 65535;
	if (comp > 32768)
		comp -= 65536;

	return comp;
}

function rotator LerpRotator( rotator R1, rotator R2, int Delta)
{
	local int PitchDiff, YawDiff, RollDiff;
	local rotator OutRot;

	PitchDiff = GetRotDiff(R1.Pitch, R2.Pitch);
	if (PitchDiff > Delta)
		PitchDiff = Delta;
	else if (PitchDiff < -Delta)
		PitchDiff = -Delta;

	YawDiff = GetRotDiff(R1.Yaw, R2.Yaw);
	if (YawDiff > Delta)
		YawDiff = Delta;
	else if (YawDiff < -Delta)
		YawDiff = -Delta;

	RollDiff = GetRotDiff(R1.Roll, R2.Roll);
	if (RollDiff > Delta)
		RollDiff = Delta;
	else if (RollDiff < -Delta)
		RollDiff = -Delta;

	OutRot = R1;
	OutRot.Pitch = (OutRot.Pitch - PitchDiff) & 65535;
	OutRot.Yaw = (OutRot.Yaw - YawDiff) & 65535;
	OutRot.Roll = (OutRot.Roll - RollDiff) & 65535;

	return OutRot;
}

//---------------------------------------------------------
//	FaceRotation
//---------------------------------------------------------
// Make the turret weapon rotate to face a particular direction.
function FaceRotation( Rotator Rot )
{
	// OK, now the aim is to end up with two alpha values for
	// animation channels 1 and 2.  These channels, along with
	// base channel 0, will be blended to produce a smooth transitioning
	// of the gunner's pose as the user moves the mouse.
	//
	// Channel 0 plays the 'level-forward' gunning animation at all times.
	// Channel 1 plays an 'edge animation' (i.e. 'level-left', 'level-right',
	// 'up-forward', or 'down-forward').  Channel 2 plays a 'diagonal animation'
	// (i.e. 'up-left', 'up-right', 'down-left', or 'down-right').
	//
	// The blending occurs progressively; that is, the edge animation is
	// blended over the base animation first, and then the diagonal animation
	// is blended over that result in turn.
	//
	local Vector Aim, AimXY, AimXZ, D, V;
	local Float DotH, DotV, Alpha1, Alpha2, m;//, TempPitch, TempLastPitch;
	local HorizontalFacing HorizFace;
	local VerticalFacing VertFace;
	local NinePointDir DirDiag, DirEdge;
	local int PitchDiff, YawDiff;
	local Vector RotX, RotY, RotZ;

	// Sanity check.
	if (MyGunner == None)
	{
		log("Error: WeapUSUsableMachineGun Gunner is null!", 'ScriptWarning');
		return;
	}

	if (bMatchStarted)  // was a saved game reloaded?
	{
		bMatchStarted = false;

		MyGunner.PlayAnim( PawnForwardLevelAnim,,, NINEPOINT_CHANNEL0 );
	}

	MyGunner.SetRotation( MyTankPawn.Rotation );

	GetAxes(MyTankPawn.Rotation, RotX, RotY, RotZ);

	if ( !m_fZoomed )
	{
		Rot = LerpRotator( MyPreviousFacingRot, Rot, MaxRotSpeed );
	}

	MyPreviousFacingRot = Rot;

	// Restrict Yaw
	YawDiff = GetRotDiff(Rot.Yaw, MyTankPawn.Rotation.Yaw);
	if (YawDiff > HorizFieldUU)
		Rot.Yaw = (MyTankPawn.Rotation.Yaw + HorizFieldUU) & 65535;
	else if (YawDiff < -HorizFieldUU)
		Rot.Yaw = (MyTankPawn.Rotation.Yaw - HorizFieldUU) & 65535;

	// Restrict Pitch
	PitchDiff = GetRotDiff(Rot.Pitch, MyTankPawn.Rotation.Pitch);
	if (PitchDiff > VertFieldUU)
		Rot.Pitch = (MyTankPawn.Rotation.Pitch + VertFieldUU) & 65535;
	else if (PitchDiff < -VertFieldUU)
		Rot.Pitch = (MyTankPawn.Rotation.Pitch - VertFieldUU) & 65535;

	SetRotation(Rot);


	// Next, we'll calculate DotH and DotV again, only using the gun's actual
	// current orientation (due to the motion-delay placed on the gun, the
	// actual orientation may differ from the requested orientation.
	Aim = Vector(Rotation);
	AimXZ = Aim - ((Aim dot RotY) * RotY);
	AimXY = Aim - ((Aim dot RotZ) * RotZ);
	AimXZ = Normal(AimXZ);
	AimXY = Normal(AimXY);

	DotH = AimXY dot RotY;
	DotV = AimXZ dot RotZ;

	// Remap the dot-prods into the space -1.0 to 1.0.
	DotH /= HorizCosTheta;
	DotV /= VertCosTheta;

	DotH = FClamp( DotH, -1.0, 1.0 );
	DotV = FClamp( DotV, -1.0, 1.0 );

	// Determine what quadrant the aim vector is in.
	if (DotV < 0)
		VertFace = VF_Down;
	else
		VertFace = VF_Up;

	//if (DotH < 0)
	if (DotH > 0)
		HorizFace = HF_Right;
	 else
		HorizFace = HF_Left;


	// Absolute-value the dot prods so that we can simplify calculations below.
	DotH = abs(DotH);
	DotV = abs(DotV);

	// From the quadrant information, determine which two
	// diagonal and edge animations to use.
	if (VertFace == VF_Down) {
		if (HorizFace == HF_Left) {
			DirDiag = NPD_LowLeft;
			if (DotH >= DotV)
				DirEdge = NPD_MidLeft;
			else
				DirEdge = NPD_LowCenter;
		} else {
			DirDiag = NPD_LowRight;
			if (DotH >= DotV)
				DirEdge = NPD_MidRight;
			else
				DirEdge = NPD_LowCenter;
		}
	} else {	// VF_Up
		if (HorizFace == HF_Left) {
			DirDiag = NPD_UpLeft;
			if (DotH >= DotV)
				DirEdge = NPD_MidLeft;
			else
				DirEdge = NPD_UpCenter;
		} else {
			DirDiag = NPD_UpRight;
			if (DotH >= DotV)
				DirEdge = NPD_MidRight;
			else
				DirEdge = NPD_UpCenter;
		}
	}

	// Step 4: Figure the alpha blending values to use for the
	// two channels.  Point D is the point in 2D space that we found
	// above.  Point V is a point of intersection between the line thru
	// D and the nearest corner with the x- or the y-axis.
	//
	// Alpha1 is found by finding the distance from the origin to V.
	// Alpha2 is the distance between V and D.
	//
	// By absolute-valuing the dot prods above, we reduce the problem
	// to quadrant 1 (at this point, we have the two animations we need.
	// Except for knowing whether our edge-animation is horizontal or vertical,
	// quadrant information is no longer relevant.
	//
	D.X = DotH;	// 0.0 to 1.0, no negative values.
	D.Y = DotV;	// 0.0 to 1.0, no negative values.
	D.Z = 0;

	if (D.X == 1.0)	{	// Avoid divide-by-zero errors in the slope formula.
		Alpha1 = 1.0;
		Alpha2 = D.Y;
	} else {
		// m is the slope of the line through D and the corner (1,1).
		m = (1.0 - D.Y) / (1.0 - D.X);

		if (DirEdge == NPD_MidRight || DirEdge == NPD_MidLeft) {

			// The edge-animation is horizontal, so find x when
			// the line intercepts the x-axis (when y=0).
			Alpha1 = D.X - (D.Y / m);	// -b/m in intercept-slope formula.
			V.x = Alpha1;
			V.y = 0;
			V.z = 0;

		} else {	// Vertical edge (NPD_UpCenter or NPD_LowCenter).
			// The edge-animation is vertical, so find y when
			// the line intercepts the y-axis (when x=0).
			Alpha1 = D.Y - (m * D.X);	// 'b' in intercept-slope formula.
			V.x = 0;
			V.y = Alpha1;
			V.z = 0;
		}

		// Alpha2 is the proportion of the length of vector D - V
		// to that of vector (1,1) - V.  The equation used below
		// is the optimized form of the one in comments.
		Alpha2 = VSize(D - V) / (1.41421 - 0.41421 * Alpha1);	// 0.41421 == sqrt(2)
		//Alpha2 = VSize(D - V) / VSize(Vect(1,1,0) - V);		// Keep this for reference.
	}

	// Play the gunning animations, supplying the edge-animation,
	// the diagonal-animation, and their blending factors.
	MyGunner.DoNinePointBlending( DirEdge, Alpha1, DirDiag, Alpha2 );
	MyTankPawn.DoNinePointBlending( DirEdge, Alpha1, DirDiag, Alpha2 );
}


function vector GetPlayerMountPoint(gbxPawn gbxP)
{
	Log(name $ ".GetMountPoint() - YOU FORGOT TO OVERRIDE THIS FUNCTION!!!");
	return vect(0,0,0);
}

//---------------------------------------------------------
//	PreparePawnToMount
//---------------------------------------------------------
function PreparePawnToMount(gbxPawn gbxP)
{
	local vector RotX, RotY, RotZ;
	local vector MountPoint;
	local vector v1, v2;
	local vector TankPawnLocation;

	gbxP.bDontFrustumCull = true;  // need to do this when tank is at steep angles otherwise player mesh gets culled out while climb anim is playing

	gbxP.bBlockZeroExtentTraces = false;
	if (gbxP.Controller != None)
	{
		PreviousGodMode = gbxP.Controller.bGodMode;  // save this so we can restore it later
		gbxP.Controller.bGodMode = true;
		gbxPlayerController( gbxP.Controller ).EnableHeavyTrauma( false );
	}

	gbxP.ResetRootRotation();  // don't twist the Pawn's lower body

	gbxP.SetCollision(false, false, false);  // jlb-hack for collision during pawn placement for mount animation
	gbxP.bCollideWorld = false;  // you HAVE to do this in case the tank is on a sleeply sloped terrain (terrain higher at right side of tank)

	MountPoint = GetPlayerMountPoint( gbxP );

	gbxP.SetLocation( MountPoint );
	gbxP.SetPhysics(PHYS_None);  // this MUST happen after the SetLocation call since it can change to PHYS_Falling

	gbxP.SetRotation( MyTankPawn.Rotation );
	gbxP.Controller.SetRotation( MyTankPawn.Rotation );

	// hard attach player pawn to tank so that animation plays properly if tank is moving...
	gbxP.bHardAttach = true;
	gbxP.SetBase(MyTankPawn);

	gbxP.PrepareToMount();

	GetAxes(MyTankPawn.Rotation, RotX, RotY, RotZ);

	TankPawnLocation = MyTankPawn.GetBoneCoords('chassis').origin;

	MyTankPawn.bFriendlyFireListen = false;

	if (bIsRearTrigger)
	{
		CameraZoomTime = CameraRearZoomTime;
		CameraSweepStartOffset = MountPoint +
							(CameraRearStartOffset.X * RotX + CameraRearStartOffset.Y * RotY + CameraRearStartOffset.Z * RotZ) -
							TankPawnLocation;
		// convert the offset vector from world space to local space (relative to the tank's location)
		CameraSweepStartOffset = CameraSweepStartOffset << MyTankPawn.Rotation;
	}
	else
	{
		CameraZoomTime = CameraTurretZoomTime;
		CameraSweepStartOffset = MountPoint +
							(CameraTurretStartOffset.X * RotX + CameraTurretStartOffset.Y * RotY + CameraTurretStartOffset.Z * RotZ) -
							TankPawnLocation;
		// convert the offset vector from world space to local space (relative to the tank's location)
		CameraSweepStartOffset = CameraSweepStartOffset << MyTankPawn.Rotation;
		CameraSweepStartOffset = CameraSweepStartOffset + vect(0,0,79);  // offset by eye height
	}

	v1 = TankPawnLocation + (GunnerOffset.X * RotX + GunnerOffset.Y * RotY + GunnerOffset.Z * RotZ);
	CameraSweepEndOffset = v1 + (CameraEndOffset.X * RotX + CameraEndOffset.Y * RotY + CameraEndOffset.Z * RotZ) - TankPawnLocation;
	CameraSweepEndOffset = CameraSweepEndOffset << MyTankPawn.Rotation;

	v1 = TankPawnLocation + (CameraSweepStartOffset.X * RotX + CameraSweepStartOffset.Y * RotY + CameraSweepStartOffset.Z * RotZ);
	v2 = MountPoint + vect(0,0,79);  // offset by eye height
	CameraStartPitch = rotator(v2 - v1).Pitch;

	CameraEndPitch = -CameraPitchUU;

	bIsMounting = true;

	bCameraIsPaused = false;
	bCameraNeedsToPause = false;

	MyGunner = gbxP;
}


//---------------------------------------------------------
//	CompleteMount
//---------------------------------------------------------
function CompleteMount( gbxPawn gbxP )
{
	local int Mode;
	local Vector RotX, RotY, RotZ;
	local int count;
	local vector NewLoc, OffsetVec;
	local bool result;
	local vector TankPawnLocation;

	MyTankPawn.CompleteMount();

	Instigator = MyGunner;
	if ( Ammo[0] != None )
		Ammo[0].Instigator = MyGunner;
	if ( FireMode[0] != None )
		FireMode[0].Instigator = Instigator;
	if ( ThirdPersonActor != None )
		ThirdPersonActor.Instigator = Instigator;

	gbxP.bDontFrustumCull = false;  // shouldn't need this anymore now that player is completely on tank

	gbxP.SetNinePointAnimations(
		PawnForwardDownAnim, PawnForwardLevelAnim, PawnForwardUpAnim,
		PawnLeftDownAnim, PawnLeftLevelAnim, PawnLeftUpAnim,
		PawnRightDownAnim, PawnRightLevelAnim, PawnRightUpAnim);

	// skeletalmesh will be stuck in last frame of mounting animation, play 0 frames of "idle" animation before blending begins...
	gbxP.PlayAnim( PawnForwardLevelAnim,,, NINEPOINT_CHANNEL0 );

	gbxP.Acceleration = vect(0,0,0);
	gbxP.Velocity = vect(0,0,0);
	gbxP.bRotateToDesired = false;
	gbxP.DesiredRotation = MyTankPawn.Rotation;

	gbxP.bBlockZeroExtentTraces = true;
	if (gbxP.Controller != None)
	{
		gbxP.Controller.bGodMode = PreviousGodMode;
		gbxPlayerController( gbxP.Controller ).EnableHeavyTrauma( true );
	}

	TankPawnLocation = MyTankPawn.GetBoneCoords('chassis').origin;

	gbxP.bHardAttach = false;
	gbxP.SetBase(None);

	// have to do this because Pawn.Physics == PHYS_None and APawn::performPhysics() won't run
	gbxP.ForceCrouch();

	// player HAS to collide here or they can't use the trigger to get off of the gun...
	gbxP.SetCollision(true, true, true);
	gbxP.bCollideWorld = true;

	MyGunner.SetRotation( MyTankPawn.Rotation );
	MyGunner.Controller.SetRotation( MyTankPawn.Rotation );

	GetAxes(MyTankPawn.Rotation, RotX, RotY, RotZ);

	// if the tank is not Karma simulating, wake it up (this MUST be done otherwise the SetLocation test below
	// will use the Collision Cylinder of the tank and the player will collide when placing)...
	if (MyTankPawn.Physics != PHYS_Karma)
	{
		MyTankPawn.SetPhysics(PHYS_Karma);
		MyTankPawn.KWake();  // wake it up

		gbxSVehicle(MyTankPawn).KarmaSleepTime = Level.TimeSeconds + 1.0f;
	}

	count = 0;
	NewLoc = TankPawnLocation + (GunnerOffset.X * RotX + GunnerOffset.Y * RotY + GunnerOffset.Z * RotZ);
	OffsetVec = vect(0,0,1) - RotX;  // up and back
	result = gbxP.SetLocation(NewLoc);
	while ((!result) && (count < 20))
	{
		// keep pushing the player up and out slightly until they don't collide!!!
		count++;
		NewLoc = NewLoc + OffsetVec;
		result = gbxP.SetLocation(NewLoc);
	}

	gbxP.SetPhysics(PHYS_None);

	gbxP.bHardAttach = true;
	gbxP.SetBase(MyTankPawn);

	gbxP.bInterpolating = false;  // allow the player to rotate the camera again

	SetRotation(MyTankPawn.Rotation);

	MyPreviousFacingRot = MyTankPawn.Rotation;

	// make sure the gun is facing the same direction as the player's controller...
	FaceRotation( gbxP.Controller.Rotation );

	PreviousTankRotation = MyTankPawn.Rotation;

	bIsMounting = false;

	for( Mode = 0; Mode < NUM_FIRE_MODES; Mode++ )
	{
		if (FireMode[Mode] != None)
		{
//				FireMode[Mode].InitEffects();
			FireMode[Mode].GetMuzzleFlash();
		}
	}

	MyTankPawn.PlayAnim(TankForwardLevelAnim);

	if (gbxPlayerController(gbxP.Controller) != None)
		gbxPlayerController(gbxP.Controller).bDisableCrosshair = false;

	gbxP.SetWeapon( Self );

	// gbxWeapon AnimEnd transitions ClientState from WS_BringUp to WS_ReadyToFire, since this weapon has no deploy animation, we set WS_ReadyToFire ourselves.
	ClientState = WS_ReadyToFire;

	bAimingAtFriendly = false;
}

//---------------------------------------------------------
//	MountFailed
//---------------------------------------------------------
function MountFailed( gbxPawn gbxP )
{
	bIsMounting = false;
	gbxP.bHardAttach = false;
	gbxP.SetBase( None );
	gbxP.SetPhysics(PHYS_Walking);
	gbxP.SetCollision(true, true, true);
	gbxP.bCollideWorld = true;
	gbxP.bInterpolating = false;
	gbxP.bBlockZeroExtentTraces = true;	

	if (gbxP.Controller != None)
	{
		gbxP.Controller.bGodMode = PreviousGodMode;
		gbxPlayerController( gbxP.Controller ).EnableHeavyTrauma( true );
	}

	MyGunner = None;

	MyTankPawn.bFriendlyFireListen = true;

	if (gbxPlayerController(gbxP.Controller) != None)
		gbxPlayerController(gbxP.Controller).bDisableCrosshair = false;

	// Reactivate the trigger.
	MyRearTrigger.bDontDisplayMessage = false;
	MyTurretTrigger.bDontDisplayMessage = false;
}

//---------------------------------------------------------
//	PreparePawnToDismount
//---------------------------------------------------------
function PreparePawnToDismount( gbxPawn gbxP )
{
	local vector RotX, RotY, RotZ;
	local vector MountPoint;
	local vector v1, v2;
	local vector TankPawnLocation;

	// Check that the pawn passed in is the gunner.
	if (gbxP != MyGunner)
		return;

	StopFiringWeapon();

	gbxP.bHardAttach = false;
	gbxP.SetBase(None);

	SetRotation(Rot(0,0,0));

	if (gbxP.bUseRootMotion)
		gbxP.SetPhysics(PHYS_RootMotion);
	else
		gbxP.SetPhysics(PHYS_Walking);

	GetAxes(MyTankPawn.Rotation, RotX, RotY, RotZ);

	TankPawnLocation = MyTankPawn.GetBoneCoords('chassis').origin;

	MountPoint = TankPawnLocation + (GunnerOffsetStanding.X * RotX + GunnerOffsetStanding.Y * RotY + GunnerOffsetStanding.Z * RotZ);

	CameraZoomTime = CameraTurretZoomHeadTime;

	CameraSweepEndOffset = MountPoint +
							(CameraTurretStartOffset.X * RotX + CameraTurretStartOffset.Y * RotY + CameraTurretStartOffset.Z * RotZ) -
							TankPawnLocation;
	// convert the offset vector from world space to local space (relative to the tank's location)
	CameraSweepEndOffset = CameraSweepEndOffset << MyTankPawn.Rotation;
	CameraSweepEndOffset = CameraSweepEndOffset + vect(0,0,79);  // offset by eye height

	v1 = TankPawnLocation + (GunnerOffset.X * RotX + GunnerOffset.Y * RotY + GunnerOffset.Z * RotZ);
	CameraSweepStartOffset = v1 + (CameraEndOffset.X * RotX + CameraEndOffset.Y * RotY + CameraEndOffset.Z * RotZ) - TankPawnLocation;
	CameraSweepStartOffset = CameraSweepStartOffset << MyTankPawn.Rotation;

	v1 = TankPawnLocation + (CameraSweepEndOffset.X * RotX + CameraSweepEndOffset.Y * RotY + CameraSweepEndOffset.Z * RotZ);
	v2 = MountPoint + vect(0,0,79);  // offset by eye height
	CameraEndPitch = rotator(v2 - v1).Pitch;

	CameraStartPitch = -CameraPitchUU;

	SetFirstPersonZoom( false );

	gbxP.AnimBlendParams( NINEPOINT_CHANNEL1, 0.0, 0, 0 );
	gbxP.AnimBlendParams( NINEPOINT_CHANNEL2, 0.0, 0, 0 );
	gbxP.PlayWaiting();
	gbxP.PlayMoving();

	bIsDismounting = true;
}

//---------------------------------------------------------
//	CompleteDismount
//---------------------------------------------------------
function CompleteDismount( gbxPawn gbxP )
{
	if ( gbxP == MyGunner )
	{
		Instigator = None;
		Ammo[0].Instigator = None;
		FireMode[0].Instigator = None;

		MyGunner = None;
		bIsDismounting = false;
		CameraOffset.X = 0.0;
		CameraOffset.Z = 0.0;

		gbxP.SetRotation( MyTankPawn.Rotation );
		gbxP.Controller.SetRotation( MyTankPawn.Rotation );

		// Reactivate my trigger, which was made inactive when used.
		MyRearTrigger.bDontDisplayMessage = false;
		MyTurretTrigger.bDontDisplayMessage = false;

		MyTankPawn.bFriendlyFireListen = true;

		MyTankPawn.AnimBlendParams( NINEPOINT_CHANNEL1, 0.0, 0, 0 );
		MyTankPawn.AnimBlendParams( NINEPOINT_CHANNEL2, 0.0, 0, 0 );
		MyTankPawn.PlayAnim(TankIdleClosedAnim);

		gbxP.Weapon = None;  // hack so SetWeapon() will call ChangedWeapon() - jlb
		gbxP.SetWeapon( gbxP.LastWeapon );
	}
}

//---------------------------------------------------------
//	GunnerDied
//---------------------------------------------------------
function GunnerDied( gbxPawn gbxP )
{
	if ( gbxP == MyGunner )
	{
		SetRotation(Rot(0,0,0));

		MyGunner.bCollideWorld = true;
//		MyGunner.SetLocation( GetMyMountPoint() );

		MyGunner = None;

		// Reactivate my trigger, which was made inactive when used.
		MyRearTrigger.bDontDisplayMessage = false;
		MyTurretTrigger.bDontDisplayMessage = false;
	}
}


//---------------------------------------------------------
//	IsFacingRightDirection
//---------------------------------------------------------
function bool IsFacingRightDirection( gbxPawn gbxP )
{
	local Rotator RotToWeapon;
	local int YawDiff;
	local bool bResult;

	RotToWeapon = Rotator(Location-gbxP.Location);

	RotToWeapon.Yaw = RotToWeapon.Yaw & 65535;

	YawDiff = abs(RotToWeapon.Yaw - (gbxP.Rotation.Yaw & 65535) );

	if (YawDiff >= 32767)
	{
		YawDiff = (65536 - YawDiff);
	}

	bResult = (YawDiff < 100);

	return bResult;
}


//---------------------------------------------------------
//	Trigger
//---------------------------------------------------------
event Trigger(Actor Other, Pawn EventInstigator)
{
	local gbxPawn gbxP;

	gbxP = gbxPawn( EventInstigator );

	// Skip the action instigator is in the middle of a reload.
	if ( gbxP.IsTransitioning() || (gbxP.Weapon != Self && gbxP.Weapon.IsReloading() ) )
		return;

	if (Other == MyRearTrigger)
		bIsRearTrigger = true;
	else
		bIsRearTrigger = false;

	if ( MyGunner == gbxP )	// Gunner wishes to dismount.
	{
		MyGunner.DismountTurretPlayer(false);
		MountStartStamp=Level.TimeSeconds;
	}
	else if ( MyGunner == None )  // Gunner wishes to mount.
	{
		MyRearTrigger.bDontDisplayMessage = true;
		MyTurretTrigger.bDontDisplayMessage = true;

		// special case if player manages to jump on top of the tank while the commander is still out
		// (level designers should not allow this, but what the heck)...
		if ( !bIsRearTrigger && !MyTankPawn.IsTankCommanderButtonedUp() )
		{
			MyTankPawn.MakeTankCommanderGoInQuick();
		}
		else
		{
			MyTankPawn.PrepareToMount();
		}

		if ( gbxP.Controller.bIsHumanPlayer )
		{
			if (gbxP.Weapon != None)
			{
				if (gbxP.Weapon.ThirdPersonActor != None)
					gbxP.Weapon.ThirdPersonActor.bHidden = true;  // hide the weapon quickly
			}

			if (gbxPlayerController(gbxP.Controller) != None)
				gbxPlayerController(gbxP.Controller).bDisableCrosshair = true;  // temporarily turn crosshair off

			PreparePawnToMount( gbxP );

			gbxP.MountTurretPlayer( Self, false );

			MountStartStamp=Level.TimeSeconds;
		}
	}
}

function ConsumeAmmo(int Mode, float load)
{
}

simulated event RenderOverlays( Canvas Canvas )
{
}

simulated function DrawCrossHair( canvas Canvas )
{
	local float XLength, YLength;
	local PlayerController PlayerOwner;
	local vector HitLoc, HitNorm;
	local Actor HitActor;
	local HUD	Hud;

	if ( m_fZoomed )
		return;

	if (bIsMounting || bIsDismounting )
		return;

	if (( Level.NetMode == NM_StandAlone ) && (Level.DifficultyLevel == DIFF_Authentic))
	{
		return;
	}
	
	if ( Instigator != None && Instigator.IsHumanControlled() )
	{
		PlayerOwner = PlayerController(Instigator.Controller);
			
		if ( PlayerOwner.DisableCrosshair() )
			return;	

		if ( PlayerOwner.iCrossHairIndex == 0)
			return;

		Hud = PlayerOwner.MyHud;

		if (Hud == None)
		{
			XLength = 32;
			YLength = 32;
		}
		else
		{
			XLength = 32 * Hud.flMinScaleX;
			YLength = 32 * Hud.flMinScaleY;
		}

		if ( Level.TimeSeconds >= CrosshairNextDrawTime )
		{
			HitActor = Trace( HitLoc, HitNorm, Location + 15000 * Vector( Rotation ), Location, false );
			
			if ( HitActor != None )
			{
				Canvas.Style = ERenderStyle.STY_Additive;
				Canvas.SetDrawColor(255,255,255,96);
				Canvas.DrawTile3D( m_TestCrosshairs[PlayerOwner.iCrossHairIndex - 1], HitLoc, XLength, YLength, 0, 0, m_TestCrosshairs[PlayerOwner.iCrossHairIndex - 1].USize, m_TestCrosshairs[PlayerOwner.iCrossHairIndex - 1].VSize);
			}

			CrossHairNextDrawTime = Level.TimeSeconds + CrosshairDrawFreq;
		}
	}		
}

simulated function DrawHud(canvas Canvas, gbxHud Hud, FontInfo Fonts, int nPass)
{
}

//---------------------------------------------------------
//	AnimEnd
//---------------------------------------------------------
simulated function AnimEnd(int channel)
{
	if ( m_fZoomed )
	{
		if ( bWeaponFiring )
		{
			//PlayAnim( 'Fire', 1.0 );
		}			
		else
		{
			PlayAnim( 'Idle', 1.0 );
		}
	}
	else
		Super.AnimEnd( channel );
}

//---------------------------------------------------------
//	Fire
//---------------------------------------------------------
simulated function Fire(float F)
{
	if( bIsDismounting )
		return;

	StartFiringWeapon();

	Super.Fire(F);	
}

//---------------------------------------------------------
//	PlayFiringAnim
//---------------------------------------------------------
simulated function PlayFiringAnim()
{
	// Deprecate. 
}

//---------------------------------------------------------
//	SetFirstPersonZoom
//---------------------------------------------------------
function SetFirstPersonZoom( bool bZoomed )
{
	local PlayerController PC;

	// don't change zoom settings if currently in OracleCam (SA View) mode...
	if( Level.Game.bOracleCamActive )
		return;

	m_fZoomed = bZoomed;

	if ( MyGunner == None || !MyGunner.IsA( 'gbxPlayerPawn' ) )
		return;

	if ( bZoomed )
	{
		ExtendedAttachment.Mesh = None;

		PC = PlayerController( MyGunner.Controller );
		PC.DesiredFOV = DisplayFOV;
	}
	else
	{
		ExtendedAttachment.Mesh = ExtendedAttachmentMesh;

		PC = PlayerController( MyGunner.Controller );
		PC.DesiredFOV = PC.DefaultFOV;
	}
}

//---------------------------------------------------------
//	CalcThirdPersonView
//---------------------------------------------------------
function CalcThirdPersonView( gbxPawn thePawn, out actor ViewActor, out vector CameraLocation, out rotator CameraRotation )
{
	local Vector RotX, RotY, RotZ;
	local Rotator ControllerRot;
	local int PitchDiff;
	local float T;
	local vector TankRotX, TankRotY, TankRotZ;
	local vector v1, v2;
	local vector TankPawnLocation;
	local rotator RotDelta;

	ViewActor = thePawn;

	GetAxes( MyTankPawn.Rotation, TankRotX, TankRotY, TankRotZ );

	TankPawnLocation = MyTankPawn.GetBoneCoords('chassis').origin;

	if ( bIsMounting || bIsDismounting )
	{
		// Player is mounting turret.  Zoom out.
		if (bCameraIsPaused)
			T = FClamp( ( CameraPausedTime - MountStartStamp ) / CameraZoomTime, 0.0, 1.0 );
		else
			T = FClamp( ( Level.TimeSeconds - MountStartStamp ) / CameraZoomTime, 0.0, 1.0 );

		v1 = TankPawnLocation + (CameraSweepStartOffset.X * TankRotX + CameraSweepStartOffset.Y * TankRotY + CameraSweepStartOffset.Z * TankRotZ);
		v2 = TankPawnLocation + (CameraSweepEndOffset.X * TankRotX + CameraSweepEndOffset.Y * TankRotY + CameraSweepEndOffset.Z * TankRotZ);
		CameraLocation = v1 + T*(v2 - v1);

		CameraRotation.Pitch = (CameraStartPitch + T*(CameraEndPitch - CameraStartPitch)) & 65535;
		CameraRotation.Yaw = MyTankPawn.Rotation.Yaw;

		if (bCameraNeedsToPause)
		{
			bCameraIsPaused = true;
			bCameraNeedsToPause = false;

			CameraPausedTime = Level.TimeSeconds;
		}
	}
	else
	{
		CameraOffset = CameraEndOffset;
	}

	// Restrict the yaw and pitch of the player's controller...
	if ( MyGunner != None )
	{
		RotDelta = PreviousTankRotation - MyTankPawn.Rotation;  // delta is negative change since previous frame

		ControllerRot = MyGunner.Controller.Rotation;
		ControllerRot.Pitch = (ControllerRot.Pitch + RotDelta.Pitch) & 65535;
		ControllerRot.Yaw = (ControllerRot.Yaw + RotDelta.Yaw) & 65535;
		ControllerRot.Roll = 0;  // always reset the roll to 0 to make the iron sights view "level"

		PreviousTankRotation = MyTankPawn.Rotation;

/*
		// Restrict Yaw
		YawDiff = GetRotDiff(ControllerRot.Yaw, MyTankPawn.Rotation.Yaw);
		if (YawDiff > ThirdPersonHorizFieldUU)
			ControllerRot.Yaw = (MyTankPawn.Rotation.Yaw + ThirdPersonHorizFieldUU) & 65535;
		else if (YawDiff < -ThirdPersonHorizFieldUU)
			ControllerRot.Yaw = (MyTankPawn.Rotation.Yaw - ThirdPersonHorizFieldUU) & 65535;
*/

		// Restrict Pitch
		PitchDiff = GetRotDiff(ControllerRot.Pitch, MyTankPawn.Rotation.Pitch);
		if (PitchDiff > ThirdPersonVertFieldUpUU)
			ControllerRot.Pitch = (MyTankPawn.Rotation.Pitch + ThirdPersonVertFieldUpUU) & 65535;
		else if (PitchDiff < -ThirdPersonVertFieldDownUU)
			ControllerRot.Pitch = (MyTankPawn.Rotation.Pitch - ThirdPersonVertFieldDownUU) & 65535;

		MyGunner.Controller.SetRotation( ControllerRot );

		if ( !bIsMounting && !bIsDismounting )
		{
			CameraRotation = ControllerRot;

			GetAxes( CameraRotation, RotX, RotY, RotZ );
			CameraLocation = thePawn.Location + (CameraOffset.X * RotX + CameraOffset.Y * RotY + CameraOffset.Z * RotZ);

			CameraRotation.Pitch -= CameraPitchUU;
		}
	}
}

//---------------------------------------------------------
//	CalcFirstPersonView
//---------------------------------------------------------
function CalcFirstPersonView( gbxPawn thePawn, out actor ViewActor, out vector CameraLocation, out rotator CameraRotation )
{
	local Vector RotX, RotY, RotZ;
	local Rotator ControllerRot;
	local int PitchDiff, YawDiff;
	local rotator RotDelta;

	ViewActor = Self;

	CameraOffset.X = CameraOffsetZoomed.X;
	CameraOffset.Z = CameraOffsetZoomed.Z;

	GetAxes( Self.Rotation, RotX, RotY, RotZ );
	CameraLocation = Self.Location + (CameraOffset.X*RotX + CameraOffset.Z*RotZ);

	// Restrict the yaw to the cone of fire.
	if ( MyGunner != None )
	{
		RotDelta = PreviousTankRotation - MyTankPawn.Rotation;  // delta is negative change since previous frame

		ControllerRot = MyGunner.Controller.Rotation;
		ControllerRot.Pitch = (ControllerRot.Pitch + RotDelta.Pitch) & 65535;
		ControllerRot.Yaw = (ControllerRot.Yaw + RotDelta.Yaw) & 65535;
		ControllerRot.Roll = 0;  // always reset the roll to 0 to make the iron sights view "level"

		PreviousTankRotation = MyTankPawn.Rotation;

		// Yaw.
		YawDiff = GetRotDiff(ControllerRot.Yaw, MyTankPawn.Rotation.Yaw);
		if (YawDiff > HorizFieldUU)
			ControllerRot.Yaw = (MyTankPawn.Rotation.Yaw + HorizFieldUU) & 65535;
		else if (YawDiff < -HorizFieldUU)
			ControllerRot.Yaw = (MyTankPawn.Rotation.Yaw - HorizFieldUU) & 65535;

		// Pitch.
		PitchDiff = GetRotDiff(ControllerRot.Pitch, MyTankPawn.Rotation.Pitch);
		if (PitchDiff > VertFieldUU)
			ControllerRot.Pitch = (MyTankPawn.Rotation.Pitch + VertFieldUU) & 65535;
		else if (PitchDiff < -VertFieldUU)
			ControllerRot.Pitch = (MyTankPawn.Rotation.Pitch - VertFieldUU) & 65535;

		CameraRotation = ControllerRot;

		MyGunner.Controller.SetRotation( ControllerRot );

		MyPreviousFacingRot = ControllerRot;
	}
}

//---------------------------------------------------------
//	SpecialCalcView
//---------------------------------------------------------
simulated function SpecialCalcView( gbxPawn thePawn, out actor ViewActor, out vector CameraLocation, out rotator CameraRotation )
{
	if ( m_fZoomed )
		CalcFirstPersonView( thePawn, ViewActor, CameraLocation, CameraRotation );
	else
		CalcThirdPersonView( thePawn, ViewActor, CameraLocation, CameraRotation );
}

//---------------------------------------------------------
//	GetFireRotation
//---------------------------------------------------------
function Rotator GetFireRotation()
{
	return Rotation;
}

simulated function Vector GetMuzzleLocationWorld()
{
	local rotator r_temp;
	local vector RotX, RotY, RotZ;
	local vector BoneLoc;

	if ( !m_fZoomed )
	{
		r_temp = GetFireRotation();
		GetAxes(r_temp, RotX, RotY, RotZ);
		BoneLoc = MyTankPawn.GetBoneCoords(GunBoneName).origin;
		return BoneLoc + (MuzzleOffset3rdPerson.X * RotX) + (MuzzleOffset3rdPerson.Y * RotY) + (MuzzleOffset3rdPerson.Z * RotZ);
	}
	else
	{
		GetAxes(Rotation, RotX, RotY, RotZ);
		return Location + (MuzzleOffset.X * RotX) + (MuzzleOffset.Y * RotY) + (MuzzleOffset.Z * RotZ);
	}
}

//---------------------------------------------------------
//	ClientStartFire
//---------------------------------------------------------
// Needed to override this because Owner is different for this weapon than most other weapons.
simulated event ClientStartFire(int Mode)
{
    if (!MyGunner.Controller.CanFire() || bIsDismounting )
        return;

	if (bAimingAtFriendly && Instigator.IsA('gbxPawn'))
	{
		bFiringAtFriendly = true;
	}

    if (Role < ROLE_Authority)
    {
        if (StartFire(Mode))
        {
            ServerStartFire(Mode);
        }
    }
    else
    {
        StartFire(Mode);
    }
}

//---------------------------------------------------------
//	AdjustAimNew
//---------------------------------------------------------
// Used only with player pawns; AI pawns use the AdjustAimNew() in FiringController.
function Rotator AdjustAimNew( Ammunition Ammo, Vector ProjStart, Rotator AimRotator, int WeaponAimError )
{
	local float FinalErrorMax;

	FinalErrorMax = WeaponAimError;

	// Yaw.
	if ( Rand(2) == 0 )
		AimRotator.Yaw += FRand() * FinalErrorMax;
	else
		AimRotator.Yaw -= FRand() * FinalErrorMax;

	// Pitch
	if ( Rand(2) == 0 )
		AimRotator.Pitch += FRand() * FinalErrorMax;
	else
		AimRotator.Pitch -= FRand() * FinalErrorMax;

	return AimRotator;
}

//---------------------------------------------------------
//	CanSpawnShellCasing
//---------------------------------------------------------
function bool CanSpawnShellCasing()
{
	return ( MyGunner.IsHumanControlled() && !m_fZoomed );
}


//---------------------------------------------------------
//	PlayZoomIn
//---------------------------------------------------------
simulated function PlayZoomIn()
{
	SetFirstPersonZoom( true );
}

//---------------------------------------------------------
//	PlayZoomOut
//---------------------------------------------------------
simulated function PlayZoomOut()
{
	SetFirstPersonZoom( false );
}

//---------------------------------------------------------
//	IsZoomed
//---------------------------------------------------------
event bool IsZoomed()
{
	return m_fZoomed;
}

//---------------------------------------------------------
//	CanZoom
//---------------------------------------------------------
simulated function bool CanZoom()
{
	return true;
}

//---------------------------------------------------------
//	GetBaseVector
//---------------------------------------------------------
function Vector GetBaseVector()
{
	return BaseVector;
}

//---------------------------------------------------------
//	NotifyForceDismount
//---------------------------------------------------------
function NotifyForceDismount( optional bool bDoNothingIfHumanControlled )
{
	if (MyGunner == None)
		return;

	if ( MyGunner.Controller.IsA( 'gbxAIController' ) )
	{
		gbxAIController( MyGunner.Controller ).BreakOutJustMe();
	}
	else if ( MyGunner.Controller.bIsHumanPlayer && !bDoNothingIfHumanControlled )
	{
		MyGunner.DismountTurretPlayer(false);
	}
}


//=========================================================
//	Default Properties
//=========================================================
defaultproperties
{
	bHidden=true
	DisplayFOV=+35.0
	bAcceptsProjectors=false
	DrawScale=1.0

	BreatheProfileClass=class'gbxSupportedBreatheProfile'

	bMatchStarted=false;

	RotRate=16384  // in Unreal rotators per second

	CrosshairDrawFreq=0.01
}